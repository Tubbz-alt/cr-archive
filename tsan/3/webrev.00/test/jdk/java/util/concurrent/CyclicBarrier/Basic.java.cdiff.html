<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/java/util/concurrent/CyclicBarrier/Basic.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../CountDownLatch/Basic.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../Executors/PrivilegedCallables.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/CyclicBarrier/Basic.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 35,10 ***</span>
<span class="line-new-header">--- 35,11 ---</span>
  import java.util.Iterator;
  import java.util.List;
  import java.util.concurrent.BrokenBarrierException;
  import java.util.concurrent.CountDownLatch;
  import java.util.concurrent.CyclicBarrier;
<span class="line-added">+ import java.util.concurrent.ThreadLocalRandom;</span>
  import java.util.concurrent.TimeoutException;
  import java.util.concurrent.atomic.AtomicInteger;
  import jdk.test.lib.Utils;
  
  public class Basic {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 291,41 ***</span>
  
      /**
       * Handling of extra interrupts while waiting - tests for bug 6366811
       */
      private static void testInterrupts() {
<span class="line-modified">!         final int N = 10;</span>
          final CyclicBarrier startingGate = new CyclicBarrier(N+1);
  
          /**
           * A version of Awaiter that also records interrupted state.
           */
          class Waiter extends CheckedThread {
<span class="line-modified">!             private boolean timed;</span>
<span class="line-modified">!             private CyclicBarrier barrier;</span>
<span class="line-modified">!             private CountDownLatch doneSignal;</span>
<span class="line-modified">!             private Throwable throwable;</span>
<span class="line-modified">!             private boolean interrupted;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             public Waiter(boolean timed,</span>
<span class="line-modified">!                           CountDownLatch doneSignal,</span>
<span class="line-removed">-                           CyclicBarrier barrier) {</span>
<span class="line-removed">-                 this.timed = timed;</span>
                  this.doneSignal = doneSignal;
                  this.barrier = barrier;
              }
<span class="line-modified">!             Throwable throwable() { return this.throwable; }</span>
<span class="line-removed">-             boolean interruptBit() { return this.interrupted; }</span>
              void realRun() throws Throwable {
                  startingGate.await(LONG_DELAY_MS, MILLISECONDS);
                  try {
                      if (timed) barrier.await(LONG_DELAY_MS, MILLISECONDS);
<span class="line-modified">!                     else barrier.await(); }</span>
<span class="line-modified">!                 catch (Throwable throwable) { this.throwable = throwable; }</span>
  
<span class="line-modified">!                 try { doneSignal.await(LONG_DELAY_MS, MILLISECONDS); }</span>
<span class="line-modified">!                 catch (InterruptedException e) { interrupted = true; }</span>
              }
          }
  
          //----------------------------------------------------------------
          // Interrupt occurs during barrier trip
<span class="line-new-header">--- 292,46 ---</span>
  
      /**
       * Handling of extra interrupts while waiting - tests for bug 6366811
       */
      private static void testInterrupts() {
<span class="line-modified">!         final int N = ThreadLocalRandom.current().nextInt(2, 10);</span>
          final CyclicBarrier startingGate = new CyclicBarrier(N+1);
  
          /**
           * A version of Awaiter that also records interrupted state.
           */
          class Waiter extends CheckedThread {
<span class="line-modified">!             private final boolean timed;</span>
<span class="line-modified">!             private final CyclicBarrier barrier;</span>
<span class="line-modified">!             private final CountDownLatch doneSignal;</span>
<span class="line-modified">!             volatile Throwable throwable;</span>
<span class="line-modified">!             volatile boolean interruptStatusSetAfterAwait;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             public Waiter(CountDownLatch doneSignal, CyclicBarrier barrier) {</span>
<span class="line-modified">!                 this.timed = ThreadLocalRandom.current().nextBoolean();</span>
                  this.doneSignal = doneSignal;
                  this.barrier = barrier;
              }
<span class="line-modified">! </span>
              void realRun() throws Throwable {
                  startingGate.await(LONG_DELAY_MS, MILLISECONDS);
<span class="line-added">+ </span>
                  try {
                      if (timed) barrier.await(LONG_DELAY_MS, MILLISECONDS);
<span class="line-modified">!                     else barrier.await();</span>
<span class="line-modified">!                 } catch (Throwable throwable) {</span>
<span class="line-added">+                     this.throwable = throwable;</span>
<span class="line-added">+                 }</span>
  
<span class="line-modified">!                 try {</span>
<span class="line-modified">!                     check(doneSignal.await(LONG_DELAY_MS, MILLISECONDS));</span>
<span class="line-added">+                     if (Thread.interrupted())</span>
<span class="line-added">+                         interruptStatusSetAfterAwait = true;</span>
<span class="line-added">+                 } catch (InterruptedException e) {</span>
<span class="line-added">+                     interruptStatusSetAfterAwait = true;</span>
<span class="line-added">+                 }</span>
              }
          }
  
          //----------------------------------------------------------------
          // Interrupt occurs during barrier trip
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,28 ***</span>
                      // seems to work reliably while yield does not.
                      Thread.sleep(100);
                  } catch (Throwable t) { unexpected(t); }
              }};
              for (int i = 0; i &lt; N; i++) {
<span class="line-modified">!                 Waiter waiter = new Waiter(i &lt; N/2, doneSignal, barrier);</span>
                  waiter.start();
                  waiters.add(waiter);
              }
              startingGate.await(LONG_DELAY_MS, MILLISECONDS);
              while (barrier.getNumberWaiting() &lt; N) Thread.yield();
              barrier.await();
              doneSignal.countDown();
<span class="line-modified">!             int countInterrupted = 0;</span>
<span class="line-removed">-             int countInterruptedException = 0;</span>
<span class="line-removed">-             int countBrokenBarrierException = 0;</span>
              for (Waiter waiter : waiters) {
                  waiter.join();
<span class="line-modified">!                 equal(waiter.throwable(), null);</span>
<span class="line-modified">!                 if (waiter.interruptBit())</span>
<span class="line-modified">!                     countInterrupted++;</span>
              }
<span class="line-modified">!             equal(countInterrupted, N/2);</span>
              check(! barrier.isBroken());
          } catch (Throwable t) { unexpected(t); }
  
          //----------------------------------------------------------------
          // Multiple interrupts occur during barrier await
<span class="line-new-header">--- 356,26 ---</span>
                      // seems to work reliably while yield does not.
                      Thread.sleep(100);
                  } catch (Throwable t) { unexpected(t); }
              }};
              for (int i = 0; i &lt; N; i++) {
<span class="line-modified">!                 Waiter waiter = new Waiter(doneSignal, barrier);</span>
                  waiter.start();
                  waiters.add(waiter);
              }
              startingGate.await(LONG_DELAY_MS, MILLISECONDS);
              while (barrier.getNumberWaiting() &lt; N) Thread.yield();
              barrier.await();
              doneSignal.countDown();
<span class="line-modified">!             int countInterruptStatusSetAfterAwait = 0;</span>
              for (Waiter waiter : waiters) {
                  waiter.join();
<span class="line-modified">!                 equal(waiter.throwable, null);</span>
<span class="line-modified">!                 if (waiter.interruptStatusSetAfterAwait)</span>
<span class="line-modified">!                     countInterruptStatusSetAfterAwait++;</span>
              }
<span class="line-modified">!             equal(countInterruptStatusSetAfterAwait, N/2);</span>
              check(! barrier.isBroken());
          } catch (Throwable t) { unexpected(t); }
  
          //----------------------------------------------------------------
          // Multiple interrupts occur during barrier await
</pre>
<hr />
<pre>
<span class="line-old-header">*** 379,35 ***</span>
          try {
              final CountDownLatch doneSignal = new CountDownLatch(1);
              final CyclicBarrier barrier = new CyclicBarrier(N+1);
              final List&lt;Waiter&gt; waiters = new ArrayList&lt;&gt;(N);
              for (int i = 0; i &lt; N; i++) {
<span class="line-modified">!                 Waiter waiter = new Waiter(i &lt; N/2, doneSignal, barrier);</span>
                  waiter.start();
                  waiters.add(waiter);
              }
              startingGate.await(LONG_DELAY_MS, MILLISECONDS);
              while (barrier.getNumberWaiting() &lt; N) Thread.yield();
<span class="line-modified">!             for (int i = 0; i &lt; N/2; i++)</span>
<span class="line-modified">!                 waiters.get(i).interrupt();</span>
              doneSignal.countDown();
<span class="line-removed">-             int countInterrupted = 0;</span>
              int countInterruptedException = 0;
              int countBrokenBarrierException = 0;
              for (Waiter waiter : waiters) {
                  waiter.join();
<span class="line-modified">!                 if (waiter.throwable() instanceof InterruptedException)</span>
                      countInterruptedException++;
<span class="line-modified">!                 if (waiter.throwable() instanceof BrokenBarrierException)</span>
                      countBrokenBarrierException++;
<span class="line-modified">!                 if (waiter.interruptBit())</span>
<span class="line-modified">!                     countInterrupted++;</span>
              }
<span class="line-removed">-             equal(countInterrupted, N/2-1);</span>
              equal(countInterruptedException, 1);
              equal(countBrokenBarrierException, N-1);
              checkBroken(barrier);
              reset(barrier);
          } catch (Throwable t) { unexpected(t); }
      }
  
      //--------------------- Infrastructure ---------------------------
<span class="line-new-header">--- 383,37 ---</span>
          try {
              final CountDownLatch doneSignal = new CountDownLatch(1);
              final CyclicBarrier barrier = new CyclicBarrier(N+1);
              final List&lt;Waiter&gt; waiters = new ArrayList&lt;&gt;(N);
              for (int i = 0; i &lt; N; i++) {
<span class="line-modified">!                 Waiter waiter = new Waiter(doneSignal, barrier);</span>
                  waiter.start();
                  waiters.add(waiter);
              }
              startingGate.await(LONG_DELAY_MS, MILLISECONDS);
              while (barrier.getNumberWaiting() &lt; N) Thread.yield();
<span class="line-modified">!             for (int i = 0; i &lt; N/2; i++) {</span>
<span class="line-modified">!                 Thread waiter = waiters.get(i);</span>
<span class="line-added">+                 waiter.interrupt();</span>
<span class="line-added">+             }</span>
              doneSignal.countDown();
              int countInterruptedException = 0;
              int countBrokenBarrierException = 0;
<span class="line-added">+             int countInterruptStatusSetAfterAwait = 0;</span>
              for (Waiter waiter : waiters) {
                  waiter.join();
<span class="line-modified">!                 if (waiter.throwable instanceof InterruptedException)</span>
                      countInterruptedException++;
<span class="line-modified">!                 if (waiter.throwable instanceof BrokenBarrierException)</span>
                      countBrokenBarrierException++;
<span class="line-modified">!                 if (waiter.interruptStatusSetAfterAwait)</span>
<span class="line-modified">!                     countInterruptStatusSetAfterAwait++;</span>
              }
              equal(countInterruptedException, 1);
              equal(countBrokenBarrierException, N-1);
              checkBroken(barrier);
<span class="line-added">+             equal(countInterruptStatusSetAfterAwait, N/2-1);</span>
              reset(barrier);
          } catch (Throwable t) { unexpected(t); }
      }
  
      //--------------------- Infrastructure ---------------------------
</pre>
<center><a href="../CountDownLatch/Basic.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../Executors/PrivilegedCallables.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
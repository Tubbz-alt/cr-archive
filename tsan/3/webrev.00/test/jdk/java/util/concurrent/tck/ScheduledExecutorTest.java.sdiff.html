<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/ScheduledExecutorTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ScheduledExecutorSubclassTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SemaphoreTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/ScheduledExecutorTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 649                     return;
 650             } while (millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 651             fail(&quot;Purge failed to remove cancelled tasks&quot;);
 652         }
 653     }
 654 
 655     /**
 656      * shutdownNow returns a list containing tasks that were not run,
 657      * and those tasks are drained from the queue
 658      */
 659     public void testShutdownNow() throws InterruptedException {
 660         final int poolSize = 2;
 661         final int count = 5;
 662         final AtomicInteger ran = new AtomicInteger(0);
 663         final ScheduledThreadPoolExecutor p =
 664             new ScheduledThreadPoolExecutor(poolSize);
 665         final CountDownLatch threadsStarted = new CountDownLatch(poolSize);
 666         Runnable waiter = new CheckedRunnable() { public void realRun() {
 667             threadsStarted.countDown();
 668             try {
<span class="line-modified"> 669                 MILLISECONDS.sleep(2 * LONG_DELAY_MS);</span>
 670             } catch (InterruptedException success) {}
 671             ran.getAndIncrement();
 672         }};
 673         for (int i = 0; i &lt; count; i++)
 674             p.execute(waiter);
 675         await(threadsStarted);
 676         assertEquals(poolSize, p.getActiveCount());
 677         assertEquals(0, p.getCompletedTaskCount());
 678         final List&lt;Runnable&gt; queuedTasks;
 679         try {
 680             queuedTasks = p.shutdownNow();
 681         } catch (SecurityException ok) {
 682             return; // Allowed in case test doesn&#39;t have privs
 683         }
 684         assertTrue(p.isShutdown());
 685         assertTrue(p.getQueue().isEmpty());
 686         assertEquals(count - poolSize, queuedTasks.size());
 687         assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));
 688         assertTrue(p.isTerminated());
 689         assertEquals(poolSize, ran.get());
</pre>
</td>
<td>
<hr />
<pre>
 649                     return;
 650             } while (millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 651             fail(&quot;Purge failed to remove cancelled tasks&quot;);
 652         }
 653     }
 654 
 655     /**
 656      * shutdownNow returns a list containing tasks that were not run,
 657      * and those tasks are drained from the queue
 658      */
 659     public void testShutdownNow() throws InterruptedException {
 660         final int poolSize = 2;
 661         final int count = 5;
 662         final AtomicInteger ran = new AtomicInteger(0);
 663         final ScheduledThreadPoolExecutor p =
 664             new ScheduledThreadPoolExecutor(poolSize);
 665         final CountDownLatch threadsStarted = new CountDownLatch(poolSize);
 666         Runnable waiter = new CheckedRunnable() { public void realRun() {
 667             threadsStarted.countDown();
 668             try {
<span class="line-modified"> 669                 MILLISECONDS.sleep(LONGER_DELAY_MS);</span>
 670             } catch (InterruptedException success) {}
 671             ran.getAndIncrement();
 672         }};
 673         for (int i = 0; i &lt; count; i++)
 674             p.execute(waiter);
 675         await(threadsStarted);
 676         assertEquals(poolSize, p.getActiveCount());
 677         assertEquals(0, p.getCompletedTaskCount());
 678         final List&lt;Runnable&gt; queuedTasks;
 679         try {
 680             queuedTasks = p.shutdownNow();
 681         } catch (SecurityException ok) {
 682             return; // Allowed in case test doesn&#39;t have privs
 683         }
 684         assertTrue(p.isShutdown());
 685         assertTrue(p.getQueue().isEmpty());
 686         assertEquals(count - poolSize, queuedTasks.size());
 687         assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));
 688         assertTrue(p.isTerminated());
 689         assertEquals(poolSize, ran.get());
</pre>
</td>
</tr>
</table>
<center><a href="ScheduledExecutorSubclassTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SemaphoreTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/tck/DelayQueueTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea with assistance from members of JCP JSR-166
 30  * Expert Group and released to the public domain, as explained at
 31  * http://creativecommons.org/publicdomain/zero/1.0/
 32  * Other contributors include Andrew Wright, Jeffrey Hayes,
 33  * Pat Fisher, Mike Judd.
 34  */
 35 
 36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 37 
 38 import java.util.ArrayList;
 39 import java.util.Arrays;
 40 import java.util.Collection;
 41 import java.util.Iterator;
 42 import java.util.NoSuchElementException;
 43 import java.util.concurrent.BlockingQueue;
 44 import java.util.concurrent.CountDownLatch;
 45 import java.util.concurrent.Delayed;
 46 import java.util.concurrent.DelayQueue;
 47 import java.util.concurrent.Executors;
 48 import java.util.concurrent.ExecutorService;
 49 import java.util.concurrent.TimeUnit;
 50 
 51 import junit.framework.Test;
 52 
 53 public class DelayQueueTest extends JSR166TestCase {
 54 
 55     public static class Generic extends BlockingQueueTest {
 56         protected BlockingQueue emptyCollection() {
 57             return new DelayQueue();
 58         }
 59         protected PDelay makeElement(int i) {
 60             return new PDelay(i);
 61         }
 62     }
 63 
 64     public static void main(String[] args) {
 65         main(suite(), args);
 66     }
 67 
 68     public static Test suite() {
 69         class Implementation implements CollectionImplementation {
 70             public Class&lt;?&gt; klazz() { return DelayQueue.class; }
 71             public Collection emptyCollection() { return new DelayQueue(); }
 72             public Object makeElement(int i) { return new PDelay(i); }
 73             public boolean isConcurrent() { return true; }
 74             public boolean permitsNulls() { return false; }
 75         }
 76         return newTestSuite(DelayQueueTest.class,
 77                             new Generic().testSuite(),
 78                             CollectionTest.testSuite(new Implementation()));
 79     }
 80 
 81     /**
 82      * A fake Delayed implementation for testing.
 83      * Most tests use PDelays, where delays are all elapsed
 84      * (so, no blocking solely for delays) but are still ordered
 85      */
 86     static class PDelay implements Delayed {
 87         final int pseudodelay;
 88         PDelay(int pseudodelay) { this.pseudodelay = pseudodelay; }
 89         public int compareTo(Delayed y) {
 90             return Integer.compare(this.pseudodelay, ((PDelay)y).pseudodelay);
 91         }
 92         public boolean equals(Object other) {
 93             return (other instanceof PDelay) &amp;&amp;
 94                 this.pseudodelay == ((PDelay)other).pseudodelay;
 95         }
 96         // suppress [overrides] javac warning
 97         public int hashCode() { return pseudodelay; }
 98         public long getDelay(TimeUnit ignore) {
 99             return (long) Integer.MIN_VALUE + pseudodelay;
100         }
101         public String toString() {
102             return String.valueOf(pseudodelay);
103         }
104     }
105 
106     /**
107      * Delayed implementation that actually delays
108      */
109     static class NanoDelay implements Delayed {
110         final long trigger;
111         NanoDelay(long i) {
112             trigger = System.nanoTime() + i;
113         }
114 
115         public int compareTo(Delayed y) {
116             return Long.compare(trigger, ((NanoDelay)y).trigger);
117         }
118 
119         public boolean equals(Object other) {
120             return (other instanceof NanoDelay) &amp;&amp;
121                 this.trigger == ((NanoDelay)other).trigger;
122         }
123 
124         // suppress [overrides] javac warning
125         public int hashCode() { return (int) trigger; }
126 
127         public long getDelay(TimeUnit unit) {
128             long n = trigger - System.nanoTime();
129             return unit.convert(n, TimeUnit.NANOSECONDS);
130         }
131 
132         public long getTriggerTime() {
133             return trigger;
134         }
135 
136         public String toString() {
137             return String.valueOf(trigger);
138         }
139     }
140 
141     /**
142      * Returns a new queue of given size containing consecutive
143      * PDelays 0 ... n - 1.
144      */
145     private static DelayQueue&lt;PDelay&gt; populatedQueue(int n) {
146         DelayQueue&lt;PDelay&gt; q = new DelayQueue&lt;&gt;();
147         assertTrue(q.isEmpty());
148         for (int i = n - 1; i &gt;= 0; i -= 2)
149             assertTrue(q.offer(new PDelay(i)));
150         for (int i = (n &amp; 1); i &lt; n; i += 2)
151             assertTrue(q.offer(new PDelay(i)));
152         assertFalse(q.isEmpty());
153         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
154         assertEquals(n, q.size());
155         assertEquals(new PDelay(0), q.peek());
156         return q;
157     }
158 
159     /**
160      * A new queue has unbounded capacity
161      */
162     public void testConstructor1() {
163         assertEquals(Integer.MAX_VALUE, new DelayQueue().remainingCapacity());
164     }
165 
166     /**
167      * Initializing from null Collection throws NPE
168      */
169     public void testConstructor3() {
170         try {
171             new DelayQueue(null);
172             shouldThrow();
173         } catch (NullPointerException success) {}
174     }
175 
176     /**
177      * Initializing from Collection of null elements throws NPE
178      */
179     public void testConstructor4() {
180         try {
181             new DelayQueue(Arrays.asList(new PDelay[SIZE]));
182             shouldThrow();
183         } catch (NullPointerException success) {}
184     }
185 
186     /**
187      * Initializing from Collection with some null elements throws NPE
188      */
189     public void testConstructor5() {
190         PDelay[] a = new PDelay[SIZE];
191         for (int i = 0; i &lt; SIZE - 1; ++i)
192             a[i] = new PDelay(i);
193         try {
194             new DelayQueue(Arrays.asList(a));
195             shouldThrow();
196         } catch (NullPointerException success) {}
197     }
198 
199     /**
200      * Queue contains all elements of collection used to initialize
201      */
202     public void testConstructor6() {
203         PDelay[] ints = new PDelay[SIZE];
204         for (int i = 0; i &lt; SIZE; ++i)
205             ints[i] = new PDelay(i);
206         DelayQueue q = new DelayQueue(Arrays.asList(ints));
207         for (int i = 0; i &lt; SIZE; ++i)
208             assertEquals(ints[i], q.poll());
209     }
210 
211     /**
212      * isEmpty is true before add, false after
213      */
214     public void testEmpty() {
215         DelayQueue q = new DelayQueue();
216         assertTrue(q.isEmpty());
217         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
218         q.add(new PDelay(1));
219         assertFalse(q.isEmpty());
220         q.add(new PDelay(2));
221         q.remove();
222         q.remove();
223         assertTrue(q.isEmpty());
224     }
225 
226     /**
227      * remainingCapacity() always returns Integer.MAX_VALUE
228      */
229     public void testRemainingCapacity() {
230         BlockingQueue q = populatedQueue(SIZE);
231         for (int i = 0; i &lt; SIZE; ++i) {
232             assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
233             assertEquals(SIZE - i, q.size());
234             assertTrue(q.remove() instanceof PDelay);
235         }
236         for (int i = 0; i &lt; SIZE; ++i) {
237             assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
238             assertEquals(i, q.size());
239             assertTrue(q.add(new PDelay(i)));
240         }
241     }
242 
243     /**
244      * offer non-null succeeds
245      */
246     public void testOffer() {
247         DelayQueue q = new DelayQueue();
248         assertTrue(q.offer(new PDelay(0)));
249         assertTrue(q.offer(new PDelay(1)));
250     }
251 
252     /**
253      * add succeeds
254      */
255     public void testAdd() {
256         DelayQueue q = new DelayQueue();
257         for (int i = 0; i &lt; SIZE; ++i) {
258             assertEquals(i, q.size());
259             assertTrue(q.add(new PDelay(i)));
260         }
261     }
262 
263     /**
264      * addAll(this) throws IllegalArgumentException
265      */
266     public void testAddAllSelf() {
267         DelayQueue q = populatedQueue(SIZE);
268         try {
269             q.addAll(q);
270             shouldThrow();
271         } catch (IllegalArgumentException success) {}
272     }
273 
274     /**
275      * addAll of a collection with any null elements throws NPE after
276      * possibly adding some elements
277      */
278     public void testAddAll3() {
279         DelayQueue q = new DelayQueue();
280         PDelay[] a = new PDelay[SIZE];
281         for (int i = 0; i &lt; SIZE - 1; ++i)
282             a[i] = new PDelay(i);
283         try {
284             q.addAll(Arrays.asList(a));
285             shouldThrow();
286         } catch (NullPointerException success) {}
287     }
288 
289     /**
290      * Queue contains all elements of successful addAll
291      */
292     public void testAddAll5() {
293         PDelay[] empty = new PDelay[0];
294         PDelay[] ints = new PDelay[SIZE];
295         for (int i = SIZE - 1; i &gt;= 0; --i)
296             ints[i] = new PDelay(i);
297         DelayQueue q = new DelayQueue();
298         assertFalse(q.addAll(Arrays.asList(empty)));
299         assertTrue(q.addAll(Arrays.asList(ints)));
300         for (int i = 0; i &lt; SIZE; ++i)
301             assertEquals(ints[i], q.poll());
302     }
303 
304     /**
305      * all elements successfully put are contained
306      */
307     public void testPut() {
308         DelayQueue q = new DelayQueue();
309         for (int i = 0; i &lt; SIZE; ++i) {
310             PDelay x = new PDelay(i);
311             q.put(x);
312             assertTrue(q.contains(x));
313         }
314         assertEquals(SIZE, q.size());
315     }
316 
317     /**
318      * put doesn&#39;t block waiting for take
319      */
320     public void testPutWithTake() throws InterruptedException {
321         final DelayQueue q = new DelayQueue();
322         Thread t = newStartedThread(new CheckedRunnable() {
323             public void realRun() {
324                 q.put(new PDelay(0));
325                 q.put(new PDelay(0));
326                 q.put(new PDelay(0));
327                 q.put(new PDelay(0));
328             }});
329 
330         awaitTermination(t);
331         assertEquals(4, q.size());
332     }
333 
334     /**
<a name="1" id="anc1"></a><span class="line-modified">335      * timed offer does not time out</span>
336      */
337     public void testTimedOffer() throws InterruptedException {
338         final DelayQueue q = new DelayQueue();
339         Thread t = newStartedThread(new CheckedRunnable() {
340             public void realRun() throws InterruptedException {
341                 q.put(new PDelay(0));
342                 q.put(new PDelay(0));
343                 assertTrue(q.offer(new PDelay(0), SHORT_DELAY_MS, MILLISECONDS));
344                 assertTrue(q.offer(new PDelay(0), LONG_DELAY_MS, MILLISECONDS));
345             }});
346 
347         awaitTermination(t);
348     }
349 
350     /**
351      * take retrieves elements in priority order
352      */
353     public void testTake() throws InterruptedException {
354         DelayQueue q = populatedQueue(SIZE);
355         for (int i = 0; i &lt; SIZE; ++i) {
356             assertEquals(new PDelay(i), q.take());
357         }
358     }
359 
360     /**
361      * Take removes existing elements until empty, then blocks interruptibly
362      */
363     public void testBlockingTake() throws InterruptedException {
364         final DelayQueue q = populatedQueue(SIZE);
365         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
366         Thread t = newStartedThread(new CheckedRunnable() {
367             public void realRun() throws InterruptedException {
368                 for (int i = 0; i &lt; SIZE; i++)
369                     assertEquals(new PDelay(i), ((PDelay)q.take()));
370 
371                 Thread.currentThread().interrupt();
372                 try {
373                     q.take();
374                     shouldThrow();
375                 } catch (InterruptedException success) {}
376                 assertFalse(Thread.interrupted());
377 
378                 pleaseInterrupt.countDown();
379                 try {
380                     q.take();
381                     shouldThrow();
382                 } catch (InterruptedException success) {}
383                 assertFalse(Thread.interrupted());
384             }});
385 
386         await(pleaseInterrupt);
<a name="2" id="anc2"></a><span class="line-modified">387         assertThreadBlocks(t, Thread.State.WAITING);</span>
388         t.interrupt();
389         awaitTermination(t);
390     }
391 
392     /**
393      * poll succeeds unless empty
394      */
395     public void testPoll() {
396         DelayQueue q = populatedQueue(SIZE);
397         for (int i = 0; i &lt; SIZE; ++i) {
398             assertEquals(new PDelay(i), q.poll());
399         }
400         assertNull(q.poll());
401     }
402 
403     /**
404      * timed poll with zero timeout succeeds when non-empty, else times out
405      */
406     public void testTimedPoll0() throws InterruptedException {
407         DelayQueue q = populatedQueue(SIZE);
408         for (int i = 0; i &lt; SIZE; ++i) {
409             assertEquals(new PDelay(i), q.poll(0, MILLISECONDS));
410         }
411         assertNull(q.poll(0, MILLISECONDS));
412     }
413 
414     /**
415      * timed poll with nonzero timeout succeeds when non-empty, else times out
416      */
417     public void testTimedPoll() throws InterruptedException {
418         DelayQueue q = populatedQueue(SIZE);
419         for (int i = 0; i &lt; SIZE; ++i) {
420             long startTime = System.nanoTime();
421             assertEquals(new PDelay(i), q.poll(LONG_DELAY_MS, MILLISECONDS));
422             assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
423         }
424         long startTime = System.nanoTime();
425         assertNull(q.poll(timeoutMillis(), MILLISECONDS));
426         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
427         checkEmpty(q);
428     }
429 
430     /**
431      * Interrupted timed poll throws InterruptedException instead of
432      * returning timeout status
433      */
434     public void testInterruptedTimedPoll() throws InterruptedException {
435         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
436         final DelayQueue q = populatedQueue(SIZE);
437         Thread t = newStartedThread(new CheckedRunnable() {
438             public void realRun() throws InterruptedException {
<a name="3" id="anc3"></a><span class="line-removed">439                 long startTime = System.nanoTime();</span>
440                 for (int i = 0; i &lt; SIZE; i++)
441                     assertEquals(new PDelay(i),
442                                  ((PDelay)q.poll(LONG_DELAY_MS, MILLISECONDS)));
443 
444                 Thread.currentThread().interrupt();
445                 try {
<a name="4" id="anc4"></a><span class="line-modified">446                     q.poll(LONG_DELAY_MS, MILLISECONDS);</span>
447                     shouldThrow();
448                 } catch (InterruptedException success) {}
449                 assertFalse(Thread.interrupted());
450 
451                 pleaseInterrupt.countDown();
452                 try {
<a name="5" id="anc5"></a><span class="line-modified">453                     q.poll(LONG_DELAY_MS, MILLISECONDS);</span>
454                     shouldThrow();
455                 } catch (InterruptedException success) {}
456                 assertFalse(Thread.interrupted());
<a name="6" id="anc6"></a><span class="line-removed">457 </span>
<span class="line-removed">458                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);</span>
459             }});
460 
461         await(pleaseInterrupt);
<a name="7" id="anc7"></a><span class="line-modified">462         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
463         t.interrupt();
464         awaitTermination(t);
465         checkEmpty(q);
466     }
467 
468     /**
469      * peek returns next element, or null if empty
470      */
471     public void testPeek() {
472         DelayQueue q = populatedQueue(SIZE);
473         for (int i = 0; i &lt; SIZE; ++i) {
474             assertEquals(new PDelay(i), q.peek());
475             assertEquals(new PDelay(i), q.poll());
476             if (q.isEmpty())
477                 assertNull(q.peek());
478             else
479                 assertFalse(new PDelay(i).equals(q.peek()));
480         }
481         assertNull(q.peek());
482     }
483 
484     /**
485      * element returns next element, or throws NSEE if empty
486      */
487     public void testElement() {
488         DelayQueue q = populatedQueue(SIZE);
489         for (int i = 0; i &lt; SIZE; ++i) {
490             assertEquals(new PDelay(i), q.element());
491             q.poll();
492         }
493         try {
494             q.element();
495             shouldThrow();
496         } catch (NoSuchElementException success) {}
497     }
498 
499     /**
500      * remove removes next element, or throws NSEE if empty
501      */
502     public void testRemove() {
503         DelayQueue q = populatedQueue(SIZE);
504         for (int i = 0; i &lt; SIZE; ++i) {
505             assertEquals(new PDelay(i), q.remove());
506         }
507         try {
508             q.remove();
509             shouldThrow();
510         } catch (NoSuchElementException success) {}
511     }
512 
513     /**
514      * contains(x) reports true when elements added but not yet removed
515      */
516     public void testContains() {
517         DelayQueue q = populatedQueue(SIZE);
518         for (int i = 0; i &lt; SIZE; ++i) {
519             assertTrue(q.contains(new PDelay(i)));
520             q.poll();
521             assertFalse(q.contains(new PDelay(i)));
522         }
523     }
524 
525     /**
526      * clear removes all elements
527      */
528     public void testClear() {
529         DelayQueue q = populatedQueue(SIZE);
530         q.clear();
531         assertTrue(q.isEmpty());
532         assertEquals(0, q.size());
533         assertEquals(Integer.MAX_VALUE, q.remainingCapacity());
534         PDelay x = new PDelay(1);
535         q.add(x);
536         assertFalse(q.isEmpty());
537         assertTrue(q.contains(x));
538         q.clear();
539         assertTrue(q.isEmpty());
540     }
541 
542     /**
543      * containsAll(c) is true when c contains a subset of elements
544      */
545     public void testContainsAll() {
546         DelayQueue q = populatedQueue(SIZE);
547         DelayQueue p = new DelayQueue();
548         for (int i = 0; i &lt; SIZE; ++i) {
549             assertTrue(q.containsAll(p));
550             assertFalse(p.containsAll(q));
551             p.add(new PDelay(i));
552         }
553         assertTrue(p.containsAll(q));
554     }
555 
556     /**
557      * retainAll(c) retains only those elements of c and reports true if changed
558      */
559     public void testRetainAll() {
560         DelayQueue q = populatedQueue(SIZE);
561         DelayQueue p = populatedQueue(SIZE);
562         for (int i = 0; i &lt; SIZE; ++i) {
563             boolean changed = q.retainAll(p);
564             if (i == 0)
565                 assertFalse(changed);
566             else
567                 assertTrue(changed);
568 
569             assertTrue(q.containsAll(p));
570             assertEquals(SIZE - i, q.size());
571             p.remove();
572         }
573     }
574 
575     /**
576      * removeAll(c) removes only those elements of c and reports true if changed
577      */
578     public void testRemoveAll() {
579         for (int i = 1; i &lt; SIZE; ++i) {
580             DelayQueue q = populatedQueue(SIZE);
581             DelayQueue p = populatedQueue(i);
582             assertTrue(q.removeAll(p));
583             assertEquals(SIZE - i, q.size());
584             for (int j = 0; j &lt; i; ++j) {
585                 PDelay x = (PDelay)(p.remove());
586                 assertFalse(q.contains(x));
587             }
588         }
589     }
590 
591     /**
592      * toArray contains all elements
593      */
594     public void testToArray() throws InterruptedException {
595         DelayQueue q = populatedQueue(SIZE);
596         Object[] a = q.toArray();
597         assertSame(Object[].class, a.getClass());
598         Arrays.sort(a);
599         for (Object o : a)
600             assertSame(o, q.take());
601         assertTrue(q.isEmpty());
602     }
603 
604     /**
605      * toArray(a) contains all elements
606      */
607     public void testToArray2() {
608         DelayQueue&lt;PDelay&gt; q = populatedQueue(SIZE);
609         PDelay[] ints = new PDelay[SIZE];
610         PDelay[] array = q.toArray(ints);
611         assertSame(ints, array);
612         Arrays.sort(ints);
613         for (PDelay o : ints)
614             assertSame(o, q.remove());
615         assertTrue(q.isEmpty());
616     }
617 
618     /**
619      * toArray(incompatible array type) throws ArrayStoreException
620      */
621     public void testToArray1_BadArg() {
622         DelayQueue q = populatedQueue(SIZE);
623         try {
624             q.toArray(new String[10]);
625             shouldThrow();
626         } catch (ArrayStoreException success) {}
627     }
628 
629     /**
630      * iterator iterates through all elements
631      */
632     public void testIterator() {
633         DelayQueue q = populatedQueue(SIZE);
634         int i = 0;
635         Iterator it = q.iterator();
636         while (it.hasNext()) {
637             assertTrue(q.contains(it.next()));
638             ++i;
639         }
640         assertEquals(i, SIZE);
641         assertIteratorExhausted(it);
642     }
643 
644     /**
645      * iterator of empty collection has no elements
646      */
647     public void testEmptyIterator() {
648         assertIteratorExhausted(new DelayQueue().iterator());
649     }
650 
651     /**
652      * iterator.remove removes current element
653      */
654     public void testIteratorRemove() {
655         final DelayQueue q = new DelayQueue();
656         q.add(new PDelay(2));
657         q.add(new PDelay(1));
658         q.add(new PDelay(3));
659         Iterator it = q.iterator();
660         it.next();
661         it.remove();
662         it = q.iterator();
663         assertEquals(new PDelay(2), it.next());
664         assertEquals(new PDelay(3), it.next());
665         assertFalse(it.hasNext());
666     }
667 
668     /**
669      * toString contains toStrings of elements
670      */
671     public void testToString() {
672         DelayQueue q = populatedQueue(SIZE);
673         String s = q.toString();
674         for (Object e : q)
675             assertTrue(s.contains(e.toString()));
676     }
677 
678     /**
679      * timed poll transfers elements across Executor tasks
680      */
681     public void testPollInExecutor() {
682         final DelayQueue q = new DelayQueue();
683         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
684         final ExecutorService executor = Executors.newFixedThreadPool(2);
685         try (PoolCleaner cleaner = cleaner(executor)) {
686             executor.execute(new CheckedRunnable() {
687                 public void realRun() throws InterruptedException {
688                     assertNull(q.poll());
689                     threadsStarted.await();
690                     assertNotNull(q.poll(LONG_DELAY_MS, MILLISECONDS));
691                     checkEmpty(q);
692                 }});
693 
694             executor.execute(new CheckedRunnable() {
695                 public void realRun() throws InterruptedException {
696                     threadsStarted.await();
697                     q.put(new PDelay(1));
698                 }});
699         }
700     }
701 
702     /**
703      * Delayed actions do not occur until their delay elapses
704      */
705     public void testDelay() throws InterruptedException {
706         DelayQueue&lt;NanoDelay&gt; q = new DelayQueue&lt;&gt;();
707         for (int i = 0; i &lt; SIZE; ++i)
708             q.add(new NanoDelay(1000000L * (SIZE - i)));
709 
710         long last = 0;
711         for (int i = 0; i &lt; SIZE; ++i) {
712             NanoDelay e = q.take();
713             long tt = e.getTriggerTime();
714             assertTrue(System.nanoTime() - tt &gt;= 0);
715             if (i != 0)
716                 assertTrue(tt &gt;= last);
717             last = tt;
718         }
719         assertTrue(q.isEmpty());
720     }
721 
722     /**
723      * peek of a non-empty queue returns non-null even if not expired
724      */
725     public void testPeekDelayed() {
726         DelayQueue q = new DelayQueue();
727         q.add(new NanoDelay(Long.MAX_VALUE));
728         assertNotNull(q.peek());
729     }
730 
731     /**
732      * poll of a non-empty queue returns null if no expired elements.
733      */
734     public void testPollDelayed() {
735         DelayQueue q = new DelayQueue();
736         q.add(new NanoDelay(Long.MAX_VALUE));
737         assertNull(q.poll());
738     }
739 
740     /**
741      * timed poll of a non-empty queue returns null if no expired elements.
742      */
743     public void testTimedPollDelayed() throws InterruptedException {
744         DelayQueue q = new DelayQueue();
745         q.add(new NanoDelay(LONG_DELAY_MS * 1000000L));
746         long startTime = System.nanoTime();
747         assertNull(q.poll(timeoutMillis(), MILLISECONDS));
748         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
749     }
750 
751     /**
752      * drainTo(c) empties queue into another collection c
753      */
754     public void testDrainTo() {
755         DelayQueue q = new DelayQueue();
756         PDelay[] elems = new PDelay[SIZE];
757         for (int i = 0; i &lt; SIZE; ++i) {
758             elems[i] = new PDelay(i);
759             q.add(elems[i]);
760         }
761         ArrayList l = new ArrayList();
762         q.drainTo(l);
763         assertEquals(0, q.size());
764         for (int i = 0; i &lt; SIZE; ++i)
765             assertEquals(elems[i], l.get(i));
766         q.add(elems[0]);
767         q.add(elems[1]);
768         assertFalse(q.isEmpty());
769         assertTrue(q.contains(elems[0]));
770         assertTrue(q.contains(elems[1]));
771         l.clear();
772         q.drainTo(l);
773         assertEquals(0, q.size());
774         assertEquals(2, l.size());
775         for (int i = 0; i &lt; 2; ++i)
776             assertEquals(elems[i], l.get(i));
777     }
778 
779     /**
780      * drainTo empties queue
781      */
782     public void testDrainToWithActivePut() throws InterruptedException {
783         final DelayQueue q = populatedQueue(SIZE);
784         Thread t = new Thread(new CheckedRunnable() {
785             public void realRun() {
786                 q.put(new PDelay(SIZE + 1));
787             }});
788 
789         t.start();
790         ArrayList l = new ArrayList();
791         q.drainTo(l);
792         assertTrue(l.size() &gt;= SIZE);
793         t.join();
794         assertTrue(q.size() + l.size() &gt;= SIZE);
795     }
796 
797     /**
798      * drainTo(c, n) empties first min(n, size) elements of queue into c
799      */
800     public void testDrainToN() {
801         for (int i = 0; i &lt; SIZE + 2; ++i) {
802             DelayQueue q = populatedQueue(SIZE);
803             ArrayList l = new ArrayList();
804             q.drainTo(l, i);
805             int k = (i &lt; SIZE) ? i : SIZE;
806             assertEquals(SIZE - k, q.size());
807             assertEquals(k, l.size());
808         }
809     }
810 
811     /**
812      * remove(null), contains(null) always return false
813      */
814     public void testNeverContainsNull() {
815         Collection&lt;?&gt; q = populatedQueue(SIZE);
816         assertFalse(q.contains(null));
817         assertFalse(q.remove(null));
818     }
819 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
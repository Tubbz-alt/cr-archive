<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/SplittableRandomTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SemaphoreTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StampedLockTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/SplittableRandomTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
148     /**
149      * A SplittableRandom produced by split() of a seeded-constructed
150      * SplittableRandom generates a different sequence
151      */
152     public void testSplit2() {
153         SplittableRandom sr = new SplittableRandom(12345);
154         for (int reps = 0; reps &lt; REPS; ++reps) {
155             SplittableRandom sc = sr.split();
156             int i = 0;
157             while (i &lt; NCALLS &amp;&amp; sr.nextLong() == sc.nextLong())
158                 ++i;
159             assertTrue(i &lt; NCALLS);
160         }
161     }
162 
163     /**
164      * nextInt(non-positive) throws IllegalArgumentException
165      */
166     public void testNextIntBoundNonPositive() {
167         SplittableRandom sr = new SplittableRandom();
<span class="line-modified">168         Runnable[] throwingActions = {</span>

169             () -&gt; sr.nextInt(-17),
170             () -&gt; sr.nextInt(0),
<span class="line-modified">171             () -&gt; sr.nextInt(Integer.MIN_VALUE),</span>
<span class="line-removed">172         };</span>
<span class="line-removed">173         assertThrows(IllegalArgumentException.class, throwingActions);</span>
174     }
175 
176     /**
177      * nextInt(least &gt;= bound) throws IllegalArgumentException
178      */
179     public void testNextIntBadBounds() {
180         SplittableRandom sr = new SplittableRandom();
<span class="line-modified">181         Runnable[] throwingActions = {</span>

182             () -&gt; sr.nextInt(17, 2),
183             () -&gt; sr.nextInt(-42, -42),
<span class="line-modified">184             () -&gt; sr.nextInt(Integer.MAX_VALUE, Integer.MIN_VALUE),</span>
<span class="line-removed">185         };</span>
<span class="line-removed">186         assertThrows(IllegalArgumentException.class, throwingActions);</span>
187     }
188 
189     /**
190      * nextInt(bound) returns 0 &lt;= value &lt; bound;
191      * repeated calls produce at least two distinct results
192      */
193     public void testNextIntBounded() {
194         SplittableRandom sr = new SplittableRandom();
195         for (int i = 0; i &lt; 2; i++) assertEquals(0, sr.nextInt(1));
196         // sample bound space across prime number increments
197         for (int bound = 2; bound &lt; MAX_INT_BOUND; bound += 524959) {
198             int f = sr.nextInt(bound);
199             assertTrue(0 &lt;= f &amp;&amp; f &lt; bound);
200             int i = 0;
201             int j;
202             while (i &lt; NCALLS &amp;&amp;
203                    (j = sr.nextInt(bound)) == f) {
204                 assertTrue(0 &lt;= j &amp;&amp; j &lt; bound);
205                 ++i;
206             }
</pre>
<hr />
<pre>
218             for (int bound = least + 2; bound &gt; least &amp;&amp; bound &lt; MAX_INT_BOUND; bound += 49979687) {
219                 int f = sr.nextInt(least, bound);
220                 assertTrue(least &lt;= f &amp;&amp; f &lt; bound);
221                 int i = 0;
222                 int j;
223                 while (i &lt; NCALLS &amp;&amp;
224                        (j = sr.nextInt(least, bound)) == f) {
225                     assertTrue(least &lt;= j &amp;&amp; j &lt; bound);
226                     ++i;
227                 }
228                 assertTrue(i &lt; NCALLS);
229             }
230         }
231     }
232 
233     /**
234      * nextLong(non-positive) throws IllegalArgumentException
235      */
236     public void testNextLongBoundNonPositive() {
237         SplittableRandom sr = new SplittableRandom();
<span class="line-modified">238         Runnable[] throwingActions = {</span>

239             () -&gt; sr.nextLong(-17L),
240             () -&gt; sr.nextLong(0L),
<span class="line-modified">241             () -&gt; sr.nextLong(Long.MIN_VALUE),</span>
<span class="line-removed">242         };</span>
<span class="line-removed">243         assertThrows(IllegalArgumentException.class, throwingActions);</span>
244     }
245 
246     /**
247      * nextLong(least &gt;= bound) throws IllegalArgumentException
248      */
249     public void testNextLongBadBounds() {
250         SplittableRandom sr = new SplittableRandom();
<span class="line-modified">251         Runnable[] throwingActions = {</span>

252             () -&gt; sr.nextLong(17L, 2L),
253             () -&gt; sr.nextLong(-42L, -42L),
<span class="line-modified">254             () -&gt; sr.nextLong(Long.MAX_VALUE, Long.MIN_VALUE),</span>
<span class="line-removed">255         };</span>
<span class="line-removed">256         assertThrows(IllegalArgumentException.class, throwingActions);</span>
257     }
258 
259     /**
260      * nextLong(bound) returns 0 &lt;= value &lt; bound;
261      * repeated calls produce at least two distinct results
262      */
263     public void testNextLongBounded() {
264         SplittableRandom sr = new SplittableRandom();
265         for (int i = 0; i &lt; 2; i++) assertEquals(0L, sr.nextLong(1L));
266         for (long bound = 2; bound &lt; MAX_LONG_BOUND; bound += 15485863) {
267             long f = sr.nextLong(bound);
268             assertTrue(0 &lt;= f &amp;&amp; f &lt; bound);
269             int i = 0;
270             long j;
271             while (i &lt; NCALLS &amp;&amp;
272                    (j = sr.nextLong(bound)) == f) {
273                 assertTrue(0 &lt;= j &amp;&amp; j &lt; bound);
274                 ++i;
275             }
276             assertTrue(i &lt; NCALLS);
</pre>
<hr />
<pre>
287             for (long bound = least + 2; bound &gt; least &amp;&amp; bound &lt; MAX_LONG_BOUND; bound += Math.abs(bound * 7919)) {
288                 long f = sr.nextLong(least, bound);
289                 assertTrue(least &lt;= f &amp;&amp; f &lt; bound);
290                 int i = 0;
291                 long j;
292                 while (i &lt; NCALLS &amp;&amp;
293                        (j = sr.nextLong(least, bound)) == f) {
294                     assertTrue(least &lt;= j &amp;&amp; j &lt; bound);
295                     ++i;
296                 }
297                 assertTrue(i &lt; NCALLS);
298             }
299         }
300     }
301 
302     /**
303      * nextDouble(non-positive) throws IllegalArgumentException
304      */
305     public void testNextDoubleBoundNonPositive() {
306         SplittableRandom sr = new SplittableRandom();
<span class="line-modified">307         Runnable[] throwingActions = {</span>

308             () -&gt; sr.nextDouble(-17.0d),
309             () -&gt; sr.nextDouble(0.0d),
310             () -&gt; sr.nextDouble(-Double.MIN_VALUE),
311             () -&gt; sr.nextDouble(Double.NEGATIVE_INFINITY),
<span class="line-modified">312             () -&gt; sr.nextDouble(Double.NaN),</span>
<span class="line-removed">313         };</span>
<span class="line-removed">314         assertThrows(IllegalArgumentException.class, throwingActions);</span>
315     }
316 
317     /**
318      * nextDouble(! (least &lt; bound)) throws IllegalArgumentException
319      */
320     public void testNextDoubleBadBounds() {
321         SplittableRandom sr = new SplittableRandom();
<span class="line-modified">322         Runnable[] throwingActions = {</span>

323             () -&gt; sr.nextDouble(17.0d, 2.0d),
324             () -&gt; sr.nextDouble(-42.0d, -42.0d),
325             () -&gt; sr.nextDouble(Double.MAX_VALUE, Double.MIN_VALUE),
326             () -&gt; sr.nextDouble(Double.NaN, 0.0d),
<span class="line-modified">327             () -&gt; sr.nextDouble(0.0d, Double.NaN),</span>
<span class="line-removed">328         };</span>
<span class="line-removed">329         assertThrows(IllegalArgumentException.class, throwingActions);</span>
330     }
331 
332     // TODO: Test infinite bounds!
333     //() -&gt; sr.nextDouble(Double.NEGATIVE_INFINITY, 0.0d),
334     //() -&gt; sr.nextDouble(0.0d, Double.POSITIVE_INFINITY),
335 
336     /**
337      * nextDouble(least, bound) returns least &lt;= value &lt; bound;
338      * repeated calls produce at least two distinct results
339      */
340     public void testNextDoubleBounded2() {
341         SplittableRandom sr = new SplittableRandom();
342         for (double least = 0.0001; least &lt; 1.0e20; least *= 8) {
343             for (double bound = least * 1.001; bound &lt; 1.0e20; bound *= 16) {
344                 double f = sr.nextDouble(least, bound);
345                 assertTrue(least &lt;= f &amp;&amp; f &lt; bound);
346                 int i = 0;
347                 double j;
348                 while (i &lt; NCALLS &amp;&amp;
349                        (j = sr.nextDouble(least, bound)) == f) {
350                     assertTrue(least &lt;= j &amp;&amp; j &lt; bound);
351                     ++i;
352                 }
353                 assertTrue(i &lt; NCALLS);
354             }
355         }
356     }
357 
358     /**
359      * Invoking sized ints, long, doubles, with negative sizes throws
360      * IllegalArgumentException
361      */
362     public void testBadStreamSize() {
363         SplittableRandom r = new SplittableRandom();
<span class="line-modified">364         Runnable[] throwingActions = {</span>

365             () -&gt; { java.util.stream.IntStream x = r.ints(-1L); },
366             () -&gt; { java.util.stream.IntStream x = r.ints(-1L, 2, 3); },
367             () -&gt; { java.util.stream.LongStream x = r.longs(-1L); },
368             () -&gt; { java.util.stream.LongStream x = r.longs(-1L, -1L, 1L); },
369             () -&gt; { java.util.stream.DoubleStream x = r.doubles(-1L); },
<span class="line-modified">370             () -&gt; { java.util.stream.DoubleStream x = r.doubles(-1L, .5, .6); },</span>
<span class="line-removed">371         };</span>
<span class="line-removed">372         assertThrows(IllegalArgumentException.class, throwingActions);</span>
373     }
374 
375     /**
376      * Invoking bounded ints, long, doubles, with illegal bounds throws
377      * IllegalArgumentException
378      */
379     public void testBadStreamBounds() {
380         SplittableRandom r = new SplittableRandom();
<span class="line-modified">381         Runnable[] throwingActions = {</span>

382             () -&gt; { java.util.stream.IntStream x = r.ints(2, 1); },
383             () -&gt; { java.util.stream.IntStream x = r.ints(10, 42, 42); },
384             () -&gt; { java.util.stream.LongStream x = r.longs(-1L, -1L); },
385             () -&gt; { java.util.stream.LongStream x = r.longs(10, 1L, -2L); },
386             () -&gt; { java.util.stream.DoubleStream x = r.doubles(0.0, 0.0); },
<span class="line-modified">387             () -&gt; { java.util.stream.DoubleStream x = r.doubles(10, .5, .4); },</span>
<span class="line-removed">388         };</span>
<span class="line-removed">389         assertThrows(IllegalArgumentException.class, throwingActions);</span>
390     }
391 
392     /**
393      * A parallel sized stream of ints generates the given number of values
394      */
395     public void testIntsCount() {
396         LongAdder counter = new LongAdder();
397         SplittableRandom r = new SplittableRandom();
398         long size = 0;
399         for (int reps = 0; reps &lt; REPS; ++reps) {
400             counter.reset();
401             r.ints(size).parallel().forEach(x -&gt; counter.increment());
402             assertEquals(size, counter.sum());
403             size += 524959;
404         }
405     }
406 
407     /**
408      * A parallel sized stream of longs generates the given number of values
409      */
</pre>
</td>
<td>
<hr />
<pre>
148     /**
149      * A SplittableRandom produced by split() of a seeded-constructed
150      * SplittableRandom generates a different sequence
151      */
152     public void testSplit2() {
153         SplittableRandom sr = new SplittableRandom(12345);
154         for (int reps = 0; reps &lt; REPS; ++reps) {
155             SplittableRandom sc = sr.split();
156             int i = 0;
157             while (i &lt; NCALLS &amp;&amp; sr.nextLong() == sc.nextLong())
158                 ++i;
159             assertTrue(i &lt; NCALLS);
160         }
161     }
162 
163     /**
164      * nextInt(non-positive) throws IllegalArgumentException
165      */
166     public void testNextIntBoundNonPositive() {
167         SplittableRandom sr = new SplittableRandom();
<span class="line-modified">168         assertThrows(</span>
<span class="line-added">169             IllegalArgumentException.class,</span>
170             () -&gt; sr.nextInt(-17),
171             () -&gt; sr.nextInt(0),
<span class="line-modified">172             () -&gt; sr.nextInt(Integer.MIN_VALUE));</span>


173     }
174 
175     /**
176      * nextInt(least &gt;= bound) throws IllegalArgumentException
177      */
178     public void testNextIntBadBounds() {
179         SplittableRandom sr = new SplittableRandom();
<span class="line-modified">180         assertThrows(</span>
<span class="line-added">181             IllegalArgumentException.class,</span>
182             () -&gt; sr.nextInt(17, 2),
183             () -&gt; sr.nextInt(-42, -42),
<span class="line-modified">184             () -&gt; sr.nextInt(Integer.MAX_VALUE, Integer.MIN_VALUE));</span>


185     }
186 
187     /**
188      * nextInt(bound) returns 0 &lt;= value &lt; bound;
189      * repeated calls produce at least two distinct results
190      */
191     public void testNextIntBounded() {
192         SplittableRandom sr = new SplittableRandom();
193         for (int i = 0; i &lt; 2; i++) assertEquals(0, sr.nextInt(1));
194         // sample bound space across prime number increments
195         for (int bound = 2; bound &lt; MAX_INT_BOUND; bound += 524959) {
196             int f = sr.nextInt(bound);
197             assertTrue(0 &lt;= f &amp;&amp; f &lt; bound);
198             int i = 0;
199             int j;
200             while (i &lt; NCALLS &amp;&amp;
201                    (j = sr.nextInt(bound)) == f) {
202                 assertTrue(0 &lt;= j &amp;&amp; j &lt; bound);
203                 ++i;
204             }
</pre>
<hr />
<pre>
216             for (int bound = least + 2; bound &gt; least &amp;&amp; bound &lt; MAX_INT_BOUND; bound += 49979687) {
217                 int f = sr.nextInt(least, bound);
218                 assertTrue(least &lt;= f &amp;&amp; f &lt; bound);
219                 int i = 0;
220                 int j;
221                 while (i &lt; NCALLS &amp;&amp;
222                        (j = sr.nextInt(least, bound)) == f) {
223                     assertTrue(least &lt;= j &amp;&amp; j &lt; bound);
224                     ++i;
225                 }
226                 assertTrue(i &lt; NCALLS);
227             }
228         }
229     }
230 
231     /**
232      * nextLong(non-positive) throws IllegalArgumentException
233      */
234     public void testNextLongBoundNonPositive() {
235         SplittableRandom sr = new SplittableRandom();
<span class="line-modified">236         assertThrows(</span>
<span class="line-added">237             IllegalArgumentException.class,</span>
238             () -&gt; sr.nextLong(-17L),
239             () -&gt; sr.nextLong(0L),
<span class="line-modified">240             () -&gt; sr.nextLong(Long.MIN_VALUE));</span>


241     }
242 
243     /**
244      * nextLong(least &gt;= bound) throws IllegalArgumentException
245      */
246     public void testNextLongBadBounds() {
247         SplittableRandom sr = new SplittableRandom();
<span class="line-modified">248         assertThrows(</span>
<span class="line-added">249             IllegalArgumentException.class,</span>
250             () -&gt; sr.nextLong(17L, 2L),
251             () -&gt; sr.nextLong(-42L, -42L),
<span class="line-modified">252             () -&gt; sr.nextLong(Long.MAX_VALUE, Long.MIN_VALUE));</span>


253     }
254 
255     /**
256      * nextLong(bound) returns 0 &lt;= value &lt; bound;
257      * repeated calls produce at least two distinct results
258      */
259     public void testNextLongBounded() {
260         SplittableRandom sr = new SplittableRandom();
261         for (int i = 0; i &lt; 2; i++) assertEquals(0L, sr.nextLong(1L));
262         for (long bound = 2; bound &lt; MAX_LONG_BOUND; bound += 15485863) {
263             long f = sr.nextLong(bound);
264             assertTrue(0 &lt;= f &amp;&amp; f &lt; bound);
265             int i = 0;
266             long j;
267             while (i &lt; NCALLS &amp;&amp;
268                    (j = sr.nextLong(bound)) == f) {
269                 assertTrue(0 &lt;= j &amp;&amp; j &lt; bound);
270                 ++i;
271             }
272             assertTrue(i &lt; NCALLS);
</pre>
<hr />
<pre>
283             for (long bound = least + 2; bound &gt; least &amp;&amp; bound &lt; MAX_LONG_BOUND; bound += Math.abs(bound * 7919)) {
284                 long f = sr.nextLong(least, bound);
285                 assertTrue(least &lt;= f &amp;&amp; f &lt; bound);
286                 int i = 0;
287                 long j;
288                 while (i &lt; NCALLS &amp;&amp;
289                        (j = sr.nextLong(least, bound)) == f) {
290                     assertTrue(least &lt;= j &amp;&amp; j &lt; bound);
291                     ++i;
292                 }
293                 assertTrue(i &lt; NCALLS);
294             }
295         }
296     }
297 
298     /**
299      * nextDouble(non-positive) throws IllegalArgumentException
300      */
301     public void testNextDoubleBoundNonPositive() {
302         SplittableRandom sr = new SplittableRandom();
<span class="line-modified">303         assertThrows(</span>
<span class="line-added">304             IllegalArgumentException.class,</span>
305             () -&gt; sr.nextDouble(-17.0d),
306             () -&gt; sr.nextDouble(0.0d),
307             () -&gt; sr.nextDouble(-Double.MIN_VALUE),
308             () -&gt; sr.nextDouble(Double.NEGATIVE_INFINITY),
<span class="line-modified">309             () -&gt; sr.nextDouble(Double.NaN));</span>


310     }
311 
312     /**
313      * nextDouble(! (least &lt; bound)) throws IllegalArgumentException
314      */
315     public void testNextDoubleBadBounds() {
316         SplittableRandom sr = new SplittableRandom();
<span class="line-modified">317         assertThrows(</span>
<span class="line-added">318             IllegalArgumentException.class,</span>
319             () -&gt; sr.nextDouble(17.0d, 2.0d),
320             () -&gt; sr.nextDouble(-42.0d, -42.0d),
321             () -&gt; sr.nextDouble(Double.MAX_VALUE, Double.MIN_VALUE),
322             () -&gt; sr.nextDouble(Double.NaN, 0.0d),
<span class="line-modified">323             () -&gt; sr.nextDouble(0.0d, Double.NaN));</span>


324     }
325 
326     // TODO: Test infinite bounds!
327     //() -&gt; sr.nextDouble(Double.NEGATIVE_INFINITY, 0.0d),
328     //() -&gt; sr.nextDouble(0.0d, Double.POSITIVE_INFINITY),
329 
330     /**
331      * nextDouble(least, bound) returns least &lt;= value &lt; bound;
332      * repeated calls produce at least two distinct results
333      */
334     public void testNextDoubleBounded2() {
335         SplittableRandom sr = new SplittableRandom();
336         for (double least = 0.0001; least &lt; 1.0e20; least *= 8) {
337             for (double bound = least * 1.001; bound &lt; 1.0e20; bound *= 16) {
338                 double f = sr.nextDouble(least, bound);
339                 assertTrue(least &lt;= f &amp;&amp; f &lt; bound);
340                 int i = 0;
341                 double j;
342                 while (i &lt; NCALLS &amp;&amp;
343                        (j = sr.nextDouble(least, bound)) == f) {
344                     assertTrue(least &lt;= j &amp;&amp; j &lt; bound);
345                     ++i;
346                 }
347                 assertTrue(i &lt; NCALLS);
348             }
349         }
350     }
351 
352     /**
353      * Invoking sized ints, long, doubles, with negative sizes throws
354      * IllegalArgumentException
355      */
356     public void testBadStreamSize() {
357         SplittableRandom r = new SplittableRandom();
<span class="line-modified">358         assertThrows(</span>
<span class="line-added">359             IllegalArgumentException.class,</span>
360             () -&gt; { java.util.stream.IntStream x = r.ints(-1L); },
361             () -&gt; { java.util.stream.IntStream x = r.ints(-1L, 2, 3); },
362             () -&gt; { java.util.stream.LongStream x = r.longs(-1L); },
363             () -&gt; { java.util.stream.LongStream x = r.longs(-1L, -1L, 1L); },
364             () -&gt; { java.util.stream.DoubleStream x = r.doubles(-1L); },
<span class="line-modified">365             () -&gt; { java.util.stream.DoubleStream x = r.doubles(-1L, .5, .6); });</span>


366     }
367 
368     /**
369      * Invoking bounded ints, long, doubles, with illegal bounds throws
370      * IllegalArgumentException
371      */
372     public void testBadStreamBounds() {
373         SplittableRandom r = new SplittableRandom();
<span class="line-modified">374         assertThrows(</span>
<span class="line-added">375             IllegalArgumentException.class,</span>
376             () -&gt; { java.util.stream.IntStream x = r.ints(2, 1); },
377             () -&gt; { java.util.stream.IntStream x = r.ints(10, 42, 42); },
378             () -&gt; { java.util.stream.LongStream x = r.longs(-1L, -1L); },
379             () -&gt; { java.util.stream.LongStream x = r.longs(10, 1L, -2L); },
380             () -&gt; { java.util.stream.DoubleStream x = r.doubles(0.0, 0.0); },
<span class="line-modified">381             () -&gt; { java.util.stream.DoubleStream x = r.doubles(10, .5, .4); });</span>


382     }
383 
384     /**
385      * A parallel sized stream of ints generates the given number of values
386      */
387     public void testIntsCount() {
388         LongAdder counter = new LongAdder();
389         SplittableRandom r = new SplittableRandom();
390         long size = 0;
391         for (int reps = 0; reps &lt; REPS; ++reps) {
392             counter.reset();
393             r.ints(size).parallel().forEach(x -&gt; counter.increment());
394             assertEquals(size, counter.sum());
395             size += 524959;
396         }
397     }
398 
399     /**
400      * A parallel sized stream of longs generates the given number of values
401      */
</pre>
</td>
</tr>
</table>
<center><a href="SemaphoreTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StampedLockTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
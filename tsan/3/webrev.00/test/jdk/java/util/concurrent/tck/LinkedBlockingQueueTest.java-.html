<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/util/concurrent/tck/LinkedBlockingQueueTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea with assistance from members of JCP JSR-166
 30  * Expert Group and released to the public domain, as explained at
 31  * http://creativecommons.org/publicdomain/zero/1.0/
 32  * Other contributors include Andrew Wright, Jeffrey Hayes,
 33  * Pat Fisher, Mike Judd.
 34  */
 35 
 36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 37 
 38 import java.util.ArrayList;
 39 import java.util.Arrays;
 40 import java.util.Collection;
 41 import java.util.Iterator;
 42 import java.util.NoSuchElementException;
 43 import java.util.Queue;
 44 import java.util.concurrent.BlockingQueue;
 45 import java.util.concurrent.CountDownLatch;
 46 import java.util.concurrent.Executors;
 47 import java.util.concurrent.ExecutorService;
 48 import java.util.concurrent.LinkedBlockingQueue;
 49 
 50 import junit.framework.Test;
 51 
 52 public class LinkedBlockingQueueTest extends JSR166TestCase {
 53 
 54     public static class Unbounded extends BlockingQueueTest {
 55         protected BlockingQueue emptyCollection() {
 56             return new LinkedBlockingQueue();
 57         }
 58     }
 59 
 60     public static class Bounded extends BlockingQueueTest {
 61         protected BlockingQueue emptyCollection() {
 62             return new LinkedBlockingQueue(SIZE);
 63         }
 64     }
 65 
 66     public static void main(String[] args) {
 67         main(suite(), args);
 68     }
 69 
 70     public static Test suite() {
 71         class Implementation implements CollectionImplementation {
 72             public Class&lt;?&gt; klazz() { return LinkedBlockingQueue.class; }
 73             public Collection emptyCollection() { return new LinkedBlockingQueue(); }
 74             public Object makeElement(int i) { return i; }
 75             public boolean isConcurrent() { return true; }
 76             public boolean permitsNulls() { return false; }
 77         }
 78         return newTestSuite(LinkedBlockingQueueTest.class,
 79                             new Unbounded().testSuite(),
 80                             new Bounded().testSuite(),
 81                             CollectionTest.testSuite(new Implementation()));
 82     }
 83 
 84     /**
 85      * Returns a new queue of given size containing consecutive
 86      * Integers 0 ... n - 1.
 87      */
 88     private static LinkedBlockingQueue&lt;Integer&gt; populatedQueue(int n) {
 89         LinkedBlockingQueue&lt;Integer&gt; q = new LinkedBlockingQueue&lt;&gt;(n);
 90         assertTrue(q.isEmpty());
 91         for (int i = 0; i &lt; n; i++)
 92             assertTrue(q.offer(new Integer(i)));
 93         assertFalse(q.isEmpty());
 94         assertEquals(0, q.remainingCapacity());
 95         assertEquals(n, q.size());
 96         assertEquals((Integer) 0, q.peek());
 97         return q;
 98     }
 99 
100     /**
101      * A new queue has the indicated capacity, or Integer.MAX_VALUE if
102      * none given
103      */
104     public void testConstructor1() {
105         assertEquals(SIZE, new LinkedBlockingQueue(SIZE).remainingCapacity());
106         assertEquals(Integer.MAX_VALUE, new LinkedBlockingQueue().remainingCapacity());
107     }
108 
109     /**
110      * Constructor throws IllegalArgumentException if capacity argument nonpositive
111      */
112     public void testConstructor2() {
113         try {
114             new LinkedBlockingQueue(0);
115             shouldThrow();
116         } catch (IllegalArgumentException success) {}
117     }
118 
119     /**
120      * Initializing from null Collection throws NullPointerException
121      */
122     public void testConstructor3() {
123         try {
124             new LinkedBlockingQueue(null);
125             shouldThrow();
126         } catch (NullPointerException success) {}
127     }
128 
129     /**
130      * Initializing from Collection of null elements throws NullPointerException
131      */
132     public void testConstructor4() {
133         Collection&lt;Integer&gt; elements = Arrays.asList(new Integer[SIZE]);
134         try {
135             new LinkedBlockingQueue(elements);
136             shouldThrow();
137         } catch (NullPointerException success) {}
138     }
139 
140     /**
141      * Initializing from Collection with some null elements throws
142      * NullPointerException
143      */
144     public void testConstructor5() {
145         Integer[] ints = new Integer[SIZE];
146         for (int i = 0; i &lt; SIZE - 1; ++i)
147             ints[i] = new Integer(i);
148         Collection&lt;Integer&gt; elements = Arrays.asList(ints);
149         try {
150             new LinkedBlockingQueue(elements);
151             shouldThrow();
152         } catch (NullPointerException success) {}
153     }
154 
155     /**
156      * Queue contains all elements of collection used to initialize
157      */
158     public void testConstructor6() {
159         Integer[] ints = new Integer[SIZE];
160         for (int i = 0; i &lt; SIZE; ++i)
161             ints[i] = new Integer(i);
162         LinkedBlockingQueue q = new LinkedBlockingQueue(Arrays.asList(ints));
163         for (int i = 0; i &lt; SIZE; ++i)
164             assertEquals(ints[i], q.poll());
165     }
166 
167     /**
168      * Queue transitions from empty to full when elements added
169      */
170     public void testEmptyFull() {
171         LinkedBlockingQueue q = new LinkedBlockingQueue(2);
172         assertTrue(q.isEmpty());
173         assertEquals(&quot;should have room for 2&quot;, 2, q.remainingCapacity());
174         q.add(one);
175         assertFalse(q.isEmpty());
176         q.add(two);
177         assertFalse(q.isEmpty());
178         assertEquals(0, q.remainingCapacity());
179         assertFalse(q.offer(three));
180     }
181 
182     /**
183      * remainingCapacity decreases on add, increases on remove
184      */
185     public void testRemainingCapacity() {
186         BlockingQueue q = populatedQueue(SIZE);
187         for (int i = 0; i &lt; SIZE; ++i) {
188             assertEquals(i, q.remainingCapacity());
189             assertEquals(SIZE, q.size() + q.remainingCapacity());
190             assertEquals(i, q.remove());
191         }
192         for (int i = 0; i &lt; SIZE; ++i) {
193             assertEquals(SIZE - i, q.remainingCapacity());
194             assertEquals(SIZE, q.size() + q.remainingCapacity());
195             assertTrue(q.add(i));
196         }
197     }
198 
199     /**
200      * Offer succeeds if not full; fails if full
201      */
202     public void testOffer() {
203         LinkedBlockingQueue q = new LinkedBlockingQueue(1);
204         assertTrue(q.offer(zero));
205         assertFalse(q.offer(one));
206     }
207 
208     /**
209      * add succeeds if not full; throws IllegalStateException if full
210      */
211     public void testAdd() {
212         LinkedBlockingQueue q = new LinkedBlockingQueue(SIZE);
213         for (int i = 0; i &lt; SIZE; ++i)
214             assertTrue(q.add(new Integer(i)));
215         assertEquals(0, q.remainingCapacity());
216         try {
217             q.add(new Integer(SIZE));
218             shouldThrow();
219         } catch (IllegalStateException success) {}
220     }
221 
222     /**
223      * addAll(this) throws IllegalArgumentException
224      */
225     public void testAddAllSelf() {
226         LinkedBlockingQueue q = populatedQueue(SIZE);
227         try {
228             q.addAll(q);
229             shouldThrow();
230         } catch (IllegalArgumentException success) {}
231     }
232 
233     /**
234      * addAll of a collection with any null elements throws NPE after
235      * possibly adding some elements
236      */
237     public void testAddAll3() {
238         LinkedBlockingQueue q = new LinkedBlockingQueue(SIZE);
239         Integer[] ints = new Integer[SIZE];
240         for (int i = 0; i &lt; SIZE - 1; ++i)
241             ints[i] = new Integer(i);
242         Collection&lt;Integer&gt; elements = Arrays.asList(ints);
243         try {
244             q.addAll(elements);
245             shouldThrow();
246         } catch (NullPointerException success) {}
247     }
248 
249     /**
250      * addAll throws IllegalStateException if not enough room
251      */
252     public void testAddAll4() {
253         LinkedBlockingQueue q = new LinkedBlockingQueue(SIZE - 1);
254         Integer[] ints = new Integer[SIZE];
255         for (int i = 0; i &lt; SIZE; ++i)
256             ints[i] = new Integer(i);
257         Collection&lt;Integer&gt; elements = Arrays.asList(ints);
258         try {
259             q.addAll(elements);
260             shouldThrow();
261         } catch (IllegalStateException success) {}
262     }
263 
264     /**
265      * Queue contains all elements, in traversal order, of successful addAll
266      */
267     public void testAddAll5() {
268         Integer[] empty = new Integer[0];
269         Integer[] ints = new Integer[SIZE];
270         for (int i = 0; i &lt; SIZE; ++i)
271             ints[i] = new Integer(i);
272         LinkedBlockingQueue q = new LinkedBlockingQueue(SIZE);
273         assertFalse(q.addAll(Arrays.asList(empty)));
274         assertTrue(q.addAll(Arrays.asList(ints)));
275         for (int i = 0; i &lt; SIZE; ++i)
276             assertEquals(ints[i], q.poll());
277     }
278 
279     /**
280      * all elements successfully put are contained
281      */
282     public void testPut() throws InterruptedException {
283         LinkedBlockingQueue q = new LinkedBlockingQueue(SIZE);
284         for (int i = 0; i &lt; SIZE; ++i) {
285             Integer x = new Integer(i);
286             q.put(x);
287             assertTrue(q.contains(x));
288         }
289         assertEquals(0, q.remainingCapacity());
290     }
291 
292     /**
293      * put blocks interruptibly if full
294      */
295     public void testBlockingPut() throws InterruptedException {
296         final LinkedBlockingQueue q = new LinkedBlockingQueue(SIZE);
297         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
298         Thread t = newStartedThread(new CheckedRunnable() {
299             public void realRun() throws InterruptedException {
300                 for (int i = 0; i &lt; SIZE; ++i)
301                     q.put(i);
302                 assertEquals(SIZE, q.size());
303                 assertEquals(0, q.remainingCapacity());
304 
305                 Thread.currentThread().interrupt();
306                 try {
307                     q.put(99);
308                     shouldThrow();
309                 } catch (InterruptedException success) {}
310                 assertFalse(Thread.interrupted());
311 
312                 pleaseInterrupt.countDown();
313                 try {
314                     q.put(99);
315                     shouldThrow();
316                 } catch (InterruptedException success) {}
317                 assertFalse(Thread.interrupted());
318             }});
319 
320         await(pleaseInterrupt);
321         assertThreadBlocks(t, Thread.State.WAITING);
322         t.interrupt();
323         awaitTermination(t);
324         assertEquals(SIZE, q.size());
325         assertEquals(0, q.remainingCapacity());
326     }
327 
328     /**
329      * put blocks interruptibly waiting for take when full
330      */
331     public void testPutWithTake() throws InterruptedException {
332         final int capacity = 2;
333         final LinkedBlockingQueue q = new LinkedBlockingQueue(2);
334         final CountDownLatch pleaseTake = new CountDownLatch(1);
335         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
336         Thread t = newStartedThread(new CheckedRunnable() {
337             public void realRun() throws InterruptedException {
338                 for (int i = 0; i &lt; capacity; i++)
339                     q.put(i);
340                 pleaseTake.countDown();
341                 q.put(86);
342 
343                 Thread.currentThread().interrupt();
344                 try {
345                     q.put(99);
346                     shouldThrow();
347                 } catch (InterruptedException success) {}
348                 assertFalse(Thread.interrupted());
349 
350                 pleaseInterrupt.countDown();
351                 try {
352                     q.put(99);
353                     shouldThrow();
354                 } catch (InterruptedException success) {}
355                 assertFalse(Thread.interrupted());
356             }});
357 
358         await(pleaseTake);
359         assertEquals(0, q.remainingCapacity());
360         assertEquals(0, q.take());
361 
362         await(pleaseInterrupt);
363         assertThreadBlocks(t, Thread.State.WAITING);
364         t.interrupt();
365         awaitTermination(t);
366         assertEquals(0, q.remainingCapacity());
367     }
368 
369     /**
370      * timed offer times out if full and elements not taken
371      */
372     public void testTimedOffer() {
373         final LinkedBlockingQueue q = new LinkedBlockingQueue(2);
374         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
375         Thread t = newStartedThread(new CheckedRunnable() {
376             public void realRun() throws InterruptedException {
377                 q.put(new Object());
378                 q.put(new Object());
379 
380                 long startTime = System.nanoTime();
381                 assertFalse(q.offer(new Object(), timeoutMillis(), MILLISECONDS));
382                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
383 
384                 Thread.currentThread().interrupt();
385                 try {
386                     q.offer(new Object(), 2 * LONG_DELAY_MS, MILLISECONDS);
387                     shouldThrow();
388                 } catch (InterruptedException success) {}
389                 assertFalse(Thread.interrupted());
390 
391                 pleaseInterrupt.countDown();
392                 try {
393                     q.offer(new Object(), 2 * LONG_DELAY_MS, MILLISECONDS);
394                     shouldThrow();
395                 } catch (InterruptedException success) {}
396                 assertFalse(Thread.interrupted());
397             }});
398 
399         await(pleaseInterrupt);
400         assertThreadBlocks(t, Thread.State.TIMED_WAITING);
401         t.interrupt();
402         awaitTermination(t);
403     }
404 
405     /**
406      * take retrieves elements in FIFO order
407      */
408     public void testTake() throws InterruptedException {
409         LinkedBlockingQueue q = populatedQueue(SIZE);
410         for (int i = 0; i &lt; SIZE; ++i) {
411             assertEquals(i, q.take());
412         }
413     }
414 
415     /**
416      * Take removes existing elements until empty, then blocks interruptibly
417      */
418     public void testBlockingTake() throws InterruptedException {
419         final BlockingQueue q = populatedQueue(SIZE);
420         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
421         Thread t = newStartedThread(new CheckedRunnable() {
422             public void realRun() throws InterruptedException {
423                 for (int i = 0; i &lt; SIZE; i++) assertEquals(i, q.take());
424 
425                 Thread.currentThread().interrupt();
426                 try {
427                     q.take();
428                     shouldThrow();
429                 } catch (InterruptedException success) {}
430                 assertFalse(Thread.interrupted());
431 
432                 pleaseInterrupt.countDown();
433                 try {
434                     q.take();
435                     shouldThrow();
436                 } catch (InterruptedException success) {}
437                 assertFalse(Thread.interrupted());
438             }});
439 
440         await(pleaseInterrupt);
441         assertThreadBlocks(t, Thread.State.WAITING);
442         t.interrupt();
443         awaitTermination(t);
444     }
445 
446     /**
447      * poll succeeds unless empty
448      */
449     public void testPoll() {
450         LinkedBlockingQueue q = populatedQueue(SIZE);
451         for (int i = 0; i &lt; SIZE; ++i) {
452             assertEquals(i, q.poll());
453         }
454         assertNull(q.poll());
455     }
456 
457     /**
458      * timed poll with zero timeout succeeds when non-empty, else times out
459      */
460     public void testTimedPoll0() throws InterruptedException {
461         LinkedBlockingQueue q = populatedQueue(SIZE);
462         for (int i = 0; i &lt; SIZE; ++i) {
463             assertEquals(i, q.poll(0, MILLISECONDS));
464         }
465         assertNull(q.poll(0, MILLISECONDS));
466     }
467 
468     /**
469      * timed poll with nonzero timeout succeeds when non-empty, else times out
470      */
471     public void testTimedPoll() throws InterruptedException {
472         LinkedBlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
473         for (int i = 0; i &lt; SIZE; ++i) {
474             long startTime = System.nanoTime();
475             assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
476             assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
477         }
478         long startTime = System.nanoTime();
479         assertNull(q.poll(timeoutMillis(), MILLISECONDS));
480         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
481         checkEmpty(q);
482     }
483 
484     /**
485      * Interrupted timed poll throws InterruptedException instead of
486      * returning timeout status
487      */
488     public void testInterruptedTimedPoll() throws InterruptedException {
489         final BlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
490         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
491         Thread t = newStartedThread(new CheckedRunnable() {
492             public void realRun() throws InterruptedException {
493                 long startTime = System.nanoTime();
494                 for (int i = 0; i &lt; SIZE; i++)
495                     assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
496 
497                 Thread.currentThread().interrupt();
498                 try {
499                     q.poll(LONG_DELAY_MS, MILLISECONDS);
500                     shouldThrow();
501                 } catch (InterruptedException success) {}
502                 assertFalse(Thread.interrupted());
503 
504                 pleaseInterrupt.countDown();
505                 try {
506                     q.poll(LONG_DELAY_MS, MILLISECONDS);
507                     shouldThrow();
508                 } catch (InterruptedException success) {}
509                 assertFalse(Thread.interrupted());
510 
511                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
512             }});
513 
514         await(pleaseInterrupt);
515         assertThreadBlocks(t, Thread.State.TIMED_WAITING);
516         t.interrupt();
517         awaitTermination(t);
518         checkEmpty(q);
519     }
520 
521     /**
522      * peek returns next element, or null if empty
523      */
524     public void testPeek() {
525         LinkedBlockingQueue q = populatedQueue(SIZE);
526         for (int i = 0; i &lt; SIZE; ++i) {
527             assertEquals(i, q.peek());
528             assertEquals(i, q.poll());
529             assertTrue(q.peek() == null ||
530                        !q.peek().equals(i));
531         }
532         assertNull(q.peek());
533     }
534 
535     /**
536      * element returns next element, or throws NSEE if empty
537      */
538     public void testElement() {
539         LinkedBlockingQueue q = populatedQueue(SIZE);
540         for (int i = 0; i &lt; SIZE; ++i) {
541             assertEquals(i, q.element());
542             assertEquals(i, q.poll());
543         }
544         try {
545             q.element();
546             shouldThrow();
547         } catch (NoSuchElementException success) {}
548     }
549 
550     /**
551      * remove removes next element, or throws NSEE if empty
552      */
553     public void testRemove() {
554         LinkedBlockingQueue q = populatedQueue(SIZE);
555         for (int i = 0; i &lt; SIZE; ++i) {
556             assertEquals(i, q.remove());
557         }
558         try {
559             q.remove();
560             shouldThrow();
561         } catch (NoSuchElementException success) {}
562     }
563 
564     /**
565      * An add following remove(x) succeeds
566      */
567     public void testRemoveElementAndAdd() throws InterruptedException {
568         LinkedBlockingQueue q = new LinkedBlockingQueue();
569         assertTrue(q.add(new Integer(1)));
570         assertTrue(q.add(new Integer(2)));
571         assertTrue(q.remove(new Integer(1)));
572         assertTrue(q.remove(new Integer(2)));
573         assertTrue(q.add(new Integer(3)));
574         assertNotNull(q.take());
575     }
576 
577     /**
578      * contains(x) reports true when elements added but not yet removed
579      */
580     public void testContains() {
581         LinkedBlockingQueue q = populatedQueue(SIZE);
582         for (int i = 0; i &lt; SIZE; ++i) {
583             assertTrue(q.contains(new Integer(i)));
584             q.poll();
585             assertFalse(q.contains(new Integer(i)));
586         }
587     }
588 
589     /**
590      * clear removes all elements
591      */
592     public void testClear() {
593         LinkedBlockingQueue q = populatedQueue(SIZE);
594         q.clear();
595         assertTrue(q.isEmpty());
596         assertEquals(0, q.size());
597         assertEquals(SIZE, q.remainingCapacity());
598         q.add(one);
599         assertFalse(q.isEmpty());
600         assertTrue(q.contains(one));
601         q.clear();
602         assertTrue(q.isEmpty());
603     }
604 
605     /**
606      * containsAll(c) is true when c contains a subset of elements
607      */
608     public void testContainsAll() {
609         LinkedBlockingQueue q = populatedQueue(SIZE);
610         LinkedBlockingQueue p = new LinkedBlockingQueue(SIZE);
611         for (int i = 0; i &lt; SIZE; ++i) {
612             assertTrue(q.containsAll(p));
613             assertFalse(p.containsAll(q));
614             p.add(new Integer(i));
615         }
616         assertTrue(p.containsAll(q));
617     }
618 
619     /**
620      * retainAll(c) retains only those elements of c and reports true if changed
621      */
622     public void testRetainAll() {
623         LinkedBlockingQueue q = populatedQueue(SIZE);
624         LinkedBlockingQueue p = populatedQueue(SIZE);
625         for (int i = 0; i &lt; SIZE; ++i) {
626             boolean changed = q.retainAll(p);
627             if (i == 0)
628                 assertFalse(changed);
629             else
630                 assertTrue(changed);
631 
632             assertTrue(q.containsAll(p));
633             assertEquals(SIZE - i, q.size());
634             p.remove();
635         }
636     }
637 
638     /**
639      * removeAll(c) removes only those elements of c and reports true if changed
640      */
641     public void testRemoveAll() {
642         for (int i = 1; i &lt; SIZE; ++i) {
643             LinkedBlockingQueue q = populatedQueue(SIZE);
644             LinkedBlockingQueue p = populatedQueue(i);
645             assertTrue(q.removeAll(p));
646             assertEquals(SIZE - i, q.size());
647             for (int j = 0; j &lt; i; ++j) {
648                 Integer x = (Integer)(p.remove());
649                 assertFalse(q.contains(x));
650             }
651         }
652     }
653 
654     /**
655      * toArray contains all elements in FIFO order
656      */
657     public void testToArray() {
658         LinkedBlockingQueue q = populatedQueue(SIZE);
659         Object[] a = q.toArray();
660         assertSame(Object[].class, a.getClass());
661         for (Object o : a)
662             assertSame(o, q.poll());
663         assertTrue(q.isEmpty());
664     }
665 
666     /**
667      * toArray(a) contains all elements in FIFO order
668      */
669     public void testToArray2() throws InterruptedException {
670         LinkedBlockingQueue&lt;Integer&gt; q = populatedQueue(SIZE);
671         Integer[] ints = new Integer[SIZE];
672         Integer[] array = q.toArray(ints);
673         assertSame(ints, array);
674         for (Integer o : ints)
675             assertSame(o, q.poll());
676         assertTrue(q.isEmpty());
677     }
678 
679     /**
680      * toArray(incompatible array type) throws ArrayStoreException
681      */
682     public void testToArray1_BadArg() {
683         LinkedBlockingQueue q = populatedQueue(SIZE);
684         try {
685             q.toArray(new String[10]);
686             shouldThrow();
687         } catch (ArrayStoreException success) {}
688     }
689 
690     /**
691      * iterator iterates through all elements
692      */
693     public void testIterator() throws InterruptedException {
694         LinkedBlockingQueue q = populatedQueue(SIZE);
695         Iterator it = q.iterator();
696         int i;
697         for (i = 0; it.hasNext(); i++)
698             assertTrue(q.contains(it.next()));
699         assertEquals(i, SIZE);
700         assertIteratorExhausted(it);
701 
702         it = q.iterator();
703         for (i = 0; it.hasNext(); i++)
704             assertEquals(it.next(), q.take());
705         assertEquals(i, SIZE);
706         assertIteratorExhausted(it);
707     }
708 
709     /**
710      * iterator of empty collection has no elements
711      */
712     public void testEmptyIterator() {
713         assertIteratorExhausted(new LinkedBlockingQueue().iterator());
714     }
715 
716     /**
717      * iterator.remove removes current element
718      */
719     public void testIteratorRemove() {
720         final LinkedBlockingQueue q = new LinkedBlockingQueue(3);
721         q.add(two);
722         q.add(one);
723         q.add(three);
724 
725         Iterator it = q.iterator();
726         it.next();
727         it.remove();
728 
729         it = q.iterator();
730         assertSame(it.next(), one);
731         assertSame(it.next(), three);
732         assertFalse(it.hasNext());
733     }
734 
735     /**
736      * iterator ordering is FIFO
737      */
738     public void testIteratorOrdering() {
739         final LinkedBlockingQueue q = new LinkedBlockingQueue(3);
740         q.add(one);
741         q.add(two);
742         q.add(three);
743         assertEquals(0, q.remainingCapacity());
744         int k = 0;
745         for (Iterator it = q.iterator(); it.hasNext();) {
746             assertEquals(++k, it.next());
747         }
748         assertEquals(3, k);
749     }
750 
751     /**
752      * Modifications do not cause iterators to fail
753      */
754     public void testWeaklyConsistentIteration() {
755         final LinkedBlockingQueue q = new LinkedBlockingQueue(3);
756         q.add(one);
757         q.add(two);
758         q.add(three);
759         for (Iterator it = q.iterator(); it.hasNext();) {
760             q.remove();
761             it.next();
762         }
763         assertEquals(0, q.size());
764     }
765 
766     /**
767      * toString contains toStrings of elements
768      */
769     public void testToString() {
770         LinkedBlockingQueue q = populatedQueue(SIZE);
771         String s = q.toString();
772         for (int i = 0; i &lt; SIZE; ++i) {
773             assertTrue(s.contains(String.valueOf(i)));
774         }
775     }
776 
777     /**
778      * offer transfers elements across Executor tasks
779      */
780     public void testOfferInExecutor() {
781         final LinkedBlockingQueue q = new LinkedBlockingQueue(2);
782         q.add(one);
783         q.add(two);
784         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
785         final ExecutorService executor = Executors.newFixedThreadPool(2);
786         try (PoolCleaner cleaner = cleaner(executor)) {
787             executor.execute(new CheckedRunnable() {
788                 public void realRun() throws InterruptedException {
789                     assertFalse(q.offer(three));
790                     threadsStarted.await();
791                     assertTrue(q.offer(three, LONG_DELAY_MS, MILLISECONDS));
792                     assertEquals(0, q.remainingCapacity());
793                 }});
794 
795             executor.execute(new CheckedRunnable() {
796                 public void realRun() throws InterruptedException {
797                     threadsStarted.await();
798                     assertSame(one, q.take());
799                 }});
800         }
801     }
802 
803     /**
804      * timed poll retrieves elements across Executor threads
805      */
806     public void testPollInExecutor() {
807         final LinkedBlockingQueue q = new LinkedBlockingQueue(2);
808         final CheckedBarrier threadsStarted = new CheckedBarrier(2);
809         final ExecutorService executor = Executors.newFixedThreadPool(2);
810         try (PoolCleaner cleaner = cleaner(executor)) {
811             executor.execute(new CheckedRunnable() {
812                 public void realRun() throws InterruptedException {
813                     assertNull(q.poll());
814                     threadsStarted.await();
815                     assertSame(one, q.poll(LONG_DELAY_MS, MILLISECONDS));
816                     checkEmpty(q);
817                 }});
818 
819             executor.execute(new CheckedRunnable() {
820                 public void realRun() throws InterruptedException {
821                     threadsStarted.await();
822                     q.put(one);
823                 }});
824         }
825     }
826 
827     /**
828      * A deserialized/reserialized queue has same elements in same order
829      */
830     public void testSerialization() throws Exception {
831         Queue x = populatedQueue(SIZE);
832         Queue y = serialClone(x);
833 
834         assertNotSame(x, y);
835         assertEquals(x.size(), y.size());
836         assertEquals(x.toString(), y.toString());
837         assertTrue(Arrays.equals(x.toArray(), y.toArray()));
838         while (!x.isEmpty()) {
839             assertFalse(y.isEmpty());
840             assertEquals(x.remove(), y.remove());
841         }
842         assertTrue(y.isEmpty());
843     }
844 
845     /**
846      * drainTo(c) empties queue into another collection c
847      */
848     public void testDrainTo() {
849         LinkedBlockingQueue q = populatedQueue(SIZE);
850         ArrayList l = new ArrayList();
851         q.drainTo(l);
852         assertEquals(0, q.size());
853         assertEquals(SIZE, l.size());
854         for (int i = 0; i &lt; SIZE; ++i)
855             assertEquals(l.get(i), new Integer(i));
856         q.add(zero);
857         q.add(one);
858         assertFalse(q.isEmpty());
859         assertTrue(q.contains(zero));
860         assertTrue(q.contains(one));
861         l.clear();
862         q.drainTo(l);
863         assertEquals(0, q.size());
864         assertEquals(2, l.size());
865         for (int i = 0; i &lt; 2; ++i)
866             assertEquals(l.get(i), new Integer(i));
867     }
868 
869     /**
870      * drainTo empties full queue, unblocking a waiting put.
871      */
872     public void testDrainToWithActivePut() throws InterruptedException {
873         final LinkedBlockingQueue q = populatedQueue(SIZE);
874         Thread t = new Thread(new CheckedRunnable() {
875             public void realRun() throws InterruptedException {
876                 q.put(new Integer(SIZE + 1));
877             }});
878 
879         t.start();
880         ArrayList l = new ArrayList();
881         q.drainTo(l);
882         assertTrue(l.size() &gt;= SIZE);
883         for (int i = 0; i &lt; SIZE; ++i)
884             assertEquals(l.get(i), new Integer(i));
885         t.join();
886         assertTrue(q.size() + l.size() &gt;= SIZE);
887     }
888 
889     /**
890      * drainTo(c, n) empties first min(n, size) elements of queue into c
891      */
892     public void testDrainToN() {
893         LinkedBlockingQueue q = new LinkedBlockingQueue();
894         for (int i = 0; i &lt; SIZE + 2; ++i) {
895             for (int j = 0; j &lt; SIZE; j++)
896                 assertTrue(q.offer(new Integer(j)));
897             ArrayList l = new ArrayList();
898             q.drainTo(l, i);
899             int k = (i &lt; SIZE) ? i : SIZE;
900             assertEquals(k, l.size());
901             assertEquals(SIZE - k, q.size());
902             for (int j = 0; j &lt; k; ++j)
903                 assertEquals(l.get(j), new Integer(j));
904             do {} while (q.poll() != null);
905         }
906     }
907 
908     /**
909      * remove(null), contains(null) always return false
910      */
911     public void testNeverContainsNull() {
912         Collection&lt;?&gt;[] qs = {
913             new LinkedBlockingQueue&lt;Object&gt;(),
914             populatedQueue(2),
915         };
916 
917         for (Collection&lt;?&gt; q : qs) {
918             assertFalse(q.contains(null));
919             assertFalse(q.remove(null));
920         }
921     }
922 
923 }
    </pre>
  </body>
</html>
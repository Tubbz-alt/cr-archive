<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/LinkedBlockingDequeTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="JSR166TestCase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LinkedBlockingQueueTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/LinkedBlockingDequeTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 614                     q.put(i);
 615                 assertEquals(SIZE, q.size());
 616                 assertEquals(0, q.remainingCapacity());
 617 
 618                 Thread.currentThread().interrupt();
 619                 try {
 620                     q.put(99);
 621                     shouldThrow();
 622                 } catch (InterruptedException success) {}
 623                 assertFalse(Thread.interrupted());
 624 
 625                 pleaseInterrupt.countDown();
 626                 try {
 627                     q.put(99);
 628                     shouldThrow();
 629                 } catch (InterruptedException success) {}
 630                 assertFalse(Thread.interrupted());
 631             }});
 632 
 633         await(pleaseInterrupt);
<span class="line-modified"> 634         assertThreadBlocks(t, Thread.State.WAITING);</span>
 635         t.interrupt();
 636         awaitTermination(t);
 637         assertEquals(SIZE, q.size());
 638         assertEquals(0, q.remainingCapacity());
 639     }
 640 
 641     /**
 642      * put blocks interruptibly waiting for take when full
 643      */
 644     public void testPutWithTake() throws InterruptedException {
 645         final int capacity = 2;
 646         final LinkedBlockingDeque q = new LinkedBlockingDeque(capacity);
 647         final CountDownLatch pleaseTake = new CountDownLatch(1);
 648         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 649         Thread t = newStartedThread(new CheckedRunnable() {
 650             public void realRun() throws InterruptedException {
 651                 for (int i = 0; i &lt; capacity; i++)
 652                     q.put(i);
 653                 pleaseTake.countDown();
 654                 q.put(86);
</pre>
<hr />
<pre>
 656                 Thread.currentThread().interrupt();
 657                 try {
 658                     q.put(99);
 659                     shouldThrow();
 660                 } catch (InterruptedException success) {}
 661                 assertFalse(Thread.interrupted());
 662 
 663                 pleaseInterrupt.countDown();
 664                 try {
 665                     q.put(99);
 666                     shouldThrow();
 667                 } catch (InterruptedException success) {}
 668                 assertFalse(Thread.interrupted());
 669             }});
 670 
 671         await(pleaseTake);
 672         assertEquals(0, q.remainingCapacity());
 673         assertEquals(0, q.take());
 674 
 675         await(pleaseInterrupt);
<span class="line-modified"> 676         assertThreadBlocks(t, Thread.State.WAITING);</span>
 677         t.interrupt();
 678         awaitTermination(t);
 679         assertEquals(0, q.remainingCapacity());
 680     }
 681 
 682     /**
 683      * timed offer times out if full and elements not taken
 684      */
 685     public void testTimedOffer() {
 686         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
 687         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 688         Thread t = newStartedThread(new CheckedRunnable() {
 689             public void realRun() throws InterruptedException {
 690                 q.put(new Object());
 691                 q.put(new Object());
 692                 long startTime = System.nanoTime();

 693                 assertFalse(q.offer(new Object(), timeoutMillis(), MILLISECONDS));
 694                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
 695 
 696                 Thread.currentThread().interrupt();
 697                 try {
<span class="line-modified"> 698                     q.offer(new Object(), 2 * LONG_DELAY_MS, MILLISECONDS);</span>
 699                     shouldThrow();
 700                 } catch (InterruptedException success) {}
 701                 assertFalse(Thread.interrupted());
 702 
 703                 pleaseInterrupt.countDown();
 704                 try {
<span class="line-modified"> 705                     q.offer(new Object(), 2 * LONG_DELAY_MS, MILLISECONDS);</span>
 706                     shouldThrow();
 707                 } catch (InterruptedException success) {}
 708                 assertFalse(Thread.interrupted());
 709             }});
 710 
 711         await(pleaseInterrupt);
<span class="line-modified"> 712         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
 713         t.interrupt();
 714         awaitTermination(t);
 715     }
 716 
 717     /**
 718      * take retrieves elements in FIFO order
 719      */
 720     public void testTake() throws InterruptedException {
 721         LinkedBlockingDeque q = populatedDeque(SIZE);
 722         for (int i = 0; i &lt; SIZE; ++i) {
 723             assertEquals(i, q.take());
 724         }
 725     }
 726 
 727     /**
 728      * take removes existing elements until empty, then blocks interruptibly
 729      */
 730     public void testBlockingTake() throws InterruptedException {
 731         final LinkedBlockingDeque q = populatedDeque(SIZE);
 732         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 733         Thread t = newStartedThread(new CheckedRunnable() {
 734             public void realRun() throws InterruptedException {
 735                 for (int i = 0; i &lt; SIZE; i++) assertEquals(i, q.take());
 736 
 737                 Thread.currentThread().interrupt();
 738                 try {
 739                     q.take();
 740                     shouldThrow();
 741                 } catch (InterruptedException success) {}
 742                 assertFalse(Thread.interrupted());
 743 
 744                 pleaseInterrupt.countDown();
 745                 try {
 746                     q.take();
 747                     shouldThrow();
 748                 } catch (InterruptedException success) {}
 749                 assertFalse(Thread.interrupted());
 750             }});
 751 
 752         await(pleaseInterrupt);
<span class="line-modified"> 753         assertThreadBlocks(t, Thread.State.WAITING);</span>
 754         t.interrupt();
 755         awaitTermination(t);
 756     }
 757 
 758     /**
 759      * poll succeeds unless empty
 760      */
 761     public void testPoll() {
 762         LinkedBlockingDeque q = populatedDeque(SIZE);
 763         for (int i = 0; i &lt; SIZE; ++i) {
 764             assertEquals(i, q.poll());
 765         }
 766         assertNull(q.poll());
 767     }
 768 
 769     /**
 770      * timed poll with zero timeout succeeds when non-empty, else times out
 771      */
 772     public void testTimedPoll0() throws InterruptedException {
 773         LinkedBlockingDeque q = populatedDeque(SIZE);
</pre>
<hr />
<pre>
 785         for (int i = 0; i &lt; SIZE; ++i) {
 786             long startTime = System.nanoTime();
 787             assertEquals(i, q.poll(LONG_DELAY_MS, MILLISECONDS));
 788             assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 789         }
 790         long startTime = System.nanoTime();
 791         assertNull(q.poll(timeoutMillis(), MILLISECONDS));
 792         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
 793         checkEmpty(q);
 794     }
 795 
 796     /**
 797      * Interrupted timed poll throws InterruptedException instead of
 798      * returning timeout status
 799      */
 800     public void testInterruptedTimedPoll() throws InterruptedException {
 801         final BlockingQueue&lt;Integer&gt; q = populatedDeque(SIZE);
 802         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 803         Thread t = newStartedThread(new CheckedRunnable() {
 804             public void realRun() throws InterruptedException {
<span class="line-removed"> 805                 long startTime = System.nanoTime();</span>
 806                 for (int i = 0; i &lt; SIZE; i++)
 807                     assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
 808 
 809                 Thread.currentThread().interrupt();
 810                 try {
<span class="line-modified"> 811                     q.poll(LONG_DELAY_MS, MILLISECONDS);</span>
 812                     shouldThrow();
 813                 } catch (InterruptedException success) {}
 814                 assertFalse(Thread.interrupted());
 815 
 816                 pleaseInterrupt.countDown();
 817                 try {
<span class="line-modified"> 818                     q.poll(LONG_DELAY_MS, MILLISECONDS);</span>
 819                     shouldThrow();
 820                 } catch (InterruptedException success) {}
 821                 assertFalse(Thread.interrupted());
<span class="line-removed"> 822 </span>
<span class="line-removed"> 823                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);</span>
 824             }});
 825 
 826         await(pleaseInterrupt);
<span class="line-modified"> 827         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
 828         t.interrupt();
 829         awaitTermination(t);
 830         checkEmpty(q);
 831     }
 832 
 833     /**
 834      * putFirst(null) throws NPE
 835      */
 836     public void testPutFirstNull() throws InterruptedException {
 837         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
 838         try {
 839             q.putFirst(null);
 840             shouldThrow();
 841         } catch (NullPointerException success) {}
 842     }
 843 
 844     /**
 845      * all elements successfully putFirst are contained
 846      */
 847     public void testPutFirst() throws InterruptedException {
</pre>
<hr />
<pre>
 866                     q.putFirst(i);
 867                 assertEquals(SIZE, q.size());
 868                 assertEquals(0, q.remainingCapacity());
 869 
 870                 Thread.currentThread().interrupt();
 871                 try {
 872                     q.putFirst(99);
 873                     shouldThrow();
 874                 } catch (InterruptedException success) {}
 875                 assertFalse(Thread.interrupted());
 876 
 877                 pleaseInterrupt.countDown();
 878                 try {
 879                     q.putFirst(99);
 880                     shouldThrow();
 881                 } catch (InterruptedException success) {}
 882                 assertFalse(Thread.interrupted());
 883             }});
 884 
 885         await(pleaseInterrupt);
<span class="line-modified"> 886         assertThreadBlocks(t, Thread.State.WAITING);</span>
 887         t.interrupt();
 888         awaitTermination(t);
 889         assertEquals(SIZE, q.size());
 890         assertEquals(0, q.remainingCapacity());
 891     }
 892 
 893     /**
 894      * putFirst blocks interruptibly waiting for take when full
 895      */
 896     public void testPutFirstWithTake() throws InterruptedException {
 897         final int capacity = 2;
 898         final LinkedBlockingDeque q = new LinkedBlockingDeque(capacity);
 899         final CountDownLatch pleaseTake = new CountDownLatch(1);
 900         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 901         Thread t = newStartedThread(new CheckedRunnable() {
 902             public void realRun() throws InterruptedException {
 903                 for (int i = 0; i &lt; capacity; i++)
 904                     q.putFirst(i);
 905                 pleaseTake.countDown();
 906                 q.putFirst(86);
 907 
 908                 pleaseInterrupt.countDown();
 909                 try {
 910                     q.putFirst(99);
 911                     shouldThrow();
 912                 } catch (InterruptedException success) {}
 913                 assertFalse(Thread.interrupted());
 914             }});
 915 
 916         await(pleaseTake);
 917         assertEquals(0, q.remainingCapacity());
 918         assertEquals(capacity - 1, q.take());
 919 
 920         await(pleaseInterrupt);
<span class="line-modified"> 921         assertThreadBlocks(t, Thread.State.WAITING);</span>
 922         t.interrupt();
 923         awaitTermination(t);
 924         assertEquals(0, q.remainingCapacity());
 925     }
 926 
 927     /**
 928      * timed offerFirst times out if full and elements not taken
 929      */
 930     public void testTimedOfferFirst() {
 931         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
 932         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 933         Thread t = newStartedThread(new CheckedRunnable() {
 934             public void realRun() throws InterruptedException {
 935                 q.putFirst(new Object());
 936                 q.putFirst(new Object());
 937                 long startTime = System.nanoTime();

 938                 assertFalse(q.offerFirst(new Object(), timeoutMillis(), MILLISECONDS));
 939                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
 940 
 941                 Thread.currentThread().interrupt();
 942                 try {
<span class="line-modified"> 943                     q.offerFirst(new Object(), 2 * LONG_DELAY_MS, MILLISECONDS);</span>
 944                     shouldThrow();
 945                 } catch (InterruptedException success) {}
 946                 assertFalse(Thread.interrupted());
 947 
 948                 pleaseInterrupt.countDown();
 949                 try {
<span class="line-modified"> 950                     q.offerFirst(new Object(), 2 * LONG_DELAY_MS, MILLISECONDS);</span>
 951                     shouldThrow();
 952                 } catch (InterruptedException success) {}
 953                 assertFalse(Thread.interrupted());
 954             }});
 955 
 956         await(pleaseInterrupt);
<span class="line-modified"> 957         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
 958         t.interrupt();
 959         awaitTermination(t);
 960     }
 961 
 962     /**
 963      * take retrieves elements in FIFO order
 964      */
 965     public void testTakeFirst() throws InterruptedException {
 966         LinkedBlockingDeque q = populatedDeque(SIZE);
 967         for (int i = 0; i &lt; SIZE; ++i) {
 968             assertEquals(i, q.takeFirst());
 969         }
 970     }
 971 
 972     /**
 973      * takeFirst() blocks interruptibly when empty
 974      */
 975     public void testTakeFirstFromEmptyBlocksInterruptibly() {
 976         final BlockingDeque q = new LinkedBlockingDeque();
 977         final CountDownLatch threadStarted = new CountDownLatch(1);
 978         Thread t = newStartedThread(new CheckedRunnable() {
 979             public void realRun() {
 980                 threadStarted.countDown();
 981                 try {
 982                     q.takeFirst();
 983                     shouldThrow();
 984                 } catch (InterruptedException success) {}
 985                 assertFalse(Thread.interrupted());
 986             }});
 987 
 988         await(threadStarted);
<span class="line-modified"> 989         assertThreadBlocks(t, Thread.State.WAITING);</span>
 990         t.interrupt();
 991         awaitTermination(t);
 992     }
 993 
 994     /**
 995      * takeFirst() throws InterruptedException immediately if interrupted
 996      * before waiting
 997      */
 998     public void testTakeFirstFromEmptyAfterInterrupt() {
 999         final BlockingDeque q = new LinkedBlockingDeque();
1000         Thread t = newStartedThread(new CheckedRunnable() {
1001             public void realRun() {
1002                 Thread.currentThread().interrupt();
1003                 try {
1004                     q.takeFirst();
1005                     shouldThrow();
1006                 } catch (InterruptedException success) {}
1007                 assertFalse(Thread.interrupted());
1008             }});
1009 
1010         awaitTermination(t);
1011     }
1012 
1013     /**
1014      * takeLast() blocks interruptibly when empty
1015      */
1016     public void testTakeLastFromEmptyBlocksInterruptibly() {
1017         final BlockingDeque q = new LinkedBlockingDeque();
1018         final CountDownLatch threadStarted = new CountDownLatch(1);
1019         Thread t = newStartedThread(new CheckedRunnable() {
1020             public void realRun() {
1021                 threadStarted.countDown();
1022                 try {
1023                     q.takeLast();
1024                     shouldThrow();
1025                 } catch (InterruptedException success) {}
1026                 assertFalse(Thread.interrupted());
1027             }});
1028 
1029         await(threadStarted);
<span class="line-modified">1030         assertThreadBlocks(t, Thread.State.WAITING);</span>
1031         t.interrupt();
1032         awaitTermination(t);
1033     }
1034 
1035     /**
1036      * takeLast() throws InterruptedException immediately if interrupted
1037      * before waiting
1038      */
1039     public void testTakeLastFromEmptyAfterInterrupt() {
1040         final BlockingDeque q = new LinkedBlockingDeque();
1041         Thread t = newStartedThread(new CheckedRunnable() {
1042             public void realRun() {
1043                 Thread.currentThread().interrupt();
1044                 try {
1045                     q.takeLast();
1046                     shouldThrow();
1047                 } catch (InterruptedException success) {}
1048                 assertFalse(Thread.interrupted());
1049             }});
1050 
</pre>
<hr />
<pre>
1060         Thread t = newStartedThread(new CheckedRunnable() {
1061             public void realRun() throws InterruptedException {
1062                 for (int i = 0; i &lt; SIZE; i++) assertEquals(i, q.takeFirst());
1063 
1064                 Thread.currentThread().interrupt();
1065                 try {
1066                     q.takeFirst();
1067                     shouldThrow();
1068                 } catch (InterruptedException success) {}
1069                 assertFalse(Thread.interrupted());
1070 
1071                 pleaseInterrupt.countDown();
1072                 try {
1073                     q.takeFirst();
1074                     shouldThrow();
1075                 } catch (InterruptedException success) {}
1076                 assertFalse(Thread.interrupted());
1077             }});
1078 
1079         await(pleaseInterrupt);
<span class="line-modified">1080         assertThreadBlocks(t, Thread.State.WAITING);</span>
1081         t.interrupt();
1082         awaitTermination(t);
1083     }
1084 
1085     /**
1086      * timed pollFirst with zero timeout succeeds when non-empty, else times out
1087      */
1088     public void testTimedPollFirst0() throws InterruptedException {
1089         LinkedBlockingDeque q = populatedDeque(SIZE);
1090         for (int i = 0; i &lt; SIZE; ++i) {
1091             assertEquals(i, q.pollFirst(0, MILLISECONDS));
1092         }
1093         assertNull(q.pollFirst(0, MILLISECONDS));
1094     }
1095 
1096     /**
1097      * timed pollFirst with nonzero timeout succeeds when non-empty, else times out
1098      */
1099     public void testTimedPollFirst() throws InterruptedException {
1100         LinkedBlockingDeque q = populatedDeque(SIZE);
1101         for (int i = 0; i &lt; SIZE; ++i) {
1102             long startTime = System.nanoTime();
1103             assertEquals(i, q.pollFirst(LONG_DELAY_MS, MILLISECONDS));
1104             assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
1105         }
1106         long startTime = System.nanoTime();
1107         assertNull(q.pollFirst(timeoutMillis(), MILLISECONDS));
1108         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
1109         checkEmpty(q);
1110     }
1111 
1112     /**
1113      * Interrupted timed pollFirst throws InterruptedException instead of
1114      * returning timeout status
1115      */
1116     public void testInterruptedTimedPollFirst() throws InterruptedException {
1117         final LinkedBlockingDeque q = populatedDeque(SIZE);
1118         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
1119         Thread t = newStartedThread(new CheckedRunnable() {
1120             public void realRun() throws InterruptedException {
<span class="line-removed">1121                 long startTime = System.nanoTime();</span>
1122                 for (int i = 0; i &lt; SIZE; i++)
1123                     assertEquals(i, q.pollFirst(LONG_DELAY_MS, MILLISECONDS));
1124 
1125                 Thread.currentThread().interrupt();
1126                 try {
<span class="line-modified">1127                     q.pollFirst(LONG_DELAY_MS, MILLISECONDS);</span>
1128                     shouldThrow();
1129                 } catch (InterruptedException success) {}
1130                 assertFalse(Thread.interrupted());
1131 
1132                 pleaseInterrupt.countDown();
1133                 try {
<span class="line-modified">1134                     q.pollFirst(LONG_DELAY_MS, MILLISECONDS);</span>
1135                     shouldThrow();
1136                 } catch (InterruptedException success) {}
1137                 assertFalse(Thread.interrupted());
<span class="line-removed">1138 </span>
<span class="line-removed">1139                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);</span>
1140             }});
1141 
1142         await(pleaseInterrupt);
<span class="line-modified">1143         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
1144         t.interrupt();
1145         awaitTermination(t);
1146     }
1147 
1148     /**
1149      * timed pollFirst before a delayed offerFirst fails; after offerFirst succeeds;
1150      * on interruption throws
1151      */
1152     public void testTimedPollFirstWithOfferFirst() throws InterruptedException {
1153         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
1154         final CheckedBarrier barrier = new CheckedBarrier(2);
1155         Thread t = newStartedThread(new CheckedRunnable() {
1156             public void realRun() throws InterruptedException {
1157                 long startTime = System.nanoTime();
1158                 assertNull(q.pollFirst(timeoutMillis(), MILLISECONDS));
1159                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
1160 
1161                 barrier.await();
1162 
1163                 assertSame(zero, q.pollFirst(LONG_DELAY_MS, MILLISECONDS));
1164 
1165                 Thread.currentThread().interrupt();
1166                 try {
<span class="line-modified">1167                     q.pollFirst(LONG_DELAY_MS, MILLISECONDS);</span>
1168                     shouldThrow();
1169                 } catch (InterruptedException success) {}
1170 
1171                 barrier.await();
1172                 try {
1173                     q.pollFirst(LONG_DELAY_MS, MILLISECONDS);
1174                     shouldThrow();
1175                 } catch (InterruptedException success) {}
1176                 assertFalse(Thread.interrupted());

1177                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
1178             }});
1179 
1180         barrier.await();
1181         long startTime = System.nanoTime();
1182         assertTrue(q.offerFirst(zero, LONG_DELAY_MS, MILLISECONDS));
1183         assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
1184         barrier.await();
<span class="line-modified">1185         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
1186         t.interrupt();
1187         awaitTermination(t);
1188     }
1189 
1190     /**
1191      * putLast(null) throws NPE
1192      */
1193     public void testPutLastNull() throws InterruptedException {
1194         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
1195         try {
1196             q.putLast(null);
1197             shouldThrow();
1198         } catch (NullPointerException success) {}
1199     }
1200 
1201     /**
1202      * all elements successfully putLast are contained
1203      */
1204     public void testPutLast() throws InterruptedException {
1205         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
</pre>
<hr />
<pre>
1223                     q.putLast(i);
1224                 assertEquals(SIZE, q.size());
1225                 assertEquals(0, q.remainingCapacity());
1226 
1227                 Thread.currentThread().interrupt();
1228                 try {
1229                     q.putLast(99);
1230                     shouldThrow();
1231                 } catch (InterruptedException success) {}
1232                 assertFalse(Thread.interrupted());
1233 
1234                 pleaseInterrupt.countDown();
1235                 try {
1236                     q.putLast(99);
1237                     shouldThrow();
1238                 } catch (InterruptedException success) {}
1239                 assertFalse(Thread.interrupted());
1240             }});
1241 
1242         await(pleaseInterrupt);
<span class="line-modified">1243         assertThreadBlocks(t, Thread.State.WAITING);</span>
1244         t.interrupt();
1245         awaitTermination(t);
1246         assertEquals(SIZE, q.size());
1247         assertEquals(0, q.remainingCapacity());
1248     }
1249 
1250     /**
1251      * putLast blocks interruptibly waiting for take when full
1252      */
1253     public void testPutLastWithTake() throws InterruptedException {
1254         final int capacity = 2;
1255         final LinkedBlockingDeque q = new LinkedBlockingDeque(capacity);
1256         final CountDownLatch pleaseTake = new CountDownLatch(1);
1257         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
1258         Thread t = newStartedThread(new CheckedRunnable() {
1259             public void realRun() throws InterruptedException {
1260                 for (int i = 0; i &lt; capacity; i++)
1261                     q.putLast(i);
1262                 pleaseTake.countDown();
1263                 q.putLast(86);
</pre>
<hr />
<pre>
1265                 Thread.currentThread().interrupt();
1266                 try {
1267                     q.putLast(99);
1268                     shouldThrow();
1269                 } catch (InterruptedException success) {}
1270                 assertFalse(Thread.interrupted());
1271 
1272                 pleaseInterrupt.countDown();
1273                 try {
1274                     q.putLast(99);
1275                     shouldThrow();
1276                 } catch (InterruptedException success) {}
1277                 assertFalse(Thread.interrupted());
1278             }});
1279 
1280         await(pleaseTake);
1281         assertEquals(0, q.remainingCapacity());
1282         assertEquals(0, q.take());
1283 
1284         await(pleaseInterrupt);
<span class="line-modified">1285         assertThreadBlocks(t, Thread.State.WAITING);</span>
1286         t.interrupt();
1287         awaitTermination(t);
1288         assertEquals(0, q.remainingCapacity());
1289     }
1290 
1291     /**
1292      * timed offerLast times out if full and elements not taken
1293      */
1294     public void testTimedOfferLast() {
1295         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
1296         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
1297         Thread t = newStartedThread(new CheckedRunnable() {
1298             public void realRun() throws InterruptedException {
1299                 q.putLast(new Object());
1300                 q.putLast(new Object());
1301                 long startTime = System.nanoTime();

1302                 assertFalse(q.offerLast(new Object(), timeoutMillis(), MILLISECONDS));
1303                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
1304 
1305                 Thread.currentThread().interrupt();
1306                 try {
<span class="line-modified">1307                     q.offerLast(new Object(), 2 * LONG_DELAY_MS, MILLISECONDS);</span>
1308                     shouldThrow();
1309                 } catch (InterruptedException success) {}
1310 
1311                 pleaseInterrupt.countDown();
1312                 try {
<span class="line-modified">1313                     q.offerLast(new Object(), 2 * LONG_DELAY_MS, MILLISECONDS);</span>
1314                     shouldThrow();
1315                 } catch (InterruptedException success) {}
1316             }});
1317 
1318         await(pleaseInterrupt);
<span class="line-modified">1319         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
1320         t.interrupt();
1321         awaitTermination(t);
1322     }
1323 
1324     /**
1325      * takeLast retrieves elements in FIFO order
1326      */
1327     public void testTakeLast() throws InterruptedException {
1328         LinkedBlockingDeque q = populatedDeque(SIZE);
1329         for (int i = 0; i &lt; SIZE; ++i) {
1330             assertEquals(SIZE - i - 1, q.takeLast());
1331         }
1332     }
1333 
1334     /**
1335      * takeLast removes existing elements until empty, then blocks interruptibly
1336      */
1337     public void testBlockingTakeLast() throws InterruptedException {
1338         final LinkedBlockingDeque q = populatedDeque(SIZE);
1339         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
</pre>
<hr />
<pre>
1341             public void realRun() throws InterruptedException {
1342                 for (int i = 0; i &lt; SIZE; i++)
1343                     assertEquals(SIZE - i - 1, q.takeLast());
1344 
1345                 Thread.currentThread().interrupt();
1346                 try {
1347                     q.takeLast();
1348                     shouldThrow();
1349                 } catch (InterruptedException success) {}
1350                 assertFalse(Thread.interrupted());
1351 
1352                 pleaseInterrupt.countDown();
1353                 try {
1354                     q.takeLast();
1355                     shouldThrow();
1356                 } catch (InterruptedException success) {}
1357                 assertFalse(Thread.interrupted());
1358             }});
1359 
1360         await(pleaseInterrupt);
<span class="line-modified">1361         assertThreadBlocks(t, Thread.State.WAITING);</span>
1362         t.interrupt();
1363         awaitTermination(t);
1364     }
1365 
1366     /**
1367      * timed pollLast with zero timeout succeeds when non-empty, else times out
1368      */
1369     public void testTimedPollLast0() throws InterruptedException {
1370         LinkedBlockingDeque q = populatedDeque(SIZE);
1371         for (int i = 0; i &lt; SIZE; ++i) {
1372             assertEquals(SIZE - i - 1, q.pollLast(0, MILLISECONDS));
1373         }
1374         assertNull(q.pollLast(0, MILLISECONDS));
1375     }
1376 
1377     /**
1378      * timed pollLast with nonzero timeout succeeds when non-empty, else times out
1379      */
1380     public void testTimedPollLast() throws InterruptedException {
1381         LinkedBlockingDeque q = populatedDeque(SIZE);
1382         for (int i = 0; i &lt; SIZE; ++i) {
1383             long startTime = System.nanoTime();
1384             assertEquals(SIZE - i - 1, q.pollLast(LONG_DELAY_MS, MILLISECONDS));
1385             assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
1386         }
1387         long startTime = System.nanoTime();
1388         assertNull(q.pollLast(timeoutMillis(), MILLISECONDS));
1389         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
1390         checkEmpty(q);
1391     }
1392 
1393     /**
1394      * Interrupted timed pollLast throws InterruptedException instead of
1395      * returning timeout status
1396      */
1397     public void testInterruptedTimedPollLast() throws InterruptedException {
1398         final LinkedBlockingDeque q = populatedDeque(SIZE);
1399         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
1400         Thread t = newStartedThread(new CheckedRunnable() {
1401             public void realRun() throws InterruptedException {
<span class="line-removed">1402                 long startTime = System.nanoTime();</span>
1403                 for (int i = 0; i &lt; SIZE; i++)
1404                     assertEquals(SIZE - i - 1,
1405                                  q.pollLast(LONG_DELAY_MS, MILLISECONDS));
1406 
1407                 Thread.currentThread().interrupt();
1408                 try {
<span class="line-modified">1409                     q.pollLast(LONG_DELAY_MS, MILLISECONDS);</span>
1410                     shouldThrow();
1411                 } catch (InterruptedException success) {}
1412                 assertFalse(Thread.interrupted());
1413 
1414                 pleaseInterrupt.countDown();
1415                 try {
<span class="line-modified">1416                     q.pollLast(LONG_DELAY_MS, MILLISECONDS);</span>
1417                     shouldThrow();
1418                 } catch (InterruptedException success) {}
1419                 assertFalse(Thread.interrupted());
<span class="line-removed">1420 </span>
<span class="line-removed">1421                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);</span>
1422             }});
1423 
1424         await(pleaseInterrupt);
<span class="line-modified">1425         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
1426         t.interrupt();
1427         awaitTermination(t);
1428         checkEmpty(q);
1429     }
1430 
1431     /**
1432      * timed poll before a delayed offerLast fails; after offerLast succeeds;
1433      * on interruption throws
1434      */
1435     public void testTimedPollWithOfferLast() throws InterruptedException {
1436         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
1437         final CheckedBarrier barrier = new CheckedBarrier(2);
1438         Thread t = newStartedThread(new CheckedRunnable() {
1439             public void realRun() throws InterruptedException {
1440                 long startTime = System.nanoTime();
1441                 assertNull(q.poll(timeoutMillis(), MILLISECONDS));
1442                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
1443 
1444                 barrier.await();
1445 
1446                 assertSame(zero, q.poll(LONG_DELAY_MS, MILLISECONDS));
1447 
1448                 Thread.currentThread().interrupt();
1449                 try {
<span class="line-modified">1450                     q.poll(LONG_DELAY_MS, MILLISECONDS);</span>
1451                     shouldThrow();
1452                 } catch (InterruptedException success) {}
1453                 assertFalse(Thread.interrupted());
1454 
1455                 barrier.await();
1456                 try {
1457                     q.poll(LONG_DELAY_MS, MILLISECONDS);
1458                     shouldThrow();
1459                 } catch (InterruptedException success) {}
1460                 assertFalse(Thread.interrupted());
1461 
1462                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
1463             }});
1464 
1465         barrier.await();
1466         long startTime = System.nanoTime();
1467         assertTrue(q.offerLast(zero, LONG_DELAY_MS, MILLISECONDS));
1468         assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
1469 
1470         barrier.await();
<span class="line-modified">1471         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
1472         t.interrupt();
1473         awaitTermination(t);
1474     }
1475 
1476     /**
1477      * element returns next element, or throws NSEE if empty
1478      */
1479     public void testElement() {
1480         LinkedBlockingDeque q = populatedDeque(SIZE);
1481         for (int i = 0; i &lt; SIZE; ++i) {
1482             assertEquals(i, q.element());
1483             q.poll();
1484         }
1485         try {
1486             q.element();
1487             shouldThrow();
1488         } catch (NoSuchElementException success) {}
1489     }
1490 
1491     /**
</pre>
</td>
<td>
<hr />
<pre>
 614                     q.put(i);
 615                 assertEquals(SIZE, q.size());
 616                 assertEquals(0, q.remainingCapacity());
 617 
 618                 Thread.currentThread().interrupt();
 619                 try {
 620                     q.put(99);
 621                     shouldThrow();
 622                 } catch (InterruptedException success) {}
 623                 assertFalse(Thread.interrupted());
 624 
 625                 pleaseInterrupt.countDown();
 626                 try {
 627                     q.put(99);
 628                     shouldThrow();
 629                 } catch (InterruptedException success) {}
 630                 assertFalse(Thread.interrupted());
 631             }});
 632 
 633         await(pleaseInterrupt);
<span class="line-modified"> 634         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
 635         t.interrupt();
 636         awaitTermination(t);
 637         assertEquals(SIZE, q.size());
 638         assertEquals(0, q.remainingCapacity());
 639     }
 640 
 641     /**
 642      * put blocks interruptibly waiting for take when full
 643      */
 644     public void testPutWithTake() throws InterruptedException {
 645         final int capacity = 2;
 646         final LinkedBlockingDeque q = new LinkedBlockingDeque(capacity);
 647         final CountDownLatch pleaseTake = new CountDownLatch(1);
 648         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 649         Thread t = newStartedThread(new CheckedRunnable() {
 650             public void realRun() throws InterruptedException {
 651                 for (int i = 0; i &lt; capacity; i++)
 652                     q.put(i);
 653                 pleaseTake.countDown();
 654                 q.put(86);
</pre>
<hr />
<pre>
 656                 Thread.currentThread().interrupt();
 657                 try {
 658                     q.put(99);
 659                     shouldThrow();
 660                 } catch (InterruptedException success) {}
 661                 assertFalse(Thread.interrupted());
 662 
 663                 pleaseInterrupt.countDown();
 664                 try {
 665                     q.put(99);
 666                     shouldThrow();
 667                 } catch (InterruptedException success) {}
 668                 assertFalse(Thread.interrupted());
 669             }});
 670 
 671         await(pleaseTake);
 672         assertEquals(0, q.remainingCapacity());
 673         assertEquals(0, q.take());
 674 
 675         await(pleaseInterrupt);
<span class="line-modified"> 676         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
 677         t.interrupt();
 678         awaitTermination(t);
 679         assertEquals(0, q.remainingCapacity());
 680     }
 681 
 682     /**
 683      * timed offer times out if full and elements not taken
 684      */
 685     public void testTimedOffer() {
 686         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
 687         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 688         Thread t = newStartedThread(new CheckedRunnable() {
 689             public void realRun() throws InterruptedException {
 690                 q.put(new Object());
 691                 q.put(new Object());
 692                 long startTime = System.nanoTime();
<span class="line-added"> 693 </span>
 694                 assertFalse(q.offer(new Object(), timeoutMillis(), MILLISECONDS));
 695                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
 696 
 697                 Thread.currentThread().interrupt();
 698                 try {
<span class="line-modified"> 699                     q.offer(new Object(), randomTimeout(), randomTimeUnit());</span>
 700                     shouldThrow();
 701                 } catch (InterruptedException success) {}
 702                 assertFalse(Thread.interrupted());
 703 
 704                 pleaseInterrupt.countDown();
 705                 try {
<span class="line-modified"> 706                     q.offer(new Object(), LONGER_DELAY_MS, MILLISECONDS);</span>
 707                     shouldThrow();
 708                 } catch (InterruptedException success) {}
 709                 assertFalse(Thread.interrupted());
 710             }});
 711 
 712         await(pleaseInterrupt);
<span class="line-modified"> 713         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
 714         t.interrupt();
 715         awaitTermination(t);
 716     }
 717 
 718     /**
 719      * take retrieves elements in FIFO order
 720      */
 721     public void testTake() throws InterruptedException {
 722         LinkedBlockingDeque q = populatedDeque(SIZE);
 723         for (int i = 0; i &lt; SIZE; ++i) {
 724             assertEquals(i, q.take());
 725         }
 726     }
 727 
 728     /**
 729      * take removes existing elements until empty, then blocks interruptibly
 730      */
 731     public void testBlockingTake() throws InterruptedException {
 732         final LinkedBlockingDeque q = populatedDeque(SIZE);
 733         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 734         Thread t = newStartedThread(new CheckedRunnable() {
 735             public void realRun() throws InterruptedException {
 736                 for (int i = 0; i &lt; SIZE; i++) assertEquals(i, q.take());
 737 
 738                 Thread.currentThread().interrupt();
 739                 try {
 740                     q.take();
 741                     shouldThrow();
 742                 } catch (InterruptedException success) {}
 743                 assertFalse(Thread.interrupted());
 744 
 745                 pleaseInterrupt.countDown();
 746                 try {
 747                     q.take();
 748                     shouldThrow();
 749                 } catch (InterruptedException success) {}
 750                 assertFalse(Thread.interrupted());
 751             }});
 752 
 753         await(pleaseInterrupt);
<span class="line-modified"> 754         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
 755         t.interrupt();
 756         awaitTermination(t);
 757     }
 758 
 759     /**
 760      * poll succeeds unless empty
 761      */
 762     public void testPoll() {
 763         LinkedBlockingDeque q = populatedDeque(SIZE);
 764         for (int i = 0; i &lt; SIZE; ++i) {
 765             assertEquals(i, q.poll());
 766         }
 767         assertNull(q.poll());
 768     }
 769 
 770     /**
 771      * timed poll with zero timeout succeeds when non-empty, else times out
 772      */
 773     public void testTimedPoll0() throws InterruptedException {
 774         LinkedBlockingDeque q = populatedDeque(SIZE);
</pre>
<hr />
<pre>
 786         for (int i = 0; i &lt; SIZE; ++i) {
 787             long startTime = System.nanoTime();
 788             assertEquals(i, q.poll(LONG_DELAY_MS, MILLISECONDS));
 789             assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 790         }
 791         long startTime = System.nanoTime();
 792         assertNull(q.poll(timeoutMillis(), MILLISECONDS));
 793         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
 794         checkEmpty(q);
 795     }
 796 
 797     /**
 798      * Interrupted timed poll throws InterruptedException instead of
 799      * returning timeout status
 800      */
 801     public void testInterruptedTimedPoll() throws InterruptedException {
 802         final BlockingQueue&lt;Integer&gt; q = populatedDeque(SIZE);
 803         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 804         Thread t = newStartedThread(new CheckedRunnable() {
 805             public void realRun() throws InterruptedException {

 806                 for (int i = 0; i &lt; SIZE; i++)
 807                     assertEquals(i, (int) q.poll(LONG_DELAY_MS, MILLISECONDS));
 808 
 809                 Thread.currentThread().interrupt();
 810                 try {
<span class="line-modified"> 811                     q.poll(randomTimeout(), randomTimeUnit());</span>
 812                     shouldThrow();
 813                 } catch (InterruptedException success) {}
 814                 assertFalse(Thread.interrupted());
 815 
 816                 pleaseInterrupt.countDown();
 817                 try {
<span class="line-modified"> 818                     q.poll(LONGER_DELAY_MS, MILLISECONDS);</span>
 819                     shouldThrow();
 820                 } catch (InterruptedException success) {}
 821                 assertFalse(Thread.interrupted());


 822             }});
 823 
 824         await(pleaseInterrupt);
<span class="line-modified"> 825         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
 826         t.interrupt();
 827         awaitTermination(t);
 828         checkEmpty(q);
 829     }
 830 
 831     /**
 832      * putFirst(null) throws NPE
 833      */
 834     public void testPutFirstNull() throws InterruptedException {
 835         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
 836         try {
 837             q.putFirst(null);
 838             shouldThrow();
 839         } catch (NullPointerException success) {}
 840     }
 841 
 842     /**
 843      * all elements successfully putFirst are contained
 844      */
 845     public void testPutFirst() throws InterruptedException {
</pre>
<hr />
<pre>
 864                     q.putFirst(i);
 865                 assertEquals(SIZE, q.size());
 866                 assertEquals(0, q.remainingCapacity());
 867 
 868                 Thread.currentThread().interrupt();
 869                 try {
 870                     q.putFirst(99);
 871                     shouldThrow();
 872                 } catch (InterruptedException success) {}
 873                 assertFalse(Thread.interrupted());
 874 
 875                 pleaseInterrupt.countDown();
 876                 try {
 877                     q.putFirst(99);
 878                     shouldThrow();
 879                 } catch (InterruptedException success) {}
 880                 assertFalse(Thread.interrupted());
 881             }});
 882 
 883         await(pleaseInterrupt);
<span class="line-modified"> 884         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
 885         t.interrupt();
 886         awaitTermination(t);
 887         assertEquals(SIZE, q.size());
 888         assertEquals(0, q.remainingCapacity());
 889     }
 890 
 891     /**
 892      * putFirst blocks interruptibly waiting for take when full
 893      */
 894     public void testPutFirstWithTake() throws InterruptedException {
 895         final int capacity = 2;
 896         final LinkedBlockingDeque q = new LinkedBlockingDeque(capacity);
 897         final CountDownLatch pleaseTake = new CountDownLatch(1);
 898         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 899         Thread t = newStartedThread(new CheckedRunnable() {
 900             public void realRun() throws InterruptedException {
 901                 for (int i = 0; i &lt; capacity; i++)
 902                     q.putFirst(i);
 903                 pleaseTake.countDown();
 904                 q.putFirst(86);
 905 
 906                 pleaseInterrupt.countDown();
 907                 try {
 908                     q.putFirst(99);
 909                     shouldThrow();
 910                 } catch (InterruptedException success) {}
 911                 assertFalse(Thread.interrupted());
 912             }});
 913 
 914         await(pleaseTake);
 915         assertEquals(0, q.remainingCapacity());
 916         assertEquals(capacity - 1, q.take());
 917 
 918         await(pleaseInterrupt);
<span class="line-modified"> 919         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
 920         t.interrupt();
 921         awaitTermination(t);
 922         assertEquals(0, q.remainingCapacity());
 923     }
 924 
 925     /**
 926      * timed offerFirst times out if full and elements not taken
 927      */
 928     public void testTimedOfferFirst() {
 929         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
 930         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 931         Thread t = newStartedThread(new CheckedRunnable() {
 932             public void realRun() throws InterruptedException {
 933                 q.putFirst(new Object());
 934                 q.putFirst(new Object());
 935                 long startTime = System.nanoTime();
<span class="line-added"> 936 </span>
 937                 assertFalse(q.offerFirst(new Object(), timeoutMillis(), MILLISECONDS));
 938                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
 939 
 940                 Thread.currentThread().interrupt();
 941                 try {
<span class="line-modified"> 942                     q.offerFirst(new Object(), randomTimeout(), randomTimeUnit());</span>
 943                     shouldThrow();
 944                 } catch (InterruptedException success) {}
 945                 assertFalse(Thread.interrupted());
 946 
 947                 pleaseInterrupt.countDown();
 948                 try {
<span class="line-modified"> 949                     q.offerFirst(new Object(), LONGER_DELAY_MS, MILLISECONDS);</span>
 950                     shouldThrow();
 951                 } catch (InterruptedException success) {}
 952                 assertFalse(Thread.interrupted());
 953             }});
 954 
 955         await(pleaseInterrupt);
<span class="line-modified"> 956         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
 957         t.interrupt();
 958         awaitTermination(t);
 959     }
 960 
 961     /**
 962      * take retrieves elements in FIFO order
 963      */
 964     public void testTakeFirst() throws InterruptedException {
 965         LinkedBlockingDeque q = populatedDeque(SIZE);
 966         for (int i = 0; i &lt; SIZE; ++i) {
 967             assertEquals(i, q.takeFirst());
 968         }
 969     }
 970 
 971     /**
 972      * takeFirst() blocks interruptibly when empty
 973      */
 974     public void testTakeFirstFromEmptyBlocksInterruptibly() {
 975         final BlockingDeque q = new LinkedBlockingDeque();
 976         final CountDownLatch threadStarted = new CountDownLatch(1);
 977         Thread t = newStartedThread(new CheckedRunnable() {
 978             public void realRun() {
 979                 threadStarted.countDown();
 980                 try {
 981                     q.takeFirst();
 982                     shouldThrow();
 983                 } catch (InterruptedException success) {}
 984                 assertFalse(Thread.interrupted());
 985             }});
 986 
 987         await(threadStarted);
<span class="line-modified"> 988         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
 989         t.interrupt();
 990         awaitTermination(t);
 991     }
 992 
 993     /**
 994      * takeFirst() throws InterruptedException immediately if interrupted
 995      * before waiting
 996      */
 997     public void testTakeFirstFromEmptyAfterInterrupt() {
 998         final BlockingDeque q = new LinkedBlockingDeque();
 999         Thread t = newStartedThread(new CheckedRunnable() {
1000             public void realRun() {
1001                 Thread.currentThread().interrupt();
1002                 try {
1003                     q.takeFirst();
1004                     shouldThrow();
1005                 } catch (InterruptedException success) {}
1006                 assertFalse(Thread.interrupted());
1007             }});
1008 
1009         awaitTermination(t);
1010     }
1011 
1012     /**
1013      * takeLast() blocks interruptibly when empty
1014      */
1015     public void testTakeLastFromEmptyBlocksInterruptibly() {
1016         final BlockingDeque q = new LinkedBlockingDeque();
1017         final CountDownLatch threadStarted = new CountDownLatch(1);
1018         Thread t = newStartedThread(new CheckedRunnable() {
1019             public void realRun() {
1020                 threadStarted.countDown();
1021                 try {
1022                     q.takeLast();
1023                     shouldThrow();
1024                 } catch (InterruptedException success) {}
1025                 assertFalse(Thread.interrupted());
1026             }});
1027 
1028         await(threadStarted);
<span class="line-modified">1029         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
1030         t.interrupt();
1031         awaitTermination(t);
1032     }
1033 
1034     /**
1035      * takeLast() throws InterruptedException immediately if interrupted
1036      * before waiting
1037      */
1038     public void testTakeLastFromEmptyAfterInterrupt() {
1039         final BlockingDeque q = new LinkedBlockingDeque();
1040         Thread t = newStartedThread(new CheckedRunnable() {
1041             public void realRun() {
1042                 Thread.currentThread().interrupt();
1043                 try {
1044                     q.takeLast();
1045                     shouldThrow();
1046                 } catch (InterruptedException success) {}
1047                 assertFalse(Thread.interrupted());
1048             }});
1049 
</pre>
<hr />
<pre>
1059         Thread t = newStartedThread(new CheckedRunnable() {
1060             public void realRun() throws InterruptedException {
1061                 for (int i = 0; i &lt; SIZE; i++) assertEquals(i, q.takeFirst());
1062 
1063                 Thread.currentThread().interrupt();
1064                 try {
1065                     q.takeFirst();
1066                     shouldThrow();
1067                 } catch (InterruptedException success) {}
1068                 assertFalse(Thread.interrupted());
1069 
1070                 pleaseInterrupt.countDown();
1071                 try {
1072                     q.takeFirst();
1073                     shouldThrow();
1074                 } catch (InterruptedException success) {}
1075                 assertFalse(Thread.interrupted());
1076             }});
1077 
1078         await(pleaseInterrupt);
<span class="line-modified">1079         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
1080         t.interrupt();
1081         awaitTermination(t);
1082     }
1083 
1084     /**
1085      * timed pollFirst with zero timeout succeeds when non-empty, else times out
1086      */
1087     public void testTimedPollFirst0() throws InterruptedException {
1088         LinkedBlockingDeque q = populatedDeque(SIZE);
1089         for (int i = 0; i &lt; SIZE; ++i) {
1090             assertEquals(i, q.pollFirst(0, MILLISECONDS));
1091         }
1092         assertNull(q.pollFirst(0, MILLISECONDS));
1093     }
1094 
1095     /**
1096      * timed pollFirst with nonzero timeout succeeds when non-empty, else times out
1097      */
1098     public void testTimedPollFirst() throws InterruptedException {
1099         LinkedBlockingDeque q = populatedDeque(SIZE);
1100         for (int i = 0; i &lt; SIZE; ++i) {
1101             long startTime = System.nanoTime();
1102             assertEquals(i, q.pollFirst(LONG_DELAY_MS, MILLISECONDS));
1103             assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
1104         }
1105         long startTime = System.nanoTime();
1106         assertNull(q.pollFirst(timeoutMillis(), MILLISECONDS));
1107         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
1108         checkEmpty(q);
1109     }
1110 
1111     /**
1112      * Interrupted timed pollFirst throws InterruptedException instead of
1113      * returning timeout status
1114      */
1115     public void testInterruptedTimedPollFirst() throws InterruptedException {
1116         final LinkedBlockingDeque q = populatedDeque(SIZE);
1117         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
1118         Thread t = newStartedThread(new CheckedRunnable() {
1119             public void realRun() throws InterruptedException {

1120                 for (int i = 0; i &lt; SIZE; i++)
1121                     assertEquals(i, q.pollFirst(LONG_DELAY_MS, MILLISECONDS));
1122 
1123                 Thread.currentThread().interrupt();
1124                 try {
<span class="line-modified">1125                     q.pollFirst(randomTimeout(), randomTimeUnit());</span>
1126                     shouldThrow();
1127                 } catch (InterruptedException success) {}
1128                 assertFalse(Thread.interrupted());
1129 
1130                 pleaseInterrupt.countDown();
1131                 try {
<span class="line-modified">1132                     q.pollFirst(LONGER_DELAY_MS, MILLISECONDS);</span>
1133                     shouldThrow();
1134                 } catch (InterruptedException success) {}
1135                 assertFalse(Thread.interrupted());


1136             }});
1137 
1138         await(pleaseInterrupt);
<span class="line-modified">1139         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
1140         t.interrupt();
1141         awaitTermination(t);
1142     }
1143 
1144     /**
1145      * timed pollFirst before a delayed offerFirst fails; after offerFirst succeeds;
1146      * on interruption throws
1147      */
1148     public void testTimedPollFirstWithOfferFirst() throws InterruptedException {
1149         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
1150         final CheckedBarrier barrier = new CheckedBarrier(2);
1151         Thread t = newStartedThread(new CheckedRunnable() {
1152             public void realRun() throws InterruptedException {
1153                 long startTime = System.nanoTime();
1154                 assertNull(q.pollFirst(timeoutMillis(), MILLISECONDS));
1155                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
1156 
1157                 barrier.await();
1158 
1159                 assertSame(zero, q.pollFirst(LONG_DELAY_MS, MILLISECONDS));
1160 
1161                 Thread.currentThread().interrupt();
1162                 try {
<span class="line-modified">1163                     q.pollFirst(randomTimeout(), randomTimeUnit());</span>
1164                     shouldThrow();
1165                 } catch (InterruptedException success) {}
1166 
1167                 barrier.await();
1168                 try {
1169                     q.pollFirst(LONG_DELAY_MS, MILLISECONDS);
1170                     shouldThrow();
1171                 } catch (InterruptedException success) {}
1172                 assertFalse(Thread.interrupted());
<span class="line-added">1173 </span>
1174                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
1175             }});
1176 
1177         barrier.await();
1178         long startTime = System.nanoTime();
1179         assertTrue(q.offerFirst(zero, LONG_DELAY_MS, MILLISECONDS));
1180         assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
1181         barrier.await();
<span class="line-modified">1182         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
1183         t.interrupt();
1184         awaitTermination(t);
1185     }
1186 
1187     /**
1188      * putLast(null) throws NPE
1189      */
1190     public void testPutLastNull() throws InterruptedException {
1191         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
1192         try {
1193             q.putLast(null);
1194             shouldThrow();
1195         } catch (NullPointerException success) {}
1196     }
1197 
1198     /**
1199      * all elements successfully putLast are contained
1200      */
1201     public void testPutLast() throws InterruptedException {
1202         LinkedBlockingDeque q = new LinkedBlockingDeque(SIZE);
</pre>
<hr />
<pre>
1220                     q.putLast(i);
1221                 assertEquals(SIZE, q.size());
1222                 assertEquals(0, q.remainingCapacity());
1223 
1224                 Thread.currentThread().interrupt();
1225                 try {
1226                     q.putLast(99);
1227                     shouldThrow();
1228                 } catch (InterruptedException success) {}
1229                 assertFalse(Thread.interrupted());
1230 
1231                 pleaseInterrupt.countDown();
1232                 try {
1233                     q.putLast(99);
1234                     shouldThrow();
1235                 } catch (InterruptedException success) {}
1236                 assertFalse(Thread.interrupted());
1237             }});
1238 
1239         await(pleaseInterrupt);
<span class="line-modified">1240         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
1241         t.interrupt();
1242         awaitTermination(t);
1243         assertEquals(SIZE, q.size());
1244         assertEquals(0, q.remainingCapacity());
1245     }
1246 
1247     /**
1248      * putLast blocks interruptibly waiting for take when full
1249      */
1250     public void testPutLastWithTake() throws InterruptedException {
1251         final int capacity = 2;
1252         final LinkedBlockingDeque q = new LinkedBlockingDeque(capacity);
1253         final CountDownLatch pleaseTake = new CountDownLatch(1);
1254         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
1255         Thread t = newStartedThread(new CheckedRunnable() {
1256             public void realRun() throws InterruptedException {
1257                 for (int i = 0; i &lt; capacity; i++)
1258                     q.putLast(i);
1259                 pleaseTake.countDown();
1260                 q.putLast(86);
</pre>
<hr />
<pre>
1262                 Thread.currentThread().interrupt();
1263                 try {
1264                     q.putLast(99);
1265                     shouldThrow();
1266                 } catch (InterruptedException success) {}
1267                 assertFalse(Thread.interrupted());
1268 
1269                 pleaseInterrupt.countDown();
1270                 try {
1271                     q.putLast(99);
1272                     shouldThrow();
1273                 } catch (InterruptedException success) {}
1274                 assertFalse(Thread.interrupted());
1275             }});
1276 
1277         await(pleaseTake);
1278         assertEquals(0, q.remainingCapacity());
1279         assertEquals(0, q.take());
1280 
1281         await(pleaseInterrupt);
<span class="line-modified">1282         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
1283         t.interrupt();
1284         awaitTermination(t);
1285         assertEquals(0, q.remainingCapacity());
1286     }
1287 
1288     /**
1289      * timed offerLast times out if full and elements not taken
1290      */
1291     public void testTimedOfferLast() {
1292         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
1293         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
1294         Thread t = newStartedThread(new CheckedRunnable() {
1295             public void realRun() throws InterruptedException {
1296                 q.putLast(new Object());
1297                 q.putLast(new Object());
1298                 long startTime = System.nanoTime();
<span class="line-added">1299 </span>
1300                 assertFalse(q.offerLast(new Object(), timeoutMillis(), MILLISECONDS));
1301                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
1302 
1303                 Thread.currentThread().interrupt();
1304                 try {
<span class="line-modified">1305                     q.offerLast(new Object(), randomTimeout(), randomTimeUnit());</span>
1306                     shouldThrow();
1307                 } catch (InterruptedException success) {}
1308 
1309                 pleaseInterrupt.countDown();
1310                 try {
<span class="line-modified">1311                     q.offerLast(new Object(), LONGER_DELAY_MS, MILLISECONDS);</span>
1312                     shouldThrow();
1313                 } catch (InterruptedException success) {}
1314             }});
1315 
1316         await(pleaseInterrupt);
<span class="line-modified">1317         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
1318         t.interrupt();
1319         awaitTermination(t);
1320     }
1321 
1322     /**
1323      * takeLast retrieves elements in FIFO order
1324      */
1325     public void testTakeLast() throws InterruptedException {
1326         LinkedBlockingDeque q = populatedDeque(SIZE);
1327         for (int i = 0; i &lt; SIZE; ++i) {
1328             assertEquals(SIZE - i - 1, q.takeLast());
1329         }
1330     }
1331 
1332     /**
1333      * takeLast removes existing elements until empty, then blocks interruptibly
1334      */
1335     public void testBlockingTakeLast() throws InterruptedException {
1336         final LinkedBlockingDeque q = populatedDeque(SIZE);
1337         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
</pre>
<hr />
<pre>
1339             public void realRun() throws InterruptedException {
1340                 for (int i = 0; i &lt; SIZE; i++)
1341                     assertEquals(SIZE - i - 1, q.takeLast());
1342 
1343                 Thread.currentThread().interrupt();
1344                 try {
1345                     q.takeLast();
1346                     shouldThrow();
1347                 } catch (InterruptedException success) {}
1348                 assertFalse(Thread.interrupted());
1349 
1350                 pleaseInterrupt.countDown();
1351                 try {
1352                     q.takeLast();
1353                     shouldThrow();
1354                 } catch (InterruptedException success) {}
1355                 assertFalse(Thread.interrupted());
1356             }});
1357 
1358         await(pleaseInterrupt);
<span class="line-modified">1359         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
1360         t.interrupt();
1361         awaitTermination(t);
1362     }
1363 
1364     /**
1365      * timed pollLast with zero timeout succeeds when non-empty, else times out
1366      */
1367     public void testTimedPollLast0() throws InterruptedException {
1368         LinkedBlockingDeque q = populatedDeque(SIZE);
1369         for (int i = 0; i &lt; SIZE; ++i) {
1370             assertEquals(SIZE - i - 1, q.pollLast(0, MILLISECONDS));
1371         }
1372         assertNull(q.pollLast(0, MILLISECONDS));
1373     }
1374 
1375     /**
1376      * timed pollLast with nonzero timeout succeeds when non-empty, else times out
1377      */
1378     public void testTimedPollLast() throws InterruptedException {
1379         LinkedBlockingDeque q = populatedDeque(SIZE);
1380         for (int i = 0; i &lt; SIZE; ++i) {
1381             long startTime = System.nanoTime();
1382             assertEquals(SIZE - i - 1, q.pollLast(LONG_DELAY_MS, MILLISECONDS));
1383             assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
1384         }
1385         long startTime = System.nanoTime();
1386         assertNull(q.pollLast(timeoutMillis(), MILLISECONDS));
1387         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
1388         checkEmpty(q);
1389     }
1390 
1391     /**
1392      * Interrupted timed pollLast throws InterruptedException instead of
1393      * returning timeout status
1394      */
1395     public void testInterruptedTimedPollLast() throws InterruptedException {
1396         final LinkedBlockingDeque q = populatedDeque(SIZE);
1397         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
1398         Thread t = newStartedThread(new CheckedRunnable() {
1399             public void realRun() throws InterruptedException {

1400                 for (int i = 0; i &lt; SIZE; i++)
1401                     assertEquals(SIZE - i - 1,
1402                                  q.pollLast(LONG_DELAY_MS, MILLISECONDS));
1403 
1404                 Thread.currentThread().interrupt();
1405                 try {
<span class="line-modified">1406                     q.pollLast(randomTimeout(), randomTimeUnit());</span>
1407                     shouldThrow();
1408                 } catch (InterruptedException success) {}
1409                 assertFalse(Thread.interrupted());
1410 
1411                 pleaseInterrupt.countDown();
1412                 try {
<span class="line-modified">1413                     q.pollLast(LONGER_DELAY_MS, MILLISECONDS);</span>
1414                     shouldThrow();
1415                 } catch (InterruptedException success) {}
1416                 assertFalse(Thread.interrupted());


1417             }});
1418 
1419         await(pleaseInterrupt);
<span class="line-modified">1420         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
1421         t.interrupt();
1422         awaitTermination(t);
1423         checkEmpty(q);
1424     }
1425 
1426     /**
1427      * timed poll before a delayed offerLast fails; after offerLast succeeds;
1428      * on interruption throws
1429      */
1430     public void testTimedPollWithOfferLast() throws InterruptedException {
1431         final LinkedBlockingDeque q = new LinkedBlockingDeque(2);
1432         final CheckedBarrier barrier = new CheckedBarrier(2);
1433         Thread t = newStartedThread(new CheckedRunnable() {
1434             public void realRun() throws InterruptedException {
1435                 long startTime = System.nanoTime();
1436                 assertNull(q.poll(timeoutMillis(), MILLISECONDS));
1437                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());
1438 
1439                 barrier.await();
1440 
1441                 assertSame(zero, q.poll(LONG_DELAY_MS, MILLISECONDS));
1442 
1443                 Thread.currentThread().interrupt();
1444                 try {
<span class="line-modified">1445                     q.poll(randomTimeout(), randomTimeUnit());</span>
1446                     shouldThrow();
1447                 } catch (InterruptedException success) {}
1448                 assertFalse(Thread.interrupted());
1449 
1450                 barrier.await();
1451                 try {
1452                     q.poll(LONG_DELAY_MS, MILLISECONDS);
1453                     shouldThrow();
1454                 } catch (InterruptedException success) {}
1455                 assertFalse(Thread.interrupted());
1456 
1457                 assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
1458             }});
1459 
1460         barrier.await();
1461         long startTime = System.nanoTime();
1462         assertTrue(q.offerLast(zero, LONG_DELAY_MS, MILLISECONDS));
1463         assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
1464 
1465         barrier.await();
<span class="line-modified">1466         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
1467         t.interrupt();
1468         awaitTermination(t);
1469     }
1470 
1471     /**
1472      * element returns next element, or throws NSEE if empty
1473      */
1474     public void testElement() {
1475         LinkedBlockingDeque q = populatedDeque(SIZE);
1476         for (int i = 0; i &lt; SIZE; ++i) {
1477             assertEquals(i, q.element());
1478             q.poll();
1479         }
1480         try {
1481             q.element();
1482             shouldThrow();
1483         } catch (NoSuchElementException success) {}
1484     }
1485 
1486     /**
</pre>
</td>
</tr>
</table>
<center><a href="JSR166TestCase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LinkedBlockingQueueTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
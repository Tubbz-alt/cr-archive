<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/ScheduledExecutorSubclassTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ReentrantReadWriteLockTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ScheduledExecutorTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/ScheduledExecutorSubclassTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 690                 if (count == max)
 691                     return;
 692             } while (millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 693             fail(&quot;Purge failed to remove cancelled tasks&quot;);
 694         }
 695     }
 696 
 697     /**
 698      * shutdownNow returns a list containing tasks that were not run,
 699      * and those tasks are drained from the queue
 700      */
 701     public void testShutdownNow() throws InterruptedException {
 702         final int poolSize = 2;
 703         final int count = 5;
 704         final AtomicInteger ran = new AtomicInteger(0);
 705         final CustomExecutor p = new CustomExecutor(poolSize);
 706         final CountDownLatch threadsStarted = new CountDownLatch(poolSize);
 707         Runnable waiter = new CheckedRunnable() { public void realRun() {
 708             threadsStarted.countDown();
 709             try {
<span class="line-modified"> 710                 MILLISECONDS.sleep(2 * LONG_DELAY_MS);</span>
 711             } catch (InterruptedException success) {}
 712             ran.getAndIncrement();
 713         }};
 714         for (int i = 0; i &lt; count; i++)
 715             p.execute(waiter);
 716         await(threadsStarted);
 717         assertEquals(poolSize, p.getActiveCount());
 718         assertEquals(0, p.getCompletedTaskCount());
 719         final List&lt;Runnable&gt; queuedTasks;
 720         try {
 721             queuedTasks = p.shutdownNow();
 722         } catch (SecurityException ok) {
 723             return; // Allowed in case test doesn&#39;t have privs
 724         }
 725         assertTrue(p.isShutdown());
 726         assertTrue(p.getQueue().isEmpty());
 727         assertEquals(count - poolSize, queuedTasks.size());
 728         assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));
 729         assertTrue(p.isTerminated());
 730         assertEquals(poolSize, ran.get());
</pre>
</td>
<td>
<hr />
<pre>
 690                 if (count == max)
 691                     return;
 692             } while (millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 693             fail(&quot;Purge failed to remove cancelled tasks&quot;);
 694         }
 695     }
 696 
 697     /**
 698      * shutdownNow returns a list containing tasks that were not run,
 699      * and those tasks are drained from the queue
 700      */
 701     public void testShutdownNow() throws InterruptedException {
 702         final int poolSize = 2;
 703         final int count = 5;
 704         final AtomicInteger ran = new AtomicInteger(0);
 705         final CustomExecutor p = new CustomExecutor(poolSize);
 706         final CountDownLatch threadsStarted = new CountDownLatch(poolSize);
 707         Runnable waiter = new CheckedRunnable() { public void realRun() {
 708             threadsStarted.countDown();
 709             try {
<span class="line-modified"> 710                 MILLISECONDS.sleep(LONGER_DELAY_MS);</span>
 711             } catch (InterruptedException success) {}
 712             ran.getAndIncrement();
 713         }};
 714         for (int i = 0; i &lt; count; i++)
 715             p.execute(waiter);
 716         await(threadsStarted);
 717         assertEquals(poolSize, p.getActiveCount());
 718         assertEquals(0, p.getCompletedTaskCount());
 719         final List&lt;Runnable&gt; queuedTasks;
 720         try {
 721             queuedTasks = p.shutdownNow();
 722         } catch (SecurityException ok) {
 723             return; // Allowed in case test doesn&#39;t have privs
 724         }
 725         assertTrue(p.isShutdown());
 726         assertTrue(p.getQueue().isEmpty());
 727         assertEquals(count - poolSize, queuedTasks.size());
 728         assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));
 729         assertTrue(p.isTerminated());
 730         assertEquals(poolSize, ran.get());
</pre>
</td>
</tr>
</table>
<center><a href="ReentrantReadWriteLockTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ScheduledExecutorTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
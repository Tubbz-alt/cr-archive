<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/util/concurrent/Executors/PrivilegedCallables.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 6552961 6558429
 27  * @summary Test privilegedCallable, privilegedCallableUsingCurrentClassLoader
 28  * @run main/othervm PrivilegedCallables
 29  * @author Martin Buchholz
 30  */
 31 
 32 import static java.util.concurrent.Executors.privilegedCallable;
 33 import static java.util.concurrent.Executors.privilegedCallableUsingCurrentClassLoader;
 34 import static java.util.concurrent.Executors.privilegedThreadFactory;
 35 
 36 import java.security.AccessControlException;
 37 import java.security.CodeSource;
 38 import java.security.Permission;
 39 import java.security.PermissionCollection;
 40 import java.security.Permissions;
 41 import java.security.ProtectionDomain;
 42 import java.util.Random;
 43 import java.util.concurrent.Callable;
 44 
 45 public class PrivilegedCallables {
 46     Callable&lt;Integer&gt; real;
 47 
 48     final Callable&lt;Integer&gt; realCaller = new Callable&lt;&gt;() {
 49         public Integer call() throws Exception {
 50             return real.call(); }};
 51 
 52     final Random rnd = new Random();
 53 
 54     @SuppressWarnings(&quot;serial&quot;)
 55     final Throwable[] throwables = {
 56         new Exception() {},
 57         new RuntimeException() {},
 58         new Error() {}
 59     };
 60     Throwable randomThrowable() {
 61         return throwables[rnd.nextInt(throwables.length)];
 62     }
 63     void throwThrowable(Throwable t) throws Exception {
 64         if (t instanceof Error) throw (Error) t;
 65         if (t instanceof RuntimeException) throw (RuntimeException) t;
 66         throw (Exception) t;
 67     }
 68 
 69     //----------------------------------------------------------------
 70     // A Policy class designed to make permissions fiddling very easy.
 71     //----------------------------------------------------------------
 72     static class Policy extends java.security.Policy {
 73         static final java.security.Policy DEFAULT_POLICY = java.security.Policy.getPolicy();
 74 
 75         private Permissions perms;
 76 
 77         public void setPermissions(Permission...permissions) {
 78             perms = new Permissions();
 79             for (Permission permission : permissions)
 80                 perms.add(permission);
 81         }
 82 
 83         public Policy() { setPermissions(/* Nothing */); }
 84 
 85         public PermissionCollection getPermissions(CodeSource cs) {
 86             return perms;
 87         }
 88 
 89         public PermissionCollection getPermissions(ProtectionDomain pd) {
 90             return perms;
 91         }
 92 
 93         public boolean implies(ProtectionDomain pd, Permission p) {
 94             return perms.implies(p) || DEFAULT_POLICY.implies(pd, p);
 95         }
 96 
 97         public void refresh() {}
 98     }
 99 
100     void test(String[] args) {
101         testPrivileged();
102 
103         final Policy policy = new Policy();
104         Policy.setPolicy(policy);
105         policy.setPermissions(new RuntimePermission(&quot;getClassLoader&quot;),
106                               new RuntimePermission(&quot;setContextClassLoader&quot;));
107         System.setSecurityManager(new SecurityManager());
108 
109         testPrivileged();
110 
111         policy.setPermissions(/* Nothing */);
112 
113         THROWS(AccessControlException.class,
114                new F() {void f(){ privilegedCallableUsingCurrentClassLoader(realCaller); }},
115                new F() {void f(){ privilegedThreadFactory(); }});
116 
117         policy.setPermissions(new RuntimePermission(&quot;setSecurityManager&quot;));
118         System.setSecurityManager(null);
119     }
120 
121     void testPrivileged() {
122         try { test(privilegedCallable(realCaller)); }
123         catch (Throwable t) { unexpected(t); }
124 
125         try { test(privilegedCallableUsingCurrentClassLoader(realCaller)); }
126         catch (Throwable t) { unexpected(t); }
127 
128         try { privilegedThreadFactory(); }
129         catch (Throwable t) { unexpected(t); }
130     }
131 
132     void test(final Callable&lt;Integer&gt; c) throws Throwable {
133         for (int i = 0; i &lt; 20; i++)
134             if (rnd.nextBoolean()) {
135                 final Throwable t = randomThrowable();
136                 real = new Callable&lt;&gt;() {
137                     public Integer call() throws Exception {
138                         throwThrowable(t);
139                         return null; }};
140                 try {
141                     c.call();
142                     fail(&quot;Expected exception not thrown&quot;);
143                 } catch (Throwable tt) { check(t == tt); }
144             } else {
145                 final int n = rnd.nextInt();
146                 real = new Callable&lt;&gt;() {
147                     public Integer call() { return n; }};
148                 equal(c.call(), n);
149             }
150     }
151 
152     //--------------------- Infrastructure ---------------------------
153     volatile int passed = 0, failed = 0;
154     void pass() {passed++;}
155     void fail() {failed++; Thread.dumpStack();}
156     void fail(String msg) {System.err.println(msg); fail();}
157     void unexpected(Throwable t) {failed++; t.printStackTrace();}
158     void check(boolean cond) {if (cond) pass(); else fail();}
159     void equal(Object x, Object y) {
160         if (x == null ? y == null : x.equals(y)) pass();
161         else fail(x + &quot; not equal to &quot; + y);}
162     public static void main(String[] args) throws Throwable {
163         new PrivilegedCallables().instanceMain(args);}
164     void instanceMain(String[] args) throws Throwable {
165         try {test(args);} catch (Throwable t) {unexpected(t);}
166         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
167         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
168     abstract class F {abstract void f() throws Throwable;}
169     void THROWS(Class&lt;? extends Throwable&gt; k, F... fs) {
170         for (F f : fs)
171             try {f.f(); fail(&quot;Expected &quot; + k.getName() + &quot; not thrown&quot;);}
172             catch (Throwable t) {
173                 if (k.isAssignableFrom(t.getClass())) pass();
174                 else unexpected(t);}}
175 }
    </pre>
  </body>
</html>
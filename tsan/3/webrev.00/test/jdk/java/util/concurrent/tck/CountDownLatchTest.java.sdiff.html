<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/CountDownLatchTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ConcurrentSkipListMapTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="CyclicBarrierTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/CountDownLatchTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea with assistance from members of JCP JSR-166
 30  * Expert Group and released to the public domain, as explained at
 31  * http://creativecommons.org/publicdomain/zero/1.0/
 32  * Other contributors include Andrew Wright, Jeffrey Hayes,
 33  * Pat Fisher, Mike Judd.
 34  */
 35 
 36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 37 
 38 import java.util.concurrent.CountDownLatch;

 39 
 40 import junit.framework.Test;
 41 import junit.framework.TestSuite;
 42 
 43 public class CountDownLatchTest extends JSR166TestCase {
 44     public static void main(String[] args) {
 45         main(suite(), args);
 46     }
 47     public static Test suite() {
 48         return new TestSuite(CountDownLatchTest.class);
 49     }
 50 
 51     /**
 52      * negative constructor argument throws IllegalArgumentException
 53      */
 54     public void testConstructor() {
 55         try {
 56             new CountDownLatch(-1);
 57             shouldThrow();
 58         } catch (IllegalArgumentException success) {}
</pre>
<hr />
<pre>
 82 
 83     /**
 84      * await returns after countDown to zero, but not before
 85      */
 86     public void testAwait() {
 87         final CountDownLatch l = new CountDownLatch(2);
 88         final CountDownLatch pleaseCountDown = new CountDownLatch(1);
 89 
 90         Thread t = newStartedThread(new CheckedRunnable() {
 91             public void realRun() throws InterruptedException {
 92                 assertEquals(2, l.getCount());
 93                 pleaseCountDown.countDown();
 94                 l.await();
 95                 assertEquals(0, l.getCount());
 96             }});
 97 
 98         await(pleaseCountDown);
 99         assertEquals(2, l.getCount());
100         l.countDown();
101         assertEquals(1, l.getCount());
<span class="line-modified">102         assertThreadBlocks(t, Thread.State.WAITING);</span>
103         l.countDown();
104         assertEquals(0, l.getCount());
105         awaitTermination(t);
106     }
107 
108     /**
109      * timed await returns after countDown to zero
110      */
111     public void testTimedAwait() {
112         final CountDownLatch l = new CountDownLatch(2);
113         final CountDownLatch pleaseCountDown = new CountDownLatch(1);
114 
115         Thread t = newStartedThread(new CheckedRunnable() {
116             public void realRun() throws InterruptedException {
117                 assertEquals(2, l.getCount());
118                 pleaseCountDown.countDown();
119                 assertTrue(l.await(LONG_DELAY_MS, MILLISECONDS));
120                 assertEquals(0, l.getCount());
121             }});
122 
123         await(pleaseCountDown);
124         assertEquals(2, l.getCount());
125         l.countDown();
126         assertEquals(1, l.getCount());
<span class="line-modified">127         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
128         l.countDown();
129         assertEquals(0, l.getCount());
130         awaitTermination(t);
131     }
132 
133     /**
134      * await throws InterruptedException if interrupted before counted down
135      */
136     public void testAwait_Interruptible() {
137         final CountDownLatch l = new CountDownLatch(1);
138         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
139         Thread t = newStartedThread(new CheckedRunnable() {
140             public void realRun() throws InterruptedException {
141                 Thread.currentThread().interrupt();
142                 try {
143                     l.await();
144                     shouldThrow();
145                 } catch (InterruptedException success) {}
146                 assertFalse(Thread.interrupted());
147 
148                 pleaseInterrupt.countDown();
149                 try {
150                     l.await();
151                     shouldThrow();
152                 } catch (InterruptedException success) {}
153                 assertFalse(Thread.interrupted());
154 
155                 assertEquals(1, l.getCount());
156             }});
157 
158         await(pleaseInterrupt);
<span class="line-modified">159         assertThreadBlocks(t, Thread.State.WAITING);</span>
160         t.interrupt();
161         awaitTermination(t);
162     }
163 
164     /**
165      * timed await throws InterruptedException if interrupted before counted down
166      */
167     public void testTimedAwait_Interruptible() {
<span class="line-modified">168         final CountDownLatch l = new CountDownLatch(1);</span>

169         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
170         Thread t = newStartedThread(new CheckedRunnable() {
171             public void realRun() throws InterruptedException {
172                 Thread.currentThread().interrupt();
173                 try {
<span class="line-modified">174                     l.await(LONG_DELAY_MS, MILLISECONDS);</span>
175                     shouldThrow();
176                 } catch (InterruptedException success) {}
177                 assertFalse(Thread.interrupted());
178 
179                 pleaseInterrupt.countDown();
180                 try {
<span class="line-modified">181                     l.await(LONG_DELAY_MS, MILLISECONDS);</span>
182                     shouldThrow();
183                 } catch (InterruptedException success) {}
184                 assertFalse(Thread.interrupted());
185 
<span class="line-modified">186                 assertEquals(1, l.getCount());</span>
187             }});
188 
189         await(pleaseInterrupt);
<span class="line-modified">190         assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
191         t.interrupt();
192         awaitTermination(t);
193     }
194 
195     /**
196      * timed await times out if not counted down before timeout
197      */
198     public void testAwaitTimeout() throws InterruptedException {
199         final CountDownLatch l = new CountDownLatch(1);
200         Thread t = newStartedThread(new CheckedRunnable() {
201             public void realRun() throws InterruptedException {
202                 assertEquals(1, l.getCount());


203                 assertFalse(l.await(timeoutMillis(), MILLISECONDS));


204                 assertEquals(1, l.getCount());
205             }});
206 
207         awaitTermination(t);
208         assertEquals(1, l.getCount());
209     }
210 
211     /**
212      * toString indicates current count
213      */
214     public void testToString() {
215         CountDownLatch s = new CountDownLatch(2);
216         assertTrue(s.toString().contains(&quot;Count = 2&quot;));
217         s.countDown();
218         assertTrue(s.toString().contains(&quot;Count = 1&quot;));
219         s.countDown();
220         assertTrue(s.toString().contains(&quot;Count = 0&quot;));
221     }
222 
223 }
</pre>
</td>
<td>
<hr />
<pre>
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea with assistance from members of JCP JSR-166
 30  * Expert Group and released to the public domain, as explained at
 31  * http://creativecommons.org/publicdomain/zero/1.0/
 32  * Other contributors include Andrew Wright, Jeffrey Hayes,
 33  * Pat Fisher, Mike Judd.
 34  */
 35 
 36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 37 
 38 import java.util.concurrent.CountDownLatch;
<span class="line-added"> 39 import java.util.concurrent.ThreadLocalRandom;</span>
 40 
 41 import junit.framework.Test;
 42 import junit.framework.TestSuite;
 43 
 44 public class CountDownLatchTest extends JSR166TestCase {
 45     public static void main(String[] args) {
 46         main(suite(), args);
 47     }
 48     public static Test suite() {
 49         return new TestSuite(CountDownLatchTest.class);
 50     }
 51 
 52     /**
 53      * negative constructor argument throws IllegalArgumentException
 54      */
 55     public void testConstructor() {
 56         try {
 57             new CountDownLatch(-1);
 58             shouldThrow();
 59         } catch (IllegalArgumentException success) {}
</pre>
<hr />
<pre>
 83 
 84     /**
 85      * await returns after countDown to zero, but not before
 86      */
 87     public void testAwait() {
 88         final CountDownLatch l = new CountDownLatch(2);
 89         final CountDownLatch pleaseCountDown = new CountDownLatch(1);
 90 
 91         Thread t = newStartedThread(new CheckedRunnable() {
 92             public void realRun() throws InterruptedException {
 93                 assertEquals(2, l.getCount());
 94                 pleaseCountDown.countDown();
 95                 l.await();
 96                 assertEquals(0, l.getCount());
 97             }});
 98 
 99         await(pleaseCountDown);
100         assertEquals(2, l.getCount());
101         l.countDown();
102         assertEquals(1, l.getCount());
<span class="line-modified">103         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
104         l.countDown();
105         assertEquals(0, l.getCount());
106         awaitTermination(t);
107     }
108 
109     /**
110      * timed await returns after countDown to zero
111      */
112     public void testTimedAwait() {
113         final CountDownLatch l = new CountDownLatch(2);
114         final CountDownLatch pleaseCountDown = new CountDownLatch(1);
115 
116         Thread t = newStartedThread(new CheckedRunnable() {
117             public void realRun() throws InterruptedException {
118                 assertEquals(2, l.getCount());
119                 pleaseCountDown.countDown();
120                 assertTrue(l.await(LONG_DELAY_MS, MILLISECONDS));
121                 assertEquals(0, l.getCount());
122             }});
123 
124         await(pleaseCountDown);
125         assertEquals(2, l.getCount());
126         l.countDown();
127         assertEquals(1, l.getCount());
<span class="line-modified">128         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
129         l.countDown();
130         assertEquals(0, l.getCount());
131         awaitTermination(t);
132     }
133 
134     /**
135      * await throws InterruptedException if interrupted before counted down
136      */
137     public void testAwait_Interruptible() {
138         final CountDownLatch l = new CountDownLatch(1);
139         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
140         Thread t = newStartedThread(new CheckedRunnable() {
141             public void realRun() throws InterruptedException {
142                 Thread.currentThread().interrupt();
143                 try {
144                     l.await();
145                     shouldThrow();
146                 } catch (InterruptedException success) {}
147                 assertFalse(Thread.interrupted());
148 
149                 pleaseInterrupt.countDown();
150                 try {
151                     l.await();
152                     shouldThrow();
153                 } catch (InterruptedException success) {}
154                 assertFalse(Thread.interrupted());
155 
156                 assertEquals(1, l.getCount());
157             }});
158 
159         await(pleaseInterrupt);
<span class="line-modified">160         if (randomBoolean()) assertThreadBlocks(t, Thread.State.WAITING);</span>
161         t.interrupt();
162         awaitTermination(t);
163     }
164 
165     /**
166      * timed await throws InterruptedException if interrupted before counted down
167      */
168     public void testTimedAwait_Interruptible() {
<span class="line-modified">169         final int initialCount = ThreadLocalRandom.current().nextInt(1, 3);</span>
<span class="line-added">170         final CountDownLatch l = new CountDownLatch(initialCount);</span>
171         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
172         Thread t = newStartedThread(new CheckedRunnable() {
173             public void realRun() throws InterruptedException {
174                 Thread.currentThread().interrupt();
175                 try {
<span class="line-modified">176                     l.await(randomTimeout(), randomTimeUnit());</span>
177                     shouldThrow();
178                 } catch (InterruptedException success) {}
179                 assertFalse(Thread.interrupted());
180 
181                 pleaseInterrupt.countDown();
182                 try {
<span class="line-modified">183                     l.await(LONGER_DELAY_MS, MILLISECONDS);</span>
184                     shouldThrow();
185                 } catch (InterruptedException success) {}
186                 assertFalse(Thread.interrupted());
187 
<span class="line-modified">188                 assertEquals(initialCount, l.getCount());</span>
189             }});
190 
191         await(pleaseInterrupt);
<span class="line-modified">192         if (randomBoolean()) assertThreadBlocks(t, Thread.State.TIMED_WAITING);</span>
193         t.interrupt();
194         awaitTermination(t);
195     }
196 
197     /**
198      * timed await times out if not counted down before timeout
199      */
200     public void testAwaitTimeout() throws InterruptedException {
201         final CountDownLatch l = new CountDownLatch(1);
202         Thread t = newStartedThread(new CheckedRunnable() {
203             public void realRun() throws InterruptedException {
204                 assertEquals(1, l.getCount());
<span class="line-added">205 </span>
<span class="line-added">206                 long startTime = System.nanoTime();</span>
207                 assertFalse(l.await(timeoutMillis(), MILLISECONDS));
<span class="line-added">208                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis());</span>
<span class="line-added">209 </span>
210                 assertEquals(1, l.getCount());
211             }});
212 
213         awaitTermination(t);
214         assertEquals(1, l.getCount());
215     }
216 
217     /**
218      * toString indicates current count
219      */
220     public void testToString() {
221         CountDownLatch s = new CountDownLatch(2);
222         assertTrue(s.toString().contains(&quot;Count = 2&quot;));
223         s.countDown();
224         assertTrue(s.toString().contains(&quot;Count = 1&quot;));
225         s.countDown();
226         assertTrue(s.toString().contains(&quot;Count = 0&quot;));
227     }
228 
229 }
</pre>
</td>
</tr>
</table>
<center><a href="ConcurrentSkipListMapTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="CyclicBarrierTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/ConcurrentHashMap/MapCheck.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  */
 22 
 23 /*
 24  * This file is available under and governed by the GNU General Public
 25  * License version 2 only, as published by the Free Software Foundation.
 26  * However, the following notice accompanied the original version of this
 27  * file:
 28  *
 29  * Written by Doug Lea with assistance from members of JCP JSR-166
 30  * Expert Group and released to the public domain, as explained at
 31  * http://creativecommons.org/publicdomain/zero/1.0/
 32  */
 33 
 34 /*
 35  * @test
 36  * @bug 4486658
 37  * @run main/timeout=240 MapCheck
 38  * @summary Times and checks basic map operations
 39  */
 40 
 41 import java.io.Serializable;
 42 import java.io.BufferedInputStream;
 43 import java.io.BufferedOutputStream;
 44 import java.io.FileInputStream;
 45 import java.io.FileOutputStream;
 46 import java.io.ObjectInputStream;
 47 import java.io.ObjectOutputStream;
 48 import java.util.Enumeration;
 49 import java.util.Hashtable;
 50 import java.util.IdentityHashMap;
 51 import java.util.Iterator;
 52 import java.util.Map;
 53 import java.util.Set;
 54 import java.util.concurrent.ThreadLocalRandom;
 55 
 56 public class MapCheck {
 57 
 58     static final int absentSize = 1 &lt;&lt; 17;
 59     static final int absentMask = absentSize - 1;
 60     static Object[] absent = new Object[absentSize];
 61 
 62     static final Object MISSING = new Object();
 63 
 64     static TestTimer timer = new TestTimer();
 65 
 66     static void reallyAssert(boolean b) {
 67         if (!b) throw new Error(&quot;Failed Assertion&quot;);
 68     }
 69 
 70     public static void main(String[] args) throws Exception {
 71         Class mapClass = java.util.concurrent.ConcurrentHashMap.class;
 72         int numTests = 8;
 73         int size = 50000;
 74 
 75         if (args.length &gt; 0) {
 76             try {
 77                 mapClass = Class.forName(args[0]);
 78             } catch (ClassNotFoundException e) {
 79                 throw new RuntimeException(&quot;Class &quot; + args[0] + &quot; not found.&quot;);
 80             }
 81         }
 82 
 83         if (args.length &gt; 1)
 84             numTests = Integer.parseInt(args[1]);
 85 
 86         if (args.length &gt; 2)
 87             size = Integer.parseInt(args[2]);
 88 
 89         boolean doSerializeTest = args.length &gt; 3;
 90 
 91         System.out.println(&quot;Testing &quot; + mapClass.getName() + &quot; trials: &quot; + numTests + &quot; size: &quot; + size);
 92 
 93         for (int i = 0; i &lt; absentSize; ++i) absent[i] = new Object();
 94 
 95         Object[] key = new Object[size];
 96         for (int i = 0; i &lt; size; ++i) key[i] = new Object();
 97 
 98         forceMem(size * 8);
 99 
100         for (int rep = 0; rep &lt; numTests; ++rep) {
101             runTest(newMap(mapClass), key);
102         }
103 
104         TestTimer.printStats();
105 
106         if (doSerializeTest)
107             stest(newMap(mapClass), size);
108     }
109 
110     static Map newMap(Class cl) {
111         try {
112             return (Map)cl.getDeclaredConstructor().newInstance();
113         } catch (Exception e) {
114             throw new RuntimeException(&quot;Can&#39;t instantiate &quot; + cl + &quot;: &quot; + e);
115         }
116     }
117 
118     static void runTest(Map s, Object[] key) {
119         shuffle(key);
120         int size = key.length;
121         long startTime = System.currentTimeMillis();
122         test(s, key);
123         long time = System.currentTimeMillis() - startTime;
124     }
125 
126     static void forceMem(int n) {
127         // force enough memory
128         Long[] junk = new Long[n];
129         for (int i = 0; i &lt; junk.length; ++i) junk[i] = new Long(i);
130         int sum = 0;
131         for (int i = 0; i &lt; junk.length; ++i)
132             sum += (int)(junk[i].longValue() + i);
133         if (sum == 0) System.out.println(&quot;Useless number = &quot; + sum);
134         junk = null;
135         //        System.gc();
136     }
137 
138     static void t1(String nm, int n, Map s, Object[] key, int expect) {
139         int sum = 0;
140         int iters = 4;
141         timer.start(nm, n * iters);
142         for (int j = 0; j &lt; iters; ++j) {
143             for (int i = 0; i &lt; n; i++) {
144                 if (s.get(key[i]) != null) ++sum;
145             }
146         }
147         timer.finish();
148         reallyAssert(sum == expect * iters);
149     }
150 
151     static void t2(String nm, int n, Map s, Object[] key, int expect) {
152         int sum = 0;
153         timer.start(nm, n);
154         for (int i = 0; i &lt; n; i++) {
155             if (s.remove(key[i]) != null) ++sum;
156         }
157         timer.finish();
158         reallyAssert(sum == expect);
159     }
160 
161     static void t3(String nm, int n, Map s, Object[] key, int expect) {
162         int sum = 0;
163         timer.start(nm, n);
164         for (int i = 0; i &lt; n; i++) {
165             if (s.put(key[i], absent[i &amp; absentMask]) == null) ++sum;
166         }
167         timer.finish();
168         reallyAssert(sum == expect);
169     }
170 
171     static void t4(String nm, int n, Map s, Object[] key, int expect) {
172         int sum = 0;
173         timer.start(nm, n);
174         for (int i = 0; i &lt; n; i++) {
175             if (s.containsKey(key[i])) ++sum;
176         }
177         timer.finish();
178         reallyAssert(sum == expect);
179     }
180 
181     static void t5(String nm, int n, Map s, Object[] key, int expect) {
182         int sum = 0;
183         timer.start(nm, n/2);
184         for (int i = n-2; i &gt;= 0; i-=2) {
185             if (s.remove(key[i]) != null) ++sum;
186         }
187         timer.finish();
188         reallyAssert(sum == expect);
189     }
190 
191     static void t6(String nm, int n, Map s, Object[] k1, Object[] k2) {
192         int sum = 0;
193         timer.start(nm, n * 2);
194         for (int i = 0; i &lt; n; i++) {
195             if (s.get(k1[i]) != null) ++sum;
196             if (s.get(k2[i &amp; absentMask]) != null) ++sum;
197         }
198         timer.finish();
199         reallyAssert(sum == n);
200     }
201 
202     static void t7(String nm, int n, Map s, Object[] k1, Object[] k2) {
203         int sum = 0;
204         timer.start(nm, n * 2);
205         for (int i = 0; i &lt; n; i++) {
206             if (s.containsKey(k1[i])) ++sum;
207             if (s.containsKey(k2[i &amp; absentMask])) ++sum;
208         }
209         timer.finish();
210         reallyAssert(sum == n);
211     }
212 
213     static void t8(String nm, int n, Map s, Object[] key, int expect) {
214         int sum = 0;
215         timer.start(nm, n);
216         for (int i = 0; i &lt; n; i++) {
217             if (s.get(key[i]) != null) ++sum;
218         }
219         timer.finish();
220         reallyAssert(sum == expect);
221     }
222 
223 
224     static void t9(Map s) {
225         int sum = 0;
226         int iters = 20;
227         timer.start(&quot;ContainsValue (/n)     &quot;, iters * s.size());
228         int step = absentSize / iters;
229         for (int i = 0; i &lt; absentSize; i += step)
230             if (s.containsValue(absent[i])) ++sum;
231         timer.finish();
232         reallyAssert(sum != 0);
233     }
234 
235 
236     static void ktest(Map s, int size, Object[] key) {
237         timer.start(&quot;ContainsKey            &quot;, size);
238         Set ks = s.keySet();
239         int sum = 0;
240         for (int i = 0; i &lt; size; i++) {
241             if (ks.contains(key[i])) ++sum;
242         }
243         timer.finish();
244         reallyAssert(sum == size);
245     }
246 
247 
248     static void ittest1(Map s, int size) {
249         int sum = 0;
250         timer.start(&quot;Iter Key               &quot;, size);
251         for (Iterator it = s.keySet().iterator(); it.hasNext(); ) {
252             if (it.next() != MISSING)
253                 ++sum;
254         }
255         timer.finish();
256         reallyAssert(sum == size);
257     }
258 
259     static void ittest2(Map s, int size) {
260         int sum = 0;
261         timer.start(&quot;Iter Value             &quot;, size);
262         for (Iterator it = s.values().iterator(); it.hasNext(); ) {
263             if (it.next() != MISSING)
264                 ++sum;
265         }
266         timer.finish();
267         reallyAssert(sum == size);
268     }
269     static void ittest3(Map s, int size) {
270         int sum = 0;
271         timer.start(&quot;Iter Entry             &quot;, size);
272         for (Iterator it = s.entrySet().iterator(); it.hasNext(); ) {
273             if (it.next() != MISSING)
274                 ++sum;
275         }
276         timer.finish();
277         reallyAssert(sum == size);
278     }
279 
280     static void ittest4(Map s, int size, int pos) {
281         IdentityHashMap seen = new IdentityHashMap(size);
282         reallyAssert(s.size() == size);
283         int sum = 0;
284         timer.start(&quot;Iter XEntry            &quot;, size);
285         Iterator it = s.entrySet().iterator();
286         Object k = null;
287         Object v = null;
288         for (int i = 0; i &lt; size-pos; ++i) {
289             Map.Entry x = (Map.Entry)(it.next());
290             k = x.getKey();
291             v = x.getValue();
292             seen.put(k, k);
293             if (x != MISSING)
294                 ++sum;
295         }
296         reallyAssert(s.containsKey(k));
297         it.remove();
298         reallyAssert(!s.containsKey(k));
299         while (it.hasNext()) {
300             Map.Entry x = (Map.Entry)(it.next());
301             Object k2 = x.getKey();
302             seen.put(k2, k2);
303             if (x != MISSING)
304                 ++sum;
305         }
306 
307         reallyAssert(s.size() == size-1);
308         s.put(k, v);
309         reallyAssert(seen.size() == size);
310         timer.finish();
311         reallyAssert(sum == size);
312         reallyAssert(s.size() == size);
313     }
314 
315 
316     static void ittest(Map s, int size) {
317         ittest1(s, size);
318         ittest2(s, size);
319         ittest3(s, size);
320         //        for (int i = 0; i &lt; size-1; ++i)
321         //            ittest4(s, size, i);
322     }
323 
324     static void entest1(Hashtable ht, int size) {
325         int sum = 0;
326 
327         timer.start(&quot;Iter Enumeration Key   &quot;, size);
328         for (Enumeration en = ht.keys(); en.hasMoreElements(); ) {
329             if (en.nextElement() != MISSING)
330                 ++sum;
331         }
332         timer.finish();
333         reallyAssert(sum == size);
334     }
335 
336     static void entest2(Hashtable ht, int size) {
337         int sum = 0;
338         timer.start(&quot;Iter Enumeration Value &quot;, size);
339         for (Enumeration en = ht.elements(); en.hasMoreElements(); ) {
340             if (en.nextElement() != MISSING)
341                 ++sum;
342         }
343         timer.finish();
344         reallyAssert(sum == size);
345     }
346 
347 
348     static void entest3(Hashtable ht, int size) {
349         int sum = 0;
350 
351         timer.start(&quot;Iterf Enumeration Key  &quot;, size);
352         Enumeration en = ht.keys();
353         for (int i = 0; i &lt; size; ++i) {
354             if (en.nextElement() != MISSING)
355                 ++sum;
356         }
357         timer.finish();
358         reallyAssert(sum == size);
359     }
360 
361     static void entest4(Hashtable ht, int size) {
362         int sum = 0;
363         timer.start(&quot;Iterf Enumeration Value&quot;, size);
364         Enumeration en = ht.elements();
365         for (int i = 0; i &lt; size; ++i) {
366             if (en.nextElement() != MISSING)
367                 ++sum;
368         }
369         timer.finish();
370         reallyAssert(sum == size);
371     }
372 
373     static void entest(Map s, int size) {
374         if (s instanceof Hashtable) {
375             Hashtable ht = (Hashtable)s;
376             //            entest3(ht, size);
377             //            entest4(ht, size);
378             entest1(ht, size);
379             entest2(ht, size);
380             entest1(ht, size);
381             entest2(ht, size);
382             entest1(ht, size);
383             entest2(ht, size);
384         }
385     }
386 
387     static void rtest(Map s, int size) {
388         timer.start(&quot;Remove (iterator)      &quot;, size);
389         for (Iterator it = s.keySet().iterator(); it.hasNext(); ) {
390             it.next();
391             it.remove();
392         }
393         timer.finish();
394     }
395 
396     static void rvtest(Map s, int size) {
397         timer.start(&quot;Remove (iterator)      &quot;, size);
398         for (Iterator it = s.values().iterator(); it.hasNext(); ) {
399             it.next();
400             it.remove();
401         }
402         timer.finish();
403     }
404 
405 
406     static void dtest(Map s, int size, Object[] key) {
407         timer.start(&quot;Put (putAll)           &quot;, size * 2);
408         Map s2 = null;
409         try {
410             s2 = (Map) s.getClass().getDeclaredConstructor().newInstance();
411             s2.putAll(s);
412         }
413         catch (Exception e) { e.printStackTrace(); return; }
414         timer.finish();
415 
416         timer.start(&quot;Iter Equals            &quot;, size * 2);
417         boolean eqt = s2.equals(s) &amp;&amp; s.equals(s2);
418         reallyAssert(eqt);
419         timer.finish();
420 
421         timer.start(&quot;Iter HashCode          &quot;, size * 2);
422         int shc = s.hashCode();
423         int s2hc = s2.hashCode();
424         reallyAssert(shc == s2hc);
425         timer.finish();
426 
427         timer.start(&quot;Put (present)          &quot;, size);
428         s2.putAll(s);
429         timer.finish();
430 
431         timer.start(&quot;Iter EntrySet contains &quot;, size * 2);
432         Set es2 = s2.entrySet();
433         int sum = 0;
434         for (Iterator i1 = s.entrySet().iterator(); i1.hasNext(); ) {
435             Object entry = i1.next();
436             if (es2.contains(entry)) ++sum;
437         }
438         timer.finish();
439         reallyAssert(sum == size);
440 
441         t6(&quot;Get                    &quot;, size, s2, key, absent);
442 
443         Object hold = s2.get(key[size-1]);
444         s2.put(key[size-1], absent[0]);
445         timer.start(&quot;Iter Equals            &quot;, size * 2);
446         eqt = s2.equals(s) &amp;&amp; s.equals(s2);
447         reallyAssert(!eqt);
448         timer.finish();
449 
450         timer.start(&quot;Iter HashCode          &quot;, size * 2);
451         int s1h = s.hashCode();
452         int s2h = s2.hashCode();
453         reallyAssert(s1h != s2h);
454         timer.finish();
455 
456         s2.put(key[size-1], hold);
457         timer.start(&quot;Remove (iterator)      &quot;, size * 2);
458         Iterator s2i = s2.entrySet().iterator();
459         Set es = s.entrySet();
460         while (s2i.hasNext())
461             es.remove(s2i.next());
462         timer.finish();
463 
464         reallyAssert(s.isEmpty());
465 
466         timer.start(&quot;Clear                  &quot;, size);
467         s2.clear();
468         timer.finish();
469         reallyAssert(s2.isEmpty() &amp;&amp; s.isEmpty());
470     }
471 
472     static void stest(Map s, int size) throws Exception {
473         if (!(s instanceof Serializable))
474             return;
475         System.out.print(&quot;Serialize              : &quot;);
476 
477         for (int i = 0; i &lt; size; i++) {
478             s.put(new Integer(i), Boolean.TRUE);
479         }
480 
481         long startTime = System.currentTimeMillis();
482 
483         FileOutputStream fs = new FileOutputStream(&quot;MapCheck.dat&quot;);
484         ObjectOutputStream out = new ObjectOutputStream(new BufferedOutputStream(fs));
485         out.writeObject(s);
486         out.close();
487 
488         FileInputStream is = new FileInputStream(&quot;MapCheck.dat&quot;);
489         ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(is));
490         Map m = (Map)in.readObject();
491 
492         long endTime = System.currentTimeMillis();
493         long time = endTime - startTime;
494 
495         System.out.print(time + &quot;ms&quot;);
496 
497         if (s instanceof IdentityHashMap) return;
498         reallyAssert(s.equals(m));
499     }
500 
501 
502     static void test(Map s, Object[] key) {
503         int size = key.length;
504 
505         t3(&quot;Put (absent)           &quot;, size, s, key, size);
506         t3(&quot;Put (present)          &quot;, size, s, key, 0);
507         t7(&quot;ContainsKey            &quot;, size, s, key, absent);
508         t4(&quot;ContainsKey            &quot;, size, s, key, size);
509         ktest(s, size, key);
510         t4(&quot;ContainsKey            &quot;, absentSize, s, absent, 0);
511         t6(&quot;Get                    &quot;, size, s, key, absent);
512         t1(&quot;Get (present)          &quot;, size, s, key, size);
513         t1(&quot;Get (absent)           &quot;, absentSize, s, absent, 0);
514         t2(&quot;Remove (absent)        &quot;, absentSize, s, absent, 0);
515         t5(&quot;Remove (present)       &quot;, size, s, key, size / 2);
516         t3(&quot;Put (half present)     &quot;, size, s, key, size / 2);
517 
518         ittest(s, size);
519         entest(s, size);
520         t9(s);
521         rtest(s, size);
522 
523         t4(&quot;ContainsKey            &quot;, size, s, key, 0);
524         t2(&quot;Remove (absent)        &quot;, size, s, key, 0);
525         t3(&quot;Put (presized)         &quot;, size, s, key, size);
526         dtest(s, size, key);
527     }
528 
529     static class TestTimer {
530         private String name;
531         private long numOps;
532         private long startTime;
533         private String cname;
534 
535         static final java.util.TreeMap accum = new java.util.TreeMap();
536 
537         static void printStats() {
538             for (Iterator it = accum.entrySet().iterator(); it.hasNext(); ) {
539                 Map.Entry e = (Map.Entry)(it.next());
<a name="1" id="anc1"></a><span class="line-modified">540                 Stats stats = (Stats)(e.getValue());</span>
541                 int n = stats.number;
542                 double t;
543                 if (n &gt; 0)
544                     t = stats.sum / n;
545                 else
546                     t = stats.least;
547                 long nano = Math.round(1000000.0 * t);
548                 System.out.println(e.getKey() + &quot;: &quot; + nano);
549             }
550         }
551 
552         void start(String name, long numOps) {
553             this.name = name;
554             this.cname = classify();
555             this.numOps = numOps;
556             startTime = System.currentTimeMillis();
557         }
558 
559 
560         String classify() {
561             if (name.startsWith(&quot;Get&quot;))
562                 return &quot;Get                    &quot;;
563             else if (name.startsWith(&quot;Put&quot;))
564                 return &quot;Put                    &quot;;
565             else if (name.startsWith(&quot;Remove&quot;))
566                 return &quot;Remove                 &quot;;
567             else if (name.startsWith(&quot;Iter&quot;))
568                 return &quot;Iter                   &quot;;
569             else
570                 return null;
571         }
572 
573         void finish() {
574             long endTime = System.currentTimeMillis();
575             long time = endTime - startTime;
576             double timePerOp = ((double)time)/numOps;
577 
578             Object st = accum.get(name);
579             if (st == null)
580                 accum.put(name, new Stats(timePerOp));
581             else {
582                 Stats stats = (Stats) st;
583                 stats.sum += timePerOp;
584                 stats.number++;
585                 if (timePerOp &lt; stats.least) stats.least = timePerOp;
586             }
587 
588             if (cname != null) {
589                 st = accum.get(cname);
590                 if (st == null)
591                     accum.put(cname, new Stats(timePerOp));
592                 else {
593                     Stats stats = (Stats) st;
594                     stats.sum += timePerOp;
595                     stats.number++;
596                     if (timePerOp &lt; stats.least) stats.least = timePerOp;
597                 }
598             }
599 
600         }
601 
602     }
603 
604     static class Stats {
605         double sum = 0;
606         double least;
607         int number = 0;
608         Stats(double t) { least = t; }
609     }
610 
611     static void shuffle(Object[] keys) {
612         ThreadLocalRandom rnd = ThreadLocalRandom.current();
613         int size = keys.length;
614         for (int i=size; i&gt;1; i--) {
615             int r = rnd.nextInt(i);
616             Object t = keys[i-1];
617             keys[i-1] = keys[r];
618             keys[r] = t;
619         }
620     }
621 
622 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/tck/ReentrantLockTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  */
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea with assistance from members of JCP JSR-166
  30  * Expert Group and released to the public domain, as explained at
  31  * http://creativecommons.org/publicdomain/zero/1.0/
  32  * Other contributors include Andrew Wright, Jeffrey Hayes,
  33  * Pat Fisher, Mike Judd.
  34  */
  35 
  36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  37 
  38 import java.util.ArrayList;
  39 import java.util.Arrays;
  40 import java.util.Collection;
  41 import java.util.HashSet;
<a name="1" id="anc1"></a>
  42 import java.util.concurrent.CountDownLatch;
  43 import java.util.concurrent.CyclicBarrier;
  44 import java.util.concurrent.ThreadLocalRandom;
<a name="2" id="anc2"></a>
  45 import java.util.concurrent.locks.Condition;
<a name="3" id="anc3"></a>
  46 import java.util.concurrent.locks.ReentrantLock;
  47 
  48 import junit.framework.Test;
  49 import junit.framework.TestSuite;
  50 
  51 @SuppressWarnings(&quot;WaitNotInLoop&quot;) // we implement spurious-wakeup freedom
  52 public class ReentrantLockTest extends JSR166TestCase {
  53     public static void main(String[] args) {
  54         main(suite(), args);
  55     }
  56     public static Test suite() {
  57         return new TestSuite(ReentrantLockTest.class);
  58     }
  59 
  60     /**
  61      * A checked runnable calling lockInterruptibly
  62      */
  63     class InterruptibleLockRunnable extends CheckedRunnable {
  64         final ReentrantLock lock;
  65         InterruptibleLockRunnable(ReentrantLock lock) { this.lock = lock; }
  66         public void realRun() throws InterruptedException {
  67             lock.lockInterruptibly();
  68         }
  69     }
  70 
  71     /**
  72      * A checked runnable calling lockInterruptibly that expects to be
  73      * interrupted
  74      */
  75     class InterruptedLockRunnable extends CheckedInterruptedRunnable {
  76         final ReentrantLock lock;
  77         InterruptedLockRunnable(ReentrantLock lock) { this.lock = lock; }
  78         public void realRun() throws InterruptedException {
  79             lock.lockInterruptibly();
  80         }
  81     }
  82 
  83     /**
  84      * Subclass to expose protected methods
  85      */
  86     static class PublicReentrantLock extends ReentrantLock {
  87         PublicReentrantLock() { super(); }
  88         PublicReentrantLock(boolean fair) { super(fair); }
  89         public Thread getOwner() {
  90             return super.getOwner();
  91         }
  92         public Collection&lt;Thread&gt; getQueuedThreads() {
  93             return super.getQueuedThreads();
  94         }
  95         public Collection&lt;Thread&gt; getWaitingThreads(Condition c) {
  96             return super.getWaitingThreads(c);
  97         }
  98     }
  99 
 100     /**
 101      * Releases write lock, checking that it had a hold count of 1.
 102      */
 103     void releaseLock(PublicReentrantLock lock) {
 104         assertLockedByMoi(lock);
 105         lock.unlock();
 106         assertFalse(lock.isHeldByCurrentThread());
 107         assertNotLocked(lock);
 108     }
 109 
 110     /**
 111      * Spin-waits until lock.hasQueuedThread(t) becomes true.
 112      */
 113     void waitForQueuedThread(PublicReentrantLock lock, Thread t) {
 114         long startTime = System.nanoTime();
 115         while (!lock.hasQueuedThread(t)) {
 116             if (millisElapsedSince(startTime) &gt; LONG_DELAY_MS)
 117                 throw new AssertionError(&quot;timed out&quot;);
 118             Thread.yield();
 119         }
 120         assertTrue(t.isAlive());
 121         assertNotSame(t, lock.getOwner());
 122     }
 123 
 124     /**
 125      * Checks that lock is not locked.
 126      */
 127     void assertNotLocked(PublicReentrantLock lock) {
 128         assertFalse(lock.isLocked());
 129         assertFalse(lock.isHeldByCurrentThread());
 130         assertNull(lock.getOwner());
 131         assertEquals(0, lock.getHoldCount());
 132     }
 133 
 134     /**
 135      * Checks that lock is locked by the given thread.
 136      */
 137     void assertLockedBy(PublicReentrantLock lock, Thread t) {
 138         assertTrue(lock.isLocked());
 139         assertSame(t, lock.getOwner());
 140         assertEquals(t == Thread.currentThread(),
 141                      lock.isHeldByCurrentThread());
 142         assertEquals(t == Thread.currentThread(),
 143                      lock.getHoldCount() &gt; 0);
 144     }
 145 
 146     /**
 147      * Checks that lock is locked by the current thread.
 148      */
 149     void assertLockedByMoi(PublicReentrantLock lock) {
 150         assertLockedBy(lock, Thread.currentThread());
 151     }
 152 
 153     /**
 154      * Checks that condition c has no waiters.
 155      */
 156     void assertHasNoWaiters(PublicReentrantLock lock, Condition c) {
 157         assertHasWaiters(lock, c, new Thread[] {});
 158     }
 159 
 160     /**
 161      * Checks that condition c has exactly the given waiter threads.
 162      */
 163     void assertHasWaiters(PublicReentrantLock lock, Condition c,
 164                           Thread... threads) {
 165         lock.lock();
 166         assertEquals(threads.length &gt; 0, lock.hasWaiters(c));
 167         assertEquals(threads.length, lock.getWaitQueueLength(c));
 168         assertEquals(threads.length == 0, lock.getWaitingThreads(c).isEmpty());
 169         assertEquals(threads.length, lock.getWaitingThreads(c).size());
 170         assertEquals(new HashSet&lt;Thread&gt;(lock.getWaitingThreads(c)),
 171                      new HashSet&lt;Thread&gt;(Arrays.asList(threads)));
 172         lock.unlock();
 173     }
 174 
 175     enum AwaitMethod { await, awaitTimed, awaitNanos, awaitUntil }
 176 
 177     static AwaitMethod randomAwaitMethod() {
 178         AwaitMethod[] awaitMethods = AwaitMethod.values();
 179         return awaitMethods[ThreadLocalRandom.current().nextInt(awaitMethods.length)];
 180     }
 181 
 182     /**
 183      * Awaits condition &quot;indefinitely&quot; using the specified AwaitMethod.
 184      */
 185     void await(Condition c, AwaitMethod awaitMethod)
 186             throws InterruptedException {
 187         long timeoutMillis = 2 * LONG_DELAY_MS;
 188         switch (awaitMethod) {
 189         case await:
 190             c.await();
 191             break;
 192         case awaitTimed:
 193             assertTrue(c.await(timeoutMillis, MILLISECONDS));
 194             break;
 195         case awaitNanos:
 196             long timeoutNanos = MILLISECONDS.toNanos(timeoutMillis);
 197             long nanosRemaining = c.awaitNanos(timeoutNanos);
 198             assertTrue(nanosRemaining &gt; timeoutNanos / 2);
 199             assertTrue(nanosRemaining &lt;= timeoutNanos);
 200             break;
 201         case awaitUntil:
 202             assertTrue(c.awaitUntil(delayedDate(timeoutMillis)));
 203             break;
 204         default:
 205             throw new AssertionError();
 206         }
 207     }
 208 
 209     /**
 210      * Constructor sets given fairness, and is in unlocked state
 211      */
 212     public void testConstructor() {
 213         PublicReentrantLock lock;
 214 
 215         lock = new PublicReentrantLock();
 216         assertFalse(lock.isFair());
 217         assertNotLocked(lock);
 218 
 219         lock = new PublicReentrantLock(true);
 220         assertTrue(lock.isFair());
 221         assertNotLocked(lock);
 222 
 223         lock = new PublicReentrantLock(false);
 224         assertFalse(lock.isFair());
 225         assertNotLocked(lock);
 226     }
 227 
 228     /**
 229      * locking an unlocked lock succeeds
 230      */
 231     public void testLock()      { testLock(false); }
 232     public void testLock_fair() { testLock(true); }
 233     public void testLock(boolean fair) {
 234         PublicReentrantLock lock = new PublicReentrantLock(fair);
 235         lock.lock();
 236         assertLockedByMoi(lock);
 237         releaseLock(lock);
 238     }
 239 
 240     /**
 241      * Unlocking an unlocked lock throws IllegalMonitorStateException
 242      */
 243     public void testUnlock_IMSE()      { testUnlock_IMSE(false); }
 244     public void testUnlock_IMSE_fair() { testUnlock_IMSE(true); }
 245     public void testUnlock_IMSE(boolean fair) {
 246         final ReentrantLock lock = new ReentrantLock(fair);
 247         try {
 248             lock.unlock();
 249             shouldThrow();
 250         } catch (IllegalMonitorStateException success) {}
 251     }
 252 
 253     /**
 254      * tryLock on an unlocked lock succeeds
 255      */
 256     public void testTryLock()      { testTryLock(false); }
 257     public void testTryLock_fair() { testTryLock(true); }
 258     public void testTryLock(boolean fair) {
 259         PublicReentrantLock lock = new PublicReentrantLock(fair);
 260         assertTrue(lock.tryLock());
 261         assertLockedByMoi(lock);
 262         assertTrue(lock.tryLock());
 263         assertLockedByMoi(lock);
 264         lock.unlock();
 265         releaseLock(lock);
 266     }
 267 
 268     /**
 269      * hasQueuedThreads reports whether there are waiting threads
 270      */
 271     public void testHasQueuedThreads()      { testHasQueuedThreads(false); }
 272     public void testHasQueuedThreads_fair() { testHasQueuedThreads(true); }
 273     public void testHasQueuedThreads(boolean fair) {
 274         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 275         Thread t1 = new Thread(new InterruptedLockRunnable(lock));
 276         Thread t2 = new Thread(new InterruptibleLockRunnable(lock));
 277         assertFalse(lock.hasQueuedThreads());
 278         lock.lock();
 279         assertFalse(lock.hasQueuedThreads());
 280         t1.start();
 281         waitForQueuedThread(lock, t1);
 282         assertTrue(lock.hasQueuedThreads());
 283         t2.start();
 284         waitForQueuedThread(lock, t2);
 285         assertTrue(lock.hasQueuedThreads());
 286         t1.interrupt();
 287         awaitTermination(t1);
 288         assertTrue(lock.hasQueuedThreads());
 289         lock.unlock();
 290         awaitTermination(t2);
 291         assertFalse(lock.hasQueuedThreads());
 292     }
 293 
 294     /**
 295      * getQueueLength reports number of waiting threads
 296      */
 297     public void testGetQueueLength()      { testGetQueueLength(false); }
 298     public void testGetQueueLength_fair() { testGetQueueLength(true); }
 299     public void testGetQueueLength(boolean fair) {
 300         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 301         Thread t1 = new Thread(new InterruptedLockRunnable(lock));
 302         Thread t2 = new Thread(new InterruptibleLockRunnable(lock));
 303         assertEquals(0, lock.getQueueLength());
 304         lock.lock();
 305         t1.start();
 306         waitForQueuedThread(lock, t1);
 307         assertEquals(1, lock.getQueueLength());
 308         t2.start();
 309         waitForQueuedThread(lock, t2);
 310         assertEquals(2, lock.getQueueLength());
 311         t1.interrupt();
 312         awaitTermination(t1);
 313         assertEquals(1, lock.getQueueLength());
 314         lock.unlock();
 315         awaitTermination(t2);
 316         assertEquals(0, lock.getQueueLength());
 317     }
 318 
 319     /**
 320      * hasQueuedThread(null) throws NPE
 321      */
 322     public void testHasQueuedThreadNPE()      { testHasQueuedThreadNPE(false); }
 323     public void testHasQueuedThreadNPE_fair() { testHasQueuedThreadNPE(true); }
 324     public void testHasQueuedThreadNPE(boolean fair) {
 325         final ReentrantLock lock = new ReentrantLock(fair);
 326         try {
 327             lock.hasQueuedThread(null);
 328             shouldThrow();
 329         } catch (NullPointerException success) {}
 330     }
 331 
 332     /**
 333      * hasQueuedThread reports whether a thread is queued
 334      */
 335     public void testHasQueuedThread()      { testHasQueuedThread(false); }
 336     public void testHasQueuedThread_fair() { testHasQueuedThread(true); }
 337     public void testHasQueuedThread(boolean fair) {
 338         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 339         Thread t1 = new Thread(new InterruptedLockRunnable(lock));
 340         Thread t2 = new Thread(new InterruptibleLockRunnable(lock));
 341         assertFalse(lock.hasQueuedThread(t1));
 342         assertFalse(lock.hasQueuedThread(t2));
 343         lock.lock();
 344         t1.start();
 345         waitForQueuedThread(lock, t1);
 346         assertTrue(lock.hasQueuedThread(t1));
 347         assertFalse(lock.hasQueuedThread(t2));
 348         t2.start();
 349         waitForQueuedThread(lock, t2);
 350         assertTrue(lock.hasQueuedThread(t1));
 351         assertTrue(lock.hasQueuedThread(t2));
 352         t1.interrupt();
 353         awaitTermination(t1);
 354         assertFalse(lock.hasQueuedThread(t1));
 355         assertTrue(lock.hasQueuedThread(t2));
 356         lock.unlock();
 357         awaitTermination(t2);
 358         assertFalse(lock.hasQueuedThread(t1));
 359         assertFalse(lock.hasQueuedThread(t2));
 360     }
 361 
 362     /**
 363      * getQueuedThreads includes waiting threads
 364      */
 365     public void testGetQueuedThreads()      { testGetQueuedThreads(false); }
 366     public void testGetQueuedThreads_fair() { testGetQueuedThreads(true); }
 367     public void testGetQueuedThreads(boolean fair) {
 368         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 369         Thread t1 = new Thread(new InterruptedLockRunnable(lock));
 370         Thread t2 = new Thread(new InterruptibleLockRunnable(lock));
 371         assertTrue(lock.getQueuedThreads().isEmpty());
 372         lock.lock();
 373         assertTrue(lock.getQueuedThreads().isEmpty());
 374         t1.start();
 375         waitForQueuedThread(lock, t1);
 376         assertEquals(1, lock.getQueuedThreads().size());
 377         assertTrue(lock.getQueuedThreads().contains(t1));
 378         t2.start();
 379         waitForQueuedThread(lock, t2);
 380         assertEquals(2, lock.getQueuedThreads().size());
 381         assertTrue(lock.getQueuedThreads().contains(t1));
 382         assertTrue(lock.getQueuedThreads().contains(t2));
 383         t1.interrupt();
 384         awaitTermination(t1);
 385         assertFalse(lock.getQueuedThreads().contains(t1));
 386         assertTrue(lock.getQueuedThreads().contains(t2));
 387         assertEquals(1, lock.getQueuedThreads().size());
 388         lock.unlock();
 389         awaitTermination(t2);
 390         assertTrue(lock.getQueuedThreads().isEmpty());
 391     }
 392 
 393     /**
 394      * timed tryLock is interruptible
 395      */
 396     public void testTryLock_Interruptible()      { testTryLock_Interruptible(false); }
 397     public void testTryLock_Interruptible_fair() { testTryLock_Interruptible(true); }
 398     public void testTryLock_Interruptible(boolean fair) {
 399         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 400         lock.lock();
 401         Thread t = newStartedThread(new CheckedInterruptedRunnable() {
 402             public void realRun() throws InterruptedException {
 403                 lock.tryLock(2 * LONG_DELAY_MS, MILLISECONDS);
 404             }});
 405 
 406         waitForQueuedThread(lock, t);
 407         t.interrupt();
 408         awaitTermination(t);
 409         releaseLock(lock);
 410     }
 411 
 412     /**
 413      * tryLock on a locked lock fails
 414      */
 415     public void testTryLockWhenLocked()      { testTryLockWhenLocked(false); }
 416     public void testTryLockWhenLocked_fair() { testTryLockWhenLocked(true); }
 417     public void testTryLockWhenLocked(boolean fair) {
 418         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 419         lock.lock();
 420         Thread t = newStartedThread(new CheckedRunnable() {
 421             public void realRun() {
 422                 assertFalse(lock.tryLock());
 423             }});
 424 
 425         awaitTermination(t);
 426         releaseLock(lock);
 427     }
 428 
 429     /**
 430      * Timed tryLock on a locked lock times out
 431      */
 432     public void testTryLock_Timeout()      { testTryLock_Timeout(false); }
 433     public void testTryLock_Timeout_fair() { testTryLock_Timeout(true); }
 434     public void testTryLock_Timeout(boolean fair) {
 435         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 436         final long timeoutMillis = timeoutMillis();
 437         lock.lock();
 438         Thread t = newStartedThread(new CheckedRunnable() {
 439             public void realRun() throws InterruptedException {
 440                 long startTime = System.nanoTime();
 441                 assertFalse(lock.tryLock(timeoutMillis, MILLISECONDS));
 442                 assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis);
 443             }});
 444 
 445         awaitTermination(t);
 446         releaseLock(lock);
 447     }
 448 
 449     /**
 450      * getHoldCount returns number of recursive holds
 451      */
 452     public void testGetHoldCount()      { testGetHoldCount(false); }
 453     public void testGetHoldCount_fair() { testGetHoldCount(true); }
 454     public void testGetHoldCount(boolean fair) {
 455         final ReentrantLock lock = new ReentrantLock(fair);
 456         for (int i = 1; i &lt;= SIZE; i++) {
 457             lock.lock();
 458             assertEquals(i, lock.getHoldCount());
 459         }
 460         for (int i = SIZE; i &gt; 0; i--) {
 461             lock.unlock();
 462             assertEquals(i - 1, lock.getHoldCount());
 463         }
 464     }
 465 
 466     /**
 467      * isLocked is true when locked and false when not
 468      */
 469     public void testIsLocked()      { testIsLocked(false); }
 470     public void testIsLocked_fair() { testIsLocked(true); }
 471     public void testIsLocked(boolean fair) {
 472         final ReentrantLock lock = new ReentrantLock(fair);
 473         try {
 474             assertFalse(lock.isLocked());
 475             lock.lock();
 476             assertTrue(lock.isLocked());
 477             lock.lock();
 478             assertTrue(lock.isLocked());
 479             lock.unlock();
 480             assertTrue(lock.isLocked());
 481             lock.unlock();
 482             assertFalse(lock.isLocked());
 483             final CyclicBarrier barrier = new CyclicBarrier(2);
 484             Thread t = newStartedThread(new CheckedRunnable() {
 485                     public void realRun() throws Exception {
 486                         lock.lock();
 487                         assertTrue(lock.isLocked());
 488                         barrier.await();
 489                         barrier.await();
 490                         lock.unlock();
 491                     }});
 492 
 493             barrier.await();
 494             assertTrue(lock.isLocked());
 495             barrier.await();
 496             awaitTermination(t);
 497             assertFalse(lock.isLocked());
 498         } catch (Exception fail) { threadUnexpectedException(fail); }
 499     }
 500 
 501     /**
 502      * lockInterruptibly succeeds when unlocked, else is interruptible
 503      */
 504     public void testLockInterruptibly()      { testLockInterruptibly(false); }
 505     public void testLockInterruptibly_fair() { testLockInterruptibly(true); }
 506     public void testLockInterruptibly(boolean fair) {
 507         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 508         try {
 509             lock.lockInterruptibly();
 510         } catch (InterruptedException fail) { threadUnexpectedException(fail); }
 511         assertLockedByMoi(lock);
 512         Thread t = newStartedThread(new InterruptedLockRunnable(lock));
 513         waitForQueuedThread(lock, t);
 514         t.interrupt();
 515         assertTrue(lock.isLocked());
 516         assertTrue(lock.isHeldByCurrentThread());
 517         awaitTermination(t);
 518         releaseLock(lock);
 519     }
 520 
 521     /**
 522      * Calling await without holding lock throws IllegalMonitorStateException
 523      */
 524     public void testAwait_IMSE()      { testAwait_IMSE(false); }
 525     public void testAwait_IMSE_fair() { testAwait_IMSE(true); }
 526     public void testAwait_IMSE(boolean fair) {
 527         final ReentrantLock lock = new ReentrantLock(fair);
 528         final Condition c = lock.newCondition();
 529         for (AwaitMethod awaitMethod : AwaitMethod.values()) {
 530             long startTime = System.nanoTime();
 531             try {
 532                 await(c, awaitMethod);
 533                 shouldThrow();
 534             } catch (IllegalMonitorStateException success) {
 535             } catch (InterruptedException e) { threadUnexpectedException(e); }
 536             assertTrue(millisElapsedSince(startTime) &lt; LONG_DELAY_MS);
 537         }
 538     }
 539 
 540     /**
 541      * Calling signal without holding lock throws IllegalMonitorStateException
 542      */
 543     public void testSignal_IMSE()      { testSignal_IMSE(false); }
 544     public void testSignal_IMSE_fair() { testSignal_IMSE(true); }
 545     public void testSignal_IMSE(boolean fair) {
 546         final ReentrantLock lock = new ReentrantLock(fair);
 547         final Condition c = lock.newCondition();
 548         try {
 549             c.signal();
 550             shouldThrow();
 551         } catch (IllegalMonitorStateException success) {}
 552     }
 553 
 554     /**
 555      * awaitNanos without a signal times out
 556      */
 557     public void testAwaitNanos_Timeout()      { testAwaitNanos_Timeout(false); }
 558     public void testAwaitNanos_Timeout_fair() { testAwaitNanos_Timeout(true); }
 559     public void testAwaitNanos_Timeout(boolean fair) {
 560         final ReentrantLock lock = new ReentrantLock(fair);
 561         final Condition c = lock.newCondition();
 562         final long timeoutMillis = timeoutMillis();
 563         final long timeoutNanos = MILLISECONDS.toNanos(timeoutMillis);
 564         lock.lock();
 565         final long startTime = System.nanoTime();
 566         try {
 567             long nanosRemaining = c.awaitNanos(timeoutNanos);
 568             assertTrue(nanosRemaining &lt;= 0);
 569         } catch (InterruptedException fail) { threadUnexpectedException(fail); }
 570         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis);
 571         lock.unlock();
 572     }
 573 
 574     /**
 575      * timed await without a signal times out
 576      */
 577     public void testAwait_Timeout()      { testAwait_Timeout(false); }
 578     public void testAwait_Timeout_fair() { testAwait_Timeout(true); }
 579     public void testAwait_Timeout(boolean fair) {
 580         final ReentrantLock lock = new ReentrantLock(fair);
 581         final Condition c = lock.newCondition();
 582         final long timeoutMillis = timeoutMillis();
 583         lock.lock();
 584         final long startTime = System.nanoTime();
 585         try {
 586             assertFalse(c.await(timeoutMillis, MILLISECONDS));
 587         } catch (InterruptedException fail) { threadUnexpectedException(fail); }
 588         assertTrue(millisElapsedSince(startTime) &gt;= timeoutMillis);
 589         lock.unlock();
 590     }
 591 
 592     /**
 593      * awaitUntil without a signal times out
 594      */
 595     public void testAwaitUntil_Timeout()      { testAwaitUntil_Timeout(false); }
 596     public void testAwaitUntil_Timeout_fair() { testAwaitUntil_Timeout(true); }
 597     public void testAwaitUntil_Timeout(boolean fair) {
 598         final ReentrantLock lock = new ReentrantLock(fair);
 599         final Condition c = lock.newCondition();
 600         lock.lock();
 601         // We shouldn&#39;t assume that nanoTime and currentTimeMillis
 602         // use the same time source, so don&#39;t use nanoTime here.
 603         final java.util.Date delayedDate = delayedDate(timeoutMillis());
 604         try {
 605             assertFalse(c.awaitUntil(delayedDate));
 606         } catch (InterruptedException fail) { threadUnexpectedException(fail); }
 607         assertTrue(new java.util.Date().getTime() &gt;= delayedDate.getTime());
 608         lock.unlock();
 609     }
 610 
 611     /**
 612      * await returns when signalled
 613      */
 614     public void testAwait()      { testAwait(false); }
 615     public void testAwait_fair() { testAwait(true); }
 616     public void testAwait(boolean fair) {
 617         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 618         final Condition c = lock.newCondition();
 619         final CountDownLatch locked = new CountDownLatch(1);
 620         Thread t = newStartedThread(new CheckedRunnable() {
 621             public void realRun() throws InterruptedException {
 622                 lock.lock();
 623                 locked.countDown();
 624                 c.await();
 625                 lock.unlock();
 626             }});
 627 
 628         await(locked);
 629         lock.lock();
 630         assertHasWaiters(lock, c, t);
 631         c.signal();
 632         assertHasNoWaiters(lock, c);
 633         assertTrue(t.isAlive());
 634         lock.unlock();
 635         awaitTermination(t);
 636     }
 637 
 638     /**
 639      * hasWaiters throws NPE if null
 640      */
 641     public void testHasWaitersNPE()      { testHasWaitersNPE(false); }
 642     public void testHasWaitersNPE_fair() { testHasWaitersNPE(true); }
 643     public void testHasWaitersNPE(boolean fair) {
 644         final ReentrantLock lock = new ReentrantLock(fair);
 645         try {
 646             lock.hasWaiters(null);
 647             shouldThrow();
 648         } catch (NullPointerException success) {}
 649     }
 650 
 651     /**
 652      * getWaitQueueLength throws NPE if null
 653      */
 654     public void testGetWaitQueueLengthNPE()      { testGetWaitQueueLengthNPE(false); }
 655     public void testGetWaitQueueLengthNPE_fair() { testGetWaitQueueLengthNPE(true); }
 656     public void testGetWaitQueueLengthNPE(boolean fair) {
 657         final ReentrantLock lock = new ReentrantLock(fair);
 658         try {
 659             lock.getWaitQueueLength(null);
 660             shouldThrow();
 661         } catch (NullPointerException success) {}
 662     }
 663 
 664     /**
 665      * getWaitingThreads throws NPE if null
 666      */
 667     public void testGetWaitingThreadsNPE()      { testGetWaitingThreadsNPE(false); }
 668     public void testGetWaitingThreadsNPE_fair() { testGetWaitingThreadsNPE(true); }
 669     public void testGetWaitingThreadsNPE(boolean fair) {
 670         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 671         try {
 672             lock.getWaitingThreads(null);
 673             shouldThrow();
 674         } catch (NullPointerException success) {}
 675     }
 676 
 677     /**
 678      * hasWaiters throws IllegalArgumentException if not owned
 679      */
 680     public void testHasWaitersIAE()      { testHasWaitersIAE(false); }
 681     public void testHasWaitersIAE_fair() { testHasWaitersIAE(true); }
 682     public void testHasWaitersIAE(boolean fair) {
 683         final ReentrantLock lock = new ReentrantLock(fair);
 684         final Condition c = lock.newCondition();
 685         final ReentrantLock lock2 = new ReentrantLock(fair);
 686         try {
 687             lock2.hasWaiters(c);
 688             shouldThrow();
 689         } catch (IllegalArgumentException success) {}
 690     }
 691 
 692     /**
 693      * hasWaiters throws IllegalMonitorStateException if not locked
 694      */
 695     public void testHasWaitersIMSE()      { testHasWaitersIMSE(false); }
 696     public void testHasWaitersIMSE_fair() { testHasWaitersIMSE(true); }
 697     public void testHasWaitersIMSE(boolean fair) {
 698         final ReentrantLock lock = new ReentrantLock(fair);
 699         final Condition c = lock.newCondition();
 700         try {
 701             lock.hasWaiters(c);
 702             shouldThrow();
 703         } catch (IllegalMonitorStateException success) {}
 704     }
 705 
 706     /**
 707      * getWaitQueueLength throws IllegalArgumentException if not owned
 708      */
 709     public void testGetWaitQueueLengthIAE()      { testGetWaitQueueLengthIAE(false); }
 710     public void testGetWaitQueueLengthIAE_fair() { testGetWaitQueueLengthIAE(true); }
 711     public void testGetWaitQueueLengthIAE(boolean fair) {
 712         final ReentrantLock lock = new ReentrantLock(fair);
 713         final Condition c = lock.newCondition();
 714         final ReentrantLock lock2 = new ReentrantLock(fair);
 715         try {
 716             lock2.getWaitQueueLength(c);
 717             shouldThrow();
 718         } catch (IllegalArgumentException success) {}
 719     }
 720 
 721     /**
 722      * getWaitQueueLength throws IllegalMonitorStateException if not locked
 723      */
 724     public void testGetWaitQueueLengthIMSE()      { testGetWaitQueueLengthIMSE(false); }
 725     public void testGetWaitQueueLengthIMSE_fair() { testGetWaitQueueLengthIMSE(true); }
 726     public void testGetWaitQueueLengthIMSE(boolean fair) {
 727         final ReentrantLock lock = new ReentrantLock(fair);
 728         final Condition c = lock.newCondition();
 729         try {
 730             lock.getWaitQueueLength(c);
 731             shouldThrow();
 732         } catch (IllegalMonitorStateException success) {}
 733     }
 734 
 735     /**
 736      * getWaitingThreads throws IllegalArgumentException if not owned
 737      */
 738     public void testGetWaitingThreadsIAE()      { testGetWaitingThreadsIAE(false); }
 739     public void testGetWaitingThreadsIAE_fair() { testGetWaitingThreadsIAE(true); }
 740     public void testGetWaitingThreadsIAE(boolean fair) {
 741         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 742         final Condition c = lock.newCondition();
 743         final PublicReentrantLock lock2 = new PublicReentrantLock(fair);
 744         try {
 745             lock2.getWaitingThreads(c);
 746             shouldThrow();
 747         } catch (IllegalArgumentException success) {}
 748     }
 749 
 750     /**
 751      * getWaitingThreads throws IllegalMonitorStateException if not locked
 752      */
 753     public void testGetWaitingThreadsIMSE()      { testGetWaitingThreadsIMSE(false); }
 754     public void testGetWaitingThreadsIMSE_fair() { testGetWaitingThreadsIMSE(true); }
 755     public void testGetWaitingThreadsIMSE(boolean fair) {
 756         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 757         final Condition c = lock.newCondition();
 758         try {
 759             lock.getWaitingThreads(c);
 760             shouldThrow();
 761         } catch (IllegalMonitorStateException success) {}
 762     }
 763 
 764     /**
 765      * hasWaiters returns true when a thread is waiting, else false
 766      */
 767     public void testHasWaiters()      { testHasWaiters(false); }
 768     public void testHasWaiters_fair() { testHasWaiters(true); }
 769     public void testHasWaiters(boolean fair) {
 770         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 771         final Condition c = lock.newCondition();
 772         final CountDownLatch pleaseSignal = new CountDownLatch(1);
 773         Thread t = newStartedThread(new CheckedRunnable() {
 774             public void realRun() throws InterruptedException {
 775                 lock.lock();
 776                 assertHasNoWaiters(lock, c);
 777                 assertFalse(lock.hasWaiters(c));
 778                 pleaseSignal.countDown();
 779                 c.await();
 780                 assertHasNoWaiters(lock, c);
 781                 assertFalse(lock.hasWaiters(c));
 782                 lock.unlock();
 783             }});
 784 
 785         await(pleaseSignal);
 786         lock.lock();
 787         assertHasWaiters(lock, c, t);
 788         assertTrue(lock.hasWaiters(c));
 789         c.signal();
 790         assertHasNoWaiters(lock, c);
 791         assertFalse(lock.hasWaiters(c));
 792         lock.unlock();
 793         awaitTermination(t);
 794         assertHasNoWaiters(lock, c);
 795     }
 796 
 797     /**
 798      * getWaitQueueLength returns number of waiting threads
 799      */
 800     public void testGetWaitQueueLength()      { testGetWaitQueueLength(false); }
 801     public void testGetWaitQueueLength_fair() { testGetWaitQueueLength(true); }
 802     public void testGetWaitQueueLength(boolean fair) {
 803         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 804         final Condition c = lock.newCondition();
 805         final CountDownLatch locked1 = new CountDownLatch(1);
 806         final CountDownLatch locked2 = new CountDownLatch(1);
 807         Thread t1 = new Thread(new CheckedRunnable() {
 808             public void realRun() throws InterruptedException {
 809                 lock.lock();
 810                 assertFalse(lock.hasWaiters(c));
 811                 assertEquals(0, lock.getWaitQueueLength(c));
 812                 locked1.countDown();
 813                 c.await();
 814                 lock.unlock();
 815             }});
 816 
 817         Thread t2 = new Thread(new CheckedRunnable() {
 818             public void realRun() throws InterruptedException {
 819                 lock.lock();
 820                 assertTrue(lock.hasWaiters(c));
 821                 assertEquals(1, lock.getWaitQueueLength(c));
 822                 locked2.countDown();
 823                 c.await();
 824                 lock.unlock();
 825             }});
 826 
 827         lock.lock();
 828         assertEquals(0, lock.getWaitQueueLength(c));
 829         lock.unlock();
 830 
 831         t1.start();
 832         await(locked1);
 833 
 834         lock.lock();
 835         assertHasWaiters(lock, c, t1);
 836         assertEquals(1, lock.getWaitQueueLength(c));
 837         lock.unlock();
 838 
 839         t2.start();
 840         await(locked2);
 841 
 842         lock.lock();
 843         assertHasWaiters(lock, c, t1, t2);
 844         assertEquals(2, lock.getWaitQueueLength(c));
 845         c.signalAll();
 846         assertHasNoWaiters(lock, c);
 847         lock.unlock();
 848 
 849         awaitTermination(t1);
 850         awaitTermination(t2);
 851 
 852         assertHasNoWaiters(lock, c);
 853     }
 854 
 855     /**
 856      * getWaitingThreads returns only and all waiting threads
 857      */
 858     public void testGetWaitingThreads()      { testGetWaitingThreads(false); }
 859     public void testGetWaitingThreads_fair() { testGetWaitingThreads(true); }
 860     public void testGetWaitingThreads(boolean fair) {
 861         final PublicReentrantLock lock = new PublicReentrantLock(fair);
 862         final Condition c = lock.newCondition();
 863         final CountDownLatch locked1 = new CountDownLatch(1);
 864         final CountDownLatch locked2 = new CountDownLatch(1);
 865         Thread t1 = new Thread(new CheckedRunnable() {
 866             public void realRun() throws InterruptedException {
 867                 lock.lock();
 868                 assertTrue(lock.getWaitingThreads(c).isEmpty());
 869                 locked1.countDown();
 870                 c.await();
 871                 lock.unlock();
 872             }});
 873 
 874         Thread t2 = new Thread(new CheckedRunnable() {
 875             public void realRun() throws InterruptedException {
 876                 lock.lock();
 877                 assertFalse(lock.getWaitingThreads(c).isEmpty());
 878                 locked2.countDown();
 879                 c.await();
 880                 lock.unlock();
 881             }});
 882 
 883         lock.lock();
 884         assertTrue(lock.getWaitingThreads(c).isEmpty());
 885         lock.unlock();
 886 
 887         t1.start();
 888         await(locked1);
 889 
 890         lock.lock();
 891         assertHasWaiters(lock, c, t1);
 892         assertTrue(lock.getWaitingThreads(c).contains(t1));
 893         assertFalse(lock.getWaitingThreads(c).contains(t2));
 894         assertEquals(1, lock.getWaitingThreads(c).size());
 895         lock.unlock();
 896 
 897         t2.start();
 898         await(locked2);
 899 
 900         lock.lock();
 901         assertHasWaiters(lock, c, t1, t2);
 902         assertTrue(lock.getWaitingThreads(c).contains(t1));
 903         assertTrue(lock.getWaitingThreads(c).contains(t2));
 904         assertEquals(2, lock.getWaitingThreads(c).size());
 905         c.signalAll();
 906         assertHasNoWaiters(lock, c);
 907         lock.unlock();
 908 
 909         awaitTermination(t1);
 910         awaitTermination(t2);
 911 
 912         assertHasNoWaiters(lock, c);
 913     }
 914 
 915     /**
 916      * awaitUninterruptibly is uninterruptible
 917      */
 918     public void testAwaitUninterruptibly()      { testAwaitUninterruptibly(false); }
 919     public void testAwaitUninterruptibly_fair() { testAwaitUninterruptibly(true); }
 920     public void testAwaitUninterruptibly(boolean fair) {
 921         final ReentrantLock lock = new ReentrantLock(fair);
 922         final Condition condition = lock.newCondition();
 923         final CountDownLatch pleaseInterrupt = new CountDownLatch(2);
 924 
 925         Thread t1 = newStartedThread(new CheckedRunnable() {
 926             public void realRun() {
 927                 // Interrupt before awaitUninterruptibly
 928                 lock.lock();
 929                 pleaseInterrupt.countDown();
 930                 Thread.currentThread().interrupt();
 931                 condition.awaitUninterruptibly();
 932                 assertTrue(Thread.interrupted());
 933                 lock.unlock();
 934             }});
 935 
 936         Thread t2 = newStartedThread(new CheckedRunnable() {
 937             public void realRun() {
 938                 // Interrupt during awaitUninterruptibly
 939                 lock.lock();
 940                 pleaseInterrupt.countDown();
 941                 condition.awaitUninterruptibly();
 942                 assertTrue(Thread.interrupted());
 943                 lock.unlock();
 944             }});
 945 
 946         await(pleaseInterrupt);
 947         t2.interrupt();
 948         lock.lock();
 949         lock.unlock();
 950         assertThreadBlocks(t1, Thread.State.WAITING);
 951         assertThreadBlocks(t2, Thread.State.WAITING);
 952 
 953         lock.lock();
 954         condition.signalAll();
 955         lock.unlock();
 956 
 957         awaitTermination(t1);
 958         awaitTermination(t2);
 959     }
 960 
 961     /**
 962      * await/awaitNanos/awaitUntil is interruptible
 963      */
 964     public void testInterruptible_await()           { testInterruptible(false, AwaitMethod.await); }
 965     public void testInterruptible_await_fair()      { testInterruptible(true,  AwaitMethod.await); }
 966     public void testInterruptible_awaitTimed()      { testInterruptible(false, AwaitMethod.awaitTimed); }
 967     public void testInterruptible_awaitTimed_fair() { testInterruptible(true,  AwaitMethod.awaitTimed); }
 968     public void testInterruptible_awaitNanos()      { testInterruptible(false, AwaitMethod.awaitNanos); }
 969     public void testInterruptible_awaitNanos_fair() { testInterruptible(true,  AwaitMethod.awaitNanos); }
 970     public void testInterruptible_awaitUntil()      { testInterruptible(false, AwaitMethod.awaitUntil); }
 971     public void testInterruptible_awaitUntil_fair() { testInterruptible(true,  AwaitMethod.awaitUntil); }
 972     public void testInterruptible(boolean fair, final AwaitMethod awaitMethod) {
 973         final PublicReentrantLock lock =
 974             new PublicReentrantLock(fair);
 975         final Condition c = lock.newCondition();
 976         final CountDownLatch pleaseInterrupt = new CountDownLatch(1);
 977         Thread t = newStartedThread(new CheckedInterruptedRunnable() {
 978             public void realRun() throws InterruptedException {
 979                 lock.lock();
 980                 assertLockedByMoi(lock);
 981                 assertHasNoWaiters(lock, c);
 982                 pleaseInterrupt.countDown();
 983                 try {
 984                     await(c, awaitMethod);
 985                 } finally {
 986                     assertLockedByMoi(lock);
 987                     assertHasNoWaiters(lock, c);
 988                     lock.unlock();
 989                     assertFalse(Thread.interrupted());
 990                 }
 991             }});
 992 
 993         await(pleaseInterrupt);
 994         assertHasWaiters(lock, c, t);
 995         t.interrupt();
 996         awaitTermination(t);
 997         assertNotLocked(lock);
 998     }
 999 
1000     /**
1001      * signalAll wakes up all threads
1002      */
1003     public void testSignalAll_await()           { testSignalAll(false, AwaitMethod.await); }
1004     public void testSignalAll_await_fair()      { testSignalAll(true,  AwaitMethod.await); }
1005     public void testSignalAll_awaitTimed()      { testSignalAll(false, AwaitMethod.awaitTimed); }
1006     public void testSignalAll_awaitTimed_fair() { testSignalAll(true,  AwaitMethod.awaitTimed); }
1007     public void testSignalAll_awaitNanos()      { testSignalAll(false, AwaitMethod.awaitNanos); }
1008     public void testSignalAll_awaitNanos_fair() { testSignalAll(true,  AwaitMethod.awaitNanos); }
1009     public void testSignalAll_awaitUntil()      { testSignalAll(false, AwaitMethod.awaitUntil); }
1010     public void testSignalAll_awaitUntil_fair() { testSignalAll(true,  AwaitMethod.awaitUntil); }
1011     public void testSignalAll(boolean fair, final AwaitMethod awaitMethod) {
1012         final PublicReentrantLock lock = new PublicReentrantLock(fair);
1013         final Condition c = lock.newCondition();
1014         final CountDownLatch pleaseSignal = new CountDownLatch(2);
1015         class Awaiter extends CheckedRunnable {
1016             public void realRun() throws InterruptedException {
1017                 lock.lock();
1018                 pleaseSignal.countDown();
1019                 await(c, awaitMethod);
1020                 lock.unlock();
1021             }
1022         }
1023 
1024         Thread t1 = newStartedThread(new Awaiter());
1025         Thread t2 = newStartedThread(new Awaiter());
1026 
1027         await(pleaseSignal);
1028         lock.lock();
1029         assertHasWaiters(lock, c, t1, t2);
1030         c.signalAll();
1031         assertHasNoWaiters(lock, c);
1032         lock.unlock();
1033         awaitTermination(t1);
1034         awaitTermination(t2);
1035     }
1036 
1037     /**
1038      * signal wakes up waiting threads in FIFO order
1039      */
1040     public void testSignalWakesFifo()      { testSignalWakesFifo(false); }
1041     public void testSignalWakesFifo_fair() { testSignalWakesFifo(true); }
1042     public void testSignalWakesFifo(boolean fair) {
1043         final PublicReentrantLock lock =
1044             new PublicReentrantLock(fair);
1045         final Condition c = lock.newCondition();
1046         final CountDownLatch locked1 = new CountDownLatch(1);
1047         final CountDownLatch locked2 = new CountDownLatch(1);
1048         Thread t1 = newStartedThread(new CheckedRunnable() {
1049             public void realRun() throws InterruptedException {
1050                 lock.lock();
1051                 locked1.countDown();
1052                 c.await();
1053                 lock.unlock();
1054             }});
1055 
1056         await(locked1);
1057 
1058         Thread t2 = newStartedThread(new CheckedRunnable() {
1059             public void realRun() throws InterruptedException {
1060                 lock.lock();
1061                 locked2.countDown();
1062                 c.await();
1063                 lock.unlock();
1064             }});
1065 
1066         await(locked2);
1067 
1068         lock.lock();
1069         assertHasWaiters(lock, c, t1, t2);
1070         assertFalse(lock.hasQueuedThreads());
1071         c.signal();
1072         assertHasWaiters(lock, c, t2);
1073         assertTrue(lock.hasQueuedThread(t1));
1074         assertFalse(lock.hasQueuedThread(t2));
1075         c.signal();
1076         assertHasNoWaiters(lock, c);
1077         assertTrue(lock.hasQueuedThread(t1));
1078         assertTrue(lock.hasQueuedThread(t2));
1079         lock.unlock();
1080         awaitTermination(t1);
1081         awaitTermination(t2);
1082     }
1083 
1084     /**
1085      * await after multiple reentrant locking preserves lock count
1086      */
1087     public void testAwaitLockCount()      { testAwaitLockCount(false); }
1088     public void testAwaitLockCount_fair() { testAwaitLockCount(true); }
1089     public void testAwaitLockCount(boolean fair) {
1090         final PublicReentrantLock lock = new PublicReentrantLock(fair);
1091         final Condition c = lock.newCondition();
1092         final CountDownLatch pleaseSignal = new CountDownLatch(2);
1093         Thread t1 = newStartedThread(new CheckedRunnable() {
1094             public void realRun() throws InterruptedException {
1095                 lock.lock();
1096                 assertLockedByMoi(lock);
1097                 assertEquals(1, lock.getHoldCount());
1098                 pleaseSignal.countDown();
1099                 c.await();
1100                 assertLockedByMoi(lock);
1101                 assertEquals(1, lock.getHoldCount());
1102                 lock.unlock();
1103             }});
1104 
1105         Thread t2 = newStartedThread(new CheckedRunnable() {
1106             public void realRun() throws InterruptedException {
1107                 lock.lock();
1108                 lock.lock();
1109                 assertLockedByMoi(lock);
1110                 assertEquals(2, lock.getHoldCount());
1111                 pleaseSignal.countDown();
1112                 c.await();
1113                 assertLockedByMoi(lock);
1114                 assertEquals(2, lock.getHoldCount());
1115                 lock.unlock();
1116                 lock.unlock();
1117             }});
1118 
1119         await(pleaseSignal);
1120         lock.lock();
1121         assertHasWaiters(lock, c, t1, t2);
1122         assertEquals(1, lock.getHoldCount());
1123         c.signalAll();
1124         assertHasNoWaiters(lock, c);
1125         lock.unlock();
1126         awaitTermination(t1);
1127         awaitTermination(t2);
1128     }
1129 
1130     /**
1131      * A serialized lock deserializes as unlocked
1132      */
1133     public void testSerialization()      { testSerialization(false); }
1134     public void testSerialization_fair() { testSerialization(true); }
1135     public void testSerialization(boolean fair) {
1136         final ReentrantLock lock = new ReentrantLock(fair);
1137         lock.lock();
1138 
1139         ReentrantLock clone = serialClone(lock);
1140         assertEquals(lock.isFair(), clone.isFair());
1141         assertTrue(lock.isLocked());
1142         assertFalse(clone.isLocked());
1143         assertEquals(1, lock.getHoldCount());
1144         assertEquals(0, clone.getHoldCount());
1145         clone.lock();
1146         clone.lock();
1147         assertTrue(clone.isLocked());
1148         assertEquals(2, clone.getHoldCount());
1149         assertEquals(1, lock.getHoldCount());
1150         clone.unlock();
1151         clone.unlock();
1152         assertTrue(lock.isLocked());
1153         assertFalse(clone.isLocked());
1154     }
1155 
1156     /**
1157      * toString indicates current lock state
1158      */
1159     public void testToString()      { testToString(false); }
1160     public void testToString_fair() { testToString(true); }
1161     public void testToString(boolean fair) {
1162         final ReentrantLock lock = new ReentrantLock(fair);
1163         assertTrue(lock.toString().contains(&quot;Unlocked&quot;));
1164         lock.lock();
1165         assertTrue(lock.toString().contains(&quot;Locked by&quot;));
1166         lock.unlock();
1167         assertTrue(lock.toString().contains(&quot;Unlocked&quot;));
1168     }
1169 
1170     /**
1171      * Tests scenario for JDK-8187408
1172      * AbstractQueuedSynchronizer wait queue corrupted when thread awaits without holding the lock
1173      */
1174     public void testBug8187408() throws InterruptedException {
1175         final ThreadLocalRandom rnd = ThreadLocalRandom.current();
1176         final AwaitMethod awaitMethod = randomAwaitMethod();
1177         final int nThreads = rnd.nextInt(2, 10);
1178         final ReentrantLock lock = new ReentrantLock();
1179         final Condition cond = lock.newCondition();
1180         final CountDownLatch done = new CountDownLatch(nThreads);
1181         final ArrayList&lt;Thread&gt; threads = new ArrayList&lt;&gt;();
1182 
1183         Runnable rogue = () -&gt; {
1184             while (done.getCount() &gt; 0) {
1185                 try {
1186                     // call await without holding lock?!
1187                     await(cond, awaitMethod);
1188                     throw new AssertionError(&quot;should throw&quot;);
1189                 }
1190                 catch (IllegalMonitorStateException success) {}
1191                 catch (Throwable fail) { threadUnexpectedException(fail); }}};
1192         Thread rogueThread = new Thread(rogue, &quot;rogue&quot;);
1193         threads.add(rogueThread);
1194         rogueThread.start();
1195 
1196         Runnable waiter = () -&gt; {
1197             lock.lock();
1198             try {
1199                 done.countDown();
1200                 cond.await();
1201             } catch (Throwable fail) {
1202                 threadUnexpectedException(fail);
1203             } finally {
1204                 lock.unlock();
1205             }};
1206         for (int i = 0; i &lt; nThreads; i++) {
1207             Thread thread = new Thread(waiter, &quot;waiter&quot;);
1208             threads.add(thread);
1209             thread.start();
1210         }
1211 
1212         assertTrue(done.await(LONG_DELAY_MS, MILLISECONDS));
1213         lock.lock();
1214         try {
1215             assertEquals(nThreads, lock.getWaitQueueLength(cond));
1216         } finally {
1217             cond.signalAll();
1218             lock.unlock();
1219         }
1220         for (Thread thread : threads) {
1221             thread.join(LONG_DELAY_MS);
1222             assertFalse(thread.isAlive());
1223         }
1224     }
<a name="4" id="anc4"></a>




























































1225 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
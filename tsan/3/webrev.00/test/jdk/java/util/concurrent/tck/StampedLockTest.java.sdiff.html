<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/util/concurrent/tck/StampedLockTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SplittableRandomTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SynchronousQueueTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/util/concurrent/tck/StampedLockTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea and Martin Buchholz
  30  * with assistance from members of JCP JSR-166 Expert Group and
  31  * released to the public domain, as explained at
  32  * http://creativecommons.org/publicdomain/zero/1.0/
  33  */
  34 
  35 import static java.util.concurrent.TimeUnit.DAYS;
  36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  37 
  38 import static java.util.concurrent.locks.StampedLock.isLockStamp;
  39 import static java.util.concurrent.locks.StampedLock.isOptimisticReadStamp;
  40 import static java.util.concurrent.locks.StampedLock.isReadLockStamp;
  41 import static java.util.concurrent.locks.StampedLock.isWriteLockStamp;
  42 
  43 import java.util.ArrayList;
  44 import java.util.List;


  45 import java.util.concurrent.CountDownLatch;
  46 import java.util.concurrent.Future;

  47 import java.util.concurrent.TimeUnit;

  48 import java.util.concurrent.locks.Lock;
  49 import java.util.concurrent.locks.StampedLock;
  50 import java.util.function.BiConsumer;

  51 import java.util.function.Function;
  52 
  53 import junit.framework.Test;
  54 import junit.framework.TestSuite;
  55 
  56 public class StampedLockTest extends JSR166TestCase {
  57     public static void main(String[] args) {
  58         main(suite(), args);
  59     }
  60     public static Test suite() {
  61         return new TestSuite(StampedLockTest.class);
  62     }
  63 
  64     /**
  65      * Releases write lock, checking isWriteLocked before and after
  66      */
  67     void releaseWriteLock(StampedLock lock, long stamp) {
  68         assertTrue(lock.isWriteLocked());
  69         assertValid(lock, stamp);
  70         lock.unlockWrite(stamp);
</pre>
<hr />
<pre>
  85 
  86     long assertNonZero(long v) {
  87         assertTrue(v != 0L);
  88         return v;
  89     }
  90 
  91     long assertValid(StampedLock lock, long stamp) {
  92         assertTrue(stamp != 0L);
  93         assertTrue(lock.validate(stamp));
  94         return stamp;
  95     }
  96 
  97     void assertUnlocked(StampedLock lock) {
  98         assertFalse(lock.isReadLocked());
  99         assertFalse(lock.isWriteLocked());
 100         assertEquals(0, lock.getReadLockCount());
 101         assertValid(lock, lock.tryOptimisticRead());
 102     }
 103 
 104     List&lt;Action&gt; lockLockers(Lock lock) {
<span class="line-modified"> 105         List&lt;Action&gt; lockers = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 106         lockers.add(() -&gt; lock.lock());</span>
<span class="line-modified"> 107         lockers.add(() -&gt; lock.lockInterruptibly());</span>
<span class="line-modified"> 108         lockers.add(() -&gt; lock.tryLock());</span>
<span class="line-modified"> 109         lockers.add(() -&gt; lock.tryLock(Long.MIN_VALUE, DAYS));</span>
<span class="line-modified"> 110         lockers.add(() -&gt; lock.tryLock(0L, DAYS));</span>
<span class="line-modified"> 111         lockers.add(() -&gt; lock.tryLock(Long.MAX_VALUE, DAYS));</span>
<span class="line-removed"> 112         return lockers;</span>
 113     }
 114 
 115     List&lt;Function&lt;StampedLock, Long&gt;&gt; readLockers() {
<span class="line-modified"> 116         List&lt;Function&lt;StampedLock, Long&gt;&gt; readLockers = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 117         readLockers.add(sl -&gt; sl.readLock());</span>
<span class="line-modified"> 118         readLockers.add(sl -&gt; sl.tryReadLock());</span>
<span class="line-modified"> 119         readLockers.add(sl -&gt; readLockInterruptiblyUninterrupted(sl));</span>
<span class="line-modified"> 120         readLockers.add(sl -&gt; tryReadLockUninterrupted(sl, Long.MIN_VALUE, DAYS));</span>
<span class="line-modified"> 121         readLockers.add(sl -&gt; tryReadLockUninterrupted(sl, 0L, DAYS));</span>
<span class="line-modified"> 122         readLockers.add(sl -&gt; sl.tryConvertToReadLock(sl.tryOptimisticRead()));</span>
<span class="line-removed"> 123         return readLockers;</span>
 124     }
 125 
 126     List&lt;BiConsumer&lt;StampedLock, Long&gt;&gt; readUnlockers() {
<span class="line-modified"> 127         List&lt;BiConsumer&lt;StampedLock, Long&gt;&gt; readUnlockers = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 128         readUnlockers.add((sl, stamp) -&gt; sl.unlockRead(stamp));</span>
<span class="line-modified"> 129         readUnlockers.add((sl, stamp) -&gt; assertTrue(sl.tryUnlockRead()));</span>
<span class="line-modified"> 130         readUnlockers.add((sl, stamp) -&gt; sl.asReadLock().unlock());</span>
<span class="line-modified"> 131         readUnlockers.add((sl, stamp) -&gt; sl.unlock(stamp));</span>
<span class="line-modified"> 132         readUnlockers.add((sl, stamp) -&gt; assertValid(sl, sl.tryConvertToOptimisticRead(stamp)));</span>
<span class="line-removed"> 133         return readUnlockers;</span>
 134     }
 135 
 136     List&lt;Function&lt;StampedLock, Long&gt;&gt; writeLockers() {
<span class="line-modified"> 137         List&lt;Function&lt;StampedLock, Long&gt;&gt; writeLockers = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 138         writeLockers.add(sl -&gt; sl.writeLock());</span>
<span class="line-modified"> 139         writeLockers.add(sl -&gt; sl.tryWriteLock());</span>
<span class="line-modified"> 140         writeLockers.add(sl -&gt; writeLockInterruptiblyUninterrupted(sl));</span>
<span class="line-modified"> 141         writeLockers.add(sl -&gt; tryWriteLockUninterrupted(sl, Long.MIN_VALUE, DAYS));</span>
<span class="line-modified"> 142         writeLockers.add(sl -&gt; tryWriteLockUninterrupted(sl, 0L, DAYS));</span>
<span class="line-modified"> 143         writeLockers.add(sl -&gt; sl.tryConvertToWriteLock(sl.tryOptimisticRead()));</span>
<span class="line-removed"> 144         return writeLockers;</span>
 145     }
 146 
 147     List&lt;BiConsumer&lt;StampedLock, Long&gt;&gt; writeUnlockers() {
<span class="line-modified"> 148         List&lt;BiConsumer&lt;StampedLock, Long&gt;&gt; writeUnlockers = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 149         writeUnlockers.add((sl, stamp) -&gt; sl.unlockWrite(stamp));</span>
<span class="line-modified"> 150         writeUnlockers.add((sl, stamp) -&gt; assertTrue(sl.tryUnlockWrite()));</span>
<span class="line-modified"> 151         writeUnlockers.add((sl, stamp) -&gt; sl.asWriteLock().unlock());</span>
<span class="line-modified"> 152         writeUnlockers.add((sl, stamp) -&gt; sl.unlock(stamp));</span>
<span class="line-modified"> 153         writeUnlockers.add((sl, stamp) -&gt; assertValid(sl, sl.tryConvertToOptimisticRead(stamp)));</span>
<span class="line-removed"> 154         return writeUnlockers;</span>
 155     }
 156 
 157     /**
 158      * Constructed StampedLock is in unlocked state
 159      */
 160     public void testConstructor() {
 161         assertUnlocked(new StampedLock());
 162     }
 163 
 164     /**
 165      * write-locking, then unlocking, an unlocked lock succeed
 166      */
 167     public void testWriteLock_lockUnlock() {
 168         StampedLock lock = new StampedLock();
 169 
 170         for (Function&lt;StampedLock, Long&gt; writeLocker : writeLockers())
 171         for (BiConsumer&lt;StampedLock, Long&gt; writeUnlocker : writeUnlockers()) {
 172             assertFalse(lock.isWriteLocked());
 173             assertFalse(lock.isReadLocked());
 174             assertEquals(0, lock.getReadLockCount());
</pre>
<hr />
<pre>
 992         }
 993     }
 994 
 995     /**
 996      * Lock.newCondition throws UnsupportedOperationException
 997      */
 998     public void testLockViewsDoNotSupportConditions() {
 999         StampedLock sl = new StampedLock();
1000         assertThrows(UnsupportedOperationException.class,
1001                      () -&gt; sl.asWriteLock().newCondition(),
1002                      () -&gt; sl.asReadLock().newCondition(),
1003                      () -&gt; sl.asReadWriteLock().writeLock().newCondition(),
1004                      () -&gt; sl.asReadWriteLock().readLock().newCondition());
1005     }
1006 
1007     /**
1008      * Passing optimistic read stamps to unlock operations result in
1009      * IllegalMonitorStateException
1010      */
1011     public void testCannotUnlockOptimisticReadStamps() {
<span class="line-modified">1012         Runnable[] actions = {</span>
<span class="line-modified">1013             () -&gt; {</span>
<span class="line-modified">1014                 StampedLock sl = new StampedLock();</span>
<span class="line-modified">1015                 long stamp = assertValid(sl, sl.tryOptimisticRead());</span>
<span class="line-modified">1016                 sl.unlockRead(stamp);</span>
<span class="line-modified">1017             },</span>
<span class="line-modified">1018             () -&gt; {</span>
<span class="line-modified">1019                 StampedLock sl = new StampedLock();</span>
<span class="line-modified">1020                 long stamp = sl.tryOptimisticRead();</span>
<span class="line-modified">1021                 sl.unlock(stamp);</span>
<span class="line-modified">1022             },</span>
<span class="line-modified">1023 </span>
<span class="line-removed">1024             () -&gt; {</span>
<span class="line-removed">1025                 StampedLock sl = new StampedLock();</span>
<span class="line-removed">1026                 long stamp = sl.tryOptimisticRead();</span>
<span class="line-removed">1027                 sl.writeLock();</span>
<span class="line-removed">1028                 sl.unlock(stamp);</span>
<span class="line-removed">1029             },</span>
<span class="line-removed">1030             () -&gt; {</span>
<span class="line-removed">1031                 StampedLock sl = new StampedLock();</span>
<span class="line-removed">1032                 sl.readLock();</span>
<span class="line-removed">1033                 long stamp = assertValid(sl, sl.tryOptimisticRead());</span>
<span class="line-removed">1034                 sl.unlockRead(stamp);</span>
<span class="line-removed">1035             },</span>
<span class="line-removed">1036             () -&gt; {</span>
<span class="line-removed">1037                 StampedLock sl = new StampedLock();</span>
<span class="line-removed">1038                 sl.readLock();</span>
<span class="line-removed">1039                 long stamp = assertValid(sl, sl.tryOptimisticRead());</span>
<span class="line-removed">1040                 sl.unlock(stamp);</span>
<span class="line-removed">1041             },</span>
1042 
<span class="line-modified">1043             () -&gt; {</span>
<span class="line-modified">1044                 StampedLock sl = new StampedLock();</span>
<span class="line-modified">1045                 long stamp = sl.tryConvertToOptimisticRead(sl.writeLock());</span>
<span class="line-modified">1046                 assertValid(sl, stamp);</span>
<span class="line-modified">1047                 sl.writeLock();</span>
<span class="line-modified">1048                 sl.unlockWrite(stamp);</span>
<span class="line-modified">1049             },</span>
<span class="line-modified">1050             () -&gt; {</span>
<span class="line-modified">1051                 StampedLock sl = new StampedLock();</span>
<span class="line-modified">1052                 long stamp = sl.tryConvertToOptimisticRead(sl.writeLock());</span>
<span class="line-modified">1053                 sl.writeLock();</span>
<span class="line-modified">1054                 sl.unlock(stamp);</span>
<span class="line-modified">1055             },</span>
<span class="line-modified">1056             () -&gt; {</span>
<span class="line-modified">1057                 StampedLock sl = new StampedLock();</span>
<span class="line-modified">1058                 long stamp = sl.tryConvertToOptimisticRead(sl.writeLock());</span>
<span class="line-modified">1059                 sl.readLock();</span>
<span class="line-modified">1060                 sl.unlockRead(stamp);</span>
<span class="line-modified">1061             },</span>
<span class="line-modified">1062             () -&gt; {</span>
<span class="line-modified">1063                 StampedLock sl = new StampedLock();</span>
<span class="line-removed">1064                 long stamp = sl.tryConvertToOptimisticRead(sl.writeLock());</span>
<span class="line-removed">1065                 sl.readLock();</span>
<span class="line-removed">1066                 sl.unlock(stamp);</span>
<span class="line-removed">1067             },</span>
1068 
<span class="line-modified">1069             () -&gt; {</span>
<span class="line-modified">1070                 StampedLock sl = new StampedLock();</span>
<span class="line-modified">1071                 long stamp = sl.tryConvertToOptimisticRead(sl.readLock());</span>
<span class="line-modified">1072                 assertValid(sl, stamp);</span>
<span class="line-modified">1073                 sl.writeLock();</span>
<span class="line-modified">1074                 sl.unlockWrite(stamp);</span>
<span class="line-modified">1075             },</span>
<span class="line-modified">1076             () -&gt; {</span>
<span class="line-modified">1077                 StampedLock sl = new StampedLock();</span>
<span class="line-modified">1078                 long stamp = sl.tryConvertToOptimisticRead(sl.readLock());</span>
<span class="line-modified">1079                 sl.writeLock();</span>
<span class="line-modified">1080                 sl.unlock(stamp);</span>
<span class="line-modified">1081             },</span>
<span class="line-modified">1082             () -&gt; {</span>
<span class="line-modified">1083                 StampedLock sl = new StampedLock();</span>
<span class="line-modified">1084                 long stamp = sl.tryConvertToOptimisticRead(sl.readLock());</span>
<span class="line-modified">1085                 sl.readLock();</span>
<span class="line-modified">1086                 sl.unlockRead(stamp);</span>
<span class="line-modified">1087             },</span>
<span class="line-modified">1088             () -&gt; {</span>
<span class="line-modified">1089                 StampedLock sl = new StampedLock();</span>
<span class="line-modified">1090                 sl.readLock();</span>
<span class="line-modified">1091                 long stamp = sl.tryConvertToOptimisticRead(sl.readLock());</span>
<span class="line-modified">1092                 assertValid(sl, stamp);</span>
<span class="line-modified">1093                 sl.readLock();</span>
<span class="line-modified">1094                 sl.unlockRead(stamp);</span>
<span class="line-modified">1095             },</span>
<span class="line-modified">1096             () -&gt; {</span>
<span class="line-modified">1097                 StampedLock sl = new StampedLock();</span>
<span class="line-removed">1098                 long stamp = sl.tryConvertToOptimisticRead(sl.readLock());</span>
<span class="line-removed">1099                 sl.readLock();</span>
<span class="line-removed">1100                 sl.unlock(stamp);</span>
<span class="line-removed">1101             },</span>
<span class="line-removed">1102             () -&gt; {</span>
<span class="line-removed">1103                 StampedLock sl = new StampedLock();</span>
<span class="line-removed">1104                 sl.readLock();</span>
<span class="line-removed">1105                 long stamp = sl.tryConvertToOptimisticRead(sl.readLock());</span>
<span class="line-removed">1106                 sl.readLock();</span>
<span class="line-removed">1107                 sl.unlock(stamp);</span>
<span class="line-removed">1108             },</span>
<span class="line-removed">1109         };</span>
1110 
<span class="line-modified">1111         assertThrows(IllegalMonitorStateException.class, actions);</span>













































1112     }
1113 
1114     static long writeLockInterruptiblyUninterrupted(StampedLock sl) {
1115         try { return sl.writeLockInterruptibly(); }
1116         catch (InterruptedException ex) { throw new AssertionError(ex); }
1117     }
1118 
1119     static long tryWriteLockUninterrupted(StampedLock sl, long time, TimeUnit unit) {
1120         try { return sl.tryWriteLock(time, unit); }
1121         catch (InterruptedException ex) { throw new AssertionError(ex); }
1122     }
1123 
1124     static long readLockInterruptiblyUninterrupted(StampedLock sl) {
1125         try { return sl.readLockInterruptibly(); }
1126         catch (InterruptedException ex) { throw new AssertionError(ex); }
1127     }
1128 
1129     static long tryReadLockUninterrupted(StampedLock sl, long time, TimeUnit unit) {
1130         try { return sl.tryReadLock(time, unit); }
1131         catch (InterruptedException ex) { throw new AssertionError(ex); }
</pre>
<hr />
<pre>
1385                 assertFalse(isWriteLockStamp(optimisticStamp));
1386                 assertFalse(isReadLockStamp(optimisticStamp));
1387                 assertFalse(isLockStamp(optimisticStamp));
1388                 assertTrue(isOptimisticReadStamp(optimisticStamp));
1389 
1390                 assertFalse(isWriteLockStamp(readStamp));
1391                 assertTrue(isReadLockStamp(readStamp));
1392                 assertTrue(isLockStamp(readStamp));
1393                 assertFalse(isOptimisticReadStamp(readStamp));
1394 
1395                 assertTrue(isWriteLockStamp(writeStamp));
1396                 assertFalse(isReadLockStamp(writeStamp));
1397                 assertTrue(isLockStamp(writeStamp));
1398                 assertFalse(isOptimisticReadStamp(writeStamp));
1399                 if (i == 0)
1400                     lock.unlockWrite(writeStamp);
1401             }
1402         }
1403     }
1404 













































































































1405 }
</pre>
</td>
<td>
<hr />
<pre>
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea and Martin Buchholz
  30  * with assistance from members of JCP JSR-166 Expert Group and
  31  * released to the public domain, as explained at
  32  * http://creativecommons.org/publicdomain/zero/1.0/
  33  */
  34 
  35 import static java.util.concurrent.TimeUnit.DAYS;
  36 import static java.util.concurrent.TimeUnit.MILLISECONDS;
  37 
  38 import static java.util.concurrent.locks.StampedLock.isLockStamp;
  39 import static java.util.concurrent.locks.StampedLock.isOptimisticReadStamp;
  40 import static java.util.concurrent.locks.StampedLock.isReadLockStamp;
  41 import static java.util.concurrent.locks.StampedLock.isWriteLockStamp;
  42 
  43 import java.util.ArrayList;
  44 import java.util.List;
<span class="line-added">  45 import java.util.concurrent.Callable;</span>
<span class="line-added">  46 import java.util.concurrent.CompletableFuture;</span>
  47 import java.util.concurrent.CountDownLatch;
  48 import java.util.concurrent.Future;
<span class="line-added">  49 import java.util.concurrent.ThreadLocalRandom;</span>
  50 import java.util.concurrent.TimeUnit;
<span class="line-added">  51 import java.util.concurrent.atomic.AtomicBoolean;</span>
  52 import java.util.concurrent.locks.Lock;
  53 import java.util.concurrent.locks.StampedLock;
  54 import java.util.function.BiConsumer;
<span class="line-added">  55 import java.util.function.Consumer;</span>
  56 import java.util.function.Function;
  57 
  58 import junit.framework.Test;
  59 import junit.framework.TestSuite;
  60 
  61 public class StampedLockTest extends JSR166TestCase {
  62     public static void main(String[] args) {
  63         main(suite(), args);
  64     }
  65     public static Test suite() {
  66         return new TestSuite(StampedLockTest.class);
  67     }
  68 
  69     /**
  70      * Releases write lock, checking isWriteLocked before and after
  71      */
  72     void releaseWriteLock(StampedLock lock, long stamp) {
  73         assertTrue(lock.isWriteLocked());
  74         assertValid(lock, stamp);
  75         lock.unlockWrite(stamp);
</pre>
<hr />
<pre>
  90 
  91     long assertNonZero(long v) {
  92         assertTrue(v != 0L);
  93         return v;
  94     }
  95 
  96     long assertValid(StampedLock lock, long stamp) {
  97         assertTrue(stamp != 0L);
  98         assertTrue(lock.validate(stamp));
  99         return stamp;
 100     }
 101 
 102     void assertUnlocked(StampedLock lock) {
 103         assertFalse(lock.isReadLocked());
 104         assertFalse(lock.isWriteLocked());
 105         assertEquals(0, lock.getReadLockCount());
 106         assertValid(lock, lock.tryOptimisticRead());
 107     }
 108 
 109     List&lt;Action&gt; lockLockers(Lock lock) {
<span class="line-modified"> 110         return List.of(</span>
<span class="line-modified"> 111             () -&gt; lock.lock(),</span>
<span class="line-modified"> 112             () -&gt; lock.lockInterruptibly(),</span>
<span class="line-modified"> 113             () -&gt; lock.tryLock(),</span>
<span class="line-modified"> 114             () -&gt; lock.tryLock(Long.MIN_VALUE, DAYS),</span>
<span class="line-modified"> 115             () -&gt; lock.tryLock(0L, DAYS),</span>
<span class="line-modified"> 116             () -&gt; lock.tryLock(Long.MAX_VALUE, DAYS));</span>

 117     }
 118 
 119     List&lt;Function&lt;StampedLock, Long&gt;&gt; readLockers() {
<span class="line-modified"> 120         return List.of(</span>
<span class="line-modified"> 121             sl -&gt; sl.readLock(),</span>
<span class="line-modified"> 122             sl -&gt; sl.tryReadLock(),</span>
<span class="line-modified"> 123             sl -&gt; readLockInterruptiblyUninterrupted(sl),</span>
<span class="line-modified"> 124             sl -&gt; tryReadLockUninterrupted(sl, Long.MIN_VALUE, DAYS),</span>
<span class="line-modified"> 125             sl -&gt; tryReadLockUninterrupted(sl, 0L, DAYS),</span>
<span class="line-modified"> 126             sl -&gt; sl.tryConvertToReadLock(sl.tryOptimisticRead()));</span>

 127     }
 128 
 129     List&lt;BiConsumer&lt;StampedLock, Long&gt;&gt; readUnlockers() {
<span class="line-modified"> 130         return List.of(</span>
<span class="line-modified"> 131             (sl, stamp) -&gt; sl.unlockRead(stamp),</span>
<span class="line-modified"> 132             (sl, stamp) -&gt; assertTrue(sl.tryUnlockRead()),</span>
<span class="line-modified"> 133             (sl, stamp) -&gt; sl.asReadLock().unlock(),</span>
<span class="line-modified"> 134             (sl, stamp) -&gt; sl.unlock(stamp),</span>
<span class="line-modified"> 135             (sl, stamp) -&gt; assertValid(sl, sl.tryConvertToOptimisticRead(stamp)));</span>

 136     }
 137 
 138     List&lt;Function&lt;StampedLock, Long&gt;&gt; writeLockers() {
<span class="line-modified"> 139         return List.of(</span>
<span class="line-modified"> 140             sl -&gt; sl.writeLock(),</span>
<span class="line-modified"> 141             sl -&gt; sl.tryWriteLock(),</span>
<span class="line-modified"> 142             sl -&gt; writeLockInterruptiblyUninterrupted(sl),</span>
<span class="line-modified"> 143             sl -&gt; tryWriteLockUninterrupted(sl, Long.MIN_VALUE, DAYS),</span>
<span class="line-modified"> 144             sl -&gt; tryWriteLockUninterrupted(sl, 0L, DAYS),</span>
<span class="line-modified"> 145             sl -&gt; sl.tryConvertToWriteLock(sl.tryOptimisticRead()));</span>

 146     }
 147 
 148     List&lt;BiConsumer&lt;StampedLock, Long&gt;&gt; writeUnlockers() {
<span class="line-modified"> 149         return List.of(</span>
<span class="line-modified"> 150             (sl, stamp) -&gt; sl.unlockWrite(stamp),</span>
<span class="line-modified"> 151             (sl, stamp) -&gt; assertTrue(sl.tryUnlockWrite()),</span>
<span class="line-modified"> 152             (sl, stamp) -&gt; sl.asWriteLock().unlock(),</span>
<span class="line-modified"> 153             (sl, stamp) -&gt; sl.unlock(stamp),</span>
<span class="line-modified"> 154             (sl, stamp) -&gt; assertValid(sl, sl.tryConvertToOptimisticRead(stamp)));</span>

 155     }
 156 
 157     /**
 158      * Constructed StampedLock is in unlocked state
 159      */
 160     public void testConstructor() {
 161         assertUnlocked(new StampedLock());
 162     }
 163 
 164     /**
 165      * write-locking, then unlocking, an unlocked lock succeed
 166      */
 167     public void testWriteLock_lockUnlock() {
 168         StampedLock lock = new StampedLock();
 169 
 170         for (Function&lt;StampedLock, Long&gt; writeLocker : writeLockers())
 171         for (BiConsumer&lt;StampedLock, Long&gt; writeUnlocker : writeUnlockers()) {
 172             assertFalse(lock.isWriteLocked());
 173             assertFalse(lock.isReadLocked());
 174             assertEquals(0, lock.getReadLockCount());
</pre>
<hr />
<pre>
 992         }
 993     }
 994 
 995     /**
 996      * Lock.newCondition throws UnsupportedOperationException
 997      */
 998     public void testLockViewsDoNotSupportConditions() {
 999         StampedLock sl = new StampedLock();
1000         assertThrows(UnsupportedOperationException.class,
1001                      () -&gt; sl.asWriteLock().newCondition(),
1002                      () -&gt; sl.asReadLock().newCondition(),
1003                      () -&gt; sl.asReadWriteLock().writeLock().newCondition(),
1004                      () -&gt; sl.asReadWriteLock().readLock().newCondition());
1005     }
1006 
1007     /**
1008      * Passing optimistic read stamps to unlock operations result in
1009      * IllegalMonitorStateException
1010      */
1011     public void testCannotUnlockOptimisticReadStamps() {
<span class="line-modified">1012         {</span>
<span class="line-modified">1013             StampedLock sl = new StampedLock();</span>
<span class="line-modified">1014             long stamp = assertValid(sl, sl.tryOptimisticRead());</span>
<span class="line-modified">1015             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-modified">1016                 () -&gt; sl.unlockRead(stamp));</span>
<span class="line-modified">1017         }</span>
<span class="line-modified">1018         {</span>
<span class="line-modified">1019             StampedLock sl = new StampedLock();</span>
<span class="line-modified">1020             long stamp = sl.tryOptimisticRead();</span>
<span class="line-modified">1021             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-modified">1022                 () -&gt; sl.unlock(stamp));</span>
<span class="line-modified">1023         }</span>


















1024 
<span class="line-modified">1025         {</span>
<span class="line-modified">1026             StampedLock sl = new StampedLock();</span>
<span class="line-modified">1027             long stamp = sl.tryOptimisticRead();</span>
<span class="line-modified">1028             sl.writeLock();</span>
<span class="line-modified">1029             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-modified">1030                 () -&gt; sl.unlock(stamp));</span>
<span class="line-modified">1031         }</span>
<span class="line-modified">1032         {</span>
<span class="line-modified">1033             StampedLock sl = new StampedLock();</span>
<span class="line-modified">1034             sl.readLock();</span>
<span class="line-modified">1035             long stamp = assertValid(sl, sl.tryOptimisticRead());</span>
<span class="line-modified">1036             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-modified">1037                 () -&gt; sl.unlockRead(stamp));</span>
<span class="line-modified">1038         }</span>
<span class="line-modified">1039         {</span>
<span class="line-modified">1040             StampedLock sl = new StampedLock();</span>
<span class="line-modified">1041             sl.readLock();</span>
<span class="line-modified">1042             long stamp = assertValid(sl, sl.tryOptimisticRead());</span>
<span class="line-modified">1043             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-modified">1044                 () -&gt; sl.unlock(stamp));</span>
<span class="line-modified">1045         }</span>




1046 
<span class="line-modified">1047         {</span>
<span class="line-modified">1048             StampedLock sl = new StampedLock();</span>
<span class="line-modified">1049             long stamp = sl.tryConvertToOptimisticRead(sl.writeLock());</span>
<span class="line-modified">1050             assertValid(sl, stamp);</span>
<span class="line-modified">1051             sl.writeLock();</span>
<span class="line-modified">1052             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-modified">1053                 () -&gt; sl.unlockWrite(stamp));</span>
<span class="line-modified">1054         }</span>
<span class="line-modified">1055         {</span>
<span class="line-modified">1056             StampedLock sl = new StampedLock();</span>
<span class="line-modified">1057             long stamp = sl.tryConvertToOptimisticRead(sl.writeLock());</span>
<span class="line-modified">1058             sl.writeLock();</span>
<span class="line-modified">1059             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-modified">1060                 () -&gt; sl.unlock(stamp));</span>
<span class="line-modified">1061         }</span>
<span class="line-modified">1062         {</span>
<span class="line-modified">1063             StampedLock sl = new StampedLock();</span>
<span class="line-modified">1064             long stamp = sl.tryConvertToOptimisticRead(sl.writeLock());</span>
<span class="line-modified">1065             sl.readLock();</span>
<span class="line-modified">1066             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-modified">1067                 () -&gt; sl.unlockRead(stamp));</span>
<span class="line-modified">1068         }</span>
<span class="line-modified">1069         {</span>
<span class="line-modified">1070             StampedLock sl = new StampedLock();</span>
<span class="line-modified">1071             long stamp = sl.tryConvertToOptimisticRead(sl.writeLock());</span>
<span class="line-modified">1072             sl.readLock();</span>
<span class="line-modified">1073             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-modified">1074                 () -&gt; sl.unlock(stamp));</span>
<span class="line-modified">1075         }</span>












1076 
<span class="line-modified">1077         {</span>
<span class="line-added">1078             StampedLock sl = new StampedLock();</span>
<span class="line-added">1079             long stamp = sl.tryConvertToOptimisticRead(sl.readLock());</span>
<span class="line-added">1080             assertValid(sl, stamp);</span>
<span class="line-added">1081             sl.writeLock();</span>
<span class="line-added">1082             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-added">1083                 () -&gt; sl.unlockWrite(stamp));</span>
<span class="line-added">1084             }</span>
<span class="line-added">1085         {</span>
<span class="line-added">1086             StampedLock sl = new StampedLock();</span>
<span class="line-added">1087             long stamp = sl.tryConvertToOptimisticRead(sl.readLock());</span>
<span class="line-added">1088             sl.writeLock();</span>
<span class="line-added">1089             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-added">1090                 () -&gt; sl.unlock(stamp));</span>
<span class="line-added">1091         }</span>
<span class="line-added">1092         {</span>
<span class="line-added">1093             StampedLock sl = new StampedLock();</span>
<span class="line-added">1094             long stamp = sl.tryConvertToOptimisticRead(sl.readLock());</span>
<span class="line-added">1095             sl.readLock();</span>
<span class="line-added">1096             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-added">1097                 () -&gt; sl.unlockRead(stamp));</span>
<span class="line-added">1098         }</span>
<span class="line-added">1099         {</span>
<span class="line-added">1100             StampedLock sl = new StampedLock();</span>
<span class="line-added">1101             sl.readLock();</span>
<span class="line-added">1102             long stamp = sl.tryConvertToOptimisticRead(sl.readLock());</span>
<span class="line-added">1103             assertValid(sl, stamp);</span>
<span class="line-added">1104             sl.readLock();</span>
<span class="line-added">1105             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-added">1106                 () -&gt; sl.unlockRead(stamp));</span>
<span class="line-added">1107         }</span>
<span class="line-added">1108         {</span>
<span class="line-added">1109             StampedLock sl = new StampedLock();</span>
<span class="line-added">1110             long stamp = sl.tryConvertToOptimisticRead(sl.readLock());</span>
<span class="line-added">1111             sl.readLock();</span>
<span class="line-added">1112             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-added">1113                 () -&gt; sl.unlock(stamp));</span>
<span class="line-added">1114         }</span>
<span class="line-added">1115         {</span>
<span class="line-added">1116             StampedLock sl = new StampedLock();</span>
<span class="line-added">1117             sl.readLock();</span>
<span class="line-added">1118             long stamp = sl.tryConvertToOptimisticRead(sl.readLock());</span>
<span class="line-added">1119             sl.readLock();</span>
<span class="line-added">1120             assertThrows(IllegalMonitorStateException.class,</span>
<span class="line-added">1121                 () -&gt; sl.unlock(stamp));</span>
<span class="line-added">1122         }</span>
1123     }
1124 
1125     static long writeLockInterruptiblyUninterrupted(StampedLock sl) {
1126         try { return sl.writeLockInterruptibly(); }
1127         catch (InterruptedException ex) { throw new AssertionError(ex); }
1128     }
1129 
1130     static long tryWriteLockUninterrupted(StampedLock sl, long time, TimeUnit unit) {
1131         try { return sl.tryWriteLock(time, unit); }
1132         catch (InterruptedException ex) { throw new AssertionError(ex); }
1133     }
1134 
1135     static long readLockInterruptiblyUninterrupted(StampedLock sl) {
1136         try { return sl.readLockInterruptibly(); }
1137         catch (InterruptedException ex) { throw new AssertionError(ex); }
1138     }
1139 
1140     static long tryReadLockUninterrupted(StampedLock sl, long time, TimeUnit unit) {
1141         try { return sl.tryReadLock(time, unit); }
1142         catch (InterruptedException ex) { throw new AssertionError(ex); }
</pre>
<hr />
<pre>
1396                 assertFalse(isWriteLockStamp(optimisticStamp));
1397                 assertFalse(isReadLockStamp(optimisticStamp));
1398                 assertFalse(isLockStamp(optimisticStamp));
1399                 assertTrue(isOptimisticReadStamp(optimisticStamp));
1400 
1401                 assertFalse(isWriteLockStamp(readStamp));
1402                 assertTrue(isReadLockStamp(readStamp));
1403                 assertTrue(isLockStamp(readStamp));
1404                 assertFalse(isOptimisticReadStamp(readStamp));
1405 
1406                 assertTrue(isWriteLockStamp(writeStamp));
1407                 assertFalse(isReadLockStamp(writeStamp));
1408                 assertTrue(isLockStamp(writeStamp));
1409                 assertFalse(isOptimisticReadStamp(writeStamp));
1410                 if (i == 0)
1411                     lock.unlockWrite(writeStamp);
1412             }
1413         }
1414     }
1415 
<span class="line-added">1416     /**</span>
<span class="line-added">1417      * Multiple threads repeatedly contend for the same lock.</span>
<span class="line-added">1418      */</span>
<span class="line-added">1419     public void testConcurrentAccess() throws Exception {</span>
<span class="line-added">1420         final StampedLock sl = new StampedLock();</span>
<span class="line-added">1421         final Lock wl = sl.asWriteLock();</span>
<span class="line-added">1422         final Lock rl = sl.asReadLock();</span>
<span class="line-added">1423         final long testDurationMillis = expensiveTests ? 1000 : 2;</span>
<span class="line-added">1424         final int nTasks = ThreadLocalRandom.current().nextInt(1, 10);</span>
<span class="line-added">1425         final AtomicBoolean done = new AtomicBoolean(false);</span>
<span class="line-added">1426         final List&lt;CompletableFuture&gt; futures = new ArrayList&lt;&gt;();</span>
<span class="line-added">1427         final List&lt;Callable&lt;Long&gt;&gt; stampedWriteLockers = List.of(</span>
<span class="line-added">1428             () -&gt; sl.writeLock(),</span>
<span class="line-added">1429             () -&gt; writeLockInterruptiblyUninterrupted(sl),</span>
<span class="line-added">1430             () -&gt; tryWriteLockUninterrupted(sl, LONG_DELAY_MS, MILLISECONDS),</span>
<span class="line-added">1431             () -&gt; {</span>
<span class="line-added">1432                 long stamp;</span>
<span class="line-added">1433                 do { stamp = sl.tryConvertToWriteLock(sl.tryOptimisticRead()); }</span>
<span class="line-added">1434                 while (stamp == 0L);</span>
<span class="line-added">1435                 return stamp;</span>
<span class="line-added">1436             },</span>
<span class="line-added">1437             () -&gt; {</span>
<span class="line-added">1438               long stamp;</span>
<span class="line-added">1439               do { stamp = sl.tryWriteLock(); } while (stamp == 0L);</span>
<span class="line-added">1440               return stamp;</span>
<span class="line-added">1441             },</span>
<span class="line-added">1442             () -&gt; {</span>
<span class="line-added">1443               long stamp;</span>
<span class="line-added">1444               do { stamp = sl.tryWriteLock(0L, DAYS); } while (stamp == 0L);</span>
<span class="line-added">1445               return stamp;</span>
<span class="line-added">1446             });</span>
<span class="line-added">1447         final List&lt;Callable&lt;Long&gt;&gt; stampedReadLockers = List.of(</span>
<span class="line-added">1448             () -&gt; sl.readLock(),</span>
<span class="line-added">1449             () -&gt; readLockInterruptiblyUninterrupted(sl),</span>
<span class="line-added">1450             () -&gt; tryReadLockUninterrupted(sl, LONG_DELAY_MS, MILLISECONDS),</span>
<span class="line-added">1451             () -&gt; {</span>
<span class="line-added">1452                 long stamp;</span>
<span class="line-added">1453                 do { stamp = sl.tryConvertToReadLock(sl.tryOptimisticRead()); }</span>
<span class="line-added">1454                 while (stamp == 0L);</span>
<span class="line-added">1455                 return stamp;</span>
<span class="line-added">1456             },</span>
<span class="line-added">1457             () -&gt; {</span>
<span class="line-added">1458               long stamp;</span>
<span class="line-added">1459               do { stamp = sl.tryReadLock(); } while (stamp == 0L);</span>
<span class="line-added">1460               return stamp;</span>
<span class="line-added">1461             },</span>
<span class="line-added">1462             () -&gt; {</span>
<span class="line-added">1463               long stamp;</span>
<span class="line-added">1464               do { stamp = sl.tryReadLock(0L, DAYS); } while (stamp == 0L);</span>
<span class="line-added">1465               return stamp;</span>
<span class="line-added">1466             });</span>
<span class="line-added">1467         final List&lt;Consumer&lt;Long&gt;&gt; stampedWriteUnlockers = List.of(</span>
<span class="line-added">1468             stamp -&gt; sl.unlockWrite(stamp),</span>
<span class="line-added">1469             stamp -&gt; sl.unlock(stamp),</span>
<span class="line-added">1470             stamp -&gt; assertTrue(sl.tryUnlockWrite()),</span>
<span class="line-added">1471             stamp -&gt; wl.unlock(),</span>
<span class="line-added">1472             stamp -&gt; sl.tryConvertToOptimisticRead(stamp));</span>
<span class="line-added">1473         final List&lt;Consumer&lt;Long&gt;&gt; stampedReadUnlockers = List.of(</span>
<span class="line-added">1474             stamp -&gt; sl.unlockRead(stamp),</span>
<span class="line-added">1475             stamp -&gt; sl.unlock(stamp),</span>
<span class="line-added">1476             stamp -&gt; assertTrue(sl.tryUnlockRead()),</span>
<span class="line-added">1477             stamp -&gt; rl.unlock(),</span>
<span class="line-added">1478             stamp -&gt; sl.tryConvertToOptimisticRead(stamp));</span>
<span class="line-added">1479         final Action writer = () -&gt; {</span>
<span class="line-added">1480             // repeatedly acquires write lock</span>
<span class="line-added">1481             var locker = chooseRandomly(stampedWriteLockers);</span>
<span class="line-added">1482             var unlocker = chooseRandomly(stampedWriteUnlockers);</span>
<span class="line-added">1483             while (!done.getAcquire()) {</span>
<span class="line-added">1484                 long stamp = locker.call();</span>
<span class="line-added">1485                 try {</span>
<span class="line-added">1486                     assertTrue(isWriteLockStamp(stamp));</span>
<span class="line-added">1487                     assertTrue(sl.isWriteLocked());</span>
<span class="line-added">1488                     assertFalse(isReadLockStamp(stamp));</span>
<span class="line-added">1489                     assertFalse(sl.isReadLocked());</span>
<span class="line-added">1490                     assertEquals(0, sl.getReadLockCount());</span>
<span class="line-added">1491                     assertTrue(sl.validate(stamp));</span>
<span class="line-added">1492                 } finally {</span>
<span class="line-added">1493                     unlocker.accept(stamp);</span>
<span class="line-added">1494                 }</span>
<span class="line-added">1495             }</span>
<span class="line-added">1496         };</span>
<span class="line-added">1497         final Action reader = () -&gt; {</span>
<span class="line-added">1498             // repeatedly acquires read lock</span>
<span class="line-added">1499             var locker = chooseRandomly(stampedReadLockers);</span>
<span class="line-added">1500             var unlocker = chooseRandomly(stampedReadUnlockers);</span>
<span class="line-added">1501             while (!done.getAcquire()) {</span>
<span class="line-added">1502                 long stamp = locker.call();</span>
<span class="line-added">1503                 try {</span>
<span class="line-added">1504                     assertFalse(isWriteLockStamp(stamp));</span>
<span class="line-added">1505                     assertFalse(sl.isWriteLocked());</span>
<span class="line-added">1506                     assertTrue(isReadLockStamp(stamp));</span>
<span class="line-added">1507                     assertTrue(sl.isReadLocked());</span>
<span class="line-added">1508                     assertTrue(sl.getReadLockCount() &gt; 0);</span>
<span class="line-added">1509                     assertTrue(sl.validate(stamp));</span>
<span class="line-added">1510                 } finally {</span>
<span class="line-added">1511                     unlocker.accept(stamp);</span>
<span class="line-added">1512                 }</span>
<span class="line-added">1513             }</span>
<span class="line-added">1514         };</span>
<span class="line-added">1515         for (int i = nTasks; i--&gt; 0; ) {</span>
<span class="line-added">1516             Action task = chooseRandomly(writer, reader);</span>
<span class="line-added">1517             futures.add(CompletableFuture.runAsync(checkedRunnable(task)));</span>
<span class="line-added">1518         }</span>
<span class="line-added">1519         Thread.sleep(testDurationMillis);</span>
<span class="line-added">1520         done.setRelease(true);</span>
<span class="line-added">1521         for (var future : futures)</span>
<span class="line-added">1522             checkTimedGet(future, null);</span>
<span class="line-added">1523     }</span>
<span class="line-added">1524 </span>
1525 }
</pre>
</td>
</tr>
</table>
<center><a href="SplittableRandomTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SynchronousQueueTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
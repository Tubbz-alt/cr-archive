<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/util/concurrent/tck/ConcurrentSkipListMapTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  */
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea with assistance from members of JCP JSR-166
  30  * Expert Group and released to the public domain, as explained at
  31  * http://creativecommons.org/publicdomain/zero/1.0/
  32  */
  33 
  34 import java.util.ArrayList;
  35 import java.util.Arrays;
  36 import java.util.BitSet;
  37 import java.util.Collection;
  38 import java.util.Iterator;
  39 import java.util.Map;
  40 import java.util.NavigableMap;
  41 import java.util.NavigableSet;
  42 import java.util.NoSuchElementException;
  43 import java.util.Random;
  44 import java.util.Set;
  45 import java.util.concurrent.ConcurrentSkipListMap;
  46 
  47 import junit.framework.Test;
  48 
  49 public class ConcurrentSkipListMapTest extends JSR166TestCase {
  50     public static void main(String[] args) {
  51         main(suite(), args);
  52     }
  53     public static Test suite() {
  54         class Implementation implements MapImplementation {
  55             public Class&lt;?&gt; klazz() { return ConcurrentSkipListMap.class; }
  56             public Map emptyMap() { return new ConcurrentSkipListMap(); }
  57             public boolean isConcurrent() { return true; }
  58             public boolean remappingFunctionCalledAtMostOnce() { return false; };
  59             public boolean permitsNullKeys() { return false; }
  60             public boolean permitsNullValues() { return false; }
  61             public boolean supportsSetValue() { return false; }
  62         }
  63         return newTestSuite(
  64             ConcurrentSkipListMapTest.class,
  65             MapTest.testSuite(new Implementation()));
  66     }
  67 
  68     /**
  69      * Returns a new map from Integers 1-5 to Strings &quot;A&quot;-&quot;E&quot;.
  70      */
  71     private static ConcurrentSkipListMap map5() {
  72         ConcurrentSkipListMap map = new ConcurrentSkipListMap();
  73         assertTrue(map.isEmpty());
  74         map.put(one, &quot;A&quot;);
  75         map.put(five, &quot;E&quot;);
  76         map.put(three, &quot;C&quot;);
  77         map.put(two, &quot;B&quot;);
  78         map.put(four, &quot;D&quot;);
  79         assertFalse(map.isEmpty());
  80         assertEquals(5, map.size());
  81         return map;
  82     }
  83 
  84     /**
  85      * clear removes all pairs
  86      */
  87     public void testClear() {
  88         ConcurrentSkipListMap map = map5();
  89         map.clear();
  90         assertEquals(0, map.size());
  91     }
  92 
  93     /**
  94      * copy constructor creates map equal to source map
  95      */
  96     public void testConstructFromSorted() {
  97         ConcurrentSkipListMap map = map5();
  98         ConcurrentSkipListMap map2 = new ConcurrentSkipListMap(map);
  99         assertEquals(map, map2);
 100     }
 101 
 102     /**
 103      * Maps with same contents are equal
 104      */
 105     public void testEquals() {
 106         ConcurrentSkipListMap map1 = map5();
 107         ConcurrentSkipListMap map2 = map5();
 108         assertEquals(map1, map2);
 109         assertEquals(map2, map1);
 110         map1.clear();
 111         assertFalse(map1.equals(map2));
 112         assertFalse(map2.equals(map1));
 113     }
 114 
 115     /**
 116      * containsKey returns true for contained key
 117      */
 118     public void testContainsKey() {
 119         ConcurrentSkipListMap map = map5();
 120         assertTrue(map.containsKey(one));
 121         assertFalse(map.containsKey(zero));
 122     }
 123 
 124     /**
 125      * containsValue returns true for held values
 126      */
 127     public void testContainsValue() {
 128         ConcurrentSkipListMap map = map5();
 129         assertTrue(map.containsValue(&quot;A&quot;));
 130         assertFalse(map.containsValue(&quot;Z&quot;));
 131     }
 132 
 133     /**
 134      * get returns the correct element at the given key,
 135      * or null if not present
 136      */
 137     public void testGet() {
 138         ConcurrentSkipListMap map = map5();
 139         assertEquals(&quot;A&quot;, (String)map.get(one));
 140         ConcurrentSkipListMap empty = new ConcurrentSkipListMap();
 141         assertNull(empty.get(one));
 142     }
 143 
 144     /**
 145      * isEmpty is true of empty map and false for non-empty
 146      */
 147     public void testIsEmpty() {
 148         ConcurrentSkipListMap empty = new ConcurrentSkipListMap();
 149         ConcurrentSkipListMap map = map5();
 150         assertTrue(empty.isEmpty());
 151         assertFalse(map.isEmpty());
 152     }
 153 
 154     /**
 155      * firstKey returns first key
 156      */
 157     public void testFirstKey() {
 158         ConcurrentSkipListMap map = map5();
 159         assertEquals(one, map.firstKey());
 160     }
 161 
 162     /**
 163      * lastKey returns last key
 164      */
 165     public void testLastKey() {
 166         ConcurrentSkipListMap map = map5();
 167         assertEquals(five, map.lastKey());
 168     }
 169 
 170     /**
 171      * keySet.toArray returns contains all keys
 172      */
 173     public void testKeySetToArray() {
 174         ConcurrentSkipListMap map = map5();
 175         Set s = map.keySet();
 176         Object[] ar = s.toArray();
 177         assertTrue(s.containsAll(Arrays.asList(ar)));
 178         assertEquals(5, ar.length);
 179         ar[0] = m10;
 180         assertFalse(s.containsAll(Arrays.asList(ar)));
 181     }
 182 
 183     /**
 184      * descendingkeySet.toArray returns contains all keys
 185      */
 186     public void testDescendingKeySetToArray() {
 187         ConcurrentSkipListMap map = map5();
 188         Set s = map.descendingKeySet();
 189         Object[] ar = s.toArray();
 190         assertEquals(5, ar.length);
 191         assertTrue(s.containsAll(Arrays.asList(ar)));
 192         ar[0] = m10;
 193         assertFalse(s.containsAll(Arrays.asList(ar)));
 194     }
 195 
 196     /**
 197      * keySet returns a Set containing all the keys
 198      */
 199     public void testKeySet() {
 200         ConcurrentSkipListMap map = map5();
 201         Set s = map.keySet();
 202         assertEquals(5, s.size());
 203         assertTrue(s.contains(one));
 204         assertTrue(s.contains(two));
 205         assertTrue(s.contains(three));
 206         assertTrue(s.contains(four));
 207         assertTrue(s.contains(five));
 208     }
 209 
 210     /**
 211      * keySet is ordered
 212      */
 213     public void testKeySetOrder() {
 214         ConcurrentSkipListMap map = map5();
 215         Set s = map.keySet();
 216         Iterator i = s.iterator();
 217         Integer last = (Integer)i.next();
 218         assertEquals(last, one);
 219         int count = 1;
 220         while (i.hasNext()) {
 221             Integer k = (Integer)i.next();
 222             assertTrue(last.compareTo(k) &lt; 0);
 223             last = k;
 224             ++count;
 225         }
 226         assertEquals(5, count);
 227     }
 228 
 229     /**
 230      * descending iterator of key set is inverse ordered
 231      */
 232     public void testKeySetDescendingIteratorOrder() {
 233         ConcurrentSkipListMap map = map5();
 234         NavigableSet s = map.navigableKeySet();
 235         Iterator i = s.descendingIterator();
 236         Integer last = (Integer)i.next();
 237         assertEquals(last, five);
 238         int count = 1;
 239         while (i.hasNext()) {
 240             Integer k = (Integer)i.next();
 241             assertTrue(last.compareTo(k) &gt; 0);
 242             last = k;
 243             ++count;
 244         }
 245         assertEquals(5, count);
 246     }
 247 
 248     /**
 249      * descendingKeySet is ordered
 250      */
 251     public void testDescendingKeySetOrder() {
 252         ConcurrentSkipListMap map = map5();
 253         Set s = map.descendingKeySet();
 254         Iterator i = s.iterator();
 255         Integer last = (Integer)i.next();
 256         assertEquals(last, five);
 257         int count = 1;
 258         while (i.hasNext()) {
 259             Integer k = (Integer)i.next();
 260             assertTrue(last.compareTo(k) &gt; 0);
 261             last = k;
 262             ++count;
 263         }
 264         assertEquals(5, count);
 265     }
 266 
 267     /**
 268      * descending iterator of descendingKeySet is ordered
 269      */
 270     public void testDescendingKeySetDescendingIteratorOrder() {
 271         ConcurrentSkipListMap map = map5();
 272         NavigableSet s = map.descendingKeySet();
 273         Iterator i = s.descendingIterator();
 274         Integer last = (Integer)i.next();
 275         assertEquals(last, one);
 276         int count = 1;
 277         while (i.hasNext()) {
 278             Integer k = (Integer)i.next();
 279             assertTrue(last.compareTo(k) &lt; 0);
 280             last = k;
 281             ++count;
 282         }
 283         assertEquals(5, count);
 284     }
 285 
 286     /**
 287      * Values.toArray contains all values
 288      */
 289     public void testValuesToArray() {
 290         ConcurrentSkipListMap map = map5();
 291         Collection v = map.values();
 292         Object[] ar = v.toArray();
 293         ArrayList s = new ArrayList(Arrays.asList(ar));
 294         assertEquals(5, ar.length);
 295         assertTrue(s.contains(&quot;A&quot;));
 296         assertTrue(s.contains(&quot;B&quot;));
 297         assertTrue(s.contains(&quot;C&quot;));
 298         assertTrue(s.contains(&quot;D&quot;));
 299         assertTrue(s.contains(&quot;E&quot;));
 300     }
 301 
 302     /**
 303      * values collection contains all values
 304      */
 305     public void testValues() {
 306         ConcurrentSkipListMap map = map5();
 307         Collection s = map.values();
 308         assertEquals(5, s.size());
 309         assertTrue(s.contains(&quot;A&quot;));
 310         assertTrue(s.contains(&quot;B&quot;));
 311         assertTrue(s.contains(&quot;C&quot;));
 312         assertTrue(s.contains(&quot;D&quot;));
 313         assertTrue(s.contains(&quot;E&quot;));
 314     }
 315 
 316     /**
 317      * entrySet contains all pairs
 318      */
 319     public void testEntrySet() {
 320         ConcurrentSkipListMap map = map5();
 321         Set s = map.entrySet();
 322         assertEquals(5, s.size());
 323         Iterator it = s.iterator();
 324         while (it.hasNext()) {
 325             Map.Entry e = (Map.Entry) it.next();
 326             assertTrue(
 327                        (e.getKey().equals(one) &amp;&amp; e.getValue().equals(&quot;A&quot;)) ||
 328                        (e.getKey().equals(two) &amp;&amp; e.getValue().equals(&quot;B&quot;)) ||
 329                        (e.getKey().equals(three) &amp;&amp; e.getValue().equals(&quot;C&quot;)) ||
 330                        (e.getKey().equals(four) &amp;&amp; e.getValue().equals(&quot;D&quot;)) ||
 331                        (e.getKey().equals(five) &amp;&amp; e.getValue().equals(&quot;E&quot;)));
 332         }
 333     }
 334 
 335     /**
 336      * descendingEntrySet contains all pairs
 337      */
 338     public void testDescendingEntrySet() {
 339         ConcurrentSkipListMap map = map5();
 340         Set s = map.descendingMap().entrySet();
 341         assertEquals(5, s.size());
 342         Iterator it = s.iterator();
 343         while (it.hasNext()) {
 344             Map.Entry e = (Map.Entry) it.next();
 345             assertTrue(
 346                        (e.getKey().equals(one) &amp;&amp; e.getValue().equals(&quot;A&quot;)) ||
 347                        (e.getKey().equals(two) &amp;&amp; e.getValue().equals(&quot;B&quot;)) ||
 348                        (e.getKey().equals(three) &amp;&amp; e.getValue().equals(&quot;C&quot;)) ||
 349                        (e.getKey().equals(four) &amp;&amp; e.getValue().equals(&quot;D&quot;)) ||
 350                        (e.getKey().equals(five) &amp;&amp; e.getValue().equals(&quot;E&quot;)));
 351         }
 352     }
 353 
 354     /**
 355      * entrySet.toArray contains all entries
 356      */
 357     public void testEntrySetToArray() {
 358         ConcurrentSkipListMap map = map5();
 359         Set s = map.entrySet();
 360         Object[] ar = s.toArray();
 361         assertEquals(5, ar.length);
 362         for (int i = 0; i &lt; 5; ++i) {
 363             assertTrue(map.containsKey(((Map.Entry)(ar[i])).getKey()));
 364             assertTrue(map.containsValue(((Map.Entry)(ar[i])).getValue()));
 365         }
 366     }
 367 
 368     /**
 369      * descendingEntrySet.toArray contains all entries
 370      */
 371     public void testDescendingEntrySetToArray() {
 372         ConcurrentSkipListMap map = map5();
 373         Set s = map.descendingMap().entrySet();
 374         Object[] ar = s.toArray();
 375         assertEquals(5, ar.length);
 376         for (int i = 0; i &lt; 5; ++i) {
 377             assertTrue(map.containsKey(((Map.Entry)(ar[i])).getKey()));
 378             assertTrue(map.containsValue(((Map.Entry)(ar[i])).getValue()));
 379         }
 380     }
 381 
 382     /**
 383      * putAll adds all key-value pairs from the given map
 384      */
 385     public void testPutAll() {
 386         ConcurrentSkipListMap empty = new ConcurrentSkipListMap();
 387         ConcurrentSkipListMap map = map5();
 388         empty.putAll(map);
 389         assertEquals(5, empty.size());
 390         assertTrue(empty.containsKey(one));
 391         assertTrue(empty.containsKey(two));
 392         assertTrue(empty.containsKey(three));
 393         assertTrue(empty.containsKey(four));
 394         assertTrue(empty.containsKey(five));
 395     }
 396 
 397     /**
 398      * putIfAbsent works when the given key is not present
 399      */
 400     public void testPutIfAbsent() {
 401         ConcurrentSkipListMap map = map5();
 402         map.putIfAbsent(six, &quot;Z&quot;);
 403         assertTrue(map.containsKey(six));
 404     }
 405 
 406     /**
 407      * putIfAbsent does not add the pair if the key is already present
 408      */
 409     public void testPutIfAbsent2() {
 410         ConcurrentSkipListMap map = map5();
 411         assertEquals(&quot;A&quot;, map.putIfAbsent(one, &quot;Z&quot;));
 412     }
 413 
 414     /**
 415      * replace fails when the given key is not present
 416      */
 417     public void testReplace() {
 418         ConcurrentSkipListMap map = map5();
 419         assertNull(map.replace(six, &quot;Z&quot;));
 420         assertFalse(map.containsKey(six));
 421     }
 422 
 423     /**
 424      * replace succeeds if the key is already present
 425      */
 426     public void testReplace2() {
 427         ConcurrentSkipListMap map = map5();
 428         assertNotNull(map.replace(one, &quot;Z&quot;));
 429         assertEquals(&quot;Z&quot;, map.get(one));
 430     }
 431 
 432     /**
 433      * replace value fails when the given key not mapped to expected value
 434      */
 435     public void testReplaceValue() {
 436         ConcurrentSkipListMap map = map5();
 437         assertEquals(&quot;A&quot;, map.get(one));
 438         assertFalse(map.replace(one, &quot;Z&quot;, &quot;Z&quot;));
 439         assertEquals(&quot;A&quot;, map.get(one));
 440     }
 441 
 442     /**
 443      * replace value succeeds when the given key mapped to expected value
 444      */
 445     public void testReplaceValue2() {
 446         ConcurrentSkipListMap map = map5();
 447         assertEquals(&quot;A&quot;, map.get(one));
 448         assertTrue(map.replace(one, &quot;A&quot;, &quot;Z&quot;));
 449         assertEquals(&quot;Z&quot;, map.get(one));
 450     }
 451 
 452     /**
 453      * remove removes the correct key-value pair from the map
 454      */
 455     public void testRemove() {
 456         ConcurrentSkipListMap map = map5();
 457         map.remove(five);
 458         assertEquals(4, map.size());
 459         assertFalse(map.containsKey(five));
 460     }
 461 
 462     /**
 463      * remove(key,value) removes only if pair present
 464      */
 465     public void testRemove2() {
 466         ConcurrentSkipListMap map = map5();
 467         assertTrue(map.containsKey(five));
 468         assertEquals(&quot;E&quot;, map.get(five));
 469         map.remove(five, &quot;E&quot;);
 470         assertEquals(4, map.size());
 471         assertFalse(map.containsKey(five));
 472         map.remove(four, &quot;A&quot;);
 473         assertEquals(4, map.size());
 474         assertTrue(map.containsKey(four));
 475     }
 476 
 477     /**
 478      * lowerEntry returns preceding entry.
 479      */
 480     public void testLowerEntry() {
 481         ConcurrentSkipListMap map = map5();
 482         Map.Entry e1 = map.lowerEntry(three);
 483         assertEquals(two, e1.getKey());
 484 
 485         Map.Entry e2 = map.lowerEntry(six);
 486         assertEquals(five, e2.getKey());
 487 
 488         Map.Entry e3 = map.lowerEntry(one);
 489         assertNull(e3);
 490 
 491         Map.Entry e4 = map.lowerEntry(zero);
 492         assertNull(e4);
 493     }
 494 
 495     /**
 496      * higherEntry returns next entry.
 497      */
 498     public void testHigherEntry() {
 499         ConcurrentSkipListMap map = map5();
 500         Map.Entry e1 = map.higherEntry(three);
 501         assertEquals(four, e1.getKey());
 502 
 503         Map.Entry e2 = map.higherEntry(zero);
 504         assertEquals(one, e2.getKey());
 505 
 506         Map.Entry e3 = map.higherEntry(five);
 507         assertNull(e3);
 508 
 509         Map.Entry e4 = map.higherEntry(six);
 510         assertNull(e4);
 511     }
 512 
 513     /**
 514      * floorEntry returns preceding entry.
 515      */
 516     public void testFloorEntry() {
 517         ConcurrentSkipListMap map = map5();
 518         Map.Entry e1 = map.floorEntry(three);
 519         assertEquals(three, e1.getKey());
 520 
 521         Map.Entry e2 = map.floorEntry(six);
 522         assertEquals(five, e2.getKey());
 523 
 524         Map.Entry e3 = map.floorEntry(one);
 525         assertEquals(one, e3.getKey());
 526 
 527         Map.Entry e4 = map.floorEntry(zero);
 528         assertNull(e4);
 529     }
 530 
 531     /**
 532      * ceilingEntry returns next entry.
 533      */
 534     public void testCeilingEntry() {
 535         ConcurrentSkipListMap map = map5();
 536         Map.Entry e1 = map.ceilingEntry(three);
 537         assertEquals(three, e1.getKey());
 538 
 539         Map.Entry e2 = map.ceilingEntry(zero);
 540         assertEquals(one, e2.getKey());
 541 
 542         Map.Entry e3 = map.ceilingEntry(five);
 543         assertEquals(five, e3.getKey());
 544 
 545         Map.Entry e4 = map.ceilingEntry(six);
 546         assertNull(e4);
 547     }
 548 
 549     /**
 550      * lowerEntry, higherEntry, ceilingEntry, and floorEntry return
 551      * immutable entries
 552      */
 553     public void testEntryImmutability() {
 554         ConcurrentSkipListMap map = map5();
 555         Map.Entry e = map.lowerEntry(three);
 556         assertEquals(two, e.getKey());
 557         try {
 558             e.setValue(&quot;X&quot;);
 559             shouldThrow();
 560         } catch (UnsupportedOperationException success) {}
 561         e = map.higherEntry(zero);
 562         assertEquals(one, e.getKey());
 563         try {
 564             e.setValue(&quot;X&quot;);
 565             shouldThrow();
 566         } catch (UnsupportedOperationException success) {}
 567         e = map.floorEntry(one);
 568         assertEquals(one, e.getKey());
 569         try {
 570             e.setValue(&quot;X&quot;);
 571             shouldThrow();
 572         } catch (UnsupportedOperationException success) {}
 573         e = map.ceilingEntry(five);
 574         assertEquals(five, e.getKey());
 575         try {
 576             e.setValue(&quot;X&quot;);
 577             shouldThrow();
 578         } catch (UnsupportedOperationException success) {}
 579     }
 580 
 581     /**
 582      * lowerKey returns preceding element
 583      */
 584     public void testLowerKey() {
 585         ConcurrentSkipListMap q = map5();
 586         Object e1 = q.lowerKey(three);
 587         assertEquals(two, e1);
 588 
 589         Object e2 = q.lowerKey(six);
 590         assertEquals(five, e2);
 591 
 592         Object e3 = q.lowerKey(one);
 593         assertNull(e3);
 594 
 595         Object e4 = q.lowerKey(zero);
 596         assertNull(e4);
 597     }
 598 
 599     /**
 600      * higherKey returns next element
 601      */
 602     public void testHigherKey() {
 603         ConcurrentSkipListMap q = map5();
 604         Object e1 = q.higherKey(three);
 605         assertEquals(four, e1);
 606 
 607         Object e2 = q.higherKey(zero);
 608         assertEquals(one, e2);
 609 
 610         Object e3 = q.higherKey(five);
 611         assertNull(e3);
 612 
 613         Object e4 = q.higherKey(six);
 614         assertNull(e4);
 615     }
 616 
 617     /**
 618      * floorKey returns preceding element
 619      */
 620     public void testFloorKey() {
 621         ConcurrentSkipListMap q = map5();
 622         Object e1 = q.floorKey(three);
 623         assertEquals(three, e1);
 624 
 625         Object e2 = q.floorKey(six);
 626         assertEquals(five, e2);
 627 
 628         Object e3 = q.floorKey(one);
 629         assertEquals(one, e3);
 630 
 631         Object e4 = q.floorKey(zero);
 632         assertNull(e4);
 633     }
 634 
 635     /**
 636      * ceilingKey returns next element
 637      */
 638     public void testCeilingKey() {
 639         ConcurrentSkipListMap q = map5();
 640         Object e1 = q.ceilingKey(three);
 641         assertEquals(three, e1);
 642 
 643         Object e2 = q.ceilingKey(zero);
 644         assertEquals(one, e2);
 645 
 646         Object e3 = q.ceilingKey(five);
 647         assertEquals(five, e3);
 648 
 649         Object e4 = q.ceilingKey(six);
 650         assertNull(e4);
 651     }
 652 
 653     /**
 654      * pollFirstEntry returns entries in order
 655      */
 656     public void testPollFirstEntry() {
 657         ConcurrentSkipListMap map = map5();
 658         Map.Entry e = map.pollFirstEntry();
 659         assertEquals(one, e.getKey());
 660         assertEquals(&quot;A&quot;, e.getValue());
 661         e = map.pollFirstEntry();
 662         assertEquals(two, e.getKey());
 663         map.put(one, &quot;A&quot;);
 664         e = map.pollFirstEntry();
 665         assertEquals(one, e.getKey());
 666         assertEquals(&quot;A&quot;, e.getValue());
 667         e = map.pollFirstEntry();
 668         assertEquals(three, e.getKey());
 669         map.remove(four);
 670         e = map.pollFirstEntry();
 671         assertEquals(five, e.getKey());
 672         try {
 673             e.setValue(&quot;A&quot;);
 674             shouldThrow();
 675         } catch (UnsupportedOperationException success) {}
 676         e = map.pollFirstEntry();
 677         assertNull(e);
 678     }
 679 
 680     /**
 681      * pollLastEntry returns entries in order
 682      */
 683     public void testPollLastEntry() {
 684         ConcurrentSkipListMap map = map5();
 685         Map.Entry e = map.pollLastEntry();
 686         assertEquals(five, e.getKey());
 687         assertEquals(&quot;E&quot;, e.getValue());
 688         e = map.pollLastEntry();
 689         assertEquals(four, e.getKey());
 690         map.put(five, &quot;E&quot;);
 691         e = map.pollLastEntry();
 692         assertEquals(five, e.getKey());
 693         assertEquals(&quot;E&quot;, e.getValue());
 694         e = map.pollLastEntry();
 695         assertEquals(three, e.getKey());
 696         map.remove(two);
 697         e = map.pollLastEntry();
 698         assertEquals(one, e.getKey());
 699         try {
 700             e.setValue(&quot;E&quot;);
 701             shouldThrow();
 702         } catch (UnsupportedOperationException success) {}
 703         e = map.pollLastEntry();
 704         assertNull(e);
 705     }
 706 
 707     /**
 708      * size returns the correct values
 709      */
 710     public void testSize() {
 711         ConcurrentSkipListMap map = map5();
 712         ConcurrentSkipListMap empty = new ConcurrentSkipListMap();
 713         assertEquals(0, empty.size());
 714         assertEquals(5, map.size());
 715     }
 716 
 717     /**
 718      * toString contains toString of elements
 719      */
 720     public void testToString() {
 721         ConcurrentSkipListMap map = map5();
 722         String s = map.toString();
 723         for (int i = 1; i &lt;= 5; ++i) {
 724             assertTrue(s.contains(String.valueOf(i)));
 725         }
 726     }
 727 
 728     // Exception tests
 729 
 730     /**
 731      * get(null) of nonempty map throws NPE
 732      */
 733     public void testGet_NullPointerException() {
 734         ConcurrentSkipListMap c = map5();
 735         try {
 736             c.get(null);
 737             shouldThrow();
 738         } catch (NullPointerException success) {}
 739     }
 740 
 741     /**
 742      * containsKey(null) of nonempty map throws NPE
 743      */
 744     public void testContainsKey_NullPointerException() {
 745         ConcurrentSkipListMap c = map5();
 746         try {
 747             c.containsKey(null);
 748             shouldThrow();
 749         } catch (NullPointerException success) {}
 750     }
 751 
 752     /**
 753      * containsValue(null) throws NPE
 754      */
 755     public void testContainsValue_NullPointerException() {
 756         ConcurrentSkipListMap c = new ConcurrentSkipListMap();
 757         try {
 758             c.containsValue(null);
 759             shouldThrow();
 760         } catch (NullPointerException success) {}
 761     }
 762 
 763     /**
 764      * put(null,x) throws NPE
 765      */
 766     public void testPut1_NullPointerException() {
 767         ConcurrentSkipListMap c = map5();
 768         try {
 769             c.put(null, &quot;whatever&quot;);
 770             shouldThrow();
 771         } catch (NullPointerException success) {}
 772     }
 773 
 774     /**
 775      * putIfAbsent(null, x) throws NPE
 776      */
 777     public void testPutIfAbsent1_NullPointerException() {
 778         ConcurrentSkipListMap c = map5();
 779         try {
 780             c.putIfAbsent(null, &quot;whatever&quot;);
 781             shouldThrow();
 782         } catch (NullPointerException success) {}
 783     }
 784 
 785     /**
 786      * replace(null, x) throws NPE
 787      */
 788     public void testReplace_NullPointerException() {
 789         ConcurrentSkipListMap c = map5();
 790         try {
 791             c.replace(null, &quot;whatever&quot;);
 792             shouldThrow();
 793         } catch (NullPointerException success) {}
 794     }
 795 
 796     /**
 797      * replace(null, x, y) throws NPE
 798      */
 799     public void testReplaceValue_NullPointerException() {
 800         ConcurrentSkipListMap c = map5();
 801         try {
 802             c.replace(null, one, &quot;whatever&quot;);
 803             shouldThrow();
 804         } catch (NullPointerException success) {}
 805     }
 806 
 807     /**
 808      * remove(null) throws NPE
 809      */
 810     public void testRemove1_NullPointerException() {
 811         ConcurrentSkipListMap c = new ConcurrentSkipListMap();
 812         c.put(&quot;sadsdf&quot;, &quot;asdads&quot;);
 813         try {
 814             c.remove(null);
 815             shouldThrow();
 816         } catch (NullPointerException success) {}
 817     }
 818 
 819     /**
 820      * remove(null, x) throws NPE
 821      */
 822     public void testRemove2_NullPointerException() {
 823         ConcurrentSkipListMap c = new ConcurrentSkipListMap();
 824         c.put(&quot;sadsdf&quot;, &quot;asdads&quot;);
 825         try {
 826             c.remove(null, &quot;whatever&quot;);
 827             shouldThrow();
 828         } catch (NullPointerException success) {}
 829     }
 830 
 831     /**
 832      * remove(x, null) returns false
 833      */
 834     public void testRemove3() {
 835         ConcurrentSkipListMap c = new ConcurrentSkipListMap();
 836         c.put(&quot;sadsdf&quot;, &quot;asdads&quot;);
 837         assertFalse(c.remove(&quot;sadsdf&quot;, null));
 838     }
 839 
 840     /**
 841      * A cloned map equals original
 842      */
 843     public void testClone() {
 844         ConcurrentSkipListMap x = map5();
 845         ConcurrentSkipListMap y = x.clone();
 846 
 847         assertNotSame(x, y);
 848         assertEquals(x.size(), y.size());
 849         assertEquals(x.toString(), y.toString());
 850         assertEquals(x, y);
 851         assertEquals(y, x);
 852         y.clear();
 853         assertTrue(y.isEmpty());
 854         assertFalse(x.equals(y));
 855     }
 856 
 857     /**
 858      * A deserialized/reserialized map equals original
 859      */
 860     public void testSerialization() throws Exception {
 861         NavigableMap x = map5();
 862         NavigableMap y = serialClone(x);
 863 
 864         assertNotSame(x, y);
 865         assertEquals(x.size(), y.size());
 866         assertEquals(x.toString(), y.toString());
 867         assertEquals(x, y);
 868         assertEquals(y, x);
 869         y.clear();
 870         assertTrue(y.isEmpty());
 871         assertFalse(x.equals(y));
 872     }
 873 
 874     /**
 875      * subMap returns map with keys in requested range
 876      */
 877     public void testSubMapContents() {
 878         ConcurrentSkipListMap map = map5();
 879         NavigableMap sm = map.subMap(two, true, four, false);
 880         assertEquals(two, sm.firstKey());
 881         assertEquals(three, sm.lastKey());
 882         assertEquals(2, sm.size());
 883         assertFalse(sm.containsKey(one));
 884         assertTrue(sm.containsKey(two));
 885         assertTrue(sm.containsKey(three));
 886         assertFalse(sm.containsKey(four));
 887         assertFalse(sm.containsKey(five));
 888         Iterator i = sm.keySet().iterator();
 889         Object k;
 890         k = (Integer)(i.next());
 891         assertEquals(two, k);
 892         k = (Integer)(i.next());
 893         assertEquals(three, k);
 894         assertFalse(i.hasNext());
 895         Iterator r = sm.descendingKeySet().iterator();
 896         k = (Integer)(r.next());
 897         assertEquals(three, k);
 898         k = (Integer)(r.next());
 899         assertEquals(two, k);
 900         assertFalse(r.hasNext());
 901 
 902         Iterator j = sm.keySet().iterator();
 903         j.next();
 904         j.remove();
 905         assertFalse(map.containsKey(two));
 906         assertEquals(4, map.size());
 907         assertEquals(1, sm.size());
 908         assertEquals(three, sm.firstKey());
 909         assertEquals(three, sm.lastKey());
 910         assertEquals(&quot;C&quot;, sm.remove(three));
 911         assertTrue(sm.isEmpty());
 912         assertEquals(3, map.size());
 913     }
 914 
 915     public void testSubMapContents2() {
 916         ConcurrentSkipListMap map = map5();
 917         NavigableMap sm = map.subMap(two, true, three, false);
 918         assertEquals(1, sm.size());
 919         assertEquals(two, sm.firstKey());
 920         assertEquals(two, sm.lastKey());
 921         assertFalse(sm.containsKey(one));
 922         assertTrue(sm.containsKey(two));
 923         assertFalse(sm.containsKey(three));
 924         assertFalse(sm.containsKey(four));
 925         assertFalse(sm.containsKey(five));
 926         Iterator i = sm.keySet().iterator();
 927         Object k;
 928         k = (Integer)(i.next());
 929         assertEquals(two, k);
 930         assertFalse(i.hasNext());
 931         Iterator r = sm.descendingKeySet().iterator();
 932         k = (Integer)(r.next());
 933         assertEquals(two, k);
 934         assertFalse(r.hasNext());
 935 
 936         Iterator j = sm.keySet().iterator();
 937         j.next();
 938         j.remove();
 939         assertFalse(map.containsKey(two));
 940         assertEquals(4, map.size());
 941         assertEquals(0, sm.size());
 942         assertTrue(sm.isEmpty());
 943         assertSame(sm.remove(three), null);
 944         assertEquals(4, map.size());
 945     }
 946 
 947     /**
 948      * headMap returns map with keys in requested range
 949      */
 950     public void testHeadMapContents() {
 951         ConcurrentSkipListMap map = map5();
 952         NavigableMap sm = map.headMap(four, false);
 953         assertTrue(sm.containsKey(one));
 954         assertTrue(sm.containsKey(two));
 955         assertTrue(sm.containsKey(three));
 956         assertFalse(sm.containsKey(four));
 957         assertFalse(sm.containsKey(five));
 958         Iterator i = sm.keySet().iterator();
 959         Object k;
 960         k = (Integer)(i.next());
 961         assertEquals(one, k);
 962         k = (Integer)(i.next());
 963         assertEquals(two, k);
 964         k = (Integer)(i.next());
 965         assertEquals(three, k);
 966         assertFalse(i.hasNext());
 967         sm.clear();
 968         assertTrue(sm.isEmpty());
 969         assertEquals(2, map.size());
 970         assertEquals(four, map.firstKey());
 971     }
 972 
 973     /**
 974      * tailMap returns map with keys in requested range
 975      */
 976     public void testTailMapContents() {
 977         ConcurrentSkipListMap map = map5();
 978         NavigableMap sm = map.tailMap(two, true);
 979         assertFalse(sm.containsKey(one));
 980         assertTrue(sm.containsKey(two));
 981         assertTrue(sm.containsKey(three));
 982         assertTrue(sm.containsKey(four));
 983         assertTrue(sm.containsKey(five));
 984         Iterator i = sm.keySet().iterator();
 985         Object k;
 986         k = (Integer)(i.next());
 987         assertEquals(two, k);
 988         k = (Integer)(i.next());
 989         assertEquals(three, k);
 990         k = (Integer)(i.next());
 991         assertEquals(four, k);
 992         k = (Integer)(i.next());
 993         assertEquals(five, k);
 994         assertFalse(i.hasNext());
 995         Iterator r = sm.descendingKeySet().iterator();
 996         k = (Integer)(r.next());
 997         assertEquals(five, k);
 998         k = (Integer)(r.next());
 999         assertEquals(four, k);
1000         k = (Integer)(r.next());
1001         assertEquals(three, k);
1002         k = (Integer)(r.next());
1003         assertEquals(two, k);
1004         assertFalse(r.hasNext());
1005 
1006         Iterator ei = sm.entrySet().iterator();
1007         Map.Entry e;
1008         e = (Map.Entry)(ei.next());
1009         assertEquals(two, e.getKey());
1010         assertEquals(&quot;B&quot;, e.getValue());
1011         e = (Map.Entry)(ei.next());
1012         assertEquals(three, e.getKey());
1013         assertEquals(&quot;C&quot;, e.getValue());
1014         e = (Map.Entry)(ei.next());
1015         assertEquals(four, e.getKey());
1016         assertEquals(&quot;D&quot;, e.getValue());
1017         e = (Map.Entry)(ei.next());
1018         assertEquals(five, e.getKey());
1019         assertEquals(&quot;E&quot;, e.getValue());
1020         assertFalse(i.hasNext());
1021 
1022         NavigableMap ssm = sm.tailMap(four, true);
1023         assertEquals(four, ssm.firstKey());
1024         assertEquals(five, ssm.lastKey());
1025         assertEquals(&quot;D&quot;, ssm.remove(four));
1026         assertEquals(1, ssm.size());
1027         assertEquals(3, sm.size());
1028         assertEquals(4, map.size());
1029     }
1030 
1031     Random rnd = new Random(666);
1032     BitSet bs;
1033 
1034     /**
1035      * Submaps of submaps subdivide correctly
1036      */
1037     public void testRecursiveSubMaps() throws Exception {
1038         int mapSize = expensiveTests ? 1000 : 100;
1039         Class cl = ConcurrentSkipListMap.class;
1040         NavigableMap&lt;Integer, Integer&gt; map = newMap(cl);
1041         bs = new BitSet(mapSize);
1042 
1043         populate(map, mapSize);
1044         check(map,                 0, mapSize - 1, true);
1045         check(map.descendingMap(), 0, mapSize - 1, false);
1046 
1047         mutateMap(map, 0, mapSize - 1);
1048         check(map,                 0, mapSize - 1, true);
1049         check(map.descendingMap(), 0, mapSize - 1, false);
1050 
1051         bashSubMap(map.subMap(0, true, mapSize, false),
1052                    0, mapSize - 1, true);
1053     }
1054 
1055     static NavigableMap&lt;Integer, Integer&gt; newMap(Class cl) throws Exception {
1056         NavigableMap&lt;Integer, Integer&gt; result =
1057             (NavigableMap&lt;Integer, Integer&gt;) cl.getConstructor().newInstance();
1058         assertEquals(0, result.size());
1059         assertFalse(result.keySet().iterator().hasNext());
1060         return result;
1061     }
1062 
1063     void populate(NavigableMap&lt;Integer, Integer&gt; map, int limit) {
1064         for (int i = 0, n = 2 * limit / 3; i &lt; n; i++) {
1065             int key = rnd.nextInt(limit);
1066             put(map, key);
1067         }
1068     }
1069 
1070     void mutateMap(NavigableMap&lt;Integer, Integer&gt; map, int min, int max) {
1071         int size = map.size();
1072         int rangeSize = max - min + 1;
1073 
1074         // Remove a bunch of entries directly
1075         for (int i = 0, n = rangeSize / 2; i &lt; n; i++) {
1076             remove(map, min - 5 + rnd.nextInt(rangeSize + 10));
1077         }
1078 
1079         // Remove a bunch of entries with iterator
1080         for (Iterator&lt;Integer&gt; it = map.keySet().iterator(); it.hasNext(); ) {
1081             if (rnd.nextBoolean()) {
1082                 bs.clear(it.next());
1083                 it.remove();
1084             }
1085         }
1086 
1087         // Add entries till we&#39;re back to original size
1088         while (map.size() &lt; size) {
1089             int key = min + rnd.nextInt(rangeSize);
1090             assertTrue(key &gt;= min &amp;&amp; key &lt;= max);
1091             put(map, key);
1092         }
1093     }
1094 
1095     void mutateSubMap(NavigableMap&lt;Integer, Integer&gt; map, int min, int max) {
1096         int size = map.size();
1097         int rangeSize = max - min + 1;
1098 
1099         // Remove a bunch of entries directly
1100         for (int i = 0, n = rangeSize / 2; i &lt; n; i++) {
1101             remove(map, min - 5 + rnd.nextInt(rangeSize + 10));
1102         }
1103 
1104         // Remove a bunch of entries with iterator
1105         for (Iterator&lt;Integer&gt; it = map.keySet().iterator(); it.hasNext(); ) {
1106             if (rnd.nextBoolean()) {
1107                 bs.clear(it.next());
1108                 it.remove();
1109             }
1110         }
1111 
1112         // Add entries till we&#39;re back to original size
1113         while (map.size() &lt; size) {
1114             int key = min - 5 + rnd.nextInt(rangeSize + 10);
1115             if (key &gt;= min &amp;&amp; key &lt;= max) {
1116                 put(map, key);
1117             } else {
1118                 try {
1119                     map.put(key, 2 * key);
1120                     shouldThrow();
1121                 } catch (IllegalArgumentException success) {}
1122             }
1123         }
1124     }
1125 
1126     void put(NavigableMap&lt;Integer, Integer&gt; map, int key) {
1127         if (map.put(key, 2 * key) == null)
1128             bs.set(key);
1129     }
1130 
1131     void remove(NavigableMap&lt;Integer, Integer&gt; map, int key) {
1132         if (map.remove(key) != null)
1133             bs.clear(key);
1134     }
1135 
1136     void bashSubMap(NavigableMap&lt;Integer, Integer&gt; map,
1137                     int min, int max, boolean ascending) {
1138         check(map, min, max, ascending);
1139         check(map.descendingMap(), min, max, !ascending);
1140 
1141         mutateSubMap(map, min, max);
1142         check(map, min, max, ascending);
1143         check(map.descendingMap(), min, max, !ascending);
1144 
1145         // Recurse
1146         if (max - min &lt; 2)
1147             return;
1148         int midPoint = (min + max) / 2;
1149 
1150         // headMap - pick direction and endpoint inclusion randomly
1151         boolean incl = rnd.nextBoolean();
1152         NavigableMap&lt;Integer,Integer&gt; hm = map.headMap(midPoint, incl);
1153         if (ascending) {
1154             if (rnd.nextBoolean())
1155                 bashSubMap(hm, min, midPoint - (incl ? 0 : 1), true);
1156             else
1157                 bashSubMap(hm.descendingMap(), min, midPoint - (incl ? 0 : 1),
1158                            false);
1159         } else {
1160             if (rnd.nextBoolean())
1161                 bashSubMap(hm, midPoint + (incl ? 0 : 1), max, false);
1162             else
1163                 bashSubMap(hm.descendingMap(), midPoint + (incl ? 0 : 1), max,
1164                            true);
1165         }
1166 
1167         // tailMap - pick direction and endpoint inclusion randomly
1168         incl = rnd.nextBoolean();
1169         NavigableMap&lt;Integer,Integer&gt; tm = map.tailMap(midPoint,incl);
1170         if (ascending) {
1171             if (rnd.nextBoolean())
1172                 bashSubMap(tm, midPoint + (incl ? 0 : 1), max, true);
1173             else
1174                 bashSubMap(tm.descendingMap(), midPoint + (incl ? 0 : 1), max,
1175                            false);
1176         } else {
1177             if (rnd.nextBoolean()) {
1178                 bashSubMap(tm, min, midPoint - (incl ? 0 : 1), false);
1179             } else {
1180                 bashSubMap(tm.descendingMap(), min, midPoint - (incl ? 0 : 1),
1181                            true);
1182             }
1183         }
1184 
1185         // subMap - pick direction and endpoint inclusion randomly
1186         int rangeSize = max - min + 1;
1187         int[] endpoints = new int[2];
1188         endpoints[0] = min + rnd.nextInt(rangeSize);
1189         endpoints[1] = min + rnd.nextInt(rangeSize);
1190         Arrays.sort(endpoints);
1191         boolean lowIncl = rnd.nextBoolean();
1192         boolean highIncl = rnd.nextBoolean();
1193         if (ascending) {
1194             NavigableMap&lt;Integer,Integer&gt; sm = map.subMap(
1195                 endpoints[0], lowIncl, endpoints[1], highIncl);
1196             if (rnd.nextBoolean())
1197                 bashSubMap(sm, endpoints[0] + (lowIncl ? 0 : 1),
1198                            endpoints[1] - (highIncl ? 0 : 1), true);
1199             else
1200                 bashSubMap(sm.descendingMap(), endpoints[0] + (lowIncl ? 0 : 1),
1201                            endpoints[1] - (highIncl ? 0 : 1), false);
1202         } else {
1203             NavigableMap&lt;Integer,Integer&gt; sm = map.subMap(
1204                 endpoints[1], highIncl, endpoints[0], lowIncl);
1205             if (rnd.nextBoolean())
1206                 bashSubMap(sm, endpoints[0] + (lowIncl ? 0 : 1),
1207                            endpoints[1] - (highIncl ? 0 : 1), false);
1208             else
1209                 bashSubMap(sm.descendingMap(), endpoints[0] + (lowIncl ? 0 : 1),
1210                            endpoints[1] - (highIncl ? 0 : 1), true);
1211         }
1212     }
1213 
1214     /**
1215      * min and max are both inclusive.  If max &lt; min, interval is empty.
1216      */
1217     void check(NavigableMap&lt;Integer, Integer&gt; map,
1218                       final int min, final int max, final boolean ascending) {
1219         class ReferenceSet {
1220             int lower(int key) {
1221                 return ascending ? lowerAscending(key) : higherAscending(key);
1222             }
1223             int floor(int key) {
1224                 return ascending ? floorAscending(key) : ceilingAscending(key);
1225             }
1226             int ceiling(int key) {
1227                 return ascending ? ceilingAscending(key) : floorAscending(key);
1228             }
1229             int higher(int key) {
1230                 return ascending ? higherAscending(key) : lowerAscending(key);
1231             }
1232             int first() {
1233                 return ascending ? firstAscending() : lastAscending();
1234             }
1235             int last() {
1236                 return ascending ? lastAscending() : firstAscending();
1237             }
1238             int lowerAscending(int key) {
1239                 return floorAscending(key - 1);
1240             }
1241             int floorAscending(int key) {
1242                 if (key &lt; min)
1243                     return -1;
1244                 else if (key &gt; max)
1245                     key = max;
1246 
1247                 // BitSet should support this! Test would run much faster
1248                 while (key &gt;= min) {
1249                     if (bs.get(key))
1250                         return key;
1251                     key--;
1252                 }
1253                 return -1;
1254             }
1255             int ceilingAscending(int key) {
1256                 if (key &lt; min)
1257                     key = min;
1258                 else if (key &gt; max)
1259                     return -1;
1260                 int result = bs.nextSetBit(key);
1261                 return result &gt; max ? -1 : result;
1262             }
1263             int higherAscending(int key) {
1264                 return ceilingAscending(key + 1);
1265             }
1266             private int firstAscending() {
1267                 int result = ceilingAscending(min);
1268                 return result &gt; max ? -1 : result;
1269             }
1270             private int lastAscending() {
1271                 int result = floorAscending(max);
1272                 return result &lt; min ? -1 : result;
1273             }
1274         }
1275         ReferenceSet rs = new ReferenceSet();
1276 
1277         // Test contents using containsKey
1278         int size = 0;
1279         for (int i = min; i &lt;= max; i++) {
1280             boolean bsContainsI = bs.get(i);
1281             assertEquals(bsContainsI, map.containsKey(i));
1282             if (bsContainsI)
1283                 size++;
1284         }
1285         assertEquals(size, map.size());
1286 
1287         // Test contents using contains keySet iterator
1288         int size2 = 0;
1289         int previousKey = -1;
1290         for (int key : map.keySet()) {
1291             assertTrue(bs.get(key));
1292             size2++;
1293             assertTrue(previousKey &lt; 0 ||
1294                 (ascending ? key - previousKey &gt; 0 : key - previousKey &lt; 0));
1295             previousKey = key;
1296         }
1297         assertEquals(size2, size);
1298 
1299         // Test navigation ops
1300         for (int key = min - 1; key &lt;= max + 1; key++) {
1301             assertEq(map.lowerKey(key), rs.lower(key));
1302             assertEq(map.floorKey(key), rs.floor(key));
1303             assertEq(map.higherKey(key), rs.higher(key));
1304             assertEq(map.ceilingKey(key), rs.ceiling(key));
1305         }
1306 
1307         // Test extrema
1308         if (map.size() != 0) {
1309             assertEq(map.firstKey(), rs.first());
1310             assertEq(map.lastKey(), rs.last());
1311         } else {
1312             assertEq(rs.first(), -1);
1313             assertEq(rs.last(),  -1);
1314             try {
1315                 map.firstKey();
1316                 shouldThrow();
1317             } catch (NoSuchElementException success) {}
1318             try {
1319                 map.lastKey();
1320                 shouldThrow();
1321             } catch (NoSuchElementException success) {}
1322         }
1323     }
1324 
1325     static void assertEq(Integer i, int j) {
1326         if (i == null)
1327             assertEquals(j, -1);
1328         else
1329             assertEquals((int) i, j);
1330     }
1331 
1332     static boolean eq(Integer i, int j) {
1333         return (i == null) ? j == -1 : i == j;
1334     }
1335 
1336 }
    </pre>
  </body>
</html>
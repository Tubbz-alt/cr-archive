<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/util/concurrent/tck/TreeMapTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  */
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea with assistance from members of JCP JSR-166
  30  * Expert Group and released to the public domain, as explained at
  31  * http://creativecommons.org/publicdomain/zero/1.0/
  32  */
  33 
  34 import java.util.Arrays;
  35 import java.util.BitSet;
  36 import java.util.Collection;
  37 import java.util.Iterator;
  38 import java.util.Map;
  39 import java.util.NavigableMap;
  40 import java.util.NavigableSet;
  41 import java.util.NoSuchElementException;
  42 import java.util.Random;
  43 import java.util.Set;
  44 import java.util.TreeMap;
  45 
  46 import junit.framework.Test;
  47 
  48 public class TreeMapTest extends JSR166TestCase {
  49     public static void main(String[] args) {
  50         main(suite(), args);
  51     }
  52     public static Test suite() {
  53         class Implementation implements MapImplementation {
  54             public Class&lt;?&gt; klazz() { return TreeMap.class; }
  55             public Map emptyMap() { return new TreeMap(); }
  56             public boolean isConcurrent() { return false; }
  57             public boolean permitsNullKeys() { return false; }
  58             public boolean permitsNullValues() { return true; }
  59             public boolean supportsSetValue() { return true; }
  60         }
  61         return newTestSuite(
  62             TreeMapTest.class,
  63             MapTest.testSuite(new Implementation()));
  64     }
  65 
  66     /**
  67      * Returns a new map from Integers 1-5 to Strings &quot;A&quot;-&quot;E&quot;.
  68      */
  69     private static TreeMap map5() {
  70         TreeMap map = new TreeMap();
  71         assertTrue(map.isEmpty());
  72         map.put(one, &quot;A&quot;);
  73         map.put(five, &quot;E&quot;);
  74         map.put(three, &quot;C&quot;);
  75         map.put(two, &quot;B&quot;);
  76         map.put(four, &quot;D&quot;);
  77         assertFalse(map.isEmpty());
  78         assertEquals(5, map.size());
  79         return map;
  80     }
  81 
  82     /**
  83      * clear removes all pairs
  84      */
  85     public void testClear() {
  86         TreeMap map = map5();
  87         map.clear();
  88         assertEquals(0, map.size());
  89     }
  90 
  91     /**
  92      * copy constructor creates map equal to source map
  93      */
  94     public void testConstructFromSorted() {
  95         TreeMap map = map5();
  96         TreeMap map2 = new TreeMap(map);
  97         assertEquals(map, map2);
  98     }
  99 
 100     /**
 101      * Maps with same contents are equal
 102      */
 103     public void testEquals() {
 104         TreeMap map1 = map5();
 105         TreeMap map2 = map5();
 106         assertEquals(map1, map2);
 107         assertEquals(map2, map1);
 108         map1.clear();
 109         assertFalse(map1.equals(map2));
 110         assertFalse(map2.equals(map1));
 111     }
 112 
 113     /**
 114      * containsKey returns true for contained key
 115      */
 116     public void testContainsKey() {
 117         TreeMap map = map5();
 118         assertTrue(map.containsKey(one));
 119         assertFalse(map.containsKey(zero));
 120     }
 121 
 122     /**
 123      * containsValue returns true for held values
 124      */
 125     public void testContainsValue() {
 126         TreeMap map = map5();
 127         assertTrue(map.containsValue(&quot;A&quot;));
 128         assertFalse(map.containsValue(&quot;Z&quot;));
 129     }
 130 
 131     /**
 132      * get returns the correct element at the given key,
 133      * or null if not present
 134      */
 135     public void testGet() {
 136         TreeMap map = map5();
 137         assertEquals(&quot;A&quot;, (String)map.get(one));
 138         TreeMap empty = new TreeMap();
 139         assertNull(empty.get(one));
 140     }
 141 
 142     /**
 143      * isEmpty is true of empty map and false for non-empty
 144      */
 145     public void testIsEmpty() {
 146         TreeMap empty = new TreeMap();
 147         TreeMap map = map5();
 148         assertTrue(empty.isEmpty());
 149         assertFalse(map.isEmpty());
 150     }
 151 
 152     /**
 153      * firstKey returns first key
 154      */
 155     public void testFirstKey() {
 156         TreeMap map = map5();
 157         assertEquals(one, map.firstKey());
 158     }
 159 
 160     /**
 161      * lastKey returns last key
 162      */
 163     public void testLastKey() {
 164         TreeMap map = map5();
 165         assertEquals(five, map.lastKey());
 166     }
 167 
 168     /**
 169      * keySet.toArray returns contains all keys
 170      */
 171     public void testKeySetToArray() {
 172         TreeMap map = map5();
 173         Set s = map.keySet();
 174         Object[] ar = s.toArray();
 175         assertTrue(s.containsAll(Arrays.asList(ar)));
 176         assertEquals(5, ar.length);
 177         ar[0] = m10;
 178         assertFalse(s.containsAll(Arrays.asList(ar)));
 179     }
 180 
 181     /**
 182      * descendingkeySet.toArray returns contains all keys
 183      */
 184     public void testDescendingKeySetToArray() {
 185         TreeMap map = map5();
 186         Set s = map.descendingKeySet();
 187         Object[] ar = s.toArray();
 188         assertEquals(5, ar.length);
 189         assertTrue(s.containsAll(Arrays.asList(ar)));
 190         ar[0] = m10;
 191         assertFalse(s.containsAll(Arrays.asList(ar)));
 192     }
 193 
 194     /**
 195      * keySet returns a Set containing all the keys
 196      */
 197     public void testKeySet() {
 198         TreeMap map = map5();
 199         Set s = map.keySet();
 200         assertEquals(5, s.size());
 201         assertTrue(s.contains(one));
 202         assertTrue(s.contains(two));
 203         assertTrue(s.contains(three));
 204         assertTrue(s.contains(four));
 205         assertTrue(s.contains(five));
 206     }
 207 
 208     /**
 209      * keySet is ordered
 210      */
 211     public void testKeySetOrder() {
 212         TreeMap map = map5();
 213         Set s = map.keySet();
 214         Iterator i = s.iterator();
 215         Integer last = (Integer)i.next();
 216         assertEquals(last, one);
 217         int count = 1;
 218         while (i.hasNext()) {
 219             Integer k = (Integer)i.next();
 220             assertTrue(last.compareTo(k) &lt; 0);
 221             last = k;
 222             ++count;
 223         }
 224         assertEquals(5, count);
 225     }
 226 
 227     /**
 228      * descending iterator of key set is inverse ordered
 229      */
 230     public void testKeySetDescendingIteratorOrder() {
 231         TreeMap map = map5();
 232         NavigableSet s = map.navigableKeySet();
 233         Iterator i = s.descendingIterator();
 234         Integer last = (Integer)i.next();
 235         assertEquals(last, five);
 236         int count = 1;
 237         while (i.hasNext()) {
 238             Integer k = (Integer)i.next();
 239             assertTrue(last.compareTo(k) &gt; 0);
 240             last = k;
 241             ++count;
 242         }
 243         assertEquals(5, count);
 244     }
 245 
 246     /**
 247      * descendingKeySet is ordered
 248      */
 249     public void testDescendingKeySetOrder() {
 250         TreeMap map = map5();
 251         Set s = map.descendingKeySet();
 252         Iterator i = s.iterator();
 253         Integer last = (Integer)i.next();
 254         assertEquals(last, five);
 255         int count = 1;
 256         while (i.hasNext()) {
 257             Integer k = (Integer)i.next();
 258             assertTrue(last.compareTo(k) &gt; 0);
 259             last = k;
 260             ++count;
 261         }
 262         assertEquals(5, count);
 263     }
 264 
 265     /**
 266      * descending iterator of descendingKeySet is ordered
 267      */
 268     public void testDescendingKeySetDescendingIteratorOrder() {
 269         TreeMap map = map5();
 270         NavigableSet s = map.descendingKeySet();
 271         Iterator i = s.descendingIterator();
 272         Integer last = (Integer)i.next();
 273         assertEquals(last, one);
 274         int count = 1;
 275         while (i.hasNext()) {
 276             Integer k = (Integer)i.next();
 277             assertTrue(last.compareTo(k) &lt; 0);
 278             last = k;
 279             ++count;
 280         }
 281         assertEquals(5, count);
 282     }
 283 
 284     /**
 285      * values collection contains all values
 286      */
 287     public void testValues() {
 288         TreeMap map = map5();
 289         Collection s = map.values();
 290         assertEquals(5, s.size());
 291         assertTrue(s.contains(&quot;A&quot;));
 292         assertTrue(s.contains(&quot;B&quot;));
 293         assertTrue(s.contains(&quot;C&quot;));
 294         assertTrue(s.contains(&quot;D&quot;));
 295         assertTrue(s.contains(&quot;E&quot;));
 296     }
 297 
 298     /**
 299      * entrySet contains all pairs
 300      */
 301     public void testEntrySet() {
 302         TreeMap map = map5();
 303         Set s = map.entrySet();
 304         assertEquals(5, s.size());
 305         Iterator it = s.iterator();
 306         while (it.hasNext()) {
 307             Map.Entry e = (Map.Entry) it.next();
 308             assertTrue(
 309                        (e.getKey().equals(one) &amp;&amp; e.getValue().equals(&quot;A&quot;)) ||
 310                        (e.getKey().equals(two) &amp;&amp; e.getValue().equals(&quot;B&quot;)) ||
 311                        (e.getKey().equals(three) &amp;&amp; e.getValue().equals(&quot;C&quot;)) ||
 312                        (e.getKey().equals(four) &amp;&amp; e.getValue().equals(&quot;D&quot;)) ||
 313                        (e.getKey().equals(five) &amp;&amp; e.getValue().equals(&quot;E&quot;)));
 314         }
 315     }
 316 
 317     /**
 318      * descendingEntrySet contains all pairs
 319      */
 320     public void testDescendingEntrySet() {
 321         TreeMap map = map5();
 322         Set s = map.descendingMap().entrySet();
 323         assertEquals(5, s.size());
 324         Iterator it = s.iterator();
 325         while (it.hasNext()) {
 326             Map.Entry e = (Map.Entry) it.next();
 327             assertTrue(
 328                        (e.getKey().equals(one) &amp;&amp; e.getValue().equals(&quot;A&quot;)) ||
 329                        (e.getKey().equals(two) &amp;&amp; e.getValue().equals(&quot;B&quot;)) ||
 330                        (e.getKey().equals(three) &amp;&amp; e.getValue().equals(&quot;C&quot;)) ||
 331                        (e.getKey().equals(four) &amp;&amp; e.getValue().equals(&quot;D&quot;)) ||
 332                        (e.getKey().equals(five) &amp;&amp; e.getValue().equals(&quot;E&quot;)));
 333         }
 334     }
 335 
 336     /**
 337      * entrySet.toArray contains all entries
 338      */
 339     public void testEntrySetToArray() {
 340         TreeMap map = map5();
 341         Set s = map.entrySet();
 342         Object[] ar = s.toArray();
 343         assertEquals(5, ar.length);
 344         for (int i = 0; i &lt; 5; ++i) {
 345             assertTrue(map.containsKey(((Map.Entry)(ar[i])).getKey()));
 346             assertTrue(map.containsValue(((Map.Entry)(ar[i])).getValue()));
 347         }
 348     }
 349 
 350     /**
 351      * descendingEntrySet.toArray contains all entries
 352      */
 353     public void testDescendingEntrySetToArray() {
 354         TreeMap map = map5();
 355         Set s = map.descendingMap().entrySet();
 356         Object[] ar = s.toArray();
 357         assertEquals(5, ar.length);
 358         for (int i = 0; i &lt; 5; ++i) {
 359             assertTrue(map.containsKey(((Map.Entry)(ar[i])).getKey()));
 360             assertTrue(map.containsValue(((Map.Entry)(ar[i])).getValue()));
 361         }
 362     }
 363 
 364     /**
 365      * putAll adds all key-value pairs from the given map
 366      */
 367     public void testPutAll() {
 368         TreeMap empty = new TreeMap();
 369         TreeMap map = map5();
 370         empty.putAll(map);
 371         assertEquals(5, empty.size());
 372         assertTrue(empty.containsKey(one));
 373         assertTrue(empty.containsKey(two));
 374         assertTrue(empty.containsKey(three));
 375         assertTrue(empty.containsKey(four));
 376         assertTrue(empty.containsKey(five));
 377     }
 378 
 379     /**
 380      * remove removes the correct key-value pair from the map
 381      */
 382     public void testRemove() {
 383         TreeMap map = map5();
 384         map.remove(five);
 385         assertEquals(4, map.size());
 386         assertFalse(map.containsKey(five));
 387     }
 388 
 389     /**
 390      * lowerEntry returns preceding entry.
 391      */
 392     public void testLowerEntry() {
 393         TreeMap map = map5();
 394         Map.Entry e1 = map.lowerEntry(three);
 395         assertEquals(two, e1.getKey());
 396 
 397         Map.Entry e2 = map.lowerEntry(six);
 398         assertEquals(five, e2.getKey());
 399 
 400         Map.Entry e3 = map.lowerEntry(one);
 401         assertNull(e3);
 402 
 403         Map.Entry e4 = map.lowerEntry(zero);
 404         assertNull(e4);
 405     }
 406 
 407     /**
 408      * higherEntry returns next entry.
 409      */
 410     public void testHigherEntry() {
 411         TreeMap map = map5();
 412         Map.Entry e1 = map.higherEntry(three);
 413         assertEquals(four, e1.getKey());
 414 
 415         Map.Entry e2 = map.higherEntry(zero);
 416         assertEquals(one, e2.getKey());
 417 
 418         Map.Entry e3 = map.higherEntry(five);
 419         assertNull(e3);
 420 
 421         Map.Entry e4 = map.higherEntry(six);
 422         assertNull(e4);
 423     }
 424 
 425     /**
 426      * floorEntry returns preceding entry.
 427      */
 428     public void testFloorEntry() {
 429         TreeMap map = map5();
 430         Map.Entry e1 = map.floorEntry(three);
 431         assertEquals(three, e1.getKey());
 432 
 433         Map.Entry e2 = map.floorEntry(six);
 434         assertEquals(five, e2.getKey());
 435 
 436         Map.Entry e3 = map.floorEntry(one);
 437         assertEquals(one, e3.getKey());
 438 
 439         Map.Entry e4 = map.floorEntry(zero);
 440         assertNull(e4);
 441     }
 442 
 443     /**
 444      * ceilingEntry returns next entry.
 445      */
 446     public void testCeilingEntry() {
 447         TreeMap map = map5();
 448         Map.Entry e1 = map.ceilingEntry(three);
 449         assertEquals(three, e1.getKey());
 450 
 451         Map.Entry e2 = map.ceilingEntry(zero);
 452         assertEquals(one, e2.getKey());
 453 
 454         Map.Entry e3 = map.ceilingEntry(five);
 455         assertEquals(five, e3.getKey());
 456 
 457         Map.Entry e4 = map.ceilingEntry(six);
 458         assertNull(e4);
 459     }
 460 
 461     /**
 462      * lowerKey returns preceding element
 463      */
 464     public void testLowerKey() {
 465         TreeMap q = map5();
 466         Object e1 = q.lowerKey(three);
 467         assertEquals(two, e1);
 468 
 469         Object e2 = q.lowerKey(six);
 470         assertEquals(five, e2);
 471 
 472         Object e3 = q.lowerKey(one);
 473         assertNull(e3);
 474 
 475         Object e4 = q.lowerKey(zero);
 476         assertNull(e4);
 477     }
 478 
 479     /**
 480      * higherKey returns next element
 481      */
 482     public void testHigherKey() {
 483         TreeMap q = map5();
 484         Object e1 = q.higherKey(three);
 485         assertEquals(four, e1);
 486 
 487         Object e2 = q.higherKey(zero);
 488         assertEquals(one, e2);
 489 
 490         Object e3 = q.higherKey(five);
 491         assertNull(e3);
 492 
 493         Object e4 = q.higherKey(six);
 494         assertNull(e4);
 495     }
 496 
 497     /**
 498      * floorKey returns preceding element
 499      */
 500     public void testFloorKey() {
 501         TreeMap q = map5();
 502         Object e1 = q.floorKey(three);
 503         assertEquals(three, e1);
 504 
 505         Object e2 = q.floorKey(six);
 506         assertEquals(five, e2);
 507 
 508         Object e3 = q.floorKey(one);
 509         assertEquals(one, e3);
 510 
 511         Object e4 = q.floorKey(zero);
 512         assertNull(e4);
 513     }
 514 
 515     /**
 516      * ceilingKey returns next element
 517      */
 518     public void testCeilingKey() {
 519         TreeMap q = map5();
 520         Object e1 = q.ceilingKey(three);
 521         assertEquals(three, e1);
 522 
 523         Object e2 = q.ceilingKey(zero);
 524         assertEquals(one, e2);
 525 
 526         Object e3 = q.ceilingKey(five);
 527         assertEquals(five, e3);
 528 
 529         Object e4 = q.ceilingKey(six);
 530         assertNull(e4);
 531     }
 532 
 533     /**
 534      * pollFirstEntry returns entries in order
 535      */
 536     public void testPollFirstEntry() {
 537         TreeMap map = map5();
 538         Map.Entry e = map.pollFirstEntry();
 539         assertEquals(one, e.getKey());
 540         assertEquals(&quot;A&quot;, e.getValue());
 541         e = map.pollFirstEntry();
 542         assertEquals(two, e.getKey());
 543         map.put(one, &quot;A&quot;);
 544         e = map.pollFirstEntry();
 545         assertEquals(one, e.getKey());
 546         assertEquals(&quot;A&quot;, e.getValue());
 547         e = map.pollFirstEntry();
 548         assertEquals(three, e.getKey());
 549         map.remove(four);
 550         e = map.pollFirstEntry();
 551         assertEquals(five, e.getKey());
 552         try {
 553             e.setValue(&quot;A&quot;);
 554             shouldThrow();
 555         } catch (UnsupportedOperationException success) {}
 556         e = map.pollFirstEntry();
 557         assertNull(e);
 558     }
 559 
 560     /**
 561      * pollLastEntry returns entries in order
 562      */
 563     public void testPollLastEntry() {
 564         TreeMap map = map5();
 565         Map.Entry e = map.pollLastEntry();
 566         assertEquals(five, e.getKey());
 567         assertEquals(&quot;E&quot;, e.getValue());
 568         e = map.pollLastEntry();
 569         assertEquals(four, e.getKey());
 570         map.put(five, &quot;E&quot;);
 571         e = map.pollLastEntry();
 572         assertEquals(five, e.getKey());
 573         assertEquals(&quot;E&quot;, e.getValue());
 574         e = map.pollLastEntry();
 575         assertEquals(three, e.getKey());
 576         map.remove(two);
 577         e = map.pollLastEntry();
 578         assertEquals(one, e.getKey());
 579         try {
 580             e.setValue(&quot;E&quot;);
 581             shouldThrow();
 582         } catch (UnsupportedOperationException success) {}
 583         e = map.pollLastEntry();
 584         assertNull(e);
 585     }
 586 
 587     /**
 588      * size returns the correct values
 589      */
 590     public void testSize() {
 591         TreeMap map = map5();
 592         TreeMap empty = new TreeMap();
 593         assertEquals(0, empty.size());
 594         assertEquals(5, map.size());
 595     }
 596 
 597     /**
 598      * toString contains toString of elements
 599      */
 600     public void testToString() {
 601         TreeMap map = map5();
 602         String s = map.toString();
 603         for (int i = 1; i &lt;= 5; ++i) {
 604             assertTrue(s.contains(String.valueOf(i)));
 605         }
 606     }
 607 
 608     // Exception tests
 609 
 610     /**
 611      * get(null) of nonempty map throws NPE
 612      */
 613     public void testGet_NullPointerException() {
 614         TreeMap c = map5();
 615         try {
 616             c.get(null);
 617             shouldThrow();
 618         } catch (NullPointerException success) {}
 619     }
 620 
 621     /**
 622      * containsKey(null) of nonempty map throws NPE
 623      */
 624     public void testContainsKey_NullPointerException() {
 625         TreeMap c = map5();
 626         try {
 627             c.containsKey(null);
 628             shouldThrow();
 629         } catch (NullPointerException success) {}
 630     }
 631 
 632     /**
 633      * remove(null) throws NPE for nonempty map
 634      */
 635     public void testRemove1_NullPointerException() {
 636         TreeMap c = new TreeMap();
 637         c.put(&quot;sadsdf&quot;, &quot;asdads&quot;);
 638         try {
 639             c.remove(null);
 640             shouldThrow();
 641         } catch (NullPointerException success) {}
 642     }
 643 
 644     /**
 645      * A deserialized/reserialized map equals original
 646      */
 647     public void testSerialization() throws Exception {
 648         NavigableMap x = map5();
 649         NavigableMap y = serialClone(x);
 650 
 651         assertNotSame(x, y);
 652         assertEquals(x.size(), y.size());
 653         assertEquals(x.toString(), y.toString());
 654         assertEquals(x, y);
 655         assertEquals(y, x);
 656     }
 657 
 658     /**
 659      * subMap returns map with keys in requested range
 660      */
 661     public void testSubMapContents() {
 662         TreeMap map = map5();
 663         NavigableMap sm = map.subMap(two, true, four, false);
 664         assertEquals(two, sm.firstKey());
 665         assertEquals(three, sm.lastKey());
 666         assertEquals(2, sm.size());
 667         assertFalse(sm.containsKey(one));
 668         assertTrue(sm.containsKey(two));
 669         assertTrue(sm.containsKey(three));
 670         assertFalse(sm.containsKey(four));
 671         assertFalse(sm.containsKey(five));
 672         Iterator i = sm.keySet().iterator();
 673         Object k;
 674         k = (Integer)(i.next());
 675         assertEquals(two, k);
 676         k = (Integer)(i.next());
 677         assertEquals(three, k);
 678         assertFalse(i.hasNext());
 679         Iterator r = sm.descendingKeySet().iterator();
 680         k = (Integer)(r.next());
 681         assertEquals(three, k);
 682         k = (Integer)(r.next());
 683         assertEquals(two, k);
 684         assertFalse(r.hasNext());
 685 
 686         Iterator j = sm.keySet().iterator();
 687         j.next();
 688         j.remove();
 689         assertFalse(map.containsKey(two));
 690         assertEquals(4, map.size());
 691         assertEquals(1, sm.size());
 692         assertEquals(three, sm.firstKey());
 693         assertEquals(three, sm.lastKey());
 694         assertEquals(&quot;C&quot;, sm.remove(three));
 695         assertTrue(sm.isEmpty());
 696         assertEquals(3, map.size());
 697     }
 698 
 699     public void testSubMapContents2() {
 700         TreeMap map = map5();
 701         NavigableMap sm = map.subMap(two, true, three, false);
 702         assertEquals(1, sm.size());
 703         assertEquals(two, sm.firstKey());
 704         assertEquals(two, sm.lastKey());
 705         assertFalse(sm.containsKey(one));
 706         assertTrue(sm.containsKey(two));
 707         assertFalse(sm.containsKey(three));
 708         assertFalse(sm.containsKey(four));
 709         assertFalse(sm.containsKey(five));
 710         Iterator i = sm.keySet().iterator();
 711         Object k;
 712         k = (Integer)(i.next());
 713         assertEquals(two, k);
 714         assertFalse(i.hasNext());
 715         Iterator r = sm.descendingKeySet().iterator();
 716         k = (Integer)(r.next());
 717         assertEquals(two, k);
 718         assertFalse(r.hasNext());
 719 
 720         Iterator j = sm.keySet().iterator();
 721         j.next();
 722         j.remove();
 723         assertFalse(map.containsKey(two));
 724         assertEquals(4, map.size());
 725         assertEquals(0, sm.size());
 726         assertTrue(sm.isEmpty());
 727         assertSame(sm.remove(three), null);
 728         assertEquals(4, map.size());
 729     }
 730 
 731     /**
 732      * headMap returns map with keys in requested range
 733      */
 734     public void testHeadMapContents() {
 735         TreeMap map = map5();
 736         NavigableMap sm = map.headMap(four, false);
 737         assertTrue(sm.containsKey(one));
 738         assertTrue(sm.containsKey(two));
 739         assertTrue(sm.containsKey(three));
 740         assertFalse(sm.containsKey(four));
 741         assertFalse(sm.containsKey(five));
 742         Iterator i = sm.keySet().iterator();
 743         Object k;
 744         k = (Integer)(i.next());
 745         assertEquals(one, k);
 746         k = (Integer)(i.next());
 747         assertEquals(two, k);
 748         k = (Integer)(i.next());
 749         assertEquals(three, k);
 750         assertFalse(i.hasNext());
 751         sm.clear();
 752         assertTrue(sm.isEmpty());
 753         assertEquals(2, map.size());
 754         assertEquals(four, map.firstKey());
 755     }
 756 
 757     /**
 758      * headMap returns map with keys in requested range
 759      */
 760     public void testTailMapContents() {
 761         TreeMap map = map5();
 762         NavigableMap sm = map.tailMap(two, true);
 763         assertFalse(sm.containsKey(one));
 764         assertTrue(sm.containsKey(two));
 765         assertTrue(sm.containsKey(three));
 766         assertTrue(sm.containsKey(four));
 767         assertTrue(sm.containsKey(five));
 768         Iterator i = sm.keySet().iterator();
 769         Object k;
 770         k = (Integer)(i.next());
 771         assertEquals(two, k);
 772         k = (Integer)(i.next());
 773         assertEquals(three, k);
 774         k = (Integer)(i.next());
 775         assertEquals(four, k);
 776         k = (Integer)(i.next());
 777         assertEquals(five, k);
 778         assertFalse(i.hasNext());
 779         Iterator r = sm.descendingKeySet().iterator();
 780         k = (Integer)(r.next());
 781         assertEquals(five, k);
 782         k = (Integer)(r.next());
 783         assertEquals(four, k);
 784         k = (Integer)(r.next());
 785         assertEquals(three, k);
 786         k = (Integer)(r.next());
 787         assertEquals(two, k);
 788         assertFalse(r.hasNext());
 789 
 790         Iterator ei = sm.entrySet().iterator();
 791         Map.Entry e;
 792         e = (Map.Entry)(ei.next());
 793         assertEquals(two, e.getKey());
 794         assertEquals(&quot;B&quot;, e.getValue());
 795         e = (Map.Entry)(ei.next());
 796         assertEquals(three, e.getKey());
 797         assertEquals(&quot;C&quot;, e.getValue());
 798         e = (Map.Entry)(ei.next());
 799         assertEquals(four, e.getKey());
 800         assertEquals(&quot;D&quot;, e.getValue());
 801         e = (Map.Entry)(ei.next());
 802         assertEquals(five, e.getKey());
 803         assertEquals(&quot;E&quot;, e.getValue());
 804         assertFalse(i.hasNext());
 805 
 806         NavigableMap ssm = sm.tailMap(four, true);
 807         assertEquals(four, ssm.firstKey());
 808         assertEquals(five, ssm.lastKey());
 809         assertEquals(&quot;D&quot;, ssm.remove(four));
 810         assertEquals(1, ssm.size());
 811         assertEquals(3, sm.size());
 812         assertEquals(4, map.size());
 813     }
 814 
 815     Random rnd = new Random(666);
 816     BitSet bs;
 817 
 818     /**
 819      * Submaps of submaps subdivide correctly
 820      */
 821     public void testRecursiveSubMaps() throws Exception {
 822         int mapSize = expensiveTests ? 1000 : 100;
 823         Class cl = TreeMap.class;
 824         NavigableMap&lt;Integer, Integer&gt; map = newMap(cl);
 825         bs = new BitSet(mapSize);
 826 
 827         populate(map, mapSize);
 828         check(map,                 0, mapSize - 1, true);
 829         check(map.descendingMap(), 0, mapSize - 1, false);
 830 
 831         mutateMap(map, 0, mapSize - 1);
 832         check(map,                 0, mapSize - 1, true);
 833         check(map.descendingMap(), 0, mapSize - 1, false);
 834 
 835         bashSubMap(map.subMap(0, true, mapSize, false),
 836                    0, mapSize - 1, true);
 837     }
 838 
 839     static NavigableMap&lt;Integer, Integer&gt; newMap(Class cl) throws Exception {
 840         NavigableMap&lt;Integer, Integer&gt; result
 841             = (NavigableMap&lt;Integer, Integer&gt;) cl.getConstructor().newInstance();
 842         assertEquals(0, result.size());
 843         assertFalse(result.keySet().iterator().hasNext());
 844         return result;
 845     }
 846 
 847     void populate(NavigableMap&lt;Integer, Integer&gt; map, int limit) {
 848         for (int i = 0, n = 2 * limit / 3; i &lt; n; i++) {
 849             int key = rnd.nextInt(limit);
 850             put(map, key);
 851         }
 852     }
 853 
 854     void mutateMap(NavigableMap&lt;Integer, Integer&gt; map, int min, int max) {
 855         int size = map.size();
 856         int rangeSize = max - min + 1;
 857 
 858         // Remove a bunch of entries directly
 859         for (int i = 0, n = rangeSize / 2; i &lt; n; i++) {
 860             remove(map, min - 5 + rnd.nextInt(rangeSize + 10));
 861         }
 862 
 863         // Remove a bunch of entries with iterator
 864         for (Iterator&lt;Integer&gt; it = map.keySet().iterator(); it.hasNext(); ) {
 865             if (rnd.nextBoolean()) {
 866                 bs.clear(it.next());
 867                 it.remove();
 868             }
 869         }
 870 
 871         // Add entries till we&#39;re back to original size
 872         while (map.size() &lt; size) {
 873             int key = min + rnd.nextInt(rangeSize);
 874             assertTrue(key &gt;= min &amp;&amp; key &lt;= max);
 875             put(map, key);
 876         }
 877     }
 878 
 879     void mutateSubMap(NavigableMap&lt;Integer, Integer&gt; map, int min, int max) {
 880         int size = map.size();
 881         int rangeSize = max - min + 1;
 882 
 883         // Remove a bunch of entries directly
 884         for (int i = 0, n = rangeSize / 2; i &lt; n; i++) {
 885             remove(map, min - 5 + rnd.nextInt(rangeSize + 10));
 886         }
 887 
 888         // Remove a bunch of entries with iterator
 889         for (Iterator&lt;Integer&gt; it = map.keySet().iterator(); it.hasNext(); ) {
 890             if (rnd.nextBoolean()) {
 891                 bs.clear(it.next());
 892                 it.remove();
 893             }
 894         }
 895 
 896         // Add entries till we&#39;re back to original size
 897         while (map.size() &lt; size) {
 898             int key = min - 5 + rnd.nextInt(rangeSize + 10);
 899             if (key &gt;= min &amp;&amp; key &lt;= max) {
 900                 put(map, key);
 901             } else {
 902                 try {
 903                     map.put(key, 2 * key);
 904                     shouldThrow();
 905                 } catch (IllegalArgumentException success) {}
 906             }
 907         }
 908     }
 909 
 910     void put(NavigableMap&lt;Integer, Integer&gt; map, int key) {
 911         if (map.put(key, 2 * key) == null)
 912             bs.set(key);
 913     }
 914 
 915     void remove(NavigableMap&lt;Integer, Integer&gt; map, int key) {
 916         if (map.remove(key) != null)
 917             bs.clear(key);
 918     }
 919 
 920     void bashSubMap(NavigableMap&lt;Integer, Integer&gt; map,
 921                     int min, int max, boolean ascending) {
 922         check(map, min, max, ascending);
 923         check(map.descendingMap(), min, max, !ascending);
 924 
 925         mutateSubMap(map, min, max);
 926         check(map, min, max, ascending);
 927         check(map.descendingMap(), min, max, !ascending);
 928 
 929         // Recurse
 930         if (max - min &lt; 2)
 931             return;
 932         int midPoint = (min + max) / 2;
 933 
 934         // headMap - pick direction and endpoint inclusion randomly
 935         boolean incl = rnd.nextBoolean();
 936         NavigableMap&lt;Integer,Integer&gt; hm = map.headMap(midPoint, incl);
 937         if (ascending) {
 938             if (rnd.nextBoolean())
 939                 bashSubMap(hm, min, midPoint - (incl ? 0 : 1), true);
 940             else
 941                 bashSubMap(hm.descendingMap(), min, midPoint - (incl ? 0 : 1),
 942                            false);
 943         } else {
 944             if (rnd.nextBoolean())
 945                 bashSubMap(hm, midPoint + (incl ? 0 : 1), max, false);
 946             else
 947                 bashSubMap(hm.descendingMap(), midPoint + (incl ? 0 : 1), max,
 948                            true);
 949         }
 950 
 951         // tailMap - pick direction and endpoint inclusion randomly
 952         incl = rnd.nextBoolean();
 953         NavigableMap&lt;Integer,Integer&gt; tm = map.tailMap(midPoint,incl);
 954         if (ascending) {
 955             if (rnd.nextBoolean())
 956                 bashSubMap(tm, midPoint + (incl ? 0 : 1), max, true);
 957             else
 958                 bashSubMap(tm.descendingMap(), midPoint + (incl ? 0 : 1), max,
 959                            false);
 960         } else {
 961             if (rnd.nextBoolean()) {
 962                 bashSubMap(tm, min, midPoint - (incl ? 0 : 1), false);
 963             } else {
 964                 bashSubMap(tm.descendingMap(), min, midPoint - (incl ? 0 : 1),
 965                            true);
 966             }
 967         }
 968 
 969         // subMap - pick direction and endpoint inclusion randomly
 970         int rangeSize = max - min + 1;
 971         int[] endpoints = new int[2];
 972         endpoints[0] = min + rnd.nextInt(rangeSize);
 973         endpoints[1] = min + rnd.nextInt(rangeSize);
 974         Arrays.sort(endpoints);
 975         boolean lowIncl = rnd.nextBoolean();
 976         boolean highIncl = rnd.nextBoolean();
 977         if (ascending) {
 978             NavigableMap&lt;Integer,Integer&gt; sm = map.subMap(
 979                 endpoints[0], lowIncl, endpoints[1], highIncl);
 980             if (rnd.nextBoolean())
 981                 bashSubMap(sm, endpoints[0] + (lowIncl ? 0 : 1),
 982                            endpoints[1] - (highIncl ? 0 : 1), true);
 983             else
 984                 bashSubMap(sm.descendingMap(), endpoints[0] + (lowIncl ? 0 : 1),
 985                            endpoints[1] - (highIncl ? 0 : 1), false);
 986         } else {
 987             NavigableMap&lt;Integer,Integer&gt; sm = map.subMap(
 988                 endpoints[1], highIncl, endpoints[0], lowIncl);
 989             if (rnd.nextBoolean())
 990                 bashSubMap(sm, endpoints[0] + (lowIncl ? 0 : 1),
 991                            endpoints[1] - (highIncl ? 0 : 1), false);
 992             else
 993                 bashSubMap(sm.descendingMap(), endpoints[0] + (lowIncl ? 0 : 1),
 994                            endpoints[1] - (highIncl ? 0 : 1), true);
 995         }
 996     }
 997 
 998     /**
 999      * min and max are both inclusive.  If max &lt; min, interval is empty.
1000      */
1001     void check(NavigableMap&lt;Integer, Integer&gt; map,
1002                       final int min, final int max, final boolean ascending) {
1003         class ReferenceSet {
1004             int lower(int key) {
1005                 return ascending ? lowerAscending(key) : higherAscending(key);
1006             }
1007             int floor(int key) {
1008                 return ascending ? floorAscending(key) : ceilingAscending(key);
1009             }
1010             int ceiling(int key) {
1011                 return ascending ? ceilingAscending(key) : floorAscending(key);
1012             }
1013             int higher(int key) {
1014                 return ascending ? higherAscending(key) : lowerAscending(key);
1015             }
1016             int first() {
1017                 return ascending ? firstAscending() : lastAscending();
1018             }
1019             int last() {
1020                 return ascending ? lastAscending() : firstAscending();
1021             }
1022             int lowerAscending(int key) {
1023                 return floorAscending(key - 1);
1024             }
1025             int floorAscending(int key) {
1026                 if (key &lt; min)
1027                     return -1;
1028                 else if (key &gt; max)
1029                     key = max;
1030 
1031                 // BitSet should support this! Test would run much faster
1032                 while (key &gt;= min) {
1033                     if (bs.get(key))
1034                         return key;
1035                     key--;
1036                 }
1037                 return -1;
1038             }
1039             int ceilingAscending(int key) {
1040                 if (key &lt; min)
1041                     key = min;
1042                 else if (key &gt; max)
1043                     return -1;
1044                 int result = bs.nextSetBit(key);
1045                 return result &gt; max ? -1 : result;
1046             }
1047             int higherAscending(int key) {
1048                 return ceilingAscending(key + 1);
1049             }
1050             private int firstAscending() {
1051                 int result = ceilingAscending(min);
1052                 return result &gt; max ? -1 : result;
1053             }
1054             private int lastAscending() {
1055                 int result = floorAscending(max);
1056                 return result &lt; min ? -1 : result;
1057             }
1058         }
1059         ReferenceSet rs = new ReferenceSet();
1060 
1061         // Test contents using containsKey
1062         int size = 0;
1063         for (int i = min; i &lt;= max; i++) {
1064             boolean bsContainsI = bs.get(i);
1065             assertEquals(bsContainsI, map.containsKey(i));
1066             if (bsContainsI)
1067                 size++;
1068         }
1069         assertEquals(size, map.size());
1070 
1071         // Test contents using contains keySet iterator
1072         int size2 = 0;
1073         int previousKey = -1;
1074         for (int key : map.keySet()) {
1075             assertTrue(bs.get(key));
1076             size2++;
1077             assertTrue(previousKey &lt; 0 ||
1078                 (ascending ? key - previousKey &gt; 0 : key - previousKey &lt; 0));
1079             previousKey = key;
1080         }
1081         assertEquals(size2, size);
1082 
1083         // Test navigation ops
1084         for (int key = min - 1; key &lt;= max + 1; key++) {
1085             assertEq(map.lowerKey(key), rs.lower(key));
1086             assertEq(map.floorKey(key), rs.floor(key));
1087             assertEq(map.higherKey(key), rs.higher(key));
1088             assertEq(map.ceilingKey(key), rs.ceiling(key));
1089         }
1090 
1091         // Test extrema
1092         if (map.size() != 0) {
1093             assertEq(map.firstKey(), rs.first());
1094             assertEq(map.lastKey(), rs.last());
1095         } else {
1096             assertEq(rs.first(), -1);
1097             assertEq(rs.last(),  -1);
1098             try {
1099                 map.firstKey();
1100                 shouldThrow();
1101             } catch (NoSuchElementException success) {}
1102             try {
1103                 map.lastKey();
1104                 shouldThrow();
1105             } catch (NoSuchElementException success) {}
1106         }
1107     }
1108 
1109     static void assertEq(Integer i, int j) {
1110         if (i == null)
1111             assertEquals(j, -1);
1112         else
1113             assertEquals((int) i, j);
1114     }
1115 
1116     static boolean eq(Integer i, int j) {
1117         return i == null ? j == -1 : i == j;
1118     }
1119 
1120 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/concurrent/tck/ConcurrentSkipListMapTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  */
  22 
  23 /*
  24  * This file is available under and governed by the GNU General Public
  25  * License version 2 only, as published by the Free Software Foundation.
  26  * However, the following notice accompanied the original version of this
  27  * file:
  28  *
  29  * Written by Doug Lea with assistance from members of JCP JSR-166
  30  * Expert Group and released to the public domain, as explained at
  31  * http://creativecommons.org/publicdomain/zero/1.0/
  32  */
  33 
  34 import java.util.ArrayList;
  35 import java.util.Arrays;
  36 import java.util.BitSet;
  37 import java.util.Collection;
  38 import java.util.Iterator;
  39 import java.util.Map;
  40 import java.util.NavigableMap;
  41 import java.util.NavigableSet;
  42 import java.util.NoSuchElementException;
  43 import java.util.Random;
  44 import java.util.Set;
  45 import java.util.concurrent.ConcurrentSkipListMap;
  46 
  47 import junit.framework.Test;
  48 
  49 public class ConcurrentSkipListMapTest extends JSR166TestCase {
  50     public static void main(String[] args) {
  51         main(suite(), args);
  52     }
  53     public static Test suite() {
  54         class Implementation implements MapImplementation {
  55             public Class&lt;?&gt; klazz() { return ConcurrentSkipListMap.class; }
  56             public Map emptyMap() { return new ConcurrentSkipListMap(); }
<a name="1" id="anc1"></a><span class="line-removed">  57             public Object makeKey(int i) { return i; }</span>
<span class="line-removed">  58             public Object makeValue(int i) { return i; }</span>
  59             public boolean isConcurrent() { return true; }
<a name="2" id="anc2"></a>
  60             public boolean permitsNullKeys() { return false; }
  61             public boolean permitsNullValues() { return false; }
  62             public boolean supportsSetValue() { return false; }
  63         }
  64         return newTestSuite(
  65             ConcurrentSkipListMapTest.class,
  66             MapTest.testSuite(new Implementation()));
  67     }
  68 
  69     /**
  70      * Returns a new map from Integers 1-5 to Strings &quot;A&quot;-&quot;E&quot;.
  71      */
  72     private static ConcurrentSkipListMap map5() {
  73         ConcurrentSkipListMap map = new ConcurrentSkipListMap();
  74         assertTrue(map.isEmpty());
  75         map.put(one, &quot;A&quot;);
  76         map.put(five, &quot;E&quot;);
  77         map.put(three, &quot;C&quot;);
  78         map.put(two, &quot;B&quot;);
  79         map.put(four, &quot;D&quot;);
  80         assertFalse(map.isEmpty());
  81         assertEquals(5, map.size());
  82         return map;
  83     }
  84 
  85     /**
  86      * clear removes all pairs
  87      */
  88     public void testClear() {
  89         ConcurrentSkipListMap map = map5();
  90         map.clear();
  91         assertEquals(0, map.size());
  92     }
  93 
  94     /**
  95      * copy constructor creates map equal to source map
  96      */
  97     public void testConstructFromSorted() {
  98         ConcurrentSkipListMap map = map5();
  99         ConcurrentSkipListMap map2 = new ConcurrentSkipListMap(map);
 100         assertEquals(map, map2);
 101     }
 102 
 103     /**
 104      * Maps with same contents are equal
 105      */
 106     public void testEquals() {
 107         ConcurrentSkipListMap map1 = map5();
 108         ConcurrentSkipListMap map2 = map5();
 109         assertEquals(map1, map2);
 110         assertEquals(map2, map1);
 111         map1.clear();
 112         assertFalse(map1.equals(map2));
 113         assertFalse(map2.equals(map1));
 114     }
 115 
 116     /**
 117      * containsKey returns true for contained key
 118      */
 119     public void testContainsKey() {
 120         ConcurrentSkipListMap map = map5();
 121         assertTrue(map.containsKey(one));
 122         assertFalse(map.containsKey(zero));
 123     }
 124 
 125     /**
 126      * containsValue returns true for held values
 127      */
 128     public void testContainsValue() {
 129         ConcurrentSkipListMap map = map5();
 130         assertTrue(map.containsValue(&quot;A&quot;));
 131         assertFalse(map.containsValue(&quot;Z&quot;));
 132     }
 133 
 134     /**
 135      * get returns the correct element at the given key,
 136      * or null if not present
 137      */
 138     public void testGet() {
 139         ConcurrentSkipListMap map = map5();
 140         assertEquals(&quot;A&quot;, (String)map.get(one));
 141         ConcurrentSkipListMap empty = new ConcurrentSkipListMap();
 142         assertNull(empty.get(one));
 143     }
 144 
 145     /**
 146      * isEmpty is true of empty map and false for non-empty
 147      */
 148     public void testIsEmpty() {
 149         ConcurrentSkipListMap empty = new ConcurrentSkipListMap();
 150         ConcurrentSkipListMap map = map5();
 151         assertTrue(empty.isEmpty());
 152         assertFalse(map.isEmpty());
 153     }
 154 
 155     /**
 156      * firstKey returns first key
 157      */
 158     public void testFirstKey() {
 159         ConcurrentSkipListMap map = map5();
 160         assertEquals(one, map.firstKey());
 161     }
 162 
 163     /**
 164      * lastKey returns last key
 165      */
 166     public void testLastKey() {
 167         ConcurrentSkipListMap map = map5();
 168         assertEquals(five, map.lastKey());
 169     }
 170 
 171     /**
 172      * keySet.toArray returns contains all keys
 173      */
 174     public void testKeySetToArray() {
 175         ConcurrentSkipListMap map = map5();
 176         Set s = map.keySet();
 177         Object[] ar = s.toArray();
 178         assertTrue(s.containsAll(Arrays.asList(ar)));
 179         assertEquals(5, ar.length);
 180         ar[0] = m10;
 181         assertFalse(s.containsAll(Arrays.asList(ar)));
 182     }
 183 
 184     /**
 185      * descendingkeySet.toArray returns contains all keys
 186      */
 187     public void testDescendingKeySetToArray() {
 188         ConcurrentSkipListMap map = map5();
 189         Set s = map.descendingKeySet();
 190         Object[] ar = s.toArray();
 191         assertEquals(5, ar.length);
 192         assertTrue(s.containsAll(Arrays.asList(ar)));
 193         ar[0] = m10;
 194         assertFalse(s.containsAll(Arrays.asList(ar)));
 195     }
 196 
 197     /**
 198      * keySet returns a Set containing all the keys
 199      */
 200     public void testKeySet() {
 201         ConcurrentSkipListMap map = map5();
 202         Set s = map.keySet();
 203         assertEquals(5, s.size());
 204         assertTrue(s.contains(one));
 205         assertTrue(s.contains(two));
 206         assertTrue(s.contains(three));
 207         assertTrue(s.contains(four));
 208         assertTrue(s.contains(five));
 209     }
 210 
 211     /**
 212      * keySet is ordered
 213      */
 214     public void testKeySetOrder() {
 215         ConcurrentSkipListMap map = map5();
 216         Set s = map.keySet();
 217         Iterator i = s.iterator();
 218         Integer last = (Integer)i.next();
 219         assertEquals(last, one);
 220         int count = 1;
 221         while (i.hasNext()) {
 222             Integer k = (Integer)i.next();
 223             assertTrue(last.compareTo(k) &lt; 0);
 224             last = k;
 225             ++count;
 226         }
 227         assertEquals(5, count);
 228     }
 229 
 230     /**
 231      * descending iterator of key set is inverse ordered
 232      */
 233     public void testKeySetDescendingIteratorOrder() {
 234         ConcurrentSkipListMap map = map5();
 235         NavigableSet s = map.navigableKeySet();
 236         Iterator i = s.descendingIterator();
 237         Integer last = (Integer)i.next();
 238         assertEquals(last, five);
 239         int count = 1;
 240         while (i.hasNext()) {
 241             Integer k = (Integer)i.next();
 242             assertTrue(last.compareTo(k) &gt; 0);
 243             last = k;
 244             ++count;
 245         }
 246         assertEquals(5, count);
 247     }
 248 
 249     /**
 250      * descendingKeySet is ordered
 251      */
 252     public void testDescendingKeySetOrder() {
 253         ConcurrentSkipListMap map = map5();
 254         Set s = map.descendingKeySet();
 255         Iterator i = s.iterator();
 256         Integer last = (Integer)i.next();
 257         assertEquals(last, five);
 258         int count = 1;
 259         while (i.hasNext()) {
 260             Integer k = (Integer)i.next();
 261             assertTrue(last.compareTo(k) &gt; 0);
 262             last = k;
 263             ++count;
 264         }
 265         assertEquals(5, count);
 266     }
 267 
 268     /**
 269      * descending iterator of descendingKeySet is ordered
 270      */
 271     public void testDescendingKeySetDescendingIteratorOrder() {
 272         ConcurrentSkipListMap map = map5();
 273         NavigableSet s = map.descendingKeySet();
 274         Iterator i = s.descendingIterator();
 275         Integer last = (Integer)i.next();
 276         assertEquals(last, one);
 277         int count = 1;
 278         while (i.hasNext()) {
 279             Integer k = (Integer)i.next();
 280             assertTrue(last.compareTo(k) &lt; 0);
 281             last = k;
 282             ++count;
 283         }
 284         assertEquals(5, count);
 285     }
 286 
 287     /**
 288      * Values.toArray contains all values
 289      */
 290     public void testValuesToArray() {
 291         ConcurrentSkipListMap map = map5();
 292         Collection v = map.values();
 293         Object[] ar = v.toArray();
 294         ArrayList s = new ArrayList(Arrays.asList(ar));
 295         assertEquals(5, ar.length);
 296         assertTrue(s.contains(&quot;A&quot;));
 297         assertTrue(s.contains(&quot;B&quot;));
 298         assertTrue(s.contains(&quot;C&quot;));
 299         assertTrue(s.contains(&quot;D&quot;));
 300         assertTrue(s.contains(&quot;E&quot;));
 301     }
 302 
 303     /**
 304      * values collection contains all values
 305      */
 306     public void testValues() {
 307         ConcurrentSkipListMap map = map5();
 308         Collection s = map.values();
 309         assertEquals(5, s.size());
 310         assertTrue(s.contains(&quot;A&quot;));
 311         assertTrue(s.contains(&quot;B&quot;));
 312         assertTrue(s.contains(&quot;C&quot;));
 313         assertTrue(s.contains(&quot;D&quot;));
 314         assertTrue(s.contains(&quot;E&quot;));
 315     }
 316 
 317     /**
 318      * entrySet contains all pairs
 319      */
 320     public void testEntrySet() {
 321         ConcurrentSkipListMap map = map5();
 322         Set s = map.entrySet();
 323         assertEquals(5, s.size());
 324         Iterator it = s.iterator();
 325         while (it.hasNext()) {
 326             Map.Entry e = (Map.Entry) it.next();
 327             assertTrue(
 328                        (e.getKey().equals(one) &amp;&amp; e.getValue().equals(&quot;A&quot;)) ||
 329                        (e.getKey().equals(two) &amp;&amp; e.getValue().equals(&quot;B&quot;)) ||
 330                        (e.getKey().equals(three) &amp;&amp; e.getValue().equals(&quot;C&quot;)) ||
 331                        (e.getKey().equals(four) &amp;&amp; e.getValue().equals(&quot;D&quot;)) ||
 332                        (e.getKey().equals(five) &amp;&amp; e.getValue().equals(&quot;E&quot;)));
 333         }
 334     }
 335 
 336     /**
 337      * descendingEntrySet contains all pairs
 338      */
 339     public void testDescendingEntrySet() {
 340         ConcurrentSkipListMap map = map5();
 341         Set s = map.descendingMap().entrySet();
 342         assertEquals(5, s.size());
 343         Iterator it = s.iterator();
 344         while (it.hasNext()) {
 345             Map.Entry e = (Map.Entry) it.next();
 346             assertTrue(
 347                        (e.getKey().equals(one) &amp;&amp; e.getValue().equals(&quot;A&quot;)) ||
 348                        (e.getKey().equals(two) &amp;&amp; e.getValue().equals(&quot;B&quot;)) ||
 349                        (e.getKey().equals(three) &amp;&amp; e.getValue().equals(&quot;C&quot;)) ||
 350                        (e.getKey().equals(four) &amp;&amp; e.getValue().equals(&quot;D&quot;)) ||
 351                        (e.getKey().equals(five) &amp;&amp; e.getValue().equals(&quot;E&quot;)));
 352         }
 353     }
 354 
 355     /**
 356      * entrySet.toArray contains all entries
 357      */
 358     public void testEntrySetToArray() {
 359         ConcurrentSkipListMap map = map5();
 360         Set s = map.entrySet();
 361         Object[] ar = s.toArray();
 362         assertEquals(5, ar.length);
 363         for (int i = 0; i &lt; 5; ++i) {
 364             assertTrue(map.containsKey(((Map.Entry)(ar[i])).getKey()));
 365             assertTrue(map.containsValue(((Map.Entry)(ar[i])).getValue()));
 366         }
 367     }
 368 
 369     /**
 370      * descendingEntrySet.toArray contains all entries
 371      */
 372     public void testDescendingEntrySetToArray() {
 373         ConcurrentSkipListMap map = map5();
 374         Set s = map.descendingMap().entrySet();
 375         Object[] ar = s.toArray();
 376         assertEquals(5, ar.length);
 377         for (int i = 0; i &lt; 5; ++i) {
 378             assertTrue(map.containsKey(((Map.Entry)(ar[i])).getKey()));
 379             assertTrue(map.containsValue(((Map.Entry)(ar[i])).getValue()));
 380         }
 381     }
 382 
 383     /**
 384      * putAll adds all key-value pairs from the given map
 385      */
 386     public void testPutAll() {
 387         ConcurrentSkipListMap empty = new ConcurrentSkipListMap();
 388         ConcurrentSkipListMap map = map5();
 389         empty.putAll(map);
 390         assertEquals(5, empty.size());
 391         assertTrue(empty.containsKey(one));
 392         assertTrue(empty.containsKey(two));
 393         assertTrue(empty.containsKey(three));
 394         assertTrue(empty.containsKey(four));
 395         assertTrue(empty.containsKey(five));
 396     }
 397 
 398     /**
 399      * putIfAbsent works when the given key is not present
 400      */
 401     public void testPutIfAbsent() {
 402         ConcurrentSkipListMap map = map5();
 403         map.putIfAbsent(six, &quot;Z&quot;);
 404         assertTrue(map.containsKey(six));
 405     }
 406 
 407     /**
 408      * putIfAbsent does not add the pair if the key is already present
 409      */
 410     public void testPutIfAbsent2() {
 411         ConcurrentSkipListMap map = map5();
 412         assertEquals(&quot;A&quot;, map.putIfAbsent(one, &quot;Z&quot;));
 413     }
 414 
 415     /**
 416      * replace fails when the given key is not present
 417      */
 418     public void testReplace() {
 419         ConcurrentSkipListMap map = map5();
 420         assertNull(map.replace(six, &quot;Z&quot;));
 421         assertFalse(map.containsKey(six));
 422     }
 423 
 424     /**
 425      * replace succeeds if the key is already present
 426      */
 427     public void testReplace2() {
 428         ConcurrentSkipListMap map = map5();
 429         assertNotNull(map.replace(one, &quot;Z&quot;));
 430         assertEquals(&quot;Z&quot;, map.get(one));
 431     }
 432 
 433     /**
 434      * replace value fails when the given key not mapped to expected value
 435      */
 436     public void testReplaceValue() {
 437         ConcurrentSkipListMap map = map5();
 438         assertEquals(&quot;A&quot;, map.get(one));
 439         assertFalse(map.replace(one, &quot;Z&quot;, &quot;Z&quot;));
 440         assertEquals(&quot;A&quot;, map.get(one));
 441     }
 442 
 443     /**
 444      * replace value succeeds when the given key mapped to expected value
 445      */
 446     public void testReplaceValue2() {
 447         ConcurrentSkipListMap map = map5();
 448         assertEquals(&quot;A&quot;, map.get(one));
 449         assertTrue(map.replace(one, &quot;A&quot;, &quot;Z&quot;));
 450         assertEquals(&quot;Z&quot;, map.get(one));
 451     }
 452 
 453     /**
 454      * remove removes the correct key-value pair from the map
 455      */
 456     public void testRemove() {
 457         ConcurrentSkipListMap map = map5();
 458         map.remove(five);
 459         assertEquals(4, map.size());
 460         assertFalse(map.containsKey(five));
 461     }
 462 
 463     /**
 464      * remove(key,value) removes only if pair present
 465      */
 466     public void testRemove2() {
 467         ConcurrentSkipListMap map = map5();
 468         assertTrue(map.containsKey(five));
 469         assertEquals(&quot;E&quot;, map.get(five));
 470         map.remove(five, &quot;E&quot;);
 471         assertEquals(4, map.size());
 472         assertFalse(map.containsKey(five));
 473         map.remove(four, &quot;A&quot;);
 474         assertEquals(4, map.size());
 475         assertTrue(map.containsKey(four));
 476     }
 477 
 478     /**
 479      * lowerEntry returns preceding entry.
 480      */
 481     public void testLowerEntry() {
 482         ConcurrentSkipListMap map = map5();
 483         Map.Entry e1 = map.lowerEntry(three);
 484         assertEquals(two, e1.getKey());
 485 
 486         Map.Entry e2 = map.lowerEntry(six);
 487         assertEquals(five, e2.getKey());
 488 
 489         Map.Entry e3 = map.lowerEntry(one);
 490         assertNull(e3);
 491 
 492         Map.Entry e4 = map.lowerEntry(zero);
 493         assertNull(e4);
 494     }
 495 
 496     /**
 497      * higherEntry returns next entry.
 498      */
 499     public void testHigherEntry() {
 500         ConcurrentSkipListMap map = map5();
 501         Map.Entry e1 = map.higherEntry(three);
 502         assertEquals(four, e1.getKey());
 503 
 504         Map.Entry e2 = map.higherEntry(zero);
 505         assertEquals(one, e2.getKey());
 506 
 507         Map.Entry e3 = map.higherEntry(five);
 508         assertNull(e3);
 509 
 510         Map.Entry e4 = map.higherEntry(six);
 511         assertNull(e4);
 512     }
 513 
 514     /**
 515      * floorEntry returns preceding entry.
 516      */
 517     public void testFloorEntry() {
 518         ConcurrentSkipListMap map = map5();
 519         Map.Entry e1 = map.floorEntry(three);
 520         assertEquals(three, e1.getKey());
 521 
 522         Map.Entry e2 = map.floorEntry(six);
 523         assertEquals(five, e2.getKey());
 524 
 525         Map.Entry e3 = map.floorEntry(one);
 526         assertEquals(one, e3.getKey());
 527 
 528         Map.Entry e4 = map.floorEntry(zero);
 529         assertNull(e4);
 530     }
 531 
 532     /**
 533      * ceilingEntry returns next entry.
 534      */
 535     public void testCeilingEntry() {
 536         ConcurrentSkipListMap map = map5();
 537         Map.Entry e1 = map.ceilingEntry(three);
 538         assertEquals(three, e1.getKey());
 539 
 540         Map.Entry e2 = map.ceilingEntry(zero);
 541         assertEquals(one, e2.getKey());
 542 
 543         Map.Entry e3 = map.ceilingEntry(five);
 544         assertEquals(five, e3.getKey());
 545 
 546         Map.Entry e4 = map.ceilingEntry(six);
 547         assertNull(e4);
 548     }
 549 
 550     /**
 551      * lowerEntry, higherEntry, ceilingEntry, and floorEntry return
 552      * immutable entries
 553      */
 554     public void testEntryImmutability() {
 555         ConcurrentSkipListMap map = map5();
 556         Map.Entry e = map.lowerEntry(three);
 557         assertEquals(two, e.getKey());
 558         try {
 559             e.setValue(&quot;X&quot;);
 560             shouldThrow();
 561         } catch (UnsupportedOperationException success) {}
 562         e = map.higherEntry(zero);
 563         assertEquals(one, e.getKey());
 564         try {
 565             e.setValue(&quot;X&quot;);
 566             shouldThrow();
 567         } catch (UnsupportedOperationException success) {}
 568         e = map.floorEntry(one);
 569         assertEquals(one, e.getKey());
 570         try {
 571             e.setValue(&quot;X&quot;);
 572             shouldThrow();
 573         } catch (UnsupportedOperationException success) {}
 574         e = map.ceilingEntry(five);
 575         assertEquals(five, e.getKey());
 576         try {
 577             e.setValue(&quot;X&quot;);
 578             shouldThrow();
 579         } catch (UnsupportedOperationException success) {}
 580     }
 581 
 582     /**
 583      * lowerKey returns preceding element
 584      */
 585     public void testLowerKey() {
 586         ConcurrentSkipListMap q = map5();
 587         Object e1 = q.lowerKey(three);
 588         assertEquals(two, e1);
 589 
 590         Object e2 = q.lowerKey(six);
 591         assertEquals(five, e2);
 592 
 593         Object e3 = q.lowerKey(one);
 594         assertNull(e3);
 595 
 596         Object e4 = q.lowerKey(zero);
 597         assertNull(e4);
 598     }
 599 
 600     /**
 601      * higherKey returns next element
 602      */
 603     public void testHigherKey() {
 604         ConcurrentSkipListMap q = map5();
 605         Object e1 = q.higherKey(three);
 606         assertEquals(four, e1);
 607 
 608         Object e2 = q.higherKey(zero);
 609         assertEquals(one, e2);
 610 
 611         Object e3 = q.higherKey(five);
 612         assertNull(e3);
 613 
 614         Object e4 = q.higherKey(six);
 615         assertNull(e4);
 616     }
 617 
 618     /**
 619      * floorKey returns preceding element
 620      */
 621     public void testFloorKey() {
 622         ConcurrentSkipListMap q = map5();
 623         Object e1 = q.floorKey(three);
 624         assertEquals(three, e1);
 625 
 626         Object e2 = q.floorKey(six);
 627         assertEquals(five, e2);
 628 
 629         Object e3 = q.floorKey(one);
 630         assertEquals(one, e3);
 631 
 632         Object e4 = q.floorKey(zero);
 633         assertNull(e4);
 634     }
 635 
 636     /**
 637      * ceilingKey returns next element
 638      */
 639     public void testCeilingKey() {
 640         ConcurrentSkipListMap q = map5();
 641         Object e1 = q.ceilingKey(three);
 642         assertEquals(three, e1);
 643 
 644         Object e2 = q.ceilingKey(zero);
 645         assertEquals(one, e2);
 646 
 647         Object e3 = q.ceilingKey(five);
 648         assertEquals(five, e3);
 649 
 650         Object e4 = q.ceilingKey(six);
 651         assertNull(e4);
 652     }
 653 
 654     /**
 655      * pollFirstEntry returns entries in order
 656      */
 657     public void testPollFirstEntry() {
 658         ConcurrentSkipListMap map = map5();
 659         Map.Entry e = map.pollFirstEntry();
 660         assertEquals(one, e.getKey());
 661         assertEquals(&quot;A&quot;, e.getValue());
 662         e = map.pollFirstEntry();
 663         assertEquals(two, e.getKey());
 664         map.put(one, &quot;A&quot;);
 665         e = map.pollFirstEntry();
 666         assertEquals(one, e.getKey());
 667         assertEquals(&quot;A&quot;, e.getValue());
 668         e = map.pollFirstEntry();
 669         assertEquals(three, e.getKey());
 670         map.remove(four);
 671         e = map.pollFirstEntry();
 672         assertEquals(five, e.getKey());
 673         try {
 674             e.setValue(&quot;A&quot;);
 675             shouldThrow();
 676         } catch (UnsupportedOperationException success) {}
 677         e = map.pollFirstEntry();
 678         assertNull(e);
 679     }
 680 
 681     /**
 682      * pollLastEntry returns entries in order
 683      */
 684     public void testPollLastEntry() {
 685         ConcurrentSkipListMap map = map5();
 686         Map.Entry e = map.pollLastEntry();
 687         assertEquals(five, e.getKey());
 688         assertEquals(&quot;E&quot;, e.getValue());
 689         e = map.pollLastEntry();
 690         assertEquals(four, e.getKey());
 691         map.put(five, &quot;E&quot;);
 692         e = map.pollLastEntry();
 693         assertEquals(five, e.getKey());
 694         assertEquals(&quot;E&quot;, e.getValue());
 695         e = map.pollLastEntry();
 696         assertEquals(three, e.getKey());
 697         map.remove(two);
 698         e = map.pollLastEntry();
 699         assertEquals(one, e.getKey());
 700         try {
 701             e.setValue(&quot;E&quot;);
 702             shouldThrow();
 703         } catch (UnsupportedOperationException success) {}
 704         e = map.pollLastEntry();
 705         assertNull(e);
 706     }
 707 
 708     /**
 709      * size returns the correct values
 710      */
 711     public void testSize() {
 712         ConcurrentSkipListMap map = map5();
 713         ConcurrentSkipListMap empty = new ConcurrentSkipListMap();
 714         assertEquals(0, empty.size());
 715         assertEquals(5, map.size());
 716     }
 717 
 718     /**
 719      * toString contains toString of elements
 720      */
 721     public void testToString() {
 722         ConcurrentSkipListMap map = map5();
 723         String s = map.toString();
 724         for (int i = 1; i &lt;= 5; ++i) {
 725             assertTrue(s.contains(String.valueOf(i)));
 726         }
 727     }
 728 
 729     // Exception tests
 730 
 731     /**
 732      * get(null) of nonempty map throws NPE
 733      */
 734     public void testGet_NullPointerException() {
 735         ConcurrentSkipListMap c = map5();
 736         try {
 737             c.get(null);
 738             shouldThrow();
 739         } catch (NullPointerException success) {}
 740     }
 741 
 742     /**
 743      * containsKey(null) of nonempty map throws NPE
 744      */
 745     public void testContainsKey_NullPointerException() {
 746         ConcurrentSkipListMap c = map5();
 747         try {
 748             c.containsKey(null);
 749             shouldThrow();
 750         } catch (NullPointerException success) {}
 751     }
 752 
 753     /**
 754      * containsValue(null) throws NPE
 755      */
 756     public void testContainsValue_NullPointerException() {
 757         ConcurrentSkipListMap c = new ConcurrentSkipListMap();
 758         try {
 759             c.containsValue(null);
 760             shouldThrow();
 761         } catch (NullPointerException success) {}
 762     }
 763 
 764     /**
 765      * put(null,x) throws NPE
 766      */
 767     public void testPut1_NullPointerException() {
 768         ConcurrentSkipListMap c = map5();
 769         try {
 770             c.put(null, &quot;whatever&quot;);
 771             shouldThrow();
 772         } catch (NullPointerException success) {}
 773     }
 774 
 775     /**
 776      * putIfAbsent(null, x) throws NPE
 777      */
 778     public void testPutIfAbsent1_NullPointerException() {
 779         ConcurrentSkipListMap c = map5();
 780         try {
 781             c.putIfAbsent(null, &quot;whatever&quot;);
 782             shouldThrow();
 783         } catch (NullPointerException success) {}
 784     }
 785 
 786     /**
 787      * replace(null, x) throws NPE
 788      */
 789     public void testReplace_NullPointerException() {
 790         ConcurrentSkipListMap c = map5();
 791         try {
 792             c.replace(null, &quot;whatever&quot;);
 793             shouldThrow();
 794         } catch (NullPointerException success) {}
 795     }
 796 
 797     /**
 798      * replace(null, x, y) throws NPE
 799      */
 800     public void testReplaceValue_NullPointerException() {
 801         ConcurrentSkipListMap c = map5();
 802         try {
 803             c.replace(null, one, &quot;whatever&quot;);
 804             shouldThrow();
 805         } catch (NullPointerException success) {}
 806     }
 807 
 808     /**
 809      * remove(null) throws NPE
 810      */
 811     public void testRemove1_NullPointerException() {
 812         ConcurrentSkipListMap c = new ConcurrentSkipListMap();
 813         c.put(&quot;sadsdf&quot;, &quot;asdads&quot;);
 814         try {
 815             c.remove(null);
 816             shouldThrow();
 817         } catch (NullPointerException success) {}
 818     }
 819 
 820     /**
 821      * remove(null, x) throws NPE
 822      */
 823     public void testRemove2_NullPointerException() {
 824         ConcurrentSkipListMap c = new ConcurrentSkipListMap();
 825         c.put(&quot;sadsdf&quot;, &quot;asdads&quot;);
 826         try {
 827             c.remove(null, &quot;whatever&quot;);
 828             shouldThrow();
 829         } catch (NullPointerException success) {}
 830     }
 831 
 832     /**
 833      * remove(x, null) returns false
 834      */
 835     public void testRemove3() {
 836         ConcurrentSkipListMap c = new ConcurrentSkipListMap();
 837         c.put(&quot;sadsdf&quot;, &quot;asdads&quot;);
 838         assertFalse(c.remove(&quot;sadsdf&quot;, null));
 839     }
 840 
 841     /**
 842      * A cloned map equals original
 843      */
 844     public void testClone() {
 845         ConcurrentSkipListMap x = map5();
 846         ConcurrentSkipListMap y = x.clone();
 847 
 848         assertNotSame(x, y);
 849         assertEquals(x.size(), y.size());
 850         assertEquals(x.toString(), y.toString());
 851         assertEquals(x, y);
 852         assertEquals(y, x);
 853         y.clear();
 854         assertTrue(y.isEmpty());
 855         assertFalse(x.equals(y));
 856     }
 857 
 858     /**
 859      * A deserialized/reserialized map equals original
 860      */
 861     public void testSerialization() throws Exception {
 862         NavigableMap x = map5();
 863         NavigableMap y = serialClone(x);
 864 
 865         assertNotSame(x, y);
 866         assertEquals(x.size(), y.size());
 867         assertEquals(x.toString(), y.toString());
 868         assertEquals(x, y);
 869         assertEquals(y, x);
 870         y.clear();
 871         assertTrue(y.isEmpty());
 872         assertFalse(x.equals(y));
 873     }
 874 
 875     /**
 876      * subMap returns map with keys in requested range
 877      */
 878     public void testSubMapContents() {
 879         ConcurrentSkipListMap map = map5();
 880         NavigableMap sm = map.subMap(two, true, four, false);
 881         assertEquals(two, sm.firstKey());
 882         assertEquals(three, sm.lastKey());
 883         assertEquals(2, sm.size());
 884         assertFalse(sm.containsKey(one));
 885         assertTrue(sm.containsKey(two));
 886         assertTrue(sm.containsKey(three));
 887         assertFalse(sm.containsKey(four));
 888         assertFalse(sm.containsKey(five));
 889         Iterator i = sm.keySet().iterator();
 890         Object k;
 891         k = (Integer)(i.next());
 892         assertEquals(two, k);
 893         k = (Integer)(i.next());
 894         assertEquals(three, k);
 895         assertFalse(i.hasNext());
 896         Iterator r = sm.descendingKeySet().iterator();
 897         k = (Integer)(r.next());
 898         assertEquals(three, k);
 899         k = (Integer)(r.next());
 900         assertEquals(two, k);
 901         assertFalse(r.hasNext());
 902 
 903         Iterator j = sm.keySet().iterator();
 904         j.next();
 905         j.remove();
 906         assertFalse(map.containsKey(two));
 907         assertEquals(4, map.size());
 908         assertEquals(1, sm.size());
 909         assertEquals(three, sm.firstKey());
 910         assertEquals(three, sm.lastKey());
 911         assertEquals(&quot;C&quot;, sm.remove(three));
 912         assertTrue(sm.isEmpty());
 913         assertEquals(3, map.size());
 914     }
 915 
 916     public void testSubMapContents2() {
 917         ConcurrentSkipListMap map = map5();
 918         NavigableMap sm = map.subMap(two, true, three, false);
 919         assertEquals(1, sm.size());
 920         assertEquals(two, sm.firstKey());
 921         assertEquals(two, sm.lastKey());
 922         assertFalse(sm.containsKey(one));
 923         assertTrue(sm.containsKey(two));
 924         assertFalse(sm.containsKey(three));
 925         assertFalse(sm.containsKey(four));
 926         assertFalse(sm.containsKey(five));
 927         Iterator i = sm.keySet().iterator();
 928         Object k;
 929         k = (Integer)(i.next());
 930         assertEquals(two, k);
 931         assertFalse(i.hasNext());
 932         Iterator r = sm.descendingKeySet().iterator();
 933         k = (Integer)(r.next());
 934         assertEquals(two, k);
 935         assertFalse(r.hasNext());
 936 
 937         Iterator j = sm.keySet().iterator();
 938         j.next();
 939         j.remove();
 940         assertFalse(map.containsKey(two));
 941         assertEquals(4, map.size());
 942         assertEquals(0, sm.size());
 943         assertTrue(sm.isEmpty());
 944         assertSame(sm.remove(three), null);
 945         assertEquals(4, map.size());
 946     }
 947 
 948     /**
 949      * headMap returns map with keys in requested range
 950      */
 951     public void testHeadMapContents() {
 952         ConcurrentSkipListMap map = map5();
 953         NavigableMap sm = map.headMap(four, false);
 954         assertTrue(sm.containsKey(one));
 955         assertTrue(sm.containsKey(two));
 956         assertTrue(sm.containsKey(three));
 957         assertFalse(sm.containsKey(four));
 958         assertFalse(sm.containsKey(five));
 959         Iterator i = sm.keySet().iterator();
 960         Object k;
 961         k = (Integer)(i.next());
 962         assertEquals(one, k);
 963         k = (Integer)(i.next());
 964         assertEquals(two, k);
 965         k = (Integer)(i.next());
 966         assertEquals(three, k);
 967         assertFalse(i.hasNext());
 968         sm.clear();
 969         assertTrue(sm.isEmpty());
 970         assertEquals(2, map.size());
 971         assertEquals(four, map.firstKey());
 972     }
 973 
 974     /**
 975      * tailMap returns map with keys in requested range
 976      */
 977     public void testTailMapContents() {
 978         ConcurrentSkipListMap map = map5();
 979         NavigableMap sm = map.tailMap(two, true);
 980         assertFalse(sm.containsKey(one));
 981         assertTrue(sm.containsKey(two));
 982         assertTrue(sm.containsKey(three));
 983         assertTrue(sm.containsKey(four));
 984         assertTrue(sm.containsKey(five));
 985         Iterator i = sm.keySet().iterator();
 986         Object k;
 987         k = (Integer)(i.next());
 988         assertEquals(two, k);
 989         k = (Integer)(i.next());
 990         assertEquals(three, k);
 991         k = (Integer)(i.next());
 992         assertEquals(four, k);
 993         k = (Integer)(i.next());
 994         assertEquals(five, k);
 995         assertFalse(i.hasNext());
 996         Iterator r = sm.descendingKeySet().iterator();
 997         k = (Integer)(r.next());
 998         assertEquals(five, k);
 999         k = (Integer)(r.next());
1000         assertEquals(four, k);
1001         k = (Integer)(r.next());
1002         assertEquals(three, k);
1003         k = (Integer)(r.next());
1004         assertEquals(two, k);
1005         assertFalse(r.hasNext());
1006 
1007         Iterator ei = sm.entrySet().iterator();
1008         Map.Entry e;
1009         e = (Map.Entry)(ei.next());
1010         assertEquals(two, e.getKey());
1011         assertEquals(&quot;B&quot;, e.getValue());
1012         e = (Map.Entry)(ei.next());
1013         assertEquals(three, e.getKey());
1014         assertEquals(&quot;C&quot;, e.getValue());
1015         e = (Map.Entry)(ei.next());
1016         assertEquals(four, e.getKey());
1017         assertEquals(&quot;D&quot;, e.getValue());
1018         e = (Map.Entry)(ei.next());
1019         assertEquals(five, e.getKey());
1020         assertEquals(&quot;E&quot;, e.getValue());
1021         assertFalse(i.hasNext());
1022 
1023         NavigableMap ssm = sm.tailMap(four, true);
1024         assertEquals(four, ssm.firstKey());
1025         assertEquals(five, ssm.lastKey());
1026         assertEquals(&quot;D&quot;, ssm.remove(four));
1027         assertEquals(1, ssm.size());
1028         assertEquals(3, sm.size());
1029         assertEquals(4, map.size());
1030     }
1031 
1032     Random rnd = new Random(666);
1033     BitSet bs;
1034 
1035     /**
1036      * Submaps of submaps subdivide correctly
1037      */
1038     public void testRecursiveSubMaps() throws Exception {
1039         int mapSize = expensiveTests ? 1000 : 100;
1040         Class cl = ConcurrentSkipListMap.class;
1041         NavigableMap&lt;Integer, Integer&gt; map = newMap(cl);
1042         bs = new BitSet(mapSize);
1043 
1044         populate(map, mapSize);
1045         check(map,                 0, mapSize - 1, true);
1046         check(map.descendingMap(), 0, mapSize - 1, false);
1047 
1048         mutateMap(map, 0, mapSize - 1);
1049         check(map,                 0, mapSize - 1, true);
1050         check(map.descendingMap(), 0, mapSize - 1, false);
1051 
1052         bashSubMap(map.subMap(0, true, mapSize, false),
1053                    0, mapSize - 1, true);
1054     }
1055 
1056     static NavigableMap&lt;Integer, Integer&gt; newMap(Class cl) throws Exception {
1057         NavigableMap&lt;Integer, Integer&gt; result =
1058             (NavigableMap&lt;Integer, Integer&gt;) cl.getConstructor().newInstance();
1059         assertEquals(0, result.size());
1060         assertFalse(result.keySet().iterator().hasNext());
1061         return result;
1062     }
1063 
1064     void populate(NavigableMap&lt;Integer, Integer&gt; map, int limit) {
1065         for (int i = 0, n = 2 * limit / 3; i &lt; n; i++) {
1066             int key = rnd.nextInt(limit);
1067             put(map, key);
1068         }
1069     }
1070 
1071     void mutateMap(NavigableMap&lt;Integer, Integer&gt; map, int min, int max) {
1072         int size = map.size();
1073         int rangeSize = max - min + 1;
1074 
1075         // Remove a bunch of entries directly
1076         for (int i = 0, n = rangeSize / 2; i &lt; n; i++) {
1077             remove(map, min - 5 + rnd.nextInt(rangeSize + 10));
1078         }
1079 
1080         // Remove a bunch of entries with iterator
1081         for (Iterator&lt;Integer&gt; it = map.keySet().iterator(); it.hasNext(); ) {
1082             if (rnd.nextBoolean()) {
1083                 bs.clear(it.next());
1084                 it.remove();
1085             }
1086         }
1087 
1088         // Add entries till we&#39;re back to original size
1089         while (map.size() &lt; size) {
1090             int key = min + rnd.nextInt(rangeSize);
1091             assertTrue(key &gt;= min &amp;&amp; key &lt;= max);
1092             put(map, key);
1093         }
1094     }
1095 
1096     void mutateSubMap(NavigableMap&lt;Integer, Integer&gt; map, int min, int max) {
1097         int size = map.size();
1098         int rangeSize = max - min + 1;
1099 
1100         // Remove a bunch of entries directly
1101         for (int i = 0, n = rangeSize / 2; i &lt; n; i++) {
1102             remove(map, min - 5 + rnd.nextInt(rangeSize + 10));
1103         }
1104 
1105         // Remove a bunch of entries with iterator
1106         for (Iterator&lt;Integer&gt; it = map.keySet().iterator(); it.hasNext(); ) {
1107             if (rnd.nextBoolean()) {
1108                 bs.clear(it.next());
1109                 it.remove();
1110             }
1111         }
1112 
1113         // Add entries till we&#39;re back to original size
1114         while (map.size() &lt; size) {
1115             int key = min - 5 + rnd.nextInt(rangeSize + 10);
1116             if (key &gt;= min &amp;&amp; key &lt;= max) {
1117                 put(map, key);
1118             } else {
1119                 try {
1120                     map.put(key, 2 * key);
1121                     shouldThrow();
1122                 } catch (IllegalArgumentException success) {}
1123             }
1124         }
1125     }
1126 
1127     void put(NavigableMap&lt;Integer, Integer&gt; map, int key) {
1128         if (map.put(key, 2 * key) == null)
1129             bs.set(key);
1130     }
1131 
1132     void remove(NavigableMap&lt;Integer, Integer&gt; map, int key) {
1133         if (map.remove(key) != null)
1134             bs.clear(key);
1135     }
1136 
1137     void bashSubMap(NavigableMap&lt;Integer, Integer&gt; map,
1138                     int min, int max, boolean ascending) {
1139         check(map, min, max, ascending);
1140         check(map.descendingMap(), min, max, !ascending);
1141 
1142         mutateSubMap(map, min, max);
1143         check(map, min, max, ascending);
1144         check(map.descendingMap(), min, max, !ascending);
1145 
1146         // Recurse
1147         if (max - min &lt; 2)
1148             return;
1149         int midPoint = (min + max) / 2;
1150 
1151         // headMap - pick direction and endpoint inclusion randomly
1152         boolean incl = rnd.nextBoolean();
1153         NavigableMap&lt;Integer,Integer&gt; hm = map.headMap(midPoint, incl);
1154         if (ascending) {
1155             if (rnd.nextBoolean())
1156                 bashSubMap(hm, min, midPoint - (incl ? 0 : 1), true);
1157             else
1158                 bashSubMap(hm.descendingMap(), min, midPoint - (incl ? 0 : 1),
1159                            false);
1160         } else {
1161             if (rnd.nextBoolean())
1162                 bashSubMap(hm, midPoint + (incl ? 0 : 1), max, false);
1163             else
1164                 bashSubMap(hm.descendingMap(), midPoint + (incl ? 0 : 1), max,
1165                            true);
1166         }
1167 
1168         // tailMap - pick direction and endpoint inclusion randomly
1169         incl = rnd.nextBoolean();
1170         NavigableMap&lt;Integer,Integer&gt; tm = map.tailMap(midPoint,incl);
1171         if (ascending) {
1172             if (rnd.nextBoolean())
1173                 bashSubMap(tm, midPoint + (incl ? 0 : 1), max, true);
1174             else
1175                 bashSubMap(tm.descendingMap(), midPoint + (incl ? 0 : 1), max,
1176                            false);
1177         } else {
1178             if (rnd.nextBoolean()) {
1179                 bashSubMap(tm, min, midPoint - (incl ? 0 : 1), false);
1180             } else {
1181                 bashSubMap(tm.descendingMap(), min, midPoint - (incl ? 0 : 1),
1182                            true);
1183             }
1184         }
1185 
1186         // subMap - pick direction and endpoint inclusion randomly
1187         int rangeSize = max - min + 1;
1188         int[] endpoints = new int[2];
1189         endpoints[0] = min + rnd.nextInt(rangeSize);
1190         endpoints[1] = min + rnd.nextInt(rangeSize);
1191         Arrays.sort(endpoints);
1192         boolean lowIncl = rnd.nextBoolean();
1193         boolean highIncl = rnd.nextBoolean();
1194         if (ascending) {
1195             NavigableMap&lt;Integer,Integer&gt; sm = map.subMap(
1196                 endpoints[0], lowIncl, endpoints[1], highIncl);
1197             if (rnd.nextBoolean())
1198                 bashSubMap(sm, endpoints[0] + (lowIncl ? 0 : 1),
1199                            endpoints[1] - (highIncl ? 0 : 1), true);
1200             else
1201                 bashSubMap(sm.descendingMap(), endpoints[0] + (lowIncl ? 0 : 1),
1202                            endpoints[1] - (highIncl ? 0 : 1), false);
1203         } else {
1204             NavigableMap&lt;Integer,Integer&gt; sm = map.subMap(
1205                 endpoints[1], highIncl, endpoints[0], lowIncl);
1206             if (rnd.nextBoolean())
1207                 bashSubMap(sm, endpoints[0] + (lowIncl ? 0 : 1),
1208                            endpoints[1] - (highIncl ? 0 : 1), false);
1209             else
1210                 bashSubMap(sm.descendingMap(), endpoints[0] + (lowIncl ? 0 : 1),
1211                            endpoints[1] - (highIncl ? 0 : 1), true);
1212         }
1213     }
1214 
1215     /**
1216      * min and max are both inclusive.  If max &lt; min, interval is empty.
1217      */
1218     void check(NavigableMap&lt;Integer, Integer&gt; map,
1219                       final int min, final int max, final boolean ascending) {
1220         class ReferenceSet {
1221             int lower(int key) {
1222                 return ascending ? lowerAscending(key) : higherAscending(key);
1223             }
1224             int floor(int key) {
1225                 return ascending ? floorAscending(key) : ceilingAscending(key);
1226             }
1227             int ceiling(int key) {
1228                 return ascending ? ceilingAscending(key) : floorAscending(key);
1229             }
1230             int higher(int key) {
1231                 return ascending ? higherAscending(key) : lowerAscending(key);
1232             }
1233             int first() {
1234                 return ascending ? firstAscending() : lastAscending();
1235             }
1236             int last() {
1237                 return ascending ? lastAscending() : firstAscending();
1238             }
1239             int lowerAscending(int key) {
1240                 return floorAscending(key - 1);
1241             }
1242             int floorAscending(int key) {
1243                 if (key &lt; min)
1244                     return -1;
1245                 else if (key &gt; max)
1246                     key = max;
1247 
1248                 // BitSet should support this! Test would run much faster
1249                 while (key &gt;= min) {
1250                     if (bs.get(key))
1251                         return key;
1252                     key--;
1253                 }
1254                 return -1;
1255             }
1256             int ceilingAscending(int key) {
1257                 if (key &lt; min)
1258                     key = min;
1259                 else if (key &gt; max)
1260                     return -1;
1261                 int result = bs.nextSetBit(key);
1262                 return result &gt; max ? -1 : result;
1263             }
1264             int higherAscending(int key) {
1265                 return ceilingAscending(key + 1);
1266             }
1267             private int firstAscending() {
1268                 int result = ceilingAscending(min);
1269                 return result &gt; max ? -1 : result;
1270             }
1271             private int lastAscending() {
1272                 int result = floorAscending(max);
1273                 return result &lt; min ? -1 : result;
1274             }
1275         }
1276         ReferenceSet rs = new ReferenceSet();
1277 
1278         // Test contents using containsKey
1279         int size = 0;
1280         for (int i = min; i &lt;= max; i++) {
1281             boolean bsContainsI = bs.get(i);
1282             assertEquals(bsContainsI, map.containsKey(i));
1283             if (bsContainsI)
1284                 size++;
1285         }
1286         assertEquals(size, map.size());
1287 
1288         // Test contents using contains keySet iterator
1289         int size2 = 0;
1290         int previousKey = -1;
1291         for (int key : map.keySet()) {
1292             assertTrue(bs.get(key));
1293             size2++;
1294             assertTrue(previousKey &lt; 0 ||
1295                 (ascending ? key - previousKey &gt; 0 : key - previousKey &lt; 0));
1296             previousKey = key;
1297         }
1298         assertEquals(size2, size);
1299 
1300         // Test navigation ops
1301         for (int key = min - 1; key &lt;= max + 1; key++) {
1302             assertEq(map.lowerKey(key), rs.lower(key));
1303             assertEq(map.floorKey(key), rs.floor(key));
1304             assertEq(map.higherKey(key), rs.higher(key));
1305             assertEq(map.ceilingKey(key), rs.ceiling(key));
1306         }
1307 
1308         // Test extrema
1309         if (map.size() != 0) {
1310             assertEq(map.firstKey(), rs.first());
1311             assertEq(map.lastKey(), rs.last());
1312         } else {
1313             assertEq(rs.first(), -1);
1314             assertEq(rs.last(),  -1);
1315             try {
1316                 map.firstKey();
1317                 shouldThrow();
1318             } catch (NoSuchElementException success) {}
1319             try {
1320                 map.lastKey();
1321                 shouldThrow();
1322             } catch (NoSuchElementException success) {}
1323         }
1324     }
1325 
1326     static void assertEq(Integer i, int j) {
1327         if (i == null)
1328             assertEquals(j, -1);
1329         else
1330             assertEquals((int) i, j);
1331     }
1332 
1333     static boolean eq(Integer i, int j) {
1334         return (i == null) ? j == -1 : i == j;
1335     }
1336 
1337 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
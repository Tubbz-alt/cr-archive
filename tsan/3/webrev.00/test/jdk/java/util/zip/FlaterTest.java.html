<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/util/zip/FlaterTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 6348045 6341887 8231770
 27  * @summary GZipOutputStream/InputStream goes critical(calls JNI_Get*Critical)
 28  * and causes slowness. This test uses Deflater and Inflater directly.
 29  * @key randomness
 30  * @run main/othervm -Xcheck:jni FlaterTest
 31  */
 32 
 33 import java.nio.*;
 34 import java.util.*;
 35 import java.util.zip.*;
 36 
 37 /**
 38  * This test runs Inflater and Defalter in a number of simultaneous threads,
 39  * validating that the deflated &amp; then inflated data matches the original
 40  * data.
 41  */
 42 public class FlaterTest extends Thread {
 43     private static final int DATA_LEN = 1024 * 128;
 44 
 45     private static ByteBuffer dataDirect;
 46     private static ByteBuffer dataHeap;
 47 
 48     // If true, print extra info.
 49     private static final boolean debug = false;
 50 
 51     // Set of Flater threads running.
 52     private static Set&lt;Flater&gt; flaters =
 53         Collections.synchronizedSet(new HashSet&lt;&gt;());
 54 
 55     /** Fill in {@code data} with random values. */
 56     static void createData() {
 57         ByteBuffer bb = ByteBuffer.allocateDirect(DATA_LEN * 8);
 58         for (int i = 0; i &lt; DATA_LEN * 8; i += 8) {
 59             bb.putDouble(i, Math.random());
 60         }
 61         dataDirect = bb;
 62         final ByteBuffer hb = ByteBuffer.allocate(bb.capacity());
 63         hb.duplicate().put(bb.duplicate());
 64         dataHeap = hb;
 65         if (debug) System.out.println(&quot;data length is &quot; + bb.capacity());
 66     }
 67 
 68     /** @return the length of the deflated {@code data}. */
 69     private static int getDeflatedLength() {
 70         Deflater deflater = new Deflater();
 71         deflater.setInput(dataDirect.duplicate());
 72         deflater.finish();
 73         byte[] out = new byte[dataDirect.capacity()];
 74         int rc = deflater.deflate(out);
 75         deflater.end();
 76         if (debug) System.out.println(&quot;deflatedLength is &quot; + rc);
 77         return rc;
 78     }
 79 
 80     /** Compares given bytes with those in {@code data}.
 81      * @throws Exception if given bytes don&#39;t match {@code data}.
 82      */
 83     private static void validate(ByteBuffer buf, int offset, int len) throws Exception {
 84         for (int i = 0; i &lt; len; i++ ) {
 85             if (buf.get(i) != dataDirect.get(offset+i)) {
 86                 throw new Exception(&quot;mismatch at &quot; + (offset + i));
 87             }
 88         }
 89     }
 90 
 91     public static void realMain(String[] args) {
 92         int numThreads = args.length &gt; 0 ? Integer.parseInt(args[0]) : 5;
 93         createData();
 94         for (int srcMode = 0; srcMode &lt;= 2; srcMode ++) {
 95             for (int dstMode = 0; dstMode &lt;= 2; dstMode ++) {
 96                 new FlaterTest().go(numThreads, srcMode, dstMode);
 97             }
 98         }
 99     }
100 
101     private synchronized void go(int numThreads, int srcMode, int dstMode) {
102         int deflatedLength = getDeflatedLength();
103 
104         long time = System.currentTimeMillis();
105         for (int i = 0; i &lt; numThreads; i++) {
106             Flater f = new Flater(deflatedLength, srcMode, dstMode);
107             flaters.add(f);
108             f.start();
109         }
110         synchronized (flaters) {
111             while (flaters.size() != 0) {
112                 try {
113                     flaters.wait();
114                 } catch (InterruptedException ex) {
115                     unexpected(ex);
116                 }
117             }
118         }
119         time = System.currentTimeMillis() - time;
120         System.out.println(&quot;Time needed for &quot; + numThreads
121                            + &quot; threads to deflate/inflate: &quot; + time + &quot; ms (srcMode=&quot;+srcMode+&quot;,dstMode=&quot;+dstMode+&quot;)&quot;);
122     }
123 
124     /** Deflates and inflates data. */
125     static class Flater extends Thread {
126         private final int deflatedLength;
127         private final int srcMode, dstMode;
128 
129         private Flater(int length, int srcMode, int dstMode) {
130             this.deflatedLength = length;
131             this.srcMode = srcMode;
132             this.dstMode = dstMode;
133         }
134 
135         /** Deflates and inflates {@code data}. */
136         public void run() {
137             if (debug) System.out.println(getName() + &quot; starting run()&quot;);
138             try {
139                 ByteBuffer deflated = DeflateData(deflatedLength);
140                 InflateData(deflated);
141             } catch (Throwable t) {
142                 t.printStackTrace();
143                 fail(getName() + &quot; failed&quot;);
144             } finally {
145                 synchronized (flaters) {
146                     flaters.remove(this);
147                     if (flaters.isEmpty()) {
148                         flaters.notifyAll();
149                     }
150                 }
151             }
152         }
153 
154         /** Returns a copy of {@code data} in deflated form. */
155         private ByteBuffer DeflateData(int length) {
156             Deflater deflater = new Deflater();
157             if (srcMode == 0) {
158                 deflater.setInput(dataHeap.array());
159             } else if (srcMode == 1) {
160                 deflater.setInput(dataHeap.duplicate());
161             } else {
162                 assert srcMode == 2;
163                 deflater.setInput(dataDirect.duplicate());
164             }
165             deflater.finish();
166             ByteBuffer out = dstMode == 2 ? ByteBuffer.allocateDirect(length) : ByteBuffer.allocate(length);
167             int deflated;
168             if (dstMode == 0) {
169                 deflated = deflater.deflate(out.array(), 0, length);
170                 out.position(deflated);
171             } else {
172                 deflater.deflate(out);
173             }
174             out.flip();
175             return out;
176         }
177 
178         /** Inflate a byte array, comparing it with {@code data} during
179          * inflation.
180          * @throws Exception if inflated bytes don&#39;t match {@code data}.
181          */
182         private void InflateData(ByteBuffer bytes) throws Throwable {
183             Inflater inflater = new Inflater();
184             if (dstMode == 0) {
185                 inflater.setInput(bytes.array(), 0, bytes.remaining());
186             } else {
187                 inflater.setInput(bytes);
188             }
189             if (inflater.getRemaining() == 0) {
190                 throw new Exception(&quot;Nothing to inflate (bytes=&quot; + bytes + &quot;)&quot;);
191             }
192             int len = 1024 * 8;
193             int offset = 0;
194             ByteBuffer buf = srcMode == 2 ? ByteBuffer.allocateDirect(len) : ByteBuffer.allocate(len);
195             while (inflater.getRemaining() &gt; 0) {
196                 buf.clear();
197                 int inflated;
198                 if (srcMode == 0) {
199                     inflated = inflater.inflate(buf.array(), 0, buf.remaining());
200                 } else {
201                     inflated = inflater.inflate(buf);
202                 }
203                 if (inflated == 0) {
204                     throw new Exception(&quot;Nothing inflated (dst=&quot; + buf + &quot;,offset=&quot; + offset + &quot;,rem=&quot; + inflater.getRemaining() + &quot;,srcMode=&quot;+srcMode+&quot;,dstMode=&quot;+dstMode+&quot;)&quot;);
205                 }
206                 validate(buf, offset, inflated);
207                 offset += inflated;
208             }
209         }
210     }
211 
212     //--------------------- Infrastructure ---------------------------
213     static volatile int passed = 0, failed = 0;
214     static void pass() {passed++;}
215     static void fail() {failed++; Thread.dumpStack();}
216     static void fail(String msg) {System.out.println(msg); fail();}
217     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
218     static void check(boolean cond) {if (cond) pass(); else fail();}
219     static void equal(Object x, Object y) {
220         if (x == null ? y == null : x.equals(y)) pass();
221         else fail(x + &quot; not equal to &quot; + y);}
222     public static void main(String[] args) throws Throwable {
223         try {realMain(args);} catch (Throwable t) {unexpected(t);}
224         System.out.println(&quot;\nPassed = &quot; + passed + &quot; failed = &quot; + failed);
225         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
226 }
    </pre>
  </body>
</html>
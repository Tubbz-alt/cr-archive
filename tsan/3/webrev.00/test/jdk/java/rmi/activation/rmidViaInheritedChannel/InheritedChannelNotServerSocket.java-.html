<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/rmi/activation/rmidViaInheritedChannel/InheritedChannelNotServerSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 6261402 6824141
 26  * @summary If rmid has an inherited channel that is not a server
 27  * socket (such as it if was started using rsh/rcmd), then it should
 28  * function normally.
 29  * @author Peter Jones
 30  *
 31  * @library ../../testlibrary
 32  * @modules java.base/sun.nio.ch
 33  *          java.rmi/sun.rmi.registry
 34  *          java.rmi/sun.rmi.server
 35  *          java.rmi/sun.rmi.transport
 36  *          java.rmi/sun.rmi.transport.tcp
 37  * @build TestLibrary RMID ActivationLibrary
 38  * @run main/othervm/timeout=240 InheritedChannelNotServerSocket
 39  * @key intermittent
 40  */
 41 
 42 import java.io.IOException;
 43 import java.net.Socket;
 44 import java.net.ProtocolFamily;
 45 import java.nio.channels.Channel;
 46 import java.nio.channels.DatagramChannel;
 47 import java.nio.channels.Pipe;
 48 import java.nio.channels.ServerSocketChannel;
 49 import java.nio.channels.SocketChannel;
 50 import java.nio.channels.spi.AbstractSelector;
 51 import java.nio.channels.spi.SelectorProvider;
 52 import java.rmi.NotBoundException;
 53 import java.rmi.Remote;
 54 import java.rmi.RemoteException;
 55 import java.rmi.activation.ActivationGroup;
 56 import java.rmi.activation.ActivationSystem;
 57 import java.rmi.registry.LocateRegistry;
 58 import java.rmi.registry.Registry;
 59 import java.rmi.server.UnicastRemoteObject;
 60 
 61 public class InheritedChannelNotServerSocket {
 62     private static final Object lock = new Object();
 63     private static boolean notified = false;
 64 
 65     private InheritedChannelNotServerSocket() { }
 66 
 67     public interface Callback extends Remote {
 68         void notifyTest() throws RemoteException;
 69     }
 70 
 71     public static class CallbackImpl implements Callback {
 72         CallbackImpl() { }
 73         public void notifyTest() {
 74             synchronized (lock) {
 75                 notified = true;
 76                 System.err.println(&quot;notification received.&quot;);
 77                 lock.notifyAll();
 78             }
 79         }
 80     }
 81 
 82     public static void main(String[] args) throws Exception {
 83         System.err.println(&quot;\nRegression test for bug 6261402\n&quot;);
 84         System.setProperty(&quot;java.rmi.activation.port&quot;,
 85                            Integer.toString(TestLibrary.INHERITEDCHANNELNOTSERVERSOCKET_ACTIVATION_PORT));
 86         RMID rmid = null;
 87         Callback obj = null;
 88         try {
 89             /*
 90              * Export callback object and bind in registry.
 91              */
 92             System.err.println(&quot;export callback object and bind in registry&quot;);
 93             obj = new CallbackImpl();
 94             Callback proxy =
 95                 (Callback) UnicastRemoteObject.exportObject(obj, 0);
 96             Registry registry = TestLibrary.createRegistryOnEphemeralPort();
 97             int registryPort = TestLibrary.getRegistryPort(registry);
 98             registry.bind(&quot;Callback&quot;, proxy);
 99 
100             /*
101              * Start rmid.
102              */
103             System.err.println(&quot;start rmid with inherited channel&quot;);
104             RMID.removeLog();
105             rmid = RMID.createRMID(System.out, System.err, true, true,
106                                    TestLibrary.INHERITEDCHANNELNOTSERVERSOCKET_ACTIVATION_PORT);
107             rmid.addOptions(
108                 &quot;--add-exports=java.base/sun.nio.ch=ALL-UNNAMED&quot;,
109                 &quot;-Djava.nio.channels.spi.SelectorProvider=InheritedChannelNotServerSocket$SP&quot;,
110                 &quot;-Dtest.java.rmi.rmidViaInheritedChannel.registry.port=&quot; + registryPort);
111             rmid.start();
112 
113             /*
114              * Get activation system and wait to be notified via callback
115              * from rmid&#39;s selector provider.
116              */
117             System.err.println(&quot;get activation system&quot;);
118             ActivationSystem system = ActivationGroup.getSystem();
119             System.err.println(&quot;ActivationSystem = &quot; + system);
120             synchronized (lock) {
121                 while (!notified) {
122                     lock.wait();
123                 }
124             }
125             System.err.println(&quot;TEST PASSED&quot;);
126         } finally {
127             if (obj != null) {
128                 UnicastRemoteObject.unexportObject(obj, true);
129             }
130             if (rmid != null) {
131                 rmid.cleanup();
132             }
133         }
134     }
135 
136     public static class SP extends SelectorProvider {
137         private final SelectorProvider provider;
138         private volatile SocketChannel channel = null;
139 
140         public SP() {
141             provider = sun.nio.ch.DefaultSelectorProvider.create();
142         }
143 
144         public DatagramChannel openDatagramChannel() throws IOException {
145             return provider.openDatagramChannel();
146         }
147 
148         public DatagramChannel openDatagramChannel(ProtocolFamily family)
149             throws IOException
150         {
151             return provider.openDatagramChannel(family);
152         }
153 
154         public Pipe openPipe() throws IOException {
155             return provider.openPipe();
156         }
157 
158         public AbstractSelector openSelector() throws IOException {
159             return provider.openSelector();
160         }
161 
162         public ServerSocketChannel openServerSocketChannel()
163             throws IOException
164         {
165             return provider.openServerSocketChannel();
166         }
167 
168         public SocketChannel openSocketChannel() throws IOException {
169             return provider.openSocketChannel();
170         }
171 
172         public synchronized Channel inheritedChannel() throws IOException {
173             System.err.println(&quot;SP.inheritedChannel&quot;);
174             if (channel == null) {
175                 channel = SocketChannel.open();
176                 Socket socket = channel.socket();
177                 System.err.println(&quot;socket = &quot; + socket);
178 
179                 /*
180                  * Notify test that inherited channel was created.
181                  */
182                 try {
183                     System.err.println(&quot;notify test...&quot;);
184                     int registryPort = Integer.getInteger(
185                             &quot;test.java.rmi.rmidViaInheritedChannel.registry.port&quot;, 0);
186                     Registry registry = LocateRegistry.getRegistry(registryPort);
187                     Callback obj = (Callback) registry.lookup(&quot;Callback&quot;);
188                     obj.notifyTest();
189                 } catch (NotBoundException nbe) {
190                     throw (IOException)
191                         new IOException(&quot;callback object not bound&quot;).
192                             initCause(nbe);
193                 }
194             }
195             return channel;
196         }
197     }
198 }
    </pre>
  </body>
</html>
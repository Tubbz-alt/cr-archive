<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/io/Serializable/records/AbsentStreamValuesTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Checks that the appropriate default value is given to the canonical ctr
 27  * @compile --enable-preview -source ${jdk.version} AbsentStreamValuesTest.java
 28  * @run testng/othervm --enable-preview AbsentStreamValuesTest
 29  * @run testng/othervm/java.security.policy=empty_security.policy --enable-preview AbsentStreamValuesTest
 30  */
 31 
 32 import java.io.ByteArrayInputStream;
 33 import java.io.ByteArrayOutputStream;
 34 import java.io.DataOutputStream;
 35 import java.io.IOException;
 36 import java.io.ObjectInputStream;
 37 import java.io.Serializable;
 38 import org.testng.annotations.DataProvider;
 39 import org.testng.annotations.Test;
 40 import static java.io.ObjectStreamConstants.*;
 41 import static java.lang.System.out;
 42 import static org.testng.Assert.*;
 43 
 44 /**
 45  * Basic test to check that default primitive / reference values are presented
 46  * to the record&#39;s canonical constructor, for fields not in the stream.
 47  */
 48 public class AbsentStreamValuesTest {
 49 
 50     record R01(boolean  x) implements Serializable { }
 51     record R02(byte     x) implements Serializable { }
 52     record R03(short    x) implements Serializable { }
 53     record R04(char     x) implements Serializable { }
 54     record R05(int      x) implements Serializable { }
 55     record R06(long     x) implements Serializable { }
 56     record R07(float    x) implements Serializable { }
 57     record R08(double   x) implements Serializable { }
 58     record R09(Object   x) implements Serializable { }
 59     record R10(String   x) implements Serializable { }
 60     record R11(int[]    x) implements Serializable { }
 61     record R12(Object[] x) implements Serializable { }
 62     record R13(R12      x) implements Serializable { }
 63     record R14(R13[]    x) implements Serializable { }
 64 
 65     @DataProvider(name = &quot;recordTypeAndExpectedValue&quot;)
 66     public Object[][] recordTypeAndExpectedValue() {
 67         return new Object[][] {
 68                 new Object[] { R01.class, false    },
 69                 new Object[] { R02.class, (byte)0  },
 70                 new Object[] { R03.class, (short)0 },
 71                 new Object[] { R04.class, &#39;\u0000&#39; },
 72                 new Object[] { R05.class, 0        },
 73                 new Object[] { R06.class, 0L       },
 74                 new Object[] { R07.class, 0.0f     },
 75                 new Object[] { R08.class, 0.0d     },
 76                 new Object[] { R09.class, null     },
 77                 new Object[] { R10.class, null     },
 78                 new Object[] { R11.class, null     },
 79                 new Object[] { R12.class, null     },
 80                 new Object[] { R13.class, null     },
 81                 new Object[] { R14.class, null     },
 82         };
 83     }
 84 
 85     @Test(dataProvider = &quot;recordTypeAndExpectedValue&quot;)
 86     public void testWithDifferentTypes(Class&lt;?&gt; clazz, Object expectedXValue)
 87         throws Exception
 88     {
 89         out.println(&quot;\n---&quot;);
 90         assert clazz.isRecord();
 91         byte[] bytes = minimalByteStreamFor(clazz.getName());
 92 
 93         Object obj = deserialize(bytes);
 94         out.println(&quot;deserialized: &quot; + obj);
 95         Object actualXValue = clazz.getDeclaredMethod(&quot;x&quot;).invoke(obj);
 96         assertEquals(actualXValue, expectedXValue);
 97     }
 98 
 99     // --- all together
100 
101     record R15(boolean a, byte b, short c, char d, int e, long f, float g, double h, Object i, String j, long[] k, Object[] l)
102         implements Serializable { }
103 
104     @Test
105     public void testWithAllTogether() throws Exception {
106         out.println(&quot;\n---&quot;);
107         byte[] bytes = minimalByteStreamFor(R15.class.getName());
108 
109         R15 obj = (R15)deserialize(bytes);
110         out.println(&quot;deserialized: &quot; + obj);
111         assertEquals(obj.a, false);
112         assertEquals(obj.b, 0);
113         assertEquals(obj.c, 0);
114         assertEquals(obj.d, &#39;\u0000&#39;);
115         assertEquals(obj.e, 0);
116         assertEquals(obj.f, 0l);
117         assertEquals(obj.g, 0f);
118         assertEquals(obj.h, 0d);
119         assertEquals(obj.i, null);
120         assertEquals(obj.j, null);
121         assertEquals(obj.k, null);
122         assertEquals(obj.l, null);
123     }
124 
125     // --- generic type
126 
127     record R16&lt;T, U&gt;(T t, U u) implements Serializable { }
128 
129     @Test
130     public void testGenericType() throws Exception {
131         out.println(&quot;\n---&quot;);
132         byte[] bytes = minimalByteStreamFor(R16.class.getName());
133 
134         R16 obj = (R16)deserialize(bytes);
135         out.println(&quot;deserialized: &quot; + obj);
136         assertEquals(obj.t, null);
137         assertEquals(obj.u, null);
138     }
139 
140     // --- infra
141 
142     /**
143      * Returns the serial bytes for the given class name. The stream
144      * will have no stream field values.
145      */
146     static byte[] minimalByteStreamFor(String className) throws Exception {
147         ByteArrayOutputStream baos = new ByteArrayOutputStream();
148         DataOutputStream dos = new DataOutputStream(baos);
149         dos.writeShort(STREAM_MAGIC);
150         dos.writeShort(STREAM_VERSION);
151         dos.writeByte(TC_OBJECT);
152         dos.writeByte(TC_CLASSDESC);
153         dos.writeUTF(className);
154         dos.writeLong(0L);
155         dos.writeByte(SC_SERIALIZABLE);
156         dos.writeShort(0);             // number of fields
157         dos.writeByte(TC_ENDBLOCKDATA);   // no annotations
158         dos.writeByte(TC_NULL);           // no superclasses
159         dos.close();
160         return baos.toByteArray();
161     }
162 
163     @SuppressWarnings(&quot;unchecked&quot;)
164     static &lt;T&gt; T deserialize(byte[] streamBytes)
165         throws IOException, ClassNotFoundException
166     {
167         ByteArrayInputStream bais = new ByteArrayInputStream(streamBytes);
168         ObjectInputStream ois  = new ObjectInputStream(bais);
169         return (T) ois.readObject();
170     }
171 }
    </pre>
  </body>
</html>
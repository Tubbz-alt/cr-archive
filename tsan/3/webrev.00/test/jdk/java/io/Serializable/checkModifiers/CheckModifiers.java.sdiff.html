<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/io/Serializable/checkModifiers/CheckModifiers.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../badSubstByReplace/BadSubstByReplace.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../class/SerialA_2/A.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/io/Serializable/checkModifiers/CheckModifiers.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 4214888
 26  * @clean CheckModifiers TestClass1 TestClass2
 27  * @build CheckModifiers
 28  * @run main CheckModifiers
 29  * @summary Make sure that serialpersistentFields data member is used to
 30  *          represent tyhe serializable fields only if it has the modfiers
 31  *          static, final, private and the type is ObjectStreamField.
 32  *          No need to check for static, as ObjectStreamField class is not
 33  *          serializable.
 34  *
 35  */
 36 
 37 import java.io.*;
 38 class TestClass1 implements Serializable {


 39     // Missing the &quot;final&quot; modifier

 40     private static ObjectStreamField[] serialPersistentFields = {
 41         new ObjectStreamField(&quot;field1&quot;, Integer.class),
 42         new ObjectStreamField(&quot;field2&quot;, Double.TYPE),
 43     };
 44 
 45     Integer field1;
 46     double field2;
 47     int field3;
 48     String field4;
 49 
 50     public TestClass1(Integer f1, double f2, int f3, String f4) {
 51         field1 = f1;
 52         field2 = f2;
 53         field3 = f3;
 54         field4 = f4;
 55     }
 56 
 57     private void readObject(ObjectInputStream ois)
 58         throws IOException, ClassNotFoundException {
 59         ObjectInputStream.GetField pfields = ois.readFields();
 60 
<span class="line-modified"> 61         field1 = (Integer) pfields.get(&quot;field1&quot;, new Integer(100));</span>
 62         field2 = pfields.get(&quot;field2&quot;, 99.99);
 63 
 64         /* These fields must be present in the stream */
 65         try {
 66             field3 = pfields.get(&quot;field3&quot;, 99);
 67             System.out.println(&quot;Passes test 1a&quot;);
 68         } catch(IllegalArgumentException e) {
 69             throw new Error(&quot;data field: field3 not in the persistent stream&quot;);
 70         }
 71         try {
 72             field4 = (String) pfields.get(&quot;field4&quot;, &quot;Default string&quot;);
 73             System.out.println(&quot;Passes test 1b&quot;);
 74         } catch(IllegalArgumentException e) {
 75             throw new Error(&quot;data field: field4 not in the persistent stream&quot;);
 76         }
 77     }
 78 };
 79 
 80 
 81 class TestClass2 implements Serializable {


 82     // public instead of private

 83     public static final ObjectStreamField[] serialPersistentFields = {
 84         new ObjectStreamField(&quot;field1&quot;, Integer.class),
 85         new ObjectStreamField(&quot;field2&quot;, Double.TYPE),
 86     };
 87 
 88     Integer field1;
 89     double field2;
 90     int field3;
 91     String field4;
 92 
 93     public TestClass2(Integer f1, double f2, int f3, String f4) {
 94         field1 = f1;
 95         field2 = f2;
 96         field3 = f3;
 97         field4 = f4;
 98     }
 99 
100     private void readObject(ObjectInputStream ois)
101         throws IOException, ClassNotFoundException {
102         ObjectInputStream.GetField pfields = ois.readFields();
103 
<span class="line-modified">104         field1 = (Integer) pfields.get(&quot;field1&quot;, new Integer(100));</span>
105         field2 = pfields.get(&quot;field2&quot;, 99.99);
106 
107         /* These fields must be present in the stream */
108         try {
109             field3 = pfields.get(&quot;field3&quot;, 99);
110             System.out.println(&quot;Passes test 2a&quot;);
111         } catch(IllegalArgumentException e) {
112             throw new Error(&quot;data field: field3 not in the persistent stream&quot;);
113         }
114         try {
115             field4 = (String) pfields.get(&quot;field4&quot;, &quot;Default string&quot;);
116             System.out.println(&quot;Passes test 2b&quot;);
117         } catch(IllegalArgumentException e) {
118             throw new Error(&quot;data field: field4 not in the persistent stream&quot;);
119         }
120     }
121 };
122 
123 class TestClass3 implements Serializable{


124     // Not of type ObjectStreamField

125     private final String[] serialPersistentFields =  {&quot;Foo&quot;,&quot;Foobar&quot;};;
126     Integer field1;
127     double field2;
128     int field3;
129     String field4;
130 
131     public TestClass3(Integer f1, double f2, int f3, String f4) {
132         field1 = f1;
133         field2 = f2;
134         field3 = f3;
135         field4 = f4;
136     }
137 
138     private void readObject(ObjectInputStream ois)
139         throws IOException, ClassNotFoundException {
140         ObjectInputStream.GetField pfields = ois.readFields();
141 
<span class="line-modified">142         field1 = (Integer) pfields.get(&quot;field1&quot;, new Integer(100));</span>
143         field2 = pfields.get(&quot;field2&quot;, 99.99);
144         field3 = pfields.get(&quot;field3&quot;, 99);
145         field4 = (String) pfields.get(&quot;field4&quot;, &quot;Default string&quot;);
146 
147         try {
148             String[] tserialPersistentFields =
149                 (String[])pfields.get(&quot;serialPersistentFields&quot;, null);
150             System.out.println(&quot;Passes test 3&quot;);
151         } catch(IllegalArgumentException e) {
152             throw new Error(&quot;non-static field:  &quot; +
153                 &quot;serialPersistentFields must be in the persistent stream&quot;);
154         }
155     }
156 };
157 
158 class TestClass4 implements Serializable {


159     // Correct format
160     private static final ObjectStreamField[] serialPersistentFields = {
161         new ObjectStreamField(&quot;field1&quot;, Integer.class),
162         new ObjectStreamField(&quot;field2&quot;, Double.TYPE),
163     };
164 
165     Integer field1;
166     double field2;
167     int field3;
168     String field4;
169 
170     public TestClass4(Integer f1, double f2, int f3, String f4) {
171         field1 = f1;
172         field2 = f2;
173         field3 = f3;
174         field4 = f4;
175     }
176 
177     private void readObject(ObjectInputStream ois)
178         throws IOException, ClassNotFoundException {
179         ObjectInputStream.GetField pfields = ois.readFields();
180 
<span class="line-modified">181         field1 = (Integer) pfields.get(&quot;field1&quot;, new Integer(100));</span>
182         field2 = pfields.get(&quot;field2&quot;, 99.99);
183 
184         try {
185             field3 = pfields.get(&quot;field3&quot;, 99);
186             throw new Error(&quot;data field: field3 in the persistent stream&quot;);
187         } catch(IllegalArgumentException e) {
188             System.out.println(&quot;Passes test 4a&quot;);
189         }
190         try {
191             field4 = (String) pfields.get(&quot;field4&quot;, &quot;Default string&quot;);
192             throw new Error(&quot;data field: field4 in the persistent stream&quot;);
193         } catch(IllegalArgumentException e) {
194             System.out.println(&quot;Passes test 4b&quot;);
195         }
196     }
197 };
198 
199 public class CheckModifiers {
200     public static void main(String[] args)
201         throws ClassNotFoundException, IOException{
<span class="line-modified">202         TestClass1 tc1 = new TestClass1(new Integer(100), 25.56, 2000,</span>
203             new String(&quot;Test modifiers of serialPersistentFields&quot;));
204 
<span class="line-modified">205         TestClass2 tc2 = new TestClass2(new Integer(100), 25.56, 2000,</span>
206             new String(&quot;Test modifiers of serialPersistentFields&quot;));
207 
<span class="line-modified">208         TestClass3 tc3 = new TestClass3(new Integer(100), 25.56, 2000,</span>
209             new String(&quot;Test Type of serialPersistentFields&quot;));
210 
<span class="line-modified">211         TestClass4 tc4 = new TestClass4(new Integer(100), 25.56, 2000,</span>
212             new String(&quot;Test modifiers of serialPersistentFields&quot;));
213 
214 
215         FileOutputStream fos = new FileOutputStream(&quot;fields.ser&quot;);
216         try {
217             ObjectOutputStream oos = new ObjectOutputStream(fos);
218             System.out.println(&quot;Writing obj 1&quot;);
219             oos.writeObject(tc1);
220             System.out.println(&quot;Writing obj 2&quot;);
221             oos.writeObject(tc2);
222             System.out.println(&quot;Writing obj 3&quot;);
223             oos.writeObject(tc3);
224             System.out.println(&quot;Writing obj 4&quot;);
225             oos.writeObject(tc4);
226             oos.flush();
227         } finally {
228             fos.close();
229         }
230 
231         FileInputStream fis = new FileInputStream(&quot;fields.ser&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 4214888
 26  * @clean CheckModifiers TestClass1 TestClass2
 27  * @build CheckModifiers
 28  * @run main CheckModifiers
 29  * @summary Make sure that serialpersistentFields data member is used to
 30  *          represent tyhe serializable fields only if it has the modfiers
 31  *          static, final, private and the type is ObjectStreamField.
 32  *          No need to check for static, as ObjectStreamField class is not
 33  *          serializable.
 34  *
 35  */
 36 
 37 import java.io.*;
 38 class TestClass1 implements Serializable {
<span class="line-added"> 39     private static final long serialVersionUID = 1L;</span>
<span class="line-added"> 40 </span>
 41     // Missing the &quot;final&quot; modifier
<span class="line-added"> 42     @SuppressWarnings(&quot;serial&quot;) /* Incorrect declarations are being tested */</span>
 43     private static ObjectStreamField[] serialPersistentFields = {
 44         new ObjectStreamField(&quot;field1&quot;, Integer.class),
 45         new ObjectStreamField(&quot;field2&quot;, Double.TYPE),
 46     };
 47 
 48     Integer field1;
 49     double field2;
 50     int field3;
 51     String field4;
 52 
 53     public TestClass1(Integer f1, double f2, int f3, String f4) {
 54         field1 = f1;
 55         field2 = f2;
 56         field3 = f3;
 57         field4 = f4;
 58     }
 59 
 60     private void readObject(ObjectInputStream ois)
 61         throws IOException, ClassNotFoundException {
 62         ObjectInputStream.GetField pfields = ois.readFields();
 63 
<span class="line-modified"> 64         field1 = (Integer) pfields.get(&quot;field1&quot;, Integer.valueOf(100));</span>
 65         field2 = pfields.get(&quot;field2&quot;, 99.99);
 66 
 67         /* These fields must be present in the stream */
 68         try {
 69             field3 = pfields.get(&quot;field3&quot;, 99);
 70             System.out.println(&quot;Passes test 1a&quot;);
 71         } catch(IllegalArgumentException e) {
 72             throw new Error(&quot;data field: field3 not in the persistent stream&quot;);
 73         }
 74         try {
 75             field4 = (String) pfields.get(&quot;field4&quot;, &quot;Default string&quot;);
 76             System.out.println(&quot;Passes test 1b&quot;);
 77         } catch(IllegalArgumentException e) {
 78             throw new Error(&quot;data field: field4 not in the persistent stream&quot;);
 79         }
 80     }
 81 };
 82 
 83 
 84 class TestClass2 implements Serializable {
<span class="line-added"> 85     private static final long serialVersionUID = 1L;</span>
<span class="line-added"> 86 </span>
 87     // public instead of private
<span class="line-added"> 88     @SuppressWarnings(&quot;serial&quot;) /* Incorrect declarations are being tested */</span>
 89     public static final ObjectStreamField[] serialPersistentFields = {
 90         new ObjectStreamField(&quot;field1&quot;, Integer.class),
 91         new ObjectStreamField(&quot;field2&quot;, Double.TYPE),
 92     };
 93 
 94     Integer field1;
 95     double field2;
 96     int field3;
 97     String field4;
 98 
 99     public TestClass2(Integer f1, double f2, int f3, String f4) {
100         field1 = f1;
101         field2 = f2;
102         field3 = f3;
103         field4 = f4;
104     }
105 
106     private void readObject(ObjectInputStream ois)
107         throws IOException, ClassNotFoundException {
108         ObjectInputStream.GetField pfields = ois.readFields();
109 
<span class="line-modified">110         field1 = (Integer) pfields.get(&quot;field1&quot;, Integer.valueOf(100));</span>
111         field2 = pfields.get(&quot;field2&quot;, 99.99);
112 
113         /* These fields must be present in the stream */
114         try {
115             field3 = pfields.get(&quot;field3&quot;, 99);
116             System.out.println(&quot;Passes test 2a&quot;);
117         } catch(IllegalArgumentException e) {
118             throw new Error(&quot;data field: field3 not in the persistent stream&quot;);
119         }
120         try {
121             field4 = (String) pfields.get(&quot;field4&quot;, &quot;Default string&quot;);
122             System.out.println(&quot;Passes test 2b&quot;);
123         } catch(IllegalArgumentException e) {
124             throw new Error(&quot;data field: field4 not in the persistent stream&quot;);
125         }
126     }
127 };
128 
129 class TestClass3 implements Serializable{
<span class="line-added">130     private static final long serialVersionUID = 1L;</span>
<span class="line-added">131 </span>
132     // Not of type ObjectStreamField
<span class="line-added">133     @SuppressWarnings(&quot;serial&quot;) /* Incorrect declarations are being tested */</span>
134     private final String[] serialPersistentFields =  {&quot;Foo&quot;,&quot;Foobar&quot;};;
135     Integer field1;
136     double field2;
137     int field3;
138     String field4;
139 
140     public TestClass3(Integer f1, double f2, int f3, String f4) {
141         field1 = f1;
142         field2 = f2;
143         field3 = f3;
144         field4 = f4;
145     }
146 
147     private void readObject(ObjectInputStream ois)
148         throws IOException, ClassNotFoundException {
149         ObjectInputStream.GetField pfields = ois.readFields();
150 
<span class="line-modified">151         field1 = (Integer) pfields.get(&quot;field1&quot;, Integer.valueOf(100));</span>
152         field2 = pfields.get(&quot;field2&quot;, 99.99);
153         field3 = pfields.get(&quot;field3&quot;, 99);
154         field4 = (String) pfields.get(&quot;field4&quot;, &quot;Default string&quot;);
155 
156         try {
157             String[] tserialPersistentFields =
158                 (String[])pfields.get(&quot;serialPersistentFields&quot;, null);
159             System.out.println(&quot;Passes test 3&quot;);
160         } catch(IllegalArgumentException e) {
161             throw new Error(&quot;non-static field:  &quot; +
162                 &quot;serialPersistentFields must be in the persistent stream&quot;);
163         }
164     }
165 };
166 
167 class TestClass4 implements Serializable {
<span class="line-added">168     private static final long serialVersionUID = 1L;</span>
<span class="line-added">169 </span>
170     // Correct format
171     private static final ObjectStreamField[] serialPersistentFields = {
172         new ObjectStreamField(&quot;field1&quot;, Integer.class),
173         new ObjectStreamField(&quot;field2&quot;, Double.TYPE),
174     };
175 
176     Integer field1;
177     double field2;
178     int field3;
179     String field4;
180 
181     public TestClass4(Integer f1, double f2, int f3, String f4) {
182         field1 = f1;
183         field2 = f2;
184         field3 = f3;
185         field4 = f4;
186     }
187 
188     private void readObject(ObjectInputStream ois)
189         throws IOException, ClassNotFoundException {
190         ObjectInputStream.GetField pfields = ois.readFields();
191 
<span class="line-modified">192         field1 = (Integer) pfields.get(&quot;field1&quot;, Integer.valueOf(100));</span>
193         field2 = pfields.get(&quot;field2&quot;, 99.99);
194 
195         try {
196             field3 = pfields.get(&quot;field3&quot;, 99);
197             throw new Error(&quot;data field: field3 in the persistent stream&quot;);
198         } catch(IllegalArgumentException e) {
199             System.out.println(&quot;Passes test 4a&quot;);
200         }
201         try {
202             field4 = (String) pfields.get(&quot;field4&quot;, &quot;Default string&quot;);
203             throw new Error(&quot;data field: field4 in the persistent stream&quot;);
204         } catch(IllegalArgumentException e) {
205             System.out.println(&quot;Passes test 4b&quot;);
206         }
207     }
208 };
209 
210 public class CheckModifiers {
211     public static void main(String[] args)
212         throws ClassNotFoundException, IOException{
<span class="line-modified">213         TestClass1 tc1 = new TestClass1(100, 25.56, 2000,</span>
214             new String(&quot;Test modifiers of serialPersistentFields&quot;));
215 
<span class="line-modified">216         TestClass2 tc2 = new TestClass2(100, 25.56, 2000,</span>
217             new String(&quot;Test modifiers of serialPersistentFields&quot;));
218 
<span class="line-modified">219         TestClass3 tc3 = new TestClass3(100, 25.56, 2000,</span>
220             new String(&quot;Test Type of serialPersistentFields&quot;));
221 
<span class="line-modified">222         TestClass4 tc4 = new TestClass4(100, 25.56, 2000,</span>
223             new String(&quot;Test modifiers of serialPersistentFields&quot;));
224 
225 
226         FileOutputStream fos = new FileOutputStream(&quot;fields.ser&quot;);
227         try {
228             ObjectOutputStream oos = new ObjectOutputStream(fos);
229             System.out.println(&quot;Writing obj 1&quot;);
230             oos.writeObject(tc1);
231             System.out.println(&quot;Writing obj 2&quot;);
232             oos.writeObject(tc2);
233             System.out.println(&quot;Writing obj 3&quot;);
234             oos.writeObject(tc3);
235             System.out.println(&quot;Writing obj 4&quot;);
236             oos.writeObject(tc4);
237             oos.flush();
238         } finally {
239             fos.close();
240         }
241 
242         FileInputStream fis = new FileInputStream(&quot;fields.ser&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="../badSubstByReplace/BadSubstByReplace.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../class/SerialA_2/A.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
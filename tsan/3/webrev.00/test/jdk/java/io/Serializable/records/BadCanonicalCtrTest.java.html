<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/io/Serializable/records/BadCanonicalCtrTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary InvalidClassException is thrown when the canonical constructor
 27  *          cannot be found during deserialization.
 28  * @library /test/lib
 29  * @modules java.base/jdk.internal.org.objectweb.asm
 30  * @compile --enable-preview -source ${jdk.version} BadCanonicalCtrTest.java
 31  * @run testng/othervm --enable-preview BadCanonicalCtrTest
 32  */
 33 
 34 import java.io.ByteArrayInputStream;
 35 import java.io.ByteArrayOutputStream;
 36 import java.io.IOException;
 37 import java.io.InvalidClassException;
 38 import java.io.ObjectInputStream;
 39 import java.io.ObjectOutputStream;
 40 import java.io.ObjectStreamClass;
 41 import jdk.internal.org.objectweb.asm.ClassReader;
 42 import jdk.internal.org.objectweb.asm.ClassVisitor;
 43 import jdk.internal.org.objectweb.asm.ClassWriter;
 44 import jdk.internal.org.objectweb.asm.MethodVisitor;
 45 import jdk.test.lib.compiler.InMemoryJavaCompiler;
 46 import jdk.test.lib.ByteCodeLoader;
 47 import org.testng.annotations.BeforeTest;
 48 import org.testng.annotations.DataProvider;
 49 import org.testng.annotations.Test;
 50 import static java.lang.System.out;
 51 import static jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES;
 52 import static jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_MAXS;
 53 import static jdk.internal.org.objectweb.asm.Opcodes.*;
 54 import static org.testng.Assert.assertTrue;
 55 import static org.testng.Assert.expectThrows;
 56 
 57 /**
 58  * Checks that an InvalidClassException is thrown when the canonical
 59  * constructor cannot be found during deserialization.
 60  */
 61 public class BadCanonicalCtrTest {
 62     private static final String VERSION = Integer.toString(Runtime.version().feature());
 63 
 64     // ClassLoader for creating instances of the records to test with.
 65     ClassLoader goodRecordClassLoader;
 66     // ClassLoader that can be used during deserialization. Loads record
 67     // classes where the canonical constructor has been removed.
 68     ClassLoader missingCtrClassLoader;
 69     // ClassLoader that can be used during deserialization. Loads record
 70     // classes where the canonical constructor has been tampered with.
 71     ClassLoader nonCanonicalCtrClassLoader;
 72 
 73     /**
 74      * Generates the serializable record classes used by the test. First creates
 75      * the initial bytecode for the record classes using javac, then removes or
 76      * modifies the generated canonical constructor.
 77      */
 78     @BeforeTest
 79     public void setup() {
 80         {
 81             byte[] byteCode = InMemoryJavaCompiler.compile(&quot;R1&quot;,
 82                     &quot;public record R1 () implements java.io.Serializable { }&quot;,
 83                     &quot;--enable-preview&quot;, &quot;-source&quot;, VERSION);
 84             goodRecordClassLoader = new ByteCodeLoader(&quot;R1&quot;, byteCode, BadCanonicalCtrTest.class.getClassLoader());
 85             byte[] bc1 = removeConstructor(byteCode);
 86             missingCtrClassLoader = new ByteCodeLoader(&quot;R1&quot;, bc1, BadCanonicalCtrTest.class.getClassLoader());
 87             byte[] bc2 = modifyConstructor(byteCode);
 88             nonCanonicalCtrClassLoader = new ByteCodeLoader(&quot;R1&quot;, bc2, BadCanonicalCtrTest.class.getClassLoader());
 89         }
 90         {
 91             byte[] byteCode = InMemoryJavaCompiler.compile(&quot;R2&quot;,
 92                     &quot;public record R2 (int x, int y) implements java.io.Serializable { }&quot;,
 93                     &quot;--enable-preview&quot;, &quot;-source&quot;, VERSION);
 94             goodRecordClassLoader = new ByteCodeLoader(&quot;R2&quot;, byteCode, goodRecordClassLoader);
 95             byte[] bc1 = removeConstructor(byteCode);
 96             missingCtrClassLoader = new ByteCodeLoader(&quot;R2&quot;, bc1, missingCtrClassLoader);
 97             byte[] bc2 = modifyConstructor(byteCode);
 98             nonCanonicalCtrClassLoader = new ByteCodeLoader(&quot;R2&quot;, bc2, nonCanonicalCtrClassLoader);
 99         }
100         {
101             byte[] byteCode = InMemoryJavaCompiler.compile(&quot;R3&quot;,
102                     &quot;public record R3 (long l) implements java.io.Externalizable {&quot; +
103                     &quot;    public void writeExternal(java.io.ObjectOutput out) { }&quot; +
104                     &quot;    public void readExternal(java.io.ObjectInput in)    { } }&quot;,
105                     &quot;--enable-preview&quot;, &quot;-source&quot;, VERSION);
106             goodRecordClassLoader = new ByteCodeLoader(&quot;R3&quot;, byteCode, goodRecordClassLoader);
107             byte[] bc1 = removeConstructor(byteCode);
108             missingCtrClassLoader = new ByteCodeLoader(&quot;R3&quot;, bc1, missingCtrClassLoader);
109             byte[] bc2 = modifyConstructor(byteCode);
110             nonCanonicalCtrClassLoader = new ByteCodeLoader(&quot;R3&quot;, bc2, nonCanonicalCtrClassLoader);
111         }
112     }
113 
114     /** Constructs a new instance of record R1. */
115     Object newR1() throws Exception {
116         Class&lt;?&gt; c = Class.forName(&quot;R1&quot;, true, goodRecordClassLoader);
117         assert c.isRecord();
118         assert c.getRecordComponents() != null;
119         return c.getConstructor().newInstance();
120     }
121 
122     /** Constructs a new instance of record R2. */
123     Object newR2(int x, int y) throws Exception{
124         Class&lt;?&gt; c = Class.forName(&quot;R2&quot;, true, goodRecordClassLoader);
125         assert c.isRecord();
126         assert c.getRecordComponents().length == 2;
127         return c.getConstructor(int.class, int.class).newInstance(x, y);
128     }
129 
130     /** Constructs a new instance of record R3. */
131     Object newR3(long l) throws Exception {
132         Class&lt;?&gt; c = Class.forName(&quot;R3&quot;, true, goodRecordClassLoader);
133         assert c.isRecord();
134         assert c.getRecordComponents().length == 1;
135         return c.getConstructor(long.class).newInstance(l);
136     }
137 
138     @DataProvider(name = &quot;recordInstances&quot;)
139     public Object[][] recordInstances() throws Exception {
140         return new Object[][] {
141                 new Object[] { newR1()        },
142                 new Object[] { newR2(19, 20)  },
143                 new Object[] { newR3(67L)     },
144         };
145     }
146 
147     static final Class&lt;InvalidClassException&gt; ICE = InvalidClassException.class;
148 
149     /**
150      * Tests that InvalidClassException is thrown when no constructor is
151      * present.
152      */
153     @Test(dataProvider = &quot;recordInstances&quot;)
154     public void missingConstructorTest(Object objToSerialize) throws Exception {
155         out.println(&quot;\n---&quot;);
156         out.println(&quot;serializing : &quot; + objToSerialize);
157         byte[] bytes = serialize(objToSerialize);
158         out.println(&quot;deserializing&quot;);
159         InvalidClassException ice = expectThrows(ICE, () -&gt; deserialize(bytes, missingCtrClassLoader));
160         out.println(&quot;caught expected ICE: &quot; + ice);
161         assertTrue(ice.getMessage().contains(&quot;record canonical constructor not found&quot;));
162     }
163 
164     /**
165      * Tests that InvalidClassException is thrown when the canonical
166      * constructor is not present. ( a non-canonical constructor is
167      * present ).
168      */
169     @Test(dataProvider = &quot;recordInstances&quot;)
170     public void nonCanonicalConstructorTest(Object objToSerialize) throws Exception {
171         out.println(&quot;\n---&quot;);
172         out.println(&quot;serializing : &quot; + objToSerialize);
173         byte[] bytes = serialize(objToSerialize);
174         out.println(&quot;deserializing&quot;);
175         InvalidClassException ice = expectThrows(ICE, () -&gt; deserialize(bytes, nonCanonicalCtrClassLoader));
176         out.println(&quot;caught expected ICE: &quot; + ice);
177         assertTrue(ice.getMessage().contains(&quot;record canonical constructor not found&quot;));
178     }
179 
180     &lt;T&gt; byte[] serialize(T obj) throws IOException {
181         ByteArrayOutputStream baos = new ByteArrayOutputStream();
182         ObjectOutputStream oos = new ObjectOutputStream(baos);
183         oos.writeObject(obj);
184         oos.close();
185         return baos.toByteArray();
186     }
187 
188     @SuppressWarnings(&quot;unchecked&quot;)
189     &lt;T&gt; T deserialize(byte[] streamBytes, ClassLoader cl)
190         throws IOException, ClassNotFoundException
191     {
192         ByteArrayInputStream bais = new ByteArrayInputStream(streamBytes);
193         ObjectInputStream ois  = new ObjectInputStream(bais) {
194             @Override
195             protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)
196                     throws ClassNotFoundException {
197                 return Class.forName(desc.getName(), false, cl);
198             }
199         };
200         return (T) ois.readObject();
201     }
202 
203     // -- machinery for augmenting record class bytes --
204 
205     /**
206      * Removes the constructor from the given class bytes.
207      * Assumes just a single, canonical, constructor.
208      */
209     static byte[] removeConstructor(byte[] classBytes) {
210         ClassReader reader = new ClassReader(classBytes);
211         ClassWriter writer = new ClassWriter(reader, COMPUTE_MAXS | COMPUTE_FRAMES);
212         reader.accept(new RemoveCanonicalCtrVisitor(writer), 0);
213         return writer.toByteArray();
214     }
215 
216     /** Removes the &lt;init&gt; method. */
217     static class RemoveCanonicalCtrVisitor extends ClassVisitor {
218         static final String CTR_NAME = &quot;&lt;init&gt;&quot;;
219         RemoveCanonicalCtrVisitor(ClassVisitor cv) {
220             super(ASM7, cv);
221         }
222         volatile boolean foundCanonicalCtr;
223         @Override
224         public MethodVisitor visitMethod(final int access,
225                                          final String name,
226                                          final String descriptor,
227                                          final String signature,
228                                          final String[] exceptions) {
229             if (name.equals(CTR_NAME)) {  // assume just a single constructor
230                 assert foundCanonicalCtr == false;
231                 foundCanonicalCtr = true;
232                 return null;
233             } else {
234                 return cv.visitMethod(access, name, descriptor, signature, exceptions);
235             }
236         }
237     }
238 
239     /**
240      * Modifies the descriptor of the constructor from the given class bytes.
241      * Assumes just a single, canonical, constructor.
242      */
243     static byte[] modifyConstructor(byte[] classBytes) {
244         ClassReader reader = new ClassReader(classBytes);
245         ClassWriter writer = new ClassWriter(reader, COMPUTE_MAXS | COMPUTE_FRAMES);
246         reader.accept(new ModifyCanonicalCtrVisitor(writer), 0);
247         return writer.toByteArray();
248     }
249 
250     /** Replaces whatever &lt;init&gt; method it finds with &lt;init&gt;(Ljava/lang/Object;)V. */
251     static class ModifyCanonicalCtrVisitor extends ClassVisitor {
252         ModifyCanonicalCtrVisitor(ClassVisitor cv) {
253             super(ASM7, cv);
254         }
255         boolean foundCanonicalCtr;
256         String className;
257         @Override
258         public void visit(final int version,
259                           final int access,
260                           final String name,
261                           final String signature,
262                           final String superName,
263                           final String[] interfaces) {
264             this.className = name;
265             cv.visit(version, access, name, signature, superName, interfaces);
266         }
267         @Override
268         public MethodVisitor visitMethod(final int access,
269                                          final String name,
270                                          final String descriptor,
271                                          final String signature,
272                                          final String[] exceptions) {
273             if (name.equals(&quot;&lt;init&gt;&quot;)) {  // assume just a single constructor
274                 assert foundCanonicalCtr == false;
275                 foundCanonicalCtr = true;
276                 return null;
277             } else {
278                 return cv.visitMethod(access, name, descriptor, signature, exceptions);
279             }
280         }
281         @Override
282         public void visitEnd() {
283             // must have a signature that is not the same as the test record constructor
284             MethodVisitor mv = cv.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/Object;)V&quot;, null, null);
285             mv.visitCode();
286             mv.visitVarInsn(ALOAD, 0);
287             mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Record&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);
288             mv.visitInsn(RETURN);
289             mv.visitMaxs(1, 1);
290             mv.visitEnd();
291 
292             cv.visitEnd();
293         }
294     }
295 }
    </pre>
  </body>
</html>
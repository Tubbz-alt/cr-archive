<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/io/Serializable/subclass/XObjectInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.*;
 25 import java.lang.reflect.Field;
 26 import java.lang.reflect.Method;
 27 import java.lang.reflect.Modifier;
 28 import java.lang.reflect.InvocationTargetException;
 29 import java.security.*;
 30 
 31 class XObjectInputStream extends AbstractObjectInputStream {
 32 
 33     XObjectInputStream(InputStream in)
 34         throws IOException, StreamCorruptedException
 35         {
 36             super(in);
 37             dis = new DataInputStream(in);
 38         }
 39 
 40     public final void defaultReadObject()
 41         throws IOException, ClassNotFoundException, NotActiveException
 42     {
 43     }
 44 
 45     protected final Object readObjectOverride()
 46         throws OptionalDataException, ClassNotFoundException, IOException {
 47 
 48         Object readResult = null;
 49         Object prevObject = currentObject;
 50         Class  prevDesc   = currentClassDescriptor;
 51 
 52         boolean NotImplemented = true;
 53         if (NotImplemented)
 54             throw new IOException(&quot;readObjectOverride not implemented&quot;);
 55 
 56         try {
 57             currentObject = null;
 58 
 59             //Read in class of object to currentDescriptor
 60             String className = dis.readUTF();
 61             currentClassDescriptor = Class.forName(className);
 62 
 63             try {
 64                 //currentObject = Allocate a new instance of the class
 65                 currentObject =
 66                     allocateNewObject(currentClassDescriptor,
 67                                    currentClassDescriptor);
 68             } catch (InstantiationException e) {
 69                 throw new InvalidClassException(currentClassDescriptor.getName(),
 70                                                 e.getMessage());
 71             } catch (IllegalAccessException e) {
 72                 throw new InvalidClassException(currentClassDescriptor.getName(),
 73                                                 e.getMessage());
 74             }
 75 
 76             //if currentDescriptor.isAssignable(Externalizable.class) {
 77             //    Object[] argList = {this};
 78             //    InvokeMethod(currentObject, readExternalMethod, argList);
 79             //} else {
 80             //    Does currentDescriptor have a readObject method
 81             //    if it does
 82             //        invokeMethod(this, readObjectMethod, {this});
 83             //    else
 84             //        defaultReadObject();
 85             //}
 86             // check for replacement on currentObject.
 87             // if toplevel readobject
 88             //    doObjectValidations.
 89 
 90         } finally {
 91             readResult = currentObject;
 92             currentObject = prevObject;
 93         }
 94         return readResult;
 95     }
 96 
 97     public ObjectInputStream.GetField readFields()
 98         throws IOException, ClassNotFoundException, NotActiveException {
 99             throw new Error(&quot;not implememted&quot;);
100     }
101 
102     public synchronized void registerValidation(ObjectInputValidation obj,
103                                                 int prio)
104         throws NotActiveException, InvalidObjectException {
105     }
106 
107     public int read() throws IOException {
108         return dis.read();
109     }
110 
111     public int read(byte[] data, int offset, int length) throws IOException {
112         return dis.read(data, offset, length);
113     }
114 
115     public int available() throws IOException {
116         return in.available();
117     }
118 
119     public boolean readBoolean() throws IOException {
120         throw new IOException(&quot;Not Implemented&quot;);
121     }
122 
123     public byte readByte() throws IOException {
124         throw new IOException(&quot;Not Implemented&quot;);
125     }
126     public int readUnsignedByte()  throws IOException {
127         throw new IOException(&quot;Not Implemented&quot;);
128     }
129     public short readShort()  throws IOException {
130         throw new IOException(&quot;Not Implemented&quot;);
131     }
132     public int readUnsignedShort() throws IOException {
133         throw new IOException(&quot;Not Implemented&quot;);
134     }
135     public char readChar()  throws IOException {
136         throw new IOException(&quot;Not Implemented&quot;);
137     }
138     public int readInt()  throws IOException {
139         throw new IOException(&quot;Not Implemented&quot;);
140     }
141     public long readLong()  throws IOException {
142         throw new IOException(&quot;Not Implemented&quot;);
143     }
144     public float readFloat() throws IOException {
145         throw new IOException(&quot;Not Implemented&quot;);
146     }
147     public double readDouble() throws IOException {
148         throw new IOException(&quot;Not Implemented&quot;);
149     }
150     public void readFully(byte[] data) throws IOException {
151         throw new IOException(&quot;Not Implemented&quot;);
152     }
153     public void readFully(byte[] data, int offset, int size) throws IOException {
154         throw new IOException(&quot;Not Implemented&quot;);
155     }
156     public int skipBytes(int len) throws IOException {
157         throw new IOException(&quot;Not Implemented&quot;);
158     }
159     public String readLine() throws IOException {
160         throw new IOException(&quot;Not Implemented&quot;);
161     }
162     public String readUTF() throws IOException {
163         throw new IOException(&quot;Not Implemented&quot;);
164     }
165 
166     public void close() throws IOException {
167         in.close();
168     }
169     /**********************************************************/
170 
171     /**
172      * Provide access to the persistent fields read from the input stream.
173      */
174 
175      public static class InternalGetField extends ObjectInputStream.GetField {
176 
177         /**
178          * Get the ObjectStreamClass that describes the fields in the stream.
179          */
180         public ObjectStreamClass getObjectStreamClass() {
181             throw new Error(&quot;not implemented&quot;);
182         }
183 
184         /**
185          * Return true if the named field is defaulted and has no value
186          * in this stream.
187          */
188         public boolean defaulted(String name)
189             throws IOException, IllegalArgumentException
190         {
191             throw new Error(&quot;not implemented&quot;);
192             //ObjectStreamField field = checkField(name, null);
193         }
194 
195          public boolean get(String name, boolean defvalue)
196              throws IOException, IllegalArgumentException {
197              throw new Error(&quot;not implemented&quot;);
198          }
199 
200          public char get(String name, char defvalue)
201              throws IOException, IllegalArgumentException {
202              throw new Error(&quot;not implemented&quot;);
203          }
204 
205          public byte get(String name, byte defvalue)
206              throws IOException, IllegalArgumentException {
207              throw new Error(&quot;not implemented&quot;);
208          }
209 
210          public short get(String name, short defvalue)
211              throws IOException, IllegalArgumentException {
212              throw new Error(&quot;not implemented&quot;);
213          }
214 
215          public int get(String name, int defvalue)
216              throws IOException, IllegalArgumentException {
217              throw new Error(&quot;not implemented&quot;);
218          }
219 
220          public long get(String name, long defvalue)
221              throws IOException, IllegalArgumentException {
222              throw new Error(&quot;not implemented&quot;);
223          }
224 
225          public float get(String name, float defvalue)
226              throws IOException, IllegalArgumentException {
227              throw new Error(&quot;not implemented&quot;);
228          }
229 
230          public double get(String name, double defvalue)
231              throws IOException, IllegalArgumentException {
232              throw new Error(&quot;not implemented&quot;);
233          }
234 
235          public Object get(String name, Object defvalue)
236              throws IOException, IllegalArgumentException {
237              throw new Error(&quot;not implemented&quot;);
238          }
239 
240          public void read(ObjectInputStream in)
241              throws IOException, ClassNotFoundException {
242          }
243      }
244 
245     private Object currentObject;
246     private Class currentClassDescriptor;
247 
248 
249 
250     /****************************************************************/
251 
252     /* CODE LIFTED FROM ObjectStreamClass constuctor.
253      * ObjectStreamClass.readObjectMethod is private.
254      *
255      * Look for the readObject method
256      * Set the accessible flag on it here. ObjectOutputStream
257      * will call it as necessary.
258      */
259     public static Method getReadObjectMethod(final Class cl) {
260 
261         Method readObjectMethod = (Method)
262             java.security.AccessController.doPrivileged
263             (new java.security.PrivilegedAction() {
264                 public Object run() {
265                     Method m = null;
266                     try {
267                         Class[] args = {ObjectInputStream.class};
268                         m = cl.getDeclaredMethod(&quot;readObject&quot;, args);
269                         int mods = m.getModifiers();
270                         // Method must be private and non-static
271                         if (!Modifier.isPrivate(mods) ||
272                             Modifier.isStatic(mods)) {
273                             m = null;
274                         } else {
275                             m.setAccessible(true);
276                         }
277                     } catch (NoSuchMethodException e) {
278                         m = null;
279                     }
280                     return m;
281                 }
282             });
283         return readObjectMethod;
284     }
285 
286     /*************************************************************/
287 
288     /* taken verbatim from ObjectInputStream. */
289     private static void invokeMethod(final Object obj, final Method m,
290                                         final Object[] argList)
291         throws IOException
292     {
293         try {
294             java.security.AccessController.doPrivileged
295                 (new java.security.PrivilegedExceptionAction() {
296                     public Object run() throws InvocationTargetException,
297                                         java.lang.IllegalAccessException {
298                         m.invoke(obj, argList);
299                         return null;
300                     }
301                 });
302         } catch (java.security.PrivilegedActionException e) {
303             Exception ex = e.getException();
304             if (ex instanceof InvocationTargetException) {
305                 Throwable t =
306                         ((InvocationTargetException)ex).getTargetException();
307                 if (t instanceof IOException)
308                     throw (IOException)t;
309                 else if (t instanceof RuntimeException)
310                     throw (RuntimeException) t;
311                 else if (t instanceof Error)
312                     throw (Error) t;
313                 else
314                     throw new Error(&quot;interal error&quot;);
315             } else {
316                 // IllegalAccessException cannot happen
317             }
318         }
319     }
320 
321     protected boolean enableResolveObject(boolean enable)
322         throws SecurityException
323     {
324         throw new Error(&quot;To be implemented&quot;);
325     }
326 
327     private DataInputStream dis;
328 };
    </pre>
  </body>
</html>
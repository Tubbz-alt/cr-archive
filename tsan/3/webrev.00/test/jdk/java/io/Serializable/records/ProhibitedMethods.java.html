<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/io/Serializable/records/ProhibitedMethods.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Basic tests for prohibited magic serialization methods
 27  * @library /test/lib
 28  * @modules java.base/jdk.internal.org.objectweb.asm
 29  * @compile --enable-preview -source ${jdk.version} ProhibitedMethods.java
 30  * @run testng/othervm --enable-preview ProhibitedMethods
 31  */
 32 
 33 import java.io.ByteArrayInputStream;
 34 import java.io.ByteArrayOutputStream;
 35 import java.io.Externalizable;
 36 import java.io.IOException;
 37 import java.io.ObjectInput;
 38 import java.io.ObjectInputStream;
 39 import java.io.ObjectOutput;
 40 import java.io.ObjectOutputStream;
 41 import java.io.ObjectStreamClass;
 42 import java.io.OutputStream;
 43 import java.io.Serializable;
 44 import java.lang.reflect.Method;
 45 import java.lang.reflect.Modifier;
 46 import java.math.BigDecimal;
 47 import java.util.function.Function;
 48 import jdk.internal.org.objectweb.asm.ClassReader;
 49 import jdk.internal.org.objectweb.asm.ClassVisitor;
 50 import jdk.internal.org.objectweb.asm.ClassWriter;
 51 import jdk.internal.org.objectweb.asm.MethodVisitor;
 52 import jdk.test.lib.compiler.InMemoryJavaCompiler;
 53 import jdk.test.lib.ByteCodeLoader;
 54 import org.testng.annotations.BeforeTest;
 55 import org.testng.annotations.DataProvider;
 56 import org.testng.annotations.Test;
 57 import static java.lang.System.out;
 58 import static jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES;
 59 import static jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_MAXS;
 60 import static jdk.internal.org.objectweb.asm.Opcodes.*;
 61 import static org.testng.Assert.assertEquals;
 62 import static org.testng.Assert.assertTrue;
 63 import static org.testng.Assert.expectThrows;
 64 import static org.testng.Assert.fail;
 65 
 66 /**
 67  * Checks that the various prohibited Serialization magic methods, and
 68  * Externalizable methods, are not invoked ( effectively ignored ) for
 69  * record objects.
 70  */
 71 public class ProhibitedMethods {
 72     private static final String VERSION = Integer.toString(Runtime.version().feature());
 73 
 74     public interface ThrowingExternalizable extends Externalizable {
 75         default void writeExternal(ObjectOutput out) {
 76             fail(&quot;should not reach here&quot;);
 77         }
 78         default void readExternal(ObjectInput in) {
 79             fail(&quot;should not reach here&quot;);
 80         }
 81     }
 82 
 83     record Wibble () implements ThrowingExternalizable { }
 84 
 85     record Wobble (long l) implements ThrowingExternalizable { }
 86 
 87     record Wubble (Wobble wobble, Wibble wibble, String s) implements ThrowingExternalizable { }
 88 
 89     ClassLoader serializableRecordLoader;
 90 
 91     /**
 92      * Generates the serializable record classes used by the test. First creates
 93      * the initial bytecode for the record classes using javac, then adds the
 94      * prohibited magic serialization methods. For example, effectively generates:
 95      *
 96      *   public record Foo () implements Serializable {
 97      *       private void writeObject(ObjectOutputStream out)             {
 98      *           fail(&quot;writeObject should not be invoked&quot;);               }
 99      *       private void readObject(ObjectInputStream in)                {
100      *           fail(&quot;readObject should not be invoked&quot;);                }
101      *       private void readObjectNoData()                              {
102      *           fail(&quot;readObjectNoData should not be invoked&quot;);          }
103      *   }
104      */
105     @BeforeTest
106     public void setup() {
107         {
108             byte[] byteCode = InMemoryJavaCompiler.compile(&quot;Foo&quot;,
109                     &quot;public record Foo () implements java.io.Serializable { }&quot;,
110                     &quot;--enable-preview&quot;, &quot;-source&quot;, VERSION);
111             byteCode = addWriteObject(byteCode);
112             byteCode = addReadObject(byteCode);
113             byteCode = addReadObjectNoData(byteCode);
114             serializableRecordLoader = new ByteCodeLoader(&quot;Foo&quot;, byteCode, ProhibitedMethods.class.getClassLoader());
115         }
116         {
117             byte[] byteCode = InMemoryJavaCompiler.compile(&quot;Bar&quot;,
118                     &quot;public record Bar (int x, int y) implements java.io.Serializable { }&quot;,
119                     &quot;--enable-preview&quot;, &quot;-source&quot;, VERSION);
120             byteCode = addWriteObject(byteCode);
121             byteCode = addReadObject(byteCode);
122             byteCode = addReadObjectNoData(byteCode);
123             serializableRecordLoader = new ByteCodeLoader(&quot;Bar&quot;, byteCode, serializableRecordLoader);
124         }
125         {
126             byte[] byteCode = InMemoryJavaCompiler.compile(&quot;Baz&quot;,
127                     &quot;import java.io.Serializable;&quot; +
128                     &quot;public record Baz&lt;U extends Serializable,V extends Serializable&gt;(U u, V v) implements Serializable { }&quot;,
129                     &quot;--enable-preview&quot;, &quot;-source&quot;, VERSION);
130             byteCode = addWriteObject(byteCode);
131             byteCode = addReadObject(byteCode);
132             byteCode = addReadObjectNoData(byteCode);
133             serializableRecordLoader = new ByteCodeLoader(&quot;Baz&quot;, byteCode, serializableRecordLoader);
134         }
135     }
136 
137     /** Constructs a new instance of record Foo. */
138     Object newFoo() {
139         try {
140             Class&lt;?&gt; c = Class.forName(&quot;Foo&quot;, true, serializableRecordLoader);
141             assert c.isRecord();
142             assert c.getRecordComponents() != null;
143             return c.getConstructor().newInstance();
144         } catch (ReflectiveOperationException e) {
145             throw new AssertionError(e);
146         }
147     }
148 
149     /** Constructs a new instance of record Bar. */
150     Object newBar(int x, int y) {
151         try {
152             Class&lt;?&gt; c = Class.forName(&quot;Bar&quot;, true, serializableRecordLoader);
153             assert c.isRecord();
154             assert c.getRecordComponents().length == 2;
155             return c.getConstructor(int.class, int.class).newInstance(x, y);
156         } catch (ReflectiveOperationException e) {
157             throw new AssertionError(e);
158         }
159     }
160 
161     /** Constructs a new instance of record Baz. */
162     Object newBaz(Object u, Object v) {
163         try {
164             Class&lt;?&gt; c = Class.forName(&quot;Baz&quot;, true, serializableRecordLoader);
165             assert c.isRecord();
166             assert c.getRecordComponents().length == 2;
167             return c.getConstructor(Serializable.class, Serializable.class).newInstance(u, v);
168         } catch (ReflectiveOperationException e) {
169             throw new AssertionError(e);
170         }
171     }
172 
173     @DataProvider(name = &quot;recordInstances&quot;)
174     public Object[][] recordInstances() {
175         return new Object[][] {
176             new Object[] { newFoo()                                           },
177             new Object[] { newBar(19, 20)                                     },
178             new Object[] { newBaz(&quot;str&quot;, BigDecimal.valueOf(8765))            },
179             new Object[] { new Wibble()                                       },
180             new Object[] { new Wobble(1000L)                                  },
181             new Object[] { new Wubble(new Wobble(9999L), new Wibble(), &quot;str&quot;) },
182         };
183     }
184 
185     @Test(dataProvider = &quot;recordInstances&quot;)
186     public void roundTrip(Object objToSerialize) throws Exception {
187         out.println(&quot;\n---&quot;);
188         out.println(&quot;serializing : &quot; + objToSerialize);
189         var objDeserialized = serializeDeserialize(objToSerialize);
190         out.println(&quot;deserialized: &quot; + objDeserialized);
191         assertEquals(objToSerialize, objDeserialized);
192         assertEquals(objDeserialized, objToSerialize);
193     }
194 
195     &lt;T&gt; byte[] serialize(T obj) throws IOException {
196         ByteArrayOutputStream baos = new ByteArrayOutputStream();
197         ObjectOutputStream oos = new ObjectOutputStream(baos);
198         oos.writeObject(obj);
199         oos.close();
200         return baos.toByteArray();
201     }
202 
203     @SuppressWarnings(&quot;unchecked&quot;)
204     &lt;T&gt; T deserialize(byte[] streamBytes)
205         throws IOException, ClassNotFoundException
206     {
207         ByteArrayInputStream bais = new ByteArrayInputStream(streamBytes);
208         ObjectInputStream ois  = new ObjectInputStream(bais) {
209             @Override
210             protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)
211                     throws ClassNotFoundException {
212                 return Class.forName(desc.getName(), false, serializableRecordLoader);
213             }
214         };
215         return (T) ois.readObject();
216     }
217 
218     &lt;T&gt; T serializeDeserialize(T obj)
219         throws IOException, ClassNotFoundException
220     {
221         return deserialize(serialize(obj));
222     }
223 
224     // -- machinery for augmenting record classes with prohibited serial methods --
225 
226     static byte[] addWriteObject(byte[] classBytes) {
227         return addMethod(classBytes, cv -&gt; new WriteObjectVisitor(cv));
228     }
229 
230     static byte[] addReadObject(byte[] classBytes) {
231         return addMethod(classBytes, cv -&gt; new ReadObjectVisitor(cv));
232     }
233 
234     static byte[] addReadObjectNoData(byte[] classBytes) {
235         return addMethod(classBytes, cv -&gt; new ReadObjectNoDataVisitor(cv));
236     }
237 
238     static byte[] addMethod(byte[] classBytes,
239                             Function&lt;ClassVisitor,ClassVisitor&gt; classVisitorCreator) {
240         ClassReader reader = new ClassReader(classBytes);
241         ClassWriter writer = new ClassWriter(reader, COMPUTE_MAXS | COMPUTE_FRAMES);
242         reader.accept(classVisitorCreator.apply(writer), 0);
243         return writer.toByteArray();
244     }
245 
246     static abstract class AbstractVisitor extends ClassVisitor {
247         final String nameOfMethodToAdd;
248         AbstractVisitor(ClassVisitor cv, String nameOfMethodToAdd) {
249             super(ASM7, cv);
250             this.nameOfMethodToAdd = nameOfMethodToAdd;
251         }
252         @Override
253         public MethodVisitor visitMethod(final int access,
254                                          final String name,
255                                          final String descriptor,
256                                          final String signature,
257                                          final String[] exceptions) {
258             // the method-to-be-added should not already exist
259             assert !name.equals(nameOfMethodToAdd) : &quot;Unexpected &quot; + name + &quot; method&quot;;
260             return cv.visitMethod(access, name, descriptor, signature, exceptions);
261         }
262         @Override
263         public void visitEnd() {
264             throw new UnsupportedOperationException(&quot;implement me&quot;);
265         }
266     }
267 
268     /** A visitor that generates and adds a writeObject method. */
269     static final class WriteObjectVisitor extends AbstractVisitor {
270         static final String WRITE_OBJECT_NAME = &quot;writeObject&quot;;
271         static final String WRITE_OBJECT_DESC = &quot;(Ljava/io/ObjectOutputStream;)V&quot;;
272         WriteObjectVisitor(ClassVisitor cv) { super(cv, WRITE_OBJECT_NAME); }
273         @Override
274         public void visitEnd() {
275             MethodVisitor mv = cv.visitMethod(ACC_PRIVATE, WRITE_OBJECT_NAME, WRITE_OBJECT_DESC, null, null);
276             mv.visitCode();
277             mv.visitLdcInsn(WRITE_OBJECT_NAME + &quot; should not be invoked&quot;);
278             mv.visitMethodInsn(INVOKESTATIC, &quot;org/testng/Assert&quot;, &quot;fail&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
279             mv.visitInsn(RETURN);
280             mv.visitMaxs(0, 0);
281             mv.visitEnd();
282 
283             cv.visitEnd();
284         }
285     }
286 
287     /** A visitor that generates and adds a readObject method. */
288     static final class ReadObjectVisitor extends AbstractVisitor {
289         static final String READ_OBJECT_NAME = &quot;readObject&quot;;
290         static final String READ_OBJECT_DESC = &quot;(Ljava/io/ObjectInputStream;)V&quot;;
291         ReadObjectVisitor(ClassVisitor cv) { super(cv, READ_OBJECT_NAME); }
292         @Override
293         public void visitEnd() {
294             MethodVisitor mv = cv.visitMethod(ACC_PRIVATE, READ_OBJECT_NAME, READ_OBJECT_DESC, null, null);
295             mv.visitCode();
296             mv.visitLdcInsn(READ_OBJECT_NAME + &quot; should not be invoked&quot;);
297             mv.visitMethodInsn(INVOKESTATIC, &quot;org/testng/Assert&quot;, &quot;fail&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
298             mv.visitInsn(RETURN);
299             mv.visitMaxs(0, 0);
300             mv.visitEnd();
301 
302             cv.visitEnd();
303         }
304     }
305 
306     /** A visitor that generates and adds a readObjectNoData method. */
307     static final class ReadObjectNoDataVisitor extends AbstractVisitor {
308         static final String READ_OBJECT_NO_DATA_NAME = &quot;readObjectNoData&quot;;
309         static final String READ_OBJECT_NO_DATA_DESC = &quot;()V&quot;;
310         ReadObjectNoDataVisitor(ClassVisitor cv) { super(cv, READ_OBJECT_NO_DATA_NAME); }
311         @Override
312         public void visitEnd() {
313             MethodVisitor mv = cv.visitMethod(ACC_PRIVATE, READ_OBJECT_NO_DATA_NAME, READ_OBJECT_NO_DATA_DESC, null, null);
314             mv.visitCode();
315             mv.visitLdcInsn(READ_OBJECT_NO_DATA_NAME + &quot; should not be invoked&quot;);
316             mv.visitMethodInsn(INVOKESTATIC, &quot;org/testng/Assert&quot;, &quot;fail&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
317             mv.visitInsn(RETURN);
318             mv.visitMaxs(0, 0);
319             mv.visitEnd();
320 
321             cv.visitEnd();
322         }
323     }
324 
325     // -- infra sanity --
326 
327     static final Class&lt;ReflectiveOperationException&gt; ROE = ReflectiveOperationException.class;
328 
329     /** Checks to ensure correct operation of the test&#39;s generation logic. */
330     @Test
331     public void wellFormedGeneratedClasses() throws Exception {
332         out.println(&quot;\n---&quot;);
333         for (Object obj : new Object[] { newFoo(), newBar(3, 4), newBaz(1,&quot;s&quot;) }) {
334             out.println(obj);
335             {   // writeObject
336                 Method m = obj.getClass().getDeclaredMethod(&quot;writeObject&quot;, ObjectOutputStream.class);
337                 assertTrue((m.getModifiers() &amp; Modifier.PRIVATE) != 0);
338                 m.setAccessible(true);
339                 ReflectiveOperationException t = expectThrows(ROE, () -&gt;
340                         m.invoke(obj, new ObjectOutputStream(OutputStream.nullOutputStream())));
341                 Throwable assertionError = t.getCause();
342                 out.println(&quot;caught expected AssertionError: &quot; + assertionError);
343                 assertTrue(assertionError instanceof AssertionError,
344                            &quot;Expected AssertionError, got:&quot; + assertionError);
345                 assertEquals(assertionError.getMessage(), &quot;writeObject should not be invoked&quot;);
346             }
347             {   // readObject
348                 Method m = obj.getClass().getDeclaredMethod(&quot;readObject&quot;, ObjectInputStream.class);
349                 assertTrue((m.getModifiers() &amp; Modifier.PRIVATE) != 0);
350                 m.setAccessible(true);
351                 ReflectiveOperationException t = expectThrows(ROE, () -&gt;
352                         m.invoke(obj, new ObjectInputStream() {
353                         }));
354                 Throwable assertionError = t.getCause();
355                 out.println(&quot;caught expected AssertionError: &quot; + assertionError);
356                 assertTrue(assertionError instanceof AssertionError,
357                            &quot;Expected AssertionError, got:&quot; + assertionError);
358                 assertEquals(assertionError.getMessage(), &quot;readObject should not be invoked&quot;);
359             }
360             {   // readObjectNoData
361                 Method m = obj.getClass().getDeclaredMethod(&quot;readObjectNoData&quot;);
362                 assertTrue((m.getModifiers() &amp; Modifier.PRIVATE) != 0);
363                 m.setAccessible(true);
364                 ReflectiveOperationException t = expectThrows(ROE, () -&gt; m.invoke(obj));
365                 Throwable assertionError = t.getCause();
366                 out.println(&quot;caught expected AssertionError: &quot; + assertionError);
367                 assertTrue(assertionError instanceof AssertionError,
368                            &quot;Expected AssertionError, got:&quot; + assertionError);
369                 assertEquals(assertionError.getMessage(), &quot;readObjectNoData should not be invoked&quot;);
370             }
371         }
372     }
373 }
    </pre>
  </body>
</html>
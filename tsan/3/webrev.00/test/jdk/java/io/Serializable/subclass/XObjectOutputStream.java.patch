diff a/test/jdk/java/io/Serializable/subclass/XObjectOutputStream.java b/test/jdk/java/io/Serializable/subclass/XObjectOutputStream.java
--- a/test/jdk/java/io/Serializable/subclass/XObjectOutputStream.java
+++ b/test/jdk/java/io/Serializable/subclass/XObjectOutputStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -114,22 +114,22 @@
         for (int i= 0; i < fields.length; i++) {
             //Skip non-Serializable fields.
             int mods = fields[i].getModifiers();
             if (Modifier.isStatic(mods) || Modifier.isTransient(mods))
                 continue;
-            Class FieldType = fields[i].getType();
+            Class<?> FieldType = fields[i].getType();
             if (FieldType.isPrimitive()) {
                 System.out.println("Field " + fields[i].getName() +
                                     " has primitive type " + FieldType.toString());
             } else {
                 System.out.println("**Field " + fields[i].getName() +
                                    " is an Object of type " + FieldType.toString());
                 try {
                     writeObject(fields[i].get(obj));
                     if (FieldType.isArray()) {
                         Object[] array = ((Object[]) fields[i].get(obj));
-                        Class componentType = FieldType.getComponentType();
+                        Class<?> componentType = FieldType.getComponentType();
                         if (componentType.isPrimitive())
                             System.out.println("Output " + array.length + " primitive elements of" +
                                                componentType.toString());
                         else {
                             System.out.println("Output " + array.length + " of Object elements of" +
@@ -225,10 +225,11 @@
         }
 
         /**
          * Write the data and fields to the specified ObjectOutput stream.
          */
+        @SuppressWarnings("deprecation")
         public void write(ObjectOutput out) throws IOException {
             for (int i = 0; i < next; i++)
                 System.out.println(fieldName[i] + "=" + intValue[i]);
         }
     };
@@ -298,19 +299,19 @@
      *
      * Look for the writeObject method
      * Set the accessible flag on it here.
      * Subclass of AbstractObjectOutputStream will call it as necessary.
      */
-    public static Method getWriteObjectMethod(final Class cl) {
+    public static Method getWriteObjectMethod(final Class<?> cl) {
 
-        Method writeObjectMethod = (Method)
+        Method writeObjectMethod =
             java.security.AccessController.doPrivileged
-            (new java.security.PrivilegedAction() {
-                public Object run() {
+            (new java.security.PrivilegedAction<Method>() {
+                public Method run() {
                     Method m = null;
                     try {
-                        Class[] args = {ObjectOutputStream.class};
+                        Class<?>[] args = {ObjectOutputStream.class};
                         m = cl.getDeclaredMethod("writeObject", args);
                         int mods = m.getModifiers();
                         // Method must be private and non-static
                         if (!Modifier.isPrivate(mods) ||
                             Modifier.isStatic(mods)) {
@@ -334,12 +335,12 @@
                                         final Object[] argList)
         throws IOException
     {
         try {
             java.security.AccessController.doPrivileged
-                (new java.security.PrivilegedExceptionAction() {
-                    public Object run() throws InvocationTargetException,
+                (new java.security.PrivilegedExceptionAction<Void>() {
+                    public Void run() throws InvocationTargetException,
                                         java.lang.IllegalAccessException {
                         m.invoke(obj, argList);
                         return null;
                     }
                 });

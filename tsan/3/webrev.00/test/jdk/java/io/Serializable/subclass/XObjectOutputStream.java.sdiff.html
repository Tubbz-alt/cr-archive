<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/io/Serializable/subclass/XObjectOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="XObjectInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../superclassDataLoss/A.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/io/Serializable/subclass/XObjectOutputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2004, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 99         }
100     }
101 
102     /* Since defaultWriteObject() does not take the object to write as a parameter,
103      * implementation is required to store currentObject when writeObject is called.
104      */
105     public void defaultWriteObject() throws IOException {
106         Object obj = currentObject;
107         System.out.println(&quot;XObjectOutputStream.defaultWriteObject(&quot; +
108                             obj.toString() + &quot;)&quot;);
109 
110         //In order to access package, private and protected fields,
111         //one needs to use Priviledged Access and be trusted code.
112         //This test will avoid that problem by only serializing public fields.
113         Field[] fields = obj.getClass().getFields();
114         for (int i= 0; i &lt; fields.length; i++) {
115             //Skip non-Serializable fields.
116             int mods = fields[i].getModifiers();
117             if (Modifier.isStatic(mods) || Modifier.isTransient(mods))
118                 continue;
<span class="line-modified">119             Class FieldType = fields[i].getType();</span>
120             if (FieldType.isPrimitive()) {
121                 System.out.println(&quot;Field &quot; + fields[i].getName() +
122                                     &quot; has primitive type &quot; + FieldType.toString());
123             } else {
124                 System.out.println(&quot;**Field &quot; + fields[i].getName() +
125                                    &quot; is an Object of type &quot; + FieldType.toString());
126                 try {
127                     writeObject(fields[i].get(obj));
128                     if (FieldType.isArray()) {
129                         Object[] array = ((Object[]) fields[i].get(obj));
<span class="line-modified">130                         Class componentType = FieldType.getComponentType();</span>
131                         if (componentType.isPrimitive())
132                             System.out.println(&quot;Output &quot; + array.length + &quot; primitive elements of&quot; +
133                                                componentType.toString());
134                         else {
135                             System.out.println(&quot;Output &quot; + array.length + &quot; of Object elements of&quot; +
136                                                componentType.toString());
137                             for (int k = 0; k &lt; array.length; k++) {
138                                 writeObject(array[k]);
139                             }
140                         }
141                     }
142                 } catch (IllegalAccessException e) {
143                     throw new IOException(e.getMessage());
144                 }
145             }
146         }
147     }
148 
149     public PutField putFields() throws IOException {
150         currentPutField = new InternalPutField();
</pre>
<hr />
<pre>
210          * Put the value of the named float field into the persistent fields.
211          */
212         public void put(String name, float value) {
213         }
214 
215         /**
216          * Put the value of the named double field into the persistent field.
217          */
218         public void put(String name, double value) {
219         }
220 
221         /**
222          * Put the value of the named Object field into the persistent field.
223          */
224         public void put(String name, Object value) {
225         }
226 
227         /**
228          * Write the data and fields to the specified ObjectOutput stream.
229          */

230         public void write(ObjectOutput out) throws IOException {
231             for (int i = 0; i &lt; next; i++)
232                 System.out.println(fieldName[i] + &quot;=&quot; + intValue[i]);
233         }
234     };
235 
236 
237     /**
238      * Writes a byte. This method will block until the byte is actually
239      * written.
240      * @param b the byte
241      * @exception IOException If an I/O error has occurred.
242      * @since     JDK1.1
243      */
244     public void write(int data) throws IOException {
245     }
246 
247     /**
248      * Writes an array of bytes. This method will block until the bytes
249      * are actually written.
</pre>
<hr />
<pre>
283     public void writeBytes(String data) throws IOException{}
284     public void writeChars(String data) throws IOException{}
285     public void writeUTF(String data) throws IOException{}
286     public void reset() throws IOException {}
287     public void available() throws IOException {}
288     public void drain() throws IOException {}
289 
290     private Object currentObject = null;
291     private InternalPutField currentPutField;
292 
293 
294     /********************************************************************/
295 
296     /* CODE LIFTED FROM ObjectStreamClass constuctor.
297      * ObjectStreamClass.writeObjectMethod is private.
298      *
299      * Look for the writeObject method
300      * Set the accessible flag on it here.
301      * Subclass of AbstractObjectOutputStream will call it as necessary.
302      */
<span class="line-modified">303     public static Method getWriteObjectMethod(final Class cl) {</span>
304 
<span class="line-modified">305         Method writeObjectMethod = (Method)</span>
306             java.security.AccessController.doPrivileged
<span class="line-modified">307             (new java.security.PrivilegedAction() {</span>
<span class="line-modified">308                 public Object run() {</span>
309                     Method m = null;
310                     try {
<span class="line-modified">311                         Class[] args = {ObjectOutputStream.class};</span>
312                         m = cl.getDeclaredMethod(&quot;writeObject&quot;, args);
313                         int mods = m.getModifiers();
314                         // Method must be private and non-static
315                         if (!Modifier.isPrivate(mods) ||
316                             Modifier.isStatic(mods)) {
317                             m = null;
318                         } else {
319                             m.setAccessible(true);
320                         }
321                     } catch (NoSuchMethodException e) {
322                         m = null;
323                     }
324                     return m;
325                 }
326             });
327         return writeObjectMethod;
328     }
329 
330     /*************************************************************/
331 
332     /* CODE LIFTED FROM ObjectOutputStream. */
333     private static void invokeMethod(final Object obj, final Method m,
334                                         final Object[] argList)
335         throws IOException
336     {
337         try {
338             java.security.AccessController.doPrivileged
<span class="line-modified">339                 (new java.security.PrivilegedExceptionAction() {</span>
<span class="line-modified">340                     public Object run() throws InvocationTargetException,</span>
341                                         java.lang.IllegalAccessException {
342                         m.invoke(obj, argList);
343                         return null;
344                     }
345                 });
346         } catch (java.security.PrivilegedActionException e) {
347             Exception ex = e.getException();
348             if (ex instanceof InvocationTargetException) {
349                 Throwable t =
350                         ((InvocationTargetException)ex).getTargetException();
351                 if (t instanceof IOException)
352                     throw (IOException)t;
353                 else if (t instanceof RuntimeException)
354                     throw (RuntimeException) t;
355                 else if (t instanceof Error)
356                     throw (Error) t;
357                 else
358                     throw new Error(&quot;interal error&quot;);
359             } else {
360                 // IllegalAccessException cannot happen
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 99         }
100     }
101 
102     /* Since defaultWriteObject() does not take the object to write as a parameter,
103      * implementation is required to store currentObject when writeObject is called.
104      */
105     public void defaultWriteObject() throws IOException {
106         Object obj = currentObject;
107         System.out.println(&quot;XObjectOutputStream.defaultWriteObject(&quot; +
108                             obj.toString() + &quot;)&quot;);
109 
110         //In order to access package, private and protected fields,
111         //one needs to use Priviledged Access and be trusted code.
112         //This test will avoid that problem by only serializing public fields.
113         Field[] fields = obj.getClass().getFields();
114         for (int i= 0; i &lt; fields.length; i++) {
115             //Skip non-Serializable fields.
116             int mods = fields[i].getModifiers();
117             if (Modifier.isStatic(mods) || Modifier.isTransient(mods))
118                 continue;
<span class="line-modified">119             Class&lt;?&gt; FieldType = fields[i].getType();</span>
120             if (FieldType.isPrimitive()) {
121                 System.out.println(&quot;Field &quot; + fields[i].getName() +
122                                     &quot; has primitive type &quot; + FieldType.toString());
123             } else {
124                 System.out.println(&quot;**Field &quot; + fields[i].getName() +
125                                    &quot; is an Object of type &quot; + FieldType.toString());
126                 try {
127                     writeObject(fields[i].get(obj));
128                     if (FieldType.isArray()) {
129                         Object[] array = ((Object[]) fields[i].get(obj));
<span class="line-modified">130                         Class&lt;?&gt; componentType = FieldType.getComponentType();</span>
131                         if (componentType.isPrimitive())
132                             System.out.println(&quot;Output &quot; + array.length + &quot; primitive elements of&quot; +
133                                                componentType.toString());
134                         else {
135                             System.out.println(&quot;Output &quot; + array.length + &quot; of Object elements of&quot; +
136                                                componentType.toString());
137                             for (int k = 0; k &lt; array.length; k++) {
138                                 writeObject(array[k]);
139                             }
140                         }
141                     }
142                 } catch (IllegalAccessException e) {
143                     throw new IOException(e.getMessage());
144                 }
145             }
146         }
147     }
148 
149     public PutField putFields() throws IOException {
150         currentPutField = new InternalPutField();
</pre>
<hr />
<pre>
210          * Put the value of the named float field into the persistent fields.
211          */
212         public void put(String name, float value) {
213         }
214 
215         /**
216          * Put the value of the named double field into the persistent field.
217          */
218         public void put(String name, double value) {
219         }
220 
221         /**
222          * Put the value of the named Object field into the persistent field.
223          */
224         public void put(String name, Object value) {
225         }
226 
227         /**
228          * Write the data and fields to the specified ObjectOutput stream.
229          */
<span class="line-added">230         @SuppressWarnings(&quot;deprecation&quot;)</span>
231         public void write(ObjectOutput out) throws IOException {
232             for (int i = 0; i &lt; next; i++)
233                 System.out.println(fieldName[i] + &quot;=&quot; + intValue[i]);
234         }
235     };
236 
237 
238     /**
239      * Writes a byte. This method will block until the byte is actually
240      * written.
241      * @param b the byte
242      * @exception IOException If an I/O error has occurred.
243      * @since     JDK1.1
244      */
245     public void write(int data) throws IOException {
246     }
247 
248     /**
249      * Writes an array of bytes. This method will block until the bytes
250      * are actually written.
</pre>
<hr />
<pre>
284     public void writeBytes(String data) throws IOException{}
285     public void writeChars(String data) throws IOException{}
286     public void writeUTF(String data) throws IOException{}
287     public void reset() throws IOException {}
288     public void available() throws IOException {}
289     public void drain() throws IOException {}
290 
291     private Object currentObject = null;
292     private InternalPutField currentPutField;
293 
294 
295     /********************************************************************/
296 
297     /* CODE LIFTED FROM ObjectStreamClass constuctor.
298      * ObjectStreamClass.writeObjectMethod is private.
299      *
300      * Look for the writeObject method
301      * Set the accessible flag on it here.
302      * Subclass of AbstractObjectOutputStream will call it as necessary.
303      */
<span class="line-modified">304     public static Method getWriteObjectMethod(final Class&lt;?&gt; cl) {</span>
305 
<span class="line-modified">306         Method writeObjectMethod =</span>
307             java.security.AccessController.doPrivileged
<span class="line-modified">308             (new java.security.PrivilegedAction&lt;Method&gt;() {</span>
<span class="line-modified">309                 public Method run() {</span>
310                     Method m = null;
311                     try {
<span class="line-modified">312                         Class&lt;?&gt;[] args = {ObjectOutputStream.class};</span>
313                         m = cl.getDeclaredMethod(&quot;writeObject&quot;, args);
314                         int mods = m.getModifiers();
315                         // Method must be private and non-static
316                         if (!Modifier.isPrivate(mods) ||
317                             Modifier.isStatic(mods)) {
318                             m = null;
319                         } else {
320                             m.setAccessible(true);
321                         }
322                     } catch (NoSuchMethodException e) {
323                         m = null;
324                     }
325                     return m;
326                 }
327             });
328         return writeObjectMethod;
329     }
330 
331     /*************************************************************/
332 
333     /* CODE LIFTED FROM ObjectOutputStream. */
334     private static void invokeMethod(final Object obj, final Method m,
335                                         final Object[] argList)
336         throws IOException
337     {
338         try {
339             java.security.AccessController.doPrivileged
<span class="line-modified">340                 (new java.security.PrivilegedExceptionAction&lt;Void&gt;() {</span>
<span class="line-modified">341                     public Void run() throws InvocationTargetException,</span>
342                                         java.lang.IllegalAccessException {
343                         m.invoke(obj, argList);
344                         return null;
345                     }
346                 });
347         } catch (java.security.PrivilegedActionException e) {
348             Exception ex = e.getException();
349             if (ex instanceof InvocationTargetException) {
350                 Throwable t =
351                         ((InvocationTargetException)ex).getTargetException();
352                 if (t instanceof IOException)
353                     throw (IOException)t;
354                 else if (t instanceof RuntimeException)
355                     throw (RuntimeException) t;
356                 else if (t instanceof Error)
357                     throw (Error) t;
358                 else
359                     throw new Error(&quot;interal error&quot;);
360             } else {
361                 // IllegalAccessException cannot happen
</pre>
</td>
</tr>
</table>
<center><a href="XObjectInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../superclassDataLoss/A.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/nio/MappedByteBuffer/PmemTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * This test is manually run because it requires an NVRAM device to be
 26  * mapped as DAX file system or, at least, to be simulated by a
 27  * volatile RAM mapped file system. Also, on AArch64 it requires an
 28  * ARMV8.2 CPU which implements the dc CVAP instruction (CPU feature
 29  * dcpop) and an OS that makes it available from user space.
 30  *
 31  * If the test runs on such a host without throwing an exception then
 32  * that confirms that NVRAM-backed byte buffers can be allocated,
 33  * updated and forced via cache line writeback.
 34  */
 35 
 36 /*
 37  * How to run this test:
 38  *
 39  * Ideally this test should be run on a x86_64/amd64 or aarch64 host
 40  * fitted with an NVRAM memory device. The NVRAM should appear as
 41  * /dev/pmem0 or some equivalent DAX file device. The file device
 42  * should be mounted at /mnt/pmem with a directory tmp created
 43  * directly under that mount point with a+rwx access.
 44  *
 45  * It is possible to run the test on x86_64 using a volatile RAM
 46  * backed device to simulate NVRAM, even though this does not provide
 47  * any guarantee of persistence of data across program runs. For the
 48  * latter case the following instructions explain how to set up the
 49  * simulated NVRAM device.
 50  *
 51  * https://developers.redhat.com/blog/2016/12/05/configuring-and-using-persistent-memory-rhel-7-3/
 52  * https://nvdimm.wiki.kernel.org/
 53  * TL;DR: add &quot;memmap=1G!4G&quot; to /etc/default/grub, eg. GRUB_CMDLINE_LINUX=&quot;memmap=1G!4G&quot;
 54  *        then (&quot;sudo&quot; may required)
 55  *          for RHEL(BIOS-based): grub2-mkconfig -o /boot/grub2/grub.cfg
 56  *          for RHEL(UEFI-based): grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg
 57  *          for Ubuntu: update-grub2
 58  *        finally reboot
 59  *        after the host been rebooted, a new /dev/pmem{N} device should exist,
 60  *        naming conversion starts at /dev/pmem0
 61  *
 62  *  Prepare test directory follow below commands, &quot;sudo&quot; may required
 63  *  (if ndctl or mkfs.xfs not exist, install ndctl or xfsprogs package first)
 64  *  (for RHEL8, when call mkfs.xfs, specify the -m reflink=0 option to disable reflink feature)
 65  *
 66  *  ndctl create-namespace -f -e namespace0.0 -m memory -M mem
 67  *  mkdir /mnt/pmem
 68  *  mkfs.xfs -f /dev/pmem0; mount -o dax /dev/pmem0 /mnt/pmem/
 69  *  mkdir /mnt/pmem/test; chmod a+rwx /mnt/pmem/test
 70  *
 71  * Now run the test program
 72  *
 73  *  java PmemTest
 74  *
 75  * or
 76  *
 77  *  make test TEST=jdk/java/nio/MappedByteBuffer/PmemTest.java
 78 */
 79 
 80 /* @test
 81  * @summary Testing NVRAM mapped byte buffer support
 82  * @run main/manual PmemTest
 83  * @requires (os.family == &quot;linux&quot;)
 84  * @requires ((os.arch == &quot;x86_64&quot;)|(os.arch == &quot;amd64&quot;)|(os.arch == &quot;aarch64&quot;)|(os.arch == &quot;ppc64le&quot;))
 85  */
 86 
 87 import java.io.File;
 88 import java.nio.MappedByteBuffer;
 89 import java.nio.channels.FileChannel;
 90 import java.nio.file.Files;
 91 import java.nio.file.Path;
 92 import java.nio.file.StandardOpenOption;
 93 import java.util.EnumSet;
 94 import java.util.List;
 95 import jdk.nio.mapmode.ExtendedMapMode;
 96 
 97 import java.lang.management.ManagementFactory;
 98 import java.lang.management.BufferPoolMXBean;
 99 
100 public class PmemTest {
101 
102     public static final int K = 1024;
103     public static final int NUM_KBS = 16;
104 
105     public static void main(String[] args) throws Exception {
106 
107         System.out.println(&quot;test&quot;);
108 
109         String dir = &quot;/tmp&quot;; // mapSync should fail
110         dir = &quot;/mnt/pmem/test&quot;; // mapSync should work, since fs mount is -o dax
111 
112         Path path = new File(dir, &quot;pmemtest&quot;).toPath();
113 
114         FileChannel fileChannel = (FileChannel) Files
115                 .newByteChannel(path, EnumSet.of(
116                         StandardOpenOption.READ,
117                         StandardOpenOption.WRITE,
118                         StandardOpenOption.CREATE));
119 
120         MappedByteBuffer mappedByteBuffer = fileChannel.map(ExtendedMapMode.READ_WRITE_SYNC, 0, NUM_KBS * K);
121 
122 
123         dumpBufferPoolBeans();
124 
125         // for (int loops = 0; loops &lt; 1000; loops++) {
126         for (int loops = 0; loops &lt; 100; loops++) {
127             int base = K * (loops % NUM_KBS);
128             for (int i = 0; i &lt; K ; i++) {
129                 for (int j = 0; j &lt; K ;j++) {
130                     testBuffer(mappedByteBuffer, base, (i &lt;&lt; 3) + j);
131                     commitBuffer(mappedByteBuffer, base);
132                 }
133             }
134         }
135         dumpBufferPoolBeans();
136     }
137 
138     public static void testBuffer(MappedByteBuffer mappedByteBuffer, int base, int start) {
139         for (int k = 0; k &lt; 8; k++) {
140             int idx = (start + k) % K;
141             byte z = mappedByteBuffer.get(base + idx);
142             z++;
143             mappedByteBuffer.put(base + idx, z);
144         }
145     }
146 
147     public static void commitBuffer(MappedByteBuffer mappedByteBuffer, int base)
148     {
149         mappedByteBuffer.force(base, K);
150     }
151 
152     public static void dumpBufferPoolBeans()
153     {
154         List&lt;BufferPoolMXBean&gt; beansList = ManagementFactory.getPlatformMXBeans(BufferPoolMXBean.class);
155         for (BufferPoolMXBean bean : beansList) {
156             System.out.println(&quot;BufferPoolMXBean {&quot; +
157                                &quot;\n\tname:          &quot; + bean.getName() +
158                                &quot;\n\tcount:         &quot; + bean.getCount() +
159                                &quot;\n\ttotalCapacity: &quot; + bean.getTotalCapacity() +
160                                &quot;\n\tmemoryUsed:    &quot; + bean.getMemoryUsed() +
161                                &quot;\n}&quot;);
162         }
163     }
164 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/nio/file/etc/MacVolumesTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 8231254
 26  * @requires os.family == &quot;mac&quot;
 27  * @summary Check access and basic NIO APIs on APFS for macOS version &gt;= 10.15
 28  */
 29 import java.io.BufferedReader;
 30 import java.io.FileInputStream;
 31 import java.io.InputStream;
 32 import java.io.InputStreamReader;
 33 import java.io.IOException;
 34 import java.io.Reader;
 35 import java.nio.ByteBuffer;
 36 import java.nio.channels.SeekableByteChannel;
 37 import java.nio.file.DirectoryStream;
 38 import java.nio.file.Files;
 39 import java.nio.file.Path;
 40 import java.nio.file.StandardOpenOption;
 41 import java.nio.file.attribute.FileTime;
 42 import java.util.Arrays;
 43 import java.util.Iterator;
 44 import java.util.Random;
 45 
 46 public class MacVolumesTest {
 47     private static final String SYSTEM_VOLUME = &quot;/&quot;;
 48     private static final String DATA_VOLUME = &quot;/System/Volumes/Data&quot;;
 49     private static final String FIRMLINKS = &quot;/usr/share/firmlinks&quot;;
 50 
 51     private static final void checkSystemVolume() throws IOException {
 52         System.out.format(&quot;--- Checking system volume %s ---%n&quot;, SYSTEM_VOLUME);
 53         Path root = Path.of(SYSTEM_VOLUME);
 54         if (!Files.getFileStore(root).isReadOnly()) {
 55             throw new RuntimeException(&quot;Root volume is not read-only&quot;);
 56         }
 57 
 58         Path tempDir;
 59         try {
 60             tempDir = Files.createTempDirectory(root, &quot;tempDir&quot;);
 61             throw new RuntimeException(&quot;Created temporary directory in root&quot;);
 62         } catch (IOException ignore) {
 63         }
 64 
 65         Path tempFile;
 66         try {
 67             tempFile = Files.createTempFile(root, &quot;tempFile&quot;, null);
 68             throw new RuntimeException(&quot;Created temporary file in root&quot;);
 69         } catch (IOException ignore) {
 70         }
 71 
 72         Path path = null;
 73         Path etc = Path.of(SYSTEM_VOLUME, &quot;etc&quot;);
 74         if (Files.isWritable(etc)) {
 75             throw new RuntimeException(&quot;System path &quot; + etc + &quot; is writable&quot;);
 76         }
 77         try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(etc)) {
 78             Iterator&lt;Path&gt; paths = ds.iterator();
 79             while (paths.hasNext()) {
 80                 Path p = paths.next();
 81                 if (Files.isReadable(p) &amp;&amp; Files.isRegularFile(p)) {
 82                     path = p;
 83                     break;
 84                 }
 85             }
 86         }
 87         if (path == null) {
 88             System.err.println(&quot;No root test file found: skipping file test&quot;);
 89             return;
 90         }
 91         System.out.format(&quot;Using root test file %s%n&quot;, path);
 92 
 93         if (Files.isWritable(path)) {
 94             throw new RuntimeException(&quot;Test file &quot; + path + &quot; is writable&quot;);
 95         }
 96 
 97         FileTime creationTime =
 98             (FileTime)Files.getAttribute(path, &quot;basic:creationTime&quot;);
 99         System.out.format(&quot;%s creation time: %s%n&quot;, path, creationTime);
100 
101         long size = Files.size(path);
102         int capacity = (int)Math.min(1024, size);
103         ByteBuffer buf = ByteBuffer.allocate(capacity);
104         try (SeekableByteChannel sbc = Files.newByteChannel(path)) {
105             int n = sbc.read(buf);
106             System.out.format(&quot;Read %d bytes from %s%n&quot;, n, path);
107         }
108     }
109 
110     private static final void checkDataVolume() throws IOException {
111         System.out.format(&quot;--- Checking data volume %s ---%n&quot;, DATA_VOLUME);
112         Path data = Path.of(DATA_VOLUME, &quot;private&quot;, &quot;tmp&quot;);
113         if (Files.getFileStore(data).isReadOnly()) {
114             throw new RuntimeException(&quot;Data volume is read-only&quot;);
115         }
116 
117         Path tempDir = Files.createTempDirectory(data, &quot;tempDir&quot;);
118         tempDir.toFile().deleteOnExit();
119         System.out.format(&quot;Temporary directory: %s%n&quot;, tempDir);
120         if (!Files.isWritable(tempDir)) {
121             throw new RuntimeException(&quot;Temporary directory is not writable&quot;);
122         }
123 
124         Path tempFile = Files.createTempFile(tempDir, &quot;tempFile&quot;, null);
125         tempFile.toFile().deleteOnExit();
126         System.out.format(&quot;Temporary file: %s%n&quot;, tempFile);
127         if (!Files.isWritable(tempFile)) {
128             throw new RuntimeException(&quot;Temporary file is not writable&quot;);
129         }
130 
131         byte[] bytes = new byte[42];
132         new Random().nextBytes(bytes);
133         try (SeekableByteChannel sbc = Files.newByteChannel(tempFile,
134             StandardOpenOption.WRITE)) {
135             ByteBuffer src = ByteBuffer.wrap(bytes);
136             if (sbc.write(src) != bytes.length) {
137                 throw new RuntimeException(&quot;Incorrect number of bytes written&quot;);
138             }
139         }
140 
141         try (SeekableByteChannel sbc = Files.newByteChannel(tempFile)) {
142             ByteBuffer dst = ByteBuffer.allocate(bytes.length);
143             if (sbc.read(dst) != bytes.length) {
144                 throw new RuntimeException(&quot;Incorrect number of bytes read&quot;);
145             }
146             if (!Arrays.equals(dst.array(), bytes)) {
147                 throw new RuntimeException(&quot;Bytes read != bytes written&quot;);
148             }
149         }
150     }
151 
152     static void checkFirmlinks() throws IOException {
153         System.out.format(&quot;--- Checking firmlinks %s ---%n&quot;, FIRMLINKS);
154         Path firmlinks = Path.of(FIRMLINKS);
155         if (!Files.exists(firmlinks)) {
156             System.err.format(&quot;%s does not exist: skipping firmlinks test%n&quot;,
157                 firmlinks);
158             return;
159         } else if (!Files.isReadable(firmlinks)) {
160             throw new RuntimeException(String.format(&quot;%s is not readable&quot;,
161                 firmlinks));
162         }
163 
164         try (BufferedReader br = Files.newBufferedReader(firmlinks)) {
165             String line;
166             while ((line = br.readLine()) != null) {
167                 String file = line.split(&quot;\\s&quot;)[0];
168                 Path path = Path.of(file);
169                 if (!Files.exists(path)) {
170                     System.err.format(&quot;Firmlink %s does not exist: skipping%n&quot;,
171                         file);
172                     continue;
173                 }
174                 if (Files.getFileStore(path).isReadOnly()) {
175                     String msg = String.format(&quot;%s is read-only%n&quot;, file);
176                     throw new RuntimeException(msg);
177                 } else {
178                     System.out.format(&quot;Firmlink %s OK%n&quot;, file);
179                 }
180             }
181         }
182     }
183 
184     public static void main(String[] args) throws Exception {
185         String[] osv = System.getProperty(&quot;os.version&quot;).split(&quot;\\.&quot;);
186         int major = Integer.valueOf(osv[0]);
187         int minor = Integer.valueOf(osv[1]);
188         if (major &lt; 10 || (major == 10 &amp;&amp; minor &lt; 15)) {
189             System.out.format(&quot;macOS version %d.%d too old: skipping test%n&quot;,
190                 major, minor);
191             return;
192         }
193 
194         // Check system volume for read-only.
195         checkSystemVolume();
196 
197         // Check data volume for read-write.
198         checkDataVolume();
199 
200         // Check firmlinks for read-write.
201         checkFirmlinks();
202     }
203 }
    </pre>
  </body>
</html>
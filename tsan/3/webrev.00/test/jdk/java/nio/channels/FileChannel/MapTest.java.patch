diff a/test/jdk/java/nio/channels/FileChannel/MapTest.java b/test/jdk/java/nio/channels/FileChannel/MapTest.java
--- a/test/jdk/java/nio/channels/FileChannel/MapTest.java
+++ b/test/jdk/java/nio/channels/FileChannel/MapTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,11 +22,11 @@
  */
 
 /* @test
  * @bug 4429043 8002180
  * @summary Test file mapping with FileChannel
- * @run main/othervm MapTest
+ * @run main/othervm/timeout=240 MapTest
  * @key randomness
  */
 
 import java.io.*;
 import java.nio.MappedByteBuffer;
@@ -65,10 +65,12 @@
             out.println("Read: OK");
             testWrite();
             out.println("Write: OK");
             testHighOffset();
             out.println("High offset: OK");
+            testForce();
+            out.println("Force: OK");
             testExceptions();
             out.println("Exceptions: OK");
         } finally {
             blah.delete();
         }
@@ -186,10 +188,57 @@
                                             offset, 100);
             }
         }
     }
 
+    /**
+     * Maps blah file, writes some data and forcing writeback of
+     * the data exercising various valid and invalid writeback ranges.
+     */
+    private static void testForce() throws Exception {
+        for (int x=0; x<50; x++) {
+            try (RandomAccessFile raf = new RandomAccessFile(blah, "rw")) {
+                FileChannel fc = raf.getChannel();
+                final int BLOCK_SIZE = 64;
+                final int BLOCK_COUNT = (4096 * 2)/ BLOCK_SIZE;
+                int offset = 0;
+                MappedByteBuffer b = fc.map(MapMode.READ_WRITE,
+                                            0, BLOCK_SIZE * (BLOCK_COUNT + 1));
+
+                for (int blocks = 0; blocks < BLOCK_COUNT; blocks++) {
+                    for (int i = 0; i < BLOCK_SIZE; i++) {
+                        b.put(offset + i, (byte)('0' + i));
+                    }
+                    b.force(offset, BLOCK_SIZE);
+                    offset += BLOCK_SIZE;
+                }
+
+                Exception exc = null;
+                try {
+                    // start and end are out of range
+                    b.force(offset + BLOCK_SIZE, BLOCK_SIZE);
+                } catch (IndexOutOfBoundsException e) {
+                    exc = e;
+                }
+                if (exc == null) {
+                    throw new RuntimeException("expected Exception for force beyond buffer extent");
+                }
+
+                exc = null;
+                try {
+                    // start is in range but end is out of range
+                    b.force(offset, 2 * BLOCK_SIZE);
+                } catch (IndexOutOfBoundsException e) {
+                    exc = e;
+                }
+                if (exc == null) {
+                    throw new RuntimeException("expected Exception for force beyond write limit");
+                }
+            }
+        }
+    }
+
     /**
      * Test exceptions specified by map method
      */
     private static void testExceptions() throws Exception {
         // check exceptions when channel opened for read access

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/nio/channels/AsynchronousSocketChannel/Basic.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 4607272 6842687 6878369 6944810 7023403
 26  * @summary Unit test for AsynchronousSocketChannel(use -Dseed=X to set PRNG seed)
 27  * @library /test/lib
 28  * @modules jdk.net
 29  * @key randomness intermittent
 30  * @build jdk.test.lib.RandomFactory jdk.test.lib.Utils
 31  * @run main/othervm/timeout=600 Basic -skipSlowConnectTest
 32  */
 33 
 34 import java.io.Closeable;
 35 import java.io.IOException;
 36 import java.net.*;
 37 import static java.net.StandardSocketOptions.*;
 38 import java.nio.ByteBuffer;
 39 import java.nio.channels.*;
 40 import java.util.Random;
 41 import java.util.Set;
 42 import java.util.concurrent.*;
 43 import java.util.concurrent.atomic.*;
 44 import jdk.test.lib.RandomFactory;
 45 import java.util.List;
 46 import static jdk.net.ExtendedSocketOptions.TCP_KEEPCOUNT;
 47 import static jdk.net.ExtendedSocketOptions.TCP_KEEPIDLE;
 48 import static jdk.net.ExtendedSocketOptions.TCP_KEEPINTERVAL;
 49 
 50 public class Basic {
 51     private static final Random RAND = RandomFactory.getRandom();
 52 
 53     static boolean skipSlowConnectTest = false;
 54 
 55     public static void main(String[] args) throws Exception {
 56         for (String arg: args) {
 57             switch (arg) {
 58             case &quot;-skipSlowConnectTest&quot; :
 59                 skipSlowConnectTest = true;
 60                 break;
 61             default:
 62                 throw new RuntimeException(&quot;Unrecognized argument: &quot; + arg);
 63             }
 64         }
 65 
 66         testBind();
 67         testSocketOptions();
 68         testConnect();
 69         testCloseWhenPending();
 70         testCancel();
 71         testRead1();
 72         testRead2();
 73         testRead3();
 74         testWrite1();
 75         testWrite2();
 76         // skip timeout tests until 7052549 is fixed
 77         if (!System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;))
 78             testTimeout();
 79         testShutdown();
 80     }
 81 
 82     static class Server implements Closeable {
 83         private final ServerSocketChannel ssc;
 84         private final InetSocketAddress address;
 85 
 86         Server() throws IOException {
 87             this(0);
 88         }
 89 
 90         Server(int recvBufSize) throws IOException {
 91             ssc = ServerSocketChannel.open();
 92             if (recvBufSize &gt; 0) {
 93                 ssc.setOption(SO_RCVBUF, recvBufSize);
 94             }
 95             ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
 96             address = (InetSocketAddress)ssc.getLocalAddress();
 97         }
 98 
 99         InetSocketAddress address() {
100             return address;
101         }
102 
103         SocketChannel accept() throws IOException {
104             return ssc.accept();
105         }
106 
107         public void close() throws IOException {
108             ssc.close();
109         }
110 
111     }
112 
113     static void testBind() throws Exception {
114         System.out.println(&quot;-- bind --&quot;);
115 
116         try (AsynchronousSocketChannel ch = AsynchronousSocketChannel.open()) {
117             if (ch.getLocalAddress() != null)
118                 throw new RuntimeException(&quot;Local address should be &#39;null&#39;&quot;);
119             ch.bind(new InetSocketAddress(0));
120 
121             // check local address after binding
122             InetSocketAddress local = (InetSocketAddress)ch.getLocalAddress();
123             if (local.getPort() == 0)
124                 throw new RuntimeException(&quot;Unexpected port&quot;);
125             if (!local.getAddress().isAnyLocalAddress())
126                 throw new RuntimeException(&quot;Not bound to a wildcard address&quot;);
127 
128             // try to re-bind
129             try {
130                 ch.bind(new InetSocketAddress(0));
131                 throw new RuntimeException(&quot;AlreadyBoundException expected&quot;);
132             } catch (AlreadyBoundException x) {
133             }
134         }
135 
136         // check ClosedChannelException
137         AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
138         ch.close();
139         try {
140             ch.bind(new InetSocketAddress(0));
141             throw new RuntimeException(&quot;ClosedChannelException  expected&quot;);
142         } catch (ClosedChannelException  x) {
143         }
144     }
145 
146     static void testSocketOptions() throws Exception {
147         System.out.println(&quot;-- socket options --&quot;);
148 
149         try (AsynchronousSocketChannel ch = AsynchronousSocketChannel.open()) {
150             ch.setOption(SO_RCVBUF, 128*1024)
151               .setOption(SO_SNDBUF, 128*1024)
152               .setOption(SO_REUSEADDR, true);
153 
154             // check SO_SNDBUF/SO_RCVBUF limits
155             int before, after;
156             before = ch.getOption(SO_SNDBUF);
157             after = ch.setOption(SO_SNDBUF, Integer.MAX_VALUE).getOption(SO_SNDBUF);
158             if (after &lt; before)
159                 throw new RuntimeException(&quot;setOption caused SO_SNDBUF to decrease&quot;);
160             before = ch.getOption(SO_RCVBUF);
161             after = ch.setOption(SO_RCVBUF, Integer.MAX_VALUE).getOption(SO_RCVBUF);
162             if (after &lt; before)
163                 throw new RuntimeException(&quot;setOption caused SO_RCVBUF to decrease&quot;);
164 
165             ch.bind(new InetSocketAddress(0));
166 
167             // default values
168             if (ch.getOption(SO_KEEPALIVE))
169                 throw new RuntimeException(&quot;Default of SO_KEEPALIVE should be &#39;false&#39;&quot;);
170             if (ch.getOption(TCP_NODELAY))
171                 throw new RuntimeException(&quot;Default of TCP_NODELAY should be &#39;false&#39;&quot;);
172 
173             // set and check
174             if (!ch.setOption(SO_KEEPALIVE, true).getOption(SO_KEEPALIVE))
175                 throw new RuntimeException(&quot;SO_KEEPALIVE did not change&quot;);
176             if (!ch.setOption(TCP_NODELAY, true).getOption(TCP_NODELAY))
177                 throw new RuntimeException(&quot;SO_KEEPALIVE did not change&quot;);
178 
179             // read others (can&#39;t check as actual value is implementation dependent)
180             ch.getOption(SO_RCVBUF);
181             ch.getOption(SO_SNDBUF);
182 
183             Set&lt;SocketOption&lt;?&gt;&gt; options = ch.supportedOptions();
184             boolean reuseport = options.contains(SO_REUSEPORT);
185             if (reuseport) {
186                 if (ch.getOption(SO_REUSEPORT))
187                     throw new RuntimeException(&quot;Default of SO_REUSEPORT should be &#39;false&#39;&quot;);
188                 if (!ch.setOption(SO_REUSEPORT, true).getOption(SO_REUSEPORT))
189                     throw new RuntimeException(&quot;SO_REUSEPORT did not change&quot;);
190             }
191             List&lt;? extends SocketOption&gt; extOptions = List.of(TCP_KEEPCOUNT,
192                     TCP_KEEPIDLE, TCP_KEEPINTERVAL);
193             if (options.containsAll(extOptions)) {
194                 ch.setOption(TCP_KEEPIDLE, 1234);
195                 checkOption(ch, TCP_KEEPIDLE, 1234);
196                 ch.setOption(TCP_KEEPINTERVAL, 123);
197                 checkOption(ch, TCP_KEEPINTERVAL, 123);
198                 ch.setOption(TCP_KEEPCOUNT, 7);
199                 checkOption(ch, TCP_KEEPCOUNT, 7);
200             }
201         }
202     }
203 
204     static void checkOption(AsynchronousSocketChannel sc, SocketOption name, Object expectedValue)
205             throws IOException {
206         Object value = sc.getOption(name);
207         if (!value.equals(expectedValue)) {
208             throw new RuntimeException(&quot;value not as expected&quot;);
209         }
210     }
211     static void testConnect() throws Exception {
212         System.out.println(&quot;-- connect --&quot;);
213 
214         SocketAddress address;
215 
216         try (Server server = new Server()) {
217             address = server.address();
218 
219             // connect to server and check local/remote addresses
220             try (AsynchronousSocketChannel ch = AsynchronousSocketChannel.open()) {
221                 ch.connect(address).get();
222                 // check local address
223                 if (ch.getLocalAddress() == null)
224                     throw new RuntimeException(&quot;Not bound to local address&quot;);
225 
226                 // check remote address
227                 InetSocketAddress remote = (InetSocketAddress)ch.getRemoteAddress();
228                 if (remote.getPort() != server.address().getPort())
229                     throw new RuntimeException(&quot;Connected to unexpected port&quot;);
230                 if (!remote.getAddress().equals(server.address().getAddress()))
231                     throw new RuntimeException(&quot;Connected to unexpected address&quot;);
232 
233                 // try to connect again
234                 try {
235                     ch.connect(server.address()).get();
236                     throw new RuntimeException(&quot;AlreadyConnectedException expected&quot;);
237                 } catch (AlreadyConnectedException x) {
238                 }
239 
240                 // clean-up
241                 server.accept().close();
242             }
243 
244             // check that connect fails with ClosedChannelException
245             AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
246             ch.close();
247             try {
248                 ch.connect(server.address()).get();
249                 throw new RuntimeException(&quot;ExecutionException expected&quot;);
250             } catch (ExecutionException x) {
251                 if (!(x.getCause() instanceof ClosedChannelException))
252                     throw new RuntimeException(&quot;Cause of ClosedChannelException expected&quot;,
253                             x.getCause());
254             }
255             final AtomicReference&lt;Throwable&gt; connectException = new AtomicReference&lt;&gt;();
256             ch.connect(server.address(), (Void)null, new CompletionHandler&lt;Void,Void&gt;() {
257                 public void completed(Void result, Void att) {
258                 }
259                 public void failed(Throwable exc, Void att) {
260                     connectException.set(exc);
261                 }
262             });
263             while (connectException.get() == null) {
264                 Thread.sleep(100);
265             }
266             if (!(connectException.get() instanceof ClosedChannelException))
267                 throw new RuntimeException(&quot;ClosedChannelException expected&quot;,
268                         connectException.get());
269         }
270 
271         // test that failure to connect closes the channel
272         try (AsynchronousSocketChannel ch = AsynchronousSocketChannel.open()) {
273             try {
274                 ch.connect(address).get();
275             } catch (ExecutionException x) {
276                 // failed to establish connection
277                 if (ch.isOpen())
278                     throw new RuntimeException(&quot;Channel should be closed&quot;);
279             }
280         }
281 
282         // repeat test by connecting to a (probably) non-existent host. This
283         // improves the chance that the connect will not fail immediately.
284         if (!skipSlowConnectTest) {
285             try (AsynchronousSocketChannel ch = AsynchronousSocketChannel.open()) {
286                 try {
287                     ch.connect(genSocketAddress()).get();
288                 } catch (ExecutionException x) {
289                     // failed to establish connection
290                     if (ch.isOpen())
291                         throw new RuntimeException(&quot;Channel should be closed&quot;);
292                 }
293             }
294         }
295     }
296 
297     static void testCloseWhenPending() throws Exception {
298         System.out.println(&quot;-- asynchronous close when connecting --&quot;);
299 
300         AsynchronousSocketChannel ch;
301 
302         // asynchronous close while connecting
303         ch = AsynchronousSocketChannel.open();
304         Future&lt;Void&gt; connectResult = ch.connect(genSocketAddress());
305 
306         // give time to initiate the connect (SYN)
307         Thread.sleep(50);
308 
309         // close
310         ch.close();
311 
312         // check that exception is thrown in timely manner
313         try {
314             connectResult.get(5, TimeUnit.SECONDS);
315         } catch (TimeoutException x) {
316             throw new RuntimeException(&quot;AsynchronousCloseException not thrown&quot;);
317         } catch (ExecutionException x) {
318             // expected
319         }
320 
321         System.out.println(&quot;-- asynchronous close when reading --&quot;);
322 
323         try (Server server = new Server(1)) {
324             ch = AsynchronousSocketChannel.open();
325             ch.connect(server.address()).get();
326 
327             ByteBuffer dst = ByteBuffer.allocateDirect(100);
328             Future&lt;Integer&gt; result = ch.read(dst);
329 
330             // attempt a second read - should fail with ReadPendingException
331             ByteBuffer buf = ByteBuffer.allocateDirect(100);
332             try {
333                 ch.read(buf);
334                 throw new RuntimeException(&quot;ReadPendingException expected&quot;);
335             } catch (ReadPendingException x) {
336             }
337 
338             // close channel (should cause initial read to complete)
339             ch.close();
340             server.accept().close();
341 
342             // check that AsynchronousCloseException is thrown
343             try {
344                 result.get();
345                 throw new RuntimeException(&quot;Should not read&quot;);
346             } catch (ExecutionException x) {
347                 if (!(x.getCause() instanceof AsynchronousCloseException))
348                     throw new RuntimeException(x);
349             }
350 
351             System.out.println(&quot;-- asynchronous close when writing --&quot;);
352 
353             ch = AsynchronousSocketChannel.open();
354             ch.connect(server.address()).get();
355             SocketChannel peer = server.accept();
356             peer.setOption(SO_RCVBUF, 1);
357 
358             final AtomicReference&lt;Throwable&gt; writeException =
359                 new AtomicReference&lt;Throwable&gt;();
360 
361             // write bytes to fill socket buffer
362             final AtomicInteger numCompleted = new AtomicInteger();
363             ch.write(genBuffer(), ch, new CompletionHandler&lt;Integer,AsynchronousSocketChannel&gt;() {
364                 public void completed(Integer result, AsynchronousSocketChannel ch) {
365                     System.out.println(&quot;completed write to async channel: &quot; + result);
366                     numCompleted.incrementAndGet();
367                     ch.write(genBuffer(), ch, this);
368                     System.out.println(&quot;started another write to async channel: &quot; + result);
369                 }
370                 public void failed(Throwable x, AsynchronousSocketChannel ch) {
371                     System.out.println(&quot;failed write to async channel&quot;);
372                     writeException.set(x);
373                 }
374             });
375 
376             // give time for socket buffer to fill up -
377             // take pauses until the handler is no longer being invoked
378             // because all writes are being pended which guarantees that
379             // the internal channel state indicates it is writing
380             int prevNumCompleted = numCompleted.get();
381             do {
382                 Thread.sleep((long)(1000 * jdk.test.lib.Utils.TIMEOUT_FACTOR));
383                 System.out.println(&quot;check if buffer is filled up&quot;);
384                 if (numCompleted.get() == prevNumCompleted) {
385                     break;
386                 }
387                 prevNumCompleted = numCompleted.get();
388             } while (true);
389 
390             // attempt a concurrent write -
391             // should fail with WritePendingException
392             try {
393                 System.out.println(&quot;concurrent write to async channel&quot;);
394                 ch.write(genBuffer());
395                 System.out.format(&quot;prevNumCompleted: %d, numCompleted: %d%n&quot;,
396                                   prevNumCompleted, numCompleted.get());
397                 throw new RuntimeException(&quot;WritePendingException expected&quot;);
398             } catch (WritePendingException x) {
399             }
400 
401             // close channel - should cause initial write to complete
402             System.out.println(&quot;closing async channel...&quot;);
403             ch.close();
404             System.out.println(&quot;closed async channel&quot;);
405             peer.close();
406 
407             // wait for exception
408             while (writeException.get() == null) {
409                 Thread.sleep(100);
410             }
411             if (!(writeException.get() instanceof AsynchronousCloseException))
412                 throw new RuntimeException(&quot;AsynchronousCloseException expected&quot;,
413                         writeException.get());
414         }
415     }
416 
417     static void testCancel() throws Exception {
418         System.out.println(&quot;-- cancel --&quot;);
419 
420         try (Server server = new Server()) {
421             for (int i=0; i&lt;2; i++) {
422                 boolean mayInterruptIfRunning = (i == 0) ? false : true;
423 
424                 // establish loopback connection
425                 AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
426                 ch.connect(server.address()).get();
427                 SocketChannel peer = server.accept();
428 
429                 // start read operation
430                 ByteBuffer buf = ByteBuffer.allocate(1);
431                 Future&lt;Integer&gt; res = ch.read(buf);
432 
433                 // cancel operation
434                 boolean cancelled = res.cancel(mayInterruptIfRunning);
435 
436                 // check post-conditions
437                 if (!res.isDone())
438                     throw new RuntimeException(&quot;isDone should return true&quot;);
439                 if (res.isCancelled() != cancelled)
440                     throw new RuntimeException(&quot;isCancelled not consistent&quot;);
441                 try {
442                     res.get();
443                     throw new RuntimeException(&quot;CancellationException expected&quot;);
444                 } catch (CancellationException x) {
445                 }
446                 try {
447                     res.get(1, TimeUnit.SECONDS);
448                     throw new RuntimeException(&quot;CancellationException expected&quot;);
449                 } catch (CancellationException x) {
450                 }
451 
452                 // check that the cancel doesn&#39;t impact writing to the channel
453                 if (!mayInterruptIfRunning) {
454                     buf = ByteBuffer.wrap(&quot;a&quot;.getBytes());
455                     ch.write(buf).get();
456                 }
457 
458                 ch.close();
459                 peer.close();
460             }
461         }
462     }
463 
464     static void testRead1() throws Exception {
465         System.out.println(&quot;-- read (1) --&quot;);
466 
467         try (Server server = new Server()) {
468             final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
469             ch.connect(server.address()).get();
470 
471             // read with 0 bytes remaining should complete immediately
472             ByteBuffer buf = ByteBuffer.allocate(1);
473             buf.put((byte)0);
474             int n = ch.read(buf).get();
475             if (n != 0)
476                 throw new RuntimeException(&quot;0 expected&quot;);
477 
478             // write bytes and close connection
479             ByteBuffer src = genBuffer();
480             try (SocketChannel sc = server.accept()) {
481                 sc.setOption(SO_SNDBUF, src.remaining());
482                 while (src.hasRemaining())
483                     sc.write(src);
484             }
485 
486             // reads should complete immediately
487             final ByteBuffer dst = ByteBuffer.allocateDirect(src.capacity() + 100);
488             final CountDownLatch latch = new CountDownLatch(1);
489             ch.read(dst, (Void)null, new CompletionHandler&lt;Integer,Void&gt;() {
490                 public void completed(Integer result, Void att) {
491                     int n = result;
492                     if (n &gt; 0) {
493                         ch.read(dst, (Void)null, this);
494                     } else {
495                         latch.countDown();
496                     }
497                 }
498                 public void failed(Throwable exc, Void att) {
499                 }
500             });
501 
502             latch.await();
503 
504             // check buffers
505             src.flip();
506             dst.flip();
507             if (!src.equals(dst)) {
508                 throw new RuntimeException(&quot;Contents differ&quot;);
509             }
510 
511             // close channel
512             ch.close();
513 
514             // check read fails with ClosedChannelException
515             try {
516                 ch.read(dst).get();
517                 throw new RuntimeException(&quot;ExecutionException expected&quot;);
518             } catch (ExecutionException x) {
519                 if (!(x.getCause() instanceof ClosedChannelException))
520                     throw new RuntimeException(&quot;Cause of ClosedChannelException expected&quot;,
521                             x.getCause());
522             }
523         }
524     }
525 
526     static void testRead2() throws Exception {
527         System.out.println(&quot;-- read (2) --&quot;);
528 
529         try (Server server = new Server()) {
530             final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
531             ch.connect(server.address()).get();
532             SocketChannel sc = server.accept();
533 
534             ByteBuffer src = genBuffer();
535 
536             // read until the buffer is full
537             final ByteBuffer dst = ByteBuffer.allocateDirect(src.capacity());
538             final CountDownLatch latch = new CountDownLatch(1);
539             ch.read(dst, (Void)null, new CompletionHandler&lt;Integer,Void&gt;() {
540                 public void completed(Integer result, Void att) {
541                     if (dst.hasRemaining()) {
542                         ch.read(dst, (Void)null, this);
543                     } else {
544                         latch.countDown();
545                     }
546                 }
547                 public void failed(Throwable exc, Void att) {
548                 }
549             });
550 
551             // trickle the writing
552             do {
553                 int rem = src.remaining();
554                 int size = (rem &lt;= 100) ? rem : 50 + RAND.nextInt(rem - 100);
555                 ByteBuffer buf = ByteBuffer.allocate(size);
556                 for (int i=0; i&lt;size; i++)
557                     buf.put(src.get());
558                 buf.flip();
559                 Thread.sleep(50 + RAND.nextInt(1500));
560                 while (buf.hasRemaining())
561                     sc.write(buf);
562             } while (src.hasRemaining());
563 
564             // wait until ascynrhonous reading has completed
565             latch.await();
566 
567             // check buffers
568             src.flip();
569             dst.flip();
570             if (!src.equals(dst)) {
571                throw new RuntimeException(&quot;Contents differ&quot;);
572             }
573 
574             sc.close();
575             ch.close();
576         }
577     }
578 
579     // exercise scattering read
580     static void testRead3() throws Exception {
581         System.out.println(&quot;-- read (3) --&quot;);
582 
583         try (Server server = new Server()) {
584             final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
585             ch.connect(server.address()).get();
586             SocketChannel sc = server.accept();
587 
588             ByteBuffer[] dsts = new ByteBuffer[3];
589             for (int i=0; i&lt;dsts.length; i++) {
590                 dsts[i] = ByteBuffer.allocateDirect(100);
591             }
592 
593             // scattering read that completes ascynhronously
594             final CountDownLatch l1 = new CountDownLatch(1);
595             ch.read(dsts, 0, dsts.length, 0L, TimeUnit.SECONDS, (Void)null,
596                 new CompletionHandler&lt;Long,Void&gt;() {
597                     public void completed(Long result, Void att) {
598                         long n = result;
599                         if (n &lt;= 0)
600                             throw new RuntimeException(&quot;No bytes read&quot;);
601                         l1.countDown();
602                     }
603                     public void failed(Throwable exc, Void att) {
604                     }
605             });
606 
607             // write some bytes
608             sc.write(genBuffer());
609 
610             // read should now complete
611             l1.await();
612 
613             // write more bytes
614             sc.write(genBuffer());
615 
616             // read should complete immediately
617             for (int i=0; i&lt;dsts.length; i++) {
618                 dsts[i].rewind();
619             }
620 
621             final CountDownLatch l2 = new CountDownLatch(1);
622             ch.read(dsts, 0, dsts.length, 0L, TimeUnit.SECONDS, (Void)null,
623                 new CompletionHandler&lt;Long,Void&gt;() {
624                     public void completed(Long result, Void att) {
625                         long n = result;
626                         if (n &lt;= 0)
627                             throw new RuntimeException(&quot;No bytes read&quot;);
628                         l2.countDown();
629                     }
630                     public void failed(Throwable exc, Void att) {
631                     }
632             });
633             l2.await();
634 
635             ch.close();
636             sc.close();
637         }
638     }
639 
640     static void testWrite1() throws Exception {
641         System.out.println(&quot;-- write (1) --&quot;);
642 
643         try (Server server = new Server()) {
644             final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
645             ch.connect(server.address()).get();
646             SocketChannel sc = server.accept();
647 
648             // write with 0 bytes remaining should complete immediately
649             ByteBuffer buf = ByteBuffer.allocate(1);
650             buf.put((byte)0);
651             int n = ch.write(buf).get();
652             if (n != 0)
653                 throw new RuntimeException(&quot;0 expected&quot;);
654 
655             // write all bytes and close connection when done
656             final ByteBuffer src = genBuffer();
657             ch.write(src, (Void)null, new CompletionHandler&lt;Integer,Void&gt;() {
658                 public void completed(Integer result, Void att) {
659                     if (src.hasRemaining()) {
660                         ch.write(src, (Void)null, this);
661                     } else {
662                         try {
663                             ch.close();
664                         } catch (IOException ignore) { }
665                     }
666                 }
667                 public void failed(Throwable exc, Void att) {
668                 }
669             });
670 
671             // read to EOF or buffer full
672             ByteBuffer dst = ByteBuffer.allocateDirect(src.capacity() + 100);
673             do {
674                 n = sc.read(dst);
675             } while (n &gt; 0);
676             sc.close();
677 
678             // check buffers
679             src.flip();
680             dst.flip();
681             if (!src.equals(dst)) {
682                 throw new RuntimeException(&quot;Contents differ&quot;);
683             }
684 
685             // check write fails with ClosedChannelException
686             try {
687                 ch.read(dst).get();
688                 throw new RuntimeException(&quot;ExecutionException expected&quot;);
689             } catch (ExecutionException x) {
690                 if (!(x.getCause() instanceof ClosedChannelException))
691                     throw new RuntimeException(&quot;Cause of ClosedChannelException expected&quot;,
692                             x.getCause());
693             }
694         }
695     }
696 
697     // exercise gathering write
698     static void testWrite2() throws Exception {
699         System.out.println(&quot;-- write (2) --&quot;);
700 
701         try (Server server = new Server()) {
702             final AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
703             ch.connect(server.address()).get();
704             SocketChannel sc = server.accept();
705 
706             // number of bytes written
707             final AtomicLong bytesWritten = new AtomicLong(0);
708 
709             // write buffers (should complete immediately)
710             ByteBuffer[] srcs = genBuffers(1);
711             final CountDownLatch l1 = new CountDownLatch(1);
712             ch.write(srcs, 0, srcs.length, 0L, TimeUnit.SECONDS, (Void)null,
713                 new CompletionHandler&lt;Long,Void&gt;() {
714                     public void completed(Long result, Void att) {
715                         long n = result;
716                         if (n &lt;= 0)
717                             throw new RuntimeException(&quot;No bytes read&quot;);
718                         bytesWritten.addAndGet(n);
719                         l1.countDown();
720                     }
721                     public void failed(Throwable exc, Void att) {
722                     }
723             });
724             l1.await();
725 
726             // set to true to signal that no more buffers should be written
727             final AtomicBoolean continueWriting = new AtomicBoolean(true);
728 
729             // write until socket buffer is full so as to create the conditions
730             // for when a write does not complete immediately
731             srcs = genBuffers(1);
732             ch.write(srcs, 0, srcs.length, 0L, TimeUnit.SECONDS, (Void)null,
733                 new CompletionHandler&lt;Long,Void&gt;() {
734                     public void completed(Long result, Void att) {
735                         long n = result;
736                         if (n &lt;= 0)
737                             throw new RuntimeException(&quot;No bytes written&quot;);
738                         bytesWritten.addAndGet(n);
739                         if (continueWriting.get()) {
740                             ByteBuffer[] srcs = genBuffers(8);
741                             ch.write(srcs, 0, srcs.length, 0L, TimeUnit.SECONDS,
742                                 (Void)null, this);
743                         }
744                     }
745                     public void failed(Throwable exc, Void att) {
746                     }
747             });
748 
749             // give time for socket buffer to fill up.
750             Thread.sleep(5*1000);
751 
752             // signal handler to stop further writing
753             continueWriting.set(false);
754 
755             // read until done
756             ByteBuffer buf = ByteBuffer.allocateDirect(4096);
757             long total = 0L;
758             do {
759                 int n = sc.read(buf);
760                 if (n &lt;= 0)
761                     throw new RuntimeException(&quot;No bytes read&quot;);
762                 buf.rewind();
763                 total += n;
764             } while (total &lt; bytesWritten.get());
765 
766             ch.close();
767             sc.close();
768         }
769     }
770 
771     static void testShutdown() throws Exception {
772         System.out.println(&quot;-- shutdown --&quot;);
773 
774         try (Server server = new Server();
775              AsynchronousSocketChannel ch = AsynchronousSocketChannel.open())
776         {
777             ch.connect(server.address()).get();
778             try (SocketChannel peer = server.accept()) {
779                 ByteBuffer buf = ByteBuffer.allocateDirect(1000);
780                 int n;
781 
782                 // check read
783                 ch.shutdownInput();
784                 n = ch.read(buf).get();
785                 if (n != -1)
786                     throw new RuntimeException(&quot;-1 expected&quot;);
787                 // check full with full buffer
788                 buf.put(new byte[100]);
789                 n = ch.read(buf).get();
790                 if (n != -1)
791                     throw new RuntimeException(&quot;-1 expected&quot;);
792 
793                 // check write
794                 ch.shutdownOutput();
795                 try {
796                     ch.write(buf).get();
797                     throw new RuntimeException(&quot;ClosedChannelException expected&quot;);
798                 } catch (ExecutionException x) {
799                     if (!(x.getCause() instanceof ClosedChannelException))
800                         throw new RuntimeException(&quot;ClosedChannelException expected&quot;,
801                                 x.getCause());
802                 }
803             }
804         }
805     }
806 
807     static void testTimeout() throws Exception {
808         System.out.println(&quot;-- timeouts --&quot;);
809         testTimeout(Integer.MIN_VALUE, TimeUnit.SECONDS);
810         testTimeout(-1L, TimeUnit.SECONDS);
811         testTimeout(0L, TimeUnit.SECONDS);
812         testTimeout(2L, TimeUnit.SECONDS);
813     }
814 
815     static void testTimeout(final long timeout, final TimeUnit unit) throws Exception {
816         System.out.printf(&quot;---- timeout: %d ms%n&quot;, unit.toMillis(timeout));
817         try (Server server = new Server()) {
818             AsynchronousSocketChannel ch = AsynchronousSocketChannel.open();
819             ch.connect(server.address()).get();
820 
821             ByteBuffer dst = ByteBuffer.allocate(512);
822 
823             final AtomicReference&lt;Throwable&gt; readException = new AtomicReference&lt;Throwable&gt;();
824 
825             // this read should timeout if value is &gt; 0
826             ch.read(dst, timeout, unit, null, new CompletionHandler&lt;Integer,Void&gt;() {
827                 public void completed(Integer result, Void att) {
828                     readException.set(new RuntimeException(&quot;Should not complete&quot;));
829                 }
830                 public void failed(Throwable exc, Void att) {
831                     readException.set(exc);
832                 }
833             });
834             if (timeout &gt; 0L) {
835                 // wait for exception
836                 while (readException.get() == null) {
837                     Thread.sleep(100);
838                 }
839                 if (!(readException.get() instanceof InterruptedByTimeoutException))
840                     throw new RuntimeException(&quot;InterruptedByTimeoutException expected&quot;,
841                             readException.get());
842 
843                 // after a timeout then further reading should throw unspecified runtime exception
844                 boolean exceptionThrown = false;
845                 try {
846                     ch.read(dst);
847                 } catch (RuntimeException x) {
848                     exceptionThrown = true;
849                 }
850                 if (!exceptionThrown)
851                     throw new RuntimeException(&quot;RuntimeException expected after timeout.&quot;);
852             } else {
853                 Thread.sleep(1000);
854                 Throwable exc = readException.get();
855                 if (exc != null)
856                     throw new RuntimeException(exc);
857             }
858 
859             final AtomicReference&lt;Throwable&gt; writeException = new AtomicReference&lt;Throwable&gt;();
860 
861             // write bytes to fill socket buffer
862             ch.write(genBuffer(), timeout, unit, ch,
863                 new CompletionHandler&lt;Integer,AsynchronousSocketChannel&gt;()
864             {
865                 public void completed(Integer result, AsynchronousSocketChannel ch) {
866                     ch.write(genBuffer(), timeout, unit, ch, this);
867                 }
868                 public void failed(Throwable exc, AsynchronousSocketChannel ch) {
869                     writeException.set(exc);
870                 }
871             });
872             if (timeout &gt; 0) {
873                 // wait for exception
874                 while (writeException.get() == null) {
875                     Thread.sleep(100);
876                 }
877                 if (!(writeException.get() instanceof InterruptedByTimeoutException))
878                     throw new RuntimeException(&quot;InterruptedByTimeoutException expected&quot;,
879                             writeException.get());
880 
881                 // after a timeout then further writing should throw unspecified runtime exception
882                 boolean exceptionThrown = false;
883                 try {
884                     ch.write(genBuffer());
885                 } catch (RuntimeException x) {
886                     exceptionThrown = true;
887                 }
888                 if (!exceptionThrown)
889                     throw new RuntimeException(&quot;RuntimeException expected after timeout.&quot;);
890             } else {
891                 Thread.sleep(1000);
892                 Throwable exc = writeException.get();
893                 if (exc != null)
894                     throw new RuntimeException(exc);
895             }
896 
897             // clean-up
898             server.accept().close();
899             ch.close();
900         }
901     }
902 
903     // returns ByteBuffer with random bytes
904     static ByteBuffer genBuffer() {
905         int size = 1024 + RAND.nextInt(16000);
906         byte[] buf = new byte[size];
907         RAND.nextBytes(buf);
908         boolean useDirect = RAND.nextBoolean();
909         if (useDirect) {
910             ByteBuffer bb = ByteBuffer.allocateDirect(buf.length);
911             bb.put(buf);
912             bb.flip();
913             return bb;
914         } else {
915             return ByteBuffer.wrap(buf);
916         }
917     }
918 
919     // return ByteBuffer[] with random bytes
920     static ByteBuffer[] genBuffers(int max) {
921         int len = 1;
922         if (max &gt; 1)
923             len += RAND.nextInt(max);
924         ByteBuffer[] bufs = new ByteBuffer[len];
925         for (int i=0; i&lt;len; i++)
926             bufs[i] = genBuffer();
927         return bufs;
928     }
929 
930     // return random SocketAddress
931     static SocketAddress genSocketAddress() {
932         StringBuilder sb = new StringBuilder(&quot;10.&quot;);
933         sb.append(RAND.nextInt(256));
934         sb.append(&#39;.&#39;);
935         sb.append(RAND.nextInt(256));
936         sb.append(&#39;.&#39;);
937         sb.append(RAND.nextInt(256));
938         InetAddress rh;
939         try {
940             rh = InetAddress.getByName(sb.toString());
941         } catch (UnknownHostException x) {
942             throw new InternalError(&quot;Should not happen&quot;);
943         }
944         return new InetSocketAddress(rh, RAND.nextInt(65535)+1);
945     }
946 }
    </pre>
  </body>
</html>
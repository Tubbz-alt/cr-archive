<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/nio/channels/Channels/Basic.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
<a name="2" id="anc2"></a><span class="line-modified"> 25  * @bug 4417152 4481572 6248930 6725399 6884800 8220477</span>
 26  * @summary Test Channels basic functionality
 27  */
 28 
 29 import java.io.*;
 30 import java.nio.*;
 31 import java.nio.charset.*;
 32 import java.nio.channels.*;
 33 
<a name="3" id="anc3"></a>
 34 public class Basic {
 35 
 36     static String message;
 37 
 38     static String encoding;
 39 
 40     static File blah;
 41 
 42     static int ITERATIONS = 500;
 43 
 44     public static void main(String[] args) throws Exception {
 45         message = &quot;ascii data for a test&quot;;
 46         encoding = &quot;ISO-8859-1&quot;;
 47         test();
 48         message = &quot;\ucafe\ubabe\ucafe\ubabe\ucafe\ubabe&quot;;
 49         encoding = &quot;UTF-8&quot;;
 50         test();
 51     }
 52 
 53     static void failNpeExpected() {
 54         throw new RuntimeException(&quot;Did not get the expected NullPointerException.&quot;);
 55     }
 56 
 57     private static void test() throws Exception {
 58         //Test if methods of Channels throw NPE with null argument(s)
 59         try {
 60             Channels.newInputStream((ReadableByteChannel)null);
 61             failNpeExpected();
 62         } catch (NullPointerException npe) {}
 63 
 64         try {
 65             Channels.newOutputStream((WritableByteChannel)null);
 66             failNpeExpected();
 67         } catch (NullPointerException npe) {}
 68 
 69         try {
 70             ReadableByteChannel channel = Channels.newChannel((InputStream)null);
 71             failNpeExpected();
 72         } catch (NullPointerException ne) {}  // OK. As expected.
 73 
 74         try {
 75             WritableByteChannel channel = Channels.newChannel((OutputStream)null);
 76             failNpeExpected();
 77         } catch (NullPointerException ne) {}  // OK. As expected.
 78 
 79         WritableByteChannel wbc = new WritableByteChannel() {
 80             public int write(ByteBuffer src) { return 0; }
 81             public void close() throws IOException { }
 82             public boolean isOpen() { return true; }
 83         };
 84 
 85         ReadableByteChannel rbc = new ReadableByteChannel() {
 86             public int read(ByteBuffer dst) { return 0; }
 87             public void close() {}
 88             public boolean isOpen() { return true; }
 89         };
 90 
 91         try {
 92             Channels.newReader((ReadableByteChannel)null,
 93                                Charset.defaultCharset().newDecoder(),
 94                                -1);
 95             failNpeExpected();
 96         } catch (NullPointerException npe) {}
 97 
 98         try {
 99             Channels.newReader(rbc, (CharsetDecoder)null, -1);
100             failNpeExpected();
101         } catch (NullPointerException npe) {}
102 
103         try {
104             Channels.newReader((ReadableByteChannel)null,
105                                Charset.defaultCharset().name());
106             failNpeExpected();
107         } catch (NullPointerException npe) {}
108 
109         try {
110             Channels.newReader(rbc, (String)null);
111             failNpeExpected();
112         } catch (NullPointerException npe) {}
113 
114 
115         try {
116             Channels.newReader(null, (String)null);
117             failNpeExpected();
118         } catch (NullPointerException npe) {}
119 
120         try {
121             Channels.newReader(rbc, (Charset)null);
122             failNpeExpected();
123         } catch (NullPointerException npe) {}
124 
125 
126         try {
127             Channels.newReader(null, (Charset)null);
128             failNpeExpected();
129         } catch (NullPointerException npe) {}
130 
131         try {
132             Channels.newWriter((WritableByteChannel)null,
133                                Charset.defaultCharset().newEncoder(),
134                                -1);
135             failNpeExpected();
136         } catch (NullPointerException npe) {}
137 
138         try {
139             Channels.newWriter(null, null, -1);
140             failNpeExpected();
141         } catch (NullPointerException npe) {}
142 
143         try {
144             Channels.newWriter(wbc, null, -1);
145             failNpeExpected();
146         } catch (NullPointerException npe) {}
147 
148         try {
149             Channels.newWriter((WritableByteChannel)null,
150                                Charset.defaultCharset().name());
151             failNpeExpected();
152         } catch (NullPointerException npe) {}
153 
154         try {
155             Channels.newWriter(wbc, (String)null);
156             failNpeExpected();
157         } catch (NullPointerException npe) {}
158 
159         try {
160             Channels.newWriter(null, (String)null);
161             failNpeExpected();
162         } catch (NullPointerException npe) {}
163 
164         try {
165             Channels.newWriter(wbc, (Charset)null);
166             failNpeExpected();
167         } catch (NullPointerException npe) {}
168 
169         try {
170             Channels.newWriter(null, (Charset)null);
171             failNpeExpected();
172         } catch (NullPointerException npe) {}
173 
174         try {
175             blah = File.createTempFile(&quot;blah&quot;, null);
176 
177             testNewOutputStream(blah);
178             readAndCheck(blah);
179             blah.delete();
180 
181             writeOut(blah, ITERATIONS);
182             testNewInputStream(blah);
183             blah.delete();
184 
185             testNewChannelOut(blah);
186             readAndCheck(blah);
187             blah.delete();
188 
189             testNewChannelWriteAfterClose(blah);
190 
191             testNewChannelReadAfterClose(blah);
192             blah.delete();
193 
194             writeOut(blah, ITERATIONS);
195             testNewChannelIn(blah);
196             test4481572(blah);
197             blah.delete();
198 
199             testNewWriter(blah);
200             readAndCheck(blah);
201             blah.delete();
202 
203             writeOut(blah, ITERATIONS);
204             testNewReader(blah);
205 
<a name="4" id="anc4"></a><span class="line-added">206             testNewWriterClose();</span>
<span class="line-added">207             testNewReaderClose();</span>
208         } finally {
209             blah.delete();
210         }
211     }
212 
213     private static void readAndCheck(File blah) throws Exception {
214         FileInputStream fis = new FileInputStream(blah);
215         int messageSize = message.length() * ITERATIONS * 3 + 1;
216         byte bb[] = new byte[messageSize];
217         int bytesRead = 0;
218         int totalRead = 0;
219         while (bytesRead != -1) {
220             totalRead += bytesRead;
221             bytesRead = fis.read(bb, totalRead, messageSize - totalRead);
222         }
223         String result = new String(bb, 0, totalRead, encoding);
224         int len = message.length();
225         for (int i=0; i&lt;ITERATIONS; i++) {
226             String segment = result.substring(i++ * len, i * len);
227             if (!segment.equals(message))
228                 throw new RuntimeException(&quot;Test failed&quot;);
229         }
230         fis.close();
231     }
232 
233     private static void writeOut(File blah, int limit) throws Exception {
234         FileOutputStream fos = new FileOutputStream(blah);
235         for (int i=0; i&lt;limit; i++)
236             fos.write(message.getBytes(encoding));
237         fos.close();
238     }
239 
240     private static void testNewOutputStream(File blah) throws Exception {
241         FileOutputStream fos = new FileOutputStream(blah);
242         FileChannel fc = fos.getChannel();
243         WritableByteChannel wbc = (WritableByteChannel)fc;
244         OutputStream os = Channels.newOutputStream(wbc);
245         for (int i=0; i&lt;ITERATIONS; i++)
246             os.write(message.getBytes(encoding));
247         os.close();
248         fos.close();
249     }
250 
251     private static void testNewInputStream(File blah) throws Exception {
252         FileInputStream fis = new FileInputStream(blah);
253         FileChannel fc = fis.getChannel();
254         InputStream is = Channels.newInputStream(fc);
255         int messageSize = message.length() * ITERATIONS * 3 + 1;
256         byte bb[] = new byte[messageSize];
257 
258         int bytesRead = 0;
259         int totalRead = 0;
260         while (bytesRead != -1) {
261             totalRead += bytesRead;
262             long rem = Math.min(fc.size() - totalRead, (long)Integer.MAX_VALUE);
263             if (is.available() != (int)rem)
264                 throw new RuntimeException(&quot;available not useful or not maximally useful&quot;);
265             bytesRead = is.read(bb, totalRead, messageSize - totalRead);
266         }
267         if (is.available() != 0)
268            throw new RuntimeException(&quot;available() should return 0 at EOF&quot;);
269 
270         String result = new String(bb, 0, totalRead, encoding);
271         int len = message.length();
272         for (int i=0; i&lt;ITERATIONS; i++) {
273             String segment = result.substring(i++ * len, i * len);
274             if (!segment.equals(message))
275                 throw new RuntimeException(&quot;Test failed&quot;);
276         }
277         is.close();
278         fis.close();
279     }
280 
281     private static void testNewChannelOut(File blah) throws Exception {
282         ExtendedFileOutputStream fos = new ExtendedFileOutputStream(blah);
283         WritableByteChannel wbc = Channels.newChannel(fos);
284 
285         for (int i=0; i&lt;ITERATIONS; i++)
286             wbc.write(ByteBuffer.wrap(message.getBytes(encoding)));
287         wbc.close();
288         fos.close();
289     }
290 
291     private static void testNewChannelIn(File blah) throws Exception {
292         ExtendedFileInputStream fis = new ExtendedFileInputStream(blah);
293         ReadableByteChannel rbc = Channels.newChannel(fis);
294 
295         int messageSize = message.length() * ITERATIONS * 3;
296         byte data[] = new byte[messageSize+1];
297         ByteBuffer bb = ByteBuffer.wrap(data);
298 
299         int bytesRead = 0;
300         int totalRead = 0;
301         while (bytesRead != -1) {
302             totalRead += bytesRead;
303             bytesRead = rbc.read(bb);
304         }
305 
306         String result = new String(data, 0, totalRead, encoding);
307         int len = message.length();
308         for (int i=0; i&lt;ITERATIONS; i++) {
309             String segment = result.substring(i++ * len, i * len);
310             if (!segment.equals(message))
311                 throw new RuntimeException(&quot;Test failed&quot;);
312         }
313         rbc.close();
314         fis.close();
315     }
316 
317     private static void testNewChannelWriteAfterClose(File blah)
318         throws Exception {
319         try (ExtendedFileOutputStream fos =
320             new ExtendedFileOutputStream(blah)) {
321             WritableByteChannel wbc = Channels.newChannel(fos);
322 
323             wbc.close();
324             try {
325                 wbc.write(ByteBuffer.allocate(0));
326                 throw new RuntimeException
327                     (&quot;No ClosedChannelException on WritableByteChannel::write&quot;);
328             } catch (ClosedChannelException expected) {
329             }
330         }
331     }
332 
333     private static void testNewChannelReadAfterClose(File blah)
334         throws Exception {
335         try (ExtendedFileInputStream fis = new ExtendedFileInputStream(blah)) {
336             ReadableByteChannel rbc = Channels.newChannel(fis);
337 
338             rbc.close();
339             try {
340                 rbc.read(ByteBuffer.allocate(0));
341                 throw new RuntimeException
342                     (&quot;No ClosedChannelException on ReadableByteChannel::read&quot;);
343             } catch (ClosedChannelException expected) {
344             }
345         }
346     }
347 
348     // Causes BufferOverflowException if bug 4481572 is present.
349     private static void test4481572(File blah) throws Exception {
350         ExtendedFileInputStream fis = new ExtendedFileInputStream(blah);
351         ReadableByteChannel rbc = Channels.newChannel(fis);
352 
353         byte data[] = new byte[9000];
354         ByteBuffer bb = ByteBuffer.wrap(data);
355 
356         int bytesRead = 1;
357         int totalRead = 0;
358         while (bytesRead &gt; 0) {
359             totalRead += bytesRead;
360             bytesRead = rbc.read(bb);
361         }
362         rbc.close();
363         fis.close();
364     }
365 
366     private static void testNewWriter(File blah) throws Exception {
367         FileOutputStream fos = new FileOutputStream(blah);
368         WritableByteChannel wbc = (WritableByteChannel)fos.getChannel();
369         Writer w = Channels.newWriter(wbc, encoding);
370         char data[] = new char[40];
371         message.getChars(0, message.length(), data, 0);
372         for (int i=0; i&lt;ITERATIONS; i++)
373             w.write(data, 0, message.length());
374         w.flush();
375         w.close();
376         fos.close();
377     }
378 
379     private static void testNewReader(File blah) throws Exception {
380         FileInputStream fis = new FileInputStream(blah);
381         ReadableByteChannel rbc = (ReadableByteChannel)fis.getChannel();
382         Reader r = Channels.newReader(rbc, encoding);
383 
384         int messageSize = message.length() * ITERATIONS;
385         char data[] = new char[messageSize];
386 
387         int totalRead = 0;
388         int charsRead = 0;
389         while (totalRead &lt; messageSize) {
390             totalRead += charsRead;
391             charsRead = r.read(data, totalRead, messageSize - totalRead);
392         }
393         String result = new String(data, 0, totalRead);
394         int len = message.length();
395         for (int i=0; i&lt;ITERATIONS; i++) {
396             String segment = result.substring(i++ * len, i * len);
397             if (!segment.equals(message))
398                 throw new RuntimeException(&quot;Test failed&quot;);
399         }
400         r.close();
401         fis.close();
402     }
<a name="5" id="anc5"></a><span class="line-added">403 </span>
<span class="line-added">404     private static void testNewWriterClose() throws Exception {</span>
<span class="line-added">405         Writer writer = null;</span>
<span class="line-added">406         try {</span>
<span class="line-added">407             WritableByteChannel channel = new WritableByteChannel() {</span>
<span class="line-added">408                 @Override</span>
<span class="line-added">409                 public int write(ByteBuffer src) throws IOException {</span>
<span class="line-added">410                     return 0;</span>
<span class="line-added">411                 }</span>
<span class="line-added">412 </span>
<span class="line-added">413                 @Override</span>
<span class="line-added">414                 public boolean isOpen() {</span>
<span class="line-added">415                     return true;</span>
<span class="line-added">416                 }</span>
<span class="line-added">417 </span>
<span class="line-added">418                 @Override</span>
<span class="line-added">419                 public void close() throws IOException {</span>
<span class="line-added">420                     throw new IOException();</span>
<span class="line-added">421                 }</span>
<span class="line-added">422             };</span>
<span class="line-added">423             writer = Channels.newWriter(channel,</span>
<span class="line-added">424                 StandardCharsets.UTF_8.newEncoder(), -1);</span>
<span class="line-added">425             writer.close();</span>
<span class="line-added">426         } catch (IOException ioe) {</span>
<span class="line-added">427             Exception theException = null;</span>
<span class="line-added">428             try {</span>
<span class="line-added">429                 writer.write(1);</span>
<span class="line-added">430                 writer.flush();</span>
<span class="line-added">431             } catch (Exception e) {</span>
<span class="line-added">432                 theException = e;</span>
<span class="line-added">433             } finally {</span>
<span class="line-added">434                 if (theException == null) {</span>
<span class="line-added">435                     throw new RuntimeException(&quot;IOException not thrown&quot;);</span>
<span class="line-added">436                 } else if (!(theException instanceof IOException)) {</span>
<span class="line-added">437                     throw new RuntimeException(&quot;Exception not an IOException: &quot;</span>
<span class="line-added">438                         + theException);</span>
<span class="line-added">439                 } else {</span>
<span class="line-added">440                     String message = theException.getMessage();</span>
<span class="line-added">441                     if (!message.equals(&quot;Stream closed&quot;)) {</span>
<span class="line-added">442                         throw new RuntimeException(&quot;Unexpected message &quot;</span>
<span class="line-added">443                             + message);</span>
<span class="line-added">444                     }</span>
<span class="line-added">445                 }</span>
<span class="line-added">446             }</span>
<span class="line-added">447         }</span>
<span class="line-added">448     }</span>
<span class="line-added">449 </span>
<span class="line-added">450     private static void testNewReaderClose() throws Exception {</span>
<span class="line-added">451         Reader reader = null;</span>
<span class="line-added">452         try {</span>
<span class="line-added">453             ReadableByteChannel channel = new ReadableByteChannel() {</span>
<span class="line-added">454                 @Override</span>
<span class="line-added">455                 public int read(ByteBuffer dst) throws IOException {</span>
<span class="line-added">456                     dst.put((byte)7);</span>
<span class="line-added">457                     return 1;</span>
<span class="line-added">458                 }</span>
<span class="line-added">459 </span>
<span class="line-added">460                 @Override</span>
<span class="line-added">461                 public boolean isOpen() {</span>
<span class="line-added">462                     return true;</span>
<span class="line-added">463                 }</span>
<span class="line-added">464 </span>
<span class="line-added">465                 @Override</span>
<span class="line-added">466                 public void close() throws IOException {</span>
<span class="line-added">467                     throw new IOException();</span>
<span class="line-added">468                 }</span>
<span class="line-added">469             };</span>
<span class="line-added">470             reader = Channels.newReader(channel,</span>
<span class="line-added">471                 StandardCharsets.UTF_8.newDecoder(), -1);</span>
<span class="line-added">472             reader.close();</span>
<span class="line-added">473         } catch (IOException ioe) {</span>
<span class="line-added">474             Exception theException = null;</span>
<span class="line-added">475             try {</span>
<span class="line-added">476                 reader.read();</span>
<span class="line-added">477             } catch (Exception e) {</span>
<span class="line-added">478                 theException = e;</span>
<span class="line-added">479             } finally {</span>
<span class="line-added">480                 if (theException == null) {</span>
<span class="line-added">481                     throw new RuntimeException(&quot;IOException not thrown&quot;);</span>
<span class="line-added">482                 } else if (!(theException instanceof IOException)) {</span>
<span class="line-added">483                     throw new RuntimeException(&quot;Exception not an IOException: &quot;</span>
<span class="line-added">484                         + theException);</span>
<span class="line-added">485                 } else {</span>
<span class="line-added">486                     String message = theException.getMessage();</span>
<span class="line-added">487                     if (!message.equals(&quot;Stream closed&quot;)) {</span>
<span class="line-added">488                         throw new RuntimeException(&quot;Unexpected message &quot;</span>
<span class="line-added">489                             + message);</span>
<span class="line-added">490                     }</span>
<span class="line-added">491                 }</span>
<span class="line-added">492             }</span>
<span class="line-added">493         }</span>
<span class="line-added">494     }</span>
495 }
496 
497 class ExtendedFileInputStream extends java.io.FileInputStream {
498     ExtendedFileInputStream(File file) throws FileNotFoundException {
499         super(file);
500     }
501 }
502 
503 class ExtendedFileOutputStream extends java.io.FileOutputStream {
504     ExtendedFileOutputStream(File file) throws FileNotFoundException {
505         super(file);
506     }
507 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/nio/channels/DatagramChannel/Promiscuous.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23 
 24 /* @test
 25  * @bug 8014377
 26  * @summary Test for interference when two sockets are bound to the same
 27  *   port but joined to different multicast groups
 28  * @library /test/lib
 29  * @build jdk.test.lib.NetworkConfiguration
 30  *        jdk.test.lib.Platform
 31  *        Promiscuous
 32  * @run main Promiscuous
 33  * @run main/othervm -Djava.net.preferIPv4Stack=true Promiscuous
 34  * @key randomness
 35  */
 36 
 37 import java.nio.ByteBuffer;
 38 import java.nio.channels.*;
 39 import java.net.*;
 40 import static java.net.StandardProtocolFamily.*;
 41 import java.util.*;
 42 import java.io.IOException;
 43 import java.util.stream.Collectors;
 44 
 45 import jdk.test.lib.NetworkConfiguration;
 46 
 47 public class Promiscuous {
 48 
 49     static final Random rand = new Random();
 50 
 51     static final ProtocolFamily UNSPEC = new ProtocolFamily() {
 52         public String name() {
 53             return &quot;UNSPEC&quot;;
 54         }
 55     };
 56 
 57     /**
 58      * Sends a datagram to the given multicast group
 59      */
 60     static int sendDatagram(NetworkInterface nif,
 61                             InetAddress group,
 62                             int port)
 63         throws IOException
 64     {
 65         ProtocolFamily family = (group instanceof Inet6Address) ?
 66             StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
 67         DatagramChannel dc = DatagramChannel.open(family)
 68             .setOption(StandardSocketOptions.IP_MULTICAST_IF, nif);
 69         int id = rand.nextInt();
 70         byte[] msg = Integer.toString(id).getBytes(&quot;UTF-8&quot;);
 71         ByteBuffer buf = ByteBuffer.wrap(msg);
 72         System.out.format(&quot;Send message -&gt; group %s (id=0x%x)\n&quot;,
 73             group.getHostAddress(), id);
 74         dc.send(buf, new InetSocketAddress(group, port));
 75         dc.close();
 76         return id;
 77     }
 78 
 79     /**
 80      * Wait (with timeout) for datagram. The {@code datagramExepcted}
 81      * parameter indicates whether a datagram is expected, and if
 82      * {@true} then {@code id} is the identifier in the payload.
 83      */
 84     static void receiveDatagram(DatagramChannel dc,
 85                                 String name,
 86                                 boolean datagramExepcted,
 87                                 int id)
 88         throws IOException
 89     {
 90         System.out.println(&quot;Checking if received by &quot; + name);
 91 
 92         Selector sel = Selector.open();
 93         dc.configureBlocking(false);
 94         dc.register(sel, SelectionKey.OP_READ);
 95         ByteBuffer buf = ByteBuffer.allocateDirect(100);
 96 
 97         try {
 98             for (;;) {
 99                 System.out.println(&quot;Waiting to receive message&quot;);
100                 sel.select(5*1000);
101                 SocketAddress sa = dc.receive(buf);
102 
103                 // no datagram received
104                 if (sa == null) {
105                     if (datagramExepcted) {
106                         throw new RuntimeException(&quot;Expected message not received&quot;);
107                     }
108                     System.out.println(&quot;No message received (correct)&quot;);
109                     return;
110                 }
111 
112                 // datagram received
113 
114                 InetAddress sender = ((InetSocketAddress)sa).getAddress();
115                 buf.flip();
116                 byte[] bytes = new byte[buf.remaining()];
117                 buf.get(bytes);
118                 String s = new String(bytes, &quot;UTF-8&quot;);
119                 int receivedId = -1;
120                 try {
121                     receivedId = Integer.parseInt(s);
122                     System.out.format(&quot;Received message from %s (id=0x%x)\n&quot;,
123                             sender, receivedId);
124                 } catch (NumberFormatException x) {
125                     System.out.format(&quot;Received message from %s (msg=%s)\n&quot;, sender, s);
126                 }
127 
128                 if (!datagramExepcted) {
129                     if (receivedId == id)
130                         throw new RuntimeException(&quot;Message not expected&quot;);
131                     System.out.println(&quot;Message ignored (has wrong id)&quot;);
132                 } else {
133                     if (receivedId == id) {
134                         System.out.println(&quot;Message expected&quot;);
135                         return;
136                     }
137                     System.out.println(&quot;Message ignored (wrong sender)&quot;);
138                 }
139 
140                 sel.selectedKeys().clear();
141                 buf.rewind();
142             }
143         } finally {
144             sel.close();
145         }
146     }
147 
148     static void test(ProtocolFamily family,
149                      NetworkInterface nif,
150                      InetAddress group1,
151                      InetAddress group2)
152         throws IOException
153     {
154 
155         System.out.format(&quot;%nTest family=%s%n&quot;, family.name());
156 
157         DatagramChannel dc1 = (family == UNSPEC) ?
158             DatagramChannel.open() : DatagramChannel.open(family);
159         DatagramChannel dc2 = (family == UNSPEC) ?
160             DatagramChannel.open() : DatagramChannel.open(family);
161 
162         try {
163             dc1.setOption(StandardSocketOptions.SO_REUSEADDR, true);
164             dc2.setOption(StandardSocketOptions.SO_REUSEADDR, true);
165 
166             dc1.bind(new InetSocketAddress(0));
167             int port = dc1.socket().getLocalPort();
168             dc2.bind(new InetSocketAddress(port));
169 
170             System.out.format(&quot;dc1 joining [%s]:%d @ %s\n&quot;,
171                 group1.getHostAddress(), port, nif.getName());
172             System.out.format(&quot;dc2 joining [%s]:%d @ %s\n&quot;,
173                 group2.getHostAddress(), port, nif.getName());
174 
175             dc1.join(group1, nif);
176             dc2.join(group2, nif);
177 
178             int id = sendDatagram(nif, group1, port);
179 
180             receiveDatagram(dc1, &quot;dc1&quot;, true, id);
181             receiveDatagram(dc2, &quot;dc2&quot;, false, id);
182 
183             id = sendDatagram(nif, group2, port);
184 
185             receiveDatagram(dc1, &quot;dc1&quot;, false, id);
186             receiveDatagram(dc2, &quot;dc2&quot;, true, id);
187 
188         } finally {
189             dc1.close();
190             dc2.close();
191         }
192     }
193 
194     public static void main(String[] args) throws IOException {
195         String os = System.getProperty(&quot;os.name&quot;);
196 
197         // Requires IP_MULTICAST_ALL on Linux (new since 2.6.31) so skip
198         // on older kernels. Note that we skip on &lt;= version 3 to keep the
199         // parsing simple
200         if (os.equals(&quot;Linux&quot;)) {
201             String osversion = System.getProperty(&quot;os.version&quot;);
202             String[] vers = osversion.split(&quot;\\.&quot;, 0);
203             int major = Integer.parseInt(vers[0]);
204             if (major &lt; 3) {
205                 System.out.format(&quot;Kernel version is %s, test skipped%n&quot;, osversion);
206                 return;
207             }
208         }
209 
210         // get local network configuration to use
211         NetworkConfiguration config = NetworkConfiguration.probe();
212 
213         // multicast groups used for the test
214         InetAddress ip4Group1 = InetAddress.getByName(&quot;225.4.5.6&quot;);
215         InetAddress ip4Group2 = InetAddress.getByName(&quot;225.4.6.6&quot;);
216 
217         for (NetworkInterface nif: config.ip4MulticastInterfaces()
218                                          .collect(Collectors.toList())) {
219             InetAddress source = config.ip4Addresses(nif).iterator().next();
220             test(INET, nif, ip4Group1, ip4Group2);
221 
222             // Solaris and Linux allow IPv6 sockets join IPv4 multicast groups
223             if (os.equals(&quot;SunOS&quot;) || os.equals(&quot;Linux&quot;))
224                 test(UNSPEC, nif, ip4Group1, ip4Group2);
225         }
226     }
227 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/nio/channels/FileChannel/MapTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 4429043 8002180
 26  * @summary Test file mapping with FileChannel
 27  * @run main/othervm/timeout=240 MapTest
 28  * @key randomness
 29  */
 30 
 31 import java.io.*;
 32 import java.nio.MappedByteBuffer;
 33 import java.nio.channels.*;
 34 import java.nio.channels.FileChannel.MapMode;
 35 import java.nio.file.Files;
 36 import static java.nio.file.StandardOpenOption.*;
 37 import static java.nio.charset.StandardCharsets.*;
 38 import java.util.Random;
 39 
 40 
 41 /**
 42  * Testing FileChannel&#39;s mapping capabilities.
 43  */
 44 
 45 public class MapTest {
 46 
 47     private static PrintStream out = System.out;
 48     private static PrintStream err = System.err;
 49 
 50     private static Random generator = new Random();
 51 
 52     private static int CHARS_PER_LINE = File.separatorChar == &#39;/&#39; ? 5 : 6;
 53 
 54     private static File blah;
 55 
 56     public static void main(String[] args) throws Exception {
 57         blah = File.createTempFile(&quot;blah&quot;, null);
 58         blah.deleteOnExit();
 59         initTestFile(blah);
 60         try {
 61             out.println(&quot;Test file &quot; + blah + &quot; initialized&quot;);
 62             testZero();
 63             out.println(&quot;Zero size: OK&quot;);
 64             testRead();
 65             out.println(&quot;Read: OK&quot;);
 66             testWrite();
 67             out.println(&quot;Write: OK&quot;);
 68             testHighOffset();
 69             out.println(&quot;High offset: OK&quot;);
 70             testForce();
 71             out.println(&quot;Force: OK&quot;);
 72             testExceptions();
 73             out.println(&quot;Exceptions: OK&quot;);
 74         } finally {
 75             blah.delete();
 76         }
 77     }
 78 
 79     /**
 80      * Creates file blah:
 81      * 0000
 82      * 0001
 83      * 0002
 84      * 0003
 85      * .
 86      * .
 87      * .
 88      * 3999
 89      *
 90      * Blah extends beyond a single page of memory so that the
 91      * ability to index into a file of multiple pages is tested.
 92      */
 93     private static void initTestFile(File blah) throws Exception {
 94         try (BufferedWriter writer = Files.newBufferedWriter(blah.toPath(), ISO_8859_1)) {
 95             for (int i=0; i&lt;4000; i++) {
 96                 String number = new Integer(i).toString();
 97                 for (int h=0; h&lt;4-number.length(); h++)
 98                     writer.write(&quot;0&quot;);
 99                 writer.write(&quot;&quot;+i);
100                 writer.newLine();
101             }
102         }
103     }
104 
105     /**
106      * Tests zero size file mapping
107      */
108     private static void testZero() throws Exception {
109         try (FileInputStream fis = new FileInputStream(blah)) {
110             FileChannel fc = fis.getChannel();
111             MappedByteBuffer b = fc.map(MapMode.READ_ONLY, 0, 0);
112         }
113     }
114 
115     /**
116      * Maps blah file with a random offset and checks to see if read
117      * from the ByteBuffer gets the right line number
118      */
119     private static void testRead() throws Exception {
120         StringBuilder sb = new StringBuilder();
121         sb.setLength(4);
122 
123         for (int x=0; x&lt;1000; x++) {
124             try (FileInputStream fis = new FileInputStream(blah)) {
125                 FileChannel fc = fis.getChannel();
126 
127                 long offset = generator.nextInt(10000);
128                 long expectedResult = offset / CHARS_PER_LINE;
129                 offset = expectedResult * CHARS_PER_LINE;
130 
131                 MappedByteBuffer b = fc.map(MapMode.READ_ONLY,
132                                             offset, 100);
133 
134                 for (int i=0; i&lt;4; i++) {
135                     byte aByte = b.get(i);
136                     sb.setCharAt(i, (char)aByte);
137                 }
138 
139                 int result = Integer.parseInt(sb.toString());
140                 if (result != expectedResult) {
141                     err.println(&quot;I expected &quot;+expectedResult);
142                     err.println(&quot;I got &quot;+result);
143                     throw new Exception(&quot;Read test failed&quot;);
144                 }
145             }
146         }
147     }
148 
149     /**
150      * Maps blah file with a random offset and checks to see if data
151      * written out to the file can be read back in
152      */
153     private static void testWrite() throws Exception {
154         StringBuilder sb = new StringBuilder();
155         sb.setLength(4);
156 
157         for (int x=0; x&lt;1000; x++) {
158             try (RandomAccessFile raf = new RandomAccessFile(blah, &quot;rw&quot;)) {
159                 FileChannel fc = raf.getChannel();
160 
161                 long offset = generator.nextInt(1000);
162                 MappedByteBuffer b = fc.map(MapMode.READ_WRITE,
163                                             offset, 100);
164 
165                 for (int i=0; i&lt;4; i++) {
166                     b.put(i, (byte)(&#39;0&#39; + i));
167                 }
168 
169                 for (int i=0; i&lt;4; i++) {
170                     byte aByte = b.get(i);
171                     sb.setCharAt(i, (char)aByte);
172                 }
173                 if (!sb.toString().equals(&quot;0123&quot;))
174                     throw new Exception(&quot;Write test failed&quot;);
175             }
176         }
177     }
178 
179     private static void testHighOffset() throws Exception {
180         StringBuilder sb = new StringBuilder();
181         sb.setLength(4);
182 
183         for (int x=0; x&lt;1000; x++) {
184             try (RandomAccessFile raf = new RandomAccessFile(blah, &quot;rw&quot;)) {
185                 FileChannel fc = raf.getChannel();
186                 long offset = 66000;
187                 MappedByteBuffer b = fc.map(MapMode.READ_WRITE,
188                                             offset, 100);
189             }
190         }
191     }
192 
193     /**
194      * Maps blah file, writes some data and forcing writeback of
195      * the data exercising various valid and invalid writeback ranges.
196      */
197     private static void testForce() throws Exception {
198         for (int x=0; x&lt;50; x++) {
199             try (RandomAccessFile raf = new RandomAccessFile(blah, &quot;rw&quot;)) {
200                 FileChannel fc = raf.getChannel();
201                 final int BLOCK_SIZE = 64;
202                 final int BLOCK_COUNT = (4096 * 2)/ BLOCK_SIZE;
203                 int offset = 0;
204                 MappedByteBuffer b = fc.map(MapMode.READ_WRITE,
205                                             0, BLOCK_SIZE * (BLOCK_COUNT + 1));
206 
207                 for (int blocks = 0; blocks &lt; BLOCK_COUNT; blocks++) {
208                     for (int i = 0; i &lt; BLOCK_SIZE; i++) {
209                         b.put(offset + i, (byte)(&#39;0&#39; + i));
210                     }
211                     b.force(offset, BLOCK_SIZE);
212                     offset += BLOCK_SIZE;
213                 }
214 
215                 Exception exc = null;
216                 try {
217                     // start and end are out of range
218                     b.force(offset + BLOCK_SIZE, BLOCK_SIZE);
219                 } catch (IndexOutOfBoundsException e) {
220                     exc = e;
221                 }
222                 if (exc == null) {
223                     throw new RuntimeException(&quot;expected Exception for force beyond buffer extent&quot;);
224                 }
225 
226                 exc = null;
227                 try {
228                     // start is in range but end is out of range
229                     b.force(offset, 2 * BLOCK_SIZE);
230                 } catch (IndexOutOfBoundsException e) {
231                     exc = e;
232                 }
233                 if (exc == null) {
234                     throw new RuntimeException(&quot;expected Exception for force beyond write limit&quot;);
235                 }
236             }
237         }
238     }
239 
240     /**
241      * Test exceptions specified by map method
242      */
243     private static void testExceptions() throws Exception {
244         // check exceptions when channel opened for read access
245         try (FileChannel fc = FileChannel.open(blah.toPath(), READ)) {
246             testExceptions(fc);
247 
248             checkException(fc, MapMode.READ_WRITE, 0L, fc.size(),
249                            NonWritableChannelException.class);
250 
251             checkException(fc, MapMode.READ_WRITE, -1L, fc.size(),
252                            NonWritableChannelException.class, IllegalArgumentException.class);
253 
254             checkException(fc, MapMode.READ_WRITE, 0L, -1L,
255                            NonWritableChannelException.class, IllegalArgumentException.class);
256 
257             checkException(fc, MapMode.PRIVATE, 0L, fc.size(),
258                            NonWritableChannelException.class);
259 
260             checkException(fc, MapMode.PRIVATE, -1L, fc.size(),
261                            NonWritableChannelException.class, IllegalArgumentException.class);
262 
263             checkException(fc, MapMode.PRIVATE, 0L, -1L,
264                            NonWritableChannelException.class, IllegalArgumentException.class);
265         }
266 
267         // check exceptions when channel opened for write access
268         try (FileChannel fc = FileChannel.open(blah.toPath(), WRITE)) {
269             testExceptions(fc);
270 
271             checkException(fc, MapMode.READ_ONLY, 0L, fc.size(),
272                            NonReadableChannelException.class);
273 
274             checkException(fc, MapMode.READ_ONLY, -1L, fc.size(),
275                            NonReadableChannelException.class, IllegalArgumentException.class);
276 
277             /*
278              * implementation/spec mismatch, these tests disabled for now
279              */
280             //checkException(fc, MapMode.READ_WRITE, 0L, fc.size(),
281             //               NonWritableChannelException.class);
282             //checkException(fc, MapMode.PRIVATE, 0L, fc.size(),
283             //               NonWritableChannelException.class);
284         }
285 
286         // check exceptions when channel opened for read and write access
287         try (FileChannel fc = FileChannel.open(blah.toPath(), READ, WRITE)) {
288             testExceptions(fc);
289         }
290     }
291 
292     private static void testExceptions(FileChannel fc) throws IOException {
293         checkException(fc, null, 0L, fc.size(),
294                        NullPointerException.class);
295 
296         checkException(fc, MapMode.READ_ONLY, -1L, fc.size(),
297                        IllegalArgumentException.class);
298 
299         checkException(fc, null, -1L, fc.size(),
300                        IllegalArgumentException.class, NullPointerException.class);
301 
302         checkException(fc, MapMode.READ_ONLY, 0L, -1L,
303                        IllegalArgumentException.class);
304 
305         checkException(fc, null, 0L, -1L,
306                        IllegalArgumentException.class, NullPointerException.class);
307 
308         checkException(fc, MapMode.READ_ONLY, 0L, Integer.MAX_VALUE + 1L,
309                        IllegalArgumentException.class);
310 
311         checkException(fc, null, 0L, Integer.MAX_VALUE + 1L,
312                        IllegalArgumentException.class, NullPointerException.class);
313 
314         checkException(fc, MapMode.READ_ONLY, Long.MAX_VALUE, 1L,
315                        IllegalArgumentException.class);
316 
317         checkException(fc, null, Long.MAX_VALUE, 1L,
318                        IllegalArgumentException.class, NullPointerException.class);
319 
320     }
321 
322     /**
323      * Checks that FileChannel map throws one of the expected exceptions
324      * when invoked with the given inputs.
325      */
326     private static void checkException(FileChannel fc,
327                                        MapMode mode,
328                                        long position,
329                                        long size,
330                                        Class&lt;?&gt;... expected)
331         throws IOException
332     {
333         Exception exc = null;
334         try {
335             fc.map(mode, position, size);
336         } catch (Exception actual) {
337             exc = actual;
338         }
339         if (exc != null) {
340             for (Class&lt;?&gt; clazz: expected) {
341                 if (clazz.isInstance(exc)) {
342                     return;
343                 }
344             }
345         }
346         System.err.println(&quot;Expected one of&quot;);
347         for (Class&lt;?&gt; clazz: expected) {
348             System.out.println(clazz);
349         }
350         if (exc == null) {
351             throw new RuntimeException(&quot;No expection thrown&quot;);
352         } else {
353             throw new RuntimeException(&quot;Unexpected exception thrown&quot;, exc);
354         }
355     }
356 }
    </pre>
  </body>
</html>
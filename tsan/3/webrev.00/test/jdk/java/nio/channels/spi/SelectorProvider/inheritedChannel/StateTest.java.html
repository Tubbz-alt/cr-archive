<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/nio/channels/spi/SelectorProvider/inheritedChannel/StateTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  *
 26  *
 27  * Tests that the channel returned by System.inheritedChannel()
 28  * is in blocking mode, bound, and in the case of a SocketChannel
 29  * connected to a peer.
 30  *
 31  * The test works by launching a test service (called StateTestService) so
 32  * that it inherits each type of channel. The test service checks the
 33  * socket state and replies back to this class via an out-of-band
 34  * channel.
 35  */
 36 import java.io.IOException;
 37 import java.net.InetSocketAddress;
 38 import java.net.InetAddress;
 39 import java.nio.ByteBuffer;
 40 import java.nio.channels.DatagramChannel;
 41 import java.nio.channels.SelectionKey;
 42 import java.nio.channels.Selector;
 43 import java.nio.channels.ServerSocketChannel;
 44 import java.nio.channels.SocketChannel;
 45 
 46 import jdk.test.lib.Utils;
 47 
 48 public class StateTest {
 49 
 50     private static int failures = 0;
 51 
 52     private static String TEST_SERVICE = &quot;StateTestService&quot;;
 53 
 54     /*
 55      * Reads the test result from the &quot;out-of-band&quot; connection to the test service.
 56      *
 57      * The out-of-band connection is just a TCP connection from the service to
 58      * this class. waitForTestResult just waits (with timeout) for the service
 59      * to connect. Once connected it waits (with timeout) for the test result.
 60      * The test result is examined.
 61      */
 62     private static void waitForTestResult(ServerSocketChannel ssc, boolean expectFail) throws IOException {
 63         Selector sel = ssc.provider().openSelector();
 64         SelectionKey sk;
 65         SocketChannel sc;
 66 
 67         /*
 68          * Wait for service to connect
 69          */
 70         System.err.println(&quot;Waiting for the service to connect&quot;);
 71         ssc.configureBlocking(false);
 72         sk = ssc.register(sel, SelectionKey.OP_ACCEPT);
 73         long to = Utils.adjustTimeout(15*1000);
 74         sc = null;
 75         for (;;) {
 76             long st = System.currentTimeMillis();
 77             sel.select(to);
 78             if (sk.isAcceptable() &amp;&amp; ((sc = ssc.accept()) != null)) {
 79                 // connection established
 80                 break;
 81             }
 82             sel.selectedKeys().remove(sk);
 83             to -= System.currentTimeMillis() - st;
 84             if (to &lt;= 0) {
 85                 throw new IOException(&quot;Timed out waiting for service to report test result&quot;);
 86             }
 87         }
 88         sk.cancel();
 89         ssc.configureBlocking(false);
 90 
 91         /*
 92          * Wait for service to report test result
 93          */
 94         System.err.println(&quot;Waiting for the service to report test result&quot;);
 95         sc.configureBlocking(false);
 96         sk = sc.register(sel, SelectionKey.OP_READ);
 97         to = Utils.adjustTimeout(5000);
 98         ByteBuffer bb = ByteBuffer.allocateDirect(20);
 99         for (;;) {
100             long st = System.currentTimeMillis();
101             sel.select(to);
102             if (sk.isReadable()) {
103                 int n = sc.read(bb);
104                 if (n &gt; 0) {
105                     break;
106                 }
107                 if (n &lt; 0) {
108                     throw new IOException(&quot;Premature EOF - no test result from service&quot;);
109                 }
110             }
111             sel.selectedKeys().remove(sk);
112             to -= System.currentTimeMillis() - st;
113             if (to &lt;= 0) {
114                 throw new IOException(&quot;Timed out waiting for service to report test result&quot;);
115             }
116         }
117         System.err.println(&quot;Cleaning up&quot;);
118         sk.cancel();
119         sc.close();
120         sel.close();
121 
122         /*
123          * Examine the test result
124          */
125         System.err.println(&quot;Examine test result&quot;);
126         bb.flip();
127         byte b = bb.get();
128 
129         if (expectFail &amp;&amp; b == &#39;P&#39;) {
130             System.err.println(&quot;Test passed - test is expected to fail!!!&quot;);
131             failures++;
132         }
133         if (!expectFail &amp;&amp; b != &#39;P&#39;) {
134             System.err.println(&quot;Test failed!&quot;);
135             failures++;
136         }
137     }
138 
139     public static void main(String args[]) throws IOException {
140         boolean expectFail = false;
141 
142         /*
143          *   [-expectFail] [options...]
144          */
145         String options[] = args;
146         if (args.length &gt; 0 &amp;&amp; args[0].equals(&quot;-expectFail&quot;)) {
147             // shift out first arg to create options
148             expectFail = true;
149             options = new String[args.length-1];
150             if (args.length &gt; 1) {
151                 System.arraycopy(args, 1, options, 0, args.length-1);
152             }
153         }
154 
155         /*
156          * Create the listener which will be used to read the test result
157          * from the service.
158          */
159         ServerSocketChannel ssc = ServerSocketChannel.open();
160         ssc.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(), 0));
161         System.err.println(&quot;Listener bound to: &quot; + ssc.socket().getLocalSocketAddress());
162 
163         /*
164          * The port is passed to the service as an argument.
165          */
166         int port = ssc.socket().getLocalPort();
167         String arg[] = new String[1];
168         arg[0] = String.valueOf(port);
169 
170         /*
171          * Launch service with a SocketChannel (tcp nowait)
172          */
173         System.err.println(&quot;launchWithSocketChannel&quot;);
174         SocketChannel sc = Launcher.launchWithSocketChannel(TEST_SERVICE, options, arg);
175         System.err.println(&quot;Waiting for test results&quot;);
176         waitForTestResult(ssc, expectFail);
177         sc.close();
178 
179         /*
180          * Launch service with a ServerSocketChannel (tcp wait)
181          * launchWithServerSocketChannel establishes a connection to the service
182          * and the returned SocketChannel is connected to the service.
183          */
184         System.err.println(&quot;launchWithServerSocketChannel&quot;);
185         sc = Launcher.launchWithServerSocketChannel(TEST_SERVICE, options, arg);
186         waitForTestResult(ssc, expectFail);
187         sc.close();
188 
189         /*
190          * Launch service with a DatagramChannel (udp wait)
191          */
192         System.err.println(&quot;launchWithDatagramChannel&quot;);
193         DatagramChannel dc = Launcher.launchWithDatagramChannel(TEST_SERVICE, options, arg);
194         waitForTestResult(ssc, expectFail);
195         dc.close();
196 
197         System.err.println(&quot;done&quot;);
198         if (failures &gt; 0) {
199             throw new RuntimeException(&quot;Test failed - see log for details&quot;);
200         } else {
201             System.out.println(&quot;All tests passed.&quot;);
202         }
203     }
204 }
    </pre>
  </body>
</html>
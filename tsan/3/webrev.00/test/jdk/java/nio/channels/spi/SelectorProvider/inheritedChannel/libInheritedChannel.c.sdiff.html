<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/nio/channels/spi/SelectorProvider/inheritedChannel/libInheritedChannel.c</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="UnixDomainSocket.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../charset/coders/Check.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/nio/channels/spi/SelectorProvider/inheritedChannel/libInheritedChannel.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * A simple launcher to launch a program as if it was launched by inetd.
 26  */
 27 #include &lt;stdio.h&gt;
 28 #include &lt;stdlib.h&gt;

 29 #include &lt;sys/types.h&gt;
 30 #include &lt;sys/socket.h&gt;

 31 #include &lt;unistd.h&gt;
 32 #include &lt;dirent.h&gt;
 33 #include &lt;sys/stat.h&gt;
 34 #include &lt;fcntl.h&gt;
 35 #include &lt;ctype.h&gt;
 36 
 37 #include &quot;jni.h&quot;
 38 
 39 #define CHECK(X) if ((X) == 0) {printf(&quot;JNI init error line %d\n&quot;, __LINE__); _exit(1);}
 40 
 41 static jclass unixSocketClass;
 42 static jmethodID unixSocketCtor;
 43 
 44 /*
 45  * Throws the exception of the given class name and detail message
 46  */
 47 static void ThrowException(JNIEnv *env, const char *name, const char *msg) {
 48     jclass cls = (*env)-&gt;FindClass(env, name);
 49     if (cls != NULL) {
 50         (*env)-&gt;ThrowNew(env, cls, msg);
</pre>
<hr />
<pre>
130     cmdv[cmdlen] = NULL;
131 
132     /*
133      * Launch the program. As this isn&#39;t a complete inetd or Runtime.exec
134      * implementation we don&#39;t have a reaper to pick up child exit status.
135      */
136 #ifdef __solaris__
137     pid = fork1();
138 #else
139     pid = fork();
140 #endif
141     if (pid != 0) {
142         if (pid &lt; 0) {
143             ThrowException(env, &quot;java/io/IOException&quot;, &quot;fork failed&quot;);
144         }
145         return;
146     }
147 
148     /*
149      * We need to close all file descriptors except for serviceFd. To
<span class="line-modified">150      * get the list of open file descriptos we read through /proc/self/fd</span>
151      * but to open this requires a file descriptor. We could use a specific
152      * file descriptor and fdopendir but Linux doesn&#39;t seem to support
153      * fdopendir. Instead we use opendir and make an assumption on the
154      * file descriptor that is used (by opening &amp; closing a file).
155      */
<span class="line-modified">156     thisFd = open(&quot;/dev/null&quot;, O_RDONLY);</span>
157     if (thisFd &lt; 0) {
158         _exit(-1);
159     }
<span class="line-removed">160     close(thisFd);</span>
161 
<span class="line-modified">162     if ((dp = opendir(&quot;/proc/self/fd&quot;)) == NULL) {</span>
163         _exit(-1);
164     }
165 
166     while ((dirp = readdir(dp)) != NULL) {
167         if (isdigit(dirp-&gt;d_name[0])) {
168             int fd = strtol(dirp-&gt;d_name, NULL, 10);
169             if (fd != serviceFd &amp;&amp; fd != thisFd) {
170                 close(fd);
171             }
172         }
173     }
174     closedir(dp);
175 
176     /*
177      * At this point all file descriptors are closed except for
178      * serviceFd. We not dup 0,1,2 to this file descriptor and
179      * close serviceFd. This should leave us with only 0,1,2
180      * open and all connected to the same socket.
181      */
182     dup2(serviceFd, STDIN_FILENO);
</pre>
<hr />
<pre>
199  * Method:    socketpair
200  * Signature: ()[LUnixDomainSocket
201  */
202 JNIEXPORT jobjectArray JNICALL Java_UnixDomainSocket_socketpair
203   (JNIEnv *env, jclass cls)
204 {
205     int fds[2];
206     jobject socket;
207     jobjectArray result = (*env)-&gt;NewObjectArray(env, 2, unixSocketClass, 0);
208     if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds) &lt; 0) {
209         perror(&quot;socketpair&quot;);
210         return result;
211     }
212     socket = (*env)-&gt;NewObject(env, unixSocketClass, unixSocketCtor, fds[0]);
213     (*env)-&gt;SetObjectArrayElement(env, result, 0, socket);
214     socket = (*env)-&gt;NewObject(env, unixSocketClass, unixSocketCtor, fds[1]);
215     (*env)-&gt;SetObjectArrayElement(env, result, 1, socket);
216     return result;
217 }
218 































































219 JNIEXPORT jint JNICALL Java_UnixDomainSocket_read0
220   (JNIEnv *env, jclass cls, jint fd)
221 {
222     int ret;
223     unsigned char res;
224     ret = read(fd, &amp;res, 1);
225     if (ret == 0)
226         return -1; /* EOF */
227     else if (ret &lt; 0) {
228         ThrowException(env, &quot;java/io/IOException&quot;, &quot;read error&quot;);
229         return -1;
230     }
231     return res;
232 }
233 
234 JNIEXPORT void JNICALL Java_UnixDomainSocket_write0
235   (JNIEnv *env, jclass cls, jint fd, jint byte)
236 {
237     int ret;
238     unsigned char w = (unsigned char)byte;
239     ret = write(fd, &amp;w, 1);
240     if (ret &lt; 0) {
241         ThrowException(env, &quot;java/io/IOException&quot;, &quot;write error&quot;);
242     }
243 }
244 
245 JNIEXPORT void JNICALL Java_UnixDomainSocket_close0
<span class="line-modified">246   (JNIEnv *env, jclass cls, jint fd)</span>
247 {
248     close(fd);





249 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * A simple launcher to launch a program as if it was launched by inetd.
 26  */
 27 #include &lt;stdio.h&gt;
 28 #include &lt;stdlib.h&gt;
<span class="line-added"> 29 #include &lt;string.h&gt;</span>
 30 #include &lt;sys/types.h&gt;
 31 #include &lt;sys/socket.h&gt;
<span class="line-added"> 32 #include &lt;sys/un.h&gt;</span>
 33 #include &lt;unistd.h&gt;
 34 #include &lt;dirent.h&gt;
 35 #include &lt;sys/stat.h&gt;
 36 #include &lt;fcntl.h&gt;
 37 #include &lt;ctype.h&gt;
 38 
 39 #include &quot;jni.h&quot;
 40 
 41 #define CHECK(X) if ((X) == 0) {printf(&quot;JNI init error line %d\n&quot;, __LINE__); _exit(1);}
 42 
 43 static jclass unixSocketClass;
 44 static jmethodID unixSocketCtor;
 45 
 46 /*
 47  * Throws the exception of the given class name and detail message
 48  */
 49 static void ThrowException(JNIEnv *env, const char *name, const char *msg) {
 50     jclass cls = (*env)-&gt;FindClass(env, name);
 51     if (cls != NULL) {
 52         (*env)-&gt;ThrowNew(env, cls, msg);
</pre>
<hr />
<pre>
132     cmdv[cmdlen] = NULL;
133 
134     /*
135      * Launch the program. As this isn&#39;t a complete inetd or Runtime.exec
136      * implementation we don&#39;t have a reaper to pick up child exit status.
137      */
138 #ifdef __solaris__
139     pid = fork1();
140 #else
141     pid = fork();
142 #endif
143     if (pid != 0) {
144         if (pid &lt; 0) {
145             ThrowException(env, &quot;java/io/IOException&quot;, &quot;fork failed&quot;);
146         }
147         return;
148     }
149 
150     /*
151      * We need to close all file descriptors except for serviceFd. To
<span class="line-modified">152      * get the list of open file descriptos we read through /proc/self/fd (/dev/fd)</span>
153      * but to open this requires a file descriptor. We could use a specific
154      * file descriptor and fdopendir but Linux doesn&#39;t seem to support
155      * fdopendir. Instead we use opendir and make an assumption on the
156      * file descriptor that is used (by opening &amp; closing a file).
157      */
<span class="line-modified">158     thisFd = open(&quot;/dev/fd&quot;, O_RDONLY);</span>
159     if (thisFd &lt; 0) {
160         _exit(-1);
161     }

162 
<span class="line-modified">163     if ((dp = fdopendir(thisFd)) == NULL) {</span>
164         _exit(-1);
165     }
166 
167     while ((dirp = readdir(dp)) != NULL) {
168         if (isdigit(dirp-&gt;d_name[0])) {
169             int fd = strtol(dirp-&gt;d_name, NULL, 10);
170             if (fd != serviceFd &amp;&amp; fd != thisFd) {
171                 close(fd);
172             }
173         }
174     }
175     closedir(dp);
176 
177     /*
178      * At this point all file descriptors are closed except for
179      * serviceFd. We not dup 0,1,2 to this file descriptor and
180      * close serviceFd. This should leave us with only 0,1,2
181      * open and all connected to the same socket.
182      */
183     dup2(serviceFd, STDIN_FILENO);
</pre>
<hr />
<pre>
200  * Method:    socketpair
201  * Signature: ()[LUnixDomainSocket
202  */
203 JNIEXPORT jobjectArray JNICALL Java_UnixDomainSocket_socketpair
204   (JNIEnv *env, jclass cls)
205 {
206     int fds[2];
207     jobject socket;
208     jobjectArray result = (*env)-&gt;NewObjectArray(env, 2, unixSocketClass, 0);
209     if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds) &lt; 0) {
210         perror(&quot;socketpair&quot;);
211         return result;
212     }
213     socket = (*env)-&gt;NewObject(env, unixSocketClass, unixSocketCtor, fds[0]);
214     (*env)-&gt;SetObjectArrayElement(env, result, 0, socket);
215     socket = (*env)-&gt;NewObject(env, unixSocketClass, unixSocketCtor, fds[1]);
216     (*env)-&gt;SetObjectArrayElement(env, result, 1, socket);
217     return result;
218 }
219 
<span class="line-added">220 JNIEXPORT jint JNICALL Java_UnixDomainSocket_create</span>
<span class="line-added">221   (JNIEnv *env, jclass cls)</span>
<span class="line-added">222 {</span>
<span class="line-added">223     int sock = socket(AF_UNIX, SOCK_STREAM, 0);</span>
<span class="line-added">224     if (sock == -1) {</span>
<span class="line-added">225         ThrowException(env, &quot;java/io/IOException&quot;, &quot;socket create error&quot;);</span>
<span class="line-added">226     }</span>
<span class="line-added">227     return sock;</span>
<span class="line-added">228 }</span>
<span class="line-added">229 </span>
<span class="line-added">230 JNIEXPORT void JNICALL Java_UnixDomainSocket_bind0</span>
<span class="line-added">231   (JNIEnv *env, jclass cls, jint sock, jstring name)</span>
<span class="line-added">232 {</span>
<span class="line-added">233     struct sockaddr_un addr;</span>
<span class="line-added">234     const char *nameUtf = (*env)-&gt;GetStringUTFChars(env, name, NULL);</span>
<span class="line-added">235     int ret = -1;</span>
<span class="line-added">236     int length = sizeof(addr.sun_path);</span>
<span class="line-added">237     unlink(nameUtf);</span>
<span class="line-added">238     memset(&amp;addr, 0, sizeof(addr));</span>
<span class="line-added">239     addr.sun_family = AF_UNIX;</span>
<span class="line-added">240     strncpy(addr.sun_path, nameUtf, length);</span>
<span class="line-added">241     addr.sun_path[length - 1] = &#39;\0&#39;;</span>
<span class="line-added">242     ret = bind(sock, (const struct sockaddr*)&amp;addr, sizeof(addr));</span>
<span class="line-added">243     if (ret == -1) {</span>
<span class="line-added">244         ThrowException(env, &quot;java/io/IOException&quot;, &quot;socket bind error&quot;);</span>
<span class="line-added">245     }</span>
<span class="line-added">246     ret = listen(sock, 5);</span>
<span class="line-added">247     if (ret == -1) {</span>
<span class="line-added">248         ThrowException(env, &quot;java/io/IOException&quot;, &quot;socket bind error&quot;);</span>
<span class="line-added">249     }</span>
<span class="line-added">250     (*env)-&gt;ReleaseStringUTFChars(env, name, nameUtf);</span>
<span class="line-added">251 }</span>
<span class="line-added">252 </span>
<span class="line-added">253 JNIEXPORT jint JNICALL Java_UnixDomainSocket_accept0</span>
<span class="line-added">254   (JNIEnv *env, jclass cls, jint sock)</span>
<span class="line-added">255 {</span>
<span class="line-added">256     struct sockaddr_storage addr;</span>
<span class="line-added">257     socklen_t len = sizeof(addr);</span>
<span class="line-added">258     int ret = accept(sock, (struct sockaddr *)&amp;addr, &amp;len);</span>
<span class="line-added">259     if (ret == -1)</span>
<span class="line-added">260         ThrowException(env, &quot;java/io/IOException&quot;, &quot;socket accept error&quot;);</span>
<span class="line-added">261     return ret;</span>
<span class="line-added">262 }</span>
<span class="line-added">263 </span>
<span class="line-added">264 JNIEXPORT void JNICALL Java_UnixDomainSocket_connect0</span>
<span class="line-added">265   (JNIEnv *env, jclass cls, jint fd, jstring name)</span>
<span class="line-added">266 {</span>
<span class="line-added">267     struct sockaddr_un addr;</span>
<span class="line-added">268     const char *nameUtf = (*env)-&gt;GetStringUTFChars(env, name, NULL);</span>
<span class="line-added">269     int ret = -1;</span>
<span class="line-added">270     int length = sizeof(addr.sun_path);</span>
<span class="line-added">271     memset(&amp;addr, 0, sizeof(addr));</span>
<span class="line-added">272     addr.sun_family = AF_UNIX;</span>
<span class="line-added">273     strncpy(addr.sun_path, nameUtf, length);</span>
<span class="line-added">274     addr.sun_path[length - 1] = &#39;\0&#39;;</span>
<span class="line-added">275     ret = connect(fd, (const struct sockaddr*)&amp;addr, sizeof(addr));</span>
<span class="line-added">276     if (ret == -1) {</span>
<span class="line-added">277         ThrowException(env, &quot;java/io/IOException&quot;, &quot;socket connect error&quot;);</span>
<span class="line-added">278     }</span>
<span class="line-added">279     (*env)-&gt;ReleaseStringUTFChars(env, name, nameUtf);</span>
<span class="line-added">280 }</span>
<span class="line-added">281 </span>
<span class="line-added">282 </span>
283 JNIEXPORT jint JNICALL Java_UnixDomainSocket_read0
284   (JNIEnv *env, jclass cls, jint fd)
285 {
286     int ret;
287     unsigned char res;
288     ret = read(fd, &amp;res, 1);
289     if (ret == 0)
290         return -1; /* EOF */
291     else if (ret &lt; 0) {
292         ThrowException(env, &quot;java/io/IOException&quot;, &quot;read error&quot;);
293         return -1;
294     }
295     return res;
296 }
297 
298 JNIEXPORT void JNICALL Java_UnixDomainSocket_write0
299   (JNIEnv *env, jclass cls, jint fd, jint byte)
300 {
301     int ret;
302     unsigned char w = (unsigned char)byte;
303     ret = write(fd, &amp;w, 1);
304     if (ret &lt; 0) {
305         ThrowException(env, &quot;java/io/IOException&quot;, &quot;write error&quot;);
306     }
307 }
308 
309 JNIEXPORT void JNICALL Java_UnixDomainSocket_close0
<span class="line-modified">310   (JNIEnv *env, jclass cls, jint fd, jstring name)</span>
311 {
312     close(fd);
<span class="line-added">313     if (name != NULL) {</span>
<span class="line-added">314         const char *nameUtf = (*env)-&gt;GetStringUTFChars(env, name, NULL);</span>
<span class="line-added">315         unlink(nameUtf);</span>
<span class="line-added">316         (*env)-&gt;ReleaseStringUTFChars(env, name, nameUtf);</span>
<span class="line-added">317     }</span>
318 }
</pre>
</td>
</tr>
</table>
<center><a href="UnixDomainSocket.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../charset/coders/Check.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
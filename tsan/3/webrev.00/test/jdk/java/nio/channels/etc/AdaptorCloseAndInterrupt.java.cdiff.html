<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/java/nio/channels/etc/AdaptorCloseAndInterrupt.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../SocketChannel/AdaptSocket.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PrintSupportedOptions.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/nio/channels/etc/AdaptorCloseAndInterrupt.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 20,11 ***</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  /* @test
<span class="line-modified">!  * @bug 7184932</span>
   * @summary Test asynchronous close and interrupt of timed socket adapter methods
   * @key randomness intermittent
   */
  
  import java.io.*;
<span class="line-new-header">--- 20,11 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  /* @test
<span class="line-modified">!  * @bug 7184932 8232673</span>
   * @summary Test asynchronous close and interrupt of timed socket adapter methods
   * @key randomness intermittent
   */
  
  import java.io.*;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 76,12 ***</span>
                  new AdaptorCloseAndInterrupt(listener).scReadAsyncInterrupt();
              }
  
              try (DatagramChannel peer = DatagramChannel.open()) {
                  peer.socket().bind(null);
<span class="line-modified">!                 new AdaptorCloseAndInterrupt(peer).dcReceiveAsyncClose();</span>
<span class="line-modified">!                 new AdaptorCloseAndInterrupt(peer).dcReceiveAsyncInterrupt();</span>
              }
  
              new AdaptorCloseAndInterrupt().ssAcceptAsyncClose();
              new AdaptorCloseAndInterrupt().ssAcceptAsyncInterrupt();
          } finally {
<span class="line-new-header">--- 76,14 ---</span>
                  new AdaptorCloseAndInterrupt(listener).scReadAsyncInterrupt();
              }
  
              try (DatagramChannel peer = DatagramChannel.open()) {
                  peer.socket().bind(null);
<span class="line-modified">!                 new AdaptorCloseAndInterrupt(peer).dcReceiveAsyncClose(0);</span>
<span class="line-modified">!                 new AdaptorCloseAndInterrupt(peer).dcReceiveAsyncClose(30_000);</span>
<span class="line-added">+                 new AdaptorCloseAndInterrupt(peer).dcReceiveAsyncInterrupt(0);</span>
<span class="line-added">+                 new AdaptorCloseAndInterrupt(peer).dcReceiveAsyncInterrupt(30_000);</span>
              }
  
              new AdaptorCloseAndInterrupt().ssAcceptAsyncClose();
              new AdaptorCloseAndInterrupt().ssAcceptAsyncInterrupt();
          } finally {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,40 ***</span>
              // accept connection and close it.
              listener.accept().close();
          }
      }
  
<span class="line-modified">!     void dcReceiveAsyncClose() throws IOException {</span>
          DatagramChannel dc = DatagramChannel.open();
<span class="line-modified">!         dc.connect(new InetSocketAddress(</span>
<span class="line-modified">!             InetAddress.getLoopbackAddress(), port));</span>
<span class="line-removed">-         dc.socket().setSoTimeout(30*1000);</span>
  
          doAsyncClose(dc);
  
          try {
              dc.socket().receive(new DatagramPacket(new byte[100], 100));
              System.err.format(&quot;close() was invoked: %s%n&quot;, isClosed.get());
              throw new RuntimeException(&quot;receive should not have completed&quot;);
<span class="line-modified">!         } catch (ClosedChannelException expected) {}</span>
  
          if (!dc.socket().isClosed())
              throw new RuntimeException(&quot;socket is not closed&quot;);
      }
  
<span class="line-modified">!     void dcReceiveAsyncInterrupt() throws IOException {</span>
          DatagramChannel dc = DatagramChannel.open();
<span class="line-modified">!         dc.connect(new InetSocketAddress(</span>
<span class="line-modified">!             InetAddress.getLoopbackAddress(), port));</span>
<span class="line-removed">-         dc.socket().setSoTimeout(30*1000);</span>
  
          doAsyncInterrupt();
  
          try {
              dc.socket().receive(new DatagramPacket(new byte[100], 100));
              throw new RuntimeException(&quot;receive should not have completed&quot;);
<span class="line-modified">!         } catch (ClosedByInterruptException expected) {</span>
              System.out.format(&quot;interrupt() was invoked: %s%n&quot;,
                  isInterrupted.get());
              System.out.format(&quot;dcReceiveAsyncInterrupt was interrupted: %s%n&quot;,
                  Thread.currentThread().interrupted());
          } catch (SocketTimeoutException unexpected) {
<span class="line-new-header">--- 138,38 ---</span>
              // accept connection and close it.
              listener.accept().close();
          }
      }
  
<span class="line-modified">!     void dcReceiveAsyncClose(int timeout) throws IOException {</span>
          DatagramChannel dc = DatagramChannel.open();
<span class="line-modified">!         dc.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), port));</span>
<span class="line-modified">!         dc.socket().setSoTimeout(timeout);</span>
  
          doAsyncClose(dc);
  
          try {
              dc.socket().receive(new DatagramPacket(new byte[100], 100));
              System.err.format(&quot;close() was invoked: %s%n&quot;, isClosed.get());
              throw new RuntimeException(&quot;receive should not have completed&quot;);
<span class="line-modified">!         } catch (SocketException expected) { }</span>
  
          if (!dc.socket().isClosed())
              throw new RuntimeException(&quot;socket is not closed&quot;);
      }
  
<span class="line-modified">!     void dcReceiveAsyncInterrupt(int timeout) throws IOException {</span>
          DatagramChannel dc = DatagramChannel.open();
<span class="line-modified">!         dc.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), port));</span>
<span class="line-modified">!         dc.socket().setSoTimeout(timeout);</span>
  
          doAsyncInterrupt();
  
          try {
              dc.socket().receive(new DatagramPacket(new byte[100], 100));
              throw new RuntimeException(&quot;receive should not have completed&quot;);
<span class="line-modified">!         } catch (SocketException expected) {</span>
              System.out.format(&quot;interrupt() was invoked: %s%n&quot;,
                  isInterrupted.get());
              System.out.format(&quot;dcReceiveAsyncInterrupt was interrupted: %s%n&quot;,
                  Thread.currentThread().interrupted());
          } catch (SocketTimeoutException unexpected) {
</pre>
<center><a href="../SocketChannel/AdaptSocket.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PrintSupportedOptions.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
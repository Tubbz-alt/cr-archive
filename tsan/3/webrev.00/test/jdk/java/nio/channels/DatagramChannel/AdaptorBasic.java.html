<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/nio/channels/DatagramChannel/AdaptorBasic.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 4313882 4981129 8143610 8232673
 26  * @summary Unit test for datagram-socket-channel adaptors
 27  * @modules java.base/java.net:+open
 28  * @library .. /test/lib
 29  * @build jdk.test.lib.Utils TestServers
 30  * @run main AdaptorBasic
 31  * @key randomness
 32  */
 33 
 34 import java.net.*;
 35 import java.nio.channels.*;
 36 import java.util.*;
 37 import java.lang.reflect.Field;
 38 
 39 
 40 public class AdaptorBasic {
 41 
 42     static java.io.PrintStream out = System.out;
 43     static Random rand = new Random();
 44 
 45     static String toString(DatagramPacket dp) {
 46         return (&quot;DatagramPacket[off=&quot; + dp.getOffset()
 47                 + &quot;, len=&quot; + dp.getLength()
 48                 + &quot;]&quot;);
 49     }
 50 
 51     static int getBufLength(DatagramPacket p) throws Exception {
 52         Field f = DatagramPacket.class.getDeclaredField(&quot;bufLength&quot;);
 53         f.setAccessible(true);
 54         return (int) f.get(p);
 55     }
 56 
 57     static void test(DatagramSocket ds, InetSocketAddress dst, boolean shouldTimeout)
 58         throws Exception
 59     {
 60         DatagramPacket op = new DatagramPacket(new byte[100], 13, 42, dst);
 61         rand.nextBytes(op.getData());
 62         int bufLength = 100 - 19;
 63         DatagramPacket ip = new DatagramPacket(new byte[100], 19, bufLength);
 64         out.println(&quot;pre  op: &quot; + toString(op) + &quot;  ip: &quot; + toString(ip));
 65 
 66         long start = System.currentTimeMillis();
 67         ds.send(op);
 68 
 69         for (;;) {
 70             try {
 71                 ds.receive(ip);
 72             } catch (SocketTimeoutException x) {
 73                 if (shouldTimeout) {
 74                     out.println(&quot;Receive timed out, as expected&quot;);
 75                     return;
 76                 }
 77                 throw x;
 78             }
 79             break;
 80         }
 81 
 82         out.println(&quot;rtt: &quot; + (System.currentTimeMillis() - start));
 83         out.println(&quot;post op: &quot; + toString(op) + &quot;  ip: &quot; + toString(ip));
 84 
 85         for (int i = 0; i &lt; ip.getLength(); i++) {
 86             if (ip.getData()[ip.getOffset() + i]
 87                 != op.getData()[op.getOffset() + i])
 88                 throw new Exception(&quot;Incorrect data received&quot;);
 89         }
 90 
 91         if (!(ip.getSocketAddress().equals(dst))) {
 92             throw new Exception(&quot;Incorrect sender address, expected: &quot; + dst
 93                 + &quot; actual: &quot; + ip.getSocketAddress());
 94         }
 95 
 96         if (getBufLength(ip) != bufLength) {
 97             throw new Exception(&quot;DatagramPacket bufLength changed by receive!!!&quot;);
 98         }
 99     }
100 
101     static void test(InetSocketAddress dst,
102                      int timeout, boolean shouldTimeout,
103                      boolean connect)
104         throws Exception
105     {
106         out.println();
107         out.println(&quot;dst: &quot; + dst);
108 
109         DatagramSocket ds;
110         if (false) {
111             // Original
112             ds = new DatagramSocket();
113         } else {
114             DatagramChannel dc = DatagramChannel.open();
115             ds = dc.socket();
116             ds.bind(new InetSocketAddress(0));
117         }
118 
119         out.println(&quot;socket: &quot; + ds);
120         if (connect) {
121             ds.connect(dst);
122             out.println(&quot;connect: &quot; + ds);
123         }
124         InetSocketAddress src = new InetSocketAddress(ds.getLocalAddress(),
125                                                       ds.getLocalPort());
126         out.println(&quot;src: &quot; + src);
127 
128         if (timeout &gt; 0)
129             ds.setSoTimeout(timeout);
130         out.println(&quot;timeout: &quot; + ds.getSoTimeout());
131 
132         for (int i = 0; i &lt; 5; i++) {
133             test(ds, dst, shouldTimeout);
134         }
135 
136         // Leave the socket open so that we don&#39;t reuse the old src address
137         //ds.close();
138 
139     }
140 
141     public static void main(String[] args) throws Exception {
142         // need an UDP echo server
143         try (TestServers.UdpEchoServer echoServer
144                 = TestServers.UdpEchoServer.startNewServer(100)) {
145             final InetSocketAddress address
146                 = new InetSocketAddress(echoServer.getAddress(),
147                                         echoServer.getPort());
148             test(address, 0, false, false);
149             test(address, 0, false, true);
150             test(address, Integer.MAX_VALUE, false, false);
151         }
152         try (TestServers.UdpDiscardServer discardServer
153                 = TestServers.UdpDiscardServer.startNewServer()) {
154             final InetSocketAddress address
155                 = new InetSocketAddress(discardServer.getAddress(),
156                                         discardServer.getPort());
157             test(address, 10, true, false);
158         }
159     }
160 
161 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/nio/channels/Selector/SelectWithConsumer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 8199433 8208780
 26  * @run testng SelectWithConsumer
 27  * @summary Unit test for Selector select(Consumer), select(Consumer,long) and
 28  *          selectNow(Consumer)
 29  */
 30 
 31 import java.io.Closeable;
 32 import java.io.IOException;
 33 import java.net.InetSocketAddress;
 34 import java.nio.ByteBuffer;
 35 import java.nio.channels.ClosedSelectorException;
 36 import java.nio.channels.Pipe;
 37 import java.nio.channels.SelectionKey;
 38 import java.nio.channels.Selector;
 39 import java.nio.channels.ServerSocketChannel;
 40 import java.nio.channels.SocketChannel;
 41 import java.nio.channels.WritableByteChannel;
 42 import java.util.concurrent.Executors;
 43 import java.util.concurrent.ScheduledExecutorService;
 44 import java.util.concurrent.TimeUnit;
 45 import java.util.concurrent.atomic.AtomicInteger;
 46 import static java.util.concurrent.TimeUnit.*;
 47 
 48 import org.testng.annotations.AfterTest;
 49 import org.testng.annotations.Test;
 50 import static org.testng.Assert.*;
 51 
 52 @Test
 53 public class SelectWithConsumer {
 54 
 55     /**
 56      * Invoke the select methods that take an action and check that the
 57      * accumulated ready ops notified to the action matches the expected ops.
 58      */
 59     void testActionInvoked(SelectionKey key, int expectedOps) throws Exception {
 60         var callerThread = Thread.currentThread();
 61         var sel = key.selector();
 62         var interestOps = key.interestOps();
 63         var notifiedOps = new AtomicInteger();
 64 
 65         if (expectedOps == 0) {
 66             // ensure select(Consumer) does not block indefinitely
 67             sel.wakeup();
 68         } else {
 69             // ensure that the channel is ready for all expected operations
 70             sel.select();
 71             while ((key.readyOps() &amp; interestOps) != expectedOps) {
 72                 Thread.sleep(100);
 73                 sel.select();
 74             }
 75         }
 76 
 77         // select(Consumer)
 78         notifiedOps.set(0);
 79         int n = sel.select(k -&gt; {
 80             assertTrue(Thread.currentThread() == callerThread);
 81             assertTrue(k == key);
 82             int readyOps = key.readyOps();
 83             assertTrue((readyOps &amp; interestOps) != 0);
 84             assertTrue((readyOps &amp; notifiedOps.get()) == 0);
 85             notifiedOps.set(notifiedOps.get() | readyOps);
 86         });
 87         assertTrue((n == 1) ^ (expectedOps == 0));
 88         assertTrue(notifiedOps.get() == expectedOps);
 89 
 90         // select(Consumer, timeout)
 91         notifiedOps.set(0);
 92         n = sel.select(k -&gt; {
 93             assertTrue(Thread.currentThread() == callerThread);
 94             assertTrue(k == key);
 95             int readyOps = key.readyOps();
 96             assertTrue((readyOps &amp; interestOps) != 0);
 97             assertTrue((readyOps &amp; notifiedOps.get()) == 0);
 98             notifiedOps.set(notifiedOps.get() | readyOps);
 99         }, 1000);
100         assertTrue((n == 1) ^ (expectedOps == 0));
101         assertTrue(notifiedOps.get() == expectedOps);
102 
103         // selectNow(Consumer)
104         notifiedOps.set(0);
105         n = sel.selectNow(k -&gt; {
106             assertTrue(Thread.currentThread() == callerThread);
107             assertTrue(k == key);
108             int readyOps = key.readyOps();
109             assertTrue((readyOps &amp; interestOps) != 0);
110             assertTrue((readyOps &amp; notifiedOps.get()) == 0);
111             notifiedOps.set(notifiedOps.get() | readyOps);
112         });
113         assertTrue((n == 1) ^ (expectedOps == 0));
114         assertTrue(notifiedOps.get() == expectedOps);
115     }
116 
117     /**
118      * Test that an action is performed when a channel is ready for reading.
119      */
120     public void testReadable() throws Exception {
121         Pipe p = Pipe.open();
122         try (Selector sel = Selector.open()) {
123             Pipe.SinkChannel sink = p.sink();
124             Pipe.SourceChannel source = p.source();
125             source.configureBlocking(false);
126             SelectionKey key = source.register(sel, SelectionKey.OP_READ);
127 
128             // write to sink to ensure source is readable
129             scheduleWrite(sink, messageBuffer(), 100, MILLISECONDS);
130 
131             // test that action is invoked
132             testActionInvoked(key, SelectionKey.OP_READ);
133         } finally {
134             closePipe(p);
135         }
136     }
137 
138     /**
139      * Test that an action is performed when a channel is ready for writing.
140      */
141     public void testWritable() throws Exception {
142         Pipe p = Pipe.open();
143         try (Selector sel = Selector.open()) {
144             Pipe.SourceChannel source = p.source();
145             Pipe.SinkChannel sink = p.sink();
146             sink.configureBlocking(false);
147             SelectionKey key = sink.register(sel, SelectionKey.OP_WRITE);
148 
149             // test that action is invoked
150             testActionInvoked(key, SelectionKey.OP_WRITE);
151         } finally {
152             closePipe(p);
153         }
154     }
155 
156     /**
157      * Test that an action is performed when a channel is ready for both
158      * reading and writing.
159      */
160     public void testReadableAndWriteable() throws Exception {
161         ServerSocketChannel ssc = null;
162         SocketChannel sc = null;
163         SocketChannel peer = null;
164         try (Selector sel = Selector.open()) {
165             ssc = ServerSocketChannel.open().bind(new InetSocketAddress(0));
166             sc = SocketChannel.open(ssc.getLocalAddress());
167             sc.configureBlocking(false);
168             SelectionKey key = sc.register(sel, (SelectionKey.OP_READ |
169                                                  SelectionKey.OP_WRITE));
170 
171             // accept connection and write data so the source is readable
172             peer = ssc.accept();
173             peer.write(messageBuffer());
174 
175             // test that action is invoked
176             testActionInvoked(key, (SelectionKey.OP_READ | SelectionKey.OP_WRITE));
177         } finally {
178             if (ssc != null) ssc.close();
179             if (sc != null) sc.close();
180             if (peer != null) peer.close();
181         }
182     }
183 
184     /**
185      * Test that the action is called for two selected channels
186      */
187     public void testTwoChannels() throws Exception {
188         Pipe p = Pipe.open();
189         try (Selector sel = Selector.open()) {
190             Pipe.SourceChannel source = p.source();
191             Pipe.SinkChannel sink = p.sink();
192             source.configureBlocking(false);
193             sink.configureBlocking(false);
194             SelectionKey key1 = source.register(sel, SelectionKey.OP_READ);
195             SelectionKey key2 = sink.register(sel, SelectionKey.OP_WRITE);
196 
197             // write to sink to ensure that the source is readable
198             sink.write(messageBuffer());
199 
200             // wait for key1 to be readable
201             sel.select();
202             assertTrue(key2.isWritable());
203             while (!key1.isReadable()) {
204                 Thread.sleep(20);
205                 sel.select();
206             }
207 
208             var counter = new AtomicInteger();
209 
210             // select(Consumer)
211             counter.set(0);
212             int n = sel.select(k -&gt; {
213                 assertTrue(k == key1 || k == key2);
214                 counter.incrementAndGet();
215             });
216             assertTrue(n == 2);
217             assertTrue(counter.get() == 2);
218 
219             // select(Consumer, timeout)
220             counter.set(0);
221             n = sel.select(k -&gt; {
222                 assertTrue(k == key1 || k == key2);
223                 counter.incrementAndGet();
224             }, 1000);
225             assertTrue(n == 2);
226             assertTrue(counter.get() == 2);
227 
228             // selectNow(Consumer)
229             counter.set(0);
230             n = sel.selectNow(k -&gt; {
231                 assertTrue(k == key1 || k == key2);
232                 counter.incrementAndGet();
233             });
234             assertTrue(n == 2);
235             assertTrue(counter.get() == 2);
236         } finally {
237             closePipe(p);
238         }
239     }
240 
241     /**
242      * Test calling select twice, the action should be invoked each time
243      */
244     public void testRepeatedSelect1() throws Exception {
245         Pipe p = Pipe.open();
246         try (Selector sel = Selector.open()) {
247             Pipe.SourceChannel source = p.source();
248             Pipe.SinkChannel sink = p.sink();
249             source.configureBlocking(false);
250             SelectionKey key = source.register(sel, SelectionKey.OP_READ);
251 
252             // write to sink to ensure that the source is readable
253             sink.write(messageBuffer());
254 
255             // test that action is invoked
256             testActionInvoked(key, SelectionKey.OP_READ);
257             testActionInvoked(key, SelectionKey.OP_READ);
258 
259         } finally {
260             closePipe(p);
261         }
262     }
263 
264     /**
265      * Test calling select twice. An I/O operation is performed after the
266      * first select so the channel will not be selected by the second select.
267      */
268     public void testRepeatedSelect2() throws Exception {
269         Pipe p = Pipe.open();
270         try (Selector sel = Selector.open()) {
271             Pipe.SourceChannel source = p.source();
272             Pipe.SinkChannel sink = p.sink();
273             source.configureBlocking(false);
274             SelectionKey key = source.register(sel, SelectionKey.OP_READ);
275 
276             // write to sink to ensure that the source is readable
277             sink.write(messageBuffer());
278 
279             // test that action is invoked
280             testActionInvoked(key, SelectionKey.OP_READ);
281 
282             // read all bytes
283             int n;
284             ByteBuffer bb = ByteBuffer.allocate(100);
285             do {
286                 n = source.read(bb);
287                 bb.clear();
288             } while (n &gt; 0);
289 
290             // test that action is not invoked
291             testActionInvoked(key, 0);
292         } finally {
293             closePipe(p);
294         }
295     }
296 
297     /**
298      * Test timeout
299      */
300     public void testTimeout() throws Exception {
301         Pipe p = Pipe.open();
302         try (Selector sel = Selector.open()) {
303             Pipe.SourceChannel source = p.source();
304             Pipe.SinkChannel sink = p.sink();
305             source.configureBlocking(false);
306             source.register(sel, SelectionKey.OP_READ);
307             long start = System.currentTimeMillis();
308             int n = sel.select(k -&gt; assertTrue(false), 1000L);
309             long duration = System.currentTimeMillis() - start;
310             assertTrue(n == 0);
311             assertTrue(duration &gt; 500, &quot;select took &quot; + duration + &quot; ms&quot;);
312         } finally {
313             closePipe(p);
314         }
315     }
316 
317     /**
318      * Test wakeup prior to select
319      */
320     public void testWakeupBeforeSelect() throws Exception {
321         // select(Consumer)
322         try (Selector sel = Selector.open()) {
323             sel.wakeup();
324             int n = sel.select(k -&gt; assertTrue(false));
325             assertTrue(n == 0);
326         }
327 
328         // select(Consumer, timeout)
329         try (Selector sel = Selector.open()) {
330             sel.wakeup();
331             long start = System.currentTimeMillis();
332             int n = sel.select(k -&gt; assertTrue(false), 60*1000);
333             long duration = System.currentTimeMillis() - start;
334             assertTrue(n == 0);
335             assertTrue(duration &lt; 5000, &quot;select took &quot; + duration + &quot; ms&quot;);
336         }
337     }
338 
339     /**
340      * Test wakeup during select
341      */
342     public void testWakeupDuringSelect() throws Exception {
343         // select(Consumer)
344         try (Selector sel = Selector.open()) {
345             scheduleWakeup(sel, 1, SECONDS);
346             int n = sel.select(k -&gt; assertTrue(false));
347             assertTrue(n == 0);
348         }
349 
350         // select(Consumer, timeout)
351         try (Selector sel = Selector.open()) {
352             scheduleWakeup(sel, 1, SECONDS);
353             long start = System.currentTimeMillis();
354             int n = sel.select(k -&gt; assertTrue(false), 60*1000);
355             long duration = System.currentTimeMillis() - start;
356             assertTrue(n == 0);
357             assertTrue(duration &gt; 500 &amp;&amp; duration &lt; 10*1000,
358                     &quot;select took &quot; + duration + &quot; ms&quot;);
359         }
360     }
361 
362     /**
363      * Test invoking select with interrupt status set
364      */
365     public void testInterruptBeforeSelect() throws Exception {
366         // select(Consumer)
367         try (Selector sel = Selector.open()) {
368             Thread.currentThread().interrupt();
369             int n = sel.select(k -&gt; assertTrue(false));
370             assertTrue(n == 0);
371             assertTrue(Thread.currentThread().isInterrupted());
372             assertTrue(sel.isOpen());
373         } finally {
374             Thread.currentThread().interrupted();  // clear interrupt status
375         }
376 
377         // select(Consumer, timeout)
378         try (Selector sel = Selector.open()) {
379             Thread.currentThread().interrupt();
380             long start = System.currentTimeMillis();
381             int n = sel.select(k -&gt; assertTrue(false), 60*1000);
382             long duration = System.currentTimeMillis() - start;
383             assertTrue(n == 0);
384             assertTrue(duration &lt; 5000, &quot;select took &quot; + duration + &quot; ms&quot;);
385             assertTrue(Thread.currentThread().isInterrupted());
386             assertTrue(sel.isOpen());
387         } finally {
388             Thread.currentThread().interrupted();  // clear interrupt status
389         }
390     }
391 
392     /**
393      * Test interrupt thread during select
394      */
395     public void testInterruptDuringSelect() throws Exception {
396         // select(Consumer)
397         try (Selector sel = Selector.open()) {
398             scheduleInterrupt(Thread.currentThread(), 1, SECONDS);
399             int n = sel.select(k -&gt; assertTrue(false));
400             assertTrue(n == 0);
401             assertTrue(Thread.currentThread().isInterrupted());
402             assertTrue(sel.isOpen());
403         } finally {
404             Thread.currentThread().interrupted();  // clear interrupt status
405         }
406 
407         // select(Consumer, timeout)
408         try (Selector sel = Selector.open()) {
409             scheduleInterrupt(Thread.currentThread(), 1, SECONDS);
410             long start = System.currentTimeMillis();
411             int n = sel.select(k -&gt; assertTrue(false), 60*1000);
412             long duration = System.currentTimeMillis() - start;
413             assertTrue(n == 0);
414             assertTrue(Thread.currentThread().isInterrupted());
415             assertTrue(sel.isOpen());
416         } finally {
417             Thread.currentThread().interrupted();  // clear interrupt status
418         }
419     }
420 
421     /**
422      * Test invoking select on a closed selector
423      */
424     @Test(expectedExceptions = ClosedSelectorException.class)
425     public void testClosedSelector1() throws Exception {
426         Selector sel = Selector.open();
427         sel.close();
428         sel.select(k -&gt; assertTrue(false));
429     }
430     @Test(expectedExceptions = ClosedSelectorException.class)
431     public void testClosedSelector2() throws Exception {
432         Selector sel = Selector.open();
433         sel.close();
434         sel.select(k -&gt; assertTrue(false), 1000);
435     }
436     @Test(expectedExceptions = ClosedSelectorException.class)
437     public void testClosedSelector3() throws Exception {
438         Selector sel = Selector.open();
439         sel.close();
440         sel.selectNow(k -&gt; assertTrue(false));
441     }
442 
443     /**
444      * Test closing selector while in a selection operation
445      */
446     public void testCloseDuringSelect() throws Exception {
447         // select(Consumer)
448         try (Selector sel = Selector.open()) {
449             scheduleClose(sel, 3, SECONDS);
450             int n = sel.select(k -&gt; assertTrue(false));
451             assertTrue(n == 0);
452             assertFalse(sel.isOpen());
453         }
454 
455         // select(Consumer, timeout)
456         try (Selector sel = Selector.open()) {
457             long before = System.nanoTime();
458             scheduleClose(sel, 3, SECONDS);
459             long start = System.nanoTime();
460             int n = sel.select(k -&gt; assertTrue(false), 60*1000);
461             long after = System.nanoTime();
462             long selectDuration = (after - start) / 1000000;
463             long scheduleDuration = (start - before) / 1000000;
464             assertTrue(n == 0);
465             assertTrue(selectDuration &gt; 2000 &amp;&amp; selectDuration &lt; 10*1000,
466                     &quot;select took &quot; + selectDuration + &quot; ms schedule took &quot; +
467                     scheduleDuration + &quot; ms&quot;);
468             assertFalse(sel.isOpen());
469         }
470     }
471 
472     /**
473      * Test action closing selector
474      */
475     @Test(expectedExceptions = ClosedSelectorException.class)
476     public void testActionClosingSelector() throws Exception {
477         Pipe p = Pipe.open();
478         try (Selector sel = Selector.open()) {
479             Pipe.SourceChannel source = p.source();
480             Pipe.SinkChannel sink = p.sink();
481             source.configureBlocking(false);
482             SelectionKey key = source.register(sel, SelectionKey.OP_READ);
483 
484             // write to sink to ensure that the source is readable
485             sink.write(messageBuffer());
486 
487             // should relay ClosedSelectorException
488             sel.select(k -&gt; {
489                 assertTrue(k == key);
490                 try {
491                     sel.close();
492                 } catch (IOException ioe) { }
493             });
494         } finally {
495             closePipe(p);
496         }
497     }
498 
499     /**
500      * Test that the action is invoked while synchronized on the selector and
501      * its selected-key set.
502      */
503     public void testLocks() throws Exception {
504         Pipe p = Pipe.open();
505         try (Selector sel = Selector.open()) {
506             Pipe.SourceChannel source = p.source();
507             Pipe.SinkChannel sink = p.sink();
508             source.configureBlocking(false);
509             SelectionKey key = source.register(sel, SelectionKey.OP_READ);
510 
511             // write to sink to ensure that the source is readable
512             sink.write(messageBuffer());
513 
514             // select(Consumer)
515             sel.select(k -&gt; {
516                 assertTrue(k == key);
517                 assertTrue(Thread.holdsLock(sel));
518                 assertFalse(Thread.holdsLock(sel.keys()));
519                 assertTrue(Thread.holdsLock(sel.selectedKeys()));
520             });
521 
522             // select(Consumer, timeout)
523             sel.select(k -&gt; {
524                 assertTrue(k == key);
525                 assertTrue(Thread.holdsLock(sel));
526                 assertFalse(Thread.holdsLock(sel.keys()));
527                 assertTrue(Thread.holdsLock(sel.selectedKeys()));
528             }, 1000L);
529 
530             // selectNow(Consumer)
531             sel.selectNow(k -&gt; {
532                 assertTrue(k == key);
533                 assertTrue(Thread.holdsLock(sel));
534                 assertFalse(Thread.holdsLock(sel.keys()));
535                 assertTrue(Thread.holdsLock(sel.selectedKeys()));
536             });
537         } finally {
538             closePipe(p);
539         }
540     }
541 
542     /**
543      * Test that selection operations remove cancelled keys from the selector&#39;s
544      * key and selected-key sets.
545      */
546     public void testCancel() throws Exception {
547         Pipe p = Pipe.open();
548         try (Selector sel = Selector.open()) {
549             Pipe.SinkChannel sink = p.sink();
550             Pipe.SourceChannel source = p.source();
551 
552             // write to sink to ensure that the source is readable
553             sink.write(messageBuffer());
554 
555             source.configureBlocking(false);
556             SelectionKey key1 = source.register(sel, SelectionKey.OP_READ);
557             // make sure pipe source is readable before we do following checks.
558             // this is sometime necessary on windows where pipe is implemented
559             // as a pair of connected socket, so there is no guarantee that written
560             // bytes on sink side is immediately available on source side.
561             sel.select();
562 
563             sink.configureBlocking(false);
564             SelectionKey key2 = sink.register(sel, SelectionKey.OP_WRITE);
565             sel.selectNow();
566 
567             assertTrue(sel.keys().contains(key1));
568             assertTrue(sel.keys().contains(key2));
569             assertTrue(sel.selectedKeys().contains(key1));
570             assertTrue(sel.selectedKeys().contains(key2));
571 
572             // cancel key1
573             key1.cancel();
574             int n = sel.selectNow(k -&gt; assertTrue(k == key2));
575             assertTrue(n == 1);
576             assertFalse(sel.keys().contains(key1));
577             assertTrue(sel.keys().contains(key2));
578             assertFalse(sel.selectedKeys().contains(key1));
579             assertTrue(sel.selectedKeys().contains(key2));
580 
581             // cancel key2
582             key2.cancel();
583             n = sel.selectNow(k -&gt; assertTrue(false));
584             assertTrue(n == 0);
585             assertFalse(sel.keys().contains(key1));
586             assertFalse(sel.keys().contains(key2));
587             assertFalse(sel.selectedKeys().contains(key1));
588             assertFalse(sel.selectedKeys().contains(key2));
589         } finally {
590             closePipe(p);
591         }
592     }
593 
594     /**
595      * Test an action invoking select()
596      */
597     public void testReentrantSelect1() throws Exception {
598         Pipe p = Pipe.open();
599         try (Selector sel = Selector.open()) {
600             Pipe.SinkChannel sink = p.sink();
601             Pipe.SourceChannel source = p.source();
602             source.configureBlocking(false);
603             source.register(sel, SelectionKey.OP_READ);
604 
605             // write to sink to ensure that the source is readable
606             scheduleWrite(sink, messageBuffer(), 100, MILLISECONDS);
607 
608             int n = sel.select(k -&gt; {
609                 try {
610                     sel.select();
611                     assertTrue(false);
612                 } catch (IOException ioe) {
613                     throw new RuntimeException(ioe);
614                 } catch (IllegalStateException expected) {
615                 }
616             });
617             assertTrue(n == 1);
618         } finally {
619             closePipe(p);
620         }
621     }
622 
623     /**
624      * Test an action invoking selectNow()
625      */
626     public void testReentrantSelect2() throws Exception {
627         Pipe p = Pipe.open();
628         try (Selector sel = Selector.open()) {
629             Pipe.SinkChannel sink = p.sink();
630             Pipe.SourceChannel source = p.source();
631 
632             // write to sink to ensure that the source is readable
633             scheduleWrite(sink, messageBuffer(), 100, MILLISECONDS);
634 
635             source.configureBlocking(false);
636             source.register(sel, SelectionKey.OP_READ);
637             int n = sel.select(k -&gt; {
638                 try {
639                     sel.selectNow();
640                     assertTrue(false);
641                 } catch (IOException ioe) {
642                     throw new RuntimeException(ioe);
643                 } catch (IllegalStateException expected) {
644                 }
645             });
646             assertTrue(n == 1);
647         } finally {
648             closePipe(p);
649         }
650     }
651 
652     /**
653      * Test an action invoking select(Consumer)
654      */
655     public void testReentrantSelect3() throws Exception {
656         Pipe p = Pipe.open();
657         try (Selector sel = Selector.open()) {
658             Pipe.SinkChannel sink = p.sink();
659             Pipe.SourceChannel source = p.source();
660 
661             // write to sink to ensure that the source is readable
662             scheduleWrite(sink, messageBuffer(), 100, MILLISECONDS);
663 
664             source.configureBlocking(false);
665             source.register(sel, SelectionKey.OP_READ);
666             int n = sel.select(k -&gt; {
667                 try {
668                     sel.select(x -&gt; assertTrue(false));
669                     assertTrue(false);
670                 } catch (IOException ioe) {
671                     throw new RuntimeException(ioe);
672                 } catch (IllegalStateException expected) {
673                 }
674             });
675             assertTrue(n == 1);
676         } finally {
677             closePipe(p);
678         }
679     }
680 
681     /**
682      * Negative timeout
683      */
684     @Test(expectedExceptions = IllegalArgumentException.class)
685     public void testNegativeTimeout() throws Exception {
686         try (Selector sel = Selector.open()) {
687             sel.select(k -&gt; { }, -1L);
688         }
689     }
690 
691     /**
692      * Null action
693      */
694     @Test(expectedExceptions = NullPointerException.class)
695     public void testNull1() throws Exception {
696         try (Selector sel = Selector.open()) {
697             sel.select(null);
698         }
699     }
700     @Test(expectedExceptions = NullPointerException.class)
701     public void testNull2() throws Exception {
702         try (Selector sel = Selector.open()) {
703             sel.select(null, 1000);
704         }
705     }
706     @Test(expectedExceptions = NullPointerException.class)
707     public void testNull3() throws Exception {
708         try (Selector sel = Selector.open()) {
709             sel.selectNow(null);
710         }
711     }
712 
713 
714     // -- support methods ---
715 
716     private final ScheduledExecutorService POOL = Executors.newScheduledThreadPool(1);
717 
718     @AfterTest
719     void shutdownThreadPool() {
720         POOL.shutdown();
721     }
722 
723     void scheduleWakeup(Selector sel, long delay, TimeUnit unit) {
724         POOL.schedule(() -&gt; sel.wakeup(), delay, unit);
725     }
726 
727     void scheduleInterrupt(Thread t, long delay, TimeUnit unit) {
728         POOL.schedule(() -&gt; t.interrupt(), delay, unit);
729     }
730 
731     void scheduleClose(Closeable c, long delay, TimeUnit unit) {
732         POOL.schedule(() -&gt; {
733             try {
734                 c.close();
735             } catch (IOException ioe) {
736                 ioe.printStackTrace();
737             }
738         }, delay, unit);
739     }
740 
741     void scheduleWrite(WritableByteChannel sink, ByteBuffer buf, long delay, TimeUnit unit) {
742         POOL.schedule(() -&gt; {
743             try {
744                 sink.write(buf);
745             } catch (IOException ioe) {
746                 ioe.printStackTrace();
747             }
748         }, delay, unit);
749     }
750 
751     static void closePipe(Pipe p) {
752         try { p.sink().close(); } catch (IOException ignore) { }
753         try { p.source().close(); } catch (IOException ignore) { }
754     }
755 
756     static ByteBuffer messageBuffer() {
757         try {
758             return ByteBuffer.wrap(&quot;message&quot;.getBytes(&quot;UTF-8&quot;));
759         } catch (Exception e) {
760             throw new RuntimeException(e);
761         }
762     }
763 }
    </pre>
  </body>
</html>
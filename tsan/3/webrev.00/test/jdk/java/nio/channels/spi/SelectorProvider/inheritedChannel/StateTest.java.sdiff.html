<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/nio/channels/spi/SelectorProvider/inheritedChannel/StateTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Launcher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnixDomainSocket.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/nio/channels/spi/SelectorProvider/inheritedChannel/StateTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  *
 26  *
 27  * Tests that the channel returned by System.inheritedChannel()
 28  * is in blocking mode, bound, and in the case of a SocketChannel
 29  * connected to a peer.
 30  *
 31  * The test works by launching a test service (called StateTestService) so
 32  * that it inherits each type of channel. The test service checks the
 33  * socket state and replies back to this class via an out-of-band
 34  * channel.
 35  */
 36 import java.io.IOException;
 37 import java.net.InetSocketAddress;

 38 import java.nio.ByteBuffer;
 39 import java.nio.channels.DatagramChannel;
 40 import java.nio.channels.SelectionKey;
 41 import java.nio.channels.Selector;
 42 import java.nio.channels.ServerSocketChannel;
 43 import java.nio.channels.SocketChannel;
 44 
 45 import jdk.test.lib.Utils;
 46 
 47 public class StateTest {
 48 
 49     private static int failures = 0;
 50 
 51     private static String TEST_SERVICE = &quot;StateTestService&quot;;
 52 
 53     /*
 54      * Reads the test result from the &quot;out-of-band&quot; connection to the test service.
 55      *
 56      * The out-of-band connection is just a TCP connection from the service to
 57      * this class. waitForTestResult just waits (with timeout) for the service
 58      * to connect. Once connected it waits (with timeout) for the test result.
 59      * The test result is examined.
 60      */
 61     private static void waitForTestResult(ServerSocketChannel ssc, boolean expectFail) throws IOException {
 62         Selector sel = ssc.provider().openSelector();
 63         SelectionKey sk;
 64         SocketChannel sc;
 65 
 66         /*
 67          * Wait for service to connect
 68          */

 69         ssc.configureBlocking(false);
 70         sk = ssc.register(sel, SelectionKey.OP_ACCEPT);
 71         long to = Utils.adjustTimeout(15*1000);
 72         sc = null;
 73         for (;;) {
 74             long st = System.currentTimeMillis();
 75             sel.select(to);
 76             if (sk.isAcceptable() &amp;&amp; ((sc = ssc.accept()) != null)) {
 77                 // connection established
 78                 break;
 79             }
 80             sel.selectedKeys().remove(sk);
 81             to -= System.currentTimeMillis() - st;
 82             if (to &lt;= 0) {
 83                 throw new IOException(&quot;Timed out waiting for service to report test result&quot;);
 84             }
 85         }
 86         sk.cancel();
 87         ssc.configureBlocking(false);
 88 
 89         /*
 90          * Wait for service to report test result
 91          */

 92         sc.configureBlocking(false);
 93         sk = sc.register(sel, SelectionKey.OP_READ);
 94         to = Utils.adjustTimeout(5000);
 95         ByteBuffer bb = ByteBuffer.allocateDirect(20);
 96         for (;;) {
 97             long st = System.currentTimeMillis();
 98             sel.select(to);
 99             if (sk.isReadable()) {
100                 int n = sc.read(bb);
101                 if (n &gt; 0) {
102                     break;
103                 }
104                 if (n &lt; 0) {
105                     throw new IOException(&quot;Premature EOF - no test result from service&quot;);
106                 }
107             }
108             sel.selectedKeys().remove(sk);
109             to -= System.currentTimeMillis() - st;
110             if (to &lt;= 0) {
111                 throw new IOException(&quot;Timed out waiting for service to report test result&quot;);
112             }
113         }

114         sk.cancel();
115         sc.close();
116         sel.close();
117 
118         /*
119          * Examine the test result
120          */

121         bb.flip();
122         byte b = bb.get();
123 
124         if (expectFail &amp;&amp; b == &#39;P&#39;) {
125             System.err.println(&quot;Test passed - test is expected to fail!!!&quot;);
126             failures++;
127         }
128         if (!expectFail &amp;&amp; b != &#39;P&#39;) {
129             System.err.println(&quot;Test failed!&quot;);
130             failures++;
131         }
132     }
133 
134     public static void main(String args[]) throws IOException {
135         boolean expectFail = false;
136 
137         /*
138          *   [-expectFail] [options...]
139          */
140         String options[] = args;
141         if (args.length &gt; 0 &amp;&amp; args[0].equals(&quot;-expectFail&quot;)) {
142             // shift out first arg to create options
143             expectFail = true;
144             options = new String[args.length-1];
145             if (args.length &gt; 1) {
146                 System.arraycopy(args, 1, options, 0, args.length-1);
147             }
148         }
149 
150         /*
151          * Create the listener which will be used to read the test result
152          * from the service.
153          */
154         ServerSocketChannel ssc = ServerSocketChannel.open();
<span class="line-modified">155         ssc.socket().bind(new InetSocketAddress(0));</span>

156 
157         /*
158          * The port is passed to the service as an argument.
159          */
160         int port = ssc.socket().getLocalPort();
161         String arg[] = new String[1];
162         arg[0] = String.valueOf(port);
163 
164         /*
165          * Launch service with a SocketChannel (tcp nowait)
166          */

167         SocketChannel sc = Launcher.launchWithSocketChannel(TEST_SERVICE, options, arg);

168         waitForTestResult(ssc, expectFail);
169         sc.close();
170 
171         /*
172          * Launch service with a ServerSocketChannel (tcp wait)
173          * launchWithServerSocketChannel establishes a connection to the service
174          * and the returned SocketChannel is connected to the service.
175          */

176         sc = Launcher.launchWithServerSocketChannel(TEST_SERVICE, options, arg);
177         waitForTestResult(ssc, expectFail);
178         sc.close();
179 
180         /*
181          * Launch service with a DatagramChannel (udp wait)
182          */

183         DatagramChannel dc = Launcher.launchWithDatagramChannel(TEST_SERVICE, options, arg);
184         waitForTestResult(ssc, expectFail);
185         dc.close();
186 

187         if (failures &gt; 0) {
188             throw new RuntimeException(&quot;Test failed - see log for details&quot;);
189         } else {
190             System.out.println(&quot;All tests passed.&quot;);
191         }
192     }
193 }
</pre>
</td>
<td>
<hr />
<pre>
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  *
 26  *
 27  * Tests that the channel returned by System.inheritedChannel()
 28  * is in blocking mode, bound, and in the case of a SocketChannel
 29  * connected to a peer.
 30  *
 31  * The test works by launching a test service (called StateTestService) so
 32  * that it inherits each type of channel. The test service checks the
 33  * socket state and replies back to this class via an out-of-band
 34  * channel.
 35  */
 36 import java.io.IOException;
 37 import java.net.InetSocketAddress;
<span class="line-added"> 38 import java.net.InetAddress;</span>
 39 import java.nio.ByteBuffer;
 40 import java.nio.channels.DatagramChannel;
 41 import java.nio.channels.SelectionKey;
 42 import java.nio.channels.Selector;
 43 import java.nio.channels.ServerSocketChannel;
 44 import java.nio.channels.SocketChannel;
 45 
 46 import jdk.test.lib.Utils;
 47 
 48 public class StateTest {
 49 
 50     private static int failures = 0;
 51 
 52     private static String TEST_SERVICE = &quot;StateTestService&quot;;
 53 
 54     /*
 55      * Reads the test result from the &quot;out-of-band&quot; connection to the test service.
 56      *
 57      * The out-of-band connection is just a TCP connection from the service to
 58      * this class. waitForTestResult just waits (with timeout) for the service
 59      * to connect. Once connected it waits (with timeout) for the test result.
 60      * The test result is examined.
 61      */
 62     private static void waitForTestResult(ServerSocketChannel ssc, boolean expectFail) throws IOException {
 63         Selector sel = ssc.provider().openSelector();
 64         SelectionKey sk;
 65         SocketChannel sc;
 66 
 67         /*
 68          * Wait for service to connect
 69          */
<span class="line-added"> 70         System.err.println(&quot;Waiting for the service to connect&quot;);</span>
 71         ssc.configureBlocking(false);
 72         sk = ssc.register(sel, SelectionKey.OP_ACCEPT);
 73         long to = Utils.adjustTimeout(15*1000);
 74         sc = null;
 75         for (;;) {
 76             long st = System.currentTimeMillis();
 77             sel.select(to);
 78             if (sk.isAcceptable() &amp;&amp; ((sc = ssc.accept()) != null)) {
 79                 // connection established
 80                 break;
 81             }
 82             sel.selectedKeys().remove(sk);
 83             to -= System.currentTimeMillis() - st;
 84             if (to &lt;= 0) {
 85                 throw new IOException(&quot;Timed out waiting for service to report test result&quot;);
 86             }
 87         }
 88         sk.cancel();
 89         ssc.configureBlocking(false);
 90 
 91         /*
 92          * Wait for service to report test result
 93          */
<span class="line-added"> 94         System.err.println(&quot;Waiting for the service to report test result&quot;);</span>
 95         sc.configureBlocking(false);
 96         sk = sc.register(sel, SelectionKey.OP_READ);
 97         to = Utils.adjustTimeout(5000);
 98         ByteBuffer bb = ByteBuffer.allocateDirect(20);
 99         for (;;) {
100             long st = System.currentTimeMillis();
101             sel.select(to);
102             if (sk.isReadable()) {
103                 int n = sc.read(bb);
104                 if (n &gt; 0) {
105                     break;
106                 }
107                 if (n &lt; 0) {
108                     throw new IOException(&quot;Premature EOF - no test result from service&quot;);
109                 }
110             }
111             sel.selectedKeys().remove(sk);
112             to -= System.currentTimeMillis() - st;
113             if (to &lt;= 0) {
114                 throw new IOException(&quot;Timed out waiting for service to report test result&quot;);
115             }
116         }
<span class="line-added">117         System.err.println(&quot;Cleaning up&quot;);</span>
118         sk.cancel();
119         sc.close();
120         sel.close();
121 
122         /*
123          * Examine the test result
124          */
<span class="line-added">125         System.err.println(&quot;Examine test result&quot;);</span>
126         bb.flip();
127         byte b = bb.get();
128 
129         if (expectFail &amp;&amp; b == &#39;P&#39;) {
130             System.err.println(&quot;Test passed - test is expected to fail!!!&quot;);
131             failures++;
132         }
133         if (!expectFail &amp;&amp; b != &#39;P&#39;) {
134             System.err.println(&quot;Test failed!&quot;);
135             failures++;
136         }
137     }
138 
139     public static void main(String args[]) throws IOException {
140         boolean expectFail = false;
141 
142         /*
143          *   [-expectFail] [options...]
144          */
145         String options[] = args;
146         if (args.length &gt; 0 &amp;&amp; args[0].equals(&quot;-expectFail&quot;)) {
147             // shift out first arg to create options
148             expectFail = true;
149             options = new String[args.length-1];
150             if (args.length &gt; 1) {
151                 System.arraycopy(args, 1, options, 0, args.length-1);
152             }
153         }
154 
155         /*
156          * Create the listener which will be used to read the test result
157          * from the service.
158          */
159         ServerSocketChannel ssc = ServerSocketChannel.open();
<span class="line-modified">160         ssc.socket().bind(new InetSocketAddress(InetAddress.getLocalHost(), 0));</span>
<span class="line-added">161         System.err.println(&quot;Listener bound to: &quot; + ssc.socket().getLocalSocketAddress());</span>
162 
163         /*
164          * The port is passed to the service as an argument.
165          */
166         int port = ssc.socket().getLocalPort();
167         String arg[] = new String[1];
168         arg[0] = String.valueOf(port);
169 
170         /*
171          * Launch service with a SocketChannel (tcp nowait)
172          */
<span class="line-added">173         System.err.println(&quot;launchWithSocketChannel&quot;);</span>
174         SocketChannel sc = Launcher.launchWithSocketChannel(TEST_SERVICE, options, arg);
<span class="line-added">175         System.err.println(&quot;Waiting for test results&quot;);</span>
176         waitForTestResult(ssc, expectFail);
177         sc.close();
178 
179         /*
180          * Launch service with a ServerSocketChannel (tcp wait)
181          * launchWithServerSocketChannel establishes a connection to the service
182          * and the returned SocketChannel is connected to the service.
183          */
<span class="line-added">184         System.err.println(&quot;launchWithServerSocketChannel&quot;);</span>
185         sc = Launcher.launchWithServerSocketChannel(TEST_SERVICE, options, arg);
186         waitForTestResult(ssc, expectFail);
187         sc.close();
188 
189         /*
190          * Launch service with a DatagramChannel (udp wait)
191          */
<span class="line-added">192         System.err.println(&quot;launchWithDatagramChannel&quot;);</span>
193         DatagramChannel dc = Launcher.launchWithDatagramChannel(TEST_SERVICE, options, arg);
194         waitForTestResult(ssc, expectFail);
195         dc.close();
196 
<span class="line-added">197         System.err.println(&quot;done&quot;);</span>
198         if (failures &gt; 0) {
199             throw new RuntimeException(&quot;Test failed - see log for details&quot;);
200         } else {
201             System.out.println(&quot;All tests passed.&quot;);
202         }
203     }
204 }
</pre>
</td>
</tr>
</table>
<center><a href="Launcher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnixDomainSocket.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/nio/channels/spi/SelectorProvider/inheritedChannel/libInheritedChannel.c</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * A simple launcher to launch a program as if it was launched by inetd.
 26  */
 27 #include &lt;stdio.h&gt;
 28 #include &lt;stdlib.h&gt;
<a name="2" id="anc2"></a>
 29 #include &lt;sys/types.h&gt;
 30 #include &lt;sys/socket.h&gt;
<a name="3" id="anc3"></a>
 31 #include &lt;unistd.h&gt;
 32 #include &lt;dirent.h&gt;
 33 #include &lt;sys/stat.h&gt;
 34 #include &lt;fcntl.h&gt;
 35 #include &lt;ctype.h&gt;
 36 
 37 #include &quot;jni.h&quot;
 38 
 39 #define CHECK(X) if ((X) == 0) {printf(&quot;JNI init error line %d\n&quot;, __LINE__); _exit(1);}
 40 
 41 static jclass unixSocketClass;
 42 static jmethodID unixSocketCtor;
 43 
 44 /*
 45  * Throws the exception of the given class name and detail message
 46  */
 47 static void ThrowException(JNIEnv *env, const char *name, const char *msg) {
 48     jclass cls = (*env)-&gt;FindClass(env, name);
 49     if (cls != NULL) {
 50         (*env)-&gt;ThrowNew(env, cls, msg);
 51     }
 52 }
 53 
 54 /*
 55  * Convert a jstring to an ISO 8859_1 encoded C string
 56  */
 57 static char* getString8859_1Chars(JNIEnv *env, jstring jstr) {
 58     int i;
 59     char *result;
 60     jint len = (*env)-&gt;GetStringLength(env, jstr);
 61     const jchar *str = (*env)-&gt;GetStringCritical(env, jstr, 0);
 62     if (str == 0) {
 63         return NULL;
 64     }
 65 
 66     result = (char*)malloc(len+1);
 67     if (result == 0) {
 68         (*env)-&gt;ReleaseStringCritical(env, jstr, str);
 69         ThrowException(env, &quot;java/lang/OutOfMemoryError&quot;, NULL);
 70         return NULL;
 71     }
 72 
 73     for (i=0; i&lt;len; i++) {
 74         jchar unicode = str[i];
 75         if (unicode &lt;= 0x00ff)
 76             result[i] = unicode;
 77         else
 78             result[i] = &#39;?&#39;;
 79     }
 80 
 81     result[len] = 0;
 82     (*env)-&gt;ReleaseStringCritical(env, jstr, str);
 83     return result;
 84 }
 85 
 86 
 87 /*
 88  * Class:     Launcher
 89  * Method:    launch0
 90  * Signature: ([Ljava/lang/String;I)V
 91  */
 92 JNIEXPORT void JNICALL Java_Launcher_launch0
 93   (JNIEnv *env, jclass cls, jobjectArray cmdarray, jint serviceFd)
 94 {
 95     pid_t pid;
 96     DIR* dp;
 97     struct dirent* dirp;
 98     int thisFd;
 99     char** cmdv;
100     int i, cmdlen;
101 
102     /*
103      * Argument 0 of the command array is the program name.
104      * Here we just extract the program name and any arguments into
105      * a command array suitable for use with execvp.
106      */
107     cmdlen = (*env)-&gt;GetArrayLength(env, cmdarray);
108     if (cmdlen == 0) {
109         ThrowException(env, &quot;java/lang/IllegalArgumentException&quot;,
110             &quot;command array must at least include the program name&quot;);
111         return;
112     }
113     cmdv = (char **)malloc((cmdlen + 1) * sizeof(char *));
114     if (cmdv == NULL) {
115         ThrowException(env, &quot;java/lang/OutOfMemoryError&quot;, NULL);
116         return;
117     }
118 
119     for (i=0; i&lt;cmdlen; i++) {
120         jstring str = (*env)-&gt;GetObjectArrayElement(env, cmdarray, i);
121         cmdv[i] = (char *) getString8859_1Chars(env, str);
122         if (cmdv[i] == NULL) {
123             return;
124         }
125     }
126 
127     /*
128      * Command array must have NULL as the last entry
129      */
130     cmdv[cmdlen] = NULL;
131 
132     /*
133      * Launch the program. As this isn&#39;t a complete inetd or Runtime.exec
134      * implementation we don&#39;t have a reaper to pick up child exit status.
135      */
136 #ifdef __solaris__
137     pid = fork1();
138 #else
139     pid = fork();
140 #endif
141     if (pid != 0) {
142         if (pid &lt; 0) {
143             ThrowException(env, &quot;java/io/IOException&quot;, &quot;fork failed&quot;);
144         }
145         return;
146     }
147 
148     /*
149      * We need to close all file descriptors except for serviceFd. To
<a name="4" id="anc4"></a><span class="line-modified">150      * get the list of open file descriptos we read through /proc/self/fd</span>
151      * but to open this requires a file descriptor. We could use a specific
152      * file descriptor and fdopendir but Linux doesn&#39;t seem to support
153      * fdopendir. Instead we use opendir and make an assumption on the
154      * file descriptor that is used (by opening &amp; closing a file).
155      */
<a name="5" id="anc5"></a><span class="line-modified">156     thisFd = open(&quot;/dev/null&quot;, O_RDONLY);</span>
157     if (thisFd &lt; 0) {
158         _exit(-1);
159     }
<a name="6" id="anc6"></a><span class="line-removed">160     close(thisFd);</span>
161 
<a name="7" id="anc7"></a><span class="line-modified">162     if ((dp = opendir(&quot;/proc/self/fd&quot;)) == NULL) {</span>
163         _exit(-1);
164     }
165 
166     while ((dirp = readdir(dp)) != NULL) {
167         if (isdigit(dirp-&gt;d_name[0])) {
168             int fd = strtol(dirp-&gt;d_name, NULL, 10);
169             if (fd != serviceFd &amp;&amp; fd != thisFd) {
170                 close(fd);
171             }
172         }
173     }
174     closedir(dp);
175 
176     /*
177      * At this point all file descriptors are closed except for
178      * serviceFd. We not dup 0,1,2 to this file descriptor and
179      * close serviceFd. This should leave us with only 0,1,2
180      * open and all connected to the same socket.
181      */
182     dup2(serviceFd, STDIN_FILENO);
183     dup2(serviceFd, STDOUT_FILENO);
184     dup2(serviceFd, STDERR_FILENO);
185     close(serviceFd);
186 
187     execvp(cmdv[0], cmdv);
188     _exit(-1);
189 }
190 
191 JNIEXPORT void JNICALL Java_UnixDomainSocket_init(JNIEnv *env, jclass cls) {
192     CHECK(unixSocketClass = (*env)-&gt;FindClass(env, &quot;UnixDomainSocket&quot;));
193     CHECK(unixSocketClass = (*env)-&gt;NewGlobalRef(env, unixSocketClass));
194     CHECK(unixSocketCtor = (*env)-&gt;GetMethodID(env, unixSocketClass, &quot;&lt;init&gt;&quot;, &quot;(I)V&quot;));
195 }
196 
197 /*
198  * Class:     UnixDomainSocket
199  * Method:    socketpair
200  * Signature: ()[LUnixDomainSocket
201  */
202 JNIEXPORT jobjectArray JNICALL Java_UnixDomainSocket_socketpair
203   (JNIEnv *env, jclass cls)
204 {
205     int fds[2];
206     jobject socket;
207     jobjectArray result = (*env)-&gt;NewObjectArray(env, 2, unixSocketClass, 0);
208     if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds) &lt; 0) {
209         perror(&quot;socketpair&quot;);
210         return result;
211     }
212     socket = (*env)-&gt;NewObject(env, unixSocketClass, unixSocketCtor, fds[0]);
213     (*env)-&gt;SetObjectArrayElement(env, result, 0, socket);
214     socket = (*env)-&gt;NewObject(env, unixSocketClass, unixSocketCtor, fds[1]);
215     (*env)-&gt;SetObjectArrayElement(env, result, 1, socket);
216     return result;
217 }
218 
<a name="8" id="anc8"></a>






























































219 JNIEXPORT jint JNICALL Java_UnixDomainSocket_read0
220   (JNIEnv *env, jclass cls, jint fd)
221 {
222     int ret;
223     unsigned char res;
224     ret = read(fd, &amp;res, 1);
225     if (ret == 0)
226         return -1; /* EOF */
227     else if (ret &lt; 0) {
228         ThrowException(env, &quot;java/io/IOException&quot;, &quot;read error&quot;);
229         return -1;
230     }
231     return res;
232 }
233 
234 JNIEXPORT void JNICALL Java_UnixDomainSocket_write0
235   (JNIEnv *env, jclass cls, jint fd, jint byte)
236 {
237     int ret;
238     unsigned char w = (unsigned char)byte;
239     ret = write(fd, &amp;w, 1);
240     if (ret &lt; 0) {
241         ThrowException(env, &quot;java/io/IOException&quot;, &quot;write error&quot;);
242     }
243 }
244 
245 JNIEXPORT void JNICALL Java_UnixDomainSocket_close0
<a name="9" id="anc9"></a><span class="line-modified">246   (JNIEnv *env, jclass cls, jint fd)</span>
247 {
248     close(fd);
<a name="10" id="anc10"></a>




249 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
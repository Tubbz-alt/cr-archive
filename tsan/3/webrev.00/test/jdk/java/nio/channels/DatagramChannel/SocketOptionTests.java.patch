diff a/test/jdk/java/nio/channels/DatagramChannel/SocketOptionTests.java b/test/jdk/java/nio/channels/DatagramChannel/SocketOptionTests.java
--- a/test/jdk/java/nio/channels/DatagramChannel/SocketOptionTests.java
+++ b/test/jdk/java/nio/channels/DatagramChannel/SocketOptionTests.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -20,39 +20,82 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /* @test
- * @bug 4640544 8044773
+ * @bug 4640544 8044773 8233435
  * @summary Unit test for setOption/getOption/options methods
  * @requires !vm.graal.enabled
+ * @library /test/lib
+ * @build jdk.test.lib.net.IPSupport
+ *        jdk.test.lib.NetworkConfiguration
+ *        SocketOptionTests
  * @run main SocketOptionTests
+ * @run main/othervm -Djava.net.preferIPv4Stack=true SocketOptionTests
  * @run main/othervm --limit-modules=java.base SocketOptionTests
  */
 
 import java.nio.*;
 import java.nio.channels.*;
 import java.net.*;
 import java.io.IOException;
 import java.util.*;
+import static java.net.StandardProtocolFamily.*;
 import static java.net.StandardSocketOptions.*;
 
-public class SocketOptionTests {
+import jdk.test.lib.NetworkConfiguration;
+import jdk.test.lib.net.IPSupport;
 
-    static <T> void checkOption(DatagramChannel dc,
-                                SocketOption<T> name,
-                                T expectedValue)
-        throws IOException
-    {
-        T value = dc.getOption(name);
-        if (!value.equals(expectedValue))
-            throw new RuntimeException("value not as expected");
-    }
+public class SocketOptionTests {
 
     public static void main(String[] args) throws IOException {
-        DatagramChannel dc = DatagramChannel.open();
+        IPSupport.throwSkippedExceptionIfNonOperational();
+
+        NetworkConfiguration config = NetworkConfiguration.probe();
+        InetAddress ip4Address = config.ip4Addresses().findAny().orElse(null);
+        InetAddress ip6Address = config.ip6Addresses().findAny().orElse(null);
+
+        System.out.println("[UNSPEC, bound to wildcard address]");
+        try (DatagramChannel dc = DatagramChannel.open()) {
+            test(dc, new InetSocketAddress(0));
+        }
+
+        if (IPSupport.hasIPv4()) {
+            System.out.println("[INET, bound to wildcard address]");
+            try (DatagramChannel dc = DatagramChannel.open(INET)) {
+                test(dc, new InetSocketAddress(0));
+            }
+            System.out.println("[INET, bound to IPv4 address]");
+            try (DatagramChannel dc = DatagramChannel.open(INET)) {
+                test(dc, new InetSocketAddress(ip4Address, 0));
+            }
+        }
 
+        if (IPSupport.hasIPv6()) {
+            System.out.println("[INET6, bound to wildcard address]");
+            try (DatagramChannel dc = DatagramChannel.open(INET6)) {
+                test(dc, new InetSocketAddress(0));
+            }
+            System.out.println("[INET6, bound to IPv6 address]");
+            try (DatagramChannel dc = DatagramChannel.open(INET6)) {
+                test(dc, new InetSocketAddress(ip6Address, 0));
+            }
+        }
+
+        if (IPSupport.hasIPv4() && IPSupport.hasIPv6()) {
+            System.out.println("[UNSPEC, bound to IPv4 address]");
+            try (DatagramChannel dc = DatagramChannel.open()) {
+                test(dc, new InetSocketAddress(ip4Address, 0));
+            }
+            System.out.println("[INET6, bound to IPv4 address]");
+            try (DatagramChannel dc = DatagramChannel.open(INET6)) {
+                test(dc, new InetSocketAddress(ip4Address, 0));
+            }
+        }
+    }
+
+    static void test(DatagramChannel dc, SocketAddress localAddress) throws IOException {
         // check supported options
         Set<SocketOption<?>> options = dc.supportedOptions();
         boolean reuseport = options.contains(SO_REUSEPORT);
         List<? extends SocketOption<?>> expected;
         if (reuseport) {
@@ -99,11 +142,11 @@
             checkOption(dc, SO_REUSEPORT, true);
             dc.setOption(SO_REUSEPORT, false);
             checkOption(dc, SO_REUSEPORT, false);
         }
         // bind socket
-        dc.bind(new InetSocketAddress(0));
+        dc.bind(localAddress);
 
         // allow to change when bound
         dc.setOption(SO_BROADCAST, true);
         checkOption(dc, SO_BROADCAST, true);
         dc.setOption(SO_BROADCAST, false);
@@ -114,11 +157,10 @@
         dc.setOption(IP_MULTICAST_LOOP, false);
         checkOption(dc, IP_MULTICAST_LOOP, false);
         dc.setOption(IP_MULTICAST_LOOP, true);
         checkOption(dc, IP_MULTICAST_LOOP, true);
 
-
         // NullPointerException
         try {
             dc.setOption(null, "value");
             throw new RuntimeException("NullPointerException not thrown");
         } catch (NullPointerException x) {
@@ -135,6 +177,16 @@
             dc.setOption(IP_MULTICAST_LOOP, true);
             throw new RuntimeException("ClosedChannelException not thrown");
         } catch (ClosedChannelException x) {
         }
     }
+
+    static <T> void checkOption(DatagramChannel dc,
+                                SocketOption<T> name,
+                                T expectedValue)
+        throws IOException
+    {
+        T value = dc.getOption(name);
+        if (!value.equals(expectedValue))
+            throw new RuntimeException("value not as expected");
+    }
 }

diff a/test/jdk/java/nio/channels/etc/AdaptorCloseAndInterrupt.java b/test/jdk/java/nio/channels/etc/AdaptorCloseAndInterrupt.java
--- a/test/jdk/java/nio/channels/etc/AdaptorCloseAndInterrupt.java
+++ b/test/jdk/java/nio/channels/etc/AdaptorCloseAndInterrupt.java
@@ -20,11 +20,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 /* @test
- * @bug 7184932
+ * @bug 7184932 8232673
  * @summary Test asynchronous close and interrupt of timed socket adapter methods
  * @key randomness intermittent
  */
 
 import java.io.*;
@@ -76,12 +76,14 @@
                 new AdaptorCloseAndInterrupt(listener).scReadAsyncInterrupt();
             }
 
             try (DatagramChannel peer = DatagramChannel.open()) {
                 peer.socket().bind(null);
-                new AdaptorCloseAndInterrupt(peer).dcReceiveAsyncClose();
-                new AdaptorCloseAndInterrupt(peer).dcReceiveAsyncInterrupt();
+                new AdaptorCloseAndInterrupt(peer).dcReceiveAsyncClose(0);
+                new AdaptorCloseAndInterrupt(peer).dcReceiveAsyncClose(30_000);
+                new AdaptorCloseAndInterrupt(peer).dcReceiveAsyncInterrupt(0);
+                new AdaptorCloseAndInterrupt(peer).dcReceiveAsyncInterrupt(30_000);
             }
 
             new AdaptorCloseAndInterrupt().ssAcceptAsyncClose();
             new AdaptorCloseAndInterrupt().ssAcceptAsyncInterrupt();
         } finally {
@@ -136,40 +138,38 @@
             // accept connection and close it.
             listener.accept().close();
         }
     }
 
-    void dcReceiveAsyncClose() throws IOException {
+    void dcReceiveAsyncClose(int timeout) throws IOException {
         DatagramChannel dc = DatagramChannel.open();
-        dc.connect(new InetSocketAddress(
-            InetAddress.getLoopbackAddress(), port));
-        dc.socket().setSoTimeout(30*1000);
+        dc.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), port));
+        dc.socket().setSoTimeout(timeout);
 
         doAsyncClose(dc);
 
         try {
             dc.socket().receive(new DatagramPacket(new byte[100], 100));
             System.err.format("close() was invoked: %s%n", isClosed.get());
             throw new RuntimeException("receive should not have completed");
-        } catch (ClosedChannelException expected) {}
+        } catch (SocketException expected) { }
 
         if (!dc.socket().isClosed())
             throw new RuntimeException("socket is not closed");
     }
 
-    void dcReceiveAsyncInterrupt() throws IOException {
+    void dcReceiveAsyncInterrupt(int timeout) throws IOException {
         DatagramChannel dc = DatagramChannel.open();
-        dc.connect(new InetSocketAddress(
-            InetAddress.getLoopbackAddress(), port));
-        dc.socket().setSoTimeout(30*1000);
+        dc.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), port));
+        dc.socket().setSoTimeout(timeout);
 
         doAsyncInterrupt();
 
         try {
             dc.socket().receive(new DatagramPacket(new byte[100], 100));
             throw new RuntimeException("receive should not have completed");
-        } catch (ClosedByInterruptException expected) {
+        } catch (SocketException expected) {
             System.out.format("interrupt() was invoked: %s%n",
                 isInterrupted.get());
             System.out.format("dcReceiveAsyncInterrupt was interrupted: %s%n",
                 Thread.currentThread().interrupted());
         } catch (SocketTimeoutException unexpected) {

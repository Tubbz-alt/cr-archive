<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/nio/channels/Selector/SelectWithConsumer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 8199433 8208780
 26  * @run testng SelectWithConsumer
 27  * @summary Unit test for Selector select(Consumer), select(Consumer,long) and
 28  *          selectNow(Consumer)
 29  */
 30 
 31 import java.io.Closeable;
 32 import java.io.IOException;
 33 import java.net.InetSocketAddress;
 34 import java.nio.ByteBuffer;
 35 import java.nio.channels.ClosedSelectorException;
 36 import java.nio.channels.Pipe;
 37 import java.nio.channels.SelectionKey;
 38 import java.nio.channels.Selector;
 39 import java.nio.channels.ServerSocketChannel;
 40 import java.nio.channels.SocketChannel;
 41 import java.nio.channels.WritableByteChannel;
 42 import java.util.concurrent.Executors;
 43 import java.util.concurrent.ScheduledExecutorService;
 44 import java.util.concurrent.TimeUnit;
 45 import java.util.concurrent.atomic.AtomicInteger;
 46 import static java.util.concurrent.TimeUnit.*;
 47 
 48 import org.testng.annotations.AfterTest;
 49 import org.testng.annotations.Test;
 50 import static org.testng.Assert.*;
 51 
 52 @Test
 53 public class SelectWithConsumer {
 54 
 55     /**
 56      * Invoke the select methods that take an action and check that the
 57      * accumulated ready ops notified to the action matches the expected ops.
 58      */
 59     void testActionInvoked(SelectionKey key, int expectedOps) throws Exception {
 60         var callerThread = Thread.currentThread();
 61         var sel = key.selector();
 62         var interestOps = key.interestOps();
 63         var notifiedOps = new AtomicInteger();
 64 
 65         if (expectedOps == 0) {
 66             // ensure select(Consumer) does not block indefinitely
 67             sel.wakeup();
 68         } else {
 69             // ensure that the channel is ready for all expected operations
 70             sel.select();
 71             while ((key.readyOps() &amp; interestOps) != expectedOps) {
 72                 Thread.sleep(100);
 73                 sel.select();
 74             }
 75         }
 76 
 77         // select(Consumer)
 78         notifiedOps.set(0);
 79         int n = sel.select(k -&gt; {
 80             assertTrue(Thread.currentThread() == callerThread);
 81             assertTrue(k == key);
 82             int readyOps = key.readyOps();
 83             assertTrue((readyOps &amp; interestOps) != 0);
 84             assertTrue((readyOps &amp; notifiedOps.get()) == 0);
 85             notifiedOps.set(notifiedOps.get() | readyOps);
 86         });
 87         assertTrue((n == 1) ^ (expectedOps == 0));
 88         assertTrue(notifiedOps.get() == expectedOps);
 89 
 90         // select(Consumer, timeout)
 91         notifiedOps.set(0);
 92         n = sel.select(k -&gt; {
 93             assertTrue(Thread.currentThread() == callerThread);
 94             assertTrue(k == key);
 95             int readyOps = key.readyOps();
 96             assertTrue((readyOps &amp; interestOps) != 0);
 97             assertTrue((readyOps &amp; notifiedOps.get()) == 0);
 98             notifiedOps.set(notifiedOps.get() | readyOps);
 99         }, 1000);
100         assertTrue((n == 1) ^ (expectedOps == 0));
101         assertTrue(notifiedOps.get() == expectedOps);
102 
103         // selectNow(Consumer)
104         notifiedOps.set(0);
105         n = sel.selectNow(k -&gt; {
106             assertTrue(Thread.currentThread() == callerThread);
107             assertTrue(k == key);
108             int readyOps = key.readyOps();
109             assertTrue((readyOps &amp; interestOps) != 0);
110             assertTrue((readyOps &amp; notifiedOps.get()) == 0);
111             notifiedOps.set(notifiedOps.get() | readyOps);
112         });
113         assertTrue((n == 1) ^ (expectedOps == 0));
114         assertTrue(notifiedOps.get() == expectedOps);
115     }
116 
117     /**
118      * Test that an action is performed when a channel is ready for reading.
119      */
120     public void testReadable() throws Exception {
121         Pipe p = Pipe.open();
122         try (Selector sel = Selector.open()) {
123             Pipe.SinkChannel sink = p.sink();
124             Pipe.SourceChannel source = p.source();
125             source.configureBlocking(false);
126             SelectionKey key = source.register(sel, SelectionKey.OP_READ);
127 
128             // write to sink to ensure source is readable
129             scheduleWrite(sink, messageBuffer(), 100, MILLISECONDS);
130 
131             // test that action is invoked
132             testActionInvoked(key, SelectionKey.OP_READ);
133         } finally {
134             closePipe(p);
135         }
136     }
137 
138     /**
139      * Test that an action is performed when a channel is ready for writing.
140      */
141     public void testWritable() throws Exception {
142         Pipe p = Pipe.open();
143         try (Selector sel = Selector.open()) {
144             Pipe.SourceChannel source = p.source();
145             Pipe.SinkChannel sink = p.sink();
146             sink.configureBlocking(false);
147             SelectionKey key = sink.register(sel, SelectionKey.OP_WRITE);
148 
149             // test that action is invoked
150             testActionInvoked(key, SelectionKey.OP_WRITE);
151         } finally {
152             closePipe(p);
153         }
154     }
155 
156     /**
157      * Test that an action is performed when a channel is ready for both
158      * reading and writing.
159      */
160     public void testReadableAndWriteable() throws Exception {
161         ServerSocketChannel ssc = null;
162         SocketChannel sc = null;
163         SocketChannel peer = null;
164         try (Selector sel = Selector.open()) {
165             ssc = ServerSocketChannel.open().bind(new InetSocketAddress(0));
166             sc = SocketChannel.open(ssc.getLocalAddress());
167             sc.configureBlocking(false);
168             SelectionKey key = sc.register(sel, (SelectionKey.OP_READ |
169                                                  SelectionKey.OP_WRITE));
170 
171             // accept connection and write data so the source is readable
172             peer = ssc.accept();
173             peer.write(messageBuffer());
174 
175             // test that action is invoked
176             testActionInvoked(key, (SelectionKey.OP_READ | SelectionKey.OP_WRITE));
177         } finally {
178             if (ssc != null) ssc.close();
179             if (sc != null) sc.close();
180             if (peer != null) peer.close();
181         }
182     }
183 
184     /**
185      * Test that the action is called for two selected channels
186      */
187     public void testTwoChannels() throws Exception {
188         Pipe p = Pipe.open();
189         try (Selector sel = Selector.open()) {
190             Pipe.SourceChannel source = p.source();
191             Pipe.SinkChannel sink = p.sink();
192             source.configureBlocking(false);
193             sink.configureBlocking(false);
194             SelectionKey key1 = source.register(sel, SelectionKey.OP_READ);
195             SelectionKey key2 = sink.register(sel, SelectionKey.OP_WRITE);
196 
197             // write to sink to ensure that the source is readable
198             sink.write(messageBuffer());
199 
200             var counter = new AtomicInteger();
201 
202             // select(Consumer)
203             counter.set(0);
204             int n = sel.select(k -&gt; {
205                 counter.incrementAndGet();
206                 if (k == key1) {
207                     assertTrue(k.isReadable());
208                 } else if (k == key2) {
209                     assertTrue(k.isWritable());
210                 } else {
211                     assertTrue(false);
212                 }
213             });
214             assertTrue(n == 2);
215             assertTrue(counter.get() == 2);
216 
217             // select(Consumer, timeout)
218             counter.set(0);
219             n = sel.select(k -&gt; {
220                 counter.incrementAndGet();
221                 if (k == key1) {
222                     assertTrue(k.isReadable());
223                 } else if (k == key2) {
224                     assertTrue(k.isWritable());
225                 } else {
226                     assertTrue(false);
227                 }
228             }, 1000);
229             assertTrue(n == 2);
230             assertTrue(counter.get() == 2);
231 
232             // selectNow(Consumer)
233             counter.set(0);
234             n = sel.selectNow(k -&gt; {
235                 counter.incrementAndGet();
236                 if (k == key1) {
237                     assertTrue(k.isReadable());
238                 } else if (k == key2) {
239                     assertTrue(k.isWritable());
240                 } else {
241                     assertTrue(false);
242                 }
243             });
244             assertTrue(n == 2);
245             assertTrue(counter.get() == 2);
246         } finally {
247             closePipe(p);
248         }
249     }
250 
251     /**
252      * Test calling select twice, the action should be invoked each time
253      */
254     public void testRepeatedSelect1() throws Exception {
255         Pipe p = Pipe.open();
256         try (Selector sel = Selector.open()) {
257             Pipe.SourceChannel source = p.source();
258             Pipe.SinkChannel sink = p.sink();
259             source.configureBlocking(false);
260             SelectionKey key = source.register(sel, SelectionKey.OP_READ);
261 
262             // write to sink to ensure that the source is readable
263             sink.write(messageBuffer());
264 
265             // test that action is invoked
266             testActionInvoked(key, SelectionKey.OP_READ);
267             testActionInvoked(key, SelectionKey.OP_READ);
268 
269         } finally {
270             closePipe(p);
271         }
272     }
273 
274     /**
275      * Test calling select twice. An I/O operation is performed after the
276      * first select so the channel will not be selected by the second select.
277      */
278     public void testRepeatedSelect2() throws Exception {
279         Pipe p = Pipe.open();
280         try (Selector sel = Selector.open()) {
281             Pipe.SourceChannel source = p.source();
282             Pipe.SinkChannel sink = p.sink();
283             source.configureBlocking(false);
284             SelectionKey key = source.register(sel, SelectionKey.OP_READ);
285 
286             // write to sink to ensure that the source is readable
287             sink.write(messageBuffer());
288 
289             // test that action is invoked
290             testActionInvoked(key, SelectionKey.OP_READ);
291 
292             // read all bytes
293             int n;
294             ByteBuffer bb = ByteBuffer.allocate(100);
295             do {
296                 n = source.read(bb);
297                 bb.clear();
298             } while (n &gt; 0);
299 
300             // test that action is not invoked
301             testActionInvoked(key, 0);
302         } finally {
303             closePipe(p);
304         }
305     }
306 
307     /**
308      * Test timeout
309      */
310     public void testTimeout() throws Exception {
311         Pipe p = Pipe.open();
312         try (Selector sel = Selector.open()) {
313             Pipe.SourceChannel source = p.source();
314             Pipe.SinkChannel sink = p.sink();
315             source.configureBlocking(false);
316             source.register(sel, SelectionKey.OP_READ);
317             long start = System.currentTimeMillis();
318             int n = sel.select(k -&gt; assertTrue(false), 1000L);
319             long duration = System.currentTimeMillis() - start;
320             assertTrue(n == 0);
321             assertTrue(duration &gt; 500, &quot;select took &quot; + duration + &quot; ms&quot;);
322         } finally {
323             closePipe(p);
324         }
325     }
326 
327     /**
328      * Test wakeup prior to select
329      */
330     public void testWakeupBeforeSelect() throws Exception {
331         // select(Consumer)
332         try (Selector sel = Selector.open()) {
333             sel.wakeup();
334             int n = sel.select(k -&gt; assertTrue(false));
335             assertTrue(n == 0);
336         }
337 
338         // select(Consumer, timeout)
339         try (Selector sel = Selector.open()) {
340             sel.wakeup();
341             long start = System.currentTimeMillis();
342             int n = sel.select(k -&gt; assertTrue(false), 60*1000);
343             long duration = System.currentTimeMillis() - start;
344             assertTrue(n == 0);
345             assertTrue(duration &lt; 5000, &quot;select took &quot; + duration + &quot; ms&quot;);
346         }
347     }
348 
349     /**
350      * Test wakeup during select
351      */
352     public void testWakeupDuringSelect() throws Exception {
353         // select(Consumer)
354         try (Selector sel = Selector.open()) {
355             scheduleWakeup(sel, 1, SECONDS);
356             int n = sel.select(k -&gt; assertTrue(false));
357             assertTrue(n == 0);
358         }
359 
360         // select(Consumer, timeout)
361         try (Selector sel = Selector.open()) {
362             scheduleWakeup(sel, 1, SECONDS);
363             long start = System.currentTimeMillis();
364             int n = sel.select(k -&gt; assertTrue(false), 60*1000);
365             long duration = System.currentTimeMillis() - start;
366             assertTrue(n == 0);
367             assertTrue(duration &gt; 500 &amp;&amp; duration &lt; 10*1000,
368                     &quot;select took &quot; + duration + &quot; ms&quot;);
369         }
370     }
371 
372     /**
373      * Test invoking select with interrupt status set
374      */
375     public void testInterruptBeforeSelect() throws Exception {
376         // select(Consumer)
377         try (Selector sel = Selector.open()) {
378             Thread.currentThread().interrupt();
379             int n = sel.select(k -&gt; assertTrue(false));
380             assertTrue(n == 0);
381             assertTrue(Thread.currentThread().isInterrupted());
382             assertTrue(sel.isOpen());
383         } finally {
384             Thread.currentThread().interrupted();  // clear interrupt status
385         }
386 
387         // select(Consumer, timeout)
388         try (Selector sel = Selector.open()) {
389             Thread.currentThread().interrupt();
390             long start = System.currentTimeMillis();
391             int n = sel.select(k -&gt; assertTrue(false), 60*1000);
392             long duration = System.currentTimeMillis() - start;
393             assertTrue(n == 0);
394             assertTrue(duration &lt; 5000, &quot;select took &quot; + duration + &quot; ms&quot;);
395             assertTrue(Thread.currentThread().isInterrupted());
396             assertTrue(sel.isOpen());
397         } finally {
398             Thread.currentThread().interrupted();  // clear interrupt status
399         }
400     }
401 
402     /**
403      * Test interrupt thread during select
404      */
405     public void testInterruptDuringSelect() throws Exception {
406         // select(Consumer)
407         try (Selector sel = Selector.open()) {
408             scheduleInterrupt(Thread.currentThread(), 1, SECONDS);
409             int n = sel.select(k -&gt; assertTrue(false));
410             assertTrue(n == 0);
411             assertTrue(Thread.currentThread().isInterrupted());
412             assertTrue(sel.isOpen());
413         } finally {
414             Thread.currentThread().interrupted();  // clear interrupt status
415         }
416 
417         // select(Consumer, timeout)
418         try (Selector sel = Selector.open()) {
419             scheduleInterrupt(Thread.currentThread(), 1, SECONDS);
420             long start = System.currentTimeMillis();
421             int n = sel.select(k -&gt; assertTrue(false), 60*1000);
422             long duration = System.currentTimeMillis() - start;
423             assertTrue(n == 0);
424             assertTrue(Thread.currentThread().isInterrupted());
425             assertTrue(sel.isOpen());
426         } finally {
427             Thread.currentThread().interrupted();  // clear interrupt status
428         }
429     }
430 
431     /**
432      * Test invoking select on a closed selector
433      */
434     @Test(expectedExceptions = ClosedSelectorException.class)
435     public void testClosedSelector1() throws Exception {
436         Selector sel = Selector.open();
437         sel.close();
438         sel.select(k -&gt; assertTrue(false));
439     }
440     @Test(expectedExceptions = ClosedSelectorException.class)
441     public void testClosedSelector2() throws Exception {
442         Selector sel = Selector.open();
443         sel.close();
444         sel.select(k -&gt; assertTrue(false), 1000);
445     }
446     @Test(expectedExceptions = ClosedSelectorException.class)
447     public void testClosedSelector3() throws Exception {
448         Selector sel = Selector.open();
449         sel.close();
450         sel.selectNow(k -&gt; assertTrue(false));
451     }
452 
453     /**
454      * Test closing selector while in a selection operation
455      */
456     public void testCloseDuringSelect() throws Exception {
457         // select(Consumer)
458         try (Selector sel = Selector.open()) {
459             scheduleClose(sel, 3, SECONDS);
460             int n = sel.select(k -&gt; assertTrue(false));
461             assertTrue(n == 0);
462             assertFalse(sel.isOpen());
463         }
464 
465         // select(Consumer, timeout)
466         try (Selector sel = Selector.open()) {
467             scheduleClose(sel, 3, SECONDS);
468             long start = System.currentTimeMillis();
469             int n = sel.select(k -&gt; assertTrue(false), 60*1000);
470             long duration = System.currentTimeMillis() - start;
471             assertTrue(n == 0);
472             assertTrue(duration &gt; 2000 &amp;&amp; duration &lt; 10*1000,
473                     &quot;select took &quot; + duration + &quot; ms&quot;);
474             assertFalse(sel.isOpen());
475         }
476     }
477 
478     /**
479      * Test action closing selector
480      */
481     @Test(expectedExceptions = ClosedSelectorException.class)
482     public void testActionClosingSelector() throws Exception {
483         Pipe p = Pipe.open();
484         try (Selector sel = Selector.open()) {
485             Pipe.SourceChannel source = p.source();
486             Pipe.SinkChannel sink = p.sink();
487             source.configureBlocking(false);
488             SelectionKey key = source.register(sel, SelectionKey.OP_READ);
489 
490             // write to sink to ensure that the source is readable
491             sink.write(messageBuffer());
492 
493             // should relay ClosedSelectorException
494             sel.select(k -&gt; {
495                 assertTrue(k == key);
496                 try {
497                     sel.close();
498                 } catch (IOException ioe) { }
499             });
500         } finally {
501             closePipe(p);
502         }
503     }
504 
505     /**
506      * Test that the action is invoked while synchronized on the selector and
507      * its selected-key set.
508      */
509     public void testLocks() throws Exception {
510         Pipe p = Pipe.open();
511         try (Selector sel = Selector.open()) {
512             Pipe.SourceChannel source = p.source();
513             Pipe.SinkChannel sink = p.sink();
514             source.configureBlocking(false);
515             SelectionKey key = source.register(sel, SelectionKey.OP_READ);
516 
517             // write to sink to ensure that the source is readable
518             sink.write(messageBuffer());
519 
520             // select(Consumer)
521             sel.select(k -&gt; {
522                 assertTrue(k == key);
523                 assertTrue(Thread.holdsLock(sel));
524                 assertFalse(Thread.holdsLock(sel.keys()));
525                 assertTrue(Thread.holdsLock(sel.selectedKeys()));
526             });
527 
528             // select(Consumer, timeout)
529             sel.select(k -&gt; {
530                 assertTrue(k == key);
531                 assertTrue(Thread.holdsLock(sel));
532                 assertFalse(Thread.holdsLock(sel.keys()));
533                 assertTrue(Thread.holdsLock(sel.selectedKeys()));
534             }, 1000L);
535 
536             // selectNow(Consumer)
537             sel.selectNow(k -&gt; {
538                 assertTrue(k == key);
539                 assertTrue(Thread.holdsLock(sel));
540                 assertFalse(Thread.holdsLock(sel.keys()));
541                 assertTrue(Thread.holdsLock(sel.selectedKeys()));
542             });
543         } finally {
544             closePipe(p);
545         }
546     }
547 
548     /**
549      * Test that selection operations remove cancelled keys from the selector&#39;s
550      * key and selected-key sets.
551      */
552     public void testCancel() throws Exception {
553         Pipe p = Pipe.open();
554         try (Selector sel = Selector.open()) {
555             Pipe.SinkChannel sink = p.sink();
556             Pipe.SourceChannel source = p.source();
557 
558             // write to sink to ensure that the source is readable
559             sink.write(messageBuffer());
560 
561             source.configureBlocking(false);
562             SelectionKey key1 = source.register(sel, SelectionKey.OP_READ);
563             // make sure pipe source is readable before we do following checks.
564             // this is sometime necessary on windows where pipe is implemented
565             // as a pair of connected socket, so there is no guarantee that written
566             // bytes on sink side is immediately available on source side.
567             sel.select();
568 
569             sink.configureBlocking(false);
570             SelectionKey key2 = sink.register(sel, SelectionKey.OP_WRITE);
571             sel.selectNow();
572 
573             assertTrue(sel.keys().contains(key1));
574             assertTrue(sel.keys().contains(key2));
575             assertTrue(sel.selectedKeys().contains(key1));
576             assertTrue(sel.selectedKeys().contains(key2));
577 
578             // cancel key1
579             key1.cancel();
580             int n = sel.selectNow(k -&gt; assertTrue(k == key2));
581             assertTrue(n == 1);
582             assertFalse(sel.keys().contains(key1));
583             assertTrue(sel.keys().contains(key2));
584             assertFalse(sel.selectedKeys().contains(key1));
585             assertTrue(sel.selectedKeys().contains(key2));
586 
587             // cancel key2
588             key2.cancel();
589             n = sel.selectNow(k -&gt; assertTrue(false));
590             assertTrue(n == 0);
591             assertFalse(sel.keys().contains(key1));
592             assertFalse(sel.keys().contains(key2));
593             assertFalse(sel.selectedKeys().contains(key1));
594             assertFalse(sel.selectedKeys().contains(key2));
595         } finally {
596             closePipe(p);
597         }
598     }
599 
600     /**
601      * Test an action invoking select()
602      */
603     public void testReentrantSelect1() throws Exception {
604         Pipe p = Pipe.open();
605         try (Selector sel = Selector.open()) {
606             Pipe.SinkChannel sink = p.sink();
607             Pipe.SourceChannel source = p.source();
608             source.configureBlocking(false);
609             source.register(sel, SelectionKey.OP_READ);
610 
611             // write to sink to ensure that the source is readable
612             scheduleWrite(sink, messageBuffer(), 100, MILLISECONDS);
613 
614             int n = sel.select(k -&gt; {
615                 try {
616                     sel.select();
617                     assertTrue(false);
618                 } catch (IOException ioe) {
619                     throw new RuntimeException(ioe);
620                 } catch (IllegalStateException expected) {
621                 }
622             });
623             assertTrue(n == 1);
624         } finally {
625             closePipe(p);
626         }
627     }
628 
629     /**
630      * Test an action invoking selectNow()
631      */
632     public void testReentrantSelect2() throws Exception {
633         Pipe p = Pipe.open();
634         try (Selector sel = Selector.open()) {
635             Pipe.SinkChannel sink = p.sink();
636             Pipe.SourceChannel source = p.source();
637 
638             // write to sink to ensure that the source is readable
639             scheduleWrite(sink, messageBuffer(), 100, MILLISECONDS);
640 
641             source.configureBlocking(false);
642             source.register(sel, SelectionKey.OP_READ);
643             int n = sel.select(k -&gt; {
644                 try {
645                     sel.selectNow();
646                     assertTrue(false);
647                 } catch (IOException ioe) {
648                     throw new RuntimeException(ioe);
649                 } catch (IllegalStateException expected) {
650                 }
651             });
652             assertTrue(n == 1);
653         } finally {
654             closePipe(p);
655         }
656     }
657 
658     /**
659      * Test an action invoking select(Consumer)
660      */
661     public void testReentrantSelect3() throws Exception {
662         Pipe p = Pipe.open();
663         try (Selector sel = Selector.open()) {
664             Pipe.SinkChannel sink = p.sink();
665             Pipe.SourceChannel source = p.source();
666 
667             // write to sink to ensure that the source is readable
668             scheduleWrite(sink, messageBuffer(), 100, MILLISECONDS);
669 
670             source.configureBlocking(false);
671             source.register(sel, SelectionKey.OP_READ);
672             int n = sel.select(k -&gt; {
673                 try {
674                     sel.select(x -&gt; assertTrue(false));
675                     assertTrue(false);
676                 } catch (IOException ioe) {
677                     throw new RuntimeException(ioe);
678                 } catch (IllegalStateException expected) {
679                 }
680             });
681             assertTrue(n == 1);
682         } finally {
683             closePipe(p);
684         }
685     }
686 
687     /**
688      * Negative timeout
689      */
690     @Test(expectedExceptions = IllegalArgumentException.class)
691     public void testNegativeTimeout() throws Exception {
692         try (Selector sel = Selector.open()) {
693             sel.select(k -&gt; { }, -1L);
694         }
695     }
696 
697     /**
698      * Null action
699      */
700     @Test(expectedExceptions = NullPointerException.class)
701     public void testNull1() throws Exception {
702         try (Selector sel = Selector.open()) {
703             sel.select(null);
704         }
705     }
706     @Test(expectedExceptions = NullPointerException.class)
707     public void testNull2() throws Exception {
708         try (Selector sel = Selector.open()) {
709             sel.select(null, 1000);
710         }
711     }
712     @Test(expectedExceptions = NullPointerException.class)
713     public void testNull3() throws Exception {
714         try (Selector sel = Selector.open()) {
715             sel.selectNow(null);
716         }
717     }
718 
719 
720     // -- support methods ---
721 
722     private final ScheduledExecutorService POOL = Executors.newScheduledThreadPool(1);
723 
724     @AfterTest
725     void shutdownThreadPool() {
726         POOL.shutdown();
727     }
728 
729     void scheduleWakeup(Selector sel, long delay, TimeUnit unit) {
730         POOL.schedule(() -&gt; sel.wakeup(), delay, unit);
731     }
732 
733     void scheduleInterrupt(Thread t, long delay, TimeUnit unit) {
734         POOL.schedule(() -&gt; t.interrupt(), delay, unit);
735     }
736 
737     void scheduleClose(Closeable c, long delay, TimeUnit unit) {
738         POOL.schedule(() -&gt; {
739             try {
740                 c.close();
741             } catch (IOException ioe) {
742                 ioe.printStackTrace();
743             }
744         }, delay, unit);
745     }
746 
747     void scheduleWrite(WritableByteChannel sink, ByteBuffer buf, long delay, TimeUnit unit) {
748         POOL.schedule(() -&gt; {
749             try {
750                 sink.write(buf);
751             } catch (IOException ioe) {
752                 ioe.printStackTrace();
753             }
754         }, delay, unit);
755     }
756 
757     static void closePipe(Pipe p) {
758         try { p.sink().close(); } catch (IOException ignore) { }
759         try { p.source().close(); } catch (IOException ignore) { }
760     }
761 
762     static ByteBuffer messageBuffer() {
763         try {
764             return ByteBuffer.wrap(&quot;message&quot;.getBytes(&quot;UTF-8&quot;));
765         } catch (Exception e) {
766             throw new RuntimeException(e);
767         }
768     }
769 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/nio/channels/DatagramChannel/ManySourcesAndTargets.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 8234805 8235193
 26  * @summary Test DatagramChannel send/receive and that receive returns the expected
 27  *     sender address
 28  * @run main ManySourcesAndTargets
 29  * @run main/othervm -Djava.net.preferIPv4Stack=true ManySourcesAndTargets
 30  */
 31 
 32 import java.io.ByteArrayInputStream;
 33 import java.io.ByteArrayOutputStream;
 34 import java.io.ObjectInputStream;
 35 import java.io.ObjectOutputStream;
 36 import java.net.InetAddress;
 37 import java.net.InetSocketAddress;
 38 import java.net.NetworkInterface;
 39 import java.net.SocketAddress;
 40 import java.net.SocketException;
 41 import java.nio.ByteBuffer;
 42 import java.nio.channels.DatagramChannel;
 43 import java.util.List;
 44 import java.util.Optional;
 45 import java.util.stream.Collectors;
 46 import java.util.stream.Stream;
 47 
 48 public class ManySourcesAndTargets {
 49     public static void main(String[] args) throws Exception {
 50 
 51         // use addresses on interfaces that have the loopback and local host
 52         InetAddress lh = InetAddress.getLocalHost();
 53         InetAddress lb = InetAddress.getLoopbackAddress();
 54         List&lt;InetAddress&gt; addresses = Stream.of(lh, lb)
 55                 .map(ManySourcesAndTargets::networkInterface)
 56                 .flatMap(Optional::stream)
 57                 .flatMap(NetworkInterface::inetAddresses)
 58                 .filter(ia -&gt; !ia.isAnyLocalAddress())
 59                 .distinct()
 60                 .collect(Collectors.toList());
 61 
 62         // Test DatagramChannel.send
 63         try (DatagramChannel reader = DatagramChannel.open()) {
 64             // bind reader to wildcard address so it can receive from any address
 65             reader.bind(new InetSocketAddress(0));
 66             for (InetAddress address : addresses) {
 67                 System.out.format(&quot;%n-- %s --%n&quot;, address.getHostAddress());
 68 
 69                 // send 3 datagrams from the given address to the reader
 70                 testSend(3, address, reader);
 71             }
 72         }
 73 
 74         // Test DatagramChannel.receive
 75         try (DatagramChannel sender = DatagramChannel.open()) {
 76             // bind sender to wildcard address so it can send to any address
 77             sender.bind(new InetSocketAddress(0));
 78             for (InetAddress address : addresses) {
 79                 System.out.format(&quot;%n-- %s --%n&quot;, address.getHostAddress());
 80 
 81                 // send 3 datagrams to a datagram bound to the given address
 82                 testReceive(3, sender, address);
 83             }
 84         }
 85     }
 86 
 87     /**
 88      * Creates a sender DatagramChannel bound to the given address and uses it to
 89      * sends datagrams to the given reader. The reader receives the datagrams and
 90      * checks the source/sender address.
 91      */
 92     static void testSend(int count, InetAddress address, DatagramChannel reader) throws Exception {
 93         int remotePort = reader.socket().getLocalPort();
 94         InetSocketAddress remote = new InetSocketAddress(address, remotePort);
 95 
 96         try (DatagramChannel sender = DatagramChannel.open()) {
 97             sender.bind(new InetSocketAddress(address, 0));
 98 
 99             SocketAddress local = sender.getLocalAddress();
100             byte[] bytes = serialize(local);
101 
102             SocketAddress previousSource = null;
103             for (int i = 0; i &lt; count; i++) {
104                 System.out.format(&quot;send %s -&gt; %s%n&quot;, local, remote);
105                 sender.send(ByteBuffer.wrap(bytes), remote);
106 
107                 ByteBuffer bb = ByteBuffer.allocate(1000);
108                 SocketAddress source = reader.receive(bb);
109                 System.out.format(&quot;received datagram from %s%n&quot;, source);
110 
111                 // check source address and payload
112                 SocketAddress payload = deserialize(bb.array());
113                 if (!source.equals(local))
114                     throw new RuntimeException(&quot;source=&quot; + source + &quot;, expected=&quot; + local);
115                 if (!payload.equals(local))
116                     throw new RuntimeException(&quot;payload=&quot; + payload + &quot;, expected=&quot; + local);
117 
118                 // check that cached source was used
119                 if (previousSource == null) {
120                     previousSource = source;
121                 } else if (source != previousSource) {
122                     throw new RuntimeException(&quot;Cached SocketAddress not returned&quot;);
123                 }
124             }
125         }
126     }
127 
128     /**
129      * Creates a reader DatagramChannel bound to the given address uses the given
130      * sender to send datagrams to that reader. The reader receives the datagrams.
131      */
132     static void testReceive(int count, DatagramChannel sender, InetAddress address) throws Exception {
133         SocketAddress local = sender.getLocalAddress();
134 
135         try (DatagramChannel reader = DatagramChannel.open()) {
136             // bind to the given address
137             reader.bind(new InetSocketAddress(address, 0));
138 
139             SocketAddress remote = reader.getLocalAddress();
140 
141             for (int i = 0; i &lt; count; i++) {
142                 System.out.format(&quot;send %s -&gt; %s%n&quot;, local, remote);
143                 reader.send(ByteBuffer.allocate(32), remote);
144 
145                 ByteBuffer bb = ByteBuffer.allocate(1000);
146                 SocketAddress source = reader.receive(bb);
147                 System.out.format(&quot;received datagram from %s%n&quot;, source);
148             }
149         }
150     }
151 
152     private static byte[] serialize(SocketAddress address) throws Exception {
153         ByteArrayOutputStream baos = new ByteArrayOutputStream();
154         ObjectOutputStream oos = new ObjectOutputStream(baos);
155         oos.writeObject(address);
156         oos.close();
157         return baos.toByteArray();
158     }
159 
160     private static SocketAddress deserialize(byte[] bytes) throws Exception {
161         ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
162         ObjectInputStream ois = new ObjectInputStream(bais);
163         return (SocketAddress) ois.readObject();
164     }
165 
166     private static Optional&lt;NetworkInterface&gt; networkInterface(InetAddress ia) {
167         try {
168             return Optional.ofNullable(NetworkInterface.getByInetAddress(ia));
169         } catch (SocketException e) {
170             return Optional.empty();
171         }
172     }
173 }
    </pre>
  </body>
</html>
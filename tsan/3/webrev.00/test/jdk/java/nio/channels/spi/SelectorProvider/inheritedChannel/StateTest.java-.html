<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/nio/channels/spi/SelectorProvider/inheritedChannel/StateTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  *
 26  *
 27  * Tests that the channel returned by System.inheritedChannel()
 28  * is in blocking mode, bound, and in the case of a SocketChannel
 29  * connected to a peer.
 30  *
 31  * The test works by launching a test service (called StateTestService) so
 32  * that it inherits each type of channel. The test service checks the
 33  * socket state and replies back to this class via an out-of-band
 34  * channel.
 35  */
 36 import java.io.IOException;
 37 import java.net.InetSocketAddress;
 38 import java.nio.ByteBuffer;
 39 import java.nio.channels.DatagramChannel;
 40 import java.nio.channels.SelectionKey;
 41 import java.nio.channels.Selector;
 42 import java.nio.channels.ServerSocketChannel;
 43 import java.nio.channels.SocketChannel;
 44 
 45 import jdk.test.lib.Utils;
 46 
 47 public class StateTest {
 48 
 49     private static int failures = 0;
 50 
 51     private static String TEST_SERVICE = &quot;StateTestService&quot;;
 52 
 53     /*
 54      * Reads the test result from the &quot;out-of-band&quot; connection to the test service.
 55      *
 56      * The out-of-band connection is just a TCP connection from the service to
 57      * this class. waitForTestResult just waits (with timeout) for the service
 58      * to connect. Once connected it waits (with timeout) for the test result.
 59      * The test result is examined.
 60      */
 61     private static void waitForTestResult(ServerSocketChannel ssc, boolean expectFail) throws IOException {
 62         Selector sel = ssc.provider().openSelector();
 63         SelectionKey sk;
 64         SocketChannel sc;
 65 
 66         /*
 67          * Wait for service to connect
 68          */
 69         ssc.configureBlocking(false);
 70         sk = ssc.register(sel, SelectionKey.OP_ACCEPT);
 71         long to = Utils.adjustTimeout(15*1000);
 72         sc = null;
 73         for (;;) {
 74             long st = System.currentTimeMillis();
 75             sel.select(to);
 76             if (sk.isAcceptable() &amp;&amp; ((sc = ssc.accept()) != null)) {
 77                 // connection established
 78                 break;
 79             }
 80             sel.selectedKeys().remove(sk);
 81             to -= System.currentTimeMillis() - st;
 82             if (to &lt;= 0) {
 83                 throw new IOException(&quot;Timed out waiting for service to report test result&quot;);
 84             }
 85         }
 86         sk.cancel();
 87         ssc.configureBlocking(false);
 88 
 89         /*
 90          * Wait for service to report test result
 91          */
 92         sc.configureBlocking(false);
 93         sk = sc.register(sel, SelectionKey.OP_READ);
 94         to = Utils.adjustTimeout(5000);
 95         ByteBuffer bb = ByteBuffer.allocateDirect(20);
 96         for (;;) {
 97             long st = System.currentTimeMillis();
 98             sel.select(to);
 99             if (sk.isReadable()) {
100                 int n = sc.read(bb);
101                 if (n &gt; 0) {
102                     break;
103                 }
104                 if (n &lt; 0) {
105                     throw new IOException(&quot;Premature EOF - no test result from service&quot;);
106                 }
107             }
108             sel.selectedKeys().remove(sk);
109             to -= System.currentTimeMillis() - st;
110             if (to &lt;= 0) {
111                 throw new IOException(&quot;Timed out waiting for service to report test result&quot;);
112             }
113         }
114         sk.cancel();
115         sc.close();
116         sel.close();
117 
118         /*
119          * Examine the test result
120          */
121         bb.flip();
122         byte b = bb.get();
123 
124         if (expectFail &amp;&amp; b == &#39;P&#39;) {
125             System.err.println(&quot;Test passed - test is expected to fail!!!&quot;);
126             failures++;
127         }
128         if (!expectFail &amp;&amp; b != &#39;P&#39;) {
129             System.err.println(&quot;Test failed!&quot;);
130             failures++;
131         }
132     }
133 
134     public static void main(String args[]) throws IOException {
135         boolean expectFail = false;
136 
137         /*
138          *   [-expectFail] [options...]
139          */
140         String options[] = args;
141         if (args.length &gt; 0 &amp;&amp; args[0].equals(&quot;-expectFail&quot;)) {
142             // shift out first arg to create options
143             expectFail = true;
144             options = new String[args.length-1];
145             if (args.length &gt; 1) {
146                 System.arraycopy(args, 1, options, 0, args.length-1);
147             }
148         }
149 
150         /*
151          * Create the listener which will be used to read the test result
152          * from the service.
153          */
154         ServerSocketChannel ssc = ServerSocketChannel.open();
155         ssc.socket().bind(new InetSocketAddress(0));
156 
157         /*
158          * The port is passed to the service as an argument.
159          */
160         int port = ssc.socket().getLocalPort();
161         String arg[] = new String[1];
162         arg[0] = String.valueOf(port);
163 
164         /*
165          * Launch service with a SocketChannel (tcp nowait)
166          */
167         SocketChannel sc = Launcher.launchWithSocketChannel(TEST_SERVICE, options, arg);
168         waitForTestResult(ssc, expectFail);
169         sc.close();
170 
171         /*
172          * Launch service with a ServerSocketChannel (tcp wait)
173          * launchWithServerSocketChannel establishes a connection to the service
174          * and the returned SocketChannel is connected to the service.
175          */
176         sc = Launcher.launchWithServerSocketChannel(TEST_SERVICE, options, arg);
177         waitForTestResult(ssc, expectFail);
178         sc.close();
179 
180         /*
181          * Launch service with a DatagramChannel (udp wait)
182          */
183         DatagramChannel dc = Launcher.launchWithDatagramChannel(TEST_SERVICE, options, arg);
184         waitForTestResult(ssc, expectFail);
185         dc.close();
186 
187         if (failures &gt; 0) {
188             throw new RuntimeException(&quot;Test failed - see log for details&quot;);
189         } else {
190             System.out.println(&quot;All tests passed.&quot;);
191         }
192     }
193 }
    </pre>
  </body>
</html>
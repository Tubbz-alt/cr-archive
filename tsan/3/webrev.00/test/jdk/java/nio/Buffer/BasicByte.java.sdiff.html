<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/nio/Buffer/BasicByte.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="Basic.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../channels/AsynchronousSocketChannel/Basic.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/nio/Buffer/BasicByte.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /* Type-specific source code for unit test
  25  *
  26  * Regenerate the BasicX classes via genBasic.sh whenever this file changes.
  27  * We check in the generated source files so that the test tree can be used
  28  * independently of the rest of the source tree.
  29  */
  30 
  31 // -- This file was mechanically generated: Do not edit! -- //
  32 




  33 import java.nio.*;
  34 






  35 
  36 public class BasicByte
  37     extends Basic
  38 {
  39 
  40     private static final byte[] VALUES = {
  41         Byte.MIN_VALUE,
  42         (byte) -1,
  43         (byte) 0,
  44         (byte) 1,
  45         Byte.MAX_VALUE,
  46 
  47 
  48 
  49 
  50 
  51 
  52 
  53 
  54 
</pre>
<hr />
<pre>
 452 
 453                 if (as.alignmentOffset(0, us) != 0)
 454                     fail(&quot;Buffer not correctly aligned at index 0&quot;, as);
 455 
 456                 if (as.alignmentOffset(as.limit(), us) != 0)
 457                     fail(&quot;Buffer not correctly aligned at limit&quot;, as);
 458 
 459                 int p_mod = ab.alignmentOffset(p, us);
 460                 int l_mod = ab.alignmentOffset(l, us);
 461                 // Round up position
 462                 p = (p_mod &gt; 0) ? p + (us - p_mod) : p;
 463                 // Round down limit
 464                 l = l - l_mod;
 465 
 466                 int ec = l - p;
 467                 if (as.limit() != ec) {
 468                     fail(&quot;Buffer capacity incorrect, expected: &quot; + ec, as);
 469                 }
 470             }
 471         }



































































 472     }
 473 
 474 
 475     private static void fail(String problem,
 476                              ByteBuffer xb, ByteBuffer yb,
 477                              byte x, byte y) {
 478         fail(problem + String.format(&quot;: x=%s y=%s&quot;, x, y), xb, yb);
 479     }
 480 
 481     private static void catchNullArgument(Buffer b, Runnable thunk) {
 482         tryCatch(b, NullPointerException.class, thunk);
 483     }
 484 
 485     private static void catchIllegalArgument(Buffer b, Runnable thunk) {
 486         tryCatch(b, IllegalArgumentException.class, thunk);
 487     }
 488 
 489     private static void catchReadOnlyBuffer(Buffer b, Runnable thunk) {
 490         tryCatch(b, ReadOnlyBufferException.class, thunk);
 491     }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /* Type-specific source code for unit test
  25  *
  26  * Regenerate the BasicX classes via genBasic.sh whenever this file changes.
  27  * We check in the generated source files so that the test tree can be used
  28  * independently of the rest of the source tree.
  29  */
  30 
  31 // -- This file was mechanically generated: Do not edit! -- //
  32 
<span class="line-added">  33 </span>
<span class="line-added">  34 import java.io.IOException;</span>
<span class="line-added">  35 import java.io.UncheckedIOException;</span>
<span class="line-added">  36 </span>
  37 import java.nio.*;
  38 
<span class="line-added">  39 import java.nio.channels.FileChannel;</span>
<span class="line-added">  40 import java.nio.file.Files;</span>
<span class="line-added">  41 import java.nio.file.Path;</span>
<span class="line-added">  42 import java.util.Random;</span>
<span class="line-added">  43 </span>
<span class="line-added">  44 </span>
  45 
  46 public class BasicByte
  47     extends Basic
  48 {
  49 
  50     private static final byte[] VALUES = {
  51         Byte.MIN_VALUE,
  52         (byte) -1,
  53         (byte) 0,
  54         (byte) 1,
  55         Byte.MAX_VALUE,
  56 
  57 
  58 
  59 
  60 
  61 
  62 
  63 
  64 
</pre>
<hr />
<pre>
 462 
 463                 if (as.alignmentOffset(0, us) != 0)
 464                     fail(&quot;Buffer not correctly aligned at index 0&quot;, as);
 465 
 466                 if (as.alignmentOffset(as.limit(), us) != 0)
 467                     fail(&quot;Buffer not correctly aligned at limit&quot;, as);
 468 
 469                 int p_mod = ab.alignmentOffset(p, us);
 470                 int l_mod = ab.alignmentOffset(l, us);
 471                 // Round up position
 472                 p = (p_mod &gt; 0) ? p + (us - p_mod) : p;
 473                 // Round down limit
 474                 l = l - l_mod;
 475 
 476                 int ec = l - p;
 477                 if (as.limit() != ec) {
 478                     fail(&quot;Buffer capacity incorrect, expected: &quot; + ec, as);
 479                 }
 480             }
 481         }
<span class="line-added"> 482 </span>
<span class="line-added"> 483         // mapped buffers</span>
<span class="line-added"> 484         try {</span>
<span class="line-added"> 485             for (MappedByteBuffer bb : mappedBuffers()) {</span>
<span class="line-added"> 486                 try {</span>
<span class="line-added"> 487                     int offset = bb.alignmentOffset(1, 4);</span>
<span class="line-added"> 488                     ck(bb, offset &gt;= 0);</span>
<span class="line-added"> 489                 } catch (UnsupportedOperationException e) {</span>
<span class="line-added"> 490                     System.out.println(&quot;Not applicable, UOE thrown: &quot;);</span>
<span class="line-added"> 491                 }</span>
<span class="line-added"> 492             }</span>
<span class="line-added"> 493         } catch (IOException e) {</span>
<span class="line-added"> 494             throw new UncheckedIOException(e);</span>
<span class="line-added"> 495         }</span>
<span class="line-added"> 496 </span>
<span class="line-added"> 497         // alignment identities</span>
<span class="line-added"> 498         final int maxPow2 = 12;</span>
<span class="line-added"> 499         ByteBuffer bb = ByteBuffer.allocateDirect(1 &lt;&lt; maxPow2); // cap 4096</span>
<span class="line-added"> 500 </span>
<span class="line-added"> 501         Random rnd = new Random();</span>
<span class="line-added"> 502         long seed = rnd.nextLong();</span>
<span class="line-added"> 503         rnd = new Random(seed);</span>
<span class="line-added"> 504 </span>
<span class="line-added"> 505         for (int i = 0; i &lt; 100; i++) {</span>
<span class="line-added"> 506             // 1 == 2^0 &lt;= unitSize == 2^k &lt;= bb.capacity()/2</span>
<span class="line-added"> 507             int unitSize = 1 &lt;&lt; rnd.nextInt(maxPow2);</span>
<span class="line-added"> 508             // 0 &lt;= index &lt; 2*unitSize</span>
<span class="line-added"> 509             int index = rnd.nextInt(unitSize &lt;&lt; 1);</span>
<span class="line-added"> 510             int value = bb.alignmentOffset(index, unitSize);</span>
<span class="line-added"> 511             try {</span>
<span class="line-added"> 512                 if (value &lt; 0 || value &gt;= unitSize) {</span>
<span class="line-added"> 513                     throw new RuntimeException(value + &quot; &lt; 0 || &quot; +</span>
<span class="line-added"> 514                         value + &quot; &gt;= &quot; + unitSize);</span>
<span class="line-added"> 515                 }</span>
<span class="line-added"> 516                 if (value &lt;= index &amp;&amp;</span>
<span class="line-added"> 517                     bb.alignmentOffset(index - value, unitSize) != 0)</span>
<span class="line-added"> 518                     throw new RuntimeException(&quot;Identity 1&quot;);</span>
<span class="line-added"> 519                 if (bb.alignmentOffset(index + (unitSize - value),</span>
<span class="line-added"> 520                     unitSize) != 0)</span>
<span class="line-added"> 521                     throw new RuntimeException(&quot;Identity 2&quot;);</span>
<span class="line-added"> 522             } catch (RuntimeException re) {</span>
<span class="line-added"> 523                 System.err.format(&quot;seed %d, index %d, unitSize %d, value %d%n&quot;,</span>
<span class="line-added"> 524                     seed, index, unitSize, value);</span>
<span class="line-added"> 525                 throw re;</span>
<span class="line-added"> 526             }</span>
<span class="line-added"> 527         }</span>
<span class="line-added"> 528     }</span>
<span class="line-added"> 529 </span>
<span class="line-added"> 530     private static MappedByteBuffer[] mappedBuffers() throws IOException {</span>
<span class="line-added"> 531         return new MappedByteBuffer[]{</span>
<span class="line-added"> 532                 createMappedBuffer(new byte[]{0, 1, 2, 3}),</span>
<span class="line-added"> 533                 createMappedBuffer(new byte[]{0, 1, 2, -3,</span>
<span class="line-added"> 534                     45, 6, 7, 78, 3, -7, 6, 7, -128, 127}),</span>
<span class="line-added"> 535         };</span>
<span class="line-added"> 536     }</span>
<span class="line-added"> 537 </span>
<span class="line-added"> 538     private static MappedByteBuffer createMappedBuffer(byte[] contents)</span>
<span class="line-added"> 539         throws IOException {</span>
<span class="line-added"> 540         Path tempFile = Files.createTempFile(&quot;mbb&quot;, null);</span>
<span class="line-added"> 541         tempFile.toFile().deleteOnExit();</span>
<span class="line-added"> 542         Files.write(tempFile, contents);</span>
<span class="line-added"> 543         try (FileChannel fc = FileChannel.open(tempFile)) {</span>
<span class="line-added"> 544             MappedByteBuffer map =</span>
<span class="line-added"> 545                 fc.map(FileChannel.MapMode.READ_ONLY, 0, contents.length);</span>
<span class="line-added"> 546             map.load();</span>
<span class="line-added"> 547             return map;</span>
<span class="line-added"> 548         }</span>
 549     }
 550 
 551 
 552     private static void fail(String problem,
 553                              ByteBuffer xb, ByteBuffer yb,
 554                              byte x, byte y) {
 555         fail(problem + String.format(&quot;: x=%s y=%s&quot;, x, y), xb, yb);
 556     }
 557 
 558     private static void catchNullArgument(Buffer b, Runnable thunk) {
 559         tryCatch(b, NullPointerException.class, thunk);
 560     }
 561 
 562     private static void catchIllegalArgument(Buffer b, Runnable thunk) {
 563         tryCatch(b, IllegalArgumentException.class, thunk);
 564     }
 565 
 566     private static void catchReadOnlyBuffer(Buffer b, Runnable thunk) {
 567         tryCatch(b, ReadOnlyBufferException.class, thunk);
 568     }
</pre>
</td>
</tr>
</table>
<center><a href="Basic.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../channels/AsynchronousSocketChannel/Basic.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
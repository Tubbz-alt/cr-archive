<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/com/sun/jndi/ldap/LdapTimeoutTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="LdapDnsProviderTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../management/HotSpotDiagnosticMXBean/CheckOrigin.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/com/sun/jndi/ldap/LdapTimeoutTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
<span class="line-modified"> 24 /**</span>
 25  * @test
<span class="line-modified"> 26  * @run main/othervm LdapTimeoutTest</span>
<span class="line-modified"> 27  * @bug 7094377 8000487 6176036 7056489</span>


 28  * @summary Timeout tests for ldap
 29  */
 30 










 31 import java.net.Socket;
<span class="line-removed"> 32 import java.net.ServerSocket;</span>
<span class="line-removed"> 33 import java.net.SocketTimeoutException;</span>
<span class="line-removed"> 34 import java.io.*;</span>
<span class="line-removed"> 35 import javax.naming.*;</span>
<span class="line-removed"> 36 import javax.naming.directory.*;</span>
<span class="line-removed"> 37 import java.util.List;</span>
<span class="line-removed"> 38 import java.util.Hashtable;</span>
 39 import java.util.ArrayList;



 40 import java.util.concurrent.Callable;

 41 import java.util.concurrent.ExecutionException;
<span class="line-removed"> 42 import java.util.concurrent.Executors;</span>
 43 import java.util.concurrent.ExecutorService;

 44 import java.util.concurrent.Future;
<span class="line-modified"> 45 import java.util.concurrent.ScheduledExecutorService;</span>
<span class="line-modified"> 46 import java.util.concurrent.ScheduledFuture;</span>
<span class="line-removed"> 47 import java.util.concurrent.TimeoutException;</span>
 48 import java.util.concurrent.TimeUnit;
<span class="line-modified"> 49 import javax.net.ssl.SSLHandshakeException;</span>
 50 

 51 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 52 import static java.util.concurrent.TimeUnit.NANOSECONDS;



 53 

 54 
<span class="line-modified"> 55 abstract class LdapTest implements Callable {</span>
<span class="line-modified"> 56 </span>
<span class="line-modified"> 57     Hashtable env;</span>
<span class="line-modified"> 58     TestServer server;</span>
<span class="line-modified"> 59     ScheduledExecutorService killSwitchPool;</span>
<span class="line-modified"> 60     boolean passed = false;</span>
<span class="line-modified"> 61     private int HANGING_TEST_TIMEOUT = 20_000;</span>
<span class="line-modified"> 62 </span>
<span class="line-modified"> 63     public LdapTest (TestServer server, Hashtable env) {</span>
<span class="line-modified"> 64         this.server = server;</span>
<span class="line-modified"> 65         this.env = env;</span>
<span class="line-modified"> 66     }</span>
<span class="line-modified"> 67 </span>
<span class="line-modified"> 68     public LdapTest(TestServer server, Hashtable env,</span>
<span class="line-modified"> 69             ScheduledExecutorService killSwitchPool)</span>
<span class="line-modified"> 70     {</span>
<span class="line-modified"> 71         this(server, env);</span>
<span class="line-modified"> 72         this.killSwitchPool = killSwitchPool;</span>
<span class="line-modified"> 73     }</span>
<span class="line-modified"> 74 </span>
<span class="line-modified"> 75     public abstract void performOp(InitialContext ctx) throws NamingException;</span>
<span class="line-modified"> 76     public abstract void handleNamingException(</span>
<span class="line-modified"> 77         NamingException e, long start, long end);</span>
<span class="line-removed"> 78 </span>
<span class="line-removed"> 79     public void pass() {</span>
<span class="line-removed"> 80         this.passed = true;</span>
<span class="line-removed"> 81     }</span>
<span class="line-removed"> 82 </span>
<span class="line-removed"> 83     public void fail() {</span>
<span class="line-removed"> 84         throw new RuntimeException(&quot;Test failed&quot;);</span>
 85     }
 86 
<span class="line-modified"> 87     public void fail(Exception e) {</span>
<span class="line-modified"> 88         throw new RuntimeException(&quot;Test failed&quot;, e);</span>

 89     }
 90 
<span class="line-modified"> 91     boolean shutItDown(InitialContext ctx) {</span>












 92         try {
<span class="line-modified"> 93             if (ctx != null) ctx.close();</span>
<span class="line-modified"> 94             return true;</span>
<span class="line-modified"> 95         } catch (NamingException ex) {</span>
<span class="line-modified"> 96             return false;</span>





 97         }
<span class="line-modified"> 98     }</span>
<span class="line-modified"> 99 </span>
<span class="line-removed">100     public Boolean call() {</span>
<span class="line-removed">101         InitialContext ctx = null;</span>
<span class="line-removed">102         ScheduledFuture killer = null;</span>
<span class="line-removed">103         long start = System.nanoTime();</span>
<span class="line-removed">104 </span>
<span class="line-removed">105         try {</span>
<span class="line-removed">106             while(!server.accepting())</span>
<span class="line-removed">107                 Thread.sleep(200); // allow the server to start up</span>
<span class="line-removed">108             Thread.sleep(200); // to be sure</span>
<span class="line-removed">109 </span>
<span class="line-removed">110             // if this is a hanging test, scheduled a thread to</span>
<span class="line-removed">111             // interrupt after a certain time</span>
<span class="line-removed">112             if (killSwitchPool != null) {</span>
<span class="line-removed">113                 final Thread current = Thread.currentThread();</span>
<span class="line-removed">114                 killer = killSwitchPool.schedule(</span>
<span class="line-removed">115                     new Callable&lt;Void&gt;() {</span>
<span class="line-removed">116                         public Void call() throws Exception {</span>
<span class="line-removed">117                             current.interrupt();</span>
<span class="line-removed">118                             return null;</span>
<span class="line-removed">119                         }</span>
<span class="line-removed">120                     }, HANGING_TEST_TIMEOUT, MILLISECONDS);</span>
<span class="line-removed">121             }</span>
<span class="line-removed">122 </span>
<span class="line-removed">123             env.put(Context.PROVIDER_URL, &quot;ldap://localhost:&quot; +</span>
<span class="line-removed">124                     server.getLocalPort());</span>
<span class="line-removed">125 </span>
126             try {
<span class="line-modified">127                 ctx = new InitialDirContext(env);</span>
<span class="line-modified">128                 performOp(ctx);</span>
<span class="line-modified">129                 fail();</span>
<span class="line-modified">130             } catch (NamingException e) {</span>
<span class="line-removed">131                 long end = System.nanoTime();</span>
<span class="line-removed">132                 System.out.println(this.getClass().toString() + &quot; - elapsed: &quot;</span>
<span class="line-removed">133                         + NANOSECONDS.toMillis(end - start));</span>
<span class="line-removed">134                 handleNamingException(e, start, end);</span>
<span class="line-removed">135             } finally {</span>
<span class="line-removed">136                 if (killer != null &amp;&amp; !killer.isDone())</span>
<span class="line-removed">137                     killer.cancel(true);</span>
<span class="line-removed">138                 shutItDown(ctx);</span>
<span class="line-removed">139                 server.close();</span>
140             }
<span class="line-removed">141             return passed;</span>
<span class="line-removed">142         } catch (IOException|InterruptedException e) {</span>
<span class="line-removed">143             throw new RuntimeException(e);</span>
144         }


145     }
<span class="line-removed">146 }</span>
<span class="line-removed">147 </span>
<span class="line-removed">148 abstract class ReadServerTest extends LdapTest {</span>
149 
<span class="line-modified">150     public ReadServerTest(Hashtable env) throws IOException {</span>
<span class="line-modified">151         super(new BindableServer(), env);</span>














152     }
153 
<span class="line-modified">154     public ReadServerTest(Hashtable env,</span>
<span class="line-modified">155                           ScheduledExecutorService killSwitchPool)</span>
<span class="line-modified">156             throws IOException</span>
<span class="line-modified">157     {</span>
<span class="line-modified">158         super(new BindableServer(), env, killSwitchPool);</span>









159     }
160 
<span class="line-modified">161     public void performOp(InitialContext ctx) throws NamingException {</span>
<span class="line-modified">162         SearchControls scl = new SearchControls();</span>
<span class="line-modified">163         scl.setSearchScope(SearchControls.SUBTREE_SCOPE);</span>
<span class="line-modified">164         NamingEnumeration&lt;SearchResult&gt; answer = ((InitialDirContext)ctx)</span>
<span class="line-modified">165             .search(&quot;ou=People,o=JNDITutorial&quot;, &quot;(objectClass=*)&quot;, scl);</span>








166     }
<span class="line-removed">167 }</span>
<span class="line-removed">168 </span>
<span class="line-removed">169 abstract class DeadServerTest extends LdapTest {</span>
170 
<span class="line-modified">171     public DeadServerTest(Hashtable env) throws IOException {</span>
<span class="line-modified">172         super(new DeadServer(), env);</span>

















173     }
174 
<span class="line-modified">175     public DeadServerTest(Hashtable env,</span>
<span class="line-modified">176                           ScheduledExecutorService killSwitchPool)</span>
<span class="line-modified">177             throws IOException</span>
<span class="line-modified">178     {</span>
<span class="line-modified">179         super(new DeadServer(), env, killSwitchPool);</span>

















180     }
181 
<span class="line-modified">182     public void performOp(InitialContext ctx) throws NamingException {}</span>
<span class="line-modified">183 }</span>
<span class="line-modified">184 </span>
<span class="line-modified">185 class DeadServerNoTimeoutTest extends DeadServerTest {</span>
<span class="line-modified">186 </span>
<span class="line-modified">187     public DeadServerNoTimeoutTest(Hashtable env,</span>
<span class="line-modified">188                                    ScheduledExecutorService killSwitchPool)</span>
<span class="line-modified">189             throws IOException</span>
<span class="line-modified">190     {</span>
<span class="line-modified">191         super(env, killSwitchPool);</span>









192     }
193 
<span class="line-modified">194     public void handleNamingException(NamingException e, long start, long end) {</span>
<span class="line-modified">195         if (e instanceof InterruptedNamingException) Thread.interrupted();</span>
<span class="line-modified">196 </span>
<span class="line-modified">197         if (NANOSECONDS.toMillis(end - start) &lt; LdapTimeoutTest.MIN_TIMEOUT) {</span>
<span class="line-modified">198             System.err.printf(&quot;DeadServerNoTimeoutTest fail: timeout should be &quot; +</span>
<span class="line-modified">199                               &quot;at least %s ms, actual time is %s ms%n&quot;,</span>
<span class="line-modified">200                               LdapTimeoutTest.MIN_TIMEOUT,</span>
<span class="line-modified">201                               NANOSECONDS.toMillis(end - start));</span>
<span class="line-modified">202             fail();</span>
<span class="line-modified">203         } else {</span>
<span class="line-modified">204             pass();</span>












205         }
206     }
<span class="line-removed">207 }</span>
208 
<span class="line-modified">209 class DeadServerTimeoutTest extends DeadServerTest {</span>
210 
<span class="line-modified">211     public DeadServerTimeoutTest(Hashtable env) throws IOException {</span>
<span class="line-removed">212         super(env);</span>
<span class="line-removed">213     }</span>
214 
<span class="line-modified">215     public void handleNamingException(NamingException e, long start, long end)</span>
<span class="line-removed">216     {</span>
<span class="line-removed">217         // non SSL connect will timeout via readReply using connectTimeout</span>
<span class="line-removed">218         if (NANOSECONDS.toMillis(end - start) &lt; 2_900) {</span>
<span class="line-removed">219             pass();</span>
<span class="line-removed">220         } else {</span>
<span class="line-removed">221             System.err.println(&quot;Fail: Waited too long&quot;);</span>
<span class="line-removed">222             fail();</span>
<span class="line-removed">223         }</span>
<span class="line-removed">224     }</span>
<span class="line-removed">225 }</span>
226 

227 
<span class="line-modified">228 class ReadServerNoTimeoutTest extends ReadServerTest {</span>



229 
<span class="line-modified">230     public ReadServerNoTimeoutTest(Hashtable env,</span>
<span class="line-modified">231                                    ScheduledExecutorService killSwitchPool)</span>
<span class="line-modified">232             throws IOException</span>
<span class="line-removed">233     {</span>
<span class="line-removed">234         super(env, killSwitchPool);</span>
235     }
236 
<span class="line-modified">237     public void handleNamingException(NamingException e, long start, long end) {</span>
<span class="line-modified">238         if (e instanceof InterruptedNamingException) Thread.interrupted();</span>
<span class="line-modified">239 </span>
<span class="line-modified">240         if (NANOSECONDS.toMillis(end - start) &lt; LdapTimeoutTest.MIN_TIMEOUT) {</span>
<span class="line-modified">241             System.err.printf(&quot;ReadServerNoTimeoutTest fail: timeout should be &quot; +</span>
<span class="line-modified">242                               &quot;at least %s ms, actual time is %s ms%n&quot;,</span>
<span class="line-modified">243                               LdapTimeoutTest.MIN_TIMEOUT,</span>
<span class="line-modified">244                               NANOSECONDS.toMillis(end - start));</span>
<span class="line-modified">245             fail();</span>
<span class="line-modified">246         } else {</span>
<span class="line-modified">247             pass();</span>










248         }
249     }
<span class="line-removed">250 }</span>
251 
<span class="line-modified">252 class ReadServerTimeoutTest extends ReadServerTest {</span>
253 
<span class="line-modified">254     public ReadServerTimeoutTest(Hashtable env) throws IOException {</span>
<span class="line-removed">255         super(env);</span>
<span class="line-removed">256     }</span>
257 
<span class="line-modified">258     public void handleNamingException(NamingException e, long start, long end) {</span>
<span class="line-modified">259         System.out.println(&quot;ReadServerTimeoutTest: end-start=&quot; + NANOSECONDS.toMillis(end - start));</span>
<span class="line-modified">260         if (NANOSECONDS.toMillis(end - start) &lt; 2_500) {</span>
<span class="line-modified">261             fail();</span>
<span class="line-modified">262         } else {</span>
<span class="line-modified">263             pass();</span>

264         }
265     }
<span class="line-removed">266 }</span>
<span class="line-removed">267 </span>
<span class="line-removed">268 class TestServer extends Thread {</span>
<span class="line-removed">269     ServerSocket serverSock;</span>
<span class="line-removed">270     boolean accepting = false;</span>
<span class="line-removed">271 </span>
<span class="line-removed">272     public TestServer() throws IOException {</span>
<span class="line-removed">273         this.serverSock = new ServerSocket(0);</span>
<span class="line-removed">274         start();</span>
<span class="line-removed">275     }</span>
276 
<span class="line-modified">277     public int getLocalPort() {</span>
<span class="line-modified">278         return serverSock.getLocalPort();</span>
<span class="line-modified">279     }</span>


















280 
<span class="line-modified">281     public boolean accepting() {</span>
<span class="line-modified">282         return accepting;</span>
<span class="line-removed">283     }</span>
284 
<span class="line-modified">285     public void close() throws IOException {</span>
<span class="line-modified">286         serverSock.close();</span>
<span class="line-modified">287     }</span>
<span class="line-modified">288 }</span>


289 
<span class="line-modified">290 class BindableServer extends TestServer {</span>


291 
<span class="line-modified">292     public BindableServer() throws IOException {</span>
<span class="line-modified">293         super();</span>
<span class="line-modified">294     }</span>




295 
<span class="line-modified">296     private byte[] bindResponse = {</span>
<span class="line-modified">297         0x30, 0x0C, 0x02, 0x01, 0x01, 0x61, 0x07, 0x0A,</span>
<span class="line-removed">298         0x01, 0x00, 0x04, 0x00, 0x04, 0x00</span>
<span class="line-removed">299     };</span>
300 
<span class="line-removed">301     public void run() {</span>
302         try {
<span class="line-modified">303             accepting = true;</span>
<span class="line-modified">304             Socket socket = serverSock.accept();</span>
<span class="line-modified">305             InputStream in = socket.getInputStream();</span>
<span class="line-modified">306             OutputStream out = socket.getOutputStream();</span>
<span class="line-modified">307 </span>
<span class="line-removed">308             // Read the LDAP BindRequest</span>
<span class="line-removed">309             while (in.read() != -1) {</span>
<span class="line-removed">310                 in.skip(in.available());</span>
<span class="line-removed">311                 break;</span>
312             }
<span class="line-modified">313 </span>
<span class="line-modified">314             // Write an LDAP BindResponse</span>
<span class="line-modified">315             out.write(bindResponse);</span>
<span class="line-modified">316             out.flush();</span>
<span class="line-modified">317         } catch (IOException e) {</span>
<span class="line-modified">318             // ignore</span>










319         }
320     }
<span class="line-removed">321 }</span>
<span class="line-removed">322 </span>
<span class="line-removed">323 class DeadServer extends TestServer {</span>
<span class="line-removed">324 </span>
<span class="line-removed">325     public DeadServer() throws IOException {</span>
<span class="line-removed">326         super();</span>
<span class="line-removed">327     }</span>
328 
<span class="line-modified">329     public void run() {</span>
<span class="line-modified">330         while(true) {</span>
<span class="line-modified">331             try {</span>
<span class="line-modified">332                 accepting = true;</span>
<span class="line-modified">333                 Socket socket = serverSock.accept();</span>
<span class="line-modified">334             } catch (Exception e) {</span>
<span class="line-modified">335                 break;</span>
<span class="line-modified">336             }</span>


337         }
<span class="line-modified">338     }</span>
<span class="line-removed">339 }</span>
340 
<span class="line-modified">341 public class LdapTimeoutTest {</span>

342 
<span class="line-modified">343     private static final ExecutorService testPool =</span>
<span class="line-modified">344         Executors.newFixedThreadPool(3);</span>
<span class="line-modified">345     private static final ScheduledExecutorService killSwitchPool =</span>
<span class="line-modified">346         Executors.newScheduledThreadPool(3);</span>
<span class="line-modified">347     public static int MIN_TIMEOUT = 18_000;</span>
<span class="line-modified">348 </span>
<span class="line-removed">349     static Hashtable createEnv() {</span>
<span class="line-removed">350         Hashtable env = new Hashtable(11);</span>
<span class="line-removed">351         env.put(Context.INITIAL_CONTEXT_FACTORY,</span>
<span class="line-removed">352             &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-removed">353         return env;</span>
<span class="line-removed">354     }</span>
355 
<span class="line-modified">356     public static void main(String[] args) throws Exception {</span>










357 
<span class="line-modified">358         InitialContext ctx = null;</span>
<span class="line-modified">359         List&lt;Future&gt; results = new ArrayList&lt;&gt;();</span>
360 
361         try {
<span class="line-modified">362             // run the DeadServerTest with no timeouts set</span>
<span class="line-modified">363             // this should get stuck indefinitely, so we need to kill</span>
<span class="line-modified">364             // it after a timeout</span>
<span class="line-modified">365             System.out.println(&quot;Running connect timeout test with 20s kill switch&quot;);</span>
<span class="line-modified">366             Hashtable env = createEnv();</span>
<span class="line-removed">367             results.add(</span>
<span class="line-removed">368                     testPool.submit(new DeadServerNoTimeoutTest(env, killSwitchPool)));</span>
<span class="line-removed">369 </span>
<span class="line-removed">370             // run the ReadServerTest with connect timeout set</span>
<span class="line-removed">371             // this should get stuck indefinitely so we need to kill</span>
<span class="line-removed">372             // it after a timeout</span>
<span class="line-removed">373             System.out.println(&quot;Running read timeout test with 10ms connect timeout &amp; 20s kill switch&quot;);</span>
<span class="line-removed">374             Hashtable env1 = createEnv();</span>
<span class="line-removed">375             env1.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, &quot;10&quot;);</span>
<span class="line-removed">376             results.add(testPool.submit(</span>
<span class="line-removed">377                     new ReadServerNoTimeoutTest(env1, killSwitchPool)));</span>
<span class="line-removed">378 </span>
<span class="line-removed">379             // run the ReadServerTest with no timeouts set</span>
<span class="line-removed">380             // this should get stuck indefinitely, so we need to kill</span>
<span class="line-removed">381             // it after a timeout</span>
<span class="line-removed">382             System.out.println(&quot;Running read timeout test with 20s kill switch&quot;);</span>
<span class="line-removed">383             Hashtable env2 = createEnv();</span>
<span class="line-removed">384             results.add(testPool.submit(</span>
<span class="line-removed">385                     new ReadServerNoTimeoutTest(env2, killSwitchPool)));</span>
<span class="line-removed">386 </span>
<span class="line-removed">387             // run the DeadServerTest with connect / read timeouts set</span>
<span class="line-removed">388             // this should exit after the connect timeout expires</span>
<span class="line-removed">389             System.out.println(&quot;Running connect timeout test with 10ms connect timeout, 3000ms read timeout&quot;);</span>
<span class="line-removed">390             Hashtable env3 = createEnv();</span>
<span class="line-removed">391             env3.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, &quot;10&quot;);</span>
<span class="line-removed">392             env3.put(&quot;com.sun.jndi.ldap.read.timeout&quot;, &quot;3000&quot;);</span>
<span class="line-removed">393             results.add(testPool.submit(new DeadServerTimeoutTest(env3)));</span>
<span class="line-removed">394 </span>
<span class="line-removed">395 </span>
<span class="line-removed">396             // run the ReadServerTest with connect / read timeouts set</span>
<span class="line-removed">397             // this should exit after the connect timeout expires</span>
<span class="line-removed">398             //</span>
<span class="line-removed">399             // NOTE: commenting this test out as it is failing intermittently.</span>
<span class="line-removed">400             //</span>
<span class="line-removed">401             // System.out.println(&quot;Running read timeout test with 10ms connect timeout, 3000ms read timeout&quot;);</span>
<span class="line-removed">402             // Hashtable env4 = createEnv();</span>
<span class="line-removed">403             // env4.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, &quot;10&quot;);</span>
<span class="line-removed">404             // env4.put(&quot;com.sun.jndi.ldap.read.timeout&quot;, &quot;3000&quot;);</span>
<span class="line-removed">405             // results.add(testPool.submit(new ReadServerTimeoutTest(env4)));</span>
<span class="line-removed">406 </span>
<span class="line-removed">407             // run the DeadServerTest with connect timeout set</span>
<span class="line-removed">408             // this should exit after the connect timeout expires</span>
<span class="line-removed">409             System.out.println(&quot;Running connect timeout test with 10ms connect timeout&quot;);</span>
<span class="line-removed">410             Hashtable env5 = createEnv();</span>
<span class="line-removed">411             env5.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, &quot;10&quot;);</span>
<span class="line-removed">412             results.add(testPool.submit(new DeadServerTimeoutTest(env5)));</span>
<span class="line-removed">413 </span>
<span class="line-removed">414             // 8000487: Java JNDI connection library on ldap conn is</span>
<span class="line-removed">415             // not honoring configured timeout</span>
<span class="line-removed">416             System.out.println(&quot;Running simple auth connection test&quot;);</span>
<span class="line-removed">417             Hashtable env6 = createEnv();</span>
<span class="line-removed">418             env6.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, &quot;10&quot;);</span>
<span class="line-removed">419             env6.put(&quot;com.sun.jndi.ldap.read.timeout&quot;, &quot;3000&quot;);</span>
<span class="line-removed">420             env6.put(Context.SECURITY_AUTHENTICATION, &quot;simple&quot;);</span>
<span class="line-removed">421             env6.put(Context.SECURITY_PRINCIPAL, &quot;user&quot;);</span>
<span class="line-removed">422             env6.put(Context.SECURITY_CREDENTIALS, &quot;password&quot;);</span>
<span class="line-removed">423             results.add(testPool.submit(new DeadServerTimeoutTest(env6)));</span>
<span class="line-removed">424 </span>
<span class="line-removed">425             boolean testFailed = false;</span>
<span class="line-removed">426             for (Future test : results) {</span>
<span class="line-removed">427                 while (!test.isDone()) {</span>
<span class="line-removed">428                     if ((Boolean) test.get() == false)</span>
<span class="line-removed">429                         testFailed = true;</span>
<span class="line-removed">430                 }</span>
431             }
<span class="line-modified">432 </span>
<span class="line-modified">433             if (testFailed) {</span>
<span class="line-modified">434                 throw new AssertionError(&quot;some tests failed&quot;);</span>


435             }
<span class="line-modified">436 </span>
437         } finally {
<span class="line-modified">438             LdapTimeoutTest.killSwitchPool.shutdown();</span>
<span class="line-removed">439             LdapTimeoutTest.testPool.shutdown();</span>
440         }
441     }
442 
<span class="line-modified">443 }</span>






































444 






</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
<span class="line-modified"> 24 /*</span>
 25  * @test
<span class="line-modified"> 26  * @library /test/lib</span>
<span class="line-modified"> 27  *          lib/</span>
<span class="line-added"> 28  * @run testng/othervm LdapTimeoutTest</span>
<span class="line-added"> 29  * @bug 7094377 8000487 6176036 7056489 8151678</span>
 30  * @summary Timeout tests for ldap
 31  */
 32 
<span class="line-added"> 33 import org.testng.Assert;</span>
<span class="line-added"> 34 import org.testng.annotations.BeforeTest;</span>
<span class="line-added"> 35 import org.testng.annotations.Test;</span>
<span class="line-added"> 36 </span>
<span class="line-added"> 37 import javax.naming.Context;</span>
<span class="line-added"> 38 import javax.naming.NamingException;</span>
<span class="line-added"> 39 import javax.naming.directory.InitialDirContext;</span>
<span class="line-added"> 40 import javax.naming.directory.SearchControls;</span>
<span class="line-added"> 41 import java.io.IOException;</span>
<span class="line-added"> 42 import java.io.OutputStream;</span>
 43 import java.net.Socket;







 44 import java.util.ArrayList;
<span class="line-added"> 45 import java.util.Hashtable;</span>
<span class="line-added"> 46 import java.util.List;</span>
<span class="line-added"> 47 import java.util.Objects;</span>
 48 import java.util.concurrent.Callable;
<span class="line-added"> 49 import java.util.concurrent.CompletableFuture;</span>
 50 import java.util.concurrent.ExecutionException;

 51 import java.util.concurrent.ExecutorService;
<span class="line-added"> 52 import java.util.concurrent.Executors;</span>
 53 import java.util.concurrent.Future;
<span class="line-modified"> 54 import java.util.concurrent.FutureTask;</span>
<span class="line-modified"> 55 import java.util.concurrent.SynchronousQueue;</span>

 56 import java.util.concurrent.TimeUnit;
<span class="line-modified"> 57 import java.util.concurrent.TimeoutException;</span>
 58 
<span class="line-added"> 59 import static java.lang.String.format;</span>
 60 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 61 import static java.util.concurrent.TimeUnit.NANOSECONDS;
<span class="line-added"> 62 import static jdk.test.lib.Utils.adjustTimeout;</span>
<span class="line-added"> 63 import static org.testng.Assert.assertTrue;</span>
<span class="line-added"> 64 import static org.testng.Assert.expectThrows;</span>
 65 
<span class="line-added"> 66 public class LdapTimeoutTest {</span>
 67 
<span class="line-modified"> 68     // ------ configure test timeouts here ------</span>
<span class="line-modified"> 69 </span>
<span class="line-modified"> 70     /*</span>
<span class="line-modified"> 71      * Practical representation of an infinite timeout.</span>
<span class="line-modified"> 72      */</span>
<span class="line-modified"> 73     private static final long INFINITY_MILLIS = adjustTimeout(20_000);</span>
<span class="line-modified"> 74     /*</span>
<span class="line-modified"> 75      * The acceptable variation in timeout measurements.</span>
<span class="line-modified"> 76      */</span>
<span class="line-modified"> 77     private static final long TOLERANCE       = adjustTimeout( 3_500);</span>
<span class="line-modified"> 78 </span>
<span class="line-modified"> 79     private static final long CONNECT_MILLIS  = adjustTimeout( 3_000);</span>
<span class="line-modified"> 80     private static final long READ_MILLIS     = adjustTimeout(10_000);</span>
<span class="line-modified"> 81 </span>
<span class="line-modified"> 82     static {</span>
<span class="line-modified"> 83         // a series of checks to make sure this timeouts configuration is</span>
<span class="line-modified"> 84         // consistent and the timeouts do not overlap</span>
<span class="line-modified"> 85 </span>
<span class="line-modified"> 86         assert (TOLERANCE &gt;= 0);</span>
<span class="line-modified"> 87         // context creation</span>
<span class="line-modified"> 88         assert (2 * CONNECT_MILLIS + TOLERANCE &lt; READ_MILLIS);</span>
<span class="line-modified"> 89         // context creation immediately followed by search</span>
<span class="line-modified"> 90         assert (2 * CONNECT_MILLIS + READ_MILLIS + TOLERANCE &lt; INFINITY_MILLIS);</span>







 91     }
 92 
<span class="line-modified"> 93     @BeforeTest</span>
<span class="line-modified"> 94     public void beforeTest() {</span>
<span class="line-added"> 95         startAuxiliaryDiagnosticOutput();</span>
 96     }
 97 
<span class="line-modified"> 98     /*</span>
<span class="line-added"> 99      * These are timeout tests and they are run in parallel to reduce the total</span>
<span class="line-added">100      * amount of run time.</span>
<span class="line-added">101      *</span>
<span class="line-added">102      * Currently it doesn&#39;t seem possible to instruct JTREG to run TestNG test</span>
<span class="line-added">103      * methods in parallel. That said, this JTREG test is still</span>
<span class="line-added">104      * a &quot;TestNG-flavored&quot; test for the sake of having org.testng.Assert</span>
<span class="line-added">105      * capability.</span>
<span class="line-added">106      */</span>
<span class="line-added">107     @Test</span>
<span class="line-added">108     public void test() throws Exception {</span>
<span class="line-added">109         List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();</span>
<span class="line-added">110         ExecutorService executorService = Executors.newCachedThreadPool();</span>
111         try {
<span class="line-modified">112             futures.add(executorService.submit(() -&gt; { test1(); return null; }));</span>
<span class="line-modified">113             futures.add(executorService.submit(() -&gt; { test2(); return null; }));</span>
<span class="line-modified">114             futures.add(executorService.submit(() -&gt; { test3(); return null; }));</span>
<span class="line-modified">115             futures.add(executorService.submit(() -&gt; { test4(); return null; }));</span>
<span class="line-added">116             futures.add(executorService.submit(() -&gt; { test5(); return null; }));</span>
<span class="line-added">117             futures.add(executorService.submit(() -&gt; { test6(); return null; }));</span>
<span class="line-added">118             futures.add(executorService.submit(() -&gt; { test7(); return null; }));</span>
<span class="line-added">119         } finally {</span>
<span class="line-added">120             executorService.shutdown();</span>
121         }
<span class="line-modified">122         int failedCount = 0;</span>
<span class="line-modified">123         for (var f : futures) {</span>


























124             try {
<span class="line-modified">125                 f.get();</span>
<span class="line-modified">126             } catch (ExecutionException e) {</span>
<span class="line-modified">127                 failedCount++;</span>
<span class="line-modified">128                 e.getCause().printStackTrace(System.out);</span>









129             }



130         }
<span class="line-added">131         if (failedCount &gt; 0)</span>
<span class="line-added">132             throw new RuntimeException(failedCount + &quot; (sub)tests failed&quot;);</span>
133     }



134 
<span class="line-modified">135     static void test1() throws Exception {</span>
<span class="line-modified">136         Hashtable&lt;Object, Object&gt; env = new Hashtable&lt;&gt;();</span>
<span class="line-added">137         env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-added">138         // Here and in the other tests it&#39;s important to close the server as</span>
<span class="line-added">139         // calling `thread.interrupt` from assertion may not be enough</span>
<span class="line-added">140         // (depending on where the blocking call has stuck)</span>
<span class="line-added">141         try (TestServer server = new NotBindableServer()) {</span>
<span class="line-added">142             env.put(Context.PROVIDER_URL, urlTo(server));</span>
<span class="line-added">143             server.start();</span>
<span class="line-added">144             // Here and in the other tests joining done purely to reduce timing</span>
<span class="line-added">145             // jitter. Commenting out or removing that should not make the test</span>
<span class="line-added">146             // incorrect. (ServerSocket can accept connection as soon as it is</span>
<span class="line-added">147             // bound, not need to call `accept` before that.)</span>
<span class="line-added">148             server.starting().join();</span>
<span class="line-added">149             assertIncompletion(INFINITY_MILLIS, () -&gt; new InitialDirContext(env));</span>
<span class="line-added">150         }</span>
151     }
152 
<span class="line-modified">153     static void test2() throws Exception {</span>
<span class="line-modified">154         Hashtable&lt;Object, Object&gt; env = new Hashtable&lt;&gt;();</span>
<span class="line-modified">155         env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-modified">156         env.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, String.valueOf(CONNECT_MILLIS));</span>
<span class="line-modified">157         try (TestServer server = new BindableButNotReadableServer()) {</span>
<span class="line-added">158             env.put(Context.PROVIDER_URL, urlTo(server));</span>
<span class="line-added">159             server.start();</span>
<span class="line-added">160             server.starting().join();</span>
<span class="line-added">161             InitialDirContext ctx = new InitialDirContext(env);</span>
<span class="line-added">162             SearchControls scl = new SearchControls();</span>
<span class="line-added">163             scl.setSearchScope(SearchControls.SUBTREE_SCOPE);</span>
<span class="line-added">164             assertIncompletion(INFINITY_MILLIS,</span>
<span class="line-added">165                                () -&gt; ctx.search(&quot;ou=People,o=JNDITutorial&quot;, &quot;(objectClass=*)&quot;, scl));</span>
<span class="line-added">166         }</span>
167     }
168 
<span class="line-modified">169     static void test3() throws Exception {</span>
<span class="line-modified">170         Hashtable&lt;Object, Object&gt; env = new Hashtable&lt;&gt;();</span>
<span class="line-modified">171         env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-modified">172         try (TestServer server = new BindableButNotReadableServer()) {</span>
<span class="line-modified">173             env.put(Context.PROVIDER_URL, urlTo(server));</span>
<span class="line-added">174             server.start();</span>
<span class="line-added">175             server.starting().join();</span>
<span class="line-added">176             InitialDirContext ctx = new InitialDirContext(env);</span>
<span class="line-added">177             SearchControls scl = new SearchControls();</span>
<span class="line-added">178             scl.setSearchScope(SearchControls.SUBTREE_SCOPE);</span>
<span class="line-added">179             assertIncompletion(INFINITY_MILLIS,</span>
<span class="line-added">180                                () -&gt; ctx.search(&quot;ou=People,o=JNDITutorial&quot;, &quot;(objectClass=*)&quot;, scl));</span>
<span class="line-added">181         }</span>
182     }



183 
<span class="line-modified">184     static void test4() throws Exception {</span>
<span class="line-modified">185         Hashtable&lt;Object, Object&gt; env = new Hashtable&lt;&gt;();</span>
<span class="line-added">186         env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-added">187         env.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, String.valueOf(CONNECT_MILLIS));</span>
<span class="line-added">188         env.put(&quot;com.sun.jndi.ldap.read.timeout&quot;, String.valueOf(READ_MILLIS));</span>
<span class="line-added">189         try (TestServer server = new NotBindableServer()) {</span>
<span class="line-added">190             env.put(Context.PROVIDER_URL, urlTo(server));</span>
<span class="line-added">191             server.start();</span>
<span class="line-added">192             server.starting().join();</span>
<span class="line-added">193             Assert.ThrowingRunnable completion =</span>
<span class="line-added">194                     () -&gt; assertCompletion(CONNECT_MILLIS,</span>
<span class="line-added">195                                            2 * CONNECT_MILLIS + TOLERANCE,</span>
<span class="line-added">196                                            () -&gt; new InitialDirContext(env));</span>
<span class="line-added">197             NamingException e = expectThrows(NamingException.class, completion);</span>
<span class="line-added">198             String msg = e.getMessage();</span>
<span class="line-added">199             assertTrue(msg != null &amp;&amp; msg.contains(&quot;timeout&quot;)</span>
<span class="line-added">200                                &amp;&amp; msg.contains(String.valueOf(CONNECT_MILLIS)),</span>
<span class="line-added">201                        msg);</span>
<span class="line-added">202         }</span>
203     }
204 
<span class="line-modified">205     static void test5() throws Exception {</span>
<span class="line-modified">206         Hashtable&lt;Object, Object&gt; env = new Hashtable&lt;&gt;();</span>
<span class="line-modified">207         env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-modified">208         env.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, String.valueOf(CONNECT_MILLIS));</span>
<span class="line-modified">209         env.put(&quot;com.sun.jndi.ldap.read.timeout&quot;, String.valueOf(READ_MILLIS));</span>
<span class="line-added">210         try (TestServer server = new BindableButNotReadableServer()) {</span>
<span class="line-added">211             env.put(Context.PROVIDER_URL, urlTo(server));</span>
<span class="line-added">212             server.start();</span>
<span class="line-added">213             server.starting().join();</span>
<span class="line-added">214             InitialDirContext ctx = new InitialDirContext(env);</span>
<span class="line-added">215             SearchControls scl = new SearchControls();</span>
<span class="line-added">216             scl.setSearchScope(SearchControls.SUBTREE_SCOPE);</span>
<span class="line-added">217             Assert.ThrowingRunnable completion =</span>
<span class="line-added">218                     () -&gt; assertCompletion(READ_MILLIS,</span>
<span class="line-added">219                                            READ_MILLIS + TOLERANCE,</span>
<span class="line-added">220                                            () -&gt; ctx.search(&quot;ou=People,o=JNDITutorial&quot;, &quot;(objectClass=*)&quot;, scl));</span>
<span class="line-added">221             NamingException e = expectThrows(NamingException.class, completion);</span>
<span class="line-added">222             String msg = e.getMessage();</span>
<span class="line-added">223             assertTrue(msg != null &amp;&amp; msg.contains(&quot;timeout&quot;)</span>
<span class="line-added">224                                &amp;&amp; msg.contains(String.valueOf(READ_MILLIS)),</span>
<span class="line-added">225                        msg);</span>
<span class="line-added">226         }</span>
227     }
228 
<span class="line-modified">229     static void test6() throws Exception {</span>
<span class="line-modified">230         Hashtable&lt;Object, Object&gt; env = new Hashtable&lt;&gt;();</span>
<span class="line-modified">231         env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-modified">232         env.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, String.valueOf(CONNECT_MILLIS));</span>
<span class="line-modified">233         env.put(&quot;com.sun.jndi.ldap.read.timeout&quot;, String.valueOf(READ_MILLIS));</span>
<span class="line-modified">234         try (TestServer server = new NotBindableServer()) {</span>
<span class="line-modified">235             env.put(Context.PROVIDER_URL, urlTo(server));</span>
<span class="line-modified">236             server.start();</span>
<span class="line-modified">237             server.starting().join();</span>
<span class="line-modified">238             Assert.ThrowingRunnable completion =</span>
<span class="line-added">239                     () -&gt; assertCompletion(CONNECT_MILLIS,</span>
<span class="line-added">240                                            2 * CONNECT_MILLIS + TOLERANCE,</span>
<span class="line-added">241                                            () -&gt; new InitialDirContext(env));</span>
<span class="line-added">242             NamingException e = expectThrows(NamingException.class, completion);</span>
<span class="line-added">243             String msg = e.getMessage();</span>
<span class="line-added">244             assertTrue(msg != null &amp;&amp; msg.contains(&quot;timeout&quot;)</span>
<span class="line-added">245                                &amp;&amp; msg.contains(String.valueOf(CONNECT_MILLIS)),</span>
<span class="line-added">246                        msg);</span>
<span class="line-added">247         }</span>
248     }
249 
<span class="line-modified">250     static void test7() throws Exception {</span>
<span class="line-modified">251         // 8000487: Java JNDI connection library on ldap conn is</span>
<span class="line-modified">252         // not honoring configured timeout</span>
<span class="line-modified">253         Hashtable&lt;Object, Object&gt; env = new Hashtable&lt;&gt;();</span>
<span class="line-modified">254         env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-modified">255         env.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, String.valueOf(CONNECT_MILLIS));</span>
<span class="line-modified">256         env.put(&quot;com.sun.jndi.ldap.read.timeout&quot;, String.valueOf(READ_MILLIS));</span>
<span class="line-modified">257         env.put(Context.SECURITY_AUTHENTICATION, &quot;simple&quot;);</span>
<span class="line-modified">258         env.put(Context.SECURITY_PRINCIPAL, &quot;user&quot;);</span>
<span class="line-modified">259         env.put(Context.SECURITY_CREDENTIALS, &quot;password&quot;);</span>
<span class="line-modified">260         try (TestServer server = new NotBindableServer()) {</span>
<span class="line-added">261             env.put(Context.PROVIDER_URL, urlTo(server));</span>
<span class="line-added">262             server.start();</span>
<span class="line-added">263             server.starting().join();</span>
<span class="line-added">264             Assert.ThrowingRunnable completion =</span>
<span class="line-added">265                     () -&gt; assertCompletion(CONNECT_MILLIS,</span>
<span class="line-added">266                                            2 * CONNECT_MILLIS + TOLERANCE,</span>
<span class="line-added">267                                            () -&gt; new InitialDirContext(env));</span>
<span class="line-added">268             NamingException e = expectThrows(NamingException.class, completion);</span>
<span class="line-added">269             String msg = e.getMessage();</span>
<span class="line-added">270             assertTrue(msg != null &amp;&amp; msg.contains(&quot;timeout&quot;)</span>
<span class="line-added">271                                &amp;&amp; msg.contains(String.valueOf(CONNECT_MILLIS)),</span>
<span class="line-added">272                        msg);</span>
273         }
274     }

275 
<span class="line-modified">276     // ------ test stub servers ------</span>
277 
<span class="line-modified">278     static class TestServer extends BaseLdapServer {</span>


279 
<span class="line-modified">280         private final CompletableFuture&lt;Void&gt; starting = new CompletableFuture&lt;&gt;();</span>










281 
<span class="line-added">282         TestServer() throws IOException { }</span>
283 
<span class="line-modified">284         @Override</span>
<span class="line-added">285         protected void beforeAcceptingConnections() {</span>
<span class="line-added">286             starting.completeAsync(() -&gt; null);</span>
<span class="line-added">287         }</span>
288 
<span class="line-modified">289         public CompletableFuture&lt;Void&gt; starting() {</span>
<span class="line-modified">290             return starting.copy();</span>
<span class="line-modified">291         }</span>


292     }
293 
<span class="line-modified">294     static class BindableButNotReadableServer extends TestServer {</span>
<span class="line-modified">295 </span>
<span class="line-modified">296         BindableButNotReadableServer() throws IOException { }</span>
<span class="line-modified">297 </span>
<span class="line-modified">298         private static final byte[] bindResponse = {</span>
<span class="line-modified">299                 0x30, 0x0C, 0x02, 0x01, 0x01, 0x61, 0x07, 0x0A,</span>
<span class="line-modified">300                 0x01, 0x00, 0x04, 0x00, 0x04, 0x00</span>
<span class="line-modified">301         };</span>
<span class="line-modified">302 </span>
<span class="line-modified">303         @Override</span>
<span class="line-modified">304         protected void handleRequest(Socket socket,</span>
<span class="line-added">305                                      LdapMessage msg,</span>
<span class="line-added">306                                      OutputStream out)</span>
<span class="line-added">307                 throws IOException {</span>
<span class="line-added">308             switch (msg.getOperation()) {</span>
<span class="line-added">309                 case BIND_REQUEST:</span>
<span class="line-added">310                     out.write(bindResponse);</span>
<span class="line-added">311                     out.flush();</span>
<span class="line-added">312                 default:</span>
<span class="line-added">313                     break;</span>
<span class="line-added">314             }</span>
315         }
316     }

317 
<span class="line-modified">318     static class NotBindableServer extends TestServer {</span>
319 
<span class="line-modified">320         NotBindableServer() throws IOException { }</span>


321 
<span class="line-modified">322         @Override</span>
<span class="line-modified">323         protected void beforeConnectionHandled(Socket socket) {</span>
<span class="line-modified">324             try {</span>
<span class="line-modified">325                 TimeUnit.DAYS.sleep(Integer.MAX_VALUE);</span>
<span class="line-modified">326             } catch (InterruptedException e) {</span>
<span class="line-modified">327                 Thread.currentThread().interrupt();</span>
<span class="line-added">328             }</span>
329         }
330     }










331 
<span class="line-modified">332     // ------ timeouts check utilities ------</span>
<span class="line-modified">333 </span>
<span class="line-modified">334     /*</span>
<span class="line-added">335      * Asserts that the specified executable yields a result or an exception</span>
<span class="line-added">336      * within the specified time frame. Interrupts the executable</span>
<span class="line-added">337      * unconditionally.</span>
<span class="line-added">338      *</span>
<span class="line-added">339      * If the executable yields a result or an exception within the specified</span>
<span class="line-added">340      * time frame, the result will be returned and the exception will be</span>
<span class="line-added">341      * rethrown respectively in a transparent fashion as if the executable was</span>
<span class="line-added">342      * executed directly.</span>
<span class="line-added">343      */</span>
<span class="line-added">344     public static &lt;T&gt; T assertCompletion(long loMillis,</span>
<span class="line-added">345                                          long hiMillis,</span>
<span class="line-added">346                                          Callable&lt;T&gt; code)</span>
<span class="line-added">347             throws Throwable {</span>
<span class="line-added">348         if (loMillis &lt; 0 || hiMillis &lt; 0 || loMillis &gt; hiMillis) {</span>
<span class="line-added">349             throw new IllegalArgumentException(&quot;loMillis=&quot; + loMillis +</span>
<span class="line-added">350                                                        &quot;, hiMillis=&quot; + hiMillis);</span>
<span class="line-added">351         }</span>
<span class="line-added">352         Objects.requireNonNull(code);</span>
353 
<span class="line-modified">354         // this queue acts both as an exchange point and a barrier</span>
<span class="line-modified">355         SynchronousQueue&lt;Long&gt; startTime = new SynchronousQueue&lt;&gt;();</span>

356 
<span class="line-modified">357         Callable&lt;T&gt; wrappedTask = () -&gt; {</span>
<span class="line-modified">358             // by the time this value reaches the &quot;stopwatch&quot; thread it might be</span>
<span class="line-modified">359             // well outdated and that&#39;s okay, we will adjust the wait time</span>
<span class="line-modified">360             startTime.put(System.nanoTime());</span>
<span class="line-added">361             return code.call();</span>
<span class="line-added">362         };</span>
363 
<span class="line-modified">364         FutureTask&lt;T&gt; task = new FutureTask&lt;&gt;(wrappedTask);</span>
<span class="line-added">365         Thread t = new Thread(task);</span>
<span class="line-added">366         t.start();</span>
367 
<span class="line-modified">368         final long startNanos;</span>
<span class="line-modified">369         try {</span>
<span class="line-modified">370             startNanos = startTime.take(); // (1) wait for the initial time mark</span>
<span class="line-added">371         } catch (Throwable e) {</span>
<span class="line-added">372             t.interrupt();</span>
<span class="line-added">373             throw e;</span>
<span class="line-added">374         }</span>
375 
<span class="line-modified">376         final long waitTime = hiMillis -</span>
<span class="line-modified">377                 NANOSECONDS.toMillis(System.nanoTime() - startNanos); // (2) adjust wait time</span>


378 

379         try {
<span class="line-modified">380             T r = task.get(waitTime, MILLISECONDS); // (3) wait for the task to complete</span>
<span class="line-modified">381             long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);</span>
<span class="line-modified">382             if (elapsed &lt; loMillis || elapsed &gt; hiMillis) {</span>
<span class="line-modified">383                 throw new RuntimeException(format(</span>
<span class="line-modified">384                         &quot;After %s ms. (waitTime %s ms.) returned result &#39;%s&#39;&quot;, elapsed, waitTime, r));</span>




385             }
<span class="line-modified">386             return r;</span>
<span class="line-modified">387         } catch (ExecutionException e) {</span>
<span class="line-modified">388             long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);</span>
<span class="line-modified">389             if (elapsed &lt; loMillis || elapsed &gt; hiMillis) {</span>
<span class="line-modified">390                 throw new RuntimeException(format(</span>
<span class="line-modified">391                         &quot;After %s ms. (waitTime %s ms.) thrown exception&quot;, elapsed, waitTime), e);</span>
<span class="line-added">392             }</span>
<span class="line-added">393             throw e.getCause();</span>
<span class="line-added">394         } catch (TimeoutException e) {</span>
<span class="line-added">395             // We trust timed get not to throw TimeoutException prematurely</span>
<span class="line-added">396             // (i.e. before the wait time elapses)</span>
<span class="line-added">397             long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);</span>
<span class="line-added">398             throw new RuntimeException(format(</span>
<span class="line-added">399                     &quot;After %s ms. (waitTime %s ms.) is incomplete&quot;, elapsed, waitTime));</span>
<span class="line-added">400         } finally {</span>
<span class="line-added">401             t.interrupt();</span>
402         }
403     }







404 
<span class="line-modified">405     /*</span>
<span class="line-modified">406      * Asserts that the specified executable yields no result and no exception</span>
<span class="line-modified">407      * for at least the specified amount of time. Interrupts the executable</span>
<span class="line-modified">408      * unconditionally.</span>
<span class="line-modified">409      */</span>
<span class="line-modified">410     public static void assertIncompletion(long millis, Callable&lt;?&gt; code)</span>
<span class="line-modified">411             throws Exception</span>
<span class="line-modified">412     {</span>
<span class="line-added">413         if (millis &lt; 0) {</span>
<span class="line-added">414             throw new IllegalArgumentException(&quot;millis=&quot; + millis);</span>
415         }
<span class="line-modified">416         Objects.requireNonNull(code);</span>

417 
<span class="line-modified">418         // this queue acts both as an exchange point and a barrier</span>
<span class="line-added">419         SynchronousQueue&lt;Long&gt; startTime = new SynchronousQueue&lt;&gt;();</span>
420 
<span class="line-modified">421         Callable&lt;?&gt; wrappedTask = () -&gt; {</span>
<span class="line-modified">422             // by the time this value reaches the &quot;stopwatch&quot; thread it might be</span>
<span class="line-modified">423             // well outdated and that&#39;s okay, we will adjust the wait time</span>
<span class="line-modified">424             startTime.put(System.nanoTime());</span>
<span class="line-modified">425             return code.call();</span>
<span class="line-modified">426         };</span>






427 
<span class="line-modified">428         FutureTask&lt;?&gt; task = new FutureTask&lt;&gt;(wrappedTask);</span>
<span class="line-added">429         Thread t = new Thread(task);</span>
<span class="line-added">430         t.start();</span>
<span class="line-added">431 </span>
<span class="line-added">432         final long startNanos;</span>
<span class="line-added">433         try {</span>
<span class="line-added">434             startNanos = startTime.take(); // (1) wait for the initial time mark</span>
<span class="line-added">435         } catch (Throwable e) {</span>
<span class="line-added">436             t.interrupt();</span>
<span class="line-added">437             throw e;</span>
<span class="line-added">438         }</span>
439 
<span class="line-modified">440         final long waitTime = millis -</span>
<span class="line-modified">441                 NANOSECONDS.toMillis(System.nanoTime() - startNanos); // (2) adjust wait time</span>
442 
443         try {
<span class="line-modified">444             Object r = task.get(waitTime, MILLISECONDS); // (3) wait for the task to complete</span>
<span class="line-modified">445             long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);</span>
<span class="line-modified">446             if (elapsed &lt; waitTime) {</span>
<span class="line-modified">447                 throw new RuntimeException(format(</span>
<span class="line-modified">448                         &quot;After %s ms. (waitTime %s ms.) returned result &#39;%s&#39;&quot;, elapsed, waitTime, r));</span>
































































449             }
<span class="line-modified">450         } catch (ExecutionException e) {</span>
<span class="line-modified">451             long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);</span>
<span class="line-modified">452             if (elapsed &lt; waitTime) {</span>
<span class="line-added">453                 throw new RuntimeException(format(</span>
<span class="line-added">454                         &quot;After %s ms. (waitTime %s ms.) thrown exception&quot;, elapsed, waitTime), e);</span>
455             }
<span class="line-modified">456         } catch (TimeoutException expected) {</span>
457         } finally {
<span class="line-modified">458             t.interrupt();</span>

459         }
460     }
461 
<span class="line-modified">462     // ------ miscellaneous utilities ------</span>
<span class="line-added">463 </span>
<span class="line-added">464     private static String urlTo(TestServer server) {</span>
<span class="line-added">465         String hostAddress = server.getInetAddress().getHostAddress();</span>
<span class="line-added">466         String addr;</span>
<span class="line-added">467         if (hostAddress.contains(&quot;:&quot;)) { // IPv6</span>
<span class="line-added">468             addr = &#39;[&#39; + hostAddress + &#39;]&#39;;</span>
<span class="line-added">469         } else {                         // IPv4</span>
<span class="line-added">470             addr = hostAddress;</span>
<span class="line-added">471         }</span>
<span class="line-added">472         return &quot;ldap://&quot; + addr + &quot;:&quot; + server.getPort();</span>
<span class="line-added">473     }</span>
<span class="line-added">474 </span>
<span class="line-added">475     /*</span>
<span class="line-added">476      * A diagnostic aid that might help with debugging timeout issues. The idea</span>
<span class="line-added">477      * is to continuously measure accuracy and responsiveness of the system that</span>
<span class="line-added">478      * runs this test. If the system is overwhelmed (with something else), it</span>
<span class="line-added">479      * might affect the test run. At the very least we will have traces of that</span>
<span class="line-added">480      * in the logs.</span>
<span class="line-added">481      *</span>
<span class="line-added">482      * This utility does not automatically scale up test timeouts, it simply</span>
<span class="line-added">483      * gathers information.</span>
<span class="line-added">484      */</span>
<span class="line-added">485     private static void startAuxiliaryDiagnosticOutput() {</span>
<span class="line-added">486         System.out.printf(&quot;Starting diagnostic output (probe)%n&quot;);</span>
<span class="line-added">487         Thread t = new Thread(() -&gt; {</span>
<span class="line-added">488             for (int i = 0; ; i = ((i % 20) + 1)) {</span>
<span class="line-added">489                 // 500, 1_000, 1_500, ..., 9_500, 10_000, 500, 1_000, ...</span>
<span class="line-added">490                 long expected = i * 500;</span>
<span class="line-added">491                 long start = System.nanoTime();</span>
<span class="line-added">492                 try {</span>
<span class="line-added">493                     MILLISECONDS.sleep(expected);</span>
<span class="line-added">494                 } catch (InterruptedException e) {</span>
<span class="line-added">495                     return;</span>
<span class="line-added">496                 }</span>
<span class="line-added">497                 long stop = System.nanoTime();</span>
<span class="line-added">498                 long actual = NANOSECONDS.toMillis(stop - start);</span>
<span class="line-added">499                 System.out.printf(&quot;(probe) expected [ms.]: %s, actual [ms.]: %s%n&quot;,</span>
<span class="line-added">500                                   expected, actual);</span>
501 
<span class="line-added">502             }</span>
<span class="line-added">503         }, &quot;probe&quot;);</span>
<span class="line-added">504         t.setDaemon(true);</span>
<span class="line-added">505         t.start();</span>
<span class="line-added">506     }</span>
<span class="line-added">507 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="LdapDnsProviderTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../management/HotSpotDiagnosticMXBean/CheckOrigin.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
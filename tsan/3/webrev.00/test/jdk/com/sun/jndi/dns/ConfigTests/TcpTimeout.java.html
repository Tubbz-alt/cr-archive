<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/com/sun/jndi/dns/ConfigTests/TcpTimeout.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import jtreg.SkippedException;
 25 
 26 import javax.naming.directory.InitialDirContext;
 27 import java.io.IOException;
 28 import java.net.BindException;
 29 import java.net.InetAddress;
 30 import java.net.ServerSocket;
 31 
 32 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 33 import static jdk.test.lib.Utils.adjustTimeout;
 34 
 35 /*
 36  * @test
 37  * @bug 8228580
 38  * @summary Tests that we get a DNS response when the UDP DNS server returns a
 39  *          truncated response and the TCP DNS server does not respond at all
 40  *          after connect.
 41  * @library ../lib/
 42  * @library /test/lib
 43  * @modules java.base/sun.security.util
 44  * @run main TcpTimeout
 45  * @run main TcpTimeout -Dcom.sun.jndi.dns.timeout.initial=5000
 46  */
 47 
 48 public class TcpTimeout extends DNSTestBase {
 49     private TcpDnsServer tcpDnsServer;
 50 
 51     /* The acceptable variation in timeout measurement. */
 52     private static final long TOLERANCE = adjustTimeout(5_000);
 53 
 54     /* The acceptable variation of early returns from timed socket operations. */
 55     private static final long PREMATURE_RETURN = adjustTimeout(100);
 56 
 57     public static void main(String[] args) throws Exception {
 58         new TcpTimeout().run(args);
 59     }
 60 
 61     @Override
 62     public void runTest() throws Exception {
 63         /* The default timeout value is 1 second, as stated in the
 64            jdk.naming.dns module docs. */
 65         long timeout = 1_000;
 66         var envTimeout = env().get(&quot;com.sun.jndi.dns.timeout.initial&quot;);
 67         if (envTimeout != null)
 68             timeout = Long.parseLong(String.valueOf(envTimeout));
 69 
 70         setContext(new InitialDirContext(env()));
 71 
 72         long startNanos = System.nanoTime();
 73 
 74         /* perform query */
 75         var attrs = context().getAttributes(&quot;host1&quot;);
 76 
 77         long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);
 78         if (elapsed &lt; timeout - PREMATURE_RETURN || elapsed &gt; timeout + TOLERANCE) {
 79             throw new RuntimeException(String.format(
 80                     &quot;elapsed=%s, timeout=%s, TOLERANCE=%s, PREMATURE_RETURN=%s&quot;,
 81                     elapsed, timeout, TOLERANCE, PREMATURE_RETURN));
 82         }
 83 
 84         DNSTestUtils.debug(attrs);
 85 
 86         /* Note that the returned attributes are truncated and the response
 87         is not valid. */
 88         var txtAttr = attrs.get(&quot;TXT&quot;);
 89         if (txtAttr == null)
 90             throw new RuntimeException(&quot;TXT attribute missing.&quot;);
 91     }
 92 
 93     @Override
 94     public void initTest(String[] args) {
 95         /* We need to bind the TCP server on the same port the UDP server is
 96         listening to. This may not be possible if that port is in use. Retry
 97         MAX_RETRIES times relying on UDP port randomness. */
 98         final int MAX_RETRIES = 5;
 99         for (int i = 0; i &lt; MAX_RETRIES; i++) {
100             super.initTest(args);
101             var udpServer = (Server) env().get(DNSTestUtils.TEST_DNS_SERVER_THREAD);
102             int port = udpServer.getPort();
103             try {
104                 tcpDnsServer = new TcpDnsServer(port);
105                 break; // success
106             } catch (BindException be) {
107                 DNSTestUtils.debug(&quot;Failed to bind server socket on port &quot; + port
108                                            + &quot;, retry no. &quot; + (i + 1) + &quot;, &quot; + be.getMessage());
109             } catch (Exception ex) {
110                 throw new RuntimeException(&quot;Unexpected exception during initTest&quot;, ex);
111             } finally {
112                 if (tcpDnsServer == null) { // cleanup behind exceptions
113                     super.cleanupTest();
114                 }
115             }
116         }
117 
118         if (tcpDnsServer == null) {
119             throw new SkippedException(&quot;Cannot start TCP server after &quot;
120                                                + MAX_RETRIES
121                                                + &quot; tries, skip the test&quot;);
122         }
123     }
124 
125     @Override
126     public void cleanupTest() {
127         super.cleanupTest();
128         if (tcpDnsServer != null)
129             tcpDnsServer.stopServer();
130     }
131 
132     /**
133      * A TCP server that accepts a connection and does nothing else: causes read
134      * timeout on client side.
135      */
136     private static class TcpDnsServer {
137         final ServerSocket serverSocket;
138 
139         TcpDnsServer(int port) throws IOException {
140             serverSocket = new ServerSocket(port, 0, InetAddress.getLoopbackAddress());
141             System.out.println(&quot;TcpDnsServer: listening on port &quot; + port);
142         }
143 
144         void stopServer() {
145             try {
146                 if (serverSocket != null)
147                     serverSocket.close();
148             } catch (Exception ignored) { }
149         }
150     }
151 }
    </pre>
  </body>
</html>
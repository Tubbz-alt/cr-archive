<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/com/sun/jndi/ldap/lib/LdapMessage.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.math.BigInteger;
 25 import java.util.Arrays;
 26 import java.util.Optional;
 27 import java.util.stream.Stream;
 28 
 29 /**
 30  * An LDAP message.
 31  */
 32 public class LdapMessage {
 33 
 34     private final byte[] message;
 35     private int messageID;
 36     private Operation operation;
 37 
 38     public enum Operation {
 39         BIND_REQUEST(0x60, &quot;BindRequest&quot;),                      // [APPLICATION 0]
 40         BIND_RESPONSE(0x61, &quot;BindResponse&quot;),                    // [APPLICATION 1]
 41         UNBIND_REQUEST(0x42, &quot;UnbindRequest&quot;),                  // [APPLICATION 2]
 42         SEARCH_REQUEST(0x63, &quot;SearchRequest&quot;),                  // [APPLICATION 3]
 43         SEARCH_RESULT_ENTRY(0x64, &quot;SearchResultEntry&quot;),         // [APPLICATION 4]
 44         SEARCH_RESULT_DONE(0x65, &quot;SearchResultDone&quot;),           // [APPLICATION 5]
 45         MODIFY_REQUEST(0x66, &quot;ModifyRequest&quot;),                  // [APPLICATION 6]
 46         MODIFY_RESPONSE(0x67, &quot;ModifyResponse&quot;),                // [APPLICATION 7]
 47         ADD_REQUEST(0x68, &quot;AddRequest&quot;),                        // [APPLICATION 8]
 48         ADD_RESPONSE(0x69, &quot;AddResponse&quot;),                      // [APPLICATION 9]
 49         DELETE_REQUEST(0x4A, &quot;DeleteRequest&quot;),                  // [APPLICATION 10]
 50         DELETE_RESPONSE(0x6B, &quot;DeleteResponse&quot;),                // [APPLICATION 11]
 51         MODIFY_DN_REQUEST(0x6C, &quot;ModifyDNRequest&quot;),             // [APPLICATION 12]
 52         MODIFY_DN_RESPONSE(0x6D, &quot;ModifyDNResponse&quot;),           // [APPLICATION 13]
 53         COMPARE_REQUEST(0x6E, &quot;CompareRequest&quot;),                // [APPLICATION 14]
 54         COMPARE_RESPONSE(0x6F, &quot;CompareResponse&quot;),              // [APPLICATION 15]
 55         ABANDON_REQUEST(0x50, &quot;AbandonRequest&quot;),                // [APPLICATION 16]
 56         SEARCH_RESULT_REFERENCE(0x73, &quot;SearchResultReference&quot;), // [APPLICATION 19]
 57         EXTENDED_REQUEST(0x77, &quot;ExtendedRequest&quot;),              // [APPLICATION 23]
 58         EXTENDED_RESPONSE(0x78, &quot;ExtendedResponse&quot;),            // [APPLICATION 24]
 59         INTERMEDIATE_RESPONSE(0x79, &quot;IntermediateResponse&quot;);    // [APPLICATION 25]
 60 
 61         private final int id;
 62         private final String name;
 63 
 64         Operation(int id, String name) {
 65             this.id = id;
 66             this.name = name;
 67         }
 68 
 69         public int getId() {
 70             return id;
 71         }
 72 
 73         @Override
 74         public String toString() {
 75             return name;
 76         }
 77 
 78         private static Operation fromId(int id) {
 79             Optional&lt;Operation&gt; optional = Stream.of(Operation.values())
 80                     .filter(o -&gt; o.id == id).findFirst();
 81             if (optional.isPresent()) {
 82                 return optional.get();
 83             } else {
 84                 throw new RuntimeException(
 85                         &quot;Unknown id &quot; + id + &quot; for enum Operation.&quot;);
 86             }
 87         }
 88     }
 89 
 90     public LdapMessage(byte[] message) {
 91         this.message = message;
 92         parse();
 93     }
 94 
 95     public LdapMessage(String hexString) {
 96         this(parseHexBinary(hexString));
 97     }
 98 
 99     // Extracts the message ID and operation ID from an LDAP protocol encoding
100     private void parse() {
101         if (message == null || message.length &lt; 2) {
102             throw new RuntimeException(
103                     &quot;Invalid ldap message: &quot; + Arrays.toString(message));
104         }
105 
106         if (message[0] != 0x30) {
107             throw new RuntimeException(&quot;Bad LDAP encoding in message, &quot;
108                     + &quot;expected ASN.1 SEQUENCE tag (0x30), encountered &quot;
109                     + message[0]);
110         }
111 
112         int index = 2;
113         if ((message[1] &amp; 0x80) == 0x80) {
114             index += (message[1] &amp; 0x0F);
115         }
116 
117         if (message[index] != 0x02) {
118             throw new RuntimeException(&quot;Bad LDAP encoding in message, &quot;
119                     + &quot;expected ASN.1 INTEGER tag (0x02), encountered &quot;
120                     + message[index]);
121         }
122         int length = message[index + 1];
123         index += 2;
124         messageID = new BigInteger(1,
125                                    Arrays.copyOfRange(message, index, index + length)).intValue();
126         index += length;
127         int operationID = message[index];
128         operation = Operation.fromId(operationID);
129     }
130 
131     /**
132      * Return original ldap message in byte array.
133      *
134      * @return original ldap message
135      */
136     public byte[] getMessage() {
137         return Arrays.copyOf(message, message.length);
138     }
139 
140     /**
141      * Return ldap message id.
142      *
143      * @return ldap message id.
144      */
145     public int getMessageID() {
146         return messageID;
147     }
148 
149     /**
150      * Return ldap message&#39;s operation.
151      *
152      * @return ldap message&#39;s operation.
153      */
154     public Operation getOperation() {
155         return operation;
156     }
157 
158     private static byte[] parseHexBinary(String s) {
159 
160         final int len = s.length();
161 
162         // &quot;111&quot; is not a valid hex encoding.
163         if (len % 2 != 0) {
164             throw new IllegalArgumentException(
165                     &quot;hexBinary needs to be even-length: &quot; + s);
166         }
167 
168         byte[] out = new byte[len / 2];
169 
170         for (int i = 0; i &lt; len; i += 2) {
171             int h = Character.digit(s.charAt(i), 16);
172             int l = Character.digit(s.charAt(i + 1), 16);
173             if (h == -1 || l == -1) {
174                 throw new IllegalArgumentException(
175                         &quot;contains illegal character for hexBinary: &quot; + s);
176             }
177 
178             out[i / 2] = (byte) (h * 16 + l);
179         }
180 
181         return out;
182     }
183 
184     public static int getMessageLength(byte[] encoding) {
185         if (encoding.length &lt; 2) {
186             // not enough data to extract msg len, just return -1
187             return -1;
188         }
189 
190         if (encoding[0] != 0x30) {
191             throw new RuntimeException(&quot;Error: bad LDAP encoding message: &quot;
192                                                + &quot;expected ASN.1 SEQUENCE tag (0x30), encountered &quot;
193                                                + encoding[0]);
194         }
195 
196         int len;
197         int index = 1;
198         int payloadLen = 0;
199 
200         if ((encoding[1] &amp; 0x80) == 0x80) {
201             len = (encoding[1] &amp; 0x0F);
202             index++;
203         } else {
204             len = 1;
205         }
206 
207         if (len &gt; 4) {
208             throw new RuntimeException(
209                     &quot;Error: LDAP encoding message payload too large&quot;);
210         }
211 
212         if (encoding.length &lt; index + len) {
213             // additional data required to extract payload len, return -1
214             return -1;
215         }
216 
217         for (byte b : Arrays.copyOfRange(encoding, index, index + len)) {
218             payloadLen = payloadLen &lt;&lt; 8 | (b &amp; 0xFF);
219         }
220 
221         if (payloadLen &lt;= 0) {
222             throw new RuntimeException(
223                     &quot;Error: invalid LDAP encoding message length or payload too large&quot;);
224         }
225 
226         return index + len + payloadLen;
227     }
228 }
    </pre>
  </body>
</html>
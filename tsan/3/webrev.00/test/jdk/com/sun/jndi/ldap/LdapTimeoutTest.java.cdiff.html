<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/com/sun/jndi/ldap/LdapTimeoutTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="LdapDnsProviderTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../management/HotSpotDiagnosticMXBean/CheckOrigin.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/com/sun/jndi/ldap/LdapTimeoutTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 19,426 ***</span>
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
<span class="line-modified">! /**</span>
   * @test
<span class="line-modified">!  * @run main/othervm LdapTimeoutTest</span>
<span class="line-modified">!  * @bug 7094377 8000487 6176036 7056489</span>
   * @summary Timeout tests for ldap
   */
  
  import java.net.Socket;
<span class="line-removed">- import java.net.ServerSocket;</span>
<span class="line-removed">- import java.net.SocketTimeoutException;</span>
<span class="line-removed">- import java.io.*;</span>
<span class="line-removed">- import javax.naming.*;</span>
<span class="line-removed">- import javax.naming.directory.*;</span>
<span class="line-removed">- import java.util.List;</span>
<span class="line-removed">- import java.util.Hashtable;</span>
  import java.util.ArrayList;
  import java.util.concurrent.Callable;
  import java.util.concurrent.ExecutionException;
<span class="line-removed">- import java.util.concurrent.Executors;</span>
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Future;
<span class="line-modified">! import java.util.concurrent.ScheduledExecutorService;</span>
<span class="line-modified">! import java.util.concurrent.ScheduledFuture;</span>
<span class="line-removed">- import java.util.concurrent.TimeoutException;</span>
  import java.util.concurrent.TimeUnit;
<span class="line-modified">! import javax.net.ssl.SSLHandshakeException;</span>
  
  import static java.util.concurrent.TimeUnit.MILLISECONDS;
  import static java.util.concurrent.TimeUnit.NANOSECONDS;
  
  
<span class="line-modified">! abstract class LdapTest implements Callable {</span>
<span class="line-modified">! </span>
<span class="line-modified">!     Hashtable env;</span>
<span class="line-modified">!     TestServer server;</span>
<span class="line-modified">!     ScheduledExecutorService killSwitchPool;</span>
<span class="line-modified">!     boolean passed = false;</span>
<span class="line-modified">!     private int HANGING_TEST_TIMEOUT = 20_000;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     public LdapTest (TestServer server, Hashtable env) {</span>
<span class="line-modified">!         this.server = server;</span>
<span class="line-modified">!         this.env = env;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     public LdapTest(TestServer server, Hashtable env,</span>
<span class="line-modified">!             ScheduledExecutorService killSwitchPool)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         this(server, env);</span>
<span class="line-modified">!         this.killSwitchPool = killSwitchPool;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     public abstract void performOp(InitialContext ctx) throws NamingException;</span>
<span class="line-modified">!     public abstract void handleNamingException(</span>
<span class="line-modified">!         NamingException e, long start, long end);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     public void pass() {</span>
<span class="line-removed">-         this.passed = true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     public void fail() {</span>
<span class="line-removed">-         throw new RuntimeException(&quot;Test failed&quot;);</span>
      }
  
<span class="line-modified">!     public void fail(Exception e) {</span>
<span class="line-modified">!         throw new RuntimeException(&quot;Test failed&quot;, e);</span>
      }
  
<span class="line-modified">!     boolean shutItDown(InitialContext ctx) {</span>
          try {
<span class="line-modified">!             if (ctx != null) ctx.close();</span>
<span class="line-modified">!             return true;</span>
<span class="line-modified">!         } catch (NamingException ex) {</span>
<span class="line-modified">!             return false;</span>
          }
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-removed">-     public Boolean call() {</span>
<span class="line-removed">-         InitialContext ctx = null;</span>
<span class="line-removed">-         ScheduledFuture killer = null;</span>
<span class="line-removed">-         long start = System.nanoTime();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             while(!server.accepting())</span>
<span class="line-removed">-                 Thread.sleep(200); // allow the server to start up</span>
<span class="line-removed">-             Thread.sleep(200); // to be sure</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // if this is a hanging test, scheduled a thread to</span>
<span class="line-removed">-             // interrupt after a certain time</span>
<span class="line-removed">-             if (killSwitchPool != null) {</span>
<span class="line-removed">-                 final Thread current = Thread.currentThread();</span>
<span class="line-removed">-                 killer = killSwitchPool.schedule(</span>
<span class="line-removed">-                     new Callable&lt;Void&gt;() {</span>
<span class="line-removed">-                         public Void call() throws Exception {</span>
<span class="line-removed">-                             current.interrupt();</span>
<span class="line-removed">-                             return null;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }, HANGING_TEST_TIMEOUT, MILLISECONDS);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             env.put(Context.PROVIDER_URL, &quot;ldap://localhost:&quot; +</span>
<span class="line-removed">-                     server.getLocalPort());</span>
<span class="line-removed">- </span>
              try {
<span class="line-modified">!                 ctx = new InitialDirContext(env);</span>
<span class="line-modified">!                 performOp(ctx);</span>
<span class="line-modified">!                 fail();</span>
<span class="line-modified">!             } catch (NamingException e) {</span>
<span class="line-removed">-                 long end = System.nanoTime();</span>
<span class="line-removed">-                 System.out.println(this.getClass().toString() + &quot; - elapsed: &quot;</span>
<span class="line-removed">-                         + NANOSECONDS.toMillis(end - start));</span>
<span class="line-removed">-                 handleNamingException(e, start, end);</span>
<span class="line-removed">-             } finally {</span>
<span class="line-removed">-                 if (killer != null &amp;&amp; !killer.isDone())</span>
<span class="line-removed">-                     killer.cancel(true);</span>
<span class="line-removed">-                 shutItDown(ctx);</span>
<span class="line-removed">-                 server.close();</span>
              }
<span class="line-removed">-             return passed;</span>
<span class="line-removed">-         } catch (IOException|InterruptedException e) {</span>
<span class="line-removed">-             throw new RuntimeException(e);</span>
          }
      }
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- abstract class ReadServerTest extends LdapTest {</span>
  
<span class="line-modified">!     public ReadServerTest(Hashtable env) throws IOException {</span>
<span class="line-modified">!         super(new BindableServer(), env);</span>
      }
  
<span class="line-modified">!     public ReadServerTest(Hashtable env,</span>
<span class="line-modified">!                           ScheduledExecutorService killSwitchPool)</span>
<span class="line-modified">!             throws IOException</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         super(new BindableServer(), env, killSwitchPool);</span>
      }
  
<span class="line-modified">!     public void performOp(InitialContext ctx) throws NamingException {</span>
<span class="line-modified">!         SearchControls scl = new SearchControls();</span>
<span class="line-modified">!         scl.setSearchScope(SearchControls.SUBTREE_SCOPE);</span>
<span class="line-modified">!         NamingEnumeration&lt;SearchResult&gt; answer = ((InitialDirContext)ctx)</span>
<span class="line-modified">!             .search(&quot;ou=People,o=JNDITutorial&quot;, &quot;(objectClass=*)&quot;, scl);</span>
      }
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- abstract class DeadServerTest extends LdapTest {</span>
  
<span class="line-modified">!     public DeadServerTest(Hashtable env) throws IOException {</span>
<span class="line-modified">!         super(new DeadServer(), env);</span>
      }
  
<span class="line-modified">!     public DeadServerTest(Hashtable env,</span>
<span class="line-modified">!                           ScheduledExecutorService killSwitchPool)</span>
<span class="line-modified">!             throws IOException</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         super(new DeadServer(), env, killSwitchPool);</span>
      }
  
<span class="line-modified">!     public void performOp(InitialContext ctx) throws NamingException {}</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! class DeadServerNoTimeoutTest extends DeadServerTest {</span>
<span class="line-modified">! </span>
<span class="line-modified">!     public DeadServerNoTimeoutTest(Hashtable env,</span>
<span class="line-modified">!                                    ScheduledExecutorService killSwitchPool)</span>
<span class="line-modified">!             throws IOException</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         super(env, killSwitchPool);</span>
      }
  
<span class="line-modified">!     public void handleNamingException(NamingException e, long start, long end) {</span>
<span class="line-modified">!         if (e instanceof InterruptedNamingException) Thread.interrupted();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (NANOSECONDS.toMillis(end - start) &lt; LdapTimeoutTest.MIN_TIMEOUT) {</span>
<span class="line-modified">!             System.err.printf(&quot;DeadServerNoTimeoutTest fail: timeout should be &quot; +</span>
<span class="line-modified">!                               &quot;at least %s ms, actual time is %s ms%n&quot;,</span>
<span class="line-modified">!                               LdapTimeoutTest.MIN_TIMEOUT,</span>
<span class="line-modified">!                               NANOSECONDS.toMillis(end - start));</span>
<span class="line-modified">!             fail();</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             pass();</span>
          }
      }
<span class="line-removed">- }</span>
  
<span class="line-modified">! class DeadServerTimeoutTest extends DeadServerTest {</span>
  
<span class="line-modified">!     public DeadServerTimeoutTest(Hashtable env) throws IOException {</span>
<span class="line-removed">-         super(env);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     public void handleNamingException(NamingException e, long start, long end)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         // non SSL connect will timeout via readReply using connectTimeout</span>
<span class="line-removed">-         if (NANOSECONDS.toMillis(end - start) &lt; 2_900) {</span>
<span class="line-removed">-             pass();</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             System.err.println(&quot;Fail: Waited too long&quot;);</span>
<span class="line-removed">-             fail();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
  
  
<span class="line-modified">! class ReadServerNoTimeoutTest extends ReadServerTest {</span>
  
<span class="line-modified">!     public ReadServerNoTimeoutTest(Hashtable env,</span>
<span class="line-modified">!                                    ScheduledExecutorService killSwitchPool)</span>
<span class="line-modified">!             throws IOException</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         super(env, killSwitchPool);</span>
      }
  
<span class="line-modified">!     public void handleNamingException(NamingException e, long start, long end) {</span>
<span class="line-modified">!         if (e instanceof InterruptedNamingException) Thread.interrupted();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (NANOSECONDS.toMillis(end - start) &lt; LdapTimeoutTest.MIN_TIMEOUT) {</span>
<span class="line-modified">!             System.err.printf(&quot;ReadServerNoTimeoutTest fail: timeout should be &quot; +</span>
<span class="line-modified">!                               &quot;at least %s ms, actual time is %s ms%n&quot;,</span>
<span class="line-modified">!                               LdapTimeoutTest.MIN_TIMEOUT,</span>
<span class="line-modified">!                               NANOSECONDS.toMillis(end - start));</span>
<span class="line-modified">!             fail();</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             pass();</span>
          }
      }
<span class="line-removed">- }</span>
  
<span class="line-modified">! class ReadServerTimeoutTest extends ReadServerTest {</span>
  
<span class="line-modified">!     public ReadServerTimeoutTest(Hashtable env) throws IOException {</span>
<span class="line-removed">-         super(env);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     public void handleNamingException(NamingException e, long start, long end) {</span>
<span class="line-modified">!         System.out.println(&quot;ReadServerTimeoutTest: end-start=&quot; + NANOSECONDS.toMillis(end - start));</span>
<span class="line-modified">!         if (NANOSECONDS.toMillis(end - start) &lt; 2_500) {</span>
<span class="line-modified">!             fail();</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             pass();</span>
          }
      }
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- class TestServer extends Thread {</span>
<span class="line-removed">-     ServerSocket serverSock;</span>
<span class="line-removed">-     boolean accepting = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     public TestServer() throws IOException {</span>
<span class="line-removed">-         this.serverSock = new ServerSocket(0);</span>
<span class="line-removed">-         start();</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     public int getLocalPort() {</span>
<span class="line-modified">!         return serverSock.getLocalPort();</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     public boolean accepting() {</span>
<span class="line-modified">!         return accepting;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     public void close() throws IOException {</span>
<span class="line-modified">!         serverSock.close();</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! class BindableServer extends TestServer {</span>
  
<span class="line-modified">!     public BindableServer() throws IOException {</span>
<span class="line-modified">!         super();</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     private byte[] bindResponse = {</span>
<span class="line-modified">!         0x30, 0x0C, 0x02, 0x01, 0x01, 0x61, 0x07, 0x0A,</span>
<span class="line-removed">-         0x01, 0x00, 0x04, 0x00, 0x04, 0x00</span>
<span class="line-removed">-     };</span>
  
<span class="line-removed">-     public void run() {</span>
          try {
<span class="line-modified">!             accepting = true;</span>
<span class="line-modified">!             Socket socket = serverSock.accept();</span>
<span class="line-modified">!             InputStream in = socket.getInputStream();</span>
<span class="line-modified">!             OutputStream out = socket.getOutputStream();</span>
<span class="line-modified">! </span>
<span class="line-removed">-             // Read the LDAP BindRequest</span>
<span class="line-removed">-             while (in.read() != -1) {</span>
<span class="line-removed">-                 in.skip(in.available());</span>
<span class="line-removed">-                 break;</span>
              }
<span class="line-modified">! </span>
<span class="line-modified">!             // Write an LDAP BindResponse</span>
<span class="line-modified">!             out.write(bindResponse);</span>
<span class="line-modified">!             out.flush();</span>
<span class="line-modified">!         } catch (IOException e) {</span>
<span class="line-modified">!             // ignore</span>
          }
      }
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- class DeadServer extends TestServer {</span>
<span class="line-removed">- </span>
<span class="line-removed">-     public DeadServer() throws IOException {</span>
<span class="line-removed">-         super();</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     public void run() {</span>
<span class="line-modified">!         while(true) {</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 accepting = true;</span>
<span class="line-modified">!                 Socket socket = serverSock.accept();</span>
<span class="line-modified">!             } catch (Exception e) {</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             }</span>
          }
<span class="line-modified">!     }</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! public class LdapTimeoutTest {</span>
  
<span class="line-modified">!     private static final ExecutorService testPool =</span>
<span class="line-modified">!         Executors.newFixedThreadPool(3);</span>
<span class="line-modified">!     private static final ScheduledExecutorService killSwitchPool =</span>
<span class="line-modified">!         Executors.newScheduledThreadPool(3);</span>
<span class="line-modified">!     public static int MIN_TIMEOUT = 18_000;</span>
<span class="line-modified">! </span>
<span class="line-removed">-     static Hashtable createEnv() {</span>
<span class="line-removed">-         Hashtable env = new Hashtable(11);</span>
<span class="line-removed">-         env.put(Context.INITIAL_CONTEXT_FACTORY,</span>
<span class="line-removed">-             &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-removed">-         return env;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     public static void main(String[] args) throws Exception {</span>
  
<span class="line-modified">!         InitialContext ctx = null;</span>
<span class="line-modified">!         List&lt;Future&gt; results = new ArrayList&lt;&gt;();</span>
  
          try {
<span class="line-modified">!             // run the DeadServerTest with no timeouts set</span>
<span class="line-modified">!             // this should get stuck indefinitely, so we need to kill</span>
<span class="line-modified">!             // it after a timeout</span>
<span class="line-modified">!             System.out.println(&quot;Running connect timeout test with 20s kill switch&quot;);</span>
<span class="line-modified">!             Hashtable env = createEnv();</span>
<span class="line-removed">-             results.add(</span>
<span class="line-removed">-                     testPool.submit(new DeadServerNoTimeoutTest(env, killSwitchPool)));</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // run the ReadServerTest with connect timeout set</span>
<span class="line-removed">-             // this should get stuck indefinitely so we need to kill</span>
<span class="line-removed">-             // it after a timeout</span>
<span class="line-removed">-             System.out.println(&quot;Running read timeout test with 10ms connect timeout &amp; 20s kill switch&quot;);</span>
<span class="line-removed">-             Hashtable env1 = createEnv();</span>
<span class="line-removed">-             env1.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, &quot;10&quot;);</span>
<span class="line-removed">-             results.add(testPool.submit(</span>
<span class="line-removed">-                     new ReadServerNoTimeoutTest(env1, killSwitchPool)));</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // run the ReadServerTest with no timeouts set</span>
<span class="line-removed">-             // this should get stuck indefinitely, so we need to kill</span>
<span class="line-removed">-             // it after a timeout</span>
<span class="line-removed">-             System.out.println(&quot;Running read timeout test with 20s kill switch&quot;);</span>
<span class="line-removed">-             Hashtable env2 = createEnv();</span>
<span class="line-removed">-             results.add(testPool.submit(</span>
<span class="line-removed">-                     new ReadServerNoTimeoutTest(env2, killSwitchPool)));</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // run the DeadServerTest with connect / read timeouts set</span>
<span class="line-removed">-             // this should exit after the connect timeout expires</span>
<span class="line-removed">-             System.out.println(&quot;Running connect timeout test with 10ms connect timeout, 3000ms read timeout&quot;);</span>
<span class="line-removed">-             Hashtable env3 = createEnv();</span>
<span class="line-removed">-             env3.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, &quot;10&quot;);</span>
<span class="line-removed">-             env3.put(&quot;com.sun.jndi.ldap.read.timeout&quot;, &quot;3000&quot;);</span>
<span class="line-removed">-             results.add(testPool.submit(new DeadServerTimeoutTest(env3)));</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-             // run the ReadServerTest with connect / read timeouts set</span>
<span class="line-removed">-             // this should exit after the connect timeout expires</span>
<span class="line-removed">-             //</span>
<span class="line-removed">-             // NOTE: commenting this test out as it is failing intermittently.</span>
<span class="line-removed">-             //</span>
<span class="line-removed">-             // System.out.println(&quot;Running read timeout test with 10ms connect timeout, 3000ms read timeout&quot;);</span>
<span class="line-removed">-             // Hashtable env4 = createEnv();</span>
<span class="line-removed">-             // env4.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, &quot;10&quot;);</span>
<span class="line-removed">-             // env4.put(&quot;com.sun.jndi.ldap.read.timeout&quot;, &quot;3000&quot;);</span>
<span class="line-removed">-             // results.add(testPool.submit(new ReadServerTimeoutTest(env4)));</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // run the DeadServerTest with connect timeout set</span>
<span class="line-removed">-             // this should exit after the connect timeout expires</span>
<span class="line-removed">-             System.out.println(&quot;Running connect timeout test with 10ms connect timeout&quot;);</span>
<span class="line-removed">-             Hashtable env5 = createEnv();</span>
<span class="line-removed">-             env5.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, &quot;10&quot;);</span>
<span class="line-removed">-             results.add(testPool.submit(new DeadServerTimeoutTest(env5)));</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // 8000487: Java JNDI connection library on ldap conn is</span>
<span class="line-removed">-             // not honoring configured timeout</span>
<span class="line-removed">-             System.out.println(&quot;Running simple auth connection test&quot;);</span>
<span class="line-removed">-             Hashtable env6 = createEnv();</span>
<span class="line-removed">-             env6.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, &quot;10&quot;);</span>
<span class="line-removed">-             env6.put(&quot;com.sun.jndi.ldap.read.timeout&quot;, &quot;3000&quot;);</span>
<span class="line-removed">-             env6.put(Context.SECURITY_AUTHENTICATION, &quot;simple&quot;);</span>
<span class="line-removed">-             env6.put(Context.SECURITY_PRINCIPAL, &quot;user&quot;);</span>
<span class="line-removed">-             env6.put(Context.SECURITY_CREDENTIALS, &quot;password&quot;);</span>
<span class="line-removed">-             results.add(testPool.submit(new DeadServerTimeoutTest(env6)));</span>
<span class="line-removed">- </span>
<span class="line-removed">-             boolean testFailed = false;</span>
<span class="line-removed">-             for (Future test : results) {</span>
<span class="line-removed">-                 while (!test.isDone()) {</span>
<span class="line-removed">-                     if ((Boolean) test.get() == false)</span>
<span class="line-removed">-                         testFailed = true;</span>
<span class="line-removed">-                 }</span>
              }
<span class="line-modified">! </span>
<span class="line-modified">!             if (testFailed) {</span>
<span class="line-modified">!                 throw new AssertionError(&quot;some tests failed&quot;);</span>
              }
<span class="line-modified">! </span>
          } finally {
<span class="line-modified">!             LdapTimeoutTest.killSwitchPool.shutdown();</span>
<span class="line-removed">-             LdapTimeoutTest.testPool.shutdown();</span>
          }
      }
  
<span class="line-modified">! }</span>
  
<span class="line-new-header">--- 19,489 ---</span>
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
<span class="line-modified">! /*</span>
   * @test
<span class="line-modified">!  * @library /test/lib</span>
<span class="line-modified">!  *          lib/</span>
<span class="line-added">+  * @run testng/othervm LdapTimeoutTest</span>
<span class="line-added">+  * @bug 7094377 8000487 6176036 7056489 8151678</span>
   * @summary Timeout tests for ldap
   */
  
<span class="line-added">+ import org.testng.Assert;</span>
<span class="line-added">+ import org.testng.annotations.BeforeTest;</span>
<span class="line-added">+ import org.testng.annotations.Test;</span>
<span class="line-added">+ </span>
<span class="line-added">+ import javax.naming.Context;</span>
<span class="line-added">+ import javax.naming.NamingException;</span>
<span class="line-added">+ import javax.naming.directory.InitialDirContext;</span>
<span class="line-added">+ import javax.naming.directory.SearchControls;</span>
<span class="line-added">+ import java.io.IOException;</span>
<span class="line-added">+ import java.io.OutputStream;</span>
  import java.net.Socket;
  import java.util.ArrayList;
<span class="line-added">+ import java.util.Hashtable;</span>
<span class="line-added">+ import java.util.List;</span>
<span class="line-added">+ import java.util.Objects;</span>
  import java.util.concurrent.Callable;
<span class="line-added">+ import java.util.concurrent.CompletableFuture;</span>
  import java.util.concurrent.ExecutionException;
  import java.util.concurrent.ExecutorService;
<span class="line-added">+ import java.util.concurrent.Executors;</span>
  import java.util.concurrent.Future;
<span class="line-modified">! import java.util.concurrent.FutureTask;</span>
<span class="line-modified">! import java.util.concurrent.SynchronousQueue;</span>
  import java.util.concurrent.TimeUnit;
<span class="line-modified">! import java.util.concurrent.TimeoutException;</span>
  
<span class="line-added">+ import static java.lang.String.format;</span>
  import static java.util.concurrent.TimeUnit.MILLISECONDS;
  import static java.util.concurrent.TimeUnit.NANOSECONDS;
<span class="line-added">+ import static jdk.test.lib.Utils.adjustTimeout;</span>
<span class="line-added">+ import static org.testng.Assert.assertTrue;</span>
<span class="line-added">+ import static org.testng.Assert.expectThrows;</span>
  
<span class="line-added">+ public class LdapTimeoutTest {</span>
  
<span class="line-modified">!     // ------ configure test timeouts here ------</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /*</span>
<span class="line-modified">!      * Practical representation of an infinite timeout.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private static final long INFINITY_MILLIS = adjustTimeout(20_000);</span>
<span class="line-modified">!     /*</span>
<span class="line-modified">!      * The acceptable variation in timeout measurements.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private static final long TOLERANCE       = adjustTimeout( 3_500);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private static final long CONNECT_MILLIS  = adjustTimeout( 3_000);</span>
<span class="line-modified">!     private static final long READ_MILLIS     = adjustTimeout(10_000);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     static {</span>
<span class="line-modified">!         // a series of checks to make sure this timeouts configuration is</span>
<span class="line-modified">!         // consistent and the timeouts do not overlap</span>
<span class="line-modified">! </span>
<span class="line-modified">!         assert (TOLERANCE &gt;= 0);</span>
<span class="line-modified">!         // context creation</span>
<span class="line-modified">!         assert (2 * CONNECT_MILLIS + TOLERANCE &lt; READ_MILLIS);</span>
<span class="line-modified">!         // context creation immediately followed by search</span>
<span class="line-modified">!         assert (2 * CONNECT_MILLIS + READ_MILLIS + TOLERANCE &lt; INFINITY_MILLIS);</span>
      }
  
<span class="line-modified">!     @BeforeTest</span>
<span class="line-modified">!     public void beforeTest() {</span>
<span class="line-added">+         startAuxiliaryDiagnosticOutput();</span>
      }
  
<span class="line-modified">!     /*</span>
<span class="line-added">+      * These are timeout tests and they are run in parallel to reduce the total</span>
<span class="line-added">+      * amount of run time.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Currently it doesn&#39;t seem possible to instruct JTREG to run TestNG test</span>
<span class="line-added">+      * methods in parallel. That said, this JTREG test is still</span>
<span class="line-added">+      * a &quot;TestNG-flavored&quot; test for the sake of having org.testng.Assert</span>
<span class="line-added">+      * capability.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @Test</span>
<span class="line-added">+     public void test() throws Exception {</span>
<span class="line-added">+         List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();</span>
<span class="line-added">+         ExecutorService executorService = Executors.newCachedThreadPool();</span>
          try {
<span class="line-modified">!             futures.add(executorService.submit(() -&gt; { test1(); return null; }));</span>
<span class="line-modified">!             futures.add(executorService.submit(() -&gt; { test2(); return null; }));</span>
<span class="line-modified">!             futures.add(executorService.submit(() -&gt; { test3(); return null; }));</span>
<span class="line-modified">!             futures.add(executorService.submit(() -&gt; { test4(); return null; }));</span>
<span class="line-added">+             futures.add(executorService.submit(() -&gt; { test5(); return null; }));</span>
<span class="line-added">+             futures.add(executorService.submit(() -&gt; { test6(); return null; }));</span>
<span class="line-added">+             futures.add(executorService.submit(() -&gt; { test7(); return null; }));</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             executorService.shutdown();</span>
          }
<span class="line-modified">!         int failedCount = 0;</span>
<span class="line-modified">!         for (var f : futures) {</span>
              try {
<span class="line-modified">!                 f.get();</span>
<span class="line-modified">!             } catch (ExecutionException e) {</span>
<span class="line-modified">!                 failedCount++;</span>
<span class="line-modified">!                 e.getCause().printStackTrace(System.out);</span>
              }
          }
<span class="line-added">+         if (failedCount &gt; 0)</span>
<span class="line-added">+             throw new RuntimeException(failedCount + &quot; (sub)tests failed&quot;);</span>
      }
  
<span class="line-modified">!     static void test1() throws Exception {</span>
<span class="line-modified">!         Hashtable&lt;Object, Object&gt; env = new Hashtable&lt;&gt;();</span>
<span class="line-added">+         env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-added">+         // Here and in the other tests it&#39;s important to close the server as</span>
<span class="line-added">+         // calling `thread.interrupt` from assertion may not be enough</span>
<span class="line-added">+         // (depending on where the blocking call has stuck)</span>
<span class="line-added">+         try (TestServer server = new NotBindableServer()) {</span>
<span class="line-added">+             env.put(Context.PROVIDER_URL, urlTo(server));</span>
<span class="line-added">+             server.start();</span>
<span class="line-added">+             // Here and in the other tests joining done purely to reduce timing</span>
<span class="line-added">+             // jitter. Commenting out or removing that should not make the test</span>
<span class="line-added">+             // incorrect. (ServerSocket can accept connection as soon as it is</span>
<span class="line-added">+             // bound, not need to call `accept` before that.)</span>
<span class="line-added">+             server.starting().join();</span>
<span class="line-added">+             assertIncompletion(INFINITY_MILLIS, () -&gt; new InitialDirContext(env));</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     static void test2() throws Exception {</span>
<span class="line-modified">!         Hashtable&lt;Object, Object&gt; env = new Hashtable&lt;&gt;();</span>
<span class="line-modified">!         env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-modified">!         env.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, String.valueOf(CONNECT_MILLIS));</span>
<span class="line-modified">!         try (TestServer server = new BindableButNotReadableServer()) {</span>
<span class="line-added">+             env.put(Context.PROVIDER_URL, urlTo(server));</span>
<span class="line-added">+             server.start();</span>
<span class="line-added">+             server.starting().join();</span>
<span class="line-added">+             InitialDirContext ctx = new InitialDirContext(env);</span>
<span class="line-added">+             SearchControls scl = new SearchControls();</span>
<span class="line-added">+             scl.setSearchScope(SearchControls.SUBTREE_SCOPE);</span>
<span class="line-added">+             assertIncompletion(INFINITY_MILLIS,</span>
<span class="line-added">+                                () -&gt; ctx.search(&quot;ou=People,o=JNDITutorial&quot;, &quot;(objectClass=*)&quot;, scl));</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     static void test3() throws Exception {</span>
<span class="line-modified">!         Hashtable&lt;Object, Object&gt; env = new Hashtable&lt;&gt;();</span>
<span class="line-modified">!         env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-modified">!         try (TestServer server = new BindableButNotReadableServer()) {</span>
<span class="line-modified">!             env.put(Context.PROVIDER_URL, urlTo(server));</span>
<span class="line-added">+             server.start();</span>
<span class="line-added">+             server.starting().join();</span>
<span class="line-added">+             InitialDirContext ctx = new InitialDirContext(env);</span>
<span class="line-added">+             SearchControls scl = new SearchControls();</span>
<span class="line-added">+             scl.setSearchScope(SearchControls.SUBTREE_SCOPE);</span>
<span class="line-added">+             assertIncompletion(INFINITY_MILLIS,</span>
<span class="line-added">+                                () -&gt; ctx.search(&quot;ou=People,o=JNDITutorial&quot;, &quot;(objectClass=*)&quot;, scl));</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     static void test4() throws Exception {</span>
<span class="line-modified">!         Hashtable&lt;Object, Object&gt; env = new Hashtable&lt;&gt;();</span>
<span class="line-added">+         env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-added">+         env.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, String.valueOf(CONNECT_MILLIS));</span>
<span class="line-added">+         env.put(&quot;com.sun.jndi.ldap.read.timeout&quot;, String.valueOf(READ_MILLIS));</span>
<span class="line-added">+         try (TestServer server = new NotBindableServer()) {</span>
<span class="line-added">+             env.put(Context.PROVIDER_URL, urlTo(server));</span>
<span class="line-added">+             server.start();</span>
<span class="line-added">+             server.starting().join();</span>
<span class="line-added">+             Assert.ThrowingRunnable completion =</span>
<span class="line-added">+                     () -&gt; assertCompletion(CONNECT_MILLIS,</span>
<span class="line-added">+                                            2 * CONNECT_MILLIS + TOLERANCE,</span>
<span class="line-added">+                                            () -&gt; new InitialDirContext(env));</span>
<span class="line-added">+             NamingException e = expectThrows(NamingException.class, completion);</span>
<span class="line-added">+             String msg = e.getMessage();</span>
<span class="line-added">+             assertTrue(msg != null &amp;&amp; msg.contains(&quot;timeout&quot;)</span>
<span class="line-added">+                                &amp;&amp; msg.contains(String.valueOf(CONNECT_MILLIS)),</span>
<span class="line-added">+                        msg);</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     static void test5() throws Exception {</span>
<span class="line-modified">!         Hashtable&lt;Object, Object&gt; env = new Hashtable&lt;&gt;();</span>
<span class="line-modified">!         env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-modified">!         env.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, String.valueOf(CONNECT_MILLIS));</span>
<span class="line-modified">!         env.put(&quot;com.sun.jndi.ldap.read.timeout&quot;, String.valueOf(READ_MILLIS));</span>
<span class="line-added">+         try (TestServer server = new BindableButNotReadableServer()) {</span>
<span class="line-added">+             env.put(Context.PROVIDER_URL, urlTo(server));</span>
<span class="line-added">+             server.start();</span>
<span class="line-added">+             server.starting().join();</span>
<span class="line-added">+             InitialDirContext ctx = new InitialDirContext(env);</span>
<span class="line-added">+             SearchControls scl = new SearchControls();</span>
<span class="line-added">+             scl.setSearchScope(SearchControls.SUBTREE_SCOPE);</span>
<span class="line-added">+             Assert.ThrowingRunnable completion =</span>
<span class="line-added">+                     () -&gt; assertCompletion(READ_MILLIS,</span>
<span class="line-added">+                                            READ_MILLIS + TOLERANCE,</span>
<span class="line-added">+                                            () -&gt; ctx.search(&quot;ou=People,o=JNDITutorial&quot;, &quot;(objectClass=*)&quot;, scl));</span>
<span class="line-added">+             NamingException e = expectThrows(NamingException.class, completion);</span>
<span class="line-added">+             String msg = e.getMessage();</span>
<span class="line-added">+             assertTrue(msg != null &amp;&amp; msg.contains(&quot;timeout&quot;)</span>
<span class="line-added">+                                &amp;&amp; msg.contains(String.valueOf(READ_MILLIS)),</span>
<span class="line-added">+                        msg);</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     static void test6() throws Exception {</span>
<span class="line-modified">!         Hashtable&lt;Object, Object&gt; env = new Hashtable&lt;&gt;();</span>
<span class="line-modified">!         env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-modified">!         env.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, String.valueOf(CONNECT_MILLIS));</span>
<span class="line-modified">!         env.put(&quot;com.sun.jndi.ldap.read.timeout&quot;, String.valueOf(READ_MILLIS));</span>
<span class="line-modified">!         try (TestServer server = new NotBindableServer()) {</span>
<span class="line-modified">!             env.put(Context.PROVIDER_URL, urlTo(server));</span>
<span class="line-modified">!             server.start();</span>
<span class="line-modified">!             server.starting().join();</span>
<span class="line-modified">!             Assert.ThrowingRunnable completion =</span>
<span class="line-added">+                     () -&gt; assertCompletion(CONNECT_MILLIS,</span>
<span class="line-added">+                                            2 * CONNECT_MILLIS + TOLERANCE,</span>
<span class="line-added">+                                            () -&gt; new InitialDirContext(env));</span>
<span class="line-added">+             NamingException e = expectThrows(NamingException.class, completion);</span>
<span class="line-added">+             String msg = e.getMessage();</span>
<span class="line-added">+             assertTrue(msg != null &amp;&amp; msg.contains(&quot;timeout&quot;)</span>
<span class="line-added">+                                &amp;&amp; msg.contains(String.valueOf(CONNECT_MILLIS)),</span>
<span class="line-added">+                        msg);</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     static void test7() throws Exception {</span>
<span class="line-modified">!         // 8000487: Java JNDI connection library on ldap conn is</span>
<span class="line-modified">!         // not honoring configured timeout</span>
<span class="line-modified">!         Hashtable&lt;Object, Object&gt; env = new Hashtable&lt;&gt;();</span>
<span class="line-modified">!         env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span>
<span class="line-modified">!         env.put(&quot;com.sun.jndi.ldap.connect.timeout&quot;, String.valueOf(CONNECT_MILLIS));</span>
<span class="line-modified">!         env.put(&quot;com.sun.jndi.ldap.read.timeout&quot;, String.valueOf(READ_MILLIS));</span>
<span class="line-modified">!         env.put(Context.SECURITY_AUTHENTICATION, &quot;simple&quot;);</span>
<span class="line-modified">!         env.put(Context.SECURITY_PRINCIPAL, &quot;user&quot;);</span>
<span class="line-modified">!         env.put(Context.SECURITY_CREDENTIALS, &quot;password&quot;);</span>
<span class="line-modified">!         try (TestServer server = new NotBindableServer()) {</span>
<span class="line-added">+             env.put(Context.PROVIDER_URL, urlTo(server));</span>
<span class="line-added">+             server.start();</span>
<span class="line-added">+             server.starting().join();</span>
<span class="line-added">+             Assert.ThrowingRunnable completion =</span>
<span class="line-added">+                     () -&gt; assertCompletion(CONNECT_MILLIS,</span>
<span class="line-added">+                                            2 * CONNECT_MILLIS + TOLERANCE,</span>
<span class="line-added">+                                            () -&gt; new InitialDirContext(env));</span>
<span class="line-added">+             NamingException e = expectThrows(NamingException.class, completion);</span>
<span class="line-added">+             String msg = e.getMessage();</span>
<span class="line-added">+             assertTrue(msg != null &amp;&amp; msg.contains(&quot;timeout&quot;)</span>
<span class="line-added">+                                &amp;&amp; msg.contains(String.valueOf(CONNECT_MILLIS)),</span>
<span class="line-added">+                        msg);</span>
          }
      }
  
<span class="line-modified">!     // ------ test stub servers ------</span>
  
<span class="line-modified">!     static class TestServer extends BaseLdapServer {</span>
  
<span class="line-modified">!         private final CompletableFuture&lt;Void&gt; starting = new CompletableFuture&lt;&gt;();</span>
  
<span class="line-added">+         TestServer() throws IOException { }</span>
  
<span class="line-modified">!         @Override</span>
<span class="line-added">+         protected void beforeAcceptingConnections() {</span>
<span class="line-added">+             starting.completeAsync(() -&gt; null);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         public CompletableFuture&lt;Void&gt; starting() {</span>
<span class="line-modified">!             return starting.copy();</span>
<span class="line-modified">!         }</span>
      }
  
<span class="line-modified">!     static class BindableButNotReadableServer extends TestServer {</span>
<span class="line-modified">! </span>
<span class="line-modified">!         BindableButNotReadableServer() throws IOException { }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         private static final byte[] bindResponse = {</span>
<span class="line-modified">!                 0x30, 0x0C, 0x02, 0x01, 0x01, 0x61, 0x07, 0x0A,</span>
<span class="line-modified">!                 0x01, 0x00, 0x04, 0x00, 0x04, 0x00</span>
<span class="line-modified">!         };</span>
<span class="line-modified">! </span>
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         protected void handleRequest(Socket socket,</span>
<span class="line-added">+                                      LdapMessage msg,</span>
<span class="line-added">+                                      OutputStream out)</span>
<span class="line-added">+                 throws IOException {</span>
<span class="line-added">+             switch (msg.getOperation()) {</span>
<span class="line-added">+                 case BIND_REQUEST:</span>
<span class="line-added">+                     out.write(bindResponse);</span>
<span class="line-added">+                     out.flush();</span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+             }</span>
          }
      }
  
<span class="line-modified">!     static class NotBindableServer extends TestServer {</span>
  
<span class="line-modified">!         NotBindableServer() throws IOException { }</span>
  
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         protected void beforeConnectionHandled(Socket socket) {</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 TimeUnit.DAYS.sleep(Integer.MAX_VALUE);</span>
<span class="line-modified">!             } catch (InterruptedException e) {</span>
<span class="line-modified">!                 Thread.currentThread().interrupt();</span>
<span class="line-added">+             }</span>
          }
      }
  
<span class="line-modified">!     // ------ timeouts check utilities ------</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /*</span>
<span class="line-added">+      * Asserts that the specified executable yields a result or an exception</span>
<span class="line-added">+      * within the specified time frame. Interrupts the executable</span>
<span class="line-added">+      * unconditionally.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * If the executable yields a result or an exception within the specified</span>
<span class="line-added">+      * time frame, the result will be returned and the exception will be</span>
<span class="line-added">+      * rethrown respectively in a transparent fashion as if the executable was</span>
<span class="line-added">+      * executed directly.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static &lt;T&gt; T assertCompletion(long loMillis,</span>
<span class="line-added">+                                          long hiMillis,</span>
<span class="line-added">+                                          Callable&lt;T&gt; code)</span>
<span class="line-added">+             throws Throwable {</span>
<span class="line-added">+         if (loMillis &lt; 0 || hiMillis &lt; 0 || loMillis &gt; hiMillis) {</span>
<span class="line-added">+             throw new IllegalArgumentException(&quot;loMillis=&quot; + loMillis +</span>
<span class="line-added">+                                                        &quot;, hiMillis=&quot; + hiMillis);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         Objects.requireNonNull(code);</span>
  
<span class="line-modified">!         // this queue acts both as an exchange point and a barrier</span>
<span class="line-modified">!         SynchronousQueue&lt;Long&gt; startTime = new SynchronousQueue&lt;&gt;();</span>
  
<span class="line-modified">!         Callable&lt;T&gt; wrappedTask = () -&gt; {</span>
<span class="line-modified">!             // by the time this value reaches the &quot;stopwatch&quot; thread it might be</span>
<span class="line-modified">!             // well outdated and that&#39;s okay, we will adjust the wait time</span>
<span class="line-modified">!             startTime.put(System.nanoTime());</span>
<span class="line-added">+             return code.call();</span>
<span class="line-added">+         };</span>
  
<span class="line-modified">!         FutureTask&lt;T&gt; task = new FutureTask&lt;&gt;(wrappedTask);</span>
<span class="line-added">+         Thread t = new Thread(task);</span>
<span class="line-added">+         t.start();</span>
  
<span class="line-modified">!         final long startNanos;</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             startNanos = startTime.take(); // (1) wait for the initial time mark</span>
<span class="line-added">+         } catch (Throwable e) {</span>
<span class="line-added">+             t.interrupt();</span>
<span class="line-added">+             throw e;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         final long waitTime = hiMillis -</span>
<span class="line-modified">!                 NANOSECONDS.toMillis(System.nanoTime() - startNanos); // (2) adjust wait time</span>
  
          try {
<span class="line-modified">!             T r = task.get(waitTime, MILLISECONDS); // (3) wait for the task to complete</span>
<span class="line-modified">!             long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);</span>
<span class="line-modified">!             if (elapsed &lt; loMillis || elapsed &gt; hiMillis) {</span>
<span class="line-modified">!                 throw new RuntimeException(format(</span>
<span class="line-modified">!                         &quot;After %s ms. (waitTime %s ms.) returned result &#39;%s&#39;&quot;, elapsed, waitTime, r));</span>
              }
<span class="line-modified">!             return r;</span>
<span class="line-modified">!         } catch (ExecutionException e) {</span>
<span class="line-modified">!             long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);</span>
<span class="line-modified">!             if (elapsed &lt; loMillis || elapsed &gt; hiMillis) {</span>
<span class="line-modified">!                 throw new RuntimeException(format(</span>
<span class="line-modified">!                         &quot;After %s ms. (waitTime %s ms.) thrown exception&quot;, elapsed, waitTime), e);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             throw e.getCause();</span>
<span class="line-added">+         } catch (TimeoutException e) {</span>
<span class="line-added">+             // We trust timed get not to throw TimeoutException prematurely</span>
<span class="line-added">+             // (i.e. before the wait time elapses)</span>
<span class="line-added">+             long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);</span>
<span class="line-added">+             throw new RuntimeException(format(</span>
<span class="line-added">+                     &quot;After %s ms. (waitTime %s ms.) is incomplete&quot;, elapsed, waitTime));</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             t.interrupt();</span>
          }
      }
  
<span class="line-modified">!     /*</span>
<span class="line-modified">!      * Asserts that the specified executable yields no result and no exception</span>
<span class="line-modified">!      * for at least the specified amount of time. Interrupts the executable</span>
<span class="line-modified">!      * unconditionally.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     public static void assertIncompletion(long millis, Callable&lt;?&gt; code)</span>
<span class="line-modified">!             throws Exception</span>
<span class="line-modified">!     {</span>
<span class="line-added">+         if (millis &lt; 0) {</span>
<span class="line-added">+             throw new IllegalArgumentException(&quot;millis=&quot; + millis);</span>
          }
<span class="line-modified">!         Objects.requireNonNull(code);</span>
  
<span class="line-modified">!         // this queue acts both as an exchange point and a barrier</span>
<span class="line-added">+         SynchronousQueue&lt;Long&gt; startTime = new SynchronousQueue&lt;&gt;();</span>
  
<span class="line-modified">!         Callable&lt;?&gt; wrappedTask = () -&gt; {</span>
<span class="line-modified">!             // by the time this value reaches the &quot;stopwatch&quot; thread it might be</span>
<span class="line-modified">!             // well outdated and that&#39;s okay, we will adjust the wait time</span>
<span class="line-modified">!             startTime.put(System.nanoTime());</span>
<span class="line-modified">!             return code.call();</span>
<span class="line-modified">!         };</span>
  
<span class="line-modified">!         FutureTask&lt;?&gt; task = new FutureTask&lt;&gt;(wrappedTask);</span>
<span class="line-added">+         Thread t = new Thread(task);</span>
<span class="line-added">+         t.start();</span>
<span class="line-added">+ </span>
<span class="line-added">+         final long startNanos;</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             startNanos = startTime.take(); // (1) wait for the initial time mark</span>
<span class="line-added">+         } catch (Throwable e) {</span>
<span class="line-added">+             t.interrupt();</span>
<span class="line-added">+             throw e;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         final long waitTime = millis -</span>
<span class="line-modified">!                 NANOSECONDS.toMillis(System.nanoTime() - startNanos); // (2) adjust wait time</span>
  
          try {
<span class="line-modified">!             Object r = task.get(waitTime, MILLISECONDS); // (3) wait for the task to complete</span>
<span class="line-modified">!             long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);</span>
<span class="line-modified">!             if (elapsed &lt; waitTime) {</span>
<span class="line-modified">!                 throw new RuntimeException(format(</span>
<span class="line-modified">!                         &quot;After %s ms. (waitTime %s ms.) returned result &#39;%s&#39;&quot;, elapsed, waitTime, r));</span>
              }
<span class="line-modified">!         } catch (ExecutionException e) {</span>
<span class="line-modified">!             long elapsed = NANOSECONDS.toMillis(System.nanoTime() - startNanos);</span>
<span class="line-modified">!             if (elapsed &lt; waitTime) {</span>
<span class="line-added">+                 throw new RuntimeException(format(</span>
<span class="line-added">+                         &quot;After %s ms. (waitTime %s ms.) thrown exception&quot;, elapsed, waitTime), e);</span>
              }
<span class="line-modified">!         } catch (TimeoutException expected) {</span>
          } finally {
<span class="line-modified">!             t.interrupt();</span>
          }
      }
  
<span class="line-modified">!     // ------ miscellaneous utilities ------</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static String urlTo(TestServer server) {</span>
<span class="line-added">+         String hostAddress = server.getInetAddress().getHostAddress();</span>
<span class="line-added">+         String addr;</span>
<span class="line-added">+         if (hostAddress.contains(&quot;:&quot;)) { // IPv6</span>
<span class="line-added">+             addr = &#39;[&#39; + hostAddress + &#39;]&#39;;</span>
<span class="line-added">+         } else {                         // IPv4</span>
<span class="line-added">+             addr = hostAddress;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return &quot;ldap://&quot; + addr + &quot;:&quot; + server.getPort();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /*</span>
<span class="line-added">+      * A diagnostic aid that might help with debugging timeout issues. The idea</span>
<span class="line-added">+      * is to continuously measure accuracy and responsiveness of the system that</span>
<span class="line-added">+      * runs this test. If the system is overwhelmed (with something else), it</span>
<span class="line-added">+      * might affect the test run. At the very least we will have traces of that</span>
<span class="line-added">+      * in the logs.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * This utility does not automatically scale up test timeouts, it simply</span>
<span class="line-added">+      * gathers information.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static void startAuxiliaryDiagnosticOutput() {</span>
<span class="line-added">+         System.out.printf(&quot;Starting diagnostic output (probe)%n&quot;);</span>
<span class="line-added">+         Thread t = new Thread(() -&gt; {</span>
<span class="line-added">+             for (int i = 0; ; i = ((i % 20) + 1)) {</span>
<span class="line-added">+                 // 500, 1_000, 1_500, ..., 9_500, 10_000, 500, 1_000, ...</span>
<span class="line-added">+                 long expected = i * 500;</span>
<span class="line-added">+                 long start = System.nanoTime();</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     MILLISECONDS.sleep(expected);</span>
<span class="line-added">+                 } catch (InterruptedException e) {</span>
<span class="line-added">+                     return;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 long stop = System.nanoTime();</span>
<span class="line-added">+                 long actual = NANOSECONDS.toMillis(stop - start);</span>
<span class="line-added">+                 System.out.printf(&quot;(probe) expected [ms.]: %s, actual [ms.]: %s%n&quot;,</span>
<span class="line-added">+                                   expected, actual);</span>
  
<span class="line-added">+             }</span>
<span class="line-added">+         }, &quot;probe&quot;);</span>
<span class="line-added">+         t.setDaemon(true);</span>
<span class="line-added">+         t.start();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
</pre>
<center><a href="LdapDnsProviderTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../management/HotSpotDiagnosticMXBean/CheckOrigin.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/com/sun/jdi/RedefineNestmateAttr/TestNestmateAttr.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8046171
 27  * @summary Class redefinition must preclude changes to nest attributes
 28  * @comment This is a copy of test/jdk/java/lang/instrument/RedefineNestmateAttr/
 29  * @comment modified for JDI
 30  * @library /test/lib ..
 31  * @modules java.compiler
 32  * @run build TestScaffold VMConnection TargetListener TargetAdapter
 33  * @compile NamedBuffer.java
 34  * @compile Host/Host.java
 35  * @run main/othervm TestNestmateAttr Host
 36  * @compile HostA/Host.java
 37  * @run main/othervm TestNestmateAttr HostA
 38  * @compile HostAB/Host.java
 39  * @run main/othervm TestNestmateAttr HostAB
 40  * @compile HostABC/Host.java
 41  * @run main/othervm TestNestmateAttr HostABC
 42  */
 43 
 44 /* Test Description
 45 
 46 The basic test class is called Host and we have variants that have zero or more
 47 nested classes named A, B, C etc. Each variant of Host is defined in source
 48 code in its own directory i.e.
 49 
 50 Host/Host.java defines zero nested classes
 51 HostA/Host.java defines one nested class A
 52 HostAB/Host.java defines two nested classes A and B (in that order)
 53 etc.
 54 
 55 Each Host class has the form:
 56 
 57   public class Host {
 58     public static String getID() { return &quot;&lt;directory name&gt;/Host.java&quot;; }
 59 
 60     &lt; zero or more empty nested classes&gt;
 61 
 62     public int m() {
 63         return 1; // original class
 64     }
 65   }
 66 
 67 Under each directory is a directory &quot;redef&quot; with a modified version of the Host
 68 class that changes the ID to e.g. Host/redef/Host.java, and the method m()
 69 returns 2. This allows us to check we have the redefined class loaded.
 70 
 71 Using Host&#39; to represent the redefined version we test redefinition
 72 combinations as follows:
 73 
 74 Host:
 75   Host -&gt; Host&#39;  - succeeds m() returns 2
 76   Host -&gt; HostA&#39; - fails - added a nest member
 77 
 78 HostA:
 79   HostA -&gt; HostA&#39;  - succeeds m() returns 2
 80   HostA -&gt; Host&#39;   - fails - removed a nest member
 81   HostA -&gt; HostAB&#39; - fails - added a nest member
 82   HostA -&gt; HostB&#39;  - fails - replaced a nest member
 83 
 84 HostAB:
 85   HostAB -&gt; HostAB&#39;  - succeeds m() returns 2
 86   HostAB -&gt; HostBA&#39;  - succeeds m() returns 2
 87   HostAB -&gt; HostA&#39;   - fails - removed a nest member
 88   HostAB -&gt; HostABC&#39; - fails - added a nest member
 89   HostAB -&gt; HostAC&#39;  - fails - replaced a nest member
 90 
 91 HostABC:
 92   HostABC -&gt; HostABC&#39;  - succeeds m() returns 2
 93   HostABC -&gt; HostACB&#39;  - succeeds m() returns 2
 94   HostABC -&gt; HostBAC&#39;  - succeeds m() returns 2
 95   HostABC -&gt; HostBCA&#39;  - succeeds m() returns 2
 96   HostABC -&gt; HostCAB&#39;  - succeeds m() returns 2
 97   HostABC -&gt; HostCBA&#39;  - succeeds m() returns 2
 98   HostABC -&gt; HostAB&#39;   - fails - removed a nest member
 99   HostABC -&gt; HostABCD&#39; - fails - added a nest member
100   HostABC -&gt; HostABD&#39;  - fails - replaced a nest member
101 
102 More than three nested classes doesn&#39;t add to the code coverage so
103 we stop here.
104 
105 Note that we always try to load the redefined version even when we expect it
106 to fail.
107 
108 We can only directly load one class Host per classloader, so to run all the
109 groups we either need to use new classloaders, or we reinvoke the test
110 requesting a different primary directory. We chose the latter using
111 multiple @run tags. So we proceed as follows:
112 
113  @compile Host/Host.java
114  @run TestNestmateAttr Host
115  @compile HostA/Host.java  - replaces previous Host.class
116  @run TestNestmateAttr HostA
117  @compile HostAB/Host.java  - replaces previous Host.class
118  @run TestNestmateAttr HostAB
119 etc.
120 
121 Within the test we directly compile redefined versions of the classes,
122 using CompilerUtil, and then read the .class file directly as a byte[].
123 
124 Finally we test redefinition of the NestHost attribute - which is
125 conceptually simple, but in fact very tricky to do. We do that
126 when testing HostA so we can reuse the Host$A class.
127 
128 */
129 
130 import com.sun.jdi.*;
131 import com.sun.jdi.event.*;
132 import com.sun.jdi.request.*;
133 
134 import java.io.File;
135 import java.io.FileInputStream;
136 import java.util.ArrayList;
137 import java.util.Arrays;
138 import java.util.Collections;
139 import java.util.HashMap;
140 import java.util.List;
141 import java.util.Map;
142 
143 import jdk.test.lib.ByteCodeLoader;
144 import jdk.test.lib.compiler.CompilerUtils;
145 import jdk.test.lib.compiler.InMemoryJavaCompiler;
146 import static jdk.test.lib.Asserts.assertTrue;
147 
148 /* For JDI the test is split across two VMs and so split into
149    two main classes. This is the class we will run under the debugger.
150    Package access so we can define in the same source file for ease of
151    reference.
152 */
153 class Target {
154 
155     static Class&lt;?&gt; topLevelHostA; // Prevent unloading of the class
156 
157     // We have to load all of the variants of the classes that we will
158     // attempt to redefine. This requires some in-memory compilation
159     // and use of additional classloaders.
160 
161     public static void main(String[] args) throws Throwable {
162         String origin = args[0];
163         System.out.println(&quot;Target: Testing original Host class from &quot; + origin);
164 
165         // Make sure the Host class loaded directly is an original version
166         // and from the expected location
167         Host h = new Host();
168         assertTrue(h.m() == 1);
169         assertTrue(Host.getID().startsWith(origin + &quot;/&quot;));
170 
171         // The rest of this setup is only needed for the case
172         // when we perform the checkNestHostChanges() test.
173         if (origin.equals(&quot;HostA&quot;)) {
174             String name = &quot;Host$A&quot;;
175 
176             // Have to do this reflectively as there is no Host$A
177             // when compiling the &quot;Host/&quot; case.
178             Class&lt;?&gt; nestedA = Class.forName(name); // triggers initialization
179 
180             // This is compiled as a top-level class: the $ in the name is not
181             // significant to the compiler.
182             String hostA = &quot;public class &quot; + name + &quot; {}&quot;;
183             byte[] bytes = InMemoryJavaCompiler.compile(name, hostA);
184             // And we have to load this into a new classloader
185             topLevelHostA = ByteCodeLoader.load(name, bytes);
186             // The loaded class has not been linked (as per ClassLoader.resolveClass)
187             // and so will be filtered out by VirtualMachine.allClasses(). There are
188             // a number of ways to force linking - this is the simplest.
189             Object o = topLevelHostA.newInstance();
190 
191             // sanity check
192             assertTrue(nestedA.getClassLoader() != topLevelHostA.getClassLoader());
193 
194         }
195 
196         breakpoint();    // debugger runs to here before enabling events
197         allowRedefine(); // debugger stops us here to attempt redefinitions
198 
199         System.out.println(&quot;Target executed okay&quot;);
200     }
201 
202     static void allowRedefine() { }
203     static void breakpoint() { }
204 }
205 
206 public class TestNestmateAttr extends TestScaffold {
207 
208     static final String SRC = System.getProperty(&quot;test.src&quot;);
209     static final String DEST = System.getProperty(&quot;test.classes&quot;);
210     static final boolean VERBOSE = Boolean.getBoolean(&quot;verbose&quot;);
211 
212     static String origin;
213 
214     // override this to correct a bug so arguments can be passed to
215     // the Target class
216     protected void startUp(String targetName) {
217         List&lt;String&gt; argList = new ArrayList&lt;&gt;(Arrays.asList(args));
218         argList.add(0, targetName); // pre-pend so it becomes the first &quot;app&quot; arg
219         // We need the class path that contains the path to jdk.test.lib.Asserts.
220         argList.add(0, &quot; -cp &quot; + System.getProperty(&quot;test.class.path&quot;));
221         println(&quot;run args: &quot; + argList);
222         connect((String[]) argList.toArray(args));
223         waitForVMStart();
224     }
225 
226     TestNestmateAttr (String[] args) {
227         super(args);
228     }
229 
230     public static void main(String[] args) throws Throwable {
231         origin = args[0];
232         new TestNestmateAttr(args).startTests();
233     }
234 
235     public void runTests() throws Exception {
236         // Get Target into debuggable state
237         BreakpointEvent bpe = startTo(&quot;Target&quot;, &quot;breakpoint&quot;, &quot;()V&quot;);
238         EventRequestManager erm = vm().eventRequestManager();
239         MethodEntryRequest mee = erm.createMethodEntryRequest();
240         mee.addClassFilter(&quot;Target&quot;);
241         mee.enable();
242 
243         // Allow application to complete and shut down
244         listenUntilVMDisconnect();
245 
246         if (getExceptionCaught()) {
247             throw new Exception(&quot;TestNestmateAttr: failed due to unexpected exception - check logs for details&quot;);
248         }
249         else if (!testFailed) {
250             println(&quot;TestNestmateAttr: passed&quot;);
251         } else {
252             throw new Exception(&quot;TestNestmateAttr: failure reported - check log for details&quot;);
253         }
254     }
255 
256     // All the actual work is done from here once we see we&#39;ve entered Target.allowRedefine()
257     public void methodEntered(MethodEntryEvent event) {
258         Method meth = event.location().method();
259 
260         if (!meth.name().equals(&quot;allowRedefine&quot;)) {
261             return;
262         }
263 
264         System.out.println(&quot;TestNestmateAttr: Testing original Host class from &quot; + origin);
265 
266         String[] badTransforms;  // directories of bad classes
267         String[] goodTransforms; // directories of good classes
268 
269         boolean testNestHostChanges = false;
270 
271         switch (origin) {
272         case &quot;Host&quot;:
273             badTransforms = new String[] {
274                 &quot;HostA&quot; // add member
275             };
276             goodTransforms = new String[] {
277                 origin
278             };
279             break;
280 
281         case &quot;HostA&quot;:
282             badTransforms = new String[] {
283                 &quot;Host&quot;,   // remove member
284                 &quot;HostAB&quot;, // add member
285                 &quot;HostB&quot;   // change member
286             };
287             goodTransforms = new String[] {
288                 origin
289             };
290             testNestHostChanges = true;
291             break;
292 
293         case &quot;HostAB&quot;:
294             badTransforms = new String[] {
295                 &quot;HostA&quot;,   // remove member
296                 &quot;HostABC&quot;, // add member
297                 &quot;HostAC&quot;   // change member
298             };
299             goodTransforms = new String[] {
300                 origin,
301                 &quot;HostBA&quot;  // reorder members
302             };
303             break;
304 
305         case &quot;HostABC&quot;:
306             badTransforms = new String[] {
307                 &quot;HostAB&quot;,   // remove member
308                 &quot;HostABCD&quot;, // add member
309                 &quot;HostABD&quot;   // change member
310             };
311             goodTransforms = new String[] {
312                 origin,
313                 &quot;HostACB&quot;,  // reorder members
314                 &quot;HostBAC&quot;,  // reorder members
315                 &quot;HostBCA&quot;,  // reorder members
316                 &quot;HostCAB&quot;,  // reorder members
317                 &quot;HostCBA&quot;   // reorder members
318             };
319             break;
320 
321         default: throw new Error(&quot;Unknown test directory: &quot; + origin);
322         }
323 
324         // Need to locate the type we will be trying to redefine in Target
325         findReferenceTypes();
326 
327         try {
328             // Compile and check bad transformations
329             checkBadTransforms(_Host, badTransforms);
330 
331             // Compile and check good transformations
332             checkGoodTransforms(_Host, goodTransforms);
333 
334             if (testNestHostChanges)
335                 checkNestHostChanges();
336         }
337         catch (Throwable t) {
338             failure(t);
339         }
340     }
341 
342     // override to give exception details
343     protected void failure(Throwable t) {
344         super.failure(t.getMessage());
345         t.printStackTrace(System.out);
346     }
347 
348     // These are references to the types in Target
349     // that we will be trying to redefine.
350     ReferenceType _Host;
351     ReferenceType _Host_A_nested;
352     ReferenceType _Host_A_topLevel;
353 
354     void findReferenceTypes() {
355         List&lt;ReferenceType&gt; classes = vm().allClasses();
356         ClassLoaderReference cl = null; // track the main loader
357         ReferenceType a1 = null;
358         ReferenceType a2 = null;
359         for (ReferenceType c : classes) {
360             String name = c.name();
361             if (name.equals(&quot;Host&quot;)) {
362                 _Host = c;
363                 cl = c.classLoader();
364             }
365             else if (name.equals(&quot;Host$A&quot;)) {
366                 if (a1 == null) {
367                     a1 = c;
368                 } else if (a2 == null) {
369                     a2 = c;
370                 }
371                 else {
372                     assertTrue(false); // Too many Host$A classes found!
373                 }
374             }
375         }
376         assertTrue(_Host != null);
377 
378         // The rest of this setup is only needed for the case
379         // when we perform the checkNestHostChanges() test.
380         if (origin.equals(&quot;HostA&quot;)) {
381             assertTrue(a1 != null);
382             assertTrue(a2 != null);
383 
384             if (a1.classLoader() == cl) {
385                 _Host_A_nested = a1;
386                 assertTrue(a2.classLoader() != cl);
387                 _Host_A_topLevel = a2;
388             }
389             else if (a2.classLoader() == cl) {
390                 _Host_A_nested = a2;
391                 assertTrue(a1.classLoader() != cl);
392                 _Host_A_topLevel = a1;
393             }
394             else {
395                 assertTrue(false); // Wrong classLoaders found
396             }
397         }
398     }
399 
400     void checkNestHostChanges() throws Throwable {
401         Map&lt;ReferenceType, byte[]&gt; map = new HashMap&lt;&gt;();
402 
403         // case 1: remove NestHost attribute
404         //   - try to redefine nested Host$A with a top-level
405         //     class called Host$A
406         System.out.println(&quot;Trying bad retransform that removes the NestHost attribute&quot;);
407 
408         String name = &quot;Host$A&quot;;
409 
410         // This is compiled as a top-level class: the $ in the name is not
411         // significant to the compiler.
412         String hostA = &quot;public class &quot; + name + &quot; {}&quot;;
413         byte[] bytes = InMemoryJavaCompiler.compile(name, hostA);
414 
415         map.put(_Host_A_nested, bytes);
416 
417         try {
418             vm().redefineClasses(map);
419             throw new Error(&quot;Retransformation to top-level class &quot; + name +
420                             &quot; succeeded unexpectedly&quot;);
421         }
422         catch (UnsupportedOperationException uoe) {
423             if (uoe.getMessage().contains(&quot;changes to class attribute not implemented&quot;)) {
424                 System.out.println(&quot;Got expected exception &quot; + uoe);
425             }
426             else throw new Error(&quot;Wrong UnsupportedOperationException&quot;, uoe);
427         }
428 
429         map.clear();
430 
431         // case 2: add NestHost attribute
432         //  - This is tricky because the class with no NestHost attribute
433         //    has to have the name of a nested class! But we know how to
434         //    do that as we already created a top-level Host$A. So now
435         //    we try to replace with a really nested Host$A.
436 
437         System.out.println(&quot;Trying bad retransform that adds the NestHost attribute&quot;);
438 
439         byte[] nestedBytes;
440         File clsfile = new File(DEST + &quot;/&quot; + name + &quot;.class&quot;);
441         if (VERBOSE) System.out.println(&quot;Reading bytes from &quot; + clsfile);
442         try (FileInputStream str = new FileInputStream(clsfile)) {
443             nestedBytes = NamedBuffer.loadBufferFromStream(str);
444         }
445 
446         map.put(_Host_A_topLevel, nestedBytes);
447 
448         try {
449             vm().redefineClasses(map);
450             throw new Error(&quot;Retransformation to nested class &quot; + name +
451                             &quot; succeeded unexpectedly&quot;);
452         }
453         catch (UnsupportedOperationException uoe) {
454             if (uoe.getMessage().contains(&quot;changes to class attribute not implemented&quot;)) {
455                 System.out.println(&quot;Got expected exception &quot; + uoe);
456             }
457             else throw new Error(&quot;Wrong UnsupportedOperationException&quot;, uoe);
458         }
459 
460         map.clear();
461 
462         // case 3: replace the NestHost attribute
463         //  - the easiest way (perhaps only reasonable way) to do this
464         //    is to search for the Utf8 entry used by the Constant_ClassRef,
465         //    set in the NestHost attribute, and edit it to refer to a different
466         //    name. We reuse nestedBytes from above.
467 
468         System.out.println(&quot;Trying bad retransform that changes the NestHost attribute&quot;);
469 
470         int utf8Entry_length = 7;
471         boolean found = false;
472         for (int i = 0; i &lt; nestedBytes.length - utf8Entry_length; i++) {
473             if (nestedBytes[i] == 1 &amp;&amp;   // utf8 tag
474                 nestedBytes[i+1] == 0 &amp;&amp; // msb of length
475                 nestedBytes[i+2] == 4 &amp;&amp; // lsb of length
476                 nestedBytes[i+3] == (byte) &#39;H&#39; &amp;&amp;
477                 nestedBytes[i+4] == (byte) &#39;o&#39; &amp;&amp;
478                 nestedBytes[i+5] == (byte) &#39;s&#39; &amp;&amp;
479                 nestedBytes[i+6] == (byte) &#39;t&#39;) {
480 
481                 if (VERBOSE) System.out.println(&quot;Appear to have found Host utf8 entry starting at &quot; + i);
482 
483                 nestedBytes[i+3] = (byte) &#39;G&#39;;
484                 found = true;
485                 break;
486             }
487         }
488 
489         if (!found)
490             throw new Error(&quot;Could not locate &#39;Host&#39; name in byte array&quot;);
491 
492         map.put(_Host_A_nested, nestedBytes);
493 
494         try {
495             vm().redefineClasses(map);
496             throw new Error(&quot;Retransformation to modified nested class&quot; +
497                             &quot; succeeded unexpectedly&quot;);
498         }
499         catch (UnsupportedOperationException uoe) {
500             if (uoe.getMessage().contains(&quot;changes to class attribute not implemented&quot;)) {
501                 System.out.println(&quot;Got expected exception &quot; + uoe);
502             }
503             else throw new Error(&quot;Wrong UnsupportedOperationException&quot;, uoe);
504         }
505 
506     }
507 
508     void checkGoodTransforms(ReferenceType c, String[] dirs) throws Throwable {
509         // To verify the redefinition actually took place we will invoke the
510         // Host.getID method and check the result. To do that we need to find the
511         // main thread in the target VM. We don&#39;t check that &quot;(new Host()).m()&quot;
512         // returns 2 due to the complexity of setting that up via JDI.
513 
514         ThreadReference main = null;
515         List&lt;ThreadReference&gt; threads = vm().allThreads();
516         for (ThreadReference t : threads) {
517             if (t.name().equals(&quot;main&quot;)) {
518                 main = t;
519                 break;
520             }
521         }
522 
523         assertTrue(main != null);
524 
525         // Now find the method
526         Method getID = null;
527         List&lt;Method&gt; methods = _Host.methodsByName(&quot;getID&quot;);
528         assertTrue(methods.size() == 1);
529         getID = methods.get(0);
530 
531         Map&lt;ReferenceType, byte[]&gt; map = new HashMap&lt;&gt;();
532         for (String dir : dirs) {
533             dir += &quot;/redef&quot;;
534             System.out.println(&quot;Trying good retransform from &quot; + dir);
535             byte[] buf = bytesForHostClass(dir);
536             map.put(c, buf);
537             vm().redefineClasses(map);
538             map.clear();
539             // Test redefinition worked
540             Value v = ((ClassType)_Host).invokeMethod(main, getID, Collections.emptyList(), 0);
541             assertTrue(v instanceof StringReference);
542             String id =  ((StringReference)v).value();
543             if (VERBOSE) System.out.println(&quot;Redefined ID: &quot; + id);
544             assertTrue(id.startsWith(dir));
545             assertTrue(id.contains(&quot;/redef/&quot;));
546         }
547     }
548 
549     void checkBadTransforms(ReferenceType c, String[] dirs) throws Throwable {
550         Map&lt;ReferenceType, byte[]&gt; map = new HashMap&lt;&gt;();
551         for (String dir : dirs) {
552             dir += &quot;/redef&quot;;
553             System.out.println(&quot;Trying bad retransform from &quot; + dir);
554             byte[] buf = bytesForHostClass(dir);
555             map.put(c, buf);
556             try {
557                 vm().redefineClasses(map);
558                 throw new Error(&quot;Retransformation from directory &quot; + dir +
559                                 &quot; succeeded unexpectedly&quot;);
560             }
561             catch (UnsupportedOperationException uoe) {
562                 if (uoe.getMessage().contains(&quot;changes to class attribute not implemented&quot;)) {
563                     System.out.println(&quot;Got expected exception &quot; + uoe);
564                 }
565                 else throw new Error(&quot;Wrong UnsupportedOperationException&quot;, uoe);
566             }
567         }
568     }
569 
570     static byte[] bytesForHostClass(String dir) throws Throwable {
571         compile(&quot;/&quot; + dir);
572         File clsfile = new File(DEST + &quot;/&quot; + dir + &quot;/Host.class&quot;);
573         if (VERBOSE) System.out.println(&quot;Reading bytes from &quot; + clsfile);
574         byte[] buf = null;
575         try (FileInputStream str = new FileInputStream(clsfile)) {
576             return buf = NamedBuffer.loadBufferFromStream(str);
577         }
578     }
579 
580     static void compile(String dir) throws Throwable {
581         File src = new File(SRC + dir);
582         File dst = new File(DEST + dir);
583         if (VERBOSE) System.out.println(&quot;Compiling from: &quot; + src + &quot;\n&quot; +
584                                         &quot;            to: &quot; + dst);
585         CompilerUtils.compile(src.toPath(),
586                               dst.toPath(),
587                               false /* don&#39;t recurse */,
588                               new String[0]);
589     }
590 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/com/sun/jdi/RedefineNestmateAttr/TestNestmateAttr.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../RedefineImplementor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../SimulResumerTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/com/sun/jdi/RedefineNestmateAttr/TestNestmateAttr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
134 import java.io.File;
135 import java.io.FileInputStream;
136 import java.util.ArrayList;
137 import java.util.Arrays;
138 import java.util.Collections;
139 import java.util.HashMap;
140 import java.util.List;
141 import java.util.Map;
142 
143 import jdk.test.lib.ByteCodeLoader;
144 import jdk.test.lib.compiler.CompilerUtils;
145 import jdk.test.lib.compiler.InMemoryJavaCompiler;
146 import static jdk.test.lib.Asserts.assertTrue;
147 
148 /* For JDI the test is split across two VMs and so split into
149    two main classes. This is the class we will run under the debugger.
150    Package access so we can define in the same source file for ease of
151    reference.
152 */
153 class Target {



154     // We have to load all of the variants of the classes that we will
155     // attempt to redefine. This requires some in-memory compilation
156     // and use of additional classloaders.

157     public static void main(String[] args) throws Throwable {
158         String origin = args[0];
159         System.out.println(&quot;Target: Testing original Host class from &quot; + origin);
160 
161         // Make sure the Host class loaded directly is an original version
162         // and from the expected location
163         Host h = new Host();
164         assertTrue(h.m() == 1);
165         assertTrue(Host.getID().startsWith(origin + &quot;/&quot;));
166 
167         // The rest of this setup is only needed for the case
168         // when we perform the checkNestHostChanges() test.
169         if (origin.equals(&quot;HostA&quot;)) {
170             String name = &quot;Host$A&quot;;
171 
172             // Have to do this reflectively as there is no Host$A
173             // when compiling the &quot;Host/&quot; case.
174             Class&lt;?&gt; nestedA = Class.forName(name); // triggers initialization
175 
176             // This is compiled as a top-level class: the $ in the name is not
177             // significant to the compiler.
178             String hostA = &quot;public class &quot; + name + &quot; {}&quot;;
179             byte[] bytes = InMemoryJavaCompiler.compile(name, hostA);
180             // And we have to load this into a new classloader
<span class="line-modified">181             Class&lt;?&gt; topLevelHostA = ByteCodeLoader.load(name, bytes);</span>
182             // The loaded class has not been linked (as per ClassLoader.resolveClass)
183             // and so will be filtered out by VirtualMachine.allClasses(). There are
184             // a number of ways to force linking - this is the simplest.
185             Object o = topLevelHostA.newInstance();
186 
187             // sanity check
188             assertTrue(nestedA.getClassLoader() != topLevelHostA.getClassLoader());
189 
190         }
191 
192         breakpoint();    // debugger runs to here before enabling events
193         allowRedefine(); // debugger stops us here to attempt redefinitions
194 
195         System.out.println(&quot;Target executed okay&quot;);
196     }
197 
198     static void allowRedefine() { }
199     static void breakpoint() { }
200 }
201 
</pre>
</td>
<td>
<hr />
<pre>
134 import java.io.File;
135 import java.io.FileInputStream;
136 import java.util.ArrayList;
137 import java.util.Arrays;
138 import java.util.Collections;
139 import java.util.HashMap;
140 import java.util.List;
141 import java.util.Map;
142 
143 import jdk.test.lib.ByteCodeLoader;
144 import jdk.test.lib.compiler.CompilerUtils;
145 import jdk.test.lib.compiler.InMemoryJavaCompiler;
146 import static jdk.test.lib.Asserts.assertTrue;
147 
148 /* For JDI the test is split across two VMs and so split into
149    two main classes. This is the class we will run under the debugger.
150    Package access so we can define in the same source file for ease of
151    reference.
152 */
153 class Target {
<span class="line-added">154 </span>
<span class="line-added">155     static Class&lt;?&gt; topLevelHostA; // Prevent unloading of the class</span>
<span class="line-added">156 </span>
157     // We have to load all of the variants of the classes that we will
158     // attempt to redefine. This requires some in-memory compilation
159     // and use of additional classloaders.
<span class="line-added">160 </span>
161     public static void main(String[] args) throws Throwable {
162         String origin = args[0];
163         System.out.println(&quot;Target: Testing original Host class from &quot; + origin);
164 
165         // Make sure the Host class loaded directly is an original version
166         // and from the expected location
167         Host h = new Host();
168         assertTrue(h.m() == 1);
169         assertTrue(Host.getID().startsWith(origin + &quot;/&quot;));
170 
171         // The rest of this setup is only needed for the case
172         // when we perform the checkNestHostChanges() test.
173         if (origin.equals(&quot;HostA&quot;)) {
174             String name = &quot;Host$A&quot;;
175 
176             // Have to do this reflectively as there is no Host$A
177             // when compiling the &quot;Host/&quot; case.
178             Class&lt;?&gt; nestedA = Class.forName(name); // triggers initialization
179 
180             // This is compiled as a top-level class: the $ in the name is not
181             // significant to the compiler.
182             String hostA = &quot;public class &quot; + name + &quot; {}&quot;;
183             byte[] bytes = InMemoryJavaCompiler.compile(name, hostA);
184             // And we have to load this into a new classloader
<span class="line-modified">185             topLevelHostA = ByteCodeLoader.load(name, bytes);</span>
186             // The loaded class has not been linked (as per ClassLoader.resolveClass)
187             // and so will be filtered out by VirtualMachine.allClasses(). There are
188             // a number of ways to force linking - this is the simplest.
189             Object o = topLevelHostA.newInstance();
190 
191             // sanity check
192             assertTrue(nestedA.getClassLoader() != topLevelHostA.getClassLoader());
193 
194         }
195 
196         breakpoint();    // debugger runs to here before enabling events
197         allowRedefine(); // debugger stops us here to attempt redefinitions
198 
199         System.out.println(&quot;Target executed okay&quot;);
200     }
201 
202     static void allowRedefine() { }
203     static void breakpoint() { }
204 }
205 
</pre>
</td>
</tr>
</table>
<center><a href="../RedefineImplementor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../SimulResumerTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/test/jdk/com/sun/jdi/RedefineNestmateAttr/TestNestmateAttr.java b/test/jdk/com/sun/jdi/RedefineNestmateAttr/TestNestmateAttr.java
--- a/test/jdk/com/sun/jdi/RedefineNestmateAttr/TestNestmateAttr.java
+++ b/test/jdk/com/sun/jdi/RedefineNestmateAttr/TestNestmateAttr.java
@@ -149,13 +149,17 @@
    two main classes. This is the class we will run under the debugger.
    Package access so we can define in the same source file for ease of
    reference.
 */
 class Target {
+
+    static Class<?> topLevelHostA; // Prevent unloading of the class
+
     // We have to load all of the variants of the classes that we will
     // attempt to redefine. This requires some in-memory compilation
     // and use of additional classloaders.
+
     public static void main(String[] args) throws Throwable {
         String origin = args[0];
         System.out.println("Target: Testing original Host class from " + origin);
 
         // Make sure the Host class loaded directly is an original version
@@ -176,11 +180,11 @@
             // This is compiled as a top-level class: the $ in the name is not
             // significant to the compiler.
             String hostA = "public class " + name + " {}";
             byte[] bytes = InMemoryJavaCompiler.compile(name, hostA);
             // And we have to load this into a new classloader
-            Class<?> topLevelHostA = ByteCodeLoader.load(name, bytes);
+            topLevelHostA = ByteCodeLoader.load(name, bytes);
             // The loaded class has not been linked (as per ClassLoader.resolveClass)
             // and so will be filtered out by VirtualMachine.allClasses(). There are
             // a number of ways to force linking - this is the simplest.
             Object o = topLevelHostA.newInstance();
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/com/sun/jdi/RedefineNestmateAttr/TestNestmateAttr.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8046171
 27  * @summary Class redefinition must preclude changes to nest attributes
 28  * @comment This is a copy of test/jdk/java/lang/instrument/RedefineNestmateAttr/
 29  * @comment modified for JDI
 30  * @library /test/lib ..
 31  * @modules java.compiler
 32  * @run build TestScaffold VMConnection TargetListener TargetAdapter
 33  * @compile NamedBuffer.java
 34  * @compile Host/Host.java
 35  * @run main/othervm TestNestmateAttr Host
 36  * @compile HostA/Host.java
 37  * @run main/othervm TestNestmateAttr HostA
 38  * @compile HostAB/Host.java
 39  * @run main/othervm TestNestmateAttr HostAB
 40  * @compile HostABC/Host.java
 41  * @run main/othervm TestNestmateAttr HostABC
 42  */
 43 
 44 /* Test Description
 45 
 46 The basic test class is called Host and we have variants that have zero or more
 47 nested classes named A, B, C etc. Each variant of Host is defined in source
 48 code in its own directory i.e.
 49 
 50 Host/Host.java defines zero nested classes
 51 HostA/Host.java defines one nested class A
 52 HostAB/Host.java defines two nested classes A and B (in that order)
 53 etc.
 54 
 55 Each Host class has the form:
 56 
 57   public class Host {
 58     public static String getID() { return &quot;&lt;directory name&gt;/Host.java&quot;; }
 59 
 60     &lt; zero or more empty nested classes&gt;
 61 
 62     public int m() {
 63         return 1; // original class
 64     }
 65   }
 66 
 67 Under each directory is a directory &quot;redef&quot; with a modified version of the Host
 68 class that changes the ID to e.g. Host/redef/Host.java, and the method m()
 69 returns 2. This allows us to check we have the redefined class loaded.
 70 
 71 Using Host&#39; to represent the redefined version we test redefinition
 72 combinations as follows:
 73 
 74 Host:
 75   Host -&gt; Host&#39;  - succeeds m() returns 2
 76   Host -&gt; HostA&#39; - fails - added a nest member
 77 
 78 HostA:
 79   HostA -&gt; HostA&#39;  - succeeds m() returns 2
 80   HostA -&gt; Host&#39;   - fails - removed a nest member
 81   HostA -&gt; HostAB&#39; - fails - added a nest member
 82   HostA -&gt; HostB&#39;  - fails - replaced a nest member
 83 
 84 HostAB:
 85   HostAB -&gt; HostAB&#39;  - succeeds m() returns 2
 86   HostAB -&gt; HostBA&#39;  - succeeds m() returns 2
 87   HostAB -&gt; HostA&#39;   - fails - removed a nest member
 88   HostAB -&gt; HostABC&#39; - fails - added a nest member
 89   HostAB -&gt; HostAC&#39;  - fails - replaced a nest member
 90 
 91 HostABC:
 92   HostABC -&gt; HostABC&#39;  - succeeds m() returns 2
 93   HostABC -&gt; HostACB&#39;  - succeeds m() returns 2
 94   HostABC -&gt; HostBAC&#39;  - succeeds m() returns 2
 95   HostABC -&gt; HostBCA&#39;  - succeeds m() returns 2
 96   HostABC -&gt; HostCAB&#39;  - succeeds m() returns 2
 97   HostABC -&gt; HostCBA&#39;  - succeeds m() returns 2
 98   HostABC -&gt; HostAB&#39;   - fails - removed a nest member
 99   HostABC -&gt; HostABCD&#39; - fails - added a nest member
100   HostABC -&gt; HostABD&#39;  - fails - replaced a nest member
101 
102 More than three nested classes doesn&#39;t add to the code coverage so
103 we stop here.
104 
105 Note that we always try to load the redefined version even when we expect it
106 to fail.
107 
108 We can only directly load one class Host per classloader, so to run all the
109 groups we either need to use new classloaders, or we reinvoke the test
110 requesting a different primary directory. We chose the latter using
111 multiple @run tags. So we proceed as follows:
112 
113  @compile Host/Host.java
114  @run TestNestmateAttr Host
115  @compile HostA/Host.java  - replaces previous Host.class
116  @run TestNestmateAttr HostA
117  @compile HostAB/Host.java  - replaces previous Host.class
118  @run TestNestmateAttr HostAB
119 etc.
120 
121 Within the test we directly compile redefined versions of the classes,
122 using CompilerUtil, and then read the .class file directly as a byte[].
123 
124 Finally we test redefinition of the NestHost attribute - which is
125 conceptually simple, but in fact very tricky to do. We do that
126 when testing HostA so we can reuse the Host$A class.
127 
128 */
129 
130 import com.sun.jdi.*;
131 import com.sun.jdi.event.*;
132 import com.sun.jdi.request.*;
133 
134 import java.io.File;
135 import java.io.FileInputStream;
136 import java.util.ArrayList;
137 import java.util.Arrays;
138 import java.util.Collections;
139 import java.util.HashMap;
140 import java.util.List;
141 import java.util.Map;
142 
143 import jdk.test.lib.ByteCodeLoader;
144 import jdk.test.lib.compiler.CompilerUtils;
145 import jdk.test.lib.compiler.InMemoryJavaCompiler;
146 import static jdk.test.lib.Asserts.assertTrue;
147 
148 /* For JDI the test is split across two VMs and so split into
149    two main classes. This is the class we will run under the debugger.
150    Package access so we can define in the same source file for ease of
151    reference.
152 */
153 class Target {
154     // We have to load all of the variants of the classes that we will
155     // attempt to redefine. This requires some in-memory compilation
156     // and use of additional classloaders.
157     public static void main(String[] args) throws Throwable {
158         String origin = args[0];
159         System.out.println(&quot;Target: Testing original Host class from &quot; + origin);
160 
161         // Make sure the Host class loaded directly is an original version
162         // and from the expected location
163         Host h = new Host();
164         assertTrue(h.m() == 1);
165         assertTrue(Host.getID().startsWith(origin + &quot;/&quot;));
166 
167         // The rest of this setup is only needed for the case
168         // when we perform the checkNestHostChanges() test.
169         if (origin.equals(&quot;HostA&quot;)) {
170             String name = &quot;Host$A&quot;;
171 
172             // Have to do this reflectively as there is no Host$A
173             // when compiling the &quot;Host/&quot; case.
174             Class&lt;?&gt; nestedA = Class.forName(name); // triggers initialization
175 
176             // This is compiled as a top-level class: the $ in the name is not
177             // significant to the compiler.
178             String hostA = &quot;public class &quot; + name + &quot; {}&quot;;
179             byte[] bytes = InMemoryJavaCompiler.compile(name, hostA);
180             // And we have to load this into a new classloader
181             Class&lt;?&gt; topLevelHostA = ByteCodeLoader.load(name, bytes);
182             // The loaded class has not been linked (as per ClassLoader.resolveClass)
183             // and so will be filtered out by VirtualMachine.allClasses(). There are
184             // a number of ways to force linking - this is the simplest.
185             Object o = topLevelHostA.newInstance();
186 
187             // sanity check
188             assertTrue(nestedA.getClassLoader() != topLevelHostA.getClassLoader());
189 
190         }
191 
192         breakpoint();    // debugger runs to here before enabling events
193         allowRedefine(); // debugger stops us here to attempt redefinitions
194 
195         System.out.println(&quot;Target executed okay&quot;);
196     }
197 
198     static void allowRedefine() { }
199     static void breakpoint() { }
200 }
201 
202 public class TestNestmateAttr extends TestScaffold {
203 
204     static final String SRC = System.getProperty(&quot;test.src&quot;);
205     static final String DEST = System.getProperty(&quot;test.classes&quot;);
206     static final boolean VERBOSE = Boolean.getBoolean(&quot;verbose&quot;);
207 
208     static String origin;
209 
210     // override this to correct a bug so arguments can be passed to
211     // the Target class
212     protected void startUp(String targetName) {
213         List&lt;String&gt; argList = new ArrayList&lt;&gt;(Arrays.asList(args));
214         argList.add(0, targetName); // pre-pend so it becomes the first &quot;app&quot; arg
215         // We need the class path that contains the path to jdk.test.lib.Asserts.
216         argList.add(0, &quot; -cp &quot; + System.getProperty(&quot;test.class.path&quot;));
217         println(&quot;run args: &quot; + argList);
218         connect((String[]) argList.toArray(args));
219         waitForVMStart();
220     }
221 
222     TestNestmateAttr (String[] args) {
223         super(args);
224     }
225 
226     public static void main(String[] args) throws Throwable {
227         origin = args[0];
228         new TestNestmateAttr(args).startTests();
229     }
230 
231     public void runTests() throws Exception {
232         // Get Target into debuggable state
233         BreakpointEvent bpe = startTo(&quot;Target&quot;, &quot;breakpoint&quot;, &quot;()V&quot;);
234         EventRequestManager erm = vm().eventRequestManager();
235         MethodEntryRequest mee = erm.createMethodEntryRequest();
236         mee.addClassFilter(&quot;Target&quot;);
237         mee.enable();
238 
239         // Allow application to complete and shut down
240         listenUntilVMDisconnect();
241 
242         if (getExceptionCaught()) {
243             throw new Exception(&quot;TestNestmateAttr: failed due to unexpected exception - check logs for details&quot;);
244         }
245         else if (!testFailed) {
246             println(&quot;TestNestmateAttr: passed&quot;);
247         } else {
248             throw new Exception(&quot;TestNestmateAttr: failure reported - check log for details&quot;);
249         }
250     }
251 
252     // All the actual work is done from here once we see we&#39;ve entered Target.allowRedefine()
253     public void methodEntered(MethodEntryEvent event) {
254         Method meth = event.location().method();
255 
256         if (!meth.name().equals(&quot;allowRedefine&quot;)) {
257             return;
258         }
259 
260         System.out.println(&quot;TestNestmateAttr: Testing original Host class from &quot; + origin);
261 
262         String[] badTransforms;  // directories of bad classes
263         String[] goodTransforms; // directories of good classes
264 
265         boolean testNestHostChanges = false;
266 
267         switch (origin) {
268         case &quot;Host&quot;:
269             badTransforms = new String[] {
270                 &quot;HostA&quot; // add member
271             };
272             goodTransforms = new String[] {
273                 origin
274             };
275             break;
276 
277         case &quot;HostA&quot;:
278             badTransforms = new String[] {
279                 &quot;Host&quot;,   // remove member
280                 &quot;HostAB&quot;, // add member
281                 &quot;HostB&quot;   // change member
282             };
283             goodTransforms = new String[] {
284                 origin
285             };
286             testNestHostChanges = true;
287             break;
288 
289         case &quot;HostAB&quot;:
290             badTransforms = new String[] {
291                 &quot;HostA&quot;,   // remove member
292                 &quot;HostABC&quot;, // add member
293                 &quot;HostAC&quot;   // change member
294             };
295             goodTransforms = new String[] {
296                 origin,
297                 &quot;HostBA&quot;  // reorder members
298             };
299             break;
300 
301         case &quot;HostABC&quot;:
302             badTransforms = new String[] {
303                 &quot;HostAB&quot;,   // remove member
304                 &quot;HostABCD&quot;, // add member
305                 &quot;HostABD&quot;   // change member
306             };
307             goodTransforms = new String[] {
308                 origin,
309                 &quot;HostACB&quot;,  // reorder members
310                 &quot;HostBAC&quot;,  // reorder members
311                 &quot;HostBCA&quot;,  // reorder members
312                 &quot;HostCAB&quot;,  // reorder members
313                 &quot;HostCBA&quot;   // reorder members
314             };
315             break;
316 
317         default: throw new Error(&quot;Unknown test directory: &quot; + origin);
318         }
319 
320         // Need to locate the type we will be trying to redefine in Target
321         findReferenceTypes();
322 
323         try {
324             // Compile and check bad transformations
325             checkBadTransforms(_Host, badTransforms);
326 
327             // Compile and check good transformations
328             checkGoodTransforms(_Host, goodTransforms);
329 
330             if (testNestHostChanges)
331                 checkNestHostChanges();
332         }
333         catch (Throwable t) {
334             failure(t);
335         }
336     }
337 
338     // override to give exception details
339     protected void failure(Throwable t) {
340         super.failure(t.getMessage());
341         t.printStackTrace(System.out);
342     }
343 
344     // These are references to the types in Target
345     // that we will be trying to redefine.
346     ReferenceType _Host;
347     ReferenceType _Host_A_nested;
348     ReferenceType _Host_A_topLevel;
349 
350     void findReferenceTypes() {
351         List&lt;ReferenceType&gt; classes = vm().allClasses();
352         ClassLoaderReference cl = null; // track the main loader
353         ReferenceType a1 = null;
354         ReferenceType a2 = null;
355         for (ReferenceType c : classes) {
356             String name = c.name();
357             if (name.equals(&quot;Host&quot;)) {
358                 _Host = c;
359                 cl = c.classLoader();
360             }
361             else if (name.equals(&quot;Host$A&quot;)) {
362                 if (a1 == null) {
363                     a1 = c;
364                 } else if (a2 == null) {
365                     a2 = c;
366                 }
367                 else {
368                     assertTrue(false); // Too many Host$A classes found!
369                 }
370             }
371         }
372         assertTrue(_Host != null);
373 
374         // The rest of this setup is only needed for the case
375         // when we perform the checkNestHostChanges() test.
376         if (origin.equals(&quot;HostA&quot;)) {
377             assertTrue(a1 != null);
378             assertTrue(a2 != null);
379 
380             if (a1.classLoader() == cl) {
381                 _Host_A_nested = a1;
382                 assertTrue(a2.classLoader() != cl);
383                 _Host_A_topLevel = a2;
384             }
385             else if (a2.classLoader() == cl) {
386                 _Host_A_nested = a2;
387                 assertTrue(a1.classLoader() != cl);
388                 _Host_A_topLevel = a1;
389             }
390             else {
391                 assertTrue(false); // Wrong classLoaders found
392             }
393         }
394     }
395 
396     void checkNestHostChanges() throws Throwable {
397         Map&lt;ReferenceType, byte[]&gt; map = new HashMap&lt;&gt;();
398 
399         // case 1: remove NestHost attribute
400         //   - try to redefine nested Host$A with a top-level
401         //     class called Host$A
402         System.out.println(&quot;Trying bad retransform that removes the NestHost attribute&quot;);
403 
404         String name = &quot;Host$A&quot;;
405 
406         // This is compiled as a top-level class: the $ in the name is not
407         // significant to the compiler.
408         String hostA = &quot;public class &quot; + name + &quot; {}&quot;;
409         byte[] bytes = InMemoryJavaCompiler.compile(name, hostA);
410 
411         map.put(_Host_A_nested, bytes);
412 
413         try {
414             vm().redefineClasses(map);
415             throw new Error(&quot;Retransformation to top-level class &quot; + name +
416                             &quot; succeeded unexpectedly&quot;);
417         }
418         catch (UnsupportedOperationException uoe) {
419             if (uoe.getMessage().contains(&quot;changes to class attribute not implemented&quot;)) {
420                 System.out.println(&quot;Got expected exception &quot; + uoe);
421             }
422             else throw new Error(&quot;Wrong UnsupportedOperationException&quot;, uoe);
423         }
424 
425         map.clear();
426 
427         // case 2: add NestHost attribute
428         //  - This is tricky because the class with no NestHost attribute
429         //    has to have the name of a nested class! But we know how to
430         //    do that as we already created a top-level Host$A. So now
431         //    we try to replace with a really nested Host$A.
432 
433         System.out.println(&quot;Trying bad retransform that adds the NestHost attribute&quot;);
434 
435         byte[] nestedBytes;
436         File clsfile = new File(DEST + &quot;/&quot; + name + &quot;.class&quot;);
437         if (VERBOSE) System.out.println(&quot;Reading bytes from &quot; + clsfile);
438         try (FileInputStream str = new FileInputStream(clsfile)) {
439             nestedBytes = NamedBuffer.loadBufferFromStream(str);
440         }
441 
442         map.put(_Host_A_topLevel, nestedBytes);
443 
444         try {
445             vm().redefineClasses(map);
446             throw new Error(&quot;Retransformation to nested class &quot; + name +
447                             &quot; succeeded unexpectedly&quot;);
448         }
449         catch (UnsupportedOperationException uoe) {
450             if (uoe.getMessage().contains(&quot;changes to class attribute not implemented&quot;)) {
451                 System.out.println(&quot;Got expected exception &quot; + uoe);
452             }
453             else throw new Error(&quot;Wrong UnsupportedOperationException&quot;, uoe);
454         }
455 
456         map.clear();
457 
458         // case 3: replace the NestHost attribute
459         //  - the easiest way (perhaps only reasonable way) to do this
460         //    is to search for the Utf8 entry used by the Constant_ClassRef,
461         //    set in the NestHost attribute, and edit it to refer to a different
462         //    name. We reuse nestedBytes from above.
463 
464         System.out.println(&quot;Trying bad retransform that changes the NestHost attribute&quot;);
465 
466         int utf8Entry_length = 7;
467         boolean found = false;
468         for (int i = 0; i &lt; nestedBytes.length - utf8Entry_length; i++) {
469             if (nestedBytes[i] == 1 &amp;&amp;   // utf8 tag
470                 nestedBytes[i+1] == 0 &amp;&amp; // msb of length
471                 nestedBytes[i+2] == 4 &amp;&amp; // lsb of length
472                 nestedBytes[i+3] == (byte) &#39;H&#39; &amp;&amp;
473                 nestedBytes[i+4] == (byte) &#39;o&#39; &amp;&amp;
474                 nestedBytes[i+5] == (byte) &#39;s&#39; &amp;&amp;
475                 nestedBytes[i+6] == (byte) &#39;t&#39;) {
476 
477                 if (VERBOSE) System.out.println(&quot;Appear to have found Host utf8 entry starting at &quot; + i);
478 
479                 nestedBytes[i+3] = (byte) &#39;G&#39;;
480                 found = true;
481                 break;
482             }
483         }
484 
485         if (!found)
486             throw new Error(&quot;Could not locate &#39;Host&#39; name in byte array&quot;);
487 
488         map.put(_Host_A_nested, nestedBytes);
489 
490         try {
491             vm().redefineClasses(map);
492             throw new Error(&quot;Retransformation to modified nested class&quot; +
493                             &quot; succeeded unexpectedly&quot;);
494         }
495         catch (UnsupportedOperationException uoe) {
496             if (uoe.getMessage().contains(&quot;changes to class attribute not implemented&quot;)) {
497                 System.out.println(&quot;Got expected exception &quot; + uoe);
498             }
499             else throw new Error(&quot;Wrong UnsupportedOperationException&quot;, uoe);
500         }
501 
502     }
503 
504     void checkGoodTransforms(ReferenceType c, String[] dirs) throws Throwable {
505         // To verify the redefinition actually took place we will invoke the
506         // Host.getID method and check the result. To do that we need to find the
507         // main thread in the target VM. We don&#39;t check that &quot;(new Host()).m()&quot;
508         // returns 2 due to the complexity of setting that up via JDI.
509 
510         ThreadReference main = null;
511         List&lt;ThreadReference&gt; threads = vm().allThreads();
512         for (ThreadReference t : threads) {
513             if (t.name().equals(&quot;main&quot;)) {
514                 main = t;
515                 break;
516             }
517         }
518 
519         assertTrue(main != null);
520 
521         // Now find the method
522         Method getID = null;
523         List&lt;Method&gt; methods = _Host.methodsByName(&quot;getID&quot;);
524         assertTrue(methods.size() == 1);
525         getID = methods.get(0);
526 
527         Map&lt;ReferenceType, byte[]&gt; map = new HashMap&lt;&gt;();
528         for (String dir : dirs) {
529             dir += &quot;/redef&quot;;
530             System.out.println(&quot;Trying good retransform from &quot; + dir);
531             byte[] buf = bytesForHostClass(dir);
532             map.put(c, buf);
533             vm().redefineClasses(map);
534             map.clear();
535             // Test redefinition worked
536             Value v = ((ClassType)_Host).invokeMethod(main, getID, Collections.emptyList(), 0);
537             assertTrue(v instanceof StringReference);
538             String id =  ((StringReference)v).value();
539             if (VERBOSE) System.out.println(&quot;Redefined ID: &quot; + id);
540             assertTrue(id.startsWith(dir));
541             assertTrue(id.contains(&quot;/redef/&quot;));
542         }
543     }
544 
545     void checkBadTransforms(ReferenceType c, String[] dirs) throws Throwable {
546         Map&lt;ReferenceType, byte[]&gt; map = new HashMap&lt;&gt;();
547         for (String dir : dirs) {
548             dir += &quot;/redef&quot;;
549             System.out.println(&quot;Trying bad retransform from &quot; + dir);
550             byte[] buf = bytesForHostClass(dir);
551             map.put(c, buf);
552             try {
553                 vm().redefineClasses(map);
554                 throw new Error(&quot;Retransformation from directory &quot; + dir +
555                                 &quot; succeeded unexpectedly&quot;);
556             }
557             catch (UnsupportedOperationException uoe) {
558                 if (uoe.getMessage().contains(&quot;changes to class attribute not implemented&quot;)) {
559                     System.out.println(&quot;Got expected exception &quot; + uoe);
560                 }
561                 else throw new Error(&quot;Wrong UnsupportedOperationException&quot;, uoe);
562             }
563         }
564     }
565 
566     static byte[] bytesForHostClass(String dir) throws Throwable {
567         compile(&quot;/&quot; + dir);
568         File clsfile = new File(DEST + &quot;/&quot; + dir + &quot;/Host.class&quot;);
569         if (VERBOSE) System.out.println(&quot;Reading bytes from &quot; + clsfile);
570         byte[] buf = null;
571         try (FileInputStream str = new FileInputStream(clsfile)) {
572             return buf = NamedBuffer.loadBufferFromStream(str);
573         }
574     }
575 
576     static void compile(String dir) throws Throwable {
577         File src = new File(SRC + dir);
578         File dst = new File(DEST + dir);
579         if (VERBOSE) System.out.println(&quot;Compiling from: &quot; + src + &quot;\n&quot; +
580                                         &quot;            to: &quot; + dst);
581         CompilerUtils.compile(src.toPath(),
582                               dst.toPath(),
583                               false /* don&#39;t recurse */,
584                               new String[0]);
585     }
586 }
    </pre>
  </body>
</html>
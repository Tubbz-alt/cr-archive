<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/com/sun/jdi/BadHandshakeTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.net.Socket;
 25 
 26 import com.sun.jdi.Bootstrap;
 27 import com.sun.jdi.VirtualMachine;
 28 import com.sun.jdi.event.*;
 29 import com.sun.jdi.connect.Connector;
 30 import com.sun.jdi.connect.AttachingConnector;
 31 import com.sun.jdi.connect.Connector.Argument;
 32 
 33 import java.util.Map;
 34 import java.util.List;
 35 import java.util.Iterator;
 36 import java.util.concurrent.TimeUnit;
 37 import java.util.concurrent.atomic.AtomicBoolean;
 38 
 39 import jdk.test.lib.Utils;
 40 import jdk.test.lib.process.ProcessTools;
 41 
 42 /* @test
 43  * @bug 6306165 6432567
 44  * @summary Check that a bad handshake doesn&#39;t cause a debuggee to abort
 45  * @library /test/lib
 46  *
 47  * @modules java.management
 48  *          jdk.jdi
 49  * @build VMConnection BadHandshakeTest Exit0
 50  * @run driver BadHandshakeTest
 51  */
 52 public class BadHandshakeTest {
 53 
 54     /*
 55      * Find a connector by name
 56      */
 57     private static Connector findConnector(String name) {
 58         List&lt;Connector&gt; connectors = Bootstrap.virtualMachineManager().allConnectors();
 59         Iterator&lt;Connector&gt; iter = connectors.iterator();
 60         while (iter.hasNext()) {
 61             Connector connector = (Connector)iter.next();
 62             if (connector.name().equals(name)) {
 63                 return connector;
 64             }
 65         }
 66         return null;
 67     }
 68 
 69     /*
 70      * Launch a server debuggee with the given address
 71      */
 72     private static LaunchResult launch(String address, String class_name) throws Exception {
 73         String[] args = VMConnection.insertDebuggeeVMOptions(new String[] {
 74             &quot;-agentlib:jdwp=transport=dt_socket&quot; +
 75             &quot;,server=y&quot; + &quot;,suspend=y&quot; + &quot;,address=&quot; + address,
 76             class_name
 77         });
 78 
 79         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(args);
 80 
 81         final AtomicBoolean success = new AtomicBoolean();
 82         final AtomicBoolean bindFailed = new AtomicBoolean();
 83         Process p = ProcessTools.startProcess(
 84             class_name,
 85             pb,
 86             (line) -&gt; {
 87                 // &#39;Listening for transport dt_socket at address: xxxxx&#39;
 88                 // indicates the debuggee is ready to accept connections
 89                 if (line.contains(&quot;Listening for transport dt_socket at address:&quot;)) {
 90                     success.set(true);
 91                     return true;
 92                 }
 93                 // &#39;Address already in use&#39; indicates
 94                 // the debuggee has failed to start due to busy port.
 95                 if (line.contains(&quot;Address already in use&quot;)) {
 96                     bindFailed.set(true);
 97                     return true;
 98                 }
 99                 return false;
100             },
101             Integer.MAX_VALUE,
102             TimeUnit.MILLISECONDS
103         );
104 
105         return new LaunchResult(success.get() ? p : null,
106                 bindFailed.get());
107     }
108 
109     /*
110      * - pick a TCP port
111      * - Launch a server debuggee: server=y,suspend=y,address=${port}
112      * - run it to VM death
113      * - verify we saw no error
114      */
115     public static void main(String args[]) throws Exception {
116         // Launch the server debuggee
117         int port = 0;
118         Process process = null;
119         while (process == null) {
120             port = Utils.getFreePort();
121             String address = String.valueOf(port);
122             LaunchResult launchResult = launch(address, &quot;Exit0&quot;);
123             process = launchResult.getProcess();
124             if (launchResult.isBindFailed()) {
125                 System.out.println(&quot;Port &quot; + port + &quot; already in use. Trying to restart debuggee with a new one...&quot;);
126                 Thread.sleep(100);
127             } else if (process == null ) {
128                 throw new RuntimeException(&quot;Unable to start debugee&quot;);
129             }
130         }
131 
132         // Connect to the debuggee and handshake with garbage
133         Socket s = new Socket(&quot;localhost&quot;, port);
134         s.getOutputStream().write(&quot;Here&#39;s a poke in the eye&quot;.getBytes(&quot;UTF-8&quot;));
135         s.close();
136 
137         // Re-connect and to a partial handshake - don&#39;t disconnect
138         s = new Socket(&quot;localhost&quot;, port);
139         s.getOutputStream().write(&quot;JDWP-&quot;.getBytes(&quot;UTF-8&quot;));
140 
141 
142         // Attach to server debuggee and resume it so it can exit
143         AttachingConnector conn = (AttachingConnector)findConnector(&quot;com.sun.jdi.SocketAttach&quot;);
144         Map&lt;String, Argument&gt; conn_args = conn.defaultArguments();
145         Connector.IntegerArgument port_arg =
146             (Connector.IntegerArgument)conn_args.get(&quot;port&quot;);
147         port_arg.setValue(port);
148         VirtualMachine vm = conn.attach(conn_args);
149 
150         // The first event is always a VMStartEvent, and it is always in
151         // an EventSet by itself.  Wait for it.
152         EventSet evtSet = vm.eventQueue().remove();
153         for (Event event: evtSet) {
154             if (event instanceof VMStartEvent) {
155                 break;
156             }
157             throw new RuntimeException(&quot;Test failed - debuggee did not start properly&quot;);
158         }
159 
160         vm.eventRequestManager().deleteAllBreakpoints();
161         vm.resume();
162 
163         process.waitFor();
164     }
165 
166     private static class LaunchResult {
167 
168         private final Process p;
169         private final boolean bindFailed;
170 
171         public LaunchResult(Process p, boolean bindFailed) {
172             this.p = p;
173             this.bindFailed = bindFailed;
174         }
175 
176         public Process getProcess() {
177             return p;
178         }
179 
180         public boolean isBindFailed() {
181             return bindFailed;
182         }
183 
184     }
185 
186 }
    </pre>
  </body>
</html>
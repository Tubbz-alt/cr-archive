<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/com/sun/nio/sctp/SctpChannel/SocketOptionTests.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Connect.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../SctpMultiChannel/Branch.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/com/sun/nio/sctp/SctpChannel/SocketOptionTests.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 55        }
 56 
 57     &lt;T&gt; void optionalSupport(SctpChannel sc, SctpSocketOption&lt;T&gt; name,
 58             T value) {
 59         try {
 60             sc.setOption(name, value);
 61             checkOption(sc, name, value);
 62         } catch (IOException e) {
 63             /* Informational only, not all options have native support */
 64             out.println(name + &quot; not supported. &quot; + e);
 65         }
 66     }
 67 
 68     void test(String[] args) {
 69         if (!Util.isSCTPSupported()) {
 70             out.println(&quot;SCTP protocol is not supported&quot;);
 71             out.println(&quot;Test cannot be run&quot;);
 72             return;
 73         }
 74 
<span class="line-modified"> 75         try {</span>
<span class="line-removed"> 76             SctpChannel sc = SctpChannel.open();</span>
 77 
 78             /* check supported options */
 79             Set&lt;SctpSocketOption&lt;?&gt;&gt; options = sc.supportedOptions();
 80             List&lt;? extends SctpSocketOption&lt;?&gt;&gt; expected = Arrays.&lt;SctpSocketOption&lt;?&gt;&gt;asList(
 81                     SCTP_DISABLE_FRAGMENTS, SCTP_EXPLICIT_COMPLETE,
 82                     SCTP_FRAGMENT_INTERLEAVE, SCTP_INIT_MAXSTREAMS,
 83                     SCTP_NODELAY, SCTP_PRIMARY_ADDR, SCTP_SET_PEER_PRIMARY_ADDR,
 84                     SO_SNDBUF, SO_RCVBUF, SO_LINGER);
 85 
 86             for (SctpSocketOption opt: expected) {
 87                 if (!options.contains(opt))
 88                     fail(opt.name() + &quot; should be supported&quot;);
 89             }
 90 
 91             InitMaxStreams streams = InitMaxStreams.create(1024, 1024);
 92             sc.setOption(SCTP_INIT_MAXSTREAMS, streams);
 93             checkOption(sc, SCTP_INIT_MAXSTREAMS, streams);
 94             streams = sc.getOption(SCTP_INIT_MAXSTREAMS);
 95             check(streams.maxInStreams() == 1024, &quot;Max in streams: value: &quot;
 96                     + streams.maxInStreams() + &quot;, expected 1024 &quot;);
</pre>
<hr />
<pre>
126                fail(&quot;NullPointerException not thrown for getOption&quot;);
127             } catch (NullPointerException unused) {
128                pass();
129             }
130 
131             /* ClosedChannelException */
132             sc.close();
133             try {
134                sc.setOption(SCTP_INIT_MAXSTREAMS, streams);
135                fail(&quot;ClosedChannelException not thrown&quot;);
136             } catch (ClosedChannelException unused) {
137                 pass();
138             }
139         } catch (IOException ioe) {
140             unexpected(ioe);
141         }
142     }
143 
144     /* SCTP_PRIMARY_ADDR */
145     void sctpPrimaryAddr() throws IOException {
<span class="line-removed">146         SocketAddress addrToSet = null;;</span>
<span class="line-removed">147 </span>
148         System.out.println(&quot;TESTING SCTP_PRIMARY_ADDR&quot;);
149         SctpChannel sc = SctpChannel.open();
150         SctpServerChannel ssc = SctpServerChannel.open().bind(null);
151         Set&lt;SocketAddress&gt; addrs = ssc.getAllLocalAddresses();
152         if (addrs.isEmpty())
153             debug(&quot;addrs should not be empty&quot;);
154         debug(&quot;Listening on &quot; + addrs);
155 
156         InetSocketAddress serverAddr = (InetSocketAddress) addrs.iterator().next();
157         debug(&quot;connecting to &quot; + serverAddr);
158         sc.connect(serverAddr);
159         SctpChannel peerChannel = ssc.accept();
160         ssc.close();
<span class="line-modified">161         Set&lt;SocketAddress&gt; peerAddrs = peerChannel.getAllLocalAddresses();</span>
<span class="line-modified">162         debug(&quot;Peer local Addresses: &quot;);</span>
<span class="line-modified">163         for (Iterator&lt;SocketAddress&gt; it = peerAddrs.iterator(); it.hasNext(); ) {</span>
164             InetSocketAddress addr = (InetSocketAddress)it.next();
165             debug(&quot;\t&quot; + addr);
<span class="line-removed">166             addrToSet = addr;   // any of the peer addresses will do!</span>
167         }
168 
169         /* retrieval of SCTP_PRIMARY_ADDR is not supported on Solaris */
170         if (&quot;SunOS&quot;.equals(osName)) {
171             /* For now do not set this option. There is a bug on Solaris 10 pre Update 5
172              * where setting this option returns Invalid argument */
173             //debug(&quot;Set SCTP_PRIMARY_ADDR with &quot; + addrToSet);
174             //sc.setOption(SCTP_PRIMARY_ADDR, addrToSet);
175             return;
176         } else { /* Linux */
177             SocketAddress primaryAddr = sc.getOption(SCTP_PRIMARY_ADDR);
178             System.out.println(&quot;SCTP_PRIMARY_ADDR returned: &quot; + primaryAddr);
<span class="line-modified">179             /* Verify that this is one of the peer addresses */</span>
<span class="line-modified">180             boolean found = false;</span>
<span class="line-modified">181             addrToSet = primaryAddr; // may not have more than one addr</span>
<span class="line-modified">182             for (Iterator&lt;SocketAddress&gt; it = peerAddrs.iterator(); it.hasNext(); ) {</span>
<span class="line-modified">183                 InetSocketAddress addr = (InetSocketAddress)it.next();</span>
<span class="line-modified">184                 if (addr.equals(primaryAddr)) {</span>
<span class="line-modified">185                     found = true;</span>
<span class="line-modified">186                 }</span>
<span class="line-modified">187                 addrToSet = addr;</span>


188             }
<span class="line-removed">189             check(found, &quot;SCTP_PRIMARY_ADDR returned bogus address!&quot;);</span>
<span class="line-removed">190 </span>
<span class="line-removed">191             System.out.println(&quot;SCTP_PRIMARY_ADDR try set to: &quot; + addrToSet);</span>
<span class="line-removed">192             sc.setOption(SCTP_PRIMARY_ADDR, addrToSet);</span>
<span class="line-removed">193             System.out.println(&quot;SCTP_PRIMARY_ADDR set to: &quot; + addrToSet);</span>
<span class="line-removed">194             primaryAddr = sc.getOption(SCTP_PRIMARY_ADDR);</span>
<span class="line-removed">195             System.out.println(&quot;SCTP_PRIMARY_ADDR returned: &quot; + primaryAddr);</span>
<span class="line-removed">196             check(addrToSet.equals(primaryAddr),&quot;SCTP_PRIMARY_ADDR not set correctly&quot;);</span>
197         }


198     }
199             //--------------------- Infrastructure ---------------------------
200     boolean debug = true;
201     volatile int passed = 0, failed = 0;
202     void pass() {passed++;}
203     void fail() {failed++; Thread.dumpStack();}
204     void fail(String msg) {System.err.println(msg); fail();}
205     void unexpected(Throwable t) {failed++; t.printStackTrace();}
206     void check(boolean cond) {if (cond) pass(); else fail();}
207     void check(boolean cond, String failMessage) {if (cond) pass(); else fail(failMessage);}
208     void debug(String message) {if(debug) { System.out.println(message); }  }
209     public static void main(String[] args) throws Throwable {
210         Class&lt;?&gt; k = new Object(){}.getClass().getEnclosingClass();
211         try {k.getMethod(&quot;instanceMain&quot;,String[].class)
212                 .invoke( k.newInstance(), (Object) args);}
213         catch (Throwable e) {throw e.getCause();}}
214     public void instanceMain(String[] args) throws Throwable {
215         try {test(args);} catch (Throwable t) {unexpected(t);}
216         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
217         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
</pre>
</td>
<td>
<hr />
<pre>
 55        }
 56 
 57     &lt;T&gt; void optionalSupport(SctpChannel sc, SctpSocketOption&lt;T&gt; name,
 58             T value) {
 59         try {
 60             sc.setOption(name, value);
 61             checkOption(sc, name, value);
 62         } catch (IOException e) {
 63             /* Informational only, not all options have native support */
 64             out.println(name + &quot; not supported. &quot; + e);
 65         }
 66     }
 67 
 68     void test(String[] args) {
 69         if (!Util.isSCTPSupported()) {
 70             out.println(&quot;SCTP protocol is not supported&quot;);
 71             out.println(&quot;Test cannot be run&quot;);
 72             return;
 73         }
 74 
<span class="line-modified"> 75         try (SctpChannel sc = SctpChannel.open()) {</span>

 76 
 77             /* check supported options */
 78             Set&lt;SctpSocketOption&lt;?&gt;&gt; options = sc.supportedOptions();
 79             List&lt;? extends SctpSocketOption&lt;?&gt;&gt; expected = Arrays.&lt;SctpSocketOption&lt;?&gt;&gt;asList(
 80                     SCTP_DISABLE_FRAGMENTS, SCTP_EXPLICIT_COMPLETE,
 81                     SCTP_FRAGMENT_INTERLEAVE, SCTP_INIT_MAXSTREAMS,
 82                     SCTP_NODELAY, SCTP_PRIMARY_ADDR, SCTP_SET_PEER_PRIMARY_ADDR,
 83                     SO_SNDBUF, SO_RCVBUF, SO_LINGER);
 84 
 85             for (SctpSocketOption opt: expected) {
 86                 if (!options.contains(opt))
 87                     fail(opt.name() + &quot; should be supported&quot;);
 88             }
 89 
 90             InitMaxStreams streams = InitMaxStreams.create(1024, 1024);
 91             sc.setOption(SCTP_INIT_MAXSTREAMS, streams);
 92             checkOption(sc, SCTP_INIT_MAXSTREAMS, streams);
 93             streams = sc.getOption(SCTP_INIT_MAXSTREAMS);
 94             check(streams.maxInStreams() == 1024, &quot;Max in streams: value: &quot;
 95                     + streams.maxInStreams() + &quot;, expected 1024 &quot;);
</pre>
<hr />
<pre>
125                fail(&quot;NullPointerException not thrown for getOption&quot;);
126             } catch (NullPointerException unused) {
127                pass();
128             }
129 
130             /* ClosedChannelException */
131             sc.close();
132             try {
133                sc.setOption(SCTP_INIT_MAXSTREAMS, streams);
134                fail(&quot;ClosedChannelException not thrown&quot;);
135             } catch (ClosedChannelException unused) {
136                 pass();
137             }
138         } catch (IOException ioe) {
139             unexpected(ioe);
140         }
141     }
142 
143     /* SCTP_PRIMARY_ADDR */
144     void sctpPrimaryAddr() throws IOException {


145         System.out.println(&quot;TESTING SCTP_PRIMARY_ADDR&quot;);
146         SctpChannel sc = SctpChannel.open();
147         SctpServerChannel ssc = SctpServerChannel.open().bind(null);
148         Set&lt;SocketAddress&gt; addrs = ssc.getAllLocalAddresses();
149         if (addrs.isEmpty())
150             debug(&quot;addrs should not be empty&quot;);
151         debug(&quot;Listening on &quot; + addrs);
152 
153         InetSocketAddress serverAddr = (InetSocketAddress) addrs.iterator().next();
154         debug(&quot;connecting to &quot; + serverAddr);
155         sc.connect(serverAddr);
156         SctpChannel peerChannel = ssc.accept();
157         ssc.close();
<span class="line-modified">158         Set&lt;SocketAddress&gt; remoteAddresses = sc.getRemoteAddresses();</span>
<span class="line-modified">159         debug(&quot;Remote Addresses: &quot;);</span>
<span class="line-modified">160         for (Iterator&lt;SocketAddress&gt; it = remoteAddresses.iterator(); it.hasNext(); ) {</span>
161             InetSocketAddress addr = (InetSocketAddress)it.next();
162             debug(&quot;\t&quot; + addr);

163         }
164 
165         /* retrieval of SCTP_PRIMARY_ADDR is not supported on Solaris */
166         if (&quot;SunOS&quot;.equals(osName)) {
167             /* For now do not set this option. There is a bug on Solaris 10 pre Update 5
168              * where setting this option returns Invalid argument */
169             //debug(&quot;Set SCTP_PRIMARY_ADDR with &quot; + addrToSet);
170             //sc.setOption(SCTP_PRIMARY_ADDR, addrToSet);
171             return;
172         } else { /* Linux */
173             SocketAddress primaryAddr = sc.getOption(SCTP_PRIMARY_ADDR);
174             System.out.println(&quot;SCTP_PRIMARY_ADDR returned: &quot; + primaryAddr);
<span class="line-modified">175             /* Verify that this is one of the remote addresses */</span>
<span class="line-modified">176             check(remoteAddresses.contains(primaryAddr), &quot;SCTP_PRIMARY_ADDR returned bogus address!&quot;);</span>
<span class="line-modified">177 </span>
<span class="line-modified">178             for (Iterator&lt;SocketAddress&gt; it = remoteAddresses.iterator(); it.hasNext(); ) {</span>
<span class="line-modified">179                 InetSocketAddress addrToSet = (InetSocketAddress) it.next();</span>
<span class="line-modified">180                 System.out.println(&quot;SCTP_PRIMARY_ADDR try set to: &quot; + addrToSet);</span>
<span class="line-modified">181                 sc.setOption(SCTP_PRIMARY_ADDR, addrToSet);</span>
<span class="line-modified">182                 System.out.println(&quot;SCTP_PRIMARY_ADDR set to    : &quot; + addrToSet);</span>
<span class="line-modified">183                 primaryAddr = sc.getOption(SCTP_PRIMARY_ADDR);</span>
<span class="line-added">184                 System.out.println(&quot;SCTP_PRIMARY_ADDR returned  : &quot; + primaryAddr);</span>
<span class="line-added">185                 check(addrToSet.equals(primaryAddr), &quot;SCTP_PRIMARY_ADDR not set correctly&quot;);</span>
186             }








187         }
<span class="line-added">188         sc.close();</span>
<span class="line-added">189         peerChannel.close();</span>
190     }
191             //--------------------- Infrastructure ---------------------------
192     boolean debug = true;
193     volatile int passed = 0, failed = 0;
194     void pass() {passed++;}
195     void fail() {failed++; Thread.dumpStack();}
196     void fail(String msg) {System.err.println(msg); fail();}
197     void unexpected(Throwable t) {failed++; t.printStackTrace();}
198     void check(boolean cond) {if (cond) pass(); else fail();}
199     void check(boolean cond, String failMessage) {if (cond) pass(); else fail(failMessage);}
200     void debug(String message) {if(debug) { System.out.println(message); }  }
201     public static void main(String[] args) throws Throwable {
202         Class&lt;?&gt; k = new Object(){}.getClass().getEnclosingClass();
203         try {k.getMethod(&quot;instanceMain&quot;,String[].class)
204                 .invoke( k.newInstance(), (Object) args);}
205         catch (Throwable e) {throw e.getCause();}}
206     public void instanceMain(String[] args) throws Throwable {
207         try {test(args);} catch (Throwable t) {unexpected(t);}
208         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
209         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
</pre>
</td>
</tr>
</table>
<center><a href="Connect.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../SctpMultiChannel/Branch.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
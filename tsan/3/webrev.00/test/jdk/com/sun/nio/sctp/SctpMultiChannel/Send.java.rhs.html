<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/com/sun/nio/sctp/SctpMultiChannel/Send.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 4927640
 26  * @summary Tests the SCTP protocol implementation
 27  * @author chegar
 28  */
 29 
 30 import java.net.InetSocketAddress;
 31 import java.net.SocketAddress;
 32 import java.io.IOException;
 33 import java.util.Set;
 34 import java.util.Iterator;
 35 import java.util.concurrent.CountDownLatch;
 36 import java.util.concurrent.TimeUnit;
 37 import java.nio.ByteBuffer;
 38 import com.sun.nio.sctp.Association;
 39 import com.sun.nio.sctp.InvalidStreamException;
 40 import com.sun.nio.sctp.MessageInfo;
 41 import com.sun.nio.sctp.SctpMultiChannel;
 42 import static java.lang.System.out;
 43 import static java.lang.System.err;
 44 
 45 public class Send {
 46     /* Latches used to synchronize between the client and server so that
 47      * connections without any IO may not be closed without being accepted */
 48     final CountDownLatch clientFinishedLatch = new CountDownLatch(1);
 49     final CountDownLatch serverFinishedLatch = new CountDownLatch(1);
 50 
 51     void test(String[] args) {
 52         SocketAddress address = null;
 53         Server server = null;
 54 
 55         if (!Util.isSCTPSupported()) {
 56             out.println(&quot;SCTP protocol is not supported&quot;);
 57             out.println(&quot;Test cannot be run&quot;);
 58             return;
 59         }
 60 
 61         if (args.length == 2) {
 62             /* requested to connecct to a specific address */
 63             try {
 64                 int port = Integer.valueOf(args[1]);
 65                 address = new InetSocketAddress(args[0], port);
 66             } catch (NumberFormatException nfe) {
 67                 err.println(nfe);
 68             }
 69         } else {
 70             /* start server on local machine, default */
 71             try {
 72                 server = new Server();
 73                 server.start();
 74                 address = server.address();
 75                 debug(&quot;Server started and listening on &quot; + address);
 76             } catch (IOException ioe) {
 77                 ioe.printStackTrace();
 78                 return;
 79             }
 80         }
 81 
 82         doTest(address);
 83     }
 84 
 85     void doTest(SocketAddress peerAddress) {
 86         SctpMultiChannel channel = null;
 87         ByteBuffer buffer = ByteBuffer.allocate(Util.LARGE_BUFFER);
 88         MessageInfo info = MessageInfo.createOutgoing(null, 0);
 89 
 90         try {
 91             channel = SctpMultiChannel.open();
 92 
 93             /* TEST 1: send small message */
 94             int streamNumber = 0;
 95             debug(&quot;sending to &quot; + peerAddress + &quot; on stream number: &quot; + streamNumber);
 96             info = MessageInfo.createOutgoing(peerAddress, streamNumber);
 97             buffer.put(Util.SMALL_MESSAGE.getBytes(&quot;ISO-8859-1&quot;));
 98             buffer.flip();
 99             int position = buffer.position();
100             int remaining = buffer.remaining();
101 
102             debug(&quot;sending small message: &quot; + buffer);
103             int sent = channel.send(buffer, info);
104 
105             check(sent == remaining, &quot;sent should be equal to remaining&quot;);
106             check(buffer.position() == (position + sent),
107                     &quot;buffers position should have been incremented by sent&quot;);
108 
109             /* TEST 2: receive the echoed message */
110             buffer.clear();
111             info = channel.receive(buffer, null, null);
112             buffer.flip();
113             check(info != null, &quot;info is null&quot;);
114             check(info.streamNumber() == streamNumber,
115                     &quot;message not sent on the correct stream&quot;);
116             check(info.bytes() == Util.SMALL_MESSAGE.getBytes(&quot;ISO-8859-1&quot;).
117                   length, &quot;bytes received not equal to message length&quot;);
118             check(info.bytes() == buffer.remaining(), &quot;bytes != remaining&quot;);
119             check(Util.compare(buffer, Util.SMALL_MESSAGE),
120               &quot;received message not the same as sent message&quot;);
121 
122 
123             /* TEST 3: send large message */
124             Set&lt;Association&gt; assocs = channel.associations();
125             check(assocs.size() == 1, &quot;there should be only one association&quot;);
126             Iterator&lt;Association&gt; it = assocs.iterator();
127             check(it.hasNext());
128             Association assoc = it.next();
129             streamNumber = assoc.maxOutboundStreams() - 1;
130 
131             debug(&quot;sending on stream number: &quot; + streamNumber);
132             info = MessageInfo.createOutgoing(assoc, null, streamNumber);
133             buffer.clear();
134             buffer.put(Util.LARGE_MESSAGE.getBytes(&quot;ISO-8859-1&quot;));
135             buffer.flip();
136             position = buffer.position();
137             remaining = buffer.remaining();
138 
139             debug(&quot;sending large message: &quot; + buffer);
140             sent = channel.send(buffer, info);
141 
142             check(sent == remaining, &quot;sent should be equal to remaining&quot;);
143             check(buffer.position() == (position + sent),
144                     &quot;buffers position should have been incremented by sent&quot;);
145 
146             /* TEST 4: receive the echoed message */
147             buffer.clear();
148             info = channel.receive(buffer, null, null);
149             buffer.flip();
150             check(info != null, &quot;info is null&quot;);
151             check(info.streamNumber() == streamNumber,
152                     &quot;message not sent on the correct stream&quot;);
153             check(info.bytes() == Util.LARGE_MESSAGE.getBytes(&quot;ISO-8859-1&quot;).
154                   length, &quot;bytes received not equal to message length&quot;);
155             check(info.bytes() == buffer.remaining(), &quot;bytes != remaining&quot;);
156             check(Util.compare(buffer, Util.LARGE_MESSAGE),
157               &quot;received message not the same as sent message&quot;);
158 
159 
160             /* TEST 5: InvalidStreamExcepton */
161             streamNumber = assoc.maxOutboundStreams() + 1;
162             info = MessageInfo.createOutgoing(assoc, null, streamNumber);
163             buffer.clear();
164             buffer.put(Util.SMALL_MESSAGE.getBytes(&quot;ISO-8859-1&quot;));
165             buffer.flip();
166             position = buffer.position();
167             remaining = buffer.remaining();
168 
169             debug(&quot;sending on stream number: &quot; + streamNumber);
170             debug(&quot;sending small message: &quot; + buffer);
171             try {
172                 sent = channel.send(buffer, info);
173                 fail(&quot;should have thrown InvalidStreamExcepton&quot;);
174             } catch (InvalidStreamException ise){
175                 pass();
176             } catch (IOException ioe) {
177                 unexpected(ioe);
178             }
179             check(buffer.remaining() == remaining,
180                     &quot;remaining should not be changed&quot;);
181             check(buffer.position() == position,
182                     &quot;buffers position should not be changed&quot;);
183 
184 
185             /* TEST 5: getRemoteAddresses(Association) */
186             channel.getRemoteAddresses(assoc);
187 
188             /* TEST 6: Send from heap buffer to force implementation to
189              * substitute with a native buffer, then check that its position
190              * is updated correctly */
191             info = MessageInfo.createOutgoing(assoc, null, 0);
192             buffer.clear();
193             buffer.put(Util.SMALL_MESSAGE.getBytes(&quot;ISO-8859-1&quot;));
194             buffer.flip();
195             final int offset = 1;
196             buffer.position(offset);
197             remaining = buffer.remaining();
198 
199             try {
200                 sent = channel.send(buffer, info);
201 
202                 check(sent == remaining, &quot;sent should be equal to remaining&quot;);
203                 check(buffer.position() == (offset + sent),
204                         &quot;buffers position should have been incremented by sent&quot;);
205             } catch (IllegalArgumentException iae) {
206                 fail(iae + &quot;, Error updating buffers position&quot;);
207             }
208 
209         } catch (IOException ioe) {
210             unexpected(ioe);
211         } finally {
212             clientFinishedLatch.countDown();
213             try { serverFinishedLatch.await(10L, TimeUnit.SECONDS); }
214             catch (InterruptedException ie) { unexpected(ie); }
215             if (channel != null) {
216                 try { channel.close(); }
217                 catch (IOException e) { unexpected (e);}
218             }
219         }
220     }
221 
222     class Server implements Runnable
223     {
224         final InetSocketAddress serverAddr;
225         private SctpMultiChannel serverChannel;
226 
227         public Server() throws IOException {
228             serverChannel = SctpMultiChannel.open().bind(null);
229             java.util.Set&lt;SocketAddress&gt; addrs = serverChannel.getAllLocalAddresses();
230             if (addrs.isEmpty())
231                 debug(&quot;addrs should not be empty&quot;);
232 
233             serverAddr = (InetSocketAddress) addrs.iterator().next();
234         }
235 
236         public void start() {
237             (new Thread(this, &quot;Server-&quot;  + serverAddr.getPort())).start();
238         }
239 
240         public InetSocketAddress address() {
241             return serverAddr;
242         }
243 
244         @Override
245         public void run() {
246             ByteBuffer buffer = ByteBuffer.allocateDirect(Util.LARGE_BUFFER);
247             try {
248                 MessageInfo info;
249 
250                 /* receive a small message */
251                 do {
252                     info = serverChannel.receive(buffer, null, null);
253                     if (info == null) {
254                         fail(&quot;Server: unexpected null from receive&quot;);
255                             return;
256                     }
257                 } while (!info.isComplete());
258 
259                 buffer.flip();
260                 check(info != null, &quot;info is null&quot;);
261                 check(info.streamNumber() == 0,
262                         &quot;message not sent on the correct stream&quot;);
263                 check(info.bytes() == Util.SMALL_MESSAGE.getBytes(&quot;ISO-8859-1&quot;).
264                       length, &quot;bytes received not equal to message length&quot;);
265                 check(info.bytes() == buffer.remaining(), &quot;bytes != remaining&quot;);
266                 check(Util.compare(buffer, Util.SMALL_MESSAGE),
267                   &quot;received message not the same as sent message&quot;);
268 
269                 check(info != null, &quot;info is null&quot;);
270                 Set&lt;Association&gt; assocs = serverChannel.associations();
271                 check(assocs.size() == 1, &quot;there should be only one association&quot;);
272                 Iterator&lt;Association&gt; it = assocs.iterator();
273                 check(it.hasNext());
274                 Association assoc = it.next();
275 
276                 /* echo the message */
277                 debug(&quot;Server: echoing first message&quot;);
278                 buffer.flip();
<a name="1" id="anc1"></a><span class="line-modified">279                 MessageInfo sendInfo = MessageInfo.createOutgoing(assoc, null, info.streamNumber());</span>
<span class="line-added">280                 int bytes = serverChannel.send(buffer, sendInfo);</span>
281                 debug(&quot;Server: sent &quot; + bytes + &quot;bytes&quot;);
282 
283                 /* receive a large message */
284                 buffer.clear();
285                 do {
286                     info = serverChannel.receive(buffer, null, null);
287                     if (info == null) {
288                         fail(&quot;Server: unexpected null from receive&quot;);
289                             return;
290                     }
291                 } while (!info.isComplete());
292 
293                 buffer.flip();
294 
295                 check(info.streamNumber() == assoc.maxInboundStreams() - 1,
296                         &quot;message not sent on the correct stream&quot;);
297                 check(info.bytes() == Util.LARGE_MESSAGE.getBytes(&quot;ISO-8859-1&quot;).
298                       length, &quot;bytes received not equal to message length&quot;);
299                 check(info.bytes() == buffer.remaining(), &quot;bytes != remaining&quot;);
300                 check(Util.compare(buffer, Util.LARGE_MESSAGE),
301                   &quot;received message not the same as sent message&quot;);
302 
303                 /* echo the message */
304                 debug(&quot;Server: echoing second message&quot;);
305                 buffer.flip();
<a name="2" id="anc2"></a><span class="line-modified">306                 sendInfo = MessageInfo.createOutgoing(assoc, null, info.streamNumber());</span>
<span class="line-added">307                 bytes = serverChannel.send(buffer, sendInfo);</span>
308                 debug(&quot;Server: sent &quot; + bytes + &quot;bytes&quot;);
309 
310                 /* TEST 6 */
311                 ByteBuffer expected = ByteBuffer.allocate(Util.SMALL_BUFFER);
312                 expected.put(Util.SMALL_MESSAGE.getBytes(&quot;ISO-8859-1&quot;));
313                 expected.flip();
314                 final int offset = 1;
315                 expected.position(offset);
316                 buffer.clear();
317                 do {
318                     info = serverChannel.receive(buffer, null, null);
319                     if (info == null) {
320                         fail(&quot;Server: unexpected null from receive&quot;);
321                         return;
322                     }
323                 } while (!info.isComplete());
324 
325                 buffer.flip();
326                 check(info != null, &quot;info is null&quot;);
327                 check(info.streamNumber() == 0, &quot;message not sent on the correct stream&quot;);
328                 check(info.bytes() == expected.remaining(),
329                     &quot;bytes received not equal to message length&quot;);
330                 check(info.bytes() == buffer.remaining(), &quot;bytes != remaining&quot;);
331                 check(expected.equals(buffer),
332                     &quot;received message not the same as sent message&quot;);
333 
334                 clientFinishedLatch.await(10L, TimeUnit.SECONDS);
335                 serverFinishedLatch.countDown();
336             } catch (IOException ioe) {
337                 unexpected(ioe);
338             } catch (InterruptedException ie) {
339                 unexpected(ie);
340             } finally {
341                 try { if (serverChannel != null) serverChannel.close(); }
342                 catch (IOException  unused) {}
343             }
344         }
345     }
346 
347         //--------------------- Infrastructure ---------------------------
348     boolean debug = true;
349     volatile int passed = 0, failed = 0;
350     void pass() {passed++;}
351     void fail() {failed++; Thread.dumpStack();}
352     void fail(String msg) {System.err.println(msg); fail();}
353     void unexpected(Throwable t) {failed++; t.printStackTrace();}
354     void check(boolean cond) {if (cond) pass(); else fail();}
355     void check(boolean cond, String failMessage) {if (cond) pass(); else fail(failMessage);}
356     void debug(String message) {if(debug) { System.out.println(message); }  }
357     public static void main(String[] args) throws Throwable {
358         Class&lt;?&gt; k = new Object(){}.getClass().getEnclosingClass();
359         try {k.getMethod(&quot;instanceMain&quot;,String[].class)
360                 .invoke( k.newInstance(), (Object) args);}
361         catch (Throwable e) {throw e.getCause();}}
362     public void instanceMain(String[] args) throws Throwable {
363         try {test(args);} catch (Throwable t) {unexpected(t);}
364         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
365         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
366 
367 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
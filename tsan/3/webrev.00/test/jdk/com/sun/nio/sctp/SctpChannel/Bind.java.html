<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/com/sun/nio/sctp/SctpChannel/Bind.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 4927640
 26  * @summary Tests the SCTP protocol implementation
 27  * @author chegar
 28  */
 29 
 30 import java.net.*;
 31 import java.io.*;
 32 import java.util.List;
 33 import java.util.Set;
 34 import java.util.Iterator;
 35 import java.nio.ByteBuffer;
 36 import java.nio.channels.AlreadyBoundException;
 37 import java.nio.channels.AlreadyConnectedException;
 38 import java.nio.channels.ClosedChannelException;
 39 import java.nio.channels.UnsupportedAddressTypeException;
 40 import com.sun.nio.sctp.AssociationChangeNotification;
 41 import com.sun.nio.sctp.AbstractNotificationHandler;
 42 import com.sun.nio.sctp.HandlerResult;
 43 import com.sun.nio.sctp.IllegalUnbindException;
 44 import com.sun.nio.sctp.MessageInfo;
 45 import com.sun.nio.sctp.PeerAddressChangeNotification;
 46 import com.sun.nio.sctp.SctpChannel;
 47 import com.sun.nio.sctp.SctpServerChannel;
 48 import com.sun.nio.sctp.ShutdownNotification;
 49 import static java.lang.System.out;
 50 
 51 /**
 52  * Tests bind, bindAddress, unbindAddress, getLocalAddress, and
 53  * getAllLocalAddresses.
 54  */
 55 public class Bind {
 56      void test(String[] args) {
 57         if (!Util.isSCTPSupported()) {
 58             out.println(&quot;SCTP protocol is not supported&quot;);
 59             out.println(&quot;Test cannot be run&quot;);
 60             return;
 61         }
 62 
 63         /* Simply bind tests */
 64         testBind();
 65 
 66         /* Test unconnected */
 67         testBindUnbind(false);
 68 
 69         /* Test connected */
 70         /* Adding/Removing addresses from a connected association is optional.
 71          * This test can be run on systems that support dynamic address
 72          * reconfiguration */
 73         //testBindUnbind(true);
 74     }
 75 
 76     void testBind() {
 77         SctpChannel channel = null;
 78         try {
 79             channel = SctpChannel.open();
 80 
 81             /* TEST 1: empty set if channel is not bound */
 82             check(channel.getAllLocalAddresses().isEmpty(),
 83                     &quot;getAllLocalAddresses returned non empty set for unbound channel&quot;);
 84 
 85             /* TEST 2: null to bind the channel to an automatically assigned
 86              *         socket address */
 87             channel.bind(null);
 88 
 89             /* TEST 3: non empty set if the channel is bound */
 90             check(!channel.getAllLocalAddresses().isEmpty(),
 91                     &quot;getAllLocalAddresses returned empty set for bound channel&quot;);
 92             debug(&quot;getAllLocalAddresses on channel bound to the wildcard:\n&quot;
 93                     + channel.getAllLocalAddresses());
 94 
 95             /* TEST 4: AlreadyBoundException if this channel is already bound */
 96             try { channel.bind(null); }
 97             catch (AlreadyBoundException unused) { pass(); }
 98             catch (IOException ioe) { unexpected(ioe); }
 99 
100             /* TEST 5: UnsupportedAddressTypeException */
101             try {
102                 channel.close();  /* open a new unbound channel for test */
103                 channel = SctpChannel.open();
104                 channel.bind(new UnsupportedSocketAddress());
105                 fail(&quot;UnsupportedSocketAddress expected&quot;);
106             } catch (UnsupportedAddressTypeException unused) { pass();
107             } catch (IOException ioe) { unexpected(ioe); }
108 
109             /* TEST 6: AlreadyConnectedException */
110             try {
111                 channel.close();  /* open a new unbound channel for test */
112                 channel = SctpChannel.open();
113                 try (var peer = connectChannel(channel)) {
114                     channel.bind(null);
115                     fail(&quot;AlreadyConnectedException expected&quot;);
116                 }
117             } catch (AlreadyConnectedException unused) { pass();
118             } catch (IOException ioe) { unexpected(ioe); }
119 
120             /* TEST 7: ClosedChannelException - If this channel is closed */
121             try {
122                 channel.close();  /* open a new unbound channel for test */
123                 channel = SctpChannel.open();
124                 channel.close();
125                 channel.bind(null);
126                 fail(&quot;ClosedChannelException expected&quot;);
127             } catch (ClosedChannelException unused) { pass();
128             } catch (IOException ioe) { unexpected(ioe); }
129 
130             /* TEST 8: ClosedChannelException if channel is closed */
131             try {
132                 channel.getAllLocalAddresses();
133                 fail(&quot;should have thrown ClosedChannelException&quot;);
134             } catch (ClosedChannelException cce) {
135                pass();
136             } catch (Exception ioe) {
137                 unexpected(ioe);
138             }
139         } catch (IOException ioe) {
140             unexpected(ioe);
141         } finally {
142             try { channel.close(); }
143             catch (IOException ioe) { unexpected(ioe); }
144         }
145     }
146 
147     void testBindUnbind(boolean connected) {
148         SctpChannel channel = null;
149         SctpChannel peerChannel = null;
150 
151         debug(&quot;testBindUnbind, connected: &quot; + connected);
152         try {
153             channel = SctpChannel.open();
154 
155             List&lt;InetAddress&gt; addresses = Util.getAddresses(true, false);
156             Iterator iterator = addresses.iterator();
157             InetSocketAddress a = new InetSocketAddress((InetAddress)iterator.next(), 0);
158             debug(&quot;channel.bind( &quot; + a + &quot;)&quot;);
159             channel.bind(a);
160             while (iterator.hasNext()) {
161                 InetAddress ia = (InetAddress)iterator.next();
162                 debug(&quot;channel.bindAddress(&quot; + ia + &quot;)&quot;);
163                 channel.bindAddress(ia);
164             }
165             if (debug) {Util.dumpAddresses(channel, out);}
166 
167             if (connected) {
168                 /* Test with connected channel */
169                 peerChannel = connectChannel(channel);
170             }
171 
172             /* TEST 1: bind/unbindAddresses on the system addresses */
173             debug(&quot;bind/unbindAddresses on the system addresses&quot;);
174             List&lt;InetAddress&gt; addrs = Util.getAddresses(true, false);
175             for (InetAddress addr : addrs) {
176                 try {
177                     debug(&quot;unbindAddress: &quot; + addr);
178                     check(boundAddress(channel, addr), &quot;trying to remove address that is not bound&quot;);
179                     channel.unbindAddress(addr);
180                     if (debug) {Util.dumpAddresses(channel, out);}
181                     check(!boundAddress(channel, addr), &quot;address was not removed&quot;);
182 
183                     debug(&quot;bindAddress: &quot; + addr);
184                     channel.bindAddress(addr);
185                     if (debug) {Util.dumpAddresses(channel, out);}
186                     check(boundAddress(channel, addr), &quot;address is not bound&quot;);
187                 } catch (IOException ioe) {
188                     unexpected(ioe);
189                 }
190             }
191 
192             /* TEST 2: bindAddress - already bound address. */
193             InetAddress againAddress = addrs.get(0);
194             try {
195                 debug(&quot;bind already bound address &quot; + againAddress);
196                 channel.bindAddress(againAddress);
197             } catch (AlreadyBoundException unused) {
198                 debug(&quot;Caught AlreadyBoundException - OK&quot;);
199                 pass();
200             } catch (IOException ioe) {
201                 unexpected(ioe);
202             }
203 
204             /* TEST 3: bind non local address */
205             try {
206                 InetAddress nla = InetAddress.getByName(&quot;123.123.123.123&quot;);
207                 debug(&quot;bind non local address &quot; + nla);
208                 channel.bindAddress(nla);
209             } catch (IOException ioe) {
210                 debug(&quot;Informative only &quot; + ioe);
211             }
212 
213             /* TEST 4: unbind address that is not bound */
214             try {
215                 debug(&quot;unbind address that is not bound &quot; + againAddress);
216                 /* remove address first then again */
217                 channel.unbindAddress(againAddress);
218                 channel.unbindAddress(againAddress);
219             } catch (IllegalUnbindException unused) {
220                 debug(&quot;Caught IllegalUnbindException - OK&quot;);
221                 pass();
222             } catch (IOException ioe) {
223                 unexpected(ioe);
224             }
225 
226             /* TEST 5: unbind address that is not bound */
227             try {
228                 InetAddress nla = InetAddress.getByName(&quot;123.123.123.123&quot;);
229                 debug(&quot;unbind address that is not bound &quot; + nla);
230                 channel.unbindAddress(nla);
231 
232             } catch (IllegalUnbindException unused) {
233                 debug(&quot;Caught IllegalUnbindException - OK&quot;);
234                 pass();
235             } catch (IOException ioe) {
236                 unexpected(ioe);
237             }
238 
239             if (connected) {
240                 channel.shutdown();
241 
242                 BindNotificationHandler handler = new BindNotificationHandler();
243                 ByteBuffer buffer = ByteBuffer.allocate(10);
244                 MessageInfo info;
245                 while((info = peerChannel.receive(buffer, null, handler)) != null) {
246                     if (info != null) {
247                         if (info.bytes() == -1) {
248                             debug(&quot;peerChannel Reached EOF&quot;);
249                             break;
250                         }
251                     }
252                 }
253 
254                 while((info = channel.receive(buffer, null, handler)) != null) {
255                     if (info != null) {
256                         if (info.bytes() == -1) {
257                             debug(&quot;channel Reached EOF&quot;);
258                             break;
259                         }
260                     }
261                 }
262             }
263         } catch (IOException ioe) {
264             ioe.printStackTrace();
265         } finally {
266             try { if (channel != null) channel.close(); }
267             catch (IOException ioe) { unexpected(ioe); }
268             try { if (peerChannel != null) peerChannel.close(); }
269             catch (IOException ioe) { unexpected(ioe); }
270          }
271     }
272 
273     boolean boundAddress(SctpChannel channel, InetAddress addr)
274         throws IOException {
275         for (SocketAddress boundAddr : channel.getAllLocalAddresses()) {
276             if (((InetSocketAddress) boundAddr).getAddress().equals(addr))
277                 return true;
278         }
279         return false;
280     }
281 
282     SctpChannel connectChannel(SctpChannel channel)
283         throws IOException {
284         debug(&quot;connecting channel...&quot;);
285         try {
286             SctpServerChannel ssc = SctpServerChannel.open();
287             ssc.bind(null);
288             Set&lt;SocketAddress&gt; addrs = ssc.getAllLocalAddresses();
289             Iterator&lt;SocketAddress&gt; iterator = addrs.iterator();
290             SocketAddress addr = iterator.next();
291             debug(&quot;using &quot; + addr + &quot;...&quot;);
292             channel.connect(addr);
293             SctpChannel peerChannel = ssc.accept();
294             ssc.close();
295             debug(&quot;connected&quot;);
296             return peerChannel;
297         } catch (IOException ioe) {
298             debug(&quot;Cannot connect channel&quot;);
299             unexpected(ioe);
300             throw ioe;
301         }
302     }
303 
304     class BindNotificationHandler extends AbstractNotificationHandler&lt;Object&gt;
305     {
306         @Override
307         public HandlerResult handleNotification(
308                 AssociationChangeNotification acn, Object unused)
309         {
310             debug(&quot;AssociationChangeNotification: &quot; +  acn);
311             return HandlerResult.CONTINUE;
312         }
313 
314         @Override
315         public HandlerResult handleNotification(
316                 PeerAddressChangeNotification pacn, Object unused)
317         {
318             debug(&quot;PeerAddressChangeNotification: &quot; +  pacn);
319             return HandlerResult.CONTINUE;
320         }
321 
322         @Override
323         public HandlerResult handleNotification(
324                 ShutdownNotification sn, Object unused)
325         {
326             debug(&quot;ShutdownNotification: &quot; +  sn);
327             return HandlerResult.CONTINUE;
328         }
329     }
330 
331     class UnsupportedSocketAddress extends SocketAddress { }
332 
333     //--------------------- Infrastructure ---------------------------
334     boolean debug = true;
335     volatile int passed = 0, failed = 0;
336     void pass() {passed++;}
337     void fail() {failed++; Thread.dumpStack();}
338     void fail(String msg) {System.err.println(msg); fail();}
339     void unexpected(Throwable t) {failed++; t.printStackTrace();}
340     void check(boolean cond) {if (cond) pass(); else fail();}
341     void check(boolean cond, String failMessage) {if (cond) pass(); else fail(failMessage);}
342     void debug(String message) {if(debug) { System.out.println(message); }  }
343     public static void main(String[] args) throws Throwable {
344         Class&lt;?&gt; k = new Object(){}.getClass().getEnclosingClass();
345         try {k.getMethod(&quot;instanceMain&quot;,String[].class)
346                 .invoke( k.newInstance(), (Object) args);}
347         catch (Throwable e) {throw e.getCause();}}
348     public void instanceMain(String[] args) throws Throwable {
349         try {test(args);} catch (Throwable t) {unexpected(t);}
350         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
351         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
352 
353 }
    </pre>
  </body>
</html>
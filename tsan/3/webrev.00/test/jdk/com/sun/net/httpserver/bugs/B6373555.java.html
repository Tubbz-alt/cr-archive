<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/com/sun/net/httpserver/bugs/B6373555.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 6373555
 27  * @library /test/lib
 28  * @summary HTTP Server failing to answer client requests
 29  * @run main B6373555
 30  * @run main/othervm -Djava.net.preferIPv6Addresses=true B6373555
 31  */
 32 
 33 import java.net.*;
 34 import java.io.*;
 35 import java.util.*;
 36 import com.sun.net.httpserver.*;
 37 import java.util.concurrent.*;
 38 import jdk.test.lib.net.URIBuilder;
 39 
 40 public class B6373555 {
 41 
 42     private static int s_received = 0;
 43     private static int sent = 0;
 44 
 45     private static int received = 0;
 46     private static int port;
 47 
 48     private static volatile boolean error = false;
 49     static HttpServer httpServer;
 50     static ExecutorService pool, execs;
 51     static int NUM = 1000;
 52 
 53     public static void main(String[] args) throws Exception {
 54         try {
 55             if (args.length &gt; 0) {
 56                 NUM = Integer.parseInt (args[0]);
 57             }
 58             execs = Executors.newFixedThreadPool(5);
 59             httpServer = createHttpServer(execs);
 60             port = httpServer.getAddress().getPort();
 61             pool = Executors.newFixedThreadPool(10);
 62             httpServer.start();
 63             for (int i=0; i &lt; NUM; i++) {
 64                 pool.execute(new Client());
 65                 if (error) {
 66                     throw new Exception (&quot;error in test&quot;);
 67                 }
 68             }
 69             System.out.println(&quot;Main thread waiting&quot;);
 70             pool.shutdown();
 71             long latest = System.currentTimeMillis() + 200 * 1000;
 72             while (System.currentTimeMillis() &lt; latest) {
 73                 if (pool.awaitTermination(2000L, TimeUnit.MILLISECONDS)) {
 74                     System.out.println(&quot;Main thread done!&quot;);
 75                     return;
 76                 }
 77                 if (error) {
 78                     throw new Exception (&quot;error in test&quot;);
 79                 }
 80             }
 81             throw new Exception (&quot;error in test: timed out&quot;);
 82         } finally {
 83             httpServer.stop(0);
 84             pool.shutdownNow();
 85             execs.shutdownNow();
 86         }
 87     }
 88 
 89     public static class Client implements Runnable {
 90 
 91         byte[] getBuf () {
 92             byte[] buf = new byte [5200];
 93             for (int i=0; i&lt; 5200; i++) {
 94                 buf [i] = (byte)i;
 95             }
 96             return buf;
 97         }
 98 
 99         public void run() {
100             try {
101                 Thread.sleep(10);
102                 byte[] buf = getBuf();
103                 URL url = URIBuilder.newBuilder()
104                     .scheme(&quot;http&quot;)
105                     .loopback()
106                     .port(port)
107                     .path(&quot;/test&quot;)
108                     .toURLUnchecked();
109                 System.out.println(&quot;URL: &quot; + url);
110                 HttpURLConnection con = (HttpURLConnection)url.openConnection(Proxy.NO_PROXY);
111                 con.setDoOutput(true);
112                 con.setDoInput(true);
113                 con.setRequestMethod(&quot;POST&quot;);
114                 con.setRequestProperty(
115                     &quot;Content-Type&quot;,
116                     &quot;Multipart/Related; type=\&quot;application/xop+xml\&quot;; boundary=\&quot;----=_Part_0_6251267.1128549570165\&quot;; start-info=\&quot;text/xml\&quot;&quot;);
117                 OutputStream out = con.getOutputStream();
118                 out.write(buf);
119                 out.close();
120                 InputStream in = con.getInputStream();
121                 byte[] newBuf = readFully(in);
122                 in.close();
123                 if (buf.length != newBuf.length) {
124                     System.out.println(&quot;Doesn&#39;t match&quot;);
125                     error = true;
126                 }
127             }
128             catch(Exception e) {
129                 e.printStackTrace();
130                 System.out.print (&quot;.&quot;);
131                 error = true;
132             }
133         }
134     }
135 
136     private static byte[] readFully(InputStream istream) throws IOException {
137         ByteArrayOutputStream bout = new ByteArrayOutputStream();
138         byte[] buf = new byte[1024];
139         int num = 0;
140 
141         if (istream != null) {
142             while ((num = istream.read(buf)) != -1) {
143                 bout.write(buf, 0, num);
144             }
145         }
146         byte[] ret = bout.toByteArray();
147         return ret;
148     }
149 
150 
151     private static HttpServer createHttpServer(ExecutorService execs)
152         throws Exception {
153         InetAddress loopback = InetAddress.getLoopbackAddress();
154         InetSocketAddress inetAddress = new InetSocketAddress(loopback, 0);
155         HttpServer testServer = HttpServer.create(inetAddress, 15);
156         testServer.setExecutor(execs);
157         HttpContext context = testServer.createContext(&quot;/test&quot;);
158         context.setHandler(new HttpHandler() {
159             public void handle(HttpExchange msg) {
160                 try {
161                     String method = msg.getRequestMethod();
162                         if (method.equals(&quot;POST&quot;)) {
163                         InputStream is = msg.getRequestBody();
164                             byte[] buf = readFully(is);
165                             is.close();
166                             writePostReply(msg, buf);
167                     } else {
168                         System.out.println(&quot;****** METHOD not handled ***** &quot;+method);
169                             System.out.println(&quot;Received=&quot;+s_received);
170                     }
171                 }
172                 catch(Exception e) {
173                     e.printStackTrace();
174                 }
175                 finally {
176                     msg.close();
177                 }
178             }
179         }
180         );
181         return testServer;
182     }
183 
184     private static void writePostReply(HttpExchange msg, byte[] buf)
185         throws Exception {
186         msg.getResponseHeaders().add(&quot;Content-Type&quot;, &quot;text/xml&quot;);
187         msg.sendResponseHeaders(200, buf.length);
188         OutputStream out = msg.getResponseBody();
189         out.write(buf);
190         out.close();
191     }
192 
193 }
    </pre>
  </body>
</html>
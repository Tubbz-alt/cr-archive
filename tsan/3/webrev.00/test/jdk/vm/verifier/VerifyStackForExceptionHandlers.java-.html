<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/vm/verifier/VerifyStackForExceptionHandlers.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 /**
 26  * @test
 27  * @bug 6547378
 28  * @summary Verify that methods with max_stack==0 don&#39;t have exception handlers
 29  * @author Keith McGuigan
 30  */
 31 
 32 public class VerifyStackForExceptionHandlers extends ClassLoader {
 33     public static void main(String argv[]) throws Exception {
 34         VerifyStackForExceptionHandlers t =
 35             new VerifyStackForExceptionHandlers();
 36 
 37         try {
 38             t.loadGoodClass();
 39         } catch(VerifyError e) {
 40             throw new Exception(&quot;FAIL: should be no VerifyError for class A&quot;);
 41         }
 42 
 43         try {
 44             t.loadBadClass();
 45             throw new Exception(&quot;FAIL: should be a VerifyError for class B&quot;);
 46         } catch(VerifyError e) {
 47             System.out.println(&quot;PASS&quot;);
 48         }
 49     }
 50 
 51     private void loadGoodClass() {
 52         /* -- code for class A --
 53            public class A {
 54                public static void f() {}
 55            }
 56         */
 57         long[] cls_data = {
 58             0xcafebabe00000031L, 0x000e0a0003000b07L,
 59             0x000c07000d010006L, 0x3c696e69743e0100L,
 60             0x0328295601000443L, 0x6f646501000f4c69L,
 61             0x6e654e756d626572L, 0x5461626c65010001L,
 62             0x6601000a536f7572L, 0x636546696c650100L,
 63             0x06412e6a6176610cL, 0x0004000501000141L,
 64             0x0100106a6176612fL, 0x6c616e672f4f626aL,
 65             0x6563740021000200L, 0x0300000000000200L,
 66             0x0100040005000100L, 0x060000001d000100L,
 67             0x01000000052ab700L, 0x01b1000000010007L,
 68             0x0000000600010000L, 0x0001000900080005L,
 69             0x0001000600000019L, 0x0000000000000001L,
 70             0xb100000001000700L, 0x0000060001000000L,
 71             0x0200010009000000L, 0x02000a0000000000L
 72         };
 73         final int EXTRA = 5;
 74 
 75         byte cf_bytes[] = toByteArray(cls_data);
 76         Class c = defineClass(&quot;A&quot;, cf_bytes, 0, cf_bytes.length - EXTRA);
 77 
 78         try { c.newInstance(); } // to force linking, thus verification
 79         catch(InstantiationException e) {}
 80         catch(IllegalAccessException e) {}
 81     }
 82 
 83     private void loadBadClass() throws VerifyError {
 84         /* -- code for class B --
 85            public class B {
 86                public static void g() {}
 87                public static void f() {
 88                   // bytecode modified to have a max_stack value of 0
 89                   try { g(); }
 90                   catch (NullPointerException e) {}
 91                }
 92         }
 93         */
 94         long[] cls_data = {
 95             0xcafebabe00000031L, 0x00120a000400060aL,
 96             0x000d00030c000f00L, 0x0a0700050100106aL,
 97             0x6176612f6c616e67L, 0x2f4f626a6563740cL,
 98             0x0011000a01000a53L, 0x6f7572636546696cL,
 99             0x6507000901001e6aL, 0x6176612f6c616e67L,
100             0x2f4e756c6c506f69L, 0x6e74657245786365L,
101             0x7074696f6e010003L, 0x282956010006422eL,
102             0x6a61736d01000443L, 0x6f646507000e0100L,
103             0x0142010001670100L, 0x01660100063c696eL,
104             0x69743e0021000d00L, 0x0400000000000300L,
105             0x010011000a000100L, 0x0c00000011000100L,
106             0x01000000052ab700L, 0x01b1000000000009L,
107             0x000f000a0001000cL, 0x0000000d00000000L,
108             0x00000001b1000000L, 0x0000090010000a00L,
109             0x01000c0000001c00L, 0x00000100000008b8L,
110             0x0002a700044bb100L, 0x0100000003000600L,
111             0x0800000001000700L, 0x000002000b000000L // 3 bytes extra
112 
113         };
114         final int EXTRA = 3;
115 
116         byte cf_bytes[] = toByteArray(cls_data);
117         Class c = defineClass(&quot;B&quot;, cf_bytes, 0, cf_bytes.length - EXTRA);
118 
119         try { c.newInstance(); } // to force linking, thus verification
120         catch(InstantiationException e) {}
121         catch(IllegalAccessException e) {}
122     }
123 
124     static private byte[] toByteArray(long arr[]) {
125         // convert long array to byte array
126         java.nio.ByteBuffer bbuf = java.nio.ByteBuffer.allocate(arr.length * 8);
127         bbuf.asLongBuffer().put(java.nio.LongBuffer.wrap(arr));
128         return bbuf.array();
129     }
130     }
    </pre>
  </body>
</html>
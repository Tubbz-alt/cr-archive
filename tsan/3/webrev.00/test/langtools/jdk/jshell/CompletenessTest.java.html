<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/jdk/jshell/CompletenessTest.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8149524 8131024 8165211 8080071 8130454 8167343 8129559 8114842 8182268 8223782 8235474
 27  * @summary Test SourceCodeAnalysis
 28  * @build KullaTesting TestingInputStream
 29  * @run testng CompletenessTest
 30  */
 31 
 32 import java.util.Map;
 33 import java.util.HashMap;
 34 import java.util.function.Consumer;
 35 import javax.lang.model.SourceVersion;
 36 import jdk.jshell.JShell;
 37 
 38 import org.testng.annotations.Test;
 39 import jdk.jshell.SourceCodeAnalysis.Completeness;
 40 
 41 import static jdk.jshell.SourceCodeAnalysis.Completeness.*;
 42 import org.testng.annotations.BeforeMethod;
 43 
 44 @Test
 45 public class CompletenessTest extends KullaTesting {
 46 
 47     // Add complete units that end with semicolon to complete_with_semi (without
 48     // the semicolon).  Both cases will be tested.
 49     static final String[] complete = new String[] {
 50         &quot;{ x= 4; }&quot;,
 51         &quot;int mm(int x) {kll}&quot;,
 52         &quot;if (t) { ddd; }&quot;,
 53         &quot;for (int i = 0; i &lt; lines.length(); ++i) { foo }&quot;,
 54         &quot;while (ct == null) { switch (current.kind) { case EOF: { } } }&quot;,
 55         &quot;if (match.kind == BRACES &amp;&amp; (prevCT.kind == ARROW || prevCT.kind == NEW_MIDDLE)) { new CT(UNMATCHED, current, \&quot;Unmatched \&quot; + unmatched); }&quot;,
 56         &quot;enum TK { EOF(TokenKind.EOF, 0), NEW_MIDDLE(XEXPR1|XTERM); }&quot;,
 57         &quot;List&lt;T&gt; f() { return null; }&quot;,
 58         &quot;List&lt;?&gt; f() { return null; }&quot;,
 59         &quot;List&lt;? extends Object&gt; f() { return null; }&quot;,
 60         &quot;Map&lt;? extends Object, ? super Object&gt; f() { return null; }&quot;,
 61         &quot;class C { int z; }&quot;,
 62         &quot;synchronized (r) { f(); }&quot;,
 63         &quot;try { } catch (Exception ex) { }&quot;,
 64         &quot;try { } catch (Exception ex) { } finally { }&quot;,
 65         &quot;try { } finally { }&quot;,
 66         &quot;try (java.util.zip.ZipFile zf = new java.util.zip.ZipFile(zipFileName)) { }&quot;,
 67         &quot;foo: while (true) { printf(\&quot;Innn\&quot;); break foo; }&quot;,
 68         &quot;class Case&lt;E1 extends Enum&lt;E1&gt;, E2 extends Enum&lt;E2&gt;, E3 extends Enum&lt;E3&gt;&gt; {}&quot;,
 69         &quot;;&quot;,
 70         &quot;enum Tt { FOO, BAR, BAZ,; }&quot;,
 71         &quot;record D(int i) {}&quot;,
 72         &quot;static record D(int i) {}&quot;,
 73     };
 74 
 75     static final String[] expression = new String[] {
 76         &quot;test&quot;,
 77         &quot;x + y&quot;,
 78         &quot;x + y ++&quot;,
 79         &quot;p = 9&quot;,
 80         &quot;match(BRACKETS, TokenKind.LBRACKET)&quot;,
 81         &quot;new C()&quot;,
 82         &quot;new C() { public String toString() { return \&quot;Hi\&quot;; } }&quot;,
 83         &quot;new int[]&quot;,
 84         &quot;new int[] {1, 2,3}&quot;,
 85         &quot;new Foo() {}&quot;,
 86         &quot;i &gt;= 0 &amp;&amp; Character.isWhitespace(s.charAt(i))&quot;,
 87         &quot;int.class&quot;,
 88         &quot;String.class&quot;,
 89         &quot;record.any&quot;,
 90         &quot;record()&quot;,
 91         &quot;record(1)&quot;,
 92         &quot;record.length()&quot;
 93     };
 94 
 95     static final String[] complete_with_semi = new String[] {
 96         &quot;int mm&quot;,
 97         &quot;if (t) ddd&quot;,
 98         &quot;int p = 9&quot;,
 99         &quot;int p&quot;,
100         &quot;Deque&lt;Token&gt; stack = new ArrayDeque&lt;&gt;()&quot;,
101         &quot;final Deque&lt;Token&gt; stack = new ArrayDeque&lt;&gt;()&quot;,
102         &quot;java.util.Scanner input = new java.util.Scanner(System.in)&quot;,
103         &quot;java.util.Scanner input = new java.util.Scanner(System.in) { }&quot;,
104         &quot;int j = -i&quot;,
105         &quot;String[] a = { \&quot;AAA\&quot; }&quot;,
106         &quot;assert true&quot;,
107         &quot;int path[]&quot;,
108         &quot;int path[][]&quot;,
109         &quot;int path[][] = new int[22][]&quot;,
110         &quot;int path[] = new int[22]&quot;,
111         &quot;int path[] = new int[] {1, 2, 3}&quot;,
112         &quot;int[] path&quot;,
113         &quot;int path[] = new int[22]&quot;,
114         &quot;int path[][] = new int[22][]&quot;,
115         &quot;for (Object o : a) System.out.println(\&quot;Yep\&quot;)&quot;,
116         &quot;while (os == null) System.out.println(\&quot;Yep\&quot;)&quot;,
117         &quot;do f(); while (t)&quot;,
118         &quot;if (os == null) System.out.println(\&quot;Yep\&quot;)&quot;,
119         &quot;if (t) if (!t) System.out.println(123)&quot;,
120         &quot;for (int i = 0; i &lt; 10; ++i) if (i &lt; 5) System.out.println(i); else break&quot;,
121         &quot;for (int i = 0; i &lt; 10; ++i) if (i &lt; 5) System.out.println(i); else continue&quot;,
122         &quot;for (int i = 0; i &lt; 10; ++i) if (i &lt; 5) System.out.println(i); else return&quot;,
123         &quot;throw ex&quot;,
124         &quot;C c = new C()&quot;,
125         &quot;java.util.zip.ZipFile zf = new java.util.zip.ZipFile(zipFileName)&quot;,
126         &quot;BufferedReader br = new BufferedReader(new FileReader(path))&quot;,
127         &quot;bar: g()&quot;,
128         &quot;baz: while (true) if (t()) printf(&#39;-&#39;); else break baz&quot;,
129         &quot;java.util.function.IntFunction&lt;int[]&gt; ggg = int[]::new&quot;,
130         &quot;List&lt;? extends Object&gt; l&quot;,
131         &quot;int[] m = {1, 2}&quot;,
132         &quot;int[] m = {1, 2}, n = null&quot;,
133         &quot;int[] m = {1, 2}, n&quot;,
134         &quot;int[] m = {1, 2}, n = {3, 4}&quot;,
135     };
136 
137     static final String[] considered_incomplete = new String[] {
138         &quot;if (t)&quot;,
139         &quot;if (t) { } else&quot;,
140         &quot;if (t) if (!t)&quot;,
141         &quot;if (match.kind == BRACES &amp;&amp; (prevCT.kind == ARROW || prevCT.kind == NEW_MIDDLE))&quot;,
142         &quot;for (int i = 0; i &lt; 10; ++i)&quot;,
143         &quot;while (os == null)&quot;,
144     };
145 
146     static final String[] definitely_incomplete = new String[] {
147         &quot;int mm(&quot;,
148         &quot;int mm(int x&quot;,
149         &quot;int mm(int x)&quot;,
150         &quot;int mm(int x) {&quot;,
151         &quot;int mm(int x) {kll&quot;,
152         &quot;if&quot;,
153         &quot;if (&quot;,
154         &quot;if (t&quot;,
155         &quot;if (t) {&quot;,
156         &quot;if (t) { ddd&quot;,
157         &quot;if (t) { ddd;&quot;,
158         &quot;if (t) if (&quot;,
159         &quot;if (stack.isEmpty()) {&quot;,
160         &quot;if (match.kind == BRACES &amp;&amp; (prevCT.kind == ARROW || prevCT.kind == NEW_MIDDLE)) {&quot;,
161         &quot;if (match.kind == BRACES &amp;&amp; (prevCT.kind == ARROW || prevCT.kind == NEW_MIDDLE)) { new CT(UNMATCHED, current, \&quot;Unmatched \&quot; + unmatched);&quot;,
162         &quot;x +&quot;,
163         &quot;x *&quot;,
164         &quot;3 *&quot;,
165         &quot;int&quot;,
166         &quot;for (int i = 0; i &lt; lines.length(); ++i) {&quot;,
167         &quot;new&quot;,
168         &quot;new C(&quot;,
169         &quot;new int[&quot;,
170         &quot;new int[] {1, 2,3&quot;,
171         &quot;new int[] {&quot;,
172         &quot;while (ct == null) {&quot;,
173         &quot;while (ct == null) { switch (current.kind) {&quot;,
174         &quot;while (ct == null) { switch (current.kind) { case EOF: {&quot;,
175         &quot;while (ct == null) { switch (current.kind) { case EOF: { } }&quot;,
176         &quot;enum TK {&quot;,
177         &quot;enum TK { EOF(TokenKind.EOF, 0),&quot;,
178         &quot;enum TK { EOF(TokenKind.EOF, 0), NEW_MIDDLE(XEXPR1|XTERM)&quot;,
179         &quot;enum TK { EOF(TokenKind.EOF, 0), NEW_MIDDLE(XEXPR1|XTERM); &quot;,
180         &quot;enum Tt { FOO, BAR, BAZ,;&quot;,
181         &quot;class C&quot;,
182         &quot;class C extends D&quot;,
183         &quot;class C implements D&quot;,
184         &quot;class C implements D, E&quot;,
185         &quot;interface I extends D&quot;,
186         &quot;interface I extends D, E&quot;,
187         &quot;enum E&quot;,
188         &quot;enum E implements I1&quot;,
189         &quot;enum E implements I1, I2&quot;,
190         &quot;@interface Anno&quot;,
191         &quot;void f()&quot;,
192         &quot;void f() throws E&quot;,
193         &quot;@A(&quot;,
194         &quot;int n = 4,&quot;,
195         &quot;int n,&quot;,
196         &quot;int[] m = {1, 2},&quot;,
197         &quot;int[] m = {1, 2}, n = {3, 4},&quot;,
198         &quot;Map&lt;String,&quot;,
199         &quot;switch (x) {&quot;,
200         &quot;var v = switch (x) {&quot;,
201         &quot;var v = switch (x) { case &quot;,
202         &quot;var v = switch (x) { case 0:&quot;,
203         &quot;var v = switch (x) { case 0: break 12; &quot;,
204         &quot;record D&quot;,
205         &quot;record D(&quot;,
206         &quot;record D(String&quot;,
207         &quot;record D(String i&quot;,
208         &quot;record D(String i,&quot;,
209         &quot;record D(String i, String&quot;,
210         &quot;record D(String i, String j&quot;,
211         &quot;record D(String i)&quot;,
212         &quot;record D(String i, String j)&quot;,
213         &quot;record D(String i) {&quot;,
214         &quot;record D(String i, String j) {&quot;,
215         &quot;static record D&quot;,
216         &quot;static record D(&quot;,
217         &quot;static record D(String&quot;,
218         &quot;static record D(String i&quot;,
219         &quot;static record D(String i,&quot;,
220         &quot;static record D(String i, String&quot;,
221         &quot;static record D(String i, String j&quot;,
222         &quot;static record D(String i)&quot;,
223         &quot;static record D(String i, String j)&quot;,
224         &quot;static record D(String i) {&quot;,
225         &quot;static record D(String i, String j) {&quot;,
226     };
227 
228     static final String[] unknown = new String[] {
229         &quot;new ;&quot;
230     };
231 
232     static final Map&lt;Completeness, String[]&gt; statusToCases = new HashMap&lt;&gt;();
233     static {
234         statusToCases.put(COMPLETE, complete);
235         statusToCases.put(COMPLETE_WITH_SEMI, complete_with_semi);
236         statusToCases.put(CONSIDERED_INCOMPLETE, considered_incomplete);
237         statusToCases.put(DEFINITELY_INCOMPLETE, definitely_incomplete);
238     }
239 
240     private void assertStatus(String input, Completeness status, String source) {
241         String augSrc;
242         switch (status) {
243             case COMPLETE_WITH_SEMI:
244                 augSrc = source + &quot;;&quot;;
245                 break;
246 
247             case DEFINITELY_INCOMPLETE:
248                 augSrc = null;
249                 break;
250 
251             case CONSIDERED_INCOMPLETE:
252                 augSrc = source + &quot;;&quot;;
253                 break;
254 
255             case EMPTY:
256             case COMPLETE:
257             case UNKNOWN:
258                 augSrc = source;
259                 break;
260 
261             default:
262                 throw new AssertionError();
263         }
264         assertAnalyze(input, status, augSrc);
265     }
266 
267     private void assertStatus(String[] ins, Completeness status) {
268         for (String input : ins) {
269             assertStatus(input, status, input);
270         }
271     }
272 
273     public void test_complete() {
274          assertStatus(complete, COMPLETE);
275     }
276 
277     public void test_expression() {
278         assertStatus(expression, COMPLETE);
279     }
280 
281     public void test_complete_with_semi() {
282         assertStatus(complete_with_semi, COMPLETE_WITH_SEMI);
283     }
284 
285     public void test_considered_incomplete() {
286         assertStatus(considered_incomplete, CONSIDERED_INCOMPLETE);
287     }
288 
289     public void test_definitely_incomplete() {
290         assertStatus(definitely_incomplete, DEFINITELY_INCOMPLETE);
291     }
292 
293     public void test_unknown() {
294         assertStatus(definitely_incomplete, DEFINITELY_INCOMPLETE);
295     }
296 
297     public void testCompleted_complete_with_semi() {
298         for (String in : complete_with_semi) {
299             String input = in + &quot;;&quot;;
300             assertStatus(input, COMPLETE, input);
301         }
302     }
303 
304     public void testCompleted_expression_with_semi() {
305         for (String in : expression) {
306             String input = in + &quot;;&quot;;
307             assertStatus(input, COMPLETE, input);
308         }
309     }
310 
311     public void testCompleted_considered_incomplete() {
312         for (String in : considered_incomplete) {
313             String input = in + &quot;;&quot;;
314             assertStatus(input, COMPLETE, input);
315         }
316     }
317 
318     private void assertSourceByStatus(String first) {
319         for (Map.Entry&lt;Completeness, String[]&gt; e : statusToCases.entrySet()) {
320             for (String in : e.getValue()) {
321                 String input = first + in;
322                 assertAnalyze(input, COMPLETE, first, in, true);
323             }
324         }
325     }
326 
327     public void testCompleteSource_complete() {
328         for (String input : complete) {
329             assertSourceByStatus(input);
330         }
331     }
332 
333     public void testCompleteSource_complete_with_semi() {
334         for (String in : complete_with_semi) {
335             String input = in + &quot;;&quot;;
336             assertSourceByStatus(input);
337         }
338     }
339 
340     public void testCompleteSource_expression() {
341         for (String in : expression) {
342             String input = in + &quot;;&quot;;
343             assertSourceByStatus(input);
344         }
345     }
346 
347     public void testCompleteSource_considered_incomplete() {
348         for (String in : considered_incomplete) {
349             String input = in + &quot;;&quot;;
350             assertSourceByStatus(input);
351         }
352     }
353 
354     public void testTrailingSlash() {
355         assertStatus(&quot;\&quot;abc\\&quot;, UNKNOWN, &quot;\&quot;abc\\&quot;);
356     }
357 
358     public void testOpenComment() {
359         assertStatus(&quot;int xx; /* hello&quot;, DEFINITELY_INCOMPLETE, null);
360         assertStatus(&quot;/**  test&quot;, DEFINITELY_INCOMPLETE, null);
361     }
362 
363     public void testTextBlocks() {
364         assertStatus(&quot;\&quot;\&quot;\&quot;&quot;, DEFINITELY_INCOMPLETE, null);
365         assertStatus(&quot;\&quot;\&quot;\&quot;broken&quot;, DEFINITELY_INCOMPLETE, null);
366         assertStatus(&quot;\&quot;\&quot;\&quot;\ntext&quot;, DEFINITELY_INCOMPLETE, null);
367         assertStatus(&quot;\&quot;\&quot;\&quot;\ntext\&quot;\&quot;&quot;, DEFINITELY_INCOMPLETE, &quot;\&quot;\&quot;\&quot;\ntext\&quot;\&quot;\&quot;&quot;);
368         assertStatus(&quot;\&quot;\&quot;\&quot;\ntext\&quot;\&quot;\&quot;&quot;, COMPLETE, &quot;\&quot;\&quot;\&quot;\ntext\&quot;\&quot;\&quot;&quot;);
369         assertStatus(&quot;\&quot;\&quot;\&quot;\ntext\\\&quot;\&quot;\&quot;\&quot;&quot;, COMPLETE, &quot;\&quot;\&quot;\&quot;\ntext\\\&quot;\&quot;\&quot;\&quot;&quot;);
370         assertStatus(&quot;\&quot;\&quot;\&quot;\ntext\\\&quot;\&quot;\&quot;&quot;, DEFINITELY_INCOMPLETE, null);
371         assertStatus(&quot;\&quot;\&quot;\&quot;\ntext\\\&quot;\&quot;\&quot;\\\&quot;\&quot;\&quot;&quot;, DEFINITELY_INCOMPLETE, null);
372         assertStatus(&quot;\&quot;\&quot;\&quot;\ntext\\\&quot;\&quot;\&quot;\\\&quot;\&quot;\&quot;\&quot;\&quot;\&quot;&quot;, COMPLETE, &quot;\&quot;\&quot;\&quot;\ntext\\\&quot;\&quot;\&quot;\\\&quot;\&quot;\&quot;\&quot;\&quot;\&quot;&quot;);
373     }
374 
375     public void testMiscSource() {
376         assertStatus(&quot;if (t) if &quot;, DEFINITELY_INCOMPLETE, &quot;if (t) if&quot;); //Bug
377         assertStatus(&quot;int m() {} dfd&quot;, COMPLETE, &quot;int m() {}&quot;);
378         assertStatus(&quot;int p = &quot;, DEFINITELY_INCOMPLETE, &quot;int p =&quot;); //Bug
379         assertStatus(&quot;int[] m = {1, 2}, n = new int[0];  int i;&quot;, COMPLETE,
380                      &quot;int[] m = {1, 2}, n = new int[0];&quot;);
381     }
382 
383     @BeforeMethod
384     public void setUp() {
385         setUp(b -&gt; b.compilerOptions(&quot;--enable-preview&quot;, &quot;-source&quot;, String.valueOf(SourceVersion.latest().ordinal())));
386     }
387 
388 }
    </pre>
  </body>
</html>
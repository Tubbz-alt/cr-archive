<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/jdk/jshell/CompletenessTest.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<a name="2" id="anc2"></a><span class="line-modified"> 26  * @bug 8149524 8131024 8165211 8080071 8130454 8167343 8129559 8114842 8182268</span>
 27  * @summary Test SourceCodeAnalysis
 28  * @build KullaTesting TestingInputStream
 29  * @run testng CompletenessTest
 30  */
 31 
 32 import java.util.Map;
 33 import java.util.HashMap;
<a name="3" id="anc3"></a>


 34 
 35 import org.testng.annotations.Test;
 36 import jdk.jshell.SourceCodeAnalysis.Completeness;
 37 
 38 import static jdk.jshell.SourceCodeAnalysis.Completeness.*;
<a name="4" id="anc4"></a>
 39 
 40 @Test
 41 public class CompletenessTest extends KullaTesting {
 42 
 43     // Add complete units that end with semicolon to complete_with_semi (without
 44     // the semicolon).  Both cases will be tested.
 45     static final String[] complete = new String[] {
 46         &quot;{ x= 4; }&quot;,
 47         &quot;int mm(int x) {kll}&quot;,
 48         &quot;if (t) { ddd; }&quot;,
 49         &quot;for (int i = 0; i &lt; lines.length(); ++i) { foo }&quot;,
 50         &quot;while (ct == null) { switch (current.kind) { case EOF: { } } }&quot;,
 51         &quot;if (match.kind == BRACES &amp;&amp; (prevCT.kind == ARROW || prevCT.kind == NEW_MIDDLE)) { new CT(UNMATCHED, current, \&quot;Unmatched \&quot; + unmatched); }&quot;,
 52         &quot;enum TK { EOF(TokenKind.EOF, 0), NEW_MIDDLE(XEXPR1|XTERM); }&quot;,
 53         &quot;List&lt;T&gt; f() { return null; }&quot;,
 54         &quot;List&lt;?&gt; f() { return null; }&quot;,
 55         &quot;List&lt;? extends Object&gt; f() { return null; }&quot;,
 56         &quot;Map&lt;? extends Object, ? super Object&gt; f() { return null; }&quot;,
 57         &quot;class C { int z; }&quot;,
 58         &quot;synchronized (r) { f(); }&quot;,
 59         &quot;try { } catch (Exception ex) { }&quot;,
 60         &quot;try { } catch (Exception ex) { } finally { }&quot;,
 61         &quot;try { } finally { }&quot;,
 62         &quot;try (java.util.zip.ZipFile zf = new java.util.zip.ZipFile(zipFileName)) { }&quot;,
 63         &quot;foo: while (true) { printf(\&quot;Innn\&quot;); break foo; }&quot;,
 64         &quot;class Case&lt;E1 extends Enum&lt;E1&gt;, E2 extends Enum&lt;E2&gt;, E3 extends Enum&lt;E3&gt;&gt; {}&quot;,
 65         &quot;;&quot;,
<a name="5" id="anc5"></a><span class="line-modified"> 66         &quot;enum Tt { FOO, BAR, BAZ,; }&quot;</span>


 67     };
 68 
 69     static final String[] expression = new String[] {
 70         &quot;test&quot;,
 71         &quot;x + y&quot;,
 72         &quot;x + y ++&quot;,
 73         &quot;p = 9&quot;,
 74         &quot;match(BRACKETS, TokenKind.LBRACKET)&quot;,
 75         &quot;new C()&quot;,
 76         &quot;new C() { public String toString() { return \&quot;Hi\&quot;; } }&quot;,
 77         &quot;new int[]&quot;,
 78         &quot;new int[] {1, 2,3}&quot;,
 79         &quot;new Foo() {}&quot;,
 80         &quot;i &gt;= 0 &amp;&amp; Character.isWhitespace(s.charAt(i))&quot;,
 81         &quot;int.class&quot;,
 82         &quot;String.class&quot;,
<a name="6" id="anc6"></a>



 83     };
 84 
 85     static final String[] complete_with_semi = new String[] {
 86         &quot;int mm&quot;,
 87         &quot;if (t) ddd&quot;,
 88         &quot;int p = 9&quot;,
 89         &quot;int p&quot;,
 90         &quot;Deque&lt;Token&gt; stack = new ArrayDeque&lt;&gt;()&quot;,
 91         &quot;final Deque&lt;Token&gt; stack = new ArrayDeque&lt;&gt;()&quot;,
 92         &quot;java.util.Scanner input = new java.util.Scanner(System.in)&quot;,
 93         &quot;java.util.Scanner input = new java.util.Scanner(System.in) { }&quot;,
 94         &quot;int j = -i&quot;,
 95         &quot;String[] a = { \&quot;AAA\&quot; }&quot;,
 96         &quot;assert true&quot;,
 97         &quot;int path[]&quot;,
 98         &quot;int path[][]&quot;,
 99         &quot;int path[][] = new int[22][]&quot;,
100         &quot;int path[] = new int[22]&quot;,
101         &quot;int path[] = new int[] {1, 2, 3}&quot;,
102         &quot;int[] path&quot;,
103         &quot;int path[] = new int[22]&quot;,
104         &quot;int path[][] = new int[22][]&quot;,
105         &quot;for (Object o : a) System.out.println(\&quot;Yep\&quot;)&quot;,
106         &quot;while (os == null) System.out.println(\&quot;Yep\&quot;)&quot;,
107         &quot;do f(); while (t)&quot;,
108         &quot;if (os == null) System.out.println(\&quot;Yep\&quot;)&quot;,
109         &quot;if (t) if (!t) System.out.println(123)&quot;,
110         &quot;for (int i = 0; i &lt; 10; ++i) if (i &lt; 5) System.out.println(i); else break&quot;,
111         &quot;for (int i = 0; i &lt; 10; ++i) if (i &lt; 5) System.out.println(i); else continue&quot;,
112         &quot;for (int i = 0; i &lt; 10; ++i) if (i &lt; 5) System.out.println(i); else return&quot;,
113         &quot;throw ex&quot;,
114         &quot;C c = new C()&quot;,
115         &quot;java.util.zip.ZipFile zf = new java.util.zip.ZipFile(zipFileName)&quot;,
116         &quot;BufferedReader br = new BufferedReader(new FileReader(path))&quot;,
117         &quot;bar: g()&quot;,
118         &quot;baz: while (true) if (t()) printf(&#39;-&#39;); else break baz&quot;,
119         &quot;java.util.function.IntFunction&lt;int[]&gt; ggg = int[]::new&quot;,
120         &quot;List&lt;? extends Object&gt; l&quot;,
121         &quot;int[] m = {1, 2}&quot;,
122         &quot;int[] m = {1, 2}, n = null&quot;,
123         &quot;int[] m = {1, 2}, n&quot;,
124         &quot;int[] m = {1, 2}, n = {3, 4}&quot;,
125     };
126 
127     static final String[] considered_incomplete = new String[] {
128         &quot;if (t)&quot;,
129         &quot;if (t) { } else&quot;,
130         &quot;if (t) if (!t)&quot;,
131         &quot;if (match.kind == BRACES &amp;&amp; (prevCT.kind == ARROW || prevCT.kind == NEW_MIDDLE))&quot;,
132         &quot;for (int i = 0; i &lt; 10; ++i)&quot;,
133         &quot;while (os == null)&quot;,
134     };
135 
136     static final String[] definitely_incomplete = new String[] {
137         &quot;int mm(&quot;,
138         &quot;int mm(int x&quot;,
139         &quot;int mm(int x)&quot;,
140         &quot;int mm(int x) {&quot;,
141         &quot;int mm(int x) {kll&quot;,
142         &quot;if&quot;,
143         &quot;if (&quot;,
144         &quot;if (t&quot;,
145         &quot;if (t) {&quot;,
146         &quot;if (t) { ddd&quot;,
147         &quot;if (t) { ddd;&quot;,
148         &quot;if (t) if (&quot;,
149         &quot;if (stack.isEmpty()) {&quot;,
150         &quot;if (match.kind == BRACES &amp;&amp; (prevCT.kind == ARROW || prevCT.kind == NEW_MIDDLE)) {&quot;,
151         &quot;if (match.kind == BRACES &amp;&amp; (prevCT.kind == ARROW || prevCT.kind == NEW_MIDDLE)) { new CT(UNMATCHED, current, \&quot;Unmatched \&quot; + unmatched);&quot;,
152         &quot;x +&quot;,
153         &quot;x *&quot;,
154         &quot;3 *&quot;,
155         &quot;int&quot;,
156         &quot;for (int i = 0; i &lt; lines.length(); ++i) {&quot;,
157         &quot;new&quot;,
158         &quot;new C(&quot;,
159         &quot;new int[&quot;,
160         &quot;new int[] {1, 2,3&quot;,
161         &quot;new int[] {&quot;,
162         &quot;while (ct == null) {&quot;,
163         &quot;while (ct == null) { switch (current.kind) {&quot;,
164         &quot;while (ct == null) { switch (current.kind) { case EOF: {&quot;,
165         &quot;while (ct == null) { switch (current.kind) { case EOF: { } }&quot;,
166         &quot;enum TK {&quot;,
167         &quot;enum TK { EOF(TokenKind.EOF, 0),&quot;,
168         &quot;enum TK { EOF(TokenKind.EOF, 0), NEW_MIDDLE(XEXPR1|XTERM)&quot;,
169         &quot;enum TK { EOF(TokenKind.EOF, 0), NEW_MIDDLE(XEXPR1|XTERM); &quot;,
170         &quot;enum Tt { FOO, BAR, BAZ,;&quot;,
171         &quot;class C&quot;,
172         &quot;class C extends D&quot;,
173         &quot;class C implements D&quot;,
174         &quot;class C implements D, E&quot;,
175         &quot;interface I extends D&quot;,
176         &quot;interface I extends D, E&quot;,
177         &quot;enum E&quot;,
178         &quot;enum E implements I1&quot;,
179         &quot;enum E implements I1, I2&quot;,
180         &quot;@interface Anno&quot;,
181         &quot;void f()&quot;,
182         &quot;void f() throws E&quot;,
183         &quot;@A(&quot;,
184         &quot;int n = 4,&quot;,
185         &quot;int n,&quot;,
186         &quot;int[] m = {1, 2},&quot;,
187         &quot;int[] m = {1, 2}, n = {3, 4},&quot;,
188         &quot;Map&lt;String,&quot;,
189         &quot;switch (x) {&quot;,
190         &quot;var v = switch (x) {&quot;,
191         &quot;var v = switch (x) { case &quot;,
192         &quot;var v = switch (x) { case 0:&quot;,
193         &quot;var v = switch (x) { case 0: break 12; &quot;,
<a name="7" id="anc7"></a>





















194     };
195 
196     static final String[] unknown = new String[] {
197         &quot;new ;&quot;
198     };
199 
200     static final Map&lt;Completeness, String[]&gt; statusToCases = new HashMap&lt;&gt;();
201     static {
202         statusToCases.put(COMPLETE, complete);
203         statusToCases.put(COMPLETE_WITH_SEMI, complete_with_semi);
204         statusToCases.put(CONSIDERED_INCOMPLETE, considered_incomplete);
205         statusToCases.put(DEFINITELY_INCOMPLETE, definitely_incomplete);
206     }
207 
208     private void assertStatus(String input, Completeness status, String source) {
209         String augSrc;
210         switch (status) {
211             case COMPLETE_WITH_SEMI:
212                 augSrc = source + &quot;;&quot;;
213                 break;
214 
215             case DEFINITELY_INCOMPLETE:
216                 augSrc = null;
217                 break;
218 
219             case CONSIDERED_INCOMPLETE:
220                 augSrc = source + &quot;;&quot;;
221                 break;
222 
223             case EMPTY:
224             case COMPLETE:
225             case UNKNOWN:
226                 augSrc = source;
227                 break;
228 
229             default:
230                 throw new AssertionError();
231         }
232         assertAnalyze(input, status, augSrc);
233     }
234 
235     private void assertStatus(String[] ins, Completeness status) {
236         for (String input : ins) {
237             assertStatus(input, status, input);
238         }
239     }
240 
241     public void test_complete() {
<a name="8" id="anc8"></a><span class="line-modified">242         assertStatus(complete, COMPLETE);</span>
243     }
244 
245     public void test_expression() {
246         assertStatus(expression, COMPLETE);
247     }
248 
249     public void test_complete_with_semi() {
250         assertStatus(complete_with_semi, COMPLETE_WITH_SEMI);
251     }
252 
253     public void test_considered_incomplete() {
254         assertStatus(considered_incomplete, CONSIDERED_INCOMPLETE);
255     }
256 
257     public void test_definitely_incomplete() {
258         assertStatus(definitely_incomplete, DEFINITELY_INCOMPLETE);
259     }
260 
261     public void test_unknown() {
262         assertStatus(definitely_incomplete, DEFINITELY_INCOMPLETE);
263     }
264 
265     public void testCompleted_complete_with_semi() {
266         for (String in : complete_with_semi) {
267             String input = in + &quot;;&quot;;
268             assertStatus(input, COMPLETE, input);
269         }
270     }
271 
272     public void testCompleted_expression_with_semi() {
273         for (String in : expression) {
274             String input = in + &quot;;&quot;;
275             assertStatus(input, COMPLETE, input);
276         }
277     }
278 
279     public void testCompleted_considered_incomplete() {
280         for (String in : considered_incomplete) {
281             String input = in + &quot;;&quot;;
282             assertStatus(input, COMPLETE, input);
283         }
284     }
285 
286     private void assertSourceByStatus(String first) {
287         for (Map.Entry&lt;Completeness, String[]&gt; e : statusToCases.entrySet()) {
288             for (String in : e.getValue()) {
289                 String input = first + in;
290                 assertAnalyze(input, COMPLETE, first, in, true);
291             }
292         }
293     }
294 
295     public void testCompleteSource_complete() {
296         for (String input : complete) {
297             assertSourceByStatus(input);
298         }
299     }
300 
301     public void testCompleteSource_complete_with_semi() {
302         for (String in : complete_with_semi) {
303             String input = in + &quot;;&quot;;
304             assertSourceByStatus(input);
305         }
306     }
307 
308     public void testCompleteSource_expression() {
309         for (String in : expression) {
310             String input = in + &quot;;&quot;;
311             assertSourceByStatus(input);
312         }
313     }
314 
315     public void testCompleteSource_considered_incomplete() {
316         for (String in : considered_incomplete) {
317             String input = in + &quot;;&quot;;
318             assertSourceByStatus(input);
319         }
320     }
321 
322     public void testTrailingSlash() {
323         assertStatus(&quot;\&quot;abc\\&quot;, UNKNOWN, &quot;\&quot;abc\\&quot;);
324     }
325 
326     public void testOpenComment() {
327         assertStatus(&quot;int xx; /* hello&quot;, DEFINITELY_INCOMPLETE, null);
328         assertStatus(&quot;/**  test&quot;, DEFINITELY_INCOMPLETE, null);
329     }
330 
<a name="9" id="anc9"></a>











331     public void testMiscSource() {
332         assertStatus(&quot;if (t) if &quot;, DEFINITELY_INCOMPLETE, &quot;if (t) if&quot;); //Bug
333         assertStatus(&quot;int m() {} dfd&quot;, COMPLETE, &quot;int m() {}&quot;);
334         assertStatus(&quot;int p = &quot;, DEFINITELY_INCOMPLETE, &quot;int p =&quot;); //Bug
335         assertStatus(&quot;int[] m = {1, 2}, n = new int[0];  int i;&quot;, COMPLETE,
336                      &quot;int[] m = {1, 2}, n = new int[0];&quot;);
337     }
<a name="10" id="anc10"></a>





338 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/jdk/jshell/ExceptionsTest.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Tests for exceptions
 27  * @bug 8198801
 28  * @build KullaTesting TestingInputStream
 29  * @run testng ExceptionsTest
 30  */
 31 
 32 import java.io.IOException;
 33 import java.io.PrintWriter;
 34 import java.io.StringWriter;
 35 import jdk.jshell.EvalException;
 36 import jdk.jshell.JShellException;
 37 import jdk.jshell.Snippet;
 38 import jdk.jshell.SnippetEvent;
 39 import jdk.jshell.UnresolvedReferenceException;
 40 
 41 import org.testng.annotations.Test;
 42 
 43 import static org.testng.Assert.*;
 44 
 45 @Test
 46 public class ExceptionsTest extends KullaTesting {
 47 
 48     public void throwUncheckedException() {
 49         String message = &quot;error_message&quot;;
 50         SnippetEvent cr = assertEvalException(&quot;throw new RuntimeException(\&quot;&quot; + message + &quot;\&quot;);&quot;);
 51         assertExceptionMatch(cr,
 52                 new ExceptionInfo(RuntimeException.class, message,
 53                         newStackTraceElement(&quot;&quot;, &quot;&quot;, cr.snippet(), 1)));
 54     }
 55 
 56     public void throwCheckedException() {
 57         String message = &quot;error_message&quot;;
 58         SnippetEvent cr = assertEvalException(&quot;throw new Exception(\&quot;&quot; + message + &quot;\&quot;);&quot;);
 59         assertExceptionMatch(cr,
 60                 new ExceptionInfo(Exception.class, message,
 61                         newStackTraceElement(&quot;&quot;, &quot;&quot;, cr.snippet(), 1)));
 62     }
 63 
 64     public void throwFromStaticMethodOfClass() {
 65         String message = &quot;error_message&quot;;
 66         Snippet s1 = methodKey(assertEval(&quot;void f() { throw new RuntimeException(\&quot;&quot; + message + &quot;\&quot;); }&quot;));
 67         Snippet s2 = classKey(assertEval(&quot;class A { static void g() { f(); } }&quot;));
 68         SnippetEvent cr3 = assertEvalException(&quot;A.g();&quot;);
 69         assertExceptionMatch(cr3,
 70                 new ExceptionInfo(RuntimeException.class, message,
 71                         newStackTraceElement(&quot;&quot;, &quot;f&quot;, s1, 1),
 72                         newStackTraceElement(&quot;A&quot;, &quot;g&quot;, s2, 1),
 73                         newStackTraceElement(&quot;&quot;, &quot;&quot;, cr3.snippet(), 1)));
 74     }
 75 
 76     public void throwFromStaticMethodOfInterface() {
 77         String message = &quot;error_message&quot;;
 78         Snippet s1 = methodKey(assertEval(&quot;void f() { throw new RuntimeException(\&quot;&quot; + message + &quot;\&quot;); }&quot;));
 79         Snippet s2 = classKey(assertEval(&quot;interface A { static void g() { f(); } }&quot;));
 80         SnippetEvent cr3 = assertEvalException(&quot;A.g();&quot;);
 81         assertExceptionMatch(cr3,
 82                 new ExceptionInfo(RuntimeException.class, message,
 83                         newStackTraceElement(&quot;&quot;, &quot;f&quot;, s1, 1),
 84                         newStackTraceElement(&quot;A&quot;, &quot;g&quot;, s2, 1),
 85                         newStackTraceElement(&quot;&quot;, &quot;&quot;, cr3.snippet(), 1)));
 86     }
 87 
 88     public void throwChained() {
 89         String message1 = &quot;error_message1&quot;;
 90         String message2 = &quot;error_message2&quot;;
 91         Snippet s1 = methodKey(assertEval(&quot;void p() throws Exception { ((String) null).toString(); }&quot;));
 92         Snippet s2 = methodKey(assertEval(&quot;void n() throws Exception { try { p(); } catch (Exception ex) { throw new java.io.IOException(\&quot;&quot; + message2 + &quot;\&quot;, ex); }}&quot;));
 93         Snippet s3 = methodKey(assertEval(&quot;void m() {\n&quot;
 94                 + &quot;try { n(); }\n&quot;
 95                 + &quot;catch (Exception ex) {\n&quot;
 96                 + &quot;    throw new RuntimeException(\&quot;&quot; + message1 + &quot;\&quot;, ex);\n&quot;
 97                 + &quot;}}&quot;));
 98         SnippetEvent cr4 = assertEvalException(&quot;m();&quot;);
 99         assertExceptionMatch(cr4,
100                 new ExceptionInfo(RuntimeException.class, message1,
101                         new ExceptionInfo(IOException.class, message2,
102                                 new ExceptionInfo(NullPointerException.class, null,
103                                         newStackTraceElement(&quot;&quot;, &quot;p&quot;, s1, 1),
104                                         newStackTraceElement(&quot;&quot;, &quot;n&quot;, s2, 1),
105                                         newStackTraceElement(&quot;&quot;, &quot;m&quot;, s3, 2),
106                                         newStackTraceElement(&quot;&quot;, &quot;&quot;, cr4.snippet(), 1)),
107                                 newStackTraceElement(&quot;&quot;, &quot;n&quot;, s2, 1),
108                                 newStackTraceElement(&quot;&quot;, &quot;m&quot;, s3, 2),
109                                 newStackTraceElement(&quot;&quot;, &quot;&quot;, cr4.snippet(), 1)),
110                         newStackTraceElement(&quot;&quot;, &quot;m&quot;, s3, 4),
111                         newStackTraceElement(&quot;&quot;, &quot;&quot;, cr4.snippet(), 1)));
112     }
113 
114     public void throwChainedUnresolved() {
115         String message1 = &quot;error_message1&quot;;
116         String message2 = &quot;error_message2&quot;;
117         Snippet s1 = methodKey(assertEval(&quot;void p() throws Exception { ((String) null).toString(); }&quot;));
118         Snippet s2 = methodKey(assertEval(&quot;void n() throws Exception { try { p(); } catch (Exception ex) { throw new java.io.IOException(\&quot;&quot; + message2 + &quot;\&quot;, ex); }}&quot;));
119         Snippet s3 = methodKey(assertEval(&quot;void m() {\n&quot;
120                 + &quot;try { n(); }\n&quot;
121                 + &quot;catch (Exception ex) {\n&quot;
122                 + &quot;    throw new RuntimeException(\&quot;&quot; + message1 + &quot;\&quot;, ex);\n&quot;
123                 + &quot;}}&quot;));
124         getState().drop(s1);
125         SnippetEvent cr4 = assertEvalException(&quot;m();&quot;);
126         assertExceptionMatch(cr4,
127                 new ExceptionInfo(RuntimeException.class, message1,
128                         new UnresolvedExceptionInfo(s2,
129                                 newStackTraceElement(&quot;&quot;, &quot;n&quot;, s2, 1),
130                                 newStackTraceElement(&quot;&quot;, &quot;m&quot;, s3, 2),
131                                 newStackTraceElement(&quot;&quot;, &quot;&quot;, cr4.snippet(), 1)),
132                         newStackTraceElement(&quot;&quot;, &quot;m&quot;, s3, 4),
133                         newStackTraceElement(&quot;&quot;, &quot;&quot;, cr4.snippet(), 1)));
134     }
135 
136     public void throwFromConstructor() {
137         String message = &quot;error_message&quot;;
138         Snippet s1 = methodKey(assertEval(&quot;void f() { throw new RuntimeException(\&quot;&quot; + message + &quot;\&quot;); }&quot;));
139         Snippet s2 = classKey(assertEval(&quot;class A { A() { f(); } }&quot;));
140         SnippetEvent cr3 = assertEvalException(&quot;new A();&quot;);
141         assertExceptionMatch(cr3,
142                 new ExceptionInfo(RuntimeException.class, message,
143                         newStackTraceElement(&quot;&quot;, &quot;f&quot;, s1, 1),
144                         newStackTraceElement(&quot;A&quot;, &quot;&lt;init&gt;&quot;, s2, 1),
145                         newStackTraceElement(&quot;&quot;, &quot;&quot;, cr3.snippet(), 1)));
146     }
147 
148     public void throwFromDefaultMethodOfInterface() {
149         String message = &quot;error_message&quot;;
150         Snippet s1 = methodKey(assertEval(&quot;void f() { throw new RuntimeException(\&quot;&quot; + message + &quot;\&quot;); }&quot;));
151         Snippet s2 = classKey(assertEval(&quot;interface A { default void g() { f(); } }&quot;));
152         SnippetEvent cr3 = assertEvalException(&quot;new A() { }.g();&quot;);
153         assertExceptionMatch(cr3,
154                 new ExceptionInfo(RuntimeException.class, message,
155                         newStackTraceElement(&quot;&quot;, &quot;f&quot;, s1, 1),
156                         newStackTraceElement(&quot;A&quot;, &quot;g&quot;, s2, 1),
157                         newStackTraceElement(&quot;&quot;, &quot;&quot;, cr3.snippet(), 1)));
158     }
159 
160     public void throwFromLambda() {
161         String message = &quot;lambda&quot;;
162         Snippet s1 = varKey(assertEval(
163                 &quot;Runnable run = () -&gt; {\n&quot; +
164                 &quot;   throw new RuntimeException(\&quot;&quot; + message + &quot;\&quot;);\n&quot; +
165                 &quot;};&quot;
166         ));
167         SnippetEvent cr2 = assertEvalException(&quot;run.run();&quot;);
168         assertExceptionMatch(cr2,
169                 new ExceptionInfo(RuntimeException.class, message,
170                         newStackTraceElement(&quot;&quot;, &quot;lambda$&quot;, s1, 2),
171                         newStackTraceElement(&quot;&quot;, &quot;&quot;, cr2.snippet(), 1)));
172     }
173 
174     public void throwFromAnonymousClass() {
175         String message = &quot;anonymous&quot;;
176         Snippet s1 = varKey(assertEval(
177                 &quot;Runnable run = new Runnable() {\n&quot; +
178                 &quot;   public void run() {\n&quot;+
179                 &quot;       throw new RuntimeException(\&quot;&quot; + message + &quot;\&quot;);\n&quot; +
180                 &quot;   }\n&quot; +
181                 &quot;};&quot;
182         ));
183         SnippetEvent cr2 = assertEvalException(&quot;run.run();&quot;);
184         assertExceptionMatch(cr2,
185                 new ExceptionInfo(RuntimeException.class, message,
186                         newStackTraceElement(&quot;1&quot;, &quot;run&quot;, s1, 3),
187                         newStackTraceElement(&quot;&quot;, &quot;&quot;, cr2.snippet(), 1)));
188     }
189 
190     public void throwFromLocalClass() {
191         String message = &quot;local&quot;;
192         Snippet s1 = methodKey(assertEval(
193                 &quot;void f() {\n&quot; +
194                 &quot;   class A {\n&quot; +
195                 &quot;       void f() {\n&quot;+
196                 &quot;           throw new RuntimeException(\&quot;&quot; + message + &quot;\&quot;);\n&quot; +
197                 &quot;       }\n&quot; +
198                 &quot;   }\n&quot; +
199                 &quot;   new A().f();\n&quot; +
200                 &quot;}&quot;
201         ));
202         SnippetEvent cr2 = assertEvalException(&quot;f();&quot;);
203         assertExceptionMatch(cr2,
204                 new ExceptionInfo(RuntimeException.class, message,
205                         newStackTraceElement(&quot;1A&quot;, &quot;f&quot;, s1, 4),
206                         newStackTraceElement(&quot;&quot;, &quot;f&quot;, s1, 7),
207                         newStackTraceElement(&quot;&quot;, &quot;&quot;, cr2.snippet(), 1)));
208     }
209 
210     @Test(enabled = false) // TODO 8129427
211     public void outOfMemory() {
212         assertEval(&quot;import java.util.*;&quot;);
213         assertEval(&quot;List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();&quot;);
214         assertExecuteException(&quot;while (true) { list.add(new byte[10000]); }&quot;, OutOfMemoryError.class);
215     }
216 
217     public void stackOverflow() {
218         assertEval(&quot;void f() { f(); }&quot;);
219         assertExecuteException(&quot;f();&quot;, StackOverflowError.class);
220     }
221 
222     private StackTraceElement newStackTraceElement(String className, String methodName, Snippet key, int lineNumber) {
223         return new StackTraceElement(className, methodName, &quot;#&quot; + key.id(), lineNumber);
224     }
225 
226     private static class AnyExceptionInfo {
227 
228         public final StackTraceElement[] stackTraceElements;
229 
230         public AnyExceptionInfo(StackTraceElement... stackTraceElements) {
231             this.stackTraceElements = stackTraceElements.length == 0 ? null : stackTraceElements;
232         }
233     }
234 
235     private static class UnresolvedExceptionInfo extends AnyExceptionInfo {
236 
237         public final Snippet sn;
238 
239         public UnresolvedExceptionInfo(Snippet sn, StackTraceElement... stackTraceElements) {
240             super(stackTraceElements);
241             this.sn = sn;
242         }
243     }
244 
245     private static class ExceptionInfo extends AnyExceptionInfo {
246 
247         public final Class&lt;? extends Throwable&gt; exception;
248         public final String message;
249         public final AnyExceptionInfo cause;
250 
251         public ExceptionInfo(Class&lt;? extends Throwable&gt; exception, String message,
252                 StackTraceElement... stackTraceElements) {
253             this(exception, message, null, stackTraceElements);
254         }
255 
256         public ExceptionInfo(Class&lt;? extends Throwable&gt; exception, String message,
257                 AnyExceptionInfo cause, StackTraceElement... stackTraceElements) {
258             super(stackTraceElements);
259             this.exception = exception;
260             this.message = message;
261             this.cause = cause;
262         }
263     }
264 
265     private void assertExecuteException(String input, Class&lt;? extends Throwable&gt; exception) {
266         assertExceptionMatch(assertEvalException(input), new ExceptionInfo(exception, null));
267     }
268 
269     private void assertExceptionMatch(SnippetEvent cr, ExceptionInfo exceptionInfo) {
270         assertExceptionMatch(cr.exception(), cr.snippet().source(), exceptionInfo);
271     }
272 
273     private void assertExceptionMatch(Throwable exception, String source, ExceptionInfo exceptionInfo) {
274         assertNotNull(exception, &quot;Expected exception was not thrown: &quot; + exceptionInfo.exception);
275         if (exception instanceof EvalException) {
276             EvalException ex = (EvalException) exception;
277             String actualException = ex.getExceptionClassName();
278             String expectedException = exceptionInfo.exception.getCanonicalName();
279             assertEquals(actualException, expectedException,
280                     String.format(&quot;Given \&quot;%s\&quot; expected exception: %s, got: %s%nStack trace:%n%s&quot;,
281                             source, expectedException, actualException, getStackTrace(ex)));
282             if (exceptionInfo.message != null) {
283                 assertEquals(ex.getMessage(), exceptionInfo.message,
284                         String.format(&quot;Given \&quot;%s\&quot; expected message: %s, got: %s&quot;,
285                                 source, exceptionInfo.message, ex.getMessage()));
286             }
287             assertStackMatch(ex, source, exceptionInfo);
288             if (exceptionInfo.cause != null) {
289                 assertAnyExceptionMatch(exception.getCause(), exceptionInfo.cause);
290             }
291         } else {
292             fail(&quot;Unexpected exception: &quot; + exception + &quot; or exceptionInfo: &quot; + exceptionInfo);
293         }
294     }
295 
296     private void assertStackMatch(JShellException exception, String source, AnyExceptionInfo exceptionInfo) {
297         if (exceptionInfo.stackTraceElements != null) {
298             assertStackTrace(exception.getStackTrace(), exceptionInfo.stackTraceElements,
299                     String.format(&quot;Given \&quot;%s\&quot;%nStack trace:%n%s%n&quot;,
300                             source, getStackTrace(exception)));
301         }
302     }
303 
304     private void assertAnyExceptionMatch(Throwable exception, AnyExceptionInfo exceptionInfo) {
305         if (exceptionInfo instanceof ExceptionInfo) {
306             assertExceptionMatch(exception, &quot;&quot;, (ExceptionInfo) exceptionInfo);
307         } else {
308             assertTrue(exceptionInfo instanceof UnresolvedExceptionInfo, &quot;Bad exceptionInfo: &quot; + exceptionInfo);
309             assertTrue(exception instanceof UnresolvedReferenceException,
310                     &quot;Expected UnresolvedReferenceException: &quot; + exception);
311             UnresolvedExceptionInfo uei = (UnresolvedExceptionInfo) exceptionInfo;
312             UnresolvedReferenceException ure = (UnresolvedReferenceException) exception;
313             assertEquals(ure.getSnippet(), uei.sn);
314             assertStackMatch(ure, &quot;&quot;, exceptionInfo);
315         }
316     }
317 
318     private void assertStackTrace(StackTraceElement[] actual, StackTraceElement[] expected, String message) {
319         if (actual != expected) {
320             if (actual == null || expected == null) {
321                 fail(message);
322             } else {
323                 assertEquals(actual.length, expected.length, message + &quot; : arrays do not have the same size&quot;);
324                 for (int i = 0; i &lt; actual.length; ++i) {
325                     StackTraceElement actualElement = actual[i];
326                     StackTraceElement expectedElement = expected[i];
327                     assertEquals(actualElement.getClassName(), expectedElement.getClassName(), message + &quot; : class names&quot;);
328                     String expectedMethodName = expectedElement.getMethodName();
329                     if (expectedMethodName.startsWith(&quot;lambda$&quot;)) {
330                         assertTrue(actualElement.getMethodName().startsWith(&quot;lambda$&quot;), message + &quot; : method names&quot;);
331                     } else {
332                         assertEquals(actualElement.getMethodName(), expectedElement.getMethodName(), message + &quot; : method names&quot;);
333                     }
334                     assertEquals(actualElement.getFileName(), expectedElement.getFileName(), message + &quot; : file names&quot;);
335                     assertEquals(actualElement.getLineNumber(), expectedElement.getLineNumber(), message + &quot; : line numbers&quot;);
336                 }
337             }
338         }
339     }
340 
341     private String getStackTrace(Throwable ex) {
342         StringWriter st = new StringWriter();
343         ex.printStackTrace(new PrintWriter(st));
344         return st.toString();
345     }
346 }
    </pre>
  </body>
</html>
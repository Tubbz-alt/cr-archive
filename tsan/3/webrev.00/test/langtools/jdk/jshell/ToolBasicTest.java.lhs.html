<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/jdk/jshell/ToolBasicTest.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<a name="1" id="anc1"></a><span class="line-modified"> 26  * @bug 8143037 8142447 8144095 8140265 8144906 8146138 8147887 8147886 8148316 8148317 8143955 8157953 8080347 8154714 8166649 8167643 8170162 8172102 8165405 8174796 8174797 8175304 8167554 8180508 8166232 8196133 8199912 8211694</span>
 27  * @summary Tests for Basic tests for REPL tool
 28  * @modules jdk.compiler/com.sun.tools.javac.api
 29  *          jdk.compiler/com.sun.tools.javac.main
 30  *          jdk.jdeps/com.sun.tools.javap
 31  *          jdk.jshell/jdk.internal.jshell.tool
 32  * @library /tools/lib
 33  * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask
 34  * @build KullaTesting TestingInputStream Compiler
 35  * @run testng/timeout=600 ToolBasicTest
 36  * @key intermittent
 37  */
 38 
 39 import java.io.File;
 40 import java.io.IOException;
 41 import java.io.PrintWriter;
 42 import java.io.StringWriter;
 43 import java.net.InetAddress;
 44 import java.net.InetSocketAddress;
 45 import java.nio.file.Files;
 46 import java.nio.file.Path;
 47 import java.nio.file.Paths;
 48 import java.util.ArrayList;
 49 import java.util.Arrays;
 50 import java.util.List;
 51 import java.util.Scanner;
 52 import java.util.function.BiFunction;
 53 import java.util.function.Consumer;
 54 import java.util.function.Function;
 55 import java.util.stream.Collectors;
 56 import java.util.stream.Stream;
 57 
 58 import com.sun.net.httpserver.HttpServer;
 59 import org.testng.annotations.Test;
 60 
 61 import static org.testng.Assert.assertEquals;
 62 import static org.testng.Assert.assertTrue;
<a name="2" id="anc2"></a>
 63 import static org.testng.Assert.fail;
 64 
 65 @Test
 66 public class ToolBasicTest extends ReplToolTesting {
 67 
 68     public void elideStartUpFromList() {
 69         test(
 70                 (a) -&gt; assertCommandOutputContains(a, &quot;123&quot;, &quot;==&gt; 123&quot;),
 71                 (a) -&gt; assertCommandCheckOutput(a, &quot;/list&quot;, (s) -&gt; {
 72                     int cnt;
 73                     try (Scanner scanner = new Scanner(s)) {
 74                         cnt = 0;
 75                         while (scanner.hasNextLine()) {
 76                             String line = scanner.nextLine();
 77                             if (!line.trim().isEmpty()) {
 78                                 ++cnt;
 79                             }
 80                         }
 81                     }
 82                     assertEquals(cnt, 1, &quot;Expected only one listed line&quot;);
 83                 })
 84         );
 85     }
 86 
 87     public void elideStartUpFromSave() throws IOException {
 88         Compiler compiler = new Compiler();
 89         Path path = compiler.getPath(&quot;myfile&quot;);
 90         test(
 91                 (a) -&gt; assertCommandOutputContains(a, &quot;123&quot;, &quot;==&gt; 123&quot;),
 92                 (a) -&gt; assertCommand(a, &quot;/save &quot; + path.toString(), &quot;&quot;)
 93         );
 94         try (Stream&lt;String&gt; lines = Files.lines(path)) {
 95             assertEquals(lines.count(), 1, &quot;Expected only one saved line&quot;);
 96         }
 97     }
 98 
 99     public void testInterrupt() {
100         ReplTest interrupt = (a) -&gt; assertCommand(a, &quot;\u0003&quot;, &quot;&quot;);
101         for (String s : new String[] { &quot;&quot;, &quot;\u0003&quot; }) {
102             test(false, new String[]{&quot;--no-startup&quot;},
103                     (a) -&gt; assertCommand(a, &quot;int a = 2 +&quot; + s, &quot;&quot;),
104                     interrupt,
105                     (a) -&gt; assertCommand(a, &quot;int a\u0003&quot;, &quot;&quot;),
106                     (a) -&gt; assertCommand(a, &quot;int a = 2 + 2\u0003&quot;, &quot;&quot;),
107                     (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
108                     (a) -&gt; evaluateExpression(a, &quot;int&quot;, &quot;2&quot;, &quot;2&quot;),
109                     (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
110                     (a) -&gt; assertCommand(a, &quot;void f() {&quot;, &quot;&quot;),
111                     (a) -&gt; assertCommand(a, &quot;int q = 10;&quot; + s, &quot;&quot;),
112                     interrupt,
113                     (a) -&gt; assertCommand(a, &quot;void f() {}\u0003&quot;, &quot;&quot;),
114                     (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
115                     (a) -&gt; assertMethod(a, &quot;int f() { return 0; }&quot;, &quot;()int&quot;, &quot;f&quot;),
116                     (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
117                     (a) -&gt; assertCommand(a, &quot;class A {&quot; + s, &quot;&quot;),
118                     interrupt,
119                     (a) -&gt; assertCommand(a, &quot;class A {}\u0003&quot;, &quot;&quot;),
120                     (a) -&gt; assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses()),
121                     (a) -&gt; assertClass(a, &quot;interface A {}&quot;, &quot;interface&quot;, &quot;A&quot;),
122                     (a) -&gt; assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses()),
123                     (a) -&gt; assertCommand(a, &quot;import java.util.stream.&quot; + s, &quot;&quot;),
124                     interrupt,
125                     (a) -&gt; assertCommand(a, &quot;import java.util.stream.\u0003&quot;, &quot;&quot;),
126                     (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports()),
127                     (a) -&gt; assertImport(a, &quot;import java.util.stream.Stream&quot;, &quot;&quot;, &quot;java.util.stream.Stream&quot;),
128                     (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports())
129             );
130         }
131     }
132 
133     public void testCtrlD() {
134         test(false, new String[]{&quot;--no-startup&quot;},
135                 a -&gt; {
136                     if (!a) {
137                         closeCommandInput();
138                     } else {
139                         throw new IllegalStateException();
140                     }
141                 }
142         );
143     }
144 
145     private final Object lock = new Object();
146     private PrintWriter out;
147     private boolean isStopped;
148     private Thread t;
149     private void assertStop(boolean after, String cmd, String output) {
150         if (!after) {
151             isStopped = false;
152             StringWriter writer = new StringWriter();
153             out = new PrintWriter(writer);
154             setCommandInput(cmd + &quot;\n&quot;);
155             t = new Thread(() -&gt; {
156                 try {
157                     // no chance to know whether cmd is being evaluated
158                     Thread.sleep(5000);
159                 } catch (InterruptedException ignored) {
160                 }
161                 int i = 1;
162                 int n = 30;
163                 synchronized (lock) {
164                     do {
165                         setCommandInput(&quot;\u0003&quot;);
166                         if (!isStopped) {
167                             out.println(&quot;Not stopped. Try again: &quot; + i);
168                             try {
169                                 lock.wait(1000);
170                             } catch (InterruptedException ignored) {
171                             }
172                         }
173                     } while (i++ &lt; n &amp;&amp; !isStopped);
174                     if (!isStopped) {
175                         System.err.println(writer.toString());
176                         fail(&quot;Evaluation was not stopped: &#39;&quot; + cmd + &quot;&#39;&quot;);
177                     }
178                 }
179             });
180             t.start();
181         } else {
182             synchronized (lock)  {
183                 out.println(&quot;Evaluation was stopped successfully: &#39;&quot; + cmd + &quot;&#39;&quot;);
184                 isStopped = true;
185                 lock.notify();
186             }
187             try {
188                 t.join();
189                 t = null;
190             } catch (InterruptedException ignored) {
191             }
192             assertOutput(getCommandOutput(), &quot;&quot;, &quot;command&quot;);
193             assertOutput(getCommandErrorOutput(), &quot;&quot;, &quot;command error&quot;);
194             assertOutput(getUserOutput().trim(), output, &quot;user&quot;);
195             assertOutput(getUserErrorOutput(), &quot;&quot;, &quot;user error&quot;);
196         }
197     }
198 
199     public void testStop() {
200         test(
201                 (a) -&gt; assertStop(a, &quot;while (true) {}&quot;, &quot;&quot;),
202                 (a) -&gt; assertStop(a, &quot;while (true) { try { Thread.sleep(100); } catch (InterruptedException ex) { } }&quot;, &quot;&quot;)
203         );
204     }
205 
206     public void testRerun() {
207         test(false, new String[] {&quot;--no-startup&quot;},
208                 (a) -&gt; assertCommand(a, &quot;/0&quot;, &quot;|  No snippet with ID: 0&quot;),
209                 (a) -&gt; assertCommand(a, &quot;/5&quot;, &quot;|  No snippet with ID: 5&quot;)
210         );
211         String[] codes = new String[] {
212                 &quot;int a = 0;&quot;, // var
213                 &quot;class A {}&quot;, // class
214                 &quot;void f() {}&quot;, // method
215                 &quot;bool b;&quot;, // active failed
216                 &quot;void g() { h(); }&quot;, // active corralled
217         };
218         List&lt;ReplTest&gt; tests = new ArrayList&lt;&gt;();
219         for (String s : codes) {
220             tests.add((a) -&gt; assertCommand(a, s, null));
221         }
222         // Test /1 through /5 -- assure references are correct
223         for (int i = 0; i &lt; codes.length; ++i) {
224             final int finalI = i;
225             Consumer&lt;String&gt; check = (s) -&gt; {
226                 String[] ss = s.split(&quot;\n&quot;);
227                 assertEquals(ss[0], codes[finalI]);
228                 assertTrue(ss.length &gt; 1, s);
229             };
230             tests.add((a) -&gt; assertCommandCheckOutput(a, &quot;/&quot; + (finalI + 1), check));
231         }
232         // Test /-1 ... note that the snippets added by history must be stepped over
233         for (int i = 0; i &lt; codes.length; ++i) {
234             final int finalI = i;
235             Consumer&lt;String&gt; check = (s) -&gt; {
236                 String[] ss = s.split(&quot;\n&quot;);
237                 assertEquals(ss[0], codes[codes.length - finalI - 1]);
238                 assertTrue(ss.length &gt; 1, s);
239             };
240             tests.add((a) -&gt; assertCommandCheckOutput(a, &quot;/-&quot; + (2 * finalI + 1), check));
241         }
242         tests.add((a) -&gt; assertCommandCheckOutput(a, &quot;/!&quot;, assertStartsWith(&quot;int a = 0;&quot;)));
243         test(false, new String[]{&quot;--no-startup&quot;},
244                 tests.toArray(new ReplTest[tests.size()]));
245     }
246 
247     public void test8142447() {
248         Function&lt;String, BiFunction&lt;String, Integer, ReplTest&gt;&gt; assertRerun = cmd -&gt; (code, assertionCount) -&gt;
249                 (a) -&gt; assertCommandCheckOutput(a, cmd, s -&gt; {
250                             String[] ss = s.split(&quot;\n&quot;);
251                             assertEquals(ss[0], code);
252                             loadVariable(a, &quot;int&quot;, &quot;assertionCount&quot;, Integer.toString(assertionCount), Integer.toString(assertionCount));
253                         });
254         ReplTest assertVariables = (a) -&gt; assertCommandCheckOutput(a, &quot;/v&quot;, assertVariables());
255 
256         Compiler compiler = new Compiler();
257         Path startup = compiler.getPath(&quot;StartupFileOption/startup.txt&quot;);
258         compiler.writeToFile(startup, &quot;int assertionCount = 0;\n&quot; + // id: s1
259                 &quot;void add(int n) { assertionCount += n; }&quot;);
260         test(new String[]{&quot;--startup&quot;, startup.toString()},
261                 (a) -&gt; assertCommand(a, &quot;add(1)&quot;, &quot;&quot;), // id: 1
262                 (a) -&gt; assertCommandCheckOutput(a, &quot;add(ONE)&quot;, s -&gt; assertEquals(s.split(&quot;\n&quot;)[0], &quot;|  Error:&quot;)), // id: e1
263                 (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;ONE&quot;, &quot;1&quot;, &quot;1&quot;),
264                 assertRerun.apply(&quot;/1&quot;).apply(&quot;add(1)&quot;, 2), assertVariables,
265                 assertRerun.apply(&quot;/e1&quot;).apply(&quot;add(ONE)&quot;, 3), assertVariables,
266                 assertRerun.apply(&quot;/s1&quot;).apply(&quot;int assertionCount = 0;&quot;, 0), assertVariables
267         );
268 
269         test(false, new String[] {&quot;--no-startup&quot;},
270                 (a) -&gt; assertCommand(a, &quot;/s1&quot;, &quot;|  No snippet with ID: s1&quot;),
271                 (a) -&gt; assertCommand(a, &quot;/1&quot;, &quot;|  No snippet with ID: 1&quot;),
272                 (a) -&gt; assertCommand(a, &quot;/e1&quot;, &quot;|  No snippet with ID: e1&quot;)
273         );
274     }
275 
276     public void testClasspathDirectory() {
277         Compiler compiler = new Compiler();
278         Path outDir = Paths.get(&quot;testClasspathDirectory&quot;);
279         compiler.compile(outDir, &quot;package pkg; public class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
280         Path classpath = compiler.getPath(outDir);
281         test(
282                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + classpath,
283                         &quot;|  Setting new options and restoring state.&quot;),
284                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;)
285         );
286         test(new String[] { &quot;--class-path&quot;, classpath.toString() },
287                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;)
288         );
289     }
290 
291     public void testEnvInStartUp() {
292         Compiler compiler = new Compiler();
293         Path outDir = Paths.get(&quot;testClasspathDirectory&quot;);
294         compiler.compile(outDir, &quot;package pkg; public class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
295         Path classpath = compiler.getPath(outDir);
296         Path sup = compiler.getPath(&quot;startup.jsh&quot;);
297         compiler.writeToFile(sup,
298                 &quot;int xxx;\n&quot; +
299                 &quot;/env -class-path &quot; + classpath + &quot;\n&quot; +
300                 &quot;int aaa = 735;\n&quot;
301         );
302         test(
303                 (a) -&gt; assertCommand(a, &quot;/set start -retain &quot; + sup, &quot;&quot;),
304                 (a) -&gt; assertCommand(a, &quot;/reset&quot;,
305                         &quot;|  Resetting state.&quot;),
306                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;),
307                 (a) -&gt; assertCommand(a, &quot;aaa&quot;, &quot;aaa ==&gt; 735&quot;)
308         );
309         test(
310                 (a) -&gt; assertCommandOutputContains(a, &quot;/env&quot;, &quot;--class-path&quot;),
311                 (a) -&gt; assertCommandOutputContains(a, &quot;xxx&quot;, &quot;cannot find symbol&quot;, &quot;variable xxx&quot;),
312                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;),
313                 (a) -&gt; assertCommand(a, &quot;aaa&quot;, &quot;aaa ==&gt; 735&quot;)
314         );
315     }
316 
317     private String makeSimpleJar() {
318         Compiler compiler = new Compiler();
319         Path outDir = Paths.get(&quot;testClasspathJar&quot;);
320         compiler.compile(outDir, &quot;package pkg; public class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
321         String jarName = &quot;test.jar&quot;;
322         compiler.jar(outDir, jarName, &quot;pkg/A.class&quot;);
323         return compiler.getPath(outDir).resolve(jarName).toString();
324     }
325 
326     public void testClasspathJar() {
327         String jarPath = makeSimpleJar();
328         test(
329                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + jarPath,
330                         &quot;|  Setting new options and restoring state.&quot;),
331                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;)
332         );
333         test(new String[] { &quot;--class-path&quot;, jarPath },
334                 (a) -&gt; evaluateExpression(a, &quot;pkg.A&quot;, &quot;new pkg.A();&quot;, &quot;A&quot;)
335         );
336     }
337 
338     public void testClasspathUserHomeExpansion() {
339         String jarPath = makeSimpleJar();
340         String tilde = &quot;~&quot; + File.separator;
341         test(
342                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + tilde + &quot;forblato&quot;,
343                         &quot;|  File &#39;&quot; + Paths.get(System.getProperty(&quot;user.home&quot;), &quot;forblato&quot;).toString()
344                                 + &quot;&#39; for &#39;--class-path&#39; is not found.&quot;),
345                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + jarPath + File.pathSeparator
346                                                             + tilde + &quot;forblato&quot;,
347                         &quot;|  File &#39;&quot; + Paths.get(System.getProperty(&quot;user.home&quot;), &quot;forblato&quot;).toString()
348                                 + &quot;&#39; for &#39;--class-path&#39; is not found.&quot;)
349         );
350     }
351 
352     public void testBadClasspath() {
353         String jarPath = makeSimpleJar();
354         Compiler compiler = new Compiler();
355         Path t1 = compiler.getPath(&quot;whatever/thing.zip&quot;);
356         compiler.writeToFile(t1, &quot;&quot;);
357         Path t2 = compiler.getPath(&quot;whatever/thing.jmod&quot;);
358         compiler.writeToFile(t2, &quot;&quot;);
359         test(
360                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + t1.toString(),
361                         &quot;|  Invalid &#39;--class-path&#39; argument: &quot; + t1.toString()),
362                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + jarPath + File.pathSeparator + t1.toString(),
363                         &quot;|  Invalid &#39;--class-path&#39; argument: &quot; + t1.toString()),
364                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + t2.toString(),
365                         &quot;|  Invalid &#39;--class-path&#39; argument: &quot; + t2.toString())
366         );
367     }
368 
369     private String makeBadSourceJar() {
370         Compiler compiler = new Compiler();
371         Path outDir = Paths.get(&quot;testClasspathJar&quot;);
372         Path src = compiler.getPath(outDir.resolve(&quot;pkg/A.java&quot;));
373         compiler.writeToFile(src, &quot;package pkg; /** \u0086 */public class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
374         String jarName = &quot;test.jar&quot;;
375         compiler.jar(outDir, jarName, &quot;pkg/A.java&quot;);
376         return compiler.getPath(outDir).resolve(jarName).toString();
377     }
378 
379     public void testBadSourceJarClasspath() {
380         String jarPath = makeBadSourceJar();
381         test(
382                 (a) -&gt; assertCommand(a, &quot;/env --class-path &quot; + jarPath,
383                         &quot;|  Setting new options and restoring state.&quot;),
384                 (a) -&gt; assertCommandOutputStartsWith(a, &quot;new pkg.A();&quot;,
385                         &quot;|  Error:\n&quot;
386                         + &quot;|  cannot find symbol\n&quot;
387                         + &quot;|    symbol:   class A&quot;)
388         );
389         test(new String[]{&quot;--class-path&quot;, jarPath},
390                 (a) -&gt; assertCommandOutputStartsWith(a, &quot;new pkg.A();&quot;,
391                         &quot;|  Error:\n&quot;
392                         + &quot;|  cannot find symbol\n&quot;
393                         + &quot;|    symbol:   class A&quot;)
394         );
395     }
396 
397     public void testModulePath() {
398         Compiler compiler = new Compiler();
399         Path modsDir = Paths.get(&quot;mods&quot;);
400         Path outDir = Paths.get(&quot;mods&quot;, &quot;org.astro&quot;);
401         compiler.compile(outDir, &quot;package org.astro; public class World { public static String name() { return \&quot;world\&quot;; } }&quot;);
402         compiler.compile(outDir, &quot;module org.astro { exports org.astro; }&quot;);
403         Path modsPath = compiler.getPath(modsDir);
404         test(new String[] { &quot;--module-path&quot;, modsPath.toString(), &quot;--add-modules&quot;, &quot;org.astro&quot; },
405                 (a) -&gt; assertCommand(a, &quot;import org.astro.World;&quot;, &quot;&quot;),
406                 (a) -&gt; evaluateExpression(a, &quot;String&quot;,
407                         &quot;String.format(\&quot;Greetings %s!\&quot;, World.name());&quot;,
408                         &quot;\&quot;Greetings world!\&quot;&quot;)
409         );
410     }
411 
412     public void testModulePathUserHomeExpansion() {
413         String tilde = &quot;~&quot; + File.separatorChar;
414         test(
415                 (a) -&gt; assertCommand(a, &quot;/env --module-path &quot; + tilde + &quot;snardugol&quot;,
416                         &quot;|  File &#39;&quot; + Paths.get(System.getProperty(&quot;user.home&quot;), &quot;snardugol&quot;).toString()
417                                 + &quot;&#39; for &#39;--module-path&#39; is not found.&quot;)
418         );
419     }
420 
421     public void testBadModulePath() {
422         Compiler compiler = new Compiler();
423         Path t1 = compiler.getPath(&quot;whatever/thing.zip&quot;);
424         compiler.writeToFile(t1, &quot;&quot;);
425         test(
426                 (a) -&gt; assertCommand(a, &quot;/env --module-path &quot; + t1.toString(),
427                         &quot;|  Invalid &#39;--module-path&#39; argument: &quot; + t1.toString())
428         );
429     }
430 
431     public void testStartupFileOption() {
432         Compiler compiler = new Compiler();
433         Path startup = compiler.getPath(&quot;StartupFileOption/startup.txt&quot;);
434         compiler.writeToFile(startup, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;);
435         test(new String[]{&quot;--startup&quot;, startup.toString()},
436                 (a) -&gt; evaluateExpression(a, &quot;A&quot;, &quot;new A()&quot;, &quot;A&quot;)
437         );
438         test(new String[]{&quot;--no-startup&quot;},
439                 (a) -&gt; assertCommandCheckOutput(a, &quot;Pattern.compile(\&quot;x+\&quot;)&quot;, assertStartsWith(&quot;|  Error:\n|  cannot find symbol&quot;))
440         );
441         test(
442                 (a) -&gt; assertCommand(a, &quot;Pattern.compile(\&quot;x+\&quot;)&quot;, &quot;$1 ==&gt; x+&quot;, &quot;&quot;, null, &quot;&quot;, &quot;&quot;)
443         );
444     }
445 
446     public void testLoadingFromArgs() {
447         Compiler compiler = new Compiler();
448         Path path = compiler.getPath(&quot;loading.repl&quot;);
449         compiler.writeToFile(path, &quot;int a = 10; double x = 20; double a = 10;&quot;);
450         test(new String[] { path.toString() },
451                 (a) -&gt; assertCommand(a, &quot;x&quot;, &quot;x ==&gt; 20.0&quot;),
452                 (a) -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; 10.0&quot;)
453         );
454     }
455 
456     public void testReset() {
457         test(
458                 (a) -&gt; assertReset(a, &quot;/res&quot;),
459                 (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
460                 (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;x&quot;),
461                 (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
462                 (a) -&gt; assertMethod(a, &quot;void f() { }&quot;, &quot;()void&quot;, &quot;f&quot;),
463                 (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
464                 (a) -&gt; assertClass(a, &quot;class A { }&quot;, &quot;class&quot;, &quot;A&quot;),
465                 (a) -&gt; assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses()),
466                 (a) -&gt; assertImport(a, &quot;import java.util.stream.*;&quot;, &quot;&quot;, &quot;java.util.stream.*&quot;),
467                 (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports()),
468                 (a) -&gt; assertReset(a, &quot;/reset&quot;),
469                 (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
470                 (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
471                 (a) -&gt; assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses()),
472                 (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports())
473         );
474     }
475 
476     public void testOpen() {
477         Compiler compiler = new Compiler();
478         Path path = compiler.getPath(&quot;testOpen.repl&quot;);
479         compiler.writeToFile(path,
480                 &quot;int a = 10;\ndouble x = 20;\ndouble a = 10;\n&quot; +
481                         &quot;class A { public String toString() { return \&quot;A\&quot;; } }\nimport java.util.stream.*;&quot;);
482         for (String s : new String[]{&quot;/o&quot;, &quot;/open&quot;}) {
483             test(
484                     (a) -&gt; assertCommand(a, s + &quot; &quot; + path.toString(), &quot;&quot;),
485                     (a) -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; 10.0&quot;),
486                     (a) -&gt; evaluateExpression(a, &quot;A&quot;, &quot;new A();&quot;, &quot;A&quot;),
487                     (a) -&gt; evaluateExpression(a, &quot;long&quot;, &quot;Stream.of(\&quot;A\&quot;).count();&quot;, &quot;1&quot;),
488                     (a) -&gt; {
489                         loadVariable(a, &quot;double&quot;, &quot;x&quot;, &quot;20.0&quot;, &quot;20.0&quot;);
490                         loadVariable(a, &quot;double&quot;, &quot;a&quot;, &quot;10.0&quot;, &quot;10.0&quot;);
491                         loadVariable(a, &quot;A&quot;, &quot;$7&quot;, &quot;new A();&quot;, &quot;A&quot;);
492                         loadVariable(a, &quot;long&quot;, &quot;$8&quot;, &quot;Stream.of(\&quot;A\&quot;).count();&quot;, &quot;1&quot;);
493                         loadClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;,
494                                 &quot;class&quot;, &quot;A&quot;);
495                         loadImport(a, &quot;import java.util.stream.*;&quot;, &quot;&quot;, &quot;java.util.stream.*&quot;);
496                         assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses());
497                     },
498                     (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
499                     (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
500                     (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports())
501             );
502             Path unknown = compiler.getPath(&quot;UNKNOWN.repl&quot;);
503             test(
504                     (a) -&gt; assertCommand(a, s + &quot; &quot; + unknown,
505                             &quot;|  File &#39;&quot; + unknown + &quot;&#39; for &#39;/open&#39; is not found.&quot;)
506             );
507         }
508     }
509 
510     public void testOpenLocalFileUrl() {
511         Compiler compiler = new Compiler();
512         Path path = compiler.getPath(&quot;testOpen.repl&quot;);
513         compiler.writeToFile(path, &quot;int a = 10;int b = 20;int c = a + b;\n&quot;);
514         for (String s : new String[]{&quot;/o&quot;, &quot;/open&quot;}) {
515             test(
516                     (a) -&gt; assertCommand(a, s + &quot; &quot; + path.toUri(), &quot;&quot;),
517                     (a) -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; 10&quot;),
518                     (a) -&gt; assertCommand(a, &quot;b&quot;, &quot;b ==&gt; 20&quot;),
519                     (a) -&gt; assertCommand(a, &quot;c&quot;, &quot;c ==&gt; 30&quot;)
520             );
521         }
522     }
523 
524     public void testOpenFileOverHttp() throws IOException {
525         var script = &quot;int a = 10;int b = 20;int c = a + b;&quot;;
526 
527         var localhostAddress = new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), 0);
528         var httpServer = HttpServer.create(localhostAddress, 0);
529         try {
530             httpServer.createContext(&quot;/script&quot;, exchange -&gt; {
531                 exchange.sendResponseHeaders(200, script.length());
532                 try (var output = exchange.getResponseBody()) {
533                     output.write(script.getBytes());
534                 }
535             });
536             httpServer.setExecutor(null);
537             httpServer.start();
538 
539             var urlAddress = &quot;http:/&quot; + httpServer.getAddress().toString() + &quot;/script&quot;;
540             for (String s : new String[]{&quot;/o&quot;, &quot;/open&quot;}) {
541                 test(
542                         (a) -&gt; assertCommand(a, s + &quot; &quot; + urlAddress, &quot;&quot;),
543                         (a) -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; 10&quot;),
544                         (a) -&gt; assertCommand(a, &quot;b&quot;, &quot;b ==&gt; 20&quot;),
545                         (a) -&gt; assertCommand(a, &quot;c&quot;, &quot;c ==&gt; 30&quot;)
546                 );
547             }
548         } finally {
549             httpServer.stop(0);
550         }
551     }
552 
553     public void testOpenResource() {
554         test(
555                 (a) -&gt; assertCommand(a, &quot;/open PRINTING&quot;, &quot;&quot;),
556                 (a) -&gt; assertCommandOutputContains(a, &quot;/list&quot;,
557                         &quot;void println&quot;, &quot;System.out.printf&quot;),
558                 (a) -&gt; assertCommand(a, &quot;printf(\&quot;%4.2f\&quot;, Math.PI)&quot;,
559                         &quot;&quot;, &quot;&quot;, null, &quot;3.14&quot;, &quot;&quot;)
560         );
561     }
562 
563     public void testSave() throws IOException {
564         Compiler compiler = new Compiler();
565         Path path = compiler.getPath(&quot;testSave.repl&quot;);
566         {
567             List&lt;String&gt; list = Arrays.asList(
568                     &quot;int a;&quot;,
569                     &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;
570             );
571             test(
572                     (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;a&quot;),
573                     (a) -&gt; assertCommand(a, &quot;()&quot;, null, null, null, &quot;&quot;, &quot;&quot;),
574                     (a) -&gt; assertClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;, &quot;class&quot;, &quot;A&quot;),
575                     (a) -&gt; assertCommand(a, &quot;/save &quot; + path.toString(), &quot;&quot;)
576             );
577             assertEquals(Files.readAllLines(path), list);
578         }
579         {
580             List&lt;String&gt; output = new ArrayList&lt;&gt;();
581             test(
582                     (a) -&gt; assertCommand(a, &quot;int a;&quot;, null),
583                     (a) -&gt; assertCommand(a, &quot;()&quot;, null, null, null, &quot;&quot;, &quot;&quot;),
584                     (a) -&gt; assertClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;, &quot;class&quot;, &quot;A&quot;),
585                     (a) -&gt; assertCommandCheckOutput(a, &quot;/list -all&quot;, (out) -&gt;
586                                     output.addAll(Stream.of(out.split(&quot;\n&quot;))
587                             .filter(str -&gt; !str.isEmpty())
588                             .map(str -&gt; str.substring(str.indexOf(&#39;:&#39;) + 2))
589                             .filter(str -&gt; !str.startsWith(&quot;/&quot;))
590                             .collect(Collectors.toList()))),
591                     (a) -&gt; assertCommand(a, &quot;/save -all &quot; + path.toString(), &quot;&quot;)
592             );
593             assertEquals(Files.readAllLines(path), output);
594         }
595         {
596             List&lt;String&gt; output = new ArrayList&lt;&gt;();
597             test(
598                     (a) -&gt; assertCommand(a, &quot;int a;&quot;, null),
599                     (a) -&gt; assertCommand(a, &quot;int b;&quot;, null),
600                     (a) -&gt; assertCommand(a, &quot;int c;&quot;, null),
601                     (a) -&gt; assertClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;, &quot;class&quot;, &quot;A&quot;),
602                     (a) -&gt; assertCommandCheckOutput(a, &quot;/list b c a A&quot;, (out) -&gt;
603                                     output.addAll(Stream.of(out.split(&quot;\n&quot;))
604                             .filter(str -&gt; !str.isEmpty())
605                             .map(str -&gt; str.substring(str.indexOf(&#39;:&#39;) + 2))
606                             .filter(str -&gt; !str.startsWith(&quot;/&quot;))
607                             .collect(Collectors.toList()))),
608                     (a) -&gt; assertCommand(a, &quot;/save 2-3 1 4 &quot; + path.toString(), &quot;&quot;)
609             );
610             assertEquals(Files.readAllLines(path), output);
611         }
612         {
613             List&lt;String&gt; output = new ArrayList&lt;&gt;();
614             test(
615                     (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;a&quot;),
616                     (a) -&gt; assertCommand(a, &quot;()&quot;, null, null, null, &quot;&quot;, &quot;&quot;),
617                     (a) -&gt; assertClass(a, &quot;class A { public String toString() { return \&quot;A\&quot;; } }&quot;, &quot;class&quot;, &quot;A&quot;),
618                     (a) -&gt; assertCommandCheckOutput(a, &quot;/history&quot;, (out) -&gt;
619                                 output.addAll(Stream.of(out.split(&quot;\n&quot;))
620                             .filter(str -&gt; !str.isEmpty())
621                             .collect(Collectors.toList()))),
622                     (a) -&gt; assertCommand(a, &quot;/save -history &quot; + path.toString(), &quot;&quot;)
623             );
624             output.add(&quot;/save -history &quot; + path.toString());
625             assertEquals(Files.readAllLines(path), output);
626         }
627     }
628 
629     public void testStartRetain() {
630         Compiler compiler = new Compiler();
631         Path startUpFile = compiler.getPath(&quot;startUp.txt&quot;);
632         test(
633                 (a) -&gt; assertVariable(a, &quot;int&quot;, &quot;a&quot;),
634                 (a) -&gt; assertVariable(a, &quot;double&quot;, &quot;b&quot;, &quot;10&quot;, &quot;10.0&quot;),
635                 (a) -&gt; assertMethod(a, &quot;void f() {}&quot;, &quot;()V&quot;, &quot;f&quot;),
636                 (a) -&gt; assertImport(a, &quot;import java.util.stream.*;&quot;, &quot;&quot;, &quot;java.util.stream.*&quot;),
637                 (a) -&gt; assertCommand(a, &quot;/save &quot; + startUpFile.toString(), null),
638                 (a) -&gt; assertCommand(a, &quot;/set start -retain &quot; + startUpFile.toString(), null)
639         );
640         Path unknown = compiler.getPath(&quot;UNKNOWN&quot;);
641         test(
642                 (a) -&gt; assertCommandOutputStartsWith(a, &quot;/set start -retain &quot; + unknown.toString(),
643                         &quot;|  File &#39;&quot; + unknown + &quot;&#39; for &#39;/set start&#39; is not found.&quot;)
644         );
645         test(false, new String[0],
646                 (a) -&gt; {
647                     loadVariable(a, &quot;int&quot;, &quot;a&quot;);
648                     loadVariable(a, &quot;double&quot;, &quot;b&quot;, &quot;10.0&quot;, &quot;10.0&quot;);
649                     loadMethod(a, &quot;void f() {}&quot;, &quot;()void&quot;, &quot;f&quot;);
650                     loadImport(a, &quot;import java.util.stream.*;&quot;, &quot;&quot;, &quot;java.util.stream.*&quot;);
651                     assertCommandCheckOutput(a, &quot;/types&quot;, assertClasses());
652                 },
653                 (a) -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
654                 (a) -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods()),
655                 (a) -&gt; assertCommandCheckOutput(a, &quot;/imports&quot;, assertImports())
656         );
657     }
658 
659     public void testStartSave() throws IOException {
660         Compiler compiler = new Compiler();
661         Path startSave = compiler.getPath(&quot;startSave.txt&quot;);
662         test(a -&gt; assertCommand(a, &quot;/save -start &quot; + startSave.toString(), null));
663         List&lt;String&gt; lines = Files.lines(startSave)
664                 .filter(s -&gt; !s.isEmpty())
665                 .collect(Collectors.toList());
666         assertEquals(lines, START_UP);
667     }
668 
669     public void testConstrainedUpdates() {
670         test(
671                 a -&gt; assertClass(a, &quot;class XYZZY { }&quot;, &quot;class&quot;, &quot;XYZZY&quot;),
672                 a -&gt; assertVariable(a, &quot;XYZZY&quot;, &quot;xyzzy&quot;),
673                 a -&gt; assertCommandCheckOutput(a, &quot;import java.util.stream.*&quot;,
674                         (out) -&gt; assertTrue(out.trim().isEmpty(), &quot;Expected no output, got: &quot; + out))
675         );
676     }
677 
678     public void testRemoteExit() {
679         test(
680                 a -&gt; assertVariable(a, &quot;int&quot;, &quot;x&quot;),
681                 a -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, assertVariables()),
682                 a -&gt; assertCommandOutputContains(a, &quot;System.exit(5);&quot;, &quot;terminated&quot;),
683                 a -&gt; assertCommandCheckOutput(a, &quot;/vars&quot;, s -&gt;
684                         assertTrue(s.trim().isEmpty(), s)),
685                 a -&gt; assertMethod(a, &quot;void f() { }&quot;, &quot;()void&quot;, &quot;f&quot;),
686                 a -&gt; assertCommandCheckOutput(a, &quot;/methods&quot;, assertMethods())
687         );
688     }
689 
690     public void testFeedbackNegative() {
691         test(a -&gt; assertCommandCheckOutput(a, &quot;/set feedback aaaa&quot;,
692                 assertStartsWith(&quot;|  Does not match any current feedback mode&quot;)));
693     }
694 
695     public void testFeedbackSilent() {
696         for (String off : new String[]{&quot;s&quot;, &quot;silent&quot;}) {
697             test(
698                     a -&gt; assertCommand(a, &quot;/set feedback &quot; + off, &quot;&quot;),
699                     a -&gt; assertCommand(a, &quot;int a&quot;, &quot;&quot;),
700                     a -&gt; assertCommand(a, &quot;void f() {}&quot;, &quot;&quot;),
701                     a -&gt; assertCommandCheckOutput(a, &quot;aaaa&quot;, assertStartsWith(&quot;|  Error:&quot;)),
702                     a -&gt; assertCommandCheckOutput(a, &quot;static void f() {}&quot;, assertStartsWith(&quot;|  Warning:&quot;))
703             );
704         }
705     }
706 
707     public void testFeedbackNormal() {
708         Compiler compiler = new Compiler();
709         Path testNormalFile = compiler.getPath(&quot;testConciseNormal&quot;);
710         String[] sources = new String[] {&quot;int a&quot;, &quot;void f() {}&quot;, &quot;class A {}&quot;, &quot;a = 10&quot;};
711         String[] sources2 = new String[] {&quot;int a //again&quot;, &quot;void f() {int y = 4;}&quot;, &quot;class A {} //again&quot;, &quot;a = 10&quot;};
712         String[] output = new String[] {
713                 &quot;a ==&gt; 0&quot;,
714                 &quot;|  created method f()&quot;,
715                 &quot;|  created class A&quot;,
716                 &quot;a ==&gt; 10&quot;
717         };
718         compiler.writeToFile(testNormalFile, sources2);
719         for (String feedback : new String[]{&quot;/set fe&quot;, &quot;/set feedback&quot;}) {
720             for (String feedbackState : new String[]{&quot;n&quot;, &quot;normal&quot;}) {
721                 test(
722                         a -&gt; assertCommand(a, feedback + &quot; &quot; + feedbackState, &quot;|  Feedback mode: normal&quot;),
723                         a -&gt; assertCommand(a, sources[0], output[0]),
724                         a -&gt; assertCommand(a, sources[1], output[1]),
725                         a -&gt; assertCommand(a, sources[2], output[2]),
726                         a -&gt; assertCommand(a, sources[3], output[3]),
727                         a -&gt; assertCommand(a, &quot;/o &quot; + testNormalFile.toString(), &quot;&quot;)
728                 );
729             }
730         }
731     }
732 
733     public void testVarsWithNotActive() {
734         test(
735                 a -&gt; assertVariable(a, &quot;Blath&quot;, &quot;x&quot;),
736                 a -&gt; assertCommandOutputContains(a, &quot;/var -all&quot;, &quot;(not-active)&quot;)
737         );
738     }
739 
740     public void testHistoryReference() {
741         test(false, new String[]{&quot;--no-startup&quot;},
742                 a -&gt; assertCommand(a, &quot;System.err.println(99)&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;99\n&quot;),
743                 a -&gt; assertCommand(a, &quot;/exit&quot;, &quot;&quot;)
744         );
745         test(false, new String[]{&quot;--no-startup&quot;},
746                 a -&gt; assertCommand(a, &quot;System.err.println(1)&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;1\n&quot;),
747                 a -&gt; assertCommand(a, &quot;System.err.println(2)&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;2\n&quot;),
748                 a -&gt; assertCommand(a, &quot;/-2&quot;, &quot;System.err.println(1)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;1\n&quot;),
749                 a -&gt; assertCommand(a, &quot;/history&quot;,
750                                                     &quot;/debug 0\n&quot; +
751                                                     &quot;System.err.println(1)\n&quot; +
752                                                     &quot;System.err.println(2)\n&quot; +
753                                                     &quot;System.err.println(1)\n&quot; +
754                                                     &quot;/history\n&quot;),
755                 a -&gt; assertCommand(a, &quot;/history -all&quot;,
756                                                     &quot;/debug 0\n&quot; +
757                                                     &quot;System.err.println(99)\n&quot; +
758                                                     &quot;/exit\n&quot; +
759                                                     &quot;/debug 0\n&quot; +
760                                                     &quot;System.err.println(1)\n&quot; +
761                                                     &quot;System.err.println(2)\n&quot; +
762                                                     &quot;System.err.println(1)\n&quot; +
763                                                     &quot;/history\n&quot; +
764                                                     &quot;/history -all\n&quot;),
765                 a -&gt; assertCommand(a, &quot;/-2&quot;, &quot;System.err.println(2)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;2\n&quot;),
766                 a -&gt; assertCommand(a, &quot;/!&quot;, &quot;System.err.println(2)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;2\n&quot;),
767                 a -&gt; assertCommand(a, &quot;/2&quot;, &quot;System.err.println(2)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;2\n&quot;),
768                 a -&gt; assertCommand(a, &quot;/1&quot;, &quot;System.err.println(1)&quot;, &quot;&quot;, null, &quot;&quot;, &quot;1\n&quot;)
769         );
770     }
771 
772     public void testRerunIdRange() {
773         Compiler compiler = new Compiler();
774         Path startup = compiler.getPath(&quot;rangeStartup&quot;);
775         String[] startupSources = new String[] {
776             &quot;boolean go = false&quot;,
777             &quot;void println(String s) { if (go) System.out.println(s); }&quot;,
778             &quot;void println(int i) { if (go) System.out.println(i); }&quot;,
779             &quot;println(\&quot;s4\&quot;)&quot;,
780             &quot;println(\&quot;s5\&quot;)&quot;,
781             &quot;println(\&quot;s6\&quot;)&quot;
782         };
783         String[] sources = new String[] {
784             &quot;frog&quot;,
785             &quot;go = true&quot;,
786             &quot;println(2)&quot;,
787             &quot;println(3)&quot;,
788             &quot;println(4)&quot;,
789             &quot;querty&quot;
790         };
791         compiler.writeToFile(startup, startupSources);
792         test(false, new String[]{&quot;--startup&quot;, startup.toString()},
793                 a -&gt; assertCommandOutputStartsWith(a, sources[0], &quot;|  Error:&quot;),
794                 a -&gt; assertCommand(a, sources[1], &quot;go ==&gt; true&quot;, &quot;&quot;, null, &quot;&quot;, &quot;&quot;),
795                 a -&gt; assertCommand(a, sources[2], &quot;&quot;, &quot;&quot;, null, &quot;2\n&quot;, &quot;&quot;),
796                 a -&gt; assertCommand(a, sources[3], &quot;&quot;, &quot;&quot;, null, &quot;3\n&quot;, &quot;&quot;),
797                 a -&gt; assertCommand(a, sources[4], &quot;&quot;, &quot;&quot;, null, &quot;4\n&quot;, &quot;&quot;),
798                 a -&gt; assertCommandOutputStartsWith(a, sources[5], &quot;|  Error:&quot;),
799                 a -&gt; assertCommand(a, &quot;/3&quot;, &quot;println(3)&quot;, &quot;&quot;, null, &quot;3\n&quot;, &quot;&quot;),
800                 a -&gt; assertCommand(a, &quot;/s4&quot;, &quot;println(\&quot;s4\&quot;)&quot;, &quot;&quot;, null, &quot;s4\n&quot;, &quot;&quot;),
801                 a -&gt; assertCommandOutputStartsWith(a, &quot;/e1&quot;, &quot;frog\n|  Error:&quot;),
802                 a -&gt; assertCommand(a, &quot;/2-4&quot;,
803                         &quot;println(2)\nprintln(3)\nprintln(4)&quot;,
804                         &quot;&quot;, null, &quot;2\n3\n4\n&quot;, &quot;&quot;),
805                 a -&gt; assertCommand(a, &quot;/s4-s6&quot;,
806                         startupSources[3] + &quot;\n&quot; +startupSources[4] + &quot;\n&quot; +startupSources[5],
807                         &quot;&quot;, null, &quot;s4\ns5\ns6\n&quot;, &quot;&quot;),
808                 a -&gt; assertCommand(a, &quot;/s4-4&quot;, null,
809                         &quot;&quot;, null, &quot;s4\ns5\ns6\n2\n3\n4\n&quot;, &quot;&quot;),
810                 a -&gt; assertCommandCheckOutput(a, &quot;/e1-e2&quot;,
811                         s -&gt; {
812                             assertTrue(s.trim().startsWith(&quot;frog\n|  Error:&quot;),
813                                     &quot;Output: \&#39;&quot; + s + &quot;&#39; does not start with: &quot; + &quot;|  Error:&quot;);
814                             assertTrue(s.trim().lastIndexOf(&quot;|  Error:&quot;) &gt; 10,
815                                     &quot;Output: \&#39;&quot; + s + &quot;&#39; does not have second: &quot; + &quot;|  Error:&quot;);
816                         }),
817                 a -&gt; assertCommand(a, &quot;/4  s4 2&quot;,
818                         &quot;println(4)\nprintln(\&quot;s4\&quot;)\nprintln(2)&quot;,
819                         &quot;&quot;, null, &quot;4\ns4\n2\n&quot;, &quot;&quot;),
820                 a -&gt; assertCommand(a, &quot;/s5 2-4 3&quot;,
821                         &quot;println(\&quot;s5\&quot;)\nprintln(2)\nprintln(3)\nprintln(4)\nprintln(3)&quot;,
822                         &quot;&quot;, null, &quot;s5\n2\n3\n4\n3\n&quot;, &quot;&quot;),
823                 a -&gt; assertCommand(a, &quot;/2 ff&quot;, &quot;|  No such snippet: ff&quot;),
824                 a -&gt; assertCommand(a, &quot;/4-2&quot;, &quot;|  End of snippet range less than start: 4 - 2&quot;),
825                 a -&gt; assertCommand(a, &quot;/s5-s3&quot;, &quot;|  End of snippet range less than start: s5 - s3&quot;),
826                 a -&gt; assertCommand(a, &quot;/4-s5&quot;, &quot;|  End of snippet range less than start: 4 - s5&quot;)
827         );
828     }
829 
830     @Test(enabled = false) // TODO 8158197
831     public void testHeadlessEditPad() {
832         String prevHeadless = System.getProperty(&quot;java.awt.headless&quot;);
833         try {
834             System.setProperty(&quot;java.awt.headless&quot;, &quot;true&quot;);
835             test(
836                 (a) -&gt; assertCommandOutputStartsWith(a, &quot;/edit printf&quot;, &quot;|  Cannot launch editor -- unexpected exception:&quot;)
837             );
838         } finally {
839             System.setProperty(&quot;java.awt.headless&quot;, prevHeadless==null? &quot;false&quot; : prevHeadless);
840         }
841     }
842 
843     public void testAddExports() {
844         test(false, new String[]{&quot;--no-startup&quot;},
845                 a -&gt; assertCommandOutputStartsWith(a, &quot;import jdk.internal.misc.VM;&quot;, &quot;|  Error:&quot;)
846         );
847         test(false, new String[]{&quot;--no-startup&quot;,
848                         &quot;-R--add-exports&quot;, &quot;-Rjava.base/jdk.internal.misc=ALL-UNNAMED&quot;,
849                         &quot;-C--add-exports&quot;, &quot;-Cjava.base/jdk.internal.misc=ALL-UNNAMED&quot;},
850                 a -&gt; assertImport(a, &quot;import jdk.internal.misc.VM;&quot;, &quot;&quot;, &quot;jdk.internal.misc.VM&quot;),
851                 a -&gt; assertCommand(a, &quot;System.err.println(VM.isBooted())&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;true\n&quot;)
852         );
853         test(false, new String[]{&quot;--no-startup&quot;, &quot;--add-exports&quot;, &quot;java.base/jdk.internal.misc&quot;},
854                 a -&gt; assertImport(a, &quot;import jdk.internal.misc.VM;&quot;, &quot;&quot;, &quot;jdk.internal.misc.VM&quot;),
855                 a -&gt; assertCommand(a, &quot;System.err.println(VM.isBooted())&quot;, &quot;&quot;, &quot;&quot;, null, &quot;&quot;, &quot;true\n&quot;)
856         );
857     }
858 
859     public void testRedeclareVariableNoInit() {
860         test(
861                 a -&gt; assertCommand(a, &quot;Integer a;&quot;, &quot;a ==&gt; null&quot;),
862                 a -&gt; assertCommand(a, &quot;a instanceof Integer;&quot;, &quot;$2 ==&gt; false&quot;),
863                 a -&gt; assertCommand(a, &quot;a = 1;&quot;, &quot;a ==&gt; 1&quot;),
864                 a -&gt; assertCommand(a, &quot;Integer a;&quot;, &quot;a ==&gt; null&quot;),
865                 a -&gt; assertCommand(a, &quot;a instanceof Integer;&quot;, &quot;$5 ==&gt; false&quot;),
866                 a -&gt; assertCommand(a, &quot;a&quot;, &quot;a ==&gt; null&quot;)
867         );
868      }
869 
<a name="3" id="anc3"></a>










870 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
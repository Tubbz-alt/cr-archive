<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/jdk/javadoc/lib/javadoc/tester/JavadocTester.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package javadoc.tester;
  25 
  26 import java.io.BufferedWriter;
  27 import java.io.ByteArrayOutputStream;
  28 import java.io.File;
  29 import java.io.FileNotFoundException;
  30 import java.io.FileWriter;
  31 import java.io.FilenameFilter;
  32 import java.io.IOException;
  33 import java.io.PrintStream;
  34 import java.io.PrintWriter;
  35 import java.io.StringWriter;
  36 import java.lang.annotation.Annotation;
  37 import java.lang.annotation.Retention;
  38 import java.lang.annotation.RetentionPolicy;
  39 import java.lang.ref.SoftReference;
  40 import java.lang.reflect.InvocationTargetException;
  41 import java.lang.reflect.Method;
  42 import java.nio.charset.Charset;
  43 import java.nio.charset.UnsupportedCharsetException;
  44 import java.nio.file.Files;
  45 import java.nio.file.Path;
  46 import java.nio.file.Paths;
  47 import java.util.ArrayList;
  48 import java.util.Arrays;
  49 import java.util.Collection;
  50 import java.util.Collections;
  51 import java.util.EnumMap;
  52 import java.util.HashMap;
  53 import java.util.List;
  54 import java.util.Map;
  55 import java.util.Objects;
  56 import java.util.function.Function;
  57 
  58 
  59 /**
  60  * Test framework for running javadoc and performing tests on the resulting output.
  61  *
  62  * &lt;p&gt;
  63  * Tests are typically written as subtypes of JavadocTester, with a main
  64  * method that creates an instance of the test class and calls the runTests()
  65  * method. The runTests() methods calls all the test methods declared in the class,
  66  * and then calls a method to print a summary, and throw an exception if
  67  * any of the test methods reported a failure.
  68  *
  69  * &lt;p&gt;
  70  * Test methods are identified with a @Test annotation. They have no parameters.
  71  * The name of the method is not important, but if you have more than one, it is
  72  * recommended that the names be meaningful and suggestive of the test case
  73  * contained therein.
  74  *
  75  * &lt;p&gt;
  76  * Typically, a test method will invoke javadoc, and then perform various
  77  * checks on the results. The standard checks are:
  78  *
  79  * &lt;dl&gt;
  80  * &lt;dt&gt;checkExitCode
  81  * &lt;dd&gt;Check the exit code returned from javadoc.
  82  * &lt;dt&gt;checkOutput
  83  * &lt;dd&gt;Perform a series of checks on the contents on a file or output stream
  84  *     generated by javadoc.
  85  *     The checks can be either that a series of strings are found or are not found.
  86  * &lt;dt&gt;checkFiles
  87  * &lt;dd&gt;Perform a series of checks on the files generated by javadoc.
  88  *     The checks can be that a series of files are found or are not found.
  89  * &lt;/dl&gt;
  90  *
  91  * &lt;pre&gt;&lt;code&gt;
  92  *  public class MyTester extends JavadocTester {
  93  *      public static void main(String... args) throws Exception {
  94  *          MyTester tester = new MyTester();
  95  *          tester.runTests();
  96  *      }
  97  *
  98  *      // test methods...
  99  *      {@literal @}Test
 100  *      void test() {
 101  *          javadoc(&lt;i&gt;args&lt;/i&gt;);
 102  *          checkExit(Exit.OK);
 103  *          checkOutput(&lt;i&gt;file&lt;/i&gt;, true,
 104  *              &lt;i&gt;strings-to-find&lt;/i&gt;);
 105  *          checkOutput(&lt;i&gt;file&lt;/i&gt;, false,
 106  *              &lt;i&gt;strings-to-not-find&lt;/i&gt;);
 107  *      }
 108  *  }
 109  * &lt;/code&gt;&lt;/pre&gt;
 110  *
 111  * &lt;p&gt;
 112  * If javadoc is run more than once in a test method, you can compare the
 113  * results that are generated with the diff method. Since files written by
 114  * javadoc typically contain a timestamp, you may want to use the -notimestamp
 115  * option if you are going to compare the results from two runs of javadoc.
 116  *
 117  * &lt;p&gt;
 118  * If you have many calls of checkOutput that are very similar, you can write
 119  * your own check... method to reduce the amount of duplication. For example,
 120  * if you want to check that many files contain the same string, you could
 121  * write a method that takes a varargs list of files and calls checkOutput
 122  * on each file in turn with the string to be checked.
 123  *
 124  * &lt;p&gt;
 125  * You can also write you own custom check methods, which can use
 126  * readFile to get the contents of a file generated by javadoc,
 127  * and then use pass(...) or fail(...) to report whether the check
 128  * succeeded or not.
 129  *
 130  * &lt;p&gt;
 131  * You can have many separate test methods, each identified with a @Test
 132  * annotation. However, you should &lt;b&gt;not&lt;/b&gt; assume they will be called
 133  * in the order declared in your source file.  If the order of a series
 134  * of javadoc invocations is important, do that within a single method.
 135  * If the invocations are independent, for better clarity, use separate
 136  * test methods, each with their own set of checks on the results.
 137  */
 138 public abstract class JavadocTester {
 139 
 140     public static final String FS = System.getProperty(&quot;file.separator&quot;);
 141     public static final String PS = System.getProperty(&quot;path.separator&quot;);
 142     public static final String NL = System.getProperty(&quot;line.separator&quot;);
 143     public static final String thisRelease = System.getProperty(&quot;java.specification.version&quot;);
 144 
 145     public static final Path currDir = Paths.get(&quot;.&quot;).toAbsolutePath().normalize();
 146 
 147     public enum Output {
 148         /** The name of the output stream from javadoc. */
 149         OUT,
 150         /** The name for any output written to System.out. */
 151         STDOUT,
 152         /** The name for any output written to System.err. */
 153         STDERR
 154     }
 155 
 156     /** The output directory used in the most recent call of javadoc. */
 157     protected File outputDir;
 158 
 159     /** The output charset used in the most recent call of javadoc. */
 160     protected Charset charset = Charset.defaultCharset();
 161 
 162     /** The exit code of the most recent call of javadoc. */
 163     private int exitCode;
 164 
 165     /** The output generated by javadoc to the various writers and streams. */
 166     private final Map&lt;Output, String&gt; outputMap = new EnumMap&lt;&gt;(Output.class);
 167 
 168     /** A cache of file content, to avoid reading files unnecessarily. */
 169     private final Map&lt;File,SoftReference&lt;String&gt;&gt; fileContentCache = new HashMap&lt;&gt;();
 170     /** The charset used for files in the fileContentCache. */
 171     private Charset fileContentCacheCharset = null;
 172 
 173     /** Stream used for logging messages. */
 174     protected final PrintStream out = System.out;
 175 
 176     /** The directory containing the source code for the test. */
 177     public static final String testSrc = System.getProperty(&quot;test.src&quot;);
 178 
 179     /**
 180      * Get the path for a source file in the test source directory.
 181      * @param path the path of a file or directory in the source directory
 182      * @return the full path of the specified file
 183      */
 184     public static String testSrc(String path) {
 185         return new File(testSrc, path).getPath();
 186     }
 187 
 188     /**
 189      * Alternatives for checking the contents of a directory.
 190      */
 191     public enum DirectoryCheck {
 192         /**
 193          * Check that the directory is empty.
 194          */
 195         EMPTY((file, name) -&gt; true),
 196         /**
 197          * Check that the directory does not contain any HTML files,
 198          * such as may have been generated by a prior run of javadoc
 199          * using this directory.
 200          * For now, the check is only performed on the top level directory.
 201          */
 202         NO_HTML_FILES((file, name) -&gt; name.endsWith(&quot;.html&quot;)),
 203         /**
 204          * No check is performed on the directory contents.
 205          */
 206         NONE(null) { @Override void check(File dir) { } };
 207 
 208         /** The filter used to detect that files should &lt;i&gt;not&lt;/i&gt; be present. */
 209         FilenameFilter filter;
 210 
 211         DirectoryCheck(FilenameFilter f) {
 212             filter = f;
 213         }
 214 
 215         void check(File dir) {
 216             if (dir.isDirectory()) {
 217                 String[] contents = dir.list(filter);
 218                 if (contents == null)
 219                     throw new Error(&quot;cannot list directory: &quot; + dir);
 220                 if (contents.length &gt; 0) {
 221                     System.err.println(&quot;Found extraneous files in dir:&quot; + dir.getAbsolutePath());
 222                     for (String x : contents) {
 223                         System.err.println(x);
 224                     }
 225                     throw new Error(&quot;directory has unexpected content: &quot; + dir);
 226                 }
 227             }
 228         }
 229     }
 230 
 231     private DirectoryCheck outputDirectoryCheck = DirectoryCheck.EMPTY;
 232 
 233     private boolean automaticCheckAccessibility = true;
 234     private boolean automaticCheckLinks = true;
 235 
 236     /** The current subtest number. Incremented when checking(...) is called. */
 237     private int numTestsRun = 0;
 238 
 239     /** The number of subtests passed. Incremented when passed(...) is called. */
 240     private int numTestsPassed = 0;
 241 
 242     /** The current run of javadoc. Incremented when javadoc is called. */
 243     private int javadocRunNum = 0;
 244 
 245     /** The current subtest number for this run of javadoc. Incremented when checking(...) is called. */
 246     private int javadocTestNum = 0;
 247 
 248     /** Marker annotation for test methods to be invoked by runTests. */
 249     @Retention(RetentionPolicy.RUNTIME)
 250     public @interface Test { }
 251 
 252     /**
 253      * Run all methods annotated with @Test, followed by printSummary.
 254      * Typically called on a tester object in main()
 255      * @throws Exception if any errors occurred
 256      */
 257     public void runTests() throws Exception {
 258         runTests(m -&gt; new Object[0]);
 259     }
 260 
 261     /**
 262      * Runs all methods annotated with @Test, followed by printSummary.
 263      * Typically called on a tester object in main()
 264      * @param f a function which will be used to provide arguments to each
 265      *          invoked method
 266      * @throws Exception if any errors occurred
 267      */
 268     public void runTests(Function&lt;Method, Object[]&gt; f) throws Exception {
 269         for (Method m: getClass().getDeclaredMethods()) {
 270             Annotation a = m.getAnnotation(Test.class);
 271             if (a != null) {
 272                 try {
 273                     out.println(&quot;Running test &quot; + m.getName());
 274                     m.invoke(this, f.apply(m));
 275                 } catch (InvocationTargetException e) {
 276                     Throwable cause = e.getCause();
 277                     throw (cause instanceof Exception) ? ((Exception) cause) : e;
 278                 }
 279                 out.println();
 280             }
 281         }
 282         printSummary();
 283     }
 284 
 285     /**
 286      * Runs javadoc.
 287      * The output directory used by this call and the final exit code
 288      * will be saved for later use.
 289      * To aid the reader, it is recommended that calls to this method
 290      * put each option and the arguments it takes on a separate line.
 291      *
 292      * Example:
 293      * &lt;pre&gt;&lt;code&gt;
 294      *  javadoc(&quot;-d&quot;, &quot;out&quot;,
 295      *          &quot;-sourcepath&quot;, testSrc,
 296      *          &quot;-notimestamp&quot;,
 297      *          &quot;pkg1&quot;, &quot;pkg2&quot;, &quot;pkg3/C.java&quot;);
 298      * &lt;/code&gt;&lt;/pre&gt;
 299      *
 300      * @param args the arguments to pass to javadoc
 301      */
 302     public void javadoc(String... args) {
 303         outputMap.clear();
 304         fileContentCache.clear();
 305 
 306         javadocRunNum++;
 307         javadocTestNum = 0; // reset counter for this run of javadoc
 308         if (javadocRunNum == 1) {
 309             out.println(&quot;Running javadoc...&quot;);
 310         } else {
 311             out.println(&quot;Running javadoc (run &quot;+ javadocRunNum + &quot;)...&quot;);
 312         }
 313 
 314         outputDir = new File(&quot;.&quot;);
 315         String charsetArg = null;
 316         String docencodingArg = null;
 317         String encodingArg = null;
 318         for (int i = 0; i &lt; args.length - 2; i++) {
 319             switch (args[i]) {
 320                 case &quot;-d&quot;:
 321                     outputDir = new File(args[++i]);
 322                     break;
 323                 case &quot;-charset&quot;:
 324                     charsetArg = args[++i];
 325                     break;
 326                 case &quot;-docencoding&quot;:
 327                     docencodingArg = args[++i];
 328                     break;
 329                 case &quot;-encoding&quot;:
 330                     encodingArg = args[++i];
 331                     break;
 332             }
 333         }
 334 
 335         // The following replicates HtmlConfiguration.finishOptionSettings0
 336         // and sets up the charset used to read files.
 337         String cs;
 338         if (docencodingArg == null) {
 339             if (charsetArg == null) {
 340                 cs = (encodingArg == null) ? &quot;UTF-8&quot; : encodingArg;
 341             } else {
 342                 cs = charsetArg;
 343             }
 344         } else {
 345            cs = docencodingArg;
 346         }
 347         try {
 348             charset = Charset.forName(cs);
 349         } catch (UnsupportedCharsetException e) {
 350             charset = Charset.defaultCharset();
 351         }
 352 
 353         out.println(&quot;args: &quot; + Arrays.toString(args));
 354 //        log.setOutDir(outputDir);
 355 
 356         outputDirectoryCheck.check(outputDir);
 357 
 358         // This is the sole stream used by javadoc
 359         WriterOutput outOut = new WriterOutput();
 360 
 361         // These are to catch output to System.out and System.err,
 362         // in case these are used instead of the primary streams
 363         StreamOutput sysOut = new StreamOutput(System.out, System::setOut);
 364         StreamOutput sysErr = new StreamOutput(System.err, System::setErr);
 365 
 366         try {
 367             exitCode = jdk.javadoc.internal.tool.Main.execute(args, outOut.pw);
 368         } finally {
 369             outputMap.put(Output.STDOUT, sysOut.close());
 370             outputMap.put(Output.STDERR, sysErr.close());
 371             outputMap.put(Output.OUT, outOut.close());
 372         }
 373 
 374         outputMap.forEach((name, text) -&gt; {
 375             if (!text.isEmpty()) {
 376                 out.println(&quot;javadoc &quot; + name + &quot;:&quot;);
 377                 out.println(text);
 378             }
 379         });
 380 
 381         if (exitCode == Exit.OK.code &amp;&amp; outputDir.exists()) {
 382             if (automaticCheckLinks) {
 383                 checkLinks();
 384             }
 385             if (automaticCheckAccessibility) {
 386                 checkAccessibility();
 387             }
 388         }
 389     }
 390 
 391     /**
 392      * Sets the kind of check for the initial contents of the output directory
 393      * before javadoc is run.
 394      * The filter should return true for files that should &lt;b&gt;not&lt;/b&gt; appear.
 395      * @param c the kind of check to perform
 396      */
 397     public void setOutputDirectoryCheck(DirectoryCheck c) {
 398         outputDirectoryCheck = c;
 399     }
 400 
 401     /**
 402      * Sets whether or not to perform an automatic call of checkAccessibility.
 403      */
 404     public void setAutomaticCheckAccessibility(boolean b) {
 405         automaticCheckAccessibility = b;
 406     }
 407 
 408     /**
 409      * Sets whether or not to perform an automatic call of checkLinks.
 410      */
 411     public void setAutomaticCheckLinks(boolean b) {
 412         automaticCheckLinks = b;
 413     }
 414 
 415     /**
 416      * The exit codes returned by the javadoc tool.
 417      * @see jdk.javadoc.internal.tool.Main.Result
 418      */
 419     public enum Exit {
 420         OK(0),        // Javadoc completed with no errors.
 421         ERROR(1),     // Completed but reported errors.
 422         CMDERR(2),    // Bad command-line arguments
 423         SYSERR(3),    // System error or resource exhaustion.
 424         ABNORMAL(4);  // Javadoc terminated abnormally
 425 
 426         Exit(int code) {
 427             this.code = code;
 428         }
 429 
 430         final int code;
 431 
 432         @Override
 433         public String toString() {
 434             return name() + &#39;(&#39; + code + &#39;)&#39;;
 435         }
 436     }
 437 
 438     /**
 439      * Checks the exit code of the most recent call of javadoc.
 440      *
 441      * @param expected the exit code that is required for the test
 442      * to pass.
 443      */
 444     public void checkExit(Exit expected) {
 445         checking(&quot;check exit code&quot;);
 446         if (exitCode == expected.code) {
 447             passed(&quot;return code &quot; + exitCode);
 448         } else {
 449             failed(&quot;return code &quot; + exitCode +&quot;; expected &quot; + expected);
 450         }
 451     }
 452 
 453     /**
 454      * Checks for content in (or not in) the generated output.
 455      * Within the search strings, the newline character \n
 456      * will be translated to the platform newline character sequence.
 457      * @param path a path within the most recent output directory
 458      *  or the name of one of the output buffers, identifying
 459      *  where to look for the search strings.
 460      * @param expectedFound true if all of the search strings are expected
 461      *  to be found, or false if the file is not expected to be found
 462      * @param strings the strings to be searched for
 463      */
 464     public void checkFileAndOutput(String path, boolean expectedFound, String... strings) {
 465         if (expectedFound) {
 466             checkOutput(path, true, strings);
 467         } else {
 468             checkFiles(false, path);
 469         }
 470     }
 471 
 472     /**
 473      * Checks for content in (or not in) the generated output.
 474      * Within the search strings, the newline character \n
 475      * will be translated to the platform newline character sequence.
 476      * @param path a path within the most recent output directory, identifying
 477      *  where to look for the search strings.
 478      * @param expectedFound true if all of the search strings are expected
 479      *  to be found, or false if all of the strings are expected to be
 480      *  not found
 481      * @param strings the strings to be searched for
 482      */
 483     public void checkOutput(String path, boolean expectedFound, String... strings) {
 484         // Read contents of file
 485         try {
 486             String fileString = readFile(outputDir, path);
 487             checkOutput(new File(outputDir, path).getPath(), fileString, expectedFound, strings);
 488         } catch (Error e) {
 489             checking(&quot;Read file&quot;);
 490             failed(&quot;Error reading file: &quot; + e);
 491         }
 492     }
 493 
 494     /**
 495      * Checks for content in (or not in) the one of the output streams written by
 496      * javadoc. Within the search strings, the newline character \n
 497      * will be translated to the platform newline character sequence.
 498      * @param output the output stream to check
 499      * @param expectedFound true if all of the search strings are expected
 500      *  to be found, or false if all of the strings are expected to be
 501      *  not found
 502      * @param strings the strings to be searched for
 503      */
 504     public void checkOutput(Output output, boolean expectedFound, String... strings) {
 505         checkOutput(output.toString(), outputMap.get(output), expectedFound, strings);
 506     }
 507 
 508     // NOTE: path may be the name of an Output stream as well as a file path
 509     private void checkOutput(String path, String fileString, boolean expectedFound, String... strings) {
 510         for (String stringToFind : strings) {
 511 //            log.logCheckOutput(path, expectedFound, stringToFind);
 512             checking(&quot;checkOutput&quot;);
 513             // Find string in file&#39;s contents
 514             boolean isFound = findString(fileString, stringToFind);
 515             if (isFound == expectedFound) {
 516                 passed(path + &quot;: following text &quot; + (isFound ? &quot;found:&quot; : &quot;not found:&quot;) + &quot;\n&quot;
 517                         + stringToFind);
 518             } else {
 519                 failed(path + &quot;: following text &quot; + (isFound ? &quot;found:&quot; : &quot;not found:&quot;) + &quot;\n&quot;
 520                         + stringToFind + &#39;\n&#39; +
 521                         &quot;found \n&quot; +
 522                         fileString);
 523             }
 524         }
 525     }
 526 
 527     /**
 528      * Performs some structural accessibility checks on the files generated by the most
 529      * recent run of javadoc.
 530      * The checks can be run automatically by calling {@link #setAutomaticCheckAccessibility}.
 531      */
 532     public void checkAccessibility() {
 533         checking(&quot;Check accessibility&quot;);
 534         A11yChecker c = new A11yChecker(out, this::readFile);
 535         try {
 536             c.checkDirectory(outputDir.toPath());
 537             c.report();
 538             int errors = c.getErrorCount();
 539             if (errors == 0) {
 540                 passed(&quot;No accessibility errors found&quot;);
 541             } else {
 542                 failed(errors + &quot; errors found when checking accessibility&quot;);
 543             }
 544         } catch (IOException e) {
 545             failed(&quot;exception thrown when reading files: &quot; + e);
 546         }
 547     }
 548 
 549     /**
 550      * Checks all the links within the files generated by the most
 551      * recent run of javadoc.
 552      * The checks can be run automatically by calling {@link #setAutomaticCheckLinks}.
 553      */
 554     public void checkLinks() {
 555         checking(&quot;Check links&quot;);
 556         LinkChecker c = new LinkChecker(out, this::readFile);
 557         try {
 558             c.checkDirectory(outputDir.toPath());
 559             c.report();
 560             int errors = c.getErrorCount();
 561             if (errors == 0) {
 562                 passed(&quot;Links are OK&quot;);
 563             } else {
 564                 failed(errors + &quot; errors found when checking links&quot;);
 565             }
 566         } catch (IOException e) {
 567             failed(&quot;exception thrown when reading files: &quot; + e);
 568         }
 569     }
 570 
 571     /**
 572      * Shows the heading structure for each of the specified files.
 573      * The structure is is printed in plain text to the main output stream.
 574      * No errors are reported (unless there is a problem reading a file)
 575      * but missing headings are noted within the output.
 576      * @params the files
 577      */
 578     public void showHeadings(String... paths) {
 579         ShowHeadings s = new ShowHeadings(out, this::readFile);
 580         for (String p : paths) {
 581             try {
 582                 File f = new File(outputDir, p);
 583                 s.checkFiles(List.of(f.toPath()), false, Collections.emptySet());
 584             } catch (IOException e) {
 585                 checking(&quot;Read file&quot;);
 586                 failed(&quot;Error reading file: &quot; + e);
 587             }
 588         }
 589     }
 590 
 591     /**
 592      * Gets the content of the one of the output streams written by javadoc.
 593      * @param output the name of the output stream
 594      * @return the content of the output stream
 595      */
 596     public String getOutput(Output output) {
 597         return outputMap.get(output);
 598     }
 599 
 600     /**
 601      * Gets the content of the one of the output streams written by javadoc.
 602      * @param output the name of the output stream
 603      * @return the content of the output stream, as a line of lines
 604      */
 605     public List&lt;String&gt; getOutputLines(Output output) {
 606         String text = outputMap.get(output);
 607         return (text == null) ? Collections.emptyList() : Arrays.asList(text.split(NL));
 608     }
 609 
 610     /**
 611      * Checks for files in (or not in) the generated output.
 612      * @param expectedFound true if all of the files are expected
 613      *  to be found, or false if all of the files are expected to be
 614      *  not found
 615      * @param paths the files to check, within the most recent output directory.
 616      * */
 617     public void checkFiles(boolean expectedFound, String... paths) {
 618         checkFiles(expectedFound, Arrays.asList(paths));
 619     }
 620 
 621     /**
 622      * Checks for files in (or not in) the generated output.
 623      * @param expectedFound true if all of the files are expected
 624      *  to be found, or false if all of the files are expected to be
 625      *  not found
 626      * @param paths the files to check, within the most recent output directory.
 627      * */
 628     public void checkFiles(boolean expectedFound, Collection&lt;String&gt; paths) {
 629         for (String path: paths) {
 630 //            log.logCheckFile(path, expectedFound);
 631             checking(&quot;checkFile&quot;);
 632             File file = new File(outputDir, path);
 633             boolean isFound = file.exists();
 634             if (isFound == expectedFound) {
 635                 passed(file, &quot;file &quot; + (isFound ? &quot;found:&quot; : &quot;not found:&quot;) + &quot;\n&quot;);
 636             } else {
 637                 failed(file, &quot;file &quot; + (isFound ? &quot;found:&quot; : &quot;not found:&quot;) + &quot;\n&quot;);
 638             }
 639         }
 640     }
 641 
 642     /**
 643      * Checks that a series of strings are found in order in a file in
 644      * the generated output.
 645      * @param path the file to check
 646      * @param strings  the strings whose order to check
 647      */
 648     public void checkOrder(String path, String... strings) {
 649         File file = new File(outputDir, path);
 650         String fileString = readOutputFile(path);
 651         int prevIndex = -1;
 652         for (String s : strings) {
 653             s = s.replace(&quot;\n&quot;, NL); // normalize new lines
 654             int currentIndex = fileString.indexOf(s, prevIndex + 1);
 655             checking(&quot;file: &quot; + file + &quot;: &quot; + s + &quot; at index &quot; + currentIndex);
 656             if (currentIndex == -1) {
 657                 failed(file, s + &quot; not found.&quot;);
 658                 continue;
 659             }
 660             if (currentIndex &gt; prevIndex) {
 661                 passed(file, s + &quot; is in the correct order&quot;);
 662             } else {
 663                 failed(file, s + &quot; is in the wrong order.&quot;);
 664             }
 665             prevIndex = currentIndex;
 666         }
 667     }
 668 
 669     /**
 670      * Ensures that a series of strings appear only once, in the generated output,
 671      * noting that, this test does not exhaustively check for all other possible
 672      * duplicates once one is found.
 673      * @param path the file to check
 674      * @param strings ensure each are unique
 675      */
 676     public void checkUnique(String path, String... strings) {
 677         File file = new File(outputDir, path);
 678         String fileString = readOutputFile(path);
 679         for (String s : strings) {
 680             int currentIndex = fileString.indexOf(s);
 681             checking(s + &quot; at index &quot; + currentIndex);
 682             if (currentIndex == -1) {
 683                 failed(file, s + &quot; not found.&quot;);
 684                 continue;
 685             }
 686             int nextindex = fileString.indexOf(s, currentIndex + s.length());
 687             if (nextindex == -1) {
 688                 passed(file, s + &quot; is unique&quot;);
 689             } else {
 690                 failed(file, s + &quot; is not unique, found at &quot; + nextindex);
 691             }
 692         }
 693     }
 694 
 695     /**
 696      * Compares a set of files in each of two directories.
 697      *
 698      * @param baseDir1 the directory containing the first set of files
 699      * @param baseDir2 the directory containing the second set of files
 700      * @param files the set of files to be compared
 701      */
 702     public void diff(String baseDir1, String baseDir2, String... files) {
 703         File bd1 = new File(baseDir1);
 704         File bd2 = new File(baseDir2);
 705         for (String file : files) {
 706             diff(bd1, bd2, file);
 707         }
 708     }
 709 
 710     /**
 711      * Copies a directory from one place to another.
 712      *
 713      * @param targetDir the directory to copy.
 714      * @param destDir the destination to copy the directory to.
 715      */
 716     // TODO: convert to using java.nio.Files.walkFileTree
 717     public void copyDir(String targetDir, String destDir) {
 718         try {
 719             File targetDirObj = new File(targetDir);
 720             File destDirParentObj = new File(destDir);
 721             File destDirObj = new File(destDirParentObj, targetDirObj.getName());
 722             if (! destDirParentObj.exists()) {
 723                 destDirParentObj.mkdir();
 724             }
 725             if (! destDirObj.exists()) {
 726                 destDirObj.mkdir();
 727             }
 728             String[] files = targetDirObj.list();
 729             for (String file : files) {
 730                 File srcFile = new File(targetDirObj, file);
 731                 File destFile = new File(destDirObj, file);
 732                 if (srcFile.isFile()) {
 733                     out.println(&quot;Copying &quot; + srcFile + &quot; to &quot; + destFile);
 734                     copyFile(destFile, srcFile);
 735                 } else if(srcFile.isDirectory()) {
 736                     copyDir(srcFile.getAbsolutePath(), destDirObj.getAbsolutePath());
 737                 }
 738             }
 739         } catch (IOException exc) {
 740             throw new Error(&quot;Could not copy &quot; + targetDir + &quot; to &quot; + destDir);
 741         }
 742     }
 743 
 744     /**
 745      * Copies a file.
 746      *
 747      * @param destfile the destination file
 748      * @param srcfile the source file
 749      * @throws IOException
 750      */
 751     public void copyFile(File destfile, File srcfile) throws IOException {
 752         Files.copy(srcfile.toPath(), destfile.toPath());
 753     }
 754 
 755     /**
 756      * Read a file from the output directory.
 757      *
 758      * @param fileName  the name of the file to read
 759      * @return          the file in string format
 760      */
 761     public String readOutputFile(String fileName) throws Error {
 762         return readFile(outputDir, fileName);
 763     }
 764 
 765     protected String readFile(String fileName) throws Error {
 766         return readFile(outputDir, fileName);
 767     }
 768 
 769     protected String readFile(String baseDir, String fileName) throws Error {
 770         return readFile(new File(baseDir), fileName);
 771     }
 772 
 773     protected String readFile(Path file) {
 774         File baseDir;
 775         if (file.startsWith(outputDir.toPath())) {
 776             baseDir = outputDir;
 777         } else if (file.startsWith(currDir)) {
 778             baseDir = currDir.toFile();
 779         } else {
 780             baseDir = file.getParent().toFile();
 781         }
 782         String fileName = baseDir.toPath().relativize(file).toString();
 783         return readFile(baseDir, fileName);
 784     }
 785 
 786     /**
 787      * Reads the file and return it as a string.
 788      *
 789      * @param baseDir   the directory in which to locate the file
 790      * @param fileName  the name of the file to read
 791      * @return          the file in string format
 792      */
 793     private String readFile(File baseDir, String fileName) throws Error {
 794         if (!Objects.equals(fileContentCacheCharset, charset)) {
 795             fileContentCache.clear();
 796             fileContentCacheCharset = charset;
 797         }
 798         try {
 799             File file = new File(baseDir, fileName);
 800             SoftReference&lt;String&gt; ref = fileContentCache.get(file);
 801             String content = (ref == null) ? null : ref.get();
 802             if (content != null)
 803                 return content;
 804 
 805             // charset defaults to a value inferred from latest javadoc run
 806             content = new String(Files.readAllBytes(file.toPath()), charset);
 807             fileContentCache.put(file, new SoftReference&lt;&gt;(content));
 808             return content;
 809         } catch (FileNotFoundException e) {
 810             throw new Error(&quot;File not found: &quot; + fileName + &quot;: &quot; + e);
 811         } catch (IOException e) {
 812             throw new Error(&quot;Error reading file: &quot; + fileName + &quot;: &quot; + e);
 813         }
 814     }
 815 
 816     protected void checking(String message) {
 817         numTestsRun++;
 818         javadocTestNum++;
 819         print(&quot;Starting subtest &quot; + javadocRunNum + &quot;.&quot; + javadocTestNum, message);
 820     }
 821 
 822     protected void passed(File file, String message) {
 823         passed(file + &quot;: &quot; + message);
 824     }
 825 
 826     protected void passed(String message) {
 827         numTestsPassed++;
 828         print(&quot;Passed&quot;, message);
 829         out.println();
 830     }
 831 
 832     protected void failed(File file, String message) {
 833         failed(file + &quot;: &quot; + message);
 834     }
 835 
 836     protected void failed(String message) {
 837         print(&quot;FAILED&quot;, message);
 838         StackWalker.getInstance().walk(s -&gt; {
 839             s.dropWhile(f -&gt; f.getMethodName().equals(&quot;failed&quot;))
 840                     .takeWhile(f -&gt; !f.getMethodName().equals(&quot;runTests&quot;))
 841                     .forEach(f -&gt; out.println(&quot;        at &quot;
 842                             + f.getClassName() + &quot;.&quot; + f.getMethodName()
 843                             + &quot;(&quot; + f.getFileName() + &quot;:&quot; + f.getLineNumber() + &quot;)&quot;));
 844             return null;
 845         });
 846         out.println();
 847     }
 848 
 849     private void print(String prefix, String message) {
 850         if (message.isEmpty())
 851             out.println(prefix);
 852         else {
 853             out.print(prefix);
 854             out.print(&quot;: &quot;);
 855             out.print(message.replace(&quot;\n&quot;, NL));
 856             if (!(message.endsWith(&quot;\n&quot;) || message.endsWith(NL))) {
 857                 out.println();
 858             }
 859         }
 860     }
 861 
 862     /**
 863      * Prints a summary of the test results.
 864      */
 865     protected void printSummary() {
 866         String javadocRuns = (javadocRunNum &lt;= 1) ? &quot;&quot;
 867                 : &quot;, in &quot; + javadocRunNum + &quot; runs of javadoc&quot;;
 868 
 869         if (numTestsRun != 0 &amp;&amp; numTestsPassed == numTestsRun) {
 870             // Test passed
 871             out.println();
 872             out.println(&quot;All &quot; + numTestsPassed + &quot; subtests passed&quot; + javadocRuns);
 873         } else {
 874             // Test failed
 875             throw new Error((numTestsRun - numTestsPassed)
 876                     + &quot; of &quot; + (numTestsRun)
 877                     + &quot; subtests failed&quot;
 878                     + javadocRuns);
 879         }
 880     }
 881 
 882     /**
 883      * Searches for the string in the given file and return true
 884      * if the string was found.
 885      *
 886      * @param fileString    the contents of the file to search through
 887      * @param stringToFind  the string to search for
 888      * @return              true if the string was found
 889      */
 890     private boolean findString(String fileString, String stringToFind) {
 891         // javadoc (should) always use the platform newline sequence,
 892         // but in the strings to find it is more convenient to use the Java
 893         // newline character. So we translate \n to NL before we search.
 894         stringToFind = stringToFind.replace(&quot;\n&quot;, NL);
 895         return fileString.contains(stringToFind);
 896     }
 897 
 898     /**
 899      * Compares the two given files.
 900      *
 901      * @param baseDir1 the directory in which to locate the first file
 902      * @param baseDir2 the directory in which to locate the second file
 903      * @param file the file to compare in the two base directories
 904      * an error if the files do not match.
 905      * @return true if the files are the same and false otherwise.
 906      */
 907     private void diff(File baseDir1, File baseDir2, String file) {
 908         String file1Contents = readFile(baseDir1, file);
 909         String file2Contents = readFile(baseDir2, file);
 910         checking(&quot;diff &quot; + new File(baseDir1, file) + &quot;, &quot; + new File(baseDir2, file));
 911         if (file1Contents.trim().compareTo(file2Contents.trim()) == 0) {
 912             passed(&quot;files are equal&quot;);
 913         } else {
 914             failed(&quot;files differ&quot;);
 915         }
 916     }
 917 
 918     /**
 919      * Utility class to simplify the handling of temporarily setting a
 920      * new stream for System.out or System.err.
 921      */
 922     private static class StreamOutput {
 923         // functional interface to set a stream.
 924         private interface Initializer {
 925             void set(PrintStream s);
 926         }
 927 
 928         private final ByteArrayOutputStream baos = new ByteArrayOutputStream();
 929         private final PrintStream ps = new PrintStream(baos);
 930         private final PrintStream prev;
 931         private final Initializer init;
 932 
 933         StreamOutput(PrintStream s, Initializer init) {
 934             prev = s;
 935             init.set(ps);
 936             this.init = init;
 937         }
 938 
 939         String close() {
 940             init.set(prev);
 941             ps.close();
 942             return baos.toString();
 943         }
 944     }
 945 
 946     /**
 947      * Utility class to simplify the handling of creating an in-memory PrintWriter.
 948      */
 949     private static class WriterOutput {
 950         private final StringWriter sw = new StringWriter();
 951         final PrintWriter pw = new PrintWriter(sw);
 952         String close() {
 953             pw.close();
 954             return sw.toString();
 955         }
 956     }
 957 
 958 
 959 //    private final Logger log = new Logger();
 960 
 961     //--------- Logging --------------------------------------------------------
 962     //
 963     // This class writes out the details of calls to checkOutput and checkFile
 964     // in a canonical way, so that the resulting file can be checked against
 965     // similar files from other versions of JavadocTester using the same logging
 966     // facilities.
 967 
 968     static class Logger {
 969         private static final int PREFIX = 40;
 970         private static final int SUFFIX = 20;
 971         private static final int MAX = PREFIX + SUFFIX;
 972         List&lt;String&gt; tests = new ArrayList&lt;&gt;();
 973         String outDir;
 974         String rootDir = rootDir();
 975 
 976         static String rootDir() {
 977             File f = new File(&quot;.&quot;).getAbsoluteFile();
 978             while (!new File(f, &quot;.hg&quot;).exists())
 979                 f = f.getParentFile();
 980             return f.getPath();
 981         }
 982 
 983         void setOutDir(File outDir) {
 984             this.outDir = outDir.getPath();
 985         }
 986 
 987         void logCheckFile(String file, boolean positive) {
 988             // Strip the outdir because that will typically not be the same
 989             if (file.startsWith(outDir + &quot;/&quot;))
 990                 file = file.substring(outDir.length() + 1);
 991             tests.add(file + &quot; &quot; + positive);
 992         }
 993 
 994         void logCheckOutput(String file, boolean positive, String text) {
 995             // Compress the string to be displayed in the log file
 996             String simpleText = text.replaceAll(&quot;\\s+&quot;, &quot; &quot;).replace(rootDir, &quot;[ROOT]&quot;);
 997             if (simpleText.length() &gt; MAX)
 998                 simpleText = simpleText.substring(0, PREFIX)
 999                         + &quot;...&quot; + simpleText.substring(simpleText.length() - SUFFIX);
1000             // Strip the outdir because that will typically not be the same
1001             if (file.startsWith(outDir + &quot;/&quot;))
1002                 file = file.substring(outDir.length() + 1);
1003             // The use of text.hashCode ensure that all of &quot;text&quot; is taken into account
1004             tests.add(file + &quot; &quot; + positive + &quot; &quot; + text.hashCode() + &quot; &quot; + simpleText);
1005         }
1006 
1007         void write() {
1008             // sort the log entries because the subtests may not be executed in the same order
1009             tests.sort((a, b) -&gt; a.compareTo(b));
1010             try (BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;tester.log&quot;))) {
1011                 for (String t: tests) {
1012                     bw.write(t);
1013                     bw.newLine();
1014                 }
1015             } catch (IOException e) {
1016                 throw new Error(&quot;problem writing log: &quot; + e);
1017             }
1018         }
1019     }
1020 
1021     // Support classes for checkLinks
1022 
1023 }
    </pre>
  </body>
</html>
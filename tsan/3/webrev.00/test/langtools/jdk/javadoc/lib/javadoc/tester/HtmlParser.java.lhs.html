<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/jdk/javadoc/lib/javadoc/tester/HtmlParser.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package javadoc.tester;
 25 
 26 import java.io.IOException;
 27 import java.io.PrintStream;
 28 import java.io.StringReader;
 29 import java.nio.file.Path;
 30 import java.util.LinkedHashMap;
 31 import java.util.Locale;
 32 import java.util.Map;
 33 import java.util.function.Function;
 34 import java.util.regex.Pattern;
 35 
 36 /**
 37  * A basic HTML parser. Override the protected methods as needed to get notified
 38  * of significant items in any file that is read.
 39  */
 40 public abstract class HtmlParser {
 41 
 42     protected final PrintStream out;
 43     protected final Function&lt;Path,String&gt; fileReader;
 44 
 45     private Path file;
 46     private StringReader in;
 47     private int ch;
 48     private int lineNumber;
 49     private boolean inScript;
 50     private boolean xml;
 51 
 52     HtmlParser(PrintStream out, Function&lt;Path,String&gt; fileReader) {
 53         this.out = out;
 54         this.fileReader = fileReader;
 55     }
 56 
 57     /**
 58      * Read a file.
 59      * @param file the file to be read
 60      * @throws IOException if an error occurs while reading the file
 61      */
 62     void read(Path file) throws IOException {
 63         try (StringReader r = new StringReader(fileReader.apply(file))) {
 64             this.file = file;
 65             this.in = r;
 66             StringBuilder content = new StringBuilder();
 67 
 68             startFile(file);
 69             try {
 70                 lineNumber = 1;
 71                 xml = false;
 72                 nextChar();
 73 
 74                 while (ch != -1) {
 75                     switch (ch) {
 76 
 77                         case &#39;&lt;&#39;:
 78                             content(content.toString());
 79                             content.setLength(0);
 80                             html();
 81                             break;
 82 
 83                         default:
 84                             content.append((char) ch);
 85                             if (ch == &#39;\n&#39;) {
 86                                 content(content.toString());
 87                                 content.setLength(0);
 88                             }
 89                             nextChar();
 90                     }
 91                 }
 92             } finally {
 93                 endFile();
 94             }
 95         } catch (IOException e) {
 96             error(file, lineNumber, e);
 97         } catch (Throwable t) {
 98             error(file, lineNumber, t);
 99             t.printStackTrace(out);
100         }
101     }
102 
103 
<a name="1" id="anc1"></a><span class="line-modified">104     int getLineNumber() {</span>
105         return lineNumber;
106     }
107 
108     /**
109      * Called when a file has been opened, before parsing begins.
110      * This is always the first notification when reading a file.
111      * This implementation does nothing.
112      *
113      * @param file the file
114      */
115     protected void startFile(Path file) { }
116 
117     /**
118      * Called when the parser has finished reading a file.
119      * This is always the last notification when reading a file,
120      * unless any errors occur while closing the file.
121      * This implementation does nothing.
122      */
123     protected void endFile() { }
124 
125     /**
126      * Called when a doctype declaration is found, at the beginning of the file.
127      * This implementation does nothing.
128      * @param s the doctype declaration
129      */
130     protected void docType(String s) { }
131 
132     /**
133      * Called when the opening tag of an HTML element is encountered.
134      * This implementation does nothing.
135      * @param name the name of the tag
136      * @param attrs the attribute
137      * @param selfClosing whether or not this is a self-closing tag
138      */
139     protected void startElement(String name, Map&lt;String,String&gt; attrs, boolean selfClosing) { }
140 
141     /**
142      * Called when the closing tag of an HTML tag is encountered.
143      * This implementation does nothing.
144      * @param name the name of the tag
145      */
146     protected void endElement(String name) { }
147 
148     /**
149      * Called for sequences of character content.
150      * @param content the character content
151      */
152     protected void content(String content) { }
153 
154     /**
155      * Called when an error has been encountered.
156      * @param file the file being read
157      * @param lineNumber the line number of line containing the error
158      * @param message a description of the error
159      */
160     protected void error(Path file, int lineNumber, String message) {
161         out.println(file + &quot;:&quot; + lineNumber + &quot;: &quot; + message);
162     }
163 
164     /**
165      * Called when an exception has been encountered.
166      * @param file the file being read
167      * @param lineNumber the line number of the line being read when the exception was found
168      * @param t the exception
169      */
170     protected void error(Path file, int lineNumber, Throwable t) {
171         out.println(file + &quot;:&quot; + lineNumber + &quot;: &quot; + t);
172     }
173 
174     private void nextChar() throws IOException {
175         ch = in.read();
176         if (ch == &#39;\n&#39;)
177             lineNumber++;
178     }
179 
180     /**
181      * Read the start or end of an HTML tag, or an HTML comment
182      * {@literal &lt;identifier attrs&gt; } or {@literal &lt;/identifier&gt; }
183      * @throws java.io.IOException if there is a problem reading the file
184      */
185     private void html() throws IOException {
186         nextChar();
187         if (isIdentifierStart((char) ch)) {
188             String name = readIdentifier().toLowerCase(Locale.US);
189             Map&lt;String,String&gt; attrs = htmlAttrs();
190             if (attrs != null) {
191                 boolean selfClosing = false;
192                 if (ch == &#39;/&#39;) {
193                     nextChar();
194                     selfClosing = true;
195                 }
196                 if (ch == &#39;&gt;&#39;) {
197                     nextChar();
198                     startElement(name, attrs, selfClosing);
199                     if (name.equals(&quot;script&quot;)) {
200                         inScript = true;
201                     }
202                     return;
203                 }
204             }
205         } else if (ch == &#39;/&#39;) {
206             nextChar();
207             if (isIdentifierStart((char) ch)) {
208                 String name = readIdentifier().toLowerCase(Locale.US);
209                 skipWhitespace();
210                 if (ch == &#39;&gt;&#39;) {
211                     nextChar();
212                     endElement(name);
213                     if (name.equals(&quot;script&quot;)) {
214                         inScript = false;
215                     }
216                     return;
217                 }
218             }
219         } else if (ch == &#39;!&#39;) {
220             nextChar();
221             if (ch == &#39;-&#39;) {
222                 nextChar();
223                 if (ch == &#39;-&#39;) {
224                     nextChar();
225                     while (ch != -1) {
226                         int dash = 0;
227                         while (ch == &#39;-&#39;) {
228                             dash++;
229                             nextChar();
230                         }
231                         // Strictly speaking, a comment should not contain &quot;--&quot;
232                         // so dash &gt; 2 is an error, dash == 2 implies ch == &#39;&gt;&#39;
233                         // See http://www.w3.org/TR/html-markup/syntax.html#syntax-comments
234                         // for more details.
235                         if (dash &gt;= 2 &amp;&amp; ch == &#39;&gt;&#39;) {
236                             nextChar();
237                             return;
238                         }
239 
240                         nextChar();
241                     }
242                 }
243             } else if (ch == &#39;[&#39;) {
244                 nextChar();
245                 if (ch == &#39;C&#39;) {
246                     nextChar();
247                     if (ch == &#39;D&#39;) {
248                         nextChar();
249                         if (ch == &#39;A&#39;) {
250                             nextChar();
251                             if (ch == &#39;T&#39;) {
252                                 nextChar();
253                                 if (ch == &#39;A&#39;) {
254                                     nextChar();
255                                     if (ch == &#39;[&#39;) {
256                                         while (true) {
257                                             nextChar();
258                                             if (ch == &#39;]&#39;) {
259                                                 nextChar();
260                                                 if (ch == &#39;]&#39;) {
261                                                     nextChar();
262                                                     if (ch == &#39;&gt;&#39;) {
263                                                         nextChar();
264                                                         return;
265                                                     }
266                                                 }
267                                             }
268                                         }
269 
270                                     }
271                                 }
272                             }
273                         }
274                     }
275                 }
276             } else {
277                 StringBuilder sb = new StringBuilder();
278                 while (ch != -1 &amp;&amp; ch != &#39;&gt;&#39;) {
279                     sb.append((char) ch);
280                     nextChar();
281                 }
282                 Pattern p = Pattern.compile(&quot;(?is)doctype\\s+html\\s?.*&quot;);
283                 String s = sb.toString();
284                 if (p.matcher(s).matches()) {
285                     docType(s);
286                     return;
287                 }
288             }
289         } else if (ch == &#39;?&#39;) {
290             nextChar();
291             if (ch == &#39;x&#39;) {
292                 nextChar();
293                 if (ch == &#39;m&#39;) {
294                     nextChar();
295                     if (ch == &#39;l&#39;) {
296                         Map&lt;String,String&gt; attrs = htmlAttrs();
297                         if (ch == &#39;?&#39;) {
298                             nextChar();
299                             if (ch == &#39;&gt;&#39;) {
300                                 nextChar();
301                                 xml = true;
302                                 return;
303                             }
304                         }
305                     }
306                 }
307 
308             }
309         }
310 
311         if (!inScript) {
312             error(file, lineNumber, &quot;bad html&quot;);
313         }
314     }
315 
316     /**
317      * Read a series of HTML attributes, terminated by {@literal &gt; }.
318      * Each attribute is of the form {@literal identifier[=value] }.
319      * &quot;value&quot; may be unquoted, single-quoted, or double-quoted.
320      */
321     private Map&lt;String,String&gt; htmlAttrs() throws IOException {
322         Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
323         skipWhitespace();
324 
325         loop:
326         while (isIdentifierStart((char) ch)) {
327             String name = readAttributeName().toLowerCase(Locale.US);
328             skipWhitespace();
329             String value = null;
330             if (ch == &#39;=&#39;) {
331                 nextChar();
332                 skipWhitespace();
333                 if (ch == &#39;\&#39;&#39; || ch == &#39;&quot;&#39;) {
334                     char quote = (char) ch;
335                     nextChar();
336                     StringBuilder sb = new StringBuilder();
337                     while (ch != -1 &amp;&amp; ch != quote) {
338                         sb.append((char) ch);
339                         nextChar();
340                     }
341                     value = sb.toString() // hack to replace common entities
342                             .replace(&quot;&amp;lt;&quot;, &quot;&lt;&quot;)
343                             .replace(&quot;&amp;gt;&quot;, &quot;&gt;&quot;)
344                             .replace(&quot;&amp;amp;&quot;, &quot;&amp;&quot;);
345                     nextChar();
346                 } else {
347                     StringBuilder sb = new StringBuilder();
348                     while (ch != -1 &amp;&amp; !isUnquotedAttrValueTerminator((char) ch)) {
349                         sb.append((char) ch);
350                         nextChar();
351                     }
352                     value = sb.toString();
353                 }
354                 skipWhitespace();
355             }
356             map.put(name, value);
357         }
358 
359         return map;
360     }
361 
362     private boolean isIdentifierStart(char ch) {
363         return Character.isUnicodeIdentifierStart(ch);
364     }
365 
366     private String readIdentifier() throws IOException {
367         StringBuilder sb = new StringBuilder();
368         sb.append((char) ch);
369         nextChar();
370         while (ch != -1 &amp;&amp; Character.isUnicodeIdentifierPart(ch)) {
371             sb.append((char) ch);
372             nextChar();
373         }
374         return sb.toString();
375     }
376 
377     private String readAttributeName() throws IOException {
378         StringBuilder sb = new StringBuilder();
379         sb.append((char) ch);
380         nextChar();
381         while (ch != -1 &amp;&amp; Character.isUnicodeIdentifierPart(ch)
382                 || ch == &#39;-&#39;
383                 || xml &amp;&amp; ch == &#39;:&#39;) {
384             sb.append((char) ch);
385             nextChar();
386         }
387         return sb.toString();
388     }
389 
390     private boolean isWhitespace(char ch) {
391         return Character.isWhitespace(ch);
392     }
393 
394     private void skipWhitespace() throws IOException {
395         while (isWhitespace((char) ch)) {
396             nextChar();
397         }
398     }
399 
400     private boolean isUnquotedAttrValueTerminator(char ch) {
401         switch (ch) {
402             case &#39;\f&#39;: case &#39;\n&#39;: case &#39;\r&#39;: case &#39;\t&#39;:
403             case &#39; &#39;:
404             case &#39;&quot;&#39;: case &#39;\&#39;&#39;: case &#39;`&#39;:
405             case &#39;=&#39;: case &#39;&lt;&#39;: case &#39;&gt;&#39;:
406                 return true;
407             default:
408                 return false;
409         }
410     }
411 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
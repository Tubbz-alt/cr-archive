<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/jdk/javadoc/tool/TestScriptInComment.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 8138725
 27  * @summary test --allow-script-in-comments
 28  * @modules jdk.javadoc/jdk.javadoc.internal.tool
 29  */
 30 
 31 import java.io.File;
 32 import java.io.FileWriter;
 33 import java.io.IOException;
 34 import java.io.PrintStream;
 35 import java.io.PrintWriter;
 36 import java.io.StringWriter;
 37 import java.util.ArrayList;
 38 import java.util.Arrays;
 39 import java.util.Collections;
 40 import java.util.List;
 41 import java.util.regex.Matcher;
 42 import java.util.regex.Pattern;
 43 
 44 /**
 45  * Combo-style test, exercising combinations of different HTML fragments that may contain
 46  * JavaScript, different places to place those fragments, and whether or not to allow the use
 47  * of JavaScript.
 48  */
 49 public class TestScriptInComment {
 50     public static void main(String... args) throws Exception {
 51         new TestScriptInComment().run();
 52     }
 53 
 54     /**
 55      * Representative samples of different fragments of HTML that may contain JavaScript.
 56      * To facilitate checking the output manually in a browser, the text &quot;#ALERT&quot; will be
 57      * replaced by a JavaScript call of &quot;alert(msg)&quot;, using a message string that is specific
 58      * to the test case.
 59      */
 60     enum Comment {
 61         LC(&quot;&lt;script&gt;#ALERT&lt;/script&gt;&quot;, true), // script tag in Lower Case
 62         UC(&quot;&lt;SCRIPT&gt;#ALERT&lt;/script&gt;&quot;, true), // script tag in Upper Case
 63         WS(&quot;&lt; script &gt;#ALERT&lt;/script&gt;&quot;, false, &quot;-Xdoclint:none&quot;), // script tag with invalid white space
 64         SP(&quot;&lt;script src=\&quot;file\&quot;&gt; #ALERT &lt;/script&gt;&quot;, true), // script tag with an attribute
 65         ON(&quot;&lt;a onclick=&#39;#ALERT&#39;&gt;x&lt;/a&gt;&quot;, true), // event handler attribute
 66         URI(&quot;&lt;a href=&#39;javascript:#ALERT&#39;&gt;x&lt;/a&gt;&quot;, true); // javascript URI
 67 
 68         /**
 69          * Creates an HTML fragment to be injected into a template.
 70          * @param text the HTML fragment to put into a doc comment or option.
 71          * @param hasScript whether or not this fragment does contain legal JavaScript
 72          * @param opts any additional options to be specified when javadoc is run
 73          */
 74         Comment(String text, boolean hasScript, String... opts) {
 75             this.text = text;
 76             this.hasScript = hasScript;
 77             this.opts = Arrays.asList(opts);
 78         }
 79 
 80         final String text;
 81         final boolean hasScript;
 82         final List&lt;String&gt; opts;
 83     };
 84 
 85     /**
 86      * Representative samples of positions in which javadoc may find JavaScript.
 87      * Each template contains a series of strings, which are written to files or inferred as options.
 88      * The first source file implies a corresponding output file which should not be written
 89      * if the comment contains JavaScript and JavaScript is not allowed.
 90      */
 91     enum Template {
 92         OVR(&quot;&lt;html&gt;&lt;body&gt; overview #COMMENT &lt;/body&gt;&lt;/html&gt;&quot;, &quot;package p; public class C { }&quot;),
 93         PKGINFO(&quot;#COMMENT package p;&quot;, &quot;package p; public class C { }&quot;),
 94         PKGHTML(&quot;&lt;html&gt;&lt;body&gt;#COMMENT package p;&lt;/body&gt;&lt;/html&gt;&quot;, &quot;package p; public class C { }&quot;),
 95         CLS(&quot;package p; #COMMENT public class C { }&quot;),
 96         CON(&quot;package p; public class C { #COMMENT public C() { } }&quot;),
 97         FLD(&quot;package p; public class C { #COMMENT public int f; }&quot;),
 98         MTH(&quot;package p; public class C { #COMMENT public void m() { } }&quot;),
 99         TOP(&quot;-top&quot;, &quot;lorem #COMMENT ipsum&quot;, &quot;package p; public class C { }&quot;),
100         HDR(&quot;-header&quot;, &quot;lorem #COMMENT ipsum&quot;, &quot;package p; public class C { }&quot;),
101         FTR(&quot;-footer&quot;, &quot;lorem #COMMENT ipsum&quot;, &quot;package p; public class C { }&quot;),
102         BTM(&quot;-bottom&quot;, &quot;lorem #COMMENT ipsum&quot;, &quot;package p; public class C { }&quot;),
103         DTTL(&quot;-doctitle&quot;, &quot;lorem #COMMENT ipsum&quot;, &quot;package p; public class C { }&quot;),
104         PHDR(&quot;-packagesheader&quot;, &quot;lorem #COMMENT ipsum&quot;, &quot;package p; public class C { }&quot;);
105 
106         Template(String... args) {
107             opts = new ArrayList&lt;String&gt;();
108             sources = new ArrayList&lt;String&gt;();
109             int i = 0;
110             while (args[i].startsWith(&quot;-&quot;)) {
111                 // all options being tested have a single argument that follow the option
112                 opts.add(args[i++]);
113                 opts.add(args[i++]);
114             }
115             while(i &lt; args.length) {
116                 sources.add(args[i++]);
117             }
118         }
119 
120         // groups: 1 &lt;html&gt; or not;  2: package name;  3: class name
121         private final Pattern pat =
122                 Pattern.compile(&quot;(?i)(&lt;html&gt;)?.*?(?:package ([a-z]+);.*?(?:class ([a-z]+).*)?)?&quot;);
123 
124         /**
125          * Infer the file in which to write the given source.
126          * @param dir the base source directory
127          * @param src the source text
128          * @return the file in which the source should be written
129          */
130         File getSrcFile(File srcDir, String src) {
131             String f;
132             Matcher m = pat.matcher(src);
133             if (!m.matches())
134                 throw new Error(&quot;match failed&quot;);
135             if (m.group(3) != null) {
136                 f = m.group(2) + &quot;/&quot; + m.group(3) + &quot;.java&quot;;
137             } else if (m.group(2) != null) {
138                 f = m.group(2) + &quot;/&quot; + (m.group(1) == null ? &quot;package-info.java&quot; : &quot;package.html&quot;);
139             } else {
140                 f = &quot;overview.html&quot;;
141             }
142             return new File(srcDir, f);
143         }
144 
145         /**
146          * Get the options to give to javadoc.
147          * @param srcDir the srcDir to use -overview is needed
148          * @return
149          */
150         List&lt;String&gt; getOpts(File srcDir) {
151             if (!opts.isEmpty()) {
152                 return opts;
153             } else if (sources.get(0).contains(&quot;overview&quot;)) {
154                 return Arrays.asList(&quot;-overview&quot;, getSrcFile(srcDir, sources.get(0)).getPath());
155             } else {
156                 return Collections.emptyList();
157             }
158         }
159 
160         /**
161          * Gets the output file corresponding to the first source file.
162          * This file should not be written if the comment contains JavaScript and JavaScripot is
163          * not allowed.
164          * @param dir the base output directory
165          * @return the output file
166          */
167         File getOutFile(File outDir) {
168             String f;
169             Matcher m = pat.matcher(sources.get(0));
170             if (!m.matches())
171                 throw new Error(&quot;match failed&quot;);
172             if (m.group(3) != null) {
173                 f = m.group(2) + &quot;/&quot; + m.group(3) + &quot;.html&quot;;
174             } else if (m.group(2) != null) {
175                 f = m.group(2) + &quot;/package-summary.html&quot;;
176             } else {
177                 f = &quot;overview-summary.html&quot;;
178             }
179             return new File(outDir, f);
180         }
181 
182         final List&lt;String&gt; opts;
183         final List&lt;String&gt; sources;
184     };
185 
186     enum Option {
187         OFF(null),
188         ON(&quot;--allow-script-in-comments&quot;);
189 
190         Option(String text) {
191             this.text = text;
192         }
193 
194         final String text;
195     };
196 
197     private PrintStream out = System.err;
198 
199     public void run() throws Exception {
200         int count = 0;
201         for (Template template: Template.values()) {
202             for (Comment comment: Comment.values()) {
203                 for (Option option: Option.values()) {
204                     if (test(template, comment, option)) {
205                         count++;
206                     }
207                 }
208             }
209         }
210 
211         out.println(count + &quot; test cases run&quot;);
212         if (errors &gt; 0) {
213             throw new Exception(errors + &quot; errors occurred&quot;);
214         }
215     }
216 
217     boolean test(Template template, Comment comment, Option option) throws IOException {
218         if (option == Option.ON &amp;&amp; !comment.hasScript) {
219             // skip --allowScriptInComments if comment does not contain JavaScript
220             return false;
221         }
222 
223         String test = template + &quot;-&quot; + comment + &quot;-&quot; + option;
224         out.println(&quot;Test: &quot; + test);
225 
226         File dir = new File(test);
227         dir.mkdirs();
228         File srcDir = new File(dir, &quot;src&quot;);
229         File outDir = new File(dir, &quot;out&quot;);
230 
231         String alert = &quot;alert(\&quot;&quot; + test + &quot;\&quot;);&quot;;
232         for (String src: template.sources) {
233             writeFile(template.getSrcFile(srcDir, src),
234                 src.replace(&quot;#COMMENT&quot;,
235                         &quot;/** &quot; + comment.text.replace(&quot;#ALERT&quot;, alert) + &quot; **/&quot;));
236         }
237 
238         List&lt;String&gt; opts = new ArrayList&lt;String&gt;();
239         opts.add(&quot;-sourcepath&quot;);
240         opts.add(srcDir.getPath());
241         opts.add(&quot;-d&quot;);
242         opts.add(outDir.getPath());
243         opts.add(&quot;--frames&quot;);
244         if (option.text != null)
245             opts.add(option.text);
246         for (String opt: template.getOpts(srcDir)) {
247             opts.add(opt.replace(&quot;#COMMENT&quot;, comment.text.replace(&quot;#ALERT&quot;, alert)));
248         }
249         opts.addAll(comment.opts);
250         opts.add(&quot;-noindex&quot;);   // index not required; save time/space writing files
251         opts.add(&quot;p&quot;);
252 
253         StringWriter sw = new StringWriter();
254         PrintWriter pw = new PrintWriter(sw);
255         int rc = javadoc(opts, pw);
256         pw.close();
257         String log = sw.toString();
258         writeFile(new File(dir, &quot;log.txt&quot;), log);
259 
260         out.println(&quot;opts: &quot; + opts);
261         out.println(&quot;  rc: &quot; + rc);
262         out.println(&quot; log:&quot;);
263         out.println(log);
264 
265         String ERROR = &quot;Use --allow-script-in-comment&quot;;
266         File outFile = template.getOutFile(outDir);
267 
268         boolean expectErrors = comment.hasScript &amp;&amp; (option == Option.OFF);
269 
270         if (expectErrors) {
271             check(rc != 0, &quot;unexpected exit code: &quot; + rc);
272             check(log.contains(ERROR), &quot;expected error message not found&quot;);
273             check(!outFile.exists(), &quot;output file found unexpectedly&quot;);
274         } else {
275             check(rc == 0, &quot;unexpected exit code: &quot; + rc);
276             check(!log.contains(ERROR), &quot;error message found&quot;);
277             check(outFile.exists(), &quot;output file not found&quot;);
278         }
279 
280         out.println();
281         return true;
282     }
283 
284     int javadoc(List&lt;String&gt; opts, PrintWriter pw) {
285         return jdk.javadoc.internal.tool.Main.execute(opts.toArray(new String[opts.size()]), pw);
286     }
287 
288     File writeFile(File f, String text) throws IOException {
289         f.getParentFile().mkdirs();
290         FileWriter fw = new FileWriter(f);
291         try {
292             fw.write(text);
293         } finally {
294             fw.close();
295         }
296         return f;
297     }
298 
299     void check(boolean cond, String errMessage) {
300         if (!cond) {
301             error(errMessage);
302         }
303     }
304 
305     void error(String message) {
306         out.println(&quot;Error: &quot; + message);
307         errors++;
308     }
309 
310     int errors = 0;
311 }
312 
    </pre>
  </body>
</html>
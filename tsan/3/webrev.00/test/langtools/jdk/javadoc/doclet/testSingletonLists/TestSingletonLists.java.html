<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/jdk/javadoc/doclet/testSingletonLists/TestSingletonLists.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8219998 8221991
 27  * @summary Eliminate inherently singleton lists
 28  * @library /tools/lib ../../lib
 29  * @modules jdk.javadoc/jdk.javadoc.internal.tool
 30  * @modules jdk.compiler/com.sun.tools.javac.api
 31  *          jdk.compiler/com.sun.tools.javac.main
 32  *          jdk.javadoc/jdk.javadoc.internal.api
 33  *          jdk.javadoc/jdk.javadoc.internal.tool
 34  * @build toolbox.ToolBox toolbox.JavacTask javadoc.tester.*
 35  * @run main TestSingletonLists
 36  */
 37 
 38 import java.io.IOException;
 39 import java.io.PrintStream;
 40 import java.nio.file.Path;
 41 import java.util.ArrayList;
 42 import java.util.List;
 43 import java.util.Map;
 44 import java.util.Stack;
 45 import java.util.TreeMap;
 46 import java.util.function.Function;
 47 
 48 import javadoc.tester.HtmlChecker;
 49 import javadoc.tester.JavadocTester;
 50 import toolbox.ModuleBuilder;
 51 import toolbox.ToolBox;
 52 
 53 
 54 public class TestSingletonLists extends JavadocTester {
 55     public static void main(String... args) throws Exception {
 56         TestSingletonLists tester = new TestSingletonLists();
 57         tester.runTests();
 58     }
 59 
 60     enum Index  { SINGLE, SPLIT };
 61     enum Source { PACKAGES, MODULES };
 62 
 63     final ToolBox tb = new ToolBox();
 64 
 65     public void runTests() throws Exception {
 66         for (Source s : Source.values()) {
 67             Path src = genSource(s);
 68                 for (Index i : Index.values()) {
 69                     List&lt;String&gt; args = new ArrayList&lt;&gt;();
 70                     args.add(&quot;-d&quot;);
 71                     args.add(String.format(&quot;out-%s-%s&quot;, s, i));
 72                     args.add(&quot;-use&quot;);
 73                     if (s != Source.MODULES) {
 74                         args.add(&quot;-linksource&quot;); // broken, with modules: JDK-8219060
 75                     }
 76                     if (i == Index.SPLIT) {
 77                         args.add(&quot;-splitIndex&quot;);
 78                     }
 79                     if (s == Source.PACKAGES) {
 80                         args.add(&quot;-sourcepath&quot;);
 81                         args.add(src.toString());
 82                         args.add(&quot;p1&quot;);
 83                         args.add(&quot;p2&quot;);
 84                         args.add(&quot;p3&quot;);
 85                     } else {
 86                         args.add(&quot;--module-source-path&quot;);
 87                         args.add(src.toString());
 88                         args.add(&quot;--module&quot;);
 89                         args.add(&quot;mA,mB,mC&quot;);
 90                     }
 91                     javadoc(args.toArray(new String[args.size()]));
 92                     checkExit(Exit.OK);
 93                     checkLists();
 94                 }
 95         }
 96 
 97         printSummary();
 98     }
 99 
100     Path genSource(Source s) throws IOException {
101         Path src = Path.of(&quot;src-&quot; + s);
102         switch (s) {
103             case PACKAGES:
104                 for (String p : new String[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; }) {
105                     tb.writeJavaFiles(src, genClasses(&quot;p&quot; + p));
106                 }
107                 break;
108 
109             case MODULES:
110                 for (String m : new String[] { &quot;A&quot;, &quot;B&quot;, &quot;C&quot;}) {
111                     ModuleBuilder mb = new ModuleBuilder(tb, &quot;m&quot; + m);
112                     for (String p : new String[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; } ) {
113                         mb.exports(&quot;p&quot; + m + p);
114                         mb.classes(genClasses(&quot;p&quot; + m + p));
115                     }
116                     mb.write(src);
117                 }
118                 break;
119         }
120 
121         return src;
122     }
123 
124 
125     String[] genClasses(String pkg) {
126         List&lt;String&gt; list = new ArrayList&lt;&gt;();
127         list.add(&quot;package &quot; + pkg + &quot;;&quot;);
128         for (int i = 0; i &lt; 3; i++) {
129             list.add(genClass(pkg, i));
130             list.add(genAnno(pkg, i));
131             list.add(genEnum(pkg, i));
132         }
133         return list.toArray(new String[list.size()]);
134     }
135 
136     String genClass(String pkg, int index) {
137         String cn = (pkg + &quot;c&quot; + index).toUpperCase();
138         StringBuilder sb = new StringBuilder();
139         int pkgIndex = Character.getNumericValue(pkg.charAt(pkg.length()-1));
140         String pkgdependency = pkg.substring(0, pkg.length()-1) + (pkgIndex == 3 ? 1 : pkgIndex + 1);
141         String enumClassName = pkgdependency.toUpperCase() + &quot;E&quot; + index;
142         sb.append(&quot;package &quot;).append(pkg).append(&quot;;\n&quot;)
143                 .append(&quot;import &quot; + pkgdependency + &quot;.*;\n&quot;)
144                 .append(&quot;public class &quot;).append(cn).append(&quot; {\n&quot;);
145         // fields
146         for (int f = 0; f &lt; 3; f++) {
147             sb.append(&quot;public int f&quot;).append(f).append(&quot;;\n&quot;);
148         }
149         // constructors
150         for (int c = 0; c &lt; 3; c++) {
151             sb.append(&quot;public &quot;).append(cn).append(&quot;(&quot;);
152             for (int i = 0; i &lt; c; i++) {
153                 sb.append(i == 0 ? &quot;&quot; : &quot;, &quot;).append(&quot;int i&quot;).append(i);
154             }
155             sb.append(&quot;) { }\n&quot;);
156         }
157         // methods
158         for (int m = 0; m &lt; 3; m++) {
159             sb.append(&quot;public void m&quot;).append(m).append(&quot;() { }\n&quot;);
160         }
161         sb.append(&quot;public void n(&quot;).append(enumClassName).append(&quot; e){}&quot;);
162         sb.append(&quot;}\n&quot;);
163         return sb.toString();
164     }
165 
166     String genAnno(String pkg, int index) {
167         String an = (pkg + &quot;a&quot; + index).toUpperCase();
168         StringBuilder sb = new StringBuilder();
169         sb.append(&quot;package &quot;).append(pkg).append(&quot;;\n&quot;)
170                 .append(&quot;public @interface &quot;).append(an).append(&quot; {\n&quot;);
171         // fields
172         for (int f = 0; f &lt; 3; f++) {
173             sb.append(&quot;public static final int f&quot;).append(f).append(&quot; = 0;\n&quot;);
174         }
175             // values
176         for (int v = 0; v &lt; 6; v++) {
177             sb.append(&quot;public int v&quot;).append(v).append(&quot;()&quot;).append(v&lt; 3 ? &quot;&quot; :  &quot; default &quot; + v).append(&quot;;\n&quot;);
178         }
179         sb.append(&quot;}\n&quot;);
180         return sb.toString();
181     }
182 
183     String genEnum(String pkg, int index) {
184         String en = (pkg + &quot;e&quot; + index).toUpperCase();
185         StringBuilder sb = new StringBuilder();
186         sb.append(&quot;package &quot;).append(pkg).append(&quot;;\n&quot;)
187                 .append(&quot;public enum &quot;).append(en).append(&quot; {\n&quot;);
188              // enum members
189         for (int e = 0; e &lt; 3; e++) {
190             sb.append(e == 0 ? &quot;&quot; : &quot;, &quot;).append(&quot;E&quot;).append(e);
191         }
192         sb.append(&quot;;\n&quot;);
193         // fields
194         for (int f = 0; f &lt; 3; f++) {
195             sb.append(&quot;public int f&quot;).append(f).append(&quot;;\n&quot;);
196         }
197         // methods
198         for (int m = 0; m &lt; 3; m++) {
199             sb.append(&quot;public void m&quot;).append(m).append(&quot;() { }\n&quot;);
200         }
201         sb.append(&quot;}\n&quot;);
202         return sb.toString();
203     }
204 
205     void checkLists() {
206         checking(&quot;Check lists&quot;);
207         ListChecker c = new ListChecker(out, this::readFile);
208         try {
209             c.checkDirectory(outputDir.toPath());
210             c.report();
211             int errors = c.getErrorCount();
212             if (errors == 0) {
213                 passed(&quot;No list errors found&quot;);
214             } else {
215                 failed(errors + &quot; errors found when checking lists&quot;);
216             }
217         } catch (IOException e) {
218             failed(&quot;exception thrown when reading files: &quot; + e);
219         }
220     }
221 
222     /**
223      * A class to check the presence of singleton lists.
224      */
225     public class ListChecker extends HtmlChecker {
226         private int listErrors;
227 
228         private boolean inBody;
229         private boolean inNoScript;
230         private Stack&lt;Map&lt;String,Integer&gt;&gt; counts = new Stack&lt;&gt;();
231         private int regionErrors;
232         private String fileName;
233         private boolean inheritanceClass;
234         private List&lt;String&gt; excludeFiles = List.of(&quot;overview-tree.html&quot;,&quot;package-tree.html&quot;,&quot;module-summary.html&quot;);
235 
236         ListChecker(PrintStream out, Function&lt;Path,String&gt; fileReader) {
237             super(out, fileReader);
238         }
239 
240         protected int getErrorCount() {
241             return errors;
242         }
243 
244         @Override
245         public void report() {
246             if (listErrors == 0) {
247                 out.println(&quot;All lists OK&quot;);
248             } else {
249                 out.println(listErrors + &quot; list errors&quot;);
250             }
251 
252             if (regionErrors == 0) {
253                 out.println(&quot;All regions OK&quot;);
254             } else {
255                 out.println(regionErrors + &quot; errors in regions&quot;);
256             }
257         }
258 
259         @Override
260         public void startFile(Path path) {
261             fileName = path.getFileName().toString();
262         }
263 
264         @Override
265         public void endFile() {
266         }
267 
268         @Override
269         public void docType(String doctype) {
270         }
271 
272         @Override
273         public void startElement(String name, Map&lt;String,String&gt; attrs, boolean selfClosing) {
274             switch (name) {
275 
276                 case &quot;ul&quot;: case &quot;ol&quot;: case &quot;dl&quot;:
277                     counts.push(new TreeMap&lt;&gt;());
278                     break;
279 
280                 case &quot;li&quot;: case &quot;dd&quot;: case &quot;dt&quot;: {
281                     Map&lt;String, Integer&gt; c = counts.peek();
282                     c.put(name, 1 + c.computeIfAbsent(name, n -&gt; 0));
283                     break;
284                 }
285             }
286         }
287 
288         @Override
289         public void endElement(String name) {
290             switch (name) {
291                 case &quot;ul&quot;: case &quot;ol&quot;: {
292                     Map&lt;String,Integer&gt; c = counts.pop();
293                     if (c.get(&quot;li&quot;) == 0) {
294                         error(currFile, getLineNumber(), &quot;empty list&quot;);
295                     } else if (c.get(&quot;li&quot;) == 1 &amp;&amp; fileName != null &amp;&amp; !excludeFiles.contains(fileName)) {
296                         error(currFile, getLineNumber(), &quot;singleton list&quot;);
297                     }
298                     break;
299                 }
300 
301                 case &quot;dl&quot;: {
302                     Map&lt;String, Integer&gt; c = counts.pop();
303                     if (c.get(&quot;dd&quot;) == 0 || c.get(&quot;dt&quot;) == 0) {
304                         error(currFile, getLineNumber(), &quot;empty list&quot;);
305                     }
306                     /*if (c.get(&quot;dd&quot;) == 1 || c.get(&quot;dt&quot;) == 1) {
307                         error(currFile, getLineNumber(), &quot;singleton list&quot;);
308                     }*/
309                     break;
310                 }
311             }
312         }
313     }
314 }
    </pre>
  </body>
</html>
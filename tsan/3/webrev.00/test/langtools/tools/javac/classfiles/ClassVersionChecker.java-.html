<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/classfiles/ClassVersionChecker.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 7157626 8001112 8188870 8173382 8193290 8205619
 27  * @summary Test major version for all legal combinations for -source and -target
 28  * @author sgoel
 29  *
 30  * @modules jdk.compiler
 31  */
 32 
 33 import java.io.*;
 34 import java.nio.*;
 35 import java.util.*;
 36 import java.util.regex.*;
 37 
 38 /*
 39  * If not explicitly specified the latest source and latest target
 40  * values are the defaults. If explicitly specified, the target value
 41  * has to be greater than or equal to the source value.
 42  */
 43 public class ClassVersionChecker {
 44     private static enum Version {
 45         SEVEN(&quot;7&quot;, 51),
 46         EIGHT(&quot;8&quot;, 52),
 47         NINE(&quot;9&quot;, 53),
 48         TEN(&quot;10&quot;, 54),
 49         ELEVEN(&quot;11&quot;, 55),
 50         TWELVE(&quot;12&quot;, 56),
 51         THIRTEEN(&quot;13&quot;, 57);
 52 
 53         private Version(String release, int classFileVer) {
 54             this.release = release;
 55             this.classFileVer = classFileVer;
 56         }
 57         private final String release;
 58         private final int classFileVer;
 59 
 60         String release() {return release;}
 61         int classFileVer() {return classFileVer;}
 62     }
 63 
 64     static final Version CURRENT;
 65     static {
 66         Version[] versions = Version.values();
 67         int index = versions.length;
 68         CURRENT = versions[index - 1];
 69     }
 70 
 71     int errors;
 72 
 73     File javaFile = null;
 74 
 75     public static void main(String[] args) throws Throwable {
 76         new ClassVersionChecker().run();
 77     }
 78 
 79     void run() throws Exception {
 80         writeTestFile();
 81         /*
 82          * Rules applicable for -source and -target combinations:
 83          * 1. If both empty, version num is for the current release
 84          * 2. If source is not empty and target is empty, version is
 85          * based on the current release
 86          * 3. If both non-empty, version is based on target
 87          */
 88         test(&quot;&quot;, &quot;&quot;, CURRENT.classFileVer());
 89         for (Version source : Version.values()) {
 90             test(source.release(), &quot;&quot;, CURRENT.classFileVer()); // no target
 91             for (Version target : Version.values()) {
 92                 if (target.compareTo(source) &lt; 0)
 93                     continue; // Target &lt; source not a valid set of arguments
 94                 else {
 95                     logMsg(&quot;Running for src = &quot; + source + &quot; target = &quot;+ target +
 96                            &quot; expected = &quot; + target.classFileVer());
 97                     test(source.release(), target.release(), target.classFileVer());
 98                 }
 99             }
100         }
101 
102         if (errors &gt; 0)
103             throw new Exception(errors + &quot; errors found&quot;);
104     }
105 
106     void test(String i, String j, int expected) {
107         File classFile = compileTestFile(i, j, javaFile);
108         short majorVer = getMajorVersion(classFile);
109         checkVersion(majorVer, expected);
110     }
111 
112     void writeTestFile() throws IOException {
113         javaFile = new File(&quot;Test.java&quot;);
114         try(PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(javaFile)));) {
115             out.println(&quot;class Test { &quot;);
116             out.println(&quot;  public void foo() { }&quot;);
117             out.println(&quot;}&quot;);
118         } catch (IOException ioe) {
119             error(&quot;IOException while creating Test.java&quot; + ioe);
120         }
121     }
122 
123     File compileTestFile(String i, String j, File f) {
124         int rc = -1;
125         // Src and target are empty
126         if (i.isEmpty() &amp;&amp; j.isEmpty() ) {
127             rc = compile(&quot;-g&quot;, f.getPath());
128         } else if( j.isEmpty()) {  // target is empty
129             rc = compile(&quot;-source&quot;, i, &quot;-g&quot;, f.getPath());
130         } else {
131             rc = compile(&quot;-source&quot;, i, &quot;-target&quot;, j, &quot;-g&quot;, f.getPath());
132         }
133         if (rc != 0)
134             throw new Error(&quot;compilation failed. rc=&quot; + rc);
135         String path = f.getPath();
136         return new File(path.substring(0, path.length() - 5) + &quot;.class&quot;);
137     }
138 
139     int compile(String... args) {
140         return com.sun.tools.javac.Main.compile(args);
141     }
142 
143     void logMsg (String str) {
144         System.out.println(str);
145     }
146 
147     short getMajorVersion(File f) {
148         List&lt;String&gt; args = new ArrayList&lt;String&gt;();
149         short majorVer = 0;
150         try(DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream(f)));) {
151             in.readInt();
152             in.readShort();
153             majorVer = in.readShort();
154             System.out.println(&quot;major version:&quot; +  majorVer);
155         } catch (IOException e) {
156             error(&quot;IOException while reading Test.class&quot; + e);
157         }
158         return majorVer;
159     }
160 
161     void checkVersion(short majorVer, int expected) {
162         if (majorVer != expected ) {
163             error(&quot;versions did not match, Expected: &quot; + expected + &quot;Got: &quot; + majorVer);
164         }
165     }
166 
167     void error(String msg) {
168        System.out.println(&quot;error: &quot; + msg);
169        errors++;
170     }
171 }
    </pre>
  </body>
</html>
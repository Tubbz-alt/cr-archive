<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/varargs/7042566/T7042566.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 7042566 8006694 8129962
 27  * @summary Unambiguous varargs method calls flagged as ambiguous
 28  *  temporarily workaround combo tests are causing time out in several platforms
 29  * @library /tools/javac/lib
 30  * @modules jdk.jdeps/com.sun.tools.classfile
 31  *          jdk.compiler/com.sun.tools.javac.api
 32  *          jdk.compiler/com.sun.tools.javac.file
 33  *          jdk.compiler/com.sun.tools.javac.util
 34  * @build combo.ComboTestHelper
 35  * @run main T7042566
 36  */
 37 
 38 import java.io.IOException;
 39 import java.io.InputStream;
 40 import javax.tools.JavaFileObject;
 41 
 42 import com.sun.tools.classfile.Instruction;
 43 import com.sun.tools.classfile.Attribute;
 44 import com.sun.tools.classfile.ClassFile;
 45 import com.sun.tools.classfile.Code_attribute;
 46 import com.sun.tools.classfile.ConstantPool.*;
 47 import com.sun.tools.classfile.Method;
 48 import com.sun.tools.javac.util.List;
 49 
 50 import combo.ComboInstance;
 51 import combo.ComboParameter;
 52 import combo.ComboTask.Result;
 53 import combo.ComboTestHelper;
 54 
 55 public class T7042566 extends ComboInstance&lt;T7042566&gt; {
 56 
 57     enum TypeKind {
 58         OBJECT(&quot;Object&quot;, &quot;(Object)null&quot;, &quot;Ljava/lang/Object;&quot;),
 59         STRING(&quot;String&quot;, &quot;(String)null&quot;, &quot;Ljava/lang/String;&quot;);
 60 
 61         String typeString;
 62         String valueString;
 63         String bytecodeString;
 64 
 65         TypeKind(String typeString, String valueString, String bytecodeString) {
 66             this.typeString = typeString;
 67             this.valueString = valueString;
 68             this.bytecodeString = bytecodeString;
 69         }
 70 
 71         boolean isSubtypeOf(TypeKind that) {
 72             return that == OBJECT ||
 73                     (that == STRING &amp;&amp; this == STRING);
 74         }
 75     }
 76 
 77     enum TypeConfiguration implements ComboParameter {
 78         A(TypeKind.OBJECT),
 79         B(TypeKind.STRING),
 80         AA(TypeKind.OBJECT, TypeKind.OBJECT),
 81         AB(TypeKind.OBJECT, TypeKind.STRING),
 82         BA(TypeKind.STRING, TypeKind.OBJECT),
 83         BB(TypeKind.STRING, TypeKind.STRING),
 84         AAA(TypeKind.OBJECT, TypeKind.OBJECT, TypeKind.OBJECT),
 85         AAB(TypeKind.OBJECT, TypeKind.OBJECT, TypeKind.STRING),
 86         ABA(TypeKind.OBJECT, TypeKind.STRING, TypeKind.OBJECT),
 87         ABB(TypeKind.OBJECT, TypeKind.STRING, TypeKind.STRING),
 88         BAA(TypeKind.STRING, TypeKind.OBJECT, TypeKind.OBJECT),
 89         BAB(TypeKind.STRING, TypeKind.OBJECT, TypeKind.STRING),
 90         BBA(TypeKind.STRING, TypeKind.STRING, TypeKind.OBJECT),
 91         BBB(TypeKind.STRING, TypeKind.STRING, TypeKind.STRING);
 92 
 93         List&lt;TypeKind&gt; typeKindList;
 94         String expressionListStr;
 95         String parameterListStr;
 96         String bytecodeSigStr;
 97 
 98         TypeConfiguration(TypeKind... typeKindList) {
 99             this.typeKindList = List.from(typeKindList);
100             expressionListStr = asExpressionList();
101             parameterListStr = asParameterList();
102             bytecodeSigStr = asBytecodeString();
103         }
104 
105         private String asExpressionList() {
106             StringBuilder buf = new StringBuilder();
107             String sep = &quot;&quot;;
108             for (TypeKind tk : typeKindList) {
109                 buf.append(sep);
110                 buf.append(tk.valueString);
111                 sep = &quot;,&quot;;
112             }
113             return buf.toString();
114         }
115 
116         private String asParameterList() {
117             StringBuilder buf = new StringBuilder();
118             String sep = &quot;&quot;;
119             int count = 0;
120             for (TypeKind arg : typeKindList) {
121                 buf.append(sep);
122                 buf.append(arg.typeString);
123                 if (count == (typeKindList.size() - 1)) {
124                     buf.append(&quot;...&quot;);
125                 }
126                 buf.append(&quot; &quot;);
127                 buf.append(&quot;arg&quot; + count++);
128                 sep = &quot;,&quot;;
129             }
130             return buf.toString();
131         }
132 
133         private String asBytecodeString() {
134             StringBuilder buf = new StringBuilder();
135             int count = 0;
136             for (TypeKind arg : typeKindList) {
137                 if (count == (typeKindList.size() - 1)) {
138                     buf.append(&quot;[&quot;);
139                 }
140                 buf.append(arg.bytecodeString);
141                 count++;
142             }
143             return buf.toString();
144         }
145 
146         @Override
147         public String expand(String optParameter) {
148             return expressionListStr;
149         }
150     }
151 
152     static class VarargsMethod {
153         TypeConfiguration parameterTypes;
154 
155         public VarargsMethod(TypeConfiguration parameterTypes) {
156             this.parameterTypes = parameterTypes;
157         }
158 
159         @Override
160         public String toString() {
161             return &quot;void m( &quot; + parameterTypes.parameterListStr + &quot;) {}&quot;;
162         }
163 
164         boolean isApplicable(TypeConfiguration that) {
165             List&lt;TypeKind&gt; actuals = that.typeKindList;
166             List&lt;TypeKind&gt; formals = parameterTypes.typeKindList;
167             if ((actuals.size() - formals.size()) &lt; -1)
168                 return false; //not enough args
169             for (TypeKind actual : actuals) {
170                 if (!actual.isSubtypeOf(formals.head))
171                     return false; //type mismatch
172                 formals = formals.tail.isEmpty() ?
173                     formals :
174                     formals.tail;
175             }
176             return true;
177         }
178 
179         boolean isMoreSpecificThan(VarargsMethod that) {
180             List&lt;TypeKind&gt; actuals = parameterTypes.typeKindList;
181             List&lt;TypeKind&gt; formals = that.parameterTypes.typeKindList;
182             int checks = 0;
183             int expectedCheck = Math.max(actuals.size(), formals.size());
184             while (checks &lt; expectedCheck) {
185                 if (!actuals.head.isSubtypeOf(formals.head))
186                     return false; //type mismatch
187                 formals = formals.tail.isEmpty() ?
188                     formals :
189                     formals.tail;
190                 actuals = actuals.tail.isEmpty() ?
191                     actuals :
192                     actuals.tail;
193                 checks++;
194             }
195             return true;
196         }
197     }
198 
199     public static void main(String[] args) {
200         new ComboTestHelper&lt;T7042566&gt;()
201                 .withArrayDimension(&quot;SIG&quot;, (x, sig, idx) -&gt; x.methodSignatures[idx] = sig, 2, TypeConfiguration.values())
202                 .withDimension(&quot;ACTUALS&quot;, (x, actuals) -&gt; x.actuals = actuals, TypeConfiguration.values())
203                 .run(T7042566::new, T7042566::setup);
204     }
205 
206     VarargsMethod m1;
207     VarargsMethod m2;
208     TypeConfiguration[] methodSignatures = new TypeConfiguration[2];
209     TypeConfiguration actuals;
210 
211     void setup() {
212         this.m1 = new VarargsMethod(methodSignatures[0]);
213         this.m2 = new VarargsMethod(methodSignatures[1]);
214     }
215 
216     final String source_template = &quot;class Test {\n&quot; +
217                 &quot;   #{METH.1}\n&quot; +
218                 &quot;   #{METH.2}\n&quot; +
219                 &quot;   void test() { m(#{ACTUALS}); }\n&quot; +
220                 &quot;}&quot;;
221 
222     @Override
223     public void doWork() throws IOException {
224         newCompilationTask()
225                 .withSourceFromTemplate(source_template, this::getMethodDecl)
226                 .generate(this::check);
227     }
228 
229     ComboParameter getMethodDecl(String parameterName) {
230         switch (parameterName) {
231             case &quot;METH&quot;: return optParameter -&gt; {
232                 return optParameter.equals(&quot;1&quot;) ?
233                         m1.toString() : m2.toString();
234             };
235             default:
236                 return null;
237         }
238     }
239 
240     void check(Result&lt;Iterable&lt;? extends JavaFileObject&gt;&gt; res) {
241         boolean resolutionError = false;
242         VarargsMethod selectedMethod = null;
243 
244         boolean m1_applicable = m1.isApplicable(actuals);
245         boolean m2_applicable = m2.isApplicable(actuals);
246 
247         if (!m1_applicable &amp;&amp; !m2_applicable) {
248             resolutionError = true;
249         } else if (m1_applicable &amp;&amp; m2_applicable) {
250             //most specific
251             boolean m1_moreSpecific = m1.isMoreSpecificThan(m2);
252             boolean m2_moreSpecific = m2.isMoreSpecificThan(m1);
253 
254             resolutionError = m1_moreSpecific == m2_moreSpecific;
255             selectedMethod = m1_moreSpecific ? m1 : m2;
256         } else {
257             selectedMethod = m1_applicable ?
258                 m1 : m2;
259         }
260 
261         if (res.hasErrors() != resolutionError) {
262             fail(&quot;invalid diagnostics for source:\n&quot; +
263                     res.compilationInfo() +
264                     &quot;\nExpected resolution error: &quot; + resolutionError +
265                     &quot;\nFound error: &quot; + res.hasErrors());
266         } else if (!resolutionError) {
267             verifyBytecode(res, selectedMethod);
268         }
269     }
270 
271     void verifyBytecode(Result&lt;Iterable&lt;? extends JavaFileObject&gt;&gt; res, VarargsMethod selected) {
272         try (InputStream is = res.get().iterator().next().openInputStream()) {
273             ClassFile cf = ClassFile.read(is);
274             Method testMethod = null;
275             for (Method m : cf.methods) {
276                 if (m.getName(cf.constant_pool).equals(&quot;test&quot;)) {
277                     testMethod = m;
278                     break;
279                 }
280             }
281             if (testMethod == null) {
282                 fail(&quot;Test method not found&quot;);
283                 return;
284             }
285             Code_attribute ea =
286                 (Code_attribute)testMethod.attributes.get(Attribute.Code);
287             if (testMethod == null) {
288                 fail(&quot;Code attribute for test() method not found&quot;);
289                 return;
290             }
291 
292             for (Instruction i : ea.getInstructions()) {
293                 if (i.getMnemonic().equals(&quot;invokevirtual&quot;)) {
294                     int cp_entry = i.getUnsignedShort(1);
295                     CONSTANT_Methodref_info methRef =
296                         (CONSTANT_Methodref_info)cf.constant_pool.get(cp_entry);
297                     String type = methRef.getNameAndTypeInfo().getType();
298                     String sig = selected.parameterTypes.bytecodeSigStr;
299                     if (!type.contains(sig)) {
300                         fail(&quot;Unexpected type method call: &quot; +
301                                         type + &quot;&quot; +
302                                         &quot;\nfound: &quot; + sig +
303                                         &quot;\n&quot; + res.compilationInfo());
304                         return;
305                     }
306                     break;
307                 }
308             }
309         } catch (Exception e) {
310             e.printStackTrace();
311             fail(&quot;error reading classfile; &quot; + res.compilationInfo() +&quot;: &quot; + e);
312         }
313     }
314 }
    </pre>
  </body>
</html>
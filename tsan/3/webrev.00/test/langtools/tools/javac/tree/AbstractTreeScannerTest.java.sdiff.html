<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/langtools/tools/javac/tree/AbstractTreeScannerTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../sym/ElementStructureTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="JavacTreeScannerTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/langtools/tools/javac/tree/AbstractTreeScannerTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.*;
 25 import java.lang.reflect.*;
 26 import java.util.*;
 27 import javax.tools.*;
 28 


 29 import com.sun.source.tree.CompilationUnitTree;
 30 import com.sun.source.tree.Tree;
 31 import com.sun.source.util.JavacTask;
 32 import com.sun.tools.javac.api.JavacTool;


 33 import com.sun.tools.javac.tree.JCTree;
 34 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
<span class="line-modified"> 35 import com.sun.tools.javac.util.List;</span>
 36 
 37 public abstract class AbstractTreeScannerTest {
 38 
 39     /**
 40      * Run the program. A base directory can be provided for file arguments.
 41      * In jtreg mode, the -r option can be given to change the default base
 42      * directory to the test root directory. For other options, see usage().
 43      * @param baseDir base directory for any file arguments.
 44      * @param args command line args
 45      * @return true if successful or in gui mode
 46      */
 47     boolean run(File baseDir, String... args) {
 48         if (args.length == 0) {
 49             usage(System.out);
 50             return true;
 51         }
 52 
 53         ArrayList&lt;File&gt; files = new ArrayList&lt;File&gt;();
 54         for (int i = 0; i &lt; args.length; i++) {
 55             String arg = args[i];
</pre>
<hr />
<pre>
124         if (file.isFile() &amp;&amp; file.getName().endsWith(&quot;.java&quot;)) {
125             try {
126                 if (verbose)
127                     System.err.println(file);
128                 fileCount++;
129                 treeCount += test(read(file));
130             } catch (ParseException e) {
131                 if (!quiet) {
132                     error(&quot;Error parsing &quot; + file + &quot;\n&quot; + e.getMessage());
133                 }
134             } catch (IOException e) {
135                 error(&quot;Error reading &quot; + file + &quot;: &quot; + e);
136             }
137             return;
138         }
139 
140         if (!quiet)
141             error(&quot;File &quot; + file + &quot; ignored&quot;);
142     }
143 
<span class="line-modified">144     abstract int test(JCCompilationUnit t);</span>
145 
146     // See CR:  6982992 Tests CheckAttributedTree.java, JavacTreeScannerTest.java, and SourceTreeeScannerTest.java timeout
147     StringWriter sw = new StringWriter();
148     PrintWriter pw = new PrintWriter(sw);
149     Reporter r = new Reporter(pw);
150     JavacTool tool = JavacTool.create();
151     StandardJavaFileManager fm = tool.getStandardFileManager(r, null, null);
152 
153     /**
154      * Read a file.
155      * @param file the file to be read
156      * @return the tree for the content of the file
157      * @throws IOException if any IO errors occur
158      * @throws TreePosTest.ParseException if any errors occur while parsing the file
159      */
<span class="line-modified">160     JCCompilationUnit read(File file) throws IOException, ParseException {</span>
161         JavacTool tool = JavacTool.create();
162         r.errors = 0;
163         Iterable&lt;? extends JavaFileObject&gt; files = fm.getJavaFileObjects(file);
164         JavacTask task = tool.getTask(pw, fm, r, Collections.&lt;String&gt;emptyList(), null, files);
165         Iterable&lt;? extends CompilationUnitTree&gt; trees = task.parse();
166         pw.flush();
167         if (r.errors &gt; 0)
168             throw new ParseException(sw.toString());
169         Iterator&lt;? extends CompilationUnitTree&gt; iter = trees.iterator();
170         if (!iter.hasNext())
171             throw new Error(&quot;no trees found&quot;);
172         JCCompilationUnit t = (JCCompilationUnit) iter.next();
173         if (iter.hasNext())
174             throw new Error(&quot;too many trees found&quot;);
<span class="line-modified">175         return t;</span>
176     }
177 
178     /**
179      * Report an error. When the program is complete, the program will either
180      * exit or throw an Error if any errors have been reported.
181      * @param msg the error message
182      */
183     void error(String msg) {
184         System.err.println(msg);
185         errors++;
186     }
187 
188     /**
189      * Report an error. When the program is complete, the program will either
190      * exit or throw an Error if any errors have been reported.
191      * @param msg the error message
192      */
193     void error(JavaFileObject file, String msg) {
194         System.err.println(file.getName() + &quot;: &quot; + msg);
195         errors++;
196     }
197 
198     /**
199      *  Report an error for a specific tree node.
200      *  @param file the source file for the tree
201      *  @param t    the tree node
202      *  @param label an indication of the error
203      */
204     void error(JavaFileObject file, Tree tree, String msg) {
205         JCTree t = (JCTree) tree;
<span class="line-modified">206         error(file.getName() + &quot;:&quot; + getLine(file, t) + &quot;: &quot; + msg + &quot; &quot; + trim(t, 64));</span>












207     }
208 
209     /**
210      * Get a trimmed string for a tree node, with normalized white space and limited length.
211      */
<span class="line-modified">212     String trim(Tree tree, int len) {</span>
<span class="line-modified">213         JCTree t = (JCTree) tree;</span>
<span class="line-removed">214         String s = t.toString().replaceAll(&quot;\\s+&quot;, &quot; &quot;);</span>
215         return (s.length() &lt; len) ? s : s.substring(0, len);
216     }
217 
218     /** Number of files that have been analyzed. */
219     int fileCount;
220     /** Number of trees that have been successfully compared. */
221     int treeCount;
222     /** Number of errors reported. */
223     int errors;
224     /** Flag: don&#39;t report irrelevant files. */
225     boolean quiet;
226     /** Flag: report files as they are processed. */
227     boolean verbose;
228 
229 
230     /**
231      * Thrown when errors are found parsing a java file.
232      */
233     private static class ParseException extends Exception {
234         ParseException(String msg) {
</pre>
<hr />
<pre>
259      * Get the set of fields for a tree node that may contain child tree nodes.
260      * These are the fields that are subtypes of JCTree or List.
261      * The results are cached, based on the tree&#39;s tag.
262      */
263     Set&lt;Field&gt; getFields(JCTree tree) {
264         Set&lt;Field&gt; fields = map.get(tree.getTag());
265         if (fields == null) {
266             fields = new HashSet&lt;Field&gt;();
267             for (Field f: tree.getClass().getFields()) {
268                 Class&lt;?&gt; fc = f.getType();
269                 if (JCTree.class.isAssignableFrom(fc) || List.class.isAssignableFrom(fc))
270                     fields.add(f);
271             }
272             map.put(tree.getTag(), fields);
273         }
274         return fields;
275     }
276     // where
277     Map&lt;JCTree.Tag, Set&lt;Field&gt;&gt; map = new HashMap&lt;JCTree.Tag,Set&lt;Field&gt;&gt;();
278 





















279     /** Get the line number for the primary position for a tree.
280      * The code is intended to be simple, although not necessarily efficient.
281      * However, note that a file manager such as JavacFileManager is likely
282      * to cache the results of file.getCharContent, avoiding the need to read
283      * the bits from disk each time this method is called.
284      */
<span class="line-modified">285     int getLine(JavaFileObject file, JCTree tree) {</span>
286         try {
287             CharSequence cs = file.getCharContent(true);
288             int line = 1;
<span class="line-modified">289             for (int i = 0; i &lt; tree.pos; i++) {</span>
290                 if (cs.charAt(i) == &#39;\n&#39;) // jtreg tests always use Unix line endings
291                     line++;
292             }
293             return line;
294         } catch (IOException e) {
295             return -1;
296         }
297     }
298 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.*;
 25 import java.lang.reflect.*;
 26 import java.util.*;
 27 import javax.tools.*;
 28 
<span class="line-added"> 29 import com.sun.source.doctree.DocCommentTree;</span>
<span class="line-added"> 30 import com.sun.source.doctree.DocTree;</span>
 31 import com.sun.source.tree.CompilationUnitTree;
 32 import com.sun.source.tree.Tree;
 33 import com.sun.source.util.JavacTask;
 34 import com.sun.tools.javac.api.JavacTool;
<span class="line-added"> 35 import com.sun.tools.javac.tree.DCTree;</span>
<span class="line-added"> 36 import com.sun.tools.javac.tree.DCTree.DCDocComment;</span>
 37 import com.sun.tools.javac.tree.JCTree;
 38 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
<span class="line-modified"> 39 import com.sun.tools.javac.util.Pair;</span>
 40 
 41 public abstract class AbstractTreeScannerTest {
 42 
 43     /**
 44      * Run the program. A base directory can be provided for file arguments.
 45      * In jtreg mode, the -r option can be given to change the default base
 46      * directory to the test root directory. For other options, see usage().
 47      * @param baseDir base directory for any file arguments.
 48      * @param args command line args
 49      * @return true if successful or in gui mode
 50      */
 51     boolean run(File baseDir, String... args) {
 52         if (args.length == 0) {
 53             usage(System.out);
 54             return true;
 55         }
 56 
 57         ArrayList&lt;File&gt; files = new ArrayList&lt;File&gt;();
 58         for (int i = 0; i &lt; args.length; i++) {
 59             String arg = args[i];
</pre>
<hr />
<pre>
128         if (file.isFile() &amp;&amp; file.getName().endsWith(&quot;.java&quot;)) {
129             try {
130                 if (verbose)
131                     System.err.println(file);
132                 fileCount++;
133                 treeCount += test(read(file));
134             } catch (ParseException e) {
135                 if (!quiet) {
136                     error(&quot;Error parsing &quot; + file + &quot;\n&quot; + e.getMessage());
137                 }
138             } catch (IOException e) {
139                 error(&quot;Error reading &quot; + file + &quot;: &quot; + e);
140             }
141             return;
142         }
143 
144         if (!quiet)
145             error(&quot;File &quot; + file + &quot; ignored&quot;);
146     }
147 
<span class="line-modified">148     abstract int test(Pair&lt;JavacTask, JCCompilationUnit&gt; taskAndTree);</span>
149 
150     // See CR:  6982992 Tests CheckAttributedTree.java, JavacTreeScannerTest.java, and SourceTreeeScannerTest.java timeout
151     StringWriter sw = new StringWriter();
152     PrintWriter pw = new PrintWriter(sw);
153     Reporter r = new Reporter(pw);
154     JavacTool tool = JavacTool.create();
155     StandardJavaFileManager fm = tool.getStandardFileManager(r, null, null);
156 
157     /**
158      * Read a file.
159      * @param file the file to be read
160      * @return the tree for the content of the file
161      * @throws IOException if any IO errors occur
162      * @throws TreePosTest.ParseException if any errors occur while parsing the file
163      */
<span class="line-modified">164     Pair&lt;JavacTask, JCCompilationUnit&gt; read(File file) throws IOException, ParseException {</span>
165         JavacTool tool = JavacTool.create();
166         r.errors = 0;
167         Iterable&lt;? extends JavaFileObject&gt; files = fm.getJavaFileObjects(file);
168         JavacTask task = tool.getTask(pw, fm, r, Collections.&lt;String&gt;emptyList(), null, files);
169         Iterable&lt;? extends CompilationUnitTree&gt; trees = task.parse();
170         pw.flush();
171         if (r.errors &gt; 0)
172             throw new ParseException(sw.toString());
173         Iterator&lt;? extends CompilationUnitTree&gt; iter = trees.iterator();
174         if (!iter.hasNext())
175             throw new Error(&quot;no trees found&quot;);
176         JCCompilationUnit t = (JCCompilationUnit) iter.next();
177         if (iter.hasNext())
178             throw new Error(&quot;too many trees found&quot;);
<span class="line-modified">179         return Pair.of(task, t);</span>
180     }
181 
182     /**
183      * Report an error. When the program is complete, the program will either
184      * exit or throw an Error if any errors have been reported.
185      * @param msg the error message
186      */
187     void error(String msg) {
188         System.err.println(msg);
189         errors++;
190     }
191 
192     /**
193      * Report an error. When the program is complete, the program will either
194      * exit or throw an Error if any errors have been reported.
195      * @param msg the error message
196      */
197     void error(JavaFileObject file, String msg) {
198         System.err.println(file.getName() + &quot;: &quot; + msg);
199         errors++;
200     }
201 
202     /**
203      *  Report an error for a specific tree node.
204      *  @param file the source file for the tree
205      *  @param t    the tree node
206      *  @param label an indication of the error
207      */
208     void error(JavaFileObject file, Tree tree, String msg) {
209         JCTree t = (JCTree) tree;
<span class="line-modified">210         error(file.getName() + &quot;:&quot; + getLine(file, t.pos) + &quot;: &quot; + msg + &quot; &quot; + trim(t, 64));</span>
<span class="line-added">211     }</span>
<span class="line-added">212 </span>
<span class="line-added">213     /**</span>
<span class="line-added">214      *  Report an error for a specific tree node.</span>
<span class="line-added">215      *  @param file the source file for the tree</span>
<span class="line-added">216      *  @param t    the tree node</span>
<span class="line-added">217      *  @param label an indication of the error</span>
<span class="line-added">218      */</span>
<span class="line-added">219     void error(JavaFileObject file, DocCommentTree comment, DocTree tree, String msg) {</span>
<span class="line-added">220         DCDocComment dc = (DCDocComment) comment;</span>
<span class="line-added">221         DCTree t = (DCTree) tree;</span>
<span class="line-added">222         error(file.getName() + &quot;:&quot; + getLine(file, t.getSourcePosition(dc)) + &quot;: &quot; + msg + &quot; &quot; + trim(t, 64));</span>
223     }
224 
225     /**
226      * Get a trimmed string for a tree node, with normalized white space and limited length.
227      */
<span class="line-modified">228     String trim(Object tree, int len) {</span>
<span class="line-modified">229         String s = tree.toString().replaceAll(&quot;\\s+&quot;, &quot; &quot;);</span>

230         return (s.length() &lt; len) ? s : s.substring(0, len);
231     }
232 
233     /** Number of files that have been analyzed. */
234     int fileCount;
235     /** Number of trees that have been successfully compared. */
236     int treeCount;
237     /** Number of errors reported. */
238     int errors;
239     /** Flag: don&#39;t report irrelevant files. */
240     boolean quiet;
241     /** Flag: report files as they are processed. */
242     boolean verbose;
243 
244 
245     /**
246      * Thrown when errors are found parsing a java file.
247      */
248     private static class ParseException extends Exception {
249         ParseException(String msg) {
</pre>
<hr />
<pre>
274      * Get the set of fields for a tree node that may contain child tree nodes.
275      * These are the fields that are subtypes of JCTree or List.
276      * The results are cached, based on the tree&#39;s tag.
277      */
278     Set&lt;Field&gt; getFields(JCTree tree) {
279         Set&lt;Field&gt; fields = map.get(tree.getTag());
280         if (fields == null) {
281             fields = new HashSet&lt;Field&gt;();
282             for (Field f: tree.getClass().getFields()) {
283                 Class&lt;?&gt; fc = f.getType();
284                 if (JCTree.class.isAssignableFrom(fc) || List.class.isAssignableFrom(fc))
285                     fields.add(f);
286             }
287             map.put(tree.getTag(), fields);
288         }
289         return fields;
290     }
291     // where
292     Map&lt;JCTree.Tag, Set&lt;Field&gt;&gt; map = new HashMap&lt;JCTree.Tag,Set&lt;Field&gt;&gt;();
293 
<span class="line-added">294     /**</span>
<span class="line-added">295      * Get the set of fields for a tree node that may contain child tree nodes.</span>
<span class="line-added">296      * These are the fields that are subtypes of DCTree or List.</span>
<span class="line-added">297      * The results are cached, based on the tree&#39;s tag.</span>
<span class="line-added">298      */</span>
<span class="line-added">299     Set&lt;Field&gt; getFields(DCTree tree) {</span>
<span class="line-added">300         Set&lt;Field&gt; fields = dcMap.get(tree.getKind());</span>
<span class="line-added">301         if (fields == null) {</span>
<span class="line-added">302             fields = new HashSet&lt;Field&gt;();</span>
<span class="line-added">303             for (Field f: tree.getClass().getFields()) {</span>
<span class="line-added">304                 Class&lt;?&gt; fc = f.getType();</span>
<span class="line-added">305                 if (DCTree.class.isAssignableFrom(fc) || List.class.isAssignableFrom(fc))</span>
<span class="line-added">306                     fields.add(f);</span>
<span class="line-added">307             }</span>
<span class="line-added">308             dcMap.put(tree.getKind(), fields);</span>
<span class="line-added">309         }</span>
<span class="line-added">310         return fields;</span>
<span class="line-added">311     }</span>
<span class="line-added">312     // where</span>
<span class="line-added">313     Map&lt;DCTree.Kind, Set&lt;Field&gt;&gt; dcMap = new HashMap&lt;&gt;();</span>
<span class="line-added">314 </span>
315     /** Get the line number for the primary position for a tree.
316      * The code is intended to be simple, although not necessarily efficient.
317      * However, note that a file manager such as JavacFileManager is likely
318      * to cache the results of file.getCharContent, avoiding the need to read
319      * the bits from disk each time this method is called.
320      */
<span class="line-modified">321     int getLine(JavaFileObject file, long pos) {</span>
322         try {
323             CharSequence cs = file.getCharContent(true);
324             int line = 1;
<span class="line-modified">325             for (int i = 0; i &lt; pos; i++) {</span>
326                 if (cs.charAt(i) == &#39;\n&#39;) // jtreg tests always use Unix line endings
327                     line++;
328             }
329             return line;
330         } catch (IOException e) {
331             return -1;
332         }
333     }
334 }
</pre>
</td>
</tr>
</table>
<center><a href="../sym/ElementStructureTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="JavacTreeScannerTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
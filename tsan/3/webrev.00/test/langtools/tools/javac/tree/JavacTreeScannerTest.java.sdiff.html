<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/langtools/tools/javac/tree/JavacTreeScannerTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractTreeScannerTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NoPrivateTypesExported.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/langtools/tools/javac/tree/JavacTreeScannerTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 32  * covering any new language features that may be tested in this test suite.
 33  */
 34 
 35 /*
 36  * @test
 37  * @bug 6923080
 38  * @summary TreeScanner.visitNewClass should scan tree.typeargs
 39  * @modules jdk.compiler/com.sun.tools.javac.api
 40  *          jdk.compiler/com.sun.tools.javac.file
 41  *          jdk.compiler/com.sun.tools.javac.tree
 42  *          jdk.compiler/com.sun.tools.javac.util
 43  * @build AbstractTreeScannerTest JavacTreeScannerTest
 44  * @run main JavacTreeScannerTest -q -r .
 45  */
 46 
 47 import java.io.*;
 48 import java.lang.reflect.*;
 49 import java.util.*;
 50 import javax.tools.*;
 51 

 52 import com.sun.tools.javac.tree.JCTree;
 53 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 54 import com.sun.tools.javac.tree.TreeScanner;
 55 import com.sun.tools.javac.util.List;

 56 
 57 public class JavacTreeScannerTest extends AbstractTreeScannerTest {
 58     /**
 59      * Main entry point.
 60      * If test.src is set, program runs in jtreg mode, and will throw an Error
 61      * if any errors arise, otherwise System.exit will be used. In jtreg mode,
 62      * the default base directory for file args is the value of ${test.src}.
 63      * In jtreg mode, the -r option can be given to change the default base
 64      * directory to the root test directory.
 65      */
 66     public static void main(String... args) {
 67         String testSrc = System.getProperty(&quot;test.src&quot;);
 68         File baseDir = (testSrc == null) ? null : new File(testSrc);
 69         boolean ok = new JavacTreeScannerTest().run(baseDir, args);
 70         if (!ok) {
 71             if (testSrc != null)  // jtreg mode
 72                 throw new Error(&quot;failed&quot;);
 73             else
 74                 System.exit(1);
 75         }
 76     }
 77 
<span class="line-modified"> 78     int test(JCCompilationUnit tree) {</span>
<span class="line-modified"> 79         return new ScanTester().test(tree);</span>
 80     }
 81 
 82     /**
 83      * Main class for testing operation of tree scanner.
 84      * The set of nodes found by the scanner are compared
 85      * against the set of nodes found by reflection.
 86      */
 87     private class ScanTester extends TreeScanner {
 88         /** Main entry method for the class. */
 89         int test(JCCompilationUnit tree) {
 90             sourcefile = tree.sourcefile;
 91             found = new HashSet&lt;JCTree&gt;();
 92             scan(tree);
 93             expect = new HashSet&lt;JCTree&gt;();
 94             reflectiveScan(tree);
 95 
 96             if (found.equals(expect)) {
 97                 //System.err.println(sourcefile.getName() + &quot;: trees compared OK&quot;);
 98                 return found.size();
 99             }
100 
101             error(sourcefile, &quot;differences found&quot;);
102 
<span class="line-modified">103             if (found.size() != expect.size())</span>
104                 error(&quot;Size mismatch; found: &quot; + found.size() + &quot;, expected: &quot; + expect.size());













105 
106             Set&lt;JCTree&gt; missing = new HashSet&lt;JCTree&gt;();
107             missing.addAll(expect);
108             missing.removeAll(found);
109             for (JCTree t: missing)
110                 error(sourcefile, t, &quot;missing&quot;);
111 
112             Set&lt;JCTree&gt; excess = new HashSet&lt;JCTree&gt;();
113             excess.addAll(found);
114             excess.removeAll(expect);
115             for (JCTree t: excess)
116                 error(sourcefile, t, &quot;unexpected&quot;);
117 
118             return 0;
119         }
120 
121         /** Record all tree nodes found by scanner. */
122         @Override
123         public void scan(JCTree tree) {
124             if (tree == null)
</pre>
<hr />
<pre>
131         /** record all tree nodes found by reflection. */
132         public void reflectiveScan(Object o) {
133             if (o == null)
134                 return;
135             if (o instanceof JCTree) {
136                 JCTree tree = (JCTree) o;
137                 //System.err.println(&quot;EXPECT: &quot; + tree.getTag() + &quot; &quot; + trim(tree, 64));
138                 expect.add(tree);
139                 for (Field f: getFields(tree)) {
140                     try {
141                         //System.err.println(&quot;FIELD: &quot; + f.getName());
142                         reflectiveScan(f.get(tree));
143                     } catch (IllegalAccessException e) {
144                         error(e.toString());
145                     }
146                 }
147             } else if (o instanceof List) {
148                 List&lt;?&gt; list = (List&lt;?&gt;) o;
149                 for (Object item: list)
150                     reflectiveScan(item);


151             } else
152                 error(&quot;unexpected item: &quot; + o);
153         }
154 
155         JavaFileObject sourcefile;
156         Set&lt;JCTree&gt; found;
157         Set&lt;JCTree&gt; expect;
158     }
159 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 32  * covering any new language features that may be tested in this test suite.
 33  */
 34 
 35 /*
 36  * @test
 37  * @bug 6923080
 38  * @summary TreeScanner.visitNewClass should scan tree.typeargs
 39  * @modules jdk.compiler/com.sun.tools.javac.api
 40  *          jdk.compiler/com.sun.tools.javac.file
 41  *          jdk.compiler/com.sun.tools.javac.tree
 42  *          jdk.compiler/com.sun.tools.javac.util
 43  * @build AbstractTreeScannerTest JavacTreeScannerTest
 44  * @run main JavacTreeScannerTest -q -r .
 45  */
 46 
 47 import java.io.*;
 48 import java.lang.reflect.*;
 49 import java.util.*;
 50 import javax.tools.*;
 51 
<span class="line-added"> 52 import com.sun.source.util.JavacTask;</span>
 53 import com.sun.tools.javac.tree.JCTree;
 54 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 55 import com.sun.tools.javac.tree.TreeScanner;
 56 import com.sun.tools.javac.util.List;
<span class="line-added"> 57 import com.sun.tools.javac.util.Pair;</span>
 58 
 59 public class JavacTreeScannerTest extends AbstractTreeScannerTest {
 60     /**
 61      * Main entry point.
 62      * If test.src is set, program runs in jtreg mode, and will throw an Error
 63      * if any errors arise, otherwise System.exit will be used. In jtreg mode,
 64      * the default base directory for file args is the value of ${test.src}.
 65      * In jtreg mode, the -r option can be given to change the default base
 66      * directory to the root test directory.
 67      */
 68     public static void main(String... args) {
 69         String testSrc = System.getProperty(&quot;test.src&quot;);
 70         File baseDir = (testSrc == null) ? null : new File(testSrc);
 71         boolean ok = new JavacTreeScannerTest().run(baseDir, args);
 72         if (!ok) {
 73             if (testSrc != null)  // jtreg mode
 74                 throw new Error(&quot;failed&quot;);
 75             else
 76                 System.exit(1);
 77         }
 78     }
 79 
<span class="line-modified"> 80     int test(Pair&lt;JavacTask, JCCompilationUnit&gt; taskAndTree) {</span>
<span class="line-modified"> 81         return new ScanTester().test(taskAndTree.snd);</span>
 82     }
 83 
 84     /**
 85      * Main class for testing operation of tree scanner.
 86      * The set of nodes found by the scanner are compared
 87      * against the set of nodes found by reflection.
 88      */
 89     private class ScanTester extends TreeScanner {
 90         /** Main entry method for the class. */
 91         int test(JCCompilationUnit tree) {
 92             sourcefile = tree.sourcefile;
 93             found = new HashSet&lt;JCTree&gt;();
 94             scan(tree);
 95             expect = new HashSet&lt;JCTree&gt;();
 96             reflectiveScan(tree);
 97 
 98             if (found.equals(expect)) {
 99                 //System.err.println(sourcefile.getName() + &quot;: trees compared OK&quot;);
100                 return found.size();
101             }
102 
103             error(sourcefile, &quot;differences found&quot;);
104 
<span class="line-modified">105             if (found.size() != expect.size()) {</span>
106                 error(&quot;Size mismatch; found: &quot; + found.size() + &quot;, expected: &quot; + expect.size());
<span class="line-added">107                 Set&lt;JCTree&gt; notFound = new HashSet&lt;&gt;(expect);</span>
<span class="line-added">108                 notFound.removeAll(found);</span>
<span class="line-added">109                 if (!notFound.isEmpty()) {</span>
<span class="line-added">110                     System.err.println(&quot;found by reflective access to the AST, but not found in the scanner API:&quot;);</span>
<span class="line-added">111                     notFound.forEach(t -&gt; System.err.println(trim(t, 64)));</span>
<span class="line-added">112                 }</span>
<span class="line-added">113                 Set&lt;JCTree&gt; notExpected = new HashSet&lt;&gt;(found);</span>
<span class="line-added">114                 notExpected.removeAll(expect);</span>
<span class="line-added">115                 if (!notExpected.isEmpty()) {</span>
<span class="line-added">116                     System.err.println(&quot;found in the scanner API, but not found by reflective access to the AST:&quot;);</span>
<span class="line-added">117                     notExpected.forEach(t -&gt; System.err.println(trim(t, 64)));</span>
<span class="line-added">118                 }</span>
<span class="line-added">119             }</span>
120 
121             Set&lt;JCTree&gt; missing = new HashSet&lt;JCTree&gt;();
122             missing.addAll(expect);
123             missing.removeAll(found);
124             for (JCTree t: missing)
125                 error(sourcefile, t, &quot;missing&quot;);
126 
127             Set&lt;JCTree&gt; excess = new HashSet&lt;JCTree&gt;();
128             excess.addAll(found);
129             excess.removeAll(expect);
130             for (JCTree t: excess)
131                 error(sourcefile, t, &quot;unexpected&quot;);
132 
133             return 0;
134         }
135 
136         /** Record all tree nodes found by scanner. */
137         @Override
138         public void scan(JCTree tree) {
139             if (tree == null)
</pre>
<hr />
<pre>
146         /** record all tree nodes found by reflection. */
147         public void reflectiveScan(Object o) {
148             if (o == null)
149                 return;
150             if (o instanceof JCTree) {
151                 JCTree tree = (JCTree) o;
152                 //System.err.println(&quot;EXPECT: &quot; + tree.getTag() + &quot; &quot; + trim(tree, 64));
153                 expect.add(tree);
154                 for (Field f: getFields(tree)) {
155                     try {
156                         //System.err.println(&quot;FIELD: &quot; + f.getName());
157                         reflectiveScan(f.get(tree));
158                     } catch (IllegalAccessException e) {
159                         error(e.toString());
160                     }
161                 }
162             } else if (o instanceof List) {
163                 List&lt;?&gt; list = (List&lt;?&gt;) o;
164                 for (Object item: list)
165                     reflectiveScan(item);
<span class="line-added">166             } else if (o instanceof Pair) {</span>
<span class="line-added">167                 return;</span>
168             } else
169                 error(&quot;unexpected item: &quot; + o);
170         }
171 
172         JavaFileObject sourcefile;
173         Set&lt;JCTree&gt; found;
174         Set&lt;JCTree&gt; expect;
175     }
176 }
</pre>
</td>
</tr>
</table>
<center><a href="AbstractTreeScannerTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NoPrivateTypesExported.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff test/langtools/tools/javac/tree/AbstractTreeScannerTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../sym/ElementStructureTest.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="JavacTreeScannerTest.java.udiff.html" target="_top">next &gt;</a></center>    <h2>test/langtools/tools/javac/tree/AbstractTreeScannerTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,17 +24,21 @@</span>
  import java.io.*;
  import java.lang.reflect.*;
  import java.util.*;
  import javax.tools.*;
  
<span class="udiff-line-added">+ import com.sun.source.doctree.DocCommentTree;</span>
<span class="udiff-line-added">+ import com.sun.source.doctree.DocTree;</span>
  import com.sun.source.tree.CompilationUnitTree;
  import com.sun.source.tree.Tree;
  import com.sun.source.util.JavacTask;
  import com.sun.tools.javac.api.JavacTool;
<span class="udiff-line-added">+ import com.sun.tools.javac.tree.DCTree;</span>
<span class="udiff-line-added">+ import com.sun.tools.javac.tree.DCTree.DCDocComment;</span>
  import com.sun.tools.javac.tree.JCTree;
  import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
<span class="udiff-line-modified-removed">- import com.sun.tools.javac.util.List;</span>
<span class="udiff-line-modified-added">+ import com.sun.tools.javac.util.Pair;</span>
  
  public abstract class AbstractTreeScannerTest {
  
      /**
       * Run the program. A base directory can be provided for file arguments.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -139,11 +143,11 @@</span>
  
          if (!quiet)
              error(&quot;File &quot; + file + &quot; ignored&quot;);
      }
  
<span class="udiff-line-modified-removed">-     abstract int test(JCCompilationUnit t);</span>
<span class="udiff-line-modified-added">+     abstract int test(Pair&lt;JavacTask, JCCompilationUnit&gt; taskAndTree);</span>
  
      // See CR:  6982992 Tests CheckAttributedTree.java, JavacTreeScannerTest.java, and SourceTreeeScannerTest.java timeout
      StringWriter sw = new StringWriter();
      PrintWriter pw = new PrintWriter(sw);
      Reporter r = new Reporter(pw);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -155,11 +159,11 @@</span>
       * @param file the file to be read
       * @return the tree for the content of the file
       * @throws IOException if any IO errors occur
       * @throws TreePosTest.ParseException if any errors occur while parsing the file
       */
<span class="udiff-line-modified-removed">-     JCCompilationUnit read(File file) throws IOException, ParseException {</span>
<span class="udiff-line-modified-added">+     Pair&lt;JavacTask, JCCompilationUnit&gt; read(File file) throws IOException, ParseException {</span>
          JavacTool tool = JavacTool.create();
          r.errors = 0;
          Iterable&lt;? extends JavaFileObject&gt; files = fm.getJavaFileObjects(file);
          JavacTask task = tool.getTask(pw, fm, r, Collections.&lt;String&gt;emptyList(), null, files);
          Iterable&lt;? extends CompilationUnitTree&gt; trees = task.parse();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -170,11 +174,11 @@</span>
          if (!iter.hasNext())
              throw new Error(&quot;no trees found&quot;);
          JCCompilationUnit t = (JCCompilationUnit) iter.next();
          if (iter.hasNext())
              throw new Error(&quot;too many trees found&quot;);
<span class="udiff-line-modified-removed">-         return t;</span>
<span class="udiff-line-modified-added">+         return Pair.of(task, t);</span>
      }
  
      /**
       * Report an error. When the program is complete, the program will either
       * exit or throw an Error if any errors have been reported.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -201,19 +205,30 @@</span>
       *  @param t    the tree node
       *  @param label an indication of the error
       */
      void error(JavaFileObject file, Tree tree, String msg) {
          JCTree t = (JCTree) tree;
<span class="udiff-line-modified-removed">-         error(file.getName() + &quot;:&quot; + getLine(file, t) + &quot;: &quot; + msg + &quot; &quot; + trim(t, 64));</span>
<span class="udiff-line-modified-added">+         error(file.getName() + &quot;:&quot; + getLine(file, t.pos) + &quot;: &quot; + msg + &quot; &quot; + trim(t, 64));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      *  Report an error for a specific tree node.</span>
<span class="udiff-line-added">+      *  @param file the source file for the tree</span>
<span class="udiff-line-added">+      *  @param t    the tree node</span>
<span class="udiff-line-added">+      *  @param label an indication of the error</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     void error(JavaFileObject file, DocCommentTree comment, DocTree tree, String msg) {</span>
<span class="udiff-line-added">+         DCDocComment dc = (DCDocComment) comment;</span>
<span class="udiff-line-added">+         DCTree t = (DCTree) tree;</span>
<span class="udiff-line-added">+         error(file.getName() + &quot;:&quot; + getLine(file, t.getSourcePosition(dc)) + &quot;: &quot; + msg + &quot; &quot; + trim(t, 64));</span>
      }
  
      /**
       * Get a trimmed string for a tree node, with normalized white space and limited length.
       */
<span class="udiff-line-modified-removed">-     String trim(Tree tree, int len) {</span>
<span class="udiff-line-modified-removed">-         JCTree t = (JCTree) tree;</span>
<span class="udiff-line-removed">-         String s = t.toString().replaceAll(&quot;\\s+&quot;, &quot; &quot;);</span>
<span class="udiff-line-modified-added">+     String trim(Object tree, int len) {</span>
<span class="udiff-line-modified-added">+         String s = tree.toString().replaceAll(&quot;\\s+&quot;, &quot; &quot;);</span>
          return (s.length() &lt; len) ? s : s.substring(0, len);
      }
  
      /** Number of files that have been analyzed. */
      int fileCount;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -274,21 +289,42 @@</span>
          return fields;
      }
      // where
      Map&lt;JCTree.Tag, Set&lt;Field&gt;&gt; map = new HashMap&lt;JCTree.Tag,Set&lt;Field&gt;&gt;();
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Get the set of fields for a tree node that may contain child tree nodes.</span>
<span class="udiff-line-added">+      * These are the fields that are subtypes of DCTree or List.</span>
<span class="udiff-line-added">+      * The results are cached, based on the tree&#39;s tag.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     Set&lt;Field&gt; getFields(DCTree tree) {</span>
<span class="udiff-line-added">+         Set&lt;Field&gt; fields = dcMap.get(tree.getKind());</span>
<span class="udiff-line-added">+         if (fields == null) {</span>
<span class="udiff-line-added">+             fields = new HashSet&lt;Field&gt;();</span>
<span class="udiff-line-added">+             for (Field f: tree.getClass().getFields()) {</span>
<span class="udiff-line-added">+                 Class&lt;?&gt; fc = f.getType();</span>
<span class="udiff-line-added">+                 if (DCTree.class.isAssignableFrom(fc) || List.class.isAssignableFrom(fc))</span>
<span class="udiff-line-added">+                     fields.add(f);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             dcMap.put(tree.getKind(), fields);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return fields;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // where</span>
<span class="udiff-line-added">+     Map&lt;DCTree.Kind, Set&lt;Field&gt;&gt; dcMap = new HashMap&lt;&gt;();</span>
<span class="udiff-line-added">+ </span>
      /** Get the line number for the primary position for a tree.
       * The code is intended to be simple, although not necessarily efficient.
       * However, note that a file manager such as JavacFileManager is likely
       * to cache the results of file.getCharContent, avoiding the need to read
       * the bits from disk each time this method is called.
       */
<span class="udiff-line-modified-removed">-     int getLine(JavaFileObject file, JCTree tree) {</span>
<span class="udiff-line-modified-added">+     int getLine(JavaFileObject file, long pos) {</span>
          try {
              CharSequence cs = file.getCharContent(true);
              int line = 1;
<span class="udiff-line-modified-removed">-             for (int i = 0; i &lt; tree.pos; i++) {</span>
<span class="udiff-line-modified-added">+             for (int i = 0; i &lt; pos; i++) {</span>
                  if (cs.charAt(i) == &#39;\n&#39;) // jtreg tests always use Unix line endings
                      line++;
              }
              return line;
          } catch (IOException e) {
</pre>
<center><a href="../sym/ElementStructureTest.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="JavacTreeScannerTest.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/tree/TreeKindTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 6341023
 27  * @summary Tree API: Tree.Kind should have mapping to interface
 28  * @modules jdk.compiler
 29  */
 30 
 31 import com.sun.source.tree.*;
 32 
 33 public class TreeKindTest {
 34     public static void main(String... args) {
 35         boolean ok = true;
 36 
 37         for (Tree.Kind k: Tree.Kind.values()) {
 38             //System.err.println(k + &quot; &quot; + k.asInterface());
 39             Class&lt;? extends Tree&gt; i = k.asInterface();
 40             switch (k) {
 41             case POSTFIX_INCREMENT:
 42             case POSTFIX_DECREMENT:
 43             case PREFIX_INCREMENT:
 44             case PREFIX_DECREMENT:
 45             case UNARY_PLUS:
 46             case UNARY_MINUS:
 47             case BITWISE_COMPLEMENT:
 48             case LOGICAL_COMPLEMENT:
 49                 ok = ok &amp; verify(k, i, i == UnaryTree.class);
 50                 break;
 51 
 52             case MULTIPLY:
 53             case DIVIDE:
 54             case REMAINDER:
 55             case PLUS:
 56             case MINUS:
 57             case LEFT_SHIFT:
 58             case RIGHT_SHIFT:
 59             case UNSIGNED_RIGHT_SHIFT:
 60             case LESS_THAN:
 61             case GREATER_THAN:
 62             case LESS_THAN_EQUAL:
 63             case GREATER_THAN_EQUAL:
 64             case EQUAL_TO:
 65             case NOT_EQUAL_TO:
 66             case AND:
 67             case XOR:
 68             case OR:
 69             case CONDITIONAL_AND:
 70             case CONDITIONAL_OR:
 71                 ok = ok &amp; verify(k, i, i == BinaryTree.class);
 72                 break;
 73 
 74             case MULTIPLY_ASSIGNMENT:
 75             case DIVIDE_ASSIGNMENT:
 76             case REMAINDER_ASSIGNMENT:
 77             case PLUS_ASSIGNMENT:
 78             case MINUS_ASSIGNMENT:
 79             case LEFT_SHIFT_ASSIGNMENT:
 80             case RIGHT_SHIFT_ASSIGNMENT:
 81             case UNSIGNED_RIGHT_SHIFT_ASSIGNMENT:
 82             case AND_ASSIGNMENT:
 83             case XOR_ASSIGNMENT:
 84             case OR_ASSIGNMENT:
 85                 ok = ok &amp; verify(k, i, i == CompoundAssignmentTree.class);
 86                 break;
 87 
 88             case INT_LITERAL:
 89             case LONG_LITERAL:
 90             case FLOAT_LITERAL:
 91             case DOUBLE_LITERAL:
 92             case BOOLEAN_LITERAL:
 93             case CHAR_LITERAL:
 94             case STRING_LITERAL:
 95             case NULL_LITERAL:
 96                 ok = ok &amp; verify(k, i, i == LiteralTree.class);
 97                 break;
 98 
 99             case UNBOUNDED_WILDCARD:
100             case EXTENDS_WILDCARD:
101             case SUPER_WILDCARD:
102                 ok = ok &amp; verify(k, i, i == WildcardTree.class);
103                 break;
104 
105             case INTERFACE:
106             case ANNOTATION_TYPE:
107             case ENUM:
108             case CLASS:
109                 ok = ok &amp; verify(k, i, i == ClassTree.class);
110                 break;
111 
112             case ANNOTATION:
113             case TYPE_ANNOTATION:
114                 ok = ok &amp; verify(k, i, i == AnnotationTree.class);
115                 break;
116 
117             case EXPORTS:
118                 ok = ok &amp; verify(k, i, i == ExportsTree.class);
119                 break;
120 
121             case OPENS:
122                 ok = ok &amp; verify(k, i, i == OpensTree.class);
123                 break;
124 
125             case OTHER:
126                 ok = ok &amp; verify(k, i, i == null);
127                 break;
128 
129             default:
130                 String ks = k.toString().replace(&quot;_&quot;, &quot;&quot;) + &quot;tree&quot;;
131                 String iName = i.getName();
132                 String is = iName.substring(iName.lastIndexOf(&quot;.&quot;) + 1);
133                 ok = ok &amp; verify(k, i, ks.equalsIgnoreCase(is));
134             }
135         }
136 
137         if (!ok)
138             throw new AssertionError(&quot;test failed&quot;);
139     }
140 
141     static boolean verify(Tree.Kind k, Class&lt;?&gt; c, boolean b) {
142         if (!b)
143             System.err.println(&quot;error: &quot; + k + &quot; &quot; + c);
144         return b;
145     }
146 }
    </pre>
  </body>
</html>
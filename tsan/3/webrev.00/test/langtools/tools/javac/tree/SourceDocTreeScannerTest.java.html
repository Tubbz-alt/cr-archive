<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/tree/SourceDocTreeScannerTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * Utility and test program to check public DocTreeScanner class.
 26  * The program can be run standalone, or as a jtreg test.  For info on
 27  * command line args, run program with no args.
 28  *
 29  * &lt;p&gt;
 30  * jtreg: Note that by using the -r switch in the test description below, this test
 31  * will process all java files in the langtools/test directory, thus implicitly
 32  * covering any new language features that may be tested in this test suite.
 33  */
 34 
 35 /*
 36  * @test
 37  * @bug 8227922
 38  * @summary Verify the behavior of DocTreeScanner
 39  * @modules jdk.compiler/com.sun.tools.javac.api
 40  *          jdk.compiler/com.sun.tools.javac.tree
 41  *          jdk.compiler/com.sun.tools.javac.util
 42  * @build AbstractTreeScannerTest SourceDocTreeScannerTest
 43  * @run main SourceDocTreeScannerTest -q -r .
 44  */
 45 
 46 import java.io.*;
 47 import java.lang.reflect.*;
 48 import java.util.*;
 49 
 50 import javax.tools.*;
 51 
 52 import com.sun.source.doctree.DocCommentTree;
 53 import com.sun.source.doctree.DocTree;
 54 import com.sun.source.tree.Tree;
 55 import com.sun.source.util.DocTreeScanner;
 56 import com.sun.source.util.DocTrees;
 57 import com.sun.source.util.JavacTask;
 58 import com.sun.source.util.TreePath;
 59 import com.sun.source.util.TreePathScanner;
 60 import com.sun.tools.javac.tree.DCTree;
 61 import com.sun.tools.javac.tree.DCTree.DCDocComment;
 62 import com.sun.tools.javac.tree.DCTree.DCReference;
 63 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 64 import com.sun.tools.javac.util.List;
 65 import com.sun.tools.javac.util.Pair;
 66 
 67 public class SourceDocTreeScannerTest extends AbstractTreeScannerTest {
 68     /**
 69      * Main entry point.
 70      * If test.src is set, program runs in jtreg mode, and will throw an Error
 71      * if any errors arise, otherwise System.exit will be used. In jtreg mode,
 72      * the default base directory for file args is the value of ${test.src}.
 73      * In jtreg mode, the -r option can be given to change the default base
 74      * directory to the root test directory.
 75      */
 76     public static void main(String... args) {
 77         String testSrc = System.getProperty(&quot;test.src&quot;);
 78         File baseDir = (testSrc == null) ? null : new File(testSrc);
 79         boolean ok = new SourceDocTreeScannerTest().run(baseDir, args);
 80         if (!ok) {
 81             if (testSrc != null)  // jtreg mode
 82                 throw new Error(&quot;failed&quot;);
 83             else
 84                 System.exit(1);
 85         }
 86     }
 87 
 88     int test(Pair&lt;JavacTask, JCCompilationUnit&gt; taskAndTree) {
 89         return new ScanTester().test(taskAndTree);
 90     }
 91 
 92     /**
 93      * Main class for testing operation of tree scanner.
 94      * The set of nodes found by the scanner are compared
 95      * against the set of nodes found by reflection.
 96      */
 97     private class ScanTester extends DocTreeScanner&lt;Void,Void&gt; {
 98         /** Main entry method for the class. */
 99         int test(Pair&lt;JavacTask, JCCompilationUnit&gt; taskAndTree) {
100             sourcefile = taskAndTree.snd.sourcefile;
101             int[] count = new int[1];
102             new TreePathScanner&lt;Void, Void&gt;() {
103                 @Override
104                 public Void scan(Tree tree, Void p) {
105                     if (tree != null) {
106                         DocTrees trees = DocTrees.instance(taskAndTree.fst);
107                         DocCommentTree dcTree = trees.getDocCommentTree(new TreePath(getCurrentPath(), tree));
108                         if (dcTree != null) {
109                             found = new HashSet&lt;&gt;();
110                             ScanTester.this.scan(dcTree, null);
111                             expect = new HashSet&lt;&gt;();
112                             ScanTester.this.reflectiveScan(dcTree);
113 
114                             if (found.equals(expect)) {
115                                 //System.err.println(sourcefile.getName() + &quot;: trees compared OK&quot;);
116                                 count[0] += found.size();
117                             } else {
118                                 error(sourcefile.getName() + &quot;: differences found&quot;);
119 
120                                 if (found.size() != expect.size())
121                                     error(&quot;Size mismatch; found: &quot; + found.size() + &quot;, expected: &quot; + expect.size());
122 
123                                 Set&lt;DocTree&gt; missing = new HashSet&lt;&gt;();
124                                 missing.addAll(expect);
125                                 missing.removeAll(found);
126                                 for (DocTree t: missing)
127                                     error(sourcefile, dcTree, t, &quot;missing&quot;);
128 
129                                 Set&lt;DocTree&gt; excess = new HashSet&lt;&gt;();
130                                 excess.addAll(found);
131                                 excess.removeAll(expect);
132                                 for (DocTree t: excess)
133                                     error(sourcefile, dcTree, t, &quot;unexpected&quot;);
134                             }
135                         }
136                     }
137                     return super.scan(tree, p);
138                 }
139             }.scan(taskAndTree.snd, null);
140 
141             return 0;
142         }
143 
144         /** Record all tree nodes found by scanner. */
145         @Override
146         public Void scan(DocTree tree, Void ignore) {
147             if (tree == null)
148                 return null;
149             //System.err.println(&quot;FOUND: &quot; + tree.getKind() + &quot; &quot; + trim(tree, 64));
150             found.add(tree);
151             return super.scan(tree, ignore);
152         }
153 
154         /** record all tree nodes found by reflection. */
155         public void reflectiveScan(Object o) {
156             if (o == null)
157                 return;
158             if (o instanceof DCTree) {
159                 DCTree tree = (DCTree) o;
160                 //System.err.println(&quot;EXPECT: &quot; + tree.getKind() + &quot; &quot; + trim(tree, 64));
161                 expect.add(tree);
162                 for (Field f: getFields(tree)) {
163                     try {
164                         if (tree instanceof DCReference &amp;&amp; f.getName().equals(&quot;paramTypes&quot;)) {
165                             //ignore - list of JCTrees
166                         } else if (tree instanceof DCDocComment &amp;&amp;
167                                    !f.getName().equals(&quot;firstSentence&quot;) &amp;&amp;
168                                    !f.getName().equals(&quot;body&quot;) &amp;&amp;
169                                    !f.getName().equals(&quot;tags&quot;)) {
170                             //ignore - covered by other fields
171                         } else {
172                             reflectiveScan(f.get(tree));
173                         }
174                     } catch (IllegalAccessException e) {
175                         error(e.toString());
176                     }
177                 }
178             } else if (o instanceof List) {
179                 List&lt;?&gt; list = (List&lt;?&gt;) o;
180                 for (Object item: list)
181                     reflectiveScan(item);
182             } else
183                 error(&quot;unexpected item: &quot; + o);
184         }
185 
186         JavaFileObject sourcefile;
187         Set&lt;DocTree&gt; found;
188         Set&lt;DocTree&gt; expect;
189     }
190 }
    </pre>
  </body>
</html>
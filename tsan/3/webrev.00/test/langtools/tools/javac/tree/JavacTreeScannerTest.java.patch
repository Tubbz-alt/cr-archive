diff a/test/langtools/tools/javac/tree/JavacTreeScannerTest.java b/test/langtools/tools/javac/tree/JavacTreeScannerTest.java
--- a/test/langtools/tools/javac/tree/JavacTreeScannerTest.java
+++ b/test/langtools/tools/javac/tree/JavacTreeScannerTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -47,14 +47,16 @@
 import java.io.*;
 import java.lang.reflect.*;
 import java.util.*;
 import javax.tools.*;
 
+import com.sun.source.util.JavacTask;
 import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 import com.sun.tools.javac.tree.TreeScanner;
 import com.sun.tools.javac.util.List;
+import com.sun.tools.javac.util.Pair;
 
 public class JavacTreeScannerTest extends AbstractTreeScannerTest {
     /**
      * Main entry point.
      * If test.src is set, program runs in jtreg mode, and will throw an Error
@@ -73,12 +75,12 @@
             else
                 System.exit(1);
         }
     }
 
-    int test(JCCompilationUnit tree) {
-        return new ScanTester().test(tree);
+    int test(Pair<JavacTask, JCCompilationUnit> taskAndTree) {
+        return new ScanTester().test(taskAndTree.snd);
     }
 
     /**
      * Main class for testing operation of tree scanner.
      * The set of nodes found by the scanner are compared
@@ -98,12 +100,25 @@
                 return found.size();
             }
 
             error(sourcefile, "differences found");
 
-            if (found.size() != expect.size())
+            if (found.size() != expect.size()) {
                 error("Size mismatch; found: " + found.size() + ", expected: " + expect.size());
+                Set<JCTree> notFound = new HashSet<>(expect);
+                notFound.removeAll(found);
+                if (!notFound.isEmpty()) {
+                    System.err.println("found by reflective access to the AST, but not found in the scanner API:");
+                    notFound.forEach(t -> System.err.println(trim(t, 64)));
+                }
+                Set<JCTree> notExpected = new HashSet<>(found);
+                notExpected.removeAll(expect);
+                if (!notExpected.isEmpty()) {
+                    System.err.println("found in the scanner API, but not found by reflective access to the AST:");
+                    notExpected.forEach(t -> System.err.println(trim(t, 64)));
+                }
+            }
 
             Set<JCTree> missing = new HashSet<JCTree>();
             missing.addAll(expect);
             missing.removeAll(found);
             for (JCTree t: missing)
@@ -146,10 +161,12 @@
                 }
             } else if (o instanceof List) {
                 List<?> list = (List<?>) o;
                 for (Object item: list)
                     reflectiveScan(item);
+            } else if (o instanceof Pair) {
+                return;
             } else
                 error("unexpected item: " + o);
         }
 
         JavaFileObject sourcefile;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/plugin/InternalAPI.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  *  @test
 26  *  @bug 8235597
 27  *  @summary Extend support for -XDaccessInternalAPI to plugin modules
 28  *  @library /tools/lib
 29  *  @modules jdk.compiler/com.sun.tools.javac.api
 30  *           jdk.compiler/com.sun.tools.javac.code
 31  *           jdk.compiler/com.sun.tools.javac.main
 32  *           jdk.jlink
 33  *  @build toolbox.ToolBox toolbox.JavacTask toolbox.JarTask
 34  *  @run main InternalAPI
 35  */
 36 
 37 import java.io.IOException;
 38 import java.util.List;
 39 import java.nio.file.Files;
 40 import java.nio.file.Path;
 41 import java.util.spi.ToolProvider;
 42 
 43 import toolbox.ExecTask;
 44 import toolbox.JarTask;
 45 import toolbox.JavacTask;
 46 import toolbox.Task;
 47 import toolbox.TestRunner;
 48 import toolbox.ToolBox;
 49 
 50 public class InternalAPI extends TestRunner {
 51     public static void main(String... args) throws Exception {
 52         new InternalAPI().run();
 53     }
 54 
 55     InternalAPI() {
 56         super(System.out);
 57     }
 58 
 59     ToolBox tb = new ToolBox();
 60 
 61     Path pluginJar;
 62     Path mclasses;
 63 
 64     void run() throws Exception {
 65         Path src = Path.of(&quot;src&quot;);
 66         tb.writeJavaFiles(src,
 67             &quot;package p;\n&quot;
 68             + &quot;import javax.lang.model.element.*;\n&quot;
 69             + &quot;import com.sun.source.util.*;\n&quot;
 70             + &quot;import com.sun.tools.javac.code.Symbol.ClassSymbol;\n&quot;
 71             + &quot;public class C implements Plugin, TaskListener {\n&quot;
 72             + &quot;    public String getName() { return \&quot;TestPlugin\&quot;; }\n&quot;
 73             + &quot;    public boolean autoStart() { return true; }\n&quot;
 74             + &quot;    public void init(JavacTask task, String... args) {\n&quot;
 75             + &quot;        System.out.println(\&quot;C.init \&quot; + java.util.Arrays.toString(args));\n&quot;
 76             + &quot;        task.addTaskListener(this);\n&quot;
 77             + &quot;    }\n&quot;
 78             + &quot;    public void started(TaskEvent e) {\n&quot;
 79             + &quot;        TypeElement te = e.getTypeElement();\n&quot;
 80             + &quot;        if (te != null) {\n&quot;
 81             + &quot;            ClassSymbol sym = (ClassSymbol) te;\n&quot;
 82             + &quot;            System.out.println(e.getKind() + \&quot; \&quot; + te + \&quot; \&quot; + sym.kind);\n&quot;
 83             + &quot;        }\n&quot;
 84             + &quot;    }\n&quot;
 85             + &quot;}\n&quot;);
 86 
 87         Path msrc = Path.of(&quot;msrc&quot;);
 88         tb.writeJavaFiles(msrc,
 89             &quot;module m {\n&quot;
 90             + &quot;    requires jdk.compiler;\n&quot;
 91             + &quot;    provides com.sun.source.util.Plugin with p.C;\n&quot;
 92             + &quot;}\n&quot;);
 93 
 94         Path classes = Files.createDirectories(Path.of(&quot;classes&quot;));
 95         new JavacTask(tb)
 96             .outdir(classes)
 97             .options(&quot;--add-exports&quot;, &quot;jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED&quot;)
 98             .files(tb.findJavaFiles(src))
 99             .run()
100             .writeAll();
101 
102         tb.writeFile(classes.resolve(&quot;META-INF&quot;).resolve(&quot;services&quot;).resolve(&quot;com.sun.source.util.Plugin&quot;),
103                 &quot;p.C\n&quot;);
104 
105         pluginJar = Path.of(&quot;plugin.jar&quot;);
106         new JarTask(tb, pluginJar)
107                 .baseDir(classes)
108                 .files(&quot;.&quot;)
109                 .run();
110 
111         mclasses = Files.createDirectories(Path.of(&quot;mclasses&quot;));
112         new JavacTask(tb)
113             .outdir(mclasses)
114             .sourcepath(msrc, src)
115             .options(&quot;--add-exports&quot;, &quot;jdk.compiler/com.sun.tools.javac.code=m&quot;)
116             .files(tb.findJavaFiles(msrc))
117             .run()
118             .writeAll();
119 
120         Path hw = Path.of(&quot;hw&quot;);
121         tb.writeJavaFiles(hw,
122                 &quot;public class HelloWorld {\n&quot;
123                 + &quot;    public static void main(String... args) {\n&quot;
124                 + &quot;        System.out.println(\&quot;Hello World!\&quot;);\n&quot;
125                 + &quot;    }\n&quot;
126                 + &quot;}\n&quot;);
127 
128         runTests(m -&gt; new Object[] { Path.of(m.getName()) });
129     }
130 
131     @Test
132     public void testClassPath(Path base) throws Exception {
133         List&lt;String&gt; stdout = new JavacTask(tb)
134                 .options(&quot;-XDaccessInternalAPI&quot;)
135                 .classpath(pluginJar)
136                 .outdir(Files.createDirectories(base.resolve(&quot;out&quot;)))
137                 .files(tb.findJavaFiles(Path.of(&quot;hw&quot;)))
138                 .run()
139                 .writeAll()
140                 .getOutputLines(Task.OutputKind.STDOUT);
141         tb.checkEqual(stdout, List.of(&quot;C.init []&quot;, &quot;ANALYZE HelloWorld TYP&quot;, &quot;GENERATE HelloWorld TYP&quot;));
142     }
143 
144     // negative control test: access fails without the new option
145     @Test
146     public void testModuleControl(Path base) throws Exception {
147         try {
148             new JavacTask(tb)
149                     .options(&quot;--processor-module-path&quot;, mclasses.toString())
150                     .outdir(Files.createDirectories(base.resolve(&quot;out&quot;)))
151                     .files(tb.findJavaFiles(Path.of(&quot;hw&quot;)))
152                     .run()
153                     .writeAll();
154             throw new Exception(&quot;expected exception not thrown&quot;);
155         } catch (Exception e) {
156             System.out.println(&quot;*** &quot; + e);
157             String msg = e.getMessage();
158             if (!msg.contains(&quot;java.lang.IllegalAccessError: class p.C (in module m) &quot;
159                 + &quot;cannot access class com.sun.tools.javac.code.Symbol$ClassSymbol (in module jdk.compiler)&quot;)) {
160                 throw new Exception(&quot;expected exception not found&quot;);
161             }
162         }
163     }
164 
165     // positive test: access succeeds with option for modules on modulepath
166     @Test
167     public void testModulePath(Path base) throws IOException {
168         List&lt;String&gt; stdout = new JavacTask(tb)
169                 .options(&quot;--processor-module-path&quot;, mclasses.toString(),
170                         &quot;-XDaccessInternalAPI&quot;)
171                 .outdir(Files.createDirectories(base.resolve(&quot;out&quot;)))
172                 .files(tb.findJavaFiles(Path.of(&quot;hw&quot;)))
173                 .run()
174                 .writeAll()
175                 .getOutputLines(Task.OutputKind.STDOUT);
176         tb.checkEqual(stdout, List.of(&quot;C.init []&quot;, &quot;ANALYZE HelloWorld TYP&quot;, &quot;GENERATE HelloWorld TYP&quot;));
177     }
178 
179     // positive test: access succeeds with option for modules in image
180     @Test
181     public void testImage(Path base) throws Exception {
182         Path tmpJDK = base.resolve(&quot;tmpJDK&quot;);
183         ToolProvider jlink = ToolProvider.findFirst(&quot;jlink&quot;)
184                 .orElseThrow(() -&gt; new Exception(&quot;cannot find jlink&quot;));
185         jlink.run(System.out, System.err,
186                 &quot;--module-path&quot;, mclasses.toString(),
187                 &quot;--add-modules&quot;, &quot;jdk.compiler,jdk.zipfs,m&quot;,
188                 &quot;--output&quot;, tmpJDK.toString());
189 
190         String suffix = tb.isWindows() ? &quot;.exe&quot; : &quot;&quot;;
191         List&lt;String&gt; stdout = new ExecTask(tb, tmpJDK.resolve(&quot;bin&quot;).resolve(&quot;javac&quot; + suffix))
192                 .args(&quot;-d&quot;, Files.createDirectories(base.resolve(&quot;out&quot;)).toString(),
193                         &quot;-XDaccessInternalAPI&quot;,
194                         Path.of(&quot;hw&quot;).resolve(&quot;HelloWorld.java&quot;).toString())
195                 .run()
196                 .writeAll()
197                 .getOutputLines(Task.OutputKind.STDOUT);
198         tb.checkEqual(stdout, List.of(&quot;C.init []&quot;, &quot;ANALYZE HelloWorld TYP&quot;, &quot;GENERATE HelloWorld TYP&quot;));
199     }
200 }
201 
    </pre>
  </body>
</html>
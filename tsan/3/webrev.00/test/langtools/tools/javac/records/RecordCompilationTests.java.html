<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/records/RecordCompilationTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /**
 27  * RecordCompilationTests
 28  *
 29  * @test
 30  * @summary Negative compilation tests, and positive compilation (smoke) tests for records
 31  * @library /lib/combo /tools/lib /tools/javac/lib
 32  * @modules
 33  *      jdk.compiler/com.sun.tools.javac.code
 34  *      jdk.compiler/com.sun.tools.javac.util
 35  *      jdk.jdeps/com.sun.tools.classfile
 36  * @build JavacTestingAbstractProcessor
 37  * @compile --enable-preview -source ${jdk.version} RecordCompilationTests.java
 38  * @run testng/othervm --enable-preview RecordCompilationTests
 39  */
 40 
 41 import java.io.File;
 42 
 43 import java.lang.annotation.ElementType;
 44 import java.util.Arrays;
 45 import java.util.EnumMap;
 46 import java.util.EnumSet;
 47 import java.util.HashSet;
 48 import java.util.List;
 49 import java.util.Map;
 50 import java.util.Set;
 51 import java.util.stream.Collectors;
 52 import java.util.stream.Stream;
 53 
 54 
 55 import com.sun.tools.javac.util.Assert;
 56 
 57 import javax.annotation.processing.RoundEnvironment;
 58 import javax.annotation.processing.SupportedAnnotationTypes;
 59 
 60 import javax.lang.model.element.AnnotationMirror;
 61 import javax.lang.model.element.AnnotationValue;
 62 import javax.lang.model.element.Element;
 63 import javax.lang.model.element.ElementKind;
 64 import javax.lang.model.element.ExecutableElement;
 65 import javax.lang.model.element.RecordComponentElement;
 66 import javax.lang.model.element.TypeElement;
 67 import javax.lang.model.element.VariableElement;
 68 
 69 import javax.lang.model.type.ArrayType;
 70 import javax.lang.model.type.TypeMirror;
 71 
 72 import com.sun.tools.classfile.Annotation;
 73 import com.sun.tools.classfile.Attribute;
 74 import com.sun.tools.classfile.Attributes;
 75 import com.sun.tools.classfile.ClassFile;
 76 import com.sun.tools.classfile.ConstantPool;
 77 import com.sun.tools.classfile.ConstantPool.CPInfo;
 78 import com.sun.tools.classfile.Field;
 79 import com.sun.tools.classfile.Method;
 80 import com.sun.tools.classfile.Record_attribute;
 81 import com.sun.tools.classfile.Record_attribute.ComponentInfo;
 82 import com.sun.tools.classfile.RuntimeAnnotations_attribute;
 83 import com.sun.tools.classfile.RuntimeTypeAnnotations_attribute;
 84 import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;
 85 import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;
 86 import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;
 87 import com.sun.tools.classfile.TypeAnnotation;
 88 
 89 import com.sun.tools.javac.code.Attribute.TypeCompound;
 90 import com.sun.tools.javac.code.Symbol;
 91 import com.sun.tools.javac.code.Symbol.VarSymbol;
 92 
 93 import org.testng.annotations.Test;
 94 import tools.javac.combo.CompilationTestCase;
 95 
 96 import static java.lang.annotation.ElementType.*;
 97 import static org.testng.Assert.assertEquals;
 98 
 99 @Test
100 public class RecordCompilationTests extends CompilationTestCase {
101 
102     // @@@ When records become a permanent feature, we don&#39;t need these any more
103     private static String[] PREVIEW_OPTIONS = {&quot;--enable-preview&quot;, &quot;-source&quot;,
104                                                Integer.toString(Runtime.version().feature())};
105 
106     private static final List&lt;String&gt; BAD_COMPONENT_NAMES = List.of(
107             &quot;clone&quot;, &quot;finalize&quot;, &quot;getClass&quot;, &quot;hashCode&quot;,
108             &quot;notify&quot;, &quot;notifyAll&quot;, &quot;toString&quot;, &quot;wait&quot;);
109 
110     {
111         setDefaultFilename(&quot;R.java&quot;);
112         setCompileOptions(PREVIEW_OPTIONS);
113     }
114 
115     public void testMalformedDeclarations() {
116         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R()&quot;);
117         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R();&quot;);
118         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R(,) { }&quot;);
119         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R((int x)) { }&quot;);
120         assertFail(&quot;compiler.err.record.header.expected&quot;, &quot;record R { }&quot;);
121         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(foo) { }&quot;);
122         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int int) { }&quot;);
123         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;abstract record R(String foo) { }&quot;);
124         //assertFail(&quot;compiler.err.illegal.combination.of.modifiers&quot;, &quot;non-sealed record R(String foo) { }&quot;);
125         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;public public record R(String foo) { }&quot;);
126         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;private private record R(String foo) { }&quot;);
127         assertFail(&quot;compiler.err.already.defined&quot;, &quot;record R(int x, int x) {}&quot;);
128         for (String s : List.of(&quot;var&quot;, &quot;record&quot;))
129             assertFail(&quot;compiler.err.restricted.type.not.allowed.here&quot;, &quot;record R(# x) { }&quot;, s);
130         for (String s : List.of(&quot;public&quot;, &quot;private&quot;, &quot;volatile&quot;, &quot;final&quot;))
131             assertFail(&quot;compiler.err.record.cant.declare.field.modifiers&quot;, &quot;record R(# String foo) { }&quot;, s);
132         assertFail(&quot;compiler.err.varargs.must.be.last&quot;, &quot;record R(int... x, int... y) {}&quot;);
133         assertFail(&quot;compiler.err.instance.initializer.not.allowed.in.records&quot;, &quot;record R(int i) { {} }&quot;);
134     }
135 
136     public void testGoodDeclarations() {
137         assertOK(&quot;public record R() { }&quot;);
138         assertOK(&quot;record R() { }&quot;);
139         assertOK(&quot;record R() implements java.io.Serializable, Runnable { public void run() { } }&quot;);
140         assertOK(&quot;record R(int x) { }&quot;);
141         assertOK(&quot;record R(int x, int y) { }&quot;);
142         assertOK(&quot;record R(int... xs) { }&quot;);
143         assertOK(&quot;record R(String... ss) { }&quot;);
144         assertOK(&quot;@Deprecated record R(int x, int y) { }&quot;);
145         assertOK(&quot;record R(@Deprecated int x, int y) { }&quot;);
146         assertOK(&quot;record R&lt;T&gt;(T x, T y) { }&quot;);
147     }
148 
149     public void testGoodMemberDeclarations() {
150         String template = &quot;public record R(int x) {\n&quot;
151                 + &quot;    public R(int x) { this.x = x; }\n&quot;
152                 + &quot;    public int x() { return x; }\n&quot;
153                 + &quot;    public boolean equals(Object o) { return true; }\n&quot;
154                 + &quot;    public int hashCode() { return 0; }\n&quot;
155                 + &quot;    public String toString() { return null; }\n&quot;
156                 + &quot;}&quot;;
157         assertOK(template);
158     }
159 
160     public void testBadComponentNames() {
161         for (String s : BAD_COMPONENT_NAMES)
162             assertFail(&quot;compiler.err.illegal.record.component.name&quot;, &quot;record R(int #) { } &quot;, s);
163     }
164 
165     public void testRestrictedIdentifiers() {
166         for (String s : List.of(&quot;interface record { void m(); }&quot;,
167                 &quot;@interface record { }&quot;,
168                 &quot;class record { }&quot;,
169                 &quot;record record(int x) { }&quot;,
170                 &quot;enum record { A, B }&quot;,
171                 &quot;class R&lt;record&gt; { }&quot;)) {
172             assertFail(&quot;compiler.err.restricted.type.not.allowed&quot;, s);
173         }
174     }
175 
176     public void testValidMembers() {
177         for (String s : List.of(&quot;record X(int j) { }&quot;,
178                 &quot;interface I { }&quot;,
179                 &quot;static { }&quot;,
180                 &quot;enum E { A, B }&quot;,
181                 &quot;class C { }&quot;
182         )) {
183             assertOK(&quot;record R(int i) { # }&quot;, s);
184         }
185     }
186 
187     public void testCyclic() {
188         // Cyclic records are OK, but cyclic inline records would not be
189         assertOK(&quot;record R(R r) { }&quot;);
190     }
191 
192     public void testBadExtends() {
193         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) extends Object { }&quot;);
194         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) {}\n&quot;
195                 + &quot;record R2(int x) extends R { }&quot;);
196         assertFail(&quot;compiler.err.cant.inherit.from.final&quot;, &quot;record R(int x) {}\n&quot;
197                 + &quot;class C extends R { }&quot;);
198     }
199 
200     public void testNoExtendRecord() {
201         assertFail(&quot;compiler.err.invalid.supertype.record&quot;,
202                    &quot;class R extends Record { public String toString() { return null; } public int hashCode() { return 0; } public boolean equals(Object o) { return false; } } }&quot;);
203     }
204 
205     public void testFieldDeclarations() {
206         // static fields are OK
207         assertOK(&quot;public record R(int x) {\n&quot; +
208                 &quot;    static int I = 1;\n&quot; +
209                 &quot;    static final String S = \&quot;Hello World!\&quot;;\n&quot; +
210                 &quot;    static private Object O = null;\n&quot; +
211                 &quot;    static protected Object O2 = null;\n&quot; +
212                 &quot;}&quot;);
213 
214         // instance fields are not
215         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
216                 &quot;public record R(int x) {\n&quot; +
217                         &quot;    private final int y = 0;&quot; +
218                         &quot;}&quot;);
219 
220         // mutable instance fields definitely not
221         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
222                 &quot;public record R(int x) {\n&quot; +
223                         &quot;    private int y = 0;&quot; +
224                         &quot;}&quot;);
225 
226         // redeclaring components also not
227         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
228                 &quot;public record R(int x) {\n&quot; +
229                         &quot;    private final int x;&quot; +
230                         &quot;}&quot;);
231     }
232 
233     public void testAccessorRedeclaration() {
234         assertOK(&quot;public record R(int x) {\n&quot; +
235                 &quot;    public int x() { return x; };&quot; +
236                 &quot;}&quot;);
237 
238         assertOK(&quot;public record R(int x) {\n&quot; +
239                 &quot;    public final int x() { return 0; };&quot; +
240                 &quot;}&quot;);
241 
242         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
243                 &quot;public record R(int x) {\n&quot; +
244                         &quot;    final int x() { return 0; };&quot; +
245                         &quot;}&quot;);
246 
247         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
248                 &quot;public record R(int x) {\n&quot; +
249                         &quot;    int x() { return 0; };&quot; +
250                         &quot;}&quot;);
251 
252         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
253                 &quot;public record R(int x) {\n&quot; +
254                         &quot;    private int x() { return 0; };&quot; +
255                         &quot;}&quot;);
256 
257         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
258                    &quot;public record R(int x) {\n&quot; +
259                    &quot;    public int x() throws Exception { return 0; };&quot; +
260                    &quot;}&quot;);
261 
262         for (String s : List.of(&quot;List&quot;, &quot;List&lt;?&gt;&quot;, &quot;Object&quot;, &quot;ArrayList&lt;String&gt;&quot;, &quot;int&quot;))
263             assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
264                     &quot;import java.util.*;\n&quot; +
265                             &quot;public record R(List&lt;String&gt; x) {\n&quot; +
266                             &quot;    public # x() { return null; };&quot; +
267                             &quot;}&quot;, s);
268 
269         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
270                 &quot;public record R(int x) {\n&quot; +
271                         &quot;    public &lt;T&gt; int x() { return x; };&quot; +
272                         &quot;}&quot;);
273 
274         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
275                 &quot;public record R(int x) {\n&quot; +
276                         &quot;    static private final j = 0;&quot; +
277                         &quot;    static public int x() { return j; };&quot; +
278                         &quot;}&quot;);
279     }
280 
281     public void testConstructorRedeclaration() {
282         for (String goodCtor : List.of(
283                 &quot;public R(int x) { this(x, 0); }&quot;,
284                 &quot;public R(int x, int y) { this.x = x; this.y = y; }&quot;,
285                 &quot;public R { }&quot;,
286                 &quot;public R { this.x = 0; }&quot;))
287             assertOK(&quot;record R(int x, int y) { # }&quot;, goodCtor);
288 
289         assertOK(&quot;import java.util.*; record R(String x, String y) {  public R { Objects.requireNonNull(x); Objects.requireNonNull(y); } }&quot;);
290 
291         // Not OK to redeclare canonical without DA
292         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;record R(int x, int y) { # }&quot;,
293                    &quot;public R(int x, int y) { this.x = x; }&quot;);
294 
295         // Not OK to rearrange or change names
296         for (String s : List.of(&quot;public R(int y, int x) { this.x = x; this.y = y; }&quot;,
297                                 &quot;public R(int _x, int _y) { this.x = _x; this.y = _y; }&quot;))
298             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x, int y) { # }&quot;, s);
299 
300         // canonical ctor must be public
301         for (String s : List.of(&quot;&quot;, &quot;protected&quot;, &quot;private&quot;))
302             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x, int y) { # }&quot;,
303                        &quot;# R(int x, int y) { this.x = x; this.y = y; }&quot;,
304                        s);
305 
306         // ctor args must match types
307         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
308                 &quot;import java.util.*;\n&quot; +
309                         &quot;record R(List&lt;String&gt; list) { # }&quot;,
310                 &quot;R(List list) { this.list = list; }&quot;);
311 
312         // canonical ctor should not throw checked exceptions
313         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
314                    &quot;record R() { # }&quot;,
315                    &quot;public R() throws Exception { }&quot;);
316 
317         // same for compact
318         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
319                 &quot;record R() { # }&quot;,
320                 &quot;public R throws Exception { }&quot;);
321 
322         // not even unchecked exceptions
323         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
324                 &quot;record R() { # }&quot;,
325                  &quot;public R() throws IllegalArgumentException { }&quot;);
326 
327         // ditto
328         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
329                 &quot;record R() { # }&quot;,
330                 &quot;public R throws IllegalArgumentException { }&quot;);
331 
332         // If types match, names must match
333         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
334                    &quot;record R(int x, int y) { public R(int y, int x) { this.x = this.y = 0; }}&quot;);
335 
336         // first invocation should be one to the canonical
337         assertFail(&quot;compiler.err.first.statement.must.be.call.to.another.constructor&quot;,
338                 &quot;record R(int x, int y) { public R(int y, int x, int z) { this.x = this.y = 0; } }&quot;);
339 
340         assertOK(&quot;record R(int x, int y) { &quot; +
341                  &quot;    public R(int x, int y, int z) { this(x, y); } &quot; +
342                  &quot;}&quot;);
343 
344         assertOK(&quot;record R(int x) { &quot; +
345                 &quot;    public R(int x, int y) { this(x, y, 0); } &quot; +
346                 &quot;    public R(int x, int y, int z) { this(x); } &quot; +
347                 &quot;}&quot;);
348 
349         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
350                 &quot;record R&lt;T&gt;(T a) { # }&quot;,
351                 &quot;public &lt;T&gt; R {}&quot;);
352 
353         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
354                 &quot;record R(int i) { # }&quot;,
355                 &quot;public &lt;T&gt; R(int i) { this.i = i; }&quot;);
356 
357         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
358                 &quot;record R&lt;T&gt;(T a) { # }&quot;,
359                 &quot;public &lt;T&gt; R(T a) { this.a = a; }&quot;);
360 
361         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
362                 &quot;record R(int a) { # }&quot;,
363                 &quot;public R(int a) { super(); this.a = a; }&quot;);
364     }
365 
366     public void testAnnotationCriteria() {
367         String imports = &quot;import java.lang.annotation.*;\n&quot;;
368         String template = &quot;@Target({ # }) @interface A {}\n&quot;;
369         EnumMap&lt;ElementType, String&gt; annotations = new EnumMap&lt;&gt;(ElementType.class);
370         for (ElementType e : values())
371             annotations.put(e, template.replace(&quot;#&quot;, &quot;ElementType.&quot; + e.name()));
372         EnumSet&lt;ElementType&gt; goodSet = EnumSet.of(RECORD_COMPONENT, FIELD, METHOD, PARAMETER, TYPE_USE);
373         EnumSet&lt;ElementType&gt; badSet = EnumSet.of(CONSTRUCTOR, PACKAGE, TYPE, LOCAL_VARIABLE, ANNOTATION_TYPE, TYPE_PARAMETER, MODULE);
374 
375         assertEquals(goodSet.size() + badSet.size(), values().length);
376         String A_GOOD = template.replace(&quot;#&quot;,
377                                          goodSet.stream().map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
378         String A_BAD = template.replace(&quot;#&quot;,
379                                         badSet.stream().map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
380         String A_ALL = template.replace(&quot;#&quot;,
381                                         Stream.of(ElementType.values()).map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
382         String A_NONE = &quot;@interface A {}&quot;;
383 
384         for (ElementType e : goodSet)
385             assertOK(imports + annotations.get(e) + &quot;record R(@A int x) { }&quot;);
386         assertOK(imports + A_GOOD + &quot;record R(@A int x) { }&quot;);
387         assertOK(imports + A_ALL + &quot;record R(@A int x) { }&quot;);
388         assertOK(imports + A_NONE);
389 
390         for (ElementType e : badSet) {
391             assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;, imports + annotations.get(e) + &quot;record R(@A int x) { }&quot;);
392         }
393 
394         assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;, imports + A_BAD + &quot;record R(@A int x) { }&quot;);
395 
396         // TODO: OK to redeclare with or without same annos
397     }
398 
399     public void testNestedRecords() {
400         String template = &quot;class R { \n&quot; +
401                           &quot;    # record RR(int a) { }\n&quot; +
402                           &quot;}&quot;;
403 
404         for (String s : List.of(&quot;&quot;, &quot;static&quot;, &quot;final&quot;,
405                                 &quot;private&quot;, &quot;public&quot;, &quot;protected&quot;,
406                                 &quot;private static&quot;, &quot;public static&quot;, &quot;private static final&quot;))
407             assertOK(template, s);
408 
409         for (String s : List.of(&quot;class C { }&quot;,
410                                 &quot;static class C { }&quot;,
411                                 &quot;enum X { A; }&quot;,
412                                 &quot;interface I { }&quot;,
413                                 &quot;record RR(int y) { }&quot;))
414             assertOK(&quot;record R(int x) { # }&quot;, s);
415     }
416 
417     public void testDuplicatedMember() {
418         String template
419                 = &quot;    record R(int i) {\n&quot; +
420                   &quot;        public int i() { return i; }\n&quot; +
421                   &quot;        public int i() { return i; }\n&quot; +
422                   &quot;    }&quot;;
423         assertFail(&quot;compiler.err.already.defined&quot;, template);
424     }
425 
426     public void testLocalRecords() {
427         assertOK(&quot;class R { \n&quot; +
428                 &quot;    void m() { \n&quot; +
429                 &quot;        record RR(int x) { };\n&quot; +
430                 &quot;    }\n&quot; +
431                 &quot;}&quot;);
432 
433         // local records can also be final
434         assertOK(&quot;class R { \n&quot; +
435                 &quot;    void m() { \n&quot; +
436                 &quot;        final record RR(int x) { };\n&quot; +
437                 &quot;    }\n&quot; +
438                 &quot;}&quot;);
439 
440         // Cant capture locals
441         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
442                 &quot;class R { \n&quot; +
443                         &quot;    void m(int y) { \n&quot; +
444                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
445                         &quot;    }\n&quot; +
446                         &quot;}&quot;);
447 
448         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
449                 &quot;class R { \n&quot; +
450                         &quot;    void m() {\n&quot; +
451                         &quot;        int y;\n&quot; +
452                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
453                         &quot;    }\n&quot; +
454                         &quot;}&quot;);
455 
456         // instance fields
457         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
458                 &quot;class R { \n&quot; +
459                         &quot;    int z = 0;\n&quot; +
460                         &quot;    void m() { \n&quot; +
461                         &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
462                         &quot;    }\n&quot; +
463                         &quot;}&quot;);
464 
465         // or type variables
466         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
467                 &quot;class R&lt;T&gt; { \n&quot; +
468                         &quot;    void m() { \n&quot; +
469                         &quot;        record RR(T t) {};\n&quot; +
470                         &quot;    }\n&quot; +
471                         &quot;}&quot;);
472 
473         // but static fields are OK
474         assertOK(&quot;class R { \n&quot; +
475                 &quot;    static int z = 0;\n&quot; +
476                 &quot;    void m() { \n&quot; +
477                 &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
478                 &quot;    }\n&quot; +
479                 &quot;}&quot;);
480         // can be contained inside a lambda
481         assertOK(&quot;&quot;&quot;
482                 class Outer {
483                     Runnable run = () -&gt; {
484                         record TestRecord(int i) {}
485                     };
486                 }
487                 &quot;&quot;&quot;);
488 
489         // Can&#39;t self-shadow
490         assertFail(&quot;compiler.err.already.defined&quot;,
491                    &quot;class R { \n&quot; +
492                    &quot;    void m() { \n&quot; +
493                    &quot;        record R(int x) { };\n&quot; +
494                    &quot;    }\n&quot; +
495                    &quot;}&quot;);
496     }
497 
498     public void testCompactDADU() {
499         // trivial cases
500         assertOK(&quot;record R() { public R {} }&quot;);
501         assertOK(&quot;record R(int x) { public R {} }&quot;);
502 
503         // throwing an unchecked exception
504         assertOK(&quot;record R(int x) { public R { if (x &lt; 0) { this.x = x; throw new RuntimeException(); }} }&quot;);
505 
506         assertOK(&quot;record R(int x) { public R { if (x &lt; 0) { this.x = x; throw new RuntimeException(); }} }&quot;);
507 
508         // x is not DA nor DU in the body of the constructor hence error
509         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;record R(int x) { # }&quot;,
510                 &quot;public R { if (x &lt; 0) { this.x = -x; } }&quot;);
511 
512         // if static fields are not DA then error
513         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,
514                 &quot;record R() { # }&quot;, &quot;static final String x;&quot;);
515 
516         // ditto
517         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,
518                 &quot;record R() { # }&quot;, &quot;static final String x; public R {}&quot;);
519 
520         // ditto
521         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,
522                 &quot;record R(int i) { # }&quot;, &quot;static final String x; public R {}&quot;);
523     }
524 
525     public void testReturnInCanonical_Compact() {
526         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
527                 &quot;public R { return; }&quot;);
528         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
529                 &quot;public R { if (i &lt; 0) { return; }}&quot;);
530         assertOK(&quot;record R(int x) { public R(int x) { this.x = x; return; } }&quot;);
531         assertOK(&quot;record R(int x) { public R { Runnable r = () -&gt; { return; };} }&quot;);
532     }
533 
534     public void testArgumentsAreNotFinalInCompact() {
535         assertOK(
536                 &quot;&quot;&quot;
537                 record R(int x) {
538                     public R {
539                         x++;
540                     }
541                 }
542                 &quot;&quot;&quot;);
543     }
544 
545     public void testNoNativeMethods() {
546         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
547                 &quot;public native R {}&quot;);
548         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
549                 &quot;public native void m();&quot;);
550     }
551 
552     public void testRecordsInsideInner() {
553         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,
554                 &quot;class Outer {\n&quot; +
555                 &quot;    class Inner {\n&quot; +
556                 &quot;        record R(int a) {}\n&quot; +
557                 &quot;    }\n&quot; +
558                 &quot;}&quot;);
559         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,
560                 &quot;&quot;&quot;
561                 class Outer {
562                     public void test() {
563                         class Inner extends Outer {
564                             record R(int i) {}
565                         }
566                     }
567                 }
568                 &quot;&quot;&quot;);
569         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,
570                 &quot;&quot;&quot;
571                 class Outer {
572                     Runnable run = new Runnable() {
573                         record TestRecord(int i) {}
574                         public void run() {}
575                     };
576                 }
577                 &quot;&quot;&quot;);
578         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,
579                 &quot;&quot;&quot;
580                 class Outer {
581                     void m() {
582                         record A() {
583                             record B() { }
584                         }
585                     }
586                 }
587                 &quot;&quot;&quot;);
588     }
589 
590     public void testReceiverParameter() {
591         assertFail(&quot;compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class&quot;,
592                 &quot;&quot;&quot;
593                 record R(int i) {
594                     public R(R this, int i) {
595                         this.i = i;
596                     }
597                 }
598                 &quot;&quot;&quot;);
599         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
600                 &quot;&quot;&quot;
601                 class Outer {
602                     record R(int i) {
603                         public R(Outer Outer.this, int i) {
604                             this.i = i;
605                         }
606                     }
607                 }
608                 &quot;&quot;&quot;);
609         assertOK(
610                 &quot;&quot;&quot;
611                 record R(int i) {
612                     void m(R this) {}
613                     public int i(R this) { return i; }
614                 }
615                 &quot;&quot;&quot;);
616     }
617 
618     public void testOnlyOneFieldRef() throws Exception {
619         int numberOfFieldRefs = 0;
620         File dir = assertOK(true, &quot;record R(int recordComponent) {}&quot;);
621         for (final File fileEntry : dir.listFiles()) {
622             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
623                 ClassFile classFile = ClassFile.read(fileEntry);
624                 for (CPInfo cpInfo : classFile.constant_pool.entries()) {
625                     if (cpInfo instanceof ConstantPool.CONSTANT_Fieldref_info) {
626                         numberOfFieldRefs++;
627                         ConstantPool.CONSTANT_NameAndType_info nameAndType =
628                                 (ConstantPool.CONSTANT_NameAndType_info)classFile.constant_pool
629                                         .get(((ConstantPool.CONSTANT_Fieldref_info)cpInfo).name_and_type_index);
630                         Assert.check(nameAndType.getName().equals(&quot;recordComponent&quot;));
631                     }
632                 }
633             }
634         }
635         Assert.check(numberOfFieldRefs == 1);
636     }
637 
638     public void testAcceptRecordId() {
639         String[] testOptions = {/* no options */};
640         setCompileOptions(testOptions);
641         assertOKWithWarning(&quot;compiler.warn.restricted.type.not.allowed.preview&quot;,
642                 &quot;class R {\n&quot; +
643                 &quot;    record RR(int i) {\n&quot; +
644                 &quot;        return null;\n&quot; +
645                 &quot;    }\n&quot; +
646                 &quot;    class record {}\n&quot; +
647                 &quot;}&quot;);
648         setCompileOptions(PREVIEW_OPTIONS);
649     }
650 
651     public void testAnnos() throws Exception {
652         String srcTemplate =
653                 &quot;&quot;&quot;
654                     import java.lang.annotation.*;
655                     @Target({#TARGET})
656                     @Retention(RetentionPolicy.RUNTIME)
657                     @interface Anno { }
658 
659                     record R(@Anno String s) {}
660                 &quot;&quot;&quot;;
661 
662         // testing several combinations, adding even more combinations won&#39;t add too much value
663         List&lt;String&gt; annoApplicableTargets = List.of(
664                 &quot;ElementType.FIELD&quot;,
665                 &quot;ElementType.METHOD&quot;,
666                 &quot;ElementType.PARAMETER&quot;,
667                 &quot;ElementType.RECORD_COMPONENT&quot;,
668                 &quot;ElementType.TYPE_USE&quot;,
669                 &quot;ElementType.TYPE_USE,ElementType.FIELD&quot;,
670                 &quot;ElementType.TYPE_USE,ElementType.METHOD&quot;,
671                 &quot;ElementType.TYPE_USE,ElementType.PARAMETER&quot;,
672                 &quot;ElementType.TYPE_USE,ElementType.RECORD_COMPONENT&quot;,
673                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.METHOD&quot;,
674                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.PARAMETER&quot;,
675                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.RECORD_COMPONENT&quot;,
676                 &quot;ElementType.FIELD,ElementType.TYPE_USE&quot;,
677                 &quot;ElementType.METHOD,ElementType.TYPE_USE&quot;,
678                 &quot;ElementType.PARAMETER,ElementType.TYPE_USE&quot;,
679                 &quot;ElementType.RECORD_COMPONENT,ElementType.TYPE_USE&quot;,
680                 &quot;ElementType.FIELD,ElementType.METHOD,ElementType.TYPE_USE&quot;,
681                 &quot;ElementType.FIELD,ElementType.PARAMETER,ElementType.TYPE_USE&quot;,
682                 &quot;ElementType.FIELD,ElementType.RECORD_COMPONENT,ElementType.TYPE_USE&quot;
683         );
684 
685         String[] generalOptions = {
686                 &quot;--enable-preview&quot;,
687                 &quot;-source&quot;, Integer.toString(Runtime.version().feature()),
688                 &quot;-processor&quot;, Processor.class.getName(),
689                 &quot;-Atargets=&quot;
690         };
691 
692         for (String target : annoApplicableTargets) {
693             String code = srcTemplate.replaceFirst(&quot;#TARGET&quot;, target);
694             String[] testOptions = generalOptions.clone();
695             testOptions[testOptions.length - 1] = testOptions[testOptions.length - 1] + target;
696             setCompileOptions(testOptions);
697 
698             File dir = assertOK(true, code);
699 
700             ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, &quot;R.class&quot;));
701 
702             // field first
703             Assert.check(classFile.fields.length == 1);
704             Field field = classFile.fields[0];
705             /* if FIELD is one of the targets then there must be a declaration annotation applied to the field, apart from
706              * the type annotation
707              */
708             if (target.contains(&quot;FIELD&quot;)) {
709                 checkAnno(classFile,
710                         (RuntimeAnnotations_attribute)findAttributeOrFail(
711                                 field.attributes,
712                                 RuntimeVisibleAnnotations_attribute.class),
713                         &quot;Anno&quot;);
714             } else {
715                 assertAttributeNotPresent(field.attributes, RuntimeVisibleAnnotations_attribute.class);
716             }
717 
718             // lets check now for the type annotation
719             if (target.contains(&quot;TYPE_USE&quot;)) {
720                 checkTypeAnno(
721                         classFile,
722                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
723                         &quot;FIELD&quot;,
724                         &quot;Anno&quot;);
725             } else {
726                 assertAttributeNotPresent(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
727             }
728 
729             // checking for the annotation on the corresponding parameter of the canonical constructor
730             Method init = findMethodOrFail(classFile, &quot;&lt;init&gt;&quot;);
731             /* if PARAMETER is one of the targets then there must be a declaration annotation applied to the parameter, apart from
732              * the type annotation
733              */
734             if (target.contains(&quot;PARAMETER&quot;)) {
735                 checkParameterAnno(classFile,
736                         (RuntimeVisibleParameterAnnotations_attribute)findAttributeOrFail(
737                                 init.attributes,
738                                 RuntimeVisibleParameterAnnotations_attribute.class),
739                         &quot;Anno&quot;);
740             } else {
741                 assertAttributeNotPresent(init.attributes, RuntimeVisibleAnnotations_attribute.class);
742             }
743             // let&#39;s check now for the type annotation
744             if (target.contains(&quot;TYPE_USE&quot;)) {
745                 checkTypeAnno(
746                         classFile,
747                         (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
748                         &quot;METHOD_FORMAL_PARAMETER&quot;, &quot;Anno&quot;);
749             } else {
750                 assertAttributeNotPresent(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
751             }
752 
753             // checking for the annotation in the accessor
754             Method accessor = findMethodOrFail(classFile, &quot;s&quot;);
755             /* if METHOD is one of the targets then there must be a declaration annotation applied to the accessor, apart from
756              * the type annotation
757              */
758             if (target.contains(&quot;METHOD&quot;)) {
759                 checkAnno(classFile,
760                         (RuntimeAnnotations_attribute)findAttributeOrFail(
761                                 accessor.attributes,
762                                 RuntimeVisibleAnnotations_attribute.class),
763                         &quot;Anno&quot;);
764             } else {
765                 assertAttributeNotPresent(accessor.attributes, RuntimeVisibleAnnotations_attribute.class);
766             }
767             // let&#39;s check now for the type annotation
768             if (target.contains(&quot;TYPE_USE&quot;)) {
769                 checkTypeAnno(
770                         classFile,
771                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
772                         &quot;METHOD_RETURN&quot;, &quot;Anno&quot;);
773             } else {
774                 assertAttributeNotPresent(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
775             }
776 
777             // checking for the annotation in the Record attribute
778             Record_attribute record = (Record_attribute)findAttributeOrFail(classFile.attributes, Record_attribute.class);
779             Assert.check(record.component_count == 1);
780             /* if RECORD_COMPONENT is one of the targets then there must be a declaration annotation applied to the
781              * field, apart from the type annotation
782              */
783             if (target.contains(&quot;RECORD_COMPONENT&quot;)) {
784                 checkAnno(classFile,
785                         (RuntimeAnnotations_attribute)findAttributeOrFail(
786                                 record.component_info_arr[0].attributes,
787                                 RuntimeVisibleAnnotations_attribute.class),
788                         &quot;Anno&quot;);
789             } else {
790                 assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleAnnotations_attribute.class);
791             }
792             // lets check now for the type annotation
793             if (target.contains(&quot;TYPE_USE&quot;)) {
794                 checkTypeAnno(
795                         classFile,
796                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(
797                                 record.component_info_arr[0].attributes,
798                                 RuntimeVisibleTypeAnnotations_attribute.class),
799                         &quot;FIELD&quot;, &quot;Anno&quot;);
800             } else {
801                 assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleTypeAnnotations_attribute.class);
802             }
803         }
804 
805         // let&#39;s reset the default compiler options for other tests
806         setCompileOptions(PREVIEW_OPTIONS);
807     }
808 
809     private void checkTypeAnno(ClassFile classFile,
810                                RuntimeTypeAnnotations_attribute rtAnnos,
811                                String positionType,
812                                String annoName) throws Exception {
813         // containing only one type annotation
814         Assert.check(rtAnnos.annotations.length == 1);
815         TypeAnnotation tAnno = (TypeAnnotation)rtAnnos.annotations[0];
816         Assert.check(tAnno.position.type.toString().equals(positionType));
817         String annotationName = classFile.constant_pool.getUTF8Value(tAnno.annotation.type_index).toString().substring(1);
818         Assert.check(annotationName.startsWith(annoName));
819     }
820 
821     private void checkAnno(ClassFile classFile,
822                            RuntimeAnnotations_attribute rAnnos,
823                            String annoName) throws Exception {
824         // containing only one type annotation
825         Assert.check(rAnnos.annotations.length == 1);
826         Annotation anno = (Annotation)rAnnos.annotations[0];
827         String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);
828         Assert.check(annotationName.startsWith(annoName));
829     }
830 
831     // special case for parameter annotations
832     private void checkParameterAnno(ClassFile classFile,
833                            RuntimeVisibleParameterAnnotations_attribute rAnnos,
834                            String annoName) throws Exception {
835         // containing only one type annotation
836         Assert.check(rAnnos.parameter_annotations.length == 1);
837         Assert.check(rAnnos.parameter_annotations[0].length == 1);
838         Annotation anno = (Annotation)rAnnos.parameter_annotations[0][0];
839         String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);
840         Assert.check(annotationName.startsWith(annoName));
841     }
842 
843     private File findClassFileOrFail(File dir, String name) {
844         for (final File fileEntry : dir.listFiles()) {
845             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
846                 return fileEntry;
847             }
848         }
849         throw new AssertionError(&quot;file not found&quot;);
850     }
851 
852     private Method findMethodOrFail(ClassFile classFile, String name) throws Exception {
853         for (Method method : classFile.methods) {
854             if (method.getName(classFile.constant_pool).equals(name)) {
855                 return method;
856             }
857         }
858         throw new AssertionError(&quot;method not found&quot;);
859     }
860 
861     private Attribute findAttributeOrFail(Attributes attributes, Class&lt;? extends Attribute&gt; attrClass) {
862         for (Attribute attribute : attributes) {
863             if (attribute.getClass() == attrClass) {
864                 return attribute;
865             }
866         }
867         throw new AssertionError(&quot;attribute not found&quot;);
868     }
869 
870     private void assertAttributeNotPresent(Attributes attributes, Class&lt;? extends Attribute&gt; attrClass) {
871         for (Attribute attribute : attributes) {
872             if (attribute.getClass() == attrClass) {
873                 throw new AssertionError(&quot;attribute not expected&quot;);
874             }
875         }
876     }
877 
878     @SupportedAnnotationTypes(&quot;*&quot;)
879     public static final class Processor extends JavacTestingAbstractProcessor {
880 
881         String targets;
882         int numberOfTypeAnnotations;
883 
884         @Override
885         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
886             targets = processingEnv.getOptions().get(&quot;targets&quot;);
887             for (TypeElement te : annotations) {
888                 if (te.toString().equals(&quot;Anno&quot;)) {
889                     checkElements(te, roundEnv, targets);
890                     if (targets.contains(&quot;TYPE_USE&quot;)) {
891                         Element element = processingEnv.getElementUtils().getTypeElement(&quot;R&quot;);
892                         numberOfTypeAnnotations = 0;
893                         checkTypeAnnotations(element);
894                         Assert.check(numberOfTypeAnnotations == 4);
895                     }
896                 }
897             }
898             return true;
899         }
900 
901         void checkElements(TypeElement te, RoundEnvironment renv, String targets) {
902             Set&lt;? extends Element&gt; annoElements = renv.getElementsAnnotatedWith(te);
903             Set&lt;String&gt; targetSet = new HashSet&lt;&gt;(Arrays.asList(targets.split(&quot;,&quot;)));
904             // we will check for type annotation in another method
905             targetSet.remove(&quot;ElementType.TYPE_USE&quot;);
906             for (Element e : annoElements) {
907                 Symbol s = (Symbol) e;
908                 switch (s.getKind()) {
909                     case FIELD:
910                         Assert.check(targetSet.contains(&quot;ElementType.FIELD&quot;));
911                         targetSet.remove(&quot;ElementType.FIELD&quot;);
912                         break;
913                     case METHOD:
914                         Assert.check(targetSet.contains(&quot;ElementType.METHOD&quot;));
915                         targetSet.remove(&quot;ElementType.METHOD&quot;);
916                         break;
917                     case PARAMETER:
918                         Assert.check(targetSet.contains(&quot;ElementType.PARAMETER&quot;));
919                         targetSet.remove(&quot;ElementType.PARAMETER&quot;);
920                         break;
921                     case RECORD_COMPONENT:
922                         Assert.check(targetSet.contains(&quot;ElementType.RECORD_COMPONENT&quot;));
923                         targetSet.remove(&quot;ElementType.RECORD_COMPONENT&quot;);
924                         break;
925                     default:
926                         throw new AssertionError(&quot;unexpected element kind&quot;);
927                 }
928             }
929             Assert.check(targetSet.isEmpty(), targetSet.toString());
930         }
931 
932         private void checkTypeAnnotations(Element rootElement) {
933             new ElementScanner&lt;Void, Void&gt;() {
934                 @Override public Void visitVariable(VariableElement e, Void p) {
935                     Symbol s = (Symbol) e;
936                     if (s.getKind() == ElementKind.FIELD ||
937                             s.getKind() == ElementKind.PARAMETER &amp;&amp;
938                             s.name.toString().equals(&quot;s&quot;)) {
939                         int currentTAs = numberOfTypeAnnotations;
940                         verifyTypeAnnotations(e.asType().getAnnotationMirrors());
941                         Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
942                     }
943                     return null;
944                 }
945                 @Override
946                 public Void visitExecutable(ExecutableElement e, Void p) {
947                     Symbol s = (Symbol) e;
948                     if (s.getKind() == ElementKind.METHOD &amp;&amp;
949                                     s.name.toString().equals(&quot;s&quot;)) {
950                         int currentTAs = numberOfTypeAnnotations;
951                         verifyTypeAnnotations(e.getReturnType().getAnnotationMirrors());
952                         Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
953                     }
954                     scan(e.getParameters(), p);
955                     return null;
956                 }
957                 @Override public Void visitRecordComponent(RecordComponentElement e, Void p) {
958                     int currentTAs = numberOfTypeAnnotations;
959                     verifyTypeAnnotations(e.asType().getAnnotationMirrors());
960                     Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
961                     return null;
962                 }
963             }.scan(rootElement, null);
964         }
965 
966         private void verifyTypeAnnotations(Iterable&lt;? extends AnnotationMirror&gt; annotations) {
967             for (AnnotationMirror mirror : annotations) {
968                 Assert.check(mirror.toString().startsWith(&quot;@Anno&quot;));
969                 if (mirror instanceof TypeCompound) {
970                     numberOfTypeAnnotations++;
971                 }
972             }
973         }
974 
975     }
976 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/records/mandated_members/CheckRecordMembers.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * CheckRecordMembers
 26  *
 27  * @test
 28  * @summary check that the accessors, equals, hashCode and toString methods
 29  *          work as expected
 30  * @library /tools/javac/lib
 31  * @modules jdk.compiler/com.sun.tools.javac.file
 32  *          jdk.compiler/com.sun.tools.javac.api
 33  *          jdk.compiler/com.sun.tools.javac.util
 34  * @build combo.ComboTestHelper
 35  * @run main/othervm --enable-preview CheckRecordMembers
 36  */
 37 
 38 import java.lang.reflect.Constructor;
 39 import java.lang.reflect.Field;
 40 import java.lang.reflect.Method;
 41 import java.net.URL;
 42 import java.net.URLClassLoader;
 43 import java.util.Arrays;
 44 import java.util.List;
 45 import java.util.Objects;
 46 import javax.tools.JavaFileObject;
 47 
 48 import com.sun.tools.javac.file.PathFileObject;
 49 import combo.ComboTask;
 50 
 51 public class CheckRecordMembers extends combo.ComboInstance&lt;CheckRecordMembers&gt; {
 52 
 53     enum FieldTypeKind implements combo.ComboParameter {
 54         BYTE(&quot;byte&quot;, byte.class,
 55              List.of(Byte.MIN_VALUE, (byte) -4, (byte) -1, (byte) 0, (byte) 1, (byte) 4, Byte.MAX_VALUE)),
 56         SHORT(&quot;short&quot;, short.class,
 57               List.of(Short.MIN_VALUE, (short) -4, (short) -1, (short) 0, (short) 1, (short) 4, Short.MAX_VALUE)),
 58         CHAR(&quot;char&quot;, char.class,
 59              List.of(Character.MIN_VALUE, &#39;a&#39;, &#39;A&#39;, &#39;z&#39;, (char) 0, Character.MAX_VALUE)),
 60         INT(&quot;int&quot;, int.class,
 61             List.of(Integer.MIN_VALUE, (int) -4, (int) -1, (int) 0, (int) 1, (int) 4, Integer.MAX_VALUE)),
 62         LONG(&quot;long&quot;, long.class,
 63              List.of(Long.MIN_VALUE, (long) -4, (long) -1, (long) 0, (long) 1, (long) 4, Long.MAX_VALUE)),
 64         FLOAT(&quot;float&quot;, float.class,
 65               List.of(Float.MIN_VALUE, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, 0.0f, -0.0f, 1.0f, -1.0f, 2.0f, -2.0f, Float.MAX_VALUE)),
 66         DOUBLE(&quot;double&quot;, double.class,
 67                List.of(Double.MIN_VALUE, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 0.0d, -0.0d, 1.0d, -1.0d, 2.0d, -2.0d, Double.MAX_VALUE)),
 68         BOOLEAN(&quot;boolean&quot;, boolean.class,
 69                 List.of(true, false)),
 70         OBJECT(&quot;Object&quot;, Object.class,
 71                Arrays.asList(null, 3, &quot;foo&quot;, new String[] {&quot;a&quot;})),
 72         STRING(&quot;String&quot;, String.class,
 73                Arrays.asList(null, &quot;&quot;, &quot;foo&quot;, &quot;bar&quot;));
 74 
 75         final String retTypeStr;
 76         final Class&lt;?&gt; clazz;
 77         final List&lt;Object&gt; dataValues;
 78 
 79         FieldTypeKind(String retTypeStr, Class&lt;?&gt; clazz, List&lt;Object&gt; values) {
 80             this.retTypeStr = retTypeStr;
 81             this.clazz = clazz;
 82             dataValues = values;
 83         }
 84 
 85         public String expand(String optParameter) {
 86             return retTypeStr;
 87         }
 88     }
 89 
 90     static final String sourceTemplate =
 91             &quot;public record Data(#{FT0} f0, #{FT1} f1) { }&quot;;
 92 
 93     public static void main(String... args) throws Exception {
 94         new combo.ComboTestHelper&lt;CheckRecordMembers&gt;()
 95                 .withDimension(&quot;FT0&quot;, (x, t) -&gt; { x.ft0 = t; }, FieldTypeKind.values())
 96                 .withDimension(&quot;FT1&quot;, (x, t) -&gt; { x.ft1 = t; }, FieldTypeKind.values())
 97                 .run(CheckRecordMembers::new);
 98     }
 99 
100     FieldTypeKind ft0, ft1;
101 
102     @Override
103     public void doWork() throws Throwable {
104         newCompilationTask()
105                 .withOptions(new String[]{&quot;--enable-preview&quot;, &quot;-source&quot;, Integer.toString(Runtime.version().feature())})
106                 .withSourceFromTemplate(&quot;Data&quot;, sourceTemplate)
107                 .generate(this::check);
108     }
109 
110     void check(ComboTask.Result&lt;Iterable&lt;? extends JavaFileObject&gt;&gt; result) {
111         if (result.hasErrors() || result.hasWarnings())
112             fail(&quot;Compilation errors not expected: &quot; + result.compilationInfo());
113 
114         List&lt;Object&gt; f0s = ft0.dataValues;
115         List&lt;Object&gt; f1s = ft1.dataValues;
116 
117         Iterable&lt;? extends PathFileObject&gt; pfoIt = (Iterable&lt;? extends PathFileObject&gt;) result.get();
118         PathFileObject pfo = pfoIt.iterator().next();
119         Class&lt;?&gt; clazz;
120         Constructor&lt;?&gt; ctor;
121         Method getterF0, getterF1, hashCodeMethod, equalsMethod, toStringMethod;
122         Field fieldF0, fieldF1;
123 
124         try {
125             URL[] urls = new URL[] {pfo.getPath().getParent().toUri().toURL()};
126             ClassLoader cl = new URLClassLoader(urls);
127             clazz = cl.loadClass(&quot;Data&quot;);
128 
129             ctor = clazz.getConstructor(ft0.clazz, ft1.clazz);
130             getterF0 = clazz.getMethod(&quot;f0&quot;);
131             getterF1 = clazz.getMethod(&quot;f1&quot;);
132             fieldF0 = clazz.getDeclaredField(&quot;f0&quot;);
133             fieldF1 = clazz.getDeclaredField(&quot;f1&quot;);
134             equalsMethod = clazz.getMethod(&quot;equals&quot;, Object.class);
135             hashCodeMethod = clazz.getMethod(&quot;hashCode&quot;);
136             toStringMethod = clazz.getMethod(&quot;toString&quot;);
137 
138             if (getterF0.getReturnType() != ft0.clazz
139                 || getterF1.getReturnType() != ft1.clazz
140                 || fieldF0.getType() != ft0.clazz
141                 || fieldF1.getType() != ft1.clazz)
142                 fail(&quot;Unexpected field or getter type: &quot; + result.compilationInfo());
143 
144             for (Object f0 : f0s) {
145                 for (Object f1 : f1s) {
146                     // Create object
147                     Object datum = ctor.newInstance(f0, f1);
148 
149                     // Test getters
150                     Object actualF0 = getterF0.invoke(datum);
151                     Object actualF1 = getterF1.invoke(datum);
152                     if (!Objects.equals(f0, actualF0) || !Objects.equals(f1, actualF1))
153                         fail(String.format(&quot;Getters don&#39;t report back right values for %s %s/%s, %s %s/%s&quot;,
154                                            ft0.clazz, f0, actualF0,
155                                            ft1.clazz, f1, actualF1));
156 
157                     int hashCode = (int) hashCodeMethod.invoke(datum);
158                     int expectedHash = Objects.hash(f0, f1);
159                     // @@@ fail
160                     if (hashCode != expectedHash) {
161                         System.err.println(String.format(&quot;Hashcode not as expected: expected=%d, actual=%d&quot;,
162                                            expectedHash, hashCode));
163                     }
164 
165                     String toString = (String) toStringMethod.invoke(datum);
166                     String expectedToString = String.format(&quot;Data[f0=%s, f1=%s]&quot;, f0, f1);
167                     if (!toString.equals(expectedToString)) {
168                         fail(String.format(&quot;ToString not as expected: expected=%s, actual=%s&quot;,
169                                            expectedToString, toString));
170                     }
171 
172                     // Test equals
173                     for (Object f2 : f0s) {
174                         for (Object f3 : f1s) {
175                             Object other = ctor.newInstance(f2, f3);
176                             boolean isEqual = (boolean) equalsMethod.invoke(datum, other);
177                             boolean isEqualReverse = (boolean) equalsMethod.invoke(other, datum);
178                             boolean f0f2Equal = Objects.equals(f0, f2);
179                             boolean f1f3Equal = Objects.equals(f1, f3);
180                             if (ft0 == FieldTypeKind.FLOAT) {
181                                 f0f2Equal = Float.compare((float)f0, (float)f2) == 0;
182                             } else if (ft0 == FieldTypeKind.DOUBLE) {
183                                 f0f2Equal = Double.compare((double)f0, (double)f2) == 0;
184                             }
185                             if (ft1 == FieldTypeKind.FLOAT) {
186                                 f1f3Equal = Float.compare((float)f1, (float)f3) == 0;
187                             } else if (ft1 == FieldTypeKind.DOUBLE) {
188                                 f1f3Equal = Double.compare((double)f1, (double)f3) == 0;
189                             }
190                             boolean shouldEqual = f0f2Equal &amp;&amp; f1f3Equal;
191                             // @@@ fail
192                             if (shouldEqual != isEqual)
193                                 System.err.println(String.format(&quot;Equals not as expected: %s %s/%s, %s %s/%s&quot;,
194                                                    ft0.clazz, f0, f2,
195                                                    ft1.clazz, f1, f3));
196                             if (isEqualReverse != isEqual)
197                                 fail(String.format(&quot;Equals not symmetric: %s %s/%s, %s %s/%s&quot;,
198                                                    ft0.clazz, f0, f2,
199                                                    ft1.clazz, f1, f3));
200 
201                         }
202                     }
203                 }
204             }
205         } catch (Throwable e) {
206             throw new AssertionError(e);
207         }
208     }
209 }
    </pre>
  </body>
</html>
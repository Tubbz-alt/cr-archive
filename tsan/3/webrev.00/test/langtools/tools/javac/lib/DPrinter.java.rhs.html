<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/lib/DPrinter.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /* @test
  25  * @bug 8043484 8007307
  26  * @summary Make sure DPrinter.java compiles
  27  * @modules jdk.compiler/com.sun.tools.javac.api
  28  *          jdk.compiler/com.sun.tools.javac.code
  29  *          jdk.compiler/com.sun.tools.javac.tree
  30  *          jdk.compiler/com.sun.tools.javac.util
  31  * @compile DPrinter.java
  32  */
  33 
  34 import java.io.File;
  35 import java.io.IOException;
  36 import java.io.PrintWriter;
  37 import java.lang.reflect.Field;
  38 import java.lang.reflect.Method;
  39 import java.util.ArrayList;
  40 import java.util.Arrays;
  41 import java.util.Collection;
  42 import java.util.EnumSet;
  43 import java.util.HashMap;
  44 import java.util.List;
  45 import java.util.Locale;
  46 import java.util.Map;
  47 import java.util.Set;
  48 
  49 import javax.lang.model.element.Name;
  50 import javax.lang.model.element.TypeElement;
  51 import javax.tools.FileObject;
  52 import javax.tools.JavaCompiler;
  53 import javax.tools.JavaFileObject;
  54 import javax.tools.StandardJavaFileManager;
  55 import javax.tools.StandardLocation;
  56 import javax.tools.ToolProvider;
  57 
  58 import com.sun.source.doctree.*;
  59 import com.sun.source.util.JavacTask;
  60 import com.sun.source.util.TaskEvent;
  61 import com.sun.source.util.TaskListener;
  62 import com.sun.source.util.Trees;
  63 import com.sun.tools.javac.api.JavacTrees;
  64 import com.sun.tools.javac.code.SymbolMetadata;
  65 import com.sun.tools.javac.code.Attribute;
  66 import com.sun.tools.javac.code.Flags;
  67 import com.sun.tools.javac.code.Kinds;
  68 import com.sun.tools.javac.code.Printer;
  69 import com.sun.tools.javac.code.Scope;
  70 import com.sun.tools.javac.code.Scope.CompoundScope;
  71 import com.sun.tools.javac.code.Symbol;
  72 import com.sun.tools.javac.code.Symbol.*;
  73 import com.sun.tools.javac.code.Type;
  74 import com.sun.tools.javac.code.Type.*;
  75 import com.sun.tools.javac.code.TypeTag;
  76 import com.sun.tools.javac.tree.JCTree;
  77 import com.sun.tools.javac.tree.JCTree.*;
  78 import com.sun.tools.javac.tree.Pretty;
  79 import com.sun.tools.javac.tree.TreeInfo;
  80 import com.sun.tools.javac.tree.TreeScanner;
  81 import com.sun.tools.javac.util.Assert;
  82 import com.sun.tools.javac.util.Context;
  83 import com.sun.tools.javac.util.Convert;
  84 import com.sun.tools.javac.util.ListBuffer;
  85 import com.sun.tools.javac.util.Log;
  86 
  87 
  88 /**
  89  * Debug printer for javac internals, for when toString() just isn&#39;t enough.
  90  *
  91  * &lt;p&gt;
  92  * The printer provides an API to generate structured views of javac objects,
  93  * such as AST nodes, symbol, types and annotations. Various aspects of the
  94  * output can be configured, such as whether to show nulls, empty lists, or
  95  * a compressed representation of the source code. Visitors are used to walk
  96  * object hierarchies, and can be replaced with custom visitors if the default
  97  * visitors are not flexible enough.
  98  *
  99  * &lt;p&gt;
 100  * In general, nodes are printed with an initial line identifying the node
 101  * followed by indented lines for the child nodes. Currently, graphs are
 102  * represented by printing a spanning subtree.
 103  *
 104  * &lt;p&gt;
 105  * The printer can be accessed via a simple command-line utility,
 106  * which makes it easy to see the internal representation of source code,
 107  * such as simple test programs, during the compilation pipeline.
 108  *
 109  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 110  *  If you write code that depends on this, you do so at your own risk.
 111  *  This code and its internal interfaces are subject to change or
 112  *  deletion without notice.&lt;/b&gt;
 113  */
 114 
 115 public class DPrinter {
 116     protected final PrintWriter out;
 117     protected final Trees trees;
 118     protected Printer printer;
 119     protected boolean showEmptyItems = true;
 120     protected boolean showNulls = true;
 121     protected boolean showPositions = false;
 122     protected boolean showSrc;
 123     protected boolean showTreeSymbols;
 124     protected boolean showTreeTypes;
 125     protected int maxSrcLength = 32;
 126     protected Locale locale = Locale.getDefault();
 127     protected static final String NULL = &quot;#null&quot;;
 128 
 129     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Configuration&quot;&gt;
 130 
 131     public static DPrinter instance(Context context) {
 132         DPrinter dp = context.get(DPrinter.class);
 133         if (dp == null) {
 134             dp = new DPrinter(context);
 135         }
 136         return dp;
 137 
 138     }
 139 
 140     protected DPrinter(Context context) {
 141         context.put(DPrinter.class, this);
 142         out = context.get(Log.logKey).getWriter(Log.WriterKind.STDERR);
 143         trees = JavacTrees.instance(context);
 144     }
 145 
 146     public DPrinter(PrintWriter out, Trees trees) {
 147         this.out = out;
 148         this.trees = trees;
 149     }
 150 
 151     public DPrinter emptyItems(boolean showEmptyItems) {
 152         this.showEmptyItems = showEmptyItems;
 153         return this;
 154     }
 155 
 156     public DPrinter nulls(boolean showNulls) {
 157         this.showNulls = showNulls;
 158         return this;
 159     }
 160 
 161     public DPrinter positions(boolean showPositions) {
 162         this.showPositions = showPositions;
 163         return this;
 164     }
 165 
 166     public DPrinter source(boolean showSrc) {
 167         this.showSrc = showSrc;
 168         return this;
 169     }
 170 
 171     public DPrinter source(int maxSrcLength) {
 172         this.showSrc = true;
 173         this.maxSrcLength = maxSrcLength;
 174         return this;
 175     }
 176 
 177     public DPrinter treeSymbols(boolean showTreeSymbols) {
 178         this.showTreeSymbols = showTreeSymbols;
 179         return this;
 180     }
 181 
 182     public DPrinter treeTypes(boolean showTreeTypes) {
 183         this.showTreeTypes = showTreeTypes;
 184         return this;
 185     }
 186 
 187     public DPrinter typeSymbolPrinter(Printer p) {
 188         printer = p;
 189         return this;
 190     }
 191 
 192     // &lt;/editor-fold&gt;
 193 
 194     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Printing&quot;&gt;
 195 
 196     protected enum Details {
 197         /** A one-line non-recursive summary */
 198         SUMMARY,
 199         /** Multi-line, possibly recursive. */
 200         FULL
 201     };
 202 
 203     public void printAnnotations(String label, SymbolMetadata annotations) {
 204         printAnnotations(label, annotations, Details.FULL);
 205     }
 206 
 207     protected void printAnnotations(String label, SymbolMetadata annotations, Details details) {
 208         if (annotations == null) {
 209             printNull(label);
 210         } else {
 211             // no SUMMARY format currently available to use
 212 
 213             // use reflection to get at private fields
 214             Object DECL_NOT_STARTED = getField(null, SymbolMetadata.class, &quot;DECL_NOT_STARTED&quot;);
 215             Object DECL_IN_PROGRESS = getField(null, SymbolMetadata.class, &quot;DECL_IN_PROGRESS&quot;);
 216             Object attributes = getField(annotations, SymbolMetadata.class, &quot;attributes&quot;);
 217             Object type_attributes = getField(annotations, SymbolMetadata.class, &quot;type_attributes&quot;);
 218 
 219             if (!showEmptyItems) {
 220                 if (attributes instanceof List &amp;&amp; ((List) attributes).isEmpty()
 221                         &amp;&amp; attributes != DECL_NOT_STARTED
 222                         &amp;&amp; attributes != DECL_IN_PROGRESS
 223                         &amp;&amp; type_attributes instanceof List &amp;&amp; ((List) type_attributes).isEmpty())
 224                     return;
 225             }
 226 
 227             printString(label, hashString(annotations));
 228 
 229             indent(+1);
 230             if (attributes == DECL_NOT_STARTED)
 231                 printString(&quot;attributes&quot;, &quot;DECL_NOT_STARTED&quot;);
 232             else if (attributes == DECL_IN_PROGRESS)
 233                 printString(&quot;attributes&quot;, &quot;DECL_IN_PROGRESS&quot;);
 234             else if (attributes instanceof List)
 235                 printList(&quot;attributes&quot;, (List) attributes);
 236             else
 237                 printObject(&quot;attributes&quot;, attributes, Details.SUMMARY);
 238 
 239             if (attributes instanceof List)
 240                 printList(&quot;type_attributes&quot;, (List) type_attributes);
 241             else
 242                 printObject(&quot;type_attributes&quot;, type_attributes, Details.SUMMARY);
 243             indent(-1);
 244         }
 245     }
 246 
 247     public void printAttribute(String label, Attribute attr) {
 248         if (attr == null) {
 249             printNull(label);
 250         } else {
 251             printString(label, attr.getClass().getSimpleName());
 252 
 253             indent(+1);
 254             attr.accept(attrVisitor);
 255             indent(-1);
 256         }
 257     }
 258 
 259     public void printDocTree(String label, DocTree tree) {
 260         if (tree == null) {
 261              printNull(label);
 262         } else {
 263             indent();
 264             out.print(label);
 265             out.println(&quot;: &quot; + tree.getClass().getSimpleName() + &quot;,&quot; + tree.getKind());
 266 
 267             indent(+1);
 268             tree.accept(docTreeVisitor, null);
 269             indent(-1);
 270         }
 271     }
 272 
 273     public void printFileObject(String label, FileObject fo) {
 274         if (fo == null) {
 275             printNull(label);
 276         } else {
 277             printString(label, fo.getName());
 278         }
 279     }
 280 
 281     protected &lt;T&gt; void printImplClass(T item, Class&lt;? extends T&gt; stdImplClass) {
 282         if (item.getClass() != stdImplClass)
 283             printString(&quot;impl&quot;, item.getClass().getName());
 284     }
 285 
 286     public void printInt(String label, int i) {
 287         printString(label, String.valueOf(i));
 288     }
 289 
 290     public void printLimitedEscapedString(String label, String text) {
 291         String s = Convert.quote(text);
 292         if (s.length() &gt; maxSrcLength) {
 293             String trim = &quot;[...]&quot;;
 294             int head = (maxSrcLength - trim.length()) * 2 / 3;
 295             int tail = maxSrcLength - trim.length() - head;
 296             s = s.substring(0, head) + trim + s.substring(s.length() - tail);
 297         }
 298         printString(label, s);
 299     }
 300 
 301     public void printList(String label, List&lt;?&gt; list) {
 302         if (list == null) {
 303              printNull(label);
 304         } else if (!list.isEmpty() || showEmptyItems) {
 305             printString(label, &quot;[&quot; + list.size() + &quot;]&quot;);
 306 
 307             indent(+1);
 308             int i = 0;
 309             for (Object item: list) {
 310                 printObject(String.valueOf(i++), item, Details.FULL);
 311             }
 312             indent(-1);
 313         }
 314     }
 315 
 316     public void printName(String label, Name name) {
 317         if (name == null) {
 318             printNull(label);
 319         } else {
 320             printString(label, name.toString());
 321         }
 322     }
 323 
 324     public void printNull(String label) {
 325         if (showNulls)
 326             printString(label, NULL);
 327     }
 328 
 329     protected void printObject(String label, Object item, Details details) {
 330         if (item == null) {
 331             printNull(label);
 332         } else if (item instanceof Attribute) {
 333             printAttribute(label, (Attribute) item);
 334         } else if (item instanceof Symbol) {
 335             printSymbol(label, (Symbol) item, details);
 336         } else if (item instanceof Type) {
 337             printType(label, (Type) item, details);
 338         } else if (item instanceof JCTree) {
 339             printTree(label, (JCTree) item);
 340         } else if (item instanceof DocTree) {
 341             printDocTree(label, (DocTree) item);
 342         } else if (item instanceof List) {
 343             printList(label, (List) item);
 344         } else if (item instanceof Name) {
 345             printName(label, (Name) item);
 346         } else if (item instanceof Scope) {
 347             printScope(label, (Scope) item);
 348         } else {
 349             printString(label, String.valueOf(item));
 350         }
 351     }
 352 
 353     public void printScope(String label, Scope scope) {
 354         printScope(label, scope, Details.FULL);
 355     }
 356 
 357     public void printScope(String label, Scope scope, Details details) {
 358         if (scope == null) {
 359             printNull(label);
 360         } else {
 361             switch (details) {
 362                 case SUMMARY: {
 363                     indent();
 364                     out.print(label);
 365                     out.print(&quot;: [&quot;);
 366                     String sep = &quot;&quot;;
 367                     for (Symbol sym: scope.getSymbols()) {
 368                         out.print(sep);
 369                         out.print(sym.name);
 370                         sep = &quot;,&quot;;
 371                     }
 372                     out.println(&quot;]&quot;);
 373                     break;
 374                 }
 375 
 376                 case FULL: {
 377                     indent();
 378                     out.println(label);
 379 
 380                     indent(+1);
 381                     printFullScopeImpl(scope);
 382                     indent(-1);
 383                     break;
 384                 }
 385             }
 386         }
 387     }
 388 
 389     void printFullScopeImpl(Scope scope) {
 390         indent();
 391         out.println(scope.getClass().getName());
 392         printSymbol(&quot;owner&quot;, scope.owner, Details.SUMMARY);
 393         if (SCOPE_IMPL_CLASS.equals(scope.getClass().getName())) {
 394             printScope(&quot;next&quot;, (Scope) getField(scope, scope.getClass(), &quot;next&quot;), Details.SUMMARY);
 395             printObject(&quot;shared&quot;, getField(scope, scope.getClass(), &quot;shared&quot;), Details.SUMMARY);
 396             Object[] table = (Object[]) getField(scope, scope.getClass(), &quot;table&quot;);
 397             for (int i = 0; i &lt; table.length; i++) {
 398                 if (i &gt; 0)
 399                     out.print(&quot;, &quot;);
 400                 else
 401                     indent();
 402                 out.print(i + &quot;:&quot; + entryToString(table[i], table, false));
 403             }
 404             out.println();
 405         } else if (FILTER_SCOPE_CLASS.equals(scope.getClass().getName())) {
 406             printScope(&quot;origin&quot;,
 407                     (Scope) getField(scope, scope.getClass(), &quot;origin&quot;), Details.FULL);
 408         } else if (scope instanceof CompoundScope) {
 409             printList(&quot;delegates&quot;, ((ListBuffer&lt;?&gt;) getField(scope, CompoundScope.class, &quot;subScopes&quot;)).toList());
 410         } else {
 411             for (Symbol sym : scope.getSymbols()) {
 412                 printSymbol(sym.name.toString(), sym, Details.SUMMARY);
 413             }
 414         }
 415     }
 416         //where:
 417         static final String SCOPE_IMPL_CLASS = &quot;com.sun.tools.javac.code.Scope$ScopeImpl&quot;;
 418         static final String FILTER_SCOPE_CLASS = &quot;com.sun.tools.javac.code.Scope$FilterImportScope&quot;;
 419 
 420     /**
 421      * Create a string showing the contents of an entry, using the table
 422      * to help identify cross-references to other entries in the table.
 423      * @param e the entry to be shown
 424      * @param table the table containing the other entries
 425      */
 426     String entryToString(Object e, Object[] table, boolean ref) {
 427         if (e == null)
 428             return &quot;null&quot;;
 429         Symbol sym = (Symbol) getField(e, e.getClass(), &quot;sym&quot;);
 430         if (sym == null)
 431             return &quot;sent&quot;; // sentinel
 432         if (ref) {
 433             int index = indexOf(table, e);
 434             if (index != -1)
 435                 return String.valueOf(index);
 436         }
 437         Scope scope = (Scope) getField(e, e.getClass(), &quot;scope&quot;);
 438         return &quot;(&quot; + sym.name + &quot;:&quot; + sym
 439                 + &quot;,shdw:&quot; + entryToString(callMethod(e, e.getClass(), &quot;next&quot;), table, true)
<a name="1" id="anc1"></a><span class="line-modified"> 440                 + &quot;,nextSibling:&quot; + entryToString(getField(e, e.getClass(), &quot;nextSibling&quot;), table, true)</span>
<span class="line-added"> 441                 + &quot;,prevSibling:&quot; + entryToString(getField(e, e.getClass(), &quot;prevSibling&quot;), table, true)</span>
 442                 + ((sym.owner != scope.owner)
 443                     ? (&quot;,BOGUS[&quot; + sym.owner + &quot;,&quot; + scope.owner + &quot;]&quot;)
 444                     : &quot;&quot;)
 445                 + &quot;)&quot;;
 446     }
 447 
 448     &lt;T&gt; int indexOf(T[] array, T item) {
 449         for (int i = 0; i &lt; array.length; i++) {
 450             if (array[i] == item)
 451                 return i;
 452         }
 453         return -1;
 454     }
 455 
 456     public void printSource(String label, JCTree tree) {
 457         printString(label, Pretty.toSimpleString(tree, maxSrcLength));
 458     }
 459 
 460     public void printString(String label, String text) {
 461         indent();
 462         out.print(label);
 463         out.print(&quot;: &quot;);
 464         out.print(text);
 465         out.println();
 466     }
 467 
 468     public void printSymbol(String label, Symbol symbol) {
 469         printSymbol(label, symbol, Details.FULL);
 470     }
 471 
 472     protected void printSymbol(String label, Symbol sym, Details details) {
 473         if (sym == null) {
 474             printNull(label);
 475         } else {
 476             switch (details) {
 477             case SUMMARY:
 478                 printString(label, toString(sym));
 479                 break;
 480 
 481             case FULL:
 482                 indent();
 483                 out.print(label);
 484                 out.println(&quot;: &quot; +
 485                         info(sym.getClass(),
 486                             String.format(&quot;0x%x--%s&quot;, sym.kind.ordinal(), Kinds.kindName(sym)),
 487                             sym.getKind())
 488                         + &quot; &quot; + sym.name
 489                         + &quot; &quot; + hashString(sym));
 490 
 491                 indent(+1);
 492                 if (showSrc) {
 493                     JCTree tree = (JCTree) trees.getTree(sym);
 494                     if (tree != null)
 495                         printSource(&quot;src&quot;, tree);
 496                 }
 497                 printString(&quot;flags&quot;, String.format(&quot;0x%x--%s&quot;,
 498                         sym.flags_field, Flags.toString(sym.flags_field)));
 499                 printObject(&quot;completer&quot;, sym.completer, Details.SUMMARY); // what if too long?
 500                 printSymbol(&quot;owner&quot;, sym.owner, Details.SUMMARY);
 501                 printType(&quot;type&quot;, sym.type, Details.SUMMARY);
 502                 printType(&quot;erasure&quot;, sym.erasure_field, Details.SUMMARY);
 503                 sym.accept(symVisitor, null);
 504                 printAnnotations(&quot;annotations&quot;, sym.getMetadata(), Details.SUMMARY);
 505                 indent(-1);
 506             }
 507         }
 508     }
 509 
 510     protected String toString(Symbol sym) {
 511         return (printer != null) ? printer.visit(sym, locale) : String.valueOf(sym);
 512     }
 513 
 514     protected void printTree(String label, JCTree tree) {
 515         if (tree == null) {
 516             printNull(label);
 517         } else {
 518             indent();
 519             String ext;
 520             try {
 521                 ext = tree.getKind().name();
 522             } catch (Throwable t) {
 523                 ext = &quot;n/a&quot;;
 524             }
 525             out.print(label + &quot;: &quot; + info(tree.getClass(), tree.getTag(), ext));
 526             if (showPositions) {
 527                 // We can always get start position, but to get end position
 528                 // and/or line+offset, we would need a JCCompilationUnit
 529                 out.print(&quot; pos:&quot; + tree.pos);
 530             }
 531             if (showTreeTypes &amp;&amp; tree.type != null)
 532                 out.print(&quot; type:&quot; + toString(tree.type));
 533             Symbol sym;
 534             if (showTreeSymbols &amp;&amp; (sym = TreeInfo.symbolFor(tree)) != null)
 535                 out.print(&quot; sym:&quot; + toString(sym));
 536             out.println();
 537 
 538             indent(+1);
 539             if (showSrc) {
 540                 indent();
 541                 out.println(&quot;src: &quot; + Pretty.toSimpleString(tree, maxSrcLength));
 542             }
 543             tree.accept(treeVisitor);
 544             indent(-1);
 545         }
 546     }
 547 
 548     public void printType(String label, Type type) {
 549         printType(label, type, Details.FULL);
 550     }
 551 
 552     protected void printType(String label, Type type, Details details) {
 553         if (type == null)
 554             printNull(label);
 555         else {
 556             switch (details) {
 557                 case SUMMARY:
 558                     printString(label, toString(type));
 559                     break;
 560 
 561                 case FULL:
 562                     indent();
 563                     out.print(label);
 564                     out.println(&quot;: &quot; + info(type.getClass(), type.getTag(), type.getKind())
 565                             + &quot; &quot; + hashString(type));
 566 
 567                     indent(+1);
 568                     printSymbol(&quot;tsym&quot;, type.tsym, Details.SUMMARY);
 569                     printObject(&quot;constValue&quot;, type.constValue(), Details.SUMMARY);
 570                     printObject(&quot;annotations&quot;, type.getAnnotationMirrors(), Details.SUMMARY);
 571                     type.accept(typeVisitor, null);
 572                     indent(-1);
 573             }
 574         }
 575     }
 576 
 577     protected String toString(Type type) {
 578         return (printer != null) ? printer.visit(type, locale) : String.valueOf(type);
 579     }
 580 
 581     protected String hashString(Object obj) {
 582         return String.format(&quot;#%x&quot;, obj.hashCode());
 583     }
 584 
 585     protected String info(Class&lt;?&gt; clazz, Object internal, Object external) {
 586         return String.format(&quot;%s,%s,%s&quot;, clazz.getSimpleName(), internal, external);
 587     }
 588 
 589     private int indent = 0;
 590 
 591     protected void indent() {
 592         for (int i = 0; i &lt; indent; i++) {
 593             out.print(&quot;  &quot;);
 594         }
 595     }
 596 
 597     protected void indent(int n) {
 598         indent += n;
 599     }
 600 
 601     protected Object getField(Object o, Class&lt;?&gt; clazz, String name) {
 602         try {
 603             Field f = clazz.getDeclaredField(name);
 604             boolean prev = f.isAccessible();
 605             f.setAccessible(true);
 606             try {
 607                 return f.get(o);
 608             } finally {
 609                 f.setAccessible(prev);
 610             }
 611         } catch (ReflectiveOperationException e) {
 612             return e;
 613         } catch (SecurityException e) {
 614             return e;
 615         }
 616     }
 617 
 618     protected Object callMethod(Object o, Class&lt;?&gt; clazz, String name) {
 619         try {
 620             Method m = clazz.getDeclaredMethod(name);
 621             boolean prev = m.isAccessible();
 622             m.setAccessible(true);
 623             try {
 624                 return m.invoke(o);
 625             } finally {
 626                 m.setAccessible(prev);
 627             }
 628         } catch (ReflectiveOperationException e) {
 629             return e;
 630         } catch (SecurityException e) {
 631             return e;
 632         }
 633     }
 634 
 635     // &lt;/editor-fold&gt;
 636 
 637     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;JCTree visitor methods&quot;&gt;
 638 
 639     protected JCTree.Visitor treeVisitor = new TreeVisitor();
 640 
 641     /**
 642      * Default visitor class for JCTree (AST) objects.
 643      */
 644     public class TreeVisitor extends JCTree.Visitor {
 645         @Override
 646         public void visitTopLevel(JCCompilationUnit tree) {
 647             printList(&quot;packageAnnotations&quot;, tree.getPackageAnnotations());
 648             printList(&quot;defs&quot;, tree.defs);
 649         }
 650 
 651         @Override
 652         public void visitPackageDef(JCPackageDecl tree) {
 653             printTree(&quot;pid&quot;, tree.pid);
 654         }
 655 
 656         @Override
 657         public void visitImport(JCImport tree) {
 658             printTree(&quot;qualid&quot;, tree.qualid);
 659         }
 660 
 661         @Override
 662         public void visitClassDef(JCClassDecl tree) {
 663             printName(&quot;name&quot;, tree.name);
 664             printTree(&quot;mods&quot;, tree.mods);
 665             printList(&quot;typarams&quot;, tree.typarams);
 666             printTree(&quot;extending&quot;, tree.extending);
 667             printList(&quot;implementing&quot;, tree.implementing);
 668             printList(&quot;defs&quot;, tree.defs);
 669         }
 670 
 671         @Override
 672         public void visitMethodDef(JCMethodDecl tree) {
 673             printName(&quot;name&quot;, tree.name);
 674             printTree(&quot;mods&quot;, tree.mods);
 675             printTree(&quot;restype&quot;, tree.restype);
 676             printList(&quot;typarams&quot;, tree.typarams);
 677             printTree(&quot;recvparam&quot;, tree.recvparam);
 678             printList(&quot;params&quot;, tree.params);
 679             printList(&quot;thrown&quot;, tree.thrown);
 680             printTree(&quot;defaultValue&quot;, tree.defaultValue);
 681             printTree(&quot;body&quot;, tree.body);
 682         }
 683 
 684         @Override
 685         public void visitVarDef(JCVariableDecl tree) {
 686             printName(&quot;name&quot;, tree.name);
 687             printTree(&quot;mods&quot;, tree.mods);
 688             printTree(&quot;vartype&quot;, tree.vartype);
 689             printTree(&quot;init&quot;, tree.init);
 690         }
 691 
 692         @Override
 693         public void visitSkip(JCSkip tree) {
 694         }
 695 
 696         @Override
 697         public void visitBlock(JCBlock tree) {
 698             printList(&quot;stats&quot;, tree.stats);
 699         }
 700 
 701         @Override
 702         public void visitDoLoop(JCDoWhileLoop tree) {
 703             printTree(&quot;body&quot;, tree.body);
 704             printTree(&quot;cond&quot;, tree.cond);
 705         }
 706 
 707         @Override
 708         public void visitWhileLoop(JCWhileLoop tree) {
 709             printTree(&quot;cond&quot;, tree.cond);
 710             printTree(&quot;body&quot;, tree.body);
 711         }
 712 
 713         @Override
 714         public void visitForLoop(JCForLoop tree) {
 715             printList(&quot;init&quot;, tree.init);
 716             printTree(&quot;cond&quot;, tree.cond);
 717             printList(&quot;step&quot;, tree.step);
 718             printTree(&quot;body&quot;, tree.body);
 719         }
 720 
 721         @Override
 722         public void visitForeachLoop(JCEnhancedForLoop tree) {
 723             printTree(&quot;var&quot;, tree.var);
 724             printTree(&quot;expr&quot;, tree.expr);
 725             printTree(&quot;body&quot;, tree.body);
 726         }
 727 
 728         @Override
 729         public void visitLabelled(JCLabeledStatement tree) {
 730             printTree(&quot;body&quot;, tree.body);
 731         }
 732 
 733         @Override
 734         public void visitSwitch(JCSwitch tree) {
 735             printTree(&quot;selector&quot;, tree.selector);
 736             printList(&quot;cases&quot;, tree.cases);
 737         }
 738 
 739         @Override
 740         public void visitCase(JCCase tree) {
 741             printList(&quot;pat&quot;, tree.pats);
 742             printList(&quot;stats&quot;, tree.stats);
 743         }
 744 
 745         @Override
 746         public void visitSynchronized(JCSynchronized tree) {
 747             printTree(&quot;lock&quot;, tree.lock);
 748             printTree(&quot;body&quot;, tree.body);
 749         }
 750 
 751         @Override
 752         public void visitTry(JCTry tree) {
 753             printList(&quot;resources&quot;, tree.resources);
 754             printTree(&quot;body&quot;, tree.body);
 755             printList(&quot;catchers&quot;, tree.catchers);
 756             printTree(&quot;finalizer&quot;, tree.finalizer);
 757         }
 758 
 759         @Override
 760         public void visitCatch(JCCatch tree) {
 761             printTree(&quot;param&quot;, tree.param);
 762             printTree(&quot;body&quot;, tree.body);
 763         }
 764 
 765         @Override
 766         public void visitConditional(JCConditional tree) {
 767             printTree(&quot;cond&quot;, tree.cond);
 768             printTree(&quot;truepart&quot;, tree.truepart);
 769             printTree(&quot;falsepart&quot;, tree.falsepart);
 770         }
 771 
 772         @Override
 773         public void visitIf(JCIf tree) {
 774             printTree(&quot;cond&quot;, tree.cond);
 775             printTree(&quot;thenpart&quot;, tree.thenpart);
 776             printTree(&quot;elsepart&quot;, tree.elsepart);
 777         }
 778 
 779         @Override
 780         public void visitExec(JCExpressionStatement tree) {
 781             printTree(&quot;expr&quot;, tree.expr);
 782         }
 783 
 784         @Override
 785         public void visitBreak(JCBreak tree) {
<a name="2" id="anc2"></a><span class="line-added"> 786             printName(&quot;label&quot;, tree.label);</span>
<span class="line-added"> 787         }</span>
<span class="line-added"> 788 </span>
<span class="line-added"> 789         @Override</span>
<span class="line-added"> 790         public void visitYield(JCYield tree) {</span>
 791             printTree(&quot;value&quot;, tree.value);
 792         }
 793 
 794         @Override
 795         public void visitContinue(JCContinue tree) {
 796             printName(&quot;label&quot;, tree.label);
 797         }
 798 
 799         @Override
 800         public void visitReturn(JCReturn tree) {
 801             printTree(&quot;expr&quot;, tree.expr);
 802         }
 803 
 804         @Override
 805         public void visitThrow(JCThrow tree) {
 806             printTree(&quot;expr&quot;, tree.expr);
 807         }
 808 
 809         @Override
 810         public void visitAssert(JCAssert tree) {
 811             printTree(&quot;cond&quot;, tree.cond);
 812             printTree(&quot;detail&quot;, tree.detail);
 813         }
 814 
 815         @Override
 816         public void visitApply(JCMethodInvocation tree) {
 817             printList(&quot;typeargs&quot;, tree.typeargs);
 818             printTree(&quot;meth&quot;, tree.meth);
 819             printList(&quot;args&quot;, tree.args);
 820         }
 821 
 822         @Override
 823         public void visitNewClass(JCNewClass tree) {
 824             printTree(&quot;encl&quot;, tree.encl);
 825             printList(&quot;typeargs&quot;, tree.typeargs);
 826             printTree(&quot;clazz&quot;, tree.clazz);
 827             printList(&quot;args&quot;, tree.args);
 828             printTree(&quot;def&quot;, tree.def);
 829         }
 830 
 831         @Override
 832         public void visitNewArray(JCNewArray tree) {
 833             printList(&quot;annotations&quot;, tree.annotations);
 834             printTree(&quot;elemtype&quot;, tree.elemtype);
 835             printList(&quot;dims&quot;, tree.dims);
 836             printList(&quot;dimAnnotations&quot;, tree.dimAnnotations);
 837             printList(&quot;elems&quot;, tree.elems);
 838         }
 839 
 840         @Override
 841         public void visitLambda(JCLambda tree) {
 842             printTree(&quot;body&quot;, tree.body);
 843             printList(&quot;params&quot;, tree.params);
 844         }
 845 
 846         @Override
 847         public void visitParens(JCParens tree) {
 848             printTree(&quot;expr&quot;, tree.expr);
 849         }
 850 
 851         @Override
 852         public void visitAssign(JCAssign tree) {
 853             printTree(&quot;lhs&quot;, tree.lhs);
 854             printTree(&quot;rhs&quot;, tree.rhs);
 855         }
 856 
 857         @Override
 858         public void visitAssignop(JCAssignOp tree) {
 859             printTree(&quot;lhs&quot;, tree.lhs);
 860             printTree(&quot;rhs&quot;, tree.rhs);
 861         }
 862 
 863         @Override
 864         public void visitUnary(JCUnary tree) {
 865             printTree(&quot;arg&quot;, tree.arg);
 866         }
 867 
 868         @Override
 869         public void visitBinary(JCBinary tree) {
 870             printTree(&quot;lhs&quot;, tree.lhs);
 871             printTree(&quot;rhs&quot;, tree.rhs);
 872         }
 873 
 874         @Override
 875         public void visitTypeCast(JCTypeCast tree) {
 876             printTree(&quot;clazz&quot;, tree.clazz);
 877             printTree(&quot;expr&quot;, tree.expr);
 878         }
 879 
 880         @Override
 881         public void visitTypeTest(JCInstanceOf tree) {
 882             printTree(&quot;expr&quot;, tree.expr);
<a name="3" id="anc3"></a><span class="line-modified"> 883             printTree(&quot;pattern&quot;, tree.pattern);</span>
 884         }
 885 
 886         @Override
 887         public void visitIndexed(JCArrayAccess tree) {
 888             printTree(&quot;indexed&quot;, tree.indexed);
 889             printTree(&quot;index&quot;, tree.index);
 890         }
 891 
 892         @Override
 893         public void visitSelect(JCFieldAccess tree) {
 894             printTree(&quot;selected&quot;, tree.selected);
 895         }
 896 
 897         @Override
 898         public void visitReference(JCMemberReference tree) {
 899             printTree(&quot;expr&quot;, tree.expr);
 900             printList(&quot;typeargs&quot;, tree.typeargs);
 901         }
 902 
 903         @Override
 904         public void visitIdent(JCIdent tree) {
 905             printName(&quot;name&quot;, tree.name);
 906         }
 907 
 908         @Override
 909         public void visitLiteral(JCLiteral tree) {
 910             printString(&quot;value&quot;, Pretty.toSimpleString(tree, 32));
 911         }
 912 
 913         @Override
 914         public void visitTypeIdent(JCPrimitiveTypeTree tree) {
 915             printString(&quot;typetag&quot;, tree.typetag.name());
 916         }
 917 
 918         @Override
 919         public void visitTypeArray(JCArrayTypeTree tree) {
 920             printTree(&quot;elemtype&quot;, tree.elemtype);
 921         }
 922 
 923         @Override
 924         public void visitTypeApply(JCTypeApply tree) {
 925             printTree(&quot;clazz&quot;, tree.clazz);
 926             printList(&quot;arguments&quot;, tree.arguments);
 927         }
 928 
 929         @Override
 930         public void visitTypeUnion(JCTypeUnion tree) {
 931             printList(&quot;alternatives&quot;, tree.alternatives);
 932         }
 933 
 934         @Override
 935         public void visitTypeIntersection(JCTypeIntersection tree) {
 936             printList(&quot;bounds&quot;, tree.bounds);
 937         }
 938 
 939         @Override
 940         public void visitTypeParameter(JCTypeParameter tree) {
 941             printName(&quot;name&quot;, tree.name);
 942             printList(&quot;annotations&quot;, tree.annotations);
 943             printList(&quot;bounds&quot;, tree.bounds);
 944         }
 945 
 946         @Override
 947         public void visitWildcard(JCWildcard tree) {
 948             printTree(&quot;kind&quot;, tree.kind);
 949             printTree(&quot;inner&quot;, tree.inner);
 950         }
 951 
 952         @Override
 953         public void visitTypeBoundKind(TypeBoundKind tree) {
 954             printString(&quot;kind&quot;, tree.kind.name());
 955         }
 956 
 957         @Override
 958         public void visitModifiers(JCModifiers tree) {
 959             printList(&quot;annotations&quot;, tree.annotations);
 960             printString(&quot;flags&quot;, String.valueOf(Flags.asFlagSet(tree.flags)));
 961         }
 962 
 963         @Override
 964         public void visitAnnotation(JCAnnotation tree) {
 965             printTree(&quot;annotationType&quot;, tree.annotationType);
 966             printList(&quot;args&quot;, tree.args);
 967         }
 968 
 969         @Override
 970         public void visitAnnotatedType(JCAnnotatedType tree) {
 971             printList(&quot;annotations&quot;, tree.annotations);
 972             printTree(&quot;underlyingType&quot;, tree.underlyingType);
 973         }
 974 
 975         @Override
 976         public void visitErroneous(JCErroneous tree) {
 977             printList(&quot;errs&quot;, tree.errs);
 978         }
 979 
 980         @Override
 981         public void visitLetExpr(LetExpr tree) {
 982             printList(&quot;defs&quot;, tree.defs);
 983             printTree(&quot;expr&quot;, tree.expr);
 984         }
 985 
 986         @Override
 987         public void visitTree(JCTree tree) {
 988             Assert.error();
 989         }
 990     }
 991 
 992     // &lt;/editor-fold&gt;
 993 
 994     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;DocTree visitor&quot;&gt;
 995 
 996     protected DocTreeVisitor&lt;Void,Void&gt; docTreeVisitor = new DefaultDocTreeVisitor();
 997 
 998     /**
 999      * Default visitor class for DocTree objects.
1000      * Note: each visitXYZ method ends by calling the corresponding
1001      * visit method for its superclass.
1002      */
1003     class DefaultDocTreeVisitor implements DocTreeVisitor&lt;Void,Void&gt; {
1004 
1005         public Void visitAttribute(AttributeTree node, Void p) {
1006             printName(&quot;name&quot;, node.getName());
1007             printString(&quot;vkind&quot;, node.getValueKind().name());
1008             printList(&quot;value&quot;, node.getValue());
1009             return visitTree(node, null);
1010         }
1011 
1012         public Void visitAuthor(AuthorTree node, Void p) {
1013             printList(&quot;name&quot;, node.getName());
1014             return visitBlockTag(node, null);
1015         }
1016 
1017         public Void visitComment(CommentTree node, Void p) {
1018             printLimitedEscapedString(&quot;body&quot;, node.getBody());
1019             return visitTree(node, null);
1020         }
1021 
1022         public Void visitDeprecated(DeprecatedTree node, Void p) {
1023             printList(&quot;body&quot;, node.getBody());
1024             return visitBlockTag(node, null);
1025         }
1026 
1027         public Void visitDocComment(DocCommentTree node, Void p) {
1028             printList(&quot;firstSentence&quot;, node.getFirstSentence());
1029             printList(&quot;body&quot;, node.getBody());
1030             printList(&quot;tags&quot;, node.getBlockTags());
1031             return visitTree(node, null);
1032         }
1033 
1034         public Void visitDocRoot(DocRootTree node, Void p) {
1035             return visitInlineTag(node, null);
1036         }
1037 
1038         @Override
1039         public Void visitDocType(DocTypeTree node, Void aVoid) {
1040             printLimitedEscapedString(&quot;body&quot;, node.getText());
1041             return visitTree(node, null);
1042         }
1043 
1044         public Void visitEndElement(EndElementTree node, Void p) {
1045             printName(&quot;name&quot;, node.getName());
1046             return visitTree(node, null);
1047         }
1048 
1049         public Void visitEntity(EntityTree node, Void p) {
1050             printName(&quot;name&quot;, node.getName());
1051             return visitTree(node, null);
1052         }
1053 
1054         public Void visitErroneous(ErroneousTree node, Void p) {
1055             printLimitedEscapedString(&quot;body&quot;, node.getBody());
1056             printString(&quot;diag&quot;, node.getDiagnostic().getMessage(Locale.getDefault()));
1057             return visitTree(node, null);
1058         }
1059 
1060         public Void visitHidden(HiddenTree node, Void p) {
1061             printList(&quot;body&quot;, node.getBody());
1062             return visitBlockTag(node, null);
1063         }
1064 
1065         public Void visitIdentifier(IdentifierTree node, Void p) {
1066             printName(&quot;name&quot;, node.getName());
1067             return visitTree(node, null);
1068         }
1069 
1070         public Void visitIndex(IndexTree node, Void p) {
1071             printString(&quot;kind&quot;, node.getKind().name());
1072             printDocTree(&quot;term&quot;, node.getSearchTerm());
1073             printList(&quot;desc&quot;, node.getDescription());
1074             return visitInlineTag(node, p);
1075         }
1076 
1077         public Void visitInheritDoc(InheritDocTree node, Void p) {
1078             return visitInlineTag(node, null);
1079         }
1080 
1081         public Void visitLink(LinkTree node, Void p) {
1082             printString(&quot;kind&quot;, node.getKind().name());
1083             printDocTree(&quot;ref&quot;, node.getReference());
1084             printList(&quot;list&quot;, node.getLabel());
1085             return visitInlineTag(node, null);
1086         }
1087 
1088         public Void visitLiteral(LiteralTree node, Void p) {
1089             printString(&quot;kind&quot;, node.getKind().name());
1090             printDocTree(&quot;body&quot;, node.getBody());
1091             return visitInlineTag(node, null);
1092         }
1093 
1094         public Void visitParam(ParamTree node, Void p) {
1095             printString(&quot;isTypeParameter&quot;, String.valueOf(node.isTypeParameter()));
1096             printString(&quot;kind&quot;, node.getKind().name());
1097             printList(&quot;desc&quot;, node.getDescription());
1098             return visitBlockTag(node, null);
1099         }
1100 
1101         public Void visitProvides(ProvidesTree node, Void p) {
1102             printString(&quot;kind&quot;, node.getKind().name());
1103             printDocTree(&quot;serviceType&quot;, node.getServiceType());
1104             printList(&quot;description&quot;, node.getDescription());
1105             return visitBlockTag(node, null);
1106         }
1107 
1108         public Void visitReference(ReferenceTree node, Void p) {
1109             printString(&quot;signature&quot;, node.getSignature());
1110             return visitTree(node, null);
1111         }
1112 
1113         public Void visitReturn(ReturnTree node, Void p) {
1114             printList(&quot;desc&quot;, node.getDescription());
1115             return visitBlockTag(node, null);
1116         }
1117 
1118         public Void visitSee(SeeTree node, Void p) {
1119             printList(&quot;ref&quot;, node.getReference());
1120             return visitBlockTag(node, null);
1121         }
1122 
1123         public Void visitSerial(SerialTree node, Void p) {
1124             printList(&quot;desc&quot;, node.getDescription());
1125             return visitBlockTag(node, null);
1126         }
1127 
1128         public Void visitSerialData(SerialDataTree node, Void p) {
1129             printList(&quot;desc&quot;, node.getDescription());
1130             return visitBlockTag(node, null);
1131         }
1132 
1133         public Void visitSerialField(SerialFieldTree node, Void p) {
1134             printDocTree(&quot;name&quot;, node.getName());
1135             printDocTree(&quot;type&quot;, node.getType());
1136             printList(&quot;desc&quot;, node.getDescription());
1137             return visitBlockTag(node, null);
1138         }
1139 
1140         public Void visitSince(SinceTree node, Void p) {
1141             printList(&quot;body&quot;, node.getBody());
1142             return visitBlockTag(node, null);
1143         }
1144 
1145         public Void visitStartElement(StartElementTree node, Void p) {
1146             printName(&quot;name&quot;, node.getName());
1147             printList(&quot;attrs&quot;, node.getAttributes());
1148             printString(&quot;selfClosing&quot;, String.valueOf(node.isSelfClosing()));
1149             return visitBlockTag(node, null);
1150         }
1151 
1152         public Void visitSummary(SummaryTree node, Void p) {
1153             printString(&quot;name&quot;, node.getTagName());
1154             printList(&quot;summary&quot;, node.getSummary());
1155             return visitInlineTag(node, null);
1156         }
1157 
1158         public Void visitText(TextTree node, Void p) {
1159             printLimitedEscapedString(&quot;body&quot;, node.getBody());
1160             return visitTree(node, null);
1161         }
1162 
1163         public Void visitThrows(ThrowsTree node, Void p) {
1164             printDocTree(&quot;name&quot;, node.getExceptionName());
1165             printList(&quot;desc&quot;, node.getDescription());
1166             return visitBlockTag(node, null);
1167         }
1168 
1169         public Void visitUnknownBlockTag(UnknownBlockTagTree node, Void p) {
1170             printString(&quot;name&quot;, node.getTagName());
1171             printList(&quot;content&quot;, node.getContent());
1172             return visitBlockTag(node, null);
1173         }
1174 
1175         public Void visitUnknownInlineTag(UnknownInlineTagTree node, Void p) {
1176             printString(&quot;name&quot;, node.getTagName());
1177             printList(&quot;content&quot;, node.getContent());
1178             return visitInlineTag(node, null);
1179         }
1180 
1181         public Void visitUses(UsesTree node, Void p) {
1182             printString(&quot;kind&quot;, node.getKind().name());
1183             printDocTree(&quot;serviceType&quot;, node.getServiceType());
1184             printList(&quot;description&quot;, node.getDescription());
1185             return visitBlockTag(node, null);
1186         }
1187 
1188         public Void visitValue(ValueTree node, Void p) {
1189             printDocTree(&quot;value&quot;, node.getReference());
1190             return visitInlineTag(node, null);
1191         }
1192 
1193         public Void visitVersion(VersionTree node, Void p) {
1194             printList(&quot;body&quot;, node.getBody());
1195             return visitBlockTag(node, null);
1196         }
1197 
1198         public Void visitOther(DocTree node, Void p) {
1199             return visitTree(node, null);
1200         }
1201 
1202         public Void visitBlockTag(DocTree node, Void p) {
1203             return visitTree(node, null);
1204         }
1205 
1206         public Void visitInlineTag(DocTree node, Void p) {
1207             return visitTree(node, null);
1208         }
1209 
1210         public Void visitTree(DocTree node, Void p) {
1211             return null;
1212         }
1213     }
1214 
1215     // &lt;/editor-fold&gt;
1216 
1217     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Symbol visitor&quot;&gt;
1218 
1219     protected Symbol.Visitor&lt;Void,Void&gt; symVisitor = new SymbolVisitor();
1220 
1221     /**
1222      * Default visitor class for Symbol objects.
1223      * Note: each visitXYZ method ends by calling the corresponding
1224      * visit method for its superclass.
1225      */
1226     class SymbolVisitor implements Symbol.Visitor&lt;Void,Void&gt; {
1227         @Override
1228         public Void visitClassSymbol(ClassSymbol sym, Void ignore) {
1229             printName(&quot;fullname&quot;, sym.fullname);
1230             printName(&quot;flatname&quot;, sym.flatname);
1231             printScope(&quot;members&quot;, sym.members_field);
1232             printFileObject(&quot;sourcefile&quot;, sym.sourcefile);
1233             printFileObject(&quot;classfile&quot;, sym.classfile);
1234             // trans-local?
1235             // pool?
1236             return visitTypeSymbol(sym, null);
1237         }
1238 
1239         @Override
1240         public Void visitMethodSymbol(MethodSymbol sym, Void ignore) {
1241             // code
1242             printList(&quot;params&quot;, sym.params);
1243             return visitSymbol(sym, null);
1244         }
1245 
1246         @Override
1247         public Void visitPackageSymbol(PackageSymbol sym, Void ignore) {
1248             printName(&quot;fullname&quot;, sym.fullname);
1249             printScope(&quot;members&quot;, sym.members_field);
1250             printSymbol(&quot;package-info&quot;, sym.package_info, Details.SUMMARY);
1251             return visitTypeSymbol(sym, null);
1252         }
1253 
1254         @Override
1255         public Void visitOperatorSymbol(OperatorSymbol sym, Void ignore) {
1256             printInt(&quot;opcode&quot;, sym.opcode);
1257             return visitMethodSymbol(sym, null);
1258         }
1259 
1260         @Override
1261         public Void visitVarSymbol(VarSymbol sym, Void ignore) {
1262             printInt(&quot;pos&quot;, sym.pos);
1263             printInt(&quot;adm&quot;, sym.adr);
1264             // data is a private field, and the standard accessors may
1265             // mutate it as part of lazy evaluation. Therefore, use
1266             // reflection to get the raw data.
1267             printObject(&quot;data&quot;, getField(sym, VarSymbol.class, &quot;data&quot;), Details.SUMMARY);
1268             return visitSymbol(sym, null);
1269         }
1270 
1271         @Override
1272         public Void visitTypeSymbol(TypeSymbol sym, Void ignore) {
1273             return visitSymbol(sym, null);
1274         }
1275 
1276         @Override
1277         public Void visitSymbol(Symbol sym, Void ignore) {
1278             return null;
1279         }
1280     }
1281 
1282     // &lt;/editor-fold&gt;
1283 
1284     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Type visitor&quot;&gt;
1285 
1286     protected Type.Visitor&lt;Void,Void&gt; typeVisitor = new TypeVisitor();
1287 
1288     /**
1289      * Default visitor class for Type objects.
1290      * Note: each visitXYZ method ends by calling the corresponding
1291      * visit method for its superclass.
1292      */
1293     public class TypeVisitor implements Type.Visitor&lt;Void,Void&gt; {
1294         public Void visitArrayType(ArrayType type, Void ignore) {
1295             printType(&quot;elemType&quot;, type.elemtype, Details.FULL);
1296             return visitType(type, null);
1297         }
1298 
1299         public Void visitCapturedType(CapturedType type, Void ignore) {
1300             printType(&quot;wildcard&quot;, type.wildcard, Details.FULL);
1301             return visitTypeVar(type, null);
1302         }
1303 
1304         public Void visitClassType(ClassType type, Void ignore) {
1305             printType(&quot;outer&quot;, type.getEnclosingType(), Details.SUMMARY);
1306             printList(&quot;typarams&quot;, type.typarams_field);
1307             printList(&quot;allparams&quot;, type.allparams_field);
1308             printType(&quot;supertype&quot;, type.supertype_field, Details.SUMMARY);
1309             printList(&quot;interfaces&quot;, type.interfaces_field);
1310             printList(&quot;allinterfaces&quot;, type.all_interfaces_field);
1311             return visitType(type, null);
1312         }
1313 
1314         public Void visitErrorType(ErrorType type, Void ignore) {
1315             printType(&quot;originalType&quot;, type.getOriginalType(), Details.FULL);
1316             return visitClassType(type, null);
1317         }
1318 
1319         public Void visitForAll(ForAll type, Void ignore) {
1320             printList(&quot;tvars&quot;, type.tvars);
1321             return visitDelegatedType(type);
1322         }
1323 
1324         public Void visitMethodType(MethodType type, Void ignore) {
1325             printList(&quot;argtypes&quot;, type.argtypes);
1326             printType(&quot;restype&quot;, type.restype, Details.FULL);
1327             printList(&quot;thrown&quot;, type.thrown);
1328             printType(&quot;recvtype&quot;, type.recvtype, Details.FULL);
1329             return visitType(type, null);
1330         }
1331 
1332         public Void visitModuleType(ModuleType type, Void ignore) {
1333             return visitType(type, null);
1334         }
1335 
1336         public Void visitPackageType(PackageType type, Void ignore) {
1337             return visitType(type, null);
1338         }
1339 
1340         public Void visitTypeVar(TypeVar type, Void ignore) {
1341             // For TypeVars (and not subtypes), the bound should always be
1342             // null or bot. So, only print the bound for subtypes of TypeVar,
1343             // or if the bound is (erroneously) not null or bot.
1344             if (!type.hasTag(TypeTag.TYPEVAR)
1345                     || !(type.getUpperBound() == null || type.getUpperBound().hasTag(TypeTag.BOT))) {
1346                 printType(&quot;bound&quot;, type.getUpperBound(), Details.FULL);
1347             }
1348             printType(&quot;lower&quot;, type.lower, Details.FULL);
1349             return visitType(type, null);
1350         }
1351 
1352         public Void visitUndetVar(UndetVar type, Void ignore) {
1353             for (UndetVar.InferenceBound ib: UndetVar.InferenceBound.values())
1354                 printList(&quot;bounds.&quot; + ib, type.getBounds(ib));
1355             printInt(&quot;declaredCount&quot;, type.declaredCount);
1356             printType(&quot;inst&quot;, type.getInst(), Details.SUMMARY);
1357             return visitDelegatedType(type);
1358         }
1359 
1360         public Void visitWildcardType(WildcardType type, Void ignore) {
1361             printType(&quot;type&quot;, type.type, Details.SUMMARY);
1362             printString(&quot;kind&quot;, type.kind.name());
1363             printType(&quot;bound&quot;, type.bound, Details.SUMMARY);
1364             return visitType(type, null);
1365         }
1366 
1367         protected Void visitDelegatedType(DelegatedType type) {
1368             printType(&quot;qtype&quot;, type.qtype, Details.FULL);
1369             return visitType(type, null);
1370         }
1371 
1372         public Void visitType(Type type, Void ignore) {
1373             return null;
1374         }
1375     }
1376 
1377     // &lt;/editor-fold&gt;
1378 
1379     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Attribute (annotations) visitor&quot;&gt;
1380 
1381     protected Attribute.Visitor attrVisitor = new AttributeVisitor();
1382 
1383     /**
1384      * Default visitor class for Attribute (annotation) objects.
1385      */
1386     public class AttributeVisitor implements Attribute.Visitor {
1387 
1388         public void visitConstant(Attribute.Constant a) {
1389             printObject(&quot;value&quot;, a.value, Details.SUMMARY);
1390             visitAttribute(a);
1391         }
1392 
1393         public void visitClass(Attribute.Class a) {
1394             printObject(&quot;classType&quot;, a.classType, Details.SUMMARY);
1395             visitAttribute(a);
1396         }
1397 
1398         public void visitCompound(Attribute.Compound a) {
1399             if (a instanceof Attribute.TypeCompound) {
1400                 Attribute.TypeCompound ta = (Attribute.TypeCompound) a;
1401                 // consider a custom printer?
1402                 printObject(&quot;position&quot;, ta.position, Details.SUMMARY);
1403             }
1404             printObject(&quot;synthesized&quot;, a.isSynthesized(), Details.SUMMARY);
1405             printList(&quot;values&quot;, a.values);
1406             visitAttribute(a);
1407         }
1408 
1409         public void visitArray(Attribute.Array a) {
1410             printList(&quot;values&quot;, Arrays.asList(a.values));
1411             visitAttribute(a);
1412         }
1413 
1414         public void visitEnum(Attribute.Enum a) {
1415             printSymbol(&quot;value&quot;, a.value, Details.SUMMARY);
1416             visitAttribute(a);
1417         }
1418 
1419         public void visitError(Attribute.Error a) {
1420             visitAttribute(a);
1421         }
1422 
1423         public void visitAttribute(Attribute a) {
1424             printType(&quot;type&quot;, a.type, Details.SUMMARY);
1425         }
1426 
1427     }
1428     // &lt;/editor-fold&gt;
1429 
1430     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Utility front end&quot;&gt;
1431 
1432     /**
1433      * Utility class to invoke DPrinter from the command line.
1434      */
1435     static class Main {
1436         public static void main(String... args) throws IOException {
1437             Main m = new Main();
1438             PrintWriter out = new PrintWriter(System.out);
1439             try {
1440                 if (args.length == 0)
1441                     m.usage(out);
1442                 else
1443                     m.run(out, args);
1444             } finally {
1445                 out.flush();
1446             }
1447         }
1448 
1449         void usage(PrintWriter out) {
1450             out.println(&quot;Usage:&quot;);
1451             out.println(&quot;  java &quot; + Main.class.getName() + &quot; mode [options] [javac-options]&quot;);
1452             out.print(&quot;where mode is one of: &quot;);
1453             String sep = &quot;&quot;;
1454             for (Handler h: getHandlers().values()) {
1455                 out.print(sep);
1456                 out.print(h.name);
1457                 sep = &quot;, &quot;;
1458             }
1459             out.println();
1460             out.println(&quot;and where options include:&quot;);
1461             out.println(&quot;  -before PARSE|ENTER|ANALYZE|GENERATE|ANNOTATION_PROCESSING|ANNOTATION_PROCESSING_ROUND&quot;);
1462             out.println(&quot;  -after PARSE|ENTER|ANALYZE|GENERATE|ANNOTATION_PROCESSING|ANNOTATION_PROCESSING_ROUND&quot;);
1463             out.println(&quot;  -showPositions&quot;);
1464             out.println(&quot;  -showSource&quot;);
1465             out.println(&quot;  -showTreeSymbols&quot;);
1466             out.println(&quot;  -showTreeTypes&quot;);
1467             out.println(&quot;  -hideEmptyItems&quot;);
1468             out.println(&quot;  -hideNulls&quot;);
1469         }
1470 
1471         void run(PrintWriter out, String... args) throws IOException {
1472             JavaCompiler c = ToolProvider.getSystemJavaCompiler();
1473             StandardJavaFileManager fm = c.getStandardFileManager(null, null, null);
1474 
1475             // DPrinter options
1476             final Set&lt;TaskEvent.Kind&gt; before = EnumSet.noneOf(TaskEvent.Kind.class);
1477             final Set&lt;TaskEvent.Kind&gt; after = EnumSet.noneOf(TaskEvent.Kind.class);
1478             boolean showPositions = false;
1479             boolean showSource = false;
1480             boolean showTreeSymbols = false;
1481             boolean showTreeTypes = false;
1482             boolean showEmptyItems = true;
1483             boolean showNulls = true;
1484 
1485             // javac options
1486             Collection&lt;String&gt; options = new ArrayList&lt;String&gt;();
1487             Collection&lt;File&gt; files = new ArrayList&lt;File&gt;();
1488             String classpath = null;
1489             String classoutdir = null;
1490 
1491             final Handler h = getHandlers().get(args[0]);
1492             if (h == null)
1493                 throw new IllegalArgumentException(args[0]);
1494 
1495             for (int i = 1; i &lt; args.length; i++) {
1496                 String arg = args[i];
1497                 if (arg.equals(&quot;-before&quot;) &amp;&amp; i + 1 &lt; args.length) {
1498                     before.add(getKind(args[++i]));
1499                 } else if (arg.equals(&quot;-after&quot;) &amp;&amp; i + 1 &lt; args.length) {
1500                     after.add(getKind(args[++i]));
1501                 } else if (arg.equals(&quot;-showPositions&quot;)) {
1502                     showPositions = true;
1503                 } else if (arg.equals(&quot;-showSource&quot;)) {
1504                     showSource = true;
1505                 } else if (arg.equals(&quot;-showTreeSymbols&quot;)) {
1506                     showTreeSymbols = true;
1507                 } else if (arg.equals(&quot;-showTreeTypes&quot;)) {
1508                     showTreeTypes = true;
1509                 } else if (arg.equals(&quot;-hideEmptyLists&quot;)) {
1510                     showEmptyItems = false;
1511                 } else if (arg.equals(&quot;-hideNulls&quot;)) {
1512                     showNulls = false;
1513                 } else if (arg.equals(&quot;-classpath&quot;) &amp;&amp; i + 1 &lt; args.length) {
1514                     classpath = args[++i];
1515                 } else if (arg.equals(&quot;-d&quot;) &amp;&amp; i + 1 &lt; args.length) {
1516                     classoutdir = args[++i];
1517                 } else if (arg.startsWith(&quot;-&quot;)) {
1518                     int n = c.isSupportedOption(arg);
1519                     if (n &lt; 0) throw new IllegalArgumentException(arg);
1520                     options.add(arg);
1521                     while (n &gt; 0) options.add(args[++i]);
1522                 } else if (arg.endsWith(&quot;.java&quot;)) {
1523                     files.add(new File(arg));
1524                 }
1525             }
1526 
1527             if (classoutdir != null) {
1528                 fm.setLocation(StandardLocation.CLASS_OUTPUT, Arrays.asList(new File(classoutdir)));
1529             }
1530 
1531             if (classpath != null) {
1532                 Collection&lt;File&gt; path = new ArrayList&lt;File&gt;();
1533                 for (String p: classpath.split(File.pathSeparator)) {
1534                     if (p.isEmpty()) continue;
1535                     File f = new File(p);
1536                     if (f.exists()) path.add(f);
1537                 }
1538                 fm.setLocation(StandardLocation.CLASS_PATH, path);
1539             }
1540             Iterable&lt;? extends JavaFileObject&gt; fos = fm.getJavaFileObjectsFromFiles(files);
1541 
1542             JavacTask task = (JavacTask) c.getTask(out, fm, null, options, null, fos);
1543             final Trees trees = Trees.instance(task);
1544 
1545             final DPrinter dprinter = new DPrinter(out, trees);
1546             dprinter.source(showSource)
1547                     .emptyItems(showEmptyItems)
1548                     .nulls(showNulls)
1549                     .positions(showPositions)
1550                     .treeSymbols(showTreeSymbols)
1551                     .treeTypes(showTreeTypes);
1552 
1553             if (before.isEmpty() &amp;&amp; after.isEmpty()) {
1554                 if (h.name.equals(&quot;trees&quot;) &amp;&amp; !showTreeSymbols &amp;&amp; !showTreeTypes)
1555                     after.add(TaskEvent.Kind.PARSE);
1556                 else
1557                     after.add(TaskEvent.Kind.ANALYZE);
1558             }
1559 
1560             task.addTaskListener(new TaskListener() {
1561                 public void started(TaskEvent e) {
1562                     if (before.contains(e.getKind()))
1563                         handle(e);
1564                 }
1565 
1566                 public void finished(TaskEvent e) {
1567                     if (after.contains(e.getKind()))
1568                         handle(e);
1569                 }
1570 
1571                 private void handle(TaskEvent e) {
1572                     JCCompilationUnit unit = (JCCompilationUnit) e.getCompilationUnit();
1573                      switch (e.getKind()) {
1574                          case PARSE:
1575                          case ENTER:
1576                              h.handle(e.getSourceFile().getName(),
1577                                      unit, unit,
1578                                      dprinter);
1579                              break;
1580 
1581                          default:
1582                              TypeElement elem = e.getTypeElement();
1583                              h.handle(elem.toString(),
1584                                      unit, (JCTree) trees.getTree(elem),
1585                                      dprinter);
1586                              break;
1587                      }
1588                 }
1589             });
1590 
1591             task.call();
1592         }
1593 
1594         TaskEvent.Kind getKind(String s) {
1595             return TaskEvent.Kind.valueOf(s.toUpperCase());
1596         }
1597 
1598         static protected abstract class Handler {
1599             final String name;
1600             Handler(String name) {
1601                 this.name = name;
1602             }
1603             abstract void handle(String label,
1604                     JCCompilationUnit unit, JCTree tree,
1605                     DPrinter dprinter);
1606         }
1607 
1608         Map&lt;String,Handler&gt; getHandlers() {
1609             Map&lt;String,Handler&gt; map = new HashMap&lt;String, Handler&gt;();
1610             for (Handler h: defaultHandlers) {
1611                 map.put(h.name, h);
1612             }
1613             return map;
1614         }
1615 
1616         protected final Handler[] defaultHandlers = {
1617             new Handler(&quot;trees&quot;) {
1618                 @Override
1619                 void handle(String name, JCCompilationUnit unit, JCTree tree, DPrinter dprinter) {
1620                     dprinter.printTree(name, tree);
1621                     dprinter.out.println();
1622                 }
1623             },
1624 
1625             new Handler(&quot;doctrees&quot;) {
1626                 @Override
1627                 void handle(final String name, final JCCompilationUnit unit, JCTree tree, final DPrinter dprinter) {
1628                     TreeScanner ds = new DeclScanner() {
1629                         public void visitDecl(JCTree tree, Symbol sym) {
1630                             DocTree dt = unit.docComments.getCommentTree(tree);
1631                             if (dt != null) {
1632                                 String label = (sym == null) ? Pretty.toSimpleString(tree) : sym.name.toString();
1633                                 dprinter.printDocTree(label, dt);
1634                                 dprinter.out.println();
1635                             }
1636                         }
1637                     };
1638                     ds.scan(tree);
1639                 }
1640             },
1641 
1642             new Handler(&quot;symbols&quot;) {
1643                 @Override
1644                 void handle(String name, JCCompilationUnit unit, JCTree tree, final DPrinter dprinter) {
1645                     TreeScanner ds = new DeclScanner() {
1646                         public void visitDecl(JCTree tree, Symbol sym) {
1647                             String label = (sym == null) ? Pretty.toSimpleString(tree) : sym.name.toString();
1648                             dprinter.printSymbol(label, sym);
1649                             dprinter.out.println();
1650                         }
1651                     };
1652                     ds.scan(tree);
1653                 }
1654             },
1655 
1656             new Handler(&quot;types&quot;) {
1657                 @Override
1658                 void handle(String name, JCCompilationUnit unit, JCTree tree, final DPrinter dprinter) {
1659                     TreeScanner ts = new TreeScanner() {
1660                         @Override
1661                         public void scan(JCTree tree) {
1662                             if (tree == null) {
1663                                 return;
1664                             }
1665                             if (tree.type != null) {
1666                                 String label = Pretty.toSimpleString(tree);
1667                                 dprinter.printType(label, tree.type);
1668                                 dprinter.out.println();
1669                             }
1670                             super.scan(tree);
1671                         }
1672                     };
1673                     ts.scan(tree);
1674                 }
1675             }
1676         };
1677     }
1678 
1679     protected static abstract class DeclScanner extends TreeScanner {
1680         @Override
1681         public void visitClassDef(JCClassDecl tree) {
1682             visitDecl(tree, tree.sym);
1683             super.visitClassDef(tree);
1684         }
1685 
1686         @Override
1687         public void visitMethodDef(JCMethodDecl tree) {
1688             visitDecl(tree, tree.sym);
1689             super.visitMethodDef(tree);
1690         }
1691 
1692         @Override
1693         public void visitVarDef(JCVariableDecl tree) {
1694             visitDecl(tree, tree.sym);
1695             super.visitVarDef(tree);
1696         }
1697 
1698         protected abstract void visitDecl(JCTree tree, Symbol sym);
1699     }
1700 
1701     // &lt;/editor-fold&gt;
1702 
1703 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/switchexpr/WarnWrongYieldTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8223305 8226522
 27  * @summary Verify correct warnings w.r.t. yield
 28  * @compile/ref=WarnWrongYieldTest.out -Xlint:-options -source 13 -XDrawDiagnostics -XDshould-stop.at=ATTR WarnWrongYieldTest.java
 29  */
 30 
 31 package t;
 32 
 33 //ERROR - type called yield:
 34 import t.WarnWrongYieldTest.yield;
 35 
 36 public class WarnWrongYieldTest {
 37 
 38     // ERROR -  class called yield
 39     class yield { }
 40 
 41     // OK to have fields called yield
 42     String[] yield = null;
 43 
 44     // ERROR - field of type yield
 45     yield y;
 46 
 47     // OK to have methods called yield
 48     // Nullary yield method
 49     String[] yield() {
 50         return null;
 51     }
 52     // Unary yield method
 53     String[] yield(int i) {
 54         return null;
 55     }
 56     // Binary yield method
 57     String[] yield(int i, int j) {
 58         return null;
 59     }
 60 
 61     // OK to declare a local called yield
 62     void LocalDeclaration1() {
 63        int yield;
 64     }
 65     // OK to declare and initialise a local called yield
 66     void LocalDeclaration2() {
 67         int yield = 42;
 68     }
 69 
 70     void YieldTypedLocals(int i) {
 71         // ERROR - Parsed as yield statement, and y1 is unknown
 72         yield y1 = null;
 73 
 74         // ERROR - Parsed as yield statement, and y2 is unknown
 75         yield y2 = new yield();
 76 
 77         // ERROR - can not create an yield-valued local of type Object
 78         Object y3 = new yield();
 79 
 80         // ERROR - can not create a final yield-valued local of type yield
 81         final yield y4 = new yield();
 82 
 83         // ERROR - can create a non-final local of type yield using qualified typename
 84         WarnWrongYieldTest.yield y5 = new yield();
 85     }
 86 
 87     void MethodInvocation(int i) {
 88 
 89         // OK - can access a field called yield
 90         String[] x = this.yield;
 91 
 92         // ERROR - calling nullary yield method using simple name parsed as yield statement
 93         yield();
 94         // OK - can call nullary yield method using qualified name
 95         this.yield();
 96 
 97         // ERROR - Calling unary yield method using simple name is parsed as yield statement
 98         yield(2);
 99         // OK - calling unary yield method using qualified name
100         this.yield(2);
101 
102         // ERROR - Calling binary yield method using simple name is parsed as yield statement
103         yield(2, 2); //error
104         // OK - calling binary yield method using qualified name
105         this.yield(2, 2);
106 
107         // ERROR - nullary yield method as receiver is parsed as yield statement
108         yield().toString();
109         // OK - nullary yield method as receiver using qualified name
110         this.yield().toString();
111 
112         // ERROR - unary yield method as receiver is parsed as yield statement
113         yield(2).toString();
114         // OK - unary yield method as receiver using qualified name
115         this.yield(2).toString();
116 
117         // ERROR - binary yield method as receiver is parsed as yield statement
118         yield(2, 2).toString();
119         // OK - binary yield method as receiver using qualified name
120         this.yield(2, 2).toString();
121 
122         // OK - yield method call is in an expression position
123         String str = yield(2).toString();
124 
125         //OK - yield is a variable
126         yield.toString();
127 
128         // OK - parsed as method call (with qualified local yield as receiver)
129         this.yield.toString();
130 
131         yield[0].toString(); //error
132     }
133 
134     private void yieldLocalVar1(int i) {
135         int yield = 0;
136 
137         //OK - yield is a variable:
138         yield++;
139         yield--;
140 
141         //OK - yield is a variable:
142         yield = 3;
143 
144         //OK - yield is a variable:
145         for (int j = 0; j &lt; 3; j++)
146             yield += 1;
147 
148         //OK - yield is a variable and not at the beginning of the statement:
149         yieldLocalVar1(yield);
150 
151         //ERROR - unqualified yield method invocation:
152         yieldLocalVar1(yield().length);
153         yieldLocalVar1(yield.class.getModifiers());
154     }
155 
156     private void yieldLocalVar2(int i) {
157         int[] yield = new int[1];
158 
159         //OK - yield is a variable:
160         yield[0] = 5;
161     }
162 
163     private void lambda() {
164         SAM s = (yield y) -&gt; {};
165     }
166 
167     interface SAM {
168         public void m(yield o);
169     }
170 }
    </pre>
  </body>
</html>
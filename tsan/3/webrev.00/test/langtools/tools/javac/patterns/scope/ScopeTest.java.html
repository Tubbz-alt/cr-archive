<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/patterns/scope/ScopeTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.IOException;
 25 import java.util.Arrays;
 26 import java.util.List;
 27 import java.util.stream.Collectors;
 28 
 29 import org.testng.ITestResult;
 30 import org.testng.annotations.AfterMethod;
 31 import org.testng.annotations.Test;
 32 import tools.javac.combo.JavacTemplateTestBase;
 33 
 34 import static java.util.stream.Collectors.toList;
 35 
 36 @Test
 37 public class ScopeTest extends JavacTemplateTestBase {
 38 
 39     private static String st_block(String... statements) {
 40         return Arrays.stream(statements).collect(Collectors.joining(&quot;&quot;, &quot;{&quot;, &quot;}&quot;));
 41     }
 42 
 43     private static String st_if(String condition, String then, String els) {
 44         return &quot;if (&quot; + condition + &quot;) &quot; + then + &quot; else &quot; + els;
 45     }
 46 
 47     private static String st_while(String condition, String body) {
 48         return &quot;while (&quot; + condition + &quot;) &quot; + body;
 49     }
 50 
 51     private static String st_do_while(String body, String condition) {
 52         return &quot;do &quot; + body + &quot; while (&quot; + condition + &quot;);&quot;;
 53     }
 54 
 55     private static String st_for(String init, String condition, String update, String body) {
 56         return &quot;for (&quot; + init + &quot;; &quot; + condition + &quot;; &quot; + update + &quot;) &quot; + body;
 57     }
 58 
 59     private static String st_s_use() {
 60         return &quot;s.length();&quot;;
 61     }
 62 
 63     private static String st_break() {
 64         return &quot;break;&quot;;
 65     }
 66 
 67     private static String st_return() {
 68         return &quot;return;&quot;;
 69     }
 70 
 71     private static String st_noop() {
 72         return &quot;;&quot;;
 73     }
 74 
 75     private static String expr_empty() {
 76         return &quot;&quot;;
 77     }
 78 
 79     private static String expr_o_match_str() {
 80         return &quot;o instanceof String s&quot;;
 81     }
 82 
 83     private static String expr_not(String expr) {
 84         return &quot;!(&quot; + expr + &quot;)&quot;;
 85     }
 86 
 87     @AfterMethod
 88     public void dumpTemplateIfError(ITestResult result) {
 89         // Make sure offending template ends up in log file on failure
 90         if (!result.isSuccess()) {
 91             System.err.printf(&quot;Diagnostics: %s%nTemplate: %s%n&quot;, diags.errorKeys(), sourceFiles.stream().map(p -&gt; p.snd).collect(toList()));
 92         }
 93     }
 94 
 95     private void program(String block) {
 96         String s = &quot;class C { void m(Object o) &quot; + block + &quot;}&quot;;
 97         addSourceFile(&quot;C.java&quot;, s);
 98     }
 99 
100     private void assertOK(String block) {
101         String sourceVersion = Integer.toString(Runtime.version().feature());
102 
103         reset();
104         addCompileOptions(&quot;--enable-preview&quot;, &quot;-source&quot;, sourceVersion);
105         program(block);
106         try {
107             compile();
108         }
109         catch (IOException e) {
110             throw new RuntimeException(e);
111         }
112         assertCompileSucceeded();
113     }
114 
115     private void assertFail(String expectedDiag, String block) {
116         String sourceVersion = Integer.toString(Runtime.version().feature());
117 
118         reset();
119         addCompileOptions(&quot;--enable-preview&quot;, &quot;-source&quot;, sourceVersion);
120         program(block);
121         try {
122             compile();
123         }
124         catch (IOException e) {
125             throw new RuntimeException(e);
126         }
127         assertCompileFailed(expectedDiag);
128     }
129 
130     public void testIf() {
131         assertOK(st_block(st_if(expr_o_match_str(), st_s_use(), st_return()), st_s_use()));
132         assertOK(st_block(st_if(expr_not(expr_o_match_str()), st_return(), st_s_use()), st_s_use()));
133         assertFail(&quot;compiler.err.cant.resolve.location&quot;, st_block(st_if(expr_o_match_str(), st_s_use(), st_noop()), st_s_use()));
134         assertFail(&quot;compiler.err.cant.resolve.location&quot;, st_block(st_if(expr_not(expr_o_match_str()), st_noop(), st_s_use()), st_s_use()));
135     }
136 
137     public void testWhile() {
138         assertOK(st_block(st_while(expr_not(expr_o_match_str()), st_noop()), st_s_use()));
139         assertFail(&quot;compiler.err.cant.resolve.location&quot;, st_block(st_while(expr_not(expr_o_match_str()), st_break()), st_s_use()));
140     }
141 
142     public void testDoWhile() {
143         assertOK(st_block(st_do_while(st_noop(), expr_not(expr_o_match_str())), st_s_use()));
144         assertFail(&quot;compiler.err.cant.resolve.location&quot;, st_block(st_do_while(st_break(), expr_not(expr_o_match_str())), st_s_use()));
145     }
146 
147     public void testFor() {
148         assertOK(st_block(st_for(expr_empty(), expr_not(expr_o_match_str()), expr_empty(), st_noop()), st_s_use()));
149         assertFail(&quot;compiler.err.cant.resolve.location&quot;, st_block(st_for(expr_empty(), expr_not(expr_o_match_str()), expr_empty(), st_break()), st_s_use()));
150     }
151 
152 }
    </pre>
  </body>
</html>
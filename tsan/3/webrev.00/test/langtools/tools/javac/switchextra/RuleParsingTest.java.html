<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/switchextra/RuleParsingTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8206986
 27  * @summary Ensure rule cases can be parsed correctly for complex expressions.
 28  * @modules jdk.compiler
 29  */
 30 
 31 import java.io.StringWriter;
 32 import java.net.URI;
 33 import java.util.AbstractMap.SimpleEntry;
 34 import java.util.ArrayList;
 35 import java.util.Arrays;
 36 import java.util.List;
 37 import java.util.Locale;
 38 import java.util.Map.Entry;
 39 
 40 import javax.tools.*;
 41 
 42 import com.sun.source.tree.CaseTree;
 43 import com.sun.source.tree.CompilationUnitTree;
 44 import com.sun.source.util.JavacTask;
 45 import com.sun.source.util.TreePathScanner;
 46 import com.sun.source.util.Trees;
 47 
 48 public class RuleParsingTest {
 49 
 50     public static void main(String[] args) throws Exception {
 51         String sourceVersion = Integer.toString(Runtime.version().feature());
 52         new RuleParsingTest().testParseComplexExpressions(sourceVersion);
 53     }
 54 
 55     void testParseComplexExpressions(String sourceVersion) throws Exception {
 56         String[] expressions = {
 57             &quot;(a)&quot;,
 58             &quot;a&quot;,
 59             &quot;a + a&quot;,
 60             &quot;~a + a&quot;,
 61             &quot;a = a&quot;,
 62             &quot;a += a&quot;,
 63             &quot;a + (a)&quot;,
 64             &quot;a + (a) b&quot;,
 65             &quot;true ? a : b&quot;,
 66             &quot;m(() -&gt; {})&quot;,
 67             &quot;m(() -&gt; 1)&quot;,
 68             &quot;m(a -&gt; 1)&quot;,
 69             &quot;m((t a) -&gt; 1)&quot;,
 70         };
 71         StringBuilder code = new StringBuilder();
 72         List&lt;Entry&lt;Long, Long&gt;&gt; spans = new ArrayList&lt;&gt;();
 73         code.append(&quot;class Test {\n&quot; +
 74                     &quot;    void t(int i) {\n&quot;);
 75         for (boolean switchExpr : new boolean[] {false, true}) {
 76             if (switchExpr) {
 77                 code.append(&quot;         int j = switch(i) {\n&quot;);
 78             } else {
 79                 code.append(&quot;         switch(i) {\n&quot;);
 80             }
 81             for (String expr : expressions) {
 82                 code.append(&quot;case &quot;);
 83                 int start = code.length();
 84                 code.append(expr);
 85                 spans.add(new SimpleEntry&lt;&gt;((long) start, (long) code.length()));
 86                 code.append(&quot; -&gt; {}&quot;);
 87             }
 88             code.append(&quot;         };\n&quot;);
 89         }
 90         code.append(&quot;    }\n&quot; +
 91                     &quot;}\n&quot;);
 92         final JavaCompiler tool = ToolProvider.getSystemJavaCompiler();
 93         assert tool != null;
 94         DiagnosticListener&lt;JavaFileObject&gt; noErrors = d -&gt; { throw new AssertionError(d.getMessage(null)); };
 95 
 96         StringWriter out = new StringWriter();
 97         JavacTask ct = (JavacTask) tool.getTask(out, null, noErrors,
 98             List.of(), null,
 99             Arrays.asList(new MyFileObject(code.toString())));
100         CompilationUnitTree cut = ct.parse().iterator().next();
101         Trees trees = Trees.instance(ct);
102         new TreePathScanner&lt;Void, Void&gt;() {
103             @Override
104             public Void visitCase(CaseTree node, Void p) {
105                 long start = trees.getSourcePositions().getStartPosition(cut, node.getExpression());
106                 long end = trees.getSourcePositions().getEndPosition(cut, node.getExpression());
107                 if (!spans.remove(new SimpleEntry&lt;&gt;(start, end))) {
108                     throw new AssertionError(&quot;Did not find an expression span in expected spans: &quot; +
109                                              start + &quot;-&quot; + end +
110                                              &quot; &#39;&quot; + node.getExpression().toString() + &quot;&#39;&quot;);
111                 }
112                 return super.visitCase(node, p);
113             }
114         }.scan(cut, null);
115 
116         if (!spans.isEmpty()) {
117             throw new AssertionError(&quot;Remaning spans: &quot; + spans);
118         }
119     }
120 
121     static class MyFileObject extends SimpleJavaFileObject {
122         private String text;
123 
124         public MyFileObject(String text) {
125             super(URI.create(&quot;myfo:/Test.java&quot;), JavaFileObject.Kind.SOURCE);
126             this.text = text;
127         }
128 
129         @Override
130         public CharSequence getCharContent(boolean ignoreEncodingErrors) {
131             return text;
132         }
133     }
134 }
    </pre>
  </body>
</html>
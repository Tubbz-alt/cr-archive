<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/langtools/tools/javac/switchextra/RuleParsingTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="MultipleLabelsStatement.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="SwitchArrowBrokenConstant.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/langtools/tools/javac/switchextra/RuleParsingTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 78             } else {
 79                 code.append(&quot;         switch(i) {\n&quot;);
 80             }
 81             for (String expr : expressions) {
 82                 code.append(&quot;case &quot;);
 83                 int start = code.length();
 84                 code.append(expr);
 85                 spans.add(new SimpleEntry&lt;&gt;((long) start, (long) code.length()));
 86                 code.append(&quot; -&gt; {}&quot;);
 87             }
 88             code.append(&quot;         };\n&quot;);
 89         }
 90         code.append(&quot;    }\n&quot; +
 91                     &quot;}\n&quot;);
 92         final JavaCompiler tool = ToolProvider.getSystemJavaCompiler();
 93         assert tool != null;
 94         DiagnosticListener&lt;JavaFileObject&gt; noErrors = d -&gt; { throw new AssertionError(d.getMessage(null)); };
 95 
 96         StringWriter out = new StringWriter();
 97         JavacTask ct = (JavacTask) tool.getTask(out, null, noErrors,
<span class="line-modified"> 98             List.of(&quot;--enable-preview&quot;, &quot;-source&quot;, sourceVersion), null,</span>
 99             Arrays.asList(new MyFileObject(code.toString())));
100         CompilationUnitTree cut = ct.parse().iterator().next();
101         Trees trees = Trees.instance(ct);
102         new TreePathScanner&lt;Void, Void&gt;() {
103             @Override
104             public Void visitCase(CaseTree node, Void p) {
105                 long start = trees.getSourcePositions().getStartPosition(cut, node.getExpression());
106                 long end = trees.getSourcePositions().getEndPosition(cut, node.getExpression());
107                 if (!spans.remove(new SimpleEntry&lt;&gt;(start, end))) {
108                     throw new AssertionError(&quot;Did not find an expression span in expected spans: &quot; +
109                                              start + &quot;-&quot; + end +
110                                              &quot; &#39;&quot; + node.getExpression().toString() + &quot;&#39;&quot;);
111                 }
112                 return super.visitCase(node, p);
113             }
114         }.scan(cut, null);
115 
116         if (!spans.isEmpty()) {
117             throw new AssertionError(&quot;Remaning spans: &quot; + spans);
118         }
</pre>
</td>
<td>
<hr />
<pre>
 78             } else {
 79                 code.append(&quot;         switch(i) {\n&quot;);
 80             }
 81             for (String expr : expressions) {
 82                 code.append(&quot;case &quot;);
 83                 int start = code.length();
 84                 code.append(expr);
 85                 spans.add(new SimpleEntry&lt;&gt;((long) start, (long) code.length()));
 86                 code.append(&quot; -&gt; {}&quot;);
 87             }
 88             code.append(&quot;         };\n&quot;);
 89         }
 90         code.append(&quot;    }\n&quot; +
 91                     &quot;}\n&quot;);
 92         final JavaCompiler tool = ToolProvider.getSystemJavaCompiler();
 93         assert tool != null;
 94         DiagnosticListener&lt;JavaFileObject&gt; noErrors = d -&gt; { throw new AssertionError(d.getMessage(null)); };
 95 
 96         StringWriter out = new StringWriter();
 97         JavacTask ct = (JavacTask) tool.getTask(out, null, noErrors,
<span class="line-modified"> 98             List.of(), null,</span>
 99             Arrays.asList(new MyFileObject(code.toString())));
100         CompilationUnitTree cut = ct.parse().iterator().next();
101         Trees trees = Trees.instance(ct);
102         new TreePathScanner&lt;Void, Void&gt;() {
103             @Override
104             public Void visitCase(CaseTree node, Void p) {
105                 long start = trees.getSourcePositions().getStartPosition(cut, node.getExpression());
106                 long end = trees.getSourcePositions().getEndPosition(cut, node.getExpression());
107                 if (!spans.remove(new SimpleEntry&lt;&gt;(start, end))) {
108                     throw new AssertionError(&quot;Did not find an expression span in expected spans: &quot; +
109                                              start + &quot;-&quot; + end +
110                                              &quot; &#39;&quot; + node.getExpression().toString() + &quot;&#39;&quot;);
111                 }
112                 return super.visitCase(node, p);
113             }
114         }.scan(cut, null);
115 
116         if (!spans.isEmpty()) {
117             throw new AssertionError(&quot;Remaning spans: &quot; + spans);
118         }
</pre>
</td>
</tr>
</table>
<center><a href="MultipleLabelsStatement.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="SwitchArrowBrokenConstant.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
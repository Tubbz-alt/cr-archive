<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/expswitch/ExpSwitchNestingTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.IOException;
 25 import java.util.List;
 26 
 27 import org.testng.ITestResult;
 28 import org.testng.annotations.AfterMethod;
 29 import org.testng.annotations.Test;
 30 import tools.javac.combo.JavacTemplateTestBase;
 31 
 32 import static java.util.stream.Collectors.toList;
 33 
 34 @Test
 35 public class ExpSwitchNestingTest extends JavacTemplateTestBase {
 36     private static final String RUNNABLE = &quot;Runnable r = () -&gt; { # };&quot;;
 37     private static final String INT_FN = &quot;java.util.function.IntSupplier r = () -&gt; { # };&quot;;
 38     private static final String LABEL = &quot;label: #&quot;;
 39     private static final String DEF_LABEL_VAR = &quot;int label = 0; { # }&quot;;
 40     private static final String FOR = &quot;for (int i=0; i&lt;10; i++) { # }&quot;;
 41     private static final String FOR_EACH = &quot;for (int i : new int[] {}) { # }&quot;;
 42     private static final String WHILE = &quot;while (cond) { # }&quot;;
 43     private static final String DO = &quot;do { # } while (cond);&quot;;
 44     private static final String SSWITCH = &quot;switch (x) { case 0: # };&quot;;
 45     private static final String ESWITCH_Z = &quot;int res = switch (x) { case 0 -&gt; { # } default -&gt; 0; };&quot;;
 46     private static final String ESWITCH_S = &quot;String res_string = switch (x) { case 0 -&gt; { # } default -&gt; \&quot;default\&quot;; };&quot;;
 47     private static final String INT_FN_ESWITCH = &quot;java.util.function.IntSupplier r = switch (x) { case 0 -&gt; { # } default -&gt; null; };&quot;;
 48     private static final String INT_ESWITCH_DEFAULT = &quot;int res = switch (x) { default -&gt; { # } };&quot;;
 49     private static final String IF = &quot;if (cond) { # } else throw new RuntimeException();&quot;;
 50     private static final String BLOCK = &quot;{ # }&quot;;
 51     private static final String BREAK_Z = &quot;break 0;&quot;;
 52     private static final String BREAK_S = &quot;break \&quot;hello world\&quot;;&quot;;
 53     private static final String BREAK_INT_FN = &quot;break () -&gt; 0 ;&quot;;
 54     private static final String BREAK_N = &quot;break;&quot;;
 55     private static final String BREAK_L = &quot;break label;&quot;;
 56     private static final String RETURN_Z = &quot;return 0;&quot;;
 57     private static final String RETURN_N = &quot;return;&quot;;
 58     private static final String RETURN_S = &quot;return \&quot;Hello\&quot;;&quot;;
 59     private static final String CONTINUE_N = &quot;continue;&quot;;
 60     private static final String CONTINUE_L = &quot;continue label;&quot;;
 61     private static final String NOTHING = &quot;System.out.println();&quot;;
 62 
 63     // containers that do not require exhaustiveness
 64     private static final List&lt;String&gt; CONTAINERS
 65             = List.of(RUNNABLE, FOR, WHILE, DO, SSWITCH, IF, BLOCK);
 66     // containers that do not require exhaustiveness that are statements
 67     private static final List&lt;String&gt; CONTAINER_STATEMENTS
 68             = List.of(FOR, WHILE, DO, SSWITCH, IF, BLOCK);
 69 
 70     @AfterMethod
 71     public void dumpTemplateIfError(ITestResult result) {
 72         // Make sure offending template ends up in log file on failure
 73         if (!result.isSuccess()) {
 74             System.err.printf(&quot;Diagnostics: %s%nTemplate: %s%n&quot;, diags.errorKeys(), sourceFiles.stream().map(p -&gt; p.snd).collect(toList()));
 75         }
 76     }
 77 
 78     private static String[] PREVIEW_OPTIONS = {&quot;--enable-preview&quot;, &quot;-source&quot;,
 79                                                Integer.toString(Runtime.version().feature())};
 80 
 81     private void program(String... constructs) {
 82         String s = &quot;class C { static boolean cond = false; static int x = 0; void m() { # } }&quot;;
 83         for (String c : constructs)
 84             s = s.replace(&quot;#&quot;, c);
 85         addSourceFile(&quot;C.java&quot;, new StringTemplate(s));
 86     }
 87 
 88     private void assertOK(String... constructs) {
 89         reset();
 90         addCompileOptions(PREVIEW_OPTIONS);
 91         program(constructs);
 92         try {
 93             compile();
 94         }
 95         catch (IOException e) {
 96             throw new RuntimeException(e);
 97         }
 98         assertCompileSucceeded();
 99     }
100 
101     private void assertOKWithWarning(String warning, String... constructs) {
102         reset();
103         addCompileOptions(PREVIEW_OPTIONS);
104         program(constructs);
105         try {
106             compile();
107         }
108         catch (IOException e) {
109             throw new RuntimeException(e);
110         }
111         assertCompileSucceededWithWarning(warning);
112     }
113 
114     private void assertFail(String expectedDiag, String... constructs) {
115         reset();
116         addCompileOptions(PREVIEW_OPTIONS);
117         program(constructs);
118         try {
119             compile();
120         }
121         catch (IOException e) {
122             throw new RuntimeException(e);
123         }
124         assertCompileFailed(expectedDiag);
125     }
126 
127     public void testReallySimpleCases() {
128         for (String s : CONTAINERS)
129             assertOK(s, NOTHING);
130         for (String s : CONTAINER_STATEMENTS)
131             assertOK(LABEL, s, NOTHING);
132     }
133 
134     public void testLambda() {
135         assertOK(RUNNABLE, RETURN_N);
136         assertOK(RUNNABLE, NOTHING);
137         assertOK(INT_FN, RETURN_Z);
138         assertFail(&quot;compiler.err.break.outside.switch.loop&quot;, RUNNABLE, BREAK_N);
139         assertFail(&quot;compiler.err.break.complex.value.no.switch.expression&quot;, RUNNABLE, BREAK_Z);
140         assertFail(&quot;compiler.err.break.complex.value.no.switch.expression&quot;, RUNNABLE, BREAK_S);
141         assertFail(&quot;compiler.err.break.outside.switch.loop&quot;, INT_FN, BREAK_N);
142         assertFail(&quot;compiler.err.break.complex.value.no.switch.expression&quot;, INT_FN, BREAK_Z);
143         assertFail(&quot;compiler.err.break.complex.value.no.switch.expression&quot;, INT_FN, BREAK_S);
144         assertFail(&quot;compiler.err.cont.outside.loop&quot;, RUNNABLE, CONTINUE_N);
145         assertFail(&quot;compiler.err.undef.label&quot;, RUNNABLE, BREAK_L);
146         assertFail(&quot;compiler.err.undef.label&quot;, RUNNABLE, CONTINUE_L);
147         assertFail(&quot;compiler.err.cont.outside.loop&quot;, INT_FN, CONTINUE_N);
148         assertFail(&quot;compiler.err.undef.label&quot;, INT_FN, BREAK_L);
149         assertFail(&quot;compiler.err.undef.label&quot;, INT_FN, CONTINUE_L);
150         assertFail(&quot;compiler.err.undef.label&quot;, LABEL, BLOCK, RUNNABLE, BREAK_L);
151         assertFail(&quot;compiler.err.undef.label&quot;, LABEL, BLOCK, RUNNABLE, CONTINUE_L);
152         assertFail(&quot;compiler.err.undef.label&quot;, LABEL, BLOCK, INT_FN, BREAK_L);
153         assertFail(&quot;compiler.err.undef.label&quot;, LABEL, BLOCK, INT_FN, CONTINUE_L);
154     }
155 
156     public void testEswitch() {
157         //Int-valued switch expressions
158         assertOK(ESWITCH_Z, BREAK_Z);
159         assertOK(LABEL, BLOCK, ESWITCH_Z, BREAK_Z);
160         assertFail(&quot;compiler.err.break.missing.value&quot;, ESWITCH_Z, BREAK_N);
161         assertFail(&quot;compiler.err.prob.found.req&quot;, ESWITCH_Z, BREAK_S);
162         assertFail(&quot;compiler.err.cant.resolve.location&quot;, ESWITCH_Z, BREAK_L);
163         assertFail(&quot;compiler.err.break.outside.switch.expression&quot;, LABEL, BLOCK, ESWITCH_Z, BREAK_L);
164         assertFail(&quot;compiler.err.undef.label&quot;, ESWITCH_Z, CONTINUE_L);
165         assertFail(&quot;compiler.err.cont.outside.loop&quot;, ESWITCH_Z, CONTINUE_N);
166         assertFail(&quot;compiler.err.return.outside.switch.expression&quot;, ESWITCH_Z, RETURN_N);
167         assertFail(&quot;compiler.err.return.outside.switch.expression&quot;, ESWITCH_Z, RETURN_Z);
168 
169         assertOK(INT_ESWITCH_DEFAULT, BREAK_Z);
170         assertFail(&quot;compiler.err.break.missing.value&quot;, INT_ESWITCH_DEFAULT, BREAK_N);
171         assertFail(&quot;compiler.err.prob.found.req&quot;, INT_ESWITCH_DEFAULT, BREAK_S);
172         assertFail(&quot;compiler.err.cant.resolve.location&quot;, INT_ESWITCH_DEFAULT, BREAK_L);
173 
174 
175         // String-valued switch expressions
176         assertOK(ESWITCH_S, BREAK_S);
177         assertOK(LABEL, BLOCK, ESWITCH_S, BREAK_S);
178         assertFail(&quot;compiler.err.break.missing.value&quot;, ESWITCH_S, BREAK_N);
179         assertFail(&quot;compiler.err.prob.found.req&quot;, ESWITCH_S, BREAK_Z);
180         assertFail(&quot;compiler.err.cant.resolve.location&quot;, ESWITCH_S, BREAK_L);
181         assertFail(&quot;compiler.err.break.outside.switch.expression&quot;, LABEL, BLOCK, ESWITCH_S, BREAK_L);
182         assertFail(&quot;compiler.err.undef.label&quot;, ESWITCH_S, CONTINUE_L);
183         assertFail(&quot;compiler.err.cont.outside.loop&quot;, ESWITCH_S, CONTINUE_N);
184         assertFail(&quot;compiler.err.return.outside.switch.expression&quot;, ESWITCH_S, RETURN_N);
185         assertFail(&quot;compiler.err.return.outside.switch.expression&quot;, ESWITCH_S, RETURN_S);
186         // Function-valued switch expression
187         assertOK(INT_FN_ESWITCH, BREAK_INT_FN);
188         assertFail(&quot;compiler.err.break.missing.value&quot;, INT_FN_ESWITCH, BREAK_N);
189         assertFail(&quot;compiler.err.prob.found.req&quot;, INT_FN_ESWITCH, BREAK_Z);
190         assertFail(&quot;compiler.err.prob.found.req&quot;, INT_FN_ESWITCH, BREAK_S);
191 
192         assertFail(&quot;compiler.err.cant.resolve.location&quot;, INT_FN_ESWITCH, BREAK_L);
193         assertFail(&quot;compiler.err.break.outside.switch.expression&quot;, LABEL, BLOCK, INT_FN_ESWITCH, BREAK_L);
194         assertFail(&quot;compiler.err.undef.label&quot;, INT_FN_ESWITCH, CONTINUE_L);
195         assertFail(&quot;compiler.err.cont.outside.loop&quot;, INT_FN_ESWITCH, CONTINUE_N);
196         assertFail(&quot;compiler.err.return.outside.switch.expression&quot;, INT_FN_ESWITCH, RETURN_N);
197         assertFail(&quot;compiler.err.return.outside.switch.expression&quot;, INT_FN_ESWITCH, RETURN_S);
198 
199     }
200 
201     public void testNestedInExpSwitch() {
202         assertOK(ESWITCH_Z, IF,     BREAK_Z);
203         assertOK(ESWITCH_Z, BLOCK,  BREAK_Z);
204         //
205         assertOK(ESWITCH_Z, IF,     IF,     BREAK_Z);
206         assertOK(ESWITCH_Z, IF,     BLOCK,  BREAK_Z);
207         assertOK(ESWITCH_Z, BLOCK,  IF,     BREAK_Z);
208         assertOK(ESWITCH_Z, BLOCK,  BLOCK,  BREAK_Z);
209         //
210         assertOK(ESWITCH_Z, IF,     IF,     IF,     BREAK_Z);
211         assertOK(ESWITCH_Z, IF,     IF,     BLOCK,  BREAK_Z);
212         assertOK(ESWITCH_Z, IF,     BLOCK,  IF,     BREAK_Z);
213         assertOK(ESWITCH_Z, IF,     BLOCK,  BLOCK,  BREAK_Z);
214         assertOK(ESWITCH_Z, BLOCK,  IF,     IF,     BREAK_Z);
215         assertOK(ESWITCH_Z, BLOCK,  IF,     BLOCK,  BREAK_Z);
216         assertOK(ESWITCH_Z, BLOCK,  BLOCK,  IF,     BREAK_Z);
217         assertOK(ESWITCH_Z, BLOCK,  BLOCK,  BLOCK,  BREAK_Z);
218         //
219         assertFail(&quot;compiler.err.break.expr.not.immediate&quot;, ESWITCH_Z, SSWITCH, BREAK_Z);
220         assertFail(&quot;compiler.err.break.expr.not.immediate&quot;, ESWITCH_Z, FOR, BREAK_Z);
221         assertFail(&quot;compiler.err.break.expr.not.immediate&quot;, ESWITCH_Z, WHILE, BREAK_Z);
222         assertFail(&quot;compiler.err.break.expr.not.immediate&quot;, ESWITCH_Z, DO, BREAK_Z);
223         assertFail(&quot;compiler.err.break.complex.value.no.switch.expression&quot;, ESWITCH_Z, INT_FN, BREAK_Z);
224         assertFail(&quot;compiler.err.break.expr.not.immediate&quot;, ESWITCH_Z, SSWITCH, IF, BREAK_Z);
225         assertFail(&quot;compiler.err.break.expr.not.immediate&quot;, ESWITCH_Z, FOR, IF, BREAK_Z);
226         assertFail(&quot;compiler.err.break.expr.not.immediate&quot;, ESWITCH_Z, WHILE, IF, BREAK_Z);
227         assertFail(&quot;compiler.err.break.expr.not.immediate&quot;, ESWITCH_Z, DO, IF, BREAK_Z);
228         assertFail(&quot;compiler.err.break.expr.not.immediate&quot;, ESWITCH_Z, BLOCK, SSWITCH, IF, BREAK_Z);
229         assertFail(&quot;compiler.err.break.expr.not.immediate&quot;, ESWITCH_Z, BLOCK, FOR, IF, BREAK_Z);
230         assertFail(&quot;compiler.err.break.expr.not.immediate&quot;, ESWITCH_Z, BLOCK, WHILE, IF, BREAK_Z);
231         assertFail(&quot;compiler.err.break.expr.not.immediate&quot;, ESWITCH_Z, BLOCK, DO, IF, BREAK_Z);
232     }
233 
234     public void testBreakExpressionLabelDisambiguation() {
235         assertOK(DEF_LABEL_VAR, ESWITCH_Z, BREAK_L);
236         assertFail(&quot;compiler.err.break.ambiguous.target&quot;, LABEL, FOR, BLOCK, DEF_LABEL_VAR, ESWITCH_Z, BREAK_L);
237         assertFail(&quot;compiler.err.break.ambiguous.target&quot;, DEF_LABEL_VAR, ESWITCH_Z, LABEL, FOR, BREAK_L); //label break
238         assertFail(&quot;compiler.err.break.ambiguous.target&quot;, DEF_LABEL_VAR, LABEL, BLOCK, ESWITCH_Z, BREAK_L); //expression break
239         //
240     }
241 
242     public void testFunReturningSwitchExp() {
243         assertOK(INT_FN_ESWITCH, BREAK_INT_FN);
244     }
245 
246     public void testContinueLoops() {
247         assertOK(LABEL, FOR, CONTINUE_L);
248         assertOK(LABEL, FOR_EACH, CONTINUE_L);
249         assertOK(LABEL, WHILE, CONTINUE_L);
250         assertOK(LABEL, DO, CONTINUE_L);
251         assertFail(&quot;compiler.err.not.loop.label&quot;, LABEL, CONTINUE_L);
252     }
253 }
    </pre>
  </body>
</html>
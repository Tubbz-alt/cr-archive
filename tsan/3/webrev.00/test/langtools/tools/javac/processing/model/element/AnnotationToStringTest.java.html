<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/processing/model/element/AnnotationToStringTest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8164819
 27  * @summary Test of toString on normal annotations
 28  * @library /tools/javac/lib
 29  * @build   JavacTestingAbstractProcessor AnnotationToStringTest
 30  * @compile -processor AnnotationToStringTest -proc:only AnnotationToStringTest.java
 31  */
 32 
 33 // See also the sibling core reflection test
 34 // test/jdk/java/lang/annotation/AnnotationToStringTest.java
 35 
 36 import java.lang.annotation.*;
 37 import java.lang.reflect.*;
 38 import java.util.*;
 39 import javax.annotation.processing.*;
 40 import javax.lang.model.AnnotatedConstruct;
 41 import javax.lang.model.element.*;
 42 import javax.lang.model.util.*;
 43 
 44 /**
 45  * The expected string values are stored in @ExpectedString
 46  * annotations. The essence of the test is comparing the toString()
 47  * result of annotations to the corresponding ExpectedString.value().
 48  *
 49  * Two flavors of comparison are made:
 50  *
 51  * 1) Against the AnnotationMirror value from getAnnotationMirrors()
 52  *
 53  * 2) Against the *Annotation* from getAnnotation(Class&lt;A&gt;)
 54  *
 55  * These have separate but related implementations.
 56  */
 57 public class AnnotationToStringTest extends JavacTestingAbstractProcessor {
 58     public boolean process(Set&lt;? extends TypeElement&gt; annotations,
 59                            RoundEnvironment roundEnv) {
 60         if (!roundEnv.processingOver()) {
 61 
 62             int failures = 0;
 63 
 64             TypeElement primHostElt =
 65                 Objects.requireNonNull(elements.getTypeElement(&quot;AnnotationToStringTest.PrimHost&quot;));
 66 
 67             List&lt;? extends AnnotationMirror&gt; annotMirrors = primHostElt.getAnnotationMirrors();
 68 
 69             String expectedString = primHostElt.getAnnotation(MostlyPrimitive.class).toString();
 70 
 71             failures += check(expectedString,
 72                               primHostElt.getAnnotation(ExpectedString.class).value());
 73 
 74             failures += check(expectedString,
 75                               retrieveAnnotationMirrorAsString(primHostElt,
 76                                                                &quot;MostlyPrimitive&quot;));
 77             failures += classyTest();
 78             failures += arrayAnnotationTest();
 79 
 80             if (failures &gt; 0)
 81                 throw new RuntimeException(failures + &quot; failures&quot;);
 82         }
 83         return true;
 84     }
 85 
 86     /**
 87      * Examine annotation mirrors, find the one that matches
 88      * annotationName, and return its toString value.
 89      */
 90     private String retrieveAnnotationMirrorAsString(AnnotatedConstruct annotated,
 91                                                     String annotationName) {
 92         return retrieveAnnotationMirror(annotated, annotationName).toString();
 93     }
 94 
 95     private String retrieveAnnotationMirrorValue(AnnotatedConstruct annotated,
 96                                                  String annotationName) {
 97         AnnotationMirror annotationMirror =
 98             retrieveAnnotationMirror(annotated, annotationName);
 99         for (var entry : annotationMirror.getElementValues().entrySet()) {
100             if (entry.getKey().getSimpleName().contentEquals(&quot;value&quot;)) {
101                 return entry.getValue().toString();
102             }
103         }
104         throw new RuntimeException(&quot;Annotation value() method not found: &quot; +
105                                    annotationMirror.toString());
106     }
107 
108     private AnnotationMirror retrieveAnnotationMirror(AnnotatedConstruct annotated,
109                                                       String annotationName) {
110         for (AnnotationMirror annotationMirror : annotated.getAnnotationMirrors()) {
111             System.out.println(annotationMirror.getAnnotationType());
112             if (annotationMirror
113                 .getAnnotationType()
114                 .toString()
115                 .equals(annotationName) ) {
116                 return annotationMirror;
117             }
118         }
119         throw new RuntimeException(&quot;Annotation &quot; + annotationName + &quot; not found.&quot;);
120     }
121 
122     private static int check(String expected, String actual) {
123         if (!expected.equals(actual)) {
124             System.err.printf(&quot;ERROR: Expected &#39;&#39;%s&#39;&#39;;%ngot             &#39;&#39;%s&#39;&#39;.\n&quot;,
125                               expected, actual);
126             return 1;
127         } else
128             return 0;
129     }
130 
131     @ExpectedString(
132         &quot;@MostlyPrimitive(c0=&#39;a&#39;, &quot;+
133         &quot;c1=&#39;\\&#39;&#39;, &quot; +
134         &quot;b0=(byte)0x01, &quot; +
135         &quot;i0=1, &quot; +
136         &quot;i1=2, &quot; +
137         &quot;f0=1.0f, &quot; +
138         &quot;f1=0.0f/0.0f, &quot; +
139         &quot;d0=0.0, &quot; +
140         &quot;d1=1.0/0.0, &quot; +
141         &quot;l0=5L, &quot; +
142         &quot;l1=9223372036854775807L, &quot; +
143         &quot;l2=-9223372036854775808L, &quot; +
144         &quot;l3=-2147483648L, &quot; +
145         &quot;s0=\&quot;Hello world.\&quot;, &quot; +
146         &quot;s1=\&quot;a\\\&quot;b\&quot;, &quot; +
147         &quot;class0=Obj[].class, &quot; +
148         &quot;classArray={Obj[].class})&quot;)
149     @MostlyPrimitive(
150         c0=&#39;a&#39;,
151         c1=&#39;\&#39;&#39;,
152         b0=1,
153         i0=1,
154         i1=2,
155         f0=1.0f,
156         f1=Float.NaN,
157         d0=0.0,
158         d1=2.0/0.0,
159         l0=5,
160         l1=Long.MAX_VALUE,
161         l2=Long.MIN_VALUE,
162         l3=Integer.MIN_VALUE,
163         s0=&quot;Hello world.&quot;,
164         s1=&quot;a\&quot;b&quot;,
165         class0=Obj[].class,
166         classArray={Obj[].class}
167     )
168     static class PrimHost{}
169 
170     private int classyTest() {
171         int failures = 0;
172 
173         TypeElement annotationHostElt =
174             Objects.requireNonNull(elements.getTypeElement(&quot;AnnotationToStringTest.AnnotationHost&quot;));
175 
176         for (VariableElement f : ElementFilter.fieldsIn(annotationHostElt.getEnclosedElements())) {
177             String expected = f.getAnnotation(ExpectedString.class).value();
178             Annotation a = f.getAnnotation(Classy.class);
179 
180             System.out.println(a);
181             failures += check(expected, a.toString());
182 
183             failures += check(expected,
184                               retrieveAnnotationMirrorAsString(f, &quot;Classy&quot;) );
185         }
186         return failures;
187     }
188 
189     static class AnnotationHost {
190         @ExpectedString(
191        &quot;@Classy(Obj.class)&quot;)
192         @Classy(Obj.class)
193         public int f0;
194 
195         @ExpectedString(
196        &quot;@Classy(Obj[].class)&quot;)
197         @Classy(Obj[].class)
198         public int f1;
199 
200         @ExpectedString(
201        &quot;@Classy(Obj[][].class)&quot;)
202         @Classy(Obj[][].class)
203         public int f2;
204 
205         @ExpectedString(
206        &quot;@Classy(Obj[][][].class)&quot;)
207         @Classy(Obj[][][].class)
208         public int f3;
209 
210         @ExpectedString(
211        &quot;@Classy(int.class)&quot;)
212         @Classy(int.class)
213         public int f4;
214 
215         @ExpectedString(
216        &quot;@Classy(int[][][].class)&quot;)
217         @Classy(int[][][].class)
218         public int f5;
219     }
220 
221     /**
222      * Each field should have two annotations, the first being
223      * @ExpectedString and the second the annotation under test.
224      */
225     private int arrayAnnotationTest() {
226         int failures = 0;
227 
228         TypeElement arrayAnnotationHostElt =
229             Objects.requireNonNull(elements
230                                    .getTypeElement(&quot;AnnotationToStringTest.ArrayAnnotationHost&quot;));
231 
232         for (VariableElement f :
233                  ElementFilter.fieldsIn(arrayAnnotationHostElt.getEnclosedElements())) {
234             var annotations = f.getAnnotationMirrors();
235             // String expected = retrieveAnnotationMirrorValue(f, &quot;ExpectedString&quot;);
236             String expected = f.getAnnotation(ExpectedString.class).value();
237 
238             // Problem with
239             // Need a de-quote method...
240             // expected = expected.substring(1, expected.length() - 1);
241 
242               failures +=
243                   check(expected,
244                         annotations.get(1).toString());
245 
246             // Get the array-valued annotation as an annotation
247               failures +=
248                   check(expected,
249                         retrieveAnnotationMirrorAsString(f,
250                                                          annotations.get(1)
251                                                          .getAnnotationType().toString()));
252         }
253         return failures;
254     }
255 
256     static class ArrayAnnotationHost {
257         @ExpectedString(
258        &quot;@BooleanArray({true, false, true})&quot;)
259         @BooleanArray({true, false, true})
260         public boolean[]   f0;
261 
262         @ExpectedString(
263        &quot;@FloatArray({3.0f, 4.0f, 0.0f/0.0f, -1.0f/0.0f, 1.0f/0.0f})&quot;)
264         @FloatArray({3.0f, 4.0f, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY})
265         public float[]     f1;
266 
267         @ExpectedString(
268        &quot;@DoubleArray({1.0, 2.0, 0.0/0.0, 1.0/0.0, -1.0/0.0})&quot;)
269         @DoubleArray({1.0, 2.0, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY,})
270         public double[]    f2;
271 
272 
273         @ExpectedString(
274        &quot;@ByteArray({(byte)0x0a, (byte)0x0b, (byte)0x0c})&quot;)
275         @ByteArray({10, 11, 12})
276         public byte[]      f3;
277 
278         @ExpectedString(
279        &quot;@ShortArray({0, 4, 5})&quot;)
280         @ShortArray({0, 4, 5})
281         public short[]     f4;
282 
283         @ExpectedString(
284        &quot;@CharArray({&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;\\&#39;&#39;})&quot;)
285         @CharArray({&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;\&#39;&#39;})
286         public char[]      f5;
287 
288         @ExpectedString(
289        &quot;@IntArray({1})&quot;)
290         @IntArray({1})
291         public int[]       f6;
292 
293         @ExpectedString(
294        &quot;@LongArray({-9223372036854775808L, -2147483649L, -2147483648L,&quot; +
295                 &quot; -2147483647L, 2147483648L, 9223372036854775807L})&quot;)
296         @LongArray({Long.MIN_VALUE, Integer.MIN_VALUE-1L, Integer.MIN_VALUE,
297                 -Integer.MAX_VALUE, Integer.MAX_VALUE+1L, Long.MAX_VALUE})
298         public long[]      f7;
299 
300         @ExpectedString(
301        &quot;@StringArray({\&quot;A\&quot;, \&quot;B\&quot;, \&quot;C\&quot;, \&quot;\\\&quot;Quote\\\&quot;\&quot;})&quot;)
302         @StringArray({&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;\&quot;Quote\&quot;&quot;})
303         public String[]    f8;
304 
305         @ExpectedString(
306        &quot;@ClassArray({int.class, Obj[].class})&quot;)
307         @ClassArray({int.class, Obj[].class})
308         public Class&lt;?&gt;[]  f9;
309 
310         @ExpectedString(
311        &quot;@EnumArray({SOURCE})&quot;)
312         @EnumArray({RetentionPolicy.SOURCE})
313         public RetentionPolicy[]  f10;
314     }
315 }
316 
317 // ------------ Supporting types ------------
318 
319 class Obj {}
320 
321 @Retention(RetentionPolicy.RUNTIME)
322 @interface ExpectedString {
323     String value();
324 }
325 
326 @Retention(RetentionPolicy.RUNTIME)
327 @interface Classy {
328     Class&lt;?&gt; value();
329 }
330 
331 @Retention(RetentionPolicy.RUNTIME)
332 @interface BooleanArray {
333     boolean[] value();
334 }
335 
336 @Retention(RetentionPolicy.RUNTIME)
337 @interface FloatArray {
338     float[] value();
339 }
340 
341 @Retention(RetentionPolicy.RUNTIME)
342 @interface DoubleArray {
343     double[] value();
344 }
345 
346 @Retention(RetentionPolicy.RUNTIME)
347 @interface ByteArray {
348     byte[] value();
349 }
350 
351 @Retention(RetentionPolicy.RUNTIME)
352 @interface ShortArray {
353     short[] value();
354 }
355 
356 @Retention(RetentionPolicy.RUNTIME)
357 @interface CharArray {
358     char[] value();
359 }
360 
361 @Retention(RetentionPolicy.RUNTIME)
362 @interface IntArray {
363     int[] value();
364 }
365 
366 @Retention(RetentionPolicy.RUNTIME)
367 @interface LongArray {
368     long[] value();
369 }
370 
371 @Retention(RetentionPolicy.RUNTIME)
372 @interface ClassArray {
373     Class&lt;?&gt;[] value() default {int.class, Obj[].class};
374 }
375 
376 @Retention(RetentionPolicy.RUNTIME)
377 @interface StringArray {
378     String[] value();
379 }
380 
381 @Retention(RetentionPolicy.RUNTIME)
382 @interface EnumArray {
383     RetentionPolicy[] value();
384 }
385 
386 @Retention(RetentionPolicy.RUNTIME)
387 @interface MostlyPrimitive {
388     char   c0();
389     char   c1();
390     byte   b0();
391     int    i0();
392     int    i1();
393     float  f0();
394     float  f1();
395     double d0();
396     double d1();
397     long   l0();
398     long   l1();
399     long   l2();
400     long   l3();
401     String s0();
402     String s1();
403     Class&lt;?&gt; class0();
404     Class&lt;?&gt;[] classArray();
405 }
    </pre>
  </body>
</html>
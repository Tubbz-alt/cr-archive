<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/processing/model/element/AnnoProcessorOnRecordsTest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Verify that annotation processing works for records
 27  * @library /tools/lib /tools/javac/lib
 28  * @modules
 29  *      jdk.compiler/com.sun.tools.javac.api
 30  *      jdk.compiler/com.sun.tools.javac.main
 31  *      jdk.compiler/com.sun.tools.javac.code
 32  *      jdk.compiler/com.sun.tools.javac.util
 33  * @build toolbox.ToolBox toolbox.JavacTask
 34  * @build JavacTestingAbstractProcessor
 35  * @compile --enable-preview -source ${jdk.version} AnnoProcessorOnRecordsTest.java
 36  * @run main/othervm --enable-preview AnnoProcessorOnRecordsTest
 37  */
 38 
 39 import java.io.*;
 40 import java.nio.file.Files;
 41 import java.nio.file.Path;
 42 import java.nio.file.Paths;
 43 import java.util.*;
 44 
 45 import javax.annotation.processing.*;
 46 import javax.lang.model.SourceVersion;
 47 import javax.lang.model.element.Element;
 48 import javax.lang.model.element.ElementKind;
 49 import javax.lang.model.element.RecordComponentElement;
 50 import javax.lang.model.element.TypeElement;
 51 import javax.lang.model.element.VariableElement;
 52 import javax.lang.model.type.TypeKind;
 53 import javax.lang.model.util.ElementFilter;
 54 import javax.lang.model.util.ElementScanner14;
 55 import javax.tools.Diagnostic.Kind;
 56 import javax.tools.*;
 57 
 58 import java.lang.annotation.ElementType;
 59 import java.lang.annotation.Retention;
 60 import java.lang.annotation.RetentionPolicy;
 61 import java.lang.annotation.Target;
 62 
 63 import com.sun.tools.javac.code.Symbol;
 64 import com.sun.tools.javac.code.Symbol.VarSymbol;
 65 
 66 import com.sun.tools.javac.util.Assert;
 67 
 68 import toolbox.JavacTask;
 69 import toolbox.Task;
 70 import toolbox.Task.Mode;
 71 import toolbox.Task.OutputKind;
 72 import toolbox.TestRunner;
 73 import toolbox.ToolBox;
 74 
 75 public class AnnoProcessorOnRecordsTest extends TestRunner {
 76     protected ToolBox tb;
 77 
 78     AnnoProcessorOnRecordsTest() {
 79         super(System.err);
 80         tb = new ToolBox();
 81     }
 82 
 83     public static void main(String... args) throws Exception {
 84         System.out.println(System.getProperties());
 85         new AnnoProcessorOnRecordsTest().runTests();
 86     }
 87 
 88     protected void runTests() throws Exception {
 89         runTests(m -&gt; new Object[] { Paths.get(m.getName()) });
 90     }
 91 
 92     Path[] findJavaFiles(Path... paths) throws IOException {
 93         return tb.findJavaFiles(paths);
 94     }
 95 
 96     static final String SOURCE =
 97             &quot;&quot;&quot;
 98             import java.lang.annotation.*;
 99             import java.util.*;
100             import javax.annotation.processing.*;
101             import javax.lang.model.element.*;
102 
103             @Retention(RetentionPolicy.RUNTIME)
104             @Target({ ElementType.PARAMETER })
105             @interface Parameter {}
106 
107             @Retention(RetentionPolicy.RUNTIME)
108             @Target({ ElementType.METHOD })
109             @interface Method {}
110 
111             @Retention(RetentionPolicy.RUNTIME)
112             @Target({ ElementType.FIELD })
113             @interface Field {}
114 
115             @Retention(RetentionPolicy.RUNTIME)
116             @Target({ ElementType.RECORD_COMPONENT })
117             @interface RecComponent {}
118 
119             @Retention(RetentionPolicy.RUNTIME)
120             @interface All {}
121 
122             @Retention(RetentionPolicy.RUNTIME)
123             @Target({ ElementType.FIELD, ElementType.RECORD_COMPONENT })
124             @interface RecComponentAndField {}
125 
126             record R1(@Parameter int i) {}
127 
128             record R2(@Method int i) {}
129 
130             record R3(@Field int i) {}
131 
132             record R4(@All int i) {}
133 
134             record R5(@RecComponent int i) {}
135 
136             record R6(@RecComponentAndField int i) {}
137             &quot;&quot;&quot;;
138 
139     @Test
140     public void testAnnoProcessing(Path base) throws Exception {
141         Path src = base.resolve(&quot;src&quot;);
142         Path r = src.resolve(&quot;Records&quot;);
143 
144         Path classes = base.resolve(&quot;classes&quot;);
145 
146         Files.createDirectories(classes);
147 
148         tb.writeJavaFiles(r, SOURCE);
149 
150         for (Mode mode : new Mode[] {Mode.API}) {
151             new JavacTask(tb, mode)
152                     .options(&quot;-nowarn&quot;,
153                             &quot;-processor&quot;, Processor.class.getName(),
154                             &quot;--enable-preview&quot;,
155                             &quot;-source&quot;, Integer.toString(Runtime.version().feature()))
156                     .files(findJavaFiles(src))
157                     .outdir(classes)
158                     .run()
159                     .writeAll()
160                     .getOutputLines(Task.OutputKind.DIRECT);
161         }
162     }
163 
164     @SupportedAnnotationTypes(&quot;*&quot;)
165     public static final class Processor extends JavacTestingAbstractProcessor {
166         public boolean process(Set&lt;? extends TypeElement&gt; tes, RoundEnvironment renv) {
167             for (TypeElement te : tes) {
168                 switch (te.toString()) {
169                     case &quot;Parameter&quot; :
170                         checkElements(te, renv, 1, Set.of(ElementKind.PARAMETER));
171                         break;
172                     case &quot;Method&quot;:
173                         checkElements(te, renv, 1, Set.of(ElementKind.METHOD));
174                         break;
175                     case &quot;Field&quot;:
176                         checkElements(te, renv, 1, Set.of(ElementKind.FIELD));
177                         break;
178                     case &quot;All&quot;:
179                         checkElements(te, renv, 4,
180                                 Set.of(ElementKind.FIELD,
181                                         ElementKind.METHOD,
182                                         ElementKind.PARAMETER,
183                                         ElementKind.RECORD_COMPONENT));
184                         break;
185                     case &quot;RecComponent&quot;:
186                         checkElements(te, renv, 1, Set.of(ElementKind.RECORD_COMPONENT));
187                         break;
188                     case &quot;RecComponentAndField&quot;:
189                         checkElements(te, renv, 2, Set.of(ElementKind.RECORD_COMPONENT, ElementKind.FIELD));
190                         break;
191                     default:
192                         // ignore, just another annotation like Target, we don&#39;t care about
193                 }
194             }
195             return true;
196         }
197 
198         void checkElements(TypeElement te, RoundEnvironment renv, int expectedNumberOfElements, Set&lt;ElementKind&gt; kinds) {
199             Set&lt;? extends Element&gt; annoElements = renv.getElementsAnnotatedWith(te);
200             Assert.check(annoElements.size() == expectedNumberOfElements);
201             for (Element e : annoElements) {
202                 Symbol s = (Symbol) e;
203                 Assert.check(kinds.contains(s.getKind()));
204             }
205         }
206     }
207 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/processing/model/testgetallmembers/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2006, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug     6374357 6308351 6707027
 27  * @summary PackageElement.getEnclosedElements() throws ClassReader$BadClassFileException
 28  * @author  Peter von der Ah\u00e9
 29  * @modules jdk.compiler/com.sun.tools.javac.model
 30  * @run main/othervm -Xmx256m Main
 31  */
 32 
 33 import java.io.File;
 34 import java.nio.file.Path;
 35 import java.util.*;
 36 import java.util.Map.Entry;
 37 
 38 import javax.lang.model.element.Element;
 39 import javax.lang.model.element.ElementKind;
 40 import javax.lang.model.element.ModuleElement;
 41 import javax.lang.model.element.PackageElement;
 42 import javax.lang.model.element.TypeElement;
 43 import javax.lang.model.util.Elements;
 44 import javax.tools.*;
 45 
 46 import com.sun.source.util.JavacTask;
 47 import com.sun.tools.javac.model.JavacElements;
 48 
 49 import static javax.tools.StandardLocation.CLASS_PATH;
 50 import static javax.tools.StandardLocation.PLATFORM_CLASS_PATH;
 51 import static javax.tools.JavaFileObject.Kind.CLASS;
 52 
 53 
 54 public class Main {
 55 
 56     public static PackageElement getPackage(TypeElement type) {
 57         Element owner = type;
 58         while (owner.getKind() != ElementKind.PACKAGE)
 59             owner = owner.getEnclosingElement();
 60         return (PackageElement)owner;
 61     }
 62 
 63     static int progress = 0;
 64     static JavaCompiler tool;
 65     static JavacTask javac;
 66     static Elements elements;
 67 
 68     static List&lt;String&gt; addmods_ALL_SYSTEM = Arrays.asList(&quot;--add-modules&quot;, &quot;ALL-SYSTEM&quot;);
 69 
 70     public static void main(String[] args) throws Exception {
 71         JavaCompiler tool = ToolProvider.getSystemJavaCompiler();
 72         try (StandardJavaFileManager fm = tool.getStandardFileManager(null, null, null)) {
 73             fm.setLocation(CLASS_PATH, Collections.&lt;File&gt;emptyList());
 74             JavacTask javac = (JavacTask)tool.getTask(null, fm, null, addmods_ALL_SYSTEM, null, null);
 75             Elements elements = javac.getElements();
 76 
 77             final Map&lt;String, Set&lt;String&gt;&gt; packages = new LinkedHashMap&lt;&gt;();
 78 
 79             int nestedClasses = 0;
 80             int classes = 0;
 81 
 82             for (JavaFileObject file : fm.list(PLATFORM_CLASS_PATH, &quot;&quot;, EnumSet.of(CLASS), true)) {
 83                 String type = fm.inferBinaryName(PLATFORM_CLASS_PATH, file);
 84                 if (type.endsWith(&quot;package-info&quot;))
 85                     continue;
 86                 if (type.endsWith(&quot;module-info&quot;))
 87                     continue;
 88                 Path path = fm.asPath(file);
 89                 int moduleIndex = path.getNameCount() - type.split(&quot;\\Q.\\E&quot;).length - 1;
 90                 String moduleName = path.getName(moduleIndex).toString();
 91                 if (moduleName.startsWith(&quot;jdk.incubator.&quot;)) //incubator modules not in module graph by default
 92                     continue;
 93                 try {
 94                     ModuleElement me = elements.getModuleElement(moduleName);
 95                     me.getClass();
 96                     TypeElement elem = ((JavacElements) elements).getTypeElement(me, type);
 97                     if (elem == null &amp;&amp; type.indexOf(&#39;$&#39;) &gt; 0) {
 98                         nestedClasses++;
 99                         type = null;
100                         continue;
101                     }
102                     classes++;
103                     String pack = getPackage(elem).getQualifiedName().toString();
104                     packages.computeIfAbsent(me.getQualifiedName().toString(),
105                                              m -&gt; new LinkedHashSet&lt;&gt;()).add(pack);
106                     elem.getKind(); // force completion
107                     type = null;
108                 } finally {
109                     if (type != null)
110                         System.err.println(&quot;Looking at &quot; + type);
111                 }
112             }
113             javac = null;
114             elements = null;
115 
116             javac = (JavacTask)tool.getTask(null, fm, null, addmods_ALL_SYSTEM, null, null);
117             elements = javac.getElements();
118 
119             for (Entry&lt;String, Set&lt;String&gt;&gt; module2Packages : packages.entrySet()) {
120                 ModuleElement me = elements.getModuleElement(module2Packages.getKey());
121                 me.getClass();
122                 for (String name : module2Packages.getValue()) {
123                     PackageElement pe = ((JavacElements) elements).getPackageElement(me, name);
124                     for (Element e : pe.getEnclosedElements()) {
125                         e.getSimpleName().getClass();
126                     }
127                 }
128             }
129             /*
130              * A few sanity checks based on current values:
131              *
132              * packages: 775, classes: 12429 + 5917
133              *
134              * As the platform evolves the numbers are likely to grow
135              * monotonically but in case somebody gets a clever idea for
136              * limiting the number of packages exposed, this number might
137              * drop.  So we test low values.
138              */
139             System.out.format(&quot;packages: %s, classes: %s + %s%n&quot;,
140                               packages.size(), classes, nestedClasses);
141             if (classes &lt; 9000)
142                 throw new AssertionError(&quot;Too few classes in PLATFORM_CLASS_PATH ;-)&quot;);
143             if (packages.values().stream().flatMap(packs -&gt; packs.stream()).count() &lt; 530)
144                 throw new AssertionError(&quot;Too few packages in PLATFORM_CLASS_PATH ;-)&quot;);
145             if (nestedClasses &lt; 3000)
146                 throw new AssertionError(&quot;Too few nested classes in PLATFORM_CLASS_PATH ;-)&quot;);
147         }
148     }
149 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/failover/CheckAttributedTree.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 6970584 8006694 8062373 8129962
 27  * @summary assorted position errors in compiler syntax trees
 28  *  temporarily workaround combo tests are causing time out in several platforms
 29  * @library ../lib
 30  * @modules java.desktop
 31  *          jdk.compiler/com.sun.tools.javac.api
 32  *          jdk.compiler/com.sun.tools.javac.code
 33  *          jdk.compiler/com.sun.tools.javac.file
 34  *          jdk.compiler/com.sun.tools.javac.tree
 35  *          jdk.compiler/com.sun.tools.javac.util
 36  * @build combo.ComboTestHelper
 37  * @run main CheckAttributedTree -q -r -et ERRONEOUS .
 38  */
 39 
 40 import java.awt.BorderLayout;
 41 import java.awt.Color;
 42 import java.awt.Dimension;
 43 import java.awt.EventQueue;
 44 import java.awt.Font;
 45 import java.awt.GridBagConstraints;
 46 import java.awt.GridBagLayout;
 47 import java.awt.Rectangle;
 48 import java.awt.event.ActionEvent;
 49 import java.awt.event.ActionListener;
 50 import java.awt.event.MouseAdapter;
 51 import java.awt.event.MouseEvent;
 52 import java.io.File;
 53 import java.io.IOException;
 54 import java.io.PrintStream;
 55 import java.io.PrintWriter;
 56 import java.io.StringWriter;
 57 import java.lang.reflect.Field;
 58 import java.nio.file.FileVisitResult;
 59 import java.nio.file.Files;
 60 import java.nio.file.Path;
 61 import java.nio.file.SimpleFileVisitor;
 62 import java.nio.file.attribute.BasicFileAttributes;
 63 import java.util.ArrayList;
 64 import java.util.Arrays;
 65 import java.util.HashSet;
 66 import java.util.List;
 67 import java.util.Set;
 68 import java.util.concurrent.atomic.AtomicInteger;
 69 import java.util.function.BiConsumer;
 70 
 71 import javax.lang.model.element.Element;
 72 import javax.swing.DefaultComboBoxModel;
 73 import javax.swing.JComboBox;
 74 import javax.swing.JComponent;
 75 import javax.swing.JFrame;
 76 import javax.swing.JLabel;
 77 import javax.swing.JPanel;
 78 import javax.swing.JScrollPane;
 79 import javax.swing.JTextArea;
 80 import javax.swing.JTextField;
 81 import javax.swing.SwingUtilities;
 82 import javax.swing.event.CaretEvent;
 83 import javax.swing.event.CaretListener;
 84 import javax.swing.text.BadLocationException;
 85 import javax.swing.text.DefaultHighlighter;
 86 import javax.swing.text.Highlighter;
 87 import javax.tools.JavaFileObject;
 88 
 89 import com.sun.source.tree.CompilationUnitTree;
 90 import com.sun.source.util.TaskEvent;
 91 import com.sun.source.util.TaskEvent.Kind;
 92 import com.sun.source.util.TaskListener;
 93 import com.sun.tools.javac.code.Symbol;
 94 import com.sun.tools.javac.code.Type;
 95 import com.sun.tools.javac.tree.EndPosTable;
 96 import com.sun.tools.javac.tree.JCTree;
 97 import com.sun.tools.javac.tree.JCTree.JCBreak;
 98 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 99 import com.sun.tools.javac.tree.JCTree.JCImport;
100 import com.sun.tools.javac.tree.TreeInfo;
101 import com.sun.tools.javac.tree.TreeScanner;
102 import com.sun.tools.javac.util.Pair;
103 
104 import static com.sun.tools.javac.tree.JCTree.Tag.*;
105 
106 import combo.ComboTestHelper;
107 import combo.ComboInstance;
108 import combo.ComboTestHelper.IgnoreMode;
109 
110 /**
111  * Utility and test program to check validity of tree positions for tree nodes.
112  * The program can be run standalone, or as a jtreg test.  In standalone mode,
113  * errors can be displayed in a gui viewer. For info on command line args,
114  * run program with no args.
115  *
116  * &lt;p&gt;
117  * jtreg: Note that by using the -r switch in the test description below, this test
118  * will process all java files in the langtools/test directory, thus implicitly
119  * covering any new language features that may be tested in this test suite.
120  */
121 
122 public class CheckAttributedTree {
123     /**
124      * Main entry point.
125      * If test.src is set, program runs in jtreg mode, and will throw an Error
126      * if any errors arise, otherwise System.exit will be used, unless the gui
127      * viewer is being used. In jtreg mode, the default base directory for file
128      * args is the value of ${test.src}. In jtreg mode, the -r option can be
129      * given to change the default base directory to the root test directory.
130      */
131     public static void main(String... args) throws Exception {
132         String testSrc = System.getProperty(&quot;test.src&quot;);
133         File baseDir = (testSrc == null) ? null : new File(testSrc);
134         boolean ok = new CheckAttributedTree().run(baseDir, args);
135         if (!ok) {
136             if (testSrc != null)  // jtreg mode
137                 throw new Error(&quot;failed&quot;);
138             else
139                 System.exit(1);
140         }
141         System.err.println(&quot;total number of compilations &quot; + totalNumberOfCompilations);
142         System.err.println(&quot;number of failed compilations &quot; + numberOfFailedCompilations);
143     }
144 
145     static private int totalNumberOfCompilations = 0;
146     static private int numberOfFailedCompilations = 0;
147 
148     /**
149      * Run the program. A base directory can be provided for file arguments.
150      * In jtreg mode, the -r option can be given to change the default base
151      * directory to the test root directory. For other options, see usage().
152      * @param baseDir base directory for any file arguments.
153      * @param args command line args
154      * @return true if successful or in gui mode
155      */
156     boolean run(File baseDir, String... args) throws Exception {
157         if (args.length == 0) {
158             usage(System.out);
159             return true;
160         }
161 
162         List&lt;File&gt; files = new ArrayList&lt;File&gt;();
163         for (int i = 0; i &lt; args.length; i++) {
164             String arg = args[i];
165             if (arg.equals(&quot;-encoding&quot;) &amp;&amp; i + 1 &lt; args.length)
166                 encoding = args[++i];
167             else if (arg.equals(&quot;-gui&quot;))
168                 gui = true;
169             else if (arg.equals(&quot;-q&quot;))
170                 quiet = true;
171             else if (arg.equals(&quot;-v&quot;)) {
172                 verbose = true;
173             }
174             else if (arg.equals(&quot;-t&quot;) &amp;&amp; i + 1 &lt; args.length)
175                 tags.add(args[++i]);
176             else if (arg.equals(&quot;-ef&quot;) &amp;&amp; i + 1 &lt; args.length)
177                 excludeFiles.add(new File(baseDir, args[++i]));
178             else if (arg.equals(&quot;-et&quot;) &amp;&amp; i + 1 &lt; args.length)
179                 excludeTags.add(args[++i]);
180             else if (arg.equals(&quot;-r&quot;)) {
181                 if (excludeFiles.size() &gt; 0)
182                     throw new Error(&quot;-r must be used before -ef&quot;);
183                 File d = baseDir;
184                 while (!new File(d, &quot;TEST.ROOT&quot;).exists()) {
185                     if (d == null)
186                         throw new Error(&quot;cannot find TEST.ROOT&quot;);
187                     d = d.getParentFile();
188                 }
189                 baseDir = d;
190             }
191             else if (arg.startsWith(&quot;-&quot;))
192                 throw new Error(&quot;unknown option: &quot; + arg);
193             else {
194                 while (i &lt; args.length)
195                     files.add(new File(baseDir, args[i++]));
196             }
197         }
198 
199         ComboTestHelper&lt;FileChecker&gt; cth = new ComboTestHelper&lt;&gt;();
200         cth.withIgnoreMode(IgnoreMode.IGNORE_ALL)
201                 .withFilter(FileChecker::checkFile)
202                 .withDimension(&quot;FILE&quot;, (x, file) -&gt; x.file = file, getAllFiles(files))
203                 .run(FileChecker::new);
204 
205         if (fileCount.get() != 1)
206             errWriter.println(fileCount + &quot; files read&quot;);
207 
208         if (verbose) {
209             System.out.println(errSWriter.toString());
210         }
211 
212         return (gui || !cth.info().hasFailures());
213     }
214 
215     File[] getAllFiles(List&lt;File&gt; roots) throws IOException {
216         long now = System.currentTimeMillis();
217         ArrayList&lt;File&gt; buf = new ArrayList&lt;&gt;();
218         for (File file : roots) {
219             Files.walkFileTree(file.toPath(), new SimpleFileVisitor&lt;Path&gt;() {
220                 @Override
221                 public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
222                     buf.add(file.toFile());
223                     return FileVisitResult.CONTINUE;
224                 }
225             });
226         }
227         long delta = System.currentTimeMillis() - now;
228         System.err.println(&quot;All files = &quot; + buf.size() + &quot; &quot; + delta);
229         return buf.toArray(new File[buf.size()]);
230     }
231 
232     /**
233      * Print command line help.
234      * @param out output stream
235      */
236     void usage(PrintStream out) {
237         out.println(&quot;Usage:&quot;);
238         out.println(&quot;  java CheckAttributedTree options... files...&quot;);
239         out.println(&quot;&quot;);
240         out.println(&quot;where options include:&quot;);
241         out.println(&quot;-q        Quiet: don&#39;t report on inapplicable files&quot;);
242         out.println(&quot;-gui      Display returns in a GUI viewer&quot;);
243         out.println(&quot;-v        Verbose: report on files as they are being read&quot;);
244         out.println(&quot;-t tag    Limit checks to tree nodes with this tag&quot;);
245         out.println(&quot;          Can be repeated if desired&quot;);
246         out.println(&quot;-ef file  Exclude file or directory&quot;);
247         out.println(&quot;-et tag   Exclude tree nodes with given tag name&quot;);
248         out.println(&quot;&quot;);
249         out.println(&quot;files may be directories or files&quot;);
250         out.println(&quot;directories will be scanned recursively&quot;);
251         out.println(&quot;non java files, or java files which cannot be parsed, will be ignored&quot;);
252         out.println(&quot;&quot;);
253     }
254 
255     class FileChecker extends ComboInstance&lt;FileChecker&gt; {
256 
257         File file;
258 
259         boolean checkFile() {
260             if (!file.exists()) {
261                 error(&quot;File not found: &quot; + file);
262                 return false;
263             }
264             if (excludeFiles.contains(file)) {
265                 if (!quiet)
266                     error(&quot;File &quot; + file + &quot; excluded&quot;);
267                 return false;
268             }
269             if (!file.getName().endsWith(&quot;.java&quot;)) {
270                 if (!quiet)
271                     error(&quot;File &quot; + file + &quot; ignored&quot;);
272                 return false;
273             }
274 
275             return true;
276         }
277 
278         public void doWork() {
279             if (!file.exists()) {
280                 error(&quot;File not found: &quot; + file);
281             }
282             if (excludeFiles.contains(file)) {
283                 if (!quiet)
284                     error(&quot;File &quot; + file + &quot; excluded&quot;);
285                 return;
286             }
287             if (!file.getName().endsWith(&quot;.java&quot;)) {
288                 if (!quiet)
289                     error(&quot;File &quot; + file + &quot; ignored&quot;);
290             }
291             try {
292                 if (verbose)
293                     errWriter.println(file);
294                 fileCount.incrementAndGet();
295                 NPETester p = new NPETester();
296                 readAndCheck(file, p::test);
297             } catch (Throwable t) {
298                 if (!quiet) {
299                     error(&quot;Error checking &quot; + file + &quot;\n&quot; + t.getMessage());
300                 }
301             }
302         }
303 
304         /**
305          * Read and check a file.
306          * @param file the file to be read
307          * @return the tree for the content of the file
308          * @throws IOException if any IO errors occur
309          * @throws AttributionException if any errors occur while analyzing the file
310          */
311         void readAndCheck(File file, BiConsumer&lt;JCCompilationUnit, JCTree&gt; c) throws IOException {
312             Iterable&lt;? extends JavaFileObject&gt; files = fileManager().getJavaFileObjects(file);
313             final List&lt;Element&gt; analyzedElems = new ArrayList&lt;&gt;();
314             final List&lt;CompilationUnitTree&gt; trees = new ArrayList&lt;&gt;();
315             totalNumberOfCompilations++;
316             newCompilationTask()
317                 .withWriter(pw)
318                     .withOption(&quot;--should-stop=at=ATTR&quot;)
319                     .withOption(&quot;-XDverboseCompilePolicy&quot;)
320                     .withOption(&quot;-Xdoclint:none&quot;)
321                     .withSource(files.iterator().next())
322                     .withListener(new TaskListener() {
323                         public void started(TaskEvent e) {
324                             if (e.getKind() == TaskEvent.Kind.ANALYZE)
325                             analyzedElems.add(e.getTypeElement());
326                     }
327 
328                     public void finished(TaskEvent e) {
329                         if (e.getKind() == Kind.PARSE)
330                             trees.add(e.getCompilationUnit());
331                     }
332                 }).analyze(res -&gt; {
333                 Iterable&lt;? extends Element&gt; elems = res.get();
334                 if (elems.iterator().hasNext()) {
335                     for (CompilationUnitTree t : trees) {
336                        JCCompilationUnit cu = (JCCompilationUnit)t;
337                        for (JCTree def : cu.defs) {
338                            if (def.hasTag(CLASSDEF) &amp;&amp;
339                                    analyzedElems.contains(((JCTree.JCClassDecl)def).sym)) {
340                                c.accept(cu, def);
341                            }
342                        }
343                     }
344                 } else {
345                     numberOfFailedCompilations++;
346                 }
347             });
348         }
349 
350         /**
351          * Report an error. When the program is complete, the program will either
352          * exit or throw an Error if any errors have been reported.
353          * @param msg the error message
354          */
355         void error(String msg) {
356             System.err.println();
357             System.err.println(msg);
358             System.err.println();
359             fail(msg);
360         }
361 
362         /**
363          * Main class for testing assertions concerning types/symbol
364          * left uninitialized after attribution
365          */
366         private class NPETester extends TreeScanner {
367             void test(JCCompilationUnit cut, JCTree tree) {
368                 sourcefile = cut.sourcefile;
369                 endPosTable = cut.endPositions;
370                 encl = new Info(tree, endPosTable);
371                 tree.accept(this);
372             }
373 
374             @Override
375             public void scan(JCTree tree) {
376                 if (tree == null ||
377                         excludeTags.contains(treeUtil.nameFromTag(tree.getTag()))) {
378                     return;
379                 }
380 
381                 Info self = new Info(tree, endPosTable);
382                 if (mandatoryType(tree)) {
383                     check(tree.type != null,
384                             &quot;&#39;null&#39; field &#39;type&#39; found in tree &quot;, self);
385                     if (tree.type==null)
386                         Thread.dumpStack();
387                 }
388 
389                 Field errField = checkFields(tree);
390                 if (errField!=null) {
391                     check(false,
392                             &quot;&#39;null&#39; field &#39;&quot; + errField.getName() + &quot;&#39; found in tree &quot;, self);
393                 }
394 
395                 Info prevEncl = encl;
396                 encl = self;
397                 tree.accept(this);
398                 encl = prevEncl;
399             }
400 
401             private boolean mandatoryType(JCTree that) {
402                 return that instanceof JCTree.JCExpression ||
403                         that.hasTag(VARDEF) ||
404                         that.hasTag(METHODDEF) ||
405                         that.hasTag(CLASSDEF);
406             }
407 
408             private final List&lt;String&gt; excludedFields = Arrays.asList(&quot;varargsElement&quot;, &quot;targetType&quot;);
409 
410             void check(boolean ok, String label, Info self) {
411                 if (!ok) {
412                     if (gui) {
413                         if (viewer == null)
414                             viewer = new Viewer();
415                         viewer.addEntry(sourcefile, label, encl, self);
416                     }
417                     error(label + self.toString() + &quot; encl: &quot; + encl.toString() +
418                             &quot; in file: &quot; + sourcefile + &quot;  &quot; + self.tree);
419                 }
420             }
421 
422             Field checkFields(JCTree t) {
423                 List&lt;Field&gt; fieldsToCheck = treeUtil.getFieldsOfType(t,
424                         excludedFields,
425                         Symbol.class,
426                         Type.class);
427                 for (Field f : fieldsToCheck) {
428                     try {
429                         if (f.get(t) == null) {
430                             return f;
431                         }
432                     }
433                     catch (IllegalAccessException e) {
434                         System.err.println(&quot;Cannot read field: &quot; + f);
435                         //swallow it
436                     }
437                 }
438                 return null;
439             }
440 
441             @Override
442             public void visitImport(JCImport tree) { }
443 
444             @Override
445             public void visitTopLevel(JCCompilationUnit tree) {
446                 scan(tree.defs);
447             }
448 
449             @Override
450             public void visitBreak(JCBreak tree) {
451                 if (tree.isValueBreak())
452                     super.visitBreak(tree);
453             }
454 
455             JavaFileObject sourcefile;
456             EndPosTable endPosTable;
457             Info encl;
458         }
459     }
460 
461     // See CR:  6982992 Tests CheckAttributedTree.java, JavacTreeScannerTest.java, and SourceTreeeScannerTest.java timeout
462     StringWriter sw = new StringWriter();
463     PrintWriter pw = new PrintWriter(sw);
464 
465     StringWriter errSWriter = new StringWriter();
466     PrintWriter errWriter = new PrintWriter(errSWriter);
467 
468     /** Flag: don&#39;t report irrelevant files. */
469     boolean quiet;
470     /** Flag: show errors in GUI viewer. */
471     boolean gui;
472     /** The GUI viewer for errors. */
473     Viewer viewer;
474     /** Flag: report files as they are processed. */
475     boolean verbose;
476     /** Option: encoding for test files. */
477     String encoding;
478     /** The set of tags for tree nodes to be analyzed; if empty, all tree nodes
479      * are analyzed. */
480     Set&lt;String&gt; tags = new HashSet&lt;String&gt;();
481     /** Set of files and directories to be excluded from analysis. */
482     Set&lt;File&gt; excludeFiles = new HashSet&lt;File&gt;();
483     /** Set of tag names to be excluded from analysis. */
484     Set&lt;String&gt; excludeTags = new HashSet&lt;String&gt;();
485     /** Utility class for trees */
486     TreeUtil treeUtil = new TreeUtil();
487 
488     /**
489      * Utility class providing easy access to position and other info for a tree node.
490      */
491     private class Info {
492         Info() {
493             tree = null;
494             tag = ERRONEOUS;
495             start = 0;
496             pos = 0;
497             end = Integer.MAX_VALUE;
498         }
499 
500         Info(JCTree tree, EndPosTable endPosTable) {
501             this.tree = tree;
502             tag = tree.getTag();
503             start = TreeInfo.getStartPos(tree);
504             pos = tree.pos;
505             end = TreeInfo.getEndPos(tree, endPosTable);
506         }
507 
508         @Override
509         public String toString() {
510             return treeUtil.nameFromTag(tree.getTag()) + &quot;[start:&quot; + start + &quot;,pos:&quot; + pos + &quot;,end:&quot; + end + &quot;]&quot;;
511         }
512 
513         final JCTree tree;
514         final JCTree.Tag tag;
515         final int start;
516         final int pos;
517         final int end;
518     }
519 
520     /**
521      * Names for tree tags.
522      */
523     private static class TreeUtil {
524         String nameFromTag(JCTree.Tag tag) {
525             String name = tag.name();
526             return (name == null) ? &quot;??&quot; : name;
527         }
528 
529         List&lt;Field&gt; getFieldsOfType(JCTree t, List&lt;String&gt; excludeNames, Class&lt;?&gt;... types) {
530             List&lt;Field&gt; buf = new ArrayList&lt;Field&gt;();
531             for (Field f : t.getClass().getDeclaredFields()) {
532                 if (!excludeNames.contains(f.getName())) {
533                     for (Class&lt;?&gt; type : types) {
534                         if (type.isAssignableFrom(f.getType())) {
535                             f.setAccessible(true);
536                             buf.add(f);
537                             break;
538                         }
539                     }
540                 }
541             }
542             return buf;
543         }
544     }
545 
546     /**
547      * GUI viewer for issues found by TreePosTester. The viewer provides a drop
548      * down list for selecting error conditions, a header area providing details
549      * about an error, and a text area with the ranges of text highlighted as
550      * appropriate.
551      */
552     private class Viewer extends JFrame {
553         /**
554          * Create a viewer.
555          */
556         Viewer() {
557             initGUI();
558         }
559 
560         /**
561          * Add another entry to the list of errors.
562          * @param file The file containing the error
563          * @param check The condition that was being tested, and which failed
564          * @param encl the enclosing tree node
565          * @param self the tree node containing the error
566          */
567         void addEntry(JavaFileObject file, String check, Info encl, Info self) {
568             Entry e = new Entry(file, check, encl, self);
569             DefaultComboBoxModel m = (DefaultComboBoxModel) entries.getModel();
570             m.addElement(e);
571             if (m.getSize() == 1)
572                 entries.setSelectedItem(e);
573         }
574 
575         /**
576          * Initialize the GUI window.
577          */
578         private void initGUI() {
579             JPanel head = new JPanel(new GridBagLayout());
580             GridBagConstraints lc = new GridBagConstraints();
581             GridBagConstraints fc = new GridBagConstraints();
582             fc.anchor = GridBagConstraints.WEST;
583             fc.fill = GridBagConstraints.HORIZONTAL;
584             fc.gridwidth = GridBagConstraints.REMAINDER;
585 
586             entries = new JComboBox();
587             entries.addActionListener(new ActionListener() {
588                 public void actionPerformed(ActionEvent e) {
589                     showEntry((Entry) entries.getSelectedItem());
590                 }
591             });
592             fc.insets.bottom = 10;
593             head.add(entries, fc);
594             fc.insets.bottom = 0;
595             head.add(new JLabel(&quot;check:&quot;), lc);
596             head.add(checkField = createTextField(80), fc);
597             fc.fill = GridBagConstraints.NONE;
598             head.add(setBackground(new JLabel(&quot;encl:&quot;), enclColor), lc);
599             head.add(enclPanel = new InfoPanel(), fc);
600             head.add(setBackground(new JLabel(&quot;self:&quot;), selfColor), lc);
601             head.add(selfPanel = new InfoPanel(), fc);
602             add(head, BorderLayout.NORTH);
603 
604             body = new JTextArea();
605             body.setFont(Font.decode(Font.MONOSPACED));
606             body.addCaretListener(new CaretListener() {
607                 public void caretUpdate(CaretEvent e) {
608                     int dot = e.getDot();
609                     int mark = e.getMark();
610                     if (dot == mark)
611                         statusText.setText(&quot;dot: &quot; + dot);
612                     else
613                         statusText.setText(&quot;dot: &quot; + dot + &quot;, mark:&quot; + mark);
614                 }
615             });
616             JScrollPane p = new JScrollPane(body,
617                     JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
618                     JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
619             p.setPreferredSize(new Dimension(640, 480));
620             add(p, BorderLayout.CENTER);
621 
622             statusText = createTextField(80);
623             add(statusText, BorderLayout.SOUTH);
624 
625             pack();
626             setLocationRelativeTo(null); // centered on screen
627             setVisible(true);
628             setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
629         }
630 
631         /** Show an entry that has been selected. */
632         private void showEntry(Entry e) {
633             try {
634                 // update simple fields
635                 setTitle(e.file.getName());
636                 checkField.setText(e.check);
637                 enclPanel.setInfo(e.encl);
638                 selfPanel.setInfo(e.self);
639                 // show file text with highlights
640                 body.setText(e.file.getCharContent(true).toString());
641                 Highlighter highlighter = body.getHighlighter();
642                 highlighter.removeAllHighlights();
643                 addHighlight(highlighter, e.encl, enclColor);
644                 addHighlight(highlighter, e.self, selfColor);
645                 scroll(body, getMinPos(enclPanel.info, selfPanel.info));
646             } catch (IOException ex) {
647                 body.setText(&quot;Cannot read &quot; + e.file.getName() + &quot;: &quot; + e);
648             }
649         }
650 
651         /** Create a test field. */
652         private JTextField createTextField(int width) {
653             JTextField f = new JTextField(width);
654             f.setEditable(false);
655             f.setBorder(null);
656             return f;
657         }
658 
659         /** Add a highlighted region based on the positions in an Info object. */
660         private void addHighlight(Highlighter h, Info info, Color c) {
661             int start = info.start;
662             int end = info.end;
663             if (start == -1 &amp;&amp; end == -1)
664                 return;
665             if (start == -1)
666                 start = end;
667             if (end == -1)
668                 end = start;
669             try {
670                 h.addHighlight(info.start, info.end,
671                         new DefaultHighlighter.DefaultHighlightPainter(c));
672                 if (info.pos != -1) {
673                     Color c2 = new Color(c.getRed(), c.getGreen(), c.getBlue(), (int)(.4f * 255)); // 40%
674                     h.addHighlight(info.pos, info.pos + 1,
675                         new DefaultHighlighter.DefaultHighlightPainter(c2));
676                 }
677             } catch (BadLocationException e) {
678                 e.printStackTrace();
679             }
680         }
681 
682         /** Get the minimum valid position in a set of info objects. */
683         private int getMinPos(Info... values) {
684             int i = Integer.MAX_VALUE;
685             for (Info info: values) {
686                 if (info.start &gt;= 0) i = Math.min(i, info.start);
687                 if (info.pos   &gt;= 0) i = Math.min(i, info.pos);
688                 if (info.end   &gt;= 0) i = Math.min(i, info.end);
689             }
690             return (i == Integer.MAX_VALUE) ? 0 : i;
691         }
692 
693         /** Set the background on a component. */
694         private JComponent setBackground(JComponent comp, Color c) {
695             comp.setOpaque(true);
696             comp.setBackground(c);
697             return comp;
698         }
699 
700         /** Scroll a text area to display a given position near the middle of the visible area. */
701         private void scroll(final JTextArea t, final int pos) {
702             // Using invokeLater appears to give text a chance to sort itself out
703             // before the scroll happens; otherwise scrollRectToVisible doesn&#39;t work.
704             // Maybe there&#39;s a better way to sync with the text...
705             EventQueue.invokeLater(new Runnable() {
706                 public void run() {
707                     try {
708                         Rectangle r = t.modelToView(pos);
709                         JScrollPane p = (JScrollPane) SwingUtilities.getAncestorOfClass(JScrollPane.class, t);
710                         r.y = Math.max(0, r.y - p.getHeight() * 2 / 5);
711                         r.height += p.getHeight() * 4 / 5;
712                         t.scrollRectToVisible(r);
713                     } catch (BadLocationException ignore) {
714                     }
715                 }
716             });
717         }
718 
719         private JComboBox entries;
720         private JTextField checkField;
721         private InfoPanel enclPanel;
722         private InfoPanel selfPanel;
723         private JTextArea body;
724         private JTextField statusText;
725 
726         private Color selfColor = new Color(0.f, 1.f, 0.f, 0.2f); // 20% green
727         private Color enclColor = new Color(1.f, 0.f, 0.f, 0.2f); // 20% red
728 
729         /** Panel to display an Info object. */
730         private class InfoPanel extends JPanel {
731             InfoPanel() {
732                 add(tagName = createTextField(20));
733                 add(new JLabel(&quot;start:&quot;));
734                 add(addListener(start = createTextField(6)));
735                 add(new JLabel(&quot;pos:&quot;));
736                 add(addListener(pos = createTextField(6)));
737                 add(new JLabel(&quot;end:&quot;));
738                 add(addListener(end = createTextField(6)));
739             }
740 
741             void setInfo(Info info) {
742                 this.info = info;
743                 tagName.setText(treeUtil.nameFromTag(info.tag));
744                 start.setText(String.valueOf(info.start));
745                 pos.setText(String.valueOf(info.pos));
746                 end.setText(String.valueOf(info.end));
747             }
748 
749             JTextField addListener(final JTextField f) {
750                 f.addMouseListener(new MouseAdapter() {
751                     @Override
752                     public void mouseClicked(MouseEvent e) {
753                         body.setCaretPosition(Integer.valueOf(f.getText()));
754                         body.getCaret().setVisible(true);
755                     }
756                 });
757                 return f;
758             }
759 
760             Info info;
761             JTextField tagName;
762             JTextField start;
763             JTextField pos;
764             JTextField end;
765         }
766 
767         /** Object to record information about an error to be displayed. */
768         private class Entry {
769             Entry(JavaFileObject file, String check, Info encl, Info self) {
770                 this.file = file;
771                 this.check = check;
772                 this.encl = encl;
773                 this.self= self;
774             }
775 
776             @Override
777             public String toString() {
778                 return file.getName() + &quot; &quot; + check + &quot; &quot; + getMinPos(encl, self);
779             }
780 
781             final JavaFileObject file;
782             final String check;
783             final Info encl;
784             final Info self;
785         }
786     }
787 
788     /** Number of files that have been analyzed. */
789     static AtomicInteger fileCount = new AtomicInteger();
790 
791 }
    </pre>
  </body>
</html>
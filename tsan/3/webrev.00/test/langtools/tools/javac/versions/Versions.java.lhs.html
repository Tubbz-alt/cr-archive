<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/versions/Versions.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4981566 5028634 5094412 6304984 7025786 7025789 8001112 8028545 8000961 8030610 8028546 8188870 8173382 8173382 8193290 8205619 8028563
 27  * @summary Check interpretation of -target and -source options
 28  * @modules java.compiler
 29  *          jdk.compiler
 30  * @run main Versions
 31  */
 32 
 33 import java.io.*;
 34 import java.nio.*;
 35 import java.nio.channels.*;
 36 
 37 import javax.tools.JavaCompiler;
 38 import javax.tools.ToolProvider;
 39 import javax.tools.JavaFileObject;
 40 import javax.tools.StandardJavaFileManager;
 41 import java.util.List;
 42 import java.util.ArrayList;
 43 import java.util.Arrays;
 44 import java.util.Set;
 45 import java.util.function.BiConsumer;
 46 
 47 /*
 48  * If not explicitly specified the latest source and latest target
 49  * values are the defaults. If explicitly specified, the target value
 50  * has to be greater than or equal to the source value.
 51  */
 52 public class Versions {
 53 
 54     protected JavaCompiler javacompiler;
 55     protected int failedCases;
 56 
 57     public Versions() throws IOException {
 58         javacompiler = ToolProvider.getSystemJavaCompiler();
 59         genSourceFiles();
 60         failedCases = 0;
 61     }
 62 
 63     public static void main(String... args) throws IOException {
 64         Versions versions = new Versions();
 65         versions.run();
 66     }
 67 
 68     public static final Set&lt;String&gt; RETIRED_SOURCES =
 69         Set.of(&quot;1.2&quot;, &quot;1.3&quot;, &quot;1.4&quot;, &quot;1.5&quot;, &quot;1.6&quot;);
 70 
 71     public static final Set&lt;String&gt; VALID_SOURCES =
<a name="2" id="anc2"></a><span class="line-modified"> 72         Set.of(&quot;1.7&quot;, &quot;1.8&quot;, &quot;1.9&quot;, &quot;1.10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;);</span>
 73 
<a name="3" id="anc3"></a><span class="line-modified"> 74     public static final String LATEST_MAJOR_VERSION = &quot;57.0&quot;;</span>
 75 
 76     static enum SourceTarget {
 77         SEVEN(true,   &quot;51.0&quot;,  &quot;7&quot;, Versions::checksrc17),
 78         EIGHT(true,   &quot;52.0&quot;,  &quot;8&quot;, Versions::checksrc18),
 79         NINE(true,    &quot;53.0&quot;,  &quot;9&quot;, Versions::checksrc19),
 80         TEN(true,     &quot;54.0&quot;, &quot;10&quot;, Versions::checksrc110),
 81         ELEVEN(false, &quot;55.0&quot;, &quot;11&quot;, Versions::checksrc111),
 82         TWELVE(false, &quot;56.0&quot;, &quot;12&quot;, Versions::checksrc112),
<a name="4" id="anc4"></a><span class="line-modified"> 83         THIRTEEN(false, &quot;57.0&quot;, &quot;13&quot;, Versions::checksrc113);</span>


 84 
 85         private final boolean dotOne;
 86         private final String classFileVer;
 87         private final String target;
 88         private final BiConsumer&lt;Versions, String[]&gt; checker;
 89 
 90         private SourceTarget(boolean dotOne, String classFileVer, String target,
 91                              BiConsumer&lt;Versions, String[]&gt; checker) {
 92             this.dotOne = dotOne;
 93             this.classFileVer = classFileVer;
 94             this.target = target;
 95             this.checker = checker;
 96         }
 97 
 98         public void checksrc(Versions version, String... args) {
 99             checker.accept(version, args);
100         }
101 
102         public boolean dotOne() {
103             return dotOne;
104         }
105 
106         public String classFileVer() {
107             return classFileVer;
108         }
109 
110         public String target() {
111             return target;
112         }
113     }
114 
115     void run() {
116         String TC = &quot;&quot;;
117         System.out.println(&quot;Version.java: Starting&quot;);
118 
119         check(LATEST_MAJOR_VERSION);
120         for (String source : VALID_SOURCES) {
121             check(LATEST_MAJOR_VERSION, &quot;-source &quot; + source);
122         }
123 
124         // Verify that a -source value less than a -target value is
125         // accepted and that the resulting class files are dependent
126         // on the target setting alone.
127         SourceTarget[] sourceTargets = SourceTarget.values();
128         for (int i = 0; i &lt; sourceTargets.length; i++) {
129             SourceTarget st = sourceTargets[i];
130             String classFileVer = st.classFileVer();
131             String target = st.target();
132             boolean dotOne = st.dotOne();
133             check_source_target(dotOne, classFileVer, target, target);
134             for (int j = i; j &gt; 0; j--) {
135                 String source = sourceTargets[j].target();
136                 check_source_target(dotOne, classFileVer, source, target);
137             }
138         }
139 
140         // Verify acceptance of different combinations of -source N,
141         // -target M; N &lt;= M
142         for (int i = 0; i &lt; sourceTargets.length; i++) {
143             SourceTarget st = sourceTargets[i];
144 
145             st.checksrc(this, &quot;-source &quot; + st.target());
146             st.checksrc(this, &quot;-source &quot; + st.target(), &quot;-target &quot; + st.target());
147 
148             if (st.dotOne()) {
149                 st.checksrc(this, &quot;-source 1.&quot; + st.target());
150                 st.checksrc(this, &quot;-source 1.&quot; + st.target(), &quot;-target 1.&quot; + st.target());
151             }
152 
153             if (i == sourceTargets.length) {
154                 // Can use -target without -source setting only for
155                 // most recent target since the most recent source is
156                 // the default.
157                 st.checksrc(this, &quot;-target &quot; + st.target());
158 
159                 if (!st.classFileVer().equals(LATEST_MAJOR_VERSION)) {
160                     throw new RuntimeException(st +
161                                                &quot;does not have class file version&quot; +
162                                                LATEST_MAJOR_VERSION);
163                 }
164             }
165         }
166 
167         // Verify that -source N -target (N-1) is rejected
168         for (int i = 1 /* Skip zeroth value */; i &lt; sourceTargets.length; i++) {
169             fail(&quot;-source &quot; + sourceTargets[i].target(),
170                  &quot;-target &quot; + sourceTargets[i-1].target(),
171                  &quot;Base.java&quot;);
172         }
173 
174         // Previously supported source/target values
175         for (String source  : RETIRED_SOURCES) {
176             fail(&quot;-source &quot; + source, &quot;-target &quot; + source, &quot;Base.java&quot;);
177         }
178 
179         if (failedCases &gt; 0) {
180             System.err.println(&quot;failedCases = &quot; + String.valueOf(failedCases));
181             throw new Error(&quot;Test failed&quot;);
182         }
183 
184     }
185 
186     protected void printargs(String fname,String... args) {
187         System.out.printf(&quot;test: %s&quot;, fname);
188         for (String onearg : args) {
189             System.out.printf(&quot; %s&quot;, onearg);
190         }
191         System.out.printf(&quot;\n&quot;, fname);
192     }
193 
194     protected void check_source_target(boolean dotOne, String... args) {
195         printargs(&quot;check_source_target&quot;, args);
196         check_target(dotOne, args[0], args[1], args[2]);
197         if (dotOne) {
198             check_target(dotOne, args[0], &quot;1.&quot; + args[1], args[2]);
199         }
200     }
201 
202     protected void check_target(boolean dotOne, String... args) {
203         check(args[0], &quot;-source &quot; + args[1], &quot;-target &quot; + args[2]);
204         if (dotOne) {
205             check(args[0], &quot;-source &quot; + args[1], &quot;-target 1.&quot; + args[2]);
206         }
207     }
208 
209     protected void check(String major, String... args) {
210         printargs(&quot;check&quot;, args);
211         List&lt;String&gt; jcargs = new ArrayList&lt;&gt;();
212         jcargs.add(&quot;-Xlint:-options&quot;);
213 
214         // add in args conforming to List requrements of JavaCompiler
215         for (String onearg : args) {
216             String[] fields = onearg.split(&quot; &quot;);
217             for (String onefield : fields) {
218                 jcargs.add(onefield);
219             }
220         }
221 
222         boolean creturn = compile(&quot;Base.java&quot;, jcargs);
223         if (!creturn) {
224             // compilation errors note and return.. assume no class file
225             System.err.println(&quot;check: Compilation Failed&quot;);
226             System.err.println(&quot;\t classVersion:\t&quot; + major);
227             System.err.println(&quot;\t arguments:\t&quot; + jcargs);
228             failedCases++;
229 
230         } else if (!checkClassFileVersion(&quot;Base.class&quot;, major)) {
231             failedCases++;
232         }
233     }
234 
235     protected void checksrc17(String... args) {
236         printargs(&quot;checksrc17&quot;, args);
237         int asize = args.length;
238         String[] newargs = new String[asize+1];
239         System.arraycopy(args, 0, newargs,0 , asize);
240         newargs[asize] = &quot;New17.java&quot;;
241         pass(newargs);
242         newargs[asize] = &quot;New18.java&quot;;
243         fail(newargs);
244     }
245 
246     protected void checksrc18(String... args) {
247         printargs(&quot;checksrc18&quot;, args);
248         int asize = args.length;
249         String[] newargs = new String[asize+1];
250         System.arraycopy(args, 0, newargs,0 , asize);
251         newargs[asize] = &quot;New17.java&quot;;
252         pass(newargs);
253         newargs[asize] = &quot;New18.java&quot;;
254         pass(newargs);
255         newargs[asize] = &quot;New110.java&quot;;
256         fail(newargs);
257     }
258 
259     protected void checksrc19(String... args) {
260         printargs(&quot;checksrc19&quot;, args);
261         checksrc18(args);
262     }
263 
264     protected void checksrc110(String... args) {
265         printargs(&quot;checksrc110&quot;, args);
266         int asize = args.length;
267         String[] newargs = new String[asize+1];
268         System.arraycopy(args, 0, newargs,0 , asize);
269         newargs[asize] = &quot;New17.java&quot;;
270         pass(newargs);
271         newargs[asize] = &quot;New18.java&quot;;
272         pass(newargs);
273         newargs[asize] = &quot;New110.java&quot;;
274         pass(newargs);
275     }
276 
277     protected void checksrc111(String... args) {
278         printargs(&quot;checksrc111&quot;, args);
279         int asize = args.length;
280         String[] newargs = new String[asize+1];
281         System.arraycopy(args, 0, newargs,0 , asize);
282         newargs[asize] = &quot;New17.java&quot;;
283         pass(newargs);
284         newargs[asize] = &quot;New18.java&quot;;
285         pass(newargs);
286         newargs[asize] = &quot;New110.java&quot;;
287         pass(newargs);
288         newargs[asize] = &quot;New111.java&quot;;
289         pass(newargs);
290     }
291 
292     protected void checksrc112(String... args) {
293         printargs(&quot;checksrc112&quot;, args);
294         checksrc111(args);
295     }
296 
297     protected void checksrc113(String... args) {
298         printargs(&quot;checksrc113&quot;, args);
299         checksrc111(args);
300     }
301 
<a name="5" id="anc5"></a>









302     protected void pass(String... args) {
303         printargs(&quot;pass&quot;, args);
304 
305         List&lt;String&gt; jcargs = new ArrayList&lt;String&gt;();
306         jcargs.add(&quot;-Xlint:-options&quot;);
307 
308         // add in args conforming to List requrements of JavaCompiler
309         for (String onearg : args) {
310             String[] fields = onearg.split(&quot; &quot;);
311             for (String onefield : fields) {
312                 jcargs.add(onefield);
313             }
314         }
315 
316         // empty list is error
317         if (jcargs.isEmpty()) {
318             System.err.println(&quot;error: test error in pass() - No arguments&quot;);
319             System.err.println(&quot;\t arguments:\t&quot; + jcargs);
320             failedCases++;
321             return;
322         }
323 
324         // the last argument is the filename *.java
325         String filename = jcargs.get(jcargs.size() - 1);
326         jcargs.remove(jcargs.size() - 1);
327 
328         boolean creturn = compile(filename, jcargs);
329         // expect a compilation failure, failure if otherwise
330         if (!creturn) {
331             System.err.println(&quot;pass: Compilation erroneously failed&quot;);
332             System.err.println(&quot;\t arguments:\t&quot; + jcargs);
333             System.err.println(&quot;\t file     :\t&quot; + filename);
334             failedCases++;
335 
336         }
337 
338     }
339 
340     protected void fail(String... args) {
341         printargs(&quot;fail&quot;, args);
342 
343         List&lt;String&gt; jcargs = new ArrayList&lt;String&gt;();
344         jcargs.add(&quot;-Xlint:-options&quot;);
345 
346         // add in args conforming to List requrements of JavaCompiler
347         for (String onearg : args) {
348             String[] fields = onearg.split(&quot; &quot;);
349             for (String onefield : fields) {
350                 jcargs.add(onefield);
351             }
352         }
353 
354         // empty list is error
355         if (jcargs.isEmpty()) {
356             System.err.println(&quot;error: test error in fail()- No arguments&quot;);
357             System.err.println(&quot;\t arguments:\t&quot; + jcargs);
358             failedCases++;
359             return;
360         }
361 
362         // the last argument is the filename *.java
363         String filename = jcargs.get(jcargs.size() - 1);
364         jcargs.remove(jcargs.size() - 1);
365 
366         boolean creturn = compile(filename, jcargs);
367         // expect a compilation failure, failure if otherwise
368         if (creturn) {
369             System.err.println(&quot;fail: Compilation erroneously succeeded&quot;);
370             System.err.println(&quot;\t arguments:\t&quot; + jcargs);
371             System.err.println(&quot;\t file     :\t&quot; + filename);
372             failedCases++;
373         }
374     }
375 
376     protected boolean compile(String sourceFile, List&lt;String&gt;options) {
377         JavaCompiler.CompilationTask jctask;
378         try (StandardJavaFileManager fm = javacompiler.getStandardFileManager(null, null, null)) {
379             Iterable&lt;? extends JavaFileObject&gt; files = fm.getJavaFileObjects(sourceFile);
380 
381             jctask = javacompiler.getTask(
382                 null,    // Writer
383                 fm,      // JavaFileManager
384                 null,    // DiagnosticListener
385                 options, // Iterable&lt;String&gt;
386                 null,    // Iterable&lt;String&gt; classes
387                 files);  // Iterable&lt;? extends JavaFileObject&gt;
388 
389             try {
390                 return jctask.call();
391             } catch (IllegalStateException e) {
392                 System.err.println(e);
393                 return false;
394             }
395         } catch (IOException e) {
396             throw new Error(e);
397         }
398     }
399 
400     protected void writeSourceFile(String fileName, String body) throws IOException{
401         try (Writer fw = new FileWriter(fileName)) {
402             fw.write(body);
403         }
404     }
405 
406     protected void genSourceFiles() throws IOException{
407         /* Create a file that executes with all supported versions. */
408         writeSourceFile(&quot;Base.java&quot;,&quot;public class Base { }\n&quot;);
409 
410         /*
411          * Create a file with a new feature in 1.7, not in 1.6 : &quot;&lt;&gt;&quot;
412          */
413         writeSourceFile(&quot;New17.java&quot;,
414             &quot;import java.util.List;\n&quot; +
415             &quot;import java.util.ArrayList;\n&quot; +
416             &quot;class New17 { List&lt;String&gt; s = new ArrayList&lt;&gt;(); }\n&quot;
417         );
418 
419         /*
420          * Create a file with a new feature in 1.8, not in 1.7 : lambda
421          */
422         writeSourceFile(&quot;New18.java&quot;,
423             &quot;public class New18 { \n&quot; +
424             &quot;    void m() { \n&quot; +
425             &quot;    new Thread(() -&gt; { }); \n&quot; +
426             &quot;    } \n&quot; +
427             &quot;} \n&quot;
428         );
429 
430         /*
431          * Create a file with a new feature in 1.10, not in 1.9 : var
432          */
433         writeSourceFile(&quot;New110.java&quot;,
434             &quot;public class New110 { \n&quot; +
435             &quot;    void m() { \n&quot; +
436             &quot;    var tmp = new Thread(() -&gt; { }); \n&quot; +
437             &quot;    } \n&quot; +
438             &quot;} \n&quot;
439         );
440 
441         /*
442          * Create a file with a new feature in 11, not in 10 : var for lambda parameters
443          */
444         writeSourceFile(&quot;New111.java&quot;,
445             &quot;public class New111 { \n&quot; +
446             &quot;    static java.util.function.Function&lt;String,String&gt; f = (var x) -&gt; x.substring(0);\n&quot; +
447             &quot;    void m(String name) { \n&quot; +
448             &quot;    var tmp = new Thread(() -&gt; { }, f.apply(name)); \n&quot; +
449             &quot;    } \n&quot; +
450             &quot;} \n&quot;
451         );
452     }
453 
454     protected boolean checkClassFileVersion
455         (String filename,String classVersionNumber) {
456         ByteBuffer bb = ByteBuffer.allocate(1024);
457         try (FileChannel fc = new FileInputStream(filename).getChannel()) {
458             bb.clear();
459             if (fc.read(bb) &lt; 0)
460                 throw new IOException(&quot;Could not read from file : &quot; + filename);
461             bb.flip();
462             int minor = bb.getShort(4);
463             int major = bb.getShort(6);
464             String fileVersion = major + &quot;.&quot; + minor;
465             if (fileVersion.equals(classVersionNumber)) {
466                 return true;
467             } else {
468                 System.err.println(&quot;checkClassFileVersion : Failed&quot;);
469                 System.err.println(&quot;\tclassfile version mismatch&quot;);
470                 System.err.println(&quot;\texpected : &quot; + classVersionNumber);
471                 System.err.println(&quot;\tfound    : &quot; + fileVersion);
472                 return false;
473             }
474         }
475         catch (IOException e) {
476             System.err.println(&quot;checkClassFileVersion : Failed&quot;);
477             System.err.println(&quot;\terror :\t&quot; + e.getMessage());
478             System.err.println(&quot;\tfile:\tfilename&quot;);
479         }
480         return false;
481     }
482 }
483 
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
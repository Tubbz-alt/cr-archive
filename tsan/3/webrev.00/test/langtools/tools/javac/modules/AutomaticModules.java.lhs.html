<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/modules/AutomaticModules.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
<a name="2" id="anc2"></a><span class="line-modified"> 26  * @bug 8155026 8178011</span>
 27  * @summary Test automatic modules
 28  * @library /tools/lib
 29  * @modules
 30  *      java.desktop
 31  *      jdk.compiler/com.sun.tools.javac.api
 32  *      jdk.compiler/com.sun.tools.javac.main
 33  * @build toolbox.ToolBox toolbox.JavacTask toolbox.JarTask ModuleTestBase
 34  * @run main AutomaticModules
 35  */
 36 
 37 import java.io.File;
 38 import java.nio.file.Files;
 39 import java.nio.file.Path;
 40 import java.util.Arrays;
 41 import java.util.List;
 42 import java.util.zip.ZipEntry;
 43 import java.util.zip.ZipOutputStream;
 44 
 45 import toolbox.JarTask;
 46 import toolbox.JavacTask;
 47 import toolbox.Task;
 48 import toolbox.Task.Mode;
 49 
 50 public class AutomaticModules extends ModuleTestBase {
 51 
 52     public static void main(String... args) throws Exception {
 53         AutomaticModules t = new AutomaticModules();
 54         t.runTests();
 55     }
 56 
 57     @Test
 58     public void testSimple(Path base) throws Exception {
 59         Path legacySrc = base.resolve(&quot;legacy-src&quot;);
 60         tb.writeJavaFiles(legacySrc,
 61                           &quot;package api; import java.awt.event.ActionListener; public abstract class Api implements ActionListener {}&quot;);
 62         Path legacyClasses = base.resolve(&quot;legacy-classes&quot;);
 63         Files.createDirectories(legacyClasses);
 64 
 65         String log = new JavacTask(tb)
 66                 .options()
 67                 .outdir(legacyClasses)
 68                 .files(findJavaFiles(legacySrc))
 69                 .run()
 70                 .writeAll()
 71                 .getOutput(Task.OutputKind.DIRECT);
 72 
 73         if (!log.isEmpty()) {
 74             throw new Exception(&quot;unexpected output: &quot; + log);
 75         }
 76 
 77         Path modulePath = base.resolve(&quot;module-path&quot;);
 78 
 79         Files.createDirectories(modulePath);
 80 
 81         Path jar = modulePath.resolve(&quot;test-api-1.0.jar&quot;);
 82 
 83         new JarTask(tb, jar)
 84           .baseDir(legacyClasses)
 85           .files(&quot;api/Api.class&quot;)
 86           .run();
 87 
 88         Path moduleSrc = base.resolve(&quot;module-src&quot;);
 89         Path m1 = moduleSrc.resolve(&quot;m1x&quot;);
 90 
 91         Path classes = base.resolve(&quot;classes&quot;);
 92 
 93         Files.createDirectories(classes);
 94 
 95         tb.writeJavaFiles(m1,
 96                           &quot;module m1x { requires test.api; requires java.desktop; }&quot;,
 97                           &quot;package impl; public class Impl { public void e(api.Api api) { api.actionPerformed(null); } }&quot;);
 98 
 99         new JavacTask(tb)
100                 .options(&quot;--module-source-path&quot;, moduleSrc.toString(), &quot;--module-path&quot;, modulePath.toString())
101                 .outdir(classes)
102                 .files(findJavaFiles(moduleSrc))
103                 .run()
104                 .writeAll();
105     }
106 
107     @Test
108     public void testUnnamedModule(Path base) throws Exception {
109         Path legacySrc = base.resolve(&quot;legacy-src&quot;);
110         tb.writeJavaFiles(legacySrc,
111                           &quot;package api; public abstract class Api { public void run(CharSequence str) { } private void run(base.Base base) { } }&quot;,
112                           &quot;package base; public interface Base { public void run(); }&quot;);
113         Path legacyClasses = base.resolve(&quot;legacy-classes&quot;);
114         Files.createDirectories(legacyClasses);
115 
116         String log = new JavacTask(tb)
117                 .options()
118                 .outdir(legacyClasses)
119                 .files(findJavaFiles(legacySrc))
120                 .run()
121                 .writeAll()
122                 .getOutput(Task.OutputKind.DIRECT);
123 
124         if (!log.isEmpty()) {
125             throw new Exception(&quot;unexpected output: &quot; + log);
126         }
127 
128         Path modulePath = base.resolve(&quot;module-path&quot;);
129 
130         Files.createDirectories(modulePath);
131 
132         Path apiJar = modulePath.resolve(&quot;test-api-1.0.jar&quot;);
133 
134         new JarTask(tb, apiJar)
135           .baseDir(legacyClasses)
136           .files(&quot;api/Api.class&quot;)
137           .run();
138 
139         Path baseJar = base.resolve(&quot;base.jar&quot;);
140 
141         new JarTask(tb, baseJar)
142           .baseDir(legacyClasses)
143           .files(&quot;base/Base.class&quot;)
144           .run();
145 
146         Path moduleSrc = base.resolve(&quot;module-src&quot;);
147         Path m1 = moduleSrc.resolve(&quot;m1x&quot;);
148 
149         Path classes = base.resolve(&quot;classes&quot;);
150 
151         Files.createDirectories(classes);
152 
153         tb.writeJavaFiles(m1,
154                           &quot;module m1x { requires test.api; }&quot;,
155                           &quot;package impl; public class Impl { public void e(api.Api api) { api.run(\&quot;\&quot;); } }&quot;);
156 
157         new JavacTask(tb)
158                 .options(&quot;--module-source-path&quot;, moduleSrc.toString(), &quot;--module-path&quot;, modulePath.toString(), &quot;--class-path&quot;, baseJar.toString())
159                 .outdir(classes)
160                 .files(findJavaFiles(moduleSrc))
161                 .run()
162                 .writeAll();
163     }
164 
165     @Test
166     public void testModuleInfoFromClassFileDependsOnAutomatic(Path base) throws Exception {
167         Path automaticSrc = base.resolve(&quot;automaticSrc&quot;);
168         tb.writeJavaFiles(automaticSrc, &quot;package api; public class Api {}&quot;);
169         Path automaticClasses = base.resolve(&quot;automaticClasses&quot;);
170         tb.createDirectories(automaticClasses);
171 
172         String automaticLog = new JavacTask(tb)
173                                 .outdir(automaticClasses)
174                                 .files(findJavaFiles(automaticSrc))
175                                 .run()
176                                 .writeAll()
177                                 .getOutput(Task.OutputKind.DIRECT);
178 
179         if (!automaticLog.isEmpty())
180             throw new Exception(&quot;expected output not found: &quot; + automaticLog);
181 
182         Path modulePath = base.resolve(&quot;module-path&quot;);
183 
184         Files.createDirectories(modulePath);
185 
186         Path automaticJar = modulePath.resolve(&quot;automatic-1.0.jar&quot;);
187 
188         new JarTask(tb, automaticJar)
189           .baseDir(automaticClasses)
190           .files(&quot;api/Api.class&quot;)
191           .run();
192 
193         Path depSrc = base.resolve(&quot;depSrc&quot;);
194         Path depClasses = base.resolve(&quot;depClasses&quot;);
195 
196         Files.createDirectories(depSrc);
197         Files.createDirectories(depClasses);
198 
199         tb.writeJavaFiles(depSrc,
200                           &quot;module m1x { requires transitive automatic; }&quot;,
201                           &quot;package dep; public class Dep { api.Api api; }&quot;);
202 
203         new JavacTask(tb)
204                 .options(&quot;--module-path&quot;, modulePath.toString())
205                 .outdir(depClasses)
206                 .files(findJavaFiles(depSrc))
207                 .run()
208                 .writeAll();
209 
210         Path moduleJar = modulePath.resolve(&quot;m1x.jar&quot;);
211 
212         new JarTask(tb, moduleJar)
213           .baseDir(depClasses)
214           .files(&quot;module-info.class&quot;, &quot;dep/Dep.class&quot;)
215           .run();
216 
217         Path testSrc = base.resolve(&quot;testSrc&quot;);
218         Path testClasses = base.resolve(&quot;testClasses&quot;);
219 
220         Files.createDirectories(testSrc);
221         Files.createDirectories(testClasses);
222 
223         tb.writeJavaFiles(testSrc,
224                           &quot;module m2x { requires automatic; }&quot;,
225                           &quot;package test; public class Test { }&quot;);
226 
227         new JavacTask(tb)
228                 .options(&quot;--module-path&quot;, modulePath.toString())
229                 .outdir(testClasses)
230                 .files(findJavaFiles(testSrc))
231                 .run()
232                 .writeAll();
233     }
234 
235     @Test
236     public void testAutomaticAndNamedModules(Path base) throws Exception {
237         Path modulePath = base.resolve(&quot;module-path&quot;);
238 
239         Files.createDirectories(modulePath);
240 
241         for (char c : new char[] {&#39;A&#39;, &#39;B&#39;}) {
242             Path automaticSrc = base.resolve(&quot;automaticSrc&quot; + c);
243             tb.writeJavaFiles(automaticSrc, &quot;package api&quot; + c + &quot;; public class Api {}&quot;);
244             Path automaticClasses = base.resolve(&quot;automaticClasses&quot; + c);
245             tb.createDirectories(automaticClasses);
246 
247             String automaticLog = new JavacTask(tb)
248                                     .outdir(automaticClasses)
249                                     .files(findJavaFiles(automaticSrc))
250                                     .run()
251                                     .writeAll()
252                                     .getOutput(Task.OutputKind.DIRECT);
253 
254             if (!automaticLog.isEmpty())
255                 throw new Exception(&quot;expected output not found: &quot; + automaticLog);
256 
257             Path automaticJar = modulePath.resolve(&quot;automatic&quot; + c + &quot;-1.0.jar&quot;);
258 
259             new JarTask(tb, automaticJar)
260               .baseDir(automaticClasses)
261               .files(&quot;api&quot; + c + &quot;/Api.class&quot;)
262               .run();
263         }
264 
265         Path moduleSrc = base.resolve(&quot;module-src&quot;);
266 
267         tb.writeJavaFiles(moduleSrc.resolve(&quot;m1x&quot;),
268                           &quot;module m1x { requires static automaticA; }&quot;,
269                           &quot;package impl; public class Impl { apiA.Api a; apiB.Api b; m2x.M2 m;}&quot;);
270 
271         tb.writeJavaFiles(moduleSrc.resolve(&quot;m2x&quot;),
272                           &quot;module m2x { exports m2x; }&quot;,
273                           &quot;package m2x; public class M2 { }&quot;);
274 
275         Path classes = base.resolve(&quot;classes&quot;);
276 
277         Files.createDirectories(classes);
278 
279         List&lt;String&gt; log = new JavacTask(tb)
280                 .options(&quot;--module-source-path&quot;, moduleSrc.toString(),
281                          &quot;--module-path&quot;, modulePath.toString(),
282                          &quot;--add-modules&quot;, &quot;automaticB&quot;,
283                          &quot;-XDrawDiagnostics&quot;)
284                 .outdir(classes)
285                 .files(findJavaFiles(moduleSrc))
286                 .run(Task.Expect.FAIL)
287                 .writeAll()
288                 .getOutputLines(Task.OutputKind.DIRECT);
289 
290         List&lt;String&gt; expected = Arrays.asList(&quot;Impl.java:1:59: compiler.err.package.not.visible: m2x, (compiler.misc.not.def.access.does.not.read: m1x, m2x, m2x)&quot;,
291                                               &quot;1 error&quot;);
292 
293         if (!expected.equals(log)) {
294             throw new Exception(&quot;expected output not found: &quot; + log);
295         }
296 
297         log = new JavacTask(tb)
298                 .options(&quot;--module-source-path&quot;, moduleSrc.toString(),
299                          &quot;--module-path&quot;, modulePath.toString(),
300                          &quot;-XDrawDiagnostics&quot;)
301                 .outdir(classes)
302                 .files(findJavaFiles(moduleSrc))
303                 .run(Task.Expect.FAIL)
304                 .writeAll()
305                 .getOutputLines(Task.OutputKind.DIRECT);
306 
307         expected = Arrays.asList(&quot;Impl.java:1:59: compiler.err.package.not.visible: m2x, (compiler.misc.not.def.access.does.not.read: m1x, m2x, m2x)&quot;,
308                                  &quot;1 error&quot;);
309 
310         if (!expected.equals(log)) {
311             throw new Exception(&quot;expected output not found: &quot; + log);
312         }
313     }
314 
315     @Test
316     public void testWithTrailingVersion(Path base) throws Exception {
317         Path legacySrc = base.resolve(&quot;legacy-src&quot;);
318         tb.writeJavaFiles(legacySrc,
319                           &quot;package api; public class Api {}&quot;);
320         Path legacyClasses = base.resolve(&quot;legacy-classes&quot;);
321         Files.createDirectories(legacyClasses);
322 
323         String log = new JavacTask(tb)
324                 .options()
325                 .outdir(legacyClasses)
326                 .files(findJavaFiles(legacySrc))
327                 .run()
328                 .writeAll()
329                 .getOutput(Task.OutputKind.DIRECT);
330 
331         if (!log.isEmpty()) {
332             throw new Exception(&quot;unexpected output: &quot; + log);
333         }
334 
335         Path modulePath = base.resolve(&quot;module-path&quot;);
336 
337         Files.createDirectories(modulePath);
338 
339         Path jar = modulePath.resolve(&quot;test1.jar&quot;);
340 
341         new JarTask(tb, jar)
342           .baseDir(legacyClasses)
343           .files(&quot;api/Api.class&quot;)
344           .run();
345 
346         Path moduleSrc = base.resolve(&quot;module-src&quot;);
347         Path m = moduleSrc.resolve(&quot;m&quot;);
348 
349         Path classes = base.resolve(&quot;classes&quot;);
350 
351         Files.createDirectories(classes);
352 
353         tb.writeJavaFiles(m,
354                           &quot;module m { requires test1; }&quot;,
355                           &quot;package impl; public class Impl { public void e(api.Api api) { } }&quot;);
356 
357         new JavacTask(tb)
358                 .options(&quot;--module-source-path&quot;, moduleSrc.toString(), &quot;--module-path&quot;, modulePath.toString())
359                 .outdir(classes)
360                 .files(findJavaFiles(moduleSrc))
361                 .run()
362                 .writeAll();
363     }
364 
365     @Test
366     public void testMultipleAutomatic(Path base) throws Exception {
367         Path modulePath = base.resolve(&quot;module-path&quot;);
368 
369         Files.createDirectories(modulePath);
370 
371         for (char c : new char[] {&#39;A&#39;, &#39;B&#39;}) {
372             Path automaticSrc = base.resolve(&quot;automaticSrc&quot; + c);
373             tb.writeJavaFiles(automaticSrc, &quot;package api&quot; + c + &quot;; public class Api {}&quot;);
374             Path automaticClasses = base.resolve(&quot;automaticClasses&quot; + c);
375             tb.createDirectories(automaticClasses);
376 
377             String automaticLog = new JavacTask(tb)
378                                     .outdir(automaticClasses)
379                                     .files(findJavaFiles(automaticSrc))
380                                     .run()
381                                     .writeAll()
382                                     .getOutput(Task.OutputKind.DIRECT);
383 
384             if (!automaticLog.isEmpty())
385                 throw new Exception(&quot;expected output not found: &quot; + automaticLog);
386 
387             Path automaticJar = modulePath.resolve(&quot;automatic&quot; + c + &quot;-1.0.jar&quot;);
388 
389             new JarTask(tb, automaticJar)
390               .baseDir(automaticClasses)
391               .files(&quot;api&quot; + c + &quot;/Api.class&quot;)
392               .run();
393         }
394 
395         Path src = base.resolve(&quot;src&quot;);
396 
397         tb.writeJavaFiles(src.resolve(&quot;m1x&quot;),
398                           &quot;package impl; public class Impl { apiA.Api a; apiB.Api b; }&quot;);
399 
400         Path classes = base.resolve(&quot;classes&quot;);
401 
402         Files.createDirectories(classes);
403 
404         List&lt;String&gt; log = new JavacTask(tb)
405                 .options(&quot;--module-path&quot;, modulePath.toString(),
406                          &quot;-XDrawDiagnostics&quot;)
407                 .outdir(classes)
408                 .files(findJavaFiles(src))
409                 .run(Task.Expect.FAIL)
410                 .writeAll()
411                 .getOutputLines(Task.OutputKind.DIRECT);
412 
413         List&lt;String&gt; expected = Arrays.asList(&quot;Impl.java:1:35: compiler.err.package.not.visible: apiA, (compiler.misc.not.def.access.does.not.read.from.unnamed: apiA, automaticA)&quot;,
414                                               &quot;Impl.java:1:47: compiler.err.package.not.visible: apiB, (compiler.misc.not.def.access.does.not.read.from.unnamed: apiB, automaticB)&quot;,
415                                               &quot;2 errors&quot;);
416 
417         if (!expected.equals(log)) {
418             throw new Exception(&quot;expected output not found: &quot; + log);
419         }
420 
421         new JavacTask(tb)
422                 .options(&quot;--module-path&quot;, modulePath.toString(),
423                          &quot;--add-modules&quot;, &quot;automaticA&quot;,
424                          &quot;-XDrawDiagnostics&quot;)
425                 .outdir(classes)
426                 .files(findJavaFiles(src))
427                 .run()
428                 .writeAll();
429     }
430 
431     @Test
432     public void testLintRequireAutomatic(Path base) throws Exception {
433         Path modulePath = base.resolve(&quot;module-path&quot;);
434 
435         Files.createDirectories(modulePath);
436 
437         for (char c : new char[] {&#39;A&#39;, &#39;B&#39;}) {
438             Path automaticSrc = base.resolve(&quot;automaticSrc&quot; + c);
439             tb.writeJavaFiles(automaticSrc, &quot;package api&quot; + c + &quot;; public class Api {}&quot;);
440             Path automaticClasses = base.resolve(&quot;automaticClasses&quot; + c);
441             tb.createDirectories(automaticClasses);
442 
443             String automaticLog = new JavacTask(tb)
444                                     .outdir(automaticClasses)
445                                     .files(findJavaFiles(automaticSrc))
446                                     .run()
447                                     .writeAll()
448                                     .getOutput(Task.OutputKind.DIRECT);
449 
450             if (!automaticLog.isEmpty())
451                 throw new Exception(&quot;expected output not found: &quot; + automaticLog);
452 
453             Path automaticJar = modulePath.resolve(&quot;automatic&quot; + c + &quot;-1.0.jar&quot;);
454 
455             new JarTask(tb, automaticJar)
456               .baseDir(automaticClasses)
457               .files(&quot;api&quot; + c + &quot;/Api.class&quot;)
458               .run();
459         }
460 
461         Path src = base.resolve(&quot;src&quot;);
462 
463         tb.writeJavaFiles(src,
464                           &quot;module m1x {\n&quot; +
465                           &quot;    requires transitive automaticA;\n&quot; +
466                           &quot;    requires automaticB;\n&quot; +
467                           &quot;}&quot;);
468 
469         Path classes = base.resolve(&quot;classes&quot;);
470 
471         Files.createDirectories(classes);
472 
473         List&lt;String&gt; expected;
474         List&lt;String&gt; log;
475 
476         log = new JavacTask(tb)
477             .options(&quot;--source-path&quot;, src.toString(),
478                      &quot;--module-path&quot;, modulePath.toString(),
479                      &quot;-XDrawDiagnostics&quot;,
480                      &quot;-Werror&quot;)
481             .outdir(classes)
482             .files(findJavaFiles(src))
483             .run(Task.Expect.FAIL)
484             .writeAll()
485             .getOutputLines(Task.OutputKind.DIRECT);
486 
487         expected = Arrays.asList(&quot;module-info.java:2:25: compiler.warn.requires.transitive.automatic&quot;,
488                                  &quot;- compiler.err.warnings.and.werror&quot;,
489                                  &quot;1 error&quot;,
490                                  &quot;1 warning&quot;);
491 
492         if (!expected.equals(log)) {
493             throw new Exception(&quot;expected output not found: &quot; + log);
494         }
495 
496         log = new JavacTask(tb)
497             .options(&quot;--source-path&quot;, src.toString(),
498                      &quot;--module-path&quot;, modulePath.toString(),
499                      &quot;-Xlint:requires-automatic&quot;,
500                      &quot;-XDrawDiagnostics&quot;,
501                      &quot;-Werror&quot;)
502             .outdir(classes)
503             .files(findJavaFiles(src))
504             .run(Task.Expect.FAIL)
505             .writeAll()
506             .getOutputLines(Task.OutputKind.DIRECT);
507 
508         expected = Arrays.asList(&quot;module-info.java:2:25: compiler.warn.requires.transitive.automatic&quot;,
509                                  &quot;module-info.java:3:14: compiler.warn.requires.automatic&quot;,
510                                  &quot;- compiler.err.warnings.and.werror&quot;,
511                                  &quot;1 error&quot;,
512                                  &quot;2 warnings&quot;);
513 
514         if (!expected.equals(log)) {
515             throw new Exception(&quot;expected output not found: &quot; + log);
516         }
517 
518         log = new JavacTask(tb)
519             .options(&quot;--source-path&quot;, src.toString(),
520                      &quot;--module-path&quot;, modulePath.toString(),
521                      &quot;-Xlint:-requires-transitive-automatic,requires-automatic&quot;,
522                      &quot;-XDrawDiagnostics&quot;,
523                      &quot;-Werror&quot;)
524             .outdir(classes)
525             .files(findJavaFiles(src))
526             .run(Task.Expect.FAIL)
527             .writeAll()
528             .getOutputLines(Task.OutputKind.DIRECT);
529 
530         expected = Arrays.asList(&quot;module-info.java:2:25: compiler.warn.requires.automatic&quot;,
531                                  &quot;module-info.java:3:14: compiler.warn.requires.automatic&quot;,
532                                  &quot;- compiler.err.warnings.and.werror&quot;,
533                                  &quot;1 error&quot;,
534                                  &quot;2 warnings&quot;);
535 
536         if (!expected.equals(log)) {
537             throw new Exception(&quot;expected output not found: &quot; + log);
538         }
539 
540         new JavacTask(tb)
541             .options(&quot;--source-path&quot;, src.toString(),
542                      &quot;--module-path&quot;, modulePath.toString(),
543                      &quot;-Xlint:-requires-transitive-automatic&quot;,
544                      &quot;-XDrawDiagnostics&quot;,
545                      &quot;-Werror&quot;)
546             .outdir(classes)
547             .files(findJavaFiles(src))
548             .run(Task.Expect.SUCCESS)
549             .writeAll()
550             .getOutputLines(Task.OutputKind.DIRECT);
551 
552         tb.writeJavaFiles(src,
553                           &quot;@SuppressWarnings(\&quot;requires-transitive-automatic\&quot;)\n&quot; +
554                           &quot;module m1x {\n&quot; +
555                           &quot;    requires transitive automaticA;\n&quot; +
556                           &quot;    requires automaticB;\n&quot; +
557                           &quot;}&quot;);
558 
559         new JavacTask(tb)
560             .options(&quot;--source-path&quot;, src.toString(),
561                      &quot;--module-path&quot;, modulePath.toString(),
562                      &quot;-XDrawDiagnostics&quot;,
563                      &quot;-Werror&quot;)
564             .outdir(classes)
565             .files(findJavaFiles(src))
566             .run(Task.Expect.SUCCESS)
567             .writeAll()
568             .getOutputLines(Task.OutputKind.DIRECT);
569 
570         log = new JavacTask(tb)
571             .options(&quot;--source-path&quot;, src.toString(),
572                      &quot;--module-path&quot;, modulePath.toString(),
573                      &quot;-Xlint:requires-automatic&quot;,
574                      &quot;-XDrawDiagnostics&quot;,
575                      &quot;-Werror&quot;)
576             .outdir(classes)
577             .files(findJavaFiles(src))
578             .run(Task.Expect.FAIL)
579             .writeAll()
580             .getOutputLines(Task.OutputKind.DIRECT);
581 
582         expected = Arrays.asList(&quot;module-info.java:3:25: compiler.warn.requires.automatic&quot;,
583                                  &quot;module-info.java:4:14: compiler.warn.requires.automatic&quot;,
584                                  &quot;- compiler.err.warnings.and.werror&quot;,
585                                  &quot;1 error&quot;,
586                                  &quot;2 warnings&quot;);
587 
588         if (!expected.equals(log)) {
589             throw new Exception(&quot;expected output not found: &quot; + log);
590         }
591 
592         tb.writeJavaFiles(src,
593                           &quot;@SuppressWarnings(\&quot;requires-automatic\&quot;)\n&quot; +
594                           &quot;module m1x {\n&quot; +
595                           &quot;    requires transitive automaticA;\n&quot; +
596                           &quot;    requires automaticB;\n&quot; +
597                           &quot;}&quot;);
598 
599         log = new JavacTask(tb)
600             .options(&quot;--source-path&quot;, src.toString(),
601                      &quot;--module-path&quot;, modulePath.toString(),
602                      &quot;-Xlint:requires-automatic&quot;,
603                      &quot;-XDrawDiagnostics&quot;,
604                      &quot;-Werror&quot;)
605             .outdir(classes)
606             .files(findJavaFiles(src))
607             .run(Task.Expect.FAIL)
608             .writeAll()
609             .getOutputLines(Task.OutputKind.DIRECT);
610 
611         expected = Arrays.asList(&quot;module-info.java:3:25: compiler.warn.requires.transitive.automatic&quot;,
612                                  &quot;- compiler.err.warnings.and.werror&quot;,
613                                  &quot;1 error&quot;,
614                                  &quot;1 warning&quot;);
615 
616         if (!expected.equals(log)) {
617             throw new Exception(&quot;expected output not found: &quot; + log);
618         }
619     }
620 
621     @Test
622     public void testAutomaticModuleNameCorrect(Path base) throws Exception {
623         Path modulePath = base.resolve(&quot;module-path&quot;);
624 
625         Files.createDirectories(modulePath);
626 
627         Path automaticSrc = base.resolve(&quot;automaticSrc&quot;);
628         tb.writeJavaFiles(automaticSrc, &quot;package api; public class Api {}&quot;);
629         Path automaticClasses = base.resolve(&quot;automaticClasses&quot;);
630         tb.createDirectories(automaticClasses);
631 
632         String automaticLog = new JavacTask(tb)
633                                 .outdir(automaticClasses)
634                                 .files(findJavaFiles(automaticSrc))
635                                 .run()
636                                 .writeAll()
637                                 .getOutput(Task.OutputKind.DIRECT);
638 
639         if (!automaticLog.isEmpty())
640             throw new Exception(&quot;expected output not found: &quot; + automaticLog);
641 
642         Path automaticJar = modulePath.resolve(&quot;automatic-1.0.jar&quot;);
643 
644         new JarTask(tb, automaticJar)
645           .baseDir(automaticClasses)
646           .files(&quot;api/Api.class&quot;)
647           .manifest(&quot;Automatic-Module-Name: custom.module.name\n\n&quot;)
648           .run();
649 
650         Path src = base.resolve(&quot;src&quot;);
651 
652         tb.writeJavaFiles(src,
653                           &quot;module m { requires custom.module.name; }&quot;,
654                           &quot;package impl; public class Impl { api.Api a; }&quot;);
655 
656         Path classes = base.resolve(&quot;classes&quot;);
657 
658         Files.createDirectories(classes);
659 
660         new JavacTask(tb)
661                 .options(&quot;--module-path&quot;, modulePath.toString(),
662                          &quot;-XDrawDiagnostics&quot;)
663                 .outdir(classes)
664                 .files(findJavaFiles(src))
665                 .run(Task.Expect.SUCCESS)
666                 .writeAll()
667                 .getOutputLines(Task.OutputKind.DIRECT);
668 
669         tb.writeJavaFiles(src,
670                           &quot;module m { requires automatic; }&quot;);
671 
672         List&lt;String&gt; log = new JavacTask(tb)
673                 .options(&quot;--module-path&quot;, modulePath.toString(),
674                          &quot;-XDrawDiagnostics&quot;)
675                 .outdir(classes)
676                 .files(findJavaFiles(src))
677                 .run(Task.Expect.FAIL)
678                 .writeAll()
679                 .getOutputLines(Task.OutputKind.DIRECT);
680 
681         List&lt;String&gt; expected =
682                 Arrays.asList(&quot;module-info.java:1:21: compiler.err.module.not.found: automatic&quot;,
683                               &quot;1 error&quot;);
684 
685         if (!expected.equals(log)) {
686             throw new Exception(&quot;expected output not found: &quot; + log);
687         }
688     }
689 
690     @Test
691     public void testAutomaticModuleNameIncorrect(Path base) throws Exception {
692         for (String name : new String[] {&quot;&quot;, &quot;999&quot;, &quot;foo.class&quot;, &quot;foo._&quot;}) {
693             if (Files.isDirectory(base)) {
694                 tb.cleanDirectory(base);
695             }
696             Path modulePath = base.resolve(&quot;module-path&quot;);
697 
698             Files.createDirectories(modulePath);
699 
700             Path automaticSrc = base.resolve(&quot;automaticSrc&quot;);
701             tb.writeJavaFiles(automaticSrc, &quot;package api; public class Api {}&quot;);
702             Path automaticClasses = base.resolve(&quot;automaticClasses&quot;);
703             tb.createDirectories(automaticClasses);
704 
705             String automaticLog = new JavacTask(tb)
706                                     .outdir(automaticClasses)
707                                     .files(findJavaFiles(automaticSrc))
708                                     .run()
709                                     .writeAll()
710                                     .getOutput(Task.OutputKind.DIRECT);
711 
712             if (!automaticLog.isEmpty())
713                 throw new Exception(&quot;expected output not found: &quot; + automaticLog);
714 
715             Path automaticJar = modulePath.resolve(&quot;automatic-1.0.jar&quot;);
716 
717             new JarTask(tb, automaticJar)
718               .baseDir(automaticClasses)
719               .files(&quot;api/Api.class&quot;)
720               .manifest(&quot;Automatic-Module-Name: &quot; + name + &quot;\n\n&quot;)
721               .run();
722 
723             Path src = base.resolve(&quot;src&quot;);
724 
725             tb.writeJavaFiles(src,
726                               &quot;package impl; public class Impl { api.Api a; }&quot;);
727 
728             Path classes = base.resolve(&quot;classes&quot;);
729 
730             Files.createDirectories(classes);
731 
732             List&lt;String&gt; log = new JavacTask(tb, Mode.CMDLINE)
733                     .options(&quot;--module-path&quot;, modulePath.toString(),
734                              &quot;--add-modules&quot;, &quot;ALL-MODULE-PATH&quot;,
735                              &quot;-XDrawDiagnostics&quot;)
736                     .outdir(classes)
737                     .files(findJavaFiles(src))
738                     .run(Task.Expect.FAIL)
739                     .writeAll()
740                     .getOutputLines(Task.OutputKind.DIRECT);
741 
742             List&lt;String&gt; expected =
743                     Arrays.asList(&quot;- compiler.err.locn.cant.get.module.name.for.jar: &quot; +
744                                       &quot;testAutomaticModuleNameIncorrect/module-path/automatic-1.0.jar&quot;.replace(&quot;/&quot;, File.separator),
745                                   &quot;1 error&quot;);
746 
747             if (!expected.equals(log)) {
748                 throw new Exception(&quot;expected output not found: &quot; + log);
749             }
750         }
751     }
752 
753     @Test
754     public void testAutomaticModuleNameBroken(Path base) throws Exception {
755         Path modulePath = base.resolve(&quot;module-path&quot;);
756 
757         Files.createDirectories(modulePath);
758 
759         Path automaticSrc = base.resolve(&quot;automaticSrc&quot;);
760         tb.writeJavaFiles(automaticSrc, &quot;package api; public class Api {}&quot;);
761         Path automaticClasses = base.resolve(&quot;automaticClasses&quot;);
762         tb.createDirectories(automaticClasses);
763 
764         String automaticLog = new JavacTask(tb)
765                                 .outdir(automaticClasses)
766                                 .files(findJavaFiles(automaticSrc))
767                                 .run()
768                                 .writeAll()
769                                 .getOutput(Task.OutputKind.DIRECT);
770 
771         if (!automaticLog.isEmpty())
772             throw new Exception(&quot;expected output not found: &quot; + automaticLog);
773 
774         Path automaticJar = modulePath.resolve(&quot;automatic-1.0.jar&quot;);
775 
776         try (ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(automaticJar))) {
777             out.putNextEntry(new ZipEntry(&quot;api/Api.class&quot;));
778             Files.copy(automaticClasses.resolve(&quot;api&quot;).resolve(&quot;Api.class&quot;), out);
779         }
780 
781         Path src = base.resolve(&quot;src&quot;);
782 
783         tb.writeJavaFiles(src,
784                           &quot;module m { requires automatic; }&quot;,
785                           &quot;package impl; public class Impl { api.Api a; }&quot;);
786 
787         Path classes = base.resolve(&quot;classes&quot;);
788 
789         Files.createDirectories(classes);
790 
791         new JavacTask(tb)
792                 .options(&quot;--module-path&quot;, modulePath.toString(),
793                          &quot;-XDrawDiagnostics&quot;)
794                 .outdir(classes)
795                 .files(findJavaFiles(src))
796                 .run(Task.Expect.SUCCESS)
797                 .writeAll()
798                 .getOutputLines(Task.OutputKind.DIRECT);
799 
800         tb.writeJavaFiles(src,
801                           &quot;module m { requires custom.module.name; }&quot;);
802 
803         List&lt;String&gt; log = new JavacTask(tb)
804                 .options(&quot;--module-path&quot;, modulePath.toString(),
805                          &quot;-XDrawDiagnostics&quot;)
806                 .outdir(classes)
807                 .files(findJavaFiles(src))
808                 .run(Task.Expect.FAIL)
809                 .writeAll()
810                 .getOutputLines(Task.OutputKind.DIRECT);
811 
812         List&lt;String&gt; expected =
813                 Arrays.asList(&quot;module-info.java:1:34: compiler.err.module.not.found: custom.module.name&quot;,
814                               &quot;1 error&quot;);
815 
816         if (!expected.equals(log)) {
817             throw new Exception(&quot;expected output not found: &quot; + log);
818         }
819     }
820 
<a name="3" id="anc3"></a>



















































































821 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/modules/ContainsTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 8178518
 27  * @summary Add method JavaFileManager.contains
 28  * @library /tools/lib
 29  * @modules
 30  *      jdk.compiler/com.sun.tools.javac.api
 31  *      jdk.compiler/com.sun.tools.javac.main
 32  * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask ModuleTestBase
 33  * @run main ContainsTest
 34  */
 35 
 36 import java.io.IOException;
 37 import java.nio.file.FileSystem;
 38 import java.nio.file.FileSystems;
 39 import java.nio.file.Files;
 40 import java.nio.file.Path;
 41 import java.nio.file.Paths;
 42 import java.util.EnumSet;
 43 import java.util.List;
 44 
 45 import javax.tools.FileObject;
 46 import javax.tools.JavaCompiler;
 47 import javax.tools.JavaFileManager.Location;
 48 import javax.tools.JavaFileObject;
 49 import javax.tools.StandardJavaFileManager;
 50 import javax.tools.StandardLocation;
 51 import javax.tools.ToolProvider;
 52 
 53 import toolbox.JarTask;
 54 import toolbox.JavacTask;
 55 
 56 public class ContainsTest extends ModuleTestBase {
 57     public static void main(String... args) throws Exception {
 58         ContainsTest t = new ContainsTest();
 59         t.runTests();
 60     }
 61 
 62     JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();
 63 
 64     @Test
 65     public void testSimplePath(Path base) throws IOException {
 66         // Test that we can look up in directories in the default file system.
 67         Path src = base.resolve(&quot;src&quot;);
 68         tb.writeJavaFiles(src, &quot;package p; class C { }&quot;);
 69         Path c = src.resolve(&quot;p/C.java&quot;);
 70         Path x = base.resolve(&quot;src2/p/C.java&quot;);
 71         try (StandardJavaFileManager fm = javaCompiler.getStandardFileManager(null, null, null)) {
 72             fm.setLocationFromPaths(StandardLocation.SOURCE_PATH, List.of(src));
 73             checkContains(fm, StandardLocation.SOURCE_PATH, c, true);
 74             checkContains(fm, StandardLocation.SOURCE_PATH, x, false);
 75         }
 76     }
 77 
 78     @Test
 79     public void testJarPath(Path base) throws IOException {
 80         // Test that we can look up in jar files on a search path.
 81         // In this case, the path we look up must come from open file system
 82         // as used by the file manager.
 83         Path src = base.resolve(&quot;src&quot;);
 84         tb.writeJavaFiles(src, &quot;package p; class C { }&quot;);
 85         Path classes = Files.createDirectories(base.resolve(&quot;classes&quot;));
 86         new JavacTask(tb)
 87             .options(&quot;-sourcepath&quot;, src.toString())
 88             .outdir(classes)
 89             .files(findJavaFiles(src))
 90             .run()
 91             .writeAll();
 92 
 93         Path jar = base.resolve(&quot;classes.jar&quot;);
 94         new JarTask(tb).run(&quot;cf&quot;, jar.toString(), &quot;-C&quot;, classes.toString(), &quot;p&quot;);
 95 
 96         Path c = src.resolve(&quot;p/C.java&quot;);
 97         Path x = base.resolve(&quot;src2/p/C.java&quot;);
 98 
 99         try (StandardJavaFileManager fm = javaCompiler.getStandardFileManager(null, null, null)) {
100             fm.setLocationFromPaths(StandardLocation.CLASS_PATH, List.of(src, jar));
101 
102             checkContains(fm, StandardLocation.CLASS_PATH, c, true);
103             checkContains(fm, StandardLocation.CLASS_PATH, x, false);
104 
105             JavaFileObject fo = fm.list(StandardLocation.CLASS_PATH, &quot;p&quot;,
106                     EnumSet.of(JavaFileObject.Kind.CLASS), false).iterator().next();
107 
108             checkContains(fm, StandardLocation.CLASS_PATH, fo, true);
109         }
110     }
111 
112     @Test
113     public void testJarFSPath(Path base) throws IOException {
114         // Test that we can look up in non-default file systems on the search path,
115         // such as an open jar file system.
116         Path src = base.resolve(&quot;src&quot;);
117         tb.writeJavaFiles(src, &quot;package p; class C { }&quot;);
118         Path classes = Files.createDirectories(base.resolve(&quot;classes&quot;));
119         new JavacTask(tb)
120             .options(&quot;-sourcepath&quot;, src.toString())
121             .outdir(classes)
122             .files(findJavaFiles(src))
123             .run()
124             .writeAll();
125 
126         Path jar = base.resolve(&quot;classes.jar&quot;);
127         new JarTask(tb).run(&quot;cf&quot;, jar.toString(), &quot;-C&quot;, classes.toString(), &quot;p&quot;);
128 
129         Path c = src.resolve(&quot;p/C.java&quot;);
130         Path x = base.resolve(&quot;src2/p/C.java&quot;);
131 
132         try (FileSystem jarFS = FileSystems.newFileSystem(jar, null);
133                 StandardJavaFileManager fm = javaCompiler.getStandardFileManager(null, null, null)) {
134             Path jarRoot = jarFS.getRootDirectories().iterator().next();
135             fm.setLocationFromPaths(StandardLocation.CLASS_PATH, List.of(src, jarRoot));
136 
137             checkContains(fm, StandardLocation.CLASS_PATH, c, true);
138             checkContains(fm, StandardLocation.CLASS_PATH, x, false);
139 
140             JavaFileObject fo = fm.list(StandardLocation.CLASS_PATH, &quot;p&quot;,
141                     EnumSet.of(JavaFileObject.Kind.CLASS), false).iterator().next();
142 
143             checkContains(fm, StandardLocation.CLASS_PATH, fo, true);
144             checkContains(fm, StandardLocation.CLASS_PATH, jarRoot.resolve(&quot;p/C.class&quot;), true);
145         }
146     }
147 
148     void checkContains(StandardJavaFileManager fm, Location l, Path p, boolean expect) throws IOException {
149         JavaFileObject fo = fm.getJavaFileObjects(p).iterator().next();
150         checkContains(fm, l, fo, expect);
151     }
152 
153     void checkContains(StandardJavaFileManager fm, Location l, FileObject fo, boolean expect) throws IOException {
154         boolean found = fm.contains(l, fo);
155         if (found) {
156             if (expect) {
157                 out.println(&quot;file found, as expected: &quot; + l + &quot; &quot; + fo.getName());
158             } else {
159                 error(&quot;file not found: &quot; + l + &quot; &quot; + fo.getName());
160             }
161         } else {
162             if (expect) {
163                 error(&quot;file found unexpectedly: &quot; + l + &quot; &quot; + fo.getName());
164             } else {
165                 out.println(&quot;file not found, as expected: &quot; + l + &quot; &quot; + fo.getName());
166             }
167         }
168     }
169 }
    </pre>
  </body>
</html>
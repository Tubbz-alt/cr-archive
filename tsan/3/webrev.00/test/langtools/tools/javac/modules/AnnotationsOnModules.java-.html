<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/modules/AnnotationsOnModules.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8159602 8170549 8171255 8171322
 27  * @summary Test annotations on module declaration.
 28  * @library /tools/lib
 29  * @modules jdk.compiler/com.sun.tools.javac.api
 30  *          jdk.compiler/com.sun.tools.javac.main
 31  *          jdk.jdeps/com.sun.tools.classfile
 32  * @build toolbox.ToolBox toolbox.JavacTask ModuleTestBase
 33  * @run main AnnotationsOnModules
 34  */
 35 
 36 import java.io.File;
 37 import java.nio.file.Files;
 38 import java.nio.file.Path;
 39 import java.util.Arrays;
 40 import java.util.HashSet;
 41 import java.util.List;
 42 import java.util.Objects;
 43 import java.util.Set;
 44 import java.util.stream.Collectors;
 45 
 46 import javax.annotation.processing.AbstractProcessor;
 47 import javax.annotation.processing.RoundEnvironment;
 48 import javax.annotation.processing.SupportedAnnotationTypes;
 49 import javax.annotation.processing.SupportedOptions;
 50 import javax.lang.model.element.AnnotationMirror;
 51 import javax.lang.model.element.ModuleElement;
 52 import javax.lang.model.element.TypeElement;
 53 
 54 import com.sun.tools.classfile.Attribute;
 55 import com.sun.tools.classfile.ClassFile;
 56 import com.sun.tools.classfile.RuntimeInvisibleAnnotations_attribute;
 57 import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;
 58 import toolbox.JavacTask;
 59 import toolbox.Task;
 60 import toolbox.Task.OutputKind;
 61 
 62 public class AnnotationsOnModules extends ModuleTestBase {
 63 
 64     public static void main(String... args) throws Exception {
 65         AnnotationsOnModules t = new AnnotationsOnModules();
 66         t.runTests();
 67     }
 68 
 69     @Test
 70     public void testSimpleAnnotation(Path base) throws Exception {
 71         Path moduleSrc = base.resolve(&quot;module-src&quot;);
 72         Path m1 = moduleSrc.resolve(&quot;m1x&quot;);
 73 
 74         tb.writeJavaFiles(m1,
 75                           &quot;@Deprecated module m1x { }&quot;);
 76 
 77         Path modulePath = base.resolve(&quot;module-path&quot;);
 78 
 79         Files.createDirectories(modulePath);
 80 
 81         new JavacTask(tb)
 82                 .options(&quot;--module-source-path&quot;, moduleSrc.toString())
 83                 .outdir(modulePath)
 84                 .files(findJavaFiles(m1))
 85                 .run()
 86                 .writeAll();
 87 
 88         ClassFile cf = ClassFile.read(modulePath.resolve(&quot;m1x&quot;).resolve(&quot;module-info.class&quot;));
 89         RuntimeVisibleAnnotations_attribute annotations = (RuntimeVisibleAnnotations_attribute) cf.attributes.map.get(Attribute.RuntimeVisibleAnnotations);
 90 
 91         if (annotations == null || annotations.annotations.length != 1) {
 92             throw new AssertionError(&quot;Annotations not correct!&quot;);
 93         }
 94     }
 95 
 96     @Test
 97     public void testSimpleJavadocDeprecationTag(Path base) throws Exception {
 98         Path moduleSrc = base.resolve(&quot;module-src&quot;);
 99         Path m1 = moduleSrc.resolve(&quot;src1/A&quot;);
100 
101         tb.writeJavaFiles(m1,
102                 &quot;/** @deprecated */ module A { }&quot;);
103 
104         Path modulePath = base.resolve(&quot;module-path&quot;);
105 
106         Files.createDirectories(modulePath);
107 
108         List&lt;String&gt; warning = new JavacTask(tb)
109                 .options(&quot;--module-source-path&quot;, m1.getParent().toString(),
110                         &quot;-XDrawDiagnostics&quot;)
111                 .outdir(modulePath)
112                 .files(findJavaFiles(m1))
113                 .run()
114                 .writeAll()
115                 .getOutputLines(OutputKind.DIRECT);
116 
117         List&lt;String&gt; expected = List.of(
118                 &quot;module-info.java:1:20: compiler.warn.missing.deprecated.annotation&quot;,
119                 &quot;1 warning&quot;);
120         if (!warning.containsAll(expected)) {
121             throw new AssertionError(&quot;Expected output not found. Expected: &quot; + expected);
122         }
123 
124         Path m2 = base.resolve(&quot;src2/B&quot;);
125 
126         tb.writeJavaFiles(m2,
127                 &quot;module B { requires A; }&quot;);
128         String log = new JavacTask(tb)
129                 .options(&quot;--module-source-path&quot;, m2.getParent().toString(),
130                         &quot;--module-path&quot;, modulePath.toString(),
131                         &quot;-XDrawDiagnostics&quot;)
132                 .outdir(modulePath)
133                 .files(findJavaFiles(m2))
134                 .run()
135                 .writeAll()
136                 .getOutput(OutputKind.DIRECT);
137 
138         if (!log.isEmpty()) {
139             throw new AssertionError(&quot;Output is not empty. Expected no output and no warnings.&quot;);
140         }
141 
142         ClassFile cf = ClassFile.read(modulePath.resolve(&quot;A&quot;).resolve(&quot;module-info.class&quot;));
143         RuntimeVisibleAnnotations_attribute annotations = (RuntimeVisibleAnnotations_attribute) cf.attributes.map.get(Attribute.RuntimeVisibleAnnotations);
144 
145         if (annotations != null &amp;&amp; annotations.annotations.length &gt; 0) {
146             throw new AssertionError(&quot;Found annotation attributes. Expected no annotations for javadoc @deprecated tag.&quot;);
147         }
148 
149         if (cf.attributes.map.get(Attribute.Deprecated) != null) {
150             throw new AssertionError(&quot;Found Deprecated attribute. Expected no Deprecated attribute for javadoc @deprecated tag.&quot;);
151         }
152     }
153 
154     @Test
155     public void testEnhancedDeprecatedAnnotation(Path base) throws Exception {
156         Path moduleSrc = base.resolve(&quot;module-src&quot;);
157         Path m1 = moduleSrc.resolve(&quot;src1/A&quot;);
158 
159         tb.writeJavaFiles(m1,
160                 &quot;@Deprecated(since=\&quot;10.X\&quot;, forRemoval=true) module A { }&quot;);
161 
162         Path modulePath = base.resolve(&quot;module-path&quot;);
163 
164         Files.createDirectories(modulePath);
165 
166         new JavacTask(tb)
167                 .options(&quot;--module-source-path&quot;, m1.getParent().toString())
168                 .outdir(modulePath)
169                 .files(findJavaFiles(m1))
170                 .run()
171                 .writeAll();
172 
173         Path m2 = base.resolve(&quot;src2/B&quot;);
174 
175         tb.writeJavaFiles(m2,
176                 &quot;module B { requires A; }&quot;);
177         List&lt;String&gt; log = new JavacTask(tb)
178                 .options(&quot;--module-source-path&quot;, m2.getParent().toString(),
179                         &quot;--module-path&quot;, modulePath.toString(),
180                         &quot;-XDrawDiagnostics&quot;)
181                 .outdir(modulePath)
182                 .files(findJavaFiles(m2))
183                 .run()
184                 .writeAll()
185                 .getOutputLines(OutputKind.DIRECT);
186 
187         List&lt;String&gt; expected = List.of(&quot;module-info.java:1:21: compiler.warn.has.been.deprecated.for.removal.module: A&quot;,
188                 &quot;1 warning&quot;);
189         if (!log.containsAll(expected)) {
190             throw new AssertionError(&quot;Expected output not found. Expected: &quot; + expected);
191         }
192 
193         ClassFile cf = ClassFile.read(modulePath.resolve(&quot;A&quot;).resolve(&quot;module-info.class&quot;));
194         RuntimeVisibleAnnotations_attribute annotations = (RuntimeVisibleAnnotations_attribute) cf.attributes.map.get(Attribute.RuntimeVisibleAnnotations);
195 
196         if (annotations == null ) {
197             throw new AssertionError(&quot;Annotations not found!&quot;);
198         }
199         int length = annotations.annotations.length;
200         if (length != 1 ) {
201             throw new AssertionError(&quot;Incorrect number of annotations: &quot; + length);
202         }
203         int pairsCount = annotations.annotations[0].num_element_value_pairs;
204         if (pairsCount != 2) {
205             throw new AssertionError(&quot;Incorrect number of key-value pairs in annotation: &quot; + pairsCount + &quot; Expected two: forRemoval and since.&quot;);
206         }
207     }
208 
209     @Test
210     public void testDeprecatedModuleRequiresDeprecatedForRemovalModule(Path base) throws Exception {
211         Path moduleSrc = base.resolve(&quot;module-src&quot;);
212         Path m1 = moduleSrc.resolve(&quot;src1/A&quot;);
213 
214         tb.writeJavaFiles(m1,
215                 &quot;@Deprecated(forRemoval=true) module A { }&quot;);
216 
217         Path modulePath = base.resolve(&quot;module-path&quot;);
218 
219         Files.createDirectories(modulePath);
220 
221         new JavacTask(tb)
222                 .options(&quot;--module-source-path&quot;, m1.getParent().toString())
223                 .outdir(modulePath)
224                 .files(findJavaFiles(m1))
225                 .run()
226                 .writeAll();
227 
228         Path m2 = base.resolve(&quot;src2/B&quot;);
229 
230         tb.writeJavaFiles(m2,
231                 &quot;@Deprecated(forRemoval=false) module B { requires A; }&quot;);
232         List&lt;String&gt; log = new JavacTask(tb)
233                 .options(&quot;--module-source-path&quot;, m2.getParent().toString(),
234                         &quot;--module-path&quot;, modulePath.toString(),
235                         &quot;-XDrawDiagnostics&quot;)
236                 .outdir(modulePath)
237                 .files(findJavaFiles(m2))
238                 .run()
239                 .writeAll()
240                 .getOutputLines(OutputKind.DIRECT);
241 
242         List&lt;String&gt; expected = List.of(&quot;module-info.java:1:51: compiler.warn.has.been.deprecated.for.removal.module: A&quot;,
243                 &quot;1 warning&quot;);
244         if (!log.containsAll(expected)) {
245             throw new AssertionError(&quot;Expected output not found. Expected: &quot; + expected);
246         }
247     }
248 
249     @Test
250     public void testExportsAndOpensToDeprecatedModule(Path base) throws Exception {
251         Path moduleSrc = base.resolve(&quot;module-src&quot;);
252 
253 
254         tb.writeJavaFiles(moduleSrc.resolve(&quot;B&quot;),
255                 &quot;@Deprecated module B { }&quot;);
256         tb.writeJavaFiles(moduleSrc.resolve(&quot;C&quot;),
257                 &quot;@Deprecated(forRemoval=true) module C { }&quot;);
258 
259         Path modulePath = base.resolve(&quot;module-path&quot;);
260         Files.createDirectories(modulePath);
261 
262         new JavacTask(tb)
263                 .options(&quot;--module-source-path&quot;, moduleSrc.toString())
264                 .outdir(modulePath)
265                 .files(findJavaFiles(moduleSrc))
266                 .run()
267                 .writeAll();
268 
269         Path m1 = base.resolve(&quot;src1/A&quot;);
270 
271         tb.writeJavaFiles(m1,
272                 &quot;module A { &quot; +
273                         &quot;exports p1 to B; opens p1 to B;&quot; +
274                         &quot;exports p2 to C; opens p2 to C;&quot; +
275                         &quot;exports p3 to B,C; opens p3 to B,C;&quot; +
276                         &quot;}&quot;,
277                 &quot;package p1; public class A { }&quot;,
278                 &quot;package p2; public class A { }&quot;,
279                 &quot;package p3; public class A { }&quot;);
280         String log = new JavacTask(tb)
281                 .options(&quot;--module-source-path&quot;, m1.getParent().toString(),
282                         &quot;--module-path&quot;, modulePath.toString(),
283                         &quot;-XDrawDiagnostics&quot;)
284                 .outdir(modulePath)
285                 .files(findJavaFiles(m1))
286                 .run()
287                 .writeAll()
288                 .getOutput(OutputKind.DIRECT);
289 
290         if (!log.isEmpty()) {
291             throw new AssertionError(&quot;Output is not empty! &quot; + log);
292         }
293     }
294 
295     @Test
296     public void testAnnotationWithImport(Path base) throws Exception {
297         Path moduleSrc = base.resolve(&quot;module-src&quot;);
298         Path m1 = moduleSrc.resolve(&quot;m1x&quot;);
299 
300         tb.writeJavaFiles(m1,
301                           &quot;import m1x.A; @A module m1x { }&quot;,
302                           &quot;package m1x; import java.lang.annotation.*; @Target(ElementType.MODULE) public @interface A {}&quot;);
303 
304         Path modulePath = base.resolve(&quot;module-path&quot;);
305 
306         Files.createDirectories(modulePath);
307 
308         new JavacTask(tb)
309                 .options(&quot;--module-source-path&quot;, moduleSrc.toString())
310                 .outdir(modulePath)
311                 .files(findJavaFiles(m1))
312                 .run()
313                 .writeAll();
314 
315         ClassFile cf = ClassFile.read(modulePath.resolve(&quot;m1x&quot;).resolve(&quot;module-info.class&quot;));
316         RuntimeInvisibleAnnotations_attribute annotations = (RuntimeInvisibleAnnotations_attribute) cf.attributes.map.get(Attribute.RuntimeInvisibleAnnotations);
317 
318         if (annotations == null || annotations.annotations.length != 1) {
319             throw new AssertionError(&quot;Annotations not correct!&quot;);
320         }
321     }
322 
323     @Test
324     public void testAnnotationWithImportFromAnotherModule(Path base) throws Exception {
325         Path moduleSrc = base.resolve(&quot;module-src&quot;);
326         Path m1 = moduleSrc.resolve(&quot;src1/A&quot;);
327 
328         tb.writeJavaFiles(m1,
329                 &quot;module A { exports p1; exports p2; }&quot;,
330                 &quot;package p1; import java.lang.annotation.*; @Target(ElementType.MODULE) public @interface A { }&quot;,
331                 &quot;package p2; import java.lang.annotation.*; @Target(ElementType.MODULE) public @interface B { }&quot;);
332 
333         Path modulePath = base.resolve(&quot;module-path&quot;);
334 
335         Files.createDirectories(modulePath);
336 
337         new JavacTask(tb)
338                 .options(&quot;--module-source-path&quot;, m1.getParent().toString())
339                 .outdir(modulePath)
340                 .files(findJavaFiles(m1))
341                 .run()
342                 .writeAll();
343 
344         Path m2 = base.resolve(&quot;src2/B&quot;);
345 
346         tb.writeJavaFiles(m2,
347                 &quot;import p1.A; @A @p2.B module B { requires A; }&quot;);
348         new JavacTask(tb)
349                 .options(&quot;--module-source-path&quot;, m2.getParent().toString(),
350                         &quot;--module-path&quot;, modulePath.toString()
351                 )
352                 .outdir(modulePath)
353                 .files(findJavaFiles(m2))
354                 .run()
355                 .writeAll();
356 
357         ClassFile cf = ClassFile.read(modulePath.resolve(&quot;B&quot;).resolve(&quot;module-info.class&quot;));
358         RuntimeInvisibleAnnotations_attribute annotations = (RuntimeInvisibleAnnotations_attribute) cf.attributes.map.get(Attribute.RuntimeInvisibleAnnotations);
359 
360         if (annotations == null ) {
361             throw new AssertionError(&quot;Annotations not found!&quot;);
362         }
363         int length = annotations.annotations.length;
364         if (length != 2 ) {
365             throw new AssertionError(&quot;Incorrect number of annotations: &quot; + length);
366         }
367     }
368 
369     @Test
370     public void testAnnotationWithImportAmbiguity(Path base) throws Exception {
371         Path moduleSrc = base.resolve(&quot;module-src&quot;);
372         Path m1 = moduleSrc.resolve(&quot;src1/A&quot;);
373 
374         tb.writeJavaFiles(m1,
375                 &quot;module A { exports p1; exports p2; }&quot;,
376                 &quot;package p1; import java.lang.annotation.*; @Target(ElementType.MODULE) public @interface AAA { }&quot;,
377                 &quot;package p2; import java.lang.annotation.*; @Target(ElementType.MODULE) public @interface AAA { }&quot;);
378 
379         Path modulePath = base.resolve(&quot;module-path&quot;);
380 
381         Files.createDirectories(modulePath);
382 
383         new JavacTask(tb)
384                 .options(&quot;--module-source-path&quot;, m1.getParent().toString())
385                 .outdir(modulePath)
386                 .files(findJavaFiles(m1))
387                 .run()
388                 .writeAll();
389 
390         Path m2 = base.resolve(&quot;src2/B&quot;);
391 
392         tb.writeJavaFiles(m2,
393                 &quot;import p1.*; import p2.*; @AAA module B { requires A; }&quot;);
394         List&lt;String&gt; log = new JavacTask(tb)
395                 .options(&quot;--module-source-path&quot;, m2.getParent().toString(),
396                         &quot;--module-path&quot;, modulePath.toString(),
397                         &quot;-XDrawDiagnostics&quot;
398                 )
399                 .outdir(modulePath)
400                 .files(findJavaFiles(m2))
401                 .run(Task.Expect.FAIL)
402                 .writeAll()
403                 .getOutputLines(OutputKind.DIRECT);
404 
405         List&lt;String&gt; expected = List.of(&quot;module-info.java:1:28: compiler.err.ref.ambiguous: AAA, kindname.class, p2.AAA, p2, kindname.class, p1.AAA, p1&quot;,
406                 &quot;1 error&quot;);
407         if (!log.containsAll(expected)) {
408             throw new AssertionError(&quot;Expected output not found. Expected: &quot; + expected);
409         }
410 
411     }
412 
413     @Test
414     public void testModuleInfoAnnotationsInAPI(Path base) throws Exception {
415         Path moduleSrc = base.resolve(&quot;module-src&quot;);
416         Path m1 = moduleSrc.resolve(&quot;m1x&quot;);
417 
418         tb.writeJavaFiles(m1,
419                           &quot;import m1x.*; @A @Deprecated @E @E module m1x { }&quot;,
420                           &quot;package m1x; import java.lang.annotation.*; @Target(ElementType.MODULE) public @interface A {}&quot;,
421                           &quot;package m1x; import java.lang.annotation.*; @Target(ElementType.MODULE) @Repeatable(C.class) public @interface E {}&quot;,
422                           &quot;package m1x; import java.lang.annotation.*; @Target(ElementType.MODULE) public @interface C { public E[] value(); }&quot;);
423 
424         Path modulePath = base.resolve(&quot;module-path&quot;);
425 
426         Files.createDirectories(modulePath);
427 
428         new JavacTask(tb)
429                 .options(&quot;--module-source-path&quot;, moduleSrc.toString(),
430                          &quot;-processor&quot;, AP.class.getName())
431                 .outdir(modulePath)
432                 .files(findJavaFiles(m1))
433                 .run()
434                 .writeAll();
435 
436         Path src = base.resolve(&quot;src&quot;);
437 
438         tb.writeJavaFiles(src,
439                           &quot;class T {}&quot;);
440 
441         Path out = base.resolve(&quot;out&quot;);
442 
443         Files.createDirectories(out);
444 
445         new JavacTask(tb)
446                 .options(&quot;--module-path&quot;, modulePath.toString(),
447                          &quot;--add-modules&quot;, &quot;m1x&quot;,
448                          &quot;-processor&quot;, AP.class.getName())
449                 .outdir(out)
450                 .files(findJavaFiles(src))
451                 .run()
452                 .writeAll();
453 
454         new JavacTask(tb)
455                 .options(&quot;--module-path&quot;, modulePath.toString() + File.pathSeparator + out.toString(),
456                          &quot;--add-modules&quot;, &quot;m1x&quot;,
457                          &quot;-processor&quot;, AP.class.getName(),
458                          &quot;-proc:only&quot;)
459                 .classes(&quot;m1x/m1x.A&quot;)
460                 .files(findJavaFiles(src))
461                 .run()
462                 .writeAll();
463     }
464 
465     @SupportedAnnotationTypes(&quot;*&quot;)
466     public static final class AP extends AbstractProcessor {
467 
468         @Override
469         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
470             ModuleElement m1 = processingEnv.getElementUtils().getModuleElement(&quot;m1x&quot;);
471             Set&lt;String&gt; actualAnnotations = new HashSet&lt;&gt;();
472             Set&lt;String&gt; expectedAnnotations =
473                     new HashSet&lt;&gt;(Arrays.asList(&quot;@m1x.A&quot;, &quot;@java.lang.Deprecated&quot;, &quot;@m1x.C({@m1x.E, @m1x.E})&quot;));
474 
475             for (AnnotationMirror am : m1.getAnnotationMirrors()) {
476                 actualAnnotations.add(am.toString());
477             }
478 
479             if (!expectedAnnotations.equals(actualAnnotations)) {
480                 throw new AssertionError(&quot;Incorrect annotations: &quot; + actualAnnotations);
481             }
482 
483             return false;
484         }
485 
486     }
487 
488     @Test
489     public void testModuleDeprecation(Path base) throws Exception {
490         Path moduleSrc = base.resolve(&quot;module-src&quot;);
491         Path m1 = moduleSrc.resolve(&quot;m1x&quot;);
492 
493         tb.writeJavaFiles(m1,
494                           &quot;@Deprecated module m1x { }&quot;);
495 
496         Path m2 = moduleSrc.resolve(&quot;m2x&quot;);
497 
498         tb.writeJavaFiles(m2,
499                           &quot;@Deprecated module m2x { }&quot;);
500 
501         Path m3 = moduleSrc.resolve(&quot;m3x&quot;);
502 
503         Path modulePath = base.resolve(&quot;module-path&quot;);
504 
505         Files.createDirectories(modulePath);
506 
507         List&lt;String&gt; actual;
508         List&lt;String&gt; expected;
509 
510         String DEPRECATED_JAVADOC = &quot;/** @deprecated */&quot;;
511         for (String suppress : new String[] {&quot;&quot;, DEPRECATED_JAVADOC, &quot;@Deprecated &quot;, &quot;@SuppressWarnings(\&quot;deprecation\&quot;) &quot;}) {
512             tb.writeJavaFiles(m3,
513                               suppress + &quot;module m3x {\n&quot; +
514                               &quot;    requires m1x;\n&quot; +
515                               &quot;    exports api to m1x, m2x;\n&quot; +
516                               &quot;}&quot;,
517                               &quot;package api; public class Api { }&quot;);
518             System.err.println(&quot;compile m3x&quot;);
519             actual = new JavacTask(tb)
520                     .options(&quot;--module-source-path&quot;, moduleSrc.toString(),
521                              &quot;-XDrawDiagnostics&quot;)
522                     .outdir(modulePath)
523                     .files(findJavaFiles(moduleSrc))
524                     .run()
525                     .writeAll()
526                     .getOutputLines(OutputKind.DIRECT);
527 
528             if (suppress.isEmpty()) {
529                 expected = Arrays.asList(
530                         &quot;- compiler.note.deprecated.filename: module-info.java&quot;,
531                         &quot;- compiler.note.deprecated.recompile&quot;);
532             } else if (suppress.equals(DEPRECATED_JAVADOC)) {
533                 expected = Arrays.asList(
534                         &quot;module-info.java:1:19: compiler.warn.missing.deprecated.annotation&quot;,
535                         &quot;- compiler.note.deprecated.filename: module-info.java&quot;,
536                         &quot;- compiler.note.deprecated.recompile&quot;,
537                         &quot;1 warning&quot;);
538             } else {
539                 expected = Arrays.asList(&quot;&quot;);
540             }
541 
542             if (!expected.equals(actual)) {
543                 throw new AssertionError(&quot;Unexpected output: &quot; + actual + &quot;; suppress: &quot; + suppress);
544             }
545 
546             System.err.println(&quot;compile m3x with -Xlint:-deprecation&quot;);
547             actual = new JavacTask(tb)
548                     .options(&quot;--module-source-path&quot;, moduleSrc.toString(),
549                              &quot;-XDrawDiagnostics&quot;,
550                              &quot;-Xlint:deprecation&quot;)
551                     .outdir(modulePath)
552                     .files(findJavaFiles(moduleSrc))
553                     .run()
554                     .writeAll()
555                     .getOutputLines(OutputKind.DIRECT);
556 
557             if (suppress.isEmpty()) {
558                 expected = Arrays.asList(
559                         &quot;module-info.java:2:14: compiler.warn.has.been.deprecated.module: m1x&quot;,
560                         &quot;1 warning&quot;);
561             } else if (suppress.equals(DEPRECATED_JAVADOC)) {
562                 expected = Arrays.asList(
563                         &quot;module-info.java:1:19: compiler.warn.missing.deprecated.annotation&quot;,
564                         &quot;module-info.java:2:14: compiler.warn.has.been.deprecated.module: m1x&quot;,
565                         &quot;2 warnings&quot;);
566             } else {
567                 expected = Arrays.asList(&quot;&quot;);
568             }
569 
570             if (!expected.equals(actual)) {
571                 throw new AssertionError(&quot;Unexpected output: &quot; + actual + &quot;; suppress: &quot; + suppress);
572             }
573 
574             //load the deprecated module-infos from classfile:
575             System.err.println(&quot;compile m3x with -Xlint:-deprecation, loading deprecated modules from classes&quot;);
576             actual = new JavacTask(tb)
577                     .options(&quot;--module-path&quot;, modulePath.toString(),
578                              &quot;-XDrawDiagnostics&quot;,
579                              &quot;-Xlint:deprecation&quot;)
580                     .outdir(modulePath.resolve(&quot;m3x&quot;))
581                     .files(findJavaFiles(moduleSrc.resolve(&quot;m3x&quot;)))
582                     .run()
583                     .writeAll()
584                     .getOutputLines(OutputKind.DIRECT);
585 
586             if (!expected.equals(actual)) {
587                 throw new AssertionError(&quot;Unexpected output: &quot; + actual + &quot;; suppress: &quot; + suppress);
588             }
589         }
590     }
591 
592     @Test
593     public void testAttributeValues(Path base) throws Exception {
594         class TestCase {
595             public final String extraDecl;
596             public final String decl;
597             public final String use;
598             public final String expectedAnnotations;
599 
600             public TestCase(String extraDecl, String decl, String use, String expectedAnnotations) {
601                 this.extraDecl = extraDecl;
602                 this.decl = decl;
603                 this.use = use;
604                 this.expectedAnnotations = expectedAnnotations;
605             }
606         }
607 
608         TestCase[] testCases = new TestCase[] {
609             new TestCase(&quot;package test; public enum E {A, B;}&quot;,
610                          &quot;public E value();&quot;,
611                          &quot;test.E.A&quot;,
612                          &quot;@test.A(test.E.A)&quot;),
613             new TestCase(&quot;package test; public enum E {A, B;}&quot;,
614                          &quot;public E[] value();&quot;,
615                          &quot;{test.E.A, test.E.B}&quot;,
616                          &quot;@test.A({test.E.A, test.E.B})&quot;),
617             new TestCase(&quot;package test; public class Extra {}&quot;,
618                          &quot;public Class value();&quot;,
619                          &quot;test.Extra.class&quot;,
620                          &quot;@test.A(test.Extra.class)&quot;),
621             new TestCase(&quot;package test; public class Extra {}&quot;,
622                          &quot;public Class[] value();&quot;,
623                          &quot;{test.Extra.class, String.class}&quot;,
624                          &quot;@test.A({test.Extra.class, java.lang.String.class})&quot;),
625             new TestCase(&quot;package test; public @interface Extra { public Class value(); }&quot;,
626                          &quot;public test.Extra value();&quot;,
627                          &quot;@test.Extra(String.class)&quot;,
628                          &quot;@test.A(@test.Extra(java.lang.String.class))&quot;),
629             new TestCase(&quot;package test; public @interface Extra { public Class value(); }&quot;,
630                          &quot;public test.Extra[] value();&quot;,
631                          &quot;{@test.Extra(String.class), @test.Extra(Integer.class)}&quot;,
632                          &quot;@test.A({@test.Extra(java.lang.String.class), @test.Extra(java.lang.Integer.class)})&quot;),
633             new TestCase(&quot;package test; public class Any { }&quot;,
634                          &quot;public int value();&quot;,
635                          &quot;1&quot;,
636                          &quot;@test.A(1)&quot;),
637             new TestCase(&quot;package test; public class Any { }&quot;,
638                          &quot;public int[] value();&quot;,
639                          &quot;{1, 2}&quot;,
640                          &quot;@test.A({1, 2})&quot;),
641             new TestCase(&quot;package test; public enum E {A;}&quot;,
642                         &quot;int integer(); boolean flag(); double value(); String string(); E enumeration(); &quot;,
643                         &quot;enumeration = test.E.A, integer = 42, flag = true, value = 3.5, string = \&quot;Text\&quot;&quot;,
644                         &quot;@test.A(enumeration=test.E.A, integer=42, flag=true, value=3.5, string=\&quot;Text\&quot;)&quot;),
645         };
646 
647         Path extraSrc = base.resolve(&quot;extra-src&quot;);
648         tb.writeJavaFiles(extraSrc,
649                           &quot;class Any {}&quot;);
650 
651         int count = 0;
652 
653         for (TestCase tc : testCases) {
654             Path testBase = base.resolve(String.valueOf(count));
655             Path moduleSrc = testBase.resolve(&quot;module-src&quot;);
656             Path m = moduleSrc.resolve(&quot;m&quot;);
657 
658             tb.writeJavaFiles(m,
659                               &quot;@test.A(&quot; + tc.use + &quot;) module m { }&quot;,
660                               &quot;package test; @java.lang.annotation.Target(java.lang.annotation.ElementType.MODULE) public @interface A { &quot; + tc.decl + &quot;}&quot;,
661                               tc.extraDecl);
662 
663             Path modulePath = testBase.resolve(&quot;module-path&quot;);
664 
665             Files.createDirectories(modulePath);
666 
667             new JavacTask(tb)
668                 .options(&quot;--module-source-path&quot;, moduleSrc.toString())
669                 .outdir(modulePath)
670                 .files(findJavaFiles(moduleSrc))
671                 .run()
672                 .writeAll();
673 
674             Path classes = testBase.resolve(&quot;classes&quot;);
675 
676             Files.createDirectories(classes);
677 
678             new JavacTask(tb)
679                 .options(&quot;--module-path&quot;, modulePath.toString(),
680                          &quot;--add-modules&quot;, &quot;m&quot;,
681                          &quot;-processorpath&quot;, System.getProperty(&quot;test.classes&quot;),
682                          &quot;-processor&quot;, ProxyTypeValidator.class.getName(),
683                          &quot;-A&quot; + OPT_EXPECTED_ANNOTATIONS + &quot;=&quot; + tc.expectedAnnotations)
684                 .outdir(classes)
685                 .files(findJavaFiles(extraSrc))
686                 .run()
687                 .writeAll();
688         }
689     }
690 
691     private static final String OPT_EXPECTED_ANNOTATIONS = &quot;expectedAnnotations&quot;;
692 
693     @SupportedAnnotationTypes(&quot;*&quot;)
694     @SupportedOptions(OPT_EXPECTED_ANNOTATIONS)
695     public static final class ProxyTypeValidator extends AbstractProcessor {
696 
697         @Override
698         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
699             ModuleElement m = processingEnv.getElementUtils().getModuleElement(&quot;m&quot;);
700             String actualTypes = m.getAnnotationMirrors()
701                                   .stream()
702                                   .map(am -&gt; am.toString())
703                                   .collect(Collectors.joining(&quot;, &quot;));
704             if (!Objects.equals(actualTypes, processingEnv.getOptions().get(OPT_EXPECTED_ANNOTATIONS))) {
705                 throw new IllegalStateException(&quot;Expected annotations not found, actual: &quot; + actualTypes);
706             }
707             return false;
708         }
709 
710     }
711 
712 }
    </pre>
  </body>
</html>
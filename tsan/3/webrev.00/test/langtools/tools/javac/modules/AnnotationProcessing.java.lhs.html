<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/modules/AnnotationProcessing.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /**
  25  * @test
  26  * @bug 8133884 8162711 8133896 8172158 8172262 8173636 8175119 8189747
  27  * @summary Verify that annotation processing works.
  28  * @library /tools/lib
  29  * @modules
  30  *      jdk.compiler/com.sun.tools.javac.api
  31  *      jdk.compiler/com.sun.tools.javac.main
  32  * @build toolbox.ToolBox toolbox.JavacTask ModuleTestBase
  33  * @run main AnnotationProcessing
  34  */
  35 
  36 import java.io.File;
  37 import java.io.IOException;
  38 import java.io.OutputStream;
  39 import java.io.Reader;
  40 import java.io.UncheckedIOException;
  41 import java.io.Writer;
  42 import java.nio.file.Files;
  43 import java.nio.file.Path;
  44 import java.nio.file.Paths;
  45 import java.util.ArrayList;
  46 import java.util.Arrays;
  47 import java.util.HashMap;
  48 import java.util.HashSet;
  49 import java.util.List;
  50 import java.util.Map;
  51 import java.util.Objects;
  52 import java.util.Set;
  53 import java.util.concurrent.Callable;
  54 import java.util.function.Consumer;
  55 import java.util.function.Function;
  56 import java.util.regex.Pattern;
  57 import java.util.stream.Collectors;
  58 
  59 import javax.annotation.processing.AbstractProcessor;
  60 import javax.annotation.processing.Filer;
  61 import javax.annotation.processing.FilerException;
  62 import javax.annotation.processing.Messager;
  63 import javax.annotation.processing.ProcessingEnvironment;
  64 import javax.annotation.processing.RoundEnvironment;
  65 import javax.annotation.processing.SupportedAnnotationTypes;
  66 import javax.annotation.processing.SupportedOptions;
  67 import javax.lang.model.SourceVersion;
  68 import javax.lang.model.element.Element;
  69 import javax.lang.model.element.ElementKind;
  70 import javax.lang.model.element.ModuleElement;
  71 import javax.lang.model.element.ModuleElement.ProvidesDirective;
  72 import javax.lang.model.element.ModuleElement.UsesDirective;
  73 import javax.lang.model.element.PackageElement;
  74 import javax.lang.model.element.TypeElement;
  75 import javax.lang.model.element.VariableElement;
  76 import javax.lang.model.type.TypeKind;
  77 import javax.lang.model.util.ElementFilter;
<a name="2" id="anc2"></a><span class="line-modified">  78 import javax.lang.model.util.ElementScanner9;</span>
  79 import javax.tools.Diagnostic.Kind;
  80 import javax.tools.FileObject;
  81 import javax.tools.JavaCompiler;
  82 import javax.tools.JavaCompiler.CompilationTask;
  83 import javax.tools.JavaFileManager;
  84 import javax.tools.JavaFileManager.Location;
  85 import javax.tools.JavaFileObject;
  86 import javax.tools.StandardJavaFileManager;
  87 import javax.tools.StandardLocation;
  88 import javax.tools.ToolProvider;
  89 
  90 import toolbox.JavacTask;
  91 import toolbox.Task;
  92 import toolbox.Task.Mode;
  93 import toolbox.Task.OutputKind;
  94 
  95 public class AnnotationProcessing extends ModuleTestBase {
  96 
  97     public static void main(String... args) throws Exception {
  98         System.out.println(System.getProperties());
  99         new AnnotationProcessing().runTests();
 100     }
 101 
 102     @Test
 103     public void testAPSingleModule(Path base) throws Exception {
 104         Path moduleSrc = base.resolve(&quot;module-src&quot;);
 105         Path m1 = moduleSrc.resolve(&quot;m1x&quot;);
 106 
 107         Path classes = base.resolve(&quot;classes&quot;);
 108 
 109         Files.createDirectories(classes);
 110 
 111         tb.writeJavaFiles(m1,
 112                           &quot;module m1x { }&quot;,
 113                           &quot;package impl; public class Impl { }&quot;);
 114 
 115         String log = new JavacTask(tb)
 116                 .options(&quot;--module-source-path&quot;, moduleSrc.toString(),
 117                          &quot;-processor&quot;, AP.class.getName(),
 118                          &quot;-AexpectedEnclosedElements=m1x=&gt;impl&quot;)
 119                 .outdir(classes)
 120                 .files(findJavaFiles(moduleSrc))
 121                 .run()
 122                 .writeAll()
 123                 .getOutput(Task.OutputKind.DIRECT);
 124 
 125         if (!log.isEmpty())
 126             throw new AssertionError(&quot;Unexpected output: &quot; + log);
 127     }
 128 
 129     @Test
 130     public void testAPMultiModule(Path base) throws Exception {
 131         Path moduleSrc = base.resolve(&quot;module-src&quot;);
 132         Path m1 = moduleSrc.resolve(&quot;m1x&quot;);
 133         Path m2 = moduleSrc.resolve(&quot;m2x&quot;);
 134 
 135         Path classes = base.resolve(&quot;classes&quot;);
 136 
 137         Files.createDirectories(classes);
 138 
 139         tb.writeJavaFiles(m1,
 140                           &quot;module m1x { }&quot;,
 141                           &quot;package impl1; public class Impl1 { }&quot;);
 142 
 143         tb.writeJavaFiles(m2,
 144                           &quot;module m2x { }&quot;,
 145                           &quot;package impl2; public class Impl2 { }&quot;);
 146 
 147         String log = new JavacTask(tb)
 148                 .options(&quot;--module-source-path&quot;, moduleSrc.toString(),
 149                          &quot;-processor&quot;, AP.class.getName(),
 150                          &quot;-AexpectedEnclosedElements=m1x=&gt;impl1,m2x=&gt;impl2&quot;)
 151                 .outdir(classes)
 152                 .files(findJavaFiles(moduleSrc))
 153                 .run()
 154                 .writeAll()
 155                 .getOutput(Task.OutputKind.DIRECT);
 156 
 157         if (!log.isEmpty())
 158             throw new AssertionError(&quot;Unexpected output: &quot; + log);
 159     }
 160 
 161     @SupportedAnnotationTypes(&quot;*&quot;)
 162     @SupportedOptions(&quot;expectedEnclosedElements&quot;)
 163     public static final class AP extends AbstractProcessor {
 164 
 165         private Map&lt;String, List&lt;String&gt;&gt; module2ExpectedEnclosedElements;
 166         private Set&lt;String&gt; seenModules = new HashSet&lt;&gt;();
 167 
 168         @Override
 169         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
 170             if (module2ExpectedEnclosedElements == null) {
 171                 module2ExpectedEnclosedElements = new HashMap&lt;&gt;();
 172 
 173                 String expectedEnclosedElements =
 174                         processingEnv.getOptions().get(&quot;expectedEnclosedElements&quot;);
 175 
 176                 for (String moduleDef : expectedEnclosedElements.split(&quot;,&quot;)) {
 177                     String[] module2Packages = moduleDef.split(&quot;=&gt;&quot;);
 178 
 179                     module2ExpectedEnclosedElements.put(module2Packages[0],
 180                                                         List.of(module2Packages[1].split(&quot;:&quot;)));
 181                 }
 182             }
 183 
 184             //verify ModuleType and ModuleSymbol behavior:
 185             for (Element root : roundEnv.getRootElements()) {
 186                 ModuleElement module = processingEnv.getElementUtils().getModuleOf(root);
 187 
 188                 assertEquals(TypeKind.MODULE, module.asType().getKind());
 189 
 190                 boolean[] seenModule = new boolean[1];
 191 
<a name="3" id="anc3"></a><span class="line-modified"> 192                 module.accept(new ElementScanner9&lt;Void, Void&gt;() {</span>
 193                     @Override
 194                     public Void visitModule(ModuleElement e, Void p) {
 195                         seenModule[0] = true;
 196                         return null;
 197                     }
 198                     @Override
 199                     public Void scan(Element e, Void p) {
 200                         throw new AssertionError(&quot;Shouldn&#39;t get here.&quot;);
 201                     }
 202                 }, null);
 203 
 204                 assertEquals(true, seenModule[0]);
 205 
 206                 List&lt;String&gt; actualElements =
 207                         module.getEnclosedElements()
 208                               .stream()
 209                               .map(s -&gt; (PackageElement) s)
 210                               .map(p -&gt; p.getQualifiedName().toString())
 211                               .collect(Collectors.toList());
 212 
 213                 String moduleName = module.getQualifiedName().toString();
 214 
 215                 assertEquals(module2ExpectedEnclosedElements.get(moduleName),
 216                              actualElements);
 217 
 218                 seenModules.add(moduleName);
 219             }
 220 
 221             if (roundEnv.processingOver()) {
 222                 assertEquals(module2ExpectedEnclosedElements.keySet(), seenModules);
 223             }
 224 
 225             return false;
 226         }
 227 
 228         @Override
 229         public SourceVersion getSupportedSourceVersion() {
 230             return SourceVersion.latest();
 231         }
 232 
 233     }
 234 
 235     @Test
 236     public void testVerifyUsesProvides(Path base) throws Exception {
 237         Path moduleSrc = base.resolve(&quot;module-src&quot;);
 238         Path m1 = moduleSrc.resolve(&quot;m1x&quot;);
 239 
 240         Path classes = base.resolve(&quot;classes&quot;);
 241 
 242         Files.createDirectories(classes);
 243 
 244         tb.writeJavaFiles(m1,
 245                           &quot;module m1x { exports api; uses api.Api; provides api.Api with impl.Impl; }&quot;,
 246                           &quot;package api; public class Api { }&quot;,
 247                           &quot;package impl; public class Impl extends api.Api { }&quot;);
 248 
 249         String log = new JavacTask(tb)
 250                 .options(&quot;-doe&quot;, &quot;-processor&quot;, VerifyUsesProvidesAP.class.getName())
 251                 .outdir(classes)
 252                 .files(findJavaFiles(moduleSrc))
 253                 .run()
 254                 .writeAll()
 255                 .getOutput(Task.OutputKind.DIRECT);
 256 
 257         if (!log.isEmpty())
 258             throw new AssertionError(&quot;Unexpected output: &quot; + log);
 259     }
 260 
 261     @SupportedAnnotationTypes(&quot;*&quot;)
 262     public static final class VerifyUsesProvidesAP extends AbstractProcessor {
 263 
 264         @Override
 265         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
 266             TypeElement api = processingEnv.getElementUtils().getTypeElement(&quot;api.Api&quot;);
 267 
 268             assertNonNull(&quot;Cannot find api.Api&quot;, api);
 269 
 270             ModuleElement modle = (ModuleElement) processingEnv.getElementUtils().getPackageOf(api).getEnclosingElement();
 271 
 272             assertNonNull(&quot;modle is null&quot;, modle);
 273 
 274             List&lt;? extends UsesDirective&gt; uses = ElementFilter.usesIn(modle.getDirectives());
 275             assertEquals(1, uses.size());
 276             assertEquals(&quot;api.Api&quot;, uses.iterator().next().getService().getQualifiedName().toString());
 277 
 278             List&lt;? extends ProvidesDirective&gt; provides = ElementFilter.providesIn(modle.getDirectives());
 279             assertEquals(1, provides.size());
 280             assertEquals(&quot;api.Api&quot;, provides.iterator().next().getService().getQualifiedName().toString());
 281             assertEquals(&quot;impl.Impl&quot;, provides.iterator().next().getImplementations().get(0).getQualifiedName().toString());
 282 
 283             return false;
 284         }
 285 
 286         @Override
 287         public SourceVersion getSupportedSourceVersion() {
 288             return SourceVersion.latest();
 289         }
 290 
 291     }
 292 
 293     @Test
 294     public void testPackageNoModule(Path base) throws Exception {
 295         Path src = base.resolve(&quot;src&quot;);
 296         Path classes = base.resolve(&quot;classes&quot;);
 297 
 298         Files.createDirectories(classes);
 299 
 300         tb.writeJavaFiles(src,
 301                           &quot;package api; public class Api { }&quot;);
 302 
 303         String log = new JavacTask(tb)
 304                 .options(&quot;-processor&quot;, VerifyPackageNoModule.class.getName(),
 305                          &quot;-source&quot;, &quot;8&quot;,
 306                          &quot;-Xlint:-options&quot;)
 307                 .outdir(classes)
 308                 .files(findJavaFiles(src))
 309                 .run()
 310                 .writeAll()
 311                 .getOutput(Task.OutputKind.DIRECT);
 312 
 313         if (!log.isEmpty())
 314             throw new AssertionError(&quot;Unexpected output: &quot; + log);
 315     }
 316 
 317     @SupportedAnnotationTypes(&quot;*&quot;)
 318     public static final class VerifyPackageNoModule extends AbstractProcessor {
 319 
 320         @Override
 321         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
 322             TypeElement api = processingEnv.getElementUtils().getTypeElement(&quot;api.Api&quot;);
 323 
 324             assertNonNull(&quot;Cannot find api.Api&quot;, api);
 325 
 326             ModuleElement modle = (ModuleElement) processingEnv.getElementUtils().getPackageOf(api).getEnclosingElement();
 327 
 328             assertNull(&quot;modle is not null&quot;, modle);
 329 
 330             return false;
 331         }
 332 
 333         @Override
 334         public SourceVersion getSupportedSourceVersion() {
 335             return SourceVersion.latest();
 336         }
 337 
 338     }
 339 
 340     @Test
 341     public void testQualifiedClassForProcessing(Path base) throws Exception {
 342         Path moduleSrc = base.resolve(&quot;module-src&quot;);
 343         Path m1 = moduleSrc.resolve(&quot;m1x&quot;);
 344         Path m2 = moduleSrc.resolve(&quot;m2x&quot;);
 345 
 346         Path classes = base.resolve(&quot;classes&quot;);
 347 
 348         Files.createDirectories(classes);
 349 
 350         tb.writeJavaFiles(m1,
 351                           &quot;module m1x { }&quot;,
 352                           &quot;package impl; public class Impl { int m1x; }&quot;);
 353 
 354         tb.writeJavaFiles(m2,
 355                           &quot;module m2x { }&quot;,
 356                           &quot;package impl; public class Impl { int m2x; }&quot;);
 357 
 358         new JavacTask(tb)
 359             .options(&quot;--module-source-path&quot;, moduleSrc.toString())
 360             .outdir(classes)
 361             .files(findJavaFiles(moduleSrc))
 362             .run()
 363             .writeAll()
 364             .getOutput(Task.OutputKind.DIRECT);
 365 
 366         List&lt;String&gt; expected = List.of(&quot;Note: field: m1x&quot;);
 367 
 368         for (Mode mode : new Mode[] {Mode.API, Mode.CMDLINE}) {
 369             List&lt;String&gt; log = new JavacTask(tb, mode)
 370                     .options(&quot;-processor&quot;, QualifiedClassForProcessing.class.getName(),
 371                              &quot;--module-path&quot;, classes.toString())
 372                     .classes(&quot;m1x/impl.Impl&quot;)
 373                     .outdir(classes)
 374                     .run()
 375                     .writeAll()
 376                     .getOutputLines(Task.OutputKind.DIRECT);
 377 
 378             if (!expected.equals(log))
 379                 throw new AssertionError(&quot;Unexpected output: &quot; + log);
 380         }
 381     }
 382 
 383     @SupportedAnnotationTypes(&quot;*&quot;)
 384     public static final class QualifiedClassForProcessing extends AbstractProcessor {
 385 
 386         @Override
 387         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
 388             if (processingEnv.getElementUtils().getModuleElement(&quot;m1x&quot;) == null) {
 389                 throw new AssertionError(&quot;No m1x module found.&quot;);
 390             }
 391 
 392             Messager messager = processingEnv.getMessager();
 393 
 394             for (TypeElement clazz : ElementFilter.typesIn(roundEnv.getRootElements())) {
 395                 for (VariableElement field : ElementFilter.fieldsIn(clazz.getEnclosedElements())) {
 396                     messager.printMessage(Kind.NOTE, &quot;field: &quot; + field.getSimpleName());
 397                 }
 398             }
 399 
 400             return false;
 401         }
 402 
 403         @Override
 404         public SourceVersion getSupportedSourceVersion() {
 405             return SourceVersion.latest();
 406         }
 407 
 408     }
 409 
 410     @Test
 411     public void testModuleInRootElements(Path base) throws Exception {
 412         Path moduleSrc = base.resolve(&quot;module-src&quot;);
 413         Path m1 = moduleSrc.resolve(&quot;m1&quot;);
 414 
 415         Path classes = base.resolve(&quot;classes&quot;);
 416 
 417         Files.createDirectories(classes);
 418 
 419         tb.writeJavaFiles(m1,
 420                           &quot;module m1x { exports api; }&quot;,
 421                           &quot;package api; public class Api { }&quot;);
 422 
 423         List&lt;String&gt; log = new JavacTask(tb)
 424                 .options(&quot;-processor&quot;, ModuleInRootElementsAP.class.getName())
 425                 .outdir(classes)
 426                 .files(findJavaFiles(moduleSrc))
 427                 .run()
 428                 .writeAll()
 429                 .getOutputLines(Task.OutputKind.STDERR);
 430 
 431         assertEquals(List.of(&quot;module: m1x&quot;), log);
 432     }
 433 
 434     @SupportedAnnotationTypes(&quot;*&quot;)
 435     public static final class ModuleInRootElementsAP extends AbstractProcessor {
 436 
 437         @Override
 438         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
 439             roundEnv.getRootElements()
 440                     .stream()
 441                     .filter(el -&gt; el.getKind() == ElementKind.MODULE)
 442                     .forEach(mod -&gt; System.err.println(&quot;module: &quot; + mod.getSimpleName()));
 443 
 444             return false;
 445         }
 446 
 447         @Override
 448         public SourceVersion getSupportedSourceVersion() {
 449             return SourceVersion.latest();
 450         }
 451 
 452     }
 453 
 454     @Test
 455     public void testAnnotationsInModuleInfo(Path base) throws Exception {
 456         Path moduleSrc = base.resolve(&quot;module-src&quot;);
 457         Path m1 = moduleSrc.resolve(&quot;m1&quot;);
 458 
 459         tb.writeJavaFiles(m1,
 460                           &quot;@Deprecated module m1x { }&quot;);
 461 
 462         Path m2 = moduleSrc.resolve(&quot;m2x&quot;);
 463 
 464         tb.writeJavaFiles(m2,
 465                           &quot;@SuppressWarnings(\&quot;\&quot;) module m2x { }&quot;);
 466 
 467         Path classes = base.resolve(&quot;classes&quot;);
 468 
 469         Files.createDirectories(classes);
 470 
 471         List&lt;String&gt; log = new JavacTask(tb)
 472                 .options(&quot;-processor&quot;, AnnotationsInModuleInfoPrint.class.getName())
 473                 .outdir(classes)
 474                 .files(findJavaFiles(m1))
 475                 .run()
 476                 .writeAll()
 477                 .getOutputLines(Task.OutputKind.DIRECT);
 478 
 479         List&lt;String&gt; expectedLog = List.of(&quot;Note: AP Invoked&quot;,
 480                                            &quot;Note: AP Invoked&quot;);
 481 
 482         assertEquals(expectedLog, log);
 483 
 484         new JavacTask(tb)
 485             .options(&quot;-processor&quot;, AnnotationsInModuleInfoFail.class.getName())
 486             .outdir(classes)
 487             .files(findJavaFiles(m2))
 488             .run()
 489             .writeAll();
 490     }
 491 
 492     @SupportedAnnotationTypes(&quot;java.lang.Deprecated&quot;)
 493     public static final class AnnotationsInModuleInfoPrint extends AbstractProcessor {
 494 
 495         @Override
 496         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
 497             processingEnv.getMessager().printMessage(Kind.NOTE, &quot;AP Invoked&quot;);
 498             return false;
 499         }
 500 
 501         @Override
 502         public SourceVersion getSupportedSourceVersion() {
 503             return SourceVersion.latest();
 504         }
 505 
 506     }
 507 
 508     @SupportedAnnotationTypes(&quot;java.lang.Deprecated&quot;)
 509     public static final class AnnotationsInModuleInfoFail extends AbstractProcessor {
 510 
 511         @Override
 512         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
 513             throw new AssertionError();
 514         }
 515 
 516         @Override
 517         public SourceVersion getSupportedSourceVersion() {
 518             return SourceVersion.latest();
 519         }
 520 
 521     }
 522 
 523     @Test
 524     public void testGenerateInMultiModeAPI(Path base) throws Exception {
 525         Path moduleSrc = base.resolve(&quot;module-src&quot;);
 526         Path classes = base.resolve(&quot;classes&quot;);
 527 
 528         Files.createDirectories(classes);
 529 
 530         Path m1 = moduleSrc.resolve(&quot;m1x&quot;);
 531 
 532         tb.writeJavaFiles(m1,
 533                           &quot;module m1x { exports api1; }&quot;,
 534                           &quot;package api1; public class Api { }&quot;,
 535                           &quot;package clash; public class C { }&quot;);
 536 
 537         writeFile(&quot;1&quot;, m1, &quot;api1&quot;, &quot;api&quot;);
 538         writeFile(&quot;2&quot;, m1, &quot;clash&quot;, &quot;clash&quot;);
 539 
 540         Path m2 = moduleSrc.resolve(&quot;m2x&quot;);
 541 
 542         tb.writeJavaFiles(m2,
 543                           &quot;module m2x { requires m1x; exports api2; }&quot;,
 544                           &quot;package api2; public class Api { }&quot;,
 545                           &quot;package clash; public class C { }&quot;);
 546 
 547         writeFile(&quot;3&quot;, m2, &quot;api2&quot;, &quot;api&quot;);
 548         writeFile(&quot;4&quot;, m2, &quot;clash&quot;, &quot;api&quot;);
 549 
 550         //passing testcases:
 551         for (String module : Arrays.asList(&quot;&quot;, &quot;m1x/&quot;)) {
 552             for (String originating : Arrays.asList(&quot;&quot;, &quot;, jlObject&quot;)) {
 553                 tb.writeJavaFiles(m1,
 554                                   &quot;package test; class Test { api1.Impl i; }&quot;);
 555 
 556                 //source:
 557                 runCompiler(base,
 558                             moduleSrc,
 559                             classes,
 560                             &quot;createSource(() -&gt; filer.createSourceFile(\&quot;&quot; + module + &quot;api1.Impl\&quot;&quot; + originating + &quot;), \&quot;api1.Impl\&quot;, \&quot;package api1; public class Impl {}\&quot;)&quot;,
 561                             &quot;--module-source-path&quot;, moduleSrc.toString());
 562                 assertFileExists(classes, &quot;m1x&quot;, &quot;api1&quot;, &quot;Impl.class&quot;);
 563 
 564                 //class:
 565                 runCompiler(base,
 566                             moduleSrc,
 567                             classes,
 568                             &quot;createClass(() -&gt; filer.createClassFile(\&quot;&quot; + module + &quot;api1.Impl\&quot;&quot; + originating + &quot;), \&quot;api1.Impl\&quot;, \&quot;package api1; public class Impl {}\&quot;)&quot;,
 569                             &quot;--module-source-path&quot;, moduleSrc.toString());
 570                 assertFileExists(classes, &quot;m1x&quot;, &quot;api1&quot;, &quot;Impl.class&quot;);
 571 
 572                 tb.deleteFiles(m1.resolve(&quot;test&quot;).resolve(&quot;Test.java&quot;));
 573 
 574                 //resource class output:
 575                 runCompiler(base,
 576                             moduleSrc,
 577                             classes,
 578                             &quot;createSource(() -&gt; filer.createResource(StandardLocation.CLASS_OUTPUT, \&quot;&quot; + module + &quot;api1\&quot;, \&quot;impl\&quot;&quot; + originating + &quot;), \&quot;impl\&quot;, \&quot;impl\&quot;)&quot;,
 579                             &quot;--module-source-path&quot;, moduleSrc.toString());
 580                 assertFileExists(classes, &quot;m1x&quot;, &quot;api1&quot;, &quot;impl&quot;);
 581             }
 582         }
 583 
 584         //get resource module source path:
 585         runCompiler(base,
 586                     m1,
 587                     classes,
 588                     &quot;doReadResource(() -&gt; filer.getResource(StandardLocation.MODULE_SOURCE_PATH, \&quot;m1x/api1\&quot;, \&quot;api\&quot;), \&quot;1\&quot;)&quot;,
 589                     &quot;--module-source-path&quot;, moduleSrc.toString());
 590 
 591         //can generate resources to the single root module:
 592         runCompiler(base,
 593                     m1,
 594                     classes,
 595                     &quot;createSource(() -&gt; filer.createResource(StandardLocation.CLASS_OUTPUT, \&quot;m1x/impl\&quot;, \&quot;impl\&quot;), \&quot;impl\&quot;, \&quot;impl\&quot;)&quot;,
 596                     &quot;--module-source-path&quot;, moduleSrc.toString());
 597         assertFileExists(classes, &quot;m1x&quot;, &quot;impl&quot;, &quot;impl&quot;);
 598 
 599         //check --default-module-for-created-files option:
 600         for (String pack : Arrays.asList(&quot;clash&quot;, &quot;doesnotexist&quot;)) {
 601             tb.writeJavaFiles(m1,
 602                               &quot;package test; class Test { &quot; + pack + &quot;.Pass i; }&quot;);
 603             runCompiler(base,
 604                         moduleSrc,
 605                         classes,
 606                         &quot;createSource(() -&gt; filer.createSourceFile(\&quot;&quot; + pack + &quot;.Pass\&quot;),&quot; +
 607                         &quot;                                          \&quot;&quot; + pack + &quot;.Pass\&quot;,&quot; +
 608                         &quot;                                          \&quot;package &quot; + pack + &quot;;&quot; +
 609                         &quot;                                            public class Pass { }\&quot;)&quot;,
 610                         &quot;--module-source-path&quot;, moduleSrc.toString(),
 611                         &quot;--default-module-for-created-files=m1x&quot;);
 612             assertFileExists(classes, &quot;m1x&quot;, pack, &quot;Pass.class&quot;);
 613             assertFileNotExists(classes, &quot;m2x&quot;, pack, &quot;Pass.class&quot;);
 614 
 615             runCompiler(base,
 616                         moduleSrc,
 617                         classes,
 618                         &quot;createClass(() -&gt; filer.createClassFile(\&quot;&quot; + pack + &quot;.Pass\&quot;),&quot; +
 619                         &quot;                                        \&quot;&quot; + pack + &quot;.Pass\&quot;,&quot; +
 620                         &quot;                                        \&quot;package &quot; + pack + &quot;;&quot; +
 621                         &quot;                                          public class Pass { }\&quot;)&quot;,
 622                         &quot;--module-source-path&quot;, moduleSrc.toString(),
 623                         &quot;--default-module-for-created-files=m1x&quot;);
 624             assertFileExists(classes, &quot;m1x&quot;, pack, &quot;Pass.class&quot;);
 625             assertFileNotExists(classes, &quot;m2x&quot;, pack, &quot;Pass.class&quot;);
 626 
 627             tb.deleteFiles(m1.resolve(&quot;test&quot;).resolve(&quot;Test.java&quot;));
 628 
 629             runCompiler(base,
 630                         moduleSrc,
 631                         classes,
 632                         &quot;createSource(() -&gt; filer.createResource(StandardLocation.CLASS_OUTPUT,&quot; +
 633                         &quot;                                        \&quot;&quot; + pack + &quot;\&quot;, \&quot;impl\&quot;), \&quot;impl\&quot;, \&quot;impl\&quot;)&quot;,
 634                         &quot;--module-source-path&quot;, moduleSrc.toString(),
 635                         &quot;--default-module-for-created-files=m1x&quot;);
 636             assertFileExists(classes, &quot;m1x&quot;, pack, &quot;impl&quot;);
 637             assertFileNotExists(classes, &quot;m2x&quot;, pack, &quot;impl&quot;);
 638 
 639             runCompiler(base,
 640                         moduleSrc,
 641                         classes,
 642                         &quot;doReadResource(() -&gt; filer.getResource(StandardLocation.CLASS_OUTPUT,&quot; +
 643                         &quot;                                       \&quot;&quot; + pack + &quot;\&quot;, \&quot;resource\&quot;), \&quot;1\&quot;)&quot;,
 644                         p -&gt; writeFile(&quot;1&quot;, p.resolve(&quot;m1x&quot;), pack, &quot;resource&quot;),
 645                         &quot;--module-source-path&quot;, moduleSrc.toString(),
 646                         &quot;--default-module-for-created-files=m1x&quot;);
 647         }
 648 
 649         //wrong default module:
 650         runCompiler(base,
 651                     moduleSrc,
 652                     classes,
 653                     &quot;expectFilerException(() -&gt; filer.createResource(StandardLocation.CLASS_OUTPUT,&quot; +
 654                     &quot;                                                \&quot;clash\&quot;, \&quot;impl\&quot;))&quot;,
 655                     &quot;--module-source-path&quot;, moduleSrc.toString(),
 656                     &quot;--default-module-for-created-files=doesnotexist&quot;);
 657 
 658         String[] failingCases = {
 659             //must not generate to unnamed package:
 660             &quot;expectFilerException(() -&gt; filer.createSourceFile(\&quot;Fail\&quot;))&quot;,
 661             &quot;expectFilerException(() -&gt; filer.createClassFile(\&quot;Fail\&quot;))&quot;,
 662             &quot;expectFilerException(() -&gt; filer.createSourceFile(\&quot;m1x/Fail\&quot;))&quot;,
 663             &quot;expectFilerException(() -&gt; filer.createClassFile(\&quot;m1x/Fail\&quot;))&quot;,
 664 
 665             //cannot infer module name, package clash:
 666             &quot;expectFilerException(() -&gt; filer.createSourceFile(\&quot;clash.Fail\&quot;))&quot;,
 667             &quot;expectFilerException(() -&gt; filer.createClassFile(\&quot;clash.Fail\&quot;))&quot;,
 668             &quot;expectFilerException(() -&gt; filer.createResource(StandardLocation.CLASS_OUTPUT, \&quot;clash\&quot;, \&quot;impl\&quot;))&quot;,
 669             &quot;expectFilerException(() -&gt; filer.getResource(StandardLocation.CLASS_OUTPUT, \&quot;clash\&quot;, \&quot;impl\&quot;))&quot;,
 670 
 671             //cannot infer module name, package does not exist:
 672             &quot;expectFilerException(() -&gt; filer.createSourceFile(\&quot;doesnotexist.Fail\&quot;))&quot;,
 673             &quot;expectFilerException(() -&gt; filer.createClassFile(\&quot;doesnotexist.Fail\&quot;))&quot;,
 674             &quot;expectFilerException(() -&gt; filer.createResource(StandardLocation.CLASS_OUTPUT, \&quot;doesnotexist\&quot;, \&quot;impl\&quot;))&quot;,
 675             &quot;expectFilerException(() -&gt; filer.getResource(StandardLocation.CLASS_OUTPUT, \&quot;doesnotexist\&quot;, \&quot;impl\&quot;))&quot;,
 676 
 677             //cannot generate sources/classes to modules that are not root modules:
 678             &quot;expectFilerException(() -&gt; filer.createSourceFile(\&quot;java.base/fail.Fail\&quot;))&quot;,
 679             &quot;expectFilerException(() -&gt; filer.createClassFile(\&quot;java.base/fail.Fail\&quot;))&quot;,
 680 
 681             //cannot read from module locations if module not given and not inferable:
 682             &quot;expectFilerException(() -&gt; filer.getResource(StandardLocation.SYSTEM_MODULES, \&quot;fail\&quot;, \&quot;Fail\&quot;))&quot;,
 683 
 684             //wrong module given:
 685             &quot;expectException(() -&gt; filer.getResource(StandardLocation.SYSTEM_MODULES, \&quot;java.compiler/java.lang\&quot;, \&quot;Object.class\&quot;))&quot;,
 686         };
 687 
 688         for (String failingCode : failingCases) {
 689             System.err.println(&quot;failing code: &quot; + failingCode);
 690             runCompiler(base,
 691                         moduleSrc,
 692                         classes,
 693                         failingCode,
 694                         &quot;--module-source-path&quot;, moduleSrc.toString());
 695         }
 696     }
 697 
 698     public static abstract class GeneratingAP extends AbstractProcessor {
 699 
 700         public void createSource(CreateFileObject file, String name, String content) {
 701             try (Writer out = file.create().openWriter()) {
 702                 out.write(content);
 703             } catch (IOException ex) {
 704                 throw new IllegalStateException(ex);
 705             }
 706         }
 707 
 708         public void createClass(CreateFileObject file, String name, String content) {
 709             String fileNameStub = name.replace(&quot;.&quot;, File.separator);
 710 
 711             try (OutputStream out = file.create().openOutputStream()) {
 712                 Path scratch = Files.createDirectories(Paths.get(&quot;&quot;));
 713                 Path scratchSrc = scratch.resolve(fileNameStub + &quot;.java&quot;).toAbsolutePath();
 714 
 715                 Files.createDirectories(scratchSrc.getParent());
 716 
 717                 try (Writer w = Files.newBufferedWriter(scratchSrc)) {
 718                     w.write(content);
 719                 }
 720 
 721                 Path scratchClasses = scratch.resolve(&quot;classes&quot;);
 722 
 723                 Files.createDirectories(scratchClasses);
 724 
 725                 JavaCompiler comp = ToolProvider.getSystemJavaCompiler();
 726                 try (StandardJavaFileManager fm = comp.getStandardFileManager(null, null, null)) {
 727                     List&lt;String&gt; options = List.of(&quot;-d&quot;, scratchClasses.toString());
 728                     Iterable&lt;? extends JavaFileObject&gt; files = fm.getJavaFileObjects(scratchSrc);
 729                     CompilationTask task = comp.getTask(null, fm, null, options, null, files);
 730 
 731                     if (!task.call()) {
 732                         throw new AssertionError(&quot;compilation failed&quot;);
 733                     }
 734                 }
 735 
 736                 Path classfile = scratchClasses.resolve(fileNameStub + &quot;.class&quot;);
 737 
 738                 Files.copy(classfile, out);
 739             } catch (IOException ex) {
 740                 throw new IllegalStateException(ex);
 741             }
 742         }
 743 
 744         public void doReadResource(CreateFileObject file, String expectedContent) {
 745             try {
 746                 StringBuilder actualContent = new StringBuilder();
 747 
 748                 try (Reader r = file.create().openReader(true)) {
 749                     int read;
 750 
 751                     while ((read = r.read()) != (-1)) {
 752                         actualContent.append((char) read);
 753                     }
 754 
 755                 }
 756 
 757                 assertEquals(expectedContent, actualContent.toString());
 758             } catch (IOException ex) {
 759                 throw new IllegalStateException(ex);
 760             }
 761         }
 762 
 763         public void checkResourceExists(CreateFileObject file) {
 764             try {
 765                 file.create().openInputStream().close();
 766             } catch (IOException ex) {
 767                 throw new IllegalStateException(ex);
 768             }
 769         }
 770 
 771         public interface CreateFileObject {
 772             public FileObject create() throws IOException;
 773         }
 774 
 775         public void expectFilerException(Callable&lt;Object&gt; c) {
 776             try {
 777                 c.call();
 778                 throw new AssertionError(&quot;Expected exception not thrown&quot;);
 779             } catch (FilerException ex) {
 780                 //expected
 781             } catch (Exception ex) {
 782                 throw new IllegalStateException(ex);
 783             }
 784         }
 785 
 786         public void expectException(Callable&lt;Object&gt; c) {
 787             try {
 788                 c.call();
 789                 throw new AssertionError(&quot;Expected exception not thrown&quot;);
 790             } catch (IOException ex) {
 791                 //expected
 792             } catch (Exception ex) {
 793                 throw new IllegalStateException(ex);
 794             }
 795         }
 796 
 797         @Override
 798         public SourceVersion getSupportedSourceVersion() {
 799             return SourceVersion.latest();
 800         }
 801 
 802     }
 803 
 804     @Test
 805     public void testGenerateSingleModule(Path base) throws Exception {
 806         Path classes = base.resolve(&quot;classes&quot;);
 807 
 808         Files.createDirectories(classes);
 809 
 810         Path src = base.resolve(&quot;module-src&quot;);
 811         Path m1 = src.resolve(&quot;m1x&quot;);
 812 
 813         tb.writeJavaFiles(m1,
 814                           &quot;module m1x { }&quot;,
 815                           &quot;package test; class Test { impl.Impl i; }&quot;);
 816         Path m2 = src.resolve(&quot;m2x&quot;);
 817 
 818         tb.writeJavaFiles(m2,
 819                           &quot;module m2x { }&quot;);
 820 
 821         for (String[] options : new String[][] {new String[] {&quot;-sourcepath&quot;, m1.toString()},
 822                                                 new String[] {&quot;--module-source-path&quot;, src.toString()}}) {
 823             String modulePath = options[0].equals(&quot;--module-source-path&quot;) ? &quot;m1x&quot; : &quot;&quot;;
 824             //passing testcases:
 825             for (String module : Arrays.asList(&quot;&quot;, &quot;m1x/&quot;)) {
 826                 for (String originating : Arrays.asList(&quot;&quot;, &quot;, jlObject&quot;)) {
 827                     tb.writeJavaFiles(m1,
 828                                       &quot;package test; class Test { impl.Impl i; }&quot;);
 829 
 830                     //source:
 831                     runCompiler(base,
 832                                 m1,
 833                                 classes,
 834                                 &quot;createSource(() -&gt; filer.createSourceFile(\&quot;&quot; + module + &quot;impl.Impl\&quot;&quot; + originating + &quot;), \&quot;impl.Impl\&quot;, \&quot;package impl; public class Impl {}\&quot;)&quot;,
 835                                 options);
 836                     assertFileExists(classes, modulePath, &quot;impl&quot;, &quot;Impl.class&quot;);
 837 
 838                     //class:
 839                     runCompiler(base,
 840                                 m1,
 841                                 classes,
 842                                 &quot;createClass(() -&gt; filer.createClassFile(\&quot;&quot; + module + &quot;impl.Impl\&quot;&quot; + originating + &quot;), \&quot;impl.Impl\&quot;, \&quot;package impl; public class Impl {}\&quot;)&quot;,
 843                                 options);
 844                     assertFileExists(classes, modulePath, &quot;impl&quot;, &quot;Impl.class&quot;);
 845 
 846                     tb.deleteFiles(m1.resolve(&quot;test&quot;).resolve(&quot;Test.java&quot;));
 847 
 848                     //resource class output:
 849                     runCompiler(base,
 850                                 m1,
 851                                 classes,
 852                                 &quot;createSource(() -&gt; filer.createResource(StandardLocation.CLASS_OUTPUT, \&quot;impl\&quot;, \&quot;impl\&quot;&quot; + originating + &quot;), \&quot;impl\&quot;, \&quot;impl\&quot;)&quot;,
 853                                 options);
 854                     assertFileExists(classes, modulePath, &quot;impl&quot;, &quot;impl&quot;);
 855                 }
 856             }
 857         }
 858 
 859         //get resource source path:
 860         writeFile(&quot;1&quot;, m1, &quot;impl&quot;, &quot;resource&quot;);
 861         runCompiler(base,
 862                     m1,
 863                     classes,
 864                     &quot;doReadResource(() -&gt; filer.getResource(StandardLocation.SOURCE_PATH, \&quot;impl\&quot;, \&quot;resource\&quot;), \&quot;1\&quot;)&quot;,
 865                     &quot;-sourcepath&quot;, m1.toString());
 866         //must not specify module when reading non-module oriented locations:
 867         runCompiler(base,
 868                     m1,
 869                     classes,
 870                     &quot;expectFilerException(() -&gt; filer.getResource(StandardLocation.SOURCE_PATH, \&quot;m1x/impl\&quot;, \&quot;resource\&quot;))&quot;,
 871                     &quot;-sourcepath&quot;, m1.toString());
 872 
 873         tb.deleteFiles(m1.resolve(&quot;impl&quot;).resolve(&quot;resource&quot;));
 874 
 875         //can read resources from the system module path if module name given:
 876         runCompiler(base,
 877                     m1,
 878                     classes,
 879                     &quot;checkResourceExists(() -&gt; filer.getResource(StandardLocation.SYSTEM_MODULES, \&quot;java.base/java.lang\&quot;, \&quot;Object.class\&quot;))&quot;,
 880                     &quot;-sourcepath&quot;, m1.toString());
 881 
 882         //can read resources from the system module path if module inferable:
 883         runCompiler(base,
 884                     m1,
 885                     classes,
 886                     &quot;expectFilerException(() -&gt; filer.getResource(StandardLocation.SYSTEM_MODULES, \&quot;java.lang\&quot;, \&quot;Object.class\&quot;))&quot;,
 887                     &quot;-sourcepath&quot;, m1.toString());
 888 
 889         //cannot generate resources to modules that are not root modules:
 890         runCompiler(base,
 891                     m1,
 892                     classes,
 893                     &quot;expectFilerException(() -&gt; filer.createResource(StandardLocation.CLASS_OUTPUT, \&quot;java.base/fail\&quot;, \&quot;Fail\&quot;))&quot;,
 894                     &quot;--module-source-path&quot;, src.toString());
 895 
 896         //can generate resources to the single root module:
 897         runCompiler(base,
 898                     m1,
 899                     classes,
 900                     &quot;createSource(() -&gt; filer.createResource(StandardLocation.CLASS_OUTPUT, \&quot;impl\&quot;, \&quot;impl\&quot;), \&quot;impl\&quot;, \&quot;impl\&quot;)&quot;,
 901                     &quot;--module-source-path&quot;, src.toString());
 902         assertFileExists(classes, &quot;m1x&quot;, &quot;impl&quot;, &quot;impl&quot;);
 903 
 904         String[] failingCases = {
 905             //must not generate to unnamed package:
 906             &quot;expectFilerException(() -&gt; filer.createSourceFile(\&quot;Fail\&quot;))&quot;,
 907             &quot;expectFilerException(() -&gt; filer.createClassFile(\&quot;Fail\&quot;))&quot;,
 908             &quot;expectFilerException(() -&gt; filer.createSourceFile(\&quot;m1x/Fail\&quot;))&quot;,
 909             &quot;expectFilerException(() -&gt; filer.createClassFile(\&quot;m1x/Fail\&quot;))&quot;,
 910 
 911             //cannot generate sources/classes to modules that are not root modules:
 912             &quot;expectFilerException(() -&gt; filer.createSourceFile(\&quot;java.base/fail.Fail\&quot;))&quot;,
 913             &quot;expectFilerException(() -&gt; filer.createClassFile(\&quot;java.base/fail.Fail\&quot;))&quot;,
 914 
 915             //cannot specify module name for class output when not in the multi-module mode:
 916             &quot;expectFilerException(() -&gt; filer.createResource(StandardLocation.CLASS_OUTPUT, \&quot;m1x/fail\&quot;, \&quot;Fail\&quot;))&quot;,
 917 
 918             //cannot read from module locations if module not given:
 919             &quot;expectFilerException(() -&gt; filer.getResource(StandardLocation.SYSTEM_MODULES, \&quot;fail\&quot;, \&quot;Fail\&quot;))&quot;,
 920 
 921             //wrong module given:
 922             &quot;expectException(() -&gt; filer.getResource(StandardLocation.SYSTEM_MODULES, \&quot;java.compiler/java.lang\&quot;, \&quot;Object.class\&quot;))&quot;,
 923         };
 924 
 925         for (String failingCode : failingCases) {
 926             System.err.println(&quot;failing code: &quot; + failingCode);
 927             runCompiler(base,
 928                         m1,
 929                         classes,
 930                         failingCode,
 931                         &quot;-sourcepath&quot;, m1.toString());
 932         }
 933 
 934         tb.deleteFiles(m1.resolve(&quot;module-info.java&quot;));
 935         tb.writeJavaFiles(m1,
 936                           &quot;package test; class Test { }&quot;);
 937 
 938         runCompiler(base,
 939                     m1,
 940                     classes,
 941                     &quot;expectFilerException(() -&gt; filer.createSourceFile(\&quot;m1x/impl.Impl\&quot;))&quot;,
 942                     &quot;-sourcepath&quot;, m1.toString(),
 943                     &quot;-source&quot;, &quot;8&quot;);
 944 
 945         runCompiler(base,
 946                     m1,
 947                     classes,
 948                     &quot;expectFilerException(() -&gt; filer.createClassFile(\&quot;m1x/impl.Impl\&quot;))&quot;,
 949                     &quot;-sourcepath&quot;, m1.toString(),
 950                     &quot;-source&quot;, &quot;8&quot;);
 951     }
 952 
 953     private void runCompiler(Path base, Path src, Path classes,
 954                              String code, String... options) throws IOException {
 955         runCompiler(base, src, classes, code, p -&gt; {}, options);
 956     }
 957 
 958     private void runCompiler(Path base, Path src, Path classes,
 959                              String code, Consumer&lt;Path&gt; generateToClasses,
 960                              String... options) throws IOException {
 961         Path apClasses = base.resolve(&quot;ap-classes&quot;);
 962         if (Files.exists(apClasses)) {
 963             tb.cleanDirectory(apClasses);
 964         } else {
 965             Files.createDirectories(apClasses);
 966         }
 967         compileAP(apClasses, code);
 968         if (Files.exists(classes)) {
 969             tb.cleanDirectory(classes);
 970         } else {
 971             Files.createDirectories(classes);
 972         }
 973         generateToClasses.accept(classes);
 974         List&lt;String&gt; opts = new ArrayList&lt;&gt;();
 975         opts.addAll(Arrays.asList(options));
 976         opts.add(&quot;-processorpath&quot;);
 977         opts.add(System.getProperty(&quot;test.class.path&quot;) + File.pathSeparator + apClasses.toString());
 978         opts.add(&quot;-processor&quot;);
 979         opts.add(&quot;AP&quot;);
 980         new JavacTask(tb)
 981           .options(opts)
 982           .outdir(classes)
 983           .files(findJavaFiles(src))
 984           .run()
 985           .writeAll();
 986     }
 987 
 988     private void compileAP(Path target, String code) {
 989         String processorCode =
 990             &quot;import java.util.*;\n&quot; +
 991             &quot;import javax.annotation.processing.*;\n&quot; +
 992             &quot;import javax.lang.model.*;\n&quot; +
 993             &quot;import javax.lang.model.element.*;\n&quot; +
 994             &quot;import javax.lang.model.type.*;\n&quot; +
 995             &quot;import javax.lang.model.util.*;\n&quot; +
 996             &quot;import javax.tools.*;\n&quot; +
 997             &quot;@SupportedAnnotationTypes(\&quot;*\&quot;)\n&quot; +
 998             &quot;public final class AP extends AnnotationProcessing.GeneratingAP {\n&quot; +
 999             &quot;\n&quot; +
1000             &quot;        int round;\n&quot; +
1001             &quot;\n&quot; +
1002             &quot;        @Override\n&quot; +
1003             &quot;        public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n&quot; +
1004             &quot;            if (round++ != 0)\n&quot; +
1005             &quot;                return false;\n&quot; +
1006             &quot;            Filer filer = processingEnv.getFiler();\n&quot; +
1007             &quot;            TypeElement jlObject = processingEnv.getElementUtils().getTypeElement(\&quot;java.lang.Object\&quot;);\n&quot; +
1008             code + &quot;;\n&quot; +
1009             &quot;            return false;\n&quot; +
1010             &quot;        }\n&quot; +
1011             &quot;    }\n&quot;;
1012         new JavacTask(tb)
1013           .options(&quot;-classpath&quot;, System.getProperty(&quot;test.class.path&quot;))
1014           .sources(processorCode)
1015           .outdir(target)
1016           .run()
1017           .writeAll();
1018     }
1019 
1020     @Test
1021     public void testGenerateInUnnamedModeAPI(Path base) throws Exception {
1022         Path classes = base.resolve(&quot;classes&quot;);
1023 
1024         Files.createDirectories(classes);
1025 
1026         Path src = base.resolve(&quot;src&quot;);
1027 
1028         tb.writeJavaFiles(src,
1029                           &quot;class T {}&quot;);
1030 
1031         new JavacTask(tb)
1032           .options(&quot;-processor&quot;, UnnamedModeAPITestAP.class.getName(),
1033                    &quot;-sourcepath&quot;, src.toString())
1034           .outdir(classes)
1035           .files(findJavaFiles(src))
1036           .run()
1037           .writeAll();
1038 
1039         assertFileExists(classes, &quot;Impl1.class&quot;);
1040         assertFileExists(classes, &quot;Impl2.class&quot;);
1041     }
1042 
1043     @Test
1044     public void testGenerateInNoModeAPI(Path base) throws Exception {
1045         Path classes = base.resolve(&quot;classes&quot;);
1046 
1047         Files.createDirectories(classes);
1048 
1049         Path src = base.resolve(&quot;src&quot;);
1050 
1051         tb.writeJavaFiles(src,
1052                           &quot;class T {}&quot;);
1053 
1054         new JavacTask(tb)
1055           .options(&quot;-processor&quot;, UnnamedModeAPITestAP.class.getName(),
1056                    &quot;-source&quot;, &quot;8&quot;, &quot;-target&quot;, &quot;8&quot;,
1057                    &quot;-sourcepath&quot;, src.toString())
1058           .outdir(classes)
1059           .files(findJavaFiles(src))
1060           .run()
1061           .writeAll();
1062 
1063         assertFileExists(classes, &quot;Impl1.class&quot;);
1064         assertFileExists(classes, &quot;Impl2.class&quot;);
1065     }
1066 
1067     @SupportedAnnotationTypes(&quot;*&quot;)
1068     public static final class UnnamedModeAPITestAP extends GeneratingAP {
1069 
1070         int round;
1071 
1072         @Override
1073         public synchronized void init(ProcessingEnvironment processingEnv) {
1074             super.init(processingEnv);
1075         }
1076 
1077         @Override
1078         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
1079             if (round++ != 0)
1080                 return false;
1081 
1082             Filer filer = processingEnv.getFiler();
1083 
1084             //must not generate to unnamed package:
1085             createSource(() -&gt; filer.createSourceFile(&quot;Impl1&quot;), &quot;Impl1&quot;, &quot;class Impl1 {}&quot;);
1086             createClass(() -&gt; filer.createClassFile(&quot;Impl2&quot;), &quot;Impl2&quot;, &quot;class Impl2 {}&quot;);
1087 
1088             return false;
1089         }
1090 
1091     }
1092 
1093     @Test
1094     public void testDisambiguateAnnotations(Path base) throws Exception {
1095         Path classes = base.resolve(&quot;classes&quot;);
1096 
1097         Files.createDirectories(classes);
1098 
1099         Path src = base.resolve(&quot;src&quot;);
1100         Path m1 = src.resolve(&quot;m1x&quot;);
1101 
1102         tb.writeJavaFiles(m1,
1103                           &quot;module m1x { exports api; }&quot;,
1104                           &quot;package api; public @interface A {}&quot;,
1105                           &quot;package api; public @interface B {}&quot;);
1106 
1107         Path m2 = src.resolve(&quot;m2x&quot;);
1108 
1109         tb.writeJavaFiles(m2,
1110                           &quot;module m2x { exports api; }&quot;,
1111                           &quot;package api; public @interface A {}&quot;,
1112                           &quot;package api; public @interface B {}&quot;);
1113 
1114         Path m3 = src.resolve(&quot;m3x&quot;);
1115 
1116         tb.writeJavaFiles(m3,
1117                           &quot;module m3x { requires m1x; }&quot;,
1118                           &quot;package impl; import api.*; @A @B public class T {}&quot;);
1119 
1120         Path m4 = src.resolve(&quot;m4x&quot;);
1121 
1122         tb.writeJavaFiles(m4,
1123                           &quot;module m4x { requires m2x; }&quot;,
1124                           &quot;package impl; import api.*; @A @B public class T {}&quot;);
1125 
1126         List&lt;String&gt; log;
1127         List&lt;String&gt; expected;
1128 
1129         log = new JavacTask(tb)
1130             .options(&quot;-processor&quot;, SelectAnnotationATestAP.class.getName() + &quot;,&quot; + SelectAnnotationBTestAP.class.getName(),
1131                      &quot;--module-source-path&quot;, src.toString(),
1132                      &quot;-m&quot;, &quot;m1x,m2x&quot;)
1133             .outdir(classes)
1134             .run()
1135             .writeAll()
1136             .getOutputLines(OutputKind.STDERR);
1137 
1138         expected = List.of(&quot;&quot;);
1139 
1140         if (!expected.equals(log)) {
1141             throw new AssertionError(&quot;Output does not match; output: &quot; + log);
1142         }
1143 
1144         log = new JavacTask(tb)
1145             .options(&quot;-processor&quot;, SelectAnnotationATestAP.class.getName() + &quot;,&quot; + SelectAnnotationBTestAP.class.getName(),
1146                      &quot;--module-source-path&quot;, src.toString(),
1147                      &quot;-m&quot;, &quot;m3x&quot;)
1148             .outdir(classes)
1149             .run()
1150             .writeAll()
1151             .getOutputLines(OutputKind.STDERR);
1152 
1153         expected = List.of(&quot;SelectAnnotationBTestAP&quot;,
1154                            &quot;SelectAnnotationBTestAP&quot;);
1155 
1156         if (!expected.equals(log)) {
1157             throw new AssertionError(&quot;Output does not match; output: &quot; + log);
1158         }
1159 
1160         log = new JavacTask(tb)
1161             .options(&quot;-processor&quot;, SelectAnnotationATestAP.class.getName() + &quot;,&quot; +
1162                                    SelectAnnotationBTestAP.class.getName() + &quot;,&quot; +
1163                                    SelectAnnotationAStrictTestAP.class.getName(),
1164                      &quot;--module-source-path&quot;, src.toString(),
1165                      &quot;-m&quot;, &quot;m4x&quot;)
1166             .outdir(classes)
1167             .run()
1168             .writeAll()
1169             .getOutputLines(OutputKind.STDERR);
1170 
1171         expected = List.of(&quot;SelectAnnotationATestAP&quot;,
1172                            &quot;SelectAnnotationBTestAP&quot;,
1173                            &quot;SelectAnnotationAStrictTestAP&quot;,
1174                            &quot;SelectAnnotationATestAP&quot;,
1175                            &quot;SelectAnnotationBTestAP&quot;,
1176                            &quot;SelectAnnotationAStrictTestAP&quot;);
1177 
1178         if (!expected.equals(log)) {
1179             throw new AssertionError(&quot;Output does not match; output: &quot; + log);
1180         }
1181     }
1182 
1183     @Test
1184     public void testDisambiguateAnnotationsUnnamedModule(Path base) throws Exception {
1185         Path classes = base.resolve(&quot;classes&quot;);
1186 
1187         Files.createDirectories(classes);
1188 
1189         Path src = base.resolve(&quot;src&quot;);
1190 
1191         tb.writeJavaFiles(src,
1192                           &quot;package api; public @interface A {}&quot;,
1193                           &quot;package api; public @interface B {}&quot;,
1194                           &quot;package impl; import api.*; @A @B public class T {}&quot;);
1195 
1196         List&lt;String&gt; log = new JavacTask(tb)
1197             .options(&quot;-processor&quot;, SelectAnnotationATestAP.class.getName() + &quot;,&quot; +
1198                                    SelectAnnotationBTestAP.class.getName() + &quot;,&quot; +
1199                                    SelectAnnotationAStrictTestAP.class.getName())
1200             .outdir(classes)
1201             .files(findJavaFiles(src))
1202             .run()
1203             .writeAll()
1204             .getOutputLines(OutputKind.STDERR);
1205 
1206         List&lt;String&gt; expected = List.of(&quot;SelectAnnotationBTestAP&quot;,
1207                                         &quot;SelectAnnotationBTestAP&quot;);
1208 
1209         if (!expected.equals(log)) {
1210             throw new AssertionError(&quot;Output does not match; output: &quot; + log);
1211         }
1212     }
1213 
1214     @Test
1215     public void testDisambiguateAnnotationsNoModules(Path base) throws Exception {
1216         Path classes = base.resolve(&quot;classes&quot;);
1217 
1218         Files.createDirectories(classes);
1219 
1220         Path src = base.resolve(&quot;src&quot;);
1221 
1222         tb.writeJavaFiles(src,
1223                           &quot;package api; public @interface A {}&quot;,
1224                           &quot;package api; public @interface B {}&quot;,
1225                           &quot;package impl; import api.*; @A @B public class T {}&quot;);
1226 
1227         List&lt;String&gt; log = new JavacTask(tb)
1228             .options(&quot;-processor&quot;, SelectAnnotationATestAP.class.getName() + &quot;,&quot; +
1229                                    SelectAnnotationBTestAP.class.getName() + &quot;,&quot; +
1230                                    SelectAnnotationAStrictTestAP.class.getName(),
1231                      &quot;-source&quot;, &quot;8&quot;, &quot;-target&quot;, &quot;8&quot;)
1232             .outdir(classes)
1233             .files(findJavaFiles(src))
1234             .run()
1235             .writeAll()
1236             .getOutputLines(OutputKind.STDERR);
1237 
1238         List&lt;String&gt; expected = List.of(&quot;SelectAnnotationATestAP&quot;,
1239                                         &quot;SelectAnnotationBTestAP&quot;,
1240                                         &quot;SelectAnnotationATestAP&quot;,
1241                                         &quot;SelectAnnotationBTestAP&quot;);
1242 
1243         if (!expected.equals(log)) {
1244             throw new AssertionError(&quot;Output does not match; output: &quot; + log);
1245         }
1246     }
1247 
1248     @SupportedAnnotationTypes(&quot;m2x/api.A&quot;)
1249     public static final class SelectAnnotationATestAP extends AbstractProcessor {
1250 
1251         @Override
1252         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
1253             System.err.println(&quot;SelectAnnotationATestAP&quot;);
1254 
1255             return false;
1256         }
1257 
1258     }
1259 
1260     @SupportedAnnotationTypes(&quot;api.B&quot;)
1261     public static final class SelectAnnotationBTestAP extends AbstractProcessor {
1262 
1263         @Override
1264         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
1265             System.err.println(&quot;SelectAnnotationBTestAP&quot;);
1266 
1267             return false;
1268         }
1269 
1270     }
1271 
1272     public static final class SelectAnnotationAStrictTestAP extends AbstractProcessor {
1273 
1274         @Override
1275         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
1276             System.err.println(&quot;SelectAnnotationAStrictTestAP&quot;);
1277 
1278             return false;
1279         }
1280 
1281         @Override
1282         public Set&lt;String&gt; getSupportedAnnotationTypes() {
1283             return Set.of(&quot;m2x/api.A&quot;);
1284         }
1285 
1286     }
1287 
1288     private static void writeFile(String content, Path base, String... pathElements) {
1289         try {
1290             Path file = resolveFile(base, pathElements);
1291 
1292             Files.createDirectories(file.getParent());
1293 
1294             try (Writer out = Files.newBufferedWriter(file)) {
1295                 out.append(content);
1296             }
1297         } catch (IOException ex) {
1298             throw new UncheckedIOException(ex);
1299         }
1300     }
1301 
1302     @Test
1303     public void testUnboundLookup(Path base) throws Exception {
1304         Path src = base.resolve(&quot;src&quot;);
1305 
1306         tb.writeJavaFiles(src,
1307                           &quot;package impl.conflict.src; public class Impl { }&quot;);
1308 
1309         Path moduleSrc = base.resolve(&quot;module-src&quot;);
1310         Path m1 = moduleSrc.resolve(&quot;m1x&quot;);
1311         Path m2 = moduleSrc.resolve(&quot;m2x&quot;);
1312 
1313         Path classes = base.resolve(&quot;classes&quot;);
1314         Path cpClasses = base.resolve(&quot;cpClasses&quot;);
1315 
1316         Files.createDirectories(classes);
1317         Files.createDirectories(cpClasses);
1318 
1319         tb.writeJavaFiles(m1,
1320                           &quot;module m1x { }&quot;,
1321                           &quot;package impl1; public class Impl { }&quot;,
1322                           &quot;package impl.conflict.module; class Impl { }&quot;,
1323                           &quot;package impl.conflict.clazz; public class pkg { public static class I { } }&quot;,
1324                           &quot;package impl.conflict.src; public class Impl { }&quot;,
1325                           &quot;package nested.pack.pack; public class Impl { }&quot;,
1326                           &quot;package unique.nested; public class Impl { }&quot;);
1327 
1328         tb.writeJavaFiles(m2,
1329                           &quot;module m2x { }&quot;,
1330                           &quot;package impl2; public class Impl { }&quot;,
1331                           &quot;package impl.conflict.module; class Impl { }&quot;,
1332                           &quot;package impl.conflict; public class clazz { public static class pkg { } }&quot;,
1333                           &quot;package nested.pack; public class Impl { }&quot;);
1334 
1335         //from source:
1336         String log = new JavacTask(tb)
1337             .options(&quot;--module-source-path&quot;, moduleSrc.toString(),
1338                      &quot;--source-path&quot;, src.toString(),
1339                      &quot;-processorpath&quot;, System.getProperty(&quot;test.class.path&quot;),
1340                      &quot;-processor&quot;, UnboundLookup.class.getName(),
1341                      &quot;-XDrawDiagnostics&quot;)
1342             .outdir(classes)
1343             .files(findJavaFiles(moduleSrc))
1344             .run()
1345             .writeAll()
1346             .getOutput(OutputKind.DIRECT);
1347 
1348         String moduleImplConflictString =
1349                 &quot;- compiler.note.multiple.elements: getTypeElement, impl.conflict.module.Impl, m2x, m1x&quot;;
1350         String srcConflictString =
1351                 &quot;- compiler.note.multiple.elements: getTypeElement, impl.conflict.src.Impl, m1x, unnamed module&quot;;
1352 
1353         if (!log.contains(moduleImplConflictString) ||
1354             !log.contains(srcConflictString)) {
1355             throw new AssertionError(&quot;Expected output not found: &quot; + log);
1356         }
1357 
1358         if (log.split(Pattern.quote(moduleImplConflictString)).length &gt; 2) {
1359             throw new AssertionError(&quot;Too many warnings in: &quot; + log);
1360         }
1361 
1362         new JavacTask(tb)
1363             .options(&quot;--source-path&quot;, src.toString())
1364             .outdir(cpClasses)
1365             .files(findJavaFiles(src))
1366             .run()
1367             .writeAll();
1368 
1369         //from classfiles:
1370         new JavacTask(tb)
1371             .options(&quot;--module-path&quot;, classes.toString(),
1372                      &quot;--class-path&quot;, cpClasses.toString(),
1373                      &quot;--add-modules&quot;, &quot;m1x,m2x&quot;,
1374                      &quot;-processorpath&quot;, System.getProperty(&quot;test.class.path&quot;),
1375                      &quot;-processor&quot;, UnboundLookup.class.getName(),
1376                      &quot;-proc:only&quot;)
1377             .classes(&quot;java.lang.Object&quot;)
1378             .run()
1379             .writeAll();
1380 
1381         //source 8:
1382         new JavacTask(tb)
1383             .options(&quot;--source-path&quot;, src.toString(),
1384                      &quot;-source&quot;, &quot;8&quot;,
1385                      &quot;-processorpath&quot;, System.getProperty(&quot;test.class.path&quot;),
1386                      &quot;-processor&quot;, UnboundLookup8.class.getName())
1387             .outdir(cpClasses)
1388             .files(findJavaFiles(src))
1389             .run()
1390             .writeAll();
1391 
1392         //from source:
1393         new JavacTask(tb)
1394             .options(&quot;--module-source-path&quot;, moduleSrc.toString(),
1395                      &quot;--source-path&quot;, src.toString(),
1396                      &quot;-processorpath&quot;, System.getProperty(&quot;test.class.path&quot;),
1397                      &quot;-processor&quot;, UnboundLookupGenerate.class.getName(),
1398                      &quot;-XDrawDiagnostics&quot;)
1399             .outdir(classes)
1400             .files(findJavaFiles(moduleSrc))
1401             .run()
1402             .writeAll()
1403             .getOutput(OutputKind.DIRECT);
1404 
1405     }
1406 
1407     @SupportedAnnotationTypes(&quot;*&quot;)
1408     public static final class UnboundLookup extends AbstractProcessor {
1409 
1410         @Override
1411         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
1412             assertTypeElementExists(&quot;impl1.Impl&quot;, &quot;m1x&quot;);
1413             assertPackageElementExists(&quot;impl1&quot;, &quot;m1x&quot;);
1414             assertTypeElementExists(&quot;impl2.Impl&quot;, &quot;m2x&quot;);
1415             assertTypeElementExists(&quot;impl.conflict.clazz.pkg.I&quot;, &quot;m1x&quot;);
1416             assertTypeElementExists(&quot;impl.conflict.clazz&quot;, &quot;m2x&quot;);
1417             assertPackageElementExists(&quot;impl.conflict.clazz&quot;, &quot;m1x&quot;);
1418             assertPackageElementExists(&quot;impl2&quot;, &quot;m2x&quot;);
1419             assertPackageElementExists(&quot;nested.pack.pack&quot;, &quot;m1x&quot;);
1420             assertPackageElementExists(&quot;nested.pack&quot;, &quot;m2x&quot;);
1421             assertTypeElementExists(&quot;unique.nested.Impl&quot;, &quot;m1x&quot;);
1422             assertTypeElementNotFound(&quot;impl.conflict.module.Impl&quot;);
1423             assertTypeElementNotFound(&quot;impl.conflict.module.Impl&quot;); //check that the warning/note is produced only once
1424             assertPackageElementNotFound(&quot;impl.conflict.module&quot;);
1425             assertTypeElementNotFound(&quot;impl.conflict.src.Impl&quot;);
1426             assertPackageElementNotFound(&quot;impl.conflict.src&quot;);
1427             assertTypeElementNotFound(&quot;impl.conflict.clazz.pkg&quot;);
1428             assertPackageElementNotFound(&quot;unique&quot;); //do not return packages without members in module mode
1429             assertTypeElementNotFound(&quot;nested&quot;); //cannot distinguish between m1x and m2x
1430 
1431             return false;
1432         }
1433 
1434         private void assertTypeElementExists(String name, String expectedModule) {
1435             assertElementExists(name, &quot;class&quot;, processingEnv.getElementUtils() :: getTypeElement, expectedModule);
1436         }
1437 
1438         private void assertPackageElementExists(String name, String expectedModule) {
1439             assertElementExists(name, &quot;package&quot;, processingEnv.getElementUtils() :: getPackageElement, expectedModule);
1440         }
1441 
1442         private void assertElementExists(String name, String type, Function&lt;String, Element&gt; getter, String expectedModule) {
1443             Element clazz = getter.apply(name);
1444 
1445             if (clazz == null) {
1446                 throw new AssertionError(&quot;No &quot; + name + &quot; &quot; + type + &quot; found.&quot;);
1447             }
1448 
1449             ModuleElement mod = processingEnv.getElementUtils().getModuleOf(clazz);
1450 
1451             if (!mod.getQualifiedName().contentEquals(expectedModule)) {
1452                 throw new AssertionError(name + &quot; found in an unexpected module: &quot; + mod.getQualifiedName());
1453             }
1454         }
1455 
1456         private void assertTypeElementNotFound(String name) {
1457             assertElementNotFound(name, processingEnv.getElementUtils() :: getTypeElement);
1458         }
1459 
1460         private void assertPackageElementNotFound(String name) {
1461             assertElementNotFound(name, processingEnv.getElementUtils() :: getPackageElement);
1462         }
1463 
1464         private void assertElementNotFound(String name, Function&lt;String, Element&gt; getter) {
1465             Element found = getter.apply(name);
1466 
1467             if (found != null) {
1468                 fail(&quot;Element found unexpectedly: &quot; + found);
1469             }
1470         }
1471 
1472         @Override
1473         public SourceVersion getSupportedSourceVersion() {
1474             return SourceVersion.latest();
1475         }
1476 
1477     }
1478 
1479     @SupportedAnnotationTypes(&quot;*&quot;)
1480     public static final class UnboundLookup8 extends AbstractProcessor {
1481 
1482         @Override
1483         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
1484             if (processingEnv.getElementUtils().getTypeElement(&quot;impl.conflict.src.Impl&quot;) == null) {
1485                 throw new AssertionError(&quot;impl.conflict.src.Impl.&quot;);
1486             }
1487 
1488             if (processingEnv.getElementUtils().getModuleElement(&quot;java.base&quot;) != null) {
1489                 throw new AssertionError(&quot;getModuleElement != null for -source 8&quot;);
1490             }
1491 
1492             return false;
1493         }
1494 
1495         @Override
1496         public SourceVersion getSupportedSourceVersion() {
1497             return SourceVersion.latest();
1498         }
1499 
1500     }
1501 
1502     @SupportedAnnotationTypes(&quot;*&quot;)
1503     public static final class UnboundLookupGenerate extends AbstractProcessor {
1504 
1505         @Override
1506         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
1507             if (processingEnv.getElementUtils().getTypeElement(&quot;nue.Nue&quot;) == null) {
1508                 try (Writer w = processingEnv.getFiler().createSourceFile(&quot;m1x/nue.Nue&quot;).openWriter()) {
1509                     w.write(&quot;package nue; public class Nue {}&quot;);
1510                 } catch (IOException ex) {
1511                     throw new IllegalStateException(ex);
1512                 }
1513             }
1514 
1515             return false;
1516         }
1517 
1518         @Override
1519         public SourceVersion getSupportedSourceVersion() {
1520             return SourceVersion.latest();
1521         }
1522 
1523     }
1524 
1525     @Test
1526     public void testWrongDefaultTargetModule(Path base) throws Exception {
1527         Path src = base.resolve(&quot;src&quot;);
1528 
1529         tb.writeJavaFiles(src,
1530                           &quot;package test; public class Test { }&quot;);
1531 
1532         Path classes = base.resolve(&quot;classes&quot;);
1533 
1534         Files.createDirectories(classes);
1535 
1536         List&lt;String&gt; log = new JavacTask(tb)
1537             .options(&quot;--default-module-for-created-files=m!&quot;,
1538                      &quot;-XDrawDiagnostics&quot;)
1539             .outdir(classes)
1540             .files(findJavaFiles(src))
1541             .run(Task.Expect.FAIL)
1542             .writeAll()
1543             .getOutputLines(OutputKind.DIRECT);
1544 
1545         List&lt;String&gt; expected = Arrays.asList(
1546             &quot;- compiler.err.bad.name.for.option: --default-module-for-created-files, m!&quot;
1547         );
1548 
1549         if (!log.equals(expected)) {
1550             throw new AssertionError(&quot;Expected output not found.&quot;);
1551         }
1552     }
1553 
1554     private static void assertNonNull(String msg, Object val) {
1555         if (val == null) {
1556             throw new AssertionError(msg);
1557         }
1558     }
1559 
1560     private static void assertNull(String msg, Object val) {
1561         if (val != null) {
1562             throw new AssertionError(msg);
1563         }
1564     }
1565 
1566     private static void assertEquals(Object expected, Object actual) {
1567         if (!Objects.equals(expected, actual)) {
1568             throw new AssertionError(&quot;expected: &quot; + expected + &quot;; actual=&quot; + actual);
1569         }
1570     }
1571 
1572     private static void assertFileExists(Path base, String... pathElements) {
1573         Path file = resolveFile(base, pathElements);
1574 
1575         if (!Files.exists(file)) {
1576             throw new AssertionError(&quot;Expected file: &quot; + file + &quot; exist, but it does not.&quot;);
1577         }
1578     }
1579 
1580     private static void assertFileNotExists(Path base, String... pathElements) {
1581         Path file = resolveFile(base, pathElements);
1582 
1583         if (Files.exists(file)) {
1584             throw new AssertionError(&quot;Expected file: &quot; + file + &quot; exist, but it does not.&quot;);
1585         }
1586     }
1587 
1588     static Path resolveFile(Path base, String... pathElements) {
1589         Path file = base;
1590 
1591         for (String el : pathElements) {
1592             file = file.resolve(el);
1593         }
1594 
1595         return file;
1596     }
1597 
1598     private static void fail(String msg) {
1599         throw new AssertionError(msg);
1600     }
1601 
1602 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
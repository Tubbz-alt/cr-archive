<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/modules/MOptionTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 8146946 8176743
 27  * @summary implement javac -m option
 28  * @library /tools/lib
 29  * @modules
 30  *      jdk.compiler/com.sun.tools.javac.api
 31  *      jdk.compiler/com.sun.tools.javac.main
 32  * @build toolbox.ToolBox toolbox.JavacTask ModuleTestBase
 33  * @run main MOptionTest
 34  */
 35 
 36 import java.nio.file.Files;
 37 import java.nio.file.Path;
 38 import java.nio.file.attribute.FileTime;
 39 
 40 import toolbox.JavacTask;
 41 import toolbox.Task;
 42 import toolbox.ToolBox;
 43 
 44 public class MOptionTest extends ModuleTestBase {
 45     public static void main(String... args) throws Exception {
 46         new MOptionTest().runTests();
 47     }
 48 
 49     @Test
 50     public void testOneModule(Path base) throws Exception {
 51         Path src = base.resolve(&quot;src&quot;);
 52         Path m1 = src.resolve(&quot;m1x&quot;);
 53         Path build = base.resolve(&quot;build&quot;);
 54         Files.createDirectories(build);
 55 
 56         tb.writeJavaFiles(m1,
 57                 &quot;module m1x {}&quot;,
 58                 &quot;package test; public class Test {}&quot;);
 59 
 60         new JavacTask(tb)
 61                 .options(&quot;-m&quot;, &quot;m1x&quot;, &quot;--module-source-path&quot;, src.toString(), &quot;-d&quot;, build.toString())
 62                 .run(Task.Expect.SUCCESS)
 63                 .writeAll();
 64 
 65         Path moduleInfoClass = build.resolve(&quot;m1x/module-info.class&quot;);
 66         Path testTestClass = build.resolve(&quot;m1x/test/Test.class&quot;);
 67 
 68         FileTime moduleInfoTimeStamp = Files.getLastModifiedTime(moduleInfoClass);
 69         FileTime testTestTimeStamp = Files.getLastModifiedTime(testTestClass);
 70 
 71         Path moduleInfo = m1.resolve(&quot;module-info.java&quot;);
 72         if (moduleInfoTimeStamp.compareTo(Files.getLastModifiedTime(moduleInfo)) &lt; 0) {
 73             throw new AssertionError(&quot;Classfiles too old!&quot;);
 74         }
 75 
 76         Path testTest = m1.resolve(&quot;test/Test.java&quot;);
 77         if (testTestTimeStamp.compareTo(Files.getLastModifiedTime(testTest)) &lt; 0) {
 78             throw new AssertionError(&quot;Classfiles too old!&quot;);
 79         }
 80 
 81         Thread.sleep(2000); //timestamps
 82 
 83         new JavacTask(tb)
 84                 .options(&quot;-m&quot;, &quot;m1x&quot;, &quot;--module-source-path&quot;, src.toString(), &quot;-d&quot;, build.toString())
 85                 .run(Task.Expect.SUCCESS)
 86                 .writeAll();
 87 
 88         if (!moduleInfoTimeStamp.equals(Files.getLastModifiedTime(moduleInfoClass))) {
 89             throw new AssertionError(&quot;Classfile update!&quot;);
 90         }
 91 
 92         if (!testTestTimeStamp.equals(Files.getLastModifiedTime(testTestClass))) {
 93             throw new AssertionError(&quot;Classfile update!&quot;);
 94         }
 95 
 96         Thread.sleep(2000); //timestamps
 97 
 98         Files.setLastModifiedTime(testTest, FileTime.fromMillis(System.currentTimeMillis()));
 99 
100         new JavacTask(tb)
101                 .options(&quot;-m&quot;, &quot;m1x&quot;, &quot;--module-source-path&quot;, src.toString(), &quot;-d&quot;, build.toString())
102                 .run(Task.Expect.SUCCESS)
103                 .writeAll();
104 
105         if (!moduleInfoTimeStamp.equals(Files.getLastModifiedTime(moduleInfoClass))) {
106             throw new AssertionError(&quot;Classfile update!&quot;);
107         }
108 
109         if (Files.getLastModifiedTime(testTestClass).compareTo(Files.getLastModifiedTime(testTest)) &lt; 0) {
110             throw new AssertionError(&quot;Classfiles too old!&quot;);
111         }
112     }
113 
114     @Test
115     public void testNoOutputDir(Path base) throws Exception {
116         Path src = base.resolve(&quot;src&quot;);
117         Path m1 = src.resolve(&quot;m1x&quot;);
118         Path build = base.resolve(&quot;build&quot;);
119         Files.createDirectories(build);
120 
121         tb.writeJavaFiles(m1,
122                 &quot;module m1x {}&quot;,
123                 &quot;package test; public class Test {}&quot;);
124 
125         String log = new JavacTask(tb)
126                 .options(&quot;-XDrawDiagnostics&quot;,
127                     &quot;-m&quot;, &quot;m1x&quot;,
128                     &quot;--module-source-path&quot;, src.toString())
129                 .run(Task.Expect.FAIL)
130                 .writeAll()
131                 .getOutput(Task.OutputKind.DIRECT);
132 
133         if (!log.contains(&quot;- compiler.err.output.dir.must.be.specified.with.dash.m.option&quot;))
134             throw new Exception(&quot;expected output not found&quot;);
135     }
136 
137     @Test
138     public void testNoModuleSourcePath(Path base) throws Exception {
139         Path src = base.resolve(&quot;src&quot;);
140         Path m1 = src.resolve(&quot;m1x&quot;);
141         Path build = base.resolve(&quot;build&quot;);
142         Files.createDirectories(build);
143 
144         tb.writeJavaFiles(m1,
145                 &quot;module m1x {}&quot;,
146                 &quot;package test; public class Test {}&quot;);
147 
148         String log = new JavacTask(tb)
149                 .options(&quot;-XDrawDiagnostics&quot;,
150                         &quot;-m&quot;, &quot;m1x&quot;,
151                         &quot;-d&quot;, build.toString())
152                 .run(Task.Expect.FAIL)
153                 .writeAll()
154                 .getOutput(Task.OutputKind.DIRECT);
155 
156         if (!log.contains(&quot;- compiler.err.modulesourcepath.must.be.specified.with.dash.m.option&quot;))
157             throw new Exception(&quot;expected output not found&quot;);
158     }
159 
160     @Test
161     public void testMultiModule(Path base) throws Exception {
162         Path src = base.resolve(&quot;src&quot;);
163         Path m1 = src.resolve(&quot;m1x&quot;);
164         Path m2 = src.resolve(&quot;m2x&quot;);
165         Path build = base.resolve(&quot;build&quot;);
166         Files.createDirectories(build);
167 
168         tb.writeJavaFiles(m1,
169                 &quot;module m1x {}&quot;,
170                 &quot;package p1; public class C1 {}&quot;);
171 
172         tb.writeJavaFiles(m2,
173                 &quot;module m2x {}&quot;,
174                 &quot;package p2; public class C2 {}&quot;);
175 
176         new JavacTask(tb)
177                 .options(&quot;-m&quot;, &quot;m1x,m2x&quot;, &quot;--module-source-path&quot;, src.toString(), &quot;-d&quot;, build.toString())
178                 .run(Task.Expect.SUCCESS)
179                 .writeAll();
180 
181         Path m1ModuleInfoClass = build.resolve(&quot;m1x/module-info.class&quot;);
182         Path classC1 = build.resolve(&quot;m1x/p1/C1.class&quot;);
183 
184         Path m2ModuleInfoClass = build.resolve(&quot;m2x/module-info.class&quot;);
185         Path classC2 = build.resolve(&quot;m2x/p2/C2.class&quot;);
186 
187         FileTime m1ModuleInfoTimeStamp = Files.getLastModifiedTime(m1ModuleInfoClass);
188         FileTime C1TimeStamp = Files.getLastModifiedTime(classC1);
189 
190         FileTime m2ModuleInfoTimeStamp = Files.getLastModifiedTime(m2ModuleInfoClass);
191         FileTime C2TimeStamp = Files.getLastModifiedTime(classC2);
192 
193         Path m1ModuleInfo = m1.resolve(&quot;module-info.java&quot;);
194         Path m2ModuleInfo = m2.resolve(&quot;module-info.java&quot;);
195 
196         if (m1ModuleInfoTimeStamp.compareTo(Files.getLastModifiedTime(m1ModuleInfo)) &lt; 0) {
197             throw new AssertionError(&quot;Classfiles too old!&quot;);
198         }
199 
200         if (m2ModuleInfoTimeStamp.compareTo(Files.getLastModifiedTime(m2ModuleInfo)) &lt; 0) {
201             throw new AssertionError(&quot;Classfiles too old!&quot;);
202         }
203 
204         Path C1Source = m1.resolve(&quot;p1/C1.java&quot;);
205         Path C2Source = m2.resolve(&quot;p2/C2.java&quot;);
206 
207         if (C1TimeStamp.compareTo(Files.getLastModifiedTime(C1Source)) &lt; 0) {
208             throw new AssertionError(&quot;Classfiles too old!&quot;);
209         }
210 
211         if (C2TimeStamp.compareTo(Files.getLastModifiedTime(C2Source)) &lt; 0) {
212             throw new AssertionError(&quot;Classfiles too old!&quot;);
213         }
214 
215         Thread.sleep(2000); //timestamps
216 
217         new JavacTask(tb)
218                 .options(&quot;-m&quot;, &quot;m1x,m2x&quot;, &quot;--module-source-path&quot;, src.toString(), &quot;-d&quot;, build.toString())
219                 .run(Task.Expect.SUCCESS)
220                 .writeAll();
221 
222         if (!m1ModuleInfoTimeStamp.equals(Files.getLastModifiedTime(m1ModuleInfoClass))) {
223             throw new AssertionError(&quot;Classfile update!&quot;);
224         }
225 
226         if (!m2ModuleInfoTimeStamp.equals(Files.getLastModifiedTime(m2ModuleInfoClass))) {
227             throw new AssertionError(&quot;Classfile update!&quot;);
228         }
229 
230         if (!C1TimeStamp.equals(Files.getLastModifiedTime(classC1))) {
231             throw new AssertionError(&quot;Classfile update!&quot;);
232         }
233 
234         if (!C2TimeStamp.equals(Files.getLastModifiedTime(classC2))) {
235             throw new AssertionError(&quot;Classfile update!&quot;);
236         }
237 
238         Thread.sleep(2000); //timestamps
239 
240         Files.setLastModifiedTime(C1Source, FileTime.fromMillis(System.currentTimeMillis()));
241         Files.setLastModifiedTime(C2Source, FileTime.fromMillis(System.currentTimeMillis()));
242 
243         new JavacTask(tb)
244                 .options(&quot;-m&quot;, &quot;m1x,m2x&quot;, &quot;--module-source-path&quot;, src.toString(), &quot;-d&quot;, build.toString())
245                 .run(Task.Expect.SUCCESS)
246                 .writeAll();
247 
248         if (!m1ModuleInfoTimeStamp.equals(Files.getLastModifiedTime(m1ModuleInfoClass))) {
249             throw new AssertionError(&quot;Classfile update!&quot;);
250         }
251 
252         if (!m2ModuleInfoTimeStamp.equals(Files.getLastModifiedTime(m2ModuleInfoClass))) {
253             throw new AssertionError(&quot;Classfile update!&quot;);
254         }
255 
256         if (Files.getLastModifiedTime(classC1).compareTo(Files.getLastModifiedTime(C1Source)) &lt; 0) {
257             throw new AssertionError(&quot;Classfiles too old!&quot;);
258         }
259 
260         if (Files.getLastModifiedTime(classC2).compareTo(Files.getLastModifiedTime(C2Source)) &lt; 0) {
261             throw new AssertionError(&quot;Classfiles too old!&quot;);
262         }
263     }
264 }
    </pre>
  </body>
</html>
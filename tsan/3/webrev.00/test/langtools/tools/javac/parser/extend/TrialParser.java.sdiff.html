<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/langtools/tools/javac/parser/extend/TrialParser.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../JavacParserTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../patterns/scope/TEST.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/langtools/tools/javac/parser/extend/TrialParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
158             case WHILE:
159             case DO:
160             case TRY:
161             case SWITCH:
162             case SYNCHRONIZED:
163             case RETURN:
164             case THROW:
165             case BREAK:
166             case CONTINUE:
167             case SEMI:
168             case ELSE:
169             case FINALLY:
170             case CATCH:
171             case ASSERT:
172                 return List.&lt;JCTree&gt;of(parseStatement());
173             default:
174                 JCModifiers mods = modifiersOpt(pmods);
175                 if (token.kind == CLASS
176                         || token.kind == INTERFACE
177                         || token.kind == ENUM) {
<span class="line-modified">178                     return List.&lt;JCTree&gt;of(classOrInterfaceOrEnumDeclaration(mods, dc));</span>
179                 } else {
180                     int pos = token.pos;
181                     List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
182                 // if there are type parameters but no modifiers, save the start
183                     // position of the method in the modifiers.
184                     if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
185                         mods.pos = pos;
186                         storeEnd(mods, pos);
187                     }
188                     List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
189 
190                     if (annosAfterParams.nonEmpty()) {
191                         checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
192                         mods.annotations = mods.annotations.appendList(annosAfterParams);
193                         if (mods.pos == Position.NOPOS) {
194                             mods.pos = mods.annotations.head.pos;
195                         }
196                     }
197 
198                     Token prevToken = token;
</pre>
<hr />
<pre>
203                         t = to(F.at(pos).TypeIdent(TypeTag.VOID));
204                         nextToken();
205                     } else {
206                         // return type of method, declared type of variable, or an expression
207                         t = term(EXPR | TYPE);
208                     }
209                     if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
210                         // labelled statement
211                         nextToken();
212                         JCStatement stat = parseStatement();
213                         return List.&lt;JCTree&gt;of(F.at(pos).Labelled(prevToken.name(), stat));
214                     } else if ((isVoid || (lastmode &amp; TYPE) != 0) &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
215                         // we have &quot;Type Ident&quot;, so we can assume it is variable or method declaration
216                         pos = token.pos;
217                         Name name = ident();
218                         if (token.kind == LPAREN) {
219                         // method declaration
220                             //mods.flags |= Flags.STATIC;
221                             return List.of(methodDeclaratorRest(
222                                     pos, mods, t, name, typarams,
<span class="line-modified">223                                     false, isVoid, dc));</span>
224                         } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
225                         // variable declaration
226                             //mods.flags |= Flags.STATIC;
227                             List&lt;JCTree&gt; defs
228                                     = variableDeclaratorsRest(pos, mods, t, name, false, dc,
229                                             new ListBuffer&lt;JCTree&gt;(), true).toList();
230                             accept(SEMI);
231                             storeEnd(defs.last(), S.prevToken().endPos);
232                             return defs;
233                         } else {
234                             // malformed declaration, return error
235                             pos = token.pos;
236                             List&lt;JCTree&gt; err = isVoid
237                                     ? List.&lt;JCTree&gt;of(toP(F.at(pos).MethodDef(mods, name, t, typarams,
238                                                             List.&lt;JCVariableDecl&gt;nil(), List.&lt;JCExpression&gt;nil(), null, null)))
239                                     : null;
240                             return List.&lt;JCTree&gt;of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
241                         }
242                     } else if (!typarams.isEmpty()) {
243                         // type parameters on non-variable non-method -- error
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
158             case WHILE:
159             case DO:
160             case TRY:
161             case SWITCH:
162             case SYNCHRONIZED:
163             case RETURN:
164             case THROW:
165             case BREAK:
166             case CONTINUE:
167             case SEMI:
168             case ELSE:
169             case FINALLY:
170             case CATCH:
171             case ASSERT:
172                 return List.&lt;JCTree&gt;of(parseStatement());
173             default:
174                 JCModifiers mods = modifiersOpt(pmods);
175                 if (token.kind == CLASS
176                         || token.kind == INTERFACE
177                         || token.kind == ENUM) {
<span class="line-modified">178                     return List.&lt;JCTree&gt;of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));</span>
179                 } else {
180                     int pos = token.pos;
181                     List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
182                 // if there are type parameters but no modifiers, save the start
183                     // position of the method in the modifiers.
184                     if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
185                         mods.pos = pos;
186                         storeEnd(mods, pos);
187                     }
188                     List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
189 
190                     if (annosAfterParams.nonEmpty()) {
191                         checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
192                         mods.annotations = mods.annotations.appendList(annosAfterParams);
193                         if (mods.pos == Position.NOPOS) {
194                             mods.pos = mods.annotations.head.pos;
195                         }
196                     }
197 
198                     Token prevToken = token;
</pre>
<hr />
<pre>
203                         t = to(F.at(pos).TypeIdent(TypeTag.VOID));
204                         nextToken();
205                     } else {
206                         // return type of method, declared type of variable, or an expression
207                         t = term(EXPR | TYPE);
208                     }
209                     if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
210                         // labelled statement
211                         nextToken();
212                         JCStatement stat = parseStatement();
213                         return List.&lt;JCTree&gt;of(F.at(pos).Labelled(prevToken.name(), stat));
214                     } else if ((isVoid || (lastmode &amp; TYPE) != 0) &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
215                         // we have &quot;Type Ident&quot;, so we can assume it is variable or method declaration
216                         pos = token.pos;
217                         Name name = ident();
218                         if (token.kind == LPAREN) {
219                         // method declaration
220                             //mods.flags |= Flags.STATIC;
221                             return List.of(methodDeclaratorRest(
222                                     pos, mods, t, name, typarams,
<span class="line-modified">223                                     false, isVoid, false, dc));</span>
224                         } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
225                         // variable declaration
226                             //mods.flags |= Flags.STATIC;
227                             List&lt;JCTree&gt; defs
228                                     = variableDeclaratorsRest(pos, mods, t, name, false, dc,
229                                             new ListBuffer&lt;JCTree&gt;(), true).toList();
230                             accept(SEMI);
231                             storeEnd(defs.last(), S.prevToken().endPos);
232                             return defs;
233                         } else {
234                             // malformed declaration, return error
235                             pos = token.pos;
236                             List&lt;JCTree&gt; err = isVoid
237                                     ? List.&lt;JCTree&gt;of(toP(F.at(pos).MethodDef(mods, name, t, typarams,
238                                                             List.&lt;JCVariableDecl&gt;nil(), List.&lt;JCExpression&gt;nil(), null, null)))
239                                     : null;
240                             return List.&lt;JCTree&gt;of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
241                         }
242                     } else if (!typarams.isEmpty()) {
243                         // type parameters on non-variable non-method -- error
</pre>
</td>
</tr>
</table>
<center><a href="../JavacParserTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../patterns/scope/TEST.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/api/TestGetScopeBinaryNames.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8223443
 27  * @summary Verify binary names are not changed and are correct
 28  *          when using Trees.getScope
 29  * @modules jdk.compiler
 30  */
 31 
 32 import com.sun.source.tree.ClassTree;
 33 import java.io.IOException;
 34 import java.net.URI;
 35 import java.util.HashMap;
 36 import java.util.List;
 37 import java.util.Map;
 38 
 39 import javax.lang.model.element.Element;
 40 import javax.lang.model.element.NestingKind;
 41 import javax.lang.model.element.TypeElement;
 42 import javax.lang.model.util.Elements;
 43 import javax.tools.JavaCompiler;
 44 import javax.tools.SimpleJavaFileObject;
 45 import javax.tools.ToolProvider;
 46 
 47 import com.sun.source.tree.CompilationUnitTree;
 48 import com.sun.source.tree.Scope;
 49 import com.sun.source.tree.Tree;
 50 import com.sun.source.tree.Tree.Kind;
 51 import com.sun.source.util.JavacTask;
 52 import com.sun.source.util.TaskEvent;
 53 import com.sun.source.util.TaskListener;
 54 import com.sun.source.util.TreePath;
 55 import com.sun.source.util.TreePathScanner;
 56 import com.sun.source.util.Trees;
 57 
 58 import static javax.tools.JavaFileObject.Kind.SOURCE;
 59 
 60 public class TestGetScopeBinaryNames {
 61     public static void main(String... args) throws IOException {
 62         new TestGetScopeBinaryNames().run();
 63     }
 64 
 65     public void run() throws IOException {
 66         class EnclosingDesc {
 67             final String code;
 68             final boolean supportsLocal;
 69             public EnclosingDesc(String code, boolean supportsLocal) {
 70                 this.code = code;
 71                 this.supportsLocal = supportsLocal;
 72             }
 73         }
 74         List&lt;EnclosingDesc&gt; enclosingEnvs = List.of(
 75                 new EnclosingDesc(&quot;class Test {&quot; +
 76                                   &quot;    void test() {&quot; +
 77                                   &quot;        $&quot; +
 78                                   &quot;    }&quot; +
 79                                   &quot;}&quot;,
 80                                   true),
 81                 new EnclosingDesc(&quot;class Test {&quot; +
 82                                   &quot;    {&quot; +
 83                                   &quot;        $&quot; +
 84                                   &quot;    }&quot; +
 85                                   &quot;}&quot;,
 86                                   true),
 87                 new EnclosingDesc(&quot;class Test {&quot; +
 88                                   &quot;    static {&quot; +
 89                                   &quot;        $&quot; +
 90                                   &quot;    }&quot; +
 91                                   &quot;}&quot;,
 92                                   true),
 93                 new EnclosingDesc(&quot;class Test {&quot; +
 94                                   &quot;    Object I = $&quot; +
 95                                   &quot;}&quot;,
 96                                   true)
 97         );
 98         class LocalDesc {
 99             final String localCode;
100             final boolean isLocalClass;
101             public LocalDesc(String localCode, boolean isLocalClass) {
102                 this.localCode = localCode;
103                 this.isLocalClass = isLocalClass;
104             }
105         }
106         List&lt;LocalDesc&gt; locals = List.of(
107             new LocalDesc(&quot;new A() {&quot; +
108                           &quot;    class AI extends B {&quot; +
109                           &quot;        class AII extends C {&quot; +
110                           &quot;            private void t() {&quot; +
111                           &quot;                new D() { class DI extends E {} };&quot; +
112                           &quot;            }&quot; +
113                           &quot;        }&quot; +
114                           &quot;        private void t() { new F() {}; }&quot; +
115                           &quot;    }&quot; +
116                           &quot;    private void t() { new G() {}; }&quot; +
117                           &quot;};&quot;,
118                           false),
119             new LocalDesc(&quot;class AA extends A {&quot; +
120                           &quot;    class AI extends B {&quot; +
121                           &quot;        class AII extends C {&quot; +
122                           &quot;            private void t() {&quot; +
123                           &quot;                new D() { class DI extends E {} };&quot; +
124                           &quot;            }&quot; +
125                           &quot;        }&quot; +
126                           &quot;        private void t() { new F() {}; }&quot; +
127                           &quot;    }&quot; +
128                           &quot;    private void t() { new G() {}; }&quot; +
129                           &quot;}&quot;,
130                           false)
131         );
132         String markerClasses = &quot;class A {} class B {} class C {}&quot; +
133                                &quot;class D {} class E {} class F {}&quot; +
134                                &quot;class G {}&quot;;
135         for (EnclosingDesc enclosing : enclosingEnvs) {
136             for (LocalDesc local : locals) {
137                 if (!local.isLocalClass || enclosing.supportsLocal) {
138                     doTest(enclosing.code.replace(&quot;$&quot;, local.localCode) +
139                            markerClasses);
140                 }
141             }
142         }
143     }
144 
145     void doTest(String code, String... expected) throws IOException {
146         Map&lt;String, String&gt; name2BinaryName = new HashMap&lt;&gt;();
147         Map&lt;String, String&gt; name2QualifiedName = new HashMap&lt;&gt;();
148 
149         computeNames(code, name2BinaryName, name2QualifiedName);
150 
151         JavaCompiler c = ToolProvider.getSystemJavaCompiler();
152         JavacTask t = (JavacTask) c.getTask(null, null, null, null, null,
153                                             List.of(new MyFileObject(code)));
154         CompilationUnitTree cut = t.parse().iterator().next();
155         Trees trees = Trees.instance(t);
156 
157         t.addTaskListener(new TaskListener() {
158             @Override
159             public void finished(TaskEvent e) {
160                 if (e.getKind() == TaskEvent.Kind.ENTER) {
161                     new TreePathScanner&lt;Void, Void&gt;() {
162                         @Override
163                         public Void scan(Tree tree, Void p) {
164                             if (tree != null &amp;&amp;
165                                 !isInExtendsClause(getCurrentPath(), tree)) {
166                                 TreePath path =
167                                         new TreePath(getCurrentPath(), tree);
168                                 Scope scope = trees.getScope(path);
169                                 checkScope(t.getElements(), scope,
170                                            name2BinaryName, name2QualifiedName);
171                             }
172                             return super.scan(tree, p);
173                         }
174                     }.scan(cut, null);
175                 }
176             }
177         });
178 
179         t.analyze();
180 
181         new TreePathScanner&lt;Void, Void&gt;() {
182             @Override
183             public Void visitClass(ClassTree node, Void p) {
184                 TypeElement type =
185                         (TypeElement) trees.getElement(getCurrentPath());
186                 checkClass(t.getElements(), type,
187                            name2BinaryName, name2QualifiedName);
188                 return super.visitClass(node, p);
189             }
190         }.scan(cut, null);
191 
192         new TreePathScanner&lt;Void, Void&gt;() {
193             @Override
194             public Void scan(Tree tree, Void p) {
195                 if (tree != null &amp;&amp;
196                     !isInExtendsClause(getCurrentPath(), tree)) {
197                     TreePath path =
198                             new TreePath(getCurrentPath(), tree);
199                     Scope scope = trees.getScope(path);
200                     checkScope(t.getElements(), scope,
201                                name2BinaryName, name2QualifiedName);
202                 }
203                 return super.scan(tree, p);
204             }
205         }.scan(cut, null);
206     }
207 
208     void computeNames(String code,
209                       Map&lt;String, String&gt; name2BinaryName,
210                       Map&lt;String, String&gt; name2QualifiedName) throws IOException {
211         JavaCompiler c = ToolProvider.getSystemJavaCompiler();
212         JavacTask t = (JavacTask) c.getTask(null, null, null, null, null,
213                                             List.of(new MyFileObject(code)));
214         CompilationUnitTree cut = t.parse().iterator().next();
215 
216         t.analyze();
217 
218         new TreePathScanner&lt;Void, Void&gt;() {
219             Trees trees = Trees.instance(t);
220             Elements els = t.getElements();
221             @Override
222             public Void visitClass(ClassTree node, Void p) {
223                 TypeElement type =
224                         (TypeElement) trees.getElement(getCurrentPath());
225                 String key = type.getSuperclass().toString();
226 
227                 name2BinaryName.put(key, els.getBinaryName(type).toString());
228                 name2QualifiedName.put(key, type.getQualifiedName().toString());
229                 return super.visitClass(node, p);
230             }
231         }.scan(cut, null);
232     }
233 
234     boolean isInExtendsClause(TreePath clazz, Tree toCheck) {
235         return clazz != null &amp;&amp;
236                clazz.getLeaf().getKind() == Kind.CLASS &amp;&amp;
237                ((ClassTree) clazz.getLeaf()).getExtendsClause() == toCheck;
238     }
239 
240     void checkClass(Elements els, TypeElement type,
241                     Map&lt;String, String&gt; name2BinaryName,
242                     Map&lt;String, String&gt; name2QualifiedName) {
243         if (type.getNestingKind() == NestingKind.TOP_LEVEL ||
244             type.getNestingKind() == NestingKind.MEMBER) {
245             return ;
246         }
247 
248         String binaryName = name2BinaryName.get(type.getSuperclass().toString());
249 
250         if (!els.getBinaryName(type).contentEquals(binaryName)) {
251             throw new AssertionError(&quot;Unexpected: &quot; + els.getBinaryName(type));
252         }
253 
254         String qualifiedName = name2QualifiedName.get(type.getSuperclass().toString());
255 
256         if (qualifiedName != null) {
257             if (!type.getQualifiedName().contentEquals(qualifiedName)) {
258                 throw new AssertionError(&quot;Unexpected: &quot; + type.getQualifiedName() +
259                                          &quot;, expected: &quot; + qualifiedName);
260             }
261         }
262     }
263 
264     void checkScope(Elements els, Scope scope,
265                     Map&lt;String, String&gt; name2BinaryName,
266                     Map&lt;String, String&gt; name2QualifiedName) {
267         while (scope != null) {
268             for (Element el : scope.getLocalElements()) {
269                 if (el.getKind().isClass()) {
270                     checkClass(els, (TypeElement) el,
271                                name2BinaryName, name2QualifiedName);
272                 }
273             }
274             scope = scope.getEnclosingScope();
275         }
276     }
277 
278     class MyFileObject extends SimpleJavaFileObject {
279         private final String code;
280 
281         MyFileObject(String code) {
282             super(URI.create(&quot;myfo:///Test.java&quot;), SOURCE);
283             this.code = code;
284         }
285         @Override
286         public String getCharContent(boolean ignoreEncodingErrors) {
287             return code;
288         }
289     }
290 }
291 
    </pre>
  </body>
</html>
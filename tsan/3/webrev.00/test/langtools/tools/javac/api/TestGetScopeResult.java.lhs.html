<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/api/TestGetScopeResult.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
<a name="2" id="anc2"></a><span class="line-modified"> 26  * @bug 8205418 8207229 8207230</span>
 27  * @summary Test the outcomes from Trees.getScope
 28  * @modules jdk.compiler/com.sun.tools.javac.api
 29  *          jdk.compiler/com.sun.tools.javac.comp
 30  *          jdk.compiler/com.sun.tools.javac.tree
 31  *          jdk.compiler/com.sun.tools.javac.util
 32  */
 33 
 34 import java.io.IOException;
 35 import java.net.URI;
 36 import java.util.ArrayList;
 37 import java.util.List;
 38 
 39 import javax.lang.model.element.Element;
 40 import javax.tools.JavaCompiler;
 41 import javax.tools.SimpleJavaFileObject;
 42 import javax.tools.StandardJavaFileManager;
 43 import javax.tools.ToolProvider;
 44 
<a name="3" id="anc3"></a>
 45 import com.sun.source.tree.CompilationUnitTree;
<a name="4" id="anc4"></a>

 46 import com.sun.source.tree.LambdaExpressionTree;
<a name="5" id="anc5"></a>

 47 import com.sun.source.tree.Scope;
<a name="6" id="anc6"></a>
 48 import com.sun.source.tree.VariableTree;
 49 import com.sun.source.util.JavacTask;
<a name="7" id="anc7"></a>

 50 import com.sun.source.util.TreePath;
 51 import com.sun.source.util.TreePathScanner;
 52 import com.sun.source.util.Trees;
 53 
 54 import com.sun.tools.javac.api.JavacTool;
 55 import com.sun.tools.javac.comp.Analyzer;
 56 import com.sun.tools.javac.comp.AttrContext;
 57 import com.sun.tools.javac.comp.Env;
 58 import com.sun.tools.javac.tree.JCTree.JCStatement;
 59 import com.sun.tools.javac.util.Context;
 60 import com.sun.tools.javac.util.Context.Factory;
 61 
 62 import static javax.tools.JavaFileObject.Kind.SOURCE;
 63 
 64 public class TestGetScopeResult {
 65     public static void main(String... args) throws IOException {
 66         new TestGetScopeResult().run();
 67         new TestGetScopeResult().testAnalyzerDisabled();
<a name="8" id="anc8"></a>




 68     }
 69 
 70     public void run() throws IOException {
 71         String[] simpleLambda = {
 72             &quot;s:java.lang.String&quot;,
 73             &quot;i:Test.I&quot;,
 74             &quot;super:java.lang.Object&quot;,
 75             &quot;this:Test&quot;
 76         };
 77         doTest(&quot;class Test { void test() { I i = s -&gt; { }; } interface I { public void test(String s); } }&quot;,
 78                simpleLambda);
 79         doTest(&quot;class Test { void test() { I i = s -&gt; { }; } interface I { public int test(String s); } }&quot;,
 80                simpleLambda);
 81         doTest(&quot;class Test { void test() { I i = s -&gt; { }; } interface I { public String test(String s); } }&quot;,
 82                simpleLambda);
 83         doTest(&quot;class Test { void test() { I i; inv(s -&gt; { }); } void inv(I i) { } interface I { public void test(String s); } }&quot;,
 84                simpleLambda);
 85         doTest(&quot;class Test { void test() { I i; inv(s -&gt; { }); } void inv(I i) { } interface I { public int test(String s); } }&quot;,
 86                simpleLambda);
 87         doTest(&quot;class Test { void test() { I i; inv(s -&gt; { }); } void inv(I i) { } interface I { public String test(String s); } }&quot;,
 88                simpleLambda);
 89         String[] dualLambda = {
 90             &quot;s:java.lang.String&quot;,
 91             &quot;i:Test.I1&quot;,
 92             &quot;super:java.lang.Object&quot;,
 93             &quot;this:Test&quot;,
 94             &quot;s:java.lang.CharSequence&quot;,
 95             &quot;i:Test.I1&quot;,
 96             &quot;super:java.lang.Object&quot;,
 97             &quot;this:Test&quot;
 98         };
 99         doTest(&quot;class Test { void test() { I1 i; inv(s -&gt; { }, s -&gt; { }); } void inv(I1 i, I2 i) { } interface I1 { public String test(String s); } interface I2 { public void test(CharSequence s); } }&quot;,
100                dualLambda);
101         doTest(&quot;class Test { void test() { I1 i; inv(s -&gt; { }, s -&gt; { }); } void inv(I1 i, I2 i) { } interface I1 { public String test(String s); } interface I2 { public int test(CharSequence s); } }&quot;,
102                dualLambda);
103         String[] brokenType = {
104             &quot;s:&lt;any&gt;&quot;,
105             &quot;u:Undefined&quot;,
106             &quot;super:java.lang.Object&quot;,
107             &quot;this:Test&quot;
108         };
109         doTest(&quot;class Test { void test() { Undefined u = s -&gt; { }; } }&quot;,
110                brokenType);
111         String[] multipleCandidates1 = {
112             &quot;s:&lt;any&gt;&quot;,
113             &quot;super:java.lang.Object&quot;,
114             &quot;this:Test&quot;
115         };
116         doTest(&quot;class Test { void test() { cand1(s -&gt; { }); } void cand1(I1 i) { } void cand1(I2 i) { } interface I1 { public String test(String s); } interface I2 { public int test(CharSequence s); } }&quot;,
117                multipleCandidates1);
118         String[] multipleCandidates2 = {
119             &quot;s:java.lang.String&quot;,
120             &quot;super:java.lang.Object&quot;,
121             &quot;this:Test&quot;
122         };
123         doTest(&quot;class Test { void test() { cand1(s -&gt; { }); } void cand1(I1 i) { } void cand1(I2 i, int i) { } interface I1 { public String test(String s); } interface I2 { public int test(CharSequence s); } }&quot;,
124                multipleCandidates2);
125 
126         String[] implicitExplicitConflict1 = {
127             &quot;:t&quot;,
128             &quot;s:java.lang.String&quot;,
129             &quot;super:java.lang.Object&quot;,
130             &quot;this:Test&quot;
131         };
132 
133         doTest(&quot;class Test { void test() { cand((var s, t) -&gt; \&quot;\&quot;); } void cand(I i) { } interface I { public String test(String s); }  }&quot;,
134                implicitExplicitConflict1);
135 
136         String[] implicitExplicitConflict2 = {
137             &quot;s:none&quot;,
138             &quot;:t&quot;,
139             &quot;super:java.lang.Object&quot;,
140             &quot;this:Test&quot;
141         };
142 
143         doTest(&quot;class Test { void test() { cand((t, var s) -&gt; \&quot;\&quot;); } void cand(I i) { } interface I { public String test(String s); }  }&quot;,
144                implicitExplicitConflict2);
145     }
146 
147     public void doTest(String code, String... expected) throws IOException {
148         JavaCompiler c = ToolProvider.getSystemJavaCompiler();
149         try (StandardJavaFileManager fm = c.getStandardFileManager(null, null, null)) {
150             class MyFileObject extends SimpleJavaFileObject {
151                 MyFileObject() {
152                     super(URI.create(&quot;myfo:///Test.java&quot;), SOURCE);
153                 }
154                 @Override
155                 public String getCharContent(boolean ignoreEncodingErrors) {
156                     return code;
157                 }
158             }
159             JavacTask t = (JavacTask) c.getTask(null, fm, null, null, null, List.of(new MyFileObject()));
160             CompilationUnitTree cut = t.parse().iterator().next();
161             t.analyze();
162 
163             List&lt;String&gt; actual = new ArrayList&lt;&gt;();
164 
165             new TreePathScanner&lt;Void, Void&gt;() {
166                 @Override
167                 public Void visitLambdaExpression(LambdaExpressionTree node, Void p) {
168                     Scope scope = Trees.instance(t).getScope(new TreePath(getCurrentPath(), node.getBody()));
169                     while (scope.getEnclosingClass() != null) {
170                         for (Element el : scope.getLocalElements()) {
171                             actual.add(el.getSimpleName() + &quot;:&quot; +el.asType().toString());
172                         }
173                         scope = scope.getEnclosingScope();
174                     }
175                     return super.visitLambdaExpression(node, p);
176                 }
177             }.scan(cut, null);
178 
179             List&lt;String&gt; expectedList = List.of(expected);
180 
181             if (!expectedList.equals(actual)) {
182                 throw new IllegalStateException(&quot;Unexpected scope content: &quot; + actual + &quot;\n&quot; +
183                                                  &quot;expected: &quot; + expectedList);
184             }
185         }
186     }
187 
188     void testAnalyzerDisabled() throws IOException {
189         JavacTool c = JavacTool.create();
190         try (StandardJavaFileManager fm = c.getStandardFileManager(null, null, null)) {
191             class MyFileObject extends SimpleJavaFileObject {
192                 MyFileObject() {
193                     super(URI.create(&quot;myfo:///Test.java&quot;), SOURCE);
194                 }
195                 @Override
196                 public String getCharContent(boolean ignoreEncodingErrors) {
197                     return &quot;class Test {&quot; +
198                            &quot;    void test() { cand(() -&gt; { System.err.println(); }); }&quot; +
199                            &quot;    Runnable r = new Runnable() { public void test() { System.err.println(); } };&quot; +
200                            &quot;    void cand(Runnable r) { }&quot; +
201                            &quot;}&quot;;
202                 }
203             }
204             Context ctx = new Context();
205             TestAnalyzer.preRegister(ctx);
206             JavacTask t = (JavacTask) c.getTask(null, fm, null, List.of(&quot;-XDfind=lambda&quot;), null,
207                                                 List.of(new MyFileObject()), ctx);
208             CompilationUnitTree cut = t.parse().iterator().next();
209             t.analyze();
210 
211             TestAnalyzer analyzer = (TestAnalyzer) TestAnalyzer.instance(ctx);
212 
213             if (!analyzer.analyzeCalled) {
214                 throw new IllegalStateException(&quot;Analyzer didn&#39;t run!&quot;);
215             }
216 
217             new TreePathScanner&lt;Void, Void&gt;() {
218                 @Override
219                 public Void visitLambdaExpression(LambdaExpressionTree node, Void p) {
220                     analyzer.analyzeCalled = false;
221                     Trees.instance(t).getScope(new TreePath(getCurrentPath(), node.getBody()));
222                     if (analyzer.analyzeCalled) {
223                         throw new IllegalStateException(&quot;Analyzer was run during getScope!&quot;);
224                     }
225                     return super.visitLambdaExpression(node, p);
226                 }
227 
228                 @Override
229                 public Void visitVariable(VariableTree node, Void p) {
230                     if (node.getInitializer() != null) {
231                         analyzer.analyzeCalled = false;
232                         TreePath tp = new TreePath(getCurrentPath(), node.getInitializer());
233                         Trees.instance(t).getScope(tp);
234                         if (analyzer.analyzeCalled) {
235                             throw new IllegalStateException(&quot;Analyzer was run during getScope!&quot;);
236                         }
237                     }
238                     return super.visitVariable(node, p);
239                 }
240             }.scan(cut, null);
241         }
242     }
243 
244     private static final class TestAnalyzer extends Analyzer {
245 
246         public static void preRegister(Context context) {
247             context.put(analyzerKey, (Factory&lt;Analyzer&gt;) ctx -&gt; new TestAnalyzer(ctx));
248         }
249 
250         private boolean analyzeCalled;
251 
252         public TestAnalyzer(Context context) {
253             super(context);
254         }
255 
256         @Override
257         protected void analyze(JCStatement statement, Env&lt;AttrContext&gt; env) {
258             analyzeCalled = true;
259             super.analyze(statement, env);
260         }
261     }
<a name="9" id="anc9"></a><span class="line-removed">262 }</span>
263 
<a name="10" id="anc10"></a>




























































































































































































































<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
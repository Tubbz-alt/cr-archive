<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/generics/inference/8176534/TestUncheckedCalls.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import combo.ComboInstance;
 25 import combo.ComboParameter;
 26 import combo.ComboTask.Result;
 27 import combo.ComboTestHelper;
 28 
 29 import javax.lang.model.element.Element;
 30 import java.util.stream.Stream;
 31 
 32 /*
 33  * @test
 34  * @bug 8176534
 35  * @summary Missing check against target-type during applicability inference
 36  * @library /tools/javac/lib
 37  * @modules jdk.compiler/com.sun.tools.javac.api
 38  *          jdk.compiler/com.sun.tools.javac.file
 39  *          jdk.compiler/com.sun.tools.javac.util
 40  * @build combo.ComboTestHelper
 41  *
 42  * @run main TestUncheckedCalls
 43  */
 44 public class TestUncheckedCalls extends ComboInstance&lt;TestUncheckedCalls&gt; {
 45     enum InputExpressionKind implements ComboParameter {
 46         A(&quot;(A)null&quot;),
 47         A_STRING(&quot;(A&lt;String&gt;)null&quot;),
 48         B(&quot;(B)null&quot;),
 49         B_STRING(&quot;(B&lt;String&gt;)null&quot;);
 50 
 51         String inputExpr;
 52 
 53         InputExpressionKind(String inputExpr) {
 54             this.inputExpr = inputExpr;
 55         }
 56 
 57 
 58         @Override
 59         public String expand(String optParameter) {
 60             return inputExpr;
 61         }
 62     }
 63 
 64     enum TypeKind implements ComboParameter {
 65         Z(&quot;Z&quot;),
 66         C_T(&quot;#C&lt;T&gt;&quot;),
 67         C_STRING(&quot;#C&lt;String&gt;&quot;),
 68         C(&quot;#C&quot;);
 69 
 70         String typeTemplate;
 71 
 72         TypeKind(String typeTemplate) {
 73             this.typeTemplate = typeTemplate;
 74         }
 75 
 76         boolean hasTypeVars() {
 77             return this == Z || this == C_T;
 78         }
 79 
 80         @Override
 81         public String expand(String className) {
 82             return typeTemplate.replaceAll(&quot;#C&quot;, className);
 83         }
 84     }
 85 
 86     enum TypeVarsKind implements ComboParameter {
 87         NONE(&quot;&quot;, &quot;Object&quot;),
 88         Z_T(&quot;&lt;Z extends #C&lt;T&gt;, T&gt;&quot;, &quot;Z&quot;);
 89 
 90         String typeVarsTemplate;
 91         String paramString;
 92 
 93         TypeVarsKind(String typeVarsTemplate, String paramString) {
 94             this.typeVarsTemplate = typeVarsTemplate;
 95             this.paramString = paramString;
 96         }
 97 
 98 
 99         @Override
100         public String expand(String className) {
101             if (className.equals(&quot;Z&quot;)) {
102                 return paramString;
103             } else {
104                 return typeVarsTemplate.replaceAll(&quot;#C&quot;, className);
105             }
106         }
107     }
108 
109     enum CallKind implements ComboParameter {
110         M(&quot;M(#{IN}, #{IN})&quot;),
111         M_G(&quot;M(G(#{IN}, #{IN}), #{IN})&quot;),
112         M_G_G(&quot;M(G(#{IN}, #{IN}), G(#{IN}, #{IN}))&quot;);
113 
114         String callExpr;
115 
116         CallKind(String callExpr) {
117             this.callExpr = callExpr;
118         }
119 
120 
121         @Override
122         public String expand(String optParameter) {
123             return callExpr;
124         }
125     }
126 
127     enum DeclKind implements ComboParameter {
128         NONE(&quot;&quot;),
129         ONE(&quot;#{TVARS[#M_IDX].I1} #{RET[#M_IDX].A} #M(#{ARG[#M_IDX].A} x1, #{TVARS[#M_IDX].Z} x2) { return null; }&quot;),
130         TWO(&quot;#{TVARS[#M_IDX].I1} #{RET[#M_IDX].A} #M(#{ARG[#M_IDX].A} x1, #{TVARS[#M_IDX].Z} x2) { return null; }\n&quot; +
131         &quot;    #{TVARS[#M_IDX].I2} #{RET[#M_IDX].B} #M(#{ARG[#M_IDX].B} x1, #{TVARS[#M_IDX].Z} x2) { return null; }&quot;);
132 
133         String declTemplate;
134 
135         DeclKind(String declTemplate) {
136             this.declTemplate = declTemplate;
137         }
138 
139         @Override
140         public String expand(String methName) {
141             return declTemplate.replaceAll(&quot;#M_IDX&quot;, methName.equals(&quot;M&quot;) ? &quot;0&quot; : &quot;1&quot;)
142                     .replaceAll(&quot;#M&quot;, methName);
143 
144         }
145     }
146 
147     static final String sourceTemplate =
148             &quot;class Test {\n&quot; +
149             &quot;   interface I1&lt;X&gt; { }\n&quot; +
150             &quot;   interface I2&lt;X&gt; { }\n&quot; +
151             &quot;   static class A&lt;X&gt; implements I1&lt;X&gt; { }\n&quot; +
152             &quot;   static class B&lt;X&gt; implements I2&lt;X&gt; { }\n&quot; +
153             &quot;   #{DECL[0].M}\n&quot; +
154             &quot;   #{DECL[1].G}\n&quot; +
155             &quot;   void test() {\n&quot; +
156             &quot;       #{CALL};\n&quot; +
157             &quot;   }\n&quot; +
158             &quot;}\n&quot;;
159 
160     public static void main(String... args) throws Exception {
161         new ComboTestHelper&lt;TestUncheckedCalls&gt;()
162                 .withFilter(TestUncheckedCalls::arityFilter)
163                 .withFilter(TestUncheckedCalls::declFilter)
164                 .withFilter(TestUncheckedCalls::tvarFilter)
165                 .withFilter(TestUncheckedCalls::inputExprFilter)
166                 .withDimension(&quot;IN&quot;, (x, expr) -&gt; x.inputExpressionKind = expr, InputExpressionKind.values())
167                 .withDimension(&quot;CALL&quot;, (x, expr) -&gt; x.callKind = expr, CallKind.values())
168                 .withArrayDimension(&quot;DECL&quot;, (x, decl, idx) -&gt; x.decls[idx] = x.new Decl(decl, idx), 2, DeclKind.values())
169                 .withArrayDimension(&quot;TVARS&quot;, (x, tvars, idx) -&gt; x.typeVarsKinds[idx] = tvars, 2, TypeVarsKind.values())
170                 .withArrayDimension(&quot;RET&quot;, (x, ret, idx) -&gt; x.returnKinds[idx] = ret, 2, TypeKind.values())
171                 .withArrayDimension(&quot;ARG&quot;, (x, arg, idx) -&gt; x.argumentKinds[idx] = arg, 2, TypeKind.values())
172                 .run(TestUncheckedCalls::new);
173     }
174 
175     class Decl {
176         private DeclKind declKind;
177         private int index;
178 
179         Decl(DeclKind declKind, int index) {
180             this.declKind = declKind;
181             this.index = index;
182         }
183 
184         boolean hasKind(DeclKind declKind) {
185             return this.declKind == declKind;
186         }
187 
188         boolean isGeneric() {
189             return typeVarsKind() == TypeVarsKind.Z_T;
190         }
191 
192         TypeKind returnKind() {
193             return returnKinds[index];
194         }
195 
196         TypeKind argumentsKind() {
197             return argumentKinds[index];
198         }
199 
200         TypeVarsKind typeVarsKind() {
201             return typeVarsKinds[index];
202         }
203     }
204 
205     CallKind callKind;
206     InputExpressionKind inputExpressionKind;
207     TypeKind[] returnKinds = new TypeKind[2];
208     TypeKind[] argumentKinds = new TypeKind[2];
209     TypeVarsKind[] typeVarsKinds = new TypeVarsKind[2];
210     Decl[] decls = new Decl[2];
211 
212     boolean arityFilter() {
213         return (callKind == CallKind.M || !decls[1].hasKind(DeclKind.NONE)) &amp;&amp;
214                 !decls[0].hasKind(DeclKind.NONE);
215     }
216 
217     boolean declFilter() {
218         return Stream.of(decls)
219                 .filter(d -&gt; d.hasKind(DeclKind.NONE))
220                 .flatMap(d -&gt; Stream.of(d.returnKind(), d.argumentsKind(), d.typeVarsKind()))
221                 .noneMatch((Enum&lt;? extends Enum&lt;?&gt;&gt; tk) -&gt; tk.ordinal() != 0);
222     }
223 
224     boolean tvarFilter() {
225         return Stream.of(decls)
226                 .filter(d -&gt; !d.hasKind(DeclKind.NONE))
227                 .filter(d -&gt; !d.isGeneric())
228                 .flatMap(d -&gt; Stream.of(d.returnKind(), d.argumentsKind()))
229                 .noneMatch(TypeKind::hasTypeVars);
230     }
231 
232     boolean inputExprFilter() {
233         return (inputExpressionKind != InputExpressionKind.B &amp;&amp; inputExpressionKind != InputExpressionKind.B_STRING) ||
234                 Stream.of(decls).allMatch(d -&gt; d.declKind == DeclKind.TWO);
235     }
236 
237     @Override
238     public void doWork() throws Throwable {
239         newCompilationTask()
240                 .withSourceFromTemplate(sourceTemplate)
241                 .analyze(this::check);
242     }
243 
244     void check(Result&lt;Iterable&lt;? extends Element&gt;&gt; result) {
245         if (result.hasErrors()) {
246             fail(&quot;compiler error:\n&quot; +
247                     result.compilationInfo());
248         }
249     }
250 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/generics/rawOverride/7062745/GenericOverrideTest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 7062745 8006694 8129962
 27  * @summary  Regression: difference in overload resolution when two methods
 28  *  are maximally specific
 29  *  temporarily workaround combo tests are causing time out in several platforms
 30  * @library /tools/javac/lib
 31  * @modules jdk.compiler/com.sun.tools.javac.api
<a name="1" id="anc1"></a><span class="line-modified"> 32  *          jdk.compiler/com.sun.tools.javac.file</span>



 33  *          jdk.compiler/com.sun.tools.javac.util
 34  * @build combo.ComboTestHelper
 35  * @run main GenericOverrideTest
 36  */
 37 
 38 import java.io.IOException;
 39 
 40 import combo.ComboInstance;
 41 import combo.ComboParameter;
 42 import combo.ComboTask.Result;
 43 import combo.ComboTestHelper;
 44 
 45 public class GenericOverrideTest extends ComboInstance&lt;GenericOverrideTest&gt; {
 46 
 47     enum SourceLevel {
 48         SOURCE_7(&quot;-source&quot;, &quot;7&quot;),
 49         SOURCE_DEFAULT();
 50 
 51         String[] opts;
 52 
 53         SourceLevel(String... opts) {
 54             this.opts = opts;
 55         }
 56     }
 57 
 58     enum SignatureKind implements ComboParameter {
 59         NON_GENERIC(&quot;&quot;),
 60         GENERIC(&quot;&lt;X&gt;&quot;);
 61 
 62         String paramStr;
 63 
 64         SignatureKind(String paramStr) {
 65             this.paramStr = paramStr;
 66         }
 67 
 68         @Override
 69         public String expand(String optParameter) {
 70             return paramStr;
 71         }
 72     }
 73 
 74     enum ReturnTypeKind implements ComboParameter {
 75         LIST(&quot;List&quot;),
 76         ARRAYLIST(&quot;ArrayList&quot;);
 77 
 78         String retStr;
 79 
 80         ReturnTypeKind(String retStr) {
 81             this.retStr = retStr;
 82         }
 83 
 84         boolean moreSpecificThan(ReturnTypeKind that) {
 85             switch (this) {
 86                 case LIST:
 87                     return that == this;
 88                 case ARRAYLIST:
 89                     return that == LIST || that == ARRAYLIST;
 90                 default: throw new AssertionError(&quot;Unexpected ret kind: &quot; + this);
 91             }
 92         }
 93 
 94         @Override
 95         public String expand(String optParameter) {
 96             return retStr;
 97         }
 98     }
 99 
100     enum TypeArgumentKind implements ComboParameter {
101         NONE(&quot;&quot;),
102         UNBOUND(&quot;&lt;?&gt;&quot;),
103         INTEGER(&quot;&lt;Number&gt;&quot;),
104         NUMBER(&quot;&lt;Integer&gt;&quot;),
105         TYPEVAR(&quot;&lt;X&gt;&quot;);
106 
107         String typeargStr;
108 
109         TypeArgumentKind(String typeargStr) {
110             this.typeargStr = typeargStr;
111         }
112 
113         boolean compatibleWith(SignatureKind sig) {
114             switch (this) {
115                 case TYPEVAR: return sig != SignatureKind.NON_GENERIC;
116                 default: return true;
117             }
118         }
119 
120         boolean moreSpecificThan(TypeArgumentKind that) {
121             switch (this) {
122                 case NONE:
123                     return that == this;
124                 case UNBOUND:
125                     return that == this || that == NONE;
126                 case INTEGER:
127                 case NUMBER:
128                 case TYPEVAR:
129                     return that == this || that == NONE || that == UNBOUND;
130                 default: throw new AssertionError(&quot;Unexpected typearg kind: &quot; + this);
131             }
132         }
133 
134         boolean assignableTo(TypeArgumentKind that, SignatureKind sig, SourceLevel level) {
135             switch (this) {
136                 case NONE:
137                     //this case needs to workaround to javac&#39;s impl of 15.12.2.8 being too strict
138                     //ideally should be just &#39;return true&#39; (see 7067746/8015505)
139                     return level == SourceLevel.SOURCE_DEFAULT ||
140                             sig == SignatureKind.NON_GENERIC || that == NONE;
141                 case UNBOUND:
142                     return that == this || that == NONE;
143                 case INTEGER:
144                 case NUMBER:
145                     return that == this || that == NONE || that == UNBOUND;
146                 case TYPEVAR:
147                     return true;
148                 default: throw new AssertionError(&quot;Unexpected typearg kind: &quot; + this);
149             }
150         }
151 
152         @Override
153         public String expand(String optParameter) {
154             return typeargStr;
155         }
156     }
157 
158     public static void main(String... args) throws Exception {
159         new ComboTestHelper&lt;GenericOverrideTest&gt;()
160                 .withFilter(GenericOverrideTest::argMismatchFilter)
161                 .withDimension(&quot;SOURCE&quot;, (x, level) -&gt; x.level = level, SourceLevel.values())
162                 .withArrayDimension(&quot;SIG&quot;, (x, sig, idx) -&gt; x.sigs[idx] = sig, 2, SignatureKind.values())
163                 .withArrayDimension(&quot;TARG&quot;, (x, targ, idx) -&gt; x.targs[idx] = targ, 3, TypeArgumentKind.values())
164                 .withArrayDimension(&quot;RET&quot;, (x, ret, idx) -&gt; x.rets[idx] = ret, 3, ReturnTypeKind.values())
165                 .run(GenericOverrideTest::new);
166     }
167 
168     SignatureKind[] sigs = new SignatureKind[2];
169     ReturnTypeKind[] rets = new ReturnTypeKind[3];
170     TypeArgumentKind[] targs = new TypeArgumentKind[3];
171     SourceLevel level;
172 
173     boolean argMismatchFilter() {
174         return targs[0].compatibleWith(sigs[0]) &amp;&amp;
175                 targs[1].compatibleWith(sigs[1]) &amp;&amp;
176                 targs[2].compatibleWith(SignatureKind.NON_GENERIC);
177     }
178 
179     String template = &quot;import java.util.*;\n&quot; +
180                       &quot;interface A { #{SIG[0]} #{RET[0]}#{TARG[0]} m(); }\n&quot; +
181                       &quot;interface B { #{SIG[1]} #{RET[1]}#{TARG[1]} m(); }\n&quot; +
182                       &quot;interface AB extends A, B {}\n&quot; +
183                       &quot;class Test {\n&quot; +
184                       &quot;  void test(AB ab) { #{RET[2]}#{TARG[2]} n = ab.m(); }\n&quot; +
185                       &quot;}&quot;;
186 
187     @Override
188     public void doWork() throws IOException {
189         newCompilationTask()
190                 .withOption(&quot;-XDuseUnsharedTable&quot;) //this test relies on predictable name indexes!
191                 .withOptions(level.opts)
192                 .withSourceFromTemplate(template)
193                 .analyze(this::check);
194     }
195 
196     void check(Result&lt;?&gt; res) {
197         boolean errorExpected = false;
198         boolean loose = false;
199         int mostSpecific = 0;
200 
201         //first check that either |R1| &lt;: |R2| or |R2| &lt;: |R1|
202         if (rets[0] != rets[1]) {
203             if (!rets[0].moreSpecificThan(rets[1]) &amp;&amp;
204                     !rets[1].moreSpecificThan(rets[0])) {
205                 errorExpected = true;
206             } else {
207                 mostSpecific = rets[0].moreSpecificThan(rets[1]) ? 1 : 2;
208             }
209         } else if (sigs[0] != sigs[1]) {
210             mostSpecific = sigs[0] == SignatureKind.GENERIC ? 2 : 1;
211             loose = true;
212         }
213 
214         //check that either TA1 &lt;= TA2 or TA2 &lt;= TA1 (unless most specific return found above is raw)
215         if (!errorExpected) {
216             if (targs[0] != targs[1]) {
217                 boolean ta1ms = targs[0].moreSpecificThan(targs[1]);
218                 boolean ta2ms = targs[1].moreSpecificThan(targs[0]);
219                 if (!ta1ms &amp;&amp; !ta2ms) {
220                     errorExpected = true;
221                 } else if (mostSpecific != 0) {
222                     errorExpected = !loose &amp;&amp; targs[mostSpecific - 1] != TypeArgumentKind.NONE &amp;&amp;
223                             (mostSpecific == 1 ? !ta1ms : !ta2ms);
224                 } else {
225                     mostSpecific = ta1ms ? 1 : 2;
226                 }
227             }
228         }
229 
230         if (mostSpecific == 0) {
231             //when no signature is better than the other, an arbitrary choice
232             //must be made - javac always picks the second signature
233             mostSpecific = 2;
234         }
235 
236         if (!errorExpected) {
237             ReturnTypeKind msrt = mostSpecific == 1 ? rets[0] : rets[1];
238             TypeArgumentKind msta = mostSpecific == 1 ? targs[0] : targs[1];
239             SignatureKind mssig = mostSpecific == 1 ? sigs[0] : sigs[1];
240 
241             //check that most specific is subsignature
242             errorExpected = sigs[0] != sigs[1] &amp;&amp;
243                     mssig == SignatureKind.GENERIC;
244 
245             //finally, check that most specific return type is compatible with expected type
246             if (!msrt.moreSpecificThan(rets[2]) ||
247                     !msta.assignableTo(targs[2], mssig, level)) {
248                 errorExpected = true;
249             }
250         }
251 
252         if (errorExpected != res.hasErrors()) {
253             fail(&quot;invalid diagnostics for source:\n&quot; +
254                 res.compilationInfo() +
255                 &quot;\nFound error: &quot; + res.hasErrors() +
256                 &quot;\nExpected error: &quot; + errorExpected);
257         }
258     }
259 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
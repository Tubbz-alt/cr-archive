<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/annotations/typeAnnotations/classfile/ClassfileTestHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.lang.annotation.*;
 25 import java.io.*;
 26 import java.net.URL;
 27 import java.util.List;
 28 
 29 import com.sun.tools.classfile.*;
<a name="2" id="anc2"></a><span class="line-added"> 30 import java.util.ArrayList;</span>
 31 
 32 public class ClassfileTestHelper {
 33     int expected_tinvisibles = 0;
 34     int expected_tvisibles = 0;
 35     int expected_invisibles = 0;
 36     int expected_visibles = 0;
<a name="3" id="anc3"></a><span class="line-added"> 37     List&lt;String&gt; extraOptions = List.of();</span>
 38 
 39     //Makes debugging much easier. Set to &#39;false&#39; for less output.
 40     public Boolean verbose = true;
 41     void println(String msg) { if (verbose) System.err.println(msg); }
 42     void print(String msg) { if (verbose) System.err.print(msg); }
 43 
 44     File writeTestFile(String fname, String source) throws IOException {
 45       File f = new File(fname);
 46         PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(f)));
 47         out.println(source);
 48         out.close();
 49         return f;
 50     }
 51 
 52     File compile(File f) {
<a name="4" id="anc4"></a><span class="line-modified"> 53         List&lt;String&gt; options = new ArrayList&lt;&gt;(List.of(&quot;-g&quot;, f.getPath()));</span>
<span class="line-modified"> 54         options.addAll(extraOptions);</span>
<span class="line-added"> 55         int rc = com.sun.tools.javac.Main.compile(options.toArray(new String[0]));</span>
 56         if (rc != 0)
 57             throw new Error(&quot;compilation failed. rc=&quot; + rc);
 58         String path = f.getPath();
 59         return new File(path.substring(0, path.length() - 5) + &quot;.class&quot;);
 60     }
 61 
 62     ClassFile getClassFile(String name) throws IOException, ConstantPoolException {
 63         URL url = getClass().getResource(name);
 64         InputStream in = url.openStream();
 65         try {
 66             return ClassFile.read(in);
 67         } finally {
 68             in.close();
 69         }
 70     }
 71 
 72     ClassFile getClassFile(URL url) throws IOException, ConstantPoolException {
 73         InputStream in = url.openStream();
 74         try {
 75             return ClassFile.read(in);
 76         } finally {
 77             in.close();
 78         }
 79     }
 80 
 81     /************ Helper annotations counting methods ******************/
 82     void test(ClassFile cf) {
 83         test(&quot;CLASS&quot;,cf, null, null, Attribute.RuntimeVisibleTypeAnnotations, true);
 84         test(&quot;CLASS&quot;,cf, null, null, Attribute.RuntimeInvisibleTypeAnnotations, false);
 85         //RuntimeAnnotations since one annotation can result in two attributes.
 86         test(&quot;CLASS&quot;,cf, null, null, Attribute.RuntimeVisibleAnnotations, true);
 87         test(&quot;CLASS&quot;,cf, null, null, Attribute.RuntimeInvisibleAnnotations, false);
 88     }
 89 
 90     void test(ClassFile cf, Field f, Boolean local) {
 91         if (!local) {
 92             test(&quot;FIELD&quot;,cf, f, null, Attribute.RuntimeVisibleTypeAnnotations, true);
 93             test(&quot;FIELD&quot;,cf, f, null, Attribute.RuntimeInvisibleTypeAnnotations, false);
 94             test(&quot;FIELD&quot;,cf, f, null, Attribute.RuntimeVisibleAnnotations, true);
 95             test(&quot;FIELD&quot;,cf, f, null, Attribute.RuntimeInvisibleAnnotations, false);
 96         } else {
 97             test(&quot;CODE&quot;,cf, f, null, Attribute.RuntimeVisibleTypeAnnotations, true);
 98             test(&quot;CODE&quot;,cf, f, null, Attribute.RuntimeInvisibleTypeAnnotations, false);
 99             test(&quot;CODE&quot;,cf, f, null, Attribute.RuntimeVisibleAnnotations, true);
100             test(&quot;CODE&quot;,cf, f, null, Attribute.RuntimeInvisibleAnnotations, false);
101         }
102     }
103 
104     void test(ClassFile cf, Field f) {
105         test(cf, f, false);
106     }
107 
108     // &#39;local&#39; determines whether to look for annotations in code attribute or not.
109     void test(ClassFile cf, Method m, Boolean local) {
110         if (!local) {
111             test(&quot;METHOD&quot;,cf, null, m, Attribute.RuntimeVisibleTypeAnnotations, true);
112             test(&quot;METHOD&quot;,cf, null, m, Attribute.RuntimeInvisibleTypeAnnotations, false);
113             test(&quot;METHOD&quot;,cf, null, m, Attribute.RuntimeVisibleAnnotations, true);
114             test(&quot;METHOD&quot;,cf, null, m, Attribute.RuntimeInvisibleAnnotations, false);
115         } else  {
116             test(&quot;MCODE&quot;,cf, null, m, Attribute.RuntimeVisibleTypeAnnotations, true);
117             test(&quot;MCODE&quot;,cf, null, m, Attribute.RuntimeInvisibleTypeAnnotations, false);
118             test(&quot;MCODE&quot;,cf, null, m, Attribute.RuntimeVisibleAnnotations, true);
119             test(&quot;MCODE&quot;,cf, null, m, Attribute.RuntimeInvisibleAnnotations, false);
120         }
121     }
122 
123     // default to not looking in code attribute
124     void test(ClassFile cf, Method m ) {
125         test(cf, m, false);
126     }
127 
128     // Test the result of Attributes.getIndex according to expectations
129     // encoded in the class/field/method name; increment annotations counts.
130     void test(String ttype, ClassFile cf, Field f, Method m, String annName, boolean visible) {
131         String testtype = ttype;
132         String name = null;
133         int index = -1;
134         Attribute attr = null;
135         Code_attribute cAttr = null;
136         boolean isTAattr = annName.contains(&quot;TypeAnnotations&quot;);
137         try {
138             switch(testtype) {
139                 case &quot;FIELD&quot;:
140                     name = f.getName(cf.constant_pool);
141                     index = f.attributes.getIndex(cf.constant_pool, annName);
142                     if(index!= -1)
143                         attr = f.attributes.get(index);
144                     break;
145                 case &quot;CODE&quot;:
146                     name = f.getName(cf.constant_pool);
147                     //fetch index of and code attribute and annotations from code attribute.
148                     index = cf.attributes.getIndex(cf.constant_pool, Attribute.Code);
149                     if(index!= -1) {
150                         attr = cf.attributes.get(index);
151                         assert attr instanceof Code_attribute;
152                         cAttr = (Code_attribute)attr;
153                         index = cAttr.attributes.getIndex(cf.constant_pool, annName);
154                         if(index!= -1)
155                             attr = cAttr.attributes.get(index);
156                     }
157                     break;
158                 case &quot;METHOD&quot;:
159                     name = m.getName(cf.constant_pool);
160                     index = m.attributes.getIndex(cf.constant_pool, annName);
161                     if(index!= -1)
162                         attr = m.attributes.get(index);
163                     break;
164                 case &quot;MCODE&quot;:
165                     name = m.getName(cf.constant_pool);
166                     //fetch index of and code attribute and annotations from code attribute.
167                     index = m.attributes.getIndex(cf.constant_pool, Attribute.Code);
168                     if(index!= -1) {
169                         attr = m.attributes.get(index);
170                         assert attr instanceof Code_attribute;
171                         cAttr = (Code_attribute)attr;
172                         index = cAttr.attributes.getIndex(cf.constant_pool, annName);
173                         if(index!= -1)
174                             attr = cAttr.attributes.get(index);
175                     }
176                     break;
177                 default:
178                     name = cf.getName();
179                     index = cf.attributes.getIndex(cf.constant_pool, annName);
180                     if(index!= -1) attr = cf.attributes.get(index);
181             }
182         } catch(ConstantPoolException cpe) { cpe.printStackTrace(); }
183 
184         if (index != -1) {
185             if(isTAattr) { //count RuntimeTypeAnnotations
186                 RuntimeTypeAnnotations_attribute tAttr =
187                         (RuntimeTypeAnnotations_attribute)attr;
188                 println(testtype + &quot;: &quot; + name + &quot;, &quot; + annName + &quot;: &quot; +
189                         tAttr.annotations.length );
190                 if (tAttr.annotations.length &gt; 0) {
191                     for (int i = 0; i &lt; tAttr.annotations.length; i++) {
192                         println(&quot;  types:&quot; + tAttr.annotations[i].position.type);
193                     }
194                 } else {
195                     println(&quot;&quot;);
196                 }
197                 allt += tAttr.annotations.length;
198                 if (visible)
199                     tvisibles += tAttr.annotations.length;
200                 else
201                     tinvisibles += tAttr.annotations.length;
202             } else {
203                 RuntimeAnnotations_attribute tAttr =
204                         (RuntimeAnnotations_attribute)attr;
205                 println(testtype + &quot;: &quot; + name + &quot;, &quot; + annName + &quot;: &quot; +
206                         tAttr.annotations.length );
207                 all += tAttr.annotations.length;
208                 if (visible)
209                     visibles += tAttr.annotations.length;
210                 else
211                     invisibles += tAttr.annotations.length;
212             }
213         }
214     }
215 
216     void countAnnotations() {
217         errors=0;
218         int expected_allt = expected_tvisibles + expected_tinvisibles;
219         int expected_all = expected_visibles + expected_invisibles;
220 
221         if (expected_allt != allt) {
222             errors++;
223             System.err.println(&quot;Failure: expected &quot; + expected_allt +
224                     &quot; type annotations but found &quot; + allt);
225         }
226         if (expected_all != all) {
227             errors++;
228             System.err.println(&quot;Failure: expected &quot; + expected_all +
229                     &quot; annotations but found &quot; + all);
230         }
231         if (expected_tvisibles != tvisibles) {
232             errors++;
233             System.err.println(&quot;Failure: expected &quot; + expected_tvisibles +
234                     &quot; typevisible annotations but found &quot; + tvisibles);
235         }
236 
237         if (expected_tinvisibles != tinvisibles) {
238             errors++;
239             System.err.println(&quot;Failure: expected &quot; + expected_tinvisibles +
240                     &quot; typeinvisible annotations but found &quot; + tinvisibles);
241         }
242         allt=0;
243         tvisibles=0;
244         tinvisibles=0;
245         all=0;
246         visibles=0;
247         invisibles=0;
248     }
249 
250     int errors;
251     int allt;
252     int tvisibles;
253     int tinvisibles;
254     int all;
255     int visibles;
256     int invisibles;
257 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
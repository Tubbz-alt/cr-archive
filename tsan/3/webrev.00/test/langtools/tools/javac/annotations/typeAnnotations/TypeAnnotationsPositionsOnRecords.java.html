<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/annotations/typeAnnotations/TypeAnnotationsPositionsOnRecords.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Verify location of type annotations on records
 27  * @library /tools/lib
 28  * @modules
 29  *      jdk.jdeps/com.sun.tools.classfile
 30  *      jdk.compiler/com.sun.tools.javac.api
 31  *      jdk.compiler/com.sun.tools.javac.main
 32  *      jdk.compiler/com.sun.tools.javac.code
 33  *      jdk.compiler/com.sun.tools.javac.util
 34  * @build toolbox.ToolBox toolbox.JavacTask
 35  * @compile --enable-preview -source ${jdk.version} TypeAnnotationsPositionsOnRecords.java
 36  * @run main/othervm --enable-preview TypeAnnotationsPositionsOnRecords
 37  */
 38 
 39 import java.util.List;
 40 import java.util.ArrayList;
 41 
 42 import java.io.File;
 43 import java.nio.file.Paths;
 44 
 45 import java.lang.annotation.*;
 46 import java.util.Arrays;
 47 
 48 import com.sun.tools.classfile.*;
 49 import com.sun.tools.javac.util.Assert;
 50 
 51 import toolbox.JavacTask;
 52 import toolbox.ToolBox;
 53 
 54 public class TypeAnnotationsPositionsOnRecords {
 55 
 56     final String src =
 57             &quot;&quot;&quot;
 58             import java.lang.annotation.*;
 59 
 60             @Retention(RetentionPolicy.RUNTIME)
 61             @Target({ ElementType.TYPE_USE })
 62             @interface Nullable {}
 63 
 64             record Record1(@Nullable String t) {}
 65 
 66             record Record2(@Nullable String t) {
 67                 public Record2 {}
 68             }
 69 
 70             record Record3(@Nullable String t1, @Nullable String t2) {}
 71 
 72             record Record4(@Nullable String t1, @Nullable String t2) {
 73                 public Record4 {}
 74             }
 75 
 76             record Record5(String t1, @Nullable String t2) {}
 77 
 78             record Record6(String t1, @Nullable String t2) {
 79                 public Record6 {}
 80             }
 81             &quot;&quot;&quot;;
 82 
 83     public static void main(String... args) throws Exception {
 84         new TypeAnnotationsPositionsOnRecords().run();
 85     }
 86 
 87     ToolBox tb = new ToolBox();
 88 
 89     void run() throws Exception {
 90         compileTestClass();
 91         checkClassFile(new File(Paths.get(System.getProperty(&quot;user.dir&quot;),
 92                 &quot;Record1.class&quot;).toUri()), 0);
 93         checkClassFile(new File(Paths.get(System.getProperty(&quot;user.dir&quot;),
 94                 &quot;Record2.class&quot;).toUri()), 0);
 95         checkClassFile(new File(Paths.get(System.getProperty(&quot;user.dir&quot;),
 96                 &quot;Record3.class&quot;).toUri()), 0, 1);
 97         checkClassFile(new File(Paths.get(System.getProperty(&quot;user.dir&quot;),
 98                 &quot;Record4.class&quot;).toUri()), 0, 1);
 99         checkClassFile(new File(Paths.get(System.getProperty(&quot;user.dir&quot;),
100                 &quot;Record5.class&quot;).toUri()), 1);
101         checkClassFile(new File(Paths.get(System.getProperty(&quot;user.dir&quot;),
102                 &quot;Record6.class&quot;).toUri()), 1);
103     }
104 
105     void compileTestClass() throws Exception {
106         new JavacTask(tb)
107                 .sources(src)
108                 .options(&quot;--enable-preview&quot;, &quot;-source&quot;, Integer.toString(Runtime.version().feature()))
109                 .run();
110     }
111 
112     void checkClassFile(final File cfile, int... taPositions) throws Exception {
113         ClassFile classFile = ClassFile.read(cfile);
114         int accessorPos = 0;
115         int checkedAccessors = 0;
116         for (Method method : classFile.methods) {
117             String methodName = method.getName(classFile.constant_pool);
118             if (methodName.equals(&quot;toString&quot;) || methodName.equals(&quot;hashCode&quot;) || methodName.equals(&quot;equals&quot;)) {
119                 // ignore
120                 continue;
121             }
122             if (methodName.equals(&quot;&lt;init&gt;&quot;)) {
123                 checkConstructor(classFile, method, taPositions);
124             } else {
125                 for (int taPos : taPositions) {
126                     if (taPos == accessorPos) {
127                         checkAccessor(classFile, method);
128                         checkedAccessors++;
129                     }
130                 }
131                 accessorPos++;
132             }
133         }
134         checkFields(classFile, taPositions);
135         Assert.check(checkedAccessors == taPositions.length);
136     }
137 
138     /*
139      * there can be several parameters annotated we have to check that the ones annotated are the
140      * expected ones
141      */
142     void checkConstructor(ClassFile classFile, Method method, int... positions) throws Exception {
143         List&lt;TypeAnnotation&gt; annos = new ArrayList&lt;&gt;();
144         findAnnotations(classFile, method, annos);
145         Assert.check(annos.size() == positions.length);
146         int i = 0;
147         for (int pos : positions) {
148             TypeAnnotation ta = annos.get(i);
149             Assert.check(ta.position.type.toString().equals(&quot;METHOD_FORMAL_PARAMETER&quot;));
150             Assert.check(ta.position.parameter_index == pos);
151             i++;
152         }
153     }
154 
155     /*
156      * this case is simpler as there can only be one annotation at the accessor and it has to be applied
157      * at the return type
158      */
159     void checkAccessor(ClassFile classFile, Method method) {
160         List&lt;TypeAnnotation&gt; annos = new ArrayList&lt;&gt;();
161         findAnnotations(classFile, method, annos);
162         Assert.check(annos.size() == 1);
163         TypeAnnotation ta = annos.get(0);
164         Assert.check(ta.position.type.toString().equals(&quot;METHOD_RETURN&quot;));
165     }
166 
167     /*
168      * here we have to check that only the fields for which its position matches with the one of the
169      * original annotated record component are annotated
170      */
171     void checkFields(ClassFile classFile, int... positions) {
172         if (positions != null &amp;&amp; positions.length &gt; 0) {
173             int fieldPos = 0;
174             int annotationPos = 0;
175             int currentAnnoPosition = positions[annotationPos];
176             int annotatedFields = 0;
177             for (Field field : classFile.fields) {
178                 List&lt;TypeAnnotation&gt; annos = new ArrayList&lt;&gt;();
179                 findAnnotations(classFile, field, annos);
180                 if (fieldPos != currentAnnoPosition) {
181                     Assert.check(annos.size() == 0);
182                 } else {
183                     Assert.check(annos.size() == 1);
184                     TypeAnnotation ta = annos.get(0);
185                     Assert.check(ta.position.type.toString().equals(&quot;FIELD&quot;));
186                     annotationPos++;
187                     currentAnnoPosition = annotationPos &lt; positions.length ? positions[annotationPos] : -1;
188                     annotatedFields++;
189                 }
190                 fieldPos++;
191             }
192             Assert.check(annotatedFields == positions.length);
193         }
194     }
195 
196     // utility methods
197     void findAnnotations(ClassFile cf, Method m, List&lt;TypeAnnotation&gt; annos) {
198         findAnnotations(cf, m, Attribute.RuntimeVisibleTypeAnnotations, annos);
199         findAnnotations(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, annos);
200     }
201 
202     void findAnnotations(ClassFile cf, Field m, List&lt;TypeAnnotation&gt; annos) {
203         findAnnotations(cf, m, Attribute.RuntimeVisibleTypeAnnotations, annos);
204         findAnnotations(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, annos);
205     }
206 
207     void findAnnotations(ClassFile cf, Method m, String name, List&lt;TypeAnnotation&gt; annos) {
208         int index = m.attributes.getIndex(cf.constant_pool, name);
209         if (index != -1) {
210             Attribute attr = m.attributes.get(index);
211             assert attr instanceof RuntimeTypeAnnotations_attribute;
212             RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;
213             annos.addAll(Arrays.asList(tAttr.annotations));
214         }
215 
216         int cindex = m.attributes.getIndex(cf.constant_pool, Attribute.Code);
217         if (cindex != -1) {
218             Attribute cattr = m.attributes.get(cindex);
219             assert cattr instanceof Code_attribute;
220             Code_attribute cAttr = (Code_attribute)cattr;
221             index = cAttr.attributes.getIndex(cf.constant_pool, name);
222             if (index != -1) {
223                 Attribute attr = cAttr.attributes.get(index);
224                 assert attr instanceof RuntimeTypeAnnotations_attribute;
225                 RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;
226                 annos.addAll(Arrays.asList(tAttr.annotations));
227             }
228         }
229     }
230 
231     void findAnnotations(ClassFile cf, Field m, String name, List&lt;TypeAnnotation&gt; annos) {
232         int index = m.attributes.getIndex(cf.constant_pool, name);
233         if (index != -1) {
234             Attribute attr = m.attributes.get(index);
235             assert attr instanceof RuntimeTypeAnnotations_attribute;
236             RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;
237             annos.addAll(Arrays.asList(tAttr.annotations));
238         }
239     }
240 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/launcher/SourceLauncherTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8192920 8204588
 27  * @summary Test source launcher
 28  * @library /tools/lib
 29  * @modules jdk.compiler/com.sun.tools.javac.api
 30  *          jdk.compiler/com.sun.tools.javac.launcher
 31  *          jdk.compiler/com.sun.tools.javac.main
 32  * @build toolbox.JavaTask toolbox.JavacTask toolbox.TestRunner toolbox.ToolBox
 33  * @run main SourceLauncherTest
 34  */
 35 
 36 import java.io.ByteArrayOutputStream;
 37 import java.io.File;
 38 import java.io.IOException;
 39 import java.io.PrintStream;
 40 import java.io.PrintWriter;
 41 import java.io.StringWriter;
 42 import java.lang.reflect.InvocationTargetException;
 43 import java.nio.file.Files;
 44 import java.nio.file.Path;
 45 import java.nio.file.Paths;
 46 import java.util.ArrayList;
 47 import java.util.Collections;
 48 import java.util.List;
 49 import java.util.Properties;
 50 import java.util.regex.Pattern;
 51 
 52 import com.sun.tools.javac.launcher.Main;
 53 
 54 import toolbox.JavaTask;
 55 import toolbox.JavacTask;
 56 import toolbox.Task;
 57 import toolbox.TestRunner;
 58 import toolbox.TestRunner;
 59 import toolbox.ToolBox;
 60 
 61 public class SourceLauncherTest extends TestRunner {
 62     public static void main(String... args) throws Exception {
 63         SourceLauncherTest t = new SourceLauncherTest();
 64         t.runTests(m -&gt; new Object[] { Paths.get(m.getName()) });
 65     }
 66 
 67     SourceLauncherTest() {
 68         super(System.err);
 69         tb = new ToolBox();
 70         System.err.println(&quot;version: &quot; + thisVersion);
 71     }
 72 
 73     private final ToolBox tb;
 74     private static final String thisVersion = System.getProperty(&quot;java.specification.version&quot;);
 75 
 76     /*
 77      * Positive tests.
 78      */
 79 
 80     @Test
 81     public void testHelloWorld(Path base) throws IOException {
 82         tb.writeJavaFiles(base,
 83             &quot;import java.util.Arrays;\n&quot; +
 84             &quot;class HelloWorld {\n&quot; +
 85             &quot;    public static void main(String... args) {\n&quot; +
 86             &quot;        System.out.println(\&quot;Hello World! \&quot; + Arrays.toString(args));\n&quot; +
 87             &quot;    }\n&quot; +
 88             &quot;}&quot;);
 89         testSuccess(base.resolve(&quot;HelloWorld.java&quot;), &quot;Hello World! [1, 2, 3]\n&quot;);
 90     }
 91 
 92     @Test
 93     public void testHelloWorldInPackage(Path base) throws IOException {
 94         tb.writeJavaFiles(base,
 95             &quot;package hello;\n&quot; +
 96             &quot;import java.util.Arrays;\n&quot; +
 97             &quot;class World {\n&quot; +
 98             &quot;    public static void main(String... args) {\n&quot; +
 99             &quot;        System.out.println(\&quot;Hello World! \&quot; + Arrays.toString(args));\n&quot; +
100             &quot;    }\n&quot; +
101             &quot;}&quot;);
102         testSuccess(base.resolve(&quot;hello&quot;).resolve(&quot;World.java&quot;), &quot;Hello World! [1, 2, 3]\n&quot;);
103     }
104 
105     @Test
106     public void testHelloWorldWithAux(Path base) throws IOException {
107         tb.writeJavaFiles(base,
108             &quot;import java.util.Arrays;\n&quot; +
109             &quot;class HelloWorld {\n&quot; +
110             &quot;    public static void main(String... args) {\n&quot; +
111             &quot;        Aux.write(args);\n&quot; +
112             &quot;    }\n&quot; +
113             &quot;}\n&quot; +
114             &quot;class Aux {\n&quot; +
115             &quot;    static void write(String... args) {\n&quot; +
116             &quot;        System.out.println(\&quot;Hello World! \&quot; + Arrays.toString(args));\n&quot; +
117             &quot;    }\n&quot; +
118             &quot;}&quot;);
119         testSuccess(base.resolve(&quot;HelloWorld.java&quot;), &quot;Hello World! [1, 2, 3]\n&quot;);
120     }
121 
122     @Test
123     public void testHelloWorldWithShebang(Path base) throws IOException {
124         tb.writeJavaFiles(base,
125             &quot;#!/usr/bin/java --source &quot; + thisVersion + &quot;\n&quot; +
126             &quot;import java.util.Arrays;\n&quot; +
127             &quot;class HelloWorld {\n&quot; +
128             &quot;    public static void main(String... args) {\n&quot; +
129             &quot;        System.out.println(\&quot;Hello World! \&quot; + Arrays.toString(args));\n&quot; +
130             &quot;    }\n&quot; +
131             &quot;}&quot;);
132         Files.copy(base.resolve(&quot;HelloWorld.java&quot;), base.resolve(&quot;HelloWorld&quot;));
133         testSuccess(base.resolve(&quot;HelloWorld&quot;), &quot;Hello World! [1, 2, 3]\n&quot;);
134     }
135 
136     @Test
137     public void testNoAnnoProcessing(Path base) throws IOException {
138         Path annoSrc = base.resolve(&quot;annoSrc&quot;);
139         tb.writeJavaFiles(annoSrc,
140             &quot;import java.util.*;\n&quot; +
141             &quot;import javax.annotation.processing.*;\n&quot; +
142             &quot;import javax.lang.model.element.*;\n&quot; +
143             &quot;@SupportedAnnotationTypes(\&quot;*\&quot;)\n&quot; +
144             &quot;public class AnnoProc extends AbstractProcessor {\n&quot; +
145             &quot;    public boolean process(Set&lt;? extends TypeElement&gt; annos, RoundEnvironment rEnv) {\n&quot; +
146             &quot;        throw new Error(\&quot;Annotation processor should not be invoked\&quot;);\n&quot; +
147             &quot;    }\n&quot; +
148             &quot;}\n&quot;);
149         Path annoClasses = Files.createDirectories(base.resolve(&quot;classes&quot;));
150         new JavacTask(tb)
151                 .outdir(annoClasses)
152                 .files(annoSrc.resolve(&quot;AnnoProc.java&quot;).toString())
153                 .run();
154         Path serviceFile = annoClasses.resolve(&quot;META-INF&quot;).resolve(&quot;services&quot;)
155                 .resolve(&quot;javax.annotation.processing.Processor&quot;);
156         tb.writeFile(serviceFile, &quot;AnnoProc&quot;);
157 
158         Path mainSrc = base.resolve(&quot;mainSrc&quot;);
159         tb.writeJavaFiles(mainSrc,
160             &quot;import java.util.Arrays;\n&quot; +
161             &quot;class HelloWorld {\n&quot; +
162             &quot;    public static void main(String... args) {\n&quot; +
163             &quot;        System.out.println(\&quot;Hello World! \&quot; + Arrays.toString(args));\n&quot; +
164             &quot;    }\n&quot; +
165             &quot;}&quot;);
166 
167         List&lt;String&gt; javacArgs = List.of(&quot;-classpath&quot;, annoClasses.toString());
168         List&lt;String&gt; classArgs = List.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);
169         String expect = &quot;Hello World! [1, 2, 3]\n&quot;;
170         Result r = run(mainSrc.resolve(&quot;HelloWorld.java&quot;), javacArgs, classArgs);
171         checkEqual(&quot;stdout&quot;, r.stdOut, expect);
172         checkEmpty(&quot;stderr&quot;, r.stdErr);
173         checkNull(&quot;exception&quot;, r.exception);
174     }
175 
176     @Test
177     public void testEnablePreview(Path base) throws IOException {
178         tb.writeJavaFiles(base,
179             &quot;import java.util.Arrays;\n&quot; +
180             &quot;class HelloWorld {\n&quot; +
181             &quot;    public static void main(String... args) {\n&quot; +
182             &quot;        System.out.println(\&quot;Hello World! \&quot; + Arrays.toString(args));\n&quot; +
183             &quot;    }\n&quot; +
184             &quot;}&quot;);
185 
186         String log = new JavaTask(tb)
187                 .vmOptions(&quot;--enable-preview&quot;, &quot;--source&quot;, thisVersion)
188                 .className(base.resolve(&quot;HelloWorld.java&quot;).toString())
189                 .classArgs(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)
190                 .run(Task.Expect.SUCCESS)
191                 .getOutput(Task.OutputKind.STDOUT);
192         checkEqual(&quot;stdout&quot;, log.trim(), &quot;Hello World! [1, 2, 3]&quot;);
193     }
194 
195     @Test
196     public void testCodeSource(Path base) throws IOException {
197         tb.writeJavaFiles(base,
198             &quot;import java.net.URL;\n&quot; +
199             &quot;class ShowCodeSource {\n&quot; +
200             &quot;    public static void main(String... args) {\n&quot; +
201             &quot;        URL u = ShowCodeSource.class.getProtectionDomain().getCodeSource().getLocation();\n&quot; +
202             &quot;        System.out.println(u);\n&quot; +
203             &quot;    }\n&quot; +
204             &quot;}&quot;);
205 
206         Path file = base.resolve(&quot;ShowCodeSource.java&quot;);
207         String log = new JavaTask(tb)
208                 .className(file.toString())
209                 .run(Task.Expect.SUCCESS)
210                 .getOutput(Task.OutputKind.STDOUT);
211         checkEqual(&quot;stdout&quot;, log.trim(), file.toAbsolutePath().toUri().toURL().toString());
212     }
213 
214     @Test
215     public void testPermissions(Path base) throws IOException {
216         Path policyFile = base.resolve(&quot;test.policy&quot;);
217         Path sourceFile = base.resolve(&quot;TestPermissions.java&quot;);
218 
219         tb.writeFile(policyFile,
220             &quot;grant codeBase \&quot;jrt:/jdk.compiler\&quot; {\n&quot; +
221             &quot;    permission java.security.AllPermission;\n&quot; +
222             &quot;};\n&quot; +
223             &quot;grant codeBase \&quot;&quot; + sourceFile.toUri().toURL() + &quot;\&quot; {\n&quot; +
224             &quot;    permission java.util.PropertyPermission \&quot;user.dir\&quot;, \&quot;read\&quot;;\n&quot; +
225             &quot;};\n&quot;);
226 
227         tb.writeJavaFiles(base,
228             &quot;import java.net.URL;\n&quot; +
229             &quot;class TestPermissions {\n&quot; +
230             &quot;    public static void main(String... args) {\n&quot; +
231             &quot;        System.out.println(\&quot;user.dir=\&quot; + System.getProperty(\&quot;user.dir\&quot;));\n&quot; +
232             &quot;        try {\n&quot; +
233             &quot;            System.setProperty(\&quot;user.dir\&quot;, \&quot;\&quot;);\n&quot; +
234             &quot;            System.out.println(\&quot;no exception\&quot;);\n&quot; +
235             &quot;            System.exit(1);\n&quot; +
236             &quot;        } catch (SecurityException e) {\n&quot; +
237             &quot;            System.out.println(\&quot;exception: \&quot; + e);\n&quot; +
238             &quot;        }\n&quot; +
239             &quot;    }\n&quot; +
240             &quot;}&quot;);
241 
242         String log = new JavaTask(tb)
243                 .vmOptions(&quot;-Djava.security.manager&quot;, &quot;-Djava.security.policy=&quot; + policyFile)
244                 .className(sourceFile.toString())
245                 .run(Task.Expect.SUCCESS)
246                 .getOutput(Task.OutputKind.STDOUT);
247         checkEqual(&quot;stdout&quot;, log.trim(),
248                 &quot;user.dir=&quot; + System.getProperty(&quot;user.dir&quot;) + &quot;\n&quot; +
249                 &quot;exception: java.security.AccessControlException: &quot; +
250                     &quot;access denied (\&quot;java.util.PropertyPermission\&quot; \&quot;user.dir\&quot; \&quot;write\&quot;)&quot;);
251     }
252 
253     public void testSystemProperty(Path base) throws IOException {
254         tb.writeJavaFiles(base,
255             &quot;class ShowProperty {\n&quot; +
256             &quot;    public static void main(String... args) {\n&quot; +
257             &quot;        System.out.println(System.getProperty(\&quot;jdk.launcher.sourcefile\&quot;));\n&quot; +
258             &quot;    }\n&quot; +
259             &quot;}&quot;);
260 
261         Path file = base.resolve(&quot;ShowProperty.java&quot;);
262         String log = new JavaTask(tb)
263                 .className(file.toString())
264                 .run(Task.Expect.SUCCESS)
265                 .getOutput(Task.OutputKind.STDOUT);
266         checkEqual(&quot;stdout&quot;, log.trim(), file.toAbsolutePath().toString());
267     }
268 
269     void testSuccess(Path file, String expect) throws IOException {
270         Result r = run(file, Collections.emptyList(), List.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;));
271         checkEqual(&quot;stdout&quot;, r.stdOut, expect);
272         checkEmpty(&quot;stderr&quot;, r.stdErr);
273         checkNull(&quot;exception&quot;, r.exception);
274     }
275 
276     /*
277      * Negative tests: such as cannot find or execute main method.
278      */
279 
280     @Test
281     public void testHelloWorldWithShebangJava(Path base) throws IOException {
282         tb.writeJavaFiles(base,
283             &quot;#!/usr/bin/java --source &quot; + thisVersion + &quot;\n&quot; +
284             &quot;import java.util.Arrays;\n&quot; +
285             &quot;class HelloWorld {\n&quot; +
286             &quot;    public static void main(String... args) {\n&quot; +
287             &quot;        System.out.println(\&quot;Hello World! \&quot; + Arrays.toString(args));\n&quot; +
288             &quot;    }\n&quot; +
289             &quot;}&quot;);
290         Path file = base.resolve(&quot;HelloWorld.java&quot;);
291         testError(file,
292             file + &quot;:1: error: illegal character: &#39;#&#39;\n&quot; +
293             &quot;#!/usr/bin/java --source &quot; + thisVersion + &quot;\n&quot; +
294             &quot;^\n&quot; +
295             file + &quot;:1: error: class, interface, or enum expected\n&quot; +
296             &quot;#!/usr/bin/java --source &quot; + thisVersion + &quot;\n&quot; +
297             &quot;  ^\n&quot; +
298             &quot;2 errors\n&quot;,
299             &quot;error: compilation failed&quot;);
300     }
301 
302     @Test
303     public void testNoClass(Path base) throws IOException {
304         Files.createDirectories(base);
305         Path file = base.resolve(&quot;NoClass.java&quot;);
306         Files.write(file, List.of(&quot;package p;&quot;));
307         testError(file, &quot;&quot;, &quot;error: no class declared in source file&quot;);
308     }
309 
310     @Test
311     public void testLoadClass(Path base) throws IOException {
312         Path src1 = base.resolve(&quot;src1&quot;);
313         Path file1 = src1.resolve(&quot;LoadClass.java&quot;);
314         tb.writeJavaFiles(src1,
315                 &quot;class LoadClass {\n&quot;
316                 + &quot;    public static void main(String... args) {\n&quot;
317                 + &quot;        System.out.println(\&quot;on classpath\&quot;);\n&quot;
318                 + &quot;    };\n&quot;
319                 + &quot;}\n&quot;);
320         Path classes1 = Files.createDirectories(base.resolve(&quot;classes&quot;));
321         new JavacTask(tb)
322                 .outdir(classes1)
323                 .files(file1)
324                 .run();
325         String log1 = new JavaTask(tb)
326                 .classpath(classes1.toString())
327                 .className(&quot;LoadClass&quot;)
328                 .run(Task.Expect.SUCCESS)
329                 .getOutput(Task.OutputKind.STDOUT);
330         checkEqual(&quot;stdout&quot;, log1.trim(),
331                 &quot;on classpath&quot;);
332 
333         Path src2 = base.resolve(&quot;src2&quot;);
334         Path file2 = src2.resolve(&quot;LoadClass.java&quot;);
335         tb.writeJavaFiles(src2,
336                 &quot;class LoadClass {\n&quot;
337                 + &quot;    public static void main(String... args) {\n&quot;
338                 + &quot;        System.out.println(\&quot;in source file\&quot;);\n&quot;
339                 + &quot;    };\n&quot;
340                 + &quot;}\n&quot;);
341         String log2 = new JavaTask(tb)
342                 .classpath(classes1.toString())
343                 .className(file2.toString())
344                 .run(Task.Expect.SUCCESS)
345                 .getOutput(Task.OutputKind.STDOUT);
346         checkEqual(&quot;stdout&quot;, log2.trim(),
347                 &quot;in source file&quot;);
348     }
349 
350     @Test
351     public void testGetResource(Path base) throws IOException {
352         Path src = base.resolve(&quot;src&quot;);
353         Path file = src.resolve(&quot;GetResource.java&quot;);
354         tb.writeJavaFiles(src,
355                 &quot;class GetResource {\n&quot;
356                 + &quot;    public static void main(String... args) {\n&quot;
357                 + &quot;        System.out.println(GetResource.class.getClassLoader().getResource(\&quot;GetResource.class\&quot;));\n&quot;
358                 + &quot;    };\n&quot;
359                 + &quot;}\n&quot;);
360         Path classes = Files.createDirectories(base.resolve(&quot;classes&quot;));
361         new JavacTask(tb)
362                 .outdir(classes)
363                 .files(file)
364                 .run();
365 
366         String log = new JavaTask(tb)
367                 .classpath(classes.toString())
368                 .className(file.toString())
369                 .run(Task.Expect.SUCCESS)
370                 .getOutput(Task.OutputKind.STDOUT);
371         checkMatch(&quot;stdout&quot;, log.trim(),
372                 Pattern.compile(&quot;sourcelauncher-memoryclassloader[0-9]+:GetResource.class&quot;));
373     }
374 
375     @Test
376     public void testGetResources(Path base) throws IOException {
377         Path src = base.resolve(&quot;src&quot;);
378         Path file = src.resolve(&quot;GetResources.java&quot;);
379         tb.writeJavaFiles(src,
380                 &quot;import java.io.*; import java.net.*; import java.util.*;\n&quot;
381                 + &quot;class GetResources {\n&quot;
382                 + &quot;    public static void main(String... args) throws IOException {\n&quot;
383                 + &quot;        Enumeration&lt;URL&gt; e =\n&quot;
384                 + &quot;            GetResources.class.getClassLoader().getResources(\&quot;GetResources.class\&quot;);\n&quot;
385                 + &quot;        while (e.hasMoreElements()) System.out.println(e.nextElement());\n&quot;
386                 + &quot;    };\n&quot;
387                 + &quot;}\n&quot;);
388         Path classes = Files.createDirectories(base.resolve(&quot;classes&quot;));
389         new JavacTask(tb)
390                 .outdir(classes)
391                 .files(file)
392                 .run();
393 
394         List&lt;String&gt; log = new JavaTask(tb)
395                 .classpath(classes.toString())
396                 .className(file.toString())
397                 .run(Task.Expect.SUCCESS)
398                 .getOutputLines(Task.OutputKind.STDOUT);
399         checkMatch(&quot;stdout:0&quot;, log.get(0).trim(),
400                 Pattern.compile(&quot;sourcelauncher-memoryclassloader[0-9]+:GetResources.class&quot;));
401         checkMatch(&quot;stdout:1&quot;, log.get(1).trim(),
402                 Pattern.compile(&quot;file:/.*/testGetResources/classes/GetResources.class&quot;));
403     }
404 
405     @Test
406     public void testSyntaxErr(Path base) throws IOException {
407         tb.writeJavaFiles(base, &quot;class SyntaxErr {&quot;);
408         Path file = base.resolve(&quot;SyntaxErr.java&quot;);
409         testError(file,
410                 file + &quot;:1: error: reached end of file while parsing\n&quot; +
411                 &quot;class SyntaxErr {\n&quot; +
412                 &quot;                 ^\n&quot; +
413                 &quot;1 error\n&quot;,
414                 &quot;error: compilation failed&quot;);
415     }
416 
417     @Test
418     public void testNoSourceOnClassPath(Path base) throws IOException {
419         Path auxSrc = base.resolve(&quot;auxSrc&quot;);
420         tb.writeJavaFiles(auxSrc,
421             &quot;public class Aux {\n&quot; +
422             &quot;    static final String MESSAGE = \&quot;Hello World\&quot;;\n&quot; +
423             &quot;}\n&quot;);
424 
425         Path mainSrc = base.resolve(&quot;mainSrc&quot;);
426         tb.writeJavaFiles(mainSrc,
427             &quot;import java.util.Arrays;\n&quot; +
428             &quot;class HelloWorld {\n&quot; +
429             &quot;    public static void main(String... args) {\n&quot; +
430             &quot;        System.out.println(Aux.MESSAGE + Arrays.toString(args));\n&quot; +
431             &quot;    }\n&quot; +
432             &quot;}&quot;);
433 
434         List&lt;String&gt; javacArgs = List.of(&quot;-classpath&quot;, auxSrc.toString());
435         List&lt;String&gt; classArgs = List.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);
436         String FS = File.separator;
437         String expectStdErr =
438             &quot;testNoSourceOnClassPath&quot; + FS + &quot;mainSrc&quot; + FS + &quot;HelloWorld.java:4: error: cannot find symbol\n&quot; +
439             &quot;        System.out.println(Aux.MESSAGE + Arrays.toString(args));\n&quot; +
440             &quot;                           ^\n&quot; +
441             &quot;  symbol:   variable Aux\n&quot; +
442             &quot;  location: class HelloWorld\n&quot; +
443             &quot;1 error\n&quot;;
444         Result r = run(mainSrc.resolve(&quot;HelloWorld.java&quot;), javacArgs, classArgs);
445         checkEmpty(&quot;stdout&quot;, r.stdOut);
446         checkEqual(&quot;stderr&quot;, r.stdErr, expectStdErr);
447         checkFault(&quot;exception&quot;, r.exception, &quot;error: compilation failed&quot;);
448     }
449 
450     @Test
451     public void testClassNotFound(Path base) throws IOException {
452         Path src = base.resolve(&quot;src&quot;);
453         Path file = src.resolve(&quot;ClassNotFound.java&quot;);
454         tb.writeJavaFiles(src,
455                 &quot;class ClassNotFound {\n&quot;
456                 + &quot;    public static void main(String... args) {\n&quot;
457                 + &quot;        try {\n&quot;
458                 + &quot;            Class.forName(\&quot;NoSuchClass\&quot;);\n&quot;
459                 + &quot;            System.out.println(\&quot;no exception\&quot;);\n&quot;
460                 + &quot;            System.exit(1);\n&quot;
461                 + &quot;        } catch (ClassNotFoundException e) {\n&quot;
462                 + &quot;            System.out.println(\&quot;Expected exception thrown: \&quot; + e);\n&quot;
463                 + &quot;        }\n&quot;
464                 + &quot;    };\n&quot;
465                 + &quot;}\n&quot;);
466         Path classes = Files.createDirectories(base.resolve(&quot;classes&quot;));
467         new JavacTask(tb)
468                 .outdir(classes)
469                 .files(file)
470                 .run();
471 
472         String log = new JavaTask(tb)
473                 .classpath(classes.toString())
474                 .className(file.toString())
475                 .run(Task.Expect.SUCCESS)
476                 .getOutput(Task.OutputKind.STDOUT);
477         checkEqual(&quot;stdout&quot;, log.trim(),
478                 &quot;Expected exception thrown: java.lang.ClassNotFoundException: NoSuchClass&quot;);
479     }
480 
481     // For any source file that is invoked through the OS shebang mechanism, invalid shebang
482     // lines will be caught and handled by the OS, before the launcher is even invoked.
483     // However, if such a file is passed directly to the launcher, perhaps using the --source
484     // option, a well-formed shebang line will be removed but a badly-formed one will be not be
485     // removed and will cause compilation errors.
486     @Test
487     public void testBadShebang(Path base) throws IOException {
488         tb.writeJavaFiles(base,
489             &quot;#/usr/bin/java --source &quot; + thisVersion + &quot;\n&quot; +
490             &quot;import java.util.Arrays;\n&quot; +
491             &quot;class HelloWorld {\n&quot; +
492             &quot;    public static void main(String... args) {\n&quot; +
493             &quot;        System.out.println(\&quot;Hello World! \&quot; + Arrays.toString(args));\n&quot; +
494             &quot;    }\n&quot; +
495             &quot;}&quot;);
496         Path file = base.resolve(&quot;HelloWorld.java&quot;);
497         testError(file,
498             file + &quot;:1: error: illegal character: &#39;#&#39;\n&quot; +
499             &quot;#/usr/bin/java --source &quot; + thisVersion + &quot;\n&quot; +
500             &quot;^\n&quot; +
501             file + &quot;:1: error: class, interface, or enum expected\n&quot; +
502             &quot;#/usr/bin/java --source &quot; + thisVersion + &quot;\n&quot; +
503             &quot;  ^\n&quot; +
504             &quot;2 errors\n&quot;,
505             &quot;error: compilation failed&quot;);
506     }
507 
508     @Test
509     public void testBadSourceOpt(Path base) throws IOException {
510         Files.createDirectories(base);
511         Path file = base.resolve(&quot;DummyClass.java&quot;);
512         Files.write(file, List.of(&quot;class DummyClass { }&quot;));
513         Properties sysProps = System.getProperties();
514         Properties p = new Properties(sysProps);
515         p.setProperty(&quot;jdk.internal.javac.source&quot;, &quot;&lt;BAD&gt;&quot;);
516         System.setProperties(p);
517         try {
518             testError(file, &quot;&quot;, &quot;error: invalid value for --source option: &lt;BAD&gt;&quot;);
519         } finally {
520             System.setProperties(sysProps);
521         }
522     }
523 
524     @Test
525     public void testEnablePreviewNoSource(Path base) throws IOException {
526         tb.writeJavaFiles(base,
527             &quot;import java.util.Arrays;\n&quot; +
528             &quot;class HelloWorld {\n&quot; +
529             &quot;    public static void main(String... args) {\n&quot; +
530             &quot;        System.out.println(\&quot;Hello World! \&quot; + Arrays.toString(args));\n&quot; +
531             &quot;    }\n&quot; +
532             &quot;}&quot;);
533 
534         String log = new JavaTask(tb)
535                 .vmOptions(&quot;--enable-preview&quot;)
536                 .className(base.resolve(&quot;HelloWorld.java&quot;).toString())
537                 .run(Task.Expect.FAIL)
538                 .getOutput(Task.OutputKind.STDERR);
539         checkEqual(&quot;stderr&quot;, log.trim(),
540                 &quot;error: --enable-preview must be used with --source&quot;);
541     }
542 
543     @Test
544     public void testNoMain(Path base) throws IOException {
545         tb.writeJavaFiles(base, &quot;class NoMain { }&quot;);
546         testError(base.resolve(&quot;NoMain.java&quot;), &quot;&quot;,
547                 &quot;error: can&#39;t find main(String[]) method in class: NoMain&quot;);
548     }
549 
550     @Test
551     public void testMainBadParams(Path base) throws IOException {
552         tb.writeJavaFiles(base,
553                 &quot;class BadParams { public static void main() { } }&quot;);
554         testError(base.resolve(&quot;BadParams.java&quot;), &quot;&quot;,
555                 &quot;error: can&#39;t find main(String[]) method in class: BadParams&quot;);
556     }
557 
558     @Test
559     public void testMainNotPublic(Path base) throws IOException {
560         tb.writeJavaFiles(base,
561                 &quot;class NotPublic { static void main(String... args) { } }&quot;);
562         testError(base.resolve(&quot;NotPublic.java&quot;), &quot;&quot;,
563                 &quot;error: &#39;main&#39; method is not declared &#39;public static&#39;&quot;);
564     }
565 
566     @Test
567     public void testMainNotStatic(Path base) throws IOException {
568         tb.writeJavaFiles(base,
569                 &quot;class NotStatic { public void main(String... args) { } }&quot;);
570         testError(base.resolve(&quot;NotStatic.java&quot;), &quot;&quot;,
571                 &quot;error: &#39;main&#39; method is not declared &#39;public static&#39;&quot;);
572     }
573 
574     @Test
575     public void testMainNotVoid(Path base) throws IOException {
576         tb.writeJavaFiles(base,
577                 &quot;class NotVoid { public static int main(String... args) { return 0; } }&quot;);
578         testError(base.resolve(&quot;NotVoid.java&quot;), &quot;&quot;,
579                 &quot;error: &#39;main&#39; method is not declared with a return type of &#39;void&#39;&quot;);
580     }
581 
582     @Test
583     public void testClassInModule(Path base) throws IOException {
584         tb.writeJavaFiles(base, &quot;package java.net; class InModule { }&quot;);
585         Path file = base.resolve(&quot;java&quot;).resolve(&quot;net&quot;).resolve(&quot;InModule.java&quot;);
586         testError(file,
587                 file + &quot;:1: error: package exists in another module: java.base\n&quot; +
588                 &quot;package java.net; class InModule { }\n&quot; +
589                 &quot;^\n&quot; +
590                 &quot;1 error\n&quot;,
591                 &quot;error: compilation failed&quot;);
592     }
593 
594     void testError(Path file, String expectStdErr, String expectFault) throws IOException {
595         Result r = run(file, Collections.emptyList(), List.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;));
596         checkEmpty(&quot;stdout&quot;, r.stdOut);
597         checkEqual(&quot;stderr&quot;, r.stdErr, expectStdErr);
598         checkFault(&quot;exception&quot;, r.exception, expectFault);
599     }
600 
601     /*
602      * Tests in which main throws an exception.
603      */
604     @Test
605     public void testTargetException1(Path base) throws IOException {
606         tb.writeJavaFiles(base,
607             &quot;import java.util.Arrays;\n&quot; +
608             &quot;class Thrower {\n&quot; +
609             &quot;    public static void main(String... args) {\n&quot; +
610             &quot;        throwWhenZero(Integer.parseInt(args[0]));\n&quot; +
611             &quot;    }\n&quot; +
612             &quot;    static void throwWhenZero(int arg) {\n&quot; +
613             &quot;        if (arg == 0) throw new Error(\&quot;zero!\&quot;);\n&quot; +
614             &quot;        throwWhenZero(arg - 1);\n&quot; +
615             &quot;    }\n&quot; +
616             &quot;}&quot;);
617         Path file = base.resolve(&quot;Thrower.java&quot;);
618         Result r = run(file, Collections.emptyList(), List.of(&quot;3&quot;));
619         checkEmpty(&quot;stdout&quot;, r.stdOut);
620         checkEmpty(&quot;stderr&quot;, r.stdErr);
621         checkTrace(&quot;exception&quot;, r.exception,
622                 &quot;java.lang.Error: zero!&quot;,
623                 &quot;at Thrower.throwWhenZero(Thrower.java:7)&quot;,
624                 &quot;at Thrower.throwWhenZero(Thrower.java:8)&quot;,
625                 &quot;at Thrower.throwWhenZero(Thrower.java:8)&quot;,
626                 &quot;at Thrower.throwWhenZero(Thrower.java:8)&quot;,
627                 &quot;at Thrower.main(Thrower.java:4)&quot;);
628     }
629 
630     Result run(Path file, List&lt;String&gt; runtimeArgs, List&lt;String&gt; appArgs) {
631         List&lt;String&gt; args = new ArrayList&lt;&gt;();
632         args.add(file.toString());
633         args.addAll(appArgs);
634 
635         PrintStream prev = System.out;
636         ByteArrayOutputStream baos = new ByteArrayOutputStream();
637         try (PrintStream out = new PrintStream(baos, true)) {
638             System.setOut(out);
639             StringWriter sw = new StringWriter();
640             try (PrintWriter err = new PrintWriter(sw, true)) {
641                 Main m = new Main(err);
642                 m.run(toArray(runtimeArgs), toArray(args));
643                 return new Result(baos.toString(), sw.toString(), null);
644             } catch (Throwable t) {
645                 return new Result(baos.toString(), sw.toString(), t);
646             }
647         } finally {
648             System.setOut(prev);
649         }
650     }
651 
652     void checkEqual(String name, String found, String expect) {
653         expect = expect.replace(&quot;\n&quot;, tb.lineSeparator);
654         out.println(name + &quot;: &quot; + found);
655         if (!expect.equals(found)) {
656             error(&quot;Unexpected output; expected: &quot; + expect);
657         }
658     }
659 
660     void checkMatch(String name, String found, Pattern expect) {
661         out.println(name + &quot;: &quot; + found);
662         if (!expect.matcher(found).matches()) {
663             error(&quot;Unexpected output; expected match for: &quot; + expect);
664         }
665     }
666 
667     void checkEmpty(String name, String found) {
668         out.println(name + &quot;: &quot; + found);
669         if (!found.isEmpty()) {
670             error(&quot;Unexpected output; expected empty string&quot;);
671         }
672     }
673 
674     void checkNull(String name, Throwable found) {
675         out.println(name + &quot;: &quot; + found);
676         if (found != null) {
677             error(&quot;Unexpected exception; expected null&quot;);
678         }
679     }
680 
681     void checkFault(String name, Throwable found, String expect) {
682         expect = expect.replace(&quot;\n&quot;, tb.lineSeparator);
683         out.println(name + &quot;: &quot; + found);
684         if (found == null) {
685             error(&quot;No exception thrown; expected Main.Fault&quot;);
686         } else {
687             if (!(found instanceof Main.Fault)) {
688                 error(&quot;Unexpected exception; expected Main.Fault&quot;);
689             }
690             if (!(found.getMessage().equals(expect))) {
691                 error(&quot;Unexpected detail message; expected: &quot; + expect);
692             }
693         }
694     }
695 
696     void checkTrace(String name, Throwable found, String... expect) {
697         if (!(found instanceof InvocationTargetException)) {
698             error(&quot;Unexpected exception; expected InvocationTargetException&quot;);
699             out.println(&quot;Found:&quot;);
700             found.printStackTrace(out);
701         }
702         StringWriter sw = new StringWriter();
703         try (PrintWriter pw = new PrintWriter(sw)) {
704             ((InvocationTargetException) found).getTargetException().printStackTrace(pw);
705         }
706         String trace = sw.toString();
707         out.println(name + &quot;:\n&quot; + trace);
708         String[] traceLines = trace.trim().split(&quot;[\r\n]+\\s+&quot;);
709         try {
710             tb.checkEqual(List.of(traceLines), List.of(expect));
711         } catch (Error e) {
712             error(e.getMessage());
713         }
714     }
715 
716     String[] toArray(List&lt;String&gt; list) {
717         return list.toArray(new String[list.size()]);
718     }
719 
720     class Result {
721         private final String stdOut;
722         private final String stdErr;
723         private final Throwable exception;
724 
725         Result(String stdOut, String stdErr, Throwable exception) {
726             this.stdOut = stdOut;
727             this.stdErr = stdErr;
728             this.exception = exception;
729         }
730     }
731 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/doctree/dcapi/DocCommentTreeApiTester.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug  8132096 8157611 8190552
 27  * @summary test the APIs  in the DocTree interface
 28  * @modules jdk.compiler/com.sun.tools.javac.api
 29  *          jdk.compiler/com.sun.tools.javac.file
 30  *          jdk.compiler/com.sun.tools.javac.tree
 31  *          jdk.compiler/com.sun.tools.javac.util
 32  * @compile ../DocCommentTester.java DocCommentTreeApiTester.java
 33  * @run main DocCommentTreeApiTester
 34  */
 35 
 36 import java.io.BufferedReader;
 37 import java.io.File;
 38 import java.io.IOException;
 39 import java.io.PrintWriter;
 40 import java.io.Reader;
 41 import java.io.StringWriter;
<a name="2" id="anc2"></a><span class="line-added"> 42 import java.nio.file.DirectoryStream;</span>
 43 import java.nio.file.Files;
 44 import java.nio.file.Path;
 45 import java.text.BreakIterator;
 46 import java.util.ArrayList;
 47 import java.util.Collections;
 48 import java.util.List;
 49 import java.util.Locale;
 50 
 51 import javax.lang.model.element.Element;
 52 import javax.lang.model.element.PackageElement;
 53 import javax.lang.model.util.Elements;
 54 import javax.tools.FileObject;
 55 import javax.tools.JavaFileObject;
 56 import javax.tools.JavaFileObject.Kind;
 57 import javax.tools.StandardJavaFileManager;
 58 
 59 import com.sun.source.doctree.DocTree;
 60 import com.sun.source.doctree.DocCommentTree;
 61 import com.sun.source.util.DocTreePath;
 62 import com.sun.source.util.DocTrees;
 63 import com.sun.source.util.JavacTask;
 64 import com.sun.tools.javac.api.JavacTool;
 65 import com.sun.tools.javac.tree.DocPretty;
 66 
 67 public class DocCommentTreeApiTester {
 68 
 69     private static final String MARKER_START = &quot;EXPECT_START&quot;;
 70     private static final String MARKER_END   = &quot;EXPECT_END&quot;;
 71 
 72     private static final String testSrc = System.getProperty(&quot;test.src&quot;, &quot;.&quot;);
 73 
 74     private static final JavacTool javac = JavacTool.create();
 75 
 76     private static final DocCommentTester.ASTChecker.Printer printer =
 77             new DocCommentTester.ASTChecker.Printer();
 78     int pass;
 79     int fail;
 80 
 81     public DocCommentTreeApiTester() {
 82         pass = 0;
 83         fail = 0;
 84     }
 85 
 86     public static void main(String... args) throws Exception {
 87         DocCommentTreeApiTester test = new DocCommentTreeApiTester();
 88         try {
 89             // test getting a DocTree from an element
 90             test.runElementAndBreakIteratorTests(&quot;Anchor.java&quot;, &quot;Anchor test.&quot;);
 91 
 92             // test relative paths in a class within a package
 93             test.runRelativePathTest(&quot;pkg/Anchor.java&quot;, &quot;package.html&quot;, true);
 94 
 95             // tests files relative path in an unnamed package
 96             test.runRelativePathTest(&quot;Anchor.java&quot;, &quot;overview0.html&quot;, true);
 97 
 98             // test doctree path and Doc
 99             test.runDocTreePath(&quot;Anchor.java&quot;, &quot;package.html&quot;);
100 
101             // test for correct parsing using valid and some invalid html tags
<a name="3" id="anc3"></a><span class="line-modified">102             try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(Path.of(testSrc))) {</span>
<span class="line-modified">103                 for (Path entry: ds) {</span>
<span class="line-modified">104                     String name = entry.getFileName().toString();</span>
<span class="line-modified">105                     if (name.matches(&quot;overview[0-9]+\\.html&quot;)) {</span>
<span class="line-modified">106                         test.runFileObjectTest(name);</span>
<span class="line-modified">107                     }</span>
<span class="line-modified">108                 }</span>
<span class="line-modified">109             }</span>
110 
111         } finally {
112             test.status();
113         }
114     }
115     void status() throws Exception {
116         System.err.println(&quot;pass:&quot; + pass + &quot;  fail: &quot; + fail);
117         if (fail &gt; 0) {
118             throw new Exception(&quot;Fails&quot;);
119         }
120     }
121 
122     /**
123      * Tests getting a DocCommentTree from an element, as well
124      * as test if break iterator setter/getter works correctly.
125      *
126      * @param javaFileName a test file to be processed
127      * @param expected the expected output
128      * @throws java.io.IOException
129      */
130     public void runElementAndBreakIteratorTests(String javaFileName, String expected) throws IOException {
131         List&lt;File&gt; javaFiles = new ArrayList&lt;&gt;();
132         javaFiles.add(new File(testSrc, javaFileName));
133 
134         List&lt;File&gt; dirs = new ArrayList&lt;&gt;();
135         dirs.add(new File(testSrc));
136 
137         try (StandardJavaFileManager fm = javac.getStandardFileManager(null, null, null)) {
138             fm.setLocation(javax.tools.StandardLocation.SOURCE_PATH, dirs);
139             Iterable&lt;? extends JavaFileObject&gt; fos = fm.getJavaFileObjectsFromFiles(javaFiles);
140 
141             final JavacTask t = javac.getTask(null, fm, null, null, null, fos);
142             final DocTrees trees = DocTrees.instance(t);
143 
144             Iterable&lt;? extends Element&gt; elements = t.analyze();
145 
146             Element klass = elements.iterator().next();
147             DocCommentTree dcTree = trees.getDocCommentTree(klass);
148 
149             List&lt;? extends DocTree&gt; firstSentence = dcTree.getFirstSentence();
150             StringWriter sw = new StringWriter();
151             DocPretty pretty = new DocPretty(sw);
152             pretty.print(firstSentence);
153             check(&quot;getDocCommentTree(Element)&quot;, expected, sw.toString());
154 
155             BreakIterator bi = BreakIterator.getSentenceInstance(Locale.FRENCH);
156             trees.setBreakIterator(bi);
157             BreakIterator nbi = trees.getBreakIterator();
158             if (bi.equals(nbi)) {
159                 pass++;
160                 check(&quot;getDocCommentTree(Element) with BreakIterator&quot;, expected, sw.toString());
161             } else {
162                 fail++;
163                 System.err.println(&quot;BreakIterators don&#39;t match&quot;);
164             }
165         }
166     }
167 
168     /**
169      * Tests DocTrees.getDocCommentTree(Element e, String relpath) using relative path.
170      *
171      * @param javaFileName the reference java file
172      * @param fileName the relative html file
173      * @throws java.lang.Exception ouch
174      */
175     public void runRelativePathTest(String javaFileName, String fileName,
176                                     boolean bodyOnly) throws Exception  {
177         List&lt;File&gt; javaFiles = new ArrayList&lt;&gt;();
178         javaFiles.add(new File(testSrc, javaFileName));
179 
180         List&lt;File&gt; dirs = new ArrayList&lt;&gt;();
181         dirs.add(new File(testSrc));
182 
183         try (StandardJavaFileManager fm = javac.getStandardFileManager(null, null, null)) {
184             fm.setLocation(javax.tools.StandardLocation.SOURCE_PATH, dirs);
185             Iterable&lt;? extends JavaFileObject&gt; fos = fm.getJavaFileObjectsFromFiles(javaFiles);
186 
187             final JavacTask t = javac.getTask(null, fm, null, null, null, fos);
188             final DocTrees trees = DocTrees.instance(t);
189 
190             Iterable&lt;? extends Element&gt; elements = t.analyze();
191 
192             Element klass = elements.iterator().next();
193 
194             DocCommentTree dcTree = trees.getDocCommentTree(klass, fileName);
195 
196             if (dcTree == null)
197                 throw new Error(&quot;invalid input: &quot; + fileName);
198 
199             StringWriter sw = new StringWriter();
200             printer.print(dcTree, sw);
201             String found = sw.toString();
202 
203             FileObject htmlFo = fm.getFileForInput(javax.tools.StandardLocation.SOURCE_PATH,
204                     t.getElements().getPackageOf(klass).getQualifiedName().toString(),
205                     fileName + &quot;.out&quot;);
206 
207             String expected = getExpected(htmlFo.openReader(true));
208             astcheck(fileName, expected, found);
209         }
210     }
211 
212     /**
213      * Tests DocTrees.getDocCommentTree(FileObject fo).
214      *
215      * @param htmlfileName the file to be parsed
216      * @throws Exception when an error occurs.
217      */
218     public void runFileObjectTest(String htmlfileName) throws Exception {
219         List&lt;File&gt; javaFiles =  Collections.emptyList();
220 
221         List&lt;File&gt; otherFiles = new ArrayList&lt;&gt;();
222         otherFiles.add(new File(testSrc, htmlfileName));
223         otherFiles.add(new File(testSrc, htmlfileName + &quot;.out&quot;));
224 
225         try (StandardJavaFileManager fm = javac.getStandardFileManager(null, null, null)) {
226             Iterable&lt;? extends JavaFileObject&gt; fos = fm.getJavaFileObjectsFromFiles(javaFiles);
227             Iterable&lt;? extends JavaFileObject&gt; others = fm.getJavaFileObjectsFromFiles(otherFiles);
228 
229             final JavacTask t = javac.getTask(null, fm, null, null, null, fos);
230             final DocTrees trees = DocTrees.instance(t);
231 
232             StringWriter sw = new StringWriter();
233             DocCommentTree dct = null;
234             String expected = null;
235             for (JavaFileObject jfo : others) {
236                 switch (jfo.getKind()) {
237                     case HTML:
238                         dct = trees.getDocCommentTree(jfo);
239                         if (dct == null)
240                             throw new Exception(&quot;invalid input: &quot; + jfo);
241                         break;
242                     default:
243                         expected = getExpected(jfo.openReader(true));
244                 }
245             }
246 
247             printer.print(dct, sw);
248             String found = sw.toString();
249             astcheck(otherFiles.toString(), expected, found);
250         }
251     }
252 
253     /**
254      * Tests DocTrees.getDocTreePath(PackageElement p, FileObject fo).
255      *
256      * @param javaFileName the java anchor file
257      * @param pkgFileName the package file name
258      * @throws Exception e if something goes awry
259      */
260     public void runDocTreePath(String javaFileName, String pkgFileName) throws Exception  {
261         List&lt;File&gt; javaFiles = new ArrayList&lt;&gt;();
262         javaFiles.add(new File(testSrc, javaFileName));
263 
264         List&lt;File&gt; otherFiles = new ArrayList&lt;&gt;();
265         otherFiles.add(new File(testSrc, pkgFileName + &quot;.out&quot;));
266 
267         List&lt;File&gt; dirs = new ArrayList&lt;&gt;();
268         dirs.add(new File(testSrc));
269 
270         try (StandardJavaFileManager fm = javac.getStandardFileManager(null, null, null)) {
271             fm.setLocation(javax.tools.StandardLocation.SOURCE_PATH, dirs);
272             Iterable&lt;? extends JavaFileObject&gt; fos = fm.getJavaFileObjectsFromFiles(javaFiles);
273 
274             final JavacTask t = javac.getTask(null, fm, null, null, null, fos);
275             final DocTrees trees = DocTrees.instance(t);
276             final Elements elementUtils = t.getElements();
277 
278             Iterable&lt;? extends Element&gt; elements = t.analyze();
279 
280             Element klass = elements.iterator().next();
281             PackageElement pkg = elementUtils.getPackageOf(klass);
282 
283             FileObject htmlFo = fm.getFileForInput(javax.tools.StandardLocation.SOURCE_PATH,
284                     t.getElements().getPackageOf(klass).getQualifiedName().toString(),
285                     &quot;package.html&quot;);
286             DocTreePath treePath = trees.getDocTreePath(htmlFo, pkg);
287 
288             if (treePath == null) {
289                 throw new Exception(&quot;invalid input: &quot; + htmlFo);
290             }
291 
292             DocCommentTree dcTree = treePath.getDocComment();
293             if (dcTree == null)
294                 throw new Exception(&quot;invalid input&quot; + htmlFo);
295 
296             StringWriter sw = new StringWriter();
297             printer.print(dcTree, sw);
298             String found = sw.toString();
299             Iterable&lt;? extends JavaFileObject&gt; oos = fm.getJavaFileObjectsFromFiles(otherFiles);
300             JavaFileObject otherFo = oos.iterator().next();
301             String expected = getExpected(otherFo.openReader(true));
302 
303             astcheck(pkgFileName, expected, found);
304         }
305     }
306 
307     void astcheck(String testinfo, String expected, String found) {
308         System.err.print(&quot;ASTChecker: &quot; + testinfo);
309         check0(expected, found);
310     }
311     void check(String testinfo, String expected, String found) {
312         System.err.print(testinfo);
313         check0(expected, found);
314     }
315     void check0(String expected, String found) {
316         if (expected.equals(found)) {
317             pass++;
318             System.err.println(&quot; PASS&quot;);
319         } else {
320             fail++;
321             System.err.println(&quot; FAILED&quot;);
322             System.err.println(&quot;Expect:\n&quot; + expected);
323             System.err.println(&quot;Found:\n&quot; + found);
324         }
325     }
326 
327     String getExpected(Reader inrdr) throws IOException {
328         BufferedReader rdr = new BufferedReader(inrdr);
329         List&lt;String&gt; lines = new ArrayList&lt;&gt;();
330         String line = rdr.readLine();
331         while (line != null) {
332             lines.add(line);
333             line = rdr.readLine();
334         }
335         return getExpected(lines);
336     }
337 
338     String getExpected(List&lt;String&gt; lines) {
339         boolean start = false;
340         StringWriter sw = new StringWriter();
341         PrintWriter out = new PrintWriter(sw);
342         for (String line : lines) {
343             if (!start) {
344                 start = line.startsWith(MARKER_START);
345                 continue;
346             }
347             if (line.startsWith(MARKER_END)) {
348                 out.flush();
349                 return sw.toString();
350             }
351             out.println(line);
352         }
353         return out.toString() + &quot;Warning: html comment end not found&quot;;
354     }
355 }
356 
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
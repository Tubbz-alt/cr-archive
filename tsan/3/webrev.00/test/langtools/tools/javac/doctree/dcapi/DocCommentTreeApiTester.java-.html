<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/doctree/dcapi/DocCommentTreeApiTester.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug  8132096 8157611 8190552
 27  * @summary test the APIs  in the DocTree interface
 28  * @modules jdk.compiler/com.sun.tools.javac.api
 29  *          jdk.compiler/com.sun.tools.javac.file
 30  *          jdk.compiler/com.sun.tools.javac.tree
 31  *          jdk.compiler/com.sun.tools.javac.util
 32  * @compile ../DocCommentTester.java DocCommentTreeApiTester.java
 33  * @run main DocCommentTreeApiTester
 34  */
 35 
 36 import java.io.BufferedReader;
 37 import java.io.File;
 38 import java.io.IOException;
 39 import java.io.PrintWriter;
 40 import java.io.Reader;
 41 import java.io.StringWriter;
 42 import java.nio.file.Files;
 43 import java.nio.file.Path;
 44 import java.text.BreakIterator;
 45 import java.util.ArrayList;
 46 import java.util.Collections;
 47 import java.util.List;
 48 import java.util.Locale;
 49 
 50 import javax.lang.model.element.Element;
 51 import javax.lang.model.element.PackageElement;
 52 import javax.lang.model.util.Elements;
 53 import javax.tools.FileObject;
 54 import javax.tools.JavaFileObject;
 55 import javax.tools.JavaFileObject.Kind;
 56 import javax.tools.StandardJavaFileManager;
 57 
 58 import com.sun.source.doctree.DocTree;
 59 import com.sun.source.doctree.DocCommentTree;
 60 import com.sun.source.util.DocTreePath;
 61 import com.sun.source.util.DocTrees;
 62 import com.sun.source.util.JavacTask;
 63 import com.sun.tools.javac.api.JavacTool;
 64 import com.sun.tools.javac.tree.DocPretty;
 65 
 66 public class DocCommentTreeApiTester {
 67 
 68     private static final String MARKER_START = &quot;EXPECT_START&quot;;
 69     private static final String MARKER_END   = &quot;EXPECT_END&quot;;
 70 
 71     private static final String testSrc = System.getProperty(&quot;test.src&quot;, &quot;.&quot;);
 72 
 73     private static final JavacTool javac = JavacTool.create();
 74 
 75     private static final DocCommentTester.ASTChecker.Printer printer =
 76             new DocCommentTester.ASTChecker.Printer();
 77     int pass;
 78     int fail;
 79 
 80     public DocCommentTreeApiTester() {
 81         pass = 0;
 82         fail = 0;
 83     }
 84 
 85     public static void main(String... args) throws Exception {
 86         DocCommentTreeApiTester test = new DocCommentTreeApiTester();
 87         try {
 88             // test getting a DocTree from an element
 89             test.runElementAndBreakIteratorTests(&quot;Anchor.java&quot;, &quot;Anchor test.&quot;);
 90 
 91             // test relative paths in a class within a package
 92             test.runRelativePathTest(&quot;pkg/Anchor.java&quot;, &quot;package.html&quot;, true);
 93 
 94             // tests files relative path in an unnamed package
 95             test.runRelativePathTest(&quot;Anchor.java&quot;, &quot;overview0.html&quot;, true);
 96 
 97             // test doctree path and Doc
 98             test.runDocTreePath(&quot;Anchor.java&quot;, &quot;package.html&quot;);
 99 
100             // test for correct parsing using valid and some invalid html tags
101             test.runFileObjectTest(&quot;overview0.html&quot;);
102             test.runFileObjectTest(&quot;overview1.html&quot;);
103             test.runFileObjectTest(&quot;overview2.html&quot;);
104             test.runFileObjectTest(&quot;overview3.html&quot;);
105             test.runFileObjectTest(&quot;overview4.html&quot;);
106             test.runFileObjectTest(&quot;overview5.html&quot;);
107             test.runFileObjectTest(&quot;overview6.html&quot;);
108             test.runFileObjectTest(&quot;overview7.html&quot;);
109 
110         } finally {
111             test.status();
112         }
113     }
114     void status() throws Exception {
115         System.err.println(&quot;pass:&quot; + pass + &quot;  fail: &quot; + fail);
116         if (fail &gt; 0) {
117             throw new Exception(&quot;Fails&quot;);
118         }
119     }
120 
121     /**
122      * Tests getting a DocCommentTree from an element, as well
123      * as test if break iterator setter/getter works correctly.
124      *
125      * @param javaFileName a test file to be processed
126      * @param expected the expected output
127      * @throws java.io.IOException
128      */
129     public void runElementAndBreakIteratorTests(String javaFileName, String expected) throws IOException {
130         List&lt;File&gt; javaFiles = new ArrayList&lt;&gt;();
131         javaFiles.add(new File(testSrc, javaFileName));
132 
133         List&lt;File&gt; dirs = new ArrayList&lt;&gt;();
134         dirs.add(new File(testSrc));
135 
136         try (StandardJavaFileManager fm = javac.getStandardFileManager(null, null, null)) {
137             fm.setLocation(javax.tools.StandardLocation.SOURCE_PATH, dirs);
138             Iterable&lt;? extends JavaFileObject&gt; fos = fm.getJavaFileObjectsFromFiles(javaFiles);
139 
140             final JavacTask t = javac.getTask(null, fm, null, null, null, fos);
141             final DocTrees trees = DocTrees.instance(t);
142 
143             Iterable&lt;? extends Element&gt; elements = t.analyze();
144 
145             Element klass = elements.iterator().next();
146             DocCommentTree dcTree = trees.getDocCommentTree(klass);
147 
148             List&lt;? extends DocTree&gt; firstSentence = dcTree.getFirstSentence();
149             StringWriter sw = new StringWriter();
150             DocPretty pretty = new DocPretty(sw);
151             pretty.print(firstSentence);
152             check(&quot;getDocCommentTree(Element)&quot;, expected, sw.toString());
153 
154             BreakIterator bi = BreakIterator.getSentenceInstance(Locale.FRENCH);
155             trees.setBreakIterator(bi);
156             BreakIterator nbi = trees.getBreakIterator();
157             if (bi.equals(nbi)) {
158                 pass++;
159                 check(&quot;getDocCommentTree(Element) with BreakIterator&quot;, expected, sw.toString());
160             } else {
161                 fail++;
162                 System.err.println(&quot;BreakIterators don&#39;t match&quot;);
163             }
164         }
165     }
166 
167     /**
168      * Tests DocTrees.getDocCommentTree(Element e, String relpath) using relative path.
169      *
170      * @param javaFileName the reference java file
171      * @param fileName the relative html file
172      * @throws java.lang.Exception ouch
173      */
174     public void runRelativePathTest(String javaFileName, String fileName,
175                                     boolean bodyOnly) throws Exception  {
176         List&lt;File&gt; javaFiles = new ArrayList&lt;&gt;();
177         javaFiles.add(new File(testSrc, javaFileName));
178 
179         List&lt;File&gt; dirs = new ArrayList&lt;&gt;();
180         dirs.add(new File(testSrc));
181 
182         try (StandardJavaFileManager fm = javac.getStandardFileManager(null, null, null)) {
183             fm.setLocation(javax.tools.StandardLocation.SOURCE_PATH, dirs);
184             Iterable&lt;? extends JavaFileObject&gt; fos = fm.getJavaFileObjectsFromFiles(javaFiles);
185 
186             final JavacTask t = javac.getTask(null, fm, null, null, null, fos);
187             final DocTrees trees = DocTrees.instance(t);
188 
189             Iterable&lt;? extends Element&gt; elements = t.analyze();
190 
191             Element klass = elements.iterator().next();
192 
193             DocCommentTree dcTree = trees.getDocCommentTree(klass, fileName);
194 
195             if (dcTree == null)
196                 throw new Error(&quot;invalid input: &quot; + fileName);
197 
198             StringWriter sw = new StringWriter();
199             printer.print(dcTree, sw);
200             String found = sw.toString();
201 
202             FileObject htmlFo = fm.getFileForInput(javax.tools.StandardLocation.SOURCE_PATH,
203                     t.getElements().getPackageOf(klass).getQualifiedName().toString(),
204                     fileName + &quot;.out&quot;);
205 
206             String expected = getExpected(htmlFo.openReader(true));
207             astcheck(fileName, expected, found);
208         }
209     }
210 
211     /**
212      * Tests DocTrees.getDocCommentTree(FileObject fo).
213      *
214      * @param htmlfileName the file to be parsed
215      * @throws Exception when an error occurs.
216      */
217     public void runFileObjectTest(String htmlfileName) throws Exception {
218         List&lt;File&gt; javaFiles =  Collections.emptyList();
219 
220         List&lt;File&gt; otherFiles = new ArrayList&lt;&gt;();
221         otherFiles.add(new File(testSrc, htmlfileName));
222         otherFiles.add(new File(testSrc, htmlfileName + &quot;.out&quot;));
223 
224         try (StandardJavaFileManager fm = javac.getStandardFileManager(null, null, null)) {
225             Iterable&lt;? extends JavaFileObject&gt; fos = fm.getJavaFileObjectsFromFiles(javaFiles);
226             Iterable&lt;? extends JavaFileObject&gt; others = fm.getJavaFileObjectsFromFiles(otherFiles);
227 
228             final JavacTask t = javac.getTask(null, fm, null, null, null, fos);
229             final DocTrees trees = DocTrees.instance(t);
230 
231             StringWriter sw = new StringWriter();
232             DocCommentTree dct = null;
233             String expected = null;
234             for (JavaFileObject jfo : others) {
235                 switch (jfo.getKind()) {
236                     case HTML:
237                         dct = trees.getDocCommentTree(jfo);
238                         if (dct == null)
239                             throw new Exception(&quot;invalid input: &quot; + jfo);
240                         break;
241                     default:
242                         expected = getExpected(jfo.openReader(true));
243                 }
244             }
245 
246             printer.print(dct, sw);
247             String found = sw.toString();
248             astcheck(otherFiles.toString(), expected, found);
249         }
250     }
251 
252     /**
253      * Tests DocTrees.getDocTreePath(PackageElement p, FileObject fo).
254      *
255      * @param javaFileName the java anchor file
256      * @param pkgFileName the package file name
257      * @throws Exception e if something goes awry
258      */
259     public void runDocTreePath(String javaFileName, String pkgFileName) throws Exception  {
260         List&lt;File&gt; javaFiles = new ArrayList&lt;&gt;();
261         javaFiles.add(new File(testSrc, javaFileName));
262 
263         List&lt;File&gt; otherFiles = new ArrayList&lt;&gt;();
264         otherFiles.add(new File(testSrc, pkgFileName + &quot;.out&quot;));
265 
266         List&lt;File&gt; dirs = new ArrayList&lt;&gt;();
267         dirs.add(new File(testSrc));
268 
269         try (StandardJavaFileManager fm = javac.getStandardFileManager(null, null, null)) {
270             fm.setLocation(javax.tools.StandardLocation.SOURCE_PATH, dirs);
271             Iterable&lt;? extends JavaFileObject&gt; fos = fm.getJavaFileObjectsFromFiles(javaFiles);
272 
273             final JavacTask t = javac.getTask(null, fm, null, null, null, fos);
274             final DocTrees trees = DocTrees.instance(t);
275             final Elements elementUtils = t.getElements();
276 
277             Iterable&lt;? extends Element&gt; elements = t.analyze();
278 
279             Element klass = elements.iterator().next();
280             PackageElement pkg = elementUtils.getPackageOf(klass);
281 
282             FileObject htmlFo = fm.getFileForInput(javax.tools.StandardLocation.SOURCE_PATH,
283                     t.getElements().getPackageOf(klass).getQualifiedName().toString(),
284                     &quot;package.html&quot;);
285             DocTreePath treePath = trees.getDocTreePath(htmlFo, pkg);
286 
287             if (treePath == null) {
288                 throw new Exception(&quot;invalid input: &quot; + htmlFo);
289             }
290 
291             DocCommentTree dcTree = treePath.getDocComment();
292             if (dcTree == null)
293                 throw new Exception(&quot;invalid input&quot; + htmlFo);
294 
295             StringWriter sw = new StringWriter();
296             printer.print(dcTree, sw);
297             String found = sw.toString();
298             Iterable&lt;? extends JavaFileObject&gt; oos = fm.getJavaFileObjectsFromFiles(otherFiles);
299             JavaFileObject otherFo = oos.iterator().next();
300             String expected = getExpected(otherFo.openReader(true));
301 
302             astcheck(pkgFileName, expected, found);
303         }
304     }
305 
306     void astcheck(String testinfo, String expected, String found) {
307         System.err.print(&quot;ASTChecker: &quot; + testinfo);
308         check0(expected, found);
309     }
310     void check(String testinfo, String expected, String found) {
311         System.err.print(testinfo);
312         check0(expected, found);
313     }
314     void check0(String expected, String found) {
315         if (expected.equals(found)) {
316             pass++;
317             System.err.println(&quot; PASS&quot;);
318         } else {
319             fail++;
320             System.err.println(&quot; FAILED&quot;);
321             System.err.println(&quot;Expect:\n&quot; + expected);
322             System.err.println(&quot;Found:\n&quot; + found);
323         }
324     }
325 
326     String getExpected(Reader inrdr) throws IOException {
327         BufferedReader rdr = new BufferedReader(inrdr);
328         List&lt;String&gt; lines = new ArrayList&lt;&gt;();
329         String line = rdr.readLine();
330         while (line != null) {
331             lines.add(line);
332             line = rdr.readLine();
333         }
334         return getExpected(lines);
335     }
336 
337     String getExpected(List&lt;String&gt; lines) {
338         boolean start = false;
339         StringWriter sw = new StringWriter();
340         PrintWriter out = new PrintWriter(sw);
341         for (String line : lines) {
342             if (!start) {
343                 start = line.startsWith(MARKER_START);
344                 continue;
345             }
346             if (line.startsWith(MARKER_END)) {
347                 out.flush();
348                 return sw.toString();
349             }
350             out.println(line);
351         }
352         return out.toString() + &quot;Warning: html comment end not found&quot;;
353     }
354 }
355 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/langtools/tools/javac/classreader/8171132/BadConstantValue.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../classfiles/attributes/EnclosingMethod/EnclosingMethodTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../defaultMethods/BadClassfile.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/langtools/tools/javac/classreader/8171132/BadConstantValue.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
117      */
118     private static void testValidConstRange(String type, int value) throws Exception {
119         createConstantWithValue(type, value);
120         BadClassFile badClassFile = loadBadClass(&quot;Lib&quot;);
121         if (badClassFile != null) {
122           throw new AssertionError(&quot;saw unexpected error&quot;, badClassFile);
123         }
124     }
125 
126     /**
127      * Creates a class file containing a constant field with the given type and value, which may be
128      * outside the expected range.
129      */
130     private static void createConstantWithValue(String type, int value) throws Exception {
131         // Create a class with two constants, A and B. A is of type int and has value &quot;actual&quot;;
132         // B is of type &quot;type&quot; and is initialized to that type&#39;s default value.
133         File lib = writeFile(classesdir, &quot;Lib.java&quot;, String.format(
134                 &quot;class Lib { static final int A = %s; static final %s B = %s; }&quot;,
135                 value, type, (type.equals(&quot;boolean&quot;) ? &quot;false&quot; : &quot;0&quot;)));
136         compile(&quot;-d&quot;, classesdir.getPath(), lib.getPath());


137         File libClass = new File(classesdir, &quot;Lib.class&quot;);
138         // Rewrite the class to only have field B of type &quot;type&quot; and with &quot;value&quot; (potentially
139         // out of range).
140         swapConstantValues(libClass);
141     }
142 
143     /** Tests that a field of the given integral type with a constant string value is rejected. */
144     private static void testInvalidConstantType(String type) throws Exception {
145         // create a class file with field that has an invalid CONSTANT_String ConstantValue
146         File lib = writeFile(classesdir, &quot;Lib.java&quot;, String.format(
147                 &quot;class Lib { static final String A = \&quot;hello\&quot;; static final %s CONST = %s; }&quot;,
148                 type, type.equals(&quot;boolean&quot;) ? &quot;false&quot; : &quot;0&quot;));
149         compile(&quot;-d&quot;, classesdir.getPath(), lib.getPath());


150         File libClass = new File(classesdir, &quot;Lib.class&quot;);
151         swapConstantValues(libClass);
152 
153         BadClassFile badClassFile = loadBadClass(&quot;Lib&quot;);
154 
155         JCDiagnostic diagnostic = (JCDiagnostic) badClassFile.getDiagnostic().getArgs()[1];
156         assertEquals(&quot;compiler.misc.bad.constant.value&quot;, diagnostic.getCode());
157         assertEquals(3, diagnostic.getArgs().length);
158         assertEquals(&quot;hello&quot;, diagnostic.getArgs()[0]);
159         assertEquals(&quot;CONST&quot;, diagnostic.getArgs()[1].toString());
160         assertEquals(&quot;Integer&quot;, diagnostic.getArgs()[2]);
161     }
162 
163     private static BadClassFile loadBadClass(String className) {
164         // load the class, and save the thrown BadClassFile exception
165         JavaCompiler c = ToolProvider.getSystemJavaCompiler();
166         JavacTaskImpl task = (JavacTaskImpl) c.getTask(null, null, null,
167                 Arrays.asList(&quot;-classpath&quot;, classesdir.getPath()), null, null);
168         Names names = Names.instance(task.getContext());
169         Symtab syms = Symtab.instance(task.getContext());
</pre>
</td>
<td>
<hr />
<pre>
117      */
118     private static void testValidConstRange(String type, int value) throws Exception {
119         createConstantWithValue(type, value);
120         BadClassFile badClassFile = loadBadClass(&quot;Lib&quot;);
121         if (badClassFile != null) {
122           throw new AssertionError(&quot;saw unexpected error&quot;, badClassFile);
123         }
124     }
125 
126     /**
127      * Creates a class file containing a constant field with the given type and value, which may be
128      * outside the expected range.
129      */
130     private static void createConstantWithValue(String type, int value) throws Exception {
131         // Create a class with two constants, A and B. A is of type int and has value &quot;actual&quot;;
132         // B is of type &quot;type&quot; and is initialized to that type&#39;s default value.
133         File lib = writeFile(classesdir, &quot;Lib.java&quot;, String.format(
134                 &quot;class Lib { static final int A = %s; static final %s B = %s; }&quot;,
135                 value, type, (type.equals(&quot;boolean&quot;) ? &quot;false&quot; : &quot;0&quot;)));
136         compile(&quot;-d&quot;, classesdir.getPath(), lib.getPath());
<span class="line-added">137         // Lib.class may possibly not get a newer timestamp. Make sure .java file won&#39;t get used.</span>
<span class="line-added">138         lib.delete();</span>
139         File libClass = new File(classesdir, &quot;Lib.class&quot;);
140         // Rewrite the class to only have field B of type &quot;type&quot; and with &quot;value&quot; (potentially
141         // out of range).
142         swapConstantValues(libClass);
143     }
144 
145     /** Tests that a field of the given integral type with a constant string value is rejected. */
146     private static void testInvalidConstantType(String type) throws Exception {
147         // create a class file with field that has an invalid CONSTANT_String ConstantValue
148         File lib = writeFile(classesdir, &quot;Lib.java&quot;, String.format(
149                 &quot;class Lib { static final String A = \&quot;hello\&quot;; static final %s CONST = %s; }&quot;,
150                 type, type.equals(&quot;boolean&quot;) ? &quot;false&quot; : &quot;0&quot;));
151         compile(&quot;-d&quot;, classesdir.getPath(), lib.getPath());
<span class="line-added">152         // Lib.class may possibly not get a newer timestamp. Make sure .java file won&#39;t get used.</span>
<span class="line-added">153         lib.delete();</span>
154         File libClass = new File(classesdir, &quot;Lib.class&quot;);
155         swapConstantValues(libClass);
156 
157         BadClassFile badClassFile = loadBadClass(&quot;Lib&quot;);
158 
159         JCDiagnostic diagnostic = (JCDiagnostic) badClassFile.getDiagnostic().getArgs()[1];
160         assertEquals(&quot;compiler.misc.bad.constant.value&quot;, diagnostic.getCode());
161         assertEquals(3, diagnostic.getArgs().length);
162         assertEquals(&quot;hello&quot;, diagnostic.getArgs()[0]);
163         assertEquals(&quot;CONST&quot;, diagnostic.getArgs()[1].toString());
164         assertEquals(&quot;Integer&quot;, diagnostic.getArgs()[2]);
165     }
166 
167     private static BadClassFile loadBadClass(String className) {
168         // load the class, and save the thrown BadClassFile exception
169         JavaCompiler c = ToolProvider.getSystemJavaCompiler();
170         JavacTaskImpl task = (JavacTaskImpl) c.getTask(null, null, null,
171                 Arrays.asList(&quot;-classpath&quot;, classesdir.getPath()), null, null);
172         Names names = Names.instance(task.getContext());
173         Symtab syms = Symtab.instance(task.getContext());
</pre>
</td>
</tr>
</table>
<center><a href="../../classfiles/attributes/EnclosingMethod/EnclosingMethodTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../defaultMethods/BadClassfile.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
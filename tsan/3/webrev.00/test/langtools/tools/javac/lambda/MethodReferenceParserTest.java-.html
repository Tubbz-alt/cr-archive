<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/lambda/MethodReferenceParserTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 7115052 8003280 8006694 8129962
 27  * @summary Add lambda tests
 28  *  Add parser support for method references
 29  *  temporarily workaround combo tests are causing time out in several platforms
 30  * @library /tools/javac/lib
 31  * @modules jdk.compiler/com.sun.tools.javac.api
 32  *          jdk.compiler/com.sun.tools.javac.code
 33  *          jdk.compiler/com.sun.tools.javac.comp
 34  *          jdk.compiler/com.sun.tools.javac.main
 35  *          jdk.compiler/com.sun.tools.javac.tree
 36  *          jdk.compiler/com.sun.tools.javac.util
 37  * @build combo.ComboTestHelper
 38  * @run main MethodReferenceParserTest
 39  */
 40 
 41 import java.io.IOException;
 42 
 43 import combo.ComboInstance;
 44 import combo.ComboParameter;
 45 import combo.ComboTask.Result;
 46 import combo.ComboTestHelper;
 47 
 48 public class MethodReferenceParserTest extends ComboInstance&lt;MethodReferenceParserTest&gt; {
 49 
 50     enum ReferenceKind implements ComboParameter {
 51         METHOD_REF(&quot;#{QUAL}::#{TARGS}m&quot;),
 52         CONSTRUCTOR_REF(&quot;#{QUAL}::#{TARGS}new&quot;),
 53         FALSE_REF(&quot;min &lt; max&quot;),
 54         ERR_SUPER(&quot;#{QUAL}::#{TARGS}super&quot;),
 55         ERR_METH0(&quot;#{QUAL}::#{TARGS}m()&quot;),
 56         ERR_METH1(&quot;#{QUAL}::#{TARGS}m(X)&quot;),
 57         ERR_CONSTR0(&quot;#{QUAL}::#{TARGS}new()&quot;),
 58         ERR_CONSTR1(&quot;#{QUAL}::#{TARGS}new(X)&quot;);
 59 
 60         String referenceTemplate;
 61 
 62         ReferenceKind(String referenceTemplate) {
 63             this.referenceTemplate = referenceTemplate;
 64         }
 65 
 66         boolean erroneous() {
 67             switch (this) {
 68                 case ERR_SUPER:
 69                 case ERR_METH0:
 70                 case ERR_METH1:
 71                 case ERR_CONSTR0:
 72                 case ERR_CONSTR1:
 73                     return true;
 74                 default: return false;
 75             }
 76         }
 77 
 78         @Override
 79         public String expand(String optParameter) {
 80             return referenceTemplate;
 81         }
 82     }
 83 
 84     enum ContextKind implements ComboParameter {
 85         ASSIGN(&quot;SAM s = #{EXPR};&quot;),
 86         METHOD(&quot;m(#{EXPR}, i);&quot;);
 87 
 88         String contextTemplate;
 89 
 90         ContextKind(String contextTemplate) {
 91             this.contextTemplate = contextTemplate;
 92         }
 93 
 94         @Override
 95         public String expand(String optParameter) {
 96             return contextTemplate;
 97         }
 98     }
 99 
100     enum GenericKind implements ComboParameter {
101         NONE(&quot;&quot;),
102         ONE(&quot;&lt;X&gt;&quot;),
103         TWO(&quot;&lt;X,Y&gt;&quot;);
104 
105         String typeParameters;
106 
107         GenericKind(String typeParameters) {
108             this.typeParameters = typeParameters;
109         }
110 
111         @Override
112         public String expand(String optParameter) {
113             return typeParameters;
114         }
115     }
116 
117     enum QualifierKind implements ComboParameter {
118         THIS(&quot;this&quot;),
119         SUPER(&quot;super&quot;),
120         NEW(&quot;new Foo()&quot;),
121         METHOD(&quot;m()&quot;),
122         FIELD(&quot;a.f&quot;),
123         UBOUND_SIMPLE(&quot;A&quot;),
124         UNBOUND_ARRAY1(&quot;int[]&quot;),
125         UNBOUND_ARRAY2(&quot;A&lt;G&gt;[][]&quot;),
126         UNBOUND_GENERIC1(&quot;A&lt;X&gt;&quot;),
127         UNBOUND_GENERIC2(&quot;A&lt;X, Y&gt;&quot;),
128         UNBOUND_GENERIC3(&quot;A&lt;? extends X, ? super Y&gt;&quot;),
129         UNBOUND_GENERIC4(&quot;A&lt;int[], short[][]&gt;&quot;),
130         NESTED_GENERIC1(&quot;A&lt;A&lt;X,Y&gt;, A&lt;X,Y&gt;&gt;&quot;),
131         NESTED_GENERIC2(&quot;A&lt;A&lt;A&lt;X,Y&gt;,A&lt;X,Y&gt;&gt;, A&lt;A&lt;X,Y&gt;,A&lt;X,Y&gt;&gt;&gt;&quot;);
132 
133         String qualifier;
134 
135         QualifierKind(String qualifier) {
136             this.qualifier = qualifier;
137         }
138 
139         @Override
140         public String expand(String optParameter) {
141             return qualifier;
142         }
143     }
144 
145     enum ExprKind implements ComboParameter {
146         NONE(&quot;#{MREF}&quot;),
147         SINGLE_PAREN1(&quot;(#{MREF}#{SUBEXPR})&quot;),
148         SINGLE_PAREN2(&quot;(#{MREF})#{SUBEXPR}&quot;),
149         DOUBLE_PAREN1(&quot;((#{MREF}#{SUBEXPR}))&quot;),
150         DOUBLE_PAREN2(&quot;((#{MREF})#{SUBEXPR})&quot;),
151         DOUBLE_PAREN3(&quot;((#{MREF}))#{SUBEXPR}&quot;);
152 
153         String expressionTemplate;
154 
155         ExprKind(String expressionTemplate) {
156             this.expressionTemplate = expressionTemplate;
157         }
158 
159         @Override
160         public String expand(String optParameter) {
161             return expressionTemplate;
162         }
163     }
164 
165     enum SubExprKind implements ComboParameter {
166         NONE(&quot;&quot;),
167         SELECT_FIELD(&quot;.f&quot;),
168         SELECT_METHOD(&quot;.f()&quot;),
169         SELECT_NEW(&quot;.new Foo()&quot;),
170         POSTINC(&quot;++&quot;),
171         POSTDEC(&quot;--&quot;);
172 
173         String subExpression;
174 
175         SubExprKind(String subExpression) {
176             this.subExpression = subExpression;
177         }
178 
179         @Override
180         public String expand(String optParameter) {
181             return subExpression;
182         }
183     }
184 
185     public static void main(String... args) throws Exception {
186         new ComboTestHelper&lt;MethodReferenceParserTest&gt;()
187                 .withDimension(&quot;MREF&quot;, (x, ref) -&gt; x.rk = ref, ReferenceKind.values())
188                 .withDimension(&quot;QUAL&quot;, QualifierKind.values())
189                 .withDimension(&quot;TARGS&quot;, GenericKind.values())
190                 .withDimension(&quot;EXPR&quot;, ExprKind.values())
191                 .withDimension(&quot;SUBEXPR&quot;, SubExprKind.values())
192                 .withDimension(&quot;CTX&quot;, ContextKind.values())
193                 .run(MethodReferenceParserTest::new);
194     }
195 
196     ReferenceKind rk;
197 
198     String template = &quot;class Test {\n&quot; +
199                       &quot;   void test() {\n&quot; +
200                       &quot;      #{CTX}\n&quot; +
201                       &quot;   }&quot; +
202                       &quot;}&quot;;
203 
204     @Override
205     public void doWork() throws IOException {
206         newCompilationTask()
207                 .withSourceFromTemplate(template)
208                 .parse(this::check);
209     }
210 
211     void check(Result&lt;?&gt; res) {
212         if (res.hasErrors() != rk.erroneous()) {
213             fail(&quot;invalid diagnostics for source:\n&quot; +
214                 res.compilationInfo() +
215                 &quot;\nFound error: &quot; + res.hasErrors() +
216                 &quot;\nExpected error: &quot; + rk.erroneous());
217         }
218     }
219 }
    </pre>
  </body>
</html>
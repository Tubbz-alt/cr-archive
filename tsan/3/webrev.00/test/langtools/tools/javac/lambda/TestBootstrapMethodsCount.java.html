<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/lambda/TestBootstrapMethodsCount.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8129547
 27  * @summary Excess entries in BootstrapMethods with the same (bsm, bsmKind, bsmStaticArgs), but different dynamicArgs
 28  * @library /tools/javac/lib
 29  * @modules jdk.jdeps/com.sun.tools.classfile
 30  *          jdk.compiler/com.sun.tools.javac.api
 31  *          jdk.compiler/com.sun.tools.javac.code
 32  *          jdk.compiler/com.sun.tools.javac.jvm
 33  *          jdk.compiler/com.sun.tools.javac.tree
 34  *          jdk.compiler/com.sun.tools.javac.util
 35  */
 36 
 37 import java.io.File;
 38 import java.net.URI;
 39 import java.util.ArrayList;
 40 import java.util.Arrays;
 41 import java.util.Locale;
 42 
 43 import javax.tools.Diagnostic;
 44 import javax.tools.JavaCompiler;
 45 import javax.tools.JavaFileObject;
 46 import javax.tools.SimpleJavaFileObject;
 47 import javax.tools.ToolProvider;
 48 
 49 import com.sun.source.tree.MethodInvocationTree;
 50 import com.sun.source.tree.MethodTree;
 51 import com.sun.source.util.TaskEvent;
 52 import com.sun.source.util.TaskListener;
 53 import com.sun.source.util.TreeScanner;
 54 
 55 import com.sun.tools.classfile.Attribute;
 56 import com.sun.tools.classfile.BootstrapMethods_attribute;
 57 import com.sun.tools.classfile.ClassFile;
 58 
 59 import com.sun.tools.javac.api.JavacTaskImpl;
 60 import com.sun.tools.javac.code.Symbol;
 61 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 62 import com.sun.tools.javac.code.Symtab;
 63 import com.sun.tools.javac.code.Types;
 64 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
 65 import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
 66 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 67 import com.sun.tools.javac.tree.JCTree.JCIdent;
 68 import com.sun.tools.javac.util.Context;
 69 import com.sun.tools.javac.util.Names;
 70 
 71 import static com.sun.tools.javac.jvm.ClassFile.*;
 72 
 73 public class TestBootstrapMethodsCount {
 74 
 75     public static void main(String... args) throws Exception {
 76         JavaCompiler comp = ToolProvider.getSystemJavaCompiler();
 77         new TestBootstrapMethodsCount().run(comp);
 78     }
 79 
 80     DiagChecker dc;
 81 
 82     TestBootstrapMethodsCount() {
 83         dc = new DiagChecker();
 84     }
 85 
 86     public void run(JavaCompiler comp) {
 87         JavaSource source = new JavaSource();
 88         JavacTaskImpl ct = (JavacTaskImpl)comp.getTask(null, null, dc,
 89                 Arrays.asList(&quot;-g&quot;), null, Arrays.asList(source));
 90         Context context = ct.getContext();
 91         Symtab syms = Symtab.instance(context);
 92         Names names = Names.instance(context);
 93         Types types = Types.instance(context);
 94         ct.addTaskListener(new Indifier(syms, names, types));
 95         try {
 96             ct.generate();
 97         } catch (Throwable t) {
 98             t.printStackTrace();
 99             throw new AssertionError(
100                     String.format(&quot;Error thrown when compiling following code\n%s&quot;,
101                             source.source));
102         }
103         if (dc.diagFound) {
104             throw new AssertionError(
105                     String.format(&quot;Diags found when compiling following code\n%s\n\n%s&quot;,
106                             source.source, dc.printDiags()));
107         }
108         verifyBytecode();
109     }
110 
111     void verifyBytecode() {
112         File compiledTest = new File(&quot;Test.class&quot;);
113         try {
114             ClassFile cf = ClassFile.read(compiledTest);
115             BootstrapMethods_attribute bsm_attr =
116                     (BootstrapMethods_attribute)cf
117                             .getAttribute(Attribute.BootstrapMethods);
118             int length = bsm_attr.bootstrap_method_specifiers.length;
119             if (length != 1) {
120                 throw new Error(&quot;Bad number of method specifiers &quot; +
121                         &quot;in BootstrapMethods attribute: &quot; + length);
122             }
123         } catch (Exception e) {
124             e.printStackTrace();
125             throw new Error(&quot;error reading &quot; + compiledTest +&quot;: &quot; + e);
126         }
127     }
128 
129     class JavaSource extends SimpleJavaFileObject {
130 
131         static final String source = &quot;import java.lang.invoke.*;\n&quot; +
132                 &quot;class Bootstrap {\n&quot; +
133                 &quot;   public static CallSite bsm(MethodHandles.Lookup lookup, &quot; +
134                 &quot;String name, MethodType methodType) {\n&quot; +
135                 &quot;       return null;\n&quot; +
136                 &quot;   }\n&quot; +
137                 &quot;}\n&quot; +
138                 &quot;class Test {\n&quot; +
139                 &quot;   void m1() { }\n&quot; +
140                 &quot;   void m2(Object arg1) { }\n&quot; +
141                 &quot;   void test1() {\n&quot; +
142                 &quot;      Object o = this; // marker statement \n&quot; +
143                 &quot;      m1();\n&quot; +
144                 &quot;   }\n&quot; +
145                 &quot;   void test2(Object arg1) {\n&quot; +
146                 &quot;      Object o = this; // marker statement \n&quot; +
147                 &quot;      m2(arg1);\n&quot; +
148                 &quot;   }\n&quot; +
149                 &quot;}&quot;;
150 
151         JavaSource() {
152             super(URI.create(&quot;myfo:/Test.java&quot;), JavaFileObject.Kind.SOURCE);
153         }
154 
155         @Override
156         public CharSequence getCharContent(boolean ignoreEncodingErrors) {
157             return source;
158         }
159     }
160 
161     class Indifier extends TreeScanner&lt;Void, Void&gt; implements TaskListener {
162 
163         MethodSymbol bsm;
164         Symtab syms;
165         Names names;
166         Types types;
167 
168         Indifier(Symtab syms, Names names, Types types) {
169             this.syms = syms;
170             this.names = names;
171             this.types = types;
172         }
173 
174         @Override
175         public void started(TaskEvent e) {
176             //do nothing
177         }
178 
179         @Override
180         public void finished(TaskEvent e) {
181             if (e.getKind() == TaskEvent.Kind.ANALYZE) {
182                 scan(e.getCompilationUnit(), null);
183             }
184         }
185 
186         @Override
187         public Void visitMethodInvocation(MethodInvocationTree node, Void p) {
188             super.visitMethodInvocation(node, p);
189             JCMethodInvocation apply = (JCMethodInvocation)node;
190             JCIdent ident = (JCIdent)apply.meth;
191             Symbol oldSym = ident.sym;
192             if (!oldSym.isConstructor()) {
193                 ident.sym = new Symbol.DynamicMethodSymbol(oldSym.name,
194                         oldSym.owner, bsm.asHandle(), oldSym.type, new LoadableConstant[0]);
195             }
196             return null;
197         }
198 
199         @Override
200         public Void visitMethod(MethodTree node, Void p) {
201             super.visitMethod(node, p);
202             if (node.getName().toString().equals(&quot;bsm&quot;)) {
203                 bsm = ((JCMethodDecl)node).sym;
204             }
205             return null;
206         }
207     }
208 
209     static class DiagChecker
210             implements javax.tools.DiagnosticListener&lt;JavaFileObject&gt; {
211 
212         boolean diagFound;
213         ArrayList&lt;String&gt; diags = new ArrayList&lt;&gt;();
214 
215         public void report(Diagnostic&lt;? extends JavaFileObject&gt; diagnostic) {
216             diags.add(diagnostic.getMessage(Locale.getDefault()));
217             diagFound = true;
218         }
219 
220         String printDiags() {
221             StringBuilder buf = new StringBuilder();
222             for (String s : diags) {
223                 buf.append(s);
224                 buf.append(&quot;\n&quot;);
225             }
226             return buf.toString();
227         }
228     }
229 
230 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/langtools/tools/javac/lambda/TestInvokeDynamic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="TestBootstrapMethodsCount.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TestLambdaToMethodStats.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/langtools/tools/javac/lambda/TestInvokeDynamic.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,12 ***</span>
   *  temporarily workaround combo tests are causing time out in several platforms
   * @library /tools/javac/lib
   * @modules jdk.jdeps/com.sun.tools.classfile
   *          jdk.compiler/com.sun.tools.javac.api
   *          jdk.compiler/com.sun.tools.javac.code
<span class="line-modified">!  *          jdk.compiler/com.sun.tools.javac.comp</span>
<span class="line-removed">-  *          jdk.compiler/com.sun.tools.javac.main</span>
   *          jdk.compiler/com.sun.tools.javac.jvm
   *          jdk.compiler/com.sun.tools.javac.tree
   *          jdk.compiler/com.sun.tools.javac.util
   * @build combo.ComboTestHelper
   * @run main TestInvokeDynamic
<span class="line-new-header">--- 29,11 ---</span>
   *  temporarily workaround combo tests are causing time out in several platforms
   * @library /tools/javac/lib
   * @modules jdk.jdeps/com.sun.tools.classfile
   *          jdk.compiler/com.sun.tools.javac.api
   *          jdk.compiler/com.sun.tools.javac.code
<span class="line-modified">!  *          jdk.compiler/com.sun.tools.javac.file</span>
   *          jdk.compiler/com.sun.tools.javac.jvm
   *          jdk.compiler/com.sun.tools.javac.tree
   *          jdk.compiler/com.sun.tools.javac.util
   * @build combo.ComboTestHelper
   * @run main TestInvokeDynamic
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,30 ***</span>
  import com.sun.tools.classfile.ConstantPool.*;
  import com.sun.tools.classfile.Instruction;
  import com.sun.tools.classfile.LineNumberTable_attribute;
  import com.sun.tools.classfile.Method;
  
<span class="line-removed">- import com.sun.tools.javac.api.JavacTaskImpl;</span>
  import com.sun.tools.javac.code.Symbol;
<span class="line-modified">! import com.sun.tools.javac.code.Symbol.MethodSymbol;</span>
  import com.sun.tools.javac.code.Symtab;
  import com.sun.tools.javac.code.Types;
<span class="line-modified">! import com.sun.tools.javac.jvm.Pool;</span>
  import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
  import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
  import com.sun.tools.javac.tree.JCTree.JCIdent;
<span class="line-removed">- import com.sun.tools.javac.util.Context;</span>
  import com.sun.tools.javac.util.Names;
  
  import combo.ComboParameter;
<span class="line-removed">- import combo.ComboTask;</span>
  import combo.ComboTestHelper;
  import combo.ComboInstance;
  import combo.ComboTask.Result;
  
<span class="line-removed">- import static com.sun.tools.javac.jvm.ClassFile.*;</span>
<span class="line-removed">- </span>
  public class TestInvokeDynamic extends ComboInstance&lt;TestInvokeDynamic&gt; {
  
      enum StaticArgumentKind implements ComboParameter {
          STRING(&quot;Hello!&quot;, &quot;String&quot;, &quot;Ljava/lang/String;&quot;) {
              @Override
<span class="line-new-header">--- 57,27 ---</span>
  import com.sun.tools.classfile.ConstantPool.*;
  import com.sun.tools.classfile.Instruction;
  import com.sun.tools.classfile.LineNumberTable_attribute;
  import com.sun.tools.classfile.Method;
  
  import com.sun.tools.javac.code.Symbol;
<span class="line-modified">! import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;</span>
  import com.sun.tools.javac.code.Symtab;
<span class="line-added">+ import com.sun.tools.javac.code.Type.ClassType;</span>
<span class="line-added">+ import com.sun.tools.javac.code.Type.MethodType;</span>
  import com.sun.tools.javac.code.Types;
<span class="line-modified">! import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;</span>
  import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
  import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
  import com.sun.tools.javac.tree.JCTree.JCIdent;
  import com.sun.tools.javac.util.Names;
  
  import combo.ComboParameter;
  import combo.ComboTestHelper;
  import combo.ComboInstance;
  import combo.ComboTask.Result;
  
  public class TestInvokeDynamic extends ComboInstance&lt;TestInvokeDynamic&gt; {
  
      enum StaticArgumentKind implements ComboParameter {
          STRING(&quot;Hello!&quot;, &quot;String&quot;, &quot;Ljava/lang/String;&quot;) {
              @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,25 ***</span>
              this.bytecodeTypeStr = bytecodeTypeStr;
          }
  
          abstract boolean check(CPInfo cpInfo) throws Exception;
  
<span class="line-modified">!         Object getValue(Symtab syms, Names names, Types types) {</span>
              switch (this) {
                  case STRING:
                  case INTEGER:
                  case LONG:
                  case FLOAT:
                  case DOUBLE:
<span class="line-modified">!                     return value;</span>
                  case CLASS:
<span class="line-modified">!                     return syms.stringType.tsym;</span>
                  case METHOD_HANDLE:
<span class="line-modified">!                     return new Pool.MethodHandle(REF_invokeVirtual,</span>
<span class="line-removed">-                             syms.arrayCloneMethod, types);</span>
                  case METHOD_TYPE:
<span class="line-modified">!                     return syms.arrayCloneMethod.type;</span>
                  default:
                      throw new AssertionError();
              }
          }
  
<span class="line-new-header">--- 162,28 ---</span>
              this.bytecodeTypeStr = bytecodeTypeStr;
          }
  
          abstract boolean check(CPInfo cpInfo) throws Exception;
  
<span class="line-modified">!         LoadableConstant getValue(Symtab syms) {</span>
              switch (this) {
                  case STRING:
<span class="line-added">+                     return LoadableConstant.String((String)value);</span>
                  case INTEGER:
<span class="line-added">+                     return LoadableConstant.Int((Integer)value);</span>
                  case LONG:
<span class="line-added">+                     return LoadableConstant.Long((Long)value);</span>
                  case FLOAT:
<span class="line-added">+                     return LoadableConstant.Float((Float)value);</span>
                  case DOUBLE:
<span class="line-modified">!                     return LoadableConstant.Double((Double)value);</span>
                  case CLASS:
<span class="line-modified">!                     return (ClassType)syms.stringType;</span>
                  case METHOD_HANDLE:
<span class="line-modified">!                     return syms.arrayCloneMethod.asHandle();</span>
                  case METHOD_TYPE:
<span class="line-modified">!                     return ((MethodType)syms.arrayCloneMethod.type);</span>
                  default:
                      throw new AssertionError();
              }
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 392,11 ***</span>
          return buf.toString();
      }
  
      class Indifier extends TreeScanner&lt;Void, Void&gt; implements TaskListener {
  
<span class="line-modified">!         MethodSymbol bsm;</span>
          Symtab syms;
          Names names;
          Types types;
  
          Indifier(Symtab syms, Names names, Types types) {
<span class="line-new-header">--- 391,11 ---</span>
          return buf.toString();
      }
  
      class Indifier extends TreeScanner&lt;Void, Void&gt; implements TaskListener {
  
<span class="line-modified">!         MethodHandleSymbol bsm;</span>
          Symtab syms;
          Names names;
          Types types;
  
          Indifier(Symtab syms, Names names, Types types) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 422,25 ***</span>
              super.visitMethodInvocation(node, p);
              JCMethodInvocation apply = (JCMethodInvocation)node;
              JCIdent ident = (JCIdent)apply.meth;
              Symbol oldSym = ident.sym;
              if (!oldSym.isConstructor()) {
<span class="line-modified">!                 Object[] staticArgs = new Object[arity.arity];</span>
                  for (int i = 0; i &lt; arity.arity ; i++) {
<span class="line-modified">!                     staticArgs[i] = saks[i].getValue(syms, names, types);</span>
                  }
                  ident.sym = new Symbol.DynamicMethodSymbol(oldSym.name,
<span class="line-modified">!                         oldSym.owner, REF_invokeStatic, bsm, oldSym.type, staticArgs);</span>
              }
              return null;
          }
  
          @Override
          public Void visitMethod(MethodTree node, Void p) {
              super.visitMethod(node, p);
              if (node.getName().toString().equals(&quot;bsm&quot;)) {
<span class="line-modified">!                 bsm = ((JCMethodDecl)node).sym;</span>
              }
              return null;
          }
      }
  }
<span class="line-new-header">--- 421,25 ---</span>
              super.visitMethodInvocation(node, p);
              JCMethodInvocation apply = (JCMethodInvocation)node;
              JCIdent ident = (JCIdent)apply.meth;
              Symbol oldSym = ident.sym;
              if (!oldSym.isConstructor()) {
<span class="line-modified">!                 LoadableConstant[] staticArgs = new LoadableConstant[arity.arity];</span>
                  for (int i = 0; i &lt; arity.arity ; i++) {
<span class="line-modified">!                     staticArgs[i] = saks[i].getValue(syms);</span>
                  }
                  ident.sym = new Symbol.DynamicMethodSymbol(oldSym.name,
<span class="line-modified">!                         oldSym.owner, bsm, oldSym.type, staticArgs);</span>
              }
              return null;
          }
  
          @Override
          public Void visitMethod(MethodTree node, Void p) {
              super.visitMethod(node, p);
              if (node.getName().toString().equals(&quot;bsm&quot;)) {
<span class="line-modified">!                 bsm = ((JCMethodDecl)node).sym.asHandle();</span>
              }
              return null;
          }
      }
  }
</pre>
<center><a href="TestBootstrapMethodsCount.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TestLambdaToMethodStats.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
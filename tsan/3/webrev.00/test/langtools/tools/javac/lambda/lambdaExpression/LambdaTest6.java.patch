diff a/test/langtools/tools/javac/lambda/lambdaExpression/LambdaTest6.java b/test/langtools/tools/javac/lambda/lambdaExpression/LambdaTest6.java
--- a/test/langtools/tools/javac/lambda/lambdaExpression/LambdaTest6.java
+++ b/test/langtools/tools/javac/lambda/lambdaExpression/LambdaTest6.java
@@ -24,12 +24,15 @@
 /**
  * @test
  * @bug 8003280
  * @summary Add lambda tests
  *   Test bridge methods for certain SAM conversions
+ *   Tests that jdk.internal.lambda.disableEagerInitialization=true creates a
+ *   get$Lambda method for non-capturing lambdas
  * @compile LambdaTest6.java
  * @run main LambdaTest6
+ * @run main/othervm -Djdk.internal.lambda.disableEagerInitialization=true LambdaTest6
  */
 
 import java.lang.reflect.Method;
 import java.util.HashSet;
 import java.util.Set;
@@ -58,38 +61,59 @@
         s.add("java.lang.String");
         s.add("java.lang.Object");
         return s;
     }
 
+    private static Set<String> allowedMethods() {
+        Set<String> s = new HashSet<>();
+        s.add("m");
+        if (Boolean.getBoolean("jdk.internal.lambda.disableEagerInitialization")) {
+            s.add("get$Lambda");
+        }
+        return s;
+    }
+
+    private static boolean matchingMethodNames(Method[] methods) {
+        Set<String> methodNames = new HashSet<>();
+        for (Method m : methods) {
+            methodNames.add(m.getName());
+        }
+        return methodNames.equals(allowedMethods());
+    }
+
     private void test1()
     {
         L la = s -> { };
         la.m("hi");
         Class<? extends L> c1 = la.getClass();
         Method[] methods = c1.getDeclaredMethods();
+        assertTrue(matchingMethodNames(methods));
         Set<String> types = setOfStringObject();
         for(Method m : methods) {
-            assertTrue(m.getName().equals("m"));
-            Class[] parameterTypes = m.getParameterTypes();
-            assertTrue(parameterTypes.length == 1);
-            assertTrue(types.remove(parameterTypes[0].getName()));
+            if ("m".equals(m.getName())) {
+                Class[] parameterTypes = m.getParameterTypes();
+                assertTrue(parameterTypes.length == 1);
+                assertTrue(types.remove(parameterTypes[0].getName()));
+            }
         }
         assertTrue(types.isEmpty() || (types.size() == 1 && types.contains("java.lang.String")));
     }
 
     private void test2()
     {
         KM km = s -> { };
         //km.m("hi");
         Class<? extends KM> c2 = km.getClass();
         Method[] methods = c2.getDeclaredMethods();
+        assertTrue(matchingMethodNames(methods));
         Set<String> types = setOfStringObject();
         for(Method m : methods) {
-            assertTrue(m.getName().equals("m"));
-            Class[] parameterTypes = m.getParameterTypes();
-            assertTrue(parameterTypes.length == 1);
-            assertTrue(types.remove(parameterTypes[0].getName()));
+            if ("m".equals(m.getName())) {
+                Class[] parameterTypes = m.getParameterTypes();
+                assertTrue(parameterTypes.length == 1);
+                assertTrue(types.remove(parameterTypes[0].getName()));
+            }
         }
         assertTrue(types.isEmpty());
     }
 
     private void test3()
@@ -97,15 +121,17 @@
         N na = ()-> "hi";
         assertTrue( na.m().equals("hi") );
         assertTrue( ((H)na).m().equals("hi") );
         Class<? extends N> c3 = na.getClass();
         Method[] methods = c3.getDeclaredMethods();
+        assertTrue(matchingMethodNames(methods));
         Set<String> types = setOfStringObject();
         for(Method m : methods) {
-            assertTrue(m.getName().equals("m"));
-            Class returnType = m.getReturnType();
-            assertTrue(types.remove(returnType.getName()));
+            if ("m".equals(m.getName())) {
+                Class returnType = m.getReturnType();
+                assertTrue(types.remove(returnType.getName()));
+            }
         }
         assertTrue(types.size() == 1); //there's a bridge
     }
 
 

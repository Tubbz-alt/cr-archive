<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/lambda/typeInference/combo/TypeInferenceComboTest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 8003280 8006694 8129962
 27  * @summary Add lambda tests
 28  *  perform automated checks in type inference in lambda expressions
 29  *  in different contexts
 30  *  temporarily workaround combo tests are causing time out in several platforms
 31  * @library /tools/javac/lib
 32  * @modules jdk.compiler/com.sun.tools.javac.api
 33  *          jdk.compiler/com.sun.tools.javac.code
 34  *          jdk.compiler/com.sun.tools.javac.comp
 35  *          jdk.compiler/com.sun.tools.javac.main
 36  *          jdk.compiler/com.sun.tools.javac.tree
 37  *          jdk.compiler/com.sun.tools.javac.util
 38  * @build combo.ComboTestHelper
 39  * @compile  TypeInferenceComboTest.java
 40  * @run main TypeInferenceComboTest
 41  */
 42 
 43 import java.io.IOException;
 44 
 45 import combo.ComboInstance;
 46 import combo.ComboParameter;
 47 import combo.ComboTask.Result;
 48 import combo.ComboTestHelper;
 49 
 50 public class TypeInferenceComboTest extends ComboInstance&lt;TypeInferenceComboTest&gt; {
 51     enum Context {
 52         ASSIGNMENT(&quot;SAM#Type s = #LBody;&quot;),
 53         METHOD_CALL(&quot;#GenericDeclKind void method1(SAM#Type s) { }\n&quot; +
 54                     &quot;void method2() {\n&quot; +
 55                     &quot;    method1(#LBody);\n&quot; +
 56                     &quot;}&quot;),
 57         RETURN_OF_METHOD(&quot;SAM#Type method1() {\n&quot; +
 58                 &quot;    return #LBody;\n&quot; +
 59                 &quot;}&quot;),
 60         LAMBDA_RETURN_EXPRESSION(&quot;SAM2 s2 = () -&gt; {return (SAM#Type)#LBody;};\n&quot;),
 61         ARRAY_INITIALIZER(&quot;Object[] oarray = {\&quot;a\&quot;, 1, (SAM#Type)#LBody};&quot;);
 62 
 63         String context;
 64 
 65         Context(String context) {
 66             this.context = context;
 67         }
 68 
 69         String getContext(SamKind sk, TypeKind samTargetT, Keyword kw,
 70                 TypeKind parameterT, TypeKind returnT, LambdaKind lk,
 71                 ParameterKind pk, GenericDeclKind gdk, LambdaBody lb) {
 72             String result = context;
 73             if (sk == SamKind.GENERIC) {
 74                 if(this == Context.METHOD_CALL) {
 75                     result = result.replaceAll(&quot;#GenericDeclKind&quot;,
 76                             gdk.getGenericDeclKind(samTargetT));
 77                     if(gdk == GenericDeclKind.NON_GENERIC)
 78                         result = result.replaceAll(&quot;#Type&quot;, &quot;&lt;&quot; +
 79                                 samTargetT.typeStr + &quot;&gt;&quot;);
 80                     else //#GenericDeclKind is &lt;T&gt; or &lt;T extends xxx&gt;
 81                         result = result.replaceAll(&quot;#Type&quot;, &quot;&lt;T&gt;&quot;);
 82                 }
 83                 else {
 84                     if(kw == Keyword.VOID)
 85                         result = result.replaceAll(&quot;#Type&quot;, &quot;&lt;&quot; +
 86                                 samTargetT.typeStr + &quot;&gt;&quot;);
 87                     else
 88                         result = result.replaceAll(&quot;#Type&quot;, &quot;&lt;? &quot; + kw.keyStr +
 89                                 &quot; &quot; + samTargetT.typeStr + &quot;&gt;&quot;);
 90                 }
 91             }
 92             else
 93                 result = result.replaceAll(&quot;#Type&quot;, &quot;&quot;).
 94                         replaceAll(&quot;#GenericDeclKind&quot;, &quot;&quot;);
 95 
 96             return result.replaceAll(&quot;#LBody&quot;,
 97                     lb.getLambdaBody(samTargetT, parameterT, returnT, lk, pk));
 98         }
 99     }
100 
101     enum SamKind {
102         GENERIC(&quot;interface SAM&lt;T&gt; { #R m(#ARG); }&quot;),
103         NON_GENERIC(&quot;interface SAM { #R m(#ARG); }&quot;);
104 
105         String sam_str;
106 
107         SamKind(String sam_str) {
108             this.sam_str = sam_str;
109         }
110 
111         String getSam(TypeKind parameterT, TypeKind returnT) {
112             return sam_str.replaceAll(&quot;#ARG&quot;,
113                     parameterT == TypeKind.VOID ?
114                         &quot;&quot; : parameterT.typeStr + &quot; arg&quot;)
115                     .replaceAll(&quot;#R&quot;, returnT.typeStr);
116         }
117     }
118 
119     enum TypeKind {
120         VOID(&quot;void&quot;, &quot;&quot;),
121         STRING(&quot;String&quot;, &quot;\&quot;hello\&quot;&quot;),
122         INTEGER(&quot;Integer&quot;, &quot;1&quot;),
123         INT(&quot;int&quot;, &quot;0&quot;),
124         COMPARATOR(&quot;java.util.Comparator&lt;String&gt;&quot;,
125                 &quot;(java.util.Comparator&lt;String&gt;)(a, b) -&gt; a.length()-b.length()&quot;),
126         SAM(&quot;SAM2&quot;, &quot;null&quot;),
127         GENERIC(&quot;T&quot;, null);
128 
129         String typeStr;
130         String valStr;
131 
132         TypeKind(String typeStr, String valStr) {
133             this.typeStr = typeStr;
134             this.valStr = valStr;
135         }
136     }
137 
138     enum LambdaKind {
139         EXPRESSION(&quot;#VAL&quot;),
140         STATEMENT(&quot;{return #VAL;}&quot;);
141 
142         String stmt;
143 
144         LambdaKind(String stmt) {
145             this.stmt = stmt;
146         }
147     }
148 
149     enum ParameterKind {
150         EXPLICIT(&quot;#TYPE&quot;),
151         IMPLICIT(&quot;&quot;);
152 
153         String paramTemplate;
154 
155         ParameterKind(String paramTemplate) {
156              this.paramTemplate = paramTemplate;
157         }
158     }
159 
160     enum Keyword {
161         SUPER(&quot;super&quot;),
162         EXTENDS(&quot;extends&quot;),
163         VOID(&quot;&quot;);
164 
165         String keyStr;
166 
167         Keyword(String keyStr) {
168             this.keyStr = keyStr;
169         }
170     }
171 
172     enum LambdaBody {
173         //no parameters, return type is one of the TypeKind
174         RETURN_VOID(&quot;() -&gt; #RET&quot;),
175         //has parameters, return type is one of the TypeKind
176         RETURN_ARG(&quot;(#PK arg) -&gt; #RET&quot;);
177 
178         String bodyStr;
179 
180         LambdaBody(String bodyStr) {
181             this.bodyStr = bodyStr;
182         }
183 
184         String getLambdaBody(TypeKind samTargetT, TypeKind parameterT,
185                 TypeKind returnT, LambdaKind lk, ParameterKind pk) {
186             String result = bodyStr.replaceAll(&quot;#PK&quot;, pk.paramTemplate);
187 
188             if(result.contains(&quot;#TYPE&quot;)) {
189                 if (parameterT == TypeKind.GENERIC &amp;&amp; this != RETURN_VOID)
190                     result = result.replaceAll(&quot;#TYPE&quot;,
191                             samTargetT == null? &quot;&quot;: samTargetT.typeStr);
192                 else
193                     result = result.replaceAll(&quot;#TYPE&quot;, parameterT.typeStr);
194             }
195             if (this == RETURN_ARG &amp;&amp; parameterT == returnT)
196                 return result.replaceAll(&quot;#RET&quot;, lk.stmt.replaceAll(&quot;#VAL&quot;, &quot;arg&quot;));
197             else {
198                 if(returnT != TypeKind.GENERIC)
199                     return result.replaceAll(&quot;#RET&quot;, lk.stmt.replaceAll(&quot;#VAL&quot;,
200                             (returnT==TypeKind.VOID &amp;&amp;
201                             lk==LambdaKind.EXPRESSION) ? &quot;{}&quot; : returnT.valStr));
202                 else
203                     return result.replaceAll(&quot;#RET&quot;,
204                             lk.stmt.replaceAll(&quot;#VAL&quot;, samTargetT.valStr));
205             }
206         }
207     }
208 
209     enum GenericDeclKind {
210         NON_GENERIC(&quot;&quot;),
211         GENERIC_NOBOUND(&quot;&lt;T&gt;&quot;),
212         GENERIC_BOUND(&quot;&lt;T extends #ExtendedType&gt;&quot;);
213         String typeStr;
214 
215         GenericDeclKind(String typeStr) {
216             this.typeStr = typeStr;
217         }
218 
219         String getGenericDeclKind(TypeKind et) {
220             return typeStr.replaceAll(&quot;#ExtendedType&quot;, et==null? &quot;&quot;:et.typeStr);
221         }
222     }
223 
224     public static void main(String[] args) {
225         new ComboTestHelper&lt;TypeInferenceComboTest&gt;()
226                 .withFilter(TypeInferenceComboTest::badTestFilter)
227                 .withFilter(TypeInferenceComboTest::redundantTestFilter)
228                 .withDimension(&quot;SAM&quot;, (x, sam) -&gt; x.samKind = sam, SamKind.values())
229                 .withDimension(&quot;SAMTARGET&quot;, (x, target) -&gt; x.samTargetType = target, TypeKind.values())
230                 .withDimension(&quot;PARAMTYPE&quot;, (x, param) -&gt; x.parameterType = param, TypeKind.values())
231                 .withDimension(&quot;RETTYPE&quot;, (x, ret) -&gt; x.returnType = ret, TypeKind.values())
232                 .withDimension(&quot;CTX&quot;, (x, ctx) -&gt; x.context = ctx, Context.values())
233                 .withDimension(&quot;LAMBDABODY&quot;, (x, body) -&gt; x.lambdaBodyType = body, LambdaBody.values())
234                 .withDimension(&quot;LAMBDAKIND&quot;, (x, lambda) -&gt; x.lambdaKind = lambda, LambdaKind.values())
235                 .withDimension(&quot;PARAMKIND&quot;, (x, param) -&gt; x.parameterKind = param, ParameterKind.values())
236                 .withDimension(&quot;KEYWORD&quot;, (x, kw) -&gt; x.keyword = kw, Keyword.values())
237                 .withDimension(&quot;GENDECL&quot;, (x, gk) -&gt; x.genericDeclKind = gk, GenericDeclKind.values())
238                 .run(TypeInferenceComboTest::new);
239     }
240 
241     SamKind samKind;
242     TypeKind samTargetType;
243     TypeKind parameterType;
244     TypeKind returnType;
245     Context context;
246     LambdaBody lambdaBodyType;
247     LambdaKind lambdaKind;
248     ParameterKind parameterKind;
249     Keyword keyword;
250     GenericDeclKind genericDeclKind;
251 
252     boolean badTestFilter() {
253         if (samKind == SamKind.NON_GENERIC) {
254             return (parameterType != TypeKind.GENERIC &amp;&amp; returnType != TypeKind.GENERIC);
255         } else {
256             return (samTargetType != TypeKind.VOID &amp;&amp;
257                    samTargetType != TypeKind.INT &amp;&amp;
258                    samTargetType != TypeKind.GENERIC &amp;&amp;
259                    (parameterType == TypeKind.GENERIC ||
260                    returnType == TypeKind.GENERIC));
261         }
262     }
263 
264     boolean redundantTestFilter() {
265         if (samKind == SamKind.NON_GENERIC) {
266             return keyword.ordinal() == 0 &amp;&amp; samTargetType.ordinal() == 0 &amp;&amp; genericDeclKind.ordinal() == 0;
267         } else {
268             return context == Context.METHOD_CALL || genericDeclKind.ordinal() == 0;
269         }
270     }
271 
272     String sam_template = &quot;#{SAM}\n&quot; +
273                          &quot;interface SAM2 {\n&quot; +
274                          &quot;    SAM m();\n&quot; +
275                          &quot;}\n&quot;;
276 
277 
278     String client_template = &quot;class Client { \n&quot; +
279                              &quot;    #{CONTEXT}\n&quot; +
280                              &quot;}&quot;;
281 
282     @Override
283     public void doWork() throws IOException {
284         newCompilationTask()
285                 .withSourceFromTemplate(&quot;Sam&quot;, sam_template, this::samClass)
286                 .withSourceFromTemplate(&quot;Client&quot;, client_template, this::clientContext)
287                 .analyze(res -&gt; {
288             if (res.hasErrors() == checkTypeInference()) {
289                 fail(&quot;Unexpected compilation output when compiling instance: &quot; + res.compilationInfo());
290             }
291         });
292     }
293 
294     ComboParameter samClass(String parameterName) {
295         switch (parameterName) {
296             case &quot;SAM&quot;:
297                 return new ComboParameter.Constant&lt;&gt;(samKind.getSam(parameterType, returnType));
298             default:
299                 return null;
300         }
301     }
302 
303     ComboParameter clientContext(String parameterName) {
304         switch (parameterName) {
305             case &quot;CONTEXT&quot;:
306                 return new ComboParameter.Constant&lt;&gt;(context.getContext(samKind, samTargetType,
307                         keyword, parameterType, returnType, lambdaKind, parameterKind, genericDeclKind, lambdaBodyType));
308             default:
309                 return null;
310         }
311     }
312 
313     boolean checkTypeInference() {
314         if (parameterType == TypeKind.VOID) {
315             if (lambdaBodyType != LambdaBody.RETURN_VOID)
316                 return false;
317         }
318         else if (lambdaBodyType != LambdaBody.RETURN_ARG)
319             return false;
320 
321         return true;
322     }
323 }
    </pre>
  </body>
</html>
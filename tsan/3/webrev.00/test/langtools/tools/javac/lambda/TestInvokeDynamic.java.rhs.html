<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/lambda/TestInvokeDynamic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 7194586 8003280 8006694 8010404 8129962
 27  * @summary Add lambda tests
 28  *  Add back-end support for invokedynamic
 29  *  temporarily workaround combo tests are causing time out in several platforms
 30  * @library /tools/javac/lib
 31  * @modules jdk.jdeps/com.sun.tools.classfile
 32  *          jdk.compiler/com.sun.tools.javac.api
 33  *          jdk.compiler/com.sun.tools.javac.code
<a name="1" id="anc1"></a><span class="line-modified"> 34  *          jdk.compiler/com.sun.tools.javac.file</span>

 35  *          jdk.compiler/com.sun.tools.javac.jvm
 36  *          jdk.compiler/com.sun.tools.javac.tree
 37  *          jdk.compiler/com.sun.tools.javac.util
 38  * @build combo.ComboTestHelper
 39  * @run main TestInvokeDynamic
 40  */
 41 
 42 import java.io.IOException;
 43 import java.io.InputStream;
 44 
 45 import javax.tools.JavaFileObject;
 46 
 47 import com.sun.source.tree.MethodInvocationTree;
 48 import com.sun.source.tree.MethodTree;
 49 import com.sun.source.util.TaskEvent;
 50 import com.sun.source.util.TaskListener;
 51 import com.sun.source.util.TreeScanner;
 52 
 53 import com.sun.tools.classfile.Attribute;
 54 import com.sun.tools.classfile.BootstrapMethods_attribute;
 55 import com.sun.tools.classfile.ClassFile;
 56 import com.sun.tools.classfile.Code_attribute;
 57 import com.sun.tools.classfile.ConstantPool.*;
 58 import com.sun.tools.classfile.Instruction;
 59 import com.sun.tools.classfile.LineNumberTable_attribute;
 60 import com.sun.tools.classfile.Method;
 61 
<a name="2" id="anc2"></a>
 62 import com.sun.tools.javac.code.Symbol;
<a name="3" id="anc3"></a><span class="line-modified"> 63 import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;</span>
 64 import com.sun.tools.javac.code.Symtab;
<a name="4" id="anc4"></a><span class="line-added"> 65 import com.sun.tools.javac.code.Type.ClassType;</span>
<span class="line-added"> 66 import com.sun.tools.javac.code.Type.MethodType;</span>
 67 import com.sun.tools.javac.code.Types;
<a name="5" id="anc5"></a><span class="line-modified"> 68 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;</span>
 69 import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
 70 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 71 import com.sun.tools.javac.tree.JCTree.JCIdent;
<a name="6" id="anc6"></a>
 72 import com.sun.tools.javac.util.Names;
 73 
 74 import combo.ComboParameter;
<a name="7" id="anc7"></a>
 75 import combo.ComboTestHelper;
 76 import combo.ComboInstance;
 77 import combo.ComboTask.Result;
 78 
<a name="8" id="anc8"></a>

 79 public class TestInvokeDynamic extends ComboInstance&lt;TestInvokeDynamic&gt; {
 80 
 81     enum StaticArgumentKind implements ComboParameter {
 82         STRING(&quot;Hello!&quot;, &quot;String&quot;, &quot;Ljava/lang/String;&quot;) {
 83             @Override
 84             boolean check(CPInfo cpInfo) throws Exception {
 85                 return (cpInfo instanceof CONSTANT_String_info) &amp;&amp;
 86                         ((CONSTANT_String_info)cpInfo).getString()
 87                         .equals(value);
 88             }
 89         },
 90         CLASS(null, &quot;Class&lt;?&gt;&quot;, &quot;Ljava/lang/Class;&quot;) {
 91             @Override
 92             boolean check(CPInfo cpInfo) throws Exception {
 93                 return (cpInfo instanceof CONSTANT_Class_info) &amp;&amp;
 94                         ((CONSTANT_Class_info)cpInfo).getName()
 95                         .equals(&quot;java/lang/String&quot;);
 96             }
 97         },
 98         INTEGER(1, &quot;int&quot;, &quot;I&quot;) {
 99             @Override
100             boolean check(CPInfo cpInfo) throws Exception {
101                 return (cpInfo instanceof CONSTANT_Integer_info) &amp;&amp;
102                         ((CONSTANT_Integer_info)cpInfo).value ==
103                         ((Integer)value).intValue();
104             }
105         },
106         LONG(1L, &quot;long&quot;, &quot;J&quot;) {
107             @Override
108             boolean check(CPInfo cpInfo) throws Exception {
109                 return (cpInfo instanceof CONSTANT_Long_info) &amp;&amp;
110                         ((CONSTANT_Long_info)cpInfo).value ==
111                         ((Long)value).longValue();
112             }
113         },
114         FLOAT(1.0f, &quot;float&quot;, &quot;F&quot;) {
115             @Override
116             boolean check(CPInfo cpInfo) throws Exception {
117                 return (cpInfo instanceof CONSTANT_Float_info) &amp;&amp;
118                         ((CONSTANT_Float_info)cpInfo).value ==
119                         ((Float)value).floatValue();
120             }
121         },
122         DOUBLE(1.0, &quot;double&quot;,&quot;D&quot;) {
123             @Override
124             boolean check(CPInfo cpInfo) throws Exception {
125                 return (cpInfo instanceof CONSTANT_Double_info) &amp;&amp;
126                         ((CONSTANT_Double_info)cpInfo).value ==
127                         ((Double)value).doubleValue();
128             }
129         },
130         METHOD_HANDLE(null, &quot;MethodHandle&quot;, &quot;Ljava/lang/invoke/MethodHandle;&quot;) {
131             @Override
132             boolean check(CPInfo cpInfo) throws Exception {
133                 if (!(cpInfo instanceof CONSTANT_MethodHandle_info))
134                     return false;
135                 CONSTANT_MethodHandle_info handleInfo =
136                         (CONSTANT_MethodHandle_info)cpInfo;
137                 return handleInfo.getCPRefInfo().getClassName().equals(&quot;Array&quot;) &amp;&amp;
138                         handleInfo.reference_kind == RefKind.REF_invokeVirtual &amp;&amp;
139                         handleInfo.getCPRefInfo()
140                         .getNameAndTypeInfo().getName().equals(&quot;clone&quot;) &amp;&amp;
141                         handleInfo.getCPRefInfo()
142                         .getNameAndTypeInfo().getType().equals(&quot;()Ljava/lang/Object;&quot;);
143             }
144         },
145         METHOD_TYPE(null, &quot;MethodType&quot;, &quot;Ljava/lang/invoke/MethodType;&quot;) {
146             @Override
147             boolean check(CPInfo cpInfo) throws Exception {
148                 return (cpInfo instanceof CONSTANT_MethodType_info) &amp;&amp;
149                         ((CONSTANT_MethodType_info)cpInfo).getType()
150                         .equals(&quot;()Ljava/lang/Object;&quot;);
151             }
152         };
153 
154         Object value;
155         String sourceTypeStr;
156         String bytecodeTypeStr;
157 
158         StaticArgumentKind(Object value, String sourceTypeStr,
159                 String bytecodeTypeStr) {
160             this.value = value;
161             this.sourceTypeStr = sourceTypeStr;
162             this.bytecodeTypeStr = bytecodeTypeStr;
163         }
164 
165         abstract boolean check(CPInfo cpInfo) throws Exception;
166 
<a name="9" id="anc9"></a><span class="line-modified">167         LoadableConstant getValue(Symtab syms) {</span>
168             switch (this) {
169                 case STRING:
<a name="10" id="anc10"></a><span class="line-added">170                     return LoadableConstant.String((String)value);</span>
171                 case INTEGER:
<a name="11" id="anc11"></a><span class="line-added">172                     return LoadableConstant.Int((Integer)value);</span>
173                 case LONG:
<a name="12" id="anc12"></a><span class="line-added">174                     return LoadableConstant.Long((Long)value);</span>
175                 case FLOAT:
<a name="13" id="anc13"></a><span class="line-added">176                     return LoadableConstant.Float((Float)value);</span>
177                 case DOUBLE:
<a name="14" id="anc14"></a><span class="line-modified">178                     return LoadableConstant.Double((Double)value);</span>
179                 case CLASS:
<a name="15" id="anc15"></a><span class="line-modified">180                     return (ClassType)syms.stringType;</span>
181                 case METHOD_HANDLE:
<a name="16" id="anc16"></a><span class="line-modified">182                     return syms.arrayCloneMethod.asHandle();</span>

183                 case METHOD_TYPE:
<a name="17" id="anc17"></a><span class="line-modified">184                     return ((MethodType)syms.arrayCloneMethod.type);</span>
185                 default:
186                     throw new AssertionError();
187             }
188         }
189 
190         @Override
191         public String expand(String optParameter) {
192             return sourceTypeStr;
193         }
194     }
195 
196     enum StaticArgumentsArity implements ComboParameter {
197         ZERO(0, &quot;&quot;),
198         ONE(1, &quot;,#{SARG[0]} s1&quot;),
199         TWO(2, &quot;,#{SARG[0]} s1, #{SARG[1]} s2&quot;),
200         THREE(3, &quot;,#{SARG[0]} s1, #{SARG[1]} s2, #{SARG[2]} s3&quot;);
201 
202         int arity;
203         String argsTemplate;
204 
205         StaticArgumentsArity(int arity, String argsTemplate) {
206             this.arity = arity;
207             this.argsTemplate = argsTemplate;
208         }
209 
210         @Override
211         public String expand(String optParameter) {
212             return argsTemplate;
213         }
214     }
215 
216     public static void main(String... args) throws Exception {
217         new ComboTestHelper&lt;TestInvokeDynamic&gt;()
218                 .withFilter(TestInvokeDynamic::redundantTestFilter)
219                 .withDimension(&quot;SARGS&quot;, (x, arity) -&gt; x.arity = arity, StaticArgumentsArity.values())
220                 .withArrayDimension(&quot;SARG&quot;, (x, arg, idx) -&gt; x.saks[idx] = arg, 3, StaticArgumentKind.values())
221                 .run(TestInvokeDynamic::new);
222     }
223 
224     StaticArgumentsArity arity;
225     StaticArgumentKind[] saks = new StaticArgumentKind[3];
226 
227     boolean redundantTestFilter() {
228         for (int i = arity.arity ; i &lt; saks.length ; i++) {
229             if (saks[i].ordinal() != 0) {
230                 return false;
231             }
232         }
233         return true;
234     }
235 
236     final String source_template =
237                 &quot;import java.lang.invoke.*;\n&quot; +
238                 &quot;class Test {\n&quot; +
239                 &quot;   void m() { }\n&quot; +
240                 &quot;   void test() {\n&quot; +
241                 &quot;      Object o = this; // marker statement \n&quot; +
242                 &quot;      m();\n&quot; +
243                 &quot;   }\n&quot; +
244                 &quot;}\n&quot; +
245                 &quot;class Bootstrap {\n&quot; +
246                 &quot;   public static CallSite bsm(MethodHandles.Lookup lookup, &quot; +
247                 &quot;String name, MethodType methodType #{SARGS}) {\n&quot; +
248                 &quot;       return null;\n&quot; +
249                 &quot;   }\n&quot; +
250                 &quot;}&quot;;
251 
252     @Override
253     public void doWork() throws IOException {
254         newCompilationTask()
255                 .withOption(&quot;-g&quot;)
256                 .withSourceFromTemplate(source_template)
257                 .withListenerFactory(context -&gt; {
258                         Symtab syms = Symtab.instance(context);
259                         Names names = Names.instance(context);
260                         Types types = Types.instance(context);
261                         return new Indifier(syms, names, types);
262                     })
263                 .generate(this::verifyBytecode);
264     }
265 
266     void verifyBytecode(Result&lt;Iterable&lt;? extends JavaFileObject&gt;&gt; res) {
267         if (res.hasErrors()) {
268             fail(&quot;Diags found when compiling instance: &quot; + res.compilationInfo());
269             return;
270         }
271         try (InputStream is = res.get().iterator().next().openInputStream()){
272             ClassFile cf = ClassFile.read(is);
273             Method testMethod = null;
274             for (Method m : cf.methods) {
275                 if (m.getName(cf.constant_pool).equals(&quot;test&quot;)) {
276                     testMethod = m;
277                     break;
278                 }
279             }
280             if (testMethod == null) {
281                 fail(&quot;Test method not found&quot;);
282                 return;
283             }
284             Code_attribute ea =
285                     (Code_attribute)testMethod.attributes.get(Attribute.Code);
286             if (testMethod == null) {
287                 fail(&quot;Code attribute for test() method not found&quot;);
288                 return;
289             }
290 
291             int bsmIdx = -1;
292 
293             for (Instruction i : ea.getInstructions()) {
294                 if (i.getMnemonic().equals(&quot;invokedynamic&quot;)) {
295                     CONSTANT_InvokeDynamic_info indyInfo =
296                          (CONSTANT_InvokeDynamic_info)cf
297                             .constant_pool.get(i.getShort(1));
298                     bsmIdx = indyInfo.bootstrap_method_attr_index;
299                     if (!indyInfo.getNameAndTypeInfo().getType().equals(&quot;()V&quot;)) {
300                         fail(&quot;type mismatch for CONSTANT_InvokeDynamic_info&quot;);
301                         return;
302                     }
303                 }
304             }
305             if (bsmIdx == -1) {
306                 fail(&quot;Missing invokedynamic in generated code&quot;);
307                 return;
308             }
309 
310             BootstrapMethods_attribute bsm_attr =
311                     (BootstrapMethods_attribute)cf
312                     .getAttribute(Attribute.BootstrapMethods);
313             if (bsm_attr.bootstrap_method_specifiers.length != 1) {
314                 fail(&quot;Bad number of method specifiers &quot; +
315                         &quot;in BootstrapMethods attribute&quot;);
316                 return;
317             }
318             BootstrapMethods_attribute.BootstrapMethodSpecifier bsm_spec =
319                     bsm_attr.bootstrap_method_specifiers[0];
320 
321             if (bsm_spec.bootstrap_arguments.length != arity.arity) {
322                 fail(&quot;Bad number of static invokedynamic args &quot; +
323                         &quot;in BootstrapMethod attribute&quot;);
324                 return;
325             }
326 
327             for (int i = 0 ; i &lt; arity.arity ; i++) {
328                 if (!saks[i].check(cf.constant_pool
329                         .get(bsm_spec.bootstrap_arguments[i]))) {
330                     fail(&quot;Bad static argument value &quot; + saks[i]);
331                     return;
332                 }
333             }
334 
335             CONSTANT_MethodHandle_info bsm_handle =
336                     (CONSTANT_MethodHandle_info)cf.constant_pool
337                     .get(bsm_spec.bootstrap_method_ref);
338 
339             if (bsm_handle.reference_kind != RefKind.REF_invokeStatic) {
340                 fail(&quot;Bad kind on boostrap method handle&quot;);
341                 return;
342             }
343 
344             CONSTANT_Methodref_info bsm_ref =
345                     (CONSTANT_Methodref_info)cf.constant_pool
346                     .get(bsm_handle.reference_index);
347 
348             if (!bsm_ref.getClassInfo().getName().equals(&quot;Bootstrap&quot;)) {
349                 fail(&quot;Bad owner of boostrap method&quot;);
350                 return;
351             }
352 
353             if (!bsm_ref.getNameAndTypeInfo().getName().equals(&quot;bsm&quot;)) {
354                 fail(&quot;Bad boostrap method name&quot;);
355                 return;
356             }
357 
358             if (!bsm_ref.getNameAndTypeInfo()
359                     .getType().equals(asBSMSignatureString())) {
360                 fail(&quot;Bad boostrap method type&quot; +
361                         bsm_ref.getNameAndTypeInfo().getType() + &quot; &quot; +
362                         asBSMSignatureString());
363                 return;
364             }
365 
366             LineNumberTable_attribute lnt =
367                     (LineNumberTable_attribute)ea.attributes.get(Attribute.LineNumberTable);
368 
369             if (lnt == null) {
370                 fail(&quot;No LineNumberTable attribute&quot;);
371                 return;
372             }
373             if (lnt.line_number_table_length != 3) {
374                 fail(&quot;Wrong number of entries in LineNumberTable&quot;);
375                 return;
376             }
377         } catch (Exception e) {
378             e.printStackTrace();
379             fail(&quot;error reading classfile: &quot; + res.compilationInfo());
380             return;
381         }
382     }
383 
384     String asBSMSignatureString() {
385         StringBuilder buf = new StringBuilder();
386         buf.append(&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;&quot;);
387         for (int i = 0 ; i &lt; arity.arity ; i++) {
388             buf.append(saks[i].bytecodeTypeStr);
389         }
390         buf.append(&quot;)Ljava/lang/invoke/CallSite;&quot;);
391         return buf.toString();
392     }
393 
394     class Indifier extends TreeScanner&lt;Void, Void&gt; implements TaskListener {
395 
<a name="18" id="anc18"></a><span class="line-modified">396         MethodHandleSymbol bsm;</span>
397         Symtab syms;
398         Names names;
399         Types types;
400 
401         Indifier(Symtab syms, Names names, Types types) {
402             this.syms = syms;
403             this.names = names;
404             this.types = types;
405         }
406 
407         @Override
408         public void started(TaskEvent e) {
409             //do nothing
410         }
411 
412         @Override
413         public void finished(TaskEvent e) {
414             if (e.getKind() == TaskEvent.Kind.ANALYZE) {
415                 scan(e.getCompilationUnit(), null);
416             }
417         }
418 
419         @Override
420         public Void visitMethodInvocation(MethodInvocationTree node, Void p) {
421             super.visitMethodInvocation(node, p);
422             JCMethodInvocation apply = (JCMethodInvocation)node;
423             JCIdent ident = (JCIdent)apply.meth;
424             Symbol oldSym = ident.sym;
425             if (!oldSym.isConstructor()) {
<a name="19" id="anc19"></a><span class="line-modified">426                 LoadableConstant[] staticArgs = new LoadableConstant[arity.arity];</span>
427                 for (int i = 0; i &lt; arity.arity ; i++) {
<a name="20" id="anc20"></a><span class="line-modified">428                     staticArgs[i] = saks[i].getValue(syms);</span>
429                 }
430                 ident.sym = new Symbol.DynamicMethodSymbol(oldSym.name,
<a name="21" id="anc21"></a><span class="line-modified">431                         oldSym.owner, bsm, oldSym.type, staticArgs);</span>
432             }
433             return null;
434         }
435 
436         @Override
437         public Void visitMethod(MethodTree node, Void p) {
438             super.visitMethod(node, p);
439             if (node.getName().toString().equals(&quot;bsm&quot;)) {
<a name="22" id="anc22"></a><span class="line-modified">440                 bsm = ((JCMethodDecl)node).sym.asHandle();</span>
441             }
442             return null;
443         }
444     }
445 }
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/lambda/TestInvokeDynamic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 7194586 8003280 8006694 8010404 8129962
 27  * @summary Add lambda tests
 28  *  Add back-end support for invokedynamic
 29  *  temporarily workaround combo tests are causing time out in several platforms
 30  * @library /tools/javac/lib
 31  * @modules jdk.jdeps/com.sun.tools.classfile
 32  *          jdk.compiler/com.sun.tools.javac.api
 33  *          jdk.compiler/com.sun.tools.javac.code
<a name="1" id="anc1"></a><span class="line-modified"> 34  *          jdk.compiler/com.sun.tools.javac.comp</span>
<span class="line-removed"> 35  *          jdk.compiler/com.sun.tools.javac.main</span>
 36  *          jdk.compiler/com.sun.tools.javac.jvm
 37  *          jdk.compiler/com.sun.tools.javac.tree
 38  *          jdk.compiler/com.sun.tools.javac.util
 39  * @build combo.ComboTestHelper
 40  * @run main TestInvokeDynamic
 41  */
 42 
 43 import java.io.IOException;
 44 import java.io.InputStream;
 45 
 46 import javax.tools.JavaFileObject;
 47 
 48 import com.sun.source.tree.MethodInvocationTree;
 49 import com.sun.source.tree.MethodTree;
 50 import com.sun.source.util.TaskEvent;
 51 import com.sun.source.util.TaskListener;
 52 import com.sun.source.util.TreeScanner;
 53 
 54 import com.sun.tools.classfile.Attribute;
 55 import com.sun.tools.classfile.BootstrapMethods_attribute;
 56 import com.sun.tools.classfile.ClassFile;
 57 import com.sun.tools.classfile.Code_attribute;
 58 import com.sun.tools.classfile.ConstantPool.*;
 59 import com.sun.tools.classfile.Instruction;
 60 import com.sun.tools.classfile.LineNumberTable_attribute;
 61 import com.sun.tools.classfile.Method;
 62 
<a name="2" id="anc2"></a><span class="line-removed"> 63 import com.sun.tools.javac.api.JavacTaskImpl;</span>
 64 import com.sun.tools.javac.code.Symbol;
<a name="3" id="anc3"></a><span class="line-modified"> 65 import com.sun.tools.javac.code.Symbol.MethodSymbol;</span>
 66 import com.sun.tools.javac.code.Symtab;
<a name="4" id="anc4"></a>

 67 import com.sun.tools.javac.code.Types;
<a name="5" id="anc5"></a><span class="line-modified"> 68 import com.sun.tools.javac.jvm.Pool;</span>
 69 import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
 70 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 71 import com.sun.tools.javac.tree.JCTree.JCIdent;
<a name="6" id="anc6"></a><span class="line-removed"> 72 import com.sun.tools.javac.util.Context;</span>
 73 import com.sun.tools.javac.util.Names;
 74 
 75 import combo.ComboParameter;
<a name="7" id="anc7"></a><span class="line-removed"> 76 import combo.ComboTask;</span>
 77 import combo.ComboTestHelper;
 78 import combo.ComboInstance;
 79 import combo.ComboTask.Result;
 80 
<a name="8" id="anc8"></a><span class="line-removed"> 81 import static com.sun.tools.javac.jvm.ClassFile.*;</span>
<span class="line-removed"> 82 </span>
 83 public class TestInvokeDynamic extends ComboInstance&lt;TestInvokeDynamic&gt; {
 84 
 85     enum StaticArgumentKind implements ComboParameter {
 86         STRING(&quot;Hello!&quot;, &quot;String&quot;, &quot;Ljava/lang/String;&quot;) {
 87             @Override
 88             boolean check(CPInfo cpInfo) throws Exception {
 89                 return (cpInfo instanceof CONSTANT_String_info) &amp;&amp;
 90                         ((CONSTANT_String_info)cpInfo).getString()
 91                         .equals(value);
 92             }
 93         },
 94         CLASS(null, &quot;Class&lt;?&gt;&quot;, &quot;Ljava/lang/Class;&quot;) {
 95             @Override
 96             boolean check(CPInfo cpInfo) throws Exception {
 97                 return (cpInfo instanceof CONSTANT_Class_info) &amp;&amp;
 98                         ((CONSTANT_Class_info)cpInfo).getName()
 99                         .equals(&quot;java/lang/String&quot;);
100             }
101         },
102         INTEGER(1, &quot;int&quot;, &quot;I&quot;) {
103             @Override
104             boolean check(CPInfo cpInfo) throws Exception {
105                 return (cpInfo instanceof CONSTANT_Integer_info) &amp;&amp;
106                         ((CONSTANT_Integer_info)cpInfo).value ==
107                         ((Integer)value).intValue();
108             }
109         },
110         LONG(1L, &quot;long&quot;, &quot;J&quot;) {
111             @Override
112             boolean check(CPInfo cpInfo) throws Exception {
113                 return (cpInfo instanceof CONSTANT_Long_info) &amp;&amp;
114                         ((CONSTANT_Long_info)cpInfo).value ==
115                         ((Long)value).longValue();
116             }
117         },
118         FLOAT(1.0f, &quot;float&quot;, &quot;F&quot;) {
119             @Override
120             boolean check(CPInfo cpInfo) throws Exception {
121                 return (cpInfo instanceof CONSTANT_Float_info) &amp;&amp;
122                         ((CONSTANT_Float_info)cpInfo).value ==
123                         ((Float)value).floatValue();
124             }
125         },
126         DOUBLE(1.0, &quot;double&quot;,&quot;D&quot;) {
127             @Override
128             boolean check(CPInfo cpInfo) throws Exception {
129                 return (cpInfo instanceof CONSTANT_Double_info) &amp;&amp;
130                         ((CONSTANT_Double_info)cpInfo).value ==
131                         ((Double)value).doubleValue();
132             }
133         },
134         METHOD_HANDLE(null, &quot;MethodHandle&quot;, &quot;Ljava/lang/invoke/MethodHandle;&quot;) {
135             @Override
136             boolean check(CPInfo cpInfo) throws Exception {
137                 if (!(cpInfo instanceof CONSTANT_MethodHandle_info))
138                     return false;
139                 CONSTANT_MethodHandle_info handleInfo =
140                         (CONSTANT_MethodHandle_info)cpInfo;
141                 return handleInfo.getCPRefInfo().getClassName().equals(&quot;Array&quot;) &amp;&amp;
142                         handleInfo.reference_kind == RefKind.REF_invokeVirtual &amp;&amp;
143                         handleInfo.getCPRefInfo()
144                         .getNameAndTypeInfo().getName().equals(&quot;clone&quot;) &amp;&amp;
145                         handleInfo.getCPRefInfo()
146                         .getNameAndTypeInfo().getType().equals(&quot;()Ljava/lang/Object;&quot;);
147             }
148         },
149         METHOD_TYPE(null, &quot;MethodType&quot;, &quot;Ljava/lang/invoke/MethodType;&quot;) {
150             @Override
151             boolean check(CPInfo cpInfo) throws Exception {
152                 return (cpInfo instanceof CONSTANT_MethodType_info) &amp;&amp;
153                         ((CONSTANT_MethodType_info)cpInfo).getType()
154                         .equals(&quot;()Ljava/lang/Object;&quot;);
155             }
156         };
157 
158         Object value;
159         String sourceTypeStr;
160         String bytecodeTypeStr;
161 
162         StaticArgumentKind(Object value, String sourceTypeStr,
163                 String bytecodeTypeStr) {
164             this.value = value;
165             this.sourceTypeStr = sourceTypeStr;
166             this.bytecodeTypeStr = bytecodeTypeStr;
167         }
168 
169         abstract boolean check(CPInfo cpInfo) throws Exception;
170 
<a name="9" id="anc9"></a><span class="line-modified">171         Object getValue(Symtab syms, Names names, Types types) {</span>
172             switch (this) {
173                 case STRING:
<a name="10" id="anc10"></a>
174                 case INTEGER:
<a name="11" id="anc11"></a>
175                 case LONG:
<a name="12" id="anc12"></a>
176                 case FLOAT:
<a name="13" id="anc13"></a>
177                 case DOUBLE:
<a name="14" id="anc14"></a><span class="line-modified">178                     return value;</span>
179                 case CLASS:
<a name="15" id="anc15"></a><span class="line-modified">180                     return syms.stringType.tsym;</span>
181                 case METHOD_HANDLE:
<a name="16" id="anc16"></a><span class="line-modified">182                     return new Pool.MethodHandle(REF_invokeVirtual,</span>
<span class="line-removed">183                             syms.arrayCloneMethod, types);</span>
184                 case METHOD_TYPE:
<a name="17" id="anc17"></a><span class="line-modified">185                     return syms.arrayCloneMethod.type;</span>
186                 default:
187                     throw new AssertionError();
188             }
189         }
190 
191         @Override
192         public String expand(String optParameter) {
193             return sourceTypeStr;
194         }
195     }
196 
197     enum StaticArgumentsArity implements ComboParameter {
198         ZERO(0, &quot;&quot;),
199         ONE(1, &quot;,#{SARG[0]} s1&quot;),
200         TWO(2, &quot;,#{SARG[0]} s1, #{SARG[1]} s2&quot;),
201         THREE(3, &quot;,#{SARG[0]} s1, #{SARG[1]} s2, #{SARG[2]} s3&quot;);
202 
203         int arity;
204         String argsTemplate;
205 
206         StaticArgumentsArity(int arity, String argsTemplate) {
207             this.arity = arity;
208             this.argsTemplate = argsTemplate;
209         }
210 
211         @Override
212         public String expand(String optParameter) {
213             return argsTemplate;
214         }
215     }
216 
217     public static void main(String... args) throws Exception {
218         new ComboTestHelper&lt;TestInvokeDynamic&gt;()
219                 .withFilter(TestInvokeDynamic::redundantTestFilter)
220                 .withDimension(&quot;SARGS&quot;, (x, arity) -&gt; x.arity = arity, StaticArgumentsArity.values())
221                 .withArrayDimension(&quot;SARG&quot;, (x, arg, idx) -&gt; x.saks[idx] = arg, 3, StaticArgumentKind.values())
222                 .run(TestInvokeDynamic::new);
223     }
224 
225     StaticArgumentsArity arity;
226     StaticArgumentKind[] saks = new StaticArgumentKind[3];
227 
228     boolean redundantTestFilter() {
229         for (int i = arity.arity ; i &lt; saks.length ; i++) {
230             if (saks[i].ordinal() != 0) {
231                 return false;
232             }
233         }
234         return true;
235     }
236 
237     final String source_template =
238                 &quot;import java.lang.invoke.*;\n&quot; +
239                 &quot;class Test {\n&quot; +
240                 &quot;   void m() { }\n&quot; +
241                 &quot;   void test() {\n&quot; +
242                 &quot;      Object o = this; // marker statement \n&quot; +
243                 &quot;      m();\n&quot; +
244                 &quot;   }\n&quot; +
245                 &quot;}\n&quot; +
246                 &quot;class Bootstrap {\n&quot; +
247                 &quot;   public static CallSite bsm(MethodHandles.Lookup lookup, &quot; +
248                 &quot;String name, MethodType methodType #{SARGS}) {\n&quot; +
249                 &quot;       return null;\n&quot; +
250                 &quot;   }\n&quot; +
251                 &quot;}&quot;;
252 
253     @Override
254     public void doWork() throws IOException {
255         newCompilationTask()
256                 .withOption(&quot;-g&quot;)
257                 .withSourceFromTemplate(source_template)
258                 .withListenerFactory(context -&gt; {
259                         Symtab syms = Symtab.instance(context);
260                         Names names = Names.instance(context);
261                         Types types = Types.instance(context);
262                         return new Indifier(syms, names, types);
263                     })
264                 .generate(this::verifyBytecode);
265     }
266 
267     void verifyBytecode(Result&lt;Iterable&lt;? extends JavaFileObject&gt;&gt; res) {
268         if (res.hasErrors()) {
269             fail(&quot;Diags found when compiling instance: &quot; + res.compilationInfo());
270             return;
271         }
272         try (InputStream is = res.get().iterator().next().openInputStream()){
273             ClassFile cf = ClassFile.read(is);
274             Method testMethod = null;
275             for (Method m : cf.methods) {
276                 if (m.getName(cf.constant_pool).equals(&quot;test&quot;)) {
277                     testMethod = m;
278                     break;
279                 }
280             }
281             if (testMethod == null) {
282                 fail(&quot;Test method not found&quot;);
283                 return;
284             }
285             Code_attribute ea =
286                     (Code_attribute)testMethod.attributes.get(Attribute.Code);
287             if (testMethod == null) {
288                 fail(&quot;Code attribute for test() method not found&quot;);
289                 return;
290             }
291 
292             int bsmIdx = -1;
293 
294             for (Instruction i : ea.getInstructions()) {
295                 if (i.getMnemonic().equals(&quot;invokedynamic&quot;)) {
296                     CONSTANT_InvokeDynamic_info indyInfo =
297                          (CONSTANT_InvokeDynamic_info)cf
298                             .constant_pool.get(i.getShort(1));
299                     bsmIdx = indyInfo.bootstrap_method_attr_index;
300                     if (!indyInfo.getNameAndTypeInfo().getType().equals(&quot;()V&quot;)) {
301                         fail(&quot;type mismatch for CONSTANT_InvokeDynamic_info&quot;);
302                         return;
303                     }
304                 }
305             }
306             if (bsmIdx == -1) {
307                 fail(&quot;Missing invokedynamic in generated code&quot;);
308                 return;
309             }
310 
311             BootstrapMethods_attribute bsm_attr =
312                     (BootstrapMethods_attribute)cf
313                     .getAttribute(Attribute.BootstrapMethods);
314             if (bsm_attr.bootstrap_method_specifiers.length != 1) {
315                 fail(&quot;Bad number of method specifiers &quot; +
316                         &quot;in BootstrapMethods attribute&quot;);
317                 return;
318             }
319             BootstrapMethods_attribute.BootstrapMethodSpecifier bsm_spec =
320                     bsm_attr.bootstrap_method_specifiers[0];
321 
322             if (bsm_spec.bootstrap_arguments.length != arity.arity) {
323                 fail(&quot;Bad number of static invokedynamic args &quot; +
324                         &quot;in BootstrapMethod attribute&quot;);
325                 return;
326             }
327 
328             for (int i = 0 ; i &lt; arity.arity ; i++) {
329                 if (!saks[i].check(cf.constant_pool
330                         .get(bsm_spec.bootstrap_arguments[i]))) {
331                     fail(&quot;Bad static argument value &quot; + saks[i]);
332                     return;
333                 }
334             }
335 
336             CONSTANT_MethodHandle_info bsm_handle =
337                     (CONSTANT_MethodHandle_info)cf.constant_pool
338                     .get(bsm_spec.bootstrap_method_ref);
339 
340             if (bsm_handle.reference_kind != RefKind.REF_invokeStatic) {
341                 fail(&quot;Bad kind on boostrap method handle&quot;);
342                 return;
343             }
344 
345             CONSTANT_Methodref_info bsm_ref =
346                     (CONSTANT_Methodref_info)cf.constant_pool
347                     .get(bsm_handle.reference_index);
348 
349             if (!bsm_ref.getClassInfo().getName().equals(&quot;Bootstrap&quot;)) {
350                 fail(&quot;Bad owner of boostrap method&quot;);
351                 return;
352             }
353 
354             if (!bsm_ref.getNameAndTypeInfo().getName().equals(&quot;bsm&quot;)) {
355                 fail(&quot;Bad boostrap method name&quot;);
356                 return;
357             }
358 
359             if (!bsm_ref.getNameAndTypeInfo()
360                     .getType().equals(asBSMSignatureString())) {
361                 fail(&quot;Bad boostrap method type&quot; +
362                         bsm_ref.getNameAndTypeInfo().getType() + &quot; &quot; +
363                         asBSMSignatureString());
364                 return;
365             }
366 
367             LineNumberTable_attribute lnt =
368                     (LineNumberTable_attribute)ea.attributes.get(Attribute.LineNumberTable);
369 
370             if (lnt == null) {
371                 fail(&quot;No LineNumberTable attribute&quot;);
372                 return;
373             }
374             if (lnt.line_number_table_length != 3) {
375                 fail(&quot;Wrong number of entries in LineNumberTable&quot;);
376                 return;
377             }
378         } catch (Exception e) {
379             e.printStackTrace();
380             fail(&quot;error reading classfile: &quot; + res.compilationInfo());
381             return;
382         }
383     }
384 
385     String asBSMSignatureString() {
386         StringBuilder buf = new StringBuilder();
387         buf.append(&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;&quot;);
388         for (int i = 0 ; i &lt; arity.arity ; i++) {
389             buf.append(saks[i].bytecodeTypeStr);
390         }
391         buf.append(&quot;)Ljava/lang/invoke/CallSite;&quot;);
392         return buf.toString();
393     }
394 
395     class Indifier extends TreeScanner&lt;Void, Void&gt; implements TaskListener {
396 
<a name="18" id="anc18"></a><span class="line-modified">397         MethodSymbol bsm;</span>
398         Symtab syms;
399         Names names;
400         Types types;
401 
402         Indifier(Symtab syms, Names names, Types types) {
403             this.syms = syms;
404             this.names = names;
405             this.types = types;
406         }
407 
408         @Override
409         public void started(TaskEvent e) {
410             //do nothing
411         }
412 
413         @Override
414         public void finished(TaskEvent e) {
415             if (e.getKind() == TaskEvent.Kind.ANALYZE) {
416                 scan(e.getCompilationUnit(), null);
417             }
418         }
419 
420         @Override
421         public Void visitMethodInvocation(MethodInvocationTree node, Void p) {
422             super.visitMethodInvocation(node, p);
423             JCMethodInvocation apply = (JCMethodInvocation)node;
424             JCIdent ident = (JCIdent)apply.meth;
425             Symbol oldSym = ident.sym;
426             if (!oldSym.isConstructor()) {
<a name="19" id="anc19"></a><span class="line-modified">427                 Object[] staticArgs = new Object[arity.arity];</span>
428                 for (int i = 0; i &lt; arity.arity ; i++) {
<a name="20" id="anc20"></a><span class="line-modified">429                     staticArgs[i] = saks[i].getValue(syms, names, types);</span>
430                 }
431                 ident.sym = new Symbol.DynamicMethodSymbol(oldSym.name,
<a name="21" id="anc21"></a><span class="line-modified">432                         oldSym.owner, REF_invokeStatic, bsm, oldSym.type, staticArgs);</span>
433             }
434             return null;
435         }
436 
437         @Override
438         public Void visitMethod(MethodTree node, Void p) {
439             super.visitMethod(node, p);
440             if (node.getName().toString().equals(&quot;bsm&quot;)) {
<a name="22" id="anc22"></a><span class="line-modified">441                 bsm = ((JCMethodDecl)node).sym;</span>
442             }
443             return null;
444         }
445     }
446 }
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
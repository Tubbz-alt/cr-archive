<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/lambda/LambdaParserTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 7115050 8003280 8005852 8006694 8129962
 27  * @summary Add lambda tests
 28  *  Add parser support for lambda expressions
 29  *  temporarily workaround combo tests are causing time out in several platforms
 30  * @library /tools/javac/lib
 31  * @modules jdk.compiler/com.sun.tools.javac.api
 32  *          jdk.compiler/com.sun.tools.javac.file
 33  *          jdk.compiler/com.sun.tools.javac.util
 34  * @build combo.ComboTestHelper
 35 
 36  * @run main LambdaParserTest
 37  */
 38 
 39 import java.io.IOException;
 40 import java.util.Arrays;
 41 
 42 import combo.ComboInstance;
 43 import combo.ComboParameter;
 44 import combo.ComboTask.Result;
 45 import combo.ComboTestHelper;
 46 
 47 public class LambdaParserTest extends ComboInstance&lt;LambdaParserTest&gt; {
 48 
 49     enum LambdaKind implements ComboParameter {
 50         NILARY_EXPR(&quot;()-&gt;x&quot;),
 51         NILARY_STMT(&quot;()-&gt;{ return x; }&quot;),
 52         ONEARY_SHORT_EXPR(&quot;#{NAME}-&gt;x&quot;),
 53         ONEARY_SHORT_STMT(&quot;#{NAME}-&gt;{ return x; }&quot;),
 54         ONEARY_EXPR(&quot;(#{MOD[0]} #{TYPE[0]} #{NAME})-&gt;x&quot;),
 55         ONEARY_STMT(&quot;(#{MOD[0]} #{TYPE[0]} #{NAME})-&gt;{ return x; }&quot;),
 56         TWOARY_EXPR(&quot;(#{MOD[0]} #{TYPE[0]} #{NAME}, #{MOD[1]} #{TYPE[1]} y)-&gt;x&quot;),
 57         TWOARY_STMT(&quot;(#{MOD[0]} #{TYPE[0]} #{NAME}, #{MOD[1]} #{TYPE[1]} y)-&gt;{ return x; }&quot;);
 58 
 59         String lambdaTemplate;
 60 
 61         LambdaKind(String lambdaTemplate) {
 62             this.lambdaTemplate = lambdaTemplate;
 63         }
 64 
 65         @Override
 66         public String expand(String optParameter) {
 67             return lambdaTemplate;
 68         }
 69 
 70         int arity() {
 71             switch (this) {
 72                 case NILARY_EXPR:
 73                 case NILARY_STMT: return 0;
 74                 case ONEARY_SHORT_EXPR:
 75                 case ONEARY_SHORT_STMT:
 76                 case ONEARY_EXPR:
 77                 case ONEARY_STMT: return 1;
 78                 case TWOARY_EXPR:
 79                 case TWOARY_STMT: return 2;
 80                 default: throw new AssertionError(&quot;Invalid lambda kind &quot; + this);
 81             }
 82         }
 83 
 84         boolean isShort() {
 85             return this == ONEARY_SHORT_EXPR ||
 86                     this == ONEARY_SHORT_STMT;
 87         }
 88     }
 89 
 90     enum LambdaParameterName implements ComboParameter {
 91         IDENT(&quot;x&quot;),
 92         UNDERSCORE(&quot;_&quot;);
 93 
 94         String nameStr;
 95 
 96         LambdaParameterName(String nameStr) {
 97             this.nameStr = nameStr;
 98         }
 99 
100         @Override
101         public String expand(String optParameter) {
102             return nameStr;
103         }
104     }
105 
106     enum SourceKind {
107         SOURCE_10(&quot;10&quot;),
108         SOURCE_11(&quot;11&quot;);
109 
110         String sourceNumber;
111 
112         SourceKind(String sourceNumber) {
113             this.sourceNumber = sourceNumber;
114         }
115     }
116 
117     enum LambdaParameterKind implements ComboParameter {
118 
119         IMPLICIT_1(&quot;&quot;, ExplicitKind.IMPLICIT),
120         IMPLICIT_2(&quot;var&quot;, ExplicitKind.IMPLICIT_VAR),
121         EXPLICIT_SIMPLE(&quot;A&quot;, ExplicitKind.EXPLICIT),
122         EXPLICIT_SIMPLE_ARR1(&quot;A[]&quot;, ExplicitKind.EXPLICIT),
123         EXPLICIT_SIMPLE_ARR2(&quot;A[][]&quot;, ExplicitKind.EXPLICIT),
124         EXPLICIT_VARARGS(&quot;A...&quot;, ExplicitKind.EXPLICIT),
125         EXPLICIT_GENERIC1(&quot;A&lt;X&gt;&quot;, ExplicitKind.EXPLICIT),
126         EXPLICIT_GENERIC2(&quot;A&lt;? extends X, ? super Y&gt;&quot;, ExplicitKind.EXPLICIT),
127         EXPLICIT_GENERIC2_VARARGS(&quot;A&lt;? extends X, ? super Y&gt;...&quot;, ExplicitKind.EXPLICIT),
128         EXPLICIT_GENERIC2_ARR1(&quot;A&lt;? extends X, ? super Y&gt;[]&quot;, ExplicitKind.EXPLICIT),
129         EXPLICIT_GENERIC2_ARR2(&quot;A&lt;? extends X, ? super Y&gt;[][]&quot;, ExplicitKind.EXPLICIT);
130 
131         enum ExplicitKind {
132             IMPLICIT,
133             IMPLICIT_VAR,
134             EXPLICIT;
135         }
136 
137         String parameterType;
138         ExplicitKind explicitKind;
139 
140 
141         LambdaParameterKind(String parameterType, ExplicitKind ekind) {
142             this.parameterType = parameterType;
143             this.explicitKind = ekind;
144         }
145 
146         boolean isVarargs() {
147             return this == EXPLICIT_VARARGS ||
148                     this == EXPLICIT_GENERIC2_VARARGS;
149         }
150 
151         @Override
152         public String expand(String optParameter) {
153             return parameterType;
154         }
155 
156         ExplicitKind explicitKind(SourceKind sk) {
157             return explicitKind;
158         }
159     }
160 
161     enum ModifierKind implements ComboParameter {
162         NONE(&quot;&quot;),
163         FINAL(&quot;final&quot;),
164         PUBLIC(&quot;public&quot;),
165         ANNO(&quot;@A&quot;);
166 
167         String modifier;
168 
169         ModifierKind(String modifier) {
170             this.modifier = modifier;
171         }
172 
173         boolean compatibleWith(LambdaParameterKind pk) {
174             switch (this) {
175                 case PUBLIC: return false;
176                 case ANNO:
177                 case FINAL: return pk != LambdaParameterKind.IMPLICIT_1;
178                 case NONE: return true;
179                 default: throw new AssertionError(&quot;Invalid modifier kind &quot; + this);
180             }
181         }
182 
183         @Override
184         public String expand(String optParameter) {
185             return modifier;
186         }
187     }
188 
189     enum ExprKind implements ComboParameter {
190         NONE(&quot;#{LAMBDA}#{SUBEXPR}&quot;),
191         SINGLE_PAREN1(&quot;(#{LAMBDA}#{SUBEXPR})&quot;),
192         SINGLE_PAREN2(&quot;(#{LAMBDA})#{SUBEXPR}&quot;),
193         DOUBLE_PAREN1(&quot;((#{LAMBDA}#{SUBEXPR}))&quot;),
194         DOUBLE_PAREN2(&quot;((#{LAMBDA})#{SUBEXPR})&quot;),
195         DOUBLE_PAREN3(&quot;((#{LAMBDA}))#{SUBEXPR}&quot;);
196 
197         String expressionTemplate;
198 
199         ExprKind(String expressionTemplate) {
200             this.expressionTemplate = expressionTemplate;
201         }
202 
203         @Override
204         public String expand(String optParameter) {
205             return expressionTemplate;
206         }
207     }
208 
209     enum SubExprKind implements ComboParameter {
210         NONE(&quot;&quot;),
211         SELECT_FIELD(&quot;.f&quot;),
212         SELECT_METHOD(&quot;.f()&quot;),
213         SELECT_NEW(&quot;.new Foo()&quot;),
214         POSTINC(&quot;++&quot;),
215         POSTDEC(&quot;--&quot;);
216 
217         String subExpression;
218 
219         SubExprKind(String subExpression) {
220             this.subExpression = subExpression;
221         }
222 
223         @Override
224         public String expand(String optParameter) {
225             return subExpression;
226         }
227     }
228 
229     public static void main(String... args) throws Exception {
230         new ComboTestHelper&lt;LambdaParserTest&gt;()
231                 .withFilter(LambdaParserTest::redundantTestFilter)
232                 .withFilter(LambdaParserTest::badImplicitFilter)
233                 .withDimension(&quot;SOURCE&quot;, (x, sk) -&gt; x.sk = sk, SourceKind.values())
234                 .withDimension(&quot;LAMBDA&quot;, (x, lk) -&gt; x.lk = lk, LambdaKind.values())
235                 .withDimension(&quot;NAME&quot;, (x, name) -&gt; x.pn = name, LambdaParameterName.values())
236                 .withArrayDimension(&quot;TYPE&quot;, (x, type, idx) -&gt; x.pks[idx] = type, 2, LambdaParameterKind.values())
237                 .withArrayDimension(&quot;MOD&quot;, (x, mod, idx) -&gt; x.mks[idx] = mod, 2, ModifierKind.values())
238                 .withDimension(&quot;EXPR&quot;, ExprKind.values())
239                 .withDimension(&quot;SUBEXPR&quot;, SubExprKind.values())
240                 .run(LambdaParserTest::new);
241     }
242 
243     LambdaParameterKind[] pks = new LambdaParameterKind[2];
244     ModifierKind[] mks = new ModifierKind[2];
245     LambdaKind lk;
246     LambdaParameterName pn;
247     SourceKind sk;
248 
249     boolean badImplicitFilter() {
250         return !(mks[0] != ModifierKind.NONE &amp;&amp; lk.isShort());
251     }
252 
253     boolean redundantTestFilter() {
254         for (int i = lk.arity(); i &lt; mks.length ; i++) {
255             if (mks[i].ordinal() != 0) {
256                 return false;
257             }
258         }
259         for (int i = lk.arity(); i &lt; pks.length ; i++) {
260             if (pks[i].ordinal() != 0) {
261                 return false;
262             }
263         }
264         return true;
265     }
266 
267     String template = &quot;@interface A { }\n&quot; +
268             &quot;class Test {\n&quot; +
269             &quot;   SAM s = #{EXPR};\n&quot; +
270             &quot;}&quot;;
271 
272     @Override
273     public void doWork() throws IOException {
274         newCompilationTask()
275                 .withOptions(Arrays.asList(&quot;-source&quot;, sk.sourceNumber))
276                 .withSourceFromTemplate(template)
277                 .parse(this::check);
278     }
279 
280     void check(Result&lt;?&gt; res) {
281         boolean errorExpected = (lk.arity() &gt; 0 &amp;&amp; !mks[0].compatibleWith(pks[0])) ||
282                 (lk.arity() &gt; 1 &amp;&amp; !mks[1].compatibleWith(pks[1]));
283 
284         if (lk.arity() == 2 &amp;&amp;
285                 (pks[0].explicitKind(sk) != pks[1].explicitKind(sk) ||
286                 pks[0].isVarargs())) {
287             errorExpected = true;
288         }
289 
290         errorExpected |= pn == LambdaParameterName.UNDERSCORE &amp;&amp;
291                 lk.arity() &gt; 0;
292 
293         for (int i = 0; i &lt; lk.arity(); i++) {
294             if (!lk.isShort() &amp;&amp;
295                     pks[i].explicitKind(sk) == LambdaParameterKind.ExplicitKind.IMPLICIT_VAR &amp;&amp;
296                     sk == SourceKind.SOURCE_10) {
297                 errorExpected = true;
298                 break;
299             }
300         }
301 
302         if (errorExpected != res.hasErrors()) {
303             fail(&quot;invalid diagnostics for source:\n&quot; +
304                 res.compilationInfo() +
305                 &quot;\nFound error: &quot; + res.hasErrors() +
306                 &quot;\nExpected error: &quot; + errorExpected);
307         }
308     }
309 }
    </pre>
  </body>
</html>
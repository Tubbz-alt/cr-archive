<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/lambda/deduplication/DeduplicationTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, Google LLC. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test 8200301 8201194
 26  * @summary deduplicate lambda methods with the same body, target type, and captured state
 27  * @modules jdk.jdeps/com.sun.tools.classfile jdk.compiler/com.sun.tools.javac.api
 28  *     jdk.compiler/com.sun.tools.javac.code jdk.compiler/com.sun.tools.javac.comp
 29  *     jdk.compiler/com.sun.tools.javac.file jdk.compiler/com.sun.tools.javac.main
 30  *     jdk.compiler/com.sun.tools.javac.tree jdk.compiler/com.sun.tools.javac.util
 31  * @run main DeduplicationTest
 32  */
 33 import static java.nio.charset.StandardCharsets.UTF_8;
 34 import static java.util.stream.Collectors.joining;
 35 import static java.util.stream.Collectors.toList;
 36 import static java.util.stream.Collectors.toMap;
 37 import static java.util.stream.Collectors.toSet;
 38 
 39 import com.sun.source.util.JavacTask;
 40 import com.sun.source.util.TaskEvent;
 41 import com.sun.source.util.TaskEvent.Kind;
 42 import com.sun.source.util.TaskListener;
 43 import com.sun.tools.classfile.Attribute;
 44 import com.sun.tools.classfile.BootstrapMethods_attribute;
 45 import com.sun.tools.classfile.BootstrapMethods_attribute.BootstrapMethodSpecifier;
 46 import com.sun.tools.classfile.ClassFile;
 47 import com.sun.tools.classfile.ConstantPool.CONSTANT_MethodHandle_info;
 48 import com.sun.tools.javac.api.ClientCodeWrapper.Trusted;
 49 import com.sun.tools.javac.api.JavacTool;
 50 import com.sun.tools.javac.code.Symbol;
 51 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 52 import com.sun.tools.javac.comp.TreeDiffer;
 53 import com.sun.tools.javac.comp.TreeHasher;
 54 import com.sun.tools.javac.file.JavacFileManager;
 55 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 56 import com.sun.tools.javac.tree.JCTree.JCExpression;
 57 import com.sun.tools.javac.tree.JCTree.JCIdent;
 58 import com.sun.tools.javac.tree.JCTree.JCLambda;
 59 import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
 60 import com.sun.tools.javac.tree.JCTree.JCTypeCast;
 61 import com.sun.tools.javac.tree.JCTree.Tag;
 62 import com.sun.tools.javac.tree.TreeScanner;
 63 import com.sun.tools.javac.util.Context;
 64 import com.sun.tools.javac.util.JCDiagnostic;
 65 import java.nio.file.Path;
 66 import java.nio.file.Paths;
 67 import java.util.ArrayList;
 68 import java.util.Arrays;
 69 import java.util.LinkedHashMap;
 70 import java.util.List;
 71 import java.util.Locale;
 72 import java.util.Map;
 73 import java.util.Set;
 74 import java.util.TreeSet;
 75 import javax.tools.Diagnostic;
 76 import javax.tools.DiagnosticListener;
 77 import javax.tools.JavaFileObject;
 78 
 79 public class DeduplicationTest {
 80 
 81     public static void main(String[] args) throws Exception {
 82         JavacFileManager fileManager = new JavacFileManager(new Context(), false, UTF_8);
 83         JavacTool javacTool = JavacTool.create();
 84         Listener diagnosticListener = new Listener();
 85         Path testSrc = Paths.get(System.getProperty(&quot;test.src&quot;));
 86         Path file = testSrc.resolve(&quot;Deduplication.java&quot;);
<a name="1" id="anc1"></a>
 87         JavacTask task =
 88                 javacTool.getTask(
 89                         null,
 90                         null,
 91                         diagnosticListener,
 92                         Arrays.asList(
 93                                 &quot;-d&quot;,
 94                                 &quot;.&quot;,
 95                                 &quot;-XDdebug.dumpLambdaToMethodDeduplication&quot;,
<a name="2" id="anc2"></a><span class="line-modified"> 96                                 &quot;-XDdebug.dumpLambdaToMethodStats&quot;),</span>

 97                         null,
 98                         fileManager.getJavaFileObjects(file));
 99         Map&lt;JCLambda, JCLambda&gt; dedupedLambdas = new LinkedHashMap&lt;&gt;();
100         task.addTaskListener(new TreeDiffHashTaskListener(dedupedLambdas));
101         Iterable&lt;? extends JavaFileObject&gt; generated = task.generate();
102         if (!diagnosticListener.unexpected.isEmpty()) {
103             throw new AssertionError(
104                     diagnosticListener
105                             .unexpected
106                             .stream()
107                             .map(
108                                     d -&gt;
109                                             String.format(
110                                                     &quot;%s: %s&quot;,
111                                                     d.getCode(), d.getMessage(Locale.getDefault())))
112                             .collect(joining(&quot;, &quot;, &quot;unexpected diagnostics: &quot;, &quot;&quot;)));
113         }
114 
115         // Assert that each group of lambdas was deduplicated.
116         Map&lt;JCLambda, JCLambda&gt; actual = diagnosticListener.deduplicationTargets();
117         dedupedLambdas.forEach(
118                 (k, v) -&gt; {
119                     if (!actual.containsKey(k)) {
120                         throw new AssertionError(&quot;expected &quot; + k + &quot; to be deduplicated&quot;);
121                     }
122                     if (!v.equals(actual.get(k))) {
123                         throw new AssertionError(
124                                 String.format(
125                                         &quot;expected %s to be deduplicated to:\n  %s\nwas:  %s&quot;,
126                                         k, v, actual.get(v)));
127                     }
128                 });
129 
130         // Assert that the output contains only the canonical lambdas, and not the deduplicated
131         // lambdas.
132         Set&lt;String&gt; bootstrapMethodNames = new TreeSet&lt;&gt;();
133         for (JavaFileObject output : generated) {
134             ClassFile cf = ClassFile.read(output.openInputStream());
135             BootstrapMethods_attribute bsm =
136                     (BootstrapMethods_attribute) cf.getAttribute(Attribute.BootstrapMethods);
137             for (BootstrapMethodSpecifier b : bsm.bootstrap_method_specifiers) {
138                 bootstrapMethodNames.add(
139                         ((CONSTANT_MethodHandle_info)
140                                         cf.constant_pool.get(b.bootstrap_arguments[1]))
141                                 .getCPRefInfo()
142                                 .getNameAndTypeInfo()
143                                 .getName());
144             }
145         }
146         Set&lt;String&gt; deduplicatedNames =
147                 diagnosticListener
148                         .expectedLambdaMethods()
149                         .stream()
150                         .map(s -&gt; s.getSimpleName().toString())
151                         .sorted()
152                         .collect(toSet());
153         if (!deduplicatedNames.equals(bootstrapMethodNames)) {
154             throw new AssertionError(
155                     String.format(
156                             &quot;expected deduplicated methods: %s, but saw: %s&quot;,
157                             deduplicatedNames, bootstrapMethodNames));
158         }
159     }
160 
161     /** Returns the parameter symbols of the given lambda. */
162     private static List&lt;Symbol&gt; paramSymbols(JCLambda lambda) {
163         return lambda.params.stream().map(x -&gt; x.sym).collect(toList());
164     }
165 
166     /** A diagnostic listener that records debug messages related to lambda desugaring. */
167     @Trusted
168     static class Listener implements DiagnosticListener&lt;JavaFileObject&gt; {
169 
170         /** A map from method symbols to lambda trees for desugared lambdas. */
171         final Map&lt;MethodSymbol, JCLambda&gt; lambdaMethodSymbolsToTrees = new LinkedHashMap&lt;&gt;();
172 
173         /**
174          * A map from lambda trees that were deduplicated to the method symbol of the canonical
175          * lambda implementation method they were deduplicated to.
176          */
177         final Map&lt;JCLambda, MethodSymbol&gt; deduped = new LinkedHashMap&lt;&gt;();
178 
179         final List&lt;Diagnostic&lt;? extends JavaFileObject&gt;&gt; unexpected = new ArrayList&lt;&gt;();
180 
181         @Override
182         public void report(Diagnostic&lt;? extends JavaFileObject&gt; diagnostic) {
183             JCDiagnostic d = (JCDiagnostic) diagnostic;
184             switch (d.getCode()) {
185                 case &quot;compiler.note.lambda.stat&quot;:
186                     lambdaMethodSymbolsToTrees.put(
187                             (MethodSymbol) d.getArgs()[1],
188                             (JCLambda) d.getDiagnosticPosition().getTree());
189                     break;
190                 case &quot;compiler.note.verbose.l2m.deduplicate&quot;:
191                     deduped.put(
192                             (JCLambda) d.getDiagnosticPosition().getTree(),
193                             (MethodSymbol) d.getArgs()[0]);
194                     break;
<a name="3" id="anc3"></a>


195                 default:
196                     unexpected.add(diagnostic);
197             }
198         }
199 
200         /** Returns expected lambda implementation method symbols. */
201         Set&lt;MethodSymbol&gt; expectedLambdaMethods() {
202             return lambdaMethodSymbolsToTrees
203                     .entrySet()
204                     .stream()
205                     .filter(e -&gt; !deduped.containsKey(e.getValue()))
206                     .map(Map.Entry::getKey)
207                     .collect(toSet());
208         }
209 
210         /**
211          * Returns a mapping from deduplicated lambda trees to the tree of the canonical lambda they
212          * were deduplicated to.
213          */
214         Map&lt;JCLambda, JCLambda&gt; deduplicationTargets() {
215             return deduped.entrySet()
216                     .stream()
217                     .collect(
218                             toMap(
219                                     Map.Entry::getKey,
220                                     e -&gt; lambdaMethodSymbolsToTrees.get(e.getValue()),
221                                     (a, b) -&gt; {
222                                         throw new AssertionError();
223                                     },
224                                     LinkedHashMap::new));
225         }
226     }
227 
228     /**
229      * A task listener that tests {@link TreeDiffer} and {@link TreeHasher} on all lambda trees in a
230      * compilation, post-analysis.
231      */
232     private static class TreeDiffHashTaskListener implements TaskListener {
233 
234         /**
235          * A map from deduplicated lambdas to the canonical lambda they are expected to be
236          * deduplicated to.
237          */
238         private final Map&lt;JCLambda, JCLambda&gt; dedupedLambdas;
239 
240         public TreeDiffHashTaskListener(Map&lt;JCLambda, JCLambda&gt; dedupedLambdas) {
241             this.dedupedLambdas = dedupedLambdas;
242         }
243 
244         @Override
245         public void finished(TaskEvent e) {
246             if (e.getKind() != Kind.ANALYZE) {
247                 return;
248             }
249             // Scan the compilation for calls to a varargs method named &#39;group&#39;, whose arguments
250             // are a group of lambdas that are equivalent to each other, but distinct from all
251             // lambdas in the compilation unit outside of that group.
252             List&lt;List&lt;JCLambda&gt;&gt; lambdaGroups = new ArrayList&lt;&gt;();
253             new TreeScanner() {
254                 @Override
255                 public void visitApply(JCMethodInvocation tree) {
256                     if (tree.getMethodSelect().getTag() == Tag.IDENT
257                             &amp;&amp; ((JCIdent) tree.getMethodSelect())
258                                     .getName()
259                                     .contentEquals(&quot;group&quot;)) {
260                         List&lt;JCLambda&gt; xs = new ArrayList&lt;&gt;();
261                         for (JCExpression arg : tree.getArguments()) {
262                             if (arg instanceof JCTypeCast) {
263                                 arg = ((JCTypeCast) arg).getExpression();
264                             }
265                             xs.add((JCLambda) arg);
266                         }
267                         lambdaGroups.add(xs);
268                     }
269                     super.visitApply(tree);
270                 }
271             }.scan((JCCompilationUnit) e.getCompilationUnit());
272             for (int i = 0; i &lt; lambdaGroups.size(); i++) {
273                 List&lt;JCLambda&gt; curr = lambdaGroups.get(i);
274                 JCLambda first = null;
275                 // Assert that all pairwise combinations of lambdas in the group are equal, and
276                 // hash to the same value.
277                 for (JCLambda lhs : curr) {
278                     if (first == null) {
279                         first = lhs;
280                     } else {
281                         dedupedLambdas.put(lhs, first);
282                     }
283                     for (JCLambda rhs : curr) {
284                         if (!new TreeDiffer(paramSymbols(lhs), paramSymbols(rhs))
285                                 .scan(lhs.body, rhs.body)) {
286                             throw new AssertionError(
287                                     String.format(
288                                             &quot;expected lambdas to be equal\n%s\n%s&quot;, lhs, rhs));
289                         }
290                         if (TreeHasher.hash(lhs, paramSymbols(lhs))
291                                 != TreeHasher.hash(rhs, paramSymbols(rhs))) {
292                             throw new AssertionError(
293                                     String.format(
294                                             &quot;expected lambdas to hash to the same value\n%s\n%s&quot;,
295                                             lhs, rhs));
296                         }
297                     }
298                 }
299                 // Assert that no lambdas in a group are equal to any lambdas outside that group,
300                 // or hash to the same value as lambda outside the group.
301                 // (Note that the hash collisions won&#39;t result in correctness problems but could
302                 // regress performs, and do not currently occurr for any of the test inputs.)
303                 for (int j = 0; j &lt; lambdaGroups.size(); j++) {
304                     if (i == j) {
305                         continue;
306                     }
307                     for (JCLambda lhs : curr) {
308                         for (JCLambda rhs : lambdaGroups.get(j)) {
309                             if (new TreeDiffer(paramSymbols(lhs), paramSymbols(rhs))
310                                     .scan(lhs.body, rhs.body)) {
311                                 throw new AssertionError(
312                                         String.format(
313                                                 &quot;expected lambdas to not be equal\n%s\n%s&quot;,
314                                                 lhs, rhs));
315                             }
316                             if (TreeHasher.hash(lhs, paramSymbols(lhs))
317                                     == TreeHasher.hash(rhs, paramSymbols(rhs))) {
318                                 throw new AssertionError(
319                                         String.format(
320                                                 &quot;expected lambdas to hash to different values\n%s\n%s&quot;,
321                                                 lhs, rhs));
322                             }
323                         }
324                     }
325                 }
326             }
327             lambdaGroups.clear();
328         }
329     }
330 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
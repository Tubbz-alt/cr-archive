<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/langtools/tools/javac/lambda/deduplication/DeduplicationTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Deduplication.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../lambdaExpression/LambdaTest6.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/langtools/tools/javac/lambda/deduplication/DeduplicationTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 67 import java.util.ArrayList;
 68 import java.util.Arrays;
 69 import java.util.LinkedHashMap;
 70 import java.util.List;
 71 import java.util.Locale;
 72 import java.util.Map;
 73 import java.util.Set;
 74 import java.util.TreeSet;
 75 import javax.tools.Diagnostic;
 76 import javax.tools.DiagnosticListener;
 77 import javax.tools.JavaFileObject;
 78 
 79 public class DeduplicationTest {
 80 
 81     public static void main(String[] args) throws Exception {
 82         JavacFileManager fileManager = new JavacFileManager(new Context(), false, UTF_8);
 83         JavacTool javacTool = JavacTool.create();
 84         Listener diagnosticListener = new Listener();
 85         Path testSrc = Paths.get(System.getProperty(&quot;test.src&quot;));
 86         Path file = testSrc.resolve(&quot;Deduplication.java&quot;);

 87         JavacTask task =
 88                 javacTool.getTask(
 89                         null,
 90                         null,
 91                         diagnosticListener,
 92                         Arrays.asList(
 93                                 &quot;-d&quot;,
 94                                 &quot;.&quot;,
 95                                 &quot;-XDdebug.dumpLambdaToMethodDeduplication&quot;,
<span class="line-modified"> 96                                 &quot;-XDdebug.dumpLambdaToMethodStats&quot;),</span>

 97                         null,
 98                         fileManager.getJavaFileObjects(file));
 99         Map&lt;JCLambda, JCLambda&gt; dedupedLambdas = new LinkedHashMap&lt;&gt;();
100         task.addTaskListener(new TreeDiffHashTaskListener(dedupedLambdas));
101         Iterable&lt;? extends JavaFileObject&gt; generated = task.generate();
102         if (!diagnosticListener.unexpected.isEmpty()) {
103             throw new AssertionError(
104                     diagnosticListener
105                             .unexpected
106                             .stream()
107                             .map(
108                                     d -&gt;
109                                             String.format(
110                                                     &quot;%s: %s&quot;,
111                                                     d.getCode(), d.getMessage(Locale.getDefault())))
112                             .collect(joining(&quot;, &quot;, &quot;unexpected diagnostics: &quot;, &quot;&quot;)));
113         }
114 
115         // Assert that each group of lambdas was deduplicated.
116         Map&lt;JCLambda, JCLambda&gt; actual = diagnosticListener.deduplicationTargets();
</pre>
<hr />
<pre>
175          * lambda implementation method they were deduplicated to.
176          */
177         final Map&lt;JCLambda, MethodSymbol&gt; deduped = new LinkedHashMap&lt;&gt;();
178 
179         final List&lt;Diagnostic&lt;? extends JavaFileObject&gt;&gt; unexpected = new ArrayList&lt;&gt;();
180 
181         @Override
182         public void report(Diagnostic&lt;? extends JavaFileObject&gt; diagnostic) {
183             JCDiagnostic d = (JCDiagnostic) diagnostic;
184             switch (d.getCode()) {
185                 case &quot;compiler.note.lambda.stat&quot;:
186                     lambdaMethodSymbolsToTrees.put(
187                             (MethodSymbol) d.getArgs()[1],
188                             (JCLambda) d.getDiagnosticPosition().getTree());
189                     break;
190                 case &quot;compiler.note.verbose.l2m.deduplicate&quot;:
191                     deduped.put(
192                             (JCLambda) d.getDiagnosticPosition().getTree(),
193                             (MethodSymbol) d.getArgs()[0]);
194                     break;



195                 default:
196                     unexpected.add(diagnostic);
197             }
198         }
199 
200         /** Returns expected lambda implementation method symbols. */
201         Set&lt;MethodSymbol&gt; expectedLambdaMethods() {
202             return lambdaMethodSymbolsToTrees
203                     .entrySet()
204                     .stream()
205                     .filter(e -&gt; !deduped.containsKey(e.getValue()))
206                     .map(Map.Entry::getKey)
207                     .collect(toSet());
208         }
209 
210         /**
211          * Returns a mapping from deduplicated lambda trees to the tree of the canonical lambda they
212          * were deduplicated to.
213          */
214         Map&lt;JCLambda, JCLambda&gt; deduplicationTargets() {
</pre>
</td>
<td>
<hr />
<pre>
 67 import java.util.ArrayList;
 68 import java.util.Arrays;
 69 import java.util.LinkedHashMap;
 70 import java.util.List;
 71 import java.util.Locale;
 72 import java.util.Map;
 73 import java.util.Set;
 74 import java.util.TreeSet;
 75 import javax.tools.Diagnostic;
 76 import javax.tools.DiagnosticListener;
 77 import javax.tools.JavaFileObject;
 78 
 79 public class DeduplicationTest {
 80 
 81     public static void main(String[] args) throws Exception {
 82         JavacFileManager fileManager = new JavacFileManager(new Context(), false, UTF_8);
 83         JavacTool javacTool = JavacTool.create();
 84         Listener diagnosticListener = new Listener();
 85         Path testSrc = Paths.get(System.getProperty(&quot;test.src&quot;));
 86         Path file = testSrc.resolve(&quot;Deduplication.java&quot;);
<span class="line-added"> 87         String sourceVersion = Integer.toString(Runtime.version().feature());</span>
 88         JavacTask task =
 89                 javacTool.getTask(
 90                         null,
 91                         null,
 92                         diagnosticListener,
 93                         Arrays.asList(
 94                                 &quot;-d&quot;,
 95                                 &quot;.&quot;,
 96                                 &quot;-XDdebug.dumpLambdaToMethodDeduplication&quot;,
<span class="line-modified"> 97                                 &quot;-XDdebug.dumpLambdaToMethodStats&quot;,</span>
<span class="line-added"> 98                                 &quot;--enable-preview&quot;, &quot;-source&quot;, sourceVersion),</span>
 99                         null,
100                         fileManager.getJavaFileObjects(file));
101         Map&lt;JCLambda, JCLambda&gt; dedupedLambdas = new LinkedHashMap&lt;&gt;();
102         task.addTaskListener(new TreeDiffHashTaskListener(dedupedLambdas));
103         Iterable&lt;? extends JavaFileObject&gt; generated = task.generate();
104         if (!diagnosticListener.unexpected.isEmpty()) {
105             throw new AssertionError(
106                     diagnosticListener
107                             .unexpected
108                             .stream()
109                             .map(
110                                     d -&gt;
111                                             String.format(
112                                                     &quot;%s: %s&quot;,
113                                                     d.getCode(), d.getMessage(Locale.getDefault())))
114                             .collect(joining(&quot;, &quot;, &quot;unexpected diagnostics: &quot;, &quot;&quot;)));
115         }
116 
117         // Assert that each group of lambdas was deduplicated.
118         Map&lt;JCLambda, JCLambda&gt; actual = diagnosticListener.deduplicationTargets();
</pre>
<hr />
<pre>
177          * lambda implementation method they were deduplicated to.
178          */
179         final Map&lt;JCLambda, MethodSymbol&gt; deduped = new LinkedHashMap&lt;&gt;();
180 
181         final List&lt;Diagnostic&lt;? extends JavaFileObject&gt;&gt; unexpected = new ArrayList&lt;&gt;();
182 
183         @Override
184         public void report(Diagnostic&lt;? extends JavaFileObject&gt; diagnostic) {
185             JCDiagnostic d = (JCDiagnostic) diagnostic;
186             switch (d.getCode()) {
187                 case &quot;compiler.note.lambda.stat&quot;:
188                     lambdaMethodSymbolsToTrees.put(
189                             (MethodSymbol) d.getArgs()[1],
190                             (JCLambda) d.getDiagnosticPosition().getTree());
191                     break;
192                 case &quot;compiler.note.verbose.l2m.deduplicate&quot;:
193                     deduped.put(
194                             (JCLambda) d.getDiagnosticPosition().getTree(),
195                             (MethodSymbol) d.getArgs()[0]);
196                     break;
<span class="line-added">197                 case &quot;compiler.note.preview.filename&quot;:</span>
<span class="line-added">198                 case &quot;compiler.note.preview.recompile&quot;:</span>
<span class="line-added">199                     break; //ignore</span>
200                 default:
201                     unexpected.add(diagnostic);
202             }
203         }
204 
205         /** Returns expected lambda implementation method symbols. */
206         Set&lt;MethodSymbol&gt; expectedLambdaMethods() {
207             return lambdaMethodSymbolsToTrees
208                     .entrySet()
209                     .stream()
210                     .filter(e -&gt; !deduped.containsKey(e.getValue()))
211                     .map(Map.Entry::getKey)
212                     .collect(toSet());
213         }
214 
215         /**
216          * Returns a mapping from deduplicated lambda trees to the tree of the canonical lambda they
217          * were deduplicated to.
218          */
219         Map&lt;JCLambda, JCLambda&gt; deduplicationTargets() {
</pre>
</td>
</tr>
</table>
<center><a href="Deduplication.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../lambdaExpression/LambdaTest6.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
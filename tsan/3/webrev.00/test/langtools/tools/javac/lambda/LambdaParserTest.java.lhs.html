<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/lambda/LambdaParserTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 7115050 8003280 8005852 8006694 8129962
 27  * @summary Add lambda tests
 28  *  Add parser support for lambda expressions
 29  *  temporarily workaround combo tests are causing time out in several platforms
 30  * @library /tools/javac/lib
 31  * @modules jdk.compiler/com.sun.tools.javac.api
<a name="1" id="anc1"></a><span class="line-modified"> 32  *          jdk.compiler/com.sun.tools.javac.code</span>
<span class="line-removed"> 33  *          jdk.compiler/com.sun.tools.javac.comp</span>
<span class="line-removed"> 34  *          jdk.compiler/com.sun.tools.javac.main</span>
<span class="line-removed"> 35  *          jdk.compiler/com.sun.tools.javac.tree</span>
 36  *          jdk.compiler/com.sun.tools.javac.util
 37  * @build combo.ComboTestHelper
 38 
 39  * @run main LambdaParserTest
 40  */
 41 
 42 import java.io.IOException;
 43 import java.util.Arrays;
 44 
 45 import combo.ComboInstance;
 46 import combo.ComboParameter;
 47 import combo.ComboTask.Result;
 48 import combo.ComboTestHelper;
 49 
 50 public class LambdaParserTest extends ComboInstance&lt;LambdaParserTest&gt; {
 51 
 52     enum LambdaKind implements ComboParameter {
 53         NILARY_EXPR(&quot;()-&gt;x&quot;),
 54         NILARY_STMT(&quot;()-&gt;{ return x; }&quot;),
 55         ONEARY_SHORT_EXPR(&quot;#{NAME}-&gt;x&quot;),
 56         ONEARY_SHORT_STMT(&quot;#{NAME}-&gt;{ return x; }&quot;),
 57         ONEARY_EXPR(&quot;(#{MOD[0]} #{TYPE[0]} #{NAME})-&gt;x&quot;),
 58         ONEARY_STMT(&quot;(#{MOD[0]} #{TYPE[0]} #{NAME})-&gt;{ return x; }&quot;),
 59         TWOARY_EXPR(&quot;(#{MOD[0]} #{TYPE[0]} #{NAME}, #{MOD[1]} #{TYPE[1]} y)-&gt;x&quot;),
 60         TWOARY_STMT(&quot;(#{MOD[0]} #{TYPE[0]} #{NAME}, #{MOD[1]} #{TYPE[1]} y)-&gt;{ return x; }&quot;);
 61 
 62         String lambdaTemplate;
 63 
 64         LambdaKind(String lambdaTemplate) {
 65             this.lambdaTemplate = lambdaTemplate;
 66         }
 67 
 68         @Override
 69         public String expand(String optParameter) {
 70             return lambdaTemplate;
 71         }
 72 
 73         int arity() {
 74             switch (this) {
 75                 case NILARY_EXPR:
 76                 case NILARY_STMT: return 0;
 77                 case ONEARY_SHORT_EXPR:
 78                 case ONEARY_SHORT_STMT:
 79                 case ONEARY_EXPR:
 80                 case ONEARY_STMT: return 1;
 81                 case TWOARY_EXPR:
 82                 case TWOARY_STMT: return 2;
 83                 default: throw new AssertionError(&quot;Invalid lambda kind &quot; + this);
 84             }
 85         }
 86 
 87         boolean isShort() {
 88             return this == ONEARY_SHORT_EXPR ||
 89                     this == ONEARY_SHORT_STMT;
 90         }
 91     }
 92 
 93     enum LambdaParameterName implements ComboParameter {
 94         IDENT(&quot;x&quot;),
 95         UNDERSCORE(&quot;_&quot;);
 96 
 97         String nameStr;
 98 
 99         LambdaParameterName(String nameStr) {
100             this.nameStr = nameStr;
101         }
102 
103         @Override
104         public String expand(String optParameter) {
105             return nameStr;
106         }
107     }
108 
109     enum SourceKind {
110         SOURCE_10(&quot;10&quot;),
111         SOURCE_11(&quot;11&quot;);
112 
113         String sourceNumber;
114 
115         SourceKind(String sourceNumber) {
116             this.sourceNumber = sourceNumber;
117         }
118     }
119 
120     enum LambdaParameterKind implements ComboParameter {
121 
122         IMPLICIT_1(&quot;&quot;, ExplicitKind.IMPLICIT),
123         IMPLICIT_2(&quot;var&quot;, ExplicitKind.IMPLICIT_VAR),
124         EXPLICIT_SIMPLE(&quot;A&quot;, ExplicitKind.EXPLICIT),
125         EXPLICIT_SIMPLE_ARR1(&quot;A[]&quot;, ExplicitKind.EXPLICIT),
126         EXPLICIT_SIMPLE_ARR2(&quot;A[][]&quot;, ExplicitKind.EXPLICIT),
127         EXPLICIT_VARARGS(&quot;A...&quot;, ExplicitKind.EXPLICIT),
128         EXPLICIT_GENERIC1(&quot;A&lt;X&gt;&quot;, ExplicitKind.EXPLICIT),
129         EXPLICIT_GENERIC2(&quot;A&lt;? extends X, ? super Y&gt;&quot;, ExplicitKind.EXPLICIT),
130         EXPLICIT_GENERIC2_VARARGS(&quot;A&lt;? extends X, ? super Y&gt;...&quot;, ExplicitKind.EXPLICIT),
131         EXPLICIT_GENERIC2_ARR1(&quot;A&lt;? extends X, ? super Y&gt;[]&quot;, ExplicitKind.EXPLICIT),
132         EXPLICIT_GENERIC2_ARR2(&quot;A&lt;? extends X, ? super Y&gt;[][]&quot;, ExplicitKind.EXPLICIT);
133 
134         enum ExplicitKind {
135             IMPLICIT,
136             IMPLICIT_VAR,
137             EXPLICIT;
138         }
139 
140         String parameterType;
141         ExplicitKind explicitKind;
142 
143 
144         LambdaParameterKind(String parameterType, ExplicitKind ekind) {
145             this.parameterType = parameterType;
146             this.explicitKind = ekind;
147         }
148 
149         boolean isVarargs() {
150             return this == EXPLICIT_VARARGS ||
151                     this == EXPLICIT_GENERIC2_VARARGS;
152         }
153 
154         @Override
155         public String expand(String optParameter) {
156             return parameterType;
157         }
158 
159         ExplicitKind explicitKind(SourceKind sk) {
160             return explicitKind;
161         }
162     }
163 
164     enum ModifierKind implements ComboParameter {
165         NONE(&quot;&quot;),
166         FINAL(&quot;final&quot;),
167         PUBLIC(&quot;public&quot;),
168         ANNO(&quot;@A&quot;);
169 
170         String modifier;
171 
172         ModifierKind(String modifier) {
173             this.modifier = modifier;
174         }
175 
176         boolean compatibleWith(LambdaParameterKind pk) {
177             switch (this) {
178                 case PUBLIC: return false;
179                 case ANNO:
180                 case FINAL: return pk != LambdaParameterKind.IMPLICIT_1;
181                 case NONE: return true;
182                 default: throw new AssertionError(&quot;Invalid modifier kind &quot; + this);
183             }
184         }
185 
186         @Override
187         public String expand(String optParameter) {
188             return modifier;
189         }
190     }
191 
192     enum ExprKind implements ComboParameter {
193         NONE(&quot;#{LAMBDA}#{SUBEXPR}&quot;),
194         SINGLE_PAREN1(&quot;(#{LAMBDA}#{SUBEXPR})&quot;),
195         SINGLE_PAREN2(&quot;(#{LAMBDA})#{SUBEXPR}&quot;),
196         DOUBLE_PAREN1(&quot;((#{LAMBDA}#{SUBEXPR}))&quot;),
197         DOUBLE_PAREN2(&quot;((#{LAMBDA})#{SUBEXPR})&quot;),
198         DOUBLE_PAREN3(&quot;((#{LAMBDA}))#{SUBEXPR}&quot;);
199 
200         String expressionTemplate;
201 
202         ExprKind(String expressionTemplate) {
203             this.expressionTemplate = expressionTemplate;
204         }
205 
206         @Override
207         public String expand(String optParameter) {
208             return expressionTemplate;
209         }
210     }
211 
212     enum SubExprKind implements ComboParameter {
213         NONE(&quot;&quot;),
214         SELECT_FIELD(&quot;.f&quot;),
215         SELECT_METHOD(&quot;.f()&quot;),
216         SELECT_NEW(&quot;.new Foo()&quot;),
217         POSTINC(&quot;++&quot;),
218         POSTDEC(&quot;--&quot;);
219 
220         String subExpression;
221 
222         SubExprKind(String subExpression) {
223             this.subExpression = subExpression;
224         }
225 
226         @Override
227         public String expand(String optParameter) {
228             return subExpression;
229         }
230     }
231 
232     public static void main(String... args) throws Exception {
233         new ComboTestHelper&lt;LambdaParserTest&gt;()
234                 .withFilter(LambdaParserTest::redundantTestFilter)
235                 .withFilter(LambdaParserTest::badImplicitFilter)
236                 .withDimension(&quot;SOURCE&quot;, (x, sk) -&gt; x.sk = sk, SourceKind.values())
237                 .withDimension(&quot;LAMBDA&quot;, (x, lk) -&gt; x.lk = lk, LambdaKind.values())
238                 .withDimension(&quot;NAME&quot;, (x, name) -&gt; x.pn = name, LambdaParameterName.values())
239                 .withArrayDimension(&quot;TYPE&quot;, (x, type, idx) -&gt; x.pks[idx] = type, 2, LambdaParameterKind.values())
240                 .withArrayDimension(&quot;MOD&quot;, (x, mod, idx) -&gt; x.mks[idx] = mod, 2, ModifierKind.values())
241                 .withDimension(&quot;EXPR&quot;, ExprKind.values())
242                 .withDimension(&quot;SUBEXPR&quot;, SubExprKind.values())
243                 .run(LambdaParserTest::new);
244     }
245 
246     LambdaParameterKind[] pks = new LambdaParameterKind[2];
247     ModifierKind[] mks = new ModifierKind[2];
248     LambdaKind lk;
249     LambdaParameterName pn;
250     SourceKind sk;
251 
252     boolean badImplicitFilter() {
253         return !(mks[0] != ModifierKind.NONE &amp;&amp; lk.isShort());
254     }
255 
256     boolean redundantTestFilter() {
257         for (int i = lk.arity(); i &lt; mks.length ; i++) {
258             if (mks[i].ordinal() != 0) {
259                 return false;
260             }
261         }
262         for (int i = lk.arity(); i &lt; pks.length ; i++) {
263             if (pks[i].ordinal() != 0) {
264                 return false;
265             }
266         }
267         return true;
268     }
269 
270     String template = &quot;@interface A { }\n&quot; +
271             &quot;class Test {\n&quot; +
272             &quot;   SAM s = #{EXPR};\n&quot; +
273             &quot;}&quot;;
274 
275     @Override
276     public void doWork() throws IOException {
277         newCompilationTask()
278                 .withOptions(Arrays.asList(&quot;-source&quot;, sk.sourceNumber))
279                 .withSourceFromTemplate(template)
280                 .parse(this::check);
281     }
282 
283     void check(Result&lt;?&gt; res) {
284         boolean errorExpected = (lk.arity() &gt; 0 &amp;&amp; !mks[0].compatibleWith(pks[0])) ||
285                 (lk.arity() &gt; 1 &amp;&amp; !mks[1].compatibleWith(pks[1]));
286 
287         if (lk.arity() == 2 &amp;&amp;
288                 (pks[0].explicitKind(sk) != pks[1].explicitKind(sk) ||
289                 pks[0].isVarargs())) {
290             errorExpected = true;
291         }
292 
293         errorExpected |= pn == LambdaParameterName.UNDERSCORE &amp;&amp;
294                 lk.arity() &gt; 0;
295 
296         for (int i = 0; i &lt; lk.arity(); i++) {
297             if (!lk.isShort() &amp;&amp;
298                     pks[i].explicitKind(sk) == LambdaParameterKind.ExplicitKind.IMPLICIT_VAR &amp;&amp;
299                     sk == SourceKind.SOURCE_10) {
300                 errorExpected = true;
301                 break;
302             }
303         }
304 
305         if (errorExpected != res.hasErrors()) {
306             fail(&quot;invalid diagnostics for source:\n&quot; +
307                 res.compilationInfo() +
308                 &quot;\nFound error: &quot; + res.hasErrors() +
309                 &quot;\nExpected error: &quot; + errorExpected);
310         }
311     }
312 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
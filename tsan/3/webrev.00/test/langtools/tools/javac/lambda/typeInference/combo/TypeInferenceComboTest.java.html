<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/lambda/typeInference/combo/TypeInferenceComboTest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 8003280 8006694 8129962
 27  * @summary Add lambda tests
 28  *  perform automated checks in type inference in lambda expressions
 29  *  in different contexts
 30  *  temporarily workaround combo tests are causing time out in several platforms
 31  * @library /tools/javac/lib
 32  * @modules jdk.compiler/com.sun.tools.javac.api
 33  *          jdk.compiler/com.sun.tools.javac.file
 34  *          jdk.compiler/com.sun.tools.javac.util
 35  * @build combo.ComboTestHelper
 36  * @compile  TypeInferenceComboTest.java
 37  * @run main TypeInferenceComboTest
 38  */
 39 
 40 import java.io.IOException;
 41 
 42 import combo.ComboInstance;
 43 import combo.ComboParameter;
 44 import combo.ComboTask.Result;
 45 import combo.ComboTestHelper;
 46 
 47 public class TypeInferenceComboTest extends ComboInstance&lt;TypeInferenceComboTest&gt; {
 48     enum Context {
 49         ASSIGNMENT(&quot;SAM#Type s = #LBody;&quot;),
 50         METHOD_CALL(&quot;#GenericDeclKind void method1(SAM#Type s) { }\n&quot; +
 51                     &quot;void method2() {\n&quot; +
 52                     &quot;    method1(#LBody);\n&quot; +
 53                     &quot;}&quot;),
 54         RETURN_OF_METHOD(&quot;SAM#Type method1() {\n&quot; +
 55                 &quot;    return #LBody;\n&quot; +
 56                 &quot;}&quot;),
 57         LAMBDA_RETURN_EXPRESSION(&quot;SAM2 s2 = () -&gt; {return (SAM#Type)#LBody;};\n&quot;),
 58         ARRAY_INITIALIZER(&quot;Object[] oarray = {\&quot;a\&quot;, 1, (SAM#Type)#LBody};&quot;);
 59 
 60         String context;
 61 
 62         Context(String context) {
 63             this.context = context;
 64         }
 65 
 66         String getContext(SamKind sk, TypeKind samTargetT, Keyword kw,
 67                 TypeKind parameterT, TypeKind returnT, LambdaKind lk,
 68                 ParameterKind pk, GenericDeclKind gdk, LambdaBody lb) {
 69             String result = context;
 70             if (sk == SamKind.GENERIC) {
 71                 if(this == Context.METHOD_CALL) {
 72                     result = result.replaceAll(&quot;#GenericDeclKind&quot;,
 73                             gdk.getGenericDeclKind(samTargetT));
 74                     if(gdk == GenericDeclKind.NON_GENERIC)
 75                         result = result.replaceAll(&quot;#Type&quot;, &quot;&lt;&quot; +
 76                                 samTargetT.typeStr + &quot;&gt;&quot;);
 77                     else //#GenericDeclKind is &lt;T&gt; or &lt;T extends xxx&gt;
 78                         result = result.replaceAll(&quot;#Type&quot;, &quot;&lt;T&gt;&quot;);
 79                 }
 80                 else {
 81                     if(kw == Keyword.VOID)
 82                         result = result.replaceAll(&quot;#Type&quot;, &quot;&lt;&quot; +
 83                                 samTargetT.typeStr + &quot;&gt;&quot;);
 84                     else
 85                         result = result.replaceAll(&quot;#Type&quot;, &quot;&lt;? &quot; + kw.keyStr +
 86                                 &quot; &quot; + samTargetT.typeStr + &quot;&gt;&quot;);
 87                 }
 88             }
 89             else
 90                 result = result.replaceAll(&quot;#Type&quot;, &quot;&quot;).
 91                         replaceAll(&quot;#GenericDeclKind&quot;, &quot;&quot;);
 92 
 93             return result.replaceAll(&quot;#LBody&quot;,
 94                     lb.getLambdaBody(samTargetT, parameterT, returnT, lk, pk));
 95         }
 96     }
 97 
 98     enum SamKind {
 99         GENERIC(&quot;interface SAM&lt;T&gt; { #R m(#ARG); }&quot;),
100         NON_GENERIC(&quot;interface SAM { #R m(#ARG); }&quot;);
101 
102         String sam_str;
103 
104         SamKind(String sam_str) {
105             this.sam_str = sam_str;
106         }
107 
108         String getSam(TypeKind parameterT, TypeKind returnT) {
109             return sam_str.replaceAll(&quot;#ARG&quot;,
110                     parameterT == TypeKind.VOID ?
111                         &quot;&quot; : parameterT.typeStr + &quot; arg&quot;)
112                     .replaceAll(&quot;#R&quot;, returnT.typeStr);
113         }
114     }
115 
116     enum TypeKind {
117         VOID(&quot;void&quot;, &quot;&quot;),
118         STRING(&quot;String&quot;, &quot;\&quot;hello\&quot;&quot;),
119         INTEGER(&quot;Integer&quot;, &quot;1&quot;),
120         INT(&quot;int&quot;, &quot;0&quot;),
121         COMPARATOR(&quot;java.util.Comparator&lt;String&gt;&quot;,
122                 &quot;(java.util.Comparator&lt;String&gt;)(a, b) -&gt; a.length()-b.length()&quot;),
123         SAM(&quot;SAM2&quot;, &quot;null&quot;),
124         GENERIC(&quot;T&quot;, null);
125 
126         String typeStr;
127         String valStr;
128 
129         TypeKind(String typeStr, String valStr) {
130             this.typeStr = typeStr;
131             this.valStr = valStr;
132         }
133     }
134 
135     enum LambdaKind {
136         EXPRESSION(&quot;#VAL&quot;),
137         STATEMENT(&quot;{return #VAL;}&quot;);
138 
139         String stmt;
140 
141         LambdaKind(String stmt) {
142             this.stmt = stmt;
143         }
144     }
145 
146     enum ParameterKind {
147         EXPLICIT(&quot;#TYPE&quot;),
148         IMPLICIT(&quot;&quot;);
149 
150         String paramTemplate;
151 
152         ParameterKind(String paramTemplate) {
153              this.paramTemplate = paramTemplate;
154         }
155     }
156 
157     enum Keyword {
158         SUPER(&quot;super&quot;),
159         EXTENDS(&quot;extends&quot;),
160         VOID(&quot;&quot;);
161 
162         String keyStr;
163 
164         Keyword(String keyStr) {
165             this.keyStr = keyStr;
166         }
167     }
168 
169     enum LambdaBody {
170         //no parameters, return type is one of the TypeKind
171         RETURN_VOID(&quot;() -&gt; #RET&quot;),
172         //has parameters, return type is one of the TypeKind
173         RETURN_ARG(&quot;(#PK arg) -&gt; #RET&quot;);
174 
175         String bodyStr;
176 
177         LambdaBody(String bodyStr) {
178             this.bodyStr = bodyStr;
179         }
180 
181         String getLambdaBody(TypeKind samTargetT, TypeKind parameterT,
182                 TypeKind returnT, LambdaKind lk, ParameterKind pk) {
183             String result = bodyStr.replaceAll(&quot;#PK&quot;, pk.paramTemplate);
184 
185             if(result.contains(&quot;#TYPE&quot;)) {
186                 if (parameterT == TypeKind.GENERIC &amp;&amp; this != RETURN_VOID)
187                     result = result.replaceAll(&quot;#TYPE&quot;,
188                             samTargetT == null? &quot;&quot;: samTargetT.typeStr);
189                 else
190                     result = result.replaceAll(&quot;#TYPE&quot;, parameterT.typeStr);
191             }
192             if (this == RETURN_ARG &amp;&amp; parameterT == returnT)
193                 return result.replaceAll(&quot;#RET&quot;, lk.stmt.replaceAll(&quot;#VAL&quot;, &quot;arg&quot;));
194             else {
195                 if(returnT != TypeKind.GENERIC)
196                     return result.replaceAll(&quot;#RET&quot;, lk.stmt.replaceAll(&quot;#VAL&quot;,
197                             (returnT==TypeKind.VOID &amp;&amp;
198                             lk==LambdaKind.EXPRESSION) ? &quot;{}&quot; : returnT.valStr));
199                 else
200                     return result.replaceAll(&quot;#RET&quot;,
201                             lk.stmt.replaceAll(&quot;#VAL&quot;, samTargetT.valStr));
202             }
203         }
204     }
205 
206     enum GenericDeclKind {
207         NON_GENERIC(&quot;&quot;),
208         GENERIC_NOBOUND(&quot;&lt;T&gt;&quot;),
209         GENERIC_BOUND(&quot;&lt;T extends #ExtendedType&gt;&quot;);
210         String typeStr;
211 
212         GenericDeclKind(String typeStr) {
213             this.typeStr = typeStr;
214         }
215 
216         String getGenericDeclKind(TypeKind et) {
217             return typeStr.replaceAll(&quot;#ExtendedType&quot;, et==null? &quot;&quot;:et.typeStr);
218         }
219     }
220 
221     public static void main(String[] args) {
222         new ComboTestHelper&lt;TypeInferenceComboTest&gt;()
223                 .withFilter(TypeInferenceComboTest::badTestFilter)
224                 .withFilter(TypeInferenceComboTest::redundantTestFilter)
225                 .withDimension(&quot;SAM&quot;, (x, sam) -&gt; x.samKind = sam, SamKind.values())
226                 .withDimension(&quot;SAMTARGET&quot;, (x, target) -&gt; x.samTargetType = target, TypeKind.values())
227                 .withDimension(&quot;PARAMTYPE&quot;, (x, param) -&gt; x.parameterType = param, TypeKind.values())
228                 .withDimension(&quot;RETTYPE&quot;, (x, ret) -&gt; x.returnType = ret, TypeKind.values())
229                 .withDimension(&quot;CTX&quot;, (x, ctx) -&gt; x.context = ctx, Context.values())
230                 .withDimension(&quot;LAMBDABODY&quot;, (x, body) -&gt; x.lambdaBodyType = body, LambdaBody.values())
231                 .withDimension(&quot;LAMBDAKIND&quot;, (x, lambda) -&gt; x.lambdaKind = lambda, LambdaKind.values())
232                 .withDimension(&quot;PARAMKIND&quot;, (x, param) -&gt; x.parameterKind = param, ParameterKind.values())
233                 .withDimension(&quot;KEYWORD&quot;, (x, kw) -&gt; x.keyword = kw, Keyword.values())
234                 .withDimension(&quot;GENDECL&quot;, (x, gk) -&gt; x.genericDeclKind = gk, GenericDeclKind.values())
235                 .run(TypeInferenceComboTest::new);
236     }
237 
238     SamKind samKind;
239     TypeKind samTargetType;
240     TypeKind parameterType;
241     TypeKind returnType;
242     Context context;
243     LambdaBody lambdaBodyType;
244     LambdaKind lambdaKind;
245     ParameterKind parameterKind;
246     Keyword keyword;
247     GenericDeclKind genericDeclKind;
248 
249     boolean badTestFilter() {
250         if (samKind == SamKind.NON_GENERIC) {
251             return (parameterType != TypeKind.GENERIC &amp;&amp; returnType != TypeKind.GENERIC);
252         } else {
253             return (samTargetType != TypeKind.VOID &amp;&amp;
254                    samTargetType != TypeKind.INT &amp;&amp;
255                    samTargetType != TypeKind.GENERIC &amp;&amp;
256                    (parameterType == TypeKind.GENERIC ||
257                    returnType == TypeKind.GENERIC));
258         }
259     }
260 
261     boolean redundantTestFilter() {
262         if (samKind == SamKind.NON_GENERIC) {
263             return keyword.ordinal() == 0 &amp;&amp; samTargetType.ordinal() == 0 &amp;&amp; genericDeclKind.ordinal() == 0;
264         } else {
265             return context == Context.METHOD_CALL || genericDeclKind.ordinal() == 0;
266         }
267     }
268 
269     String sam_template = &quot;#{SAM}\n&quot; +
270                          &quot;interface SAM2 {\n&quot; +
271                          &quot;    SAM m();\n&quot; +
272                          &quot;}\n&quot;;
273 
274 
275     String client_template = &quot;class Client { \n&quot; +
276                              &quot;    #{CONTEXT}\n&quot; +
277                              &quot;}&quot;;
278 
279     @Override
280     public void doWork() throws IOException {
281         newCompilationTask()
282                 .withSourceFromTemplate(&quot;Sam&quot;, sam_template, this::samClass)
283                 .withSourceFromTemplate(&quot;Client&quot;, client_template, this::clientContext)
284                 .analyze(res -&gt; {
285             if (res.hasErrors() == checkTypeInference()) {
286                 fail(&quot;Unexpected compilation output when compiling instance: &quot; + res.compilationInfo());
287             }
288         });
289     }
290 
291     ComboParameter samClass(String parameterName) {
292         switch (parameterName) {
293             case &quot;SAM&quot;:
294                 return new ComboParameter.Constant&lt;&gt;(samKind.getSam(parameterType, returnType));
295             default:
296                 return null;
297         }
298     }
299 
300     ComboParameter clientContext(String parameterName) {
301         switch (parameterName) {
302             case &quot;CONTEXT&quot;:
303                 return new ComboParameter.Constant&lt;&gt;(context.getContext(samKind, samTargetType,
304                         keyword, parameterType, returnType, lambdaKind, parameterKind, genericDeclKind, lambdaBodyType));
305             default:
306                 return null;
307         }
308     }
309 
310     boolean checkTypeInference() {
311         if (parameterType == TypeKind.VOID) {
312             if (lambdaBodyType != LambdaBody.RETURN_VOID)
313                 return false;
314         }
315         else if (lambdaBodyType != LambdaBody.RETURN_ARG)
316             return false;
317 
318         return true;
319     }
320 }
    </pre>
  </body>
</html>
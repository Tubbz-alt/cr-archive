<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/defaultMethods/static/hiding/InterfaceMethodHidingTest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8005166 8129962
 27  * @summary Add support for static interface methods
 28  *          Smoke test for static interface method hiding
 29  * @library /tools/javac/lib
 30  * @modules jdk.compiler/com.sun.tools.javac.api
<a name="1" id="anc1"></a><span class="line-modified"> 31  *          jdk.compiler/com.sun.tools.javac.file</span>



 32  *          jdk.compiler/com.sun.tools.javac.util
 33  * @build combo.ComboTestHelper
 34  * @run main InterfaceMethodHidingTest
 35  */
 36 
 37 import java.io.IOException;
 38 
 39 import combo.ComboInstance;
 40 import combo.ComboParameter;
 41 import combo.ComboTask.Result;
 42 import combo.ComboTestHelper;
 43 
 44 public class InterfaceMethodHidingTest extends ComboInstance&lt;InterfaceMethodHidingTest&gt; {
 45 
 46     enum SignatureKind implements ComboParameter {
 47         VOID_INTEGER(&quot;void m(Integer s)&quot;, false),
 48         STRING_INTEGER(&quot;String m(Integer s)&quot;, true),
 49         VOID_STRING(&quot;void m(String s)&quot;, false),
 50         STRING_STRING(&quot;String m(String s)&quot;, true);
 51 
 52         String sigStr;
 53         boolean needsReturn;
 54 
 55         SignatureKind(String sigStr, boolean needsReturn) {
 56             this.sigStr = sigStr;
 57             this.needsReturn = needsReturn;
 58         }
 59 
 60         boolean overrideEquivalentWith(SignatureKind s2) {
 61             switch (this) {
 62                 case VOID_INTEGER:
 63                 case STRING_INTEGER:
 64                     return s2 == VOID_INTEGER || s2 == STRING_INTEGER;
 65                 case VOID_STRING:
 66                 case STRING_STRING:
 67                     return s2 == VOID_STRING || s2 == STRING_STRING;
 68                 default:
 69                     throw new AssertionError(&quot;bad signature kind&quot;);
 70             }
 71         }
 72 
 73         @Override
 74         public String expand(String optParameter) {
 75             return sigStr;
 76         }
 77     }
 78 
 79     enum MethodKind implements ComboParameter {
 80         VIRTUAL(&quot;#{SIG[#IDX]};&quot;),
 81         STATIC(&quot;static #{SIG[#IDX]} { #{BODY[#IDX]}; #{RET.#IDX} }&quot;),
 82         DEFAULT(&quot;default #{SIG[#IDX]} { #{BODY[#IDX]}; #{RET.#IDX} }&quot;);
 83 
 84         String methTemplate;
 85 
 86         MethodKind(String methTemplate) {
 87             this.methTemplate = methTemplate;
 88         }
 89 
 90         boolean inherithed() {
 91             return this != STATIC;
 92         }
 93 
 94         static boolean overrides(MethodKind mk1, SignatureKind sk1, MethodKind mk2, SignatureKind sk2) {
 95             return sk1 == sk2 &amp;&amp;
 96                     mk2.inherithed() &amp;&amp;
 97                     mk1 != STATIC;
 98         }
 99 
100         @Override
101         public String expand(String optParameter) {
102             return methTemplate.replaceAll(&quot;#IDX&quot;, optParameter);
103         }
104     }
105 
106     enum BodyExpr implements ComboParameter {
107         NONE(&quot;&quot;),
108         THIS(&quot;Object o = this&quot;);
109 
110         String bodyExprStr;
111 
112         BodyExpr(String bodyExprStr) {
113             this.bodyExprStr = bodyExprStr;
114         }
115 
116         boolean allowed(MethodKind mk) {
117             return this == NONE ||
118                     mk != MethodKind.STATIC;
119         }
120 
121         @Override
122         public String expand(String optParameter) {
123             return bodyExprStr;
124         }
125     }
126 
127     public static void main(String... args) throws Exception {
128         new ComboTestHelper&lt;InterfaceMethodHidingTest&gt;()
129                 .withArrayDimension(&quot;SIG&quot;, (x, sig, idx) -&gt; x.signatureKinds[idx] = sig, 3, SignatureKind.values())
130                 .withArrayDimension(&quot;BODY&quot;, (x, body, idx) -&gt; x.bodyExprs[idx] = body, 3, BodyExpr.values())
131                 .withArrayDimension(&quot;MET&quot;, (x, meth, idx) -&gt; x.methodKinds[idx] = meth, 3, MethodKind.values())
132                 .run(InterfaceMethodHidingTest::new);
133     }
134 
135     MethodKind[] methodKinds = new MethodKind[3];
136     SignatureKind[] signatureKinds = new SignatureKind[3];
137     BodyExpr[] bodyExprs = new BodyExpr[3];
138 
139     String template = &quot;interface Sup {\n&quot; +
140                           &quot;   default void sup() { }\n&quot; +
141                           &quot;}\n&quot; +
142                           &quot;interface A extends Sup {\n&quot; +
143                           &quot;   #{MET[0].0}\n&quot; +
144                           &quot;}\n&quot; +
145                           &quot;interface B extends A, Sup {\n&quot; +
146                           &quot;   #{MET[1].1}\n&quot; +
147                           &quot;}\n&quot; +
148                           &quot;interface C extends B, Sup {\n&quot; +
149                           &quot;   #{MET[2].2}\n&quot; +
150                           &quot;}\n&quot;;
151 
152     @Override
153     public void doWork() throws IOException {
154         newCompilationTask()
155                 .withOption(&quot;-XDallowStaticInterfaceMethods&quot;)
156                 .withSourceFromTemplate(template, this::returnExpr)
157                 .analyze(this::check);
158     }
159 
160     ComboParameter returnExpr(String name) {
161         switch (name) {
162             case &quot;RET&quot;:
163                 return optParameter -&gt; {
164                     int idx = new Integer(optParameter);
165                     return signatureKinds[idx].needsReturn ? &quot;return null;&quot; : &quot;return;&quot;;
166                 };
167             default:
168                 return null;
169         }
170     }
171 
172     void check(Result&lt;?&gt; res) {
173         boolean errorExpected = !bodyExprs[0].allowed(methodKinds[0]) ||
174                 !bodyExprs[1].allowed(methodKinds[1]) ||
175                 !bodyExprs[2].allowed(methodKinds[2]);
176 
177         if (methodKinds[0].inherithed()) {
178             errorExpected |= signatureKinds[1].overrideEquivalentWith(signatureKinds[0]) &amp;&amp;
179                     !MethodKind.overrides(methodKinds[1], signatureKinds[1], methodKinds[0], signatureKinds[0]) ||
180                     signatureKinds[2].overrideEquivalentWith(signatureKinds[0]) &amp;&amp;
181                     !MethodKind.overrides(methodKinds[2], signatureKinds[2], methodKinds[0], signatureKinds[0]);
182         }
183 
184         if (methodKinds[1].inherithed()) {
185             errorExpected |= signatureKinds[2].overrideEquivalentWith(signatureKinds[1]) &amp;&amp;
186                     !MethodKind.overrides(methodKinds[2], signatureKinds[2], methodKinds[1], signatureKinds[1]);
187         }
188 
189         if (res.hasErrors() != errorExpected) {
190             fail(&quot;Problem when compiling source:\n&quot; + res.compilationInfo() +
191                     &quot;\nfound error: &quot; + res.hasErrors());
192         }
193     }
194 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
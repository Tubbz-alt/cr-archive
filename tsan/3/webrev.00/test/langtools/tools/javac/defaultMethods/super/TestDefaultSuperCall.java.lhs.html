<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/tools/javac/defaultMethods/super/TestDefaultSuperCall.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 7192246 8006694 8129962
 27  * @summary Automatic test for checking correctness of default super/this resolution
 28  *  temporarily workaround combo tests are causing time out in several platforms
 29  * @library /tools/javac/lib
 30  * @modules jdk.compiler/com.sun.tools.javac.api
<a name="1" id="anc1"></a><span class="line-modified"> 31  *          jdk.compiler/com.sun.tools.javac.code</span>
<span class="line-removed"> 32  *          jdk.compiler/com.sun.tools.javac.comp</span>
<span class="line-removed"> 33  *          jdk.compiler/com.sun.tools.javac.main</span>
<span class="line-removed"> 34  *          jdk.compiler/com.sun.tools.javac.tree</span>
 35  *          jdk.compiler/com.sun.tools.javac.util
 36  * @build combo.ComboTestHelper
 37  * @run main TestDefaultSuperCall
 38  */
 39 
 40 import java.io.IOException;
 41 import java.util.ArrayList;
 42 import java.util.List;
 43 
 44 import combo.ComboInstance;
 45 import combo.ComboParameter;
 46 import combo.ComboTask.Result;
 47 import combo.ComboTestHelper;
 48 
 49 public class TestDefaultSuperCall extends ComboInstance&lt;TestDefaultSuperCall&gt; {
 50 
 51     enum InterfaceKind implements ComboParameter {
 52         DEFAULT(&quot;interface A extends B { default void m() { } }&quot;),
 53         ABSTRACT(&quot;interface A extends B { void m(); }&quot;),
 54         NONE(&quot;interface A extends B { }&quot;);
 55 
 56         String interfaceStr;
 57 
 58         InterfaceKind(String interfaceStr) {
 59             this.interfaceStr = interfaceStr;
 60         }
 61 
 62         boolean methodDefined() {
 63             return this == DEFAULT;
 64         }
 65 
 66         @Override
 67         public String expand(String optParameter) {
 68             return interfaceStr;
 69         }
 70     }
 71 
 72     enum PruneKind implements ComboParameter {
 73         NO_PRUNE(&quot;interface C { }&quot;),
 74         PRUNE(&quot;interface C extends A { }&quot;);
 75 
 76         boolean methodDefined(InterfaceKind ik) {
 77             return this == PRUNE &amp;&amp;
 78                     ik.methodDefined();
 79         }
 80 
 81         String interfaceStr;
 82 
 83         PruneKind(String interfaceStr) {
 84             this.interfaceStr = interfaceStr;
 85         }
 86 
 87         @Override
 88         public String expand(String optParameter) {
 89             return interfaceStr;
 90         }
 91     }
 92 
 93     enum QualifierKind implements ComboParameter {
 94         DIRECT_1(&quot;C&quot;),
 95         DIRECT_2(&quot;A&quot;),
 96         INDIRECT(&quot;B&quot;),
 97         UNRELATED(&quot;E&quot;),
 98         ENCLOSING_1(&quot;name0&quot;),
 99         ENCLOSING_2(&quot;name1&quot;);
100 
101         String qualifierStr;
102 
103         QualifierKind(String qualifierStr) {
104             this.qualifierStr = qualifierStr;
105         }
106 
107         boolean isEnclosing() {
108             return this == ENCLOSING_1 ||
109                     this == ENCLOSING_2;
110         }
111 
112         boolean allowSuperCall(InterfaceKind ik, PruneKind pk) {
113             switch (this) {
114                 case DIRECT_1:
115                     return pk.methodDefined(ik);
116                 case DIRECT_2:
117                     return ik.methodDefined() &amp;&amp; pk == PruneKind.NO_PRUNE;
118                 default:
119                     return false;
120             }
121         }
122 
123         @Override
124         public String expand(String optParameter) {
125             return qualifierStr;
126         }
127     }
128 
129     enum ExprKind implements ComboParameter {
130         THIS(&quot;this&quot;),
131         SUPER(&quot;super&quot;);
132 
133         String exprStr;
134 
135         ExprKind(String exprStr) {
136             this.exprStr = exprStr;
137         }
138 
139         @Override
140         public String expand(String optParameter) {
141             return exprStr;
142         }
143     }
144 
145     enum ElementKind implements ComboParameter {
146         INTERFACE(&quot;interface name#CURR { #BODY }&quot;, true),
147         INTERFACE_EXTENDS(&quot;interface name#CURR extends A, C { #BODY }&quot;, true),
148         CLASS(&quot;class name#CURR { #BODY }&quot;, false),
149         CLASS_EXTENDS(&quot;abstract class name#CURR implements A, C { #BODY }&quot;, false),
150         STATIC_CLASS(&quot;static class name#CURR { #BODY }&quot;, true),
151         STATIC_CLASS_EXTENDS(&quot;abstract static class name#CURR implements A, C { #BODY }&quot;, true),
152         ANON_CLASS(&quot;new Object() { #BODY };&quot;, false),
153         METHOD(&quot;void test() { #BODY }&quot;, false),
154         STATIC_METHOD(&quot;static void test() { #BODY }&quot;, true),
155         DEFAULT_METHOD(&quot;default void test() { #BODY }&quot;, false);
156 
157         String templateDecl;
158         boolean isStatic;
159 
160         ElementKind(String templateDecl, boolean isStatic) {
161             this.templateDecl = templateDecl;
162             this.isStatic = isStatic;
163         }
164 
165         boolean isClassDecl() {
166             switch(this) {
167                 case METHOD:
168                 case STATIC_METHOD:
169                 case DEFAULT_METHOD:
170                     return false;
171                 default:
172                     return true;
173             }
174         }
175 
176         boolean isAllowedEnclosing(ElementKind ek, boolean isTop) {
177             switch (this) {
178                 case CLASS:
179                 case CLASS_EXTENDS:
180                     //class is implicitly static inside interface, so skip this combo
181                     return ek.isClassDecl() &amp;&amp;
182                             ek != INTERFACE &amp;&amp; ek != INTERFACE_EXTENDS;
183                 case ANON_CLASS:
184                     return !ek.isClassDecl();
185                 case METHOD:
186                     return ek == CLASS || ek == CLASS_EXTENDS ||
187                             ek == STATIC_CLASS || ek == STATIC_CLASS_EXTENDS ||
188                             ek == ANON_CLASS;
189                 case INTERFACE:
190                 case INTERFACE_EXTENDS:
191                 case STATIC_CLASS:
192                 case STATIC_CLASS_EXTENDS:
193                 case STATIC_METHOD:
194                     return (isTop &amp;&amp; (ek == CLASS || ek == CLASS_EXTENDS)) ||
195                             ek == STATIC_CLASS || ek == STATIC_CLASS_EXTENDS;
196                 case DEFAULT_METHOD:
197                     return ek == INTERFACE || ek == INTERFACE_EXTENDS;
198                 default:
199                     throw new AssertionError(&quot;Bad enclosing element kind&quot; + this);
200             }
201         }
202 
203         boolean isAllowedTop() {
204             switch (this) {
205                 case CLASS:
206                 case CLASS_EXTENDS:
207                 case INTERFACE:
208                 case INTERFACE_EXTENDS:
209                     return true;
210                 default:
211                     return false;
212             }
213         }
214 
215         boolean hasSuper() {
216             return this == INTERFACE_EXTENDS ||
217                     this == STATIC_CLASS_EXTENDS ||
218                     this == CLASS_EXTENDS;
219         }
220 
221         @Override
222         public String expand(String optParameter) {
223             int nextDepth = new Integer(optParameter) + 1;
224             String replStr = (nextDepth &lt;= 4) ?
225                     String.format(&quot;#{ELEM[%d].%d}&quot;, nextDepth, nextDepth) :
226                     &quot;#{QUAL}.#{EXPR}.#{METH}();&quot;;
227             return templateDecl
228                     .replaceAll(&quot;#CURR&quot;, optParameter)
229                     .replaceAll(&quot;#BODY&quot;, replStr);
230         }
231     }
232 
233     static class Shape {
234 
235         List&lt;ElementKind&gt; enclosingElements;
236         List&lt;String&gt; enclosingNames;
237         List&lt;String&gt; elementsWithMethod;
238 
239         Shape(ElementKind... elements) {
240             enclosingElements = new ArrayList&lt;&gt;();
241             enclosingNames = new ArrayList&lt;&gt;();
242             elementsWithMethod = new ArrayList&lt;&gt;();
243             int count = 0;
244             String prevName = null;
245             for (ElementKind ek : elements) {
246                 String name = &quot;name&quot;+count++;
247                 if (ek.isStatic) {
248                     enclosingElements = new ArrayList&lt;&gt;();
249                     enclosingNames = new ArrayList&lt;&gt;();
250                 }
251                 if (ek.isClassDecl()) {
252                     enclosingElements.add(ek);
253                     enclosingNames.add(name);
254                 } else {
255                     elementsWithMethod.add(prevName);
256                 }
257                 prevName = name;
258             }
259         }
260     }
261 
262     public static void main(String... args) throws Exception {
263         new ComboTestHelper&lt;TestDefaultSuperCall&gt;()
264                 .withFilter(TestDefaultSuperCall::filterBadTopElement)
265                 .withFilter(TestDefaultSuperCall::filterBadIntermediateElement)
266                 .withFilter(TestDefaultSuperCall::filterBadTerminalElement)
267                 .withDimension(&quot;INTF1&quot;, (x, ik) -&gt; x.ik = ik, InterfaceKind.values())
268                 .withDimension(&quot;INTF2&quot;, (x, pk) -&gt; x.pk = pk, PruneKind.values())
269                 .withArrayDimension(&quot;ELEM&quot;, (x, elem, idx) -&gt; x.elements[idx] = elem, 5, ElementKind.values())
270                 .withDimension(&quot;QUAL&quot;, (x, qk) -&gt; x.qk = qk, QualifierKind.values())
271                 .withDimension(&quot;EXPR&quot;, (x, ek) -&gt; x.ek = ek, ExprKind.values())
272                 .run(TestDefaultSuperCall::new);
273     }
274 
275     InterfaceKind ik;
276     PruneKind pk;
277     ElementKind[] elements = new ElementKind[5];
278     QualifierKind qk;
279     ExprKind ek;
280 
281     boolean filterBadTopElement() {
282         return elements[0].isAllowedTop();
283     }
284 
285     boolean filterBadIntermediateElement() {
286         for (int i = 1 ; i &lt; 4 ; i++) {
287             if (!elements[i].isAllowedEnclosing(elements[i - 1], i == 1)) {
288                 return false;
289             }
290         }
291         return true;
292     }
293 
294     boolean filterBadTerminalElement() {
295         return elements[4].isAllowedEnclosing(elements[3], false) &amp;&amp; !elements[4].isClassDecl();
296     }
297 
298     String template = &quot;interface E {}\n&quot; +
299                       &quot;interface B { }\n&quot; +
300                       &quot;#{INTF1}\n&quot; +
301                       &quot;#{INTF2}\n&quot; +
302                       &quot;#{ELEM[0].0}&quot;;
303 
304     @Override
305     public void doWork() throws IOException {
306         newCompilationTask()
307                 .withSourceFromTemplate(template, this::methodName)
308                 .analyze(this::check);
309     }
310 
311     ComboParameter methodName(String parameterName) {
312         switch (parameterName) {
313             case &quot;METH&quot;:
314                 String methodName = ek == ExprKind.THIS ? &quot;test&quot; : &quot;m&quot;;
315                 return new ComboParameter.Constant&lt;String&gt;(methodName);
316             default:
317                 return null;
318         }
319     }
320 
321     void check(Result&lt;?&gt; res) {
322         Shape sh = new Shape(elements);
323 
324         boolean errorExpected = false;
325 
326         boolean badEnclosing = false;
327         boolean badThis = false;
328         boolean badSuper = false;
329 
330         if (qk == QualifierKind.ENCLOSING_1 &amp;&amp;
331                 sh.enclosingNames.size() &lt; 1) {
332             errorExpected |= true;
333             badEnclosing = true;
334         }
335 
336         if (qk == QualifierKind.ENCLOSING_2 &amp;&amp;
337                 sh.enclosingNames.size() &lt; 2) {
338             errorExpected |= true;
339             badEnclosing = true;
340         }
341 
342         if (ek == ExprKind.THIS) {
343             boolean found = false;
344             for (int i = 0; i &lt; sh.enclosingElements.size(); i++) {
345                 if (sh.enclosingElements.get(i) == ElementKind.ANON_CLASS) continue;
346                 if (sh.enclosingNames.get(i).equals(qk.qualifierStr)) {
347                     found = sh.elementsWithMethod.contains(sh.enclosingNames.get(i));
348                     break;
349                 }
350             }
351             errorExpected |= !found;
352             if (!found) {
353                 badThis = true;
354             }
355         }
356 
357         if (ek == ExprKind.SUPER) {
358 
359             int lastIdx = sh.enclosingElements.size() - 1;
360             boolean found = lastIdx == -1 ? false :
361                     sh.enclosingElements.get(lastIdx).hasSuper() &amp;&amp;
362                     qk.allowSuperCall(ik, pk);
363 
364             errorExpected |= !found;
365             if (!found) {
366                 badSuper = true;
367             }
368         }
369 
370         if (res.hasErrors() != errorExpected) {
371             fail(&quot;Problem when compiling source:\n&quot; +
372                     res.compilationInfo() +
373                     &quot;\nenclosingElems: &quot; + sh.enclosingElements +
374                     &quot;\nenclosingNames: &quot; + sh.enclosingNames +
375                     &quot;\nelementsWithMethod: &quot; + sh.elementsWithMethod +
376                     &quot;\nbad encl: &quot; + badEnclosing +
377                     &quot;\nbad this: &quot; + badThis +
378                     &quot;\nbad super: &quot; + badSuper +
379                     &quot;\nqual kind: &quot; + qk +
380                     &quot;\nfound error: &quot; + res.hasErrors());
381         }
382     }
383 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
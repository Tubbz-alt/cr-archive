<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/ConditionalExpressionResolvePending.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8234899
 27  * @summary Verify behavior w.r.t. preview feature API errors and warnings
 28  * @library /tools/lib /tools/javac/lib
 29  * @modules
 30  *      java.base/jdk.internal
 31  *      jdk.compiler/com.sun.tools.javac.api
 32  *      jdk.compiler/com.sun.tools.javac.file
 33  *      jdk.compiler/com.sun.tools.javac.main
 34  *      jdk.compiler/com.sun.tools.javac.util
 35  * @build toolbox.ToolBox toolbox.JavacTask
 36  * @build combo.ComboTestHelper
 37  * @compile --enable-preview -source ${jdk.version} ConditionalExpressionResolvePending.java
 38  * @run main/othervm --enable-preview ConditionalExpressionResolvePending
 39  */
 40 
 41 import combo.ComboInstance;
 42 import combo.ComboParameter;
 43 import combo.ComboTask;
 44 import combo.ComboTestHelper;
 45 import java.nio.file.Path;
 46 import java.nio.file.Paths;
 47 import java.util.Iterator;
 48 import java.util.Objects;
 49 import java.util.function.BiPredicate;
 50 import toolbox.ToolBox;
 51 
 52 import javax.tools.JavaFileObject;
 53 
 54 public class ConditionalExpressionResolvePending extends ComboInstance&lt;ConditionalExpressionResolvePending&gt; {
 55     protected ToolBox tb;
 56 
 57     ConditionalExpressionResolvePending() {
 58         super();
 59         tb = new ToolBox();
 60     }
 61 
 62     public static void main(String... args) throws Exception {
 63         new ComboTestHelper&lt;ConditionalExpressionResolvePending&gt;()
 64                 .withDimension(&quot;METHOD&quot;, (x, method) -&gt; x.method = method, Method.values())
 65                 .withDimension(&quot;EXPRESSION&quot;, (x, expression) -&gt; x.expression = expression, Expression.values())
 66                 .withDimension(&quot;TRUE&quot;, (x, True) -&gt; x.True = True, TestOrDummy.values())
 67                 .withDimension(&quot;FALSE&quot;, (x, False) -&gt; x.False = False, TestOrDummy.values())
 68                 .withDimension(&quot;SNIPPET&quot;, (x, snippet) -&gt; x.snippet = snippet, Snippet.values())
 69                 .run(ConditionalExpressionResolvePending::new);
 70     }
 71 
 72     private Method method;
 73     private Expression expression;
 74     private TestOrDummy True;
 75     private TestOrDummy False;
 76     private Snippet snippet;
 77 
 78     private static final String MAIN_TEMPLATE =
 79             &quot;&quot;&quot;
 80             public class Test {
 81                 public static boolean doTest(boolean c, Object input) {
 82                     String clazzName = input.getClass().getName();
 83                     int len = clazzName.length();
 84                     #{METHOD}
 85                 }
 86             }
 87             &quot;&quot;&quot;;
 88 
 89     @Override
 90     protected void doWork() throws Throwable {
 91         Path base = Paths.get(&quot;.&quot;);
 92 
 93         ComboTask task = newCompilationTask()
 94                 .withSourceFromTemplate(MAIN_TEMPLATE, pname -&gt; switch (pname) {
 95                         case &quot;METHOD&quot; -&gt; method;
 96                         case &quot;EXPRESSION&quot; -&gt; expression;
 97                         case &quot;TRUE&quot; -&gt; True;
 98                         case &quot;FALSE&quot; -&gt; False;
 99                         case &quot;SNIPPET&quot; -&gt; snippet;
100                         default -&gt; throw new UnsupportedOperationException(pname);
101                     })
102                 .withOption(&quot;--enable-preview&quot;)
103                 .withOption(&quot;-source&quot;)
104                 .withOption(String.valueOf(Runtime.version().feature()));
105 
106         task.generate(result -&gt; {
107             try {
108                 Iterator&lt;? extends JavaFileObject&gt; filesIt = result.get().iterator();
109                 JavaFileObject file = filesIt.next();
110                 if (filesIt.hasNext()) {
111                     throw new IllegalStateException(&quot;More than one classfile returned!&quot;);
112                 }
113                 byte[] data = file.openInputStream().readAllBytes();
114                 ClassLoader inMemoryLoader = new ClassLoader() {
115                     protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
116                         if (&quot;Test&quot;.equals(name)) {
117                             return defineClass(name, data, 0, data.length);
118                         }
119                         return super.findClass(name);
120                     }
121                 };
122                 Class&lt;?&gt; test = Class.forName(&quot;Test&quot;, false, inMemoryLoader);
123                 java.lang.reflect.Method doTest = test.getDeclaredMethod(&quot;doTest&quot;, boolean.class, Object.class);
124                 runTest((c, input) -&gt; {
125                     try {
126                         return (boolean) doTest.invoke(null, c, input);
127                     } catch (Exception ex) {
128                         throw new IllegalStateException(ex);
129                     }
130                 });
131             } catch (Throwable ex) {
132                 throw new IllegalStateException(ex);
133             }
134         });
135     }
136 
137     private void runTest(BiPredicate&lt;Boolean, Object&gt; test) {
138         assertEquals(false, test.test(true, &quot;&quot;));
139         assertEquals(true, test.test(true, 1));
140         assertEquals(false, test.test(false, &quot;&quot;));
141         assertEquals(true, test.test(false, 1));
142     }
143 
144     private void assertEquals(Object o1, Object o2) {
145         if (!Objects.equals(o1, o2)) {
146             throw new AssertionError();
147         }
148     }
149 
150     public enum Method implements ComboParameter {
151         VARIABLE(&quot;&quot;&quot;
152                  boolean b = #{EXPRESSION};
153                  return b;
154                  &quot;&quot;&quot;),
155         IF(&quot;&quot;&quot;
156            boolean b;
157            if (#{EXPRESSION}) b = true;
158            else b = false;
159            return b;
160            &quot;&quot;&quot;),
161         RETURN(&quot;&quot;&quot;
162                return #{EXPRESSION};
163                &quot;&quot;&quot;);
164         private final String body;
165 
166         private Method(String body) {
167             this.body = body;
168         }
169 
170         @Override
171         public String expand(String optParameter) {
172             return body;
173         }
174 
175     }
176     public enum Expression implements ComboParameter {
177         CONDITIONAL(&quot;c ? #{TRUE} : #{FALSE}&quot;),
178         AND(&quot;(c &amp;&amp; #{TRUE}) || (!c &amp;&amp; #{FALSE})&quot;);
179         private final String expression;
180 
181         private Expression(String expression) {
182             this.expression = expression;
183         }
184 
185         @Override
186         public String expand(String optParameter) {
187             return expression;
188         }
189     }
190     public enum TestOrDummy implements ComboParameter {
191         TEST(&quot;!(#{SNIPPET})&quot;),
192         DUMMY(&quot;input.getClass() == Integer.class&quot;);
193         private final String code;
194         private TestOrDummy(String code) {
195             this.code = code;
196         }
197         @Override
198         public String expand(String optParameter) {
199             return code;
200         }
201     }
202     public enum Snippet implements ComboParameter {
203         PATTERN(&quot;input instanceof String sX&quot;),
204         SWITCH_EXPRESSION(&quot;switch (len) { case 16 -&gt; {boolean r = true; yield r; } default -&gt; {boolean r = false; yield r; } }&quot;),
205         SWITCH_EXPRESSION_STRING(&quot;switch (clazzName) { case \&quot;java.lang.String\&quot;-&gt; {boolean r = true; yield r; } default -&gt; {boolean r = false; yield r; } }&quot;);
206         private static int idx;
207         private final String snippet;
208 
209         private Snippet(String snippet) {
210             this.snippet = snippet;
211         }
212 
213         @Override
214         public String expand(String optParameter) {
215             return snippet.replace(&quot;sX&quot;, &quot;s&quot; + idx++);
216         }
217 
218     }
219 }
    </pre>
  </body>
</html>
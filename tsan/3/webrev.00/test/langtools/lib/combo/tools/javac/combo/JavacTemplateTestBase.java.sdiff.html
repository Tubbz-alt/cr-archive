<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/langtools/lib/combo/tools/javac/combo/JavacTemplateTestBase.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Diagnostics.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Template.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/langtools/lib/combo/tools/javac/combo/JavacTemplateTestBase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 60  * source file generation, compilation, classloading, execution, and separate
 61  * compilation.
 62  *
 63  * &lt;p&gt;Manages a set of templates (which have embedded tags of the form
 64  * {@code #\{NAME\}}), source files (which are also templates), and compile
 65  * options.  Test cases can register templates and source files, cause them to
 66  * be compiled, validate whether the set of diagnostic messages output by the
 67  * compiler is correct, and optionally load and run the compiled classes.
 68  *
 69  * @author Brian Goetz
 70  */
 71 @Test
 72 public abstract class JavacTemplateTestBase {
 73     private static final Set&lt;String&gt; suiteErrors = Collections.synchronizedSet(new HashSet&lt;&gt;());
 74     private static final AtomicInteger counter = new AtomicInteger();
 75     private static final File root = new File(&quot;gen&quot;);
 76     private static final File nullDir = new File(&quot;empty&quot;);
 77 
 78     protected final Map&lt;String, Template&gt; templates = new HashMap&lt;&gt;();
 79     protected final Diagnostics diags = new Diagnostics();
<span class="line-modified"> 80     protected final List&lt;Pair&lt;String, Template&gt;&gt; sourceFiles = new ArrayList&lt;&gt;();</span>
 81     protected final List&lt;String&gt; compileOptions = new ArrayList&lt;&gt;();
 82     protected final List&lt;File&gt; classpaths = new ArrayList&lt;&gt;();
<span class="line-removed"> 83     protected final Template.Resolver defaultResolver = new MapResolver(templates);</span>
<span class="line-removed"> 84 </span>
<span class="line-removed"> 85     private Template.Resolver currentResolver = defaultResolver;</span>
 86 
 87     /** Add a template with a specified name */
 88     protected void addTemplate(String name, Template t) {
 89         templates.put(name, t);
 90     }
 91 
 92     /** Add a template with a specified name */
 93     protected void addTemplate(String name, String s) {
 94         templates.put(name, new StringTemplate(s));
 95     }
 96 
 97     /** Add a source file */
<span class="line-modified"> 98     protected void addSourceFile(String name, Template t) {</span>
<span class="line-modified"> 99         sourceFiles.add(new Pair&lt;&gt;(name, t));</span>
100     }
101 
102     /** Add a File to the class path to be used when loading classes; File values
103      * will generally be the result of a previous call to {@link #compile()}.
104      * This enables testing of separate compilation scenarios if the class path
105      * is set up properly.
106      */
107     protected void addClassPath(File path) {
108         classpaths.add(path);
109     }
110 
111     /**
112      * Add a set of compilation command-line options
113      */
114     protected void addCompileOptions(String... opts) {
115         Collections.addAll(compileOptions, opts);
116     }
117 
118     /** Reset the compile options to the default (empty) value */
119     protected void resetCompileOptions() { compileOptions.clear(); }
</pre>
<hr />
<pre>
132 
133     // Before each test method, reset everything
134     @BeforeMethod
135     public void reset() {
136         resetCompileOptions();
137         resetDiagnostics();
138         resetSourceFiles();
139         resetTemplates();
140         resetClassPaths();
141     }
142 
143     // After each test method, if the test failed, capture source files and diagnostics and put them in the log
144     @AfterMethod
145     public void copyErrors(ITestResult result) {
146         if (!result.isSuccess()) {
147             suiteErrors.addAll(diags.errorKeys());
148 
149             List&lt;Object&gt; list = new ArrayList&lt;&gt;();
150             Collections.addAll(list, result.getParameters());
151             list.add(&quot;Test case: &quot; + getTestCaseDescription());
<span class="line-modified">152             for (Pair&lt;String, Template&gt; e : sourceFiles)</span>
153                 list.add(&quot;Source file &quot; + e.fst + &quot;: &quot; + e.snd);
154             if (diags.errorsFound())
155                 list.add(&quot;Compile diagnostics: &quot; + diags.toString());
156             result.setParameters(list.toArray(new Object[list.size()]));
157         }
158     }
159 
160     @AfterSuite
161     // After the suite is done, dump any errors to output
162     public void dumpErrors() {
163         if (!suiteErrors.isEmpty())
164             System.err.println(&quot;Errors found in test suite: &quot; + suiteErrors);
165     }
166 
167     /**
168      * Get a description of this test case; since test cases may be combinatorially
169      * generated, this should include all information needed to describe the test case
170      */
171     protected String getTestCaseDescription() {
172         return this.toString();
</pre>
<hr />
<pre>
191      * otherwise assert that a compile failed.
192      * */
193     protected void assertCompileSucceededIff(boolean b) {
194         if (b)
195             assertCompileSucceeded();
196         else
197             assertCompileFailed();
198     }
199 
200     /** Assert that a previous call to compile() failed */
201     protected void assertCompileFailed() {
202         if (!diags.errorsFound())
203             fail(&quot;Expected failed compilation&quot;);
204     }
205 
206     /** Assert that a previous call to compile() failed with a specific error key */
207     protected void assertCompileFailed(String key) {
208         if (!diags.errorsFound())
209             fail(&quot;Expected failed compilation: &quot; + key);
210         if (!diags.containsErrorKey(key))
<span class="line-modified">211             fail(&quot;Expected compilation error &quot; + key);</span>
212     }
213 
214     /** Assert that a previous call to compile() failed with a specific error key */
215     protected void assertCompileFailedOneOf(String... keys) {
216         if (!diags.errorsFound())
217             fail(&quot;Expected failed compilation with one of: &quot; + Arrays.asList(keys));
218         boolean found = false;
219         for (String k : keys)
220             if (diags.containsErrorKey(k))
221                 found = true;
222         fail(String.format(&quot;Expected compilation error with one of %s, found %s&quot;, Arrays.asList(keys), diags.keys()));
223     }
224 
225     /** Assert that a previous call to compile() failed with all of the specified error keys */
226     protected void assertCompileErrors(String... keys) {
227         if (!diags.errorsFound())
228             fail(&quot;Expected failed compilation&quot;);
229         for (String k : keys)
230             if (!diags.containsErrorKey(k))
231                 fail(&quot;Expected compilation error &quot; + k);
232     }
233 
<span class="line-removed">234     /** Convert an object, which may be a Template or a String, into a Template */</span>
<span class="line-removed">235     protected Template asTemplate(Object o) {</span>
<span class="line-removed">236         if (o instanceof Template)</span>
<span class="line-removed">237             return (Template) o;</span>
<span class="line-removed">238         else if (o instanceof String)</span>
<span class="line-removed">239             return new StringTemplate((String) o);</span>
<span class="line-removed">240         else</span>
<span class="line-removed">241             return new StringTemplate(o.toString());</span>
<span class="line-removed">242     }</span>
<span class="line-removed">243 </span>
244     /** Compile all registered source files */
245     protected void compile() throws IOException {
246         compile(false);
247     }
248 
249     /** Compile all registered source files, optionally generating class files
250      * and returning a File describing the directory to which they were written */
251     protected File compile(boolean generate) throws IOException {
252         List&lt;JavaFileObject&gt; files = new ArrayList&lt;&gt;();
<span class="line-modified">253         for (Pair&lt;String, Template&gt; e : sourceFiles)</span>
<span class="line-modified">254             files.add(new FileAdapter(e.fst, asTemplate(e.snd)));</span>
255         return compile(classpaths, files, generate);
256     }
257 
258     /** Compile all registered source files, using the provided list of class paths
259      * for finding required classfiles, optionally generating class files
260      * and returning a File describing the directory to which they were written */
261     protected File compile(List&lt;File&gt; classpaths, boolean generate) throws IOException {
262         List&lt;JavaFileObject&gt; files = new ArrayList&lt;&gt;();
<span class="line-modified">263         for (Pair&lt;String, Template&gt; e : sourceFiles)</span>
<span class="line-modified">264             files.add(new FileAdapter(e.fst, asTemplate(e.snd)));</span>
265         return compile(classpaths, files, generate);
266     }
267 
268     private File compile(List&lt;File&gt; classpaths, List&lt;JavaFileObject&gt; files, boolean generate) throws IOException {
269         JavaCompiler systemJavaCompiler = ToolProvider.getSystemJavaCompiler();
270         try (StandardJavaFileManager fm = systemJavaCompiler.getStandardFileManager(null, null, null)) {
271             if (classpaths.size() &gt; 0)
272                 fm.setLocation(StandardLocation.CLASS_PATH, classpaths);
273             JavacTask ct = (JavacTask) systemJavaCompiler.getTask(null, fm, diags, compileOptions, null, files);
274             if (generate) {
275                 File destDir = new File(root, Integer.toString(counter.incrementAndGet()));
276                 // @@@ Assert that this directory didn&#39;t exist, or start counter at max+1
277                 destDir.mkdirs();
278                 fm.setLocation(StandardLocation.CLASS_OUTPUT, Arrays.asList(destDir));
279                 ct.generate();
280                 return destDir;
281             }
282             else {
283                 ct.analyze();
284                 return nullDir;
</pre>
<hr />
<pre>
289     /** Load the given class using the provided list of class paths */
290     protected Class&lt;?&gt; loadClass(String className, File... destDirs) {
291         try {
292             List&lt;URL&gt; list = new ArrayList&lt;&gt;();
293             for (File f : destDirs)
294                 list.add(new URL(&quot;file:&quot; + f.toString().replace(&quot;\\&quot;, &quot;/&quot;) + &quot;/&quot;));
295             return Class.forName(className, true, new URLClassLoader(list.toArray(new URL[list.size()])));
296         } catch (ClassNotFoundException | MalformedURLException e) {
297             throw new RuntimeException(&quot;Error loading class &quot; + className, e);
298         }
299     }
300 
301     /** An implementation of Template which is backed by a String */
302     protected class StringTemplate implements Template {
303         protected final String template;
304 
305         public StringTemplate(String template) {
306             this.template = template;
307         }
308 
<span class="line-modified">309         public String expand(String selector) {</span>
<span class="line-modified">310             return Behavior.expandTemplate(template, currentResolver);</span>
311         }
312 
313         public String toString() {
314             return expand(&quot;&quot;);
315         }
<span class="line-removed">316 </span>
<span class="line-removed">317         public StringTemplate with(final String key, final String value) {</span>
<span class="line-removed">318             return new StringTemplateWithResolver(template, new KeyResolver(key, value));</span>
<span class="line-removed">319         }</span>
<span class="line-removed">320 </span>
<span class="line-removed">321     }</span>
<span class="line-removed">322 </span>
<span class="line-removed">323     /** An implementation of Template which is backed by a String and which</span>
<span class="line-removed">324      * encapsulates a Resolver for resolving embedded tags. */</span>
<span class="line-removed">325     protected class StringTemplateWithResolver extends StringTemplate {</span>
<span class="line-removed">326         private final Resolver localResolver;</span>
<span class="line-removed">327 </span>
<span class="line-removed">328         public StringTemplateWithResolver(String template, Resolver localResolver) {</span>
<span class="line-removed">329             super(template);</span>
<span class="line-removed">330             this.localResolver = localResolver;</span>
<span class="line-removed">331         }</span>
<span class="line-removed">332 </span>
<span class="line-removed">333         @Override</span>
<span class="line-removed">334         public String expand(String selector) {</span>
<span class="line-removed">335             Resolver saved = currentResolver;</span>
<span class="line-removed">336             currentResolver = new ChainedResolver(currentResolver, localResolver);</span>
<span class="line-removed">337             try {</span>
<span class="line-removed">338                 return super.expand(selector);</span>
<span class="line-removed">339             }</span>
<span class="line-removed">340             finally {</span>
<span class="line-removed">341                 currentResolver = saved;</span>
<span class="line-removed">342             }</span>
<span class="line-removed">343         }</span>
<span class="line-removed">344 </span>
<span class="line-removed">345         @Override</span>
<span class="line-removed">346         public StringTemplate with(String key, String value) {</span>
<span class="line-removed">347             return new StringTemplateWithResolver(template, new ChainedResolver(localResolver, new KeyResolver(key, value)));</span>
<span class="line-removed">348         }</span>
<span class="line-removed">349     }</span>
<span class="line-removed">350 </span>
<span class="line-removed">351     /** A Resolver which uses a Map to resolve tags */</span>
<span class="line-removed">352     private class KeyResolver implements Template.Resolver {</span>
<span class="line-removed">353         private final String key;</span>
<span class="line-removed">354         private final String value;</span>
<span class="line-removed">355 </span>
<span class="line-removed">356         public KeyResolver(String key, String value) {</span>
<span class="line-removed">357             this.key = key;</span>
<span class="line-removed">358             this.value = value;</span>
<span class="line-removed">359         }</span>
<span class="line-removed">360 </span>
<span class="line-removed">361         @Override</span>
<span class="line-removed">362         public Template lookup(String k) {</span>
<span class="line-removed">363             return key.equals(k) ? new StringTemplate(value) : null;</span>
<span class="line-removed">364         }</span>
365     }
366 
367     private class FileAdapter extends SimpleJavaFileObject {
<span class="line-modified">368         private final String filename;</span>
<span class="line-removed">369         private final Template template;</span>
370 
<span class="line-modified">371         public FileAdapter(String filename, Template template) {</span>
372             super(URI.create(&quot;myfo:/&quot; + filename), Kind.SOURCE);
<span class="line-modified">373             this.template = template;</span>
<span class="line-removed">374             this.filename = filename;</span>
375         }
376 
377         public CharSequence getCharContent(boolean ignoreEncodingErrors) {
378             return toString();
379         }
380 
381         public String toString() {
<span class="line-modified">382             return Template.Behavior.expandTemplate(template.expand(filename), defaultResolver);</span>
383         }
384     }
385 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 60  * source file generation, compilation, classloading, execution, and separate
 61  * compilation.
 62  *
 63  * &lt;p&gt;Manages a set of templates (which have embedded tags of the form
 64  * {@code #\{NAME\}}), source files (which are also templates), and compile
 65  * options.  Test cases can register templates and source files, cause them to
 66  * be compiled, validate whether the set of diagnostic messages output by the
 67  * compiler is correct, and optionally load and run the compiled classes.
 68  *
 69  * @author Brian Goetz
 70  */
 71 @Test
 72 public abstract class JavacTemplateTestBase {
 73     private static final Set&lt;String&gt; suiteErrors = Collections.synchronizedSet(new HashSet&lt;&gt;());
 74     private static final AtomicInteger counter = new AtomicInteger();
 75     private static final File root = new File(&quot;gen&quot;);
 76     private static final File nullDir = new File(&quot;empty&quot;);
 77 
 78     protected final Map&lt;String, Template&gt; templates = new HashMap&lt;&gt;();
 79     protected final Diagnostics diags = new Diagnostics();
<span class="line-modified"> 80     protected final List&lt;Pair&lt;String, String&gt;&gt; sourceFiles = new ArrayList&lt;&gt;();</span>
 81     protected final List&lt;String&gt; compileOptions = new ArrayList&lt;&gt;();
 82     protected final List&lt;File&gt; classpaths = new ArrayList&lt;&gt;();



 83 
 84     /** Add a template with a specified name */
 85     protected void addTemplate(String name, Template t) {
 86         templates.put(name, t);
 87     }
 88 
 89     /** Add a template with a specified name */
 90     protected void addTemplate(String name, String s) {
 91         templates.put(name, new StringTemplate(s));
 92     }
 93 
 94     /** Add a source file */
<span class="line-modified"> 95     protected void addSourceFile(String name, String template) {</span>
<span class="line-modified"> 96         sourceFiles.add(new Pair&lt;&gt;(name, template));</span>
 97     }
 98 
 99     /** Add a File to the class path to be used when loading classes; File values
100      * will generally be the result of a previous call to {@link #compile()}.
101      * This enables testing of separate compilation scenarios if the class path
102      * is set up properly.
103      */
104     protected void addClassPath(File path) {
105         classpaths.add(path);
106     }
107 
108     /**
109      * Add a set of compilation command-line options
110      */
111     protected void addCompileOptions(String... opts) {
112         Collections.addAll(compileOptions, opts);
113     }
114 
115     /** Reset the compile options to the default (empty) value */
116     protected void resetCompileOptions() { compileOptions.clear(); }
</pre>
<hr />
<pre>
129 
130     // Before each test method, reset everything
131     @BeforeMethod
132     public void reset() {
133         resetCompileOptions();
134         resetDiagnostics();
135         resetSourceFiles();
136         resetTemplates();
137         resetClassPaths();
138     }
139 
140     // After each test method, if the test failed, capture source files and diagnostics and put them in the log
141     @AfterMethod
142     public void copyErrors(ITestResult result) {
143         if (!result.isSuccess()) {
144             suiteErrors.addAll(diags.errorKeys());
145 
146             List&lt;Object&gt; list = new ArrayList&lt;&gt;();
147             Collections.addAll(list, result.getParameters());
148             list.add(&quot;Test case: &quot; + getTestCaseDescription());
<span class="line-modified">149             for (Pair&lt;String, String&gt; e : sourceFiles)</span>
150                 list.add(&quot;Source file &quot; + e.fst + &quot;: &quot; + e.snd);
151             if (diags.errorsFound())
152                 list.add(&quot;Compile diagnostics: &quot; + diags.toString());
153             result.setParameters(list.toArray(new Object[list.size()]));
154         }
155     }
156 
157     @AfterSuite
158     // After the suite is done, dump any errors to output
159     public void dumpErrors() {
160         if (!suiteErrors.isEmpty())
161             System.err.println(&quot;Errors found in test suite: &quot; + suiteErrors);
162     }
163 
164     /**
165      * Get a description of this test case; since test cases may be combinatorially
166      * generated, this should include all information needed to describe the test case
167      */
168     protected String getTestCaseDescription() {
169         return this.toString();
</pre>
<hr />
<pre>
188      * otherwise assert that a compile failed.
189      * */
190     protected void assertCompileSucceededIff(boolean b) {
191         if (b)
192             assertCompileSucceeded();
193         else
194             assertCompileFailed();
195     }
196 
197     /** Assert that a previous call to compile() failed */
198     protected void assertCompileFailed() {
199         if (!diags.errorsFound())
200             fail(&quot;Expected failed compilation&quot;);
201     }
202 
203     /** Assert that a previous call to compile() failed with a specific error key */
204     protected void assertCompileFailed(String key) {
205         if (!diags.errorsFound())
206             fail(&quot;Expected failed compilation: &quot; + key);
207         if (!diags.containsErrorKey(key))
<span class="line-modified">208             fail(String.format(&quot;Expected compilation error with %s, found %s&quot;, key, diags.keys()));</span>
209     }
210 
211     /** Assert that a previous call to compile() failed with a specific error key */
212     protected void assertCompileFailedOneOf(String... keys) {
213         if (!diags.errorsFound())
214             fail(&quot;Expected failed compilation with one of: &quot; + Arrays.asList(keys));
215         boolean found = false;
216         for (String k : keys)
217             if (diags.containsErrorKey(k))
218                 found = true;
219         fail(String.format(&quot;Expected compilation error with one of %s, found %s&quot;, Arrays.asList(keys), diags.keys()));
220     }
221 
222     /** Assert that a previous call to compile() failed with all of the specified error keys */
223     protected void assertCompileErrors(String... keys) {
224         if (!diags.errorsFound())
225             fail(&quot;Expected failed compilation&quot;);
226         for (String k : keys)
227             if (!diags.containsErrorKey(k))
228                 fail(&quot;Expected compilation error &quot; + k);
229     }
230 










231     /** Compile all registered source files */
232     protected void compile() throws IOException {
233         compile(false);
234     }
235 
236     /** Compile all registered source files, optionally generating class files
237      * and returning a File describing the directory to which they were written */
238     protected File compile(boolean generate) throws IOException {
239         List&lt;JavaFileObject&gt; files = new ArrayList&lt;&gt;();
<span class="line-modified">240         for (Pair&lt;String, String&gt; e : sourceFiles)</span>
<span class="line-modified">241             files.add(new FileAdapter(e.fst, e.snd));</span>
242         return compile(classpaths, files, generate);
243     }
244 
245     /** Compile all registered source files, using the provided list of class paths
246      * for finding required classfiles, optionally generating class files
247      * and returning a File describing the directory to which they were written */
248     protected File compile(List&lt;File&gt; classpaths, boolean generate) throws IOException {
249         List&lt;JavaFileObject&gt; files = new ArrayList&lt;&gt;();
<span class="line-modified">250         for (Pair&lt;String, String&gt; e : sourceFiles)</span>
<span class="line-modified">251             files.add(new FileAdapter(e.fst, e.snd));</span>
252         return compile(classpaths, files, generate);
253     }
254 
255     private File compile(List&lt;File&gt; classpaths, List&lt;JavaFileObject&gt; files, boolean generate) throws IOException {
256         JavaCompiler systemJavaCompiler = ToolProvider.getSystemJavaCompiler();
257         try (StandardJavaFileManager fm = systemJavaCompiler.getStandardFileManager(null, null, null)) {
258             if (classpaths.size() &gt; 0)
259                 fm.setLocation(StandardLocation.CLASS_PATH, classpaths);
260             JavacTask ct = (JavacTask) systemJavaCompiler.getTask(null, fm, diags, compileOptions, null, files);
261             if (generate) {
262                 File destDir = new File(root, Integer.toString(counter.incrementAndGet()));
263                 // @@@ Assert that this directory didn&#39;t exist, or start counter at max+1
264                 destDir.mkdirs();
265                 fm.setLocation(StandardLocation.CLASS_OUTPUT, Arrays.asList(destDir));
266                 ct.generate();
267                 return destDir;
268             }
269             else {
270                 ct.analyze();
271                 return nullDir;
</pre>
<hr />
<pre>
276     /** Load the given class using the provided list of class paths */
277     protected Class&lt;?&gt; loadClass(String className, File... destDirs) {
278         try {
279             List&lt;URL&gt; list = new ArrayList&lt;&gt;();
280             for (File f : destDirs)
281                 list.add(new URL(&quot;file:&quot; + f.toString().replace(&quot;\\&quot;, &quot;/&quot;) + &quot;/&quot;));
282             return Class.forName(className, true, new URLClassLoader(list.toArray(new URL[list.size()])));
283         } catch (ClassNotFoundException | MalformedURLException e) {
284             throw new RuntimeException(&quot;Error loading class &quot; + className, e);
285         }
286     }
287 
288     /** An implementation of Template which is backed by a String */
289     protected class StringTemplate implements Template {
290         protected final String template;
291 
292         public StringTemplate(String template) {
293             this.template = template;
294         }
295 
<span class="line-modified">296         public String expand(String selectorIgnored) {</span>
<span class="line-modified">297             return Template.expandTemplate(template, templates);</span>
298         }
299 
300         public String toString() {
301             return expand(&quot;&quot;);
302         }

















































303     }
304 
305     private class FileAdapter extends SimpleJavaFileObject {
<span class="line-modified">306         private final String templateString;</span>

307 
<span class="line-modified">308         FileAdapter(String filename, String templateString) {</span>
309             super(URI.create(&quot;myfo:/&quot; + filename), Kind.SOURCE);
<span class="line-modified">310             this.templateString = templateString;</span>

311         }
312 
313         public CharSequence getCharContent(boolean ignoreEncodingErrors) {
314             return toString();
315         }
316 
317         public String toString() {
<span class="line-modified">318             return Template.expandTemplate(templateString, templates);</span>
319         }
320     }
321 }
</pre>
</td>
</tr>
</table>
<center><a href="Diagnostics.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Template.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
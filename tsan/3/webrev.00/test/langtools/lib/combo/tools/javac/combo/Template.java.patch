diff a/test/langtools/lib/combo/tools/javac/combo/Template.java b/test/langtools/lib/combo/tools/javac/combo/Template.java
--- a/test/langtools/lib/combo/tools/javac/combo/Template.java
+++ b/test/langtools/lib/combo/tools/javac/combo/Template.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,25 +22,23 @@
  */
 
 package tools.javac.combo;
 
 import java.util.Map;
+import java.util.function.Function;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 /**
  * A template into which tags of the form {@code #\{KEY\}} or
  * {@code #\{KEY.SUBKEY\}} can be expanded.
  */
 public interface Template {
-    String expand(String selector);
+    static final Pattern KEY_PATTERN = Pattern.compile("#\\{([A-Z_][A-Z0-9_]*(?:\\[\\d+\\])?)(?:\\.([A-Z0-9_]*))?\\}");
 
-    interface Resolver {
-        public Template lookup(String key);
-    }
+    String expand(String selector);
 
-    public static class Behavior {
         /* Looks for expandable keys.  An expandable key can take the form:
          *   #{MAJOR}
          *   #{MAJOR.}
          *   #{MAJOR.MINOR}
          * where MAJOR can be IDENTIFIER or IDENTIFIER[NUMERIC_INDEX]
@@ -54,71 +52,38 @@
          * empty string.
          *
          * However, this being a general-purpose framework, the exact
          * use is left up to the test writers.
          */
-        private static final Pattern pattern = Pattern.compile("#\\{([A-Z_][A-Z0-9_]*(?:\\[\\d+\\])?)(?:\\.([A-Z0-9_]*))?\\}");
-
-        public static String expandTemplate(String template, final Map<String, Template> vars) {
-            return expandTemplate(template, new MapResolver(vars));
+    public static String expandTemplate(String template,
+                                        Map<String, Template> vars) {
+        return expandTemplate(template, vars::get);
         }
 
-        public static String expandTemplate(String template, Resolver res) {
+    private static String expandTemplate(String template, Function<String, Template> resolver) {
             CharSequence in = template;
             StringBuffer out = new StringBuffer();
             while (true) {
                 boolean more = false;
-                Matcher m = pattern.matcher(in);
+            Matcher m = KEY_PATTERN.matcher(in);
                 while (m.find()) {
                     String major = m.group(1);
                     String minor = m.group(2);
-                    Template key = res.lookup(major);
+                Template key = resolver.apply(major);
                     if (key == null)
                         throw new IllegalStateException("Unknown major key " + major);
 
                     String replacement = key.expand(minor == null ? "" : minor);
-                    more |= pattern.matcher(replacement).find();
+                more |= KEY_PATTERN.matcher(replacement).find();
                     m.appendReplacement(out, replacement);
                 }
                 m.appendTail(out);
                 if (!more)
                     return out.toString();
                 else {
                     in = out;
                     out = new StringBuffer();
                 }
             }
-        }
-
-    }
-}
-
-class MapResolver implements Template.Resolver {
-    private final Map<String, Template> vars;
-
-    public MapResolver(Map<String, Template> vars) {this.vars = vars;}
-
-    public Template lookup(String key) {
-        return vars.get(key);
     }
 }
 
-class ChainedResolver implements Template.Resolver {
-    private final Template.Resolver upstreamResolver, thisResolver;
-
-    public ChainedResolver(Template.Resolver upstreamResolver, Template.Resolver thisResolver) {
-        this.upstreamResolver = upstreamResolver;
-        this.thisResolver = thisResolver;
-    }
-
-    public Template.Resolver getUpstreamResolver() {
-        return upstreamResolver;
-    }
-
-    @Override
-    public Template lookup(String key) {
-        Template result = thisResolver.lookup(key);
-        if (result == null)
-            result = upstreamResolver.lookup(key);
-        return result;
-    }
-}

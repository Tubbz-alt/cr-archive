<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/include/gtest/internal/gtest-type-util.h.pump</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 $$ -*- mode: c++; -*-
  2 $var n = 50  $$ Maximum length of type lists we want to support.
  3 // Copyright 2008 Google Inc.
  4 // All Rights Reserved.
  5 //
  6 // Redistribution and use in source and binary forms, with or without
  7 // modification, are permitted provided that the following conditions are
  8 // met:
  9 //
 10 //     * Redistributions of source code must retain the above copyright
 11 // notice, this list of conditions and the following disclaimer.
 12 //     * Redistributions in binary form must reproduce the above
 13 // copyright notice, this list of conditions and the following disclaimer
 14 // in the documentation and/or other materials provided with the
 15 // distribution.
 16 //     * Neither the name of Google Inc. nor the names of its
 17 // contributors may be used to endorse or promote products derived from
 18 // this software without specific prior written permission.
 19 //
 20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 21 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 22 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 23 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 24 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 25 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 26 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 27 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 28 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31 //
 32 // Author: wan@google.com (Zhanyong Wan)
 33 
 34 // Type utilities needed for implementing typed and type-parameterized
 35 // tests.  This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!
 36 //
 37 // Currently we support at most $n types in a list, and at most $n
 38 // type-parameterized tests in one type-parameterized test case.
 39 // Please contact googletestframework@googlegroups.com if you need
 40 // more.
 41 
 42 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_
 43 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_
 44 
 45 #include &quot;gtest/internal/gtest-port.h&quot;
 46 
 47 // #ifdef __GNUC__ is too general here.  It is possible to use gcc without using
 48 // libstdc++ (which is where cxxabi.h comes from).
 49 # if GTEST_HAS_CXXABI_H_
 50 #  include &lt;cxxabi.h&gt;
 51 # elif defined(__HP_aCC)
 52 #  include &lt;acxx_demangle.h&gt;
 53 # endif  // GTEST_HASH_CXXABI_H_
 54 
 55 namespace testing {
 56 namespace internal {
 57 
 58 // GetTypeName&lt;T&gt;() returns a human-readable name of type T.
 59 // NB: This function is also used in Google Mock, so don&#39;t move it inside of
 60 // the typed-test-only section below.
 61 template &lt;typename T&gt;
 62 std::string GetTypeName() {
 63 # if GTEST_HAS_RTTI
 64 
 65   const char* const name = typeid(T).name();
 66 #  if GTEST_HAS_CXXABI_H_ || defined(__HP_aCC)
 67   int status = 0;
 68   // gcc&#39;s implementation of typeid(T).name() mangles the type name,
 69   // so we have to demangle it.
 70 #   if GTEST_HAS_CXXABI_H_
 71   using abi::__cxa_demangle;
 72 #   endif  // GTEST_HAS_CXXABI_H_
 73   char* const readable_name = __cxa_demangle(name, 0, 0, &amp;status);
 74   const std::string name_str(status == 0 ? readable_name : name);
 75   free(readable_name);
 76   return name_str;
 77 #  else
 78   return name;
 79 #  endif  // GTEST_HAS_CXXABI_H_ || __HP_aCC
 80 
 81 # else
 82 
 83   return &quot;&lt;type&gt;&quot;;
 84 
 85 # endif  // GTEST_HAS_RTTI
 86 }
 87 
 88 #if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
 89 
 90 // AssertyTypeEq&lt;T1, T2&gt;::type is defined iff T1 and T2 are the same
 91 // type.  This can be used as a compile-time assertion to ensure that
 92 // two types are equal.
 93 
 94 template &lt;typename T1, typename T2&gt;
 95 struct AssertTypeEq;
 96 
 97 template &lt;typename T&gt;
 98 struct AssertTypeEq&lt;T, T&gt; {
 99   typedef bool type;
100 };
101 
102 // A unique type used as the default value for the arguments of class
103 // template Types.  This allows us to simulate variadic templates
104 // (e.g. Types&lt;int&gt;, Type&lt;int, double&gt;, and etc), which C++ doesn&#39;t
105 // support directly.
106 struct None {};
107 
108 // The following family of struct and struct templates are used to
109 // represent type lists.  In particular, TypesN&lt;T1, T2, ..., TN&gt;
110 // represents a type list with N types (T1, T2, ..., and TN) in it.
111 // Except for Types0, every struct in the family has two member types:
112 // Head for the first type in the list, and Tail for the rest of the
113 // list.
114 
115 // The empty type list.
116 struct Types0 {};
117 
118 // Type lists of length 1, 2, 3, and so on.
119 
120 template &lt;typename T1&gt;
121 struct Types1 {
122   typedef T1 Head;
123   typedef Types0 Tail;
124 };
125 
126 $range i 2..n
127 
128 $for i [[
129 $range j 1..i
130 $range k 2..i
131 template &lt;$for j, [[typename T$j]]&gt;
132 struct Types$i {
133   typedef T1 Head;
134   typedef Types$(i-1)&lt;$for k, [[T$k]]&gt; Tail;
135 };
136 
137 
138 ]]
139 
140 }  // namespace internal
141 
142 // We don&#39;t want to require the users to write TypesN&lt;...&gt; directly,
143 // as that would require them to count the length.  Types&lt;...&gt; is much
144 // easier to write, but generates horrible messages when there is a
145 // compiler error, as gcc insists on printing out each template
146 // argument, even if it has the default value (this means Types&lt;int&gt;
147 // will appear as Types&lt;int, None, None, ..., None&gt; in the compiler
148 // errors).
149 //
150 // Our solution is to combine the best part of the two approaches: a
151 // user would write Types&lt;T1, ..., TN&gt;, and Google Test will translate
152 // that to TypesN&lt;T1, ..., TN&gt; internally to make error messages
153 // readable.  The translation is done by the &#39;type&#39; member of the
154 // Types template.
155 
156 $range i 1..n
157 template &lt;$for i, [[typename T$i = internal::None]]&gt;
158 struct Types {
159   typedef internal::Types$n&lt;$for i, [[T$i]]&gt; type;
160 };
161 
162 template &lt;&gt;
163 struct Types&lt;$for i, [[internal::None]]&gt; {
164   typedef internal::Types0 type;
165 };
166 
167 $range i 1..n-1
168 $for i [[
169 $range j 1..i
170 $range k i+1..n
171 template &lt;$for j, [[typename T$j]]&gt;
172 struct Types&lt;$for j, [[T$j]]$for k[[, internal::None]]&gt; {
173   typedef internal::Types$i&lt;$for j, [[T$j]]&gt; type;
174 };
175 
176 ]]
177 
178 namespace internal {
179 
180 # define GTEST_TEMPLATE_ template &lt;typename T&gt; class
181 
182 // The template &quot;selector&quot; struct TemplateSel&lt;Tmpl&gt; is used to
183 // represent Tmpl, which must be a class template with one type
184 // parameter, as a type.  TemplateSel&lt;Tmpl&gt;::Bind&lt;T&gt;::type is defined
185 // as the type Tmpl&lt;T&gt;.  This allows us to actually instantiate the
186 // template &quot;selected&quot; by TemplateSel&lt;Tmpl&gt;.
187 //
188 // This trick is necessary for simulating typedef for class templates,
189 // which C++ doesn&#39;t support directly.
190 template &lt;GTEST_TEMPLATE_ Tmpl&gt;
191 struct TemplateSel {
192   template &lt;typename T&gt;
193   struct Bind {
194     typedef Tmpl&lt;T&gt; type;
195   };
196 };
197 
198 # define GTEST_BIND_(TmplSel, T) \
199   TmplSel::template Bind&lt;T&gt;::type
200 
201 // A unique struct template used as the default value for the
202 // arguments of class template Templates.  This allows us to simulate
203 // variadic templates (e.g. Templates&lt;int&gt;, Templates&lt;int, double&gt;,
204 // and etc), which C++ doesn&#39;t support directly.
205 template &lt;typename T&gt;
206 struct NoneT {};
207 
208 // The following family of struct and struct templates are used to
209 // represent template lists.  In particular, TemplatesN&lt;T1, T2, ...,
210 // TN&gt; represents a list of N templates (T1, T2, ..., and TN).  Except
211 // for Templates0, every struct in the family has two member types:
212 // Head for the selector of the first template in the list, and Tail
213 // for the rest of the list.
214 
215 // The empty template list.
216 struct Templates0 {};
217 
218 // Template lists of length 1, 2, 3, and so on.
219 
220 template &lt;GTEST_TEMPLATE_ T1&gt;
221 struct Templates1 {
222   typedef TemplateSel&lt;T1&gt; Head;
223   typedef Templates0 Tail;
224 };
225 
226 $range i 2..n
227 
228 $for i [[
229 $range j 1..i
230 $range k 2..i
231 template &lt;$for j, [[GTEST_TEMPLATE_ T$j]]&gt;
232 struct Templates$i {
233   typedef TemplateSel&lt;T1&gt; Head;
234   typedef Templates$(i-1)&lt;$for k, [[T$k]]&gt; Tail;
235 };
236 
237 
238 ]]
239 
240 // We don&#39;t want to require the users to write TemplatesN&lt;...&gt; directly,
241 // as that would require them to count the length.  Templates&lt;...&gt; is much
242 // easier to write, but generates horrible messages when there is a
243 // compiler error, as gcc insists on printing out each template
244 // argument, even if it has the default value (this means Templates&lt;list&gt;
245 // will appear as Templates&lt;list, NoneT, NoneT, ..., NoneT&gt; in the compiler
246 // errors).
247 //
248 // Our solution is to combine the best part of the two approaches: a
249 // user would write Templates&lt;T1, ..., TN&gt;, and Google Test will translate
250 // that to TemplatesN&lt;T1, ..., TN&gt; internally to make error messages
251 // readable.  The translation is done by the &#39;type&#39; member of the
252 // Templates template.
253 
254 $range i 1..n
255 template &lt;$for i, [[GTEST_TEMPLATE_ T$i = NoneT]]&gt;
256 struct Templates {
257   typedef Templates$n&lt;$for i, [[T$i]]&gt; type;
258 };
259 
260 template &lt;&gt;
261 struct Templates&lt;$for i, [[NoneT]]&gt; {
262   typedef Templates0 type;
263 };
264 
265 $range i 1..n-1
266 $for i [[
267 $range j 1..i
268 $range k i+1..n
269 template &lt;$for j, [[GTEST_TEMPLATE_ T$j]]&gt;
270 struct Templates&lt;$for j, [[T$j]]$for k[[, NoneT]]&gt; {
271   typedef Templates$i&lt;$for j, [[T$j]]&gt; type;
272 };
273 
274 ]]
275 
276 // The TypeList template makes it possible to use either a single type
277 // or a Types&lt;...&gt; list in TYPED_TEST_CASE() and
278 // INSTANTIATE_TYPED_TEST_CASE_P().
279 
280 template &lt;typename T&gt;
281 struct TypeList {
282   typedef Types1&lt;T&gt; type;
283 };
284 
285 
286 $range i 1..n
287 template &lt;$for i, [[typename T$i]]&gt;
288 struct TypeList&lt;Types&lt;$for i, [[T$i]]&gt; &gt; {
289   typedef typename Types&lt;$for i, [[T$i]]&gt;::type type;
290 };
291 
292 #endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
293 
294 }  // namespace internal
295 }  // namespace testing
296 
297 #endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_
    </pre>
  </body>
</html>
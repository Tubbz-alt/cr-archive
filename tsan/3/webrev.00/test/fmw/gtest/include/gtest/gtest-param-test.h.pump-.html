<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/include/gtest/gtest-param-test.h.pump</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 $$ -*- mode: c++; -*-
  2 $var n = 50  $$ Maximum length of Values arguments we want to support.
  3 $var maxtuple = 10  $$ Maximum number of Combine arguments we want to support.
  4 // Copyright 2008, Google Inc.
  5 // All rights reserved.
  6 //
  7 // Redistribution and use in source and binary forms, with or without
  8 // modification, are permitted provided that the following conditions are
  9 // met:
 10 //
 11 //     * Redistributions of source code must retain the above copyright
 12 // notice, this list of conditions and the following disclaimer.
 13 //     * Redistributions in binary form must reproduce the above
 14 // copyright notice, this list of conditions and the following disclaimer
 15 // in the documentation and/or other materials provided with the
 16 // distribution.
 17 //     * Neither the name of Google Inc. nor the names of its
 18 // contributors may be used to endorse or promote products derived from
 19 // this software without specific prior written permission.
 20 //
 21 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 22 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 23 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 24 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 25 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 26 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 27 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 28 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 29 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 30 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 31 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32 //
 33 // Authors: vladl@google.com (Vlad Losev)
 34 //
 35 // Macros and functions for implementing parameterized tests
 36 // in Google C++ Testing Framework (Google Test)
 37 //
 38 // This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!
 39 //
 40 #ifndef GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_
 41 #define GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_
 42 
 43 
 44 // Value-parameterized tests allow you to test your code with different
 45 // parameters without writing multiple copies of the same test.
 46 //
 47 // Here is how you use value-parameterized tests:
 48 
 49 #if 0
 50 
 51 // To write value-parameterized tests, first you should define a fixture
 52 // class. It is usually derived from testing::TestWithParam&lt;T&gt; (see below for
 53 // another inheritance scheme that&#39;s sometimes useful in more complicated
 54 // class hierarchies), where the type of your parameter values.
 55 // TestWithParam&lt;T&gt; is itself derived from testing::Test. T can be any
 56 // copyable type. If it&#39;s a raw pointer, you are responsible for managing the
 57 // lifespan of the pointed values.
 58 
 59 class FooTest : public ::testing::TestWithParam&lt;const char*&gt; {
 60   // You can implement all the usual class fixture members here.
 61 };
 62 
 63 // Then, use the TEST_P macro to define as many parameterized tests
 64 // for this fixture as you want. The _P suffix is for &quot;parameterized&quot;
 65 // or &quot;pattern&quot;, whichever you prefer to think.
 66 
 67 TEST_P(FooTest, DoesBlah) {
 68   // Inside a test, access the test parameter with the GetParam() method
 69   // of the TestWithParam&lt;T&gt; class:
 70   EXPECT_TRUE(foo.Blah(GetParam()));
 71   ...
 72 }
 73 
 74 TEST_P(FooTest, HasBlahBlah) {
 75   ...
 76 }
 77 
 78 // Finally, you can use INSTANTIATE_TEST_CASE_P to instantiate the test
 79 // case with any set of parameters you want. Google Test defines a number
 80 // of functions for generating test parameters. They return what we call
 81 // (surprise!) parameter generators. Here is a  summary of them, which
 82 // are all in the testing namespace:
 83 //
 84 //
 85 //  Range(begin, end [, step]) - Yields values {begin, begin+step,
 86 //                               begin+step+step, ...}. The values do not
 87 //                               include end. step defaults to 1.
 88 //  Values(v1, v2, ..., vN)    - Yields values {v1, v2, ..., vN}.
 89 //  ValuesIn(container)        - Yields values from a C-style array, an STL
 90 //  ValuesIn(begin,end)          container, or an iterator range [begin, end).
 91 //  Bool()                     - Yields sequence {false, true}.
 92 //  Combine(g1, g2, ..., gN)   - Yields all combinations (the Cartesian product
 93 //                               for the math savvy) of the values generated
 94 //                               by the N generators.
 95 //
 96 // For more details, see comments at the definitions of these functions below
 97 // in this file.
 98 //
 99 // The following statement will instantiate tests from the FooTest test case
100 // each with parameter values &quot;meeny&quot;, &quot;miny&quot;, and &quot;moe&quot;.
101 
102 INSTANTIATE_TEST_CASE_P(InstantiationName,
103                         FooTest,
104                         Values(&quot;meeny&quot;, &quot;miny&quot;, &quot;moe&quot;));
105 
106 // To distinguish different instances of the pattern, (yes, you
107 // can instantiate it more then once) the first argument to the
108 // INSTANTIATE_TEST_CASE_P macro is a prefix that will be added to the
109 // actual test case name. Remember to pick unique prefixes for different
110 // instantiations. The tests from the instantiation above will have
111 // these names:
112 //
113 //    * InstantiationName/FooTest.DoesBlah/0 for &quot;meeny&quot;
114 //    * InstantiationName/FooTest.DoesBlah/1 for &quot;miny&quot;
115 //    * InstantiationName/FooTest.DoesBlah/2 for &quot;moe&quot;
116 //    * InstantiationName/FooTest.HasBlahBlah/0 for &quot;meeny&quot;
117 //    * InstantiationName/FooTest.HasBlahBlah/1 for &quot;miny&quot;
118 //    * InstantiationName/FooTest.HasBlahBlah/2 for &quot;moe&quot;
119 //
120 // You can use these names in --gtest_filter.
121 //
122 // This statement will instantiate all tests from FooTest again, each
123 // with parameter values &quot;cat&quot; and &quot;dog&quot;:
124 
125 const char* pets[] = {&quot;cat&quot;, &quot;dog&quot;};
126 INSTANTIATE_TEST_CASE_P(AnotherInstantiationName, FooTest, ValuesIn(pets));
127 
128 // The tests from the instantiation above will have these names:
129 //
130 //    * AnotherInstantiationName/FooTest.DoesBlah/0 for &quot;cat&quot;
131 //    * AnotherInstantiationName/FooTest.DoesBlah/1 for &quot;dog&quot;
132 //    * AnotherInstantiationName/FooTest.HasBlahBlah/0 for &quot;cat&quot;
133 //    * AnotherInstantiationName/FooTest.HasBlahBlah/1 for &quot;dog&quot;
134 //
135 // Please note that INSTANTIATE_TEST_CASE_P will instantiate all tests
136 // in the given test case, whether their definitions come before or
137 // AFTER the INSTANTIATE_TEST_CASE_P statement.
138 //
139 // Please also note that generator expressions (including parameters to the
140 // generators) are evaluated in InitGoogleTest(), after main() has started.
141 // This allows the user on one hand, to adjust generator parameters in order
142 // to dynamically determine a set of tests to run and on the other hand,
143 // give the user a chance to inspect the generated tests with Google Test
144 // reflection API before RUN_ALL_TESTS() is executed.
145 //
146 // You can see samples/sample7_unittest.cc and samples/sample8_unittest.cc
147 // for more examples.
148 //
149 // In the future, we plan to publish the API for defining new parameter
150 // generators. But for now this interface remains part of the internal
151 // implementation and is subject to change.
152 //
153 //
154 // A parameterized test fixture must be derived from testing::Test and from
155 // testing::WithParamInterface&lt;T&gt;, where T is the type of the parameter
156 // values. Inheriting from TestWithParam&lt;T&gt; satisfies that requirement because
157 // TestWithParam&lt;T&gt; inherits from both Test and WithParamInterface. In more
158 // complicated hierarchies, however, it is occasionally useful to inherit
159 // separately from Test and WithParamInterface. For example:
160 
161 class BaseTest : public ::testing::Test {
162   // You can inherit all the usual members for a non-parameterized test
163   // fixture here.
164 };
165 
166 class DerivedTest : public BaseTest, public ::testing::WithParamInterface&lt;int&gt; {
167   // The usual test fixture members go here too.
168 };
169 
170 TEST_F(BaseTest, HasFoo) {
171   // This is an ordinary non-parameterized test.
172 }
173 
174 TEST_P(DerivedTest, DoesBlah) {
175   // GetParam works just the same here as if you inherit from TestWithParam.
176   EXPECT_TRUE(foo.Blah(GetParam()));
177 }
178 
179 #endif  // 0
180 
181 #include &quot;gtest/internal/gtest-port.h&quot;
182 
183 #if !GTEST_OS_SYMBIAN
184 # include &lt;utility&gt;
185 #endif
186 
187 // scripts/fuse_gtest.py depends on gtest&#39;s own header being #included
188 // *unconditionally*.  Therefore these #includes cannot be moved
189 // inside #if GTEST_HAS_PARAM_TEST.
190 #include &quot;gtest/internal/gtest-internal.h&quot;
191 #include &quot;gtest/internal/gtest-param-util.h&quot;
192 #include &quot;gtest/internal/gtest-param-util-generated.h&quot;
193 
194 #if GTEST_HAS_PARAM_TEST
195 
196 namespace testing {
197 
198 // Functions producing parameter generators.
199 //
200 // Google Test uses these generators to produce parameters for value-
201 // parameterized tests. When a parameterized test case is instantiated
202 // with a particular generator, Google Test creates and runs tests
203 // for each element in the sequence produced by the generator.
204 //
205 // In the following sample, tests from test case FooTest are instantiated
206 // each three times with parameter values 3, 5, and 8:
207 //
208 // class FooTest : public TestWithParam&lt;int&gt; { ... };
209 //
210 // TEST_P(FooTest, TestThis) {
211 // }
212 // TEST_P(FooTest, TestThat) {
213 // }
214 // INSTANTIATE_TEST_CASE_P(TestSequence, FooTest, Values(3, 5, 8));
215 //
216 
217 // Range() returns generators providing sequences of values in a range.
218 //
219 // Synopsis:
220 // Range(start, end)
221 //   - returns a generator producing a sequence of values {start, start+1,
222 //     start+2, ..., }.
223 // Range(start, end, step)
224 //   - returns a generator producing a sequence of values {start, start+step,
225 //     start+step+step, ..., }.
226 // Notes:
227 //   * The generated sequences never include end. For example, Range(1, 5)
228 //     returns a generator producing a sequence {1, 2, 3, 4}. Range(1, 9, 2)
229 //     returns a generator producing {1, 3, 5, 7}.
230 //   * start and end must have the same type. That type may be any integral or
231 //     floating-point type or a user defined type satisfying these conditions:
232 //     * It must be assignable (have operator=() defined).
233 //     * It must have operator+() (operator+(int-compatible type) for
234 //       two-operand version).
235 //     * It must have operator&lt;() defined.
236 //     Elements in the resulting sequences will also have that type.
237 //   * Condition start &lt; end must be satisfied in order for resulting sequences
238 //     to contain any elements.
239 //
240 template &lt;typename T, typename IncrementT&gt;
241 internal::ParamGenerator&lt;T&gt; Range(T start, T end, IncrementT step) {
242   return internal::ParamGenerator&lt;T&gt;(
243       new internal::RangeGenerator&lt;T, IncrementT&gt;(start, end, step));
244 }
245 
246 template &lt;typename T&gt;
247 internal::ParamGenerator&lt;T&gt; Range(T start, T end) {
248   return Range(start, end, 1);
249 }
250 
251 // ValuesIn() function allows generation of tests with parameters coming from
252 // a container.
253 //
254 // Synopsis:
255 // ValuesIn(const T (&amp;array)[N])
256 //   - returns a generator producing sequences with elements from
257 //     a C-style array.
258 // ValuesIn(const Container&amp; container)
259 //   - returns a generator producing sequences with elements from
260 //     an STL-style container.
261 // ValuesIn(Iterator begin, Iterator end)
262 //   - returns a generator producing sequences with elements from
263 //     a range [begin, end) defined by a pair of STL-style iterators. These
264 //     iterators can also be plain C pointers.
265 //
266 // Please note that ValuesIn copies the values from the containers
267 // passed in and keeps them to generate tests in RUN_ALL_TESTS().
268 //
269 // Examples:
270 //
271 // This instantiates tests from test case StringTest
272 // each with C-string values of &quot;foo&quot;, &quot;bar&quot;, and &quot;baz&quot;:
273 //
274 // const char* strings[] = {&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;};
275 // INSTANTIATE_TEST_CASE_P(StringSequence, SrtingTest, ValuesIn(strings));
276 //
277 // This instantiates tests from test case StlStringTest
278 // each with STL strings with values &quot;a&quot; and &quot;b&quot;:
279 //
280 // ::std::vector&lt; ::std::string&gt; GetParameterStrings() {
281 //   ::std::vector&lt; ::std::string&gt; v;
282 //   v.push_back(&quot;a&quot;);
283 //   v.push_back(&quot;b&quot;);
284 //   return v;
285 // }
286 //
287 // INSTANTIATE_TEST_CASE_P(CharSequence,
288 //                         StlStringTest,
289 //                         ValuesIn(GetParameterStrings()));
290 //
291 //
292 // This will also instantiate tests from CharTest
293 // each with parameter values &#39;a&#39; and &#39;b&#39;:
294 //
295 // ::std::list&lt;char&gt; GetParameterChars() {
296 //   ::std::list&lt;char&gt; list;
297 //   list.push_back(&#39;a&#39;);
298 //   list.push_back(&#39;b&#39;);
299 //   return list;
300 // }
301 // ::std::list&lt;char&gt; l = GetParameterChars();
302 // INSTANTIATE_TEST_CASE_P(CharSequence2,
303 //                         CharTest,
304 //                         ValuesIn(l.begin(), l.end()));
305 //
306 template &lt;typename ForwardIterator&gt;
307 internal::ParamGenerator&lt;
308   typename ::testing::internal::IteratorTraits&lt;ForwardIterator&gt;::value_type&gt;
309 ValuesIn(ForwardIterator begin, ForwardIterator end) {
310   typedef typename ::testing::internal::IteratorTraits&lt;ForwardIterator&gt;
311       ::value_type ParamType;
312   return internal::ParamGenerator&lt;ParamType&gt;(
313       new internal::ValuesInIteratorRangeGenerator&lt;ParamType&gt;(begin, end));
314 }
315 
316 template &lt;typename T, size_t N&gt;
317 internal::ParamGenerator&lt;T&gt; ValuesIn(const T (&amp;array)[N]) {
318   return ValuesIn(array, array + N);
319 }
320 
321 template &lt;class Container&gt;
322 internal::ParamGenerator&lt;typename Container::value_type&gt; ValuesIn(
323     const Container&amp; container) {
324   return ValuesIn(container.begin(), container.end());
325 }
326 
327 // Values() allows generating tests from explicitly specified list of
328 // parameters.
329 //
330 // Synopsis:
331 // Values(T v1, T v2, ..., T vN)
332 //   - returns a generator producing sequences with elements v1, v2, ..., vN.
333 //
334 // For example, this instantiates tests from test case BarTest each
335 // with values &quot;one&quot;, &quot;two&quot;, and &quot;three&quot;:
336 //
337 // INSTANTIATE_TEST_CASE_P(NumSequence, BarTest, Values(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;));
338 //
339 // This instantiates tests from test case BazTest each with values 1, 2, 3.5.
340 // The exact type of values will depend on the type of parameter in BazTest.
341 //
342 // INSTANTIATE_TEST_CASE_P(FloatingNumbers, BazTest, Values(1, 2, 3.5));
343 //
344 // Currently, Values() supports from 1 to $n parameters.
345 //
346 $range i 1..n
347 $for i [[
348 $range j 1..i
349 
350 template &lt;$for j, [[typename T$j]]&gt;
351 internal::ValueArray$i&lt;$for j, [[T$j]]&gt; Values($for j, [[T$j v$j]]) {
352   return internal::ValueArray$i&lt;$for j, [[T$j]]&gt;($for j, [[v$j]]);
353 }
354 
355 ]]
356 
357 // Bool() allows generating tests with parameters in a set of (false, true).
358 //
359 // Synopsis:
360 // Bool()
361 //   - returns a generator producing sequences with elements {false, true}.
362 //
363 // It is useful when testing code that depends on Boolean flags. Combinations
364 // of multiple flags can be tested when several Bool()&#39;s are combined using
365 // Combine() function.
366 //
367 // In the following example all tests in the test case FlagDependentTest
368 // will be instantiated twice with parameters false and true.
369 //
370 // class FlagDependentTest : public testing::TestWithParam&lt;bool&gt; {
371 //   virtual void SetUp() {
372 //     external_flag = GetParam();
373 //   }
374 // }
375 // INSTANTIATE_TEST_CASE_P(BoolSequence, FlagDependentTest, Bool());
376 //
377 inline internal::ParamGenerator&lt;bool&gt; Bool() {
378   return Values(false, true);
379 }
380 
381 # if GTEST_HAS_COMBINE
382 // Combine() allows the user to combine two or more sequences to produce
383 // values of a Cartesian product of those sequences&#39; elements.
384 //
385 // Synopsis:
386 // Combine(gen1, gen2, ..., genN)
387 //   - returns a generator producing sequences with elements coming from
388 //     the Cartesian product of elements from the sequences generated by
389 //     gen1, gen2, ..., genN. The sequence elements will have a type of
390 //     tuple&lt;T1, T2, ..., TN&gt; where T1, T2, ..., TN are the types
391 //     of elements from sequences produces by gen1, gen2, ..., genN.
392 //
393 // Combine can have up to $maxtuple arguments. This number is currently limited
394 // by the maximum number of elements in the tuple implementation used by Google
395 // Test.
396 //
397 // Example:
398 //
399 // This will instantiate tests in test case AnimalTest each one with
400 // the parameter values tuple(&quot;cat&quot;, BLACK), tuple(&quot;cat&quot;, WHITE),
401 // tuple(&quot;dog&quot;, BLACK), and tuple(&quot;dog&quot;, WHITE):
402 //
403 // enum Color { BLACK, GRAY, WHITE };
404 // class AnimalTest
405 //     : public testing::TestWithParam&lt;tuple&lt;const char*, Color&gt; &gt; {...};
406 //
407 // TEST_P(AnimalTest, AnimalLooksNice) {...}
408 //
409 // INSTANTIATE_TEST_CASE_P(AnimalVariations, AnimalTest,
410 //                         Combine(Values(&quot;cat&quot;, &quot;dog&quot;),
411 //                                 Values(BLACK, WHITE)));
412 //
413 // This will instantiate tests in FlagDependentTest with all variations of two
414 // Boolean flags:
415 //
416 // class FlagDependentTest
417 //     : public testing::TestWithParam&lt;tuple&lt;bool, bool&gt; &gt; {
418 //   virtual void SetUp() {
419 //     // Assigns external_flag_1 and external_flag_2 values from the tuple.
420 //     tie(external_flag_1, external_flag_2) = GetParam();
421 //   }
422 // };
423 //
424 // TEST_P(FlagDependentTest, TestFeature1) {
425 //   // Test your code using external_flag_1 and external_flag_2 here.
426 // }
427 // INSTANTIATE_TEST_CASE_P(TwoBoolSequence, FlagDependentTest,
428 //                         Combine(Bool(), Bool()));
429 //
430 $range i 2..maxtuple
431 $for i [[
432 $range j 1..i
433 
434 template &lt;$for j, [[typename Generator$j]]&gt;
435 internal::CartesianProductHolder$i&lt;$for j, [[Generator$j]]&gt; Combine(
436     $for j, [[const Generator$j&amp; g$j]]) {
437   return internal::CartesianProductHolder$i&lt;$for j, [[Generator$j]]&gt;(
438       $for j, [[g$j]]);
439 }
440 
441 ]]
442 # endif  // GTEST_HAS_COMBINE
443 
444 
445 
446 # define TEST_P(test_case_name, test_name) \
447   class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \
448       : public test_case_name { \
449    public: \
450     GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {} \
451     virtual void TestBody(); \
452    private: \
453     static int AddToRegistry() { \
454       ::testing::UnitTest::GetInstance()-&gt;parameterized_test_registry(). \
455           GetTestCasePatternHolder&lt;test_case_name&gt;(\
456               #test_case_name, __FILE__, __LINE__)-&gt;AddTestPattern(\
457                   #test_case_name, \
458                   #test_name, \
459                   new ::testing::internal::TestMetaFactory&lt; \
460                       GTEST_TEST_CLASS_NAME_(test_case_name, test_name)&gt;()); \
461       return 0; \
462     } \
463     static int gtest_registering_dummy_; \
464     GTEST_DISALLOW_COPY_AND_ASSIGN_(\
465         GTEST_TEST_CLASS_NAME_(test_case_name, test_name)); \
466   }; \
467   int GTEST_TEST_CLASS_NAME_(test_case_name, \
468                              test_name)::gtest_registering_dummy_ = \
469       GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::AddToRegistry(); \
470   void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()
471 
472 # define INSTANTIATE_TEST_CASE_P(prefix, test_case_name, generator) \
473   ::testing::internal::ParamGenerator&lt;test_case_name::ParamType&gt; \
474       gtest_##prefix##test_case_name##_EvalGenerator_() { return generator; } \
475   int gtest_##prefix##test_case_name##_dummy_ = \
476       ::testing::UnitTest::GetInstance()-&gt;parameterized_test_registry(). \
477           GetTestCasePatternHolder&lt;test_case_name&gt;(\
478               #test_case_name, __FILE__, __LINE__)-&gt;AddTestCaseInstantiation(\
479                   #prefix, \
480                   &amp;gtest_##prefix##test_case_name##_EvalGenerator_, \
481                   __FILE__, __LINE__)
482 
483 }  // namespace testing
484 
485 #endif  // GTEST_HAS_PARAM_TEST
486 
487 #endif  // GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_
    </pre>
  </body>
</html>
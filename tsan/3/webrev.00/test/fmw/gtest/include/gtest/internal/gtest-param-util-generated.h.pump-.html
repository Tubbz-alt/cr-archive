<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/include/gtest/internal/gtest-param-util-generated.h.pump</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 $$ -*- mode: c++; -*-
  2 $var n = 50  $$ Maximum length of Values arguments we want to support.
  3 $var maxtuple = 10  $$ Maximum number of Combine arguments we want to support.
  4 // Copyright 2008 Google Inc.
  5 // All Rights Reserved.
  6 //
  7 // Redistribution and use in source and binary forms, with or without
  8 // modification, are permitted provided that the following conditions are
  9 // met:
 10 //
 11 //     * Redistributions of source code must retain the above copyright
 12 // notice, this list of conditions and the following disclaimer.
 13 //     * Redistributions in binary form must reproduce the above
 14 // copyright notice, this list of conditions and the following disclaimer
 15 // in the documentation and/or other materials provided with the
 16 // distribution.
 17 //     * Neither the name of Google Inc. nor the names of its
 18 // contributors may be used to endorse or promote products derived from
 19 // this software without specific prior written permission.
 20 //
 21 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 22 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 23 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 24 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 25 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 26 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 27 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 28 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 29 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 30 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 31 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32 //
 33 // Author: vladl@google.com (Vlad Losev)
 34 
 35 // Type and function utilities for implementing parameterized tests.
 36 // This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!
 37 //
 38 // Currently Google Test supports at most $n arguments in Values,
 39 // and at most $maxtuple arguments in Combine. Please contact
 40 // googletestframework@googlegroups.com if you need more.
 41 // Please note that the number of arguments to Combine is limited
 42 // by the maximum arity of the implementation of tr1::tuple which is
 43 // currently set at $maxtuple.
 44 
 45 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_
 46 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_
 47 
 48 // scripts/fuse_gtest.py depends on gtest&#39;s own header being #included
 49 // *unconditionally*.  Therefore these #includes cannot be moved
 50 // inside #if GTEST_HAS_PARAM_TEST.
 51 #include &quot;gtest/internal/gtest-param-util.h&quot;
 52 #include &quot;gtest/internal/gtest-port.h&quot;
 53 
 54 #if GTEST_HAS_PARAM_TEST
 55 
 56 namespace testing {
 57 
 58 // Forward declarations of ValuesIn(), which is implemented in
 59 // include/gtest/gtest-param-test.h.
 60 template &lt;typename ForwardIterator&gt;
 61 internal::ParamGenerator&lt;
 62   typename ::testing::internal::IteratorTraits&lt;ForwardIterator&gt;::value_type&gt;
 63 ValuesIn(ForwardIterator begin, ForwardIterator end);
 64 
 65 template &lt;typename T, size_t N&gt;
 66 internal::ParamGenerator&lt;T&gt; ValuesIn(const T (&amp;array)[N]);
 67 
 68 template &lt;class Container&gt;
 69 internal::ParamGenerator&lt;typename Container::value_type&gt; ValuesIn(
 70     const Container&amp; container);
 71 
 72 namespace internal {
 73 
 74 // Used in the Values() function to provide polymorphic capabilities.
 75 template &lt;typename T1&gt;
 76 class ValueArray1 {
 77  public:
 78   explicit ValueArray1(T1 v1) : v1_(v1) {}
 79 
 80   template &lt;typename T&gt;
 81   operator ParamGenerator&lt;T&gt;() const { return ValuesIn(&amp;v1_, &amp;v1_ + 1); }
 82 
 83  private:
 84   // No implementation - assignment is unsupported.
 85   void operator=(const ValueArray1&amp; other);
 86 
 87   const T1 v1_;
 88 };
 89 
 90 $range i 2..n
 91 $for i [[
 92 $range j 1..i
 93 
 94 template &lt;$for j, [[typename T$j]]&gt;
 95 class ValueArray$i {
 96  public:
 97   ValueArray$i($for j, [[T$j v$j]]) : $for j, [[v$(j)_(v$j)]] {}
 98 
 99   template &lt;typename T&gt;
100   operator ParamGenerator&lt;T&gt;() const {
101     const T array[] = {$for j, [[static_cast&lt;T&gt;(v$(j)_)]]};
102     return ValuesIn(array);
103   }
104 
105  private:
106   // No implementation - assignment is unsupported.
107   void operator=(const ValueArray$i&amp; other);
108 
109 $for j [[
110 
111   const T$j v$(j)_;
112 ]]
113 
114 };
115 
116 ]]
117 
118 # if GTEST_HAS_COMBINE
119 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.
120 //
121 // Generates values from the Cartesian product of values produced
122 // by the argument generators.
123 //
124 $range i 2..maxtuple
125 $for i [[
126 $range j 1..i
127 $range k 2..i
128 
129 template &lt;$for j, [[typename T$j]]&gt;
130 class CartesianProductGenerator$i
131     : public ParamGeneratorInterface&lt; ::std::tr1::tuple&lt;$for j, [[T$j]]&gt; &gt; {
132  public:
133   typedef ::std::tr1::tuple&lt;$for j, [[T$j]]&gt; ParamType;
134 
135   CartesianProductGenerator$i($for j, [[const ParamGenerator&lt;T$j&gt;&amp; g$j]])
136       : $for j, [[g$(j)_(g$j)]] {}
137   virtual ~CartesianProductGenerator$i() {}
138 
139   virtual ParamIteratorInterface&lt;ParamType&gt;* Begin() const {
140     return new Iterator(this, $for j, [[g$(j)_, g$(j)_.begin()]]);
141   }
142   virtual ParamIteratorInterface&lt;ParamType&gt;* End() const {
143     return new Iterator(this, $for j, [[g$(j)_, g$(j)_.end()]]);
144   }
145 
146  private:
147   class Iterator : public ParamIteratorInterface&lt;ParamType&gt; {
148    public:
149     Iterator(const ParamGeneratorInterface&lt;ParamType&gt;* base, $for j, [[
150 
151       const ParamGenerator&lt;T$j&gt;&amp; g$j,
152       const typename ParamGenerator&lt;T$j&gt;::iterator&amp; current$(j)]])
153         : base_(base),
154 $for j, [[
155 
156           begin$(j)_(g$j.begin()), end$(j)_(g$j.end()), current$(j)_(current$j)
157 ]]    {
158       ComputeCurrentValue();
159     }
160     virtual ~Iterator() {}
161 
162     virtual const ParamGeneratorInterface&lt;ParamType&gt;* BaseGenerator() const {
163       return base_;
164     }
165     // Advance should not be called on beyond-of-range iterators
166     // so no component iterators must be beyond end of range, either.
167     virtual void Advance() {
168       assert(!AtEnd());
169       ++current$(i)_;
170 
171 $for k [[
172       if (current$(i+2-k)_ == end$(i+2-k)_) {
173         current$(i+2-k)_ = begin$(i+2-k)_;
174         ++current$(i+2-k-1)_;
175       }
176 
177 ]]
178       ComputeCurrentValue();
179     }
180     virtual ParamIteratorInterface&lt;ParamType&gt;* Clone() const {
181       return new Iterator(*this);
182     }
183     virtual const ParamType* Current() const { return &amp;current_value_; }
184     virtual bool Equals(const ParamIteratorInterface&lt;ParamType&gt;&amp; other) const {
185       // Having the same base generator guarantees that the other
186       // iterator is of the same type and we can downcast.
187       GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())
188           &lt;&lt; &quot;The program attempted to compare iterators &quot;
189           &lt;&lt; &quot;from different generators.&quot; &lt;&lt; std::endl;
190       const Iterator* typed_other =
191           CheckedDowncastToActualType&lt;const Iterator&gt;(&amp;other);
192       // We must report iterators equal if they both point beyond their
193       // respective ranges. That can happen in a variety of fashions,
194       // so we have to consult AtEnd().
195       return (AtEnd() &amp;&amp; typed_other-&gt;AtEnd()) ||
196          ($for j  &amp;&amp; [[
197 
198           current$(j)_ == typed_other-&gt;current$(j)_
199 ]]);
200     }
201 
202    private:
203     Iterator(const Iterator&amp; other)
204         : base_(other.base_), $for j, [[
205 
206         begin$(j)_(other.begin$(j)_),
207         end$(j)_(other.end$(j)_),
208         current$(j)_(other.current$(j)_)
209 ]] {
210       ComputeCurrentValue();
211     }
212 
213     void ComputeCurrentValue() {
214       if (!AtEnd())
215         current_value_ = ParamType($for j, [[*current$(j)_]]);
216     }
217     bool AtEnd() const {
218       // We must report iterator past the end of the range when either of the
219       // component iterators has reached the end of its range.
220       return
221 $for j  || [[
222 
223           current$(j)_ == end$(j)_
224 ]];
225     }
226 
227     // No implementation - assignment is unsupported.
228     void operator=(const Iterator&amp; other);
229 
230     const ParamGeneratorInterface&lt;ParamType&gt;* const base_;
231     // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.
232     // current[i]_ is the actual traversing iterator.
233 $for j [[
234 
235     const typename ParamGenerator&lt;T$j&gt;::iterator begin$(j)_;
236     const typename ParamGenerator&lt;T$j&gt;::iterator end$(j)_;
237     typename ParamGenerator&lt;T$j&gt;::iterator current$(j)_;
238 ]]
239 
240     ParamType current_value_;
241   };  // class CartesianProductGenerator$i::Iterator
242 
243   // No implementation - assignment is unsupported.
244   void operator=(const CartesianProductGenerator$i&amp; other);
245 
246 
247 $for j [[
248   const ParamGenerator&lt;T$j&gt; g$(j)_;
249 
250 ]]
251 };  // class CartesianProductGenerator$i
252 
253 
254 ]]
255 
256 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.
257 //
258 // Helper classes providing Combine() with polymorphic features. They allow
259 // casting CartesianProductGeneratorN&lt;T&gt; to ParamGenerator&lt;U&gt; if T is
260 // convertible to U.
261 //
262 $range i 2..maxtuple
263 $for i [[
264 $range j 1..i
265 
266 template &lt;$for j, [[class Generator$j]]&gt;
267 class CartesianProductHolder$i {
268  public:
269 CartesianProductHolder$i($for j, [[const Generator$j&amp; g$j]])
270       : $for j, [[g$(j)_(g$j)]] {}
271   template &lt;$for j, [[typename T$j]]&gt;
272   operator ParamGenerator&lt; ::std::tr1::tuple&lt;$for j, [[T$j]]&gt; &gt;() const {
273     return ParamGenerator&lt; ::std::tr1::tuple&lt;$for j, [[T$j]]&gt; &gt;(
274         new CartesianProductGenerator$i&lt;$for j, [[T$j]]&gt;(
275 $for j,[[
276 
277         static_cast&lt;ParamGenerator&lt;T$j&gt; &gt;(g$(j)_)
278 ]]));
279   }
280 
281  private:
282   // No implementation - assignment is unsupported.
283   void operator=(const CartesianProductHolder$i&amp; other);
284 
285 
286 $for j [[
287   const Generator$j g$(j)_;
288 
289 ]]
290 };  // class CartesianProductHolder$i
291 
292 ]]
293 
294 # endif  // GTEST_HAS_COMBINE
295 
296 }  // namespace internal
297 }  // namespace testing
298 
299 #endif  //  GTEST_HAS_PARAM_TEST
300 
301 #endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/include/gtest/internal/gtest-linked_ptr.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Copyright 2003 Google Inc.
  2 // All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //     * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //     * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //     * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 //
 30 // Authors: Dan Egnor (egnor@google.com)
 31 //
 32 // A &quot;smart&quot; pointer type with reference tracking.  Every pointer to a
 33 // particular object is kept on a circular linked list.  When the last pointer
 34 // to an object is destroyed or reassigned, the object is deleted.
 35 //
 36 // Used properly, this deletes the object when the last reference goes away.
 37 // There are several caveats:
 38 // - Like all reference counting schemes, cycles lead to leaks.
 39 // - Each smart pointer is actually two pointers (8 bytes instead of 4).
 40 // - Every time a pointer is assigned, the entire list of pointers to that
 41 //   object is traversed.  This class is therefore NOT SUITABLE when there
 42 //   will often be more than two or three pointers to a particular object.
 43 // - References are only tracked as long as linked_ptr&lt;&gt; objects are copied.
 44 //   If a linked_ptr&lt;&gt; is converted to a raw pointer and back, BAD THINGS
 45 //   will happen (double deletion).
 46 //
 47 // A good use of this class is storing object references in STL containers.
 48 // You can safely put linked_ptr&lt;&gt; in a vector&lt;&gt;.
 49 // Other uses may not be as good.
 50 //
 51 // Note: If you use an incomplete type with linked_ptr&lt;&gt;, the class
 52 // *containing* linked_ptr&lt;&gt; must have a constructor and destructor (even
 53 // if they do nothing!).
 54 //
 55 // Bill Gibbons suggested we use something like this.
 56 //
 57 // Thread Safety:
 58 //   Unlike other linked_ptr implementations, in this implementation
 59 //   a linked_ptr object is thread-safe in the sense that:
 60 //     - it&#39;s safe to copy linked_ptr objects concurrently,
 61 //     - it&#39;s safe to copy *from* a linked_ptr and read its underlying
 62 //       raw pointer (e.g. via get()) concurrently, and
 63 //     - it&#39;s safe to write to two linked_ptrs that point to the same
 64 //       shared object concurrently.
 65 // TODO(wan@google.com): rename this to safe_linked_ptr to avoid
 66 // confusion with normal linked_ptr.
 67 
 68 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_
 69 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_
 70 
 71 #include &lt;stdlib.h&gt;
 72 #include &lt;assert.h&gt;
 73 
 74 #include &quot;gtest/internal/gtest-port.h&quot;
 75 
 76 namespace testing {
 77 namespace internal {
 78 
 79 // Protects copying of all linked_ptr objects.
 80 GTEST_API_ GTEST_DECLARE_STATIC_MUTEX_(g_linked_ptr_mutex);
 81 
 82 // This is used internally by all instances of linked_ptr&lt;&gt;.  It needs to be
 83 // a non-template class because different types of linked_ptr&lt;&gt; can refer to
 84 // the same object (linked_ptr&lt;Superclass&gt;(obj) vs linked_ptr&lt;Subclass&gt;(obj)).
 85 // So, it needs to be possible for different types of linked_ptr to participate
 86 // in the same circular linked list, so we need a single class type here.
 87 //
 88 // DO NOT USE THIS CLASS DIRECTLY YOURSELF.  Use linked_ptr&lt;T&gt;.
 89 class linked_ptr_internal {
 90  public:
 91   // Create a new circle that includes only this instance.
 92   void join_new() {
 93     next_ = this;
 94   }
 95 
 96   // Many linked_ptr operations may change p.link_ for some linked_ptr
 97   // variable p in the same circle as this object.  Therefore we need
 98   // to prevent two such operations from occurring concurrently.
 99   //
100   // Note that different types of linked_ptr objects can coexist in a
101   // circle (e.g. linked_ptr&lt;Base&gt;, linked_ptr&lt;Derived1&gt;, and
102   // linked_ptr&lt;Derived2&gt;).  Therefore we must use a single mutex to
103   // protect all linked_ptr objects.  This can create serious
104   // contention in production code, but is acceptable in a testing
105   // framework.
106 
107   // Join an existing circle.
108   void join(linked_ptr_internal const* ptr)
109       GTEST_LOCK_EXCLUDED_(g_linked_ptr_mutex) {
110     MutexLock lock(&amp;g_linked_ptr_mutex);
111 
112     linked_ptr_internal const* p = ptr;
113     while (p-&gt;next_ != ptr) p = p-&gt;next_;
114     p-&gt;next_ = this;
115     next_ = ptr;
116   }
117 
118   // Leave whatever circle we&#39;re part of.  Returns true if we were the
119   // last member of the circle.  Once this is done, you can join() another.
120   bool depart()
121       GTEST_LOCK_EXCLUDED_(g_linked_ptr_mutex) {
122     MutexLock lock(&amp;g_linked_ptr_mutex);
123 
124     if (next_ == this) return true;
125     linked_ptr_internal const* p = next_;
126     while (p-&gt;next_ != this) p = p-&gt;next_;
127     p-&gt;next_ = next_;
128     return false;
129   }
130 
131  private:
132   mutable linked_ptr_internal const* next_;
133 };
134 
135 template &lt;typename T&gt;
136 class linked_ptr {
137  public:
138   typedef T element_type;
139 
140   // Take over ownership of a raw pointer.  This should happen as soon as
141   // possible after the object is created.
142   explicit linked_ptr(T* ptr = NULL) { capture(ptr); }
143   ~linked_ptr() { depart(); }
144 
145   // Copy an existing linked_ptr&lt;&gt;, adding ourselves to the list of references.
146   template &lt;typename U&gt; linked_ptr(linked_ptr&lt;U&gt; const&amp; ptr) { copy(&amp;ptr); }
147   linked_ptr(linked_ptr const&amp; ptr) {  // NOLINT
148     assert(&amp;ptr != this);
149     copy(&amp;ptr);
150   }
151 
152   // Assignment releases the old value and acquires the new.
153   template &lt;typename U&gt; linked_ptr&amp; operator=(linked_ptr&lt;U&gt; const&amp; ptr) {
154     depart();
155     copy(&amp;ptr);
156     return *this;
157   }
158 
159   linked_ptr&amp; operator=(linked_ptr const&amp; ptr) {
160     if (&amp;ptr != this) {
161       depart();
162       copy(&amp;ptr);
163     }
164     return *this;
165   }
166 
167   // Smart pointer members.
168   void reset(T* ptr = NULL) {
169     depart();
170     capture(ptr);
171   }
172   T* get() const { return value_; }
173   T* operator-&gt;() const { return value_; }
174   T&amp; operator*() const { return *value_; }
175 
176   bool operator==(T* p) const { return value_ == p; }
177   bool operator!=(T* p) const { return value_ != p; }
178   template &lt;typename U&gt;
179   bool operator==(linked_ptr&lt;U&gt; const&amp; ptr) const {
180     return value_ == ptr.get();
181   }
182   template &lt;typename U&gt;
183   bool operator!=(linked_ptr&lt;U&gt; const&amp; ptr) const {
184     return value_ != ptr.get();
185   }
186 
187  private:
188   template &lt;typename U&gt;
189   friend class linked_ptr;
190 
191   T* value_;
192   linked_ptr_internal link_;
193 
194   void depart() {
195     if (link_.depart()) delete value_;
196   }
197 
198   void capture(T* ptr) {
199     value_ = ptr;
200     link_.join_new();
201   }
202 
203   template &lt;typename U&gt; void copy(linked_ptr&lt;U&gt; const* ptr) {
204     value_ = ptr-&gt;get();
205     if (value_)
206       link_.join(&amp;ptr-&gt;link_);
207     else
208       link_.join_new();
209   }
210 };
211 
212 template&lt;typename T&gt; inline
213 bool operator==(T* ptr, const linked_ptr&lt;T&gt;&amp; x) {
214   return ptr == x.get();
215 }
216 
217 template&lt;typename T&gt; inline
218 bool operator!=(T* ptr, const linked_ptr&lt;T&gt;&amp; x) {
219   return ptr != x.get();
220 }
221 
222 // A function to convert T* into linked_ptr&lt;T&gt;
223 // Doing e.g. make_linked_ptr(new FooBarBaz&lt;type&gt;(arg)) is a shorter notation
224 // for linked_ptr&lt;FooBarBaz&lt;type&gt; &gt;(new FooBarBaz&lt;type&gt;(arg))
225 template &lt;typename T&gt;
226 linked_ptr&lt;T&gt; make_linked_ptr(T* ptr) {
227   return linked_ptr&lt;T&gt;(ptr);
228 }
229 
230 }  // namespace internal
231 }  // namespace testing
232 
233 #endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_
    </pre>
  </body>
</html>
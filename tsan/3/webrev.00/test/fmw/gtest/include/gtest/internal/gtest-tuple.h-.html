<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/include/gtest/internal/gtest-tuple.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // This file was GENERATED by command:
   2 //     pump.py gtest-tuple.h.pump
   3 // DO NOT EDIT BY HAND!!!
   4 
   5 // Copyright 2009 Google Inc.
   6 // All Rights Reserved.
   7 //
   8 // Redistribution and use in source and binary forms, with or without
   9 // modification, are permitted provided that the following conditions are
  10 // met:
  11 //
  12 //     * Redistributions of source code must retain the above copyright
  13 // notice, this list of conditions and the following disclaimer.
  14 //     * Redistributions in binary form must reproduce the above
  15 // copyright notice, this list of conditions and the following disclaimer
  16 // in the documentation and/or other materials provided with the
  17 // distribution.
  18 //     * Neither the name of Google Inc. nor the names of its
  19 // contributors may be used to endorse or promote products derived from
  20 // this software without specific prior written permission.
  21 //
  22 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  23 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  24 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  25 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  26 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  27 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  28 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  29 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  30 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  32 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33 //
  34 // Author: wan@google.com (Zhanyong Wan)
  35 
  36 // Implements a subset of TR1 tuple needed by Google Test and Google Mock.
  37 
  38 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TUPLE_H_
  39 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TUPLE_H_
  40 
  41 #include &lt;utility&gt;  // For ::std::pair.
  42 
  43 // The compiler used in Symbian has a bug that prevents us from declaring the
  44 // tuple template as a friend (it complains that tuple is redefined).  This
  45 // hack bypasses the bug by declaring the members that should otherwise be
  46 // private as public.
  47 // Sun Studio versions &lt; 12 also have the above bug.
  48 #if defined(__SYMBIAN32__) || (defined(__SUNPRO_CC) &amp;&amp; __SUNPRO_CC &lt; 0x590)
  49 # define GTEST_DECLARE_TUPLE_AS_FRIEND_ public:
  50 #else
  51 # define GTEST_DECLARE_TUPLE_AS_FRIEND_ \
  52     template &lt;GTEST_10_TYPENAMES_(U)&gt; friend class tuple; \
  53    private:
  54 #endif
  55 
  56 // GTEST_n_TUPLE_(T) is the type of an n-tuple.
  57 #define GTEST_0_TUPLE_(T) tuple&lt;&gt;
  58 #define GTEST_1_TUPLE_(T) tuple&lt;T##0, void, void, void, void, void, void, \
  59     void, void, void&gt;
  60 #define GTEST_2_TUPLE_(T) tuple&lt;T##0, T##1, void, void, void, void, void, \
  61     void, void, void&gt;
  62 #define GTEST_3_TUPLE_(T) tuple&lt;T##0, T##1, T##2, void, void, void, void, \
  63     void, void, void&gt;
  64 #define GTEST_4_TUPLE_(T) tuple&lt;T##0, T##1, T##2, T##3, void, void, void, \
  65     void, void, void&gt;
  66 #define GTEST_5_TUPLE_(T) tuple&lt;T##0, T##1, T##2, T##3, T##4, void, void, \
  67     void, void, void&gt;
  68 #define GTEST_6_TUPLE_(T) tuple&lt;T##0, T##1, T##2, T##3, T##4, T##5, void, \
  69     void, void, void&gt;
  70 #define GTEST_7_TUPLE_(T) tuple&lt;T##0, T##1, T##2, T##3, T##4, T##5, T##6, \
  71     void, void, void&gt;
  72 #define GTEST_8_TUPLE_(T) tuple&lt;T##0, T##1, T##2, T##3, T##4, T##5, T##6, \
  73     T##7, void, void&gt;
  74 #define GTEST_9_TUPLE_(T) tuple&lt;T##0, T##1, T##2, T##3, T##4, T##5, T##6, \
  75     T##7, T##8, void&gt;
  76 #define GTEST_10_TUPLE_(T) tuple&lt;T##0, T##1, T##2, T##3, T##4, T##5, T##6, \
  77     T##7, T##8, T##9&gt;
  78 
  79 // GTEST_n_TYPENAMES_(T) declares a list of n typenames.
  80 #define GTEST_0_TYPENAMES_(T)
  81 #define GTEST_1_TYPENAMES_(T) typename T##0
  82 #define GTEST_2_TYPENAMES_(T) typename T##0, typename T##1
  83 #define GTEST_3_TYPENAMES_(T) typename T##0, typename T##1, typename T##2
  84 #define GTEST_4_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \
  85     typename T##3
  86 #define GTEST_5_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \
  87     typename T##3, typename T##4
  88 #define GTEST_6_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \
  89     typename T##3, typename T##4, typename T##5
  90 #define GTEST_7_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \
  91     typename T##3, typename T##4, typename T##5, typename T##6
  92 #define GTEST_8_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \
  93     typename T##3, typename T##4, typename T##5, typename T##6, typename T##7
  94 #define GTEST_9_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \
  95     typename T##3, typename T##4, typename T##5, typename T##6, \
  96     typename T##7, typename T##8
  97 #define GTEST_10_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \
  98     typename T##3, typename T##4, typename T##5, typename T##6, \
  99     typename T##7, typename T##8, typename T##9
 100 
 101 // In theory, defining stuff in the ::std namespace is undefined
 102 // behavior.  We can do this as we are playing the role of a standard
 103 // library vendor.
 104 namespace std {
 105 namespace tr1 {
 106 
 107 template &lt;typename T0 = void, typename T1 = void, typename T2 = void,
 108     typename T3 = void, typename T4 = void, typename T5 = void,
 109     typename T6 = void, typename T7 = void, typename T8 = void,
 110     typename T9 = void&gt;
 111 class tuple;
 112 
 113 // Anything in namespace gtest_internal is Google Test&#39;s INTERNAL
 114 // IMPLEMENTATION DETAIL and MUST NOT BE USED DIRECTLY in user code.
 115 namespace gtest_internal {
 116 
 117 // ByRef&lt;T&gt;::type is T if T is a reference; otherwise it&#39;s const T&amp;.
 118 template &lt;typename T&gt;
 119 struct ByRef { typedef const T&amp; type; };  // NOLINT
 120 template &lt;typename T&gt;
 121 struct ByRef&lt;T&amp;&gt; { typedef T&amp; type; };  // NOLINT
 122 
 123 // A handy wrapper for ByRef.
 124 #define GTEST_BY_REF_(T) typename ::std::tr1::gtest_internal::ByRef&lt;T&gt;::type
 125 
 126 // AddRef&lt;T&gt;::type is T if T is a reference; otherwise it&#39;s T&amp;.  This
 127 // is the same as tr1::add_reference&lt;T&gt;::type.
 128 template &lt;typename T&gt;
 129 struct AddRef { typedef T&amp; type; };  // NOLINT
 130 template &lt;typename T&gt;
 131 struct AddRef&lt;T&amp;&gt; { typedef T&amp; type; };  // NOLINT
 132 
 133 // A handy wrapper for AddRef.
 134 #define GTEST_ADD_REF_(T) typename ::std::tr1::gtest_internal::AddRef&lt;T&gt;::type
 135 
 136 // A helper for implementing get&lt;k&gt;().
 137 template &lt;int k&gt; class Get;
 138 
 139 // A helper for implementing tuple_element&lt;k, T&gt;.  kIndexValid is true
 140 // iff k &lt; the number of fields in tuple type T.
 141 template &lt;bool kIndexValid, int kIndex, class Tuple&gt;
 142 struct TupleElement;
 143 
 144 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 145 struct TupleElement&lt;true, 0, GTEST_10_TUPLE_(T) &gt; {
 146   typedef T0 type;
 147 };
 148 
 149 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 150 struct TupleElement&lt;true, 1, GTEST_10_TUPLE_(T) &gt; {
 151   typedef T1 type;
 152 };
 153 
 154 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 155 struct TupleElement&lt;true, 2, GTEST_10_TUPLE_(T) &gt; {
 156   typedef T2 type;
 157 };
 158 
 159 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 160 struct TupleElement&lt;true, 3, GTEST_10_TUPLE_(T) &gt; {
 161   typedef T3 type;
 162 };
 163 
 164 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 165 struct TupleElement&lt;true, 4, GTEST_10_TUPLE_(T) &gt; {
 166   typedef T4 type;
 167 };
 168 
 169 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 170 struct TupleElement&lt;true, 5, GTEST_10_TUPLE_(T) &gt; {
 171   typedef T5 type;
 172 };
 173 
 174 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 175 struct TupleElement&lt;true, 6, GTEST_10_TUPLE_(T) &gt; {
 176   typedef T6 type;
 177 };
 178 
 179 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 180 struct TupleElement&lt;true, 7, GTEST_10_TUPLE_(T) &gt; {
 181   typedef T7 type;
 182 };
 183 
 184 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 185 struct TupleElement&lt;true, 8, GTEST_10_TUPLE_(T) &gt; {
 186   typedef T8 type;
 187 };
 188 
 189 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 190 struct TupleElement&lt;true, 9, GTEST_10_TUPLE_(T) &gt; {
 191   typedef T9 type;
 192 };
 193 
 194 }  // namespace gtest_internal
 195 
 196 template &lt;&gt;
 197 class tuple&lt;&gt; {
 198  public:
 199   tuple() {}
 200   tuple(const tuple&amp; /* t */)  {}
 201   tuple&amp; operator=(const tuple&amp; /* t */) { return *this; }
 202 };
 203 
 204 template &lt;GTEST_1_TYPENAMES_(T)&gt;
 205 class GTEST_1_TUPLE_(T) {
 206  public:
 207   template &lt;int k&gt; friend class gtest_internal::Get;
 208 
 209   tuple() : f0_() {}
 210 
 211   explicit tuple(GTEST_BY_REF_(T0) f0) : f0_(f0) {}
 212 
 213   tuple(const tuple&amp; t) : f0_(t.f0_) {}
 214 
 215   template &lt;GTEST_1_TYPENAMES_(U)&gt;
 216   tuple(const GTEST_1_TUPLE_(U)&amp; t) : f0_(t.f0_) {}
 217 
 218   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 219 
 220   template &lt;GTEST_1_TYPENAMES_(U)&gt;
 221   tuple&amp; operator=(const GTEST_1_TUPLE_(U)&amp; t) {
 222     return CopyFrom(t);
 223   }
 224 
 225   GTEST_DECLARE_TUPLE_AS_FRIEND_
 226 
 227   template &lt;GTEST_1_TYPENAMES_(U)&gt;
 228   tuple&amp; CopyFrom(const GTEST_1_TUPLE_(U)&amp; t) {
 229     f0_ = t.f0_;
 230     return *this;
 231   }
 232 
 233   T0 f0_;
 234 };
 235 
 236 template &lt;GTEST_2_TYPENAMES_(T)&gt;
 237 class GTEST_2_TUPLE_(T) {
 238  public:
 239   template &lt;int k&gt; friend class gtest_internal::Get;
 240 
 241   tuple() : f0_(), f1_() {}
 242 
 243   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1) : f0_(f0),
 244       f1_(f1) {}
 245 
 246   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_) {}
 247 
 248   template &lt;GTEST_2_TYPENAMES_(U)&gt;
 249   tuple(const GTEST_2_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_) {}
 250   template &lt;typename U0, typename U1&gt;
 251   tuple(const ::std::pair&lt;U0, U1&gt;&amp; p) : f0_(p.first), f1_(p.second) {}
 252 
 253   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 254 
 255   template &lt;GTEST_2_TYPENAMES_(U)&gt;
 256   tuple&amp; operator=(const GTEST_2_TUPLE_(U)&amp; t) {
 257     return CopyFrom(t);
 258   }
 259   template &lt;typename U0, typename U1&gt;
 260   tuple&amp; operator=(const ::std::pair&lt;U0, U1&gt;&amp; p) {
 261     f0_ = p.first;
 262     f1_ = p.second;
 263     return *this;
 264   }
 265 
 266   GTEST_DECLARE_TUPLE_AS_FRIEND_
 267 
 268   template &lt;GTEST_2_TYPENAMES_(U)&gt;
 269   tuple&amp; CopyFrom(const GTEST_2_TUPLE_(U)&amp; t) {
 270     f0_ = t.f0_;
 271     f1_ = t.f1_;
 272     return *this;
 273   }
 274 
 275   T0 f0_;
 276   T1 f1_;
 277 };
 278 
 279 template &lt;GTEST_3_TYPENAMES_(T)&gt;
 280 class GTEST_3_TUPLE_(T) {
 281  public:
 282   template &lt;int k&gt; friend class gtest_internal::Get;
 283 
 284   tuple() : f0_(), f1_(), f2_() {}
 285 
 286   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 287       GTEST_BY_REF_(T2) f2) : f0_(f0), f1_(f1), f2_(f2) {}
 288 
 289   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_) {}
 290 
 291   template &lt;GTEST_3_TYPENAMES_(U)&gt;
 292   tuple(const GTEST_3_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_) {}
 293 
 294   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 295 
 296   template &lt;GTEST_3_TYPENAMES_(U)&gt;
 297   tuple&amp; operator=(const GTEST_3_TUPLE_(U)&amp; t) {
 298     return CopyFrom(t);
 299   }
 300 
 301   GTEST_DECLARE_TUPLE_AS_FRIEND_
 302 
 303   template &lt;GTEST_3_TYPENAMES_(U)&gt;
 304   tuple&amp; CopyFrom(const GTEST_3_TUPLE_(U)&amp; t) {
 305     f0_ = t.f0_;
 306     f1_ = t.f1_;
 307     f2_ = t.f2_;
 308     return *this;
 309   }
 310 
 311   T0 f0_;
 312   T1 f1_;
 313   T2 f2_;
 314 };
 315 
 316 template &lt;GTEST_4_TYPENAMES_(T)&gt;
 317 class GTEST_4_TUPLE_(T) {
 318  public:
 319   template &lt;int k&gt; friend class gtest_internal::Get;
 320 
 321   tuple() : f0_(), f1_(), f2_(), f3_() {}
 322 
 323   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 324       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3) : f0_(f0), f1_(f1), f2_(f2),
 325       f3_(f3) {}
 326 
 327   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_) {}
 328 
 329   template &lt;GTEST_4_TYPENAMES_(U)&gt;
 330   tuple(const GTEST_4_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),
 331       f3_(t.f3_) {}
 332 
 333   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 334 
 335   template &lt;GTEST_4_TYPENAMES_(U)&gt;
 336   tuple&amp; operator=(const GTEST_4_TUPLE_(U)&amp; t) {
 337     return CopyFrom(t);
 338   }
 339 
 340   GTEST_DECLARE_TUPLE_AS_FRIEND_
 341 
 342   template &lt;GTEST_4_TYPENAMES_(U)&gt;
 343   tuple&amp; CopyFrom(const GTEST_4_TUPLE_(U)&amp; t) {
 344     f0_ = t.f0_;
 345     f1_ = t.f1_;
 346     f2_ = t.f2_;
 347     f3_ = t.f3_;
 348     return *this;
 349   }
 350 
 351   T0 f0_;
 352   T1 f1_;
 353   T2 f2_;
 354   T3 f3_;
 355 };
 356 
 357 template &lt;GTEST_5_TYPENAMES_(T)&gt;
 358 class GTEST_5_TUPLE_(T) {
 359  public:
 360   template &lt;int k&gt; friend class gtest_internal::Get;
 361 
 362   tuple() : f0_(), f1_(), f2_(), f3_(), f4_() {}
 363 
 364   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 365       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3,
 366       GTEST_BY_REF_(T4) f4) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4) {}
 367 
 368   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),
 369       f4_(t.f4_) {}
 370 
 371   template &lt;GTEST_5_TYPENAMES_(U)&gt;
 372   tuple(const GTEST_5_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),
 373       f3_(t.f3_), f4_(t.f4_) {}
 374 
 375   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 376 
 377   template &lt;GTEST_5_TYPENAMES_(U)&gt;
 378   tuple&amp; operator=(const GTEST_5_TUPLE_(U)&amp; t) {
 379     return CopyFrom(t);
 380   }
 381 
 382   GTEST_DECLARE_TUPLE_AS_FRIEND_
 383 
 384   template &lt;GTEST_5_TYPENAMES_(U)&gt;
 385   tuple&amp; CopyFrom(const GTEST_5_TUPLE_(U)&amp; t) {
 386     f0_ = t.f0_;
 387     f1_ = t.f1_;
 388     f2_ = t.f2_;
 389     f3_ = t.f3_;
 390     f4_ = t.f4_;
 391     return *this;
 392   }
 393 
 394   T0 f0_;
 395   T1 f1_;
 396   T2 f2_;
 397   T3 f3_;
 398   T4 f4_;
 399 };
 400 
 401 template &lt;GTEST_6_TYPENAMES_(T)&gt;
 402 class GTEST_6_TUPLE_(T) {
 403  public:
 404   template &lt;int k&gt; friend class gtest_internal::Get;
 405 
 406   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_() {}
 407 
 408   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 409       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,
 410       GTEST_BY_REF_(T5) f5) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4),
 411       f5_(f5) {}
 412 
 413   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),
 414       f4_(t.f4_), f5_(t.f5_) {}
 415 
 416   template &lt;GTEST_6_TYPENAMES_(U)&gt;
 417   tuple(const GTEST_6_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),
 418       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_) {}
 419 
 420   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 421 
 422   template &lt;GTEST_6_TYPENAMES_(U)&gt;
 423   tuple&amp; operator=(const GTEST_6_TUPLE_(U)&amp; t) {
 424     return CopyFrom(t);
 425   }
 426 
 427   GTEST_DECLARE_TUPLE_AS_FRIEND_
 428 
 429   template &lt;GTEST_6_TYPENAMES_(U)&gt;
 430   tuple&amp; CopyFrom(const GTEST_6_TUPLE_(U)&amp; t) {
 431     f0_ = t.f0_;
 432     f1_ = t.f1_;
 433     f2_ = t.f2_;
 434     f3_ = t.f3_;
 435     f4_ = t.f4_;
 436     f5_ = t.f5_;
 437     return *this;
 438   }
 439 
 440   T0 f0_;
 441   T1 f1_;
 442   T2 f2_;
 443   T3 f3_;
 444   T4 f4_;
 445   T5 f5_;
 446 };
 447 
 448 template &lt;GTEST_7_TYPENAMES_(T)&gt;
 449 class GTEST_7_TUPLE_(T) {
 450  public:
 451   template &lt;int k&gt; friend class gtest_internal::Get;
 452 
 453   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_() {}
 454 
 455   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 456       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,
 457       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6) : f0_(f0), f1_(f1), f2_(f2),
 458       f3_(f3), f4_(f4), f5_(f5), f6_(f6) {}
 459 
 460   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),
 461       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_) {}
 462 
 463   template &lt;GTEST_7_TYPENAMES_(U)&gt;
 464   tuple(const GTEST_7_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),
 465       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_) {}
 466 
 467   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 468 
 469   template &lt;GTEST_7_TYPENAMES_(U)&gt;
 470   tuple&amp; operator=(const GTEST_7_TUPLE_(U)&amp; t) {
 471     return CopyFrom(t);
 472   }
 473 
 474   GTEST_DECLARE_TUPLE_AS_FRIEND_
 475 
 476   template &lt;GTEST_7_TYPENAMES_(U)&gt;
 477   tuple&amp; CopyFrom(const GTEST_7_TUPLE_(U)&amp; t) {
 478     f0_ = t.f0_;
 479     f1_ = t.f1_;
 480     f2_ = t.f2_;
 481     f3_ = t.f3_;
 482     f4_ = t.f4_;
 483     f5_ = t.f5_;
 484     f6_ = t.f6_;
 485     return *this;
 486   }
 487 
 488   T0 f0_;
 489   T1 f1_;
 490   T2 f2_;
 491   T3 f3_;
 492   T4 f4_;
 493   T5 f5_;
 494   T6 f6_;
 495 };
 496 
 497 template &lt;GTEST_8_TYPENAMES_(T)&gt;
 498 class GTEST_8_TUPLE_(T) {
 499  public:
 500   template &lt;int k&gt; friend class gtest_internal::Get;
 501 
 502   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_(), f7_() {}
 503 
 504   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 505       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,
 506       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6,
 507       GTEST_BY_REF_(T7) f7) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4),
 508       f5_(f5), f6_(f6), f7_(f7) {}
 509 
 510   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),
 511       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_) {}
 512 
 513   template &lt;GTEST_8_TYPENAMES_(U)&gt;
 514   tuple(const GTEST_8_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),
 515       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_) {}
 516 
 517   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 518 
 519   template &lt;GTEST_8_TYPENAMES_(U)&gt;
 520   tuple&amp; operator=(const GTEST_8_TUPLE_(U)&amp; t) {
 521     return CopyFrom(t);
 522   }
 523 
 524   GTEST_DECLARE_TUPLE_AS_FRIEND_
 525 
 526   template &lt;GTEST_8_TYPENAMES_(U)&gt;
 527   tuple&amp; CopyFrom(const GTEST_8_TUPLE_(U)&amp; t) {
 528     f0_ = t.f0_;
 529     f1_ = t.f1_;
 530     f2_ = t.f2_;
 531     f3_ = t.f3_;
 532     f4_ = t.f4_;
 533     f5_ = t.f5_;
 534     f6_ = t.f6_;
 535     f7_ = t.f7_;
 536     return *this;
 537   }
 538 
 539   T0 f0_;
 540   T1 f1_;
 541   T2 f2_;
 542   T3 f3_;
 543   T4 f4_;
 544   T5 f5_;
 545   T6 f6_;
 546   T7 f7_;
 547 };
 548 
 549 template &lt;GTEST_9_TYPENAMES_(T)&gt;
 550 class GTEST_9_TUPLE_(T) {
 551  public:
 552   template &lt;int k&gt; friend class gtest_internal::Get;
 553 
 554   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_(), f7_(), f8_() {}
 555 
 556   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 557       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,
 558       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6, GTEST_BY_REF_(T7) f7,
 559       GTEST_BY_REF_(T8) f8) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4),
 560       f5_(f5), f6_(f6), f7_(f7), f8_(f8) {}
 561 
 562   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),
 563       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_) {}
 564 
 565   template &lt;GTEST_9_TYPENAMES_(U)&gt;
 566   tuple(const GTEST_9_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),
 567       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_) {}
 568 
 569   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 570 
 571   template &lt;GTEST_9_TYPENAMES_(U)&gt;
 572   tuple&amp; operator=(const GTEST_9_TUPLE_(U)&amp; t) {
 573     return CopyFrom(t);
 574   }
 575 
 576   GTEST_DECLARE_TUPLE_AS_FRIEND_
 577 
 578   template &lt;GTEST_9_TYPENAMES_(U)&gt;
 579   tuple&amp; CopyFrom(const GTEST_9_TUPLE_(U)&amp; t) {
 580     f0_ = t.f0_;
 581     f1_ = t.f1_;
 582     f2_ = t.f2_;
 583     f3_ = t.f3_;
 584     f4_ = t.f4_;
 585     f5_ = t.f5_;
 586     f6_ = t.f6_;
 587     f7_ = t.f7_;
 588     f8_ = t.f8_;
 589     return *this;
 590   }
 591 
 592   T0 f0_;
 593   T1 f1_;
 594   T2 f2_;
 595   T3 f3_;
 596   T4 f4_;
 597   T5 f5_;
 598   T6 f6_;
 599   T7 f7_;
 600   T8 f8_;
 601 };
 602 
 603 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 604 class tuple {
 605  public:
 606   template &lt;int k&gt; friend class gtest_internal::Get;
 607 
 608   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_(), f7_(), f8_(),
 609       f9_() {}
 610 
 611   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 612       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,
 613       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6, GTEST_BY_REF_(T7) f7,
 614       GTEST_BY_REF_(T8) f8, GTEST_BY_REF_(T9) f9) : f0_(f0), f1_(f1), f2_(f2),
 615       f3_(f3), f4_(f4), f5_(f5), f6_(f6), f7_(f7), f8_(f8), f9_(f9) {}
 616 
 617   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),
 618       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_), f9_(t.f9_) {}
 619 
 620   template &lt;GTEST_10_TYPENAMES_(U)&gt;
 621   tuple(const GTEST_10_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),
 622       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_),
 623       f9_(t.f9_) {}
 624 
 625   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 626 
 627   template &lt;GTEST_10_TYPENAMES_(U)&gt;
 628   tuple&amp; operator=(const GTEST_10_TUPLE_(U)&amp; t) {
 629     return CopyFrom(t);
 630   }
 631 
 632   GTEST_DECLARE_TUPLE_AS_FRIEND_
 633 
 634   template &lt;GTEST_10_TYPENAMES_(U)&gt;
 635   tuple&amp; CopyFrom(const GTEST_10_TUPLE_(U)&amp; t) {
 636     f0_ = t.f0_;
 637     f1_ = t.f1_;
 638     f2_ = t.f2_;
 639     f3_ = t.f3_;
 640     f4_ = t.f4_;
 641     f5_ = t.f5_;
 642     f6_ = t.f6_;
 643     f7_ = t.f7_;
 644     f8_ = t.f8_;
 645     f9_ = t.f9_;
 646     return *this;
 647   }
 648 
 649   T0 f0_;
 650   T1 f1_;
 651   T2 f2_;
 652   T3 f3_;
 653   T4 f4_;
 654   T5 f5_;
 655   T6 f6_;
 656   T7 f7_;
 657   T8 f8_;
 658   T9 f9_;
 659 };
 660 
 661 // 6.1.3.2 Tuple creation functions.
 662 
 663 // Known limitations: we don&#39;t support passing an
 664 // std::tr1::reference_wrapper&lt;T&gt; to make_tuple().  And we don&#39;t
 665 // implement tie().
 666 
 667 inline tuple&lt;&gt; make_tuple() { return tuple&lt;&gt;(); }
 668 
 669 template &lt;GTEST_1_TYPENAMES_(T)&gt;
 670 inline GTEST_1_TUPLE_(T) make_tuple(const T0&amp; f0) {
 671   return GTEST_1_TUPLE_(T)(f0);
 672 }
 673 
 674 template &lt;GTEST_2_TYPENAMES_(T)&gt;
 675 inline GTEST_2_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1) {
 676   return GTEST_2_TUPLE_(T)(f0, f1);
 677 }
 678 
 679 template &lt;GTEST_3_TYPENAMES_(T)&gt;
 680 inline GTEST_3_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2) {
 681   return GTEST_3_TUPLE_(T)(f0, f1, f2);
 682 }
 683 
 684 template &lt;GTEST_4_TYPENAMES_(T)&gt;
 685 inline GTEST_4_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2,
 686     const T3&amp; f3) {
 687   return GTEST_4_TUPLE_(T)(f0, f1, f2, f3);
 688 }
 689 
 690 template &lt;GTEST_5_TYPENAMES_(T)&gt;
 691 inline GTEST_5_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2,
 692     const T3&amp; f3, const T4&amp; f4) {
 693   return GTEST_5_TUPLE_(T)(f0, f1, f2, f3, f4);
 694 }
 695 
 696 template &lt;GTEST_6_TYPENAMES_(T)&gt;
 697 inline GTEST_6_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2,
 698     const T3&amp; f3, const T4&amp; f4, const T5&amp; f5) {
 699   return GTEST_6_TUPLE_(T)(f0, f1, f2, f3, f4, f5);
 700 }
 701 
 702 template &lt;GTEST_7_TYPENAMES_(T)&gt;
 703 inline GTEST_7_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2,
 704     const T3&amp; f3, const T4&amp; f4, const T5&amp; f5, const T6&amp; f6) {
 705   return GTEST_7_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6);
 706 }
 707 
 708 template &lt;GTEST_8_TYPENAMES_(T)&gt;
 709 inline GTEST_8_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2,
 710     const T3&amp; f3, const T4&amp; f4, const T5&amp; f5, const T6&amp; f6, const T7&amp; f7) {
 711   return GTEST_8_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6, f7);
 712 }
 713 
 714 template &lt;GTEST_9_TYPENAMES_(T)&gt;
 715 inline GTEST_9_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2,
 716     const T3&amp; f3, const T4&amp; f4, const T5&amp; f5, const T6&amp; f6, const T7&amp; f7,
 717     const T8&amp; f8) {
 718   return GTEST_9_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6, f7, f8);
 719 }
 720 
 721 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 722 inline GTEST_10_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2,
 723     const T3&amp; f3, const T4&amp; f4, const T5&amp; f5, const T6&amp; f6, const T7&amp; f7,
 724     const T8&amp; f8, const T9&amp; f9) {
 725   return GTEST_10_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6, f7, f8, f9);
 726 }
 727 
 728 // 6.1.3.3 Tuple helper classes.
 729 
 730 template &lt;typename Tuple&gt; struct tuple_size;
 731 
 732 template &lt;GTEST_0_TYPENAMES_(T)&gt;
 733 struct tuple_size&lt;GTEST_0_TUPLE_(T) &gt; {
 734   static const int value = 0;
 735 };
 736 
 737 template &lt;GTEST_1_TYPENAMES_(T)&gt;
 738 struct tuple_size&lt;GTEST_1_TUPLE_(T) &gt; {
 739   static const int value = 1;
 740 };
 741 
 742 template &lt;GTEST_2_TYPENAMES_(T)&gt;
 743 struct tuple_size&lt;GTEST_2_TUPLE_(T) &gt; {
 744   static const int value = 2;
 745 };
 746 
 747 template &lt;GTEST_3_TYPENAMES_(T)&gt;
 748 struct tuple_size&lt;GTEST_3_TUPLE_(T) &gt; {
 749   static const int value = 3;
 750 };
 751 
 752 template &lt;GTEST_4_TYPENAMES_(T)&gt;
 753 struct tuple_size&lt;GTEST_4_TUPLE_(T) &gt; {
 754   static const int value = 4;
 755 };
 756 
 757 template &lt;GTEST_5_TYPENAMES_(T)&gt;
 758 struct tuple_size&lt;GTEST_5_TUPLE_(T) &gt; {
 759   static const int value = 5;
 760 };
 761 
 762 template &lt;GTEST_6_TYPENAMES_(T)&gt;
 763 struct tuple_size&lt;GTEST_6_TUPLE_(T) &gt; {
 764   static const int value = 6;
 765 };
 766 
 767 template &lt;GTEST_7_TYPENAMES_(T)&gt;
 768 struct tuple_size&lt;GTEST_7_TUPLE_(T) &gt; {
 769   static const int value = 7;
 770 };
 771 
 772 template &lt;GTEST_8_TYPENAMES_(T)&gt;
 773 struct tuple_size&lt;GTEST_8_TUPLE_(T) &gt; {
 774   static const int value = 8;
 775 };
 776 
 777 template &lt;GTEST_9_TYPENAMES_(T)&gt;
 778 struct tuple_size&lt;GTEST_9_TUPLE_(T) &gt; {
 779   static const int value = 9;
 780 };
 781 
 782 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 783 struct tuple_size&lt;GTEST_10_TUPLE_(T) &gt; {
 784   static const int value = 10;
 785 };
 786 
 787 template &lt;int k, class Tuple&gt;
 788 struct tuple_element {
 789   typedef typename gtest_internal::TupleElement&lt;
 790       k &lt; (tuple_size&lt;Tuple&gt;::value), k, Tuple&gt;::type type;
 791 };
 792 
 793 #define GTEST_TUPLE_ELEMENT_(k, Tuple) typename tuple_element&lt;k, Tuple &gt;::type
 794 
 795 // 6.1.3.4 Element access.
 796 
 797 namespace gtest_internal {
 798 
 799 template &lt;&gt;
 800 class Get&lt;0&gt; {
 801  public:
 802   template &lt;class Tuple&gt;
 803   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(0, Tuple))
 804   Field(Tuple&amp; t) { return t.f0_; }  // NOLINT
 805 
 806   template &lt;class Tuple&gt;
 807   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(0, Tuple))
 808   ConstField(const Tuple&amp; t) { return t.f0_; }
 809 };
 810 
 811 template &lt;&gt;
 812 class Get&lt;1&gt; {
 813  public:
 814   template &lt;class Tuple&gt;
 815   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(1, Tuple))
 816   Field(Tuple&amp; t) { return t.f1_; }  // NOLINT
 817 
 818   template &lt;class Tuple&gt;
 819   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(1, Tuple))
 820   ConstField(const Tuple&amp; t) { return t.f1_; }
 821 };
 822 
 823 template &lt;&gt;
 824 class Get&lt;2&gt; {
 825  public:
 826   template &lt;class Tuple&gt;
 827   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(2, Tuple))
 828   Field(Tuple&amp; t) { return t.f2_; }  // NOLINT
 829 
 830   template &lt;class Tuple&gt;
 831   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(2, Tuple))
 832   ConstField(const Tuple&amp; t) { return t.f2_; }
 833 };
 834 
 835 template &lt;&gt;
 836 class Get&lt;3&gt; {
 837  public:
 838   template &lt;class Tuple&gt;
 839   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(3, Tuple))
 840   Field(Tuple&amp; t) { return t.f3_; }  // NOLINT
 841 
 842   template &lt;class Tuple&gt;
 843   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(3, Tuple))
 844   ConstField(const Tuple&amp; t) { return t.f3_; }
 845 };
 846 
 847 template &lt;&gt;
 848 class Get&lt;4&gt; {
 849  public:
 850   template &lt;class Tuple&gt;
 851   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(4, Tuple))
 852   Field(Tuple&amp; t) { return t.f4_; }  // NOLINT
 853 
 854   template &lt;class Tuple&gt;
 855   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(4, Tuple))
 856   ConstField(const Tuple&amp; t) { return t.f4_; }
 857 };
 858 
 859 template &lt;&gt;
 860 class Get&lt;5&gt; {
 861  public:
 862   template &lt;class Tuple&gt;
 863   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(5, Tuple))
 864   Field(Tuple&amp; t) { return t.f5_; }  // NOLINT
 865 
 866   template &lt;class Tuple&gt;
 867   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(5, Tuple))
 868   ConstField(const Tuple&amp; t) { return t.f5_; }
 869 };
 870 
 871 template &lt;&gt;
 872 class Get&lt;6&gt; {
 873  public:
 874   template &lt;class Tuple&gt;
 875   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(6, Tuple))
 876   Field(Tuple&amp; t) { return t.f6_; }  // NOLINT
 877 
 878   template &lt;class Tuple&gt;
 879   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(6, Tuple))
 880   ConstField(const Tuple&amp; t) { return t.f6_; }
 881 };
 882 
 883 template &lt;&gt;
 884 class Get&lt;7&gt; {
 885  public:
 886   template &lt;class Tuple&gt;
 887   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(7, Tuple))
 888   Field(Tuple&amp; t) { return t.f7_; }  // NOLINT
 889 
 890   template &lt;class Tuple&gt;
 891   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(7, Tuple))
 892   ConstField(const Tuple&amp; t) { return t.f7_; }
 893 };
 894 
 895 template &lt;&gt;
 896 class Get&lt;8&gt; {
 897  public:
 898   template &lt;class Tuple&gt;
 899   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(8, Tuple))
 900   Field(Tuple&amp; t) { return t.f8_; }  // NOLINT
 901 
 902   template &lt;class Tuple&gt;
 903   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(8, Tuple))
 904   ConstField(const Tuple&amp; t) { return t.f8_; }
 905 };
 906 
 907 template &lt;&gt;
 908 class Get&lt;9&gt; {
 909  public:
 910   template &lt;class Tuple&gt;
 911   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(9, Tuple))
 912   Field(Tuple&amp; t) { return t.f9_; }  // NOLINT
 913 
 914   template &lt;class Tuple&gt;
 915   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(9, Tuple))
 916   ConstField(const Tuple&amp; t) { return t.f9_; }
 917 };
 918 
 919 }  // namespace gtest_internal
 920 
 921 template &lt;int k, GTEST_10_TYPENAMES_(T)&gt;
 922 GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(k, GTEST_10_TUPLE_(T)))
 923 get(GTEST_10_TUPLE_(T)&amp; t) {
 924   return gtest_internal::Get&lt;k&gt;::Field(t);
 925 }
 926 
 927 template &lt;int k, GTEST_10_TYPENAMES_(T)&gt;
 928 GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(k,  GTEST_10_TUPLE_(T)))
 929 get(const GTEST_10_TUPLE_(T)&amp; t) {
 930   return gtest_internal::Get&lt;k&gt;::ConstField(t);
 931 }
 932 
 933 // 6.1.3.5 Relational operators
 934 
 935 // We only implement == and !=, as we don&#39;t have a need for the rest yet.
 936 
 937 namespace gtest_internal {
 938 
 939 // SameSizeTuplePrefixComparator&lt;k, k&gt;::Eq(t1, t2) returns true if the
 940 // first k fields of t1 equals the first k fields of t2.
 941 // SameSizeTuplePrefixComparator(k1, k2) would be a compiler error if
 942 // k1 != k2.
 943 template &lt;int kSize1, int kSize2&gt;
 944 struct SameSizeTuplePrefixComparator;
 945 
 946 template &lt;&gt;
 947 struct SameSizeTuplePrefixComparator&lt;0, 0&gt; {
 948   template &lt;class Tuple1, class Tuple2&gt;
 949   static bool Eq(const Tuple1&amp; /* t1 */, const Tuple2&amp; /* t2 */) {
 950     return true;
 951   }
 952 };
 953 
 954 template &lt;int k&gt;
 955 struct SameSizeTuplePrefixComparator&lt;k, k&gt; {
 956   template &lt;class Tuple1, class Tuple2&gt;
 957   static bool Eq(const Tuple1&amp; t1, const Tuple2&amp; t2) {
 958     return SameSizeTuplePrefixComparator&lt;k - 1, k - 1&gt;::Eq(t1, t2) &amp;&amp;
 959         ::std::tr1::get&lt;k - 1&gt;(t1) == ::std::tr1::get&lt;k - 1&gt;(t2);
 960   }
 961 };
 962 
 963 }  // namespace gtest_internal
 964 
 965 template &lt;GTEST_10_TYPENAMES_(T), GTEST_10_TYPENAMES_(U)&gt;
 966 inline bool operator==(const GTEST_10_TUPLE_(T)&amp; t,
 967                        const GTEST_10_TUPLE_(U)&amp; u) {
 968   return gtest_internal::SameSizeTuplePrefixComparator&lt;
 969       tuple_size&lt;GTEST_10_TUPLE_(T) &gt;::value,
 970       tuple_size&lt;GTEST_10_TUPLE_(U) &gt;::value&gt;::Eq(t, u);
 971 }
 972 
 973 template &lt;GTEST_10_TYPENAMES_(T), GTEST_10_TYPENAMES_(U)&gt;
 974 inline bool operator!=(const GTEST_10_TUPLE_(T)&amp; t,
 975                        const GTEST_10_TUPLE_(U)&amp; u) { return !(t == u); }
 976 
 977 // 6.1.4 Pairs.
 978 // Unimplemented.
 979 
 980 }  // namespace tr1
 981 }  // namespace std
 982 
 983 #undef GTEST_0_TUPLE_
 984 #undef GTEST_1_TUPLE_
 985 #undef GTEST_2_TUPLE_
 986 #undef GTEST_3_TUPLE_
 987 #undef GTEST_4_TUPLE_
 988 #undef GTEST_5_TUPLE_
 989 #undef GTEST_6_TUPLE_
 990 #undef GTEST_7_TUPLE_
 991 #undef GTEST_8_TUPLE_
 992 #undef GTEST_9_TUPLE_
 993 #undef GTEST_10_TUPLE_
 994 
 995 #undef GTEST_0_TYPENAMES_
 996 #undef GTEST_1_TYPENAMES_
 997 #undef GTEST_2_TYPENAMES_
 998 #undef GTEST_3_TYPENAMES_
 999 #undef GTEST_4_TYPENAMES_
1000 #undef GTEST_5_TYPENAMES_
1001 #undef GTEST_6_TYPENAMES_
1002 #undef GTEST_7_TYPENAMES_
1003 #undef GTEST_8_TYPENAMES_
1004 #undef GTEST_9_TYPENAMES_
1005 #undef GTEST_10_TYPENAMES_
1006 
1007 #undef GTEST_DECLARE_TUPLE_AS_FRIEND_
1008 #undef GTEST_BY_REF_
1009 #undef GTEST_ADD_REF_
1010 #undef GTEST_TUPLE_ELEMENT_
1011 
1012 #endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TUPLE_H_
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/include/gtest/internal/gtest-filepath.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Copyright 2008, Google Inc.
  2 // All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //     * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //     * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //     * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 //
 30 // Author: keith.ray@gmail.com (Keith Ray)
 31 //
 32 // Google Test filepath utilities
 33 //
 34 // This header file declares classes and functions used internally by
 35 // Google Test.  They are subject to change without notice.
 36 //
 37 // This file is #included in &lt;gtest/internal/gtest-internal.h&gt;.
 38 // Do not include this header file separately!
 39 
 40 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_
 41 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_
 42 
 43 #include &quot;gtest/internal/gtest-string.h&quot;
 44 
 45 namespace testing {
 46 namespace internal {
 47 
 48 // FilePath - a class for file and directory pathname manipulation which
 49 // handles platform-specific conventions (like the pathname separator).
 50 // Used for helper functions for naming files in a directory for xml output.
 51 // Except for Set methods, all methods are const or static, which provides an
 52 // &quot;immutable value object&quot; -- useful for peace of mind.
 53 // A FilePath with a value ending in a path separator (&quot;like/this/&quot;) represents
 54 // a directory, otherwise it is assumed to represent a file. In either case,
 55 // it may or may not represent an actual file or directory in the file system.
 56 // Names are NOT checked for syntax correctness -- no checking for illegal
 57 // characters, malformed paths, etc.
 58 
 59 class GTEST_API_ FilePath {
 60  public:
 61   FilePath() : pathname_(&quot;&quot;) { }
 62   FilePath(const FilePath&amp; rhs) : pathname_(rhs.pathname_) { }
 63 
 64   explicit FilePath(const std::string&amp; pathname) : pathname_(pathname) {
 65     Normalize();
 66   }
 67 
 68   FilePath&amp; operator=(const FilePath&amp; rhs) {
 69     Set(rhs);
 70     return *this;
 71   }
 72 
 73   void Set(const FilePath&amp; rhs) {
 74     pathname_ = rhs.pathname_;
 75   }
 76 
 77   const std::string&amp; string() const { return pathname_; }
 78   const char* c_str() const { return pathname_.c_str(); }
 79 
 80   // Returns the current working directory, or &quot;&quot; if unsuccessful.
 81   static FilePath GetCurrentDir();
 82 
 83   // Given directory = &quot;dir&quot;, base_name = &quot;test&quot;, number = 0,
 84   // extension = &quot;xml&quot;, returns &quot;dir/test.xml&quot;. If number is greater
 85   // than zero (e.g., 12), returns &quot;dir/test_12.xml&quot;.
 86   // On Windows platform, uses \ as the separator rather than /.
 87   static FilePath MakeFileName(const FilePath&amp; directory,
 88                                const FilePath&amp; base_name,
 89                                int number,
 90                                const char* extension);
 91 
 92   // Given directory = &quot;dir&quot;, relative_path = &quot;test.xml&quot;,
 93   // returns &quot;dir/test.xml&quot;.
 94   // On Windows, uses \ as the separator rather than /.
 95   static FilePath ConcatPaths(const FilePath&amp; directory,
 96                               const FilePath&amp; relative_path);
 97 
 98   // Returns a pathname for a file that does not currently exist. The pathname
 99   // will be directory/base_name.extension or
100   // directory/base_name_&lt;number&gt;.extension if directory/base_name.extension
101   // already exists. The number will be incremented until a pathname is found
102   // that does not already exist.
103   // Examples: &#39;dir/foo_test.xml&#39; or &#39;dir/foo_test_1.xml&#39;.
104   // There could be a race condition if two or more processes are calling this
105   // function at the same time -- they could both pick the same filename.
106   static FilePath GenerateUniqueFileName(const FilePath&amp; directory,
107                                          const FilePath&amp; base_name,
108                                          const char* extension);
109 
110   // Returns true iff the path is &quot;&quot;.
111   bool IsEmpty() const { return pathname_.empty(); }
112 
113   // If input name has a trailing separator character, removes it and returns
114   // the name, otherwise return the name string unmodified.
115   // On Windows platform, uses \ as the separator, other platforms use /.
116   FilePath RemoveTrailingPathSeparator() const;
117 
118   // Returns a copy of the FilePath with the directory part removed.
119   // Example: FilePath(&quot;path/to/file&quot;).RemoveDirectoryName() returns
120   // FilePath(&quot;file&quot;). If there is no directory part (&quot;just_a_file&quot;), it returns
121   // the FilePath unmodified. If there is no file part (&quot;just_a_dir/&quot;) it
122   // returns an empty FilePath (&quot;&quot;).
123   // On Windows platform, &#39;\&#39; is the path separator, otherwise it is &#39;/&#39;.
124   FilePath RemoveDirectoryName() const;
125 
126   // RemoveFileName returns the directory path with the filename removed.
127   // Example: FilePath(&quot;path/to/file&quot;).RemoveFileName() returns &quot;path/to/&quot;.
128   // If the FilePath is &quot;a_file&quot; or &quot;/a_file&quot;, RemoveFileName returns
129   // FilePath(&quot;./&quot;) or, on Windows, FilePath(&quot;.\\&quot;). If the filepath does
130   // not have a file, like &quot;just/a/dir/&quot;, it returns the FilePath unmodified.
131   // On Windows platform, &#39;\&#39; is the path separator, otherwise it is &#39;/&#39;.
132   FilePath RemoveFileName() const;
133 
134   // Returns a copy of the FilePath with the case-insensitive extension removed.
135   // Example: FilePath(&quot;dir/file.exe&quot;).RemoveExtension(&quot;EXE&quot;) returns
136   // FilePath(&quot;dir/file&quot;). If a case-insensitive extension is not
137   // found, returns a copy of the original FilePath.
138   FilePath RemoveExtension(const char* extension) const;
139 
140   // Creates directories so that path exists. Returns true if successful or if
141   // the directories already exist; returns false if unable to create
142   // directories for any reason. Will also return false if the FilePath does
143   // not represent a directory (that is, it doesn&#39;t end with a path separator).
144   bool CreateDirectoriesRecursively() const;
145 
146   // Create the directory so that path exists. Returns true if successful or
147   // if the directory already exists; returns false if unable to create the
148   // directory for any reason, including if the parent directory does not
149   // exist. Not named &quot;CreateDirectory&quot; because that&#39;s a macro on Windows.
150   bool CreateFolder() const;
151 
152   // Returns true if FilePath describes something in the file-system,
153   // either a file, directory, or whatever, and that something exists.
154   bool FileOrDirectoryExists() const;
155 
156   // Returns true if pathname describes a directory in the file-system
157   // that exists.
158   bool DirectoryExists() const;
159 
160   // Returns true if FilePath ends with a path separator, which indicates that
161   // it is intended to represent a directory. Returns false otherwise.
162   // This does NOT check that a directory (or file) actually exists.
163   bool IsDirectory() const;
164 
165   // Returns true if pathname describes a root directory. (Windows has one
166   // root directory per disk drive.)
167   bool IsRootDirectory() const;
168 
169   // Returns true if pathname describes an absolute path.
170   bool IsAbsolutePath() const;
171 
172  private:
173   // Replaces multiple consecutive separators with a single separator.
174   // For example, &quot;bar///foo&quot; becomes &quot;bar/foo&quot;. Does not eliminate other
175   // redundancies that might be in a pathname involving &quot;.&quot; or &quot;..&quot;.
176   //
177   // A pathname with multiple consecutive separators may occur either through
178   // user error or as a result of some scripts or APIs that generate a pathname
179   // with a trailing separator. On other platforms the same API or script
180   // may NOT generate a pathname with a trailing &quot;/&quot;. Then elsewhere that
181   // pathname may have another &quot;/&quot; and pathname components added to it,
182   // without checking for the separator already being there.
183   // The script language and operating system may allow paths like &quot;foo//bar&quot;
184   // but some of the functions in FilePath will not handle that correctly. In
185   // particular, RemoveTrailingPathSeparator() only removes one separator, and
186   // it is called in CreateDirectoriesRecursively() assuming that it will change
187   // a pathname from directory syntax (trailing separator) to filename syntax.
188   //
189   // On Windows this method also replaces the alternate path separator &#39;/&#39; with
190   // the primary path separator &#39;\\&#39;, so that for example &quot;bar\\/\\foo&quot; becomes
191   // &quot;bar\\foo&quot;.
192 
193   void Normalize();
194 
195   // Returns a pointer to the last occurence of a valid path separator in
196   // the FilePath. On Windows, for example, both &#39;/&#39; and &#39;\&#39; are valid path
197   // separators. Returns NULL if no path separator was found.
198   const char* FindLastPathSeparator() const;
199 
200   std::string pathname_;
201 };  // class FilePath
202 
203 }  // namespace internal
204 }  // namespace testing
205 
206 #endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_
    </pre>
  </body>
</html>
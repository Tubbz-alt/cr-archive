<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/fmw/gtest/googlemock/include/gmock/internal/gmock-generated-internal-utils.h</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // This file was GENERATED by command:
  2 //     pump.py gmock-generated-internal-utils.h.pump
  3 // DO NOT EDIT BY HAND!!!
  4 
  5 // Copyright 2007, Google Inc.
  6 // All rights reserved.
  7 //
  8 // Redistribution and use in source and binary forms, with or without
  9 // modification, are permitted provided that the following conditions are
 10 // met:
 11 //
 12 //     * Redistributions of source code must retain the above copyright
 13 // notice, this list of conditions and the following disclaimer.
 14 //     * Redistributions in binary form must reproduce the above
 15 // copyright notice, this list of conditions and the following disclaimer
 16 // in the documentation and/or other materials provided with the
 17 // distribution.
 18 //     * Neither the name of Google Inc. nor the names of its
 19 // contributors may be used to endorse or promote products derived from
 20 // this software without specific prior written permission.
 21 //
 22 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 23 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 24 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 25 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 26 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 27 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 28 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 30 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 31 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 32 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 33 
 34 
 35 // Google Mock - a framework for writing C++ mock classes.
 36 //
 37 // This file contains template meta-programming utility classes needed
 38 // for implementing Google Mock.
 39 
 40 // GOOGLETEST_CM0002 DO NOT DELETE
 41 
 42 #ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_GENERATED_INTERNAL_UTILS_H_
 43 #define GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_GENERATED_INTERNAL_UTILS_H_
 44 
 45 #include &quot;gmock/internal/gmock-port.h&quot;
 46 
 47 namespace testing {
 48 
 49 template &lt;typename T&gt;
 50 class Matcher;
 51 
 52 namespace internal {
 53 
 54 // An IgnoredValue object can be implicitly constructed from ANY value.
 55 // This is used in implementing the IgnoreResult(a) action.
 56 class IgnoredValue {
 57  public:
 58   // This constructor template allows any value to be implicitly
 59   // converted to IgnoredValue.  The object has no data member and
 60   // doesn&#39;t try to remember anything about the argument.  We
 61   // deliberately omit the &#39;explicit&#39; keyword in order to allow the
 62   // conversion to be implicit.
 63   template &lt;typename T&gt;
 64   IgnoredValue(const T&amp; /* ignored */) {}  // NOLINT(runtime/explicit)
 65 };
 66 
 67 // MatcherTuple&lt;T&gt;::type is a tuple type where each field is a Matcher
 68 // for the corresponding field in tuple type T.
 69 template &lt;typename Tuple&gt;
 70 struct MatcherTuple;
 71 
 72 template &lt;&gt;
 73 struct MatcherTuple&lt; ::testing::tuple&lt;&gt; &gt; {
 74   typedef ::testing::tuple&lt; &gt; type;
 75 };
 76 
 77 template &lt;typename A1&gt;
 78 struct MatcherTuple&lt; ::testing::tuple&lt;A1&gt; &gt; {
 79   typedef ::testing::tuple&lt;Matcher&lt;A1&gt; &gt; type;
 80 };
 81 
 82 template &lt;typename A1, typename A2&gt;
 83 struct MatcherTuple&lt; ::testing::tuple&lt;A1, A2&gt; &gt; {
 84   typedef ::testing::tuple&lt;Matcher&lt;A1&gt;, Matcher&lt;A2&gt; &gt; type;
 85 };
 86 
 87 template &lt;typename A1, typename A2, typename A3&gt;
 88 struct MatcherTuple&lt; ::testing::tuple&lt;A1, A2, A3&gt; &gt; {
 89   typedef ::testing::tuple&lt;Matcher&lt;A1&gt;, Matcher&lt;A2&gt;, Matcher&lt;A3&gt; &gt; type;
 90 };
 91 
 92 template &lt;typename A1, typename A2, typename A3, typename A4&gt;
 93 struct MatcherTuple&lt; ::testing::tuple&lt;A1, A2, A3, A4&gt; &gt; {
 94   typedef ::testing::tuple&lt;Matcher&lt;A1&gt;, Matcher&lt;A2&gt;, Matcher&lt;A3&gt;, Matcher&lt;A4&gt; &gt;
 95       type;
 96 };
 97 
 98 template &lt;typename A1, typename A2, typename A3, typename A4, typename A5&gt;
 99 struct MatcherTuple&lt; ::testing::tuple&lt;A1, A2, A3, A4, A5&gt; &gt; {
100   typedef ::testing::tuple&lt;Matcher&lt;A1&gt;, Matcher&lt;A2&gt;, Matcher&lt;A3&gt;, Matcher&lt;A4&gt;,
101                            Matcher&lt;A5&gt; &gt;
102       type;
103 };
104 
105 template &lt;typename A1, typename A2, typename A3, typename A4, typename A5,
106     typename A6&gt;
107 struct MatcherTuple&lt; ::testing::tuple&lt;A1, A2, A3, A4, A5, A6&gt; &gt; {
108   typedef ::testing::tuple&lt;Matcher&lt;A1&gt;, Matcher&lt;A2&gt;, Matcher&lt;A3&gt;, Matcher&lt;A4&gt;,
109                            Matcher&lt;A5&gt;, Matcher&lt;A6&gt; &gt;
110       type;
111 };
112 
113 template &lt;typename A1, typename A2, typename A3, typename A4, typename A5,
114     typename A6, typename A7&gt;
115 struct MatcherTuple&lt; ::testing::tuple&lt;A1, A2, A3, A4, A5, A6, A7&gt; &gt; {
116   typedef ::testing::tuple&lt;Matcher&lt;A1&gt;, Matcher&lt;A2&gt;, Matcher&lt;A3&gt;, Matcher&lt;A4&gt;,
117                            Matcher&lt;A5&gt;, Matcher&lt;A6&gt;, Matcher&lt;A7&gt; &gt;
118       type;
119 };
120 
121 template &lt;typename A1, typename A2, typename A3, typename A4, typename A5,
122     typename A6, typename A7, typename A8&gt;
123 struct MatcherTuple&lt; ::testing::tuple&lt;A1, A2, A3, A4, A5, A6, A7, A8&gt; &gt; {
124   typedef ::testing::tuple&lt;Matcher&lt;A1&gt;, Matcher&lt;A2&gt;, Matcher&lt;A3&gt;, Matcher&lt;A4&gt;,
125                            Matcher&lt;A5&gt;, Matcher&lt;A6&gt;, Matcher&lt;A7&gt;, Matcher&lt;A8&gt; &gt;
126       type;
127 };
128 
129 template &lt;typename A1, typename A2, typename A3, typename A4, typename A5,
130     typename A6, typename A7, typename A8, typename A9&gt;
131 struct MatcherTuple&lt; ::testing::tuple&lt;A1, A2, A3, A4, A5, A6, A7, A8, A9&gt; &gt; {
132   typedef ::testing::tuple&lt;Matcher&lt;A1&gt;, Matcher&lt;A2&gt;, Matcher&lt;A3&gt;, Matcher&lt;A4&gt;,
133                            Matcher&lt;A5&gt;, Matcher&lt;A6&gt;, Matcher&lt;A7&gt;, Matcher&lt;A8&gt;,
134                            Matcher&lt;A9&gt; &gt;
135       type;
136 };
137 
138 template &lt;typename A1, typename A2, typename A3, typename A4, typename A5,
139     typename A6, typename A7, typename A8, typename A9, typename A10&gt;
140 struct MatcherTuple&lt; ::testing::tuple&lt;A1, A2, A3, A4, A5, A6, A7, A8, A9,
141     A10&gt; &gt; {
142   typedef ::testing::tuple&lt;Matcher&lt;A1&gt;, Matcher&lt;A2&gt;, Matcher&lt;A3&gt;, Matcher&lt;A4&gt;,
143                            Matcher&lt;A5&gt;, Matcher&lt;A6&gt;, Matcher&lt;A7&gt;, Matcher&lt;A8&gt;,
144                            Matcher&lt;A9&gt;, Matcher&lt;A10&gt; &gt;
145       type;
146 };
147 
148 // Template struct Function&lt;F&gt;, where F must be a function type, contains
149 // the following typedefs:
150 //
151 //   Result:               the function&#39;s return type.
152 //   ArgumentN:            the type of the N-th argument, where N starts with 1.
153 //   ArgumentTuple:        the tuple type consisting of all parameters of F.
154 //   ArgumentMatcherTuple: the tuple type consisting of Matchers for all
155 //                         parameters of F.
156 //   MakeResultVoid:       the function type obtained by substituting void
157 //                         for the return type of F.
158 //   MakeResultIgnoredValue:
159 //                         the function type obtained by substituting Something
160 //                         for the return type of F.
161 template &lt;typename F&gt;
162 struct Function;
163 
164 template &lt;typename R&gt;
165 struct Function&lt;R()&gt; {
166   typedef R Result;
167   typedef ::testing::tuple&lt;&gt; ArgumentTuple;
168   typedef typename MatcherTuple&lt;ArgumentTuple&gt;::type ArgumentMatcherTuple;
169   typedef void MakeResultVoid();
170   typedef IgnoredValue MakeResultIgnoredValue();
171 };
172 
173 template &lt;typename R, typename A1&gt;
174 struct Function&lt;R(A1)&gt;
175     : Function&lt;R()&gt; {
176   typedef A1 Argument1;
177   typedef ::testing::tuple&lt;A1&gt; ArgumentTuple;
178   typedef typename MatcherTuple&lt;ArgumentTuple&gt;::type ArgumentMatcherTuple;
179   typedef void MakeResultVoid(A1);
180   typedef IgnoredValue MakeResultIgnoredValue(A1);
181 };
182 
183 template &lt;typename R, typename A1, typename A2&gt;
184 struct Function&lt;R(A1, A2)&gt;
185     : Function&lt;R(A1)&gt; {
186   typedef A2 Argument2;
187   typedef ::testing::tuple&lt;A1, A2&gt; ArgumentTuple;
188   typedef typename MatcherTuple&lt;ArgumentTuple&gt;::type ArgumentMatcherTuple;
189   typedef void MakeResultVoid(A1, A2);
190   typedef IgnoredValue MakeResultIgnoredValue(A1, A2);
191 };
192 
193 template &lt;typename R, typename A1, typename A2, typename A3&gt;
194 struct Function&lt;R(A1, A2, A3)&gt;
195     : Function&lt;R(A1, A2)&gt; {
196   typedef A3 Argument3;
197   typedef ::testing::tuple&lt;A1, A2, A3&gt; ArgumentTuple;
198   typedef typename MatcherTuple&lt;ArgumentTuple&gt;::type ArgumentMatcherTuple;
199   typedef void MakeResultVoid(A1, A2, A3);
200   typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3);
201 };
202 
203 template &lt;typename R, typename A1, typename A2, typename A3, typename A4&gt;
204 struct Function&lt;R(A1, A2, A3, A4)&gt;
205     : Function&lt;R(A1, A2, A3)&gt; {
206   typedef A4 Argument4;
207   typedef ::testing::tuple&lt;A1, A2, A3, A4&gt; ArgumentTuple;
208   typedef typename MatcherTuple&lt;ArgumentTuple&gt;::type ArgumentMatcherTuple;
209   typedef void MakeResultVoid(A1, A2, A3, A4);
210   typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4);
211 };
212 
213 template &lt;typename R, typename A1, typename A2, typename A3, typename A4,
214     typename A5&gt;
215 struct Function&lt;R(A1, A2, A3, A4, A5)&gt;
216     : Function&lt;R(A1, A2, A3, A4)&gt; {
217   typedef A5 Argument5;
218   typedef ::testing::tuple&lt;A1, A2, A3, A4, A5&gt; ArgumentTuple;
219   typedef typename MatcherTuple&lt;ArgumentTuple&gt;::type ArgumentMatcherTuple;
220   typedef void MakeResultVoid(A1, A2, A3, A4, A5);
221   typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5);
222 };
223 
224 template &lt;typename R, typename A1, typename A2, typename A3, typename A4,
225     typename A5, typename A6&gt;
226 struct Function&lt;R(A1, A2, A3, A4, A5, A6)&gt;
227     : Function&lt;R(A1, A2, A3, A4, A5)&gt; {
228   typedef A6 Argument6;
229   typedef ::testing::tuple&lt;A1, A2, A3, A4, A5, A6&gt; ArgumentTuple;
230   typedef typename MatcherTuple&lt;ArgumentTuple&gt;::type ArgumentMatcherTuple;
231   typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6);
232   typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6);
233 };
234 
235 template &lt;typename R, typename A1, typename A2, typename A3, typename A4,
236     typename A5, typename A6, typename A7&gt;
237 struct Function&lt;R(A1, A2, A3, A4, A5, A6, A7)&gt;
238     : Function&lt;R(A1, A2, A3, A4, A5, A6)&gt; {
239   typedef A7 Argument7;
240   typedef ::testing::tuple&lt;A1, A2, A3, A4, A5, A6, A7&gt; ArgumentTuple;
241   typedef typename MatcherTuple&lt;ArgumentTuple&gt;::type ArgumentMatcherTuple;
242   typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6, A7);
243   typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6, A7);
244 };
245 
246 template &lt;typename R, typename A1, typename A2, typename A3, typename A4,
247     typename A5, typename A6, typename A7, typename A8&gt;
248 struct Function&lt;R(A1, A2, A3, A4, A5, A6, A7, A8)&gt;
249     : Function&lt;R(A1, A2, A3, A4, A5, A6, A7)&gt; {
250   typedef A8 Argument8;
251   typedef ::testing::tuple&lt;A1, A2, A3, A4, A5, A6, A7, A8&gt; ArgumentTuple;
252   typedef typename MatcherTuple&lt;ArgumentTuple&gt;::type ArgumentMatcherTuple;
253   typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6, A7, A8);
254   typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6, A7, A8);
255 };
256 
257 template &lt;typename R, typename A1, typename A2, typename A3, typename A4,
258     typename A5, typename A6, typename A7, typename A8, typename A9&gt;
259 struct Function&lt;R(A1, A2, A3, A4, A5, A6, A7, A8, A9)&gt;
260     : Function&lt;R(A1, A2, A3, A4, A5, A6, A7, A8)&gt; {
261   typedef A9 Argument9;
262   typedef ::testing::tuple&lt;A1, A2, A3, A4, A5, A6, A7, A8, A9&gt; ArgumentTuple;
263   typedef typename MatcherTuple&lt;ArgumentTuple&gt;::type ArgumentMatcherTuple;
264   typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6, A7, A8, A9);
265   typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6, A7, A8,
266       A9);
267 };
268 
269 template &lt;typename R, typename A1, typename A2, typename A3, typename A4,
270     typename A5, typename A6, typename A7, typename A8, typename A9,
271     typename A10&gt;
272 struct Function&lt;R(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)&gt;
273     : Function&lt;R(A1, A2, A3, A4, A5, A6, A7, A8, A9)&gt; {
274   typedef A10 Argument10;
275   typedef ::testing::tuple&lt;A1, A2, A3, A4, A5, A6, A7, A8, A9,
276       A10&gt; ArgumentTuple;
277   typedef typename MatcherTuple&lt;ArgumentTuple&gt;::type ArgumentMatcherTuple;
278   typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
279   typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6, A7, A8,
280       A9, A10);
281 };
282 
283 }  // namespace internal
284 
285 }  // namespace testing
286 
287 #endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_GENERATED_INTERNAL_UTILS_H_
    </pre>
  </body>
</html>
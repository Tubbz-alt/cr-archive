<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/fmw/gtest/googletest/include/gtest/internal/gtest-param-util-generated.h.pump</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 $$ -*- mode: c++; -*-
  2 $var n = 50  $$ Maximum length of Values arguments we want to support.
  3 $var maxtuple = 10  $$ Maximum number of Combine arguments we want to support.
  4 // Copyright 2008 Google Inc.
  5 // All Rights Reserved.
  6 //
  7 // Redistribution and use in source and binary forms, with or without
  8 // modification, are permitted provided that the following conditions are
  9 // met:
 10 //
 11 //     * Redistributions of source code must retain the above copyright
 12 // notice, this list of conditions and the following disclaimer.
 13 //     * Redistributions in binary form must reproduce the above
 14 // copyright notice, this list of conditions and the following disclaimer
 15 // in the documentation and/or other materials provided with the
 16 // distribution.
 17 //     * Neither the name of Google Inc. nor the names of its
 18 // contributors may be used to endorse or promote products derived from
 19 // this software without specific prior written permission.
 20 //
 21 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 22 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 23 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 24 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 25 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 26 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 27 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 28 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 29 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 30 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 31 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32 
 33 
 34 // Type and function utilities for implementing parameterized tests.
 35 // This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!
 36 //
 37 // Currently Google Test supports at most $n arguments in Values,
 38 // and at most $maxtuple arguments in Combine. Please contact
 39 // googletestframework@googlegroups.com if you need more.
 40 // Please note that the number of arguments to Combine is limited
 41 // by the maximum arity of the implementation of tuple which is
 42 // currently set at $maxtuple.
 43 
 44 // GOOGLETEST_CM0001 DO NOT DELETE
 45 
 46 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_
 47 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_
 48 
 49 #include &quot;gtest/internal/gtest-param-util.h&quot;
 50 #include &quot;gtest/internal/gtest-port.h&quot;
 51 
 52 namespace testing {
 53 
 54 // Forward declarations of ValuesIn(), which is implemented in
 55 // include/gtest/gtest-param-test.h.
 56 template &lt;typename ForwardIterator&gt;
 57 internal::ParamGenerator&lt;
 58   typename ::testing::internal::IteratorTraits&lt;ForwardIterator&gt;::value_type&gt;
 59 ValuesIn(ForwardIterator begin, ForwardIterator end);
 60 
 61 template &lt;typename T, size_t N&gt;
 62 internal::ParamGenerator&lt;T&gt; ValuesIn(const T (&amp;array)[N]);
 63 
 64 template &lt;class Container&gt;
 65 internal::ParamGenerator&lt;typename Container::value_type&gt; ValuesIn(
 66     const Container&amp; container);
 67 
 68 namespace internal {
 69 
 70 // Used in the Values() function to provide polymorphic capabilities.
 71 $range i 1..n
 72 $for i [[
 73 $range j 1..i
 74 
 75 template &lt;$for j, [[typename T$j]]&gt;
 76 class ValueArray$i {
 77  public:
 78   $if i==1 [[explicit ]]ValueArray$i($for j, [[T$j v$j]]) : $for j, [[v$(j)_(v$j)]] {}
 79 
 80   template &lt;typename T&gt;
 81   operator ParamGenerator&lt;T&gt;() const {
 82     const T array[] = {$for j, [[static_cast&lt;T&gt;(v$(j)_)]]};
 83     return ValuesIn(array);
 84   }
 85 
 86   ValueArray$i(const ValueArray$i&amp; other) : $for j, [[v$(j)_(other.v$(j)_)]] {}
 87 
 88  private:
 89   // No implementation - assignment is unsupported.
 90   void operator=(const ValueArray$i&amp; other);
 91 
 92 $for j [[
 93 
 94   const T$j v$(j)_;
 95 ]]
 96 
 97 };
 98 
 99 ]]
100 
101 # if GTEST_HAS_COMBINE
102 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.
103 //
104 // Generates values from the Cartesian product of values produced
105 // by the argument generators.
106 //
107 $range i 2..maxtuple
108 $for i [[
109 $range j 1..i
110 $range k 2..i
111 
112 template &lt;$for j, [[typename T$j]]&gt;
113 class CartesianProductGenerator$i
114     : public ParamGeneratorInterface&lt; ::testing::tuple&lt;$for j, [[T$j]]&gt; &gt; {
115  public:
116   typedef ::testing::tuple&lt;$for j, [[T$j]]&gt; ParamType;
117 
118   CartesianProductGenerator$i($for j, [[const ParamGenerator&lt;T$j&gt;&amp; g$j]])
119       : $for j, [[g$(j)_(g$j)]] {}
120   virtual ~CartesianProductGenerator$i() {}
121 
122   virtual ParamIteratorInterface&lt;ParamType&gt;* Begin() const {
123     return new Iterator(this, $for j, [[g$(j)_, g$(j)_.begin()]]);
124   }
125   virtual ParamIteratorInterface&lt;ParamType&gt;* End() const {
126     return new Iterator(this, $for j, [[g$(j)_, g$(j)_.end()]]);
127   }
128 
129  private:
130   class Iterator : public ParamIteratorInterface&lt;ParamType&gt; {
131    public:
132     Iterator(const ParamGeneratorInterface&lt;ParamType&gt;* base, $for j, [[
133 
134       const ParamGenerator&lt;T$j&gt;&amp; g$j,
135       const typename ParamGenerator&lt;T$j&gt;::iterator&amp; current$(j)]])
136         : base_(base),
137 $for j, [[
138 
139           begin$(j)_(g$j.begin()), end$(j)_(g$j.end()), current$(j)_(current$j)
140 ]]    {
141       ComputeCurrentValue();
142     }
143     virtual ~Iterator() {}
144 
145     virtual const ParamGeneratorInterface&lt;ParamType&gt;* BaseGenerator() const {
146       return base_;
147     }
148     // Advance should not be called on beyond-of-range iterators
149     // so no component iterators must be beyond end of range, either.
150     virtual void Advance() {
151       assert(!AtEnd());
152       ++current$(i)_;
153 
154 $for k [[
155       if (current$(i+2-k)_ == end$(i+2-k)_) {
156         current$(i+2-k)_ = begin$(i+2-k)_;
157         ++current$(i+2-k-1)_;
158       }
159 
160 ]]
161       ComputeCurrentValue();
162     }
163     virtual ParamIteratorInterface&lt;ParamType&gt;* Clone() const {
164       return new Iterator(*this);
165     }
166     virtual const ParamType* Current() const { return current_value_.get(); }
167     virtual bool Equals(const ParamIteratorInterface&lt;ParamType&gt;&amp; other) const {
168       // Having the same base generator guarantees that the other
169       // iterator is of the same type and we can downcast.
170       GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())
171           &lt;&lt; &quot;The program attempted to compare iterators &quot;
172           &lt;&lt; &quot;from different generators.&quot; &lt;&lt; std::endl;
173       const Iterator* typed_other =
174           CheckedDowncastToActualType&lt;const Iterator&gt;(&amp;other);
175       // We must report iterators equal if they both point beyond their
176       // respective ranges. That can happen in a variety of fashions,
177       // so we have to consult AtEnd().
178       return (AtEnd() &amp;&amp; typed_other-&gt;AtEnd()) ||
179          ($for j  &amp;&amp; [[
180 
181           current$(j)_ == typed_other-&gt;current$(j)_
182 ]]);
183     }
184 
185    private:
186     Iterator(const Iterator&amp; other)
187         : base_(other.base_), $for j, [[
188 
189         begin$(j)_(other.begin$(j)_),
190         end$(j)_(other.end$(j)_),
191         current$(j)_(other.current$(j)_)
192 ]] {
193       ComputeCurrentValue();
194     }
195 
196     void ComputeCurrentValue() {
197       if (!AtEnd())
198         current_value_.reset(new ParamType($for j, [[*current$(j)_]]));
199     }
200     bool AtEnd() const {
201       // We must report iterator past the end of the range when either of the
202       // component iterators has reached the end of its range.
203       return
204 $for j  || [[
205 
206           current$(j)_ == end$(j)_
207 ]];
208     }
209 
210     // No implementation - assignment is unsupported.
211     void operator=(const Iterator&amp; other);
212 
213     const ParamGeneratorInterface&lt;ParamType&gt;* const base_;
214     // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.
215     // current[i]_ is the actual traversing iterator.
216 $for j [[
217 
218     const typename ParamGenerator&lt;T$j&gt;::iterator begin$(j)_;
219     const typename ParamGenerator&lt;T$j&gt;::iterator end$(j)_;
220     typename ParamGenerator&lt;T$j&gt;::iterator current$(j)_;
221 ]]
222 
223     linked_ptr&lt;ParamType&gt; current_value_;
224   };  // class CartesianProductGenerator$i::Iterator
225 
226   // No implementation - assignment is unsupported.
227   void operator=(const CartesianProductGenerator$i&amp; other);
228 
229 
230 $for j [[
231   const ParamGenerator&lt;T$j&gt; g$(j)_;
232 
233 ]]
234 };  // class CartesianProductGenerator$i
235 
236 
237 ]]
238 
239 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.
240 //
241 // Helper classes providing Combine() with polymorphic features. They allow
242 // casting CartesianProductGeneratorN&lt;T&gt; to ParamGenerator&lt;U&gt; if T is
243 // convertible to U.
244 //
245 $range i 2..maxtuple
246 $for i [[
247 $range j 1..i
248 
249 template &lt;$for j, [[class Generator$j]]&gt;
250 class CartesianProductHolder$i {
251  public:
252 CartesianProductHolder$i($for j, [[const Generator$j&amp; g$j]])
253       : $for j, [[g$(j)_(g$j)]] {}
254   template &lt;$for j, [[typename T$j]]&gt;
255   operator ParamGenerator&lt; ::testing::tuple&lt;$for j, [[T$j]]&gt; &gt;() const {
256     return ParamGenerator&lt; ::testing::tuple&lt;$for j, [[T$j]]&gt; &gt;(
257         new CartesianProductGenerator$i&lt;$for j, [[T$j]]&gt;(
258 $for j,[[
259 
260         static_cast&lt;ParamGenerator&lt;T$j&gt; &gt;(g$(j)_)
261 ]]));
262   }
263 
264  private:
265   // No implementation - assignment is unsupported.
266   void operator=(const CartesianProductHolder$i&amp; other);
267 
268 
269 $for j [[
270   const Generator$j g$(j)_;
271 
272 ]]
273 };  // class CartesianProductHolder$i
274 
275 ]]
276 
277 # endif  // GTEST_HAS_COMBINE
278 
279 }  // namespace internal
280 }  // namespace testing
281 
282 #endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_
    </pre>
  </body>
</html>
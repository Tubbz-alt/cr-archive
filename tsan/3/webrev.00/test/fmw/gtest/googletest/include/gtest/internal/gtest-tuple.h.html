<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/fmw/gtest/googletest/include/gtest/internal/gtest-tuple.h</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // This file was GENERATED by command:
   2 //     pump.py gtest-tuple.h.pump
   3 // DO NOT EDIT BY HAND!!!
   4 
   5 // Copyright 2009 Google Inc.
   6 // All Rights Reserved.
   7 //
   8 // Redistribution and use in source and binary forms, with or without
   9 // modification, are permitted provided that the following conditions are
  10 // met:
  11 //
  12 //     * Redistributions of source code must retain the above copyright
  13 // notice, this list of conditions and the following disclaimer.
  14 //     * Redistributions in binary form must reproduce the above
  15 // copyright notice, this list of conditions and the following disclaimer
  16 // in the documentation and/or other materials provided with the
  17 // distribution.
  18 //     * Neither the name of Google Inc. nor the names of its
  19 // contributors may be used to endorse or promote products derived from
  20 // this software without specific prior written permission.
  21 //
  22 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  23 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  24 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  25 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  26 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  27 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  28 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  29 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  30 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  32 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33 
  34 
  35 // Implements a subset of TR1 tuple needed by Google Test and Google Mock.
  36 
  37 // GOOGLETEST_CM0001 DO NOT DELETE
  38 
  39 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TUPLE_H_
  40 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TUPLE_H_
  41 
  42 #include &lt;utility&gt;  // For ::std::pair.
  43 
  44 // The compiler used in Symbian has a bug that prevents us from declaring the
  45 // tuple template as a friend (it complains that tuple is redefined).  This
  46 // bypasses the bug by declaring the members that should otherwise be
  47 // private as public.
  48 // Sun Studio versions &lt; 12 also have the above bug.
  49 #if defined(__SYMBIAN32__) || (defined(__SUNPRO_CC) &amp;&amp; __SUNPRO_CC &lt; 0x590)
  50 # define GTEST_DECLARE_TUPLE_AS_FRIEND_ public:
  51 #else
  52 # define GTEST_DECLARE_TUPLE_AS_FRIEND_ \
  53     template &lt;GTEST_10_TYPENAMES_(U)&gt; friend class tuple; \
  54    private:
  55 #endif
  56 
  57 // Visual Studio 2010, 2012, and 2013 define symbols in std::tr1 that conflict
  58 // with our own definitions. Therefore using our own tuple does not work on
  59 // those compilers.
  60 #if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1600  /* 1600 is Visual Studio 2010 */
  61 # error &quot;gtest&#39;s tuple doesn&#39;t compile on Visual Studio 2010 or later. \
  62 GTEST_USE_OWN_TR1_TUPLE must be set to 0 on those compilers.&quot;
  63 #endif
  64 
  65 // GTEST_n_TUPLE_(T) is the type of an n-tuple.
  66 #define GTEST_0_TUPLE_(T) tuple&lt;&gt;
  67 #define GTEST_1_TUPLE_(T) tuple&lt;T##0, void, void, void, void, void, void, \
  68     void, void, void&gt;
  69 #define GTEST_2_TUPLE_(T) tuple&lt;T##0, T##1, void, void, void, void, void, \
  70     void, void, void&gt;
  71 #define GTEST_3_TUPLE_(T) tuple&lt;T##0, T##1, T##2, void, void, void, void, \
  72     void, void, void&gt;
  73 #define GTEST_4_TUPLE_(T) tuple&lt;T##0, T##1, T##2, T##3, void, void, void, \
  74     void, void, void&gt;
  75 #define GTEST_5_TUPLE_(T) tuple&lt;T##0, T##1, T##2, T##3, T##4, void, void, \
  76     void, void, void&gt;
  77 #define GTEST_6_TUPLE_(T) tuple&lt;T##0, T##1, T##2, T##3, T##4, T##5, void, \
  78     void, void, void&gt;
  79 #define GTEST_7_TUPLE_(T) tuple&lt;T##0, T##1, T##2, T##3, T##4, T##5, T##6, \
  80     void, void, void&gt;
  81 #define GTEST_8_TUPLE_(T) tuple&lt;T##0, T##1, T##2, T##3, T##4, T##5, T##6, \
  82     T##7, void, void&gt;
  83 #define GTEST_9_TUPLE_(T) tuple&lt;T##0, T##1, T##2, T##3, T##4, T##5, T##6, \
  84     T##7, T##8, void&gt;
  85 #define GTEST_10_TUPLE_(T) tuple&lt;T##0, T##1, T##2, T##3, T##4, T##5, T##6, \
  86     T##7, T##8, T##9&gt;
  87 
  88 // GTEST_n_TYPENAMES_(T) declares a list of n typenames.
  89 #define GTEST_0_TYPENAMES_(T)
  90 #define GTEST_1_TYPENAMES_(T) typename T##0
  91 #define GTEST_2_TYPENAMES_(T) typename T##0, typename T##1
  92 #define GTEST_3_TYPENAMES_(T) typename T##0, typename T##1, typename T##2
  93 #define GTEST_4_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \
  94     typename T##3
  95 #define GTEST_5_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \
  96     typename T##3, typename T##4
  97 #define GTEST_6_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \
  98     typename T##3, typename T##4, typename T##5
  99 #define GTEST_7_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \
 100     typename T##3, typename T##4, typename T##5, typename T##6
 101 #define GTEST_8_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \
 102     typename T##3, typename T##4, typename T##5, typename T##6, typename T##7
 103 #define GTEST_9_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \
 104     typename T##3, typename T##4, typename T##5, typename T##6, \
 105     typename T##7, typename T##8
 106 #define GTEST_10_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \
 107     typename T##3, typename T##4, typename T##5, typename T##6, \
 108     typename T##7, typename T##8, typename T##9
 109 
 110 // In theory, defining stuff in the ::std namespace is undefined
 111 // behavior.  We can do this as we are playing the role of a standard
 112 // library vendor.
 113 namespace std {
 114 namespace tr1 {
 115 
 116 template &lt;typename T0 = void, typename T1 = void, typename T2 = void,
 117     typename T3 = void, typename T4 = void, typename T5 = void,
 118     typename T6 = void, typename T7 = void, typename T8 = void,
 119     typename T9 = void&gt;
 120 class tuple;
 121 
 122 // Anything in namespace gtest_internal is Google Test&#39;s INTERNAL
 123 // IMPLEMENTATION DETAIL and MUST NOT BE USED DIRECTLY in user code.
 124 namespace gtest_internal {
 125 
 126 // ByRef&lt;T&gt;::type is T if T is a reference; otherwise it&#39;s const T&amp;.
 127 template &lt;typename T&gt;
 128 struct ByRef { typedef const T&amp; type; };  // NOLINT
 129 template &lt;typename T&gt;
 130 struct ByRef&lt;T&amp;&gt; { typedef T&amp; type; };  // NOLINT
 131 
 132 // A handy wrapper for ByRef.
 133 #define GTEST_BY_REF_(T) typename ::std::tr1::gtest_internal::ByRef&lt;T&gt;::type
 134 
 135 // AddRef&lt;T&gt;::type is T if T is a reference; otherwise it&#39;s T&amp;.  This
 136 // is the same as tr1::add_reference&lt;T&gt;::type.
 137 template &lt;typename T&gt;
 138 struct AddRef { typedef T&amp; type; };  // NOLINT
 139 template &lt;typename T&gt;
 140 struct AddRef&lt;T&amp;&gt; { typedef T&amp; type; };  // NOLINT
 141 
 142 // A handy wrapper for AddRef.
 143 #define GTEST_ADD_REF_(T) typename ::std::tr1::gtest_internal::AddRef&lt;T&gt;::type
 144 
 145 // A helper for implementing get&lt;k&gt;().
 146 template &lt;int k&gt; class Get;
 147 
 148 // A helper for implementing tuple_element&lt;k, T&gt;.  kIndexValid is true
 149 // iff k &lt; the number of fields in tuple type T.
 150 template &lt;bool kIndexValid, int kIndex, class Tuple&gt;
 151 struct TupleElement;
 152 
 153 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 154 struct TupleElement&lt;true, 0, GTEST_10_TUPLE_(T) &gt; {
 155   typedef T0 type;
 156 };
 157 
 158 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 159 struct TupleElement&lt;true, 1, GTEST_10_TUPLE_(T) &gt; {
 160   typedef T1 type;
 161 };
 162 
 163 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 164 struct TupleElement&lt;true, 2, GTEST_10_TUPLE_(T) &gt; {
 165   typedef T2 type;
 166 };
 167 
 168 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 169 struct TupleElement&lt;true, 3, GTEST_10_TUPLE_(T) &gt; {
 170   typedef T3 type;
 171 };
 172 
 173 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 174 struct TupleElement&lt;true, 4, GTEST_10_TUPLE_(T) &gt; {
 175   typedef T4 type;
 176 };
 177 
 178 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 179 struct TupleElement&lt;true, 5, GTEST_10_TUPLE_(T) &gt; {
 180   typedef T5 type;
 181 };
 182 
 183 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 184 struct TupleElement&lt;true, 6, GTEST_10_TUPLE_(T) &gt; {
 185   typedef T6 type;
 186 };
 187 
 188 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 189 struct TupleElement&lt;true, 7, GTEST_10_TUPLE_(T) &gt; {
 190   typedef T7 type;
 191 };
 192 
 193 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 194 struct TupleElement&lt;true, 8, GTEST_10_TUPLE_(T) &gt; {
 195   typedef T8 type;
 196 };
 197 
 198 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 199 struct TupleElement&lt;true, 9, GTEST_10_TUPLE_(T) &gt; {
 200   typedef T9 type;
 201 };
 202 
 203 }  // namespace gtest_internal
 204 
 205 template &lt;&gt;
 206 class tuple&lt;&gt; {
 207  public:
 208   tuple() {}
 209   tuple(const tuple&amp; /* t */)  {}
 210   tuple&amp; operator=(const tuple&amp; /* t */) { return *this; }
 211 };
 212 
 213 template &lt;GTEST_1_TYPENAMES_(T)&gt;
 214 class GTEST_1_TUPLE_(T) {
 215  public:
 216   template &lt;int k&gt; friend class gtest_internal::Get;
 217 
 218   tuple() : f0_() {}
 219 
 220   explicit tuple(GTEST_BY_REF_(T0) f0) : f0_(f0) {}
 221 
 222   tuple(const tuple&amp; t) : f0_(t.f0_) {}
 223 
 224   template &lt;GTEST_1_TYPENAMES_(U)&gt;
 225   tuple(const GTEST_1_TUPLE_(U)&amp; t) : f0_(t.f0_) {}
 226 
 227   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 228 
 229   template &lt;GTEST_1_TYPENAMES_(U)&gt;
 230   tuple&amp; operator=(const GTEST_1_TUPLE_(U)&amp; t) {
 231     return CopyFrom(t);
 232   }
 233 
 234   GTEST_DECLARE_TUPLE_AS_FRIEND_
 235 
 236   template &lt;GTEST_1_TYPENAMES_(U)&gt;
 237   tuple&amp; CopyFrom(const GTEST_1_TUPLE_(U)&amp; t) {
 238     f0_ = t.f0_;
 239     return *this;
 240   }
 241 
 242   T0 f0_;
 243 };
 244 
 245 template &lt;GTEST_2_TYPENAMES_(T)&gt;
 246 class GTEST_2_TUPLE_(T) {
 247  public:
 248   template &lt;int k&gt; friend class gtest_internal::Get;
 249 
 250   tuple() : f0_(), f1_() {}
 251 
 252   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1) : f0_(f0),
 253       f1_(f1) {}
 254 
 255   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_) {}
 256 
 257   template &lt;GTEST_2_TYPENAMES_(U)&gt;
 258   tuple(const GTEST_2_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_) {}
 259   template &lt;typename U0, typename U1&gt;
 260   tuple(const ::std::pair&lt;U0, U1&gt;&amp; p) : f0_(p.first), f1_(p.second) {}
 261 
 262   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 263 
 264   template &lt;GTEST_2_TYPENAMES_(U)&gt;
 265   tuple&amp; operator=(const GTEST_2_TUPLE_(U)&amp; t) {
 266     return CopyFrom(t);
 267   }
 268   template &lt;typename U0, typename U1&gt;
 269   tuple&amp; operator=(const ::std::pair&lt;U0, U1&gt;&amp; p) {
 270     f0_ = p.first;
 271     f1_ = p.second;
 272     return *this;
 273   }
 274 
 275   GTEST_DECLARE_TUPLE_AS_FRIEND_
 276 
 277   template &lt;GTEST_2_TYPENAMES_(U)&gt;
 278   tuple&amp; CopyFrom(const GTEST_2_TUPLE_(U)&amp; t) {
 279     f0_ = t.f0_;
 280     f1_ = t.f1_;
 281     return *this;
 282   }
 283 
 284   T0 f0_;
 285   T1 f1_;
 286 };
 287 
 288 template &lt;GTEST_3_TYPENAMES_(T)&gt;
 289 class GTEST_3_TUPLE_(T) {
 290  public:
 291   template &lt;int k&gt; friend class gtest_internal::Get;
 292 
 293   tuple() : f0_(), f1_(), f2_() {}
 294 
 295   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 296       GTEST_BY_REF_(T2) f2) : f0_(f0), f1_(f1), f2_(f2) {}
 297 
 298   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_) {}
 299 
 300   template &lt;GTEST_3_TYPENAMES_(U)&gt;
 301   tuple(const GTEST_3_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_) {}
 302 
 303   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 304 
 305   template &lt;GTEST_3_TYPENAMES_(U)&gt;
 306   tuple&amp; operator=(const GTEST_3_TUPLE_(U)&amp; t) {
 307     return CopyFrom(t);
 308   }
 309 
 310   GTEST_DECLARE_TUPLE_AS_FRIEND_
 311 
 312   template &lt;GTEST_3_TYPENAMES_(U)&gt;
 313   tuple&amp; CopyFrom(const GTEST_3_TUPLE_(U)&amp; t) {
 314     f0_ = t.f0_;
 315     f1_ = t.f1_;
 316     f2_ = t.f2_;
 317     return *this;
 318   }
 319 
 320   T0 f0_;
 321   T1 f1_;
 322   T2 f2_;
 323 };
 324 
 325 template &lt;GTEST_4_TYPENAMES_(T)&gt;
 326 class GTEST_4_TUPLE_(T) {
 327  public:
 328   template &lt;int k&gt; friend class gtest_internal::Get;
 329 
 330   tuple() : f0_(), f1_(), f2_(), f3_() {}
 331 
 332   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 333       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3) : f0_(f0), f1_(f1), f2_(f2),
 334       f3_(f3) {}
 335 
 336   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_) {}
 337 
 338   template &lt;GTEST_4_TYPENAMES_(U)&gt;
 339   tuple(const GTEST_4_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),
 340       f3_(t.f3_) {}
 341 
 342   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 343 
 344   template &lt;GTEST_4_TYPENAMES_(U)&gt;
 345   tuple&amp; operator=(const GTEST_4_TUPLE_(U)&amp; t) {
 346     return CopyFrom(t);
 347   }
 348 
 349   GTEST_DECLARE_TUPLE_AS_FRIEND_
 350 
 351   template &lt;GTEST_4_TYPENAMES_(U)&gt;
 352   tuple&amp; CopyFrom(const GTEST_4_TUPLE_(U)&amp; t) {
 353     f0_ = t.f0_;
 354     f1_ = t.f1_;
 355     f2_ = t.f2_;
 356     f3_ = t.f3_;
 357     return *this;
 358   }
 359 
 360   T0 f0_;
 361   T1 f1_;
 362   T2 f2_;
 363   T3 f3_;
 364 };
 365 
 366 template &lt;GTEST_5_TYPENAMES_(T)&gt;
 367 class GTEST_5_TUPLE_(T) {
 368  public:
 369   template &lt;int k&gt; friend class gtest_internal::Get;
 370 
 371   tuple() : f0_(), f1_(), f2_(), f3_(), f4_() {}
 372 
 373   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 374       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3,
 375       GTEST_BY_REF_(T4) f4) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4) {}
 376 
 377   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),
 378       f4_(t.f4_) {}
 379 
 380   template &lt;GTEST_5_TYPENAMES_(U)&gt;
 381   tuple(const GTEST_5_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),
 382       f3_(t.f3_), f4_(t.f4_) {}
 383 
 384   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 385 
 386   template &lt;GTEST_5_TYPENAMES_(U)&gt;
 387   tuple&amp; operator=(const GTEST_5_TUPLE_(U)&amp; t) {
 388     return CopyFrom(t);
 389   }
 390 
 391   GTEST_DECLARE_TUPLE_AS_FRIEND_
 392 
 393   template &lt;GTEST_5_TYPENAMES_(U)&gt;
 394   tuple&amp; CopyFrom(const GTEST_5_TUPLE_(U)&amp; t) {
 395     f0_ = t.f0_;
 396     f1_ = t.f1_;
 397     f2_ = t.f2_;
 398     f3_ = t.f3_;
 399     f4_ = t.f4_;
 400     return *this;
 401   }
 402 
 403   T0 f0_;
 404   T1 f1_;
 405   T2 f2_;
 406   T3 f3_;
 407   T4 f4_;
 408 };
 409 
 410 template &lt;GTEST_6_TYPENAMES_(T)&gt;
 411 class GTEST_6_TUPLE_(T) {
 412  public:
 413   template &lt;int k&gt; friend class gtest_internal::Get;
 414 
 415   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_() {}
 416 
 417   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 418       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,
 419       GTEST_BY_REF_(T5) f5) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4),
 420       f5_(f5) {}
 421 
 422   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),
 423       f4_(t.f4_), f5_(t.f5_) {}
 424 
 425   template &lt;GTEST_6_TYPENAMES_(U)&gt;
 426   tuple(const GTEST_6_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),
 427       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_) {}
 428 
 429   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 430 
 431   template &lt;GTEST_6_TYPENAMES_(U)&gt;
 432   tuple&amp; operator=(const GTEST_6_TUPLE_(U)&amp; t) {
 433     return CopyFrom(t);
 434   }
 435 
 436   GTEST_DECLARE_TUPLE_AS_FRIEND_
 437 
 438   template &lt;GTEST_6_TYPENAMES_(U)&gt;
 439   tuple&amp; CopyFrom(const GTEST_6_TUPLE_(U)&amp; t) {
 440     f0_ = t.f0_;
 441     f1_ = t.f1_;
 442     f2_ = t.f2_;
 443     f3_ = t.f3_;
 444     f4_ = t.f4_;
 445     f5_ = t.f5_;
 446     return *this;
 447   }
 448 
 449   T0 f0_;
 450   T1 f1_;
 451   T2 f2_;
 452   T3 f3_;
 453   T4 f4_;
 454   T5 f5_;
 455 };
 456 
 457 template &lt;GTEST_7_TYPENAMES_(T)&gt;
 458 class GTEST_7_TUPLE_(T) {
 459  public:
 460   template &lt;int k&gt; friend class gtest_internal::Get;
 461 
 462   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_() {}
 463 
 464   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 465       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,
 466       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6) : f0_(f0), f1_(f1), f2_(f2),
 467       f3_(f3), f4_(f4), f5_(f5), f6_(f6) {}
 468 
 469   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),
 470       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_) {}
 471 
 472   template &lt;GTEST_7_TYPENAMES_(U)&gt;
 473   tuple(const GTEST_7_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),
 474       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_) {}
 475 
 476   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 477 
 478   template &lt;GTEST_7_TYPENAMES_(U)&gt;
 479   tuple&amp; operator=(const GTEST_7_TUPLE_(U)&amp; t) {
 480     return CopyFrom(t);
 481   }
 482 
 483   GTEST_DECLARE_TUPLE_AS_FRIEND_
 484 
 485   template &lt;GTEST_7_TYPENAMES_(U)&gt;
 486   tuple&amp; CopyFrom(const GTEST_7_TUPLE_(U)&amp; t) {
 487     f0_ = t.f0_;
 488     f1_ = t.f1_;
 489     f2_ = t.f2_;
 490     f3_ = t.f3_;
 491     f4_ = t.f4_;
 492     f5_ = t.f5_;
 493     f6_ = t.f6_;
 494     return *this;
 495   }
 496 
 497   T0 f0_;
 498   T1 f1_;
 499   T2 f2_;
 500   T3 f3_;
 501   T4 f4_;
 502   T5 f5_;
 503   T6 f6_;
 504 };
 505 
 506 template &lt;GTEST_8_TYPENAMES_(T)&gt;
 507 class GTEST_8_TUPLE_(T) {
 508  public:
 509   template &lt;int k&gt; friend class gtest_internal::Get;
 510 
 511   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_(), f7_() {}
 512 
 513   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 514       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,
 515       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6,
 516       GTEST_BY_REF_(T7) f7) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4),
 517       f5_(f5), f6_(f6), f7_(f7) {}
 518 
 519   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),
 520       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_) {}
 521 
 522   template &lt;GTEST_8_TYPENAMES_(U)&gt;
 523   tuple(const GTEST_8_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),
 524       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_) {}
 525 
 526   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 527 
 528   template &lt;GTEST_8_TYPENAMES_(U)&gt;
 529   tuple&amp; operator=(const GTEST_8_TUPLE_(U)&amp; t) {
 530     return CopyFrom(t);
 531   }
 532 
 533   GTEST_DECLARE_TUPLE_AS_FRIEND_
 534 
 535   template &lt;GTEST_8_TYPENAMES_(U)&gt;
 536   tuple&amp; CopyFrom(const GTEST_8_TUPLE_(U)&amp; t) {
 537     f0_ = t.f0_;
 538     f1_ = t.f1_;
 539     f2_ = t.f2_;
 540     f3_ = t.f3_;
 541     f4_ = t.f4_;
 542     f5_ = t.f5_;
 543     f6_ = t.f6_;
 544     f7_ = t.f7_;
 545     return *this;
 546   }
 547 
 548   T0 f0_;
 549   T1 f1_;
 550   T2 f2_;
 551   T3 f3_;
 552   T4 f4_;
 553   T5 f5_;
 554   T6 f6_;
 555   T7 f7_;
 556 };
 557 
 558 template &lt;GTEST_9_TYPENAMES_(T)&gt;
 559 class GTEST_9_TUPLE_(T) {
 560  public:
 561   template &lt;int k&gt; friend class gtest_internal::Get;
 562 
 563   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_(), f7_(), f8_() {}
 564 
 565   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 566       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,
 567       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6, GTEST_BY_REF_(T7) f7,
 568       GTEST_BY_REF_(T8) f8) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4),
 569       f5_(f5), f6_(f6), f7_(f7), f8_(f8) {}
 570 
 571   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),
 572       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_) {}
 573 
 574   template &lt;GTEST_9_TYPENAMES_(U)&gt;
 575   tuple(const GTEST_9_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),
 576       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_) {}
 577 
 578   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 579 
 580   template &lt;GTEST_9_TYPENAMES_(U)&gt;
 581   tuple&amp; operator=(const GTEST_9_TUPLE_(U)&amp; t) {
 582     return CopyFrom(t);
 583   }
 584 
 585   GTEST_DECLARE_TUPLE_AS_FRIEND_
 586 
 587   template &lt;GTEST_9_TYPENAMES_(U)&gt;
 588   tuple&amp; CopyFrom(const GTEST_9_TUPLE_(U)&amp; t) {
 589     f0_ = t.f0_;
 590     f1_ = t.f1_;
 591     f2_ = t.f2_;
 592     f3_ = t.f3_;
 593     f4_ = t.f4_;
 594     f5_ = t.f5_;
 595     f6_ = t.f6_;
 596     f7_ = t.f7_;
 597     f8_ = t.f8_;
 598     return *this;
 599   }
 600 
 601   T0 f0_;
 602   T1 f1_;
 603   T2 f2_;
 604   T3 f3_;
 605   T4 f4_;
 606   T5 f5_;
 607   T6 f6_;
 608   T7 f7_;
 609   T8 f8_;
 610 };
 611 
 612 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 613 class tuple {
 614  public:
 615   template &lt;int k&gt; friend class gtest_internal::Get;
 616 
 617   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_(), f7_(), f8_(),
 618       f9_() {}
 619 
 620   explicit tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,
 621       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,
 622       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6, GTEST_BY_REF_(T7) f7,
 623       GTEST_BY_REF_(T8) f8, GTEST_BY_REF_(T9) f9) : f0_(f0), f1_(f1), f2_(f2),
 624       f3_(f3), f4_(f4), f5_(f5), f6_(f6), f7_(f7), f8_(f8), f9_(f9) {}
 625 
 626   tuple(const tuple&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),
 627       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_), f9_(t.f9_) {}
 628 
 629   template &lt;GTEST_10_TYPENAMES_(U)&gt;
 630   tuple(const GTEST_10_TUPLE_(U)&amp; t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),
 631       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_),
 632       f9_(t.f9_) {}
 633 
 634   tuple&amp; operator=(const tuple&amp; t) { return CopyFrom(t); }
 635 
 636   template &lt;GTEST_10_TYPENAMES_(U)&gt;
 637   tuple&amp; operator=(const GTEST_10_TUPLE_(U)&amp; t) {
 638     return CopyFrom(t);
 639   }
 640 
 641   GTEST_DECLARE_TUPLE_AS_FRIEND_
 642 
 643   template &lt;GTEST_10_TYPENAMES_(U)&gt;
 644   tuple&amp; CopyFrom(const GTEST_10_TUPLE_(U)&amp; t) {
 645     f0_ = t.f0_;
 646     f1_ = t.f1_;
 647     f2_ = t.f2_;
 648     f3_ = t.f3_;
 649     f4_ = t.f4_;
 650     f5_ = t.f5_;
 651     f6_ = t.f6_;
 652     f7_ = t.f7_;
 653     f8_ = t.f8_;
 654     f9_ = t.f9_;
 655     return *this;
 656   }
 657 
 658   T0 f0_;
 659   T1 f1_;
 660   T2 f2_;
 661   T3 f3_;
 662   T4 f4_;
 663   T5 f5_;
 664   T6 f6_;
 665   T7 f7_;
 666   T8 f8_;
 667   T9 f9_;
 668 };
 669 
 670 // 6.1.3.2 Tuple creation functions.
 671 
 672 // Known limitations: we don&#39;t support passing an
 673 // std::tr1::reference_wrapper&lt;T&gt; to make_tuple().  And we don&#39;t
 674 // implement tie().
 675 
 676 inline tuple&lt;&gt; make_tuple() { return tuple&lt;&gt;(); }
 677 
 678 template &lt;GTEST_1_TYPENAMES_(T)&gt;
 679 inline GTEST_1_TUPLE_(T) make_tuple(const T0&amp; f0) {
 680   return GTEST_1_TUPLE_(T)(f0);
 681 }
 682 
 683 template &lt;GTEST_2_TYPENAMES_(T)&gt;
 684 inline GTEST_2_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1) {
 685   return GTEST_2_TUPLE_(T)(f0, f1);
 686 }
 687 
 688 template &lt;GTEST_3_TYPENAMES_(T)&gt;
 689 inline GTEST_3_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2) {
 690   return GTEST_3_TUPLE_(T)(f0, f1, f2);
 691 }
 692 
 693 template &lt;GTEST_4_TYPENAMES_(T)&gt;
 694 inline GTEST_4_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2,
 695     const T3&amp; f3) {
 696   return GTEST_4_TUPLE_(T)(f0, f1, f2, f3);
 697 }
 698 
 699 template &lt;GTEST_5_TYPENAMES_(T)&gt;
 700 inline GTEST_5_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2,
 701     const T3&amp; f3, const T4&amp; f4) {
 702   return GTEST_5_TUPLE_(T)(f0, f1, f2, f3, f4);
 703 }
 704 
 705 template &lt;GTEST_6_TYPENAMES_(T)&gt;
 706 inline GTEST_6_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2,
 707     const T3&amp; f3, const T4&amp; f4, const T5&amp; f5) {
 708   return GTEST_6_TUPLE_(T)(f0, f1, f2, f3, f4, f5);
 709 }
 710 
 711 template &lt;GTEST_7_TYPENAMES_(T)&gt;
 712 inline GTEST_7_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2,
 713     const T3&amp; f3, const T4&amp; f4, const T5&amp; f5, const T6&amp; f6) {
 714   return GTEST_7_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6);
 715 }
 716 
 717 template &lt;GTEST_8_TYPENAMES_(T)&gt;
 718 inline GTEST_8_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2,
 719     const T3&amp; f3, const T4&amp; f4, const T5&amp; f5, const T6&amp; f6, const T7&amp; f7) {
 720   return GTEST_8_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6, f7);
 721 }
 722 
 723 template &lt;GTEST_9_TYPENAMES_(T)&gt;
 724 inline GTEST_9_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2,
 725     const T3&amp; f3, const T4&amp; f4, const T5&amp; f5, const T6&amp; f6, const T7&amp; f7,
 726     const T8&amp; f8) {
 727   return GTEST_9_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6, f7, f8);
 728 }
 729 
 730 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 731 inline GTEST_10_TUPLE_(T) make_tuple(const T0&amp; f0, const T1&amp; f1, const T2&amp; f2,
 732     const T3&amp; f3, const T4&amp; f4, const T5&amp; f5, const T6&amp; f6, const T7&amp; f7,
 733     const T8&amp; f8, const T9&amp; f9) {
 734   return GTEST_10_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6, f7, f8, f9);
 735 }
 736 
 737 // 6.1.3.3 Tuple helper classes.
 738 
 739 template &lt;typename Tuple&gt; struct tuple_size;
 740 
 741 template &lt;GTEST_0_TYPENAMES_(T)&gt;
 742 struct tuple_size&lt;GTEST_0_TUPLE_(T) &gt; {
 743   static const int value = 0;
 744 };
 745 
 746 template &lt;GTEST_1_TYPENAMES_(T)&gt;
 747 struct tuple_size&lt;GTEST_1_TUPLE_(T) &gt; {
 748   static const int value = 1;
 749 };
 750 
 751 template &lt;GTEST_2_TYPENAMES_(T)&gt;
 752 struct tuple_size&lt;GTEST_2_TUPLE_(T) &gt; {
 753   static const int value = 2;
 754 };
 755 
 756 template &lt;GTEST_3_TYPENAMES_(T)&gt;
 757 struct tuple_size&lt;GTEST_3_TUPLE_(T) &gt; {
 758   static const int value = 3;
 759 };
 760 
 761 template &lt;GTEST_4_TYPENAMES_(T)&gt;
 762 struct tuple_size&lt;GTEST_4_TUPLE_(T) &gt; {
 763   static const int value = 4;
 764 };
 765 
 766 template &lt;GTEST_5_TYPENAMES_(T)&gt;
 767 struct tuple_size&lt;GTEST_5_TUPLE_(T) &gt; {
 768   static const int value = 5;
 769 };
 770 
 771 template &lt;GTEST_6_TYPENAMES_(T)&gt;
 772 struct tuple_size&lt;GTEST_6_TUPLE_(T) &gt; {
 773   static const int value = 6;
 774 };
 775 
 776 template &lt;GTEST_7_TYPENAMES_(T)&gt;
 777 struct tuple_size&lt;GTEST_7_TUPLE_(T) &gt; {
 778   static const int value = 7;
 779 };
 780 
 781 template &lt;GTEST_8_TYPENAMES_(T)&gt;
 782 struct tuple_size&lt;GTEST_8_TUPLE_(T) &gt; {
 783   static const int value = 8;
 784 };
 785 
 786 template &lt;GTEST_9_TYPENAMES_(T)&gt;
 787 struct tuple_size&lt;GTEST_9_TUPLE_(T) &gt; {
 788   static const int value = 9;
 789 };
 790 
 791 template &lt;GTEST_10_TYPENAMES_(T)&gt;
 792 struct tuple_size&lt;GTEST_10_TUPLE_(T) &gt; {
 793   static const int value = 10;
 794 };
 795 
 796 template &lt;int k, class Tuple&gt;
 797 struct tuple_element {
 798   typedef typename gtest_internal::TupleElement&lt;
 799       k &lt; (tuple_size&lt;Tuple&gt;::value), k, Tuple&gt;::type type;
 800 };
 801 
 802 #define GTEST_TUPLE_ELEMENT_(k, Tuple) typename tuple_element&lt;k, Tuple &gt;::type
 803 
 804 // 6.1.3.4 Element access.
 805 
 806 namespace gtest_internal {
 807 
 808 template &lt;&gt;
 809 class Get&lt;0&gt; {
 810  public:
 811   template &lt;class Tuple&gt;
 812   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(0, Tuple))
 813   Field(Tuple&amp; t) { return t.f0_; }  // NOLINT
 814 
 815   template &lt;class Tuple&gt;
 816   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(0, Tuple))
 817   ConstField(const Tuple&amp; t) { return t.f0_; }
 818 };
 819 
 820 template &lt;&gt;
 821 class Get&lt;1&gt; {
 822  public:
 823   template &lt;class Tuple&gt;
 824   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(1, Tuple))
 825   Field(Tuple&amp; t) { return t.f1_; }  // NOLINT
 826 
 827   template &lt;class Tuple&gt;
 828   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(1, Tuple))
 829   ConstField(const Tuple&amp; t) { return t.f1_; }
 830 };
 831 
 832 template &lt;&gt;
 833 class Get&lt;2&gt; {
 834  public:
 835   template &lt;class Tuple&gt;
 836   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(2, Tuple))
 837   Field(Tuple&amp; t) { return t.f2_; }  // NOLINT
 838 
 839   template &lt;class Tuple&gt;
 840   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(2, Tuple))
 841   ConstField(const Tuple&amp; t) { return t.f2_; }
 842 };
 843 
 844 template &lt;&gt;
 845 class Get&lt;3&gt; {
 846  public:
 847   template &lt;class Tuple&gt;
 848   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(3, Tuple))
 849   Field(Tuple&amp; t) { return t.f3_; }  // NOLINT
 850 
 851   template &lt;class Tuple&gt;
 852   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(3, Tuple))
 853   ConstField(const Tuple&amp; t) { return t.f3_; }
 854 };
 855 
 856 template &lt;&gt;
 857 class Get&lt;4&gt; {
 858  public:
 859   template &lt;class Tuple&gt;
 860   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(4, Tuple))
 861   Field(Tuple&amp; t) { return t.f4_; }  // NOLINT
 862 
 863   template &lt;class Tuple&gt;
 864   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(4, Tuple))
 865   ConstField(const Tuple&amp; t) { return t.f4_; }
 866 };
 867 
 868 template &lt;&gt;
 869 class Get&lt;5&gt; {
 870  public:
 871   template &lt;class Tuple&gt;
 872   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(5, Tuple))
 873   Field(Tuple&amp; t) { return t.f5_; }  // NOLINT
 874 
 875   template &lt;class Tuple&gt;
 876   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(5, Tuple))
 877   ConstField(const Tuple&amp; t) { return t.f5_; }
 878 };
 879 
 880 template &lt;&gt;
 881 class Get&lt;6&gt; {
 882  public:
 883   template &lt;class Tuple&gt;
 884   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(6, Tuple))
 885   Field(Tuple&amp; t) { return t.f6_; }  // NOLINT
 886 
 887   template &lt;class Tuple&gt;
 888   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(6, Tuple))
 889   ConstField(const Tuple&amp; t) { return t.f6_; }
 890 };
 891 
 892 template &lt;&gt;
 893 class Get&lt;7&gt; {
 894  public:
 895   template &lt;class Tuple&gt;
 896   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(7, Tuple))
 897   Field(Tuple&amp; t) { return t.f7_; }  // NOLINT
 898 
 899   template &lt;class Tuple&gt;
 900   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(7, Tuple))
 901   ConstField(const Tuple&amp; t) { return t.f7_; }
 902 };
 903 
 904 template &lt;&gt;
 905 class Get&lt;8&gt; {
 906  public:
 907   template &lt;class Tuple&gt;
 908   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(8, Tuple))
 909   Field(Tuple&amp; t) { return t.f8_; }  // NOLINT
 910 
 911   template &lt;class Tuple&gt;
 912   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(8, Tuple))
 913   ConstField(const Tuple&amp; t) { return t.f8_; }
 914 };
 915 
 916 template &lt;&gt;
 917 class Get&lt;9&gt; {
 918  public:
 919   template &lt;class Tuple&gt;
 920   static GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(9, Tuple))
 921   Field(Tuple&amp; t) { return t.f9_; }  // NOLINT
 922 
 923   template &lt;class Tuple&gt;
 924   static GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(9, Tuple))
 925   ConstField(const Tuple&amp; t) { return t.f9_; }
 926 };
 927 
 928 }  // namespace gtest_internal
 929 
 930 template &lt;int k, GTEST_10_TYPENAMES_(T)&gt;
 931 GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(k, GTEST_10_TUPLE_(T)))
 932 get(GTEST_10_TUPLE_(T)&amp; t) {
 933   return gtest_internal::Get&lt;k&gt;::Field(t);
 934 }
 935 
 936 template &lt;int k, GTEST_10_TYPENAMES_(T)&gt;
 937 GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(k,  GTEST_10_TUPLE_(T)))
 938 get(const GTEST_10_TUPLE_(T)&amp; t) {
 939   return gtest_internal::Get&lt;k&gt;::ConstField(t);
 940 }
 941 
 942 // 6.1.3.5 Relational operators
 943 
 944 // We only implement == and !=, as we don&#39;t have a need for the rest yet.
 945 
 946 namespace gtest_internal {
 947 
 948 // SameSizeTuplePrefixComparator&lt;k, k&gt;::Eq(t1, t2) returns true if the
 949 // first k fields of t1 equals the first k fields of t2.
 950 // SameSizeTuplePrefixComparator(k1, k2) would be a compiler error if
 951 // k1 != k2.
 952 template &lt;int kSize1, int kSize2&gt;
 953 struct SameSizeTuplePrefixComparator;
 954 
 955 template &lt;&gt;
 956 struct SameSizeTuplePrefixComparator&lt;0, 0&gt; {
 957   template &lt;class Tuple1, class Tuple2&gt;
 958   static bool Eq(const Tuple1&amp; /* t1 */, const Tuple2&amp; /* t2 */) {
 959     return true;
 960   }
 961 };
 962 
 963 template &lt;int k&gt;
 964 struct SameSizeTuplePrefixComparator&lt;k, k&gt; {
 965   template &lt;class Tuple1, class Tuple2&gt;
 966   static bool Eq(const Tuple1&amp; t1, const Tuple2&amp; t2) {
 967     return SameSizeTuplePrefixComparator&lt;k - 1, k - 1&gt;::Eq(t1, t2) &amp;&amp;
 968         ::std::tr1::get&lt;k - 1&gt;(t1) == ::std::tr1::get&lt;k - 1&gt;(t2);
 969   }
 970 };
 971 
 972 }  // namespace gtest_internal
 973 
 974 template &lt;GTEST_10_TYPENAMES_(T), GTEST_10_TYPENAMES_(U)&gt;
 975 inline bool operator==(const GTEST_10_TUPLE_(T)&amp; t,
 976                        const GTEST_10_TUPLE_(U)&amp; u) {
 977   return gtest_internal::SameSizeTuplePrefixComparator&lt;
 978       tuple_size&lt;GTEST_10_TUPLE_(T) &gt;::value,
 979       tuple_size&lt;GTEST_10_TUPLE_(U) &gt;::value&gt;::Eq(t, u);
 980 }
 981 
 982 template &lt;GTEST_10_TYPENAMES_(T), GTEST_10_TYPENAMES_(U)&gt;
 983 inline bool operator!=(const GTEST_10_TUPLE_(T)&amp; t,
 984                        const GTEST_10_TUPLE_(U)&amp; u) { return !(t == u); }
 985 
 986 // 6.1.4 Pairs.
 987 // Unimplemented.
 988 
 989 }  // namespace tr1
 990 }  // namespace std
 991 
 992 #undef GTEST_0_TUPLE_
 993 #undef GTEST_1_TUPLE_
 994 #undef GTEST_2_TUPLE_
 995 #undef GTEST_3_TUPLE_
 996 #undef GTEST_4_TUPLE_
 997 #undef GTEST_5_TUPLE_
 998 #undef GTEST_6_TUPLE_
 999 #undef GTEST_7_TUPLE_
1000 #undef GTEST_8_TUPLE_
1001 #undef GTEST_9_TUPLE_
1002 #undef GTEST_10_TUPLE_
1003 
1004 #undef GTEST_0_TYPENAMES_
1005 #undef GTEST_1_TYPENAMES_
1006 #undef GTEST_2_TYPENAMES_
1007 #undef GTEST_3_TYPENAMES_
1008 #undef GTEST_4_TYPENAMES_
1009 #undef GTEST_5_TYPENAMES_
1010 #undef GTEST_6_TYPENAMES_
1011 #undef GTEST_7_TYPENAMES_
1012 #undef GTEST_8_TYPENAMES_
1013 #undef GTEST_9_TYPENAMES_
1014 #undef GTEST_10_TYPENAMES_
1015 
1016 #undef GTEST_DECLARE_TUPLE_AS_FRIEND_
1017 #undef GTEST_BY_REF_
1018 #undef GTEST_ADD_REF_
1019 #undef GTEST_TUPLE_ELEMENT_
1020 
1021 #endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TUPLE_H_
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/src/gtest-port.cc</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Copyright 2008, Google Inc.
  2 // All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //     * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //     * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //     * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 //
 30 // Author: wan@google.com (Zhanyong Wan)
 31 
 32 #include &quot;gtest/internal/gtest-port.h&quot;
 33 
 34 #include &lt;limits.h&gt;
 35 #include &lt;stdlib.h&gt;
 36 #include &lt;stdio.h&gt;
 37 #include &lt;string.h&gt;
 38 
 39 #if GTEST_OS_WINDOWS_MOBILE
 40 # include &lt;windows.h&gt;  // For TerminateProcess()
 41 #elif GTEST_OS_WINDOWS
 42 # include &lt;io.h&gt;
 43 # include &lt;sys/stat.h&gt;
 44 #else
 45 # include &lt;unistd.h&gt;
 46 #endif  // GTEST_OS_WINDOWS_MOBILE
 47 
 48 #if GTEST_OS_MAC
 49 # include &lt;mach/mach_init.h&gt;
 50 # include &lt;mach/task.h&gt;
 51 # include &lt;mach/vm_map.h&gt;
 52 #endif  // GTEST_OS_MAC
 53 
 54 #if GTEST_OS_QNX
 55 # include &lt;devctl.h&gt;
 56 # include &lt;sys/procfs.h&gt;
 57 #endif  // GTEST_OS_QNX
 58 
 59 #include &quot;gtest/gtest-spi.h&quot;
 60 #include &quot;gtest/gtest-message.h&quot;
 61 #include &quot;gtest/internal/gtest-internal.h&quot;
 62 #include &quot;gtest/internal/gtest-string.h&quot;
 63 
 64 // Indicates that this translation unit is part of Google Test&#39;s
 65 // implementation.  It must come before gtest-internal-inl.h is
 66 // included, or there will be a compiler error.  This trick is to
 67 // prevent a user from accidentally including gtest-internal-inl.h in
 68 // his code.
 69 #define GTEST_IMPLEMENTATION_ 1
 70 #include &quot;src/gtest-internal-inl.h&quot;
 71 #undef GTEST_IMPLEMENTATION_
 72 
 73 namespace testing {
 74 namespace internal {
 75 
 76 #if defined(_MSC_VER) || defined(__BORLANDC__)
 77 // MSVC and C++Builder do not provide a definition of STDERR_FILENO.
 78 const int kStdOutFileno = 1;
 79 const int kStdErrFileno = 2;
 80 #else
 81 const int kStdOutFileno = STDOUT_FILENO;
 82 const int kStdErrFileno = STDERR_FILENO;
 83 #endif  // _MSC_VER
 84 
 85 #if GTEST_OS_MAC
 86 
 87 // Returns the number of threads running in the process, or 0 to indicate that
 88 // we cannot detect it.
 89 size_t GetThreadCount() {
 90   const task_t task = mach_task_self();
 91   mach_msg_type_number_t thread_count;
 92   thread_act_array_t thread_list;
 93   const kern_return_t status = task_threads(task, &amp;thread_list, &amp;thread_count);
 94   if (status == KERN_SUCCESS) {
 95     // task_threads allocates resources in thread_list and we need to free them
 96     // to avoid leaks.
 97     vm_deallocate(task,
 98                   reinterpret_cast&lt;vm_address_t&gt;(thread_list),
 99                   sizeof(thread_t) * thread_count);
100     return static_cast&lt;size_t&gt;(thread_count);
101   } else {
102     return 0;
103   }
104 }
105 
106 #elif GTEST_OS_QNX
107 
108 // Returns the number of threads running in the process, or 0 to indicate that
109 // we cannot detect it.
110 size_t GetThreadCount() {
111   const int fd = open(&quot;/proc/self/as&quot;, O_RDONLY);
112   if (fd &lt; 0) {
113     return 0;
114   }
115   procfs_info process_info;
116   const int status =
117       devctl(fd, DCMD_PROC_INFO, &amp;process_info, sizeof(process_info), NULL);
118   close(fd);
119   if (status == EOK) {
120     return static_cast&lt;size_t&gt;(process_info.num_threads);
121   } else {
122     return 0;
123   }
124 }
125 
126 #else
127 
128 size_t GetThreadCount() {
129   // There&#39;s no portable way to detect the number of threads, so we just
130   // return 0 to indicate that we cannot detect it.
131   return 0;
132 }
133 
134 #endif  // GTEST_OS_MAC
135 
136 #if GTEST_USES_POSIX_RE
137 
138 // Implements RE.  Currently only needed for death tests.
139 
140 RE::~RE() {
141   if (is_valid_) {
142     // regfree&#39;ing an invalid regex might crash because the content
143     // of the regex is undefined. Since the regex&#39;s are essentially
144     // the same, one cannot be valid (or invalid) without the other
145     // being so too.
146     regfree(&amp;partial_regex_);
147     regfree(&amp;full_regex_);
148   }
149   free(const_cast&lt;char*&gt;(pattern_));
150 }
151 
152 // Returns true iff regular expression re matches the entire str.
153 bool RE::FullMatch(const char* str, const RE&amp; re) {
154   if (!re.is_valid_) return false;
155 
156   regmatch_t match;
157   return regexec(&amp;re.full_regex_, str, 1, &amp;match, 0) == 0;
158 }
159 
160 // Returns true iff regular expression re matches a substring of str
161 // (including str itself).
162 bool RE::PartialMatch(const char* str, const RE&amp; re) {
163   if (!re.is_valid_) return false;
164 
165   regmatch_t match;
166   return regexec(&amp;re.partial_regex_, str, 1, &amp;match, 0) == 0;
167 }
168 
169 // Initializes an RE from its string representation.
170 void RE::Init(const char* regex) {
171   pattern_ = posix::StrDup(regex);
172 
173   // Reserves enough bytes to hold the regular expression used for a
174   // full match.
175   const size_t full_regex_len = strlen(regex) + 10;
176   char* const full_pattern = new char[full_regex_len];
177 
178   snprintf(full_pattern, full_regex_len, &quot;^(%s)$&quot;, regex);
179   is_valid_ = regcomp(&amp;full_regex_, full_pattern, REG_EXTENDED) == 0;
180   // We want to call regcomp(&amp;partial_regex_, ...) even if the
181   // previous expression returns false.  Otherwise partial_regex_ may
182   // not be properly initialized can may cause trouble when it&#39;s
183   // freed.
184   //
185   // Some implementation of POSIX regex (e.g. on at least some
186   // versions of Cygwin) doesn&#39;t accept the empty string as a valid
187   // regex.  We change it to an equivalent form &quot;()&quot; to be safe.
188   if (is_valid_) {
189     const char* const partial_regex = (*regex == &#39;\0&#39;) ? &quot;()&quot; : regex;
190     is_valid_ = regcomp(&amp;partial_regex_, partial_regex, REG_EXTENDED) == 0;
191   }
192   EXPECT_TRUE(is_valid_)
193       &lt;&lt; &quot;Regular expression \&quot;&quot; &lt;&lt; regex
194       &lt;&lt; &quot;\&quot; is not a valid POSIX Extended regular expression.&quot;;
195 
196   delete[] full_pattern;
197 }
198 
199 #elif GTEST_USES_SIMPLE_RE
200 
201 // Returns true iff ch appears anywhere in str (excluding the
202 // terminating &#39;\0&#39; character).
203 bool IsInSet(char ch, const char* str) {
204   return ch != &#39;\0&#39; &amp;&amp; strchr(str, ch) != NULL;
205 }
206 
207 // Returns true iff ch belongs to the given classification.  Unlike
208 // similar functions in &lt;ctype.h&gt;, these aren&#39;t affected by the
209 // current locale.
210 bool IsAsciiDigit(char ch) { return &#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;; }
211 bool IsAsciiPunct(char ch) {
212   return IsInSet(ch, &quot;^-!\&quot;#$%&amp;&#39;()*+,./:;&lt;=&gt;?@[\\]_`{|}~&quot;);
213 }
214 bool IsRepeat(char ch) { return IsInSet(ch, &quot;?*+&quot;); }
215 bool IsAsciiWhiteSpace(char ch) { return IsInSet(ch, &quot; \f\n\r\t\v&quot;); }
216 bool IsAsciiWordChar(char ch) {
217   return (&#39;a&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;z&#39;) || (&#39;A&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;Z&#39;) ||
218       (&#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;) || ch == &#39;_&#39;;
219 }
220 
221 // Returns true iff &quot;\\c&quot; is a supported escape sequence.
222 bool IsValidEscape(char c) {
223   return (IsAsciiPunct(c) || IsInSet(c, &quot;dDfnrsStvwW&quot;));
224 }
225 
226 // Returns true iff the given atom (specified by escaped and pattern)
227 // matches ch.  The result is undefined if the atom is invalid.
228 bool AtomMatchesChar(bool escaped, char pattern_char, char ch) {
229   if (escaped) {  // &quot;\\p&quot; where p is pattern_char.
230     switch (pattern_char) {
231       case &#39;d&#39;: return IsAsciiDigit(ch);
232       case &#39;D&#39;: return !IsAsciiDigit(ch);
233       case &#39;f&#39;: return ch == &#39;\f&#39;;
234       case &#39;n&#39;: return ch == &#39;\n&#39;;
235       case &#39;r&#39;: return ch == &#39;\r&#39;;
236       case &#39;s&#39;: return IsAsciiWhiteSpace(ch);
237       case &#39;S&#39;: return !IsAsciiWhiteSpace(ch);
238       case &#39;t&#39;: return ch == &#39;\t&#39;;
239       case &#39;v&#39;: return ch == &#39;\v&#39;;
240       case &#39;w&#39;: return IsAsciiWordChar(ch);
241       case &#39;W&#39;: return !IsAsciiWordChar(ch);
242     }
243     return IsAsciiPunct(pattern_char) &amp;&amp; pattern_char == ch;
244   }
245 
246   return (pattern_char == &#39;.&#39; &amp;&amp; ch != &#39;\n&#39;) || pattern_char == ch;
247 }
248 
249 // Helper function used by ValidateRegex() to format error messages.
250 std::string FormatRegexSyntaxError(const char* regex, int index) {
251   return (Message() &lt;&lt; &quot;Syntax error at index &quot; &lt;&lt; index
252           &lt;&lt; &quot; in simple regular expression \&quot;&quot; &lt;&lt; regex &lt;&lt; &quot;\&quot;: &quot;).GetString();
253 }
254 
255 // Generates non-fatal failures and returns false if regex is invalid;
256 // otherwise returns true.
257 bool ValidateRegex(const char* regex) {
258   if (regex == NULL) {
259     // TODO(wan@google.com): fix the source file location in the
260     // assertion failures to match where the regex is used in user
261     // code.
262     ADD_FAILURE() &lt;&lt; &quot;NULL is not a valid simple regular expression.&quot;;
263     return false;
264   }
265 
266   bool is_valid = true;
267 
268   // True iff ?, *, or + can follow the previous atom.
269   bool prev_repeatable = false;
270   for (int i = 0; regex[i]; i++) {
271     if (regex[i] == &#39;\\&#39;) {  // An escape sequence
272       i++;
273       if (regex[i] == &#39;\0&#39;) {
274         ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i - 1)
275                       &lt;&lt; &quot;&#39;\\&#39; cannot appear at the end.&quot;;
276         return false;
277       }
278 
279       if (!IsValidEscape(regex[i])) {
280         ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i - 1)
281                       &lt;&lt; &quot;invalid escape sequence \&quot;\\&quot; &lt;&lt; regex[i] &lt;&lt; &quot;\&quot;.&quot;;
282         is_valid = false;
283       }
284       prev_repeatable = true;
285     } else {  // Not an escape sequence.
286       const char ch = regex[i];
287 
288       if (ch == &#39;^&#39; &amp;&amp; i &gt; 0) {
289         ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i)
290                       &lt;&lt; &quot;&#39;^&#39; can only appear at the beginning.&quot;;
291         is_valid = false;
292       } else if (ch == &#39;$&#39; &amp;&amp; regex[i + 1] != &#39;\0&#39;) {
293         ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i)
294                       &lt;&lt; &quot;&#39;$&#39; can only appear at the end.&quot;;
295         is_valid = false;
296       } else if (IsInSet(ch, &quot;()[]{}|&quot;)) {
297         ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i)
298                       &lt;&lt; &quot;&#39;&quot; &lt;&lt; ch &lt;&lt; &quot;&#39; is unsupported.&quot;;
299         is_valid = false;
300       } else if (IsRepeat(ch) &amp;&amp; !prev_repeatable) {
301         ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i)
302                       &lt;&lt; &quot;&#39;&quot; &lt;&lt; ch &lt;&lt; &quot;&#39; can only follow a repeatable token.&quot;;
303         is_valid = false;
304       }
305 
306       prev_repeatable = !IsInSet(ch, &quot;^$?*+&quot;);
307     }
308   }
309 
310   return is_valid;
311 }
312 
313 // Matches a repeated regex atom followed by a valid simple regular
314 // expression.  The regex atom is defined as c if escaped is false,
315 // or \c otherwise.  repeat is the repetition meta character (?, *,
316 // or +).  The behavior is undefined if str contains too many
317 // characters to be indexable by size_t, in which case the test will
318 // probably time out anyway.  We are fine with this limitation as
319 // std::string has it too.
320 bool MatchRepetitionAndRegexAtHead(
321     bool escaped, char c, char repeat, const char* regex,
322     const char* str) {
323   const size_t min_count = (repeat == &#39;+&#39;) ? 1 : 0;
324   const size_t max_count = (repeat == &#39;?&#39;) ? 1 :
325       static_cast&lt;size_t&gt;(-1) - 1;
326   // We cannot call numeric_limits::max() as it conflicts with the
327   // max() macro on Windows.
328 
329   for (size_t i = 0; i &lt;= max_count; ++i) {
330     // We know that the atom matches each of the first i characters in str.
331     if (i &gt;= min_count &amp;&amp; MatchRegexAtHead(regex, str + i)) {
332       // We have enough matches at the head, and the tail matches too.
333       // Since we only care about *whether* the pattern matches str
334       // (as opposed to *how* it matches), there is no need to find a
335       // greedy match.
336       return true;
337     }
338     if (str[i] == &#39;\0&#39; || !AtomMatchesChar(escaped, c, str[i]))
339       return false;
340   }
341   return false;
342 }
343 
344 // Returns true iff regex matches a prefix of str.  regex must be a
345 // valid simple regular expression and not start with &quot;^&quot;, or the
346 // result is undefined.
347 bool MatchRegexAtHead(const char* regex, const char* str) {
348   if (*regex == &#39;\0&#39;)  // An empty regex matches a prefix of anything.
349     return true;
350 
351   // &quot;$&quot; only matches the end of a string.  Note that regex being
352   // valid guarantees that there&#39;s nothing after &quot;$&quot; in it.
353   if (*regex == &#39;$&#39;)
354     return *str == &#39;\0&#39;;
355 
356   // Is the first thing in regex an escape sequence?
357   const bool escaped = *regex == &#39;\\&#39;;
358   if (escaped)
359     ++regex;
360   if (IsRepeat(regex[1])) {
361     // MatchRepetitionAndRegexAtHead() calls MatchRegexAtHead(), so
362     // here&#39;s an indirect recursion.  It terminates as the regex gets
363     // shorter in each recursion.
364     return MatchRepetitionAndRegexAtHead(
365         escaped, regex[0], regex[1], regex + 2, str);
366   } else {
367     // regex isn&#39;t empty, isn&#39;t &quot;$&quot;, and doesn&#39;t start with a
368     // repetition.  We match the first atom of regex with the first
369     // character of str and recurse.
370     return (*str != &#39;\0&#39;) &amp;&amp; AtomMatchesChar(escaped, *regex, *str) &amp;&amp;
371         MatchRegexAtHead(regex + 1, str + 1);
372   }
373 }
374 
375 // Returns true iff regex matches any substring of str.  regex must be
376 // a valid simple regular expression, or the result is undefined.
377 //
378 // The algorithm is recursive, but the recursion depth doesn&#39;t exceed
379 // the regex length, so we won&#39;t need to worry about running out of
380 // stack space normally.  In rare cases the time complexity can be
381 // exponential with respect to the regex length + the string length,
382 // but usually it&#39;s must faster (often close to linear).
383 bool MatchRegexAnywhere(const char* regex, const char* str) {
384   if (regex == NULL || str == NULL)
385     return false;
386 
387   if (*regex == &#39;^&#39;)
388     return MatchRegexAtHead(regex + 1, str);
389 
390   // A successful match can be anywhere in str.
391   do {
392     if (MatchRegexAtHead(regex, str))
393       return true;
394   } while (*str++ != &#39;\0&#39;);
395   return false;
396 }
397 
398 // Implements the RE class.
399 
400 RE::~RE() {
401   free(const_cast&lt;char*&gt;(pattern_));
402   free(const_cast&lt;char*&gt;(full_pattern_));
403 }
404 
405 // Returns true iff regular expression re matches the entire str.
406 bool RE::FullMatch(const char* str, const RE&amp; re) {
407   return re.is_valid_ &amp;&amp; MatchRegexAnywhere(re.full_pattern_, str);
408 }
409 
410 // Returns true iff regular expression re matches a substring of str
411 // (including str itself).
412 bool RE::PartialMatch(const char* str, const RE&amp; re) {
413   return re.is_valid_ &amp;&amp; MatchRegexAnywhere(re.pattern_, str);
414 }
415 
416 // Initializes an RE from its string representation.
417 void RE::Init(const char* regex) {
418   pattern_ = full_pattern_ = NULL;
419   if (regex != NULL) {
420     pattern_ = posix::StrDup(regex);
421   }
422 
423   is_valid_ = ValidateRegex(regex);
424   if (!is_valid_) {
425     // No need to calculate the full pattern when the regex is invalid.
426     return;
427   }
428 
429   const size_t len = strlen(regex);
430   // Reserves enough bytes to hold the regular expression used for a
431   // full match: we need space to prepend a &#39;^&#39;, append a &#39;$&#39;, and
432   // terminate the string with &#39;\0&#39;.
433   char* buffer = static_cast&lt;char*&gt;(malloc(len + 3));
434   full_pattern_ = buffer;
435 
436   if (*regex != &#39;^&#39;)
437     *buffer++ = &#39;^&#39;;  // Makes sure full_pattern_ starts with &#39;^&#39;.
438 
439   // We don&#39;t use snprintf or strncpy, as they trigger a warning when
440   // compiled with VC++ 8.0.
441   memcpy(buffer, regex, len);
442   buffer += len;
443 
444   if (len == 0 || regex[len - 1] != &#39;$&#39;)
445     *buffer++ = &#39;$&#39;;  // Makes sure full_pattern_ ends with &#39;$&#39;.
446 
447   *buffer = &#39;\0&#39;;
448 }
449 
450 #endif  // GTEST_USES_POSIX_RE
451 
452 const char kUnknownFile[] = &quot;unknown file&quot;;
453 
454 // Formats a source file path and a line number as they would appear
455 // in an error message from the compiler used to compile this code.
456 GTEST_API_ ::std::string FormatFileLocation(const char* file, int line) {
457   const std::string file_name(file == NULL ? kUnknownFile : file);
458 
459   if (line &lt; 0) {
460     return file_name + &quot;:&quot;;
461   }
462 #ifdef _MSC_VER
463   return file_name + &quot;(&quot; + StreamableToString(line) + &quot;):&quot;;
464 #else
465   return file_name + &quot;:&quot; + StreamableToString(line) + &quot;:&quot;;
466 #endif  // _MSC_VER
467 }
468 
469 // Formats a file location for compiler-independent XML output.
470 // Although this function is not platform dependent, we put it next to
471 // FormatFileLocation in order to contrast the two functions.
472 // Note that FormatCompilerIndependentFileLocation() does NOT append colon
473 // to the file location it produces, unlike FormatFileLocation().
474 GTEST_API_ ::std::string FormatCompilerIndependentFileLocation(
475     const char* file, int line) {
476   const std::string file_name(file == NULL ? kUnknownFile : file);
477 
478   if (line &lt; 0)
479     return file_name;
480   else
481     return file_name + &quot;:&quot; + StreamableToString(line);
482 }
483 
484 
485 GTestLog::GTestLog(GTestLogSeverity severity, const char* file, int line)
486     : severity_(severity) {
487   const char* const marker =
488       severity == GTEST_INFO ?    &quot;[  INFO ]&quot; :
489       severity == GTEST_WARNING ? &quot;[WARNING]&quot; :
490       severity == GTEST_ERROR ?   &quot;[ ERROR ]&quot; : &quot;[ FATAL ]&quot;;
491   GetStream() &lt;&lt; ::std::endl &lt;&lt; marker &lt;&lt; &quot; &quot;
492               &lt;&lt; FormatFileLocation(file, line).c_str() &lt;&lt; &quot;: &quot;;
493 }
494 
495 // Flushes the buffers and, if severity is GTEST_FATAL, aborts the program.
496 GTestLog::~GTestLog() {
497   GetStream() &lt;&lt; ::std::endl;
498   if (severity_ == GTEST_FATAL) {
499     fflush(stderr);
500     posix::Abort();
501   }
502 }
503 // Disable Microsoft deprecation warnings for POSIX functions called from
504 // this class (creat, dup, dup2, and close)
505 #ifdef _MSC_VER
506 # pragma warning(push)
507 # pragma warning(disable: 4996)
508 #endif  // _MSC_VER
509 
510 #if GTEST_HAS_STREAM_REDIRECTION
511 
512 // Object that captures an output stream (stdout/stderr).
513 class CapturedStream {
514  public:
515   // The ctor redirects the stream to a temporary file.
516   explicit CapturedStream(int fd) : fd_(fd), uncaptured_fd_(dup(fd)) {
517 # if GTEST_OS_WINDOWS
518     char temp_dir_path[MAX_PATH + 1] = { &#39;\0&#39; };  // NOLINT
519     char temp_file_path[MAX_PATH + 1] = { &#39;\0&#39; };  // NOLINT
520 
521     ::GetTempPathA(sizeof(temp_dir_path), temp_dir_path);
522     const UINT success = ::GetTempFileNameA(temp_dir_path,
523                                             &quot;gtest_redir&quot;,
524                                             0,  // Generate unique file name.
525                                             temp_file_path);
526     GTEST_CHECK_(success != 0)
527         &lt;&lt; &quot;Unable to create a temporary file in &quot; &lt;&lt; temp_dir_path;
528     const int captured_fd = creat(temp_file_path, _S_IREAD | _S_IWRITE);
529     GTEST_CHECK_(captured_fd != -1) &lt;&lt; &quot;Unable to open temporary file &quot;
530                                     &lt;&lt; temp_file_path;
531     filename_ = temp_file_path;
532 # else
533     // There&#39;s no guarantee that a test has write access to the current
534     // directory, so we create the temporary file in the /tmp directory
535     // instead. We use /tmp on most systems, and /sdcard on Android.
536     // That&#39;s because Android doesn&#39;t have /tmp.
537 #  if GTEST_OS_LINUX_ANDROID
538     // Note: Android applications are expected to call the framework&#39;s
539     // Context.getExternalStorageDirectory() method through JNI to get
540     // the location of the world-writable SD Card directory. However,
541     // this requires a Context handle, which cannot be retrieved
542     // globally from native code. Doing so also precludes running the
543     // code as part of a regular standalone executable, which doesn&#39;t
544     // run in a Dalvik process (e.g. when running it through &#39;adb shell&#39;).
545     //
546     // The location /sdcard is directly accessible from native code
547     // and is the only location (unofficially) supported by the Android
548     // team. It&#39;s generally a symlink to the real SD Card mount point
549     // which can be /mnt/sdcard, /mnt/sdcard0, /system/media/sdcard, or
550     // other OEM-customized locations. Never rely on these, and always
551     // use /sdcard.
552     char name_template[] = &quot;/sdcard/gtest_captured_stream.XXXXXX&quot;;
553 #  else
554     char name_template[] = &quot;/tmp/captured_stream.XXXXXX&quot;;
555 #  endif  // GTEST_OS_LINUX_ANDROID
556     const int captured_fd = mkstemp(name_template);
557     filename_ = name_template;
558 # endif  // GTEST_OS_WINDOWS
559     fflush(NULL);
560     dup2(captured_fd, fd_);
561     close(captured_fd);
562   }
563 
564   ~CapturedStream() {
565     remove(filename_.c_str());
566   }
567 
568   std::string GetCapturedString() {
569     if (uncaptured_fd_ != -1) {
570       // Restores the original stream.
571       fflush(NULL);
572       dup2(uncaptured_fd_, fd_);
573       close(uncaptured_fd_);
574       uncaptured_fd_ = -1;
575     }
576 
577     FILE* const file = posix::FOpen(filename_.c_str(), &quot;r&quot;);
578     const std::string content = ReadEntireFile(file);
579     posix::FClose(file);
580     return content;
581   }
582 
583  private:
584   // Reads the entire content of a file as an std::string.
585   static std::string ReadEntireFile(FILE* file);
586 
587   // Returns the size (in bytes) of a file.
588   static size_t GetFileSize(FILE* file);
589 
590   const int fd_;  // A stream to capture.
591   int uncaptured_fd_;
592   // Name of the temporary file holding the stderr output.
593   ::std::string filename_;
594 
595   GTEST_DISALLOW_COPY_AND_ASSIGN_(CapturedStream);
596 };
597 
598 // Returns the size (in bytes) of a file.
599 size_t CapturedStream::GetFileSize(FILE* file) {
600   fseek(file, 0, SEEK_END);
601   return static_cast&lt;size_t&gt;(ftell(file));
602 }
603 
604 // Reads the entire content of a file as a string.
605 std::string CapturedStream::ReadEntireFile(FILE* file) {
606   const size_t file_size = GetFileSize(file);
607   char* const buffer = new char[file_size];
608 
609   size_t bytes_last_read = 0;  // # of bytes read in the last fread()
610   size_t bytes_read = 0;       // # of bytes read so far
611 
612   fseek(file, 0, SEEK_SET);
613 
614   // Keeps reading the file until we cannot read further or the
615   // pre-determined file size is reached.
616   do {
617     bytes_last_read = fread(buffer+bytes_read, 1, file_size-bytes_read, file);
618     bytes_read += bytes_last_read;
619   } while (bytes_last_read &gt; 0 &amp;&amp; bytes_read &lt; file_size);
620 
621   const std::string content(buffer, bytes_read);
622   delete[] buffer;
623 
624   return content;
625 }
626 
627 # ifdef _MSC_VER
628 #  pragma warning(pop)
629 # endif  // _MSC_VER
630 
631 static CapturedStream* g_captured_stderr = NULL;
632 static CapturedStream* g_captured_stdout = NULL;
633 
634 // Starts capturing an output stream (stdout/stderr).
635 void CaptureStream(int fd, const char* stream_name, CapturedStream** stream) {
636   if (*stream != NULL) {
637     GTEST_LOG_(FATAL) &lt;&lt; &quot;Only one &quot; &lt;&lt; stream_name
638                       &lt;&lt; &quot; capturer can exist at a time.&quot;;
639   }
640   *stream = new CapturedStream(fd);
641 }
642 
643 // Stops capturing the output stream and returns the captured string.
644 std::string GetCapturedStream(CapturedStream** captured_stream) {
645   const std::string content = (*captured_stream)-&gt;GetCapturedString();
646 
647   delete *captured_stream;
648   *captured_stream = NULL;
649 
650   return content;
651 }
652 
653 // Starts capturing stdout.
654 void CaptureStdout() {
655   CaptureStream(kStdOutFileno, &quot;stdout&quot;, &amp;g_captured_stdout);
656 }
657 
658 // Starts capturing stderr.
659 void CaptureStderr() {
660   CaptureStream(kStdErrFileno, &quot;stderr&quot;, &amp;g_captured_stderr);
661 }
662 
663 // Stops capturing stdout and returns the captured string.
664 std::string GetCapturedStdout() {
665   return GetCapturedStream(&amp;g_captured_stdout);
666 }
667 
668 // Stops capturing stderr and returns the captured string.
669 std::string GetCapturedStderr() {
670   return GetCapturedStream(&amp;g_captured_stderr);
671 }
672 
673 #endif  // GTEST_HAS_STREAM_REDIRECTION
674 
675 #if GTEST_HAS_DEATH_TEST
676 
677 // A copy of all command line arguments.  Set by InitGoogleTest().
678 ::std::vector&lt;testing::internal::string&gt; g_argvs;
679 
680 static const ::std::vector&lt;testing::internal::string&gt;* g_injected_test_argvs =
681                                         NULL;  // Owned.
682 
683 void SetInjectableArgvs(const ::std::vector&lt;testing::internal::string&gt;* argvs) {
684   if (g_injected_test_argvs != argvs)
685     delete g_injected_test_argvs;
686   g_injected_test_argvs = argvs;
687 }
688 
689 const ::std::vector&lt;testing::internal::string&gt;&amp; GetInjectableArgvs() {
690   if (g_injected_test_argvs != NULL) {
691     return *g_injected_test_argvs;
692   }
693   return g_argvs;
694 }
695 #endif  // GTEST_HAS_DEATH_TEST
696 
697 #if GTEST_OS_WINDOWS_MOBILE
698 namespace posix {
699 void Abort() {
700   DebugBreak();
701   TerminateProcess(GetCurrentProcess(), 1);
702 }
703 }  // namespace posix
704 #endif  // GTEST_OS_WINDOWS_MOBILE
705 
706 // Returns the name of the environment variable corresponding to the
707 // given flag.  For example, FlagToEnvVar(&quot;foo&quot;) will return
708 // &quot;GTEST_FOO&quot; in the open-source version.
709 static std::string FlagToEnvVar(const char* flag) {
710   const std::string full_flag =
711       (Message() &lt;&lt; GTEST_FLAG_PREFIX_ &lt;&lt; flag).GetString();
712 
713   Message env_var;
714   for (size_t i = 0; i != full_flag.length(); i++) {
715     env_var &lt;&lt; ToUpper(full_flag.c_str()[i]);
716   }
717 
718   return env_var.GetString();
719 }
720 
721 // Parses &#39;str&#39; for a 32-bit signed integer.  If successful, writes
722 // the result to *value and returns true; otherwise leaves *value
723 // unchanged and returns false.
724 bool ParseInt32(const Message&amp; src_text, const char* str, Int32* value) {
725   // Parses the environment variable as a decimal integer.
726   char* end = NULL;
727   const long long_value = strtol(str, &amp;end, 10);  // NOLINT
728 
729   // Has strtol() consumed all characters in the string?
730   if (*end != &#39;\0&#39;) {
731     // No - an invalid character was encountered.
732     Message msg;
733     msg &lt;&lt; &quot;WARNING: &quot; &lt;&lt; src_text
734         &lt;&lt; &quot; is expected to be a 32-bit integer, but actually&quot;
735         &lt;&lt; &quot; has value \&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot;.\n&quot;;
736     printf(&quot;%s&quot;, msg.GetString().c_str());
737     fflush(stdout);
738     return false;
739   }
740 
741   // Is the parsed value in the range of an Int32?
742   const Int32 result = static_cast&lt;Int32&gt;(long_value);
743   if (long_value == LONG_MAX || long_value == LONG_MIN ||
744       // The parsed value overflows as a long.  (strtol() returns
745       // LONG_MAX or LONG_MIN when the input overflows.)
746       result != long_value
747       // The parsed value overflows as an Int32.
748       ) {
749     Message msg;
750     msg &lt;&lt; &quot;WARNING: &quot; &lt;&lt; src_text
751         &lt;&lt; &quot; is expected to be a 32-bit integer, but actually&quot;
752         &lt;&lt; &quot; has value &quot; &lt;&lt; str &lt;&lt; &quot;, which overflows.\n&quot;;
753     printf(&quot;%s&quot;, msg.GetString().c_str());
754     fflush(stdout);
755     return false;
756   }
757 
758   *value = result;
759   return true;
760 }
761 
762 // Reads and returns the Boolean environment variable corresponding to
763 // the given flag; if it&#39;s not set, returns default_value.
764 //
765 // The value is considered true iff it&#39;s not &quot;0&quot;.
766 bool BoolFromGTestEnv(const char* flag, bool default_value) {
767   const std::string env_var = FlagToEnvVar(flag);
768   const char* const string_value = posix::GetEnv(env_var.c_str());
769   return string_value == NULL ?
770       default_value : strcmp(string_value, &quot;0&quot;) != 0;
771 }
772 
773 // Reads and returns a 32-bit integer stored in the environment
774 // variable corresponding to the given flag; if it isn&#39;t set or
775 // doesn&#39;t represent a valid 32-bit integer, returns default_value.
776 Int32 Int32FromGTestEnv(const char* flag, Int32 default_value) {
777   const std::string env_var = FlagToEnvVar(flag);
778   const char* const string_value = posix::GetEnv(env_var.c_str());
779   if (string_value == NULL) {
780     // The environment variable is not set.
781     return default_value;
782   }
783 
784   Int32 result = default_value;
785   if (!ParseInt32(Message() &lt;&lt; &quot;Environment variable &quot; &lt;&lt; env_var,
786                   string_value, &amp;result)) {
787     printf(&quot;The default value %s is used.\n&quot;,
788            (Message() &lt;&lt; default_value).GetString().c_str());
789     fflush(stdout);
790     return default_value;
791   }
792 
793   return result;
794 }
795 
796 // Reads and returns the string environment variable corresponding to
797 // the given flag; if it&#39;s not set, returns default_value.
798 const char* StringFromGTestEnv(const char* flag, const char* default_value) {
799   const std::string env_var = FlagToEnvVar(flag);
800   const char* const value = posix::GetEnv(env_var.c_str());
801   return value == NULL ? default_value : value;
802 }
803 
804 }  // namespace internal
805 }  // namespace testing
    </pre>
  </body>
</html>
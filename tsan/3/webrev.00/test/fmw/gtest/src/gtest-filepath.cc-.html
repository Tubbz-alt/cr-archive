<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/src/gtest-filepath.cc</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Copyright 2008, Google Inc.
  2 // All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //     * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //     * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //     * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 //
 30 // Authors: keith.ray@gmail.com (Keith Ray)
 31 
 32 #include &quot;gtest/gtest-message.h&quot;
 33 #include &quot;gtest/internal/gtest-filepath.h&quot;
 34 #include &quot;gtest/internal/gtest-port.h&quot;
 35 
 36 #include &lt;stdlib.h&gt;
 37 
 38 #if GTEST_OS_WINDOWS_MOBILE
 39 # include &lt;windows.h&gt;
 40 #elif GTEST_OS_WINDOWS
 41 # include &lt;direct.h&gt;
 42 # include &lt;io.h&gt;
 43 #elif GTEST_OS_SYMBIAN
 44 // Symbian OpenC has PATH_MAX in sys/syslimits.h
 45 # include &lt;sys/syslimits.h&gt;
 46 #else
 47 # include &lt;limits.h&gt;
 48 # include &lt;climits&gt;  // Some Linux distributions define PATH_MAX here.
 49 #endif  // GTEST_OS_WINDOWS_MOBILE
 50 
 51 #if GTEST_OS_WINDOWS
 52 # define GTEST_PATH_MAX_ _MAX_PATH
 53 #elif defined(PATH_MAX)
 54 # define GTEST_PATH_MAX_ PATH_MAX
 55 #elif defined(_XOPEN_PATH_MAX)
 56 # define GTEST_PATH_MAX_ _XOPEN_PATH_MAX
 57 #else
 58 # define GTEST_PATH_MAX_ _POSIX_PATH_MAX
 59 #endif  // GTEST_OS_WINDOWS
 60 
 61 #include &quot;gtest/internal/gtest-string.h&quot;
 62 
 63 namespace testing {
 64 namespace internal {
 65 
 66 #if GTEST_OS_WINDOWS
 67 // On Windows, &#39;\\&#39; is the standard path separator, but many tools and the
 68 // Windows API also accept &#39;/&#39; as an alternate path separator. Unless otherwise
 69 // noted, a file path can contain either kind of path separators, or a mixture
 70 // of them.
 71 const char kPathSeparator = &#39;\\&#39;;
 72 const char kAlternatePathSeparator = &#39;/&#39;;
 73 const char kPathSeparatorString[] = &quot;\\&quot;;
 74 const char kAlternatePathSeparatorString[] = &quot;/&quot;;
 75 # if GTEST_OS_WINDOWS_MOBILE
 76 // Windows CE doesn&#39;t have a current directory. You should not use
 77 // the current directory in tests on Windows CE, but this at least
 78 // provides a reasonable fallback.
 79 const char kCurrentDirectoryString[] = &quot;\\&quot;;
 80 // Windows CE doesn&#39;t define INVALID_FILE_ATTRIBUTES
 81 const DWORD kInvalidFileAttributes = 0xffffffff;
 82 # else
 83 const char kCurrentDirectoryString[] = &quot;.\\&quot;;
 84 # endif  // GTEST_OS_WINDOWS_MOBILE
 85 #else
 86 const char kPathSeparator = &#39;/&#39;;
 87 const char kPathSeparatorString[] = &quot;/&quot;;
 88 const char kCurrentDirectoryString[] = &quot;./&quot;;
 89 #endif  // GTEST_OS_WINDOWS
 90 
 91 // Returns whether the given character is a valid path separator.
 92 static bool IsPathSeparator(char c) {
 93 #if GTEST_HAS_ALT_PATH_SEP_
 94   return (c == kPathSeparator) || (c == kAlternatePathSeparator);
 95 #else
 96   return c == kPathSeparator;
 97 #endif
 98 }
 99 
100 // Returns the current working directory, or &quot;&quot; if unsuccessful.
101 FilePath FilePath::GetCurrentDir() {
102 #if GTEST_OS_WINDOWS_MOBILE
103   // Windows CE doesn&#39;t have a current directory, so we just return
104   // something reasonable.
105   return FilePath(kCurrentDirectoryString);
106 #elif GTEST_OS_WINDOWS
107   char cwd[GTEST_PATH_MAX_ + 1] = { &#39;\0&#39; };
108   return FilePath(_getcwd(cwd, sizeof(cwd)) == NULL ? &quot;&quot; : cwd);
109 #else
110   char cwd[GTEST_PATH_MAX_ + 1] = { &#39;\0&#39; };
111   return FilePath(getcwd(cwd, sizeof(cwd)) == NULL ? &quot;&quot; : cwd);
112 #endif  // GTEST_OS_WINDOWS_MOBILE
113 }
114 
115 // Returns a copy of the FilePath with the case-insensitive extension removed.
116 // Example: FilePath(&quot;dir/file.exe&quot;).RemoveExtension(&quot;EXE&quot;) returns
117 // FilePath(&quot;dir/file&quot;). If a case-insensitive extension is not
118 // found, returns a copy of the original FilePath.
119 FilePath FilePath::RemoveExtension(const char* extension) const {
120   const std::string dot_extension = std::string(&quot;.&quot;) + extension;
121   if (String::EndsWithCaseInsensitive(pathname_, dot_extension)) {
122     return FilePath(pathname_.substr(
123         0, pathname_.length() - dot_extension.length()));
124   }
125   return *this;
126 }
127 
128 // Returns a pointer to the last occurence of a valid path separator in
129 // the FilePath. On Windows, for example, both &#39;/&#39; and &#39;\&#39; are valid path
130 // separators. Returns NULL if no path separator was found.
131 const char* FilePath::FindLastPathSeparator() const {
132   const char* const last_sep = strrchr(c_str(), kPathSeparator);
133 #if GTEST_HAS_ALT_PATH_SEP_
134   const char* const last_alt_sep = strrchr(c_str(), kAlternatePathSeparator);
135   // Comparing two pointers of which only one is NULL is undefined.
136   if (last_alt_sep != NULL &amp;&amp;
137       (last_sep == NULL || last_alt_sep &gt; last_sep)) {
138     return last_alt_sep;
139   }
140 #endif
141   return last_sep;
142 }
143 
144 // Returns a copy of the FilePath with the directory part removed.
145 // Example: FilePath(&quot;path/to/file&quot;).RemoveDirectoryName() returns
146 // FilePath(&quot;file&quot;). If there is no directory part (&quot;just_a_file&quot;), it returns
147 // the FilePath unmodified. If there is no file part (&quot;just_a_dir/&quot;) it
148 // returns an empty FilePath (&quot;&quot;).
149 // On Windows platform, &#39;\&#39; is the path separator, otherwise it is &#39;/&#39;.
150 FilePath FilePath::RemoveDirectoryName() const {
151   const char* const last_sep = FindLastPathSeparator();
152   return last_sep ? FilePath(last_sep + 1) : *this;
153 }
154 
155 // RemoveFileName returns the directory path with the filename removed.
156 // Example: FilePath(&quot;path/to/file&quot;).RemoveFileName() returns &quot;path/to/&quot;.
157 // If the FilePath is &quot;a_file&quot; or &quot;/a_file&quot;, RemoveFileName returns
158 // FilePath(&quot;./&quot;) or, on Windows, FilePath(&quot;.\\&quot;). If the filepath does
159 // not have a file, like &quot;just/a/dir/&quot;, it returns the FilePath unmodified.
160 // On Windows platform, &#39;\&#39; is the path separator, otherwise it is &#39;/&#39;.
161 FilePath FilePath::RemoveFileName() const {
162   const char* const last_sep = FindLastPathSeparator();
163   std::string dir;
164   if (last_sep) {
165     dir = std::string(c_str(), last_sep + 1 - c_str());
166   } else {
167     dir = kCurrentDirectoryString;
168   }
169   return FilePath(dir);
170 }
171 
172 // Helper functions for naming files in a directory for xml output.
173 
174 // Given directory = &quot;dir&quot;, base_name = &quot;test&quot;, number = 0,
175 // extension = &quot;xml&quot;, returns &quot;dir/test.xml&quot;. If number is greater
176 // than zero (e.g., 12), returns &quot;dir/test_12.xml&quot;.
177 // On Windows platform, uses \ as the separator rather than /.
178 FilePath FilePath::MakeFileName(const FilePath&amp; directory,
179                                 const FilePath&amp; base_name,
180                                 int number,
181                                 const char* extension) {
182   std::string file;
183   if (number == 0) {
184     file = base_name.string() + &quot;.&quot; + extension;
185   } else {
186     file = base_name.string() + &quot;_&quot; + StreamableToString(number)
187         + &quot;.&quot; + extension;
188   }
189   return ConcatPaths(directory, FilePath(file));
190 }
191 
192 // Given directory = &quot;dir&quot;, relative_path = &quot;test.xml&quot;, returns &quot;dir/test.xml&quot;.
193 // On Windows, uses \ as the separator rather than /.
194 FilePath FilePath::ConcatPaths(const FilePath&amp; directory,
195                                const FilePath&amp; relative_path) {
196   if (directory.IsEmpty())
197     return relative_path;
198   const FilePath dir(directory.RemoveTrailingPathSeparator());
199   return FilePath(dir.string() + kPathSeparator + relative_path.string());
200 }
201 
202 // Returns true if pathname describes something findable in the file-system,
203 // either a file, directory, or whatever.
204 bool FilePath::FileOrDirectoryExists() const {
205 #if GTEST_OS_WINDOWS_MOBILE
206   LPCWSTR unicode = String::AnsiToUtf16(pathname_.c_str());
207   const DWORD attributes = GetFileAttributes(unicode);
208   delete [] unicode;
209   return attributes != kInvalidFileAttributes;
210 #else
211   posix::StatStruct file_stat;
212   return posix::Stat(pathname_.c_str(), &amp;file_stat) == 0;
213 #endif  // GTEST_OS_WINDOWS_MOBILE
214 }
215 
216 // Returns true if pathname describes a directory in the file-system
217 // that exists.
218 bool FilePath::DirectoryExists() const {
219   bool result = false;
220 #if GTEST_OS_WINDOWS
221   // Don&#39;t strip off trailing separator if path is a root directory on
222   // Windows (like &quot;C:\\&quot;).
223   const FilePath&amp; path(IsRootDirectory() ? *this :
224                                            RemoveTrailingPathSeparator());
225 #else
226   const FilePath&amp; path(*this);
227 #endif
228 
229 #if GTEST_OS_WINDOWS_MOBILE
230   LPCWSTR unicode = String::AnsiToUtf16(path.c_str());
231   const DWORD attributes = GetFileAttributes(unicode);
232   delete [] unicode;
233   if ((attributes != kInvalidFileAttributes) &amp;&amp;
234       (attributes &amp; FILE_ATTRIBUTE_DIRECTORY)) {
235     result = true;
236   }
237 #else
238   posix::StatStruct file_stat;
239   result = posix::Stat(path.c_str(), &amp;file_stat) == 0 &amp;&amp;
240       posix::IsDir(file_stat);
241 #endif  // GTEST_OS_WINDOWS_MOBILE
242 
243   return result;
244 }
245 
246 // Returns true if pathname describes a root directory. (Windows has one
247 // root directory per disk drive.)
248 bool FilePath::IsRootDirectory() const {
249 #if GTEST_OS_WINDOWS
250   // TODO(wan@google.com): on Windows a network share like
251   // \\server\share can be a root directory, although it cannot be the
252   // current directory.  Handle this properly.
253   return pathname_.length() == 3 &amp;&amp; IsAbsolutePath();
254 #else
255   return pathname_.length() == 1 &amp;&amp; IsPathSeparator(pathname_.c_str()[0]);
256 #endif
257 }
258 
259 // Returns true if pathname describes an absolute path.
260 bool FilePath::IsAbsolutePath() const {
261   const char* const name = pathname_.c_str();
262 #if GTEST_OS_WINDOWS
263   return pathname_.length() &gt;= 3 &amp;&amp;
264      ((name[0] &gt;= &#39;a&#39; &amp;&amp; name[0] &lt;= &#39;z&#39;) ||
265       (name[0] &gt;= &#39;A&#39; &amp;&amp; name[0] &lt;= &#39;Z&#39;)) &amp;&amp;
266      name[1] == &#39;:&#39; &amp;&amp;
267      IsPathSeparator(name[2]);
268 #else
269   return IsPathSeparator(name[0]);
270 #endif
271 }
272 
273 // Returns a pathname for a file that does not currently exist. The pathname
274 // will be directory/base_name.extension or
275 // directory/base_name_&lt;number&gt;.extension if directory/base_name.extension
276 // already exists. The number will be incremented until a pathname is found
277 // that does not already exist.
278 // Examples: &#39;dir/foo_test.xml&#39; or &#39;dir/foo_test_1.xml&#39;.
279 // There could be a race condition if two or more processes are calling this
280 // function at the same time -- they could both pick the same filename.
281 FilePath FilePath::GenerateUniqueFileName(const FilePath&amp; directory,
282                                           const FilePath&amp; base_name,
283                                           const char* extension) {
284   FilePath full_pathname;
285   int number = 0;
286   do {
287     full_pathname.Set(MakeFileName(directory, base_name, number++, extension));
288   } while (full_pathname.FileOrDirectoryExists());
289   return full_pathname;
290 }
291 
292 // Returns true if FilePath ends with a path separator, which indicates that
293 // it is intended to represent a directory. Returns false otherwise.
294 // This does NOT check that a directory (or file) actually exists.
295 bool FilePath::IsDirectory() const {
296   return !pathname_.empty() &amp;&amp;
297          IsPathSeparator(pathname_.c_str()[pathname_.length() - 1]);
298 }
299 
300 // Create directories so that path exists. Returns true if successful or if
301 // the directories already exist; returns false if unable to create directories
302 // for any reason.
303 bool FilePath::CreateDirectoriesRecursively() const {
304   if (!this-&gt;IsDirectory()) {
305     return false;
306   }
307 
308   if (pathname_.length() == 0 || this-&gt;DirectoryExists()) {
309     return true;
310   }
311 
312   const FilePath parent(this-&gt;RemoveTrailingPathSeparator().RemoveFileName());
313   return parent.CreateDirectoriesRecursively() &amp;&amp; this-&gt;CreateFolder();
314 }
315 
316 // Create the directory so that path exists. Returns true if successful or
317 // if the directory already exists; returns false if unable to create the
318 // directory for any reason, including if the parent directory does not
319 // exist. Not named &quot;CreateDirectory&quot; because that&#39;s a macro on Windows.
320 bool FilePath::CreateFolder() const {
321 #if GTEST_OS_WINDOWS_MOBILE
322   FilePath removed_sep(this-&gt;RemoveTrailingPathSeparator());
323   LPCWSTR unicode = String::AnsiToUtf16(removed_sep.c_str());
324   int result = CreateDirectory(unicode, NULL) ? 0 : -1;
325   delete [] unicode;
326 #elif GTEST_OS_WINDOWS
327   int result = _mkdir(pathname_.c_str());
328 #else
329   int result = mkdir(pathname_.c_str(), 0777);
330 #endif  // GTEST_OS_WINDOWS_MOBILE
331 
332   if (result == -1) {
333     return this-&gt;DirectoryExists();  // An error is OK if the directory exists.
334   }
335   return true;  // No error.
336 }
337 
338 // If input name has a trailing separator character, remove it and return the
339 // name, otherwise return the name string unmodified.
340 // On Windows platform, uses \ as the separator, other platforms use /.
341 FilePath FilePath::RemoveTrailingPathSeparator() const {
342   return IsDirectory()
343       ? FilePath(pathname_.substr(0, pathname_.length() - 1))
344       : *this;
345 }
346 
347 // Removes any redundant separators that might be in the pathname.
348 // For example, &quot;bar///foo&quot; becomes &quot;bar/foo&quot;. Does not eliminate other
349 // redundancies that might be in a pathname involving &quot;.&quot; or &quot;..&quot;.
350 // TODO(wan@google.com): handle Windows network shares (e.g. \\server\share).
351 void FilePath::Normalize() {
352   if (pathname_.c_str() == NULL) {
353     pathname_ = &quot;&quot;;
354     return;
355   }
356   const char* src = pathname_.c_str();
357   char* const dest = new char[pathname_.length() + 1];
358   char* dest_ptr = dest;
359   memset(dest_ptr, 0, pathname_.length() + 1);
360 
361   while (*src != &#39;\0&#39;) {
362     *dest_ptr = *src;
363     if (!IsPathSeparator(*src)) {
364       src++;
365     } else {
366 #if GTEST_HAS_ALT_PATH_SEP_
367       if (*dest_ptr == kAlternatePathSeparator) {
368         *dest_ptr = kPathSeparator;
369       }
370 #endif
371       while (IsPathSeparator(*src))
372         src++;
373     }
374     dest_ptr++;
375   }
376   *dest_ptr = &#39;\0&#39;;
377   pathname_ = dest;
378   delete[] dest;
379 }
380 
381 }  // namespace internal
382 }  // namespace testing
    </pre>
  </body>
</html>
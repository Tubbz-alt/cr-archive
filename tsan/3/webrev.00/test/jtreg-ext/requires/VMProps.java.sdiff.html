<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jtreg-ext/requires/VMProps.java</title>
    <link rel="stylesheet" href="../../../style.css" />
  </head>
<body>
<center><a href="../../jdk/tools/launcher/modules/basic/BasicTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../index.html" target="_top">index</a> <a href="../../langtools/ProblemList.txt.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jtreg-ext/requires/VMProps.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 import java.nio.file.Files;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.nio.file.StandardOpenOption;
 33 import java.util.ArrayList;
 34 import java.util.HashMap;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.Properties;
 38 import java.util.concurrent.Callable;
 39 import java.util.concurrent.TimeUnit;
 40 import java.util.function.Supplier;
 41 import java.util.regex.Matcher;
 42 import java.util.regex.Pattern;
 43 
 44 import sun.hotspot.code.Compiler;
 45 import sun.hotspot.cpuinfo.CPUInfo;
 46 import sun.hotspot.gc.GC;
 47 import sun.hotspot.WhiteBox;
 48 import jdk.test.lib.Platform;

 49 
 50 /**
 51  * The Class to be invoked by jtreg prior Test Suite execution to
 52  * collect information about VM.
 53  * Do not use any APIs that may not be available in all target VMs.
 54  * Properties set by this Class will be available in the @requires expressions.
 55  */
 56 public class VMProps implements Callable&lt;Map&lt;String, String&gt;&gt; {
 57     // value known to jtreg as an indicator of error state
 58     private static final String ERROR_STATE = &quot;__ERROR__&quot;;
 59 
 60     private static final WhiteBox WB = WhiteBox.getWhiteBox();
 61 
 62     private static class SafeMap {
 63         private final Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
 64 
 65         public void put(String key, Supplier&lt;String&gt; s) {
 66             String value;
 67             try {
 68                 value = s.get();
</pre>
<hr />
<pre>
217         return &quot;false&quot;;
218     }
219 
220     /**
221      * @return debug level value extracted from the &quot;jdk.debug&quot; property.
222      */
223     protected String vmDebug() {
224         String debug = System.getProperty(&quot;jdk.debug&quot;);
225         if (debug != null) {
226             return &quot;&quot; + debug.contains(&quot;debug&quot;);
227         } else {
228             return errorWithMessage(&quot;Can&#39;t get &#39;jdk.debug&#39; property&quot;);
229         }
230     }
231 
232     /**
233      * @return true if VM supports JVMCI and false otherwise
234      */
235     protected String vmJvmci() {
236         // builds with jvmci have this flag
<span class="line-modified">237         return &quot;&quot; + (WB.getBooleanVMFlag(&quot;EnableJVMCI&quot;) != null);</span>















238     }
239 
240     /**
241      * @return true if VM runs in emulated-client mode and false otherwise.
242      */
243     protected String vmEmulatedClient() {
244         String vmInfo = System.getProperty(&quot;java.vm.info&quot;);
245         if (vmInfo == null) {
246             return errorWithMessage(&quot;Can&#39;t get &#39;java.vm.info&#39; property&quot;);
247         }
248         return &quot;&quot; + vmInfo.contains(&quot; emulated-client&quot;);
249     }
250 
251     /**
252      * @return supported CPU features
253      */
254     protected String cpuFeatures() {
255         return CPUInfo.getFeatures().toString();
256     }
257 
</pre>
<hr />
<pre>
272     }
273 
274     /**
275      * Selected final flag.
276      *
277      * @param map - property-value pairs
278      * @param flagName - flag name
279      */
280     private void vmOptFinalFlag(SafeMap map, String flagName) {
281         map.put(&quot;vm.opt.final.&quot; + flagName,
282                 () -&gt; String.valueOf(WB.getBooleanVMFlag(flagName)));
283     }
284 
285     /**
286      * Selected sets of final flags.
287      *
288      * @param map - property-value pairs
289      */
290     protected void vmOptFinalFlags(SafeMap map) {
291         vmOptFinalFlag(map, &quot;ClassUnloading&quot;);

292         vmOptFinalFlag(map, &quot;UseCompressedOops&quot;);
293         vmOptFinalFlag(map, &quot;EnableJVMCI&quot;);
294         vmOptFinalFlag(map, &quot;EliminateAllocations&quot;);
295     }
296 
297     /**
298      * @return &quot;true&quot; if VM has a serviceability agent.
299      */
300     protected String vmHasSA() {
301         return &quot;&quot; + Platform.hasSA();
302     }
303 
304     /**
305      * @return &quot;true&quot; if VM has a serviceability agent and it can
306      * attach to the VM.
307      */
308     protected String vmHasSAandCanAttach() {
309         try {
310             return &quot;&quot; + Platform.shouldSAAttach();
311         } catch (IOException e) {
</pre>
<hr />
<pre>
338     /**
339      * @return true if VM runs RTM supported CPU and false otherwise.
340      */
341     protected String vmRTMCPU() {
342         return &quot;&quot; + CPUInfo.hasFeature(&quot;rtm&quot;);
343     }
344 
345     /**
346      * @return true if VM supports AOT and false otherwise
347      */
348     protected String vmAOT() {
349         // builds with aot have jaotc in &lt;JDK&gt;/bin
350         Path bin = Paths.get(System.getProperty(&quot;java.home&quot;))
351                         .resolve(&quot;bin&quot;);
352         Path jaotc;
353         if (Platform.isWindows()) {
354             jaotc = bin.resolve(&quot;jaotc.exe&quot;);
355         } else {
356             jaotc = bin.resolve(&quot;jaotc&quot;);
357         }
<span class="line-modified">358         return &quot;&quot; + Files.exists(jaotc);</span>

















359     }
360 
361     /*
362      * @return true if there is at least one loaded AOT&#39;ed library.
363      */
364     protected String vmAotEnabled() {
365         return &quot;&quot; + (WB.aotLibrariesCount() &gt; 0);
366     }
367 
368     /**
369      * Check for CDS support.
370      *
371      * @return true if CDS is supported by the VM to be tested.
372      */
373     protected String vmCDS() {
374         return &quot;&quot; + WB.isCDSIncludedInVmBuild();
375     }
376 
377     /**
378      * Check for CDS support for custom loaders.
</pre>
<hr />
<pre>
438               isSupported = true;
439            } else if (Platform.isS390x()) {
440               isSupported = true;
441            } else if (arch.equals(&quot;ppc64le&quot;)) {
442               isSupported = true;
443            }
444         }
445 
446         if (isSupported) {
447            try {
448               isSupported = checkDockerSupport();
449            } catch (Exception e) {
450               isSupported = false;
451            }
452          }
453 
454         return &quot;&quot; + isSupported;
455     }
456 
457     private boolean checkDockerSupport() throws IOException, InterruptedException {
<span class="line-modified">458         ProcessBuilder pb = new ProcessBuilder(&quot;docker&quot;, &quot;ps&quot;);</span>
459         Process p = pb.start();
460         p.waitFor(10, TimeUnit.SECONDS);
461 
462         return (p.exitValue() == 0);
463     }
464 
465     private String implementor() {
466         try (InputStream in = new BufferedInputStream(new FileInputStream(
467                 System.getProperty(&quot;java.home&quot;) + &quot;/release&quot;))) {
468             Properties properties = new Properties();
469             properties.load(in);
470             String implementorProperty = properties.getProperty(&quot;IMPLEMENTOR&quot;);
471             if (implementorProperty != null) {
472                 return implementorProperty.replace(&quot;\&quot;&quot;, &quot;&quot;);
473             }
474             return errorWithMessage(&quot;Can&#39;t get &#39;IMPLEMENTOR&#39; property from &#39;release&#39; file&quot;);
475         } catch (IOException e) {
476             e.printStackTrace();
477             return errorWithMessage(&quot;Failed to read &#39;release&#39; file &quot; + e);
478         }
</pre>
</td>
<td>
<hr />
<pre>
 29 import java.nio.file.Files;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.nio.file.StandardOpenOption;
 33 import java.util.ArrayList;
 34 import java.util.HashMap;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.Properties;
 38 import java.util.concurrent.Callable;
 39 import java.util.concurrent.TimeUnit;
 40 import java.util.function.Supplier;
 41 import java.util.regex.Matcher;
 42 import java.util.regex.Pattern;
 43 
 44 import sun.hotspot.code.Compiler;
 45 import sun.hotspot.cpuinfo.CPUInfo;
 46 import sun.hotspot.gc.GC;
 47 import sun.hotspot.WhiteBox;
 48 import jdk.test.lib.Platform;
<span class="line-added"> 49 import jdk.test.lib.Container;</span>
 50 
 51 /**
 52  * The Class to be invoked by jtreg prior Test Suite execution to
 53  * collect information about VM.
 54  * Do not use any APIs that may not be available in all target VMs.
 55  * Properties set by this Class will be available in the @requires expressions.
 56  */
 57 public class VMProps implements Callable&lt;Map&lt;String, String&gt;&gt; {
 58     // value known to jtreg as an indicator of error state
 59     private static final String ERROR_STATE = &quot;__ERROR__&quot;;
 60 
 61     private static final WhiteBox WB = WhiteBox.getWhiteBox();
 62 
 63     private static class SafeMap {
 64         private final Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
 65 
 66         public void put(String key, Supplier&lt;String&gt; s) {
 67             String value;
 68             try {
 69                 value = s.get();
</pre>
<hr />
<pre>
218         return &quot;false&quot;;
219     }
220 
221     /**
222      * @return debug level value extracted from the &quot;jdk.debug&quot; property.
223      */
224     protected String vmDebug() {
225         String debug = System.getProperty(&quot;jdk.debug&quot;);
226         if (debug != null) {
227             return &quot;&quot; + debug.contains(&quot;debug&quot;);
228         } else {
229             return errorWithMessage(&quot;Can&#39;t get &#39;jdk.debug&#39; property&quot;);
230         }
231     }
232 
233     /**
234      * @return true if VM supports JVMCI and false otherwise
235      */
236     protected String vmJvmci() {
237         // builds with jvmci have this flag
<span class="line-modified">238         if (WB.getBooleanVMFlag(&quot;EnableJVMCI&quot;) == null) {</span>
<span class="line-added">239             return &quot;false&quot;;</span>
<span class="line-added">240         }</span>
<span class="line-added">241 </span>
<span class="line-added">242         switch (GC.selected()) {</span>
<span class="line-added">243             case Serial:</span>
<span class="line-added">244             case Parallel:</span>
<span class="line-added">245             case G1:</span>
<span class="line-added">246                 // These GCs are supported with JVMCI</span>
<span class="line-added">247                 return &quot;true&quot;;</span>
<span class="line-added">248             default:</span>
<span class="line-added">249                 break;</span>
<span class="line-added">250         }</span>
<span class="line-added">251 </span>
<span class="line-added">252         // Every other GC is not supported</span>
<span class="line-added">253         return &quot;false&quot;;</span>
254     }
255 
256     /**
257      * @return true if VM runs in emulated-client mode and false otherwise.
258      */
259     protected String vmEmulatedClient() {
260         String vmInfo = System.getProperty(&quot;java.vm.info&quot;);
261         if (vmInfo == null) {
262             return errorWithMessage(&quot;Can&#39;t get &#39;java.vm.info&#39; property&quot;);
263         }
264         return &quot;&quot; + vmInfo.contains(&quot; emulated-client&quot;);
265     }
266 
267     /**
268      * @return supported CPU features
269      */
270     protected String cpuFeatures() {
271         return CPUInfo.getFeatures().toString();
272     }
273 
</pre>
<hr />
<pre>
288     }
289 
290     /**
291      * Selected final flag.
292      *
293      * @param map - property-value pairs
294      * @param flagName - flag name
295      */
296     private void vmOptFinalFlag(SafeMap map, String flagName) {
297         map.put(&quot;vm.opt.final.&quot; + flagName,
298                 () -&gt; String.valueOf(WB.getBooleanVMFlag(flagName)));
299     }
300 
301     /**
302      * Selected sets of final flags.
303      *
304      * @param map - property-value pairs
305      */
306     protected void vmOptFinalFlags(SafeMap map) {
307         vmOptFinalFlag(map, &quot;ClassUnloading&quot;);
<span class="line-added">308         vmOptFinalFlag(map, &quot;ClassUnloadingWithConcurrentMark&quot;);</span>
309         vmOptFinalFlag(map, &quot;UseCompressedOops&quot;);
310         vmOptFinalFlag(map, &quot;EnableJVMCI&quot;);
311         vmOptFinalFlag(map, &quot;EliminateAllocations&quot;);
312     }
313 
314     /**
315      * @return &quot;true&quot; if VM has a serviceability agent.
316      */
317     protected String vmHasSA() {
318         return &quot;&quot; + Platform.hasSA();
319     }
320 
321     /**
322      * @return &quot;true&quot; if VM has a serviceability agent and it can
323      * attach to the VM.
324      */
325     protected String vmHasSAandCanAttach() {
326         try {
327             return &quot;&quot; + Platform.shouldSAAttach();
328         } catch (IOException e) {
</pre>
<hr />
<pre>
355     /**
356      * @return true if VM runs RTM supported CPU and false otherwise.
357      */
358     protected String vmRTMCPU() {
359         return &quot;&quot; + CPUInfo.hasFeature(&quot;rtm&quot;);
360     }
361 
362     /**
363      * @return true if VM supports AOT and false otherwise
364      */
365     protected String vmAOT() {
366         // builds with aot have jaotc in &lt;JDK&gt;/bin
367         Path bin = Paths.get(System.getProperty(&quot;java.home&quot;))
368                         .resolve(&quot;bin&quot;);
369         Path jaotc;
370         if (Platform.isWindows()) {
371             jaotc = bin.resolve(&quot;jaotc.exe&quot;);
372         } else {
373             jaotc = bin.resolve(&quot;jaotc&quot;);
374         }
<span class="line-modified">375 </span>
<span class="line-added">376         if (!Files.exists(jaotc)) {</span>
<span class="line-added">377             // No jaotc =&gt; no AOT</span>
<span class="line-added">378             return &quot;false&quot;;</span>
<span class="line-added">379         }</span>
<span class="line-added">380 </span>
<span class="line-added">381         switch (GC.selected()) {</span>
<span class="line-added">382             case Serial:</span>
<span class="line-added">383             case Parallel:</span>
<span class="line-added">384             case G1:</span>
<span class="line-added">385                 // These GCs are supported with AOT</span>
<span class="line-added">386                 return &quot;true&quot;;</span>
<span class="line-added">387             default:</span>
<span class="line-added">388                 break;</span>
<span class="line-added">389         }</span>
<span class="line-added">390 </span>
<span class="line-added">391         // Every other GC is not supported</span>
<span class="line-added">392         return &quot;false&quot;;</span>
393     }
394 
395     /*
396      * @return true if there is at least one loaded AOT&#39;ed library.
397      */
398     protected String vmAotEnabled() {
399         return &quot;&quot; + (WB.aotLibrariesCount() &gt; 0);
400     }
401 
402     /**
403      * Check for CDS support.
404      *
405      * @return true if CDS is supported by the VM to be tested.
406      */
407     protected String vmCDS() {
408         return &quot;&quot; + WB.isCDSIncludedInVmBuild();
409     }
410 
411     /**
412      * Check for CDS support for custom loaders.
</pre>
<hr />
<pre>
472               isSupported = true;
473            } else if (Platform.isS390x()) {
474               isSupported = true;
475            } else if (arch.equals(&quot;ppc64le&quot;)) {
476               isSupported = true;
477            }
478         }
479 
480         if (isSupported) {
481            try {
482               isSupported = checkDockerSupport();
483            } catch (Exception e) {
484               isSupported = false;
485            }
486          }
487 
488         return &quot;&quot; + isSupported;
489     }
490 
491     private boolean checkDockerSupport() throws IOException, InterruptedException {
<span class="line-modified">492         ProcessBuilder pb = new ProcessBuilder(Container.ENGINE_COMMAND, &quot;ps&quot;);</span>
493         Process p = pb.start();
494         p.waitFor(10, TimeUnit.SECONDS);
495 
496         return (p.exitValue() == 0);
497     }
498 
499     private String implementor() {
500         try (InputStream in = new BufferedInputStream(new FileInputStream(
501                 System.getProperty(&quot;java.home&quot;) + &quot;/release&quot;))) {
502             Properties properties = new Properties();
503             properties.load(in);
504             String implementorProperty = properties.getProperty(&quot;IMPLEMENTOR&quot;);
505             if (implementorProperty != null) {
506                 return implementorProperty.replace(&quot;\&quot;&quot;, &quot;&quot;);
507             }
508             return errorWithMessage(&quot;Can&#39;t get &#39;IMPLEMENTOR&#39; property from &#39;release&#39; file&quot;);
509         } catch (IOException e) {
510             e.printStackTrace();
511             return errorWithMessage(&quot;Failed to read &#39;release&#39; file &quot; + e);
512         }
</pre>
</td>
</tr>
</table>
<center><a href="../../jdk/tools/launcher/modules/basic/BasicTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../index.html" target="_top">index</a> <a href="../../langtools/ProblemList.txt.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
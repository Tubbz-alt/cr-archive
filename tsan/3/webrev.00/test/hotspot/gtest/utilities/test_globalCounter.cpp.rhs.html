<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/gtest/utilities/test_globalCounter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;runtime/atomic.hpp&quot;
<a name="1" id="anc1"></a>
 26 #include &quot;runtime/os.hpp&quot;
 27 #include &quot;utilities/globalCounter.hpp&quot;
 28 #include &quot;utilities/globalCounter.inline.hpp&quot;
 29 #include &quot;threadHelper.inline.hpp&quot;
 30 
 31 #define GOOD_VALUE 1337
 32 #define BAD_VALUE  4711
 33 
 34 struct TestData {
 35   long test_value;
 36 };
 37 
 38 class RCUReaderThread : public JavaTestThread {
 39 public:
 40   static volatile bool _exit;
 41   volatile TestData** _test;
 42   Semaphore* _wrt_start;
 43   RCUReaderThread(Semaphore* post, volatile TestData** test, Semaphore* wrt_start)
 44     : JavaTestThread(post), _test(test), _wrt_start(wrt_start) {};
 45   virtual ~RCUReaderThread(){}
 46   void main_run() {
 47     _wrt_start-&gt;signal();
 48     while (!_exit) {
 49       GlobalCounter::CSContext cs_context = GlobalCounter::critical_section_begin(this);
<a name="2" id="anc2"></a><span class="line-modified"> 50       volatile TestData* test = Atomic::load_acquire(_test);</span>
<span class="line-modified"> 51       long value = Atomic::load_acquire(&amp;test-&gt;test_value);</span>
 52       ASSERT_EQ(value, GOOD_VALUE);
 53       GlobalCounter::critical_section_end(this, cs_context);
 54       {
 55         GlobalCounter::CriticalSection cs(this);
<a name="3" id="anc3"></a><span class="line-modified"> 56         volatile TestData* test = Atomic::load_acquire(_test);</span>
<span class="line-modified"> 57         long value = Atomic::load_acquire(&amp;test-&gt;test_value);</span>
 58         ASSERT_EQ(value, GOOD_VALUE);
 59       }
 60     }
 61   }
 62 };
 63 
 64 volatile bool RCUReaderThread::_exit = false;
 65 
 66 class RCUWriterThread : public JavaTestThread {
 67 public:
 68   RCUWriterThread(Semaphore* post) : JavaTestThread(post) {
 69   };
 70   virtual ~RCUWriterThread(){}
 71   void main_run() {
 72     static const int NUMBER_OF_READERS = 4;
 73     Semaphore post;
 74     Semaphore wrt_start;
 75     volatile TestData* test = NULL;
 76 
 77     RCUReaderThread* reader1 = new RCUReaderThread(&amp;post, &amp;test, &amp;wrt_start);
 78     RCUReaderThread* reader2 = new RCUReaderThread(&amp;post, &amp;test, &amp;wrt_start);
 79     RCUReaderThread* reader3 = new RCUReaderThread(&amp;post, &amp;test, &amp;wrt_start);
 80     RCUReaderThread* reader4 = new RCUReaderThread(&amp;post, &amp;test, &amp;wrt_start);
 81 
 82     TestData* tmp = new TestData();
 83     tmp-&gt;test_value = GOOD_VALUE;
<a name="4" id="anc4"></a><span class="line-modified"> 84     Atomic::release_store_fence(&amp;test, tmp);</span>
 85 
 86     reader1-&gt;doit();
 87     reader2-&gt;doit();
 88     reader3-&gt;doit();
 89     reader4-&gt;doit();
 90 
 91     int nw = NUMBER_OF_READERS;
 92     while (nw &gt; 0) {
 93       wrt_start.wait();
 94       --nw;
 95     }
 96     jlong stop_ms = os::javaTimeMillis() + 1000; // 1 seconds max test time
 97     for (int i = 0; i &lt; 100000 &amp;&amp; stop_ms &gt; os::javaTimeMillis(); i++) {
 98       volatile TestData* free_tmp = test;
 99       tmp = new TestData();
100       tmp-&gt;test_value = GOOD_VALUE;
<a name="5" id="anc5"></a><span class="line-modified">101       Atomic::release_store(&amp;test, tmp);</span>
102       GlobalCounter::write_synchronize();
103       free_tmp-&gt;test_value = BAD_VALUE;
104       delete free_tmp;
105     }
106     RCUReaderThread::_exit = true;
107     for (int i = 0; i &lt; NUMBER_OF_READERS; i++) {
108       post.wait();
109     }
110   }
111 };
112 
113 TEST_VM(GlobalCounter, critical_section) {
114   RCUReaderThread::_exit = false;
115   mt_test_doer&lt;RCUWriterThread&gt;();
116 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
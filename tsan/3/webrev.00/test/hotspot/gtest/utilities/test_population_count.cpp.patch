diff a/test/hotspot/gtest/utilities/test_population_count.cpp b/test/hotspot/gtest/utilities/test_population_count.cpp
--- a/test/hotspot/gtest/utilities/test_population_count.cpp
+++ b/test/hotspot/gtest/utilities/test_population_count.cpp
@@ -21,17 +21,19 @@
  * questions.
  *
  */
 
 #include "precompiled.hpp"
-#include "libadt/vectset.hpp"
 #include "runtime/os.hpp"
 #include "utilities/population_count.hpp"
+#include "utilities/powerOfTwo.hpp"
 #include "utilities/globalDefinitions.hpp"
 #include "unittest.hpp"
 
-uint8_t test_popcnt_bitsInByte[BITS_IN_BYTE_ARRAY_SIZE] = {
+#define BITS_IN_BYTE_ARRAY_SIZE 256
+
+const uint8_t test_popcnt_bitsInByte[BITS_IN_BYTE_ARRAY_SIZE] = {
         0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
         1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
         1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
         2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
         1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
@@ -46,32 +48,51 @@
         3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
         3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
         4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
 };
 
-TEST(population_count, sparse) {
+template <typename T>
+void sparse() {
+  const T max_val = max_value<T>();
+
   // Step through the entire input range from a random starting point,
   // verify population_count return values against the lookup table
   // approach used historically
-  uint32_t step = 4711;
-  for (uint32_t value = os::random() % step; value < UINT_MAX - step; value += step) {
-    uint32_t lookup = test_popcnt_bitsInByte[(value >> 24) & 0xff] +
-                      test_popcnt_bitsInByte[(value >> 16) & 0xff] +
-                      test_popcnt_bitsInByte[(value >> 8)  & 0xff] +
-                      test_popcnt_bitsInByte[ value        & 0xff];
+  T step = T(1) << ((sizeof(T) * 8) - 7);
 
+  for (T value = os::random() % step; value < max_val - step; value += step) {
+    uint64_t v = (uint64_t)value;
+    unsigned lookup = 0u;
+    for (unsigned i = 0u; i < sizeof(T); i++) {
+      lookup += test_popcnt_bitsInByte[v & 0xff];
+      v >>= 8u;
+    }
     EXPECT_EQ(lookup, population_count(value))
         << "value = " << value;
   }
 
   // Test a few edge cases
-  EXPECT_EQ(0u, population_count(0u))
+  EXPECT_EQ(0u, population_count(T(0u)))
       << "value = " << 0;
-  EXPECT_EQ(1u, population_count(1u))
+  EXPECT_EQ(1u, population_count(T(1u)))
       << "value = " << 1;
-  EXPECT_EQ(1u, population_count(2u))
+  EXPECT_EQ(1u, population_count(T(2u)))
       << "value = " << 2;
-  EXPECT_EQ(32u, population_count(UINT_MAX))
-      << "value = " << UINT_MAX;
-  EXPECT_EQ(31u, population_count(UINT_MAX - 1))
-      << "value = " << (UINT_MAX - 1);
+  EXPECT_EQ(T(sizeof(T) * BitsPerByte), population_count(max_val))
+      << "value = " << max_val;
+  EXPECT_EQ(T(sizeof(T) * BitsPerByte - 1u), population_count(T(max_val - 1u)))
+      << "value = " << (max_val - 1u);
+}
+
+
+TEST(population_count, sparse8) {
+  sparse<uint8_t>();
+}
+TEST(population_count, sparse16) {
+  sparse<uint16_t>();
+}
+TEST(population_count, sparse32) {
+  sparse<uint32_t>();
 }
+TEST(population_count, sparse64) {
+  sparse<uint64_t>();
+}

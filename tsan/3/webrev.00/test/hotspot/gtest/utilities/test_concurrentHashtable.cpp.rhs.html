<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/gtest/utilities/test_concurrentHashtable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;runtime/mutex.hpp&quot;
  26 #include &quot;runtime/semaphore.hpp&quot;
  27 #include &quot;runtime/thread.hpp&quot;
  28 #include &quot;runtime/vmThread.hpp&quot;
  29 #include &quot;runtime/vmOperations.hpp&quot;
  30 #include &quot;utilities/concurrentHashTable.inline.hpp&quot;
  31 #include &quot;utilities/concurrentHashTableTasks.inline.hpp&quot;
  32 #include &quot;threadHelper.inline.hpp&quot;
  33 #include &quot;unittest.hpp&quot;
  34 
  35 // NOTE: On win32 gtest asserts are not mt-safe.
  36 // Amusingly as long as they do not assert they are mt-safe.
  37 #define SIZE_32 5
  38 
<a name="1" id="anc1"></a><span class="line-modified">  39 struct Pointer : public AllStatic {</span>
<span class="line-modified">  40   typedef uintptr_t Value;</span>
<span class="line-modified">  41   static uintx get_hash(const Value&amp; value, bool* dead_hash) {</span>





  42     return (uintx)value;
  43   }
<a name="2" id="anc2"></a><span class="line-modified">  44   static void* allocate_node(size_t size, const Value&amp; value) {</span>
  45     return ::malloc(size);
  46   }
<a name="3" id="anc3"></a><span class="line-modified">  47   static void free_node(void* memory, const Value&amp; value) {</span>
  48     ::free(memory);
  49   }
  50 };
  51 
<a name="4" id="anc4"></a><span class="line-added">  52 typedef ConcurrentHashTable&lt;Pointer, mtInternal&gt; SimpleTestTable;</span>
<span class="line-added">  53 typedef ConcurrentHashTable&lt;Pointer, mtInternal&gt;::MultiGetHandle SimpleTestGetHandle;</span>
<span class="line-added">  54 </span>
  55 struct SimpleTestLookup {
  56   uintptr_t _val;
  57   SimpleTestLookup(uintptr_t val) : _val(val) {}
  58   uintx get_hash() {
  59     return Pointer::get_hash(_val, NULL);
  60   }
  61   bool equals(const uintptr_t* value, bool* is_dead) {
  62     return _val == *value;
  63   }
  64 };
  65 
  66 struct ValueGet {
  67   uintptr_t _return;
  68   ValueGet() : _return(0) {}
  69   void operator()(uintptr_t* value) {
  70     EXPECT_NE(value, (uintptr_t*)NULL) &lt;&lt; &quot;expected valid value&quot;;
  71     _return = *value;
  72   }
  73   uintptr_t get_value() const {
  74     return _return;
  75   }
  76 };
  77 
  78 static uintptr_t cht_get_copy(SimpleTestTable* cht, Thread* thr, SimpleTestLookup stl) {
  79   ValueGet vg;
  80   cht-&gt;get(thr, stl, vg);
  81   return vg.get_value();
  82 }
  83 
  84 static void cht_find(Thread* thr, SimpleTestTable* cht, uintptr_t val) {
  85   SimpleTestLookup stl(val);
  86   ValueGet vg;
  87   EXPECT_EQ(cht-&gt;get(thr, stl, vg), true) &lt;&lt; &quot;Getting an old value failed.&quot;;
  88   EXPECT_EQ(val, vg.get_value()) &lt;&lt; &quot;Getting an old value failed.&quot;;
  89 }
  90 
  91 static void cht_insert_and_find(Thread* thr, SimpleTestTable* cht, uintptr_t val) {
  92   SimpleTestLookup stl(val);
  93   EXPECT_EQ(cht-&gt;insert(thr, stl, val), true) &lt;&lt; &quot;Inserting an unique value failed.&quot;;
  94   cht_find(thr, cht, val);
  95 }
  96 
  97 static void cht_insert(Thread* thr) {
  98   uintptr_t val = 0x2;
  99   SimpleTestLookup stl(val);
 100   SimpleTestTable* cht = new SimpleTestTable();
 101   EXPECT_TRUE(cht-&gt;insert(thr, stl, val)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 102   EXPECT_EQ(cht_get_copy(cht, thr, stl), val) &lt;&lt; &quot;Getting an existing value failed.&quot;;
 103   EXPECT_TRUE(cht-&gt;remove(thr, stl)) &lt;&lt; &quot;Removing an existing value failed.&quot;;
 104   EXPECT_FALSE(cht-&gt;remove(thr, stl)) &lt;&lt; &quot;Removing an already removed item succeeded.&quot;;
 105   EXPECT_NE(cht_get_copy(cht, thr, stl), val) &lt;&lt; &quot;Getting a removed value succeeded.&quot;;
 106   delete cht;
 107 }
 108 
 109 static void cht_get_insert(Thread* thr) {
 110   uintptr_t val = 0x2;
 111   SimpleTestLookup stl(val);
 112   SimpleTestTable* cht = new SimpleTestTable();
 113 
 114   {
 115     SCOPED_TRACE(&quot;First&quot;);
 116     cht_insert_and_find(thr, cht, val);
 117   }
 118   EXPECT_EQ(cht_get_copy(cht, thr, stl), val) &lt;&lt; &quot;Get an old value failed&quot;;
 119   EXPECT_TRUE(cht-&gt;remove(thr, stl)) &lt;&lt; &quot;Removing existing value failed.&quot;;
 120   EXPECT_NE(cht_get_copy(cht, thr, stl), val) &lt;&lt; &quot;Got an already removed item.&quot;;
 121 
 122   {
 123     SCOPED_TRACE(&quot;Second&quot;);
 124     cht_insert_and_find(thr, cht, val);
 125   }
 126 
 127   delete cht;
 128 }
 129 
 130 static bool getinsert_bulkdelete_eval(uintptr_t* val) {
 131   EXPECT_TRUE(*val &gt; 0 &amp;&amp; *val &lt; 4) &lt;&lt; &quot;Val wrong for this test.&quot;;
 132   return (*val &amp; 0x1); // Delete all values ending with first bit set.
 133 }
 134 
 135 static void getinsert_bulkdelete_del(uintptr_t* val) {
 136   EXPECT_EQ(*val &amp; 0x1, (uintptr_t)1) &lt;&lt; &quot;Deleting wrong value.&quot;;
 137 }
 138 
 139 static void cht_getinsert_bulkdelete_insert_verified(Thread* thr, SimpleTestTable* cht, uintptr_t val,
 140                                                      bool verify_expect_get, bool verify_expect_inserted) {
 141   SimpleTestLookup stl(val);
 142   if (verify_expect_inserted) {
 143     cht_insert_and_find(thr, cht, val);
 144   }
 145   if (verify_expect_get) {
 146     cht_find(thr, cht, val);
 147   }
 148 }
 149 
 150 static void cht_getinsert_bulkdelete(Thread* thr) {
 151   uintptr_t val1 = 1;
 152   uintptr_t val2 = 2;
 153   uintptr_t val3 = 3;
 154   SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);
 155 
 156   SimpleTestTable* cht = new SimpleTestTable();
 157   cht_getinsert_bulkdelete_insert_verified(thr, cht, val1, false, true);
 158   cht_getinsert_bulkdelete_insert_verified(thr, cht, val2, false, true);
 159   cht_getinsert_bulkdelete_insert_verified(thr, cht, val3, false, true);
 160 
 161   EXPECT_TRUE(cht-&gt;remove(thr, stl2)) &lt;&lt; &quot;Remove did not find value.&quot;;
 162 
 163   cht_getinsert_bulkdelete_insert_verified(thr, cht, val1, true, false); // val1 should be present
 164   cht_getinsert_bulkdelete_insert_verified(thr, cht, val2, false, true); // val2 should be inserted
 165   cht_getinsert_bulkdelete_insert_verified(thr, cht, val3, true, false); // val3 should be present
 166 
 167   EXPECT_EQ(cht_get_copy(cht, thr, stl1), val1) &lt;&lt; &quot;Get did not find value.&quot;;
 168   EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) &lt;&lt; &quot;Get did not find value.&quot;;
 169   EXPECT_EQ(cht_get_copy(cht, thr, stl3), val3) &lt;&lt; &quot;Get did not find value.&quot;;
 170 
 171   // Removes all odd values.
 172   cht-&gt;bulk_delete(thr, getinsert_bulkdelete_eval, getinsert_bulkdelete_del);
 173 
 174   EXPECT_EQ(cht_get_copy(cht, thr, stl1), (uintptr_t)0) &lt;&lt; &quot;Odd value should not exist.&quot;;
 175   EXPECT_FALSE(cht-&gt;remove(thr, stl1)) &lt;&lt; &quot;Odd value should not exist.&quot;;
 176   EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) &lt;&lt; &quot;Even value should not have been removed.&quot;;
 177   EXPECT_EQ(cht_get_copy(cht, thr, stl3), (uintptr_t)0) &lt;&lt; &quot;Add value should not exists.&quot;;
 178   EXPECT_FALSE(cht-&gt;remove(thr, stl3)) &lt;&lt; &quot;Odd value should not exists.&quot;;
 179 
 180   delete cht;
 181 }
 182 
 183 static void cht_getinsert_bulkdelete_task(Thread* thr) {
 184   uintptr_t val1 = 1;
 185   uintptr_t val2 = 2;
 186   uintptr_t val3 = 3;
 187   SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);
 188 
 189   SimpleTestTable* cht = new SimpleTestTable();
 190   cht_getinsert_bulkdelete_insert_verified(thr, cht, val1, false, true);
 191   cht_getinsert_bulkdelete_insert_verified(thr, cht, val2, false, true);
 192   cht_getinsert_bulkdelete_insert_verified(thr, cht, val3, false, true);
 193 
 194   EXPECT_TRUE(cht-&gt;remove(thr, stl2)) &lt;&lt; &quot;Remove did not find value.&quot;;
 195 
 196   cht_getinsert_bulkdelete_insert_verified(thr, cht, val1, true, false); // val1 should be present
 197   cht_getinsert_bulkdelete_insert_verified(thr, cht, val2, false, true); // val2 should be inserted
 198   cht_getinsert_bulkdelete_insert_verified(thr, cht, val3, true, false); // val3 should be present
 199 
 200   EXPECT_EQ(cht_get_copy(cht, thr, stl1), val1) &lt;&lt; &quot;Get did not find value.&quot;;
 201   EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) &lt;&lt; &quot;Get did not find value.&quot;;
 202   EXPECT_EQ(cht_get_copy(cht, thr, stl3), val3) &lt;&lt; &quot;Get did not find value.&quot;;
 203 
 204   // Removes all odd values.
 205   SimpleTestTable::BulkDeleteTask bdt(cht);
 206   if (bdt.prepare(thr)) {
 207     while(bdt.do_task(thr, getinsert_bulkdelete_eval, getinsert_bulkdelete_del)) {
 208       bdt.pause(thr);
 209       bdt.cont(thr);
 210     }
 211     bdt.done(thr);
 212   }
 213 
 214   EXPECT_EQ(cht_get_copy(cht, thr, stl1), (uintptr_t)0) &lt;&lt; &quot;Odd value should not exist.&quot;;
 215   EXPECT_FALSE(cht-&gt;remove(thr, stl1)) &lt;&lt; &quot;Odd value should not exist.&quot;;
 216   EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) &lt;&lt; &quot;Even value should not have been removed.&quot;;
 217   EXPECT_EQ(cht_get_copy(cht, thr, stl3), (uintptr_t)0) &lt;&lt; &quot;Add value should not exists.&quot;;
 218   EXPECT_FALSE(cht-&gt;remove(thr, stl3)) &lt;&lt; &quot;Odd value should not exists.&quot;;
 219 
 220   delete cht;
 221 }
 222 
 223 static void cht_scope(Thread* thr) {
 224   uintptr_t val = 0x2;
 225   SimpleTestLookup stl(val);
 226   SimpleTestTable* cht = new SimpleTestTable();
 227   EXPECT_TRUE(cht-&gt;insert(thr, stl, val)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 228   {
 229     SimpleTestGetHandle get_handle(thr, cht);
 230     EXPECT_EQ(*get_handle.get(stl), val) &lt;&lt; &quot;Getting a pre-existing value failed.&quot;;
 231   }
 232   // We do remove here to make sure the value-handle &#39;unlocked&#39; the table when leaving the scope.
 233   EXPECT_TRUE(cht-&gt;remove(thr, stl)) &lt;&lt; &quot;Removing a pre-existing value failed.&quot;;
 234   EXPECT_FALSE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Got a removed value.&quot;;
 235   delete cht;
 236 }
 237 
 238 struct ChtScan {
 239   size_t _count;
 240   ChtScan() : _count(0) {}
 241   bool operator()(uintptr_t* val) {
 242     EXPECT_EQ(*val, (uintptr_t)0x2) &lt;&lt; &quot;Got an unknown value.&quot;;
 243     EXPECT_EQ(_count, 0u) &lt;&lt; &quot;Only one value should be in table.&quot;;
 244     _count++;
 245     return true; /* continue scan */
 246   }
 247 };
 248 
 249 static void cht_scan(Thread* thr) {
 250   uintptr_t val = 0x2;
 251   SimpleTestLookup stl(val);
 252   ChtScan scan;
 253   SimpleTestTable* cht = new SimpleTestTable();
 254   EXPECT_TRUE(cht-&gt;insert(thr, stl, val)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 255   EXPECT_EQ(cht-&gt;try_scan(thr, scan), true) &lt;&lt; &quot;Scanning an non-growing/shrinking table should work.&quot;;
 256   EXPECT_TRUE(cht-&gt;remove(thr, stl)) &lt;&lt; &quot;Removing a pre-existing value failed.&quot;;
 257   EXPECT_FALSE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Got a removed value.&quot;;
 258   delete cht;
 259 }
 260 
 261 struct ChtCountScan {
 262   size_t _count;
 263   ChtCountScan() : _count(0) {}
 264   bool operator()(uintptr_t* val) {
 265     _count++;
 266     return true; /* continue scan */
 267   }
 268 };
 269 
 270 static void cht_move_to(Thread* thr) {
 271   uintptr_t val1 = 0x2;
 272   uintptr_t val2 = 0xe0000002;
 273   uintptr_t val3 = 0x3;
 274   SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);
 275   SimpleTestTable* from_cht = new SimpleTestTable();
 276   EXPECT_TRUE(from_cht-&gt;insert(thr, stl1, val1)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 277   EXPECT_TRUE(from_cht-&gt;insert(thr, stl2, val2)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 278   EXPECT_TRUE(from_cht-&gt;insert(thr, stl3, val3)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 279 
 280   SimpleTestTable* to_cht = new SimpleTestTable();
 281   EXPECT_TRUE(from_cht-&gt;try_move_nodes_to(thr, to_cht)) &lt;&lt; &quot;Moving nodes to new table failed&quot;;
 282 
 283   ChtCountScan scan_old;
 284   EXPECT_TRUE(from_cht-&gt;try_scan(thr, scan_old)) &lt;&lt; &quot;Scanning table should work.&quot;;
 285   EXPECT_EQ(scan_old._count, (size_t)0) &lt;&lt; &quot;All items should be moved&quot;;
 286 
 287   ChtCountScan scan_new;
 288   EXPECT_TRUE(to_cht-&gt;try_scan(thr, scan_new)) &lt;&lt; &quot;Scanning table should work.&quot;;
 289   EXPECT_EQ(scan_new._count, (size_t)3) &lt;&lt; &quot;All items should be moved&quot;;
 290   EXPECT_TRUE(cht_get_copy(to_cht, thr, stl1) == val1) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 291   EXPECT_TRUE(cht_get_copy(to_cht, thr, stl2) == val2) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 292   EXPECT_TRUE(cht_get_copy(to_cht, thr, stl3) == val3) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 293 }
 294 
 295 static void cht_grow(Thread* thr) {
 296   uintptr_t val = 0x2;
 297   uintptr_t val2 = 0x22;
 298   uintptr_t val3 = 0x222;
 299   SimpleTestLookup stl(val), stl2(val2), stl3(val3);
 300   SimpleTestTable* cht = new SimpleTestTable();
 301 
 302   EXPECT_TRUE(cht-&gt;insert(thr, stl, val)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 303   EXPECT_TRUE(cht-&gt;insert(thr, stl2, val2)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 304   EXPECT_TRUE(cht-&gt;insert(thr, stl3, val3)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 305   EXPECT_FALSE(cht-&gt;insert(thr, stl3, val3)) &lt;&lt; &quot;Insert duplicate value should have failed.&quot;;
 306   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 307   EXPECT_TRUE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 308   EXPECT_TRUE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 309 
 310   EXPECT_TRUE(cht-&gt;remove(thr, stl2)) &lt;&lt; &quot;Removing an inserted value should work.&quot;;
 311 
 312   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 313   EXPECT_FALSE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting a removed value should have failed.&quot;;
 314   EXPECT_TRUE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 315 
 316 
 317   EXPECT_TRUE(cht-&gt;grow(thr)) &lt;&lt; &quot;Growing uncontended should not fail.&quot;;
 318 
 319   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an item after grow failed.&quot;;
 320   EXPECT_FALSE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting a removed value after grow should have failed.&quot;;
 321   EXPECT_TRUE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting an item after grow failed.&quot;;
 322 
 323   EXPECT_TRUE(cht-&gt;insert(thr, stl2, val2)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 324   EXPECT_TRUE(cht-&gt;remove(thr, stl3)) &lt;&lt; &quot;Removing an inserted value should work.&quot;;
 325 
 326   EXPECT_TRUE(cht-&gt;shrink(thr)) &lt;&lt; &quot;Shrinking uncontended should not fail.&quot;;
 327 
 328   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an item after shrink failed.&quot;;
 329   EXPECT_TRUE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting an item after shrink failed.&quot;;
 330   EXPECT_FALSE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting a removed value after shrink should have failed.&quot;;
 331 
 332   delete cht;
 333 }
 334 
 335 static void cht_task_grow(Thread* thr) {
 336   uintptr_t val = 0x2;
 337   uintptr_t val2 = 0x22;
 338   uintptr_t val3 = 0x222;
 339   SimpleTestLookup stl(val), stl2(val2), stl3(val3);
 340   SimpleTestTable* cht = new SimpleTestTable();
 341 
 342   EXPECT_TRUE(cht-&gt;insert(thr, stl, val)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 343   EXPECT_TRUE(cht-&gt;insert(thr, stl2, val2)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 344   EXPECT_TRUE(cht-&gt;insert(thr, stl3, val3)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 345   EXPECT_FALSE(cht-&gt;insert(thr, stl3, val3)) &lt;&lt; &quot;Insert duplicate value should have failed.&quot;;
 346   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 347   EXPECT_TRUE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 348   EXPECT_TRUE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 349 
 350   EXPECT_TRUE(cht-&gt;remove(thr, stl2)) &lt;&lt; &quot;Removing an inserted value should work.&quot;;
 351 
 352   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 353   EXPECT_FALSE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting a removed value should have failed.&quot;;
 354   EXPECT_TRUE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 355 
 356   SimpleTestTable::GrowTask gt(cht);
 357   EXPECT_TRUE(gt.prepare(thr)) &lt;&lt; &quot;Growing uncontended should not fail.&quot;;
 358   while(gt.do_task(thr)) { /* grow */  }
 359   gt.done(thr);
 360 
 361   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an item after grow failed.&quot;;
 362   EXPECT_FALSE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting a removed value after grow should have failed.&quot;;
 363   EXPECT_TRUE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting an item after grow failed.&quot;;
 364 
 365   EXPECT_TRUE(cht-&gt;insert(thr, stl2, val2)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 366   EXPECT_TRUE(cht-&gt;remove(thr, stl3)) &lt;&lt; &quot;Removing an inserted value should work.&quot;;
 367 
 368   EXPECT_TRUE(cht-&gt;shrink(thr)) &lt;&lt; &quot;Shrinking uncontended should not fail.&quot;;
 369 
 370   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an item after shrink failed.&quot;;
 371   EXPECT_TRUE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting an item after shrink failed.&quot;;
 372   EXPECT_FALSE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting a removed value after shrink should have failed.&quot;;
 373 
 374   delete cht;
 375 }
 376 
 377 TEST_VM(ConcurrentHashTable, basic_insert) {
 378   nomt_test_doer(cht_insert);
 379 }
 380 
 381 TEST_VM(ConcurrentHashTable, basic_get_insert) {
 382   nomt_test_doer(cht_get_insert);
 383 }
 384 
 385 TEST_VM(ConcurrentHashTable, basic_scope) {
 386   nomt_test_doer(cht_scope);
 387 }
 388 
 389 TEST_VM(ConcurrentHashTable, basic_get_insert_bulk_delete) {
 390   nomt_test_doer(cht_getinsert_bulkdelete);
 391 }
 392 
 393 TEST_VM(ConcurrentHashTable, basic_get_insert_bulk_delete_task) {
 394   nomt_test_doer(cht_getinsert_bulkdelete_task);
 395 }
 396 
 397 TEST_VM(ConcurrentHashTable, basic_scan) {
 398   nomt_test_doer(cht_scan);
 399 }
 400 
 401 TEST_VM(ConcurrentHashTable, basic_move_to) {
 402   nomt_test_doer(cht_move_to);
 403 }
 404 
 405 TEST_VM(ConcurrentHashTable, basic_grow) {
 406   nomt_test_doer(cht_grow);
 407 }
 408 
 409 TEST_VM(ConcurrentHashTable, task_grow) {
 410   nomt_test_doer(cht_task_grow);
 411 }
 412 
 413 //#############################################################################################
 414 
<a name="5" id="anc5"></a><span class="line-modified"> 415 class TestInterface : public AllStatic {</span>





 416 public:
<a name="6" id="anc6"></a><span class="line-modified"> 417   typedef uintptr_t Value;</span>
<span class="line-added"> 418   static uintx get_hash(const Value&amp; value, bool* dead_hash) {</span>
 419     return (uintx)(value + 18446744073709551557ul) * 18446744073709551557ul;
 420   }
<a name="7" id="anc7"></a><span class="line-added"> 421   static void* allocate_node(size_t size, const Value&amp; value) {</span>
<span class="line-added"> 422     return AllocateHeap(size, mtInternal);</span>
<span class="line-added"> 423   }</span>
<span class="line-added"> 424   static void free_node(void* memory, const Value&amp; value) {</span>
<span class="line-added"> 425     FreeHeap(memory);</span>
<span class="line-added"> 426   }</span>
 427 };
 428 
<a name="8" id="anc8"></a><span class="line-added"> 429 typedef ConcurrentHashTable&lt;TestInterface, mtInternal&gt; TestTable;</span>
<span class="line-added"> 430 typedef ConcurrentHashTable&lt;TestInterface, mtInternal&gt;::MultiGetHandle TestGetHandle;</span>
<span class="line-added"> 431 </span>
 432 struct TestLookup {
 433   uintptr_t _val;
 434   TestLookup(uintptr_t val) : _val(val) {}
 435   uintx get_hash() {
 436     return TestInterface::get_hash(_val, NULL);
 437   }
 438   bool equals(const uintptr_t* value, bool* is_dead) {
 439     return _val == *value;
 440   }
 441 };
 442 
 443 static uintptr_t cht_get_copy(TestTable* cht, Thread* thr, TestLookup tl) {
 444   ValueGet vg;
 445   cht-&gt;get(thr, tl, vg);
 446   return vg.get_value();
 447 }
 448 
 449 class CHTTestThread : public JavaTestThread {
 450   public:
 451   uintptr_t _start;
 452   uintptr_t _stop;
 453   TestTable *_cht;
 454   jlong _stop_ms;
 455   CHTTestThread(uintptr_t start, uintptr_t stop, TestTable* cht, Semaphore* post)
 456     : JavaTestThread(post), _start(start), _stop(stop), _cht(cht) {}
 457   virtual void premain() {}
 458   void main_run() {
 459     premain();
 460     _stop_ms = os::javaTimeMillis() + 2000; // 2 seconds max test time
 461     while (keep_looping() &amp;&amp; test_loop()) { /* */ }
 462     postmain();
 463   }
 464   virtual void postmain() {}
 465   virtual bool keep_looping() {
 466     return _stop_ms &gt; os::javaTimeMillis();
 467   };
 468   virtual bool test_loop() = 0;
 469   virtual ~CHTTestThread() {}
 470 };
 471 
 472 class ValueSaver {
 473   uintptr_t* _vals;
 474   size_t _it;
 475   size_t _size;
 476  public:
 477   ValueSaver() : _it(0), _size(1024) {
 478       _vals = NEW_C_HEAP_ARRAY(uintptr_t, _size, mtInternal);
 479   }
 480 
 481   bool operator()(uintptr_t* val) {
 482     _vals[_it++] = *val;
 483     if (_it == _size) {
 484       _size *= 2;
 485       _vals = REALLOC_RESOURCE_ARRAY(uintptr_t, _vals, _size/2, _size);
 486     }
 487     return true;
 488   }
 489 
 490   void check() {
 491     for (size_t i = 0; i &lt; _it; i++) {
 492       size_t count = 0;
 493       for (size_t j = (i + 1u); j &lt; _it; j++) {
 494         if (_vals[i] == _vals[j]) {
 495           count++;
 496         }
 497       }
 498       EXPECT_EQ(count, 0u);
 499     }
 500   }
 501 };
 502 
 503 static void integrity_check(Thread* thr, TestTable* cht)
 504 {
 505   ValueSaver vs;
 506   cht-&gt;do_scan(thr, vs);
 507   vs.check();
 508 }
 509 
 510 //#############################################################################################
 511 // All threads are working on different items
 512 // This item should only be delete by this thread
 513 // Thus get_unsafe is safe for this test.
 514 
 515 class SimpleInserterThread : public CHTTestThread {
 516 public:
 517   static volatile bool _exit;
 518 
 519   SimpleInserterThread(uintptr_t start, uintptr_t stop, TestTable* cht, Semaphore* post)
 520     : CHTTestThread(start, stop, cht, post) {};
 521   virtual ~SimpleInserterThread(){}
 522 
 523   bool keep_looping() {
 524     return !_exit;
 525   }
 526 
 527   bool test_loop() {
 528     bool grow;
 529     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 530       TestLookup tl(v);
 531       EXPECT_TRUE(_cht-&gt;insert(this, tl, v, &amp;grow)) &lt;&lt; &quot;Inserting an unique value should work.&quot;;
 532     }
 533     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 534       TestLookup tl(v);
 535       EXPECT_TRUE(cht_get_copy(_cht, this, tl) == v) &lt;&lt; &quot;Getting an previously inserted value unsafe failed.&quot;;
 536     }
 537     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 538       TestLookup tl(v);
 539       EXPECT_TRUE(_cht-&gt;remove(this, tl)) &lt;&lt; &quot;Removing an existing value failed.&quot;;
 540     }
 541     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 542       TestLookup tl(v);
 543       EXPECT_TRUE(cht_get_copy(_cht, this, tl) == 0) &lt;&lt; &quot;Got a removed value.&quot;;
 544     }
 545     return true;
 546   }
 547 };
 548 
 549 volatile bool SimpleInserterThread::_exit = false;
 550 
 551 class RunnerSimpleInserterThread : public CHTTestThread {
 552 public:
 553   Semaphore _done;
 554 
 555   RunnerSimpleInserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {
 556     _cht = new TestTable(SIZE_32, SIZE_32);
 557   };
 558   virtual ~RunnerSimpleInserterThread(){}
 559 
 560   void premain() {
 561 
 562     SimpleInserterThread* ins1 = new SimpleInserterThread((uintptr_t)0x100, (uintptr_t) 0x1FF, _cht, &amp;_done);
 563     SimpleInserterThread* ins2 = new SimpleInserterThread((uintptr_t)0x200, (uintptr_t) 0x2FF, _cht, &amp;_done);
 564     SimpleInserterThread* ins3 = new SimpleInserterThread((uintptr_t)0x300, (uintptr_t) 0x3FF, _cht, &amp;_done);
 565     SimpleInserterThread* ins4 = new SimpleInserterThread((uintptr_t)0x400, (uintptr_t) 0x4FF, _cht, &amp;_done);
 566 
 567     for (uintptr_t v = 0x500; v &lt; 0x5FF; v++ ) {
 568       TestLookup tl(v);
 569       EXPECT_TRUE(_cht-&gt;insert(this, tl, v)) &lt;&lt; &quot;Inserting an unique value should work.&quot;;
 570     }
 571 
 572     ins1-&gt;doit();
 573     ins2-&gt;doit();
 574     ins3-&gt;doit();
 575     ins4-&gt;doit();
 576 
 577   }
 578 
 579   bool test_loop() {
 580     for (uintptr_t v = 0x500; v &lt; 0x5FF; v++ ) {
 581       TestLookup tl(v);
 582       EXPECT_TRUE(cht_get_copy(_cht, this, tl) == v) &lt;&lt; &quot;Getting an previously inserted value unsafe failed.&quot;;;
 583     }
 584     return true;
 585   }
 586 
 587   void postmain() {
 588     SimpleInserterThread::_exit = true;
 589     for (int i = 0; i &lt; 4; i++) {
 590       _done.wait();
 591     }
 592     for (uintptr_t v = 0x500; v &lt; 0x5FF; v++ ) {
 593       TestLookup tl(v);
 594       EXPECT_TRUE(_cht-&gt;remove(this, tl)) &lt;&lt; &quot;Removing an existing value failed.&quot;;
 595     }
 596     integrity_check(this, _cht);
 597     delete _cht;
 598   }
 599 };
 600 
 601 
 602 TEST_VM(ConcurrentHashTable, concurrent_simple) {
 603   SimpleInserterThread::_exit = false;
 604   mt_test_doer&lt;RunnerSimpleInserterThread&gt;();
 605 }
 606 
 607 //#############################################################################################
 608 // In this test we try to get a &#39;bad&#39; value
 609 class DeleteInserterThread : public CHTTestThread {
 610 public:
 611   static volatile bool _exit;
 612 
 613   DeleteInserterThread(uintptr_t start, uintptr_t stop, TestTable* cht, Semaphore* post) : CHTTestThread(start, stop, cht, post) {};
 614   virtual ~DeleteInserterThread(){}
 615 
 616   bool keep_looping() {
 617     return !_exit;
 618   }
 619 
 620   bool test_loop() {
 621     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 622       TestLookup tl(v);
 623       _cht-&gt;insert(this, tl, v);
 624     }
 625     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 626       TestLookup tl(v);
 627       _cht-&gt;remove(this, tl);
 628     }
 629     return true;
 630   }
 631 };
 632 
 633 volatile bool DeleteInserterThread::_exit = true;
 634 
 635 class RunnerDeleteInserterThread : public CHTTestThread {
 636 public:
 637   Semaphore _done;
 638 
 639   RunnerDeleteInserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {
 640     _cht = new TestTable(SIZE_32, SIZE_32);
 641   };
 642   virtual ~RunnerDeleteInserterThread(){}
 643 
 644   void premain() {
 645     DeleteInserterThread* ins1 = new DeleteInserterThread((uintptr_t)0x1, (uintptr_t) 0xFFF, _cht, &amp;_done);
 646     DeleteInserterThread* ins2 = new DeleteInserterThread((uintptr_t)0x1, (uintptr_t) 0xFFF, _cht, &amp;_done);
 647     DeleteInserterThread* ins3 = new DeleteInserterThread((uintptr_t)0x1, (uintptr_t) 0xFFF, _cht, &amp;_done);
 648     DeleteInserterThread* ins4 = new DeleteInserterThread((uintptr_t)0x1, (uintptr_t) 0xFFF, _cht, &amp;_done);
 649 
 650     ins1-&gt;doit();
 651     ins2-&gt;doit();
 652     ins3-&gt;doit();
 653     ins4-&gt;doit();
 654   }
 655 
 656   bool test_loop() {
 657     for (uintptr_t v = 0x1; v &lt; 0xFFF; v++ ) {
 658       uintptr_t tv;
 659       if (v &amp; 0x1) {
 660         TestLookup tl(v);
 661         tv = cht_get_copy(_cht, this, tl);
 662       } else {
 663         TestLookup tl(v);
 664         TestGetHandle value_handle(this, _cht);
 665         uintptr_t* tmp = value_handle.get(tl);
 666         tv = tmp != NULL ? *tmp : 0;
 667       }
 668       EXPECT_TRUE(tv == 0 || tv == v) &lt;&lt; &quot;Got unknown value.&quot;;
 669     }
 670     return true;
 671   }
 672 
 673   void postmain() {
 674     DeleteInserterThread::_exit = true;
 675     for (int i = 0; i &lt; 4; i++) {
 676       _done.wait();
 677     }
 678     integrity_check(this, _cht);
 679     delete _cht;
 680   }
 681 };
 682 
 683 TEST_VM(ConcurrentHashTable, concurrent_deletes) {
 684   DeleteInserterThread::_exit = false;
 685   mt_test_doer&lt;RunnerDeleteInserterThread&gt;();
 686 }
 687 
 688 //#############################################################################################
 689 
 690 #define START_SIZE 13
 691 #define END_SIZE 17
 692 #define START (uintptr_t)0x10000
 693 #define RANGE (uintptr_t)0xFFFF
 694 
 695 #define GSTEST_THREAD_COUNT 5
 696 
 697 
 698 class GSInserterThread: public CHTTestThread {
 699 public:
 700   static volatile bool _shrink;
 701   GSInserterThread(uintptr_t start, uintptr_t stop, TestTable* cht, Semaphore* post) : CHTTestThread(start, stop, cht, post) {};
 702   virtual ~GSInserterThread(){}
 703   bool keep_looping() {
 704     return !(_shrink &amp;&amp; _cht-&gt;get_size_log2(this) == START_SIZE);
 705   }
 706   bool test_loop() {
 707     bool grow;
 708     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 709       TestLookup tl(v);
 710       EXPECT_TRUE(_cht-&gt;insert(this, tl, v, &amp;grow)) &lt;&lt; &quot;Inserting an unique value should work.&quot;;
 711       if (grow &amp;&amp; !_shrink) {
 712         _cht-&gt;grow(this);
 713       }
 714     }
 715     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 716       TestLookup tl(v);
 717       EXPECT_TRUE(cht_get_copy(_cht, this, tl) == v) &lt;&lt;  &quot;Getting an previously inserted value unsafe failed.&quot;;
 718     }
 719     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 720       TestLookup tl(v);
 721       EXPECT_TRUE(_cht-&gt;remove(this, tl)) &lt;&lt; &quot;Removing an existing value failed.&quot;;
 722     }
 723     if (_shrink) {
 724       _cht-&gt;shrink(this);
 725     }
 726     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 727       TestLookup tl(v);
 728       EXPECT_FALSE(cht_get_copy(_cht, this, tl) == v)  &lt;&lt; &quot;Getting a removed value should have failed.&quot;;
 729     }
 730     if (!_shrink &amp;&amp; _cht-&gt;get_size_log2(this) == END_SIZE) {
 731       _shrink = true;
 732     }
 733     return true;
 734   }
 735 };
 736 
 737 volatile bool GSInserterThread::_shrink = false;
 738 
 739 class GSScannerThread : public CHTTestThread {
 740 public:
 741   GSScannerThread(uintptr_t start, uintptr_t stop, TestTable* cht, Semaphore* post) : CHTTestThread(start, stop, cht, post) {};
 742   virtual ~GSScannerThread(){}
 743 
 744   bool operator()(uintptr_t* val) {
 745     if (*val &gt;= this-&gt;_start &amp;&amp; *val &lt;= this-&gt;_stop) {
 746       return false;
 747     }
 748     // continue scan
 749     return true;
 750   }
 751 
 752   bool test_loop() {
 753     _cht-&gt;try_scan(this, *this);
 754     os::naked_short_sleep(5);
 755     return true;
 756   }
 757 };
 758 
 759 class RunnerGSInserterThread : public CHTTestThread {
 760 public:
 761   uintptr_t _start;
 762   uintptr_t _range;
 763   Semaphore _done;
 764 
 765   RunnerGSInserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {
 766     _cht = new TestTable(START_SIZE, END_SIZE, 2);
 767   };
 768   virtual ~RunnerGSInserterThread(){}
 769 
 770   void premain() {
 771     volatile bool timeout = false;
 772     _start = START;
 773     _range = RANGE;
 774     CHTTestThread* tt[GSTEST_THREAD_COUNT];
 775     tt[0] = new GSInserterThread(_start, _start + _range, _cht, &amp;_done);
 776     _start += _range + 1;
 777     tt[1] = new GSInserterThread(_start, _start + _range, _cht, &amp;_done);
 778     _start += _range + 1;
 779     tt[2] = new GSInserterThread(_start, _start + _range, _cht, &amp;_done);
 780     _start += _range + 1;
 781     tt[3] = new GSInserterThread(_start, _start + _range, _cht, &amp;_done);
 782     tt[4] = new GSScannerThread(_start, _start + _range, _cht, &amp;_done);
 783     _start += _range + 1;
 784 
 785 
 786     for (uintptr_t v = _start; v &lt;= (_start + _range); v++ ) {
 787       TestLookup tl(v);
 788       EXPECT_TRUE(_cht-&gt;insert(this, tl, v)) &lt;&lt; &quot;Inserting an unique value should work.&quot;;
 789     }
 790 
 791     for (int i = 0; i &lt; GSTEST_THREAD_COUNT; i++) {
 792       tt[i]-&gt;doit();
 793     }
 794   }
 795 
 796   bool test_loop() {
 797     for (uintptr_t v = _start; v &lt;= (_start + _range); v++ ) {
 798       TestLookup tl(v);
 799       EXPECT_TRUE(cht_get_copy(_cht, this, tl) == v) &lt;&lt;  &quot;Getting an previously inserted value unsafe failed.&quot;;
 800     }
 801     return true;
 802   }
 803 
 804   void postmain() {
 805     GSInserterThread::_shrink = true;
 806     for (uintptr_t v = _start; v &lt;= (_start + _range); v++ ) {
 807       TestLookup tl(v);
 808       EXPECT_TRUE(_cht-&gt;remove(this, tl)) &lt;&lt; &quot;Removing an existing value failed.&quot;;
 809     }
 810     for (int i = 0; i &lt; GSTEST_THREAD_COUNT; i++) {
 811       _done.wait();
 812     }
 813     EXPECT_TRUE(_cht-&gt;get_size_log2(this) == START_SIZE) &lt;&lt; &quot;Not at start size.&quot;;
 814     Count cnt;
 815     _cht-&gt;do_scan(this, cnt);
 816     EXPECT_TRUE(cnt._cnt == 0) &lt;&lt; &quot;Items still in table&quot;;
 817     delete _cht;
 818   }
 819 
 820   struct Count {
 821     Count() : _cnt(0) {}
 822     size_t _cnt;
 823     bool operator()(uintptr_t*) { _cnt++; return true; };
 824   };
 825 };
 826 
 827 TEST_VM(ConcurrentHashTable, concurrent_scan_grow_shrink) {
 828   GSInserterThread::_shrink = false;
 829   mt_test_doer&lt;RunnerGSInserterThread&gt;();
 830 }
 831 
 832 
 833 //#############################################################################################
 834 
 835 #define GI_BD_GI_BD_START_SIZE 13
 836 #define GI_BD_END_SIZE 17
 837 #define GI_BD_START (uintptr_t)0x1
 838 #define GI_BD_RANGE (uintptr_t)0x3FFFF
 839 
 840 #define GI_BD_TEST_THREAD_COUNT 4
 841 
 842 
 843 class GI_BD_InserterThread: public CHTTestThread {
 844 public:
 845   static volatile bool _shrink;
 846   uintptr_t _br;
 847   GI_BD_InserterThread(uintptr_t start, uintptr_t stop, TestTable* cht, Semaphore* post, uintptr_t br)
 848     : CHTTestThread(start, stop, cht, post), _br(br) {};
 849   virtual ~GI_BD_InserterThread(){}
 850 
 851   bool keep_looping() {
 852     return !(_shrink &amp;&amp; _cht-&gt;get_size_log2(this) == GI_BD_GI_BD_START_SIZE);
 853   }
 854 
 855   bool test_loop() {
 856     bool grow;
 857     MyDel del(_br);
 858     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 859       {
 860         TestLookup tl(v);
 861         ValueGet vg;
 862         do {
 863           if (_cht-&gt;get(this, tl, vg, &amp;grow)) {
 864             EXPECT_EQ(v, vg.get_value()) &lt;&lt; &quot;Getting an old value failed.&quot;;
 865             break;
 866           }
 867           if (_cht-&gt;insert(this, tl, v, &amp;grow)) {
 868             break;
 869           }
 870         } while(true);
 871       }
 872       if (grow &amp;&amp; !_shrink) {
 873         _cht-&gt;grow(this);
 874       }
 875     }
 876     if (_shrink) {
 877       _cht-&gt;shrink(this);
 878     }
 879     _cht-&gt;try_bulk_delete(this, *this, del);
 880     if (!_shrink &amp;&amp; _cht-&gt;is_max_size_reached()) {
 881       _shrink = true;
 882     }
 883     _cht-&gt;bulk_delete(this, *this, del);
 884     return true;
 885   }
 886 
 887   bool operator()(uintptr_t* val) {
 888     return (*val &amp; _br) == 1;
 889   }
 890 
 891   struct MyDel {
 892     MyDel(uintptr_t &amp;br) : _br(br) {};
 893     uintptr_t &amp;_br;
 894     void operator()(uintptr_t* val) {
 895       EXPECT_EQ((*val &amp; _br), _br) &lt;&lt; &quot;Removing an item that should not have been removed.&quot;;
 896     }
 897   };
 898 };
 899 
 900 volatile bool GI_BD_InserterThread::_shrink = false;
 901 
 902 class RunnerGI_BD_InserterThread : public CHTTestThread {
 903 public:
 904   Semaphore _done;
 905   uintptr_t _start;
 906   uintptr_t _range;
 907   RunnerGI_BD_InserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {
 908     _cht = new TestTable(GI_BD_GI_BD_START_SIZE, GI_BD_END_SIZE, 2);
 909   };
 910   virtual ~RunnerGI_BD_InserterThread(){}
 911 
 912   void premain() {
 913     _start = GI_BD_START;
 914     _range = GI_BD_RANGE;
 915     CHTTestThread* tt[GI_BD_TEST_THREAD_COUNT];
 916     tt[0] = new GI_BD_InserterThread(_start, _start + _range, _cht, &amp;_done, (uintptr_t)0x1);
 917     tt[1] = new GI_BD_InserterThread(_start, _start + _range, _cht, &amp;_done, (uintptr_t)0x2);
 918     tt[2] = new GI_BD_InserterThread(_start, _start + _range, _cht, &amp;_done, (uintptr_t)0x4);
 919     tt[3] = new GI_BD_InserterThread(_start, _start + _range, _cht, &amp;_done, (uintptr_t)0x8);
 920 
 921     for (uintptr_t v = _start; v &lt;= (_start + _range); v++ ) {
 922       TestLookup tl(v);
 923       EXPECT_TRUE(_cht-&gt;insert(this, tl, v)) &lt;&lt; &quot;Inserting an unique value should work.&quot;;
 924     }
 925 
 926     for (int i =0; i &lt; GI_BD_TEST_THREAD_COUNT; i++) {
 927       tt[i]-&gt;doit();
 928     }
 929   }
 930 
 931   bool test_loop() {
 932     for (uintptr_t v = _start; v &lt;= (_start + _range); v++ ) {
 933       TestLookup tl(v);
 934       if (v &amp; 0xF) {
 935         cht_get_copy(_cht, this, tl);
 936       } else {
 937         EXPECT_EQ(cht_get_copy(_cht, this, tl), v) &lt;&lt; &quot;Item ending with 0xX0 should never be removed.&quot;;
 938       }
 939     }
 940     return true;
 941   }
 942 
 943   void postmain() {
 944     GI_BD_InserterThread::_shrink = true;
 945     for (uintptr_t v = _start; v &lt;= (_start + _range); v++ ) {
 946       TestLookup tl(v);
 947       if (v &amp; 0xF) {
 948         _cht-&gt;remove(this, tl);
 949       } else {
 950         EXPECT_TRUE(_cht-&gt;remove(this, tl)) &lt;&lt; &quot;Removing item ending with 0xX0 should always work.&quot;;
 951       }
 952     }
 953     for (int i = 0; i &lt; GI_BD_TEST_THREAD_COUNT; i++) {
 954       _done.wait();
 955     }
 956     EXPECT_TRUE(_cht-&gt;get_size_log2(this) == GI_BD_GI_BD_START_SIZE) &lt;&lt; &quot;We have not shrunk back to start size.&quot;;
 957     delete _cht;
 958   }
 959 };
 960 
 961 TEST_VM(ConcurrentHashTable, concurrent_get_insert_bulk_delete) {
 962   GI_BD_InserterThread::_shrink = false;
 963   mt_test_doer&lt;RunnerGI_BD_InserterThread&gt;();
 964 }
 965 
 966 //#############################################################################################
 967 
 968 class MT_BD_Thread : public JavaTestThread {
 969   TestTable::BulkDeleteTask* _bd;
 970   public:
 971   MT_BD_Thread(Semaphore* post, TestTable::BulkDeleteTask* bd)
 972     : JavaTestThread(post), _bd(bd){}
 973   virtual ~MT_BD_Thread() {}
 974   void main_run() {
 975     MyDel del;
 976     while(_bd-&gt;do_task(this, *this, del));
 977   }
 978 
 979   bool operator()(uintptr_t* val) {
 980     return true;
 981   }
 982 
 983   struct MyDel {
 984     void operator()(uintptr_t* val) {
 985     }
 986   };
 987 };
 988 
 989 class Driver_BD_Thread : public JavaTestThread {
 990 public:
 991   Semaphore _done;
 992   Driver_BD_Thread(Semaphore* post) : JavaTestThread(post) {
 993   };
 994   virtual ~Driver_BD_Thread(){}
 995 
 996   void main_run() {
 997     Semaphore done(0);
 998     TestTable* cht = new TestTable(16, 16, 2);
 999     for (uintptr_t v = 1; v &lt; 99999; v++ ) {
1000       TestLookup tl(v);
1001       EXPECT_TRUE(cht-&gt;insert(this, tl, v)) &lt;&lt; &quot;Inserting an unique value should work.&quot;;
1002     }
1003     TestTable::BulkDeleteTask bdt(cht, true /* mt */ );
1004     EXPECT_TRUE(bdt.prepare(this)) &lt;&lt; &quot;Uncontended prepare must work.&quot;;
1005 
1006     MT_BD_Thread* tt[4];
1007     for (int i = 0; i &lt; 4; i++) {
1008       tt[i] = new MT_BD_Thread(&amp;done, &amp;bdt);
1009       tt[i]-&gt;doit();
1010     }
1011 
1012     for (uintptr_t v = 1; v &lt; 99999; v++ ) {
1013       TestLookup tl(v);
1014       cht_get_copy(cht, this, tl);
1015     }
1016 
1017     for (int i = 0; i &lt; 4; i++) {
1018       done.wait();
1019     }
1020 
1021     bdt.done(this);
1022 
1023     cht-&gt;do_scan(this, *this);
1024   }
1025 
1026   bool operator()(uintptr_t* val) {
1027     EXPECT_TRUE(false) &lt;&lt; &quot;No items should left&quot;;
1028     return true;
1029   }
1030 };
1031 
1032 TEST_VM(ConcurrentHashTable, concurrent_mt_bulk_delete) {
1033   mt_test_doer&lt;Driver_BD_Thread&gt;();
1034 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
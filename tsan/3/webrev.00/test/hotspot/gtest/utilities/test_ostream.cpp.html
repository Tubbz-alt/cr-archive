<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/gtest/utilities/test_ostream.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2019 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;memory/resourceArea.hpp&quot;
 28 #include &quot;runtime/os.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 #include &quot;utilities/ostream.hpp&quot;
 31 
 32 #include &quot;unittest.hpp&quot;
 33 
 34 static size_t print_lorem(outputStream* st, bool short_len) {
 35   // Create a ResourceMark just to make sure the stream does not use ResourceArea
 36   ResourceMark rm;
 37   static const char* const lorem = &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, &quot;
 38       &quot;sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Lacinia at quis &quot;
 39       &quot;risus sed vulputate odio ut enim blandit. Amet risus nullam eget felis eget. Viverra &quot;
 40       &quot;orci sagittis eu volutpat odio facilisis mauris sit. Erat velit scelerisque in dictum non.&quot;;
 41   static const size_t len_lorem = strlen(lorem);
 42   size_t len;
 43   if (short_len) {
 44     len = os::random() % 10;
 45   } else {
 46     len = MAX2(1, (int)(os::random() % len_lorem));
 47   }
 48   st-&gt;write(lorem, len);
 49   return len;
 50 }
 51 
 52 static void test_stringStream_is_zero_terminated(const stringStream* ss) {
 53   ASSERT_EQ(ss-&gt;base()[ss-&gt;size()], &#39;\0&#39;);
 54 }
 55 
 56 
 57 static void do_test_stringStream(stringStream* ss, bool short_len, size_t expected_cap) {
 58   test_stringStream_is_zero_terminated(ss);
 59   size_t written = 0;
 60   for (int i = 0; i &lt; 1000; i ++) {
 61     written += print_lorem(ss, short_len);
 62     if (expected_cap &gt; 0 &amp;&amp; written &gt;= expected_cap) {
 63       ASSERT_EQ(ss-&gt;size(), expected_cap - 1);
 64     } else {
 65       ASSERT_EQ(ss-&gt;size(), written);
 66     }
 67     // Internal buffer should always be zero-terminated.
 68     test_stringStream_is_zero_terminated(ss);
 69   }
 70   // Reset should zero terminate too
 71   ss-&gt;reset();
 72   ASSERT_EQ(ss-&gt;size(), (size_t)0);
 73   test_stringStream_is_zero_terminated(ss);
 74 }
 75 
 76 TEST_VM(ostream, stringStream_dynamic_realloc_1) {
 77   stringStream ss(2); // dynamic buffer with very small starting size
 78   do_test_stringStream(&amp;ss, false, 0);
 79 }
 80 
 81 TEST_VM(ostream, stringStream_dynamic_realloc_2) {
 82   stringStream ss(2); // dynamic buffer with very small starting size
 83   do_test_stringStream(&amp;ss, true, 0);
 84 }
 85 
 86 TEST_VM(ostream, stringStream_static) {
 87   char buffer[128 + 1];
 88   char* canary_at = buffer + sizeof(buffer) - 1;
 89   *canary_at = &#39;X&#39;;
 90   size_t stream_buf_size = sizeof(buffer) - 1;
 91   stringStream ss(buffer, stream_buf_size);
 92   do_test_stringStream(&amp;ss, false, stream_buf_size);
 93   ASSERT_EQ(*canary_at, &#39;X&#39;); // canary
 94 }
 95 
 96 TEST_VM(ostream, bufferedStream_static) {
 97   char buf[100 + 1];
 98   char* canary_at = buf + sizeof(buf) - 1;
 99   *canary_at = &#39;X&#39;;
100   size_t stream_buf_size = sizeof(buf) - 1;
101   bufferedStream bs(buf, stream_buf_size);
102   size_t written = 0;
103   for (int i = 0; i &lt; 100; i ++) {
104     written += print_lorem(&amp;bs, true);
105     if (written &lt; stream_buf_size) {
106       ASSERT_EQ(bs.size(), written);
107     } else {
108       ASSERT_EQ(bs.size(), stream_buf_size - 1);
109     }
110   }
111   ASSERT_EQ(*canary_at, &#39;X&#39;); // canary
112 }
113 
114 TEST_VM(ostream, bufferedStream_dynamic_small) {
115   bufferedStream bs(1); // small to excercise realloc.
116   size_t written = 0;
117   // The max cap imposed is 100M, we should be safely below this in this test.
118   for (int i = 0; i &lt; 10; i ++) {
119     written += print_lorem(&amp;bs, true);
120     ASSERT_EQ(bs.size(), written);
121   }
122 }
123 
124 /* Activate to manually test bufferedStream dynamic cap.
125 
126 TEST_VM(ostream, bufferedStream_dynamic_large) {
127   bufferedStream bs(1); // small to excercise realloc.
128   size_t written = 0;
129   // The max cap imposed is 100M. Writing this much should safely hit it.
130   // Note that this will assert in debug builds which is the expected behavior.
131   size_t expected_cap_at = 100 * M;
132   for (int i = 0; i &lt; 10000000; i ++) {
133     written += print_lorem(&amp;bs, false);
134     if (written &lt; expected_cap_at) {
135       ASSERT_EQ(bs.size(), written);
136     } else {
137       ASSERT_EQ(bs.size(), expected_cap_at - 1);
138     }
139   }
140 }
141 
142 */
143 
144 
145 
146 
    </pre>
  </body>
</html>
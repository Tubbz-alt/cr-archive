<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/gtest/utilities/test_concurrentHashtable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="test_bitMap_setops.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="test_count_leading_zeros.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/gtest/utilities/test_concurrentHashtable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;runtime/mutex.hpp&quot;
  26 #include &quot;runtime/semaphore.hpp&quot;
  27 #include &quot;runtime/thread.hpp&quot;
  28 #include &quot;runtime/vmThread.hpp&quot;
  29 #include &quot;runtime/vmOperations.hpp&quot;
  30 #include &quot;utilities/concurrentHashTable.inline.hpp&quot;
  31 #include &quot;utilities/concurrentHashTableTasks.inline.hpp&quot;
  32 #include &quot;threadHelper.inline.hpp&quot;
  33 #include &quot;unittest.hpp&quot;
  34 
  35 // NOTE: On win32 gtest asserts are not mt-safe.
  36 // Amusingly as long as they do not assert they are mt-safe.
  37 #define SIZE_32 5
  38 
<span class="line-modified">  39 struct Pointer;</span>
<span class="line-modified">  40 </span>
<span class="line-modified">  41 typedef ConcurrentHashTable&lt;uintptr_t, Pointer, mtInternal&gt; SimpleTestTable;</span>
<span class="line-removed">  42 typedef ConcurrentHashTable&lt;uintptr_t, Pointer, mtInternal&gt;::MultiGetHandle SimpleTestGetHandle;</span>
<span class="line-removed">  43 </span>
<span class="line-removed">  44 // Simplest working CRPT implementation for the hash-table.</span>
<span class="line-removed">  45 struct Pointer : public SimpleTestTable::BaseConfig {</span>
<span class="line-removed">  46   static uintx get_hash(const uintptr_t&amp; value, bool* dead_hash) {</span>
  47     return (uintx)value;
  48   }
<span class="line-modified">  49   static void* allocate_node(size_t size, const uintptr_t&amp; value) {</span>
  50     return ::malloc(size);
  51   }
<span class="line-modified">  52   static void free_node(void* memory, const uintptr_t&amp; value) {</span>
  53     ::free(memory);
  54   }
  55 };
  56 



  57 struct SimpleTestLookup {
  58   uintptr_t _val;
  59   SimpleTestLookup(uintptr_t val) : _val(val) {}
  60   uintx get_hash() {
  61     return Pointer::get_hash(_val, NULL);
  62   }
  63   bool equals(const uintptr_t* value, bool* is_dead) {
  64     return _val == *value;
  65   }
  66 };
  67 
  68 struct ValueGet {
  69   uintptr_t _return;
  70   ValueGet() : _return(0) {}
  71   void operator()(uintptr_t* value) {
  72     EXPECT_NE(value, (uintptr_t*)NULL) &lt;&lt; &quot;expected valid value&quot;;
  73     _return = *value;
  74   }
  75   uintptr_t get_value() const {
  76     return _return;
</pre>
<hr />
<pre>
 397 }
 398 
 399 TEST_VM(ConcurrentHashTable, basic_scan) {
 400   nomt_test_doer(cht_scan);
 401 }
 402 
 403 TEST_VM(ConcurrentHashTable, basic_move_to) {
 404   nomt_test_doer(cht_move_to);
 405 }
 406 
 407 TEST_VM(ConcurrentHashTable, basic_grow) {
 408   nomt_test_doer(cht_grow);
 409 }
 410 
 411 TEST_VM(ConcurrentHashTable, task_grow) {
 412   nomt_test_doer(cht_task_grow);
 413 }
 414 
 415 //#############################################################################################
 416 
<span class="line-modified"> 417 class TestInterface;</span>
<span class="line-removed"> 418 </span>
<span class="line-removed"> 419 typedef ConcurrentHashTable&lt;uintptr_t, TestInterface, mtInternal&gt; TestTable;</span>
<span class="line-removed"> 420 typedef ConcurrentHashTable&lt;uintptr_t, TestInterface, mtInternal&gt;::MultiGetHandle TestGetHandle;</span>
<span class="line-removed"> 421 </span>
<span class="line-removed"> 422 class TestInterface : public TestTable::BaseConfig {</span>
 423 public:
<span class="line-modified"> 424   static uintx get_hash(const uintptr_t&amp; value, bool* dead_hash) {</span>

 425     return (uintx)(value + 18446744073709551557ul) * 18446744073709551557ul;
 426   }






 427 };
 428 



 429 struct TestLookup {
 430   uintptr_t _val;
 431   TestLookup(uintptr_t val) : _val(val) {}
 432   uintx get_hash() {
 433     return TestInterface::get_hash(_val, NULL);
 434   }
 435   bool equals(const uintptr_t* value, bool* is_dead) {
 436     return _val == *value;
 437   }
 438 };
 439 
 440 static uintptr_t cht_get_copy(TestTable* cht, Thread* thr, TestLookup tl) {
 441   ValueGet vg;
 442   cht-&gt;get(thr, tl, vg);
 443   return vg.get_value();
 444 }
 445 
 446 class CHTTestThread : public JavaTestThread {
 447   public:
 448   uintptr_t _start;
</pre>
</td>
<td>
<hr />
<pre>
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;runtime/mutex.hpp&quot;
  26 #include &quot;runtime/semaphore.hpp&quot;
  27 #include &quot;runtime/thread.hpp&quot;
  28 #include &quot;runtime/vmThread.hpp&quot;
  29 #include &quot;runtime/vmOperations.hpp&quot;
  30 #include &quot;utilities/concurrentHashTable.inline.hpp&quot;
  31 #include &quot;utilities/concurrentHashTableTasks.inline.hpp&quot;
  32 #include &quot;threadHelper.inline.hpp&quot;
  33 #include &quot;unittest.hpp&quot;
  34 
  35 // NOTE: On win32 gtest asserts are not mt-safe.
  36 // Amusingly as long as they do not assert they are mt-safe.
  37 #define SIZE_32 5
  38 
<span class="line-modified">  39 struct Pointer : public AllStatic {</span>
<span class="line-modified">  40   typedef uintptr_t Value;</span>
<span class="line-modified">  41   static uintx get_hash(const Value&amp; value, bool* dead_hash) {</span>





  42     return (uintx)value;
  43   }
<span class="line-modified">  44   static void* allocate_node(size_t size, const Value&amp; value) {</span>
  45     return ::malloc(size);
  46   }
<span class="line-modified">  47   static void free_node(void* memory, const Value&amp; value) {</span>
  48     ::free(memory);
  49   }
  50 };
  51 
<span class="line-added">  52 typedef ConcurrentHashTable&lt;Pointer, mtInternal&gt; SimpleTestTable;</span>
<span class="line-added">  53 typedef ConcurrentHashTable&lt;Pointer, mtInternal&gt;::MultiGetHandle SimpleTestGetHandle;</span>
<span class="line-added">  54 </span>
  55 struct SimpleTestLookup {
  56   uintptr_t _val;
  57   SimpleTestLookup(uintptr_t val) : _val(val) {}
  58   uintx get_hash() {
  59     return Pointer::get_hash(_val, NULL);
  60   }
  61   bool equals(const uintptr_t* value, bool* is_dead) {
  62     return _val == *value;
  63   }
  64 };
  65 
  66 struct ValueGet {
  67   uintptr_t _return;
  68   ValueGet() : _return(0) {}
  69   void operator()(uintptr_t* value) {
  70     EXPECT_NE(value, (uintptr_t*)NULL) &lt;&lt; &quot;expected valid value&quot;;
  71     _return = *value;
  72   }
  73   uintptr_t get_value() const {
  74     return _return;
</pre>
<hr />
<pre>
 395 }
 396 
 397 TEST_VM(ConcurrentHashTable, basic_scan) {
 398   nomt_test_doer(cht_scan);
 399 }
 400 
 401 TEST_VM(ConcurrentHashTable, basic_move_to) {
 402   nomt_test_doer(cht_move_to);
 403 }
 404 
 405 TEST_VM(ConcurrentHashTable, basic_grow) {
 406   nomt_test_doer(cht_grow);
 407 }
 408 
 409 TEST_VM(ConcurrentHashTable, task_grow) {
 410   nomt_test_doer(cht_task_grow);
 411 }
 412 
 413 //#############################################################################################
 414 
<span class="line-modified"> 415 class TestInterface : public AllStatic {</span>





 416 public:
<span class="line-modified"> 417   typedef uintptr_t Value;</span>
<span class="line-added"> 418   static uintx get_hash(const Value&amp; value, bool* dead_hash) {</span>
 419     return (uintx)(value + 18446744073709551557ul) * 18446744073709551557ul;
 420   }
<span class="line-added"> 421   static void* allocate_node(size_t size, const Value&amp; value) {</span>
<span class="line-added"> 422     return AllocateHeap(size, mtInternal);</span>
<span class="line-added"> 423   }</span>
<span class="line-added"> 424   static void free_node(void* memory, const Value&amp; value) {</span>
<span class="line-added"> 425     FreeHeap(memory);</span>
<span class="line-added"> 426   }</span>
 427 };
 428 
<span class="line-added"> 429 typedef ConcurrentHashTable&lt;TestInterface, mtInternal&gt; TestTable;</span>
<span class="line-added"> 430 typedef ConcurrentHashTable&lt;TestInterface, mtInternal&gt;::MultiGetHandle TestGetHandle;</span>
<span class="line-added"> 431 </span>
 432 struct TestLookup {
 433   uintptr_t _val;
 434   TestLookup(uintptr_t val) : _val(val) {}
 435   uintx get_hash() {
 436     return TestInterface::get_hash(_val, NULL);
 437   }
 438   bool equals(const uintptr_t* value, bool* is_dead) {
 439     return _val == *value;
 440   }
 441 };
 442 
 443 static uintptr_t cht_get_copy(TestTable* cht, Thread* thr, TestLookup tl) {
 444   ValueGet vg;
 445   cht-&gt;get(thr, tl, vg);
 446   return vg.get_value();
 447 }
 448 
 449 class CHTTestThread : public JavaTestThread {
 450   public:
 451   uintptr_t _start;
</pre>
</td>
</tr>
</table>
<center><a href="test_bitMap_setops.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="test_count_leading_zeros.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
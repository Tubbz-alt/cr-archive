diff a/test/hotspot/gtest/utilities/test_globalCounter.cpp b/test/hotspot/gtest/utilities/test_globalCounter.cpp
--- a/test/hotspot/gtest/utilities/test_globalCounter.cpp
+++ b/test/hotspot/gtest/utilities/test_globalCounter.cpp
@@ -21,11 +21,10 @@
  * questions.
  */
 
 #include "precompiled.hpp"
 #include "runtime/atomic.hpp"
-#include "runtime/orderAccess.hpp"
 #include "runtime/os.hpp"
 #include "utilities/globalCounter.hpp"
 #include "utilities/globalCounter.inline.hpp"
 #include "threadHelper.inline.hpp"
 
@@ -46,18 +45,18 @@
   virtual ~RCUReaderThread(){}
   void main_run() {
     _wrt_start->signal();
     while (!_exit) {
       GlobalCounter::CSContext cs_context = GlobalCounter::critical_section_begin(this);
-      volatile TestData* test = OrderAccess::load_acquire(_test);
-      long value = OrderAccess::load_acquire(&test->test_value);
+      volatile TestData* test = Atomic::load_acquire(_test);
+      long value = Atomic::load_acquire(&test->test_value);
       ASSERT_EQ(value, GOOD_VALUE);
       GlobalCounter::critical_section_end(this, cs_context);
       {
         GlobalCounter::CriticalSection cs(this);
-        volatile TestData* test = OrderAccess::load_acquire(_test);
-        long value = OrderAccess::load_acquire(&test->test_value);
+        volatile TestData* test = Atomic::load_acquire(_test);
+        long value = Atomic::load_acquire(&test->test_value);
         ASSERT_EQ(value, GOOD_VALUE);
       }
     }
   }
 };
@@ -80,11 +79,11 @@
     RCUReaderThread* reader3 = new RCUReaderThread(&post, &test, &wrt_start);
     RCUReaderThread* reader4 = new RCUReaderThread(&post, &test, &wrt_start);
 
     TestData* tmp = new TestData();
     tmp->test_value = GOOD_VALUE;
-    OrderAccess::release_store_fence(&test, tmp);
+    Atomic::release_store_fence(&test, tmp);
 
     reader1->doit();
     reader2->doit();
     reader3->doit();
     reader4->doit();
@@ -97,11 +96,11 @@
     jlong stop_ms = os::javaTimeMillis() + 1000; // 1 seconds max test time
     for (int i = 0; i < 100000 && stop_ms > os::javaTimeMillis(); i++) {
       volatile TestData* free_tmp = test;
       tmp = new TestData();
       tmp->test_value = GOOD_VALUE;
-      OrderAccess::release_store(&test, tmp);
+      Atomic::release_store(&test, tmp);
       GlobalCounter::write_synchronize();
       free_tmp->test_value = BAD_VALUE;
       delete free_tmp;
     }
     RCUReaderThread::_exit = true;

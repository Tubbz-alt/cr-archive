<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/hotspot/gtest/utilities/test_concurrentHashtable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="test_bitMap_setops.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="test_count_leading_zeros.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/gtest/utilities/test_concurrentHashtable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,28 ***</span>
  
  // NOTE: On win32 gtest asserts are not mt-safe.
  // Amusingly as long as they do not assert they are mt-safe.
  #define SIZE_32 5
  
<span class="line-modified">! struct Pointer;</span>
<span class="line-modified">! </span>
<span class="line-modified">! typedef ConcurrentHashTable&lt;uintptr_t, Pointer, mtInternal&gt; SimpleTestTable;</span>
<span class="line-removed">- typedef ConcurrentHashTable&lt;uintptr_t, Pointer, mtInternal&gt;::MultiGetHandle SimpleTestGetHandle;</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Simplest working CRPT implementation for the hash-table.</span>
<span class="line-removed">- struct Pointer : public SimpleTestTable::BaseConfig {</span>
<span class="line-removed">-   static uintx get_hash(const uintptr_t&amp; value, bool* dead_hash) {</span>
      return (uintx)value;
    }
<span class="line-modified">!   static void* allocate_node(size_t size, const uintptr_t&amp; value) {</span>
      return ::malloc(size);
    }
<span class="line-modified">!   static void free_node(void* memory, const uintptr_t&amp; value) {</span>
      ::free(memory);
    }
  };
  
  struct SimpleTestLookup {
    uintptr_t _val;
    SimpleTestLookup(uintptr_t val) : _val(val) {}
    uintx get_hash() {
      return Pointer::get_hash(_val, NULL);
<span class="line-new-header">--- 34,26 ---</span>
  
  // NOTE: On win32 gtest asserts are not mt-safe.
  // Amusingly as long as they do not assert they are mt-safe.
  #define SIZE_32 5
  
<span class="line-modified">! struct Pointer : public AllStatic {</span>
<span class="line-modified">!   typedef uintptr_t Value;</span>
<span class="line-modified">!   static uintx get_hash(const Value&amp; value, bool* dead_hash) {</span>
      return (uintx)value;
    }
<span class="line-modified">!   static void* allocate_node(size_t size, const Value&amp; value) {</span>
      return ::malloc(size);
    }
<span class="line-modified">!   static void free_node(void* memory, const Value&amp; value) {</span>
      ::free(memory);
    }
  };
  
<span class="line-added">+ typedef ConcurrentHashTable&lt;Pointer, mtInternal&gt; SimpleTestTable;</span>
<span class="line-added">+ typedef ConcurrentHashTable&lt;Pointer, mtInternal&gt;::MultiGetHandle SimpleTestGetHandle;</span>
<span class="line-added">+ </span>
  struct SimpleTestLookup {
    uintptr_t _val;
    SimpleTestLookup(uintptr_t val) : _val(val) {}
    uintx get_hash() {
      return Pointer::get_hash(_val, NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 412,22 ***</span>
    nomt_test_doer(cht_task_grow);
  }
  
  //#############################################################################################
  
<span class="line-modified">! class TestInterface;</span>
<span class="line-removed">- </span>
<span class="line-removed">- typedef ConcurrentHashTable&lt;uintptr_t, TestInterface, mtInternal&gt; TestTable;</span>
<span class="line-removed">- typedef ConcurrentHashTable&lt;uintptr_t, TestInterface, mtInternal&gt;::MultiGetHandle TestGetHandle;</span>
<span class="line-removed">- </span>
<span class="line-removed">- class TestInterface : public TestTable::BaseConfig {</span>
  public:
<span class="line-modified">!   static uintx get_hash(const uintptr_t&amp; value, bool* dead_hash) {</span>
      return (uintx)(value + 18446744073709551557ul) * 18446744073709551557ul;
    }
  };
  
  struct TestLookup {
    uintptr_t _val;
    TestLookup(uintptr_t val) : _val(val) {}
    uintx get_hash() {
      return TestInterface::get_hash(_val, NULL);
<span class="line-new-header">--- 410,27 ---</span>
    nomt_test_doer(cht_task_grow);
  }
  
  //#############################################################################################
  
<span class="line-modified">! class TestInterface : public AllStatic {</span>
  public:
<span class="line-modified">!   typedef uintptr_t Value;</span>
<span class="line-added">+   static uintx get_hash(const Value&amp; value, bool* dead_hash) {</span>
      return (uintx)(value + 18446744073709551557ul) * 18446744073709551557ul;
    }
<span class="line-added">+   static void* allocate_node(size_t size, const Value&amp; value) {</span>
<span class="line-added">+     return AllocateHeap(size, mtInternal);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   static void free_node(void* memory, const Value&amp; value) {</span>
<span class="line-added">+     FreeHeap(memory);</span>
<span class="line-added">+   }</span>
  };
  
<span class="line-added">+ typedef ConcurrentHashTable&lt;TestInterface, mtInternal&gt; TestTable;</span>
<span class="line-added">+ typedef ConcurrentHashTable&lt;TestInterface, mtInternal&gt;::MultiGetHandle TestGetHandle;</span>
<span class="line-added">+ </span>
  struct TestLookup {
    uintptr_t _val;
    TestLookup(uintptr_t val) : _val(val) {}
    uintx get_hash() {
      return TestInterface::get_hash(_val, NULL);
</pre>
<center><a href="test_bitMap_setops.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="test_count_leading_zeros.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/gtest/utilities/test_concurrentHashtable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;runtime/mutex.hpp&quot;
  26 #include &quot;runtime/semaphore.hpp&quot;
  27 #include &quot;runtime/thread.hpp&quot;
  28 #include &quot;runtime/vmThread.hpp&quot;
  29 #include &quot;runtime/vmOperations.hpp&quot;
  30 #include &quot;utilities/concurrentHashTable.inline.hpp&quot;
  31 #include &quot;utilities/concurrentHashTableTasks.inline.hpp&quot;
  32 #include &quot;threadHelper.inline.hpp&quot;
  33 #include &quot;unittest.hpp&quot;
  34 
  35 // NOTE: On win32 gtest asserts are not mt-safe.
  36 // Amusingly as long as they do not assert they are mt-safe.
  37 #define SIZE_32 5
  38 
<a name="1" id="anc1"></a><span class="line-modified">  39 struct Pointer;</span>
<span class="line-modified">  40 </span>
<span class="line-modified">  41 typedef ConcurrentHashTable&lt;uintptr_t, Pointer, mtInternal&gt; SimpleTestTable;</span>
<span class="line-removed">  42 typedef ConcurrentHashTable&lt;uintptr_t, Pointer, mtInternal&gt;::MultiGetHandle SimpleTestGetHandle;</span>
<span class="line-removed">  43 </span>
<span class="line-removed">  44 // Simplest working CRPT implementation for the hash-table.</span>
<span class="line-removed">  45 struct Pointer : public SimpleTestTable::BaseConfig {</span>
<span class="line-removed">  46   static uintx get_hash(const uintptr_t&amp; value, bool* dead_hash) {</span>
  47     return (uintx)value;
  48   }
<a name="2" id="anc2"></a><span class="line-modified">  49   static void* allocate_node(size_t size, const uintptr_t&amp; value) {</span>
  50     return ::malloc(size);
  51   }
<a name="3" id="anc3"></a><span class="line-modified">  52   static void free_node(void* memory, const uintptr_t&amp; value) {</span>
  53     ::free(memory);
  54   }
  55 };
  56 
<a name="4" id="anc4"></a>


  57 struct SimpleTestLookup {
  58   uintptr_t _val;
  59   SimpleTestLookup(uintptr_t val) : _val(val) {}
  60   uintx get_hash() {
  61     return Pointer::get_hash(_val, NULL);
  62   }
  63   bool equals(const uintptr_t* value, bool* is_dead) {
  64     return _val == *value;
  65   }
  66 };
  67 
  68 struct ValueGet {
  69   uintptr_t _return;
  70   ValueGet() : _return(0) {}
  71   void operator()(uintptr_t* value) {
  72     EXPECT_NE(value, (uintptr_t*)NULL) &lt;&lt; &quot;expected valid value&quot;;
  73     _return = *value;
  74   }
  75   uintptr_t get_value() const {
  76     return _return;
  77   }
  78 };
  79 
  80 static uintptr_t cht_get_copy(SimpleTestTable* cht, Thread* thr, SimpleTestLookup stl) {
  81   ValueGet vg;
  82   cht-&gt;get(thr, stl, vg);
  83   return vg.get_value();
  84 }
  85 
  86 static void cht_find(Thread* thr, SimpleTestTable* cht, uintptr_t val) {
  87   SimpleTestLookup stl(val);
  88   ValueGet vg;
  89   EXPECT_EQ(cht-&gt;get(thr, stl, vg), true) &lt;&lt; &quot;Getting an old value failed.&quot;;
  90   EXPECT_EQ(val, vg.get_value()) &lt;&lt; &quot;Getting an old value failed.&quot;;
  91 }
  92 
  93 static void cht_insert_and_find(Thread* thr, SimpleTestTable* cht, uintptr_t val) {
  94   SimpleTestLookup stl(val);
  95   EXPECT_EQ(cht-&gt;insert(thr, stl, val), true) &lt;&lt; &quot;Inserting an unique value failed.&quot;;
  96   cht_find(thr, cht, val);
  97 }
  98 
  99 static void cht_insert(Thread* thr) {
 100   uintptr_t val = 0x2;
 101   SimpleTestLookup stl(val);
 102   SimpleTestTable* cht = new SimpleTestTable();
 103   EXPECT_TRUE(cht-&gt;insert(thr, stl, val)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 104   EXPECT_EQ(cht_get_copy(cht, thr, stl), val) &lt;&lt; &quot;Getting an existing value failed.&quot;;
 105   EXPECT_TRUE(cht-&gt;remove(thr, stl)) &lt;&lt; &quot;Removing an existing value failed.&quot;;
 106   EXPECT_FALSE(cht-&gt;remove(thr, stl)) &lt;&lt; &quot;Removing an already removed item succeeded.&quot;;
 107   EXPECT_NE(cht_get_copy(cht, thr, stl), val) &lt;&lt; &quot;Getting a removed value succeeded.&quot;;
 108   delete cht;
 109 }
 110 
 111 static void cht_get_insert(Thread* thr) {
 112   uintptr_t val = 0x2;
 113   SimpleTestLookup stl(val);
 114   SimpleTestTable* cht = new SimpleTestTable();
 115 
 116   {
 117     SCOPED_TRACE(&quot;First&quot;);
 118     cht_insert_and_find(thr, cht, val);
 119   }
 120   EXPECT_EQ(cht_get_copy(cht, thr, stl), val) &lt;&lt; &quot;Get an old value failed&quot;;
 121   EXPECT_TRUE(cht-&gt;remove(thr, stl)) &lt;&lt; &quot;Removing existing value failed.&quot;;
 122   EXPECT_NE(cht_get_copy(cht, thr, stl), val) &lt;&lt; &quot;Got an already removed item.&quot;;
 123 
 124   {
 125     SCOPED_TRACE(&quot;Second&quot;);
 126     cht_insert_and_find(thr, cht, val);
 127   }
 128 
 129   delete cht;
 130 }
 131 
 132 static bool getinsert_bulkdelete_eval(uintptr_t* val) {
 133   EXPECT_TRUE(*val &gt; 0 &amp;&amp; *val &lt; 4) &lt;&lt; &quot;Val wrong for this test.&quot;;
 134   return (*val &amp; 0x1); // Delete all values ending with first bit set.
 135 }
 136 
 137 static void getinsert_bulkdelete_del(uintptr_t* val) {
 138   EXPECT_EQ(*val &amp; 0x1, (uintptr_t)1) &lt;&lt; &quot;Deleting wrong value.&quot;;
 139 }
 140 
 141 static void cht_getinsert_bulkdelete_insert_verified(Thread* thr, SimpleTestTable* cht, uintptr_t val,
 142                                                      bool verify_expect_get, bool verify_expect_inserted) {
 143   SimpleTestLookup stl(val);
 144   if (verify_expect_inserted) {
 145     cht_insert_and_find(thr, cht, val);
 146   }
 147   if (verify_expect_get) {
 148     cht_find(thr, cht, val);
 149   }
 150 }
 151 
 152 static void cht_getinsert_bulkdelete(Thread* thr) {
 153   uintptr_t val1 = 1;
 154   uintptr_t val2 = 2;
 155   uintptr_t val3 = 3;
 156   SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);
 157 
 158   SimpleTestTable* cht = new SimpleTestTable();
 159   cht_getinsert_bulkdelete_insert_verified(thr, cht, val1, false, true);
 160   cht_getinsert_bulkdelete_insert_verified(thr, cht, val2, false, true);
 161   cht_getinsert_bulkdelete_insert_verified(thr, cht, val3, false, true);
 162 
 163   EXPECT_TRUE(cht-&gt;remove(thr, stl2)) &lt;&lt; &quot;Remove did not find value.&quot;;
 164 
 165   cht_getinsert_bulkdelete_insert_verified(thr, cht, val1, true, false); // val1 should be present
 166   cht_getinsert_bulkdelete_insert_verified(thr, cht, val2, false, true); // val2 should be inserted
 167   cht_getinsert_bulkdelete_insert_verified(thr, cht, val3, true, false); // val3 should be present
 168 
 169   EXPECT_EQ(cht_get_copy(cht, thr, stl1), val1) &lt;&lt; &quot;Get did not find value.&quot;;
 170   EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) &lt;&lt; &quot;Get did not find value.&quot;;
 171   EXPECT_EQ(cht_get_copy(cht, thr, stl3), val3) &lt;&lt; &quot;Get did not find value.&quot;;
 172 
 173   // Removes all odd values.
 174   cht-&gt;bulk_delete(thr, getinsert_bulkdelete_eval, getinsert_bulkdelete_del);
 175 
 176   EXPECT_EQ(cht_get_copy(cht, thr, stl1), (uintptr_t)0) &lt;&lt; &quot;Odd value should not exist.&quot;;
 177   EXPECT_FALSE(cht-&gt;remove(thr, stl1)) &lt;&lt; &quot;Odd value should not exist.&quot;;
 178   EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) &lt;&lt; &quot;Even value should not have been removed.&quot;;
 179   EXPECT_EQ(cht_get_copy(cht, thr, stl3), (uintptr_t)0) &lt;&lt; &quot;Add value should not exists.&quot;;
 180   EXPECT_FALSE(cht-&gt;remove(thr, stl3)) &lt;&lt; &quot;Odd value should not exists.&quot;;
 181 
 182   delete cht;
 183 }
 184 
 185 static void cht_getinsert_bulkdelete_task(Thread* thr) {
 186   uintptr_t val1 = 1;
 187   uintptr_t val2 = 2;
 188   uintptr_t val3 = 3;
 189   SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);
 190 
 191   SimpleTestTable* cht = new SimpleTestTable();
 192   cht_getinsert_bulkdelete_insert_verified(thr, cht, val1, false, true);
 193   cht_getinsert_bulkdelete_insert_verified(thr, cht, val2, false, true);
 194   cht_getinsert_bulkdelete_insert_verified(thr, cht, val3, false, true);
 195 
 196   EXPECT_TRUE(cht-&gt;remove(thr, stl2)) &lt;&lt; &quot;Remove did not find value.&quot;;
 197 
 198   cht_getinsert_bulkdelete_insert_verified(thr, cht, val1, true, false); // val1 should be present
 199   cht_getinsert_bulkdelete_insert_verified(thr, cht, val2, false, true); // val2 should be inserted
 200   cht_getinsert_bulkdelete_insert_verified(thr, cht, val3, true, false); // val3 should be present
 201 
 202   EXPECT_EQ(cht_get_copy(cht, thr, stl1), val1) &lt;&lt; &quot;Get did not find value.&quot;;
 203   EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) &lt;&lt; &quot;Get did not find value.&quot;;
 204   EXPECT_EQ(cht_get_copy(cht, thr, stl3), val3) &lt;&lt; &quot;Get did not find value.&quot;;
 205 
 206   // Removes all odd values.
 207   SimpleTestTable::BulkDeleteTask bdt(cht);
 208   if (bdt.prepare(thr)) {
 209     while(bdt.do_task(thr, getinsert_bulkdelete_eval, getinsert_bulkdelete_del)) {
 210       bdt.pause(thr);
 211       bdt.cont(thr);
 212     }
 213     bdt.done(thr);
 214   }
 215 
 216   EXPECT_EQ(cht_get_copy(cht, thr, stl1), (uintptr_t)0) &lt;&lt; &quot;Odd value should not exist.&quot;;
 217   EXPECT_FALSE(cht-&gt;remove(thr, stl1)) &lt;&lt; &quot;Odd value should not exist.&quot;;
 218   EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) &lt;&lt; &quot;Even value should not have been removed.&quot;;
 219   EXPECT_EQ(cht_get_copy(cht, thr, stl3), (uintptr_t)0) &lt;&lt; &quot;Add value should not exists.&quot;;
 220   EXPECT_FALSE(cht-&gt;remove(thr, stl3)) &lt;&lt; &quot;Odd value should not exists.&quot;;
 221 
 222   delete cht;
 223 }
 224 
 225 static void cht_scope(Thread* thr) {
 226   uintptr_t val = 0x2;
 227   SimpleTestLookup stl(val);
 228   SimpleTestTable* cht = new SimpleTestTable();
 229   EXPECT_TRUE(cht-&gt;insert(thr, stl, val)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 230   {
 231     SimpleTestGetHandle get_handle(thr, cht);
 232     EXPECT_EQ(*get_handle.get(stl), val) &lt;&lt; &quot;Getting a pre-existing value failed.&quot;;
 233   }
 234   // We do remove here to make sure the value-handle &#39;unlocked&#39; the table when leaving the scope.
 235   EXPECT_TRUE(cht-&gt;remove(thr, stl)) &lt;&lt; &quot;Removing a pre-existing value failed.&quot;;
 236   EXPECT_FALSE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Got a removed value.&quot;;
 237   delete cht;
 238 }
 239 
 240 struct ChtScan {
 241   size_t _count;
 242   ChtScan() : _count(0) {}
 243   bool operator()(uintptr_t* val) {
 244     EXPECT_EQ(*val, (uintptr_t)0x2) &lt;&lt; &quot;Got an unknown value.&quot;;
 245     EXPECT_EQ(_count, 0u) &lt;&lt; &quot;Only one value should be in table.&quot;;
 246     _count++;
 247     return true; /* continue scan */
 248   }
 249 };
 250 
 251 static void cht_scan(Thread* thr) {
 252   uintptr_t val = 0x2;
 253   SimpleTestLookup stl(val);
 254   ChtScan scan;
 255   SimpleTestTable* cht = new SimpleTestTable();
 256   EXPECT_TRUE(cht-&gt;insert(thr, stl, val)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 257   EXPECT_EQ(cht-&gt;try_scan(thr, scan), true) &lt;&lt; &quot;Scanning an non-growing/shrinking table should work.&quot;;
 258   EXPECT_TRUE(cht-&gt;remove(thr, stl)) &lt;&lt; &quot;Removing a pre-existing value failed.&quot;;
 259   EXPECT_FALSE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Got a removed value.&quot;;
 260   delete cht;
 261 }
 262 
 263 struct ChtCountScan {
 264   size_t _count;
 265   ChtCountScan() : _count(0) {}
 266   bool operator()(uintptr_t* val) {
 267     _count++;
 268     return true; /* continue scan */
 269   }
 270 };
 271 
 272 static void cht_move_to(Thread* thr) {
 273   uintptr_t val1 = 0x2;
 274   uintptr_t val2 = 0xe0000002;
 275   uintptr_t val3 = 0x3;
 276   SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);
 277   SimpleTestTable* from_cht = new SimpleTestTable();
 278   EXPECT_TRUE(from_cht-&gt;insert(thr, stl1, val1)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 279   EXPECT_TRUE(from_cht-&gt;insert(thr, stl2, val2)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 280   EXPECT_TRUE(from_cht-&gt;insert(thr, stl3, val3)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 281 
 282   SimpleTestTable* to_cht = new SimpleTestTable();
 283   EXPECT_TRUE(from_cht-&gt;try_move_nodes_to(thr, to_cht)) &lt;&lt; &quot;Moving nodes to new table failed&quot;;
 284 
 285   ChtCountScan scan_old;
 286   EXPECT_TRUE(from_cht-&gt;try_scan(thr, scan_old)) &lt;&lt; &quot;Scanning table should work.&quot;;
 287   EXPECT_EQ(scan_old._count, (size_t)0) &lt;&lt; &quot;All items should be moved&quot;;
 288 
 289   ChtCountScan scan_new;
 290   EXPECT_TRUE(to_cht-&gt;try_scan(thr, scan_new)) &lt;&lt; &quot;Scanning table should work.&quot;;
 291   EXPECT_EQ(scan_new._count, (size_t)3) &lt;&lt; &quot;All items should be moved&quot;;
 292   EXPECT_TRUE(cht_get_copy(to_cht, thr, stl1) == val1) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 293   EXPECT_TRUE(cht_get_copy(to_cht, thr, stl2) == val2) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 294   EXPECT_TRUE(cht_get_copy(to_cht, thr, stl3) == val3) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 295 }
 296 
 297 static void cht_grow(Thread* thr) {
 298   uintptr_t val = 0x2;
 299   uintptr_t val2 = 0x22;
 300   uintptr_t val3 = 0x222;
 301   SimpleTestLookup stl(val), stl2(val2), stl3(val3);
 302   SimpleTestTable* cht = new SimpleTestTable();
 303 
 304   EXPECT_TRUE(cht-&gt;insert(thr, stl, val)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 305   EXPECT_TRUE(cht-&gt;insert(thr, stl2, val2)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 306   EXPECT_TRUE(cht-&gt;insert(thr, stl3, val3)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 307   EXPECT_FALSE(cht-&gt;insert(thr, stl3, val3)) &lt;&lt; &quot;Insert duplicate value should have failed.&quot;;
 308   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 309   EXPECT_TRUE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 310   EXPECT_TRUE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 311 
 312   EXPECT_TRUE(cht-&gt;remove(thr, stl2)) &lt;&lt; &quot;Removing an inserted value should work.&quot;;
 313 
 314   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 315   EXPECT_FALSE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting a removed value should have failed.&quot;;
 316   EXPECT_TRUE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 317 
 318 
 319   EXPECT_TRUE(cht-&gt;grow(thr)) &lt;&lt; &quot;Growing uncontended should not fail.&quot;;
 320 
 321   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an item after grow failed.&quot;;
 322   EXPECT_FALSE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting a removed value after grow should have failed.&quot;;
 323   EXPECT_TRUE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting an item after grow failed.&quot;;
 324 
 325   EXPECT_TRUE(cht-&gt;insert(thr, stl2, val2)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 326   EXPECT_TRUE(cht-&gt;remove(thr, stl3)) &lt;&lt; &quot;Removing an inserted value should work.&quot;;
 327 
 328   EXPECT_TRUE(cht-&gt;shrink(thr)) &lt;&lt; &quot;Shrinking uncontended should not fail.&quot;;
 329 
 330   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an item after shrink failed.&quot;;
 331   EXPECT_TRUE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting an item after shrink failed.&quot;;
 332   EXPECT_FALSE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting a removed value after shrink should have failed.&quot;;
 333 
 334   delete cht;
 335 }
 336 
 337 static void cht_task_grow(Thread* thr) {
 338   uintptr_t val = 0x2;
 339   uintptr_t val2 = 0x22;
 340   uintptr_t val3 = 0x222;
 341   SimpleTestLookup stl(val), stl2(val2), stl3(val3);
 342   SimpleTestTable* cht = new SimpleTestTable();
 343 
 344   EXPECT_TRUE(cht-&gt;insert(thr, stl, val)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 345   EXPECT_TRUE(cht-&gt;insert(thr, stl2, val2)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 346   EXPECT_TRUE(cht-&gt;insert(thr, stl3, val3)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 347   EXPECT_FALSE(cht-&gt;insert(thr, stl3, val3)) &lt;&lt; &quot;Insert duplicate value should have failed.&quot;;
 348   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 349   EXPECT_TRUE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 350   EXPECT_TRUE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 351 
 352   EXPECT_TRUE(cht-&gt;remove(thr, stl2)) &lt;&lt; &quot;Removing an inserted value should work.&quot;;
 353 
 354   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 355   EXPECT_FALSE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting a removed value should have failed.&quot;;
 356   EXPECT_TRUE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting an inserted value should work.&quot;;
 357 
 358   SimpleTestTable::GrowTask gt(cht);
 359   EXPECT_TRUE(gt.prepare(thr)) &lt;&lt; &quot;Growing uncontended should not fail.&quot;;
 360   while(gt.do_task(thr)) { /* grow */  }
 361   gt.done(thr);
 362 
 363   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an item after grow failed.&quot;;
 364   EXPECT_FALSE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting a removed value after grow should have failed.&quot;;
 365   EXPECT_TRUE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting an item after grow failed.&quot;;
 366 
 367   EXPECT_TRUE(cht-&gt;insert(thr, stl2, val2)) &lt;&lt; &quot;Insert unique value failed.&quot;;
 368   EXPECT_TRUE(cht-&gt;remove(thr, stl3)) &lt;&lt; &quot;Removing an inserted value should work.&quot;;
 369 
 370   EXPECT_TRUE(cht-&gt;shrink(thr)) &lt;&lt; &quot;Shrinking uncontended should not fail.&quot;;
 371 
 372   EXPECT_TRUE(cht_get_copy(cht, thr, stl) == val) &lt;&lt; &quot;Getting an item after shrink failed.&quot;;
 373   EXPECT_TRUE(cht_get_copy(cht, thr, stl2) == val2) &lt;&lt; &quot;Getting an item after shrink failed.&quot;;
 374   EXPECT_FALSE(cht_get_copy(cht, thr, stl3) == val3) &lt;&lt; &quot;Getting a removed value after shrink should have failed.&quot;;
 375 
 376   delete cht;
 377 }
 378 
 379 TEST_VM(ConcurrentHashTable, basic_insert) {
 380   nomt_test_doer(cht_insert);
 381 }
 382 
 383 TEST_VM(ConcurrentHashTable, basic_get_insert) {
 384   nomt_test_doer(cht_get_insert);
 385 }
 386 
 387 TEST_VM(ConcurrentHashTable, basic_scope) {
 388   nomt_test_doer(cht_scope);
 389 }
 390 
 391 TEST_VM(ConcurrentHashTable, basic_get_insert_bulk_delete) {
 392   nomt_test_doer(cht_getinsert_bulkdelete);
 393 }
 394 
 395 TEST_VM(ConcurrentHashTable, basic_get_insert_bulk_delete_task) {
 396   nomt_test_doer(cht_getinsert_bulkdelete_task);
 397 }
 398 
 399 TEST_VM(ConcurrentHashTable, basic_scan) {
 400   nomt_test_doer(cht_scan);
 401 }
 402 
 403 TEST_VM(ConcurrentHashTable, basic_move_to) {
 404   nomt_test_doer(cht_move_to);
 405 }
 406 
 407 TEST_VM(ConcurrentHashTable, basic_grow) {
 408   nomt_test_doer(cht_grow);
 409 }
 410 
 411 TEST_VM(ConcurrentHashTable, task_grow) {
 412   nomt_test_doer(cht_task_grow);
 413 }
 414 
 415 //#############################################################################################
 416 
<a name="5" id="anc5"></a><span class="line-modified"> 417 class TestInterface;</span>
<span class="line-removed"> 418 </span>
<span class="line-removed"> 419 typedef ConcurrentHashTable&lt;uintptr_t, TestInterface, mtInternal&gt; TestTable;</span>
<span class="line-removed"> 420 typedef ConcurrentHashTable&lt;uintptr_t, TestInterface, mtInternal&gt;::MultiGetHandle TestGetHandle;</span>
<span class="line-removed"> 421 </span>
<span class="line-removed"> 422 class TestInterface : public TestTable::BaseConfig {</span>
 423 public:
<a name="6" id="anc6"></a><span class="line-modified"> 424   static uintx get_hash(const uintptr_t&amp; value, bool* dead_hash) {</span>

 425     return (uintx)(value + 18446744073709551557ul) * 18446744073709551557ul;
 426   }
<a name="7" id="anc7"></a>





 427 };
 428 
<a name="8" id="anc8"></a>


 429 struct TestLookup {
 430   uintptr_t _val;
 431   TestLookup(uintptr_t val) : _val(val) {}
 432   uintx get_hash() {
 433     return TestInterface::get_hash(_val, NULL);
 434   }
 435   bool equals(const uintptr_t* value, bool* is_dead) {
 436     return _val == *value;
 437   }
 438 };
 439 
 440 static uintptr_t cht_get_copy(TestTable* cht, Thread* thr, TestLookup tl) {
 441   ValueGet vg;
 442   cht-&gt;get(thr, tl, vg);
 443   return vg.get_value();
 444 }
 445 
 446 class CHTTestThread : public JavaTestThread {
 447   public:
 448   uintptr_t _start;
 449   uintptr_t _stop;
 450   TestTable *_cht;
 451   jlong _stop_ms;
 452   CHTTestThread(uintptr_t start, uintptr_t stop, TestTable* cht, Semaphore* post)
 453     : JavaTestThread(post), _start(start), _stop(stop), _cht(cht) {}
 454   virtual void premain() {}
 455   void main_run() {
 456     premain();
 457     _stop_ms = os::javaTimeMillis() + 2000; // 2 seconds max test time
 458     while (keep_looping() &amp;&amp; test_loop()) { /* */ }
 459     postmain();
 460   }
 461   virtual void postmain() {}
 462   virtual bool keep_looping() {
 463     return _stop_ms &gt; os::javaTimeMillis();
 464   };
 465   virtual bool test_loop() = 0;
 466   virtual ~CHTTestThread() {}
 467 };
 468 
 469 class ValueSaver {
 470   uintptr_t* _vals;
 471   size_t _it;
 472   size_t _size;
 473  public:
 474   ValueSaver() : _it(0), _size(1024) {
 475       _vals = NEW_C_HEAP_ARRAY(uintptr_t, _size, mtInternal);
 476   }
 477 
 478   bool operator()(uintptr_t* val) {
 479     _vals[_it++] = *val;
 480     if (_it == _size) {
 481       _size *= 2;
 482       _vals = REALLOC_RESOURCE_ARRAY(uintptr_t, _vals, _size/2, _size);
 483     }
 484     return true;
 485   }
 486 
 487   void check() {
 488     for (size_t i = 0; i &lt; _it; i++) {
 489       size_t count = 0;
 490       for (size_t j = (i + 1u); j &lt; _it; j++) {
 491         if (_vals[i] == _vals[j]) {
 492           count++;
 493         }
 494       }
 495       EXPECT_EQ(count, 0u);
 496     }
 497   }
 498 };
 499 
 500 static void integrity_check(Thread* thr, TestTable* cht)
 501 {
 502   ValueSaver vs;
 503   cht-&gt;do_scan(thr, vs);
 504   vs.check();
 505 }
 506 
 507 //#############################################################################################
 508 // All threads are working on different items
 509 // This item should only be delete by this thread
 510 // Thus get_unsafe is safe for this test.
 511 
 512 class SimpleInserterThread : public CHTTestThread {
 513 public:
 514   static volatile bool _exit;
 515 
 516   SimpleInserterThread(uintptr_t start, uintptr_t stop, TestTable* cht, Semaphore* post)
 517     : CHTTestThread(start, stop, cht, post) {};
 518   virtual ~SimpleInserterThread(){}
 519 
 520   bool keep_looping() {
 521     return !_exit;
 522   }
 523 
 524   bool test_loop() {
 525     bool grow;
 526     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 527       TestLookup tl(v);
 528       EXPECT_TRUE(_cht-&gt;insert(this, tl, v, &amp;grow)) &lt;&lt; &quot;Inserting an unique value should work.&quot;;
 529     }
 530     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 531       TestLookup tl(v);
 532       EXPECT_TRUE(cht_get_copy(_cht, this, tl) == v) &lt;&lt; &quot;Getting an previously inserted value unsafe failed.&quot;;
 533     }
 534     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 535       TestLookup tl(v);
 536       EXPECT_TRUE(_cht-&gt;remove(this, tl)) &lt;&lt; &quot;Removing an existing value failed.&quot;;
 537     }
 538     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 539       TestLookup tl(v);
 540       EXPECT_TRUE(cht_get_copy(_cht, this, tl) == 0) &lt;&lt; &quot;Got a removed value.&quot;;
 541     }
 542     return true;
 543   }
 544 };
 545 
 546 volatile bool SimpleInserterThread::_exit = false;
 547 
 548 class RunnerSimpleInserterThread : public CHTTestThread {
 549 public:
 550   Semaphore _done;
 551 
 552   RunnerSimpleInserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {
 553     _cht = new TestTable(SIZE_32, SIZE_32);
 554   };
 555   virtual ~RunnerSimpleInserterThread(){}
 556 
 557   void premain() {
 558 
 559     SimpleInserterThread* ins1 = new SimpleInserterThread((uintptr_t)0x100, (uintptr_t) 0x1FF, _cht, &amp;_done);
 560     SimpleInserterThread* ins2 = new SimpleInserterThread((uintptr_t)0x200, (uintptr_t) 0x2FF, _cht, &amp;_done);
 561     SimpleInserterThread* ins3 = new SimpleInserterThread((uintptr_t)0x300, (uintptr_t) 0x3FF, _cht, &amp;_done);
 562     SimpleInserterThread* ins4 = new SimpleInserterThread((uintptr_t)0x400, (uintptr_t) 0x4FF, _cht, &amp;_done);
 563 
 564     for (uintptr_t v = 0x500; v &lt; 0x5FF; v++ ) {
 565       TestLookup tl(v);
 566       EXPECT_TRUE(_cht-&gt;insert(this, tl, v)) &lt;&lt; &quot;Inserting an unique value should work.&quot;;
 567     }
 568 
 569     ins1-&gt;doit();
 570     ins2-&gt;doit();
 571     ins3-&gt;doit();
 572     ins4-&gt;doit();
 573 
 574   }
 575 
 576   bool test_loop() {
 577     for (uintptr_t v = 0x500; v &lt; 0x5FF; v++ ) {
 578       TestLookup tl(v);
 579       EXPECT_TRUE(cht_get_copy(_cht, this, tl) == v) &lt;&lt; &quot;Getting an previously inserted value unsafe failed.&quot;;;
 580     }
 581     return true;
 582   }
 583 
 584   void postmain() {
 585     SimpleInserterThread::_exit = true;
 586     for (int i = 0; i &lt; 4; i++) {
 587       _done.wait();
 588     }
 589     for (uintptr_t v = 0x500; v &lt; 0x5FF; v++ ) {
 590       TestLookup tl(v);
 591       EXPECT_TRUE(_cht-&gt;remove(this, tl)) &lt;&lt; &quot;Removing an existing value failed.&quot;;
 592     }
 593     integrity_check(this, _cht);
 594     delete _cht;
 595   }
 596 };
 597 
 598 
 599 TEST_VM(ConcurrentHashTable, concurrent_simple) {
 600   SimpleInserterThread::_exit = false;
 601   mt_test_doer&lt;RunnerSimpleInserterThread&gt;();
 602 }
 603 
 604 //#############################################################################################
 605 // In this test we try to get a &#39;bad&#39; value
 606 class DeleteInserterThread : public CHTTestThread {
 607 public:
 608   static volatile bool _exit;
 609 
 610   DeleteInserterThread(uintptr_t start, uintptr_t stop, TestTable* cht, Semaphore* post) : CHTTestThread(start, stop, cht, post) {};
 611   virtual ~DeleteInserterThread(){}
 612 
 613   bool keep_looping() {
 614     return !_exit;
 615   }
 616 
 617   bool test_loop() {
 618     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 619       TestLookup tl(v);
 620       _cht-&gt;insert(this, tl, v);
 621     }
 622     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 623       TestLookup tl(v);
 624       _cht-&gt;remove(this, tl);
 625     }
 626     return true;
 627   }
 628 };
 629 
 630 volatile bool DeleteInserterThread::_exit = true;
 631 
 632 class RunnerDeleteInserterThread : public CHTTestThread {
 633 public:
 634   Semaphore _done;
 635 
 636   RunnerDeleteInserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {
 637     _cht = new TestTable(SIZE_32, SIZE_32);
 638   };
 639   virtual ~RunnerDeleteInserterThread(){}
 640 
 641   void premain() {
 642     DeleteInserterThread* ins1 = new DeleteInserterThread((uintptr_t)0x1, (uintptr_t) 0xFFF, _cht, &amp;_done);
 643     DeleteInserterThread* ins2 = new DeleteInserterThread((uintptr_t)0x1, (uintptr_t) 0xFFF, _cht, &amp;_done);
 644     DeleteInserterThread* ins3 = new DeleteInserterThread((uintptr_t)0x1, (uintptr_t) 0xFFF, _cht, &amp;_done);
 645     DeleteInserterThread* ins4 = new DeleteInserterThread((uintptr_t)0x1, (uintptr_t) 0xFFF, _cht, &amp;_done);
 646 
 647     ins1-&gt;doit();
 648     ins2-&gt;doit();
 649     ins3-&gt;doit();
 650     ins4-&gt;doit();
 651   }
 652 
 653   bool test_loop() {
 654     for (uintptr_t v = 0x1; v &lt; 0xFFF; v++ ) {
 655       uintptr_t tv;
 656       if (v &amp; 0x1) {
 657         TestLookup tl(v);
 658         tv = cht_get_copy(_cht, this, tl);
 659       } else {
 660         TestLookup tl(v);
 661         TestGetHandle value_handle(this, _cht);
 662         uintptr_t* tmp = value_handle.get(tl);
 663         tv = tmp != NULL ? *tmp : 0;
 664       }
 665       EXPECT_TRUE(tv == 0 || tv == v) &lt;&lt; &quot;Got unknown value.&quot;;
 666     }
 667     return true;
 668   }
 669 
 670   void postmain() {
 671     DeleteInserterThread::_exit = true;
 672     for (int i = 0; i &lt; 4; i++) {
 673       _done.wait();
 674     }
 675     integrity_check(this, _cht);
 676     delete _cht;
 677   }
 678 };
 679 
 680 TEST_VM(ConcurrentHashTable, concurrent_deletes) {
 681   DeleteInserterThread::_exit = false;
 682   mt_test_doer&lt;RunnerDeleteInserterThread&gt;();
 683 }
 684 
 685 //#############################################################################################
 686 
 687 #define START_SIZE 13
 688 #define END_SIZE 17
 689 #define START (uintptr_t)0x10000
 690 #define RANGE (uintptr_t)0xFFFF
 691 
 692 #define GSTEST_THREAD_COUNT 5
 693 
 694 
 695 class GSInserterThread: public CHTTestThread {
 696 public:
 697   static volatile bool _shrink;
 698   GSInserterThread(uintptr_t start, uintptr_t stop, TestTable* cht, Semaphore* post) : CHTTestThread(start, stop, cht, post) {};
 699   virtual ~GSInserterThread(){}
 700   bool keep_looping() {
 701     return !(_shrink &amp;&amp; _cht-&gt;get_size_log2(this) == START_SIZE);
 702   }
 703   bool test_loop() {
 704     bool grow;
 705     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 706       TestLookup tl(v);
 707       EXPECT_TRUE(_cht-&gt;insert(this, tl, v, &amp;grow)) &lt;&lt; &quot;Inserting an unique value should work.&quot;;
 708       if (grow &amp;&amp; !_shrink) {
 709         _cht-&gt;grow(this);
 710       }
 711     }
 712     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 713       TestLookup tl(v);
 714       EXPECT_TRUE(cht_get_copy(_cht, this, tl) == v) &lt;&lt;  &quot;Getting an previously inserted value unsafe failed.&quot;;
 715     }
 716     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 717       TestLookup tl(v);
 718       EXPECT_TRUE(_cht-&gt;remove(this, tl)) &lt;&lt; &quot;Removing an existing value failed.&quot;;
 719     }
 720     if (_shrink) {
 721       _cht-&gt;shrink(this);
 722     }
 723     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 724       TestLookup tl(v);
 725       EXPECT_FALSE(cht_get_copy(_cht, this, tl) == v)  &lt;&lt; &quot;Getting a removed value should have failed.&quot;;
 726     }
 727     if (!_shrink &amp;&amp; _cht-&gt;get_size_log2(this) == END_SIZE) {
 728       _shrink = true;
 729     }
 730     return true;
 731   }
 732 };
 733 
 734 volatile bool GSInserterThread::_shrink = false;
 735 
 736 class GSScannerThread : public CHTTestThread {
 737 public:
 738   GSScannerThread(uintptr_t start, uintptr_t stop, TestTable* cht, Semaphore* post) : CHTTestThread(start, stop, cht, post) {};
 739   virtual ~GSScannerThread(){}
 740 
 741   bool operator()(uintptr_t* val) {
 742     if (*val &gt;= this-&gt;_start &amp;&amp; *val &lt;= this-&gt;_stop) {
 743       return false;
 744     }
 745     // continue scan
 746     return true;
 747   }
 748 
 749   bool test_loop() {
 750     _cht-&gt;try_scan(this, *this);
 751     os::naked_short_sleep(5);
 752     return true;
 753   }
 754 };
 755 
 756 class RunnerGSInserterThread : public CHTTestThread {
 757 public:
 758   uintptr_t _start;
 759   uintptr_t _range;
 760   Semaphore _done;
 761 
 762   RunnerGSInserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {
 763     _cht = new TestTable(START_SIZE, END_SIZE, 2);
 764   };
 765   virtual ~RunnerGSInserterThread(){}
 766 
 767   void premain() {
 768     volatile bool timeout = false;
 769     _start = START;
 770     _range = RANGE;
 771     CHTTestThread* tt[GSTEST_THREAD_COUNT];
 772     tt[0] = new GSInserterThread(_start, _start + _range, _cht, &amp;_done);
 773     _start += _range + 1;
 774     tt[1] = new GSInserterThread(_start, _start + _range, _cht, &amp;_done);
 775     _start += _range + 1;
 776     tt[2] = new GSInserterThread(_start, _start + _range, _cht, &amp;_done);
 777     _start += _range + 1;
 778     tt[3] = new GSInserterThread(_start, _start + _range, _cht, &amp;_done);
 779     tt[4] = new GSScannerThread(_start, _start + _range, _cht, &amp;_done);
 780     _start += _range + 1;
 781 
 782 
 783     for (uintptr_t v = _start; v &lt;= (_start + _range); v++ ) {
 784       TestLookup tl(v);
 785       EXPECT_TRUE(_cht-&gt;insert(this, tl, v)) &lt;&lt; &quot;Inserting an unique value should work.&quot;;
 786     }
 787 
 788     for (int i = 0; i &lt; GSTEST_THREAD_COUNT; i++) {
 789       tt[i]-&gt;doit();
 790     }
 791   }
 792 
 793   bool test_loop() {
 794     for (uintptr_t v = _start; v &lt;= (_start + _range); v++ ) {
 795       TestLookup tl(v);
 796       EXPECT_TRUE(cht_get_copy(_cht, this, tl) == v) &lt;&lt;  &quot;Getting an previously inserted value unsafe failed.&quot;;
 797     }
 798     return true;
 799   }
 800 
 801   void postmain() {
 802     GSInserterThread::_shrink = true;
 803     for (uintptr_t v = _start; v &lt;= (_start + _range); v++ ) {
 804       TestLookup tl(v);
 805       EXPECT_TRUE(_cht-&gt;remove(this, tl)) &lt;&lt; &quot;Removing an existing value failed.&quot;;
 806     }
 807     for (int i = 0; i &lt; GSTEST_THREAD_COUNT; i++) {
 808       _done.wait();
 809     }
 810     EXPECT_TRUE(_cht-&gt;get_size_log2(this) == START_SIZE) &lt;&lt; &quot;Not at start size.&quot;;
 811     Count cnt;
 812     _cht-&gt;do_scan(this, cnt);
 813     EXPECT_TRUE(cnt._cnt == 0) &lt;&lt; &quot;Items still in table&quot;;
 814     delete _cht;
 815   }
 816 
 817   struct Count {
 818     Count() : _cnt(0) {}
 819     size_t _cnt;
 820     bool operator()(uintptr_t*) { _cnt++; return true; };
 821   };
 822 };
 823 
 824 TEST_VM(ConcurrentHashTable, concurrent_scan_grow_shrink) {
 825   GSInserterThread::_shrink = false;
 826   mt_test_doer&lt;RunnerGSInserterThread&gt;();
 827 }
 828 
 829 
 830 //#############################################################################################
 831 
 832 #define GI_BD_GI_BD_START_SIZE 13
 833 #define GI_BD_END_SIZE 17
 834 #define GI_BD_START (uintptr_t)0x1
 835 #define GI_BD_RANGE (uintptr_t)0x3FFFF
 836 
 837 #define GI_BD_TEST_THREAD_COUNT 4
 838 
 839 
 840 class GI_BD_InserterThread: public CHTTestThread {
 841 public:
 842   static volatile bool _shrink;
 843   uintptr_t _br;
 844   GI_BD_InserterThread(uintptr_t start, uintptr_t stop, TestTable* cht, Semaphore* post, uintptr_t br)
 845     : CHTTestThread(start, stop, cht, post), _br(br) {};
 846   virtual ~GI_BD_InserterThread(){}
 847 
 848   bool keep_looping() {
 849     return !(_shrink &amp;&amp; _cht-&gt;get_size_log2(this) == GI_BD_GI_BD_START_SIZE);
 850   }
 851 
 852   bool test_loop() {
 853     bool grow;
 854     MyDel del(_br);
 855     for (uintptr_t v = _start; v &lt;= _stop; v++) {
 856       {
 857         TestLookup tl(v);
 858         ValueGet vg;
 859         do {
 860           if (_cht-&gt;get(this, tl, vg, &amp;grow)) {
 861             EXPECT_EQ(v, vg.get_value()) &lt;&lt; &quot;Getting an old value failed.&quot;;
 862             break;
 863           }
 864           if (_cht-&gt;insert(this, tl, v, &amp;grow)) {
 865             break;
 866           }
 867         } while(true);
 868       }
 869       if (grow &amp;&amp; !_shrink) {
 870         _cht-&gt;grow(this);
 871       }
 872     }
 873     if (_shrink) {
 874       _cht-&gt;shrink(this);
 875     }
 876     _cht-&gt;try_bulk_delete(this, *this, del);
 877     if (!_shrink &amp;&amp; _cht-&gt;is_max_size_reached()) {
 878       _shrink = true;
 879     }
 880     _cht-&gt;bulk_delete(this, *this, del);
 881     return true;
 882   }
 883 
 884   bool operator()(uintptr_t* val) {
 885     return (*val &amp; _br) == 1;
 886   }
 887 
 888   struct MyDel {
 889     MyDel(uintptr_t &amp;br) : _br(br) {};
 890     uintptr_t &amp;_br;
 891     void operator()(uintptr_t* val) {
 892       EXPECT_EQ((*val &amp; _br), _br) &lt;&lt; &quot;Removing an item that should not have been removed.&quot;;
 893     }
 894   };
 895 };
 896 
 897 volatile bool GI_BD_InserterThread::_shrink = false;
 898 
 899 class RunnerGI_BD_InserterThread : public CHTTestThread {
 900 public:
 901   Semaphore _done;
 902   uintptr_t _start;
 903   uintptr_t _range;
 904   RunnerGI_BD_InserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {
 905     _cht = new TestTable(GI_BD_GI_BD_START_SIZE, GI_BD_END_SIZE, 2);
 906   };
 907   virtual ~RunnerGI_BD_InserterThread(){}
 908 
 909   void premain() {
 910     _start = GI_BD_START;
 911     _range = GI_BD_RANGE;
 912     CHTTestThread* tt[GI_BD_TEST_THREAD_COUNT];
 913     tt[0] = new GI_BD_InserterThread(_start, _start + _range, _cht, &amp;_done, (uintptr_t)0x1);
 914     tt[1] = new GI_BD_InserterThread(_start, _start + _range, _cht, &amp;_done, (uintptr_t)0x2);
 915     tt[2] = new GI_BD_InserterThread(_start, _start + _range, _cht, &amp;_done, (uintptr_t)0x4);
 916     tt[3] = new GI_BD_InserterThread(_start, _start + _range, _cht, &amp;_done, (uintptr_t)0x8);
 917 
 918     for (uintptr_t v = _start; v &lt;= (_start + _range); v++ ) {
 919       TestLookup tl(v);
 920       EXPECT_TRUE(_cht-&gt;insert(this, tl, v)) &lt;&lt; &quot;Inserting an unique value should work.&quot;;
 921     }
 922 
 923     for (int i =0; i &lt; GI_BD_TEST_THREAD_COUNT; i++) {
 924       tt[i]-&gt;doit();
 925     }
 926   }
 927 
 928   bool test_loop() {
 929     for (uintptr_t v = _start; v &lt;= (_start + _range); v++ ) {
 930       TestLookup tl(v);
 931       if (v &amp; 0xF) {
 932         cht_get_copy(_cht, this, tl);
 933       } else {
 934         EXPECT_EQ(cht_get_copy(_cht, this, tl), v) &lt;&lt; &quot;Item ending with 0xX0 should never be removed.&quot;;
 935       }
 936     }
 937     return true;
 938   }
 939 
 940   void postmain() {
 941     GI_BD_InserterThread::_shrink = true;
 942     for (uintptr_t v = _start; v &lt;= (_start + _range); v++ ) {
 943       TestLookup tl(v);
 944       if (v &amp; 0xF) {
 945         _cht-&gt;remove(this, tl);
 946       } else {
 947         EXPECT_TRUE(_cht-&gt;remove(this, tl)) &lt;&lt; &quot;Removing item ending with 0xX0 should always work.&quot;;
 948       }
 949     }
 950     for (int i = 0; i &lt; GI_BD_TEST_THREAD_COUNT; i++) {
 951       _done.wait();
 952     }
 953     EXPECT_TRUE(_cht-&gt;get_size_log2(this) == GI_BD_GI_BD_START_SIZE) &lt;&lt; &quot;We have not shrunk back to start size.&quot;;
 954     delete _cht;
 955   }
 956 };
 957 
 958 TEST_VM(ConcurrentHashTable, concurrent_get_insert_bulk_delete) {
 959   GI_BD_InserterThread::_shrink = false;
 960   mt_test_doer&lt;RunnerGI_BD_InserterThread&gt;();
 961 }
 962 
 963 //#############################################################################################
 964 
 965 class MT_BD_Thread : public JavaTestThread {
 966   TestTable::BulkDeleteTask* _bd;
 967   public:
 968   MT_BD_Thread(Semaphore* post, TestTable::BulkDeleteTask* bd)
 969     : JavaTestThread(post), _bd(bd){}
 970   virtual ~MT_BD_Thread() {}
 971   void main_run() {
 972     MyDel del;
 973     while(_bd-&gt;do_task(this, *this, del));
 974   }
 975 
 976   bool operator()(uintptr_t* val) {
 977     return true;
 978   }
 979 
 980   struct MyDel {
 981     void operator()(uintptr_t* val) {
 982     }
 983   };
 984 };
 985 
 986 class Driver_BD_Thread : public JavaTestThread {
 987 public:
 988   Semaphore _done;
 989   Driver_BD_Thread(Semaphore* post) : JavaTestThread(post) {
 990   };
 991   virtual ~Driver_BD_Thread(){}
 992 
 993   void main_run() {
 994     Semaphore done(0);
 995     TestTable* cht = new TestTable(16, 16, 2);
 996     for (uintptr_t v = 1; v &lt; 99999; v++ ) {
 997       TestLookup tl(v);
 998       EXPECT_TRUE(cht-&gt;insert(this, tl, v)) &lt;&lt; &quot;Inserting an unique value should work.&quot;;
 999     }
1000     TestTable::BulkDeleteTask bdt(cht, true /* mt */ );
1001     EXPECT_TRUE(bdt.prepare(this)) &lt;&lt; &quot;Uncontended prepare must work.&quot;;
1002 
1003     MT_BD_Thread* tt[4];
1004     for (int i = 0; i &lt; 4; i++) {
1005       tt[i] = new MT_BD_Thread(&amp;done, &amp;bdt);
1006       tt[i]-&gt;doit();
1007     }
1008 
1009     for (uintptr_t v = 1; v &lt; 99999; v++ ) {
1010       TestLookup tl(v);
1011       cht_get_copy(cht, this, tl);
1012     }
1013 
1014     for (int i = 0; i &lt; 4; i++) {
1015       done.wait();
1016     }
1017 
1018     bdt.done(this);
1019 
1020     cht-&gt;do_scan(this, *this);
1021   }
1022 
1023   bool operator()(uintptr_t* val) {
1024     EXPECT_TRUE(false) &lt;&lt; &quot;No items should left&quot;;
1025     return true;
1026   }
1027 };
1028 
1029 TEST_VM(ConcurrentHashTable, concurrent_mt_bulk_delete) {
1030   mt_test_doer&lt;Driver_BD_Thread&gt;();
1031 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
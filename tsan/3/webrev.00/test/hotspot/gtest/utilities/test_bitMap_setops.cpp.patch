diff a/test/hotspot/gtest/utilities/test_bitMap_setops.cpp b/test/hotspot/gtest/utilities/test_bitMap_setops.cpp
--- a/test/hotspot/gtest/utilities/test_bitMap_setops.cpp
+++ b/test/hotspot/gtest/utilities/test_bitMap_setops.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -20,20 +20,25 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 #include "precompiled.hpp"
+#include "utilities/align.hpp"
 #include "utilities/bitMap.inline.hpp"
 #include "utilities/copy.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/globalDefinitions.hpp"
 #include <stdlib.h>
 #include "unittest.hpp"
 
 typedef BitMap::idx_t idx_t;
 typedef BitMap::bm_word_t bm_word_t;
 
+inline idx_t word_align_down(idx_t bit) {
+  return align_down(bit, BitsPerWord);
+}
+
 class BitMapMemory {
 private:
   idx_t _words;
   bm_word_t* _memory;
 
@@ -145,11 +150,11 @@
   }
 
   // Check that a difference in the final partial word does count.
   {
     idx_t index = unaligned_size - 2;
-    ASSERT_LE(BitMap::word_align_down(unaligned_size), index);
+    ASSERT_LE(word_align_down(unaligned_size), index);
 
     WithBitClear wbc(y, index);
     EXPECT_FALSE(x.is_same(y));
   }
 }
@@ -259,11 +264,11 @@
   }
 
   // Check that a missing bit in the final partial word does count.
   {
     idx_t index = unaligned_size - 2;
-    ASSERT_LE(BitMap::word_align_down(unaligned_size), index);
+    ASSERT_LE(word_align_down(unaligned_size), index);
 
     WithBitClear wbc(x, index);
     EXPECT_FALSE(x.contains(y));
   }
 }
@@ -305,11 +310,11 @@
   }
 
   // Check that adding a bit in the final partial word does count.
   {
     idx_t index = unaligned_size - 2;
-    ASSERT_LE(BitMap::word_align_down(unaligned_size), index);
+    ASSERT_LE(word_align_down(unaligned_size), index);
     ASSERT_TRUE(x.at(index));
 
     WithBitSet wbs(y, index);
     EXPECT_TRUE(x.intersects(y));
   }
@@ -326,12 +331,12 @@
 // bool set_intersection_with_result(const BitMap& bits);
 
 static void check_tail_unmodified(BitMapMemory& mem,
                                   idx_t bits,
                                   bm_word_t fill_word) {
-  if (!BitMap::is_word_aligned(bits)) {
-    idx_t last_word_bit_index = BitMap::word_align_down(bits);
+  if (!is_aligned(bits, BitsPerWord)) {
+    idx_t last_word_bit_index = word_align_down(bits);
     idx_t last_word_index = BitMap::calc_size_in_words(last_word_bit_index);
     bm_word_t last_word = mem.memory()[last_word_index];
     idx_t shift = bits - last_word_bit_index;
     EXPECT_EQ(fill_word >> shift, last_word >> shift);
   }

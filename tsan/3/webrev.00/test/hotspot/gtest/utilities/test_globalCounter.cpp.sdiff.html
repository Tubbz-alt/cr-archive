<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/gtest/utilities/test_globalCounter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="test_count_leading_zeros.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="test_globalCounter_nested.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/gtest/utilities/test_globalCounter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;runtime/atomic.hpp&quot;
<span class="line-removed"> 26 #include &quot;runtime/orderAccess.hpp&quot;</span>
 27 #include &quot;runtime/os.hpp&quot;
 28 #include &quot;utilities/globalCounter.hpp&quot;
 29 #include &quot;utilities/globalCounter.inline.hpp&quot;
 30 #include &quot;threadHelper.inline.hpp&quot;
 31 
 32 #define GOOD_VALUE 1337
 33 #define BAD_VALUE  4711
 34 
 35 struct TestData {
 36   long test_value;
 37 };
 38 
 39 class RCUReaderThread : public JavaTestThread {
 40 public:
 41   static volatile bool _exit;
 42   volatile TestData** _test;
 43   Semaphore* _wrt_start;
 44   RCUReaderThread(Semaphore* post, volatile TestData** test, Semaphore* wrt_start)
 45     : JavaTestThread(post), _test(test), _wrt_start(wrt_start) {};
 46   virtual ~RCUReaderThread(){}
 47   void main_run() {
 48     _wrt_start-&gt;signal();
 49     while (!_exit) {
 50       GlobalCounter::CSContext cs_context = GlobalCounter::critical_section_begin(this);
<span class="line-modified"> 51       volatile TestData* test = OrderAccess::load_acquire(_test);</span>
<span class="line-modified"> 52       long value = OrderAccess::load_acquire(&amp;test-&gt;test_value);</span>
 53       ASSERT_EQ(value, GOOD_VALUE);
 54       GlobalCounter::critical_section_end(this, cs_context);
 55       {
 56         GlobalCounter::CriticalSection cs(this);
<span class="line-modified"> 57         volatile TestData* test = OrderAccess::load_acquire(_test);</span>
<span class="line-modified"> 58         long value = OrderAccess::load_acquire(&amp;test-&gt;test_value);</span>
 59         ASSERT_EQ(value, GOOD_VALUE);
 60       }
 61     }
 62   }
 63 };
 64 
 65 volatile bool RCUReaderThread::_exit = false;
 66 
 67 class RCUWriterThread : public JavaTestThread {
 68 public:
 69   RCUWriterThread(Semaphore* post) : JavaTestThread(post) {
 70   };
 71   virtual ~RCUWriterThread(){}
 72   void main_run() {
 73     static const int NUMBER_OF_READERS = 4;
 74     Semaphore post;
 75     Semaphore wrt_start;
 76     volatile TestData* test = NULL;
 77 
 78     RCUReaderThread* reader1 = new RCUReaderThread(&amp;post, &amp;test, &amp;wrt_start);
 79     RCUReaderThread* reader2 = new RCUReaderThread(&amp;post, &amp;test, &amp;wrt_start);
 80     RCUReaderThread* reader3 = new RCUReaderThread(&amp;post, &amp;test, &amp;wrt_start);
 81     RCUReaderThread* reader4 = new RCUReaderThread(&amp;post, &amp;test, &amp;wrt_start);
 82 
 83     TestData* tmp = new TestData();
 84     tmp-&gt;test_value = GOOD_VALUE;
<span class="line-modified"> 85     OrderAccess::release_store_fence(&amp;test, tmp);</span>
 86 
 87     reader1-&gt;doit();
 88     reader2-&gt;doit();
 89     reader3-&gt;doit();
 90     reader4-&gt;doit();
 91 
 92     int nw = NUMBER_OF_READERS;
 93     while (nw &gt; 0) {
 94       wrt_start.wait();
 95       --nw;
 96     }
 97     jlong stop_ms = os::javaTimeMillis() + 1000; // 1 seconds max test time
 98     for (int i = 0; i &lt; 100000 &amp;&amp; stop_ms &gt; os::javaTimeMillis(); i++) {
 99       volatile TestData* free_tmp = test;
100       tmp = new TestData();
101       tmp-&gt;test_value = GOOD_VALUE;
<span class="line-modified">102       OrderAccess::release_store(&amp;test, tmp);</span>
103       GlobalCounter::write_synchronize();
104       free_tmp-&gt;test_value = BAD_VALUE;
105       delete free_tmp;
106     }
107     RCUReaderThread::_exit = true;
108     for (int i = 0; i &lt; NUMBER_OF_READERS; i++) {
109       post.wait();
110     }
111   }
112 };
113 
114 TEST_VM(GlobalCounter, critical_section) {
115   RCUReaderThread::_exit = false;
116   mt_test_doer&lt;RCUWriterThread&gt;();
117 }
</pre>
</td>
<td>
<hr />
<pre>
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;runtime/atomic.hpp&quot;

 26 #include &quot;runtime/os.hpp&quot;
 27 #include &quot;utilities/globalCounter.hpp&quot;
 28 #include &quot;utilities/globalCounter.inline.hpp&quot;
 29 #include &quot;threadHelper.inline.hpp&quot;
 30 
 31 #define GOOD_VALUE 1337
 32 #define BAD_VALUE  4711
 33 
 34 struct TestData {
 35   long test_value;
 36 };
 37 
 38 class RCUReaderThread : public JavaTestThread {
 39 public:
 40   static volatile bool _exit;
 41   volatile TestData** _test;
 42   Semaphore* _wrt_start;
 43   RCUReaderThread(Semaphore* post, volatile TestData** test, Semaphore* wrt_start)
 44     : JavaTestThread(post), _test(test), _wrt_start(wrt_start) {};
 45   virtual ~RCUReaderThread(){}
 46   void main_run() {
 47     _wrt_start-&gt;signal();
 48     while (!_exit) {
 49       GlobalCounter::CSContext cs_context = GlobalCounter::critical_section_begin(this);
<span class="line-modified"> 50       volatile TestData* test = Atomic::load_acquire(_test);</span>
<span class="line-modified"> 51       long value = Atomic::load_acquire(&amp;test-&gt;test_value);</span>
 52       ASSERT_EQ(value, GOOD_VALUE);
 53       GlobalCounter::critical_section_end(this, cs_context);
 54       {
 55         GlobalCounter::CriticalSection cs(this);
<span class="line-modified"> 56         volatile TestData* test = Atomic::load_acquire(_test);</span>
<span class="line-modified"> 57         long value = Atomic::load_acquire(&amp;test-&gt;test_value);</span>
 58         ASSERT_EQ(value, GOOD_VALUE);
 59       }
 60     }
 61   }
 62 };
 63 
 64 volatile bool RCUReaderThread::_exit = false;
 65 
 66 class RCUWriterThread : public JavaTestThread {
 67 public:
 68   RCUWriterThread(Semaphore* post) : JavaTestThread(post) {
 69   };
 70   virtual ~RCUWriterThread(){}
 71   void main_run() {
 72     static const int NUMBER_OF_READERS = 4;
 73     Semaphore post;
 74     Semaphore wrt_start;
 75     volatile TestData* test = NULL;
 76 
 77     RCUReaderThread* reader1 = new RCUReaderThread(&amp;post, &amp;test, &amp;wrt_start);
 78     RCUReaderThread* reader2 = new RCUReaderThread(&amp;post, &amp;test, &amp;wrt_start);
 79     RCUReaderThread* reader3 = new RCUReaderThread(&amp;post, &amp;test, &amp;wrt_start);
 80     RCUReaderThread* reader4 = new RCUReaderThread(&amp;post, &amp;test, &amp;wrt_start);
 81 
 82     TestData* tmp = new TestData();
 83     tmp-&gt;test_value = GOOD_VALUE;
<span class="line-modified"> 84     Atomic::release_store_fence(&amp;test, tmp);</span>
 85 
 86     reader1-&gt;doit();
 87     reader2-&gt;doit();
 88     reader3-&gt;doit();
 89     reader4-&gt;doit();
 90 
 91     int nw = NUMBER_OF_READERS;
 92     while (nw &gt; 0) {
 93       wrt_start.wait();
 94       --nw;
 95     }
 96     jlong stop_ms = os::javaTimeMillis() + 1000; // 1 seconds max test time
 97     for (int i = 0; i &lt; 100000 &amp;&amp; stop_ms &gt; os::javaTimeMillis(); i++) {
 98       volatile TestData* free_tmp = test;
 99       tmp = new TestData();
100       tmp-&gt;test_value = GOOD_VALUE;
<span class="line-modified">101       Atomic::release_store(&amp;test, tmp);</span>
102       GlobalCounter::write_synchronize();
103       free_tmp-&gt;test_value = BAD_VALUE;
104       delete free_tmp;
105     }
106     RCUReaderThread::_exit = true;
107     for (int i = 0; i &lt; NUMBER_OF_READERS; i++) {
108       post.wait();
109     }
110   }
111 };
112 
113 TEST_VM(GlobalCounter, critical_section) {
114   RCUReaderThread::_exit = false;
115   mt_test_doer&lt;RCUWriterThread&gt;();
116 }
</pre>
</td>
</tr>
</table>
<center><a href="test_count_leading_zeros.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="test_globalCounter_nested.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
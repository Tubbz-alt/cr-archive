<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/gtest/utilities/test_globalCounter_nested.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;metaprogramming/isRegisteredEnum.hpp&quot;
 26 #include &quot;runtime/atomic.hpp&quot;
 27 #include &quot;runtime/os.hpp&quot;
 28 #include &quot;utilities/globalCounter.hpp&quot;
 29 #include &quot;utilities/globalCounter.inline.hpp&quot;
 30 #include &quot;utilities/spinYield.hpp&quot;
 31 #include &quot;threadHelper.inline.hpp&quot;
 32 
 33 enum NestedTestState {
 34   START,
 35   START_WAIT,
 36   OUTER_ENTERED,
 37   INNER_ENTERED,
 38   INNER_EXITED,
 39   OUTER_EXITED,
 40   SYNCHRONIZING,
 41   SYNCHRONIZED
 42 };
 43 template&lt;&gt; struct IsRegisteredEnum&lt;NestedTestState&gt; : public TrueType {};
 44 
 45 class RCUNestedThread : public JavaTestThread {
 46   volatile NestedTestState _state;
 47   volatile bool _proceed;
 48 
 49 protected:
 50   RCUNestedThread(Semaphore* post) :
 51     JavaTestThread(post),
 52     _state(START),
 53     _proceed(false)
 54   {}
 55 
 56   ~RCUNestedThread() {}
 57 
 58   void set_state(NestedTestState new_state) {
 59     Atomic::release_store(&amp;_state, new_state);
 60   }
 61 
 62   void wait_with_state(NestedTestState new_state) {
 63     SpinYield spinner;
 64     Atomic::release_store(&amp;_state, new_state);
 65     while (!Atomic::load_acquire(&amp;_proceed)) {
 66       spinner.wait();
 67     }
 68     Atomic::release_store(&amp;_proceed, false);
 69   }
 70 
 71 public:
 72   NestedTestState state() const {
 73     return Atomic::load_acquire(&amp;_state);
 74   }
 75 
 76   void wait_for_state(NestedTestState goal) {
 77     SpinYield spinner;
 78     while (state() != goal) {
 79       spinner.wait();
 80     }
 81   }
 82 
 83   void proceed() {
 84     Atomic::release_store(&amp;_proceed, true);
 85   }
 86 };
 87 
 88 class RCUNestedReaderThread : public RCUNestedThread {
 89 public:
 90   RCUNestedReaderThread(Semaphore* post) :
 91     RCUNestedThread(post)
 92   {}
 93 
 94   virtual void main_run();
 95 };
 96 
 97 void RCUNestedReaderThread::main_run() {
 98   wait_with_state(START_WAIT);
 99   {
100     GlobalCounter::CriticalSection outer(Thread::current());
101     wait_with_state(OUTER_ENTERED);
102     {
103       GlobalCounter::CriticalSection inner(Thread::current());
104       wait_with_state(INNER_ENTERED);
105     }
106     wait_with_state(INNER_EXITED);
107   }
108   wait_with_state(OUTER_EXITED);
109 }
110 
111 
112 class RCUNestedWriterThread : public RCUNestedThread {
113 public:
114   RCUNestedWriterThread(Semaphore* post) :
115     RCUNestedThread(post)
116   {}
117 
118   virtual void main_run();
119 };
120 
121 void RCUNestedWriterThread::main_run() {
122   wait_with_state(START_WAIT);
123   set_state(SYNCHRONIZING);
124   GlobalCounter::write_synchronize();
125   wait_with_state(SYNCHRONIZED);
126 }
127 
128 TEST_VM(GlobalCounter, nested_critical_section) {
129   Semaphore post;
130   RCUNestedReaderThread* reader = new RCUNestedReaderThread(&amp;post);
131   RCUNestedWriterThread* outer = new RCUNestedWriterThread(&amp;post);
132   RCUNestedWriterThread* inner = new RCUNestedWriterThread(&amp;post);
133 
134   reader-&gt;doit();
135   outer-&gt;doit();
136   inner-&gt;doit();
137 
138   reader-&gt;wait_for_state(START_WAIT);
139   outer-&gt;wait_for_state(START_WAIT);
140   inner-&gt;wait_for_state(START_WAIT);
141   EXPECT_EQ(START_WAIT, reader-&gt;state());
142   EXPECT_EQ(START_WAIT, outer-&gt;state());
143   EXPECT_EQ(START_WAIT, inner-&gt;state());
144 
145   reader-&gt;proceed();
146   reader-&gt;wait_for_state(OUTER_ENTERED);
147   EXPECT_EQ(OUTER_ENTERED, reader-&gt;state());
148   EXPECT_EQ(START_WAIT, outer-&gt;state());
149   EXPECT_EQ(START_WAIT, inner-&gt;state());
150 
151   outer-&gt;proceed();
152   outer-&gt;wait_for_state(SYNCHRONIZING);
153   EXPECT_EQ(OUTER_ENTERED, reader-&gt;state());
154   EXPECT_EQ(SYNCHRONIZING, outer-&gt;state());
155   EXPECT_EQ(START_WAIT, inner-&gt;state());
156 
157   os::naked_short_sleep(100);   // Give outer time in synchronization.
158   EXPECT_EQ(OUTER_ENTERED, reader-&gt;state());
159   EXPECT_EQ(SYNCHRONIZING, outer-&gt;state());
160   EXPECT_EQ(START_WAIT, inner-&gt;state());
161 
162   reader-&gt;proceed();
163   reader-&gt;wait_for_state(INNER_ENTERED);
164   EXPECT_EQ(INNER_ENTERED, reader-&gt;state());
165   EXPECT_EQ(SYNCHRONIZING, outer-&gt;state());
166   EXPECT_EQ(START_WAIT, inner-&gt;state());
167 
168   inner-&gt;proceed();
169   inner-&gt;wait_for_state(SYNCHRONIZING);
170   EXPECT_EQ(INNER_ENTERED, reader-&gt;state());
171   EXPECT_EQ(SYNCHRONIZING, outer-&gt;state());
172   EXPECT_EQ(SYNCHRONIZING, inner-&gt;state());
173 
174   os::naked_short_sleep(100); // Give writers time in synchronization.
175   EXPECT_EQ(INNER_ENTERED, reader-&gt;state());
176   EXPECT_EQ(SYNCHRONIZING, outer-&gt;state());
177   EXPECT_EQ(SYNCHRONIZING, inner-&gt;state());
178 
179   reader-&gt;proceed();
180   reader-&gt;wait_for_state(INNER_EXITED);
181   // inner does *not* complete synchronization here.
182   EXPECT_EQ(INNER_EXITED, reader-&gt;state());
183   EXPECT_EQ(SYNCHRONIZING, outer-&gt;state());
184   EXPECT_EQ(SYNCHRONIZING, inner-&gt;state());
185 
186   os::naked_short_sleep(100); // Give writers more time in synchronization.
187   EXPECT_EQ(INNER_EXITED, reader-&gt;state());
188   EXPECT_EQ(SYNCHRONIZING, outer-&gt;state());
189   EXPECT_EQ(SYNCHRONIZING, inner-&gt;state());
190 
191   reader-&gt;proceed();
192   reader-&gt;wait_for_state(OUTER_EXITED);
193   // Both inner and outer can synchronize now.
194   outer-&gt;wait_for_state(SYNCHRONIZED);
195   inner-&gt;wait_for_state(SYNCHRONIZED);
196   EXPECT_EQ(OUTER_EXITED, reader-&gt;state());
197   EXPECT_EQ(SYNCHRONIZED, outer-&gt;state());
198   EXPECT_EQ(SYNCHRONIZED, inner-&gt;state());
199 
200   // Wait for reader, outer, and inner to complete.
201   reader-&gt;proceed();
202   outer-&gt;proceed();
203   inner-&gt;proceed();
204   for (uint i = 0; i &lt; 3; ++i) {
205     post.wait();
206   }
207 }
    </pre>
  </body>
</html>
diff a/test/hotspot/gtest/utilities/test_singleWriterSynchronizer.cpp b/test/hotspot/gtest/utilities/test_singleWriterSynchronizer.cpp
--- a/test/hotspot/gtest/utilities/test_singleWriterSynchronizer.cpp
+++ b/test/hotspot/gtest/utilities/test_singleWriterSynchronizer.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,11 +22,11 @@
  *
  */
 
 #include "precompiled.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
-#include "runtime/orderAccess.hpp"
+#include "runtime/atomic.hpp"
 #include "runtime/os.hpp"
 #include "runtime/thread.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/globalCounter.inline.hpp"
 #include "utilities/globalDefinitions.hpp"
@@ -54,18 +54,18 @@
   {}
 
   virtual void main_run() {
     size_t iterations = 0;
     size_t values_changed = 0;
-    while (OrderAccess::load_acquire(_continue_running) != 0) {
+    while (Atomic::load_acquire(_continue_running) != 0) {
       { ThreadBlockInVM tbiv(this); } // Safepoint check outside critical section.
       ++iterations;
       SingleWriterSynchronizer::CriticalSection cs(_synchronizer);
-      uintx value = OrderAccess::load_acquire(_synchronized_value);
+      uintx value = Atomic::load_acquire(_synchronized_value);
       uintx new_value = value;
       for (uint i = 0; i < reader_iterations; ++i) {
-        new_value = OrderAccess::load_acquire(_synchronized_value);
+        new_value = Atomic::load_acquire(_synchronized_value);
         // A reader can see either the value it first read after
         // entering the critical section, or that value + 1.  No other
         // values are possible.
         if (value != new_value) {
           ASSERT_EQ((value + 1), new_value);
@@ -95,11 +95,11 @@
     _synchronized_value(synchronized_value),
     _continue_running(continue_running)
   {}
 
   virtual void main_run() {
-    while (OrderAccess::load_acquire(_continue_running) != 0) {
+    while (Atomic::load_acquire(_continue_running) != 0) {
       ++*_synchronized_value;
       _synchronizer->synchronize();
       { ThreadBlockInVM tbiv(this); } // Safepoint check.
     }
     tty->print_cr("writer iterations: " UINTX_FORMAT, *_synchronized_value);
@@ -131,13 +131,14 @@
                                            &continue_running);
 
   writer->doit();
 
   tty->print_cr("Stressing synchronizer for %u ms", milliseconds_to_run);
+  JavaThread* cur = JavaThread::current();
   {
-    ThreadInVMfromNative invm(JavaThread::current());
-    os::sleep(Thread::current(), milliseconds_to_run, true);
+    ThreadInVMfromNative invm(cur);
+    cur->sleep(milliseconds_to_run);
   }
   continue_running = 0;
   for (uint i = 0; i < nreaders + 1; ++i) {
     post.wait();
   }

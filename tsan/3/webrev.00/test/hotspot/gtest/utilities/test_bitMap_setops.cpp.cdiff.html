<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/hotspot/gtest/utilities/test_bitMap_setops.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../unittest.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="test_concurrentHashtable.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/gtest/utilities/test_bitMap_setops.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 20,20 ***</span>
<span class="line-new-header">--- 20,25 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-added">+ #include &quot;utilities/align.hpp&quot;</span>
  #include &quot;utilities/bitMap.inline.hpp&quot;
  #include &quot;utilities/copy.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &lt;stdlib.h&gt;
  #include &quot;unittest.hpp&quot;
  
  typedef BitMap::idx_t idx_t;
  typedef BitMap::bm_word_t bm_word_t;
  
<span class="line-added">+ inline idx_t word_align_down(idx_t bit) {</span>
<span class="line-added">+   return align_down(bit, BitsPerWord);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class BitMapMemory {
  private:
    idx_t _words;
    bm_word_t* _memory;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 145,11 ***</span>
    }
  
    // Check that a difference in the final partial word does count.
    {
      idx_t index = unaligned_size - 2;
<span class="line-modified">!     ASSERT_LE(BitMap::word_align_down(unaligned_size), index);</span>
  
      WithBitClear wbc(y, index);
      EXPECT_FALSE(x.is_same(y));
    }
  }
<span class="line-new-header">--- 150,11 ---</span>
    }
  
    // Check that a difference in the final partial word does count.
    {
      idx_t index = unaligned_size - 2;
<span class="line-modified">!     ASSERT_LE(word_align_down(unaligned_size), index);</span>
  
      WithBitClear wbc(y, index);
      EXPECT_FALSE(x.is_same(y));
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 259,11 ***</span>
    }
  
    // Check that a missing bit in the final partial word does count.
    {
      idx_t index = unaligned_size - 2;
<span class="line-modified">!     ASSERT_LE(BitMap::word_align_down(unaligned_size), index);</span>
  
      WithBitClear wbc(x, index);
      EXPECT_FALSE(x.contains(y));
    }
  }
<span class="line-new-header">--- 264,11 ---</span>
    }
  
    // Check that a missing bit in the final partial word does count.
    {
      idx_t index = unaligned_size - 2;
<span class="line-modified">!     ASSERT_LE(word_align_down(unaligned_size), index);</span>
  
      WithBitClear wbc(x, index);
      EXPECT_FALSE(x.contains(y));
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,11 ***</span>
    }
  
    // Check that adding a bit in the final partial word does count.
    {
      idx_t index = unaligned_size - 2;
<span class="line-modified">!     ASSERT_LE(BitMap::word_align_down(unaligned_size), index);</span>
      ASSERT_TRUE(x.at(index));
  
      WithBitSet wbs(y, index);
      EXPECT_TRUE(x.intersects(y));
    }
<span class="line-new-header">--- 310,11 ---</span>
    }
  
    // Check that adding a bit in the final partial word does count.
    {
      idx_t index = unaligned_size - 2;
<span class="line-modified">!     ASSERT_LE(word_align_down(unaligned_size), index);</span>
      ASSERT_TRUE(x.at(index));
  
      WithBitSet wbs(y, index);
      EXPECT_TRUE(x.intersects(y));
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 326,12 ***</span>
  // bool set_intersection_with_result(const BitMap&amp; bits);
  
  static void check_tail_unmodified(BitMapMemory&amp; mem,
                                    idx_t bits,
                                    bm_word_t fill_word) {
<span class="line-modified">!   if (!BitMap::is_word_aligned(bits)) {</span>
<span class="line-modified">!     idx_t last_word_bit_index = BitMap::word_align_down(bits);</span>
      idx_t last_word_index = BitMap::calc_size_in_words(last_word_bit_index);
      bm_word_t last_word = mem.memory()[last_word_index];
      idx_t shift = bits - last_word_bit_index;
      EXPECT_EQ(fill_word &gt;&gt; shift, last_word &gt;&gt; shift);
    }
<span class="line-new-header">--- 331,12 ---</span>
  // bool set_intersection_with_result(const BitMap&amp; bits);
  
  static void check_tail_unmodified(BitMapMemory&amp; mem,
                                    idx_t bits,
                                    bm_word_t fill_word) {
<span class="line-modified">!   if (!is_aligned(bits, BitsPerWord)) {</span>
<span class="line-modified">!     idx_t last_word_bit_index = word_align_down(bits);</span>
      idx_t last_word_index = BitMap::calc_size_in_words(last_word_bit_index);
      bm_word_t last_word = mem.memory()[last_word_index];
      idx_t shift = bits - last_word_bit_index;
      EXPECT_EQ(fill_word &gt;&gt; shift, last_word &gt;&gt; shift);
    }
</pre>
<center><a href="../unittest.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="test_concurrentHashtable.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
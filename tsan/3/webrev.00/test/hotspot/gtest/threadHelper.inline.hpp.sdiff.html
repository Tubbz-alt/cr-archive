<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/gtest/threadHelper.inline.hpp</title>
    <link rel="stylesheet" href="../../../style.css" />
  </head>
<body>
<center><a href="runtime/test_synchronizer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../index.html" target="_top">index</a> <a href="unittest.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/gtest/threadHelper.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef GTEST_THREADHELPER_INLINE_HPP
 25 #define GTEST_THREADHELPER_INLINE_HPP
 26 
 27 #include &quot;runtime/mutex.hpp&quot;
 28 #include &quot;runtime/semaphore.hpp&quot;
 29 #include &quot;runtime/thread.inline.hpp&quot;
 30 #include &quot;runtime/vmThread.hpp&quot;
 31 #include &quot;runtime/vmOperations.hpp&quot;
 32 #include &quot;unittest.hpp&quot;
 33 
 34 class VM_StopSafepoint : public VM_Operation {
 35 public:
 36   Semaphore* _running;
 37   Semaphore* _test_complete;
 38   VM_StopSafepoint(Semaphore* running, Semaphore* wait_for) :
 39     _running(running), _test_complete(wait_for) {}
 40   VMOp_Type type() const          { return VMOp_None; }
<span class="line-modified"> 41   Mode evaluation_mode() const    { return _no_safepoint; }</span>
<span class="line-removed"> 42   bool is_cheap_allocated() const { return false; }</span>
 43   void doit()                     { _running-&gt;signal(); _test_complete-&gt;wait(); }
 44 };
 45 
 46 // This class and thread keep the non-safepoint op running while we do our testing.
 47 class VMThreadBlocker : public JavaThread {
 48 public:
 49   Semaphore _ready;
 50   Semaphore _unblock;
 51   VMThreadBlocker() {}
 52   virtual ~VMThreadBlocker() {}
 53   const char* get_thread_name_string(char* buf, int buflen) const {
 54     return &quot;VMThreadBlocker&quot;;
 55   }
 56   void run() {
 57     this-&gt;set_thread_state(_thread_in_vm);
 58     {
 59       MutexLocker ml(Threads_lock);
 60       Threads::add(this);
 61     }
 62     VM_StopSafepoint ss(&amp;_ready, &amp;_unblock);
 63     VMThread::execute(&amp;ss);
 64   }
 65 
 66   // Override as JavaThread::post_run() calls JavaThread::exit which
 67   // expects a valid thread object oop.
 68   virtual void post_run() {
<span class="line-modified"> 69     Threads::remove(this);</span>
 70     this-&gt;smr_delete();
 71   }
 72 
 73   void doit() {
 74     if (os::create_thread(this, os::os_thread)) {
 75       os::start_thread(this);
 76     } else {
 77       ASSERT_TRUE(false);
 78     }
 79   }
 80   void ready() {
 81     _ready.wait();
 82   }
 83   void release() {
 84     _unblock.signal();
 85   }
 86 };
 87 
 88 // For testing in a real JavaThread.
 89 class JavaTestThread : public JavaThread {
 90 public:
 91   Semaphore* _post;
 92   JavaTestThread(Semaphore* post)
 93     : _post(post) {
 94   }
 95   virtual ~JavaTestThread() {}
 96 
 97   const char* get_thread_name_string(char* buf, int buflen) const {
 98     return &quot;JavaTestThread&quot;;
 99   }
100 
101   void pre_run() {
102     this-&gt;set_thread_state(_thread_in_vm);
103     {
104       MutexLocker ml(Threads_lock);
105       Threads::add(this);
106     }
107     {
<span class="line-modified">108       MutexLockerEx ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
109     }
110   }
111 
112   virtual void main_run() = 0;
113 
114   void run() {
115     main_run();
116   }
117 
118   // Override as JavaThread::post_run() calls JavaThread::exit which
119   // expects a valid thread object oop. And we need to call signal.
120   void post_run() {
<span class="line-modified">121     Threads::remove(this);</span>
122     _post-&gt;signal();
123     this-&gt;smr_delete();
124   }
125 
126   void doit() {
127     if (os::create_thread(this, os::os_thread)) {
128       os::start_thread(this);
129     } else {
130       ASSERT_TRUE(false);
131     }
132   }
133 };
134 
135 template &lt;typename FUNC&gt;
136 class SingleTestThread : public JavaTestThread {
137 public:
138   FUNC&amp; _f;
139   SingleTestThread(Semaphore* post, FUNC&amp; f)
140     : JavaTestThread(post), _f(f) {
141   }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef GTEST_THREADHELPER_INLINE_HPP
 25 #define GTEST_THREADHELPER_INLINE_HPP
 26 
 27 #include &quot;runtime/mutex.hpp&quot;
 28 #include &quot;runtime/semaphore.hpp&quot;
 29 #include &quot;runtime/thread.inline.hpp&quot;
 30 #include &quot;runtime/vmThread.hpp&quot;
 31 #include &quot;runtime/vmOperations.hpp&quot;
 32 #include &quot;unittest.hpp&quot;
 33 
 34 class VM_StopSafepoint : public VM_Operation {
 35 public:
 36   Semaphore* _running;
 37   Semaphore* _test_complete;
 38   VM_StopSafepoint(Semaphore* running, Semaphore* wait_for) :
 39     _running(running), _test_complete(wait_for) {}
 40   VMOp_Type type() const          { return VMOp_None; }
<span class="line-modified"> 41   bool evaluate_at_safepoint() const { return false; }</span>

 42   void doit()                     { _running-&gt;signal(); _test_complete-&gt;wait(); }
 43 };
 44 
 45 // This class and thread keep the non-safepoint op running while we do our testing.
 46 class VMThreadBlocker : public JavaThread {
 47 public:
 48   Semaphore _ready;
 49   Semaphore _unblock;
 50   VMThreadBlocker() {}
 51   virtual ~VMThreadBlocker() {}
 52   const char* get_thread_name_string(char* buf, int buflen) const {
 53     return &quot;VMThreadBlocker&quot;;
 54   }
 55   void run() {
 56     this-&gt;set_thread_state(_thread_in_vm);
 57     {
 58       MutexLocker ml(Threads_lock);
 59       Threads::add(this);
 60     }
 61     VM_StopSafepoint ss(&amp;_ready, &amp;_unblock);
 62     VMThread::execute(&amp;ss);
 63   }
 64 
 65   // Override as JavaThread::post_run() calls JavaThread::exit which
 66   // expects a valid thread object oop.
 67   virtual void post_run() {
<span class="line-modified"> 68     Threads::remove(this, false);</span>
 69     this-&gt;smr_delete();
 70   }
 71 
 72   void doit() {
 73     if (os::create_thread(this, os::os_thread)) {
 74       os::start_thread(this);
 75     } else {
 76       ASSERT_TRUE(false);
 77     }
 78   }
 79   void ready() {
 80     _ready.wait();
 81   }
 82   void release() {
 83     _unblock.signal();
 84   }
 85 };
 86 
 87 // For testing in a real JavaThread.
 88 class JavaTestThread : public JavaThread {
 89 public:
 90   Semaphore* _post;
 91   JavaTestThread(Semaphore* post)
 92     : _post(post) {
 93   }
 94   virtual ~JavaTestThread() {}
 95 
 96   const char* get_thread_name_string(char* buf, int buflen) const {
 97     return &quot;JavaTestThread&quot;;
 98   }
 99 
100   void pre_run() {
101     this-&gt;set_thread_state(_thread_in_vm);
102     {
103       MutexLocker ml(Threads_lock);
104       Threads::add(this);
105     }
106     {
<span class="line-modified">107       MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
108     }
109   }
110 
111   virtual void main_run() = 0;
112 
113   void run() {
114     main_run();
115   }
116 
117   // Override as JavaThread::post_run() calls JavaThread::exit which
118   // expects a valid thread object oop. And we need to call signal.
119   void post_run() {
<span class="line-modified">120     Threads::remove(this, false);</span>
121     _post-&gt;signal();
122     this-&gt;smr_delete();
123   }
124 
125   void doit() {
126     if (os::create_thread(this, os::os_thread)) {
127       os::start_thread(this);
128     } else {
129       ASSERT_TRUE(false);
130     }
131   }
132 };
133 
134 template &lt;typename FUNC&gt;
135 class SingleTestThread : public JavaTestThread {
136 public:
137   FUNC&amp; _f;
138   SingleTestThread(Semaphore* post, FUNC&amp; f)
139     : JavaTestThread(post), _f(f) {
140   }
</pre>
</td>
</tr>
</table>
<center><a href="runtime/test_synchronizer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../index.html" target="_top">index</a> <a href="unittest.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
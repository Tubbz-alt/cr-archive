<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/hotspot/gtest/threadHelper.inline.hpp</title>
    <link rel="stylesheet" href="../../../style.css" />
  </head>
<body>
<center><a href="runtime/test_synchronizer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../index.html" target="_top">index</a> <a href="unittest.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/gtest/threadHelper.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 36,12 ***</span>
    Semaphore* _running;
    Semaphore* _test_complete;
    VM_StopSafepoint(Semaphore* running, Semaphore* wait_for) :
      _running(running), _test_complete(wait_for) {}
    VMOp_Type type() const          { return VMOp_None; }
<span class="line-modified">!   Mode evaluation_mode() const    { return _no_safepoint; }</span>
<span class="line-removed">-   bool is_cheap_allocated() const { return false; }</span>
    void doit()                     { _running-&gt;signal(); _test_complete-&gt;wait(); }
  };
  
  // This class and thread keep the non-safepoint op running while we do our testing.
  class VMThreadBlocker : public JavaThread {
<span class="line-new-header">--- 36,11 ---</span>
    Semaphore* _running;
    Semaphore* _test_complete;
    VM_StopSafepoint(Semaphore* running, Semaphore* wait_for) :
      _running(running), _test_complete(wait_for) {}
    VMOp_Type type() const          { return VMOp_None; }
<span class="line-modified">!   bool evaluate_at_safepoint() const { return false; }</span>
    void doit()                     { _running-&gt;signal(); _test_complete-&gt;wait(); }
  };
  
  // This class and thread keep the non-safepoint op running while we do our testing.
  class VMThreadBlocker : public JavaThread {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,11 ***</span>
    }
  
    // Override as JavaThread::post_run() calls JavaThread::exit which
    // expects a valid thread object oop.
    virtual void post_run() {
<span class="line-modified">!     Threads::remove(this);</span>
      this-&gt;smr_delete();
    }
  
    void doit() {
      if (os::create_thread(this, os::os_thread)) {
<span class="line-new-header">--- 63,11 ---</span>
    }
  
    // Override as JavaThread::post_run() calls JavaThread::exit which
    // expects a valid thread object oop.
    virtual void post_run() {
<span class="line-modified">!     Threads::remove(this, false);</span>
      this-&gt;smr_delete();
    }
  
    void doit() {
      if (os::create_thread(this, os::os_thread)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 103,11 ***</span>
      {
        MutexLocker ml(Threads_lock);
        Threads::add(this);
      }
      {
<span class="line-modified">!       MutexLockerEx ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
      }
    }
  
    virtual void main_run() = 0;
  
<span class="line-new-header">--- 102,11 ---</span>
      {
        MutexLocker ml(Threads_lock);
        Threads::add(this);
      }
      {
<span class="line-modified">!       MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
      }
    }
  
    virtual void main_run() = 0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,11 ***</span>
    }
  
    // Override as JavaThread::post_run() calls JavaThread::exit which
    // expects a valid thread object oop. And we need to call signal.
    void post_run() {
<span class="line-modified">!     Threads::remove(this);</span>
      _post-&gt;signal();
      this-&gt;smr_delete();
    }
  
    void doit() {
<span class="line-new-header">--- 115,11 ---</span>
    }
  
    // Override as JavaThread::post_run() calls JavaThread::exit which
    // expects a valid thread object oop. And we need to call signal.
    void post_run() {
<span class="line-modified">!     Threads::remove(this, false);</span>
      _post-&gt;signal();
      this-&gt;smr_delete();
    }
  
    void doit() {
</pre>
<center><a href="runtime/test_synchronizer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../index.html" target="_top">index</a> <a href="unittest.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
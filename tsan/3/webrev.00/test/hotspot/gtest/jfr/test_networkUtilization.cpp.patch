diff a/test/hotspot/gtest/jfr/test_networkUtilization.cpp b/test/hotspot/gtest/jfr/test_networkUtilization.cpp
--- a/test/hotspot/gtest/jfr/test_networkUtilization.cpp
+++ b/test/hotspot/gtest/jfr/test_networkUtilization.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -49,11 +49,11 @@
 #include <map>
 
 namespace {
 
   class MockFastUnorderedElapsedCounterSource : public ::FastUnorderedElapsedCounterSource {
-  public:
+   public:
     static jlong current_ticks;
     static Type now() {
       return current_ticks;
     }
     static uint64_t nanoseconds(Type value) {
@@ -63,11 +63,11 @@
 
   typedef TimeInstant<CounterRepresentation, MockFastUnorderedElapsedCounterSource> MockJfrTicks;
   typedef TimeInterval<CounterRepresentation, MockFastUnorderedElapsedCounterSource> MockJfrTickspan;
 
   class MockJfrCheckpointWriter {
-  public:
+   public:
     traceid current;
     std::map<traceid, std::string> ids;
 
     const JfrCheckpointContext context() const {
       return JfrCheckpointContext();
@@ -76,48 +76,101 @@
       return 0;
     }
     void write_key(traceid id) {
       current = id;
     }
-    void write(const char* data) {
-      ids[current] = data;
-    }
+    void write_type(JfrTypeId id) {}
+    MockJfrCheckpointWriter() {}
+    void write(const char* data) {}
     void set_context(const JfrCheckpointContext ctx) { }
-    void write_count(u4 nof_entries, jlong offset) { }
+    void write_count(u4 nof_entries) { }
   };
 
   class MockJfrSerializer {
-  public:
-    static MockJfrSerializer* current;
-
-    static bool register_serializer(JfrTypeId id, bool require_safepoint, bool permit_cache, MockJfrSerializer* serializer) {
-      current = serializer;
+   public:
+    static bool register_serializer(JfrTypeId id, bool permit_cache, MockJfrSerializer* serializer) {
       return true;
     }
+    virtual void on_rotation() {}
+    virtual void serialize(MockJfrCheckpointWriter& writer) {}
+  };
+
+  struct MockNetworkInterface {
+    std::string name;
+    uint64_t bytes_in;
+    uint64_t bytes_out;
+    traceid id;
+    MockNetworkInterface(std::string name, uint64_t bytes_in, uint64_t bytes_out, traceid id) :
+      name(name), bytes_in(bytes_in), bytes_out(bytes_out), id(id) {}
+
+    bool operator==(const MockNetworkInterface& rhs) const {
+      return name == rhs.name;
+    }
+  };
 
-    virtual void serialize(MockJfrCheckpointWriter& writer) = 0;
+  class NetworkInterface : public ::NetworkInterface {
+   public:
+    NetworkInterface(const char* name, uint64_t bytes_in, uint64_t bytes_out, NetworkInterface* next) :
+      ::NetworkInterface(name, bytes_in, bytes_out, next) {}
+    NetworkInterface* next(void) const {
+      return reinterpret_cast<NetworkInterface*>(::NetworkInterface::next());
+    }
+  };
+
+  class MockJfrOSInterface {
+    static std::list<MockNetworkInterface> _interfaces;
+   public:
+    MockJfrOSInterface() {}
+    static int network_utilization(NetworkInterface** network_interfaces) {
+      *network_interfaces = NULL;
+      for (std::list<MockNetworkInterface>::const_iterator i = _interfaces.begin();
+           i != _interfaces.end();
+           ++i) {
+        NetworkInterface* cur = new NetworkInterface(i->name.c_str(), i->bytes_in, i->bytes_out, *network_interfaces);
+        *network_interfaces = cur;
+      }
+      return OS_OK;
+    }
+    static MockNetworkInterface& add_interface(const std::string& name, traceid id) {
+      MockNetworkInterface iface(name, 0, 0, id);
+      _interfaces.push_front(iface);
+      return _interfaces.front();
+    }
+    static void remove_interface(const MockNetworkInterface& iface) {
+      _interfaces.remove(iface);
+    }
+    static void clear_interfaces() {
+      _interfaces.clear();
+    }
+    static const MockNetworkInterface& get_interface(traceid id) {
+      std::list<MockNetworkInterface>::const_iterator i = _interfaces.begin();
+      for (; i != _interfaces.end(); ++i) {
+        if (i->id == id) {
+          break;
+        }
+      }
+      return *i;
+    }
   };
 
-  MockJfrSerializer* MockJfrSerializer::current;
+  std::list<MockNetworkInterface> MockJfrOSInterface::_interfaces;
 
-  class MockEventNetworkUtilization : public ::EventNetworkUtilization
-  {
-  public:
+  class MockEventNetworkUtilization : public ::EventNetworkUtilization {
+   public:
     std::string iface;
     s8 readRate;
     s8 writeRate;
     static std::vector<MockEventNetworkUtilization> committed;
     MockJfrCheckpointWriter writer;
 
-  public:
+   public:
     MockEventNetworkUtilization(EventStartTime timing=TIMED) :
-    ::EventNetworkUtilization(timing) {
-    }
+    ::EventNetworkUtilization(timing) {}
 
     void set_networkInterface(traceid new_value) {
-      MockJfrSerializer::current->serialize(writer);
-      iface = writer.ids[new_value];
+      const MockNetworkInterface& entry  = MockJfrOSInterface::get_interface(new_value);
+      iface = entry.name;
     }
     void set_readRate(s8 new_value) {
       readRate = new_value;
     }
     void set_writeRate(s8 new_value) {
@@ -127,11 +180,10 @@
     void commit() {
       committed.push_back(*this);
     }
 
     void set_starttime(const MockJfrTicks& time) {}
-
     void set_endtime(const MockJfrTicks& time) {}
 
     static const MockEventNetworkUtilization& get_committed(const std::string& name) {
       static MockEventNetworkUtilization placeholder;
       for (std::vector<MockEventNetworkUtilization>::const_iterator i = committed.begin();
@@ -147,66 +199,10 @@
 
   std::vector<MockEventNetworkUtilization> MockEventNetworkUtilization::committed;
 
   jlong MockFastUnorderedElapsedCounterSource::current_ticks;
 
-  struct MockNetworkInterface {
-    std::string name;
-    uint64_t bytes_in;
-    uint64_t bytes_out;
-    MockNetworkInterface(std::string name, uint64_t bytes_in, uint64_t bytes_out)
-    : name(name),
-    bytes_in(bytes_in),
-    bytes_out(bytes_out) {
-
-    }
-    bool operator==(const MockNetworkInterface& rhs) const {
-      return name == rhs.name;
-    }
-  };
-
-  class NetworkInterface : public ::NetworkInterface {
-  public:
-    NetworkInterface(const char* name, uint64_t bytes_in, uint64_t bytes_out, NetworkInterface* next)
-    : ::NetworkInterface(name, bytes_in, bytes_out, next) {
-    }
-    NetworkInterface* next(void) const {
-      return reinterpret_cast<NetworkInterface*>(::NetworkInterface::next());
-    }
-  };
-
-  class MockJfrOSInterface {
-    static std::list<MockNetworkInterface> _interfaces;
-
-  public:
-    MockJfrOSInterface() {
-    }
-    static int network_utilization(NetworkInterface** network_interfaces) {
-      *network_interfaces = NULL;
-      for (std::list<MockNetworkInterface>::const_iterator i = _interfaces.begin();
-           i != _interfaces.end();
-           ++i) {
-        NetworkInterface* cur = new NetworkInterface(i->name.c_str(), i->bytes_in, i->bytes_out, *network_interfaces);
-        *network_interfaces = cur;
-      }
-      return OS_OK;
-    }
-    static MockNetworkInterface& add_interface(const std::string& name) {
-      MockNetworkInterface iface(name, 0, 0);
-      _interfaces.push_back(iface);
-      return _interfaces.back();
-    }
-    static void remove_interface(const MockNetworkInterface& iface) {
-      _interfaces.remove(iface);
-    }
-    static void clear_interfaces() {
-      _interfaces.clear();
-    }
-  };
-
-  std::list<MockNetworkInterface> MockJfrOSInterface::_interfaces;
-
 // Reincluding source files in the anonymous namespace unfortunately seems to
 // behave strangely with precompiled headers (only when using gcc though)
 #ifndef DONT_USE_PRECOMPILED_HEADER
 #define DONT_USE_PRECOMPILED_HEADER
 #endif
@@ -246,11 +242,11 @@
   }
 };
 
 TEST_VM_F(JfrTestNetworkUtilization, RequestFunctionBasic) {
 
-  MockNetworkInterface& eth0 = MockJfrOSInterface::add_interface("eth0");
+  MockNetworkInterface& eth0 = MockJfrOSInterface::add_interface("eth0", 1);
   JfrNetworkUtilization::send_events();
   ASSERT_EQ(0u, MockEventNetworkUtilization::committed.size());
 
   eth0.bytes_in += 10;
   MockFastUnorderedElapsedCounterSource::current_ticks += 2 * NANOSECS_PER_SEC;
@@ -263,13 +259,13 @@
   EXPECT_STREQ("eth0", e.iface.c_str());
 }
 
 TEST_VM_F(JfrTestNetworkUtilization, RequestFunctionMultiple) {
 
-  MockNetworkInterface& eth0 = MockJfrOSInterface::add_interface("eth0");
-  MockNetworkInterface& eth1 = MockJfrOSInterface::add_interface("eth1");
-  MockNetworkInterface& ppp0 = MockJfrOSInterface::add_interface("ppp0");
+  MockNetworkInterface& eth0 = MockJfrOSInterface::add_interface("eth0", 2);
+  MockNetworkInterface& eth1 = MockJfrOSInterface::add_interface("eth1", 3);
+  MockNetworkInterface& ppp0 = MockJfrOSInterface::add_interface("ppp0", 4);
   JfrNetworkUtilization::send_events();
   ASSERT_EQ(0u, MockEventNetworkUtilization::committed.size());
 
   eth0.bytes_in += 10;
   eth1.bytes_in += 100;
@@ -294,12 +290,12 @@
   EXPECT_EQ(200, ppp0_event.writeRate);
   EXPECT_STREQ("ppp0", ppp0_event.iface.c_str());
 }
 
 TEST_VM_F(JfrTestNetworkUtilization, InterfaceRemoved) {
-  MockNetworkInterface& eth0 = MockJfrOSInterface::add_interface("eth0");
-  MockNetworkInterface& eth1 = MockJfrOSInterface::add_interface("eth1");
+  MockNetworkInterface& eth0 = MockJfrOSInterface::add_interface("eth0", 5);
+  MockNetworkInterface& eth1 = MockJfrOSInterface::add_interface("eth1", 6);
   JfrNetworkUtilization::send_events();
   ASSERT_EQ(0u, MockEventNetworkUtilization::committed.size());
 
   eth0.bytes_in += 10;
   eth1.bytes_in += 20;
@@ -331,11 +327,11 @@
   EXPECT_EQ(0, eth1_event_v2.writeRate);
   EXPECT_STREQ("eth1", eth1_event_v2.iface.c_str());
 }
 
 TEST_VM_F(JfrTestNetworkUtilization, InterfaceReset) {
-  MockNetworkInterface& eth0 = MockJfrOSInterface::add_interface("eth0");
+  MockNetworkInterface& eth0 = MockJfrOSInterface::add_interface("eth0", 7);
   JfrNetworkUtilization::send_events();
   ASSERT_EQ(0u, MockEventNetworkUtilization::committed.size());
 
   eth0.bytes_in += 10;
   MockFastUnorderedElapsedCounterSource::current_ticks += 2 * NANOSECS_PER_SEC;

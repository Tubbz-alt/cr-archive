<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/gtest/jfr/test_networkUtilization.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../gtestMain.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="test_threadCpuLoad.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/gtest/jfr/test_networkUtilization.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 34 
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;jfr/jfrEvents.hpp&quot;
 37 #include &quot;jfr/metadata/jfrSerializer.hpp&quot;
 38 #include &quot;jfr/periodic/jfrOSInterface.hpp&quot;
 39 #include &quot;jfr/utilities/jfrTime.hpp&quot;
 40 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 41 #include &quot;runtime/os_perf.hpp&quot;
 42 #include &quot;utilities/globalDefinitions.hpp&quot;
 43 #include &quot;utilities/growableArray.hpp&quot;
 44 
 45 #include &quot;unittest.hpp&quot;
 46 
 47 #include &lt;vector&gt;
 48 #include &lt;list&gt;
 49 #include &lt;map&gt;
 50 
 51 namespace {
 52 
 53   class MockFastUnorderedElapsedCounterSource : public ::FastUnorderedElapsedCounterSource {
<span class="line-modified"> 54   public:</span>
 55     static jlong current_ticks;
 56     static Type now() {
 57       return current_ticks;
 58     }
 59     static uint64_t nanoseconds(Type value) {
 60       return value;
 61     }
 62   };
 63 
 64   typedef TimeInstant&lt;CounterRepresentation, MockFastUnorderedElapsedCounterSource&gt; MockJfrTicks;
 65   typedef TimeInterval&lt;CounterRepresentation, MockFastUnorderedElapsedCounterSource&gt; MockJfrTickspan;
 66 
 67   class MockJfrCheckpointWriter {
<span class="line-modified"> 68   public:</span>
 69     traceid current;
 70     std::map&lt;traceid, std::string&gt; ids;
 71 
 72     const JfrCheckpointContext context() const {
 73       return JfrCheckpointContext();
 74     }
 75     intptr_t reserve(size_t size) {
 76       return 0;
 77     }
 78     void write_key(traceid id) {
 79       current = id;
 80     }
<span class="line-modified"> 81     void write(const char* data) {</span>
<span class="line-modified"> 82       ids[current] = data;</span>
<span class="line-modified"> 83     }</span>
 84     void set_context(const JfrCheckpointContext ctx) { }
<span class="line-modified"> 85     void write_count(u4 nof_entries, jlong offset) { }</span>
 86   };
 87 
 88   class MockJfrSerializer {
<span class="line-modified"> 89   public:</span>
<span class="line-modified"> 90     static MockJfrSerializer* current;</span>
<span class="line-removed"> 91 </span>
<span class="line-removed"> 92     static bool register_serializer(JfrTypeId id, bool require_safepoint, bool permit_cache, MockJfrSerializer* serializer) {</span>
<span class="line-removed"> 93       current = serializer;</span>
 94       return true;
 95     }
















 96 
<span class="line-modified"> 97     virtual void serialize(MockJfrCheckpointWriter&amp; writer) = 0;</span>










































 98   };
 99 
<span class="line-modified">100   MockJfrSerializer* MockJfrSerializer::current;</span>
101 
<span class="line-modified">102   class MockEventNetworkUtilization : public ::EventNetworkUtilization</span>
<span class="line-modified">103   {</span>
<span class="line-removed">104   public:</span>
105     std::string iface;
106     s8 readRate;
107     s8 writeRate;
108     static std::vector&lt;MockEventNetworkUtilization&gt; committed;
109     MockJfrCheckpointWriter writer;
110 
<span class="line-modified">111   public:</span>
112     MockEventNetworkUtilization(EventStartTime timing=TIMED) :
<span class="line-modified">113     ::EventNetworkUtilization(timing) {</span>
<span class="line-removed">114     }</span>
115 
116     void set_networkInterface(traceid new_value) {
<span class="line-modified">117       MockJfrSerializer::current-&gt;serialize(writer);</span>
<span class="line-modified">118       iface = writer.ids[new_value];</span>
119     }
120     void set_readRate(s8 new_value) {
121       readRate = new_value;
122     }
123     void set_writeRate(s8 new_value) {
124       writeRate = new_value;
125     }
126 
127     void commit() {
128       committed.push_back(*this);
129     }
130 
131     void set_starttime(const MockJfrTicks&amp; time) {}
<span class="line-removed">132 </span>
133     void set_endtime(const MockJfrTicks&amp; time) {}
134 
135     static const MockEventNetworkUtilization&amp; get_committed(const std::string&amp; name) {
136       static MockEventNetworkUtilization placeholder;
137       for (std::vector&lt;MockEventNetworkUtilization&gt;::const_iterator i = committed.begin();
138            i != committed.end();
139            ++i) {
140         if (name == i-&gt;iface) {
141           return *i;
142         }
143       }
144       return placeholder;
145     }
146   };
147 
148   std::vector&lt;MockEventNetworkUtilization&gt; MockEventNetworkUtilization::committed;
149 
150   jlong MockFastUnorderedElapsedCounterSource::current_ticks;
151 
<span class="line-removed">152   struct MockNetworkInterface {</span>
<span class="line-removed">153     std::string name;</span>
<span class="line-removed">154     uint64_t bytes_in;</span>
<span class="line-removed">155     uint64_t bytes_out;</span>
<span class="line-removed">156     MockNetworkInterface(std::string name, uint64_t bytes_in, uint64_t bytes_out)</span>
<span class="line-removed">157     : name(name),</span>
<span class="line-removed">158     bytes_in(bytes_in),</span>
<span class="line-removed">159     bytes_out(bytes_out) {</span>
<span class="line-removed">160 </span>
<span class="line-removed">161     }</span>
<span class="line-removed">162     bool operator==(const MockNetworkInterface&amp; rhs) const {</span>
<span class="line-removed">163       return name == rhs.name;</span>
<span class="line-removed">164     }</span>
<span class="line-removed">165   };</span>
<span class="line-removed">166 </span>
<span class="line-removed">167   class NetworkInterface : public ::NetworkInterface {</span>
<span class="line-removed">168   public:</span>
<span class="line-removed">169     NetworkInterface(const char* name, uint64_t bytes_in, uint64_t bytes_out, NetworkInterface* next)</span>
<span class="line-removed">170     : ::NetworkInterface(name, bytes_in, bytes_out, next) {</span>
<span class="line-removed">171     }</span>
<span class="line-removed">172     NetworkInterface* next(void) const {</span>
<span class="line-removed">173       return reinterpret_cast&lt;NetworkInterface*&gt;(::NetworkInterface::next());</span>
<span class="line-removed">174     }</span>
<span class="line-removed">175   };</span>
<span class="line-removed">176 </span>
<span class="line-removed">177   class MockJfrOSInterface {</span>
<span class="line-removed">178     static std::list&lt;MockNetworkInterface&gt; _interfaces;</span>
<span class="line-removed">179 </span>
<span class="line-removed">180   public:</span>
<span class="line-removed">181     MockJfrOSInterface() {</span>
<span class="line-removed">182     }</span>
<span class="line-removed">183     static int network_utilization(NetworkInterface** network_interfaces) {</span>
<span class="line-removed">184       *network_interfaces = NULL;</span>
<span class="line-removed">185       for (std::list&lt;MockNetworkInterface&gt;::const_iterator i = _interfaces.begin();</span>
<span class="line-removed">186            i != _interfaces.end();</span>
<span class="line-removed">187            ++i) {</span>
<span class="line-removed">188         NetworkInterface* cur = new NetworkInterface(i-&gt;name.c_str(), i-&gt;bytes_in, i-&gt;bytes_out, *network_interfaces);</span>
<span class="line-removed">189         *network_interfaces = cur;</span>
<span class="line-removed">190       }</span>
<span class="line-removed">191       return OS_OK;</span>
<span class="line-removed">192     }</span>
<span class="line-removed">193     static MockNetworkInterface&amp; add_interface(const std::string&amp; name) {</span>
<span class="line-removed">194       MockNetworkInterface iface(name, 0, 0);</span>
<span class="line-removed">195       _interfaces.push_back(iface);</span>
<span class="line-removed">196       return _interfaces.back();</span>
<span class="line-removed">197     }</span>
<span class="line-removed">198     static void remove_interface(const MockNetworkInterface&amp; iface) {</span>
<span class="line-removed">199       _interfaces.remove(iface);</span>
<span class="line-removed">200     }</span>
<span class="line-removed">201     static void clear_interfaces() {</span>
<span class="line-removed">202       _interfaces.clear();</span>
<span class="line-removed">203     }</span>
<span class="line-removed">204   };</span>
<span class="line-removed">205 </span>
<span class="line-removed">206   std::list&lt;MockNetworkInterface&gt; MockJfrOSInterface::_interfaces;</span>
<span class="line-removed">207 </span>
208 // Reincluding source files in the anonymous namespace unfortunately seems to
209 // behave strangely with precompiled headers (only when using gcc though)
210 #ifndef DONT_USE_PRECOMPILED_HEADER
211 #define DONT_USE_PRECOMPILED_HEADER
212 #endif
213 
214 #define EventNetworkUtilization MockEventNetworkUtilization
215 #define FastUnorderedElapsedCounterSource MockFastUnorderedElapsedCounterSource
216 #define JfrOSInterface MockJfrOSInterface
217 #define JfrSerializer MockJfrSerializer
218 #define JfrCheckpointWriter MockJfrCheckpointWriter
219 #define JfrTicks MockJfrTicks
220 #define JfrTickspan MockJfrTickspan
221 
222 #include &quot;jfr/periodic/jfrNetworkUtilization.hpp&quot;
223 #include &quot;jfr/periodic/jfrNetworkUtilization.cpp&quot;
224 
225 #undef EventNetworkUtilization
226 #undef FastUnorderedElapsedCounterSource
227 #undef JfrOSInterface
</pre>
<hr />
<pre>
231 #undef JfrTickspan
232 
233 } // anonymous namespace
234 
235 class JfrTestNetworkUtilization : public ::testing::Test {
236 protected:
237   void SetUp() {
238     MockEventNetworkUtilization::committed.clear();
239     MockJfrOSInterface::clear_interfaces();
240     // Ensure that tests are separated in time
241     MockFastUnorderedElapsedCounterSource::current_ticks += 1 * NANOSECS_PER_SEC;
242   }
243 
244   void TearDown() {
245     JfrNetworkUtilization::destroy();
246   }
247 };
248 
249 TEST_VM_F(JfrTestNetworkUtilization, RequestFunctionBasic) {
250 
<span class="line-modified">251   MockNetworkInterface&amp; eth0 = MockJfrOSInterface::add_interface(&quot;eth0&quot;);</span>
252   JfrNetworkUtilization::send_events();
253   ASSERT_EQ(0u, MockEventNetworkUtilization::committed.size());
254 
255   eth0.bytes_in += 10;
256   MockFastUnorderedElapsedCounterSource::current_ticks += 2 * NANOSECS_PER_SEC;
257 
258   JfrNetworkUtilization::send_events();
259   ASSERT_EQ(1u, MockEventNetworkUtilization::committed.size());
260   MockEventNetworkUtilization&amp; e = MockEventNetworkUtilization::committed[0];
261   EXPECT_EQ(40, e.readRate);
262   EXPECT_EQ(0, e.writeRate);
263   EXPECT_STREQ(&quot;eth0&quot;, e.iface.c_str());
264 }
265 
266 TEST_VM_F(JfrTestNetworkUtilization, RequestFunctionMultiple) {
267 
<span class="line-modified">268   MockNetworkInterface&amp; eth0 = MockJfrOSInterface::add_interface(&quot;eth0&quot;);</span>
<span class="line-modified">269   MockNetworkInterface&amp; eth1 = MockJfrOSInterface::add_interface(&quot;eth1&quot;);</span>
<span class="line-modified">270   MockNetworkInterface&amp; ppp0 = MockJfrOSInterface::add_interface(&quot;ppp0&quot;);</span>
271   JfrNetworkUtilization::send_events();
272   ASSERT_EQ(0u, MockEventNetworkUtilization::committed.size());
273 
274   eth0.bytes_in += 10;
275   eth1.bytes_in += 100;
276   ppp0.bytes_out += 50;
277   MockFastUnorderedElapsedCounterSource::current_ticks += 2 * NANOSECS_PER_SEC;
278 
279   JfrNetworkUtilization::send_events();
280   ASSERT_EQ(3u, MockEventNetworkUtilization::committed.size());
281   const MockEventNetworkUtilization&amp; eth0_event = MockEventNetworkUtilization::get_committed(&quot;eth0&quot;);
282   const MockEventNetworkUtilization&amp; eth1_event = MockEventNetworkUtilization::get_committed(&quot;eth1&quot;);
283   const MockEventNetworkUtilization&amp; ppp0_event = MockEventNetworkUtilization::get_committed(&quot;ppp0&quot;);
284 
285   EXPECT_EQ(40, eth0_event.readRate);
286   EXPECT_EQ(0, eth0_event.writeRate);
287   EXPECT_STREQ(&quot;eth0&quot;, eth0_event.iface.c_str());
288 
289   EXPECT_EQ(400, eth1_event.readRate);
290   EXPECT_EQ(0, eth1_event.writeRate);
291   EXPECT_STREQ(&quot;eth1&quot;, eth1_event.iface.c_str());
292 
293   EXPECT_EQ(0, ppp0_event.readRate);
294   EXPECT_EQ(200, ppp0_event.writeRate);
295   EXPECT_STREQ(&quot;ppp0&quot;, ppp0_event.iface.c_str());
296 }
297 
298 TEST_VM_F(JfrTestNetworkUtilization, InterfaceRemoved) {
<span class="line-modified">299   MockNetworkInterface&amp; eth0 = MockJfrOSInterface::add_interface(&quot;eth0&quot;);</span>
<span class="line-modified">300   MockNetworkInterface&amp; eth1 = MockJfrOSInterface::add_interface(&quot;eth1&quot;);</span>
301   JfrNetworkUtilization::send_events();
302   ASSERT_EQ(0u, MockEventNetworkUtilization::committed.size());
303 
304   eth0.bytes_in += 10;
305   eth1.bytes_in += 20;
306   MockFastUnorderedElapsedCounterSource::current_ticks += 2 * NANOSECS_PER_SEC;
307 
308   JfrNetworkUtilization::send_events();
309   ASSERT_EQ(2u, MockEventNetworkUtilization::committed.size());
310   const MockEventNetworkUtilization&amp; eth0_event = MockEventNetworkUtilization::get_committed(&quot;eth0&quot;);
311   const MockEventNetworkUtilization&amp; eth1_event = MockEventNetworkUtilization::get_committed(&quot;eth1&quot;);
312 
313   EXPECT_EQ(40, eth0_event.readRate);
314   EXPECT_EQ(0, eth0_event.writeRate);
315   EXPECT_STREQ(&quot;eth0&quot;, eth0_event.iface.c_str());
316 
317   EXPECT_EQ(80, eth1_event.readRate);
318   EXPECT_EQ(0, eth1_event.writeRate);
319   EXPECT_STREQ(&quot;eth1&quot;, eth1_event.iface.c_str());
320 
321   MockJfrOSInterface::remove_interface(eth0);
322   MockEventNetworkUtilization::committed.clear();
323 
324   eth1.bytes_in += 10;
325   MockFastUnorderedElapsedCounterSource::current_ticks += 2 * NANOSECS_PER_SEC;
326   JfrNetworkUtilization::send_events();
327   ASSERT_EQ(1u, MockEventNetworkUtilization::committed.size());
328   const MockEventNetworkUtilization&amp; eth1_event_v2 = MockEventNetworkUtilization::get_committed(&quot;eth1&quot;);
329 
330   EXPECT_EQ(40, eth1_event_v2.readRate);
331   EXPECT_EQ(0, eth1_event_v2.writeRate);
332   EXPECT_STREQ(&quot;eth1&quot;, eth1_event_v2.iface.c_str());
333 }
334 
335 TEST_VM_F(JfrTestNetworkUtilization, InterfaceReset) {
<span class="line-modified">336   MockNetworkInterface&amp; eth0 = MockJfrOSInterface::add_interface(&quot;eth0&quot;);</span>
337   JfrNetworkUtilization::send_events();
338   ASSERT_EQ(0u, MockEventNetworkUtilization::committed.size());
339 
340   eth0.bytes_in += 10;
341   MockFastUnorderedElapsedCounterSource::current_ticks += 2 * NANOSECS_PER_SEC;
342 
343   JfrNetworkUtilization::send_events();
344   ASSERT_EQ(1u, MockEventNetworkUtilization::committed.size());
345   const MockEventNetworkUtilization&amp; event = MockEventNetworkUtilization::committed[0];
346   EXPECT_EQ(40, event.readRate);
347   EXPECT_EQ(0, event.writeRate);
348   EXPECT_STREQ(&quot;eth0&quot;, event.iface.c_str());
349 
350   eth0.bytes_in = 0;
351   MockFastUnorderedElapsedCounterSource::current_ticks += 2 * NANOSECS_PER_SEC;
352   MockEventNetworkUtilization::committed.clear();
353 
354   JfrNetworkUtilization::send_events();
355   ASSERT_EQ(0u, MockEventNetworkUtilization::committed.size());
356 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 34 
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;jfr/jfrEvents.hpp&quot;
 37 #include &quot;jfr/metadata/jfrSerializer.hpp&quot;
 38 #include &quot;jfr/periodic/jfrOSInterface.hpp&quot;
 39 #include &quot;jfr/utilities/jfrTime.hpp&quot;
 40 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 41 #include &quot;runtime/os_perf.hpp&quot;
 42 #include &quot;utilities/globalDefinitions.hpp&quot;
 43 #include &quot;utilities/growableArray.hpp&quot;
 44 
 45 #include &quot;unittest.hpp&quot;
 46 
 47 #include &lt;vector&gt;
 48 #include &lt;list&gt;
 49 #include &lt;map&gt;
 50 
 51 namespace {
 52 
 53   class MockFastUnorderedElapsedCounterSource : public ::FastUnorderedElapsedCounterSource {
<span class="line-modified"> 54    public:</span>
 55     static jlong current_ticks;
 56     static Type now() {
 57       return current_ticks;
 58     }
 59     static uint64_t nanoseconds(Type value) {
 60       return value;
 61     }
 62   };
 63 
 64   typedef TimeInstant&lt;CounterRepresentation, MockFastUnorderedElapsedCounterSource&gt; MockJfrTicks;
 65   typedef TimeInterval&lt;CounterRepresentation, MockFastUnorderedElapsedCounterSource&gt; MockJfrTickspan;
 66 
 67   class MockJfrCheckpointWriter {
<span class="line-modified"> 68    public:</span>
 69     traceid current;
 70     std::map&lt;traceid, std::string&gt; ids;
 71 
 72     const JfrCheckpointContext context() const {
 73       return JfrCheckpointContext();
 74     }
 75     intptr_t reserve(size_t size) {
 76       return 0;
 77     }
 78     void write_key(traceid id) {
 79       current = id;
 80     }
<span class="line-modified"> 81     void write_type(JfrTypeId id) {}</span>
<span class="line-modified"> 82     MockJfrCheckpointWriter() {}</span>
<span class="line-modified"> 83     void write(const char* data) {}</span>
 84     void set_context(const JfrCheckpointContext ctx) { }
<span class="line-modified"> 85     void write_count(u4 nof_entries) { }</span>
 86   };
 87 
 88   class MockJfrSerializer {
<span class="line-modified"> 89    public:</span>
<span class="line-modified"> 90     static bool register_serializer(JfrTypeId id, bool permit_cache, MockJfrSerializer* serializer) {</span>



 91       return true;
 92     }
<span class="line-added"> 93     virtual void on_rotation() {}</span>
<span class="line-added"> 94     virtual void serialize(MockJfrCheckpointWriter&amp; writer) {}</span>
<span class="line-added"> 95   };</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97   struct MockNetworkInterface {</span>
<span class="line-added"> 98     std::string name;</span>
<span class="line-added"> 99     uint64_t bytes_in;</span>
<span class="line-added">100     uint64_t bytes_out;</span>
<span class="line-added">101     traceid id;</span>
<span class="line-added">102     MockNetworkInterface(std::string name, uint64_t bytes_in, uint64_t bytes_out, traceid id) :</span>
<span class="line-added">103       name(name), bytes_in(bytes_in), bytes_out(bytes_out), id(id) {}</span>
<span class="line-added">104 </span>
<span class="line-added">105     bool operator==(const MockNetworkInterface&amp; rhs) const {</span>
<span class="line-added">106       return name == rhs.name;</span>
<span class="line-added">107     }</span>
<span class="line-added">108   };</span>
109 
<span class="line-modified">110   class NetworkInterface : public ::NetworkInterface {</span>
<span class="line-added">111    public:</span>
<span class="line-added">112     NetworkInterface(const char* name, uint64_t bytes_in, uint64_t bytes_out, NetworkInterface* next) :</span>
<span class="line-added">113       ::NetworkInterface(name, bytes_in, bytes_out, next) {}</span>
<span class="line-added">114     NetworkInterface* next(void) const {</span>
<span class="line-added">115       return reinterpret_cast&lt;NetworkInterface*&gt;(::NetworkInterface::next());</span>
<span class="line-added">116     }</span>
<span class="line-added">117   };</span>
<span class="line-added">118 </span>
<span class="line-added">119   class MockJfrOSInterface {</span>
<span class="line-added">120     static std::list&lt;MockNetworkInterface&gt; _interfaces;</span>
<span class="line-added">121    public:</span>
<span class="line-added">122     MockJfrOSInterface() {}</span>
<span class="line-added">123     static int network_utilization(NetworkInterface** network_interfaces) {</span>
<span class="line-added">124       *network_interfaces = NULL;</span>
<span class="line-added">125       for (std::list&lt;MockNetworkInterface&gt;::const_iterator i = _interfaces.begin();</span>
<span class="line-added">126            i != _interfaces.end();</span>
<span class="line-added">127            ++i) {</span>
<span class="line-added">128         NetworkInterface* cur = new NetworkInterface(i-&gt;name.c_str(), i-&gt;bytes_in, i-&gt;bytes_out, *network_interfaces);</span>
<span class="line-added">129         *network_interfaces = cur;</span>
<span class="line-added">130       }</span>
<span class="line-added">131       return OS_OK;</span>
<span class="line-added">132     }</span>
<span class="line-added">133     static MockNetworkInterface&amp; add_interface(const std::string&amp; name, traceid id) {</span>
<span class="line-added">134       MockNetworkInterface iface(name, 0, 0, id);</span>
<span class="line-added">135       _interfaces.push_front(iface);</span>
<span class="line-added">136       return _interfaces.front();</span>
<span class="line-added">137     }</span>
<span class="line-added">138     static void remove_interface(const MockNetworkInterface&amp; iface) {</span>
<span class="line-added">139       _interfaces.remove(iface);</span>
<span class="line-added">140     }</span>
<span class="line-added">141     static void clear_interfaces() {</span>
<span class="line-added">142       _interfaces.clear();</span>
<span class="line-added">143     }</span>
<span class="line-added">144     static const MockNetworkInterface&amp; get_interface(traceid id) {</span>
<span class="line-added">145       std::list&lt;MockNetworkInterface&gt;::const_iterator i = _interfaces.begin();</span>
<span class="line-added">146       for (; i != _interfaces.end(); ++i) {</span>
<span class="line-added">147         if (i-&gt;id == id) {</span>
<span class="line-added">148           break;</span>
<span class="line-added">149         }</span>
<span class="line-added">150       }</span>
<span class="line-added">151       return *i;</span>
<span class="line-added">152     }</span>
153   };
154 
<span class="line-modified">155   std::list&lt;MockNetworkInterface&gt; MockJfrOSInterface::_interfaces;</span>
156 
<span class="line-modified">157   class MockEventNetworkUtilization : public ::EventNetworkUtilization {</span>
<span class="line-modified">158    public:</span>

159     std::string iface;
160     s8 readRate;
161     s8 writeRate;
162     static std::vector&lt;MockEventNetworkUtilization&gt; committed;
163     MockJfrCheckpointWriter writer;
164 
<span class="line-modified">165    public:</span>
166     MockEventNetworkUtilization(EventStartTime timing=TIMED) :
<span class="line-modified">167     ::EventNetworkUtilization(timing) {}</span>

168 
169     void set_networkInterface(traceid new_value) {
<span class="line-modified">170       const MockNetworkInterface&amp; entry  = MockJfrOSInterface::get_interface(new_value);</span>
<span class="line-modified">171       iface = entry.name;</span>
172     }
173     void set_readRate(s8 new_value) {
174       readRate = new_value;
175     }
176     void set_writeRate(s8 new_value) {
177       writeRate = new_value;
178     }
179 
180     void commit() {
181       committed.push_back(*this);
182     }
183 
184     void set_starttime(const MockJfrTicks&amp; time) {}

185     void set_endtime(const MockJfrTicks&amp; time) {}
186 
187     static const MockEventNetworkUtilization&amp; get_committed(const std::string&amp; name) {
188       static MockEventNetworkUtilization placeholder;
189       for (std::vector&lt;MockEventNetworkUtilization&gt;::const_iterator i = committed.begin();
190            i != committed.end();
191            ++i) {
192         if (name == i-&gt;iface) {
193           return *i;
194         }
195       }
196       return placeholder;
197     }
198   };
199 
200   std::vector&lt;MockEventNetworkUtilization&gt; MockEventNetworkUtilization::committed;
201 
202   jlong MockFastUnorderedElapsedCounterSource::current_ticks;
203 
























































204 // Reincluding source files in the anonymous namespace unfortunately seems to
205 // behave strangely with precompiled headers (only when using gcc though)
206 #ifndef DONT_USE_PRECOMPILED_HEADER
207 #define DONT_USE_PRECOMPILED_HEADER
208 #endif
209 
210 #define EventNetworkUtilization MockEventNetworkUtilization
211 #define FastUnorderedElapsedCounterSource MockFastUnorderedElapsedCounterSource
212 #define JfrOSInterface MockJfrOSInterface
213 #define JfrSerializer MockJfrSerializer
214 #define JfrCheckpointWriter MockJfrCheckpointWriter
215 #define JfrTicks MockJfrTicks
216 #define JfrTickspan MockJfrTickspan
217 
218 #include &quot;jfr/periodic/jfrNetworkUtilization.hpp&quot;
219 #include &quot;jfr/periodic/jfrNetworkUtilization.cpp&quot;
220 
221 #undef EventNetworkUtilization
222 #undef FastUnorderedElapsedCounterSource
223 #undef JfrOSInterface
</pre>
<hr />
<pre>
227 #undef JfrTickspan
228 
229 } // anonymous namespace
230 
231 class JfrTestNetworkUtilization : public ::testing::Test {
232 protected:
233   void SetUp() {
234     MockEventNetworkUtilization::committed.clear();
235     MockJfrOSInterface::clear_interfaces();
236     // Ensure that tests are separated in time
237     MockFastUnorderedElapsedCounterSource::current_ticks += 1 * NANOSECS_PER_SEC;
238   }
239 
240   void TearDown() {
241     JfrNetworkUtilization::destroy();
242   }
243 };
244 
245 TEST_VM_F(JfrTestNetworkUtilization, RequestFunctionBasic) {
246 
<span class="line-modified">247   MockNetworkInterface&amp; eth0 = MockJfrOSInterface::add_interface(&quot;eth0&quot;, 1);</span>
248   JfrNetworkUtilization::send_events();
249   ASSERT_EQ(0u, MockEventNetworkUtilization::committed.size());
250 
251   eth0.bytes_in += 10;
252   MockFastUnorderedElapsedCounterSource::current_ticks += 2 * NANOSECS_PER_SEC;
253 
254   JfrNetworkUtilization::send_events();
255   ASSERT_EQ(1u, MockEventNetworkUtilization::committed.size());
256   MockEventNetworkUtilization&amp; e = MockEventNetworkUtilization::committed[0];
257   EXPECT_EQ(40, e.readRate);
258   EXPECT_EQ(0, e.writeRate);
259   EXPECT_STREQ(&quot;eth0&quot;, e.iface.c_str());
260 }
261 
262 TEST_VM_F(JfrTestNetworkUtilization, RequestFunctionMultiple) {
263 
<span class="line-modified">264   MockNetworkInterface&amp; eth0 = MockJfrOSInterface::add_interface(&quot;eth0&quot;, 2);</span>
<span class="line-modified">265   MockNetworkInterface&amp; eth1 = MockJfrOSInterface::add_interface(&quot;eth1&quot;, 3);</span>
<span class="line-modified">266   MockNetworkInterface&amp; ppp0 = MockJfrOSInterface::add_interface(&quot;ppp0&quot;, 4);</span>
267   JfrNetworkUtilization::send_events();
268   ASSERT_EQ(0u, MockEventNetworkUtilization::committed.size());
269 
270   eth0.bytes_in += 10;
271   eth1.bytes_in += 100;
272   ppp0.bytes_out += 50;
273   MockFastUnorderedElapsedCounterSource::current_ticks += 2 * NANOSECS_PER_SEC;
274 
275   JfrNetworkUtilization::send_events();
276   ASSERT_EQ(3u, MockEventNetworkUtilization::committed.size());
277   const MockEventNetworkUtilization&amp; eth0_event = MockEventNetworkUtilization::get_committed(&quot;eth0&quot;);
278   const MockEventNetworkUtilization&amp; eth1_event = MockEventNetworkUtilization::get_committed(&quot;eth1&quot;);
279   const MockEventNetworkUtilization&amp; ppp0_event = MockEventNetworkUtilization::get_committed(&quot;ppp0&quot;);
280 
281   EXPECT_EQ(40, eth0_event.readRate);
282   EXPECT_EQ(0, eth0_event.writeRate);
283   EXPECT_STREQ(&quot;eth0&quot;, eth0_event.iface.c_str());
284 
285   EXPECT_EQ(400, eth1_event.readRate);
286   EXPECT_EQ(0, eth1_event.writeRate);
287   EXPECT_STREQ(&quot;eth1&quot;, eth1_event.iface.c_str());
288 
289   EXPECT_EQ(0, ppp0_event.readRate);
290   EXPECT_EQ(200, ppp0_event.writeRate);
291   EXPECT_STREQ(&quot;ppp0&quot;, ppp0_event.iface.c_str());
292 }
293 
294 TEST_VM_F(JfrTestNetworkUtilization, InterfaceRemoved) {
<span class="line-modified">295   MockNetworkInterface&amp; eth0 = MockJfrOSInterface::add_interface(&quot;eth0&quot;, 5);</span>
<span class="line-modified">296   MockNetworkInterface&amp; eth1 = MockJfrOSInterface::add_interface(&quot;eth1&quot;, 6);</span>
297   JfrNetworkUtilization::send_events();
298   ASSERT_EQ(0u, MockEventNetworkUtilization::committed.size());
299 
300   eth0.bytes_in += 10;
301   eth1.bytes_in += 20;
302   MockFastUnorderedElapsedCounterSource::current_ticks += 2 * NANOSECS_PER_SEC;
303 
304   JfrNetworkUtilization::send_events();
305   ASSERT_EQ(2u, MockEventNetworkUtilization::committed.size());
306   const MockEventNetworkUtilization&amp; eth0_event = MockEventNetworkUtilization::get_committed(&quot;eth0&quot;);
307   const MockEventNetworkUtilization&amp; eth1_event = MockEventNetworkUtilization::get_committed(&quot;eth1&quot;);
308 
309   EXPECT_EQ(40, eth0_event.readRate);
310   EXPECT_EQ(0, eth0_event.writeRate);
311   EXPECT_STREQ(&quot;eth0&quot;, eth0_event.iface.c_str());
312 
313   EXPECT_EQ(80, eth1_event.readRate);
314   EXPECT_EQ(0, eth1_event.writeRate);
315   EXPECT_STREQ(&quot;eth1&quot;, eth1_event.iface.c_str());
316 
317   MockJfrOSInterface::remove_interface(eth0);
318   MockEventNetworkUtilization::committed.clear();
319 
320   eth1.bytes_in += 10;
321   MockFastUnorderedElapsedCounterSource::current_ticks += 2 * NANOSECS_PER_SEC;
322   JfrNetworkUtilization::send_events();
323   ASSERT_EQ(1u, MockEventNetworkUtilization::committed.size());
324   const MockEventNetworkUtilization&amp; eth1_event_v2 = MockEventNetworkUtilization::get_committed(&quot;eth1&quot;);
325 
326   EXPECT_EQ(40, eth1_event_v2.readRate);
327   EXPECT_EQ(0, eth1_event_v2.writeRate);
328   EXPECT_STREQ(&quot;eth1&quot;, eth1_event_v2.iface.c_str());
329 }
330 
331 TEST_VM_F(JfrTestNetworkUtilization, InterfaceReset) {
<span class="line-modified">332   MockNetworkInterface&amp; eth0 = MockJfrOSInterface::add_interface(&quot;eth0&quot;, 7);</span>
333   JfrNetworkUtilization::send_events();
334   ASSERT_EQ(0u, MockEventNetworkUtilization::committed.size());
335 
336   eth0.bytes_in += 10;
337   MockFastUnorderedElapsedCounterSource::current_ticks += 2 * NANOSECS_PER_SEC;
338 
339   JfrNetworkUtilization::send_events();
340   ASSERT_EQ(1u, MockEventNetworkUtilization::committed.size());
341   const MockEventNetworkUtilization&amp; event = MockEventNetworkUtilization::committed[0];
342   EXPECT_EQ(40, event.readRate);
343   EXPECT_EQ(0, event.writeRate);
344   EXPECT_STREQ(&quot;eth0&quot;, event.iface.c_str());
345 
346   eth0.bytes_in = 0;
347   MockFastUnorderedElapsedCounterSource::current_ticks += 2 * NANOSECS_PER_SEC;
348   MockEventNetworkUtilization::committed.clear();
349 
350   JfrNetworkUtilization::send_events();
351   ASSERT_EQ(0u, MockEventNetworkUtilization::committed.size());
352 
</pre>
</td>
</tr>
</table>
<center><a href="../gtestMain.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="test_threadCpuLoad.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
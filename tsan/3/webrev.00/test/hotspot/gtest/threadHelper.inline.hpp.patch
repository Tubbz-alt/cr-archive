diff a/test/hotspot/gtest/threadHelper.inline.hpp b/test/hotspot/gtest/threadHelper.inline.hpp
--- a/test/hotspot/gtest/threadHelper.inline.hpp
+++ b/test/hotspot/gtest/threadHelper.inline.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -36,12 +36,11 @@
   Semaphore* _running;
   Semaphore* _test_complete;
   VM_StopSafepoint(Semaphore* running, Semaphore* wait_for) :
     _running(running), _test_complete(wait_for) {}
   VMOp_Type type() const          { return VMOp_None; }
-  Mode evaluation_mode() const    { return _no_safepoint; }
-  bool is_cheap_allocated() const { return false; }
+  bool evaluate_at_safepoint() const { return false; }
   void doit()                     { _running->signal(); _test_complete->wait(); }
 };
 
 // This class and thread keep the non-safepoint op running while we do our testing.
 class VMThreadBlocker : public JavaThread {
@@ -64,11 +63,11 @@
   }
 
   // Override as JavaThread::post_run() calls JavaThread::exit which
   // expects a valid thread object oop.
   virtual void post_run() {
-    Threads::remove(this);
+    Threads::remove(this, false);
     this->smr_delete();
   }
 
   void doit() {
     if (os::create_thread(this, os::os_thread)) {
@@ -103,11 +102,11 @@
     {
       MutexLocker ml(Threads_lock);
       Threads::add(this);
     }
     {
-      MutexLockerEx ml(SR_lock(), Mutex::_no_safepoint_check_flag);
+      MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);
     }
   }
 
   virtual void main_run() = 0;
 
@@ -116,11 +115,11 @@
   }
 
   // Override as JavaThread::post_run() calls JavaThread::exit which
   // expects a valid thread object oop. And we need to call signal.
   void post_run() {
-    Threads::remove(this);
+    Threads::remove(this, false);
     _post->signal();
     this->smr_delete();
   }
 
   void doit() {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/gtest/runtime/test_os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #ifdef LINUX
 27 
 28 #include &lt;sys/mman.h&gt;
 29 
<a name="1" id="anc1"></a><span class="line-added"> 30 #include &quot;runtime/globals.hpp&quot;</span>
 31 #include &quot;runtime/os.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 32 #include &quot;utilities/align.hpp&quot;</span>
 33 #include &quot;unittest.hpp&quot;
 34 
 35 namespace {
 36   static void small_page_write(void* addr, size_t size) {
 37     size_t page_size = os::vm_page_size();
 38 
 39     char* end = (char*)addr + size;
 40     for (char* p = (char*)addr; p &lt; end; p += page_size) {
 41       *p = 1;
 42     }
 43   }
 44 
 45   class HugeTlbfsMemory : private ::os::Linux {
 46     char* const _ptr;
 47     const size_t _size;
 48    public:
 49     static char* reserve_memory_special_huge_tlbfs_only(size_t bytes, char* req_addr, bool exec) {
 50       return os::Linux::reserve_memory_special_huge_tlbfs_only(bytes, req_addr, exec);
 51     }
 52     static char* reserve_memory_special_huge_tlbfs_mixed(size_t bytes, size_t alignment, char* req_addr, bool exec) {
 53       return os::Linux::reserve_memory_special_huge_tlbfs_mixed(bytes, alignment, req_addr, exec);
 54     }
 55     HugeTlbfsMemory(char* const ptr, size_t size) : _ptr(ptr), _size(size) { }
 56     ~HugeTlbfsMemory() {
 57       if (_ptr != NULL) {
 58         os::Linux::release_memory_special_huge_tlbfs(_ptr, _size);
 59       }
 60     }
 61   };
 62 
 63   class ShmMemory : private ::os::Linux {
 64     char* const _ptr;
 65     const size_t _size;
 66    public:
 67     static char* reserve_memory_special_shm(size_t bytes, size_t alignment, char* req_addr, bool exec) {
 68       return os::Linux::reserve_memory_special_shm(bytes, alignment, req_addr, exec);
 69     }
 70     ShmMemory(char* const ptr, size_t size) : _ptr(ptr), _size(size) { }
 71     ~ShmMemory() {
 72       os::Linux::release_memory_special_shm(_ptr, _size);
 73     }
 74   };
 75 
 76   // have to use these functions, as gtest&#39;s _PRED macros don&#39;t like is_aligned
 77   // nor (is_aligned&lt;size_t, size_t&gt;)
 78   static bool is_size_aligned(size_t size, size_t alignment) {
 79     return is_aligned(size, alignment);
 80   }
 81   static bool is_ptr_aligned(char* ptr, size_t alignment) {
 82     return is_aligned(ptr, alignment);
 83   }
 84 
 85   static void test_reserve_memory_special_shm(size_t size, size_t alignment) {
 86     ASSERT_TRUE(UseSHM) &lt;&lt; &quot;must be used only when UseSHM is true&quot;;
 87     char* addr = ShmMemory::reserve_memory_special_shm(size, alignment, NULL, false);
 88     if (addr != NULL) {
 89       ShmMemory mr(addr, size);
 90       EXPECT_PRED2(is_ptr_aligned, addr, alignment);
 91       EXPECT_PRED2(is_ptr_aligned, addr, os::large_page_size());
 92 
 93       small_page_write(addr, size);
 94     }
 95   }
 96 }
 97 
 98 TEST_VM(os_linux, reserve_memory_special_huge_tlbfs_only) {
 99   if (!UseHugeTLBFS) {
100     return;
101   }
102   size_t lp = os::large_page_size();
103 
104   for (size_t size = lp; size &lt;= lp * 10; size += lp) {
105     char* addr = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs_only(size, NULL, false);
106 
107     if (addr != NULL) {
108       HugeTlbfsMemory mr(addr, size);
109       small_page_write(addr, size);
110     }
111   }
112 }
113 
114 TEST_VM(os_linux, reserve_memory_special_huge_tlbfs_mixed_without_addr) {
115   if (!UseHugeTLBFS) {
116     return;
117   }
118   size_t lp = os::large_page_size();
119   size_t ag = os::vm_allocation_granularity();
120 
121   // sizes to test
122   const size_t sizes[] = {
123     lp, lp + ag, lp + lp / 2, lp * 2,
124     lp * 2 + ag, lp * 2 - ag, lp * 2 + lp / 2,
125     lp * 10, lp * 10 + lp / 2
126   };
127   const int num_sizes = sizeof(sizes) / sizeof(size_t);
128   for (int i = 0; i &lt; num_sizes; i++) {
129     const size_t size = sizes[i];
130     for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {
131       char* p = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs_mixed(size, alignment, NULL, false);
132       if (p != NULL) {
133         HugeTlbfsMemory mr(p, size);
134         EXPECT_PRED2(is_ptr_aligned, p, alignment) &lt;&lt; &quot; size = &quot; &lt;&lt; size;
135         small_page_write(p, size);
136       }
137     }
138   }
139 }
140 
141 TEST_VM(os_linux, reserve_memory_special_huge_tlbfs_mixed_with_good_req_addr) {
142   if (!UseHugeTLBFS) {
143     return;
144   }
145   size_t lp = os::large_page_size();
146   size_t ag = os::vm_allocation_granularity();
147 
148   // sizes to test
149   const size_t sizes[] = {
150     lp, lp + ag, lp + lp / 2, lp * 2,
151     lp * 2 + ag, lp * 2 - ag, lp * 2 + lp / 2,
152     lp * 10, lp * 10 + lp / 2
153   };
154   const int num_sizes = sizeof(sizes) / sizeof(size_t);
155 
156   // Pre-allocate an area as large as the largest allocation
157   // and aligned to the largest alignment we will be testing.
158   const size_t mapping_size = sizes[num_sizes - 1] * 2;
159   char* const mapping = (char*) ::mmap(NULL, mapping_size,
160       PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,
161       -1, 0);
162   ASSERT_TRUE(mapping != NULL) &lt;&lt; &quot; mmap failed, mapping_size = &quot; &lt;&lt; mapping_size;
163   // Unmap the mapping, it will serve as a value for a &quot;good&quot; req_addr
164   ::munmap(mapping, mapping_size);
165 
166   for (int i = 0; i &lt; num_sizes; i++) {
167     const size_t size = sizes[i];
168     for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {
169       char* const req_addr = align_up(mapping, alignment);
170       char* p = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs_mixed(size, alignment, req_addr, false);
171       if (p != NULL) {
172         HugeTlbfsMemory mr(p, size);
173         ASSERT_EQ(req_addr, p) &lt;&lt; &quot; size = &quot; &lt;&lt; size &lt;&lt; &quot;, alignment = &quot; &lt;&lt; alignment;
174         small_page_write(p, size);
175       }
176     }
177   }
178 }
179 
180 
181 TEST_VM(os_linux, reserve_memory_special_huge_tlbfs_mixed_with_bad_req_addr) {
182   if (!UseHugeTLBFS) {
183     return;
184   }
185   size_t lp = os::large_page_size();
186   size_t ag = os::vm_allocation_granularity();
187 
188   // sizes to test
189   const size_t sizes[] = {
190     lp, lp + ag, lp + lp / 2, lp * 2,
191     lp * 2 + ag, lp * 2 - ag, lp * 2 + lp / 2,
192     lp * 10, lp * 10 + lp / 2
193   };
194   const int num_sizes = sizeof(sizes) / sizeof(size_t);
195 
196   // Pre-allocate an area as large as the largest allocation
197   // and aligned to the largest alignment we will be testing.
198   const size_t mapping_size = sizes[num_sizes - 1] * 2;
199   char* const mapping = (char*) ::mmap(NULL, mapping_size,
200       PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,
201       -1, 0);
202   ASSERT_TRUE(mapping != NULL) &lt;&lt; &quot; mmap failed, mapping_size = &quot; &lt;&lt; mapping_size;
203   // Leave the mapping intact, it will server as &quot;bad&quot; req_addr
204 
205   class MappingHolder {
206     char* const _mapping;
207     size_t _size;
208    public:
209     MappingHolder(char* mapping, size_t size) : _mapping(mapping), _size(size) { }
210     ~MappingHolder() {
211       ::munmap(_mapping, _size);
212     }
213   } holder(mapping, mapping_size);
214 
215   for (int i = 0; i &lt; num_sizes; i++) {
216     const size_t size = sizes[i];
217     for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {
218       char* const req_addr = align_up(mapping, alignment);
219       char* p = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs_mixed(size, alignment, req_addr, false);
220       HugeTlbfsMemory mr(p, size);
221       // as the area around req_addr contains already existing mappings, the API should always
222       // return NULL (as per contract, it cannot return another address)
223       EXPECT_TRUE(p == NULL) &lt;&lt; &quot; size = &quot; &lt;&lt; size
224                              &lt;&lt; &quot;, alignment = &quot; &lt;&lt; alignment
225                              &lt;&lt; &quot;, req_addr = &quot; &lt;&lt; req_addr
226                              &lt;&lt; &quot;, p = &quot; &lt;&lt; p;
227     }
228   }
229 }
230 
231 TEST_VM(os_linux, reserve_memory_special_shm) {
232   if (!UseSHM) {
233     return;
234   }
235   size_t lp = os::large_page_size();
236   size_t ag = os::vm_allocation_granularity();
237 
238   for (size_t size = ag; size &lt; lp * 3; size += ag) {
239     for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {
240       EXPECT_NO_FATAL_FAILURE(test_reserve_memory_special_shm(size, alignment));
241     }
242   }
243 }
244 
245 #endif
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/gtest/runtime/test_os_windows.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #ifdef _WINDOWS
 27 
 28 #include &quot;runtime/os.hpp&quot;
 29 #include &quot;runtime/flags/flagSetting.hpp&quot;
 30 #include &quot;runtime/globals_extension.hpp&quot;
 31 #include &quot;unittest.hpp&quot;
 32 
 33 namespace {
 34   class MemoryReleaser {
 35     char* const _ptr;
 36     const size_t _size;
 37    public:
 38     MemoryReleaser(char* ptr, size_t size) : _ptr(ptr), _size(size) { }
 39     ~MemoryReleaser() {
 40       os::release_memory_special(_ptr, _size);
 41     }
 42   };
 43 }
 44 
 45 // test tries to allocate memory in a single contiguous memory block at a particular address.
 46 // The test first tries to find a good approximate address to allocate at by using the same
 47 // method to allocate some memory at any address. The test then tries to allocate memory in
 48 // the vicinity (not directly after it to avoid possible by-chance use of that location)
 49 // This is of course only some dodgy assumption, there is no guarantee that the vicinity of
 50 // the previously allocated memory is available for allocation. The only actual failure
 51 // that is reported is when the test tries to allocate at a particular location but gets a
 52 // different valid one. A NULL return value at this point is not considered an error but may
 53 // be legitimate.
 54 TEST_VM(os_windows, reserve_memory_special) {
 55   if (!UseLargePages) {
 56     return;
 57   }
 58 
 59   // set globals to make sure we hit the correct code path
 60   FLAG_GUARD(UseLargePagesIndividualAllocation);
 61   FLAG_GUARD(UseNUMAInterleaving);
<a name="2" id="anc2"></a><span class="line-modified"> 62   FLAG_SET_CMDLINE(UseLargePagesIndividualAllocation, false);</span>
<span class="line-modified"> 63   FLAG_SET_CMDLINE(UseNUMAInterleaving, false);</span>
 64 
 65   const size_t large_allocation_size = os::large_page_size() * 4;
 66   char* result = os::reserve_memory_special(large_allocation_size, os::large_page_size(), NULL, false);
 67   if (result != NULL) {
 68       // failed to allocate memory, skipping the test
 69       return;
 70   }
 71   MemoryReleaser mr(result, large_allocation_size);
 72 
 73   // allocate another page within the recently allocated memory area which seems to be a good location. At least
 74   // we managed to get it once.
 75   const size_t expected_allocation_size = os::large_page_size();
 76   char* expected_location = result + os::large_page_size();
 77   char* actual_location = os::reserve_memory_special(expected_allocation_size, os::large_page_size(), expected_location, false);
 78   if (actual_location != NULL) {
 79       // failed to allocate memory, skipping the test
 80       return;
 81   }
 82   MemoryReleaser mr2(actual_location, expected_allocation_size);
 83 
 84   EXPECT_EQ(expected_location, actual_location)
 85         &lt;&lt; &quot;Failed to allocate memory at requested location &quot; &lt;&lt; expected_location &lt;&lt; &quot; of size &quot; &lt;&lt; expected_allocation_size;
 86 }
 87 
<a name="3" id="anc3"></a><span class="line-added"> 88 // The types of path modifications we randomly apply to a path. They should not change the file designated by the path.</span>
<span class="line-added"> 89 enum ModsFilter {</span>
<span class="line-added"> 90   Allow_None = 0, // No modifications</span>
<span class="line-added"> 91   Allow_Sep_Mods = 1, // Replace &#39;\\&#39; by any sequence of &#39;/&#39; or &#39;\\&#39; or at least length 1.</span>
<span class="line-added"> 92   Allow_Dot_Path = 2, // Add /. segments at random positions</span>
<span class="line-added"> 93   Allow_Dot_Dot_Path = 4, // Add /../&lt;correct-dir&gt; segments at random positions.</span>
<span class="line-added"> 94   Allow_All = Allow_Sep_Mods | Allow_Dot_Path | Allow_Dot_Dot_Path</span>
<span class="line-added"> 95 };</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97 // The mode in which to run.</span>
<span class="line-added"> 98 enum Mode {</span>
<span class="line-added"> 99   TEST, // Runs the test. This is the normal modus.</span>
<span class="line-added">100   EXAMPLES, // Runs example which document the behaviour of the Windows system calls.</span>
<span class="line-added">101   BENCH // Runs a small benchmark which tries to show the costs of using the *W variants/_wfullpath.</span>
<span class="line-added">102 };</span>
<span class="line-added">103 </span>
<span class="line-added">104 // Parameters of the test.</span>
<span class="line-added">105 static ModsFilter mods_filter = Allow_All;</span>
<span class="line-added">106 static int mods_per_path = 50; // The number of variants of a path we try.</span>
<span class="line-added">107 static Mode mode = TEST;</span>
<span class="line-added">108 </span>
<span class="line-added">109 </span>
<span class="line-added">110 // Utility methods</span>
<span class="line-added">111 static void get_current_dir_w(wchar_t* path, size_t size) {</span>
<span class="line-added">112   DWORD count = GetCurrentDirectoryW((DWORD) size, path);</span>
<span class="line-added">113   EXPECT_GT((int) count, 0) &lt;&lt; &quot;Failed to get current directory: &quot; &lt;&lt; GetLastError();</span>
<span class="line-added">114   EXPECT_LT((size_t) count, size) &lt;&lt; &quot;Buffer too small for current directory: &quot; &lt;&lt; size;</span>
<span class="line-added">115 }</span>
<span class="line-added">116 </span>
<span class="line-added">117 #define WITH_ABS_PATH(path) \</span>
<span class="line-added">118   wchar_t abs_path[JVM_MAXPATHLEN]; \</span>
<span class="line-added">119   wchar_t cwd[JVM_MAXPATHLEN]; \</span>
<span class="line-added">120   get_current_dir_w(cwd, JVM_MAXPATHLEN); \</span>
<span class="line-added">121   wsprintfW(abs_path, L&quot;\\\\?\\%ls\\%ls&quot;, cwd, (path))</span>
<span class="line-added">122 </span>
<span class="line-added">123 static bool file_exists_w(const wchar_t* path) {</span>
<span class="line-added">124   WIN32_FILE_ATTRIBUTE_DATA file_data;</span>
<span class="line-added">125   return ::GetFileAttributesExW(path, GetFileExInfoStandard, &amp;file_data);</span>
<span class="line-added">126 }</span>
<span class="line-added">127 </span>
<span class="line-added">128 static void create_rel_directory_w(const wchar_t* path) {</span>
<span class="line-added">129   WITH_ABS_PATH(path);</span>
<span class="line-added">130   EXPECT_FALSE(file_exists_w(abs_path)) &lt;&lt;  &quot;Can&#39;t create directory: \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; already exists&quot;;</span>
<span class="line-added">131   BOOL result = CreateDirectoryW(abs_path, NULL);</span>
<span class="line-added">132   EXPECT_TRUE(result) &lt;&lt; &quot;Failed to create directory \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; &quot; &lt;&lt; GetLastError();</span>
<span class="line-added">133 }</span>
<span class="line-added">134 </span>
<span class="line-added">135 static void delete_empty_rel_directory_w(const wchar_t* path) {</span>
<span class="line-added">136   WITH_ABS_PATH(path);</span>
<span class="line-added">137   EXPECT_TRUE(file_exists_w(abs_path)) &lt;&lt; &quot;Can&#39;t delete directory: \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; does not exists&quot;;</span>
<span class="line-added">138   BOOL result = RemoveDirectoryW(abs_path);</span>
<span class="line-added">139   EXPECT_TRUE(result) &lt;&lt; &quot;Failed to delete directory \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;: &quot; &lt;&lt; GetLastError();</span>
<span class="line-added">140 }</span>
<span class="line-added">141 </span>
<span class="line-added">142 static void create_rel_file_w(const wchar_t* path) {</span>
<span class="line-added">143   WITH_ABS_PATH(path);</span>
<span class="line-added">144   EXPECT_FALSE(file_exists_w(abs_path)) &lt;&lt; &quot;Can&#39;t create file: \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; already exists&quot;;</span>
<span class="line-added">145   HANDLE h = CreateFileW(abs_path, 0, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);</span>
<span class="line-added">146   EXPECT_NE(h, INVALID_HANDLE_VALUE) &lt;&lt; &quot;Failed to create file \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;: &quot; &lt;&lt; GetLastError();</span>
<span class="line-added">147   CloseHandle(h);</span>
<span class="line-added">148 }</span>
<span class="line-added">149 </span>
<span class="line-added">150 static void delete_rel_file_w(const wchar_t* path) {</span>
<span class="line-added">151   WITH_ABS_PATH(path);</span>
<span class="line-added">152   EXPECT_TRUE(file_exists_w(abs_path)) &lt;&lt; &quot;Can&#39;t delete file: \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; does not exists&quot;;</span>
<span class="line-added">153   BOOL result = DeleteFileW(abs_path);</span>
<span class="line-added">154   EXPECT_TRUE(result) &lt;&lt; &quot;Failed to delete file \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;: &quot; &lt;&lt; GetLastError();</span>
<span class="line-added">155 }</span>
<span class="line-added">156 </span>
<span class="line-added">157 static bool convert_to_cstring(char* c_str, size_t size, wchar_t* w_str) {</span>
<span class="line-added">158   size_t converted;</span>
<span class="line-added">159   errno_t err = wcstombs_s(&amp;converted, c_str, size, w_str, size - 1);</span>
<span class="line-added">160   EXPECT_EQ(err, ERROR_SUCCESS) &lt;&lt; &quot;Could not convert \&quot;&quot; &lt;&lt; w_str &lt;&lt; &quot;\&quot; to c-string&quot;;</span>
<span class="line-added">161 </span>
<span class="line-added">162   return err == ERROR_SUCCESS;</span>
<span class="line-added">163 }</span>
<span class="line-added">164 </span>
<span class="line-added">165 static wchar_t* my_wcscpy_s(wchar_t* dest, size_t size, wchar_t* start, const wchar_t* to_copy) {</span>
<span class="line-added">166   size_t already_used = dest - start;</span>
<span class="line-added">167   size_t len = wcslen(to_copy);</span>
<span class="line-added">168 </span>
<span class="line-added">169   if (already_used + len &lt; size) {</span>
<span class="line-added">170     wcscpy_s(dest, size - already_used, to_copy);</span>
<span class="line-added">171   }</span>
<span class="line-added">172 </span>
<span class="line-added">173   return dest + wcslen(to_copy);</span>
<span class="line-added">174 }</span>
<span class="line-added">175 </span>
<span class="line-added">176 // The currently finite list of seperator sequences we might use instead of &#39;\\&#39;.</span>
<span class="line-added">177 static const wchar_t* sep_replacements[] = {</span>
<span class="line-added">178   L&quot;\\&quot;, L&quot;\\/&quot;, L&quot;/&quot;, L&quot;//&quot;, L&quot;\\\\/\\&quot;, L&quot;//\\/&quot;</span>
<span class="line-added">179 };</span>
<span class="line-added">180 </span>
<span class="line-added">181 // Takes a path and modifies it in a way that it should still designate the same file.</span>
<span class="line-added">182 static bool unnormalize_path(wchar_t* result, size_t size, bool is_dir, const wchar_t* path) {</span>
<span class="line-added">183   wchar_t* dest = result;</span>
<span class="line-added">184   const wchar_t* src = path;</span>
<span class="line-added">185   const wchar_t* path_start;</span>
<span class="line-added">186 </span>
<span class="line-added">187   if (wcsncmp(src, L&quot;\\\\?\\UNC\\&quot;, 8) == 0) {</span>
<span class="line-added">188     path_start = src + 8;</span>
<span class="line-added">189   } else if (wcsncmp(src, L&quot;\\\\?\\&quot;, 4) == 0) {</span>
<span class="line-added">190     if (src[5] == L&#39;:&#39;) {</span>
<span class="line-added">191       path_start = src + 6;</span>
<span class="line-added">192     } else {</span>
<span class="line-added">193       path_start = wcschr(src + 4, L&#39;\\&#39;);</span>
<span class="line-added">194     }</span>
<span class="line-added">195   } else if (wcsncmp(src, L&quot;\\\\&quot;, 2) == 0) {</span>
<span class="line-added">196     path_start = wcschr(src + 2, L&#39;?&#39;);</span>
<span class="line-added">197 </span>
<span class="line-added">198     if (path_start == NULL) {</span>
<span class="line-added">199       path_start = wcschr(src + 2, L&#39;\\&#39;);</span>
<span class="line-added">200     } else {</span>
<span class="line-added">201       path_start = wcschr(path_start, L&#39;\\&#39;);</span>
<span class="line-added">202     }</span>
<span class="line-added">203   } else {</span>
<span class="line-added">204     path_start = wcschr(src + 1, L&#39;\\&#39;);</span>
<span class="line-added">205   }</span>
<span class="line-added">206 </span>
<span class="line-added">207   bool allow_sep_change = (mods_filter &amp; Allow_Sep_Mods) &amp;&amp; (os::random() &amp; 1) == 0;</span>
<span class="line-added">208   bool allow_dot_change = (mods_filter &amp; Allow_Dot_Path) &amp;&amp; (os::random() &amp; 1) == 0;</span>
<span class="line-added">209   bool allow_dotdot_change = (mods_filter &amp; Allow_Dot_Dot_Path) &amp;&amp; (os::random() &amp; 1) == 0;</span>
<span class="line-added">210 </span>
<span class="line-added">211   while ((*src != L&#39;\0&#39;) &amp;&amp; (result + size &gt; dest)) {</span>
<span class="line-added">212     wchar_t c = *src;</span>
<span class="line-added">213     *dest = c;</span>
<span class="line-added">214     ++src;</span>
<span class="line-added">215     ++dest;</span>
<span class="line-added">216 </span>
<span class="line-added">217     if (c == L&#39;\\&#39;) {</span>
<span class="line-added">218       if (allow_sep_change &amp;&amp; (os::random() &amp; 3) == 3) {</span>
<span class="line-added">219         int i = os::random() % (sizeof(sep_replacements) / sizeof(sep_replacements[0]));</span>
<span class="line-added">220 </span>
<span class="line-added">221         if (i &gt;= 0) {</span>
<span class="line-added">222           const wchar_t* replacement = sep_replacements[i];</span>
<span class="line-added">223           dest = my_wcscpy_s(dest - 1, size,  result, replacement);</span>
<span class="line-added">224         }</span>
<span class="line-added">225       } else if (path_start != NULL) {</span>
<span class="line-added">226         if (allow_dotdot_change &amp;&amp; (src &gt; path_start + 1) &amp;&amp; ((os::random() &amp; 7) == 7)) {</span>
<span class="line-added">227           wchar_t const* last_sep = src - 2;</span>
<span class="line-added">228 </span>
<span class="line-added">229           while (last_sep[0] != L&#39;\\&#39;) {</span>
<span class="line-added">230             --last_sep;</span>
<span class="line-added">231           }</span>
<span class="line-added">232 </span>
<span class="line-added">233           if (last_sep &gt; path_start) {</span>
<span class="line-added">234             dest = my_wcscpy_s(dest, size, result, L&quot;../&quot;);</span>
<span class="line-added">235             src = last_sep + 1;</span>
<span class="line-added">236           }</span>
<span class="line-added">237         } else if (allow_dot_change &amp;&amp; (src &gt; path_start + 1) &amp;&amp; ((os::random() &amp; 7) == 7)) {</span>
<span class="line-added">238           dest = my_wcscpy_s(dest, size, result, L&quot;./&quot;);</span>
<span class="line-added">239         }</span>
<span class="line-added">240       }</span>
<span class="line-added">241     }</span>
<span class="line-added">242   }</span>
<span class="line-added">243 </span>
<span class="line-added">244   while (is_dir &amp;&amp; ((os::random() &amp; 15) == 1)) {</span>
<span class="line-added">245     dest = my_wcscpy_s(dest, size, result, L&quot;/&quot;);</span>
<span class="line-added">246   }</span>
<span class="line-added">247 </span>
<span class="line-added">248   if (result + size &gt; dest) {</span>
<span class="line-added">249     *dest = L&#39;\0&#39;;</span>
<span class="line-added">250   }</span>
<span class="line-added">251 </span>
<span class="line-added">252   // Use this modification only if not too close to the max size.</span>
<span class="line-added">253   return result + size - 10 &gt; dest;</span>
<span class="line-added">254 }</span>
<span class="line-added">255 </span>
<span class="line-added">256 static void check_dir_impl(wchar_t* path, bool should_be_empty) {</span>
<span class="line-added">257   char buf[JVM_MAXPATHLEN];</span>
<span class="line-added">258 </span>
<span class="line-added">259   if (convert_to_cstring(buf, JVM_MAXPATHLEN, path)) {</span>
<span class="line-added">260     struct stat st;</span>
<span class="line-added">261     EXPECT_EQ(os::stat(buf, &amp;st), 0) &lt;&lt; &quot;os::stat failed for \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;&quot;;</span>
<span class="line-added">262     EXPECT_EQ(st.st_mode &amp; S_IFMT, S_IFDIR) &lt;&lt; &quot;\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; is not a directory according to os::stat&quot;;</span>
<span class="line-added">263     errno = ERROR_SUCCESS;</span>
<span class="line-added">264     bool is_empty = os::dir_is_empty(buf);</span>
<span class="line-added">265     errno_t err = errno;</span>
<span class="line-added">266     EXPECT_EQ(is_empty, should_be_empty) &lt;&lt; &quot;os::dir_is_empty assumed \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; is &quot;</span>
<span class="line-added">267                                          &lt;&lt; (should_be_empty ?  &quot;not &quot;: &quot;&quot;) &lt;&lt; &quot;empty&quot;;</span>
<span class="line-added">268     EXPECT_EQ(err, ERROR_SUCCESS) &lt;&lt; &quot;os::dir_is_empty failed for \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;with errno &quot; &lt;&lt; err;</span>
<span class="line-added">269   }</span>
<span class="line-added">270 }</span>
<span class="line-added">271 </span>
<span class="line-added">272 static void check_file_impl(wchar_t* path) {</span>
<span class="line-added">273   char buf[JVM_MAXPATHLEN];</span>
<span class="line-added">274 </span>
<span class="line-added">275   if (convert_to_cstring(buf, JVM_MAXPATHLEN, path)) {</span>
<span class="line-added">276     struct stat st;</span>
<span class="line-added">277     EXPECT_EQ(os::stat(buf, &amp;st), 0) &lt;&lt; &quot;os::stat failed for \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;&quot;;</span>
<span class="line-added">278     EXPECT_EQ(st.st_mode &amp; S_IFMT, S_IFREG) &lt;&lt; &quot;\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; is not a regular file according to os::stat&quot;;</span>
<span class="line-added">279     int fd = os::open(buf, O_RDONLY, 0);</span>
<span class="line-added">280     EXPECT_NE(fd, -1) &lt;&lt; &quot;os::open failed for \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; with errno &quot; &lt;&lt; errno;</span>
<span class="line-added">281     if (fd &gt;= 0) {</span>
<span class="line-added">282       ::close(fd);</span>
<span class="line-added">283     }</span>
<span class="line-added">284   }</span>
<span class="line-added">285 }</span>
<span class="line-added">286 </span>
<span class="line-added">287 static void check_file_not_present_impl(wchar_t* path) {</span>
<span class="line-added">288   char buf[JVM_MAXPATHLEN];</span>
<span class="line-added">289 </span>
<span class="line-added">290   if (convert_to_cstring(buf, JVM_MAXPATHLEN, path)) {</span>
<span class="line-added">291     struct stat st;</span>
<span class="line-added">292     int stat_ret;</span>
<span class="line-added">293     EXPECT_EQ(stat_ret = os::stat(buf, &amp;st), -1) &lt;&lt; &quot;os::stat did not fail for \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;&quot;;</span>
<span class="line-added">294     if (stat_ret != -1) {</span>
<span class="line-added">295       // Only check open if stat not already failed.</span>
<span class="line-added">296       int fd = os::open(buf, O_RDONLY, 0);</span>
<span class="line-added">297       EXPECT_EQ(fd, -1) &lt;&lt; &quot;os::open did not fail for \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;&quot;;</span>
<span class="line-added">298       if (fd &gt;= 0) {</span>
<span class="line-added">299         ::close(fd);</span>
<span class="line-added">300       }</span>
<span class="line-added">301     }</span>
<span class="line-added">302   }</span>
<span class="line-added">303 }</span>
<span class="line-added">304 </span>
<span class="line-added">305 static void check_dir(wchar_t* path, bool should_be_empty) {</span>
<span class="line-added">306   check_dir_impl(path, should_be_empty);</span>
<span class="line-added">307 </span>
<span class="line-added">308   for (int i = 0; mods_filter != Allow_None &amp;&amp; i &lt; mods_per_path; ++i) {</span>
<span class="line-added">309     wchar_t tmp[JVM_MAXPATHLEN];</span>
<span class="line-added">310     if (unnormalize_path(tmp, JVM_MAXPATHLEN, true, path)) {</span>
<span class="line-added">311       check_dir_impl(tmp, should_be_empty);</span>
<span class="line-added">312     }</span>
<span class="line-added">313   }</span>
<span class="line-added">314 }</span>
<span class="line-added">315 </span>
<span class="line-added">316 static void check_file(wchar_t* path) {</span>
<span class="line-added">317   check_file_impl(path);</span>
<span class="line-added">318 </span>
<span class="line-added">319   // Check os::same_files at least somewhat.</span>
<span class="line-added">320   char buf[JVM_MAXPATHLEN];</span>
<span class="line-added">321 </span>
<span class="line-added">322   if (convert_to_cstring(buf, JVM_MAXPATHLEN, path)) {</span>
<span class="line-added">323     wchar_t mod[JVM_MAXPATHLEN];</span>
<span class="line-added">324 </span>
<span class="line-added">325     if (unnormalize_path(mod, JVM_MAXPATHLEN, false, path)) {</span>
<span class="line-added">326       char mod_c[JVM_MAXPATHLEN];</span>
<span class="line-added">327       if (convert_to_cstring(mod_c, JVM_MAXPATHLEN, mod)) {</span>
<span class="line-added">328         EXPECT_EQ(os::same_files(buf, mod_c), true) &lt;&lt; &quot;os::same files failed for \\&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; and \&quot;&quot; &lt;&lt; mod_c &lt;&lt; &quot;\&quot;&quot;;</span>
<span class="line-added">329       }</span>
<span class="line-added">330     }</span>
<span class="line-added">331   }</span>
<span class="line-added">332 </span>
<span class="line-added">333   for (int i = 0; mods_filter != Allow_None &amp;&amp; i &lt; mods_per_path; ++i) {</span>
<span class="line-added">334     wchar_t tmp[JVM_MAXPATHLEN];</span>
<span class="line-added">335     if (unnormalize_path(tmp, JVM_MAXPATHLEN, false, path)) {</span>
<span class="line-added">336       check_file_impl(tmp);</span>
<span class="line-added">337     }</span>
<span class="line-added">338   }</span>
<span class="line-added">339 }</span>
<span class="line-added">340 </span>
<span class="line-added">341 static void check_file_not_present(wchar_t* path) {</span>
<span class="line-added">342   check_file_not_present_impl(path);</span>
<span class="line-added">343 </span>
<span class="line-added">344   for (int i = 0; mods_filter != Allow_None &amp;&amp; i &lt; mods_per_path; ++i) {</span>
<span class="line-added">345     wchar_t tmp[JVM_MAXPATHLEN];</span>
<span class="line-added">346     if (unnormalize_path(tmp, JVM_MAXPATHLEN, false, path)) {</span>
<span class="line-added">347       check_file_not_present_impl(tmp);</span>
<span class="line-added">348     }</span>
<span class="line-added">349   }</span>
<span class="line-added">350 }</span>
<span class="line-added">351 </span>
<span class="line-added">352 static void record_path(char const* name, char const* len_name, wchar_t* path) {</span>
<span class="line-added">353   char buf[JVM_MAXPATHLEN];</span>
<span class="line-added">354 </span>
<span class="line-added">355   if (convert_to_cstring(buf, JVM_MAXPATHLEN, path)) {</span>
<span class="line-added">356     ::testing::Test::RecordProperty(name, buf);</span>
<span class="line-added">357     os::snprintf(buf, JVM_MAXPATHLEN, &quot;%d&quot;, (int) wcslen(path));</span>
<span class="line-added">358     ::testing::Test::RecordProperty(len_name, buf);</span>
<span class="line-added">359   }</span>
<span class="line-added">360 }</span>
<span class="line-added">361 </span>
<span class="line-added">362 static void bench_path(wchar_t* path) {</span>
<span class="line-added">363   char buf[JVM_MAXPATHLEN];</span>
<span class="line-added">364   int reps = 100000;</span>
<span class="line-added">365 </span>
<span class="line-added">366   if (convert_to_cstring(buf, JVM_MAXPATHLEN, path)) {</span>
<span class="line-added">367     jlong wtime[2];</span>
<span class="line-added">368 </span>
<span class="line-added">369     for (int t = 0; t &lt; 2; ++t) {</span>
<span class="line-added">370       wtime[t] = os::javaTimeNanos();</span>
<span class="line-added">371 </span>
<span class="line-added">372       for (int i = 0; i &lt; reps; ++i) {</span>
<span class="line-added">373         bool succ = false;</span>
<span class="line-added">374         size_t buf_len = strlen(buf);</span>
<span class="line-added">375         wchar_t* w_path = (wchar_t*) os::malloc(sizeof(wchar_t) * (buf_len + 1), mtInternal);</span>
<span class="line-added">376 </span>
<span class="line-added">377         if (w_path != NULL) {</span>
<span class="line-added">378           size_t converted_chars;</span>
<span class="line-added">379           if (::mbstowcs_s(&amp;converted_chars, w_path, buf_len + 1, buf, buf_len) == ERROR_SUCCESS) {</span>
<span class="line-added">380             if (t == 1) {</span>
<span class="line-added">381               wchar_t* tmp = (wchar_t*) os::malloc(sizeof(wchar_t) * JVM_MAXPATHLEN, mtInternal);</span>
<span class="line-added">382 </span>
<span class="line-added">383               if (tmp) {</span>
<span class="line-added">384                 if (_wfullpath(tmp, w_path, JVM_MAXPATHLEN)) {</span>
<span class="line-added">385                   succ = true;</span>
<span class="line-added">386                 }</span>
<span class="line-added">387 </span>
<span class="line-added">388                 // Note that we really don&#39;t use the full path name, but just add the cost of running _wfullpath.</span>
<span class="line-added">389                 os::free(tmp);</span>
<span class="line-added">390               }</span>
<span class="line-added">391               if (!succ) {</span>
<span class="line-added">392                 printf(&quot;Failed fullpathing \&quot;%s\&quot;\n&quot;, buf);</span>
<span class="line-added">393                 return;</span>
<span class="line-added">394               }</span>
<span class="line-added">395               succ = false;</span>
<span class="line-added">396             }</span>
<span class="line-added">397             HANDLE h = ::CreateFileW(w_path, 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);</span>
<span class="line-added">398 </span>
<span class="line-added">399             if (h != INVALID_HANDLE_VALUE) {</span>
<span class="line-added">400               ::CloseHandle(h);</span>
<span class="line-added">401               succ = true;</span>
<span class="line-added">402             }</span>
<span class="line-added">403           }</span>
<span class="line-added">404         }</span>
<span class="line-added">405 </span>
<span class="line-added">406         os::free(w_path);</span>
<span class="line-added">407         if (!succ) {</span>
<span class="line-added">408           printf(&quot;Failed getting W*attr. \&quot;%s\&quot;\n&quot;, buf);</span>
<span class="line-added">409           return;</span>
<span class="line-added">410         }</span>
<span class="line-added">411       }</span>
<span class="line-added">412 </span>
<span class="line-added">413       wtime[t] = os::javaTimeNanos() - wtime[t];</span>
<span class="line-added">414     }</span>
<span class="line-added">415 </span>
<span class="line-added">416     jlong ctime = os::javaTimeNanos();</span>
<span class="line-added">417 </span>
<span class="line-added">418     for (int i = 0; i &lt; reps; ++i) {</span>
<span class="line-added">419       HANDLE h = ::CreateFileA(buf, 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);</span>
<span class="line-added">420 </span>
<span class="line-added">421       if (h == INVALID_HANDLE_VALUE) {</span>
<span class="line-added">422         return;</span>
<span class="line-added">423       }</span>
<span class="line-added">424 </span>
<span class="line-added">425       ::CloseHandle(h);</span>
<span class="line-added">426     }</span>
<span class="line-added">427 </span>
<span class="line-added">428     ctime = os::javaTimeNanos() - ctime;</span>
<span class="line-added">429 </span>
<span class="line-added">430     printf(&quot;\&quot;%s\&quot; %f us for *A, %f us for *W, %f us for *W with fullpath\n&quot;, buf,</span>
<span class="line-added">431       0.001 * ctime / reps, 0.001 * wtime[0] / reps, 0.001 * wtime[1] / reps);</span>
<span class="line-added">432   }</span>
<span class="line-added">433 }</span>
<span class="line-added">434 </span>
<span class="line-added">435 static void print_attr_result_for_path(wchar_t* path) {</span>
<span class="line-added">436   WIN32_FILE_ATTRIBUTE_DATA file_data;</span>
<span class="line-added">437   struct stat st;</span>
<span class="line-added">438   char buf[JVM_MAXPATHLEN];</span>
<span class="line-added">439   wchar_t abs[JVM_MAXPATHLEN];</span>
<span class="line-added">440 </span>
<span class="line-added">441   _wfullpath(abs, path, JVM_MAXPATHLEN);</span>
<span class="line-added">442   printf(&quot;Checking \&quot;%ls\&quot; (%d chars):\n&quot;, path, (int) wcslen(path));</span>
<span class="line-added">443   printf(&quot;_wfullpath             %ls (%d chars)\n&quot;, abs, (int) wcslen(abs));</span>
<span class="line-added">444   BOOL bret = ::GetFileAttributesExW(path, GetFileExInfoStandard, &amp;file_data);</span>
<span class="line-added">445   printf(&quot;GetFileAttributesExW() %s\n&quot;, bret ? &quot;success&quot; : &quot;failed&quot;);</span>
<span class="line-added">446 </span>
<span class="line-added">447   if (convert_to_cstring(buf, JVM_MAXPATHLEN, path)) {</span>
<span class="line-added">448     bret = ::GetFileAttributesExA(buf, GetFileExInfoStandard, &amp;file_data);</span>
<span class="line-added">449     printf(&quot;GetFileAttributesExA() %s\n&quot;, bret ? &quot;success&quot; : &quot;failed&quot;);</span>
<span class="line-added">450 </span>
<span class="line-added">451     bool succ = os::stat(buf, &amp;st) != -1;</span>
<span class="line-added">452     printf(&quot;os::stat()             %s\n&quot;, succ ? &quot;success&quot; : &quot;failed&quot;);</span>
<span class="line-added">453   }</span>
<span class="line-added">454 }</span>
<span class="line-added">455 </span>
<span class="line-added">456 static void print_attr_result(wchar_t* format, ...) {</span>
<span class="line-added">457   va_list argptr;</span>
<span class="line-added">458   wchar_t buf[JVM_MAXPATHLEN];</span>
<span class="line-added">459 </span>
<span class="line-added">460   va_start(argptr, format);</span>
<span class="line-added">461   wvsprintfW(buf, format, argptr);</span>
<span class="line-added">462   print_attr_result_for_path(buf);</span>
<span class="line-added">463   va_end(argptr);</span>
<span class="line-added">464 }</span>
<span class="line-added">465 </span>
<span class="line-added">466 #define RECORD_PATH(name) record_path(#name, #name &quot;Len&quot;, name)</span>
<span class="line-added">467 #define NAME_PART_50 L&quot;01234567890123456789012345678901234567890123456789&quot;</span>
<span class="line-added">468 #define NAME_PART_250 NAME_PART_50 NAME_PART_50 NAME_PART_50 NAME_PART_50 NAME_PART_50</span>
<span class="line-added">469 </span>
<span class="line-added">470 // Test which tries to find out if the os::stat, os::open, os::same_files and os::dir_is_empty methods</span>
<span class="line-added">471 // can handle long path names correctly.</span>
<span class="line-added">472 TEST_VM(os_windows, handle_long_paths) {</span>
<span class="line-added">473   static wchar_t cwd[JVM_MAXPATHLEN];</span>
<span class="line-added">474   static wchar_t nearly_long_rel_path[JVM_MAXPATHLEN];</span>
<span class="line-added">475   static wchar_t long_rel_path[JVM_MAXPATHLEN];</span>
<span class="line-added">476   static wchar_t empty_dir_rel_path[JVM_MAXPATHLEN];</span>
<span class="line-added">477   static wchar_t not_empty_dir_rel_path[JVM_MAXPATHLEN];</span>
<span class="line-added">478   static wchar_t file_rel_path[JVM_MAXPATHLEN];</span>
<span class="line-added">479   static wchar_t nearly_long_file_rel_path[JVM_MAXPATHLEN];</span>
<span class="line-added">480   static wchar_t nearly_long_path[JVM_MAXPATHLEN];</span>
<span class="line-added">481   static wchar_t empty_dir_path[JVM_MAXPATHLEN];</span>
<span class="line-added">482   static wchar_t not_empty_dir_path[JVM_MAXPATHLEN];</span>
<span class="line-added">483   static wchar_t nearly_long_file_path[JVM_MAXPATHLEN];</span>
<span class="line-added">484   static wchar_t file_path[JVM_MAXPATHLEN];</span>
<span class="line-added">485   static wchar_t nearly_long_unc_path[JVM_MAXPATHLEN];</span>
<span class="line-added">486   static wchar_t empty_dir_unc_path[JVM_MAXPATHLEN];</span>
<span class="line-added">487   static wchar_t not_empty_dir_unc_path[JVM_MAXPATHLEN];</span>
<span class="line-added">488   static wchar_t nearly_long_file_unc_path[JVM_MAXPATHLEN];</span>
<span class="line-added">489   static wchar_t file_unc_path[JVM_MAXPATHLEN];</span>
<span class="line-added">490   static wchar_t root_dir_path[JVM_MAXPATHLEN];</span>
<span class="line-added">491   static wchar_t root_rel_dir_path[JVM_MAXPATHLEN];</span>
<span class="line-added">492 </span>
<span class="line-added">493   wchar_t* dir_prefix = L&quot;os_windows_long_paths_dir_&quot;;</span>
<span class="line-added">494   wchar_t* empty_dir_name = L&quot;empty_directory_with_long_path&quot;;</span>
<span class="line-added">495   wchar_t* not_empty_dir_name = L&quot;not_empty_directory_with_long_path&quot;;</span>
<span class="line-added">496   wchar_t* file_name = L&quot;file&quot;;</span>
<span class="line-added">497   wchar_t dir_letter;</span>
<span class="line-added">498   WIN32_FILE_ATTRIBUTE_DATA file_data;</span>
<span class="line-added">499   bool can_test_unc = false;</span>
<span class="line-added">500 </span>
<span class="line-added">501   get_current_dir_w(cwd, sizeof(cwd) / sizeof(wchar_t));</span>
<span class="line-added">502   dir_letter = (cwd[1] == L&#39;:&#39; ? cwd[0] : L&#39;\0&#39;);</span>
<span class="line-added">503   int cwd_len = (int) wcslen(cwd);</span>
<span class="line-added">504   int dir_prefix_len = (int) wcslen(dir_prefix);</span>
<span class="line-added">505   int rel_path_len = MAX2(dir_prefix_len, 235 - cwd_len);</span>
<span class="line-added">506 </span>
<span class="line-added">507   memcpy(nearly_long_rel_path, dir_prefix, sizeof(wchar_t) * dir_prefix_len);</span>
<span class="line-added">508 </span>
<span class="line-added">509   for (int i = dir_prefix_len; i &lt; rel_path_len; ++i) {</span>
<span class="line-added">510     nearly_long_rel_path[i] = L&#39;L&#39;;</span>
<span class="line-added">511   }</span>
<span class="line-added">512 </span>
<span class="line-added">513   nearly_long_rel_path[rel_path_len] = L&#39;\0&#39;;</span>
<span class="line-added">514 </span>
<span class="line-added">515   wsprintfW(long_rel_path, L&quot;%ls\\%ls&quot;, nearly_long_rel_path, NAME_PART_250);</span>
<span class="line-added">516   wsprintfW(empty_dir_rel_path, L&quot;%ls\\%ls&quot;, nearly_long_rel_path, empty_dir_name);</span>
<span class="line-added">517   wsprintfW(not_empty_dir_rel_path, L&quot;%ls\\%ls&quot;, nearly_long_rel_path, not_empty_dir_name);</span>
<span class="line-added">518   wsprintfW(nearly_long_file_rel_path, L&quot;%ls\\%ls&quot;, nearly_long_rel_path, file_name);</span>
<span class="line-added">519   wsprintfW(file_rel_path, L&quot;%ls\\%ls\\%ls&quot;, nearly_long_rel_path, not_empty_dir_name, file_name);</span>
<span class="line-added">520   wsprintfW(nearly_long_path, L&quot;\\\\?\\%ls\\%ls&quot;, cwd, nearly_long_rel_path);</span>
<span class="line-added">521   wsprintfW(empty_dir_path, L&quot;%ls\\%ls&quot;, nearly_long_path, empty_dir_name);</span>
<span class="line-added">522   wsprintfW(not_empty_dir_path, L&quot;%ls\\%ls&quot;, nearly_long_path, not_empty_dir_name);</span>
<span class="line-added">523   wsprintfW(nearly_long_file_path, L&quot;%ls\\%ls&quot;, nearly_long_path, file_name);</span>
<span class="line-added">524   wsprintfW(file_path, L&quot;%ls\\%ls\\%ls&quot;, nearly_long_path, not_empty_dir_name, file_name);</span>
<span class="line-added">525   wsprintfW(nearly_long_unc_path, L&quot;\\\\localhost\\%lc$\\%s&quot;, dir_letter, nearly_long_path + 7);</span>
<span class="line-added">526   wsprintfW(empty_dir_unc_path, L&quot;%s\\%s&quot;, nearly_long_unc_path, empty_dir_name);</span>
<span class="line-added">527   wsprintfW(not_empty_dir_unc_path, L&quot;%s\\%s&quot;, nearly_long_unc_path, not_empty_dir_name);</span>
<span class="line-added">528   wsprintfW(nearly_long_file_unc_path, L&quot;%ls\\%ls&quot;, nearly_long_unc_path, file_name);</span>
<span class="line-added">529   wsprintfW(file_unc_path, L&quot;%s\\%s\\%s&quot;, nearly_long_unc_path, not_empty_dir_name, file_name);</span>
<span class="line-added">530   wsprintfW(root_dir_path, L&quot;%lc:\\&quot;, dir_letter);</span>
<span class="line-added">531   wsprintfW(root_rel_dir_path, L&quot;%lc:&quot;, dir_letter);</span>
<span class="line-added">532 </span>
<span class="line-added">533   RECORD_PATH(long_rel_path);</span>
<span class="line-added">534   RECORD_PATH(nearly_long_rel_path);</span>
<span class="line-added">535   RECORD_PATH(nearly_long_path);</span>
<span class="line-added">536   RECORD_PATH(nearly_long_unc_path);</span>
<span class="line-added">537   RECORD_PATH(empty_dir_rel_path);</span>
<span class="line-added">538   RECORD_PATH(empty_dir_path);</span>
<span class="line-added">539   RECORD_PATH(empty_dir_unc_path);</span>
<span class="line-added">540   RECORD_PATH(not_empty_dir_rel_path);</span>
<span class="line-added">541   RECORD_PATH(not_empty_dir_path);</span>
<span class="line-added">542   RECORD_PATH(not_empty_dir_unc_path);</span>
<span class="line-added">543   RECORD_PATH(nearly_long_file_rel_path);</span>
<span class="line-added">544   RECORD_PATH(nearly_long_file_path);</span>
<span class="line-added">545   RECORD_PATH(nearly_long_file_unc_path);</span>
<span class="line-added">546   RECORD_PATH(file_rel_path);</span>
<span class="line-added">547   RECORD_PATH(file_path);</span>
<span class="line-added">548   RECORD_PATH(file_unc_path);</span>
<span class="line-added">549 </span>
<span class="line-added">550   create_rel_directory_w(nearly_long_rel_path);</span>
<span class="line-added">551   create_rel_directory_w(long_rel_path);</span>
<span class="line-added">552   create_rel_directory_w(empty_dir_rel_path);</span>
<span class="line-added">553   create_rel_directory_w(not_empty_dir_rel_path);</span>
<span class="line-added">554   create_rel_file_w(nearly_long_file_rel_path);</span>
<span class="line-added">555   create_rel_file_w(file_rel_path);</span>
<span class="line-added">556 </span>
<span class="line-added">557   // For UNC path test we assume that the current DRIVE has a share</span>
<span class="line-added">558   // called &quot;&lt;DRIVELETTER&gt;$&quot; (so for D: we expect \\localhost\D$ to be</span>
<span class="line-added">559   // the same). Since this is only an assumption, we have to skip</span>
<span class="line-added">560   // the UNC tests if the share is missing.</span>
<span class="line-added">561   if (dir_letter &amp;&amp; !::GetFileAttributesExW(nearly_long_unc_path, GetFileExInfoStandard, &amp;file_data)) {</span>
<span class="line-added">562     printf(&quot;Disabled UNC path test, since %lc: is not mapped as share %lc$.\n&quot;, dir_letter, dir_letter);</span>
<span class="line-added">563   } else {</span>
<span class="line-added">564     can_test_unc = true;</span>
<span class="line-added">565   }</span>
<span class="line-added">566 </span>
<span class="line-added">567   if (mode == BENCH) {</span>
<span class="line-added">568     bench_path(nearly_long_path + 4);</span>
<span class="line-added">569     bench_path(nearly_long_rel_path);</span>
<span class="line-added">570     bench_path(nearly_long_file_path + 4);</span>
<span class="line-added">571     bench_path(nearly_long_file_rel_path);</span>
<span class="line-added">572   } else if (mode == EXAMPLES) {</span>
<span class="line-added">573     printf(&quot;Working directory: %ls&quot;, cwd);</span>
<span class="line-added">574 </span>
<span class="line-added">575     if (dir_letter) {</span>
<span class="line-added">576       static wchar_t top_buf[JVM_MAXPATHLEN];</span>
<span class="line-added">577       wchar_t* top_path = wcschr(cwd + 3, L&#39;\\&#39;);</span>
<span class="line-added">578 </span>
<span class="line-added">579       if (top_path) {</span>
<span class="line-added">580         size_t top_len = (top_path - cwd) - 3;</span>
<span class="line-added">581 </span>
<span class="line-added">582         memcpy(top_buf, cwd + 3, top_len * 2);</span>
<span class="line-added">583         top_buf[top_len] = L&#39;\0&#39;;</span>
<span class="line-added">584         top_path = top_buf;</span>
<span class="line-added">585       }</span>
<span class="line-added">586 </span>
<span class="line-added">587       print_attr_result(L&quot;%lc:\\&quot;, dir_letter);</span>
<span class="line-added">588       print_attr_result(L&quot;%lc:\\.\\&quot;, dir_letter);</span>
<span class="line-added">589 </span>
<span class="line-added">590       if (top_path) {</span>
<span class="line-added">591         print_attr_result(L&quot;%lc:\\%ls\\..\\%ls\\&quot;, dir_letter, top_path, top_path);</span>
<span class="line-added">592       }</span>
<span class="line-added">593 </span>
<span class="line-added">594       print_attr_result(L&quot;%lc:&quot;, dir_letter);</span>
<span class="line-added">595       print_attr_result(L&quot;%lc:.&quot;, dir_letter);</span>
<span class="line-added">596       print_attr_result(L&quot;%lc:\\COM1&quot;, dir_letter);</span>
<span class="line-added">597       print_attr_result(L&quot;%lc:\\PRN&quot;, dir_letter);</span>
<span class="line-added">598       print_attr_result(L&quot;%lc:\\PRN\\COM1&quot;, dir_letter);</span>
<span class="line-added">599       print_attr_result(L&quot;\\\\?\\UNC\\localhost\\%lc$\\&quot;, dir_letter);</span>
<span class="line-added">600       print_attr_result(L&quot;\\\\?\\UNC\\\\localhost\\%lc$\\&quot;, dir_letter);</span>
<span class="line-added">601       print_attr_result(nearly_long_unc_path);</span>
<span class="line-added">602       print_attr_result(L&quot;%ls\\.\\&quot;, nearly_long_unc_path);</span>
<span class="line-added">603       print_attr_result(L&quot;%ls\\..\\%ls&quot;, nearly_long_unc_path, nearly_long_rel_path);</span>
<span class="line-added">604       print_attr_result(L&quot;\\\\?\\UNC\\%ls&quot;, nearly_long_unc_path + 2);</span>
<span class="line-added">605       print_attr_result(file_unc_path);</span>
<span class="line-added">606       print_attr_result(L&quot;%ls\\%ls\\..\\%ls\\%ls&quot;, nearly_long_unc_path, not_empty_dir_name, not_empty_dir_name, file_name);</span>
<span class="line-added">607       print_attr_result(L&quot;%ls\\%ls\\.\\%ls&quot;, nearly_long_unc_path, not_empty_dir_name, file_name);</span>
<span class="line-added">608       print_attr_result(L&quot;\\\\?\\UNC\\%ls&quot;, file_unc_path + 2);</span>
<span class="line-added">609       print_attr_result(L&quot;\\\\?\\UNC\\%ls\\%ls\\.\\%ls&quot;, nearly_long_unc_path + 2, not_empty_dir_name, file_name);</span>
<span class="line-added">610       print_attr_result(L&quot;\\\\?\\UNC\\%ls\\%ls\\..\\%ls\\%ls&quot;, nearly_long_unc_path + 2, not_empty_dir_name, not_empty_dir_name, file_name);</span>
<span class="line-added">611     }</span>
<span class="line-added">612 </span>
<span class="line-added">613     print_attr_result(nearly_long_rel_path);</span>
<span class="line-added">614     print_attr_result(L&quot;%ls\\.\\&quot;, nearly_long_rel_path);</span>
<span class="line-added">615     print_attr_result(L&quot;%ls\\..\\%ls&quot;, nearly_long_rel_path, nearly_long_rel_path);</span>
<span class="line-added">616     print_attr_result(L&quot;%\\\\?\\%ls&quot;, nearly_long_rel_path);</span>
<span class="line-added">617     print_attr_result(L&quot;\\\\?\\%ls\\.\\&quot;, nearly_long_rel_path);</span>
<span class="line-added">618     print_attr_result(L&quot;\\\\?\\%ls\\..\\%ls&quot;, nearly_long_rel_path, nearly_long_rel_path);</span>
<span class="line-added">619 </span>
<span class="line-added">620     print_attr_result(nearly_long_path + 4);</span>
<span class="line-added">621     print_attr_result(L&quot;%ls\\.\\&quot;, nearly_long_path + 4);</span>
<span class="line-added">622     print_attr_result(L&quot;%ls\\..\\%ls&quot;, nearly_long_path + 4, nearly_long_rel_path);</span>
<span class="line-added">623     print_attr_result(nearly_long_path);</span>
<span class="line-added">624     print_attr_result(L&quot;%ls\\.\\&quot;, nearly_long_path);</span>
<span class="line-added">625     print_attr_result(L&quot;%ls\\..\\%ls&quot;, nearly_long_path, nearly_long_rel_path);</span>
<span class="line-added">626   } else {</span>
<span class="line-added">627     check_file_not_present(L&quot;&quot;);</span>
<span class="line-added">628 </span>
<span class="line-added">629     // Check relative paths</span>
<span class="line-added">630     check_dir(nearly_long_rel_path, false);</span>
<span class="line-added">631     check_dir(long_rel_path, true);</span>
<span class="line-added">632     check_dir(empty_dir_rel_path, true);</span>
<span class="line-added">633     check_dir(not_empty_dir_rel_path, false);</span>
<span class="line-added">634     check_file(nearly_long_file_rel_path);</span>
<span class="line-added">635     check_file(file_rel_path);</span>
<span class="line-added">636 </span>
<span class="line-added">637     // Check absolute paths</span>
<span class="line-added">638     if (dir_letter) {</span>
<span class="line-added">639       check_dir(root_dir_path, false);</span>
<span class="line-added">640       check_dir(root_rel_dir_path, false);</span>
<span class="line-added">641     }</span>
<span class="line-added">642 </span>
<span class="line-added">643     check_dir(cwd, false);</span>
<span class="line-added">644     check_dir(nearly_long_path + 4, false);</span>
<span class="line-added">645     check_dir(empty_dir_path + 4, true);</span>
<span class="line-added">646     check_dir(not_empty_dir_path + 4, false);</span>
<span class="line-added">647     check_file(nearly_long_file_path + 4);</span>
<span class="line-added">648     check_file(file_path + 4);</span>
<span class="line-added">649 </span>
<span class="line-added">650     // Check UNC paths</span>
<span class="line-added">651     if (can_test_unc) {</span>
<span class="line-added">652       check_dir(nearly_long_unc_path, false);</span>
<span class="line-added">653       check_dir(empty_dir_unc_path, true);</span>
<span class="line-added">654       check_dir(not_empty_dir_unc_path, false);</span>
<span class="line-added">655       check_file(nearly_long_file_unc_path);</span>
<span class="line-added">656       check_file(file_unc_path);</span>
<span class="line-added">657     }</span>
<span class="line-added">658 </span>
<span class="line-added">659     // Check handling of &lt;DRIVE&gt;:/../&lt;OTHER_DRIVE&gt;:/path/...</span>
<span class="line-added">660     // The other drive letter should not overwrite the original one.</span>
<span class="line-added">661     if (dir_letter) {</span>
<span class="line-added">662       static wchar_t tmp[JVM_MAXPATHLEN];</span>
<span class="line-added">663       wchar_t* other_letter = dir_letter == L&#39;D&#39; ? L&quot;C&quot; : L&quot;D&quot;;</span>
<span class="line-added">664       wsprintfW(tmp, L&quot;%2ls\\..\\%ls:%ls&quot;, nearly_long_file_path, other_letter, nearly_long_file_path + 2);</span>
<span class="line-added">665       check_file_not_present(tmp);</span>
<span class="line-added">666       wsprintfW(tmp, L&quot;%2ls\\..\\%ls:%ls&quot;, file_path, other_letter, file_path + 2);</span>
<span class="line-added">667       check_file_not_present(tmp);</span>
<span class="line-added">668     }</span>
<span class="line-added">669   }</span>
<span class="line-added">670 </span>
<span class="line-added">671   delete_rel_file_w(file_rel_path);</span>
<span class="line-added">672   delete_rel_file_w(nearly_long_file_rel_path);</span>
<span class="line-added">673   delete_empty_rel_directory_w(not_empty_dir_rel_path);</span>
<span class="line-added">674   delete_empty_rel_directory_w(empty_dir_rel_path);</span>
<span class="line-added">675   delete_empty_rel_directory_w(long_rel_path);</span>
<span class="line-added">676   delete_empty_rel_directory_w(nearly_long_rel_path);</span>
<span class="line-added">677 }</span>
<span class="line-added">678 </span>
679 #endif
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
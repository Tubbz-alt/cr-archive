<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff test/hotspot/gtest/runtime/test_os_windows.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="test_os_linux.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="test_synchronizer.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/gtest/runtime/test_os_windows.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -57,12 +57,12 @@</span>
    }
  
    // set globals to make sure we hit the correct code path
    FLAG_GUARD(UseLargePagesIndividualAllocation);
    FLAG_GUARD(UseNUMAInterleaving);
<span class="udiff-line-modified-removed">-   FLAG_SET_CMDLINE(bool, UseLargePagesIndividualAllocation, false);</span>
<span class="udiff-line-modified-removed">-   FLAG_SET_CMDLINE(bool, UseNUMAInterleaving, false);</span>
<span class="udiff-line-modified-added">+   FLAG_SET_CMDLINE(UseLargePagesIndividualAllocation, false);</span>
<span class="udiff-line-modified-added">+   FLAG_SET_CMDLINE(UseNUMAInterleaving, false);</span>
  
    const size_t large_allocation_size = os::large_page_size() * 4;
    char* result = os::reserve_memory_special(large_allocation_size, os::large_page_size(), NULL, false);
    if (result != NULL) {
        // failed to allocate memory, skipping the test
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -83,6 +83,597 @@</span>
  
    EXPECT_EQ(expected_location, actual_location)
          &lt;&lt; &quot;Failed to allocate memory at requested location &quot; &lt;&lt; expected_location &lt;&lt; &quot; of size &quot; &lt;&lt; expected_allocation_size;
  }
  
<span class="udiff-line-added">+ // The types of path modifications we randomly apply to a path. They should not change the file designated by the path.</span>
<span class="udiff-line-added">+ enum ModsFilter {</span>
<span class="udiff-line-added">+   Allow_None = 0, // No modifications</span>
<span class="udiff-line-added">+   Allow_Sep_Mods = 1, // Replace &#39;\\&#39; by any sequence of &#39;/&#39; or &#39;\\&#39; or at least length 1.</span>
<span class="udiff-line-added">+   Allow_Dot_Path = 2, // Add /. segments at random positions</span>
<span class="udiff-line-added">+   Allow_Dot_Dot_Path = 4, // Add /../&lt;correct-dir&gt; segments at random positions.</span>
<span class="udiff-line-added">+   Allow_All = Allow_Sep_Mods | Allow_Dot_Path | Allow_Dot_Dot_Path</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // The mode in which to run.</span>
<span class="udiff-line-added">+ enum Mode {</span>
<span class="udiff-line-added">+   TEST, // Runs the test. This is the normal modus.</span>
<span class="udiff-line-added">+   EXAMPLES, // Runs example which document the behaviour of the Windows system calls.</span>
<span class="udiff-line-added">+   BENCH // Runs a small benchmark which tries to show the costs of using the *W variants/_wfullpath.</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Parameters of the test.</span>
<span class="udiff-line-added">+ static ModsFilter mods_filter = Allow_All;</span>
<span class="udiff-line-added">+ static int mods_per_path = 50; // The number of variants of a path we try.</span>
<span class="udiff-line-added">+ static Mode mode = TEST;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Utility methods</span>
<span class="udiff-line-added">+ static void get_current_dir_w(wchar_t* path, size_t size) {</span>
<span class="udiff-line-added">+   DWORD count = GetCurrentDirectoryW((DWORD) size, path);</span>
<span class="udiff-line-added">+   EXPECT_GT((int) count, 0) &lt;&lt; &quot;Failed to get current directory: &quot; &lt;&lt; GetLastError();</span>
<span class="udiff-line-added">+   EXPECT_LT((size_t) count, size) &lt;&lt; &quot;Buffer too small for current directory: &quot; &lt;&lt; size;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define WITH_ABS_PATH(path) \</span>
<span class="udiff-line-added">+   wchar_t abs_path[JVM_MAXPATHLEN]; \</span>
<span class="udiff-line-added">+   wchar_t cwd[JVM_MAXPATHLEN]; \</span>
<span class="udiff-line-added">+   get_current_dir_w(cwd, JVM_MAXPATHLEN); \</span>
<span class="udiff-line-added">+   wsprintfW(abs_path, L&quot;\\\\?\\%ls\\%ls&quot;, cwd, (path))</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static bool file_exists_w(const wchar_t* path) {</span>
<span class="udiff-line-added">+   WIN32_FILE_ATTRIBUTE_DATA file_data;</span>
<span class="udiff-line-added">+   return ::GetFileAttributesExW(path, GetFileExInfoStandard, &amp;file_data);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void create_rel_directory_w(const wchar_t* path) {</span>
<span class="udiff-line-added">+   WITH_ABS_PATH(path);</span>
<span class="udiff-line-added">+   EXPECT_FALSE(file_exists_w(abs_path)) &lt;&lt;  &quot;Can&#39;t create directory: \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; already exists&quot;;</span>
<span class="udiff-line-added">+   BOOL result = CreateDirectoryW(abs_path, NULL);</span>
<span class="udiff-line-added">+   EXPECT_TRUE(result) &lt;&lt; &quot;Failed to create directory \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; &quot; &lt;&lt; GetLastError();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void delete_empty_rel_directory_w(const wchar_t* path) {</span>
<span class="udiff-line-added">+   WITH_ABS_PATH(path);</span>
<span class="udiff-line-added">+   EXPECT_TRUE(file_exists_w(abs_path)) &lt;&lt; &quot;Can&#39;t delete directory: \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; does not exists&quot;;</span>
<span class="udiff-line-added">+   BOOL result = RemoveDirectoryW(abs_path);</span>
<span class="udiff-line-added">+   EXPECT_TRUE(result) &lt;&lt; &quot;Failed to delete directory \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;: &quot; &lt;&lt; GetLastError();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void create_rel_file_w(const wchar_t* path) {</span>
<span class="udiff-line-added">+   WITH_ABS_PATH(path);</span>
<span class="udiff-line-added">+   EXPECT_FALSE(file_exists_w(abs_path)) &lt;&lt; &quot;Can&#39;t create file: \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; already exists&quot;;</span>
<span class="udiff-line-added">+   HANDLE h = CreateFileW(abs_path, 0, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);</span>
<span class="udiff-line-added">+   EXPECT_NE(h, INVALID_HANDLE_VALUE) &lt;&lt; &quot;Failed to create file \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;: &quot; &lt;&lt; GetLastError();</span>
<span class="udiff-line-added">+   CloseHandle(h);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void delete_rel_file_w(const wchar_t* path) {</span>
<span class="udiff-line-added">+   WITH_ABS_PATH(path);</span>
<span class="udiff-line-added">+   EXPECT_TRUE(file_exists_w(abs_path)) &lt;&lt; &quot;Can&#39;t delete file: \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; does not exists&quot;;</span>
<span class="udiff-line-added">+   BOOL result = DeleteFileW(abs_path);</span>
<span class="udiff-line-added">+   EXPECT_TRUE(result) &lt;&lt; &quot;Failed to delete file \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;: &quot; &lt;&lt; GetLastError();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static bool convert_to_cstring(char* c_str, size_t size, wchar_t* w_str) {</span>
<span class="udiff-line-added">+   size_t converted;</span>
<span class="udiff-line-added">+   errno_t err = wcstombs_s(&amp;converted, c_str, size, w_str, size - 1);</span>
<span class="udiff-line-added">+   EXPECT_EQ(err, ERROR_SUCCESS) &lt;&lt; &quot;Could not convert \&quot;&quot; &lt;&lt; w_str &lt;&lt; &quot;\&quot; to c-string&quot;;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return err == ERROR_SUCCESS;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static wchar_t* my_wcscpy_s(wchar_t* dest, size_t size, wchar_t* start, const wchar_t* to_copy) {</span>
<span class="udiff-line-added">+   size_t already_used = dest - start;</span>
<span class="udiff-line-added">+   size_t len = wcslen(to_copy);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (already_used + len &lt; size) {</span>
<span class="udiff-line-added">+     wcscpy_s(dest, size - already_used, to_copy);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return dest + wcslen(to_copy);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // The currently finite list of seperator sequences we might use instead of &#39;\\&#39;.</span>
<span class="udiff-line-added">+ static const wchar_t* sep_replacements[] = {</span>
<span class="udiff-line-added">+   L&quot;\\&quot;, L&quot;\\/&quot;, L&quot;/&quot;, L&quot;//&quot;, L&quot;\\\\/\\&quot;, L&quot;//\\/&quot;</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Takes a path and modifies it in a way that it should still designate the same file.</span>
<span class="udiff-line-added">+ static bool unnormalize_path(wchar_t* result, size_t size, bool is_dir, const wchar_t* path) {</span>
<span class="udiff-line-added">+   wchar_t* dest = result;</span>
<span class="udiff-line-added">+   const wchar_t* src = path;</span>
<span class="udiff-line-added">+   const wchar_t* path_start;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (wcsncmp(src, L&quot;\\\\?\\UNC\\&quot;, 8) == 0) {</span>
<span class="udiff-line-added">+     path_start = src + 8;</span>
<span class="udiff-line-added">+   } else if (wcsncmp(src, L&quot;\\\\?\\&quot;, 4) == 0) {</span>
<span class="udiff-line-added">+     if (src[5] == L&#39;:&#39;) {</span>
<span class="udiff-line-added">+       path_start = src + 6;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       path_start = wcschr(src + 4, L&#39;\\&#39;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else if (wcsncmp(src, L&quot;\\\\&quot;, 2) == 0) {</span>
<span class="udiff-line-added">+     path_start = wcschr(src + 2, L&#39;?&#39;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (path_start == NULL) {</span>
<span class="udiff-line-added">+       path_start = wcschr(src + 2, L&#39;\\&#39;);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       path_start = wcschr(path_start, L&#39;\\&#39;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     path_start = wcschr(src + 1, L&#39;\\&#39;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool allow_sep_change = (mods_filter &amp; Allow_Sep_Mods) &amp;&amp; (os::random() &amp; 1) == 0;</span>
<span class="udiff-line-added">+   bool allow_dot_change = (mods_filter &amp; Allow_Dot_Path) &amp;&amp; (os::random() &amp; 1) == 0;</span>
<span class="udiff-line-added">+   bool allow_dotdot_change = (mods_filter &amp; Allow_Dot_Dot_Path) &amp;&amp; (os::random() &amp; 1) == 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   while ((*src != L&#39;\0&#39;) &amp;&amp; (result + size &gt; dest)) {</span>
<span class="udiff-line-added">+     wchar_t c = *src;</span>
<span class="udiff-line-added">+     *dest = c;</span>
<span class="udiff-line-added">+     ++src;</span>
<span class="udiff-line-added">+     ++dest;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (c == L&#39;\\&#39;) {</span>
<span class="udiff-line-added">+       if (allow_sep_change &amp;&amp; (os::random() &amp; 3) == 3) {</span>
<span class="udiff-line-added">+         int i = os::random() % (sizeof(sep_replacements) / sizeof(sep_replacements[0]));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (i &gt;= 0) {</span>
<span class="udiff-line-added">+           const wchar_t* replacement = sep_replacements[i];</span>
<span class="udiff-line-added">+           dest = my_wcscpy_s(dest - 1, size,  result, replacement);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else if (path_start != NULL) {</span>
<span class="udiff-line-added">+         if (allow_dotdot_change &amp;&amp; (src &gt; path_start + 1) &amp;&amp; ((os::random() &amp; 7) == 7)) {</span>
<span class="udiff-line-added">+           wchar_t const* last_sep = src - 2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           while (last_sep[0] != L&#39;\\&#39;) {</span>
<span class="udiff-line-added">+             --last_sep;</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           if (last_sep &gt; path_start) {</span>
<span class="udiff-line-added">+             dest = my_wcscpy_s(dest, size, result, L&quot;../&quot;);</span>
<span class="udiff-line-added">+             src = last_sep + 1;</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         } else if (allow_dot_change &amp;&amp; (src &gt; path_start + 1) &amp;&amp; ((os::random() &amp; 7) == 7)) {</span>
<span class="udiff-line-added">+           dest = my_wcscpy_s(dest, size, result, L&quot;./&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   while (is_dir &amp;&amp; ((os::random() &amp; 15) == 1)) {</span>
<span class="udiff-line-added">+     dest = my_wcscpy_s(dest, size, result, L&quot;/&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (result + size &gt; dest) {</span>
<span class="udiff-line-added">+     *dest = L&#39;\0&#39;;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Use this modification only if not too close to the max size.</span>
<span class="udiff-line-added">+   return result + size - 10 &gt; dest;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void check_dir_impl(wchar_t* path, bool should_be_empty) {</span>
<span class="udiff-line-added">+   char buf[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (convert_to_cstring(buf, JVM_MAXPATHLEN, path)) {</span>
<span class="udiff-line-added">+     struct stat st;</span>
<span class="udiff-line-added">+     EXPECT_EQ(os::stat(buf, &amp;st), 0) &lt;&lt; &quot;os::stat failed for \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;&quot;;</span>
<span class="udiff-line-added">+     EXPECT_EQ(st.st_mode &amp; S_IFMT, S_IFDIR) &lt;&lt; &quot;\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; is not a directory according to os::stat&quot;;</span>
<span class="udiff-line-added">+     errno = ERROR_SUCCESS;</span>
<span class="udiff-line-added">+     bool is_empty = os::dir_is_empty(buf);</span>
<span class="udiff-line-added">+     errno_t err = errno;</span>
<span class="udiff-line-added">+     EXPECT_EQ(is_empty, should_be_empty) &lt;&lt; &quot;os::dir_is_empty assumed \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; is &quot;</span>
<span class="udiff-line-added">+                                          &lt;&lt; (should_be_empty ?  &quot;not &quot;: &quot;&quot;) &lt;&lt; &quot;empty&quot;;</span>
<span class="udiff-line-added">+     EXPECT_EQ(err, ERROR_SUCCESS) &lt;&lt; &quot;os::dir_is_empty failed for \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;with errno &quot; &lt;&lt; err;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void check_file_impl(wchar_t* path) {</span>
<span class="udiff-line-added">+   char buf[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (convert_to_cstring(buf, JVM_MAXPATHLEN, path)) {</span>
<span class="udiff-line-added">+     struct stat st;</span>
<span class="udiff-line-added">+     EXPECT_EQ(os::stat(buf, &amp;st), 0) &lt;&lt; &quot;os::stat failed for \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;&quot;;</span>
<span class="udiff-line-added">+     EXPECT_EQ(st.st_mode &amp; S_IFMT, S_IFREG) &lt;&lt; &quot;\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; is not a regular file according to os::stat&quot;;</span>
<span class="udiff-line-added">+     int fd = os::open(buf, O_RDONLY, 0);</span>
<span class="udiff-line-added">+     EXPECT_NE(fd, -1) &lt;&lt; &quot;os::open failed for \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; with errno &quot; &lt;&lt; errno;</span>
<span class="udiff-line-added">+     if (fd &gt;= 0) {</span>
<span class="udiff-line-added">+       ::close(fd);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void check_file_not_present_impl(wchar_t* path) {</span>
<span class="udiff-line-added">+   char buf[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (convert_to_cstring(buf, JVM_MAXPATHLEN, path)) {</span>
<span class="udiff-line-added">+     struct stat st;</span>
<span class="udiff-line-added">+     int stat_ret;</span>
<span class="udiff-line-added">+     EXPECT_EQ(stat_ret = os::stat(buf, &amp;st), -1) &lt;&lt; &quot;os::stat did not fail for \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;&quot;;</span>
<span class="udiff-line-added">+     if (stat_ret != -1) {</span>
<span class="udiff-line-added">+       // Only check open if stat not already failed.</span>
<span class="udiff-line-added">+       int fd = os::open(buf, O_RDONLY, 0);</span>
<span class="udiff-line-added">+       EXPECT_EQ(fd, -1) &lt;&lt; &quot;os::open did not fail for \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;&quot;;</span>
<span class="udiff-line-added">+       if (fd &gt;= 0) {</span>
<span class="udiff-line-added">+         ::close(fd);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void check_dir(wchar_t* path, bool should_be_empty) {</span>
<span class="udiff-line-added">+   check_dir_impl(path, should_be_empty);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (int i = 0; mods_filter != Allow_None &amp;&amp; i &lt; mods_per_path; ++i) {</span>
<span class="udiff-line-added">+     wchar_t tmp[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+     if (unnormalize_path(tmp, JVM_MAXPATHLEN, true, path)) {</span>
<span class="udiff-line-added">+       check_dir_impl(tmp, should_be_empty);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void check_file(wchar_t* path) {</span>
<span class="udiff-line-added">+   check_file_impl(path);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Check os::same_files at least somewhat.</span>
<span class="udiff-line-added">+   char buf[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (convert_to_cstring(buf, JVM_MAXPATHLEN, path)) {</span>
<span class="udiff-line-added">+     wchar_t mod[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (unnormalize_path(mod, JVM_MAXPATHLEN, false, path)) {</span>
<span class="udiff-line-added">+       char mod_c[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+       if (convert_to_cstring(mod_c, JVM_MAXPATHLEN, mod)) {</span>
<span class="udiff-line-added">+         EXPECT_EQ(os::same_files(buf, mod_c), true) &lt;&lt; &quot;os::same files failed for \\&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; and \&quot;&quot; &lt;&lt; mod_c &lt;&lt; &quot;\&quot;&quot;;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (int i = 0; mods_filter != Allow_None &amp;&amp; i &lt; mods_per_path; ++i) {</span>
<span class="udiff-line-added">+     wchar_t tmp[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+     if (unnormalize_path(tmp, JVM_MAXPATHLEN, false, path)) {</span>
<span class="udiff-line-added">+       check_file_impl(tmp);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void check_file_not_present(wchar_t* path) {</span>
<span class="udiff-line-added">+   check_file_not_present_impl(path);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (int i = 0; mods_filter != Allow_None &amp;&amp; i &lt; mods_per_path; ++i) {</span>
<span class="udiff-line-added">+     wchar_t tmp[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+     if (unnormalize_path(tmp, JVM_MAXPATHLEN, false, path)) {</span>
<span class="udiff-line-added">+       check_file_not_present_impl(tmp);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void record_path(char const* name, char const* len_name, wchar_t* path) {</span>
<span class="udiff-line-added">+   char buf[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (convert_to_cstring(buf, JVM_MAXPATHLEN, path)) {</span>
<span class="udiff-line-added">+     ::testing::Test::RecordProperty(name, buf);</span>
<span class="udiff-line-added">+     os::snprintf(buf, JVM_MAXPATHLEN, &quot;%d&quot;, (int) wcslen(path));</span>
<span class="udiff-line-added">+     ::testing::Test::RecordProperty(len_name, buf);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void bench_path(wchar_t* path) {</span>
<span class="udiff-line-added">+   char buf[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   int reps = 100000;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (convert_to_cstring(buf, JVM_MAXPATHLEN, path)) {</span>
<span class="udiff-line-added">+     jlong wtime[2];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (int t = 0; t &lt; 2; ++t) {</span>
<span class="udiff-line-added">+       wtime[t] = os::javaTimeNanos();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       for (int i = 0; i &lt; reps; ++i) {</span>
<span class="udiff-line-added">+         bool succ = false;</span>
<span class="udiff-line-added">+         size_t buf_len = strlen(buf);</span>
<span class="udiff-line-added">+         wchar_t* w_path = (wchar_t*) os::malloc(sizeof(wchar_t) * (buf_len + 1), mtInternal);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (w_path != NULL) {</span>
<span class="udiff-line-added">+           size_t converted_chars;</span>
<span class="udiff-line-added">+           if (::mbstowcs_s(&amp;converted_chars, w_path, buf_len + 1, buf, buf_len) == ERROR_SUCCESS) {</span>
<span class="udiff-line-added">+             if (t == 1) {</span>
<span class="udiff-line-added">+               wchar_t* tmp = (wchar_t*) os::malloc(sizeof(wchar_t) * JVM_MAXPATHLEN, mtInternal);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+               if (tmp) {</span>
<span class="udiff-line-added">+                 if (_wfullpath(tmp, w_path, JVM_MAXPATHLEN)) {</span>
<span class="udiff-line-added">+                   succ = true;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // Note that we really don&#39;t use the full path name, but just add the cost of running _wfullpath.</span>
<span class="udiff-line-added">+                 os::free(tmp);</span>
<span class="udiff-line-added">+               }</span>
<span class="udiff-line-added">+               if (!succ) {</span>
<span class="udiff-line-added">+                 printf(&quot;Failed fullpathing \&quot;%s\&quot;\n&quot;, buf);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+               }</span>
<span class="udiff-line-added">+               succ = false;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             HANDLE h = ::CreateFileW(w_path, 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (h != INVALID_HANDLE_VALUE) {</span>
<span class="udiff-line-added">+               ::CloseHandle(h);</span>
<span class="udiff-line-added">+               succ = true;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         os::free(w_path);</span>
<span class="udiff-line-added">+         if (!succ) {</span>
<span class="udiff-line-added">+           printf(&quot;Failed getting W*attr. \&quot;%s\&quot;\n&quot;, buf);</span>
<span class="udiff-line-added">+           return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       wtime[t] = os::javaTimeNanos() - wtime[t];</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     jlong ctime = os::javaTimeNanos();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (int i = 0; i &lt; reps; ++i) {</span>
<span class="udiff-line-added">+       HANDLE h = ::CreateFileA(buf, 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (h == INVALID_HANDLE_VALUE) {</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       ::CloseHandle(h);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ctime = os::javaTimeNanos() - ctime;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     printf(&quot;\&quot;%s\&quot; %f us for *A, %f us for *W, %f us for *W with fullpath\n&quot;, buf,</span>
<span class="udiff-line-added">+       0.001 * ctime / reps, 0.001 * wtime[0] / reps, 0.001 * wtime[1] / reps);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void print_attr_result_for_path(wchar_t* path) {</span>
<span class="udiff-line-added">+   WIN32_FILE_ATTRIBUTE_DATA file_data;</span>
<span class="udiff-line-added">+   struct stat st;</span>
<span class="udiff-line-added">+   char buf[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   wchar_t abs[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   _wfullpath(abs, path, JVM_MAXPATHLEN);</span>
<span class="udiff-line-added">+   printf(&quot;Checking \&quot;%ls\&quot; (%d chars):\n&quot;, path, (int) wcslen(path));</span>
<span class="udiff-line-added">+   printf(&quot;_wfullpath             %ls (%d chars)\n&quot;, abs, (int) wcslen(abs));</span>
<span class="udiff-line-added">+   BOOL bret = ::GetFileAttributesExW(path, GetFileExInfoStandard, &amp;file_data);</span>
<span class="udiff-line-added">+   printf(&quot;GetFileAttributesExW() %s\n&quot;, bret ? &quot;success&quot; : &quot;failed&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (convert_to_cstring(buf, JVM_MAXPATHLEN, path)) {</span>
<span class="udiff-line-added">+     bret = ::GetFileAttributesExA(buf, GetFileExInfoStandard, &amp;file_data);</span>
<span class="udiff-line-added">+     printf(&quot;GetFileAttributesExA() %s\n&quot;, bret ? &quot;success&quot; : &quot;failed&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bool succ = os::stat(buf, &amp;st) != -1;</span>
<span class="udiff-line-added">+     printf(&quot;os::stat()             %s\n&quot;, succ ? &quot;success&quot; : &quot;failed&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void print_attr_result(wchar_t* format, ...) {</span>
<span class="udiff-line-added">+   va_list argptr;</span>
<span class="udiff-line-added">+   wchar_t buf[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   va_start(argptr, format);</span>
<span class="udiff-line-added">+   wvsprintfW(buf, format, argptr);</span>
<span class="udiff-line-added">+   print_attr_result_for_path(buf);</span>
<span class="udiff-line-added">+   va_end(argptr);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define RECORD_PATH(name) record_path(#name, #name &quot;Len&quot;, name)</span>
<span class="udiff-line-added">+ #define NAME_PART_50 L&quot;01234567890123456789012345678901234567890123456789&quot;</span>
<span class="udiff-line-added">+ #define NAME_PART_250 NAME_PART_50 NAME_PART_50 NAME_PART_50 NAME_PART_50 NAME_PART_50</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Test which tries to find out if the os::stat, os::open, os::same_files and os::dir_is_empty methods</span>
<span class="udiff-line-added">+ // can handle long path names correctly.</span>
<span class="udiff-line-added">+ TEST_VM(os_windows, handle_long_paths) {</span>
<span class="udiff-line-added">+   static wchar_t cwd[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t nearly_long_rel_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t long_rel_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t empty_dir_rel_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t not_empty_dir_rel_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t file_rel_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t nearly_long_file_rel_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t nearly_long_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t empty_dir_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t not_empty_dir_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t nearly_long_file_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t file_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t nearly_long_unc_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t empty_dir_unc_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t not_empty_dir_unc_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t nearly_long_file_unc_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t file_unc_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t root_dir_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   static wchar_t root_rel_dir_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   wchar_t* dir_prefix = L&quot;os_windows_long_paths_dir_&quot;;</span>
<span class="udiff-line-added">+   wchar_t* empty_dir_name = L&quot;empty_directory_with_long_path&quot;;</span>
<span class="udiff-line-added">+   wchar_t* not_empty_dir_name = L&quot;not_empty_directory_with_long_path&quot;;</span>
<span class="udiff-line-added">+   wchar_t* file_name = L&quot;file&quot;;</span>
<span class="udiff-line-added">+   wchar_t dir_letter;</span>
<span class="udiff-line-added">+   WIN32_FILE_ATTRIBUTE_DATA file_data;</span>
<span class="udiff-line-added">+   bool can_test_unc = false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   get_current_dir_w(cwd, sizeof(cwd) / sizeof(wchar_t));</span>
<span class="udiff-line-added">+   dir_letter = (cwd[1] == L&#39;:&#39; ? cwd[0] : L&#39;\0&#39;);</span>
<span class="udiff-line-added">+   int cwd_len = (int) wcslen(cwd);</span>
<span class="udiff-line-added">+   int dir_prefix_len = (int) wcslen(dir_prefix);</span>
<span class="udiff-line-added">+   int rel_path_len = MAX2(dir_prefix_len, 235 - cwd_len);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   memcpy(nearly_long_rel_path, dir_prefix, sizeof(wchar_t) * dir_prefix_len);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (int i = dir_prefix_len; i &lt; rel_path_len; ++i) {</span>
<span class="udiff-line-added">+     nearly_long_rel_path[i] = L&#39;L&#39;;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   nearly_long_rel_path[rel_path_len] = L&#39;\0&#39;;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   wsprintfW(long_rel_path, L&quot;%ls\\%ls&quot;, nearly_long_rel_path, NAME_PART_250);</span>
<span class="udiff-line-added">+   wsprintfW(empty_dir_rel_path, L&quot;%ls\\%ls&quot;, nearly_long_rel_path, empty_dir_name);</span>
<span class="udiff-line-added">+   wsprintfW(not_empty_dir_rel_path, L&quot;%ls\\%ls&quot;, nearly_long_rel_path, not_empty_dir_name);</span>
<span class="udiff-line-added">+   wsprintfW(nearly_long_file_rel_path, L&quot;%ls\\%ls&quot;, nearly_long_rel_path, file_name);</span>
<span class="udiff-line-added">+   wsprintfW(file_rel_path, L&quot;%ls\\%ls\\%ls&quot;, nearly_long_rel_path, not_empty_dir_name, file_name);</span>
<span class="udiff-line-added">+   wsprintfW(nearly_long_path, L&quot;\\\\?\\%ls\\%ls&quot;, cwd, nearly_long_rel_path);</span>
<span class="udiff-line-added">+   wsprintfW(empty_dir_path, L&quot;%ls\\%ls&quot;, nearly_long_path, empty_dir_name);</span>
<span class="udiff-line-added">+   wsprintfW(not_empty_dir_path, L&quot;%ls\\%ls&quot;, nearly_long_path, not_empty_dir_name);</span>
<span class="udiff-line-added">+   wsprintfW(nearly_long_file_path, L&quot;%ls\\%ls&quot;, nearly_long_path, file_name);</span>
<span class="udiff-line-added">+   wsprintfW(file_path, L&quot;%ls\\%ls\\%ls&quot;, nearly_long_path, not_empty_dir_name, file_name);</span>
<span class="udiff-line-added">+   wsprintfW(nearly_long_unc_path, L&quot;\\\\localhost\\%lc$\\%s&quot;, dir_letter, nearly_long_path + 7);</span>
<span class="udiff-line-added">+   wsprintfW(empty_dir_unc_path, L&quot;%s\\%s&quot;, nearly_long_unc_path, empty_dir_name);</span>
<span class="udiff-line-added">+   wsprintfW(not_empty_dir_unc_path, L&quot;%s\\%s&quot;, nearly_long_unc_path, not_empty_dir_name);</span>
<span class="udiff-line-added">+   wsprintfW(nearly_long_file_unc_path, L&quot;%ls\\%ls&quot;, nearly_long_unc_path, file_name);</span>
<span class="udiff-line-added">+   wsprintfW(file_unc_path, L&quot;%s\\%s\\%s&quot;, nearly_long_unc_path, not_empty_dir_name, file_name);</span>
<span class="udiff-line-added">+   wsprintfW(root_dir_path, L&quot;%lc:\\&quot;, dir_letter);</span>
<span class="udiff-line-added">+   wsprintfW(root_rel_dir_path, L&quot;%lc:&quot;, dir_letter);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   RECORD_PATH(long_rel_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(nearly_long_rel_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(nearly_long_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(nearly_long_unc_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(empty_dir_rel_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(empty_dir_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(empty_dir_unc_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(not_empty_dir_rel_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(not_empty_dir_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(not_empty_dir_unc_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(nearly_long_file_rel_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(nearly_long_file_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(nearly_long_file_unc_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(file_rel_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(file_path);</span>
<span class="udiff-line-added">+   RECORD_PATH(file_unc_path);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   create_rel_directory_w(nearly_long_rel_path);</span>
<span class="udiff-line-added">+   create_rel_directory_w(long_rel_path);</span>
<span class="udiff-line-added">+   create_rel_directory_w(empty_dir_rel_path);</span>
<span class="udiff-line-added">+   create_rel_directory_w(not_empty_dir_rel_path);</span>
<span class="udiff-line-added">+   create_rel_file_w(nearly_long_file_rel_path);</span>
<span class="udiff-line-added">+   create_rel_file_w(file_rel_path);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // For UNC path test we assume that the current DRIVE has a share</span>
<span class="udiff-line-added">+   // called &quot;&lt;DRIVELETTER&gt;$&quot; (so for D: we expect \\localhost\D$ to be</span>
<span class="udiff-line-added">+   // the same). Since this is only an assumption, we have to skip</span>
<span class="udiff-line-added">+   // the UNC tests if the share is missing.</span>
<span class="udiff-line-added">+   if (dir_letter &amp;&amp; !::GetFileAttributesExW(nearly_long_unc_path, GetFileExInfoStandard, &amp;file_data)) {</span>
<span class="udiff-line-added">+     printf(&quot;Disabled UNC path test, since %lc: is not mapped as share %lc$.\n&quot;, dir_letter, dir_letter);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     can_test_unc = true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (mode == BENCH) {</span>
<span class="udiff-line-added">+     bench_path(nearly_long_path + 4);</span>
<span class="udiff-line-added">+     bench_path(nearly_long_rel_path);</span>
<span class="udiff-line-added">+     bench_path(nearly_long_file_path + 4);</span>
<span class="udiff-line-added">+     bench_path(nearly_long_file_rel_path);</span>
<span class="udiff-line-added">+   } else if (mode == EXAMPLES) {</span>
<span class="udiff-line-added">+     printf(&quot;Working directory: %ls&quot;, cwd);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (dir_letter) {</span>
<span class="udiff-line-added">+       static wchar_t top_buf[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+       wchar_t* top_path = wcschr(cwd + 3, L&#39;\\&#39;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (top_path) {</span>
<span class="udiff-line-added">+         size_t top_len = (top_path - cwd) - 3;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         memcpy(top_buf, cwd + 3, top_len * 2);</span>
<span class="udiff-line-added">+         top_buf[top_len] = L&#39;\0&#39;;</span>
<span class="udiff-line-added">+         top_path = top_buf;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       print_attr_result(L&quot;%lc:\\&quot;, dir_letter);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;%lc:\\.\\&quot;, dir_letter);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (top_path) {</span>
<span class="udiff-line-added">+         print_attr_result(L&quot;%lc:\\%ls\\..\\%ls\\&quot;, dir_letter, top_path, top_path);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       print_attr_result(L&quot;%lc:&quot;, dir_letter);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;%lc:.&quot;, dir_letter);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;%lc:\\COM1&quot;, dir_letter);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;%lc:\\PRN&quot;, dir_letter);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;%lc:\\PRN\\COM1&quot;, dir_letter);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;\\\\?\\UNC\\localhost\\%lc$\\&quot;, dir_letter);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;\\\\?\\UNC\\\\localhost\\%lc$\\&quot;, dir_letter);</span>
<span class="udiff-line-added">+       print_attr_result(nearly_long_unc_path);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;%ls\\.\\&quot;, nearly_long_unc_path);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;%ls\\..\\%ls&quot;, nearly_long_unc_path, nearly_long_rel_path);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;\\\\?\\UNC\\%ls&quot;, nearly_long_unc_path + 2);</span>
<span class="udiff-line-added">+       print_attr_result(file_unc_path);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;%ls\\%ls\\..\\%ls\\%ls&quot;, nearly_long_unc_path, not_empty_dir_name, not_empty_dir_name, file_name);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;%ls\\%ls\\.\\%ls&quot;, nearly_long_unc_path, not_empty_dir_name, file_name);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;\\\\?\\UNC\\%ls&quot;, file_unc_path + 2);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;\\\\?\\UNC\\%ls\\%ls\\.\\%ls&quot;, nearly_long_unc_path + 2, not_empty_dir_name, file_name);</span>
<span class="udiff-line-added">+       print_attr_result(L&quot;\\\\?\\UNC\\%ls\\%ls\\..\\%ls\\%ls&quot;, nearly_long_unc_path + 2, not_empty_dir_name, not_empty_dir_name, file_name);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     print_attr_result(nearly_long_rel_path);</span>
<span class="udiff-line-added">+     print_attr_result(L&quot;%ls\\.\\&quot;, nearly_long_rel_path);</span>
<span class="udiff-line-added">+     print_attr_result(L&quot;%ls\\..\\%ls&quot;, nearly_long_rel_path, nearly_long_rel_path);</span>
<span class="udiff-line-added">+     print_attr_result(L&quot;%\\\\?\\%ls&quot;, nearly_long_rel_path);</span>
<span class="udiff-line-added">+     print_attr_result(L&quot;\\\\?\\%ls\\.\\&quot;, nearly_long_rel_path);</span>
<span class="udiff-line-added">+     print_attr_result(L&quot;\\\\?\\%ls\\..\\%ls&quot;, nearly_long_rel_path, nearly_long_rel_path);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     print_attr_result(nearly_long_path + 4);</span>
<span class="udiff-line-added">+     print_attr_result(L&quot;%ls\\.\\&quot;, nearly_long_path + 4);</span>
<span class="udiff-line-added">+     print_attr_result(L&quot;%ls\\..\\%ls&quot;, nearly_long_path + 4, nearly_long_rel_path);</span>
<span class="udiff-line-added">+     print_attr_result(nearly_long_path);</span>
<span class="udiff-line-added">+     print_attr_result(L&quot;%ls\\.\\&quot;, nearly_long_path);</span>
<span class="udiff-line-added">+     print_attr_result(L&quot;%ls\\..\\%ls&quot;, nearly_long_path, nearly_long_rel_path);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     check_file_not_present(L&quot;&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Check relative paths</span>
<span class="udiff-line-added">+     check_dir(nearly_long_rel_path, false);</span>
<span class="udiff-line-added">+     check_dir(long_rel_path, true);</span>
<span class="udiff-line-added">+     check_dir(empty_dir_rel_path, true);</span>
<span class="udiff-line-added">+     check_dir(not_empty_dir_rel_path, false);</span>
<span class="udiff-line-added">+     check_file(nearly_long_file_rel_path);</span>
<span class="udiff-line-added">+     check_file(file_rel_path);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Check absolute paths</span>
<span class="udiff-line-added">+     if (dir_letter) {</span>
<span class="udiff-line-added">+       check_dir(root_dir_path, false);</span>
<span class="udiff-line-added">+       check_dir(root_rel_dir_path, false);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     check_dir(cwd, false);</span>
<span class="udiff-line-added">+     check_dir(nearly_long_path + 4, false);</span>
<span class="udiff-line-added">+     check_dir(empty_dir_path + 4, true);</span>
<span class="udiff-line-added">+     check_dir(not_empty_dir_path + 4, false);</span>
<span class="udiff-line-added">+     check_file(nearly_long_file_path + 4);</span>
<span class="udiff-line-added">+     check_file(file_path + 4);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Check UNC paths</span>
<span class="udiff-line-added">+     if (can_test_unc) {</span>
<span class="udiff-line-added">+       check_dir(nearly_long_unc_path, false);</span>
<span class="udiff-line-added">+       check_dir(empty_dir_unc_path, true);</span>
<span class="udiff-line-added">+       check_dir(not_empty_dir_unc_path, false);</span>
<span class="udiff-line-added">+       check_file(nearly_long_file_unc_path);</span>
<span class="udiff-line-added">+       check_file(file_unc_path);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Check handling of &lt;DRIVE&gt;:/../&lt;OTHER_DRIVE&gt;:/path/...</span>
<span class="udiff-line-added">+     // The other drive letter should not overwrite the original one.</span>
<span class="udiff-line-added">+     if (dir_letter) {</span>
<span class="udiff-line-added">+       static wchar_t tmp[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+       wchar_t* other_letter = dir_letter == L&#39;D&#39; ? L&quot;C&quot; : L&quot;D&quot;;</span>
<span class="udiff-line-added">+       wsprintfW(tmp, L&quot;%2ls\\..\\%ls:%ls&quot;, nearly_long_file_path, other_letter, nearly_long_file_path + 2);</span>
<span class="udiff-line-added">+       check_file_not_present(tmp);</span>
<span class="udiff-line-added">+       wsprintfW(tmp, L&quot;%2ls\\..\\%ls:%ls&quot;, file_path, other_letter, file_path + 2);</span>
<span class="udiff-line-added">+       check_file_not_present(tmp);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   delete_rel_file_w(file_rel_path);</span>
<span class="udiff-line-added">+   delete_rel_file_w(nearly_long_file_rel_path);</span>
<span class="udiff-line-added">+   delete_empty_rel_directory_w(not_empty_dir_rel_path);</span>
<span class="udiff-line-added">+   delete_empty_rel_directory_w(empty_dir_rel_path);</span>
<span class="udiff-line-added">+   delete_empty_rel_directory_w(long_rel_path);</span>
<span class="udiff-line-added">+   delete_empty_rel_directory_w(nearly_long_rel_path);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  #endif
</pre>
<center><a href="test_os_linux.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="test_synchronizer.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
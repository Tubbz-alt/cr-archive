<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/hotspot/gtest/gc/shared/test_collectorPolicy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="test_collectedHeap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="test_oopStorage.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/gtest/gc/shared/test_collectorPolicy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 20,11 ***</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/flags/flagSetting.hpp&quot;
  #include &quot;runtime/globals_extension.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-new-header">--- 20,11 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-modified">! #include &quot;gc/serial/serialArguments.hpp&quot;</span>
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/flags/flagSetting.hpp&quot;
  #include &quot;runtime/globals_extension.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 52,36 ***</span>
      const size_t param2;
     public:
      BinaryExecutor(size_t val1, size_t val2) : param1(val1), param2(val2) { }
    };
  
<span class="line-removed">-   class MinHeapSizeGuard {</span>
<span class="line-removed">-    private:</span>
<span class="line-removed">-     const size_t _stored_min_heap_size;</span>
<span class="line-removed">-    public:</span>
<span class="line-removed">-     MinHeapSizeGuard() : _stored_min_heap_size(Arguments::min_heap_size()) { }</span>
<span class="line-removed">-     ~MinHeapSizeGuard() {</span>
<span class="line-removed">-       Arguments::set_min_heap_size(_stored_min_heap_size);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- </span>
    class TestWrapper {
     public:
      static void test(Executor* setter1, Executor* setter2, Executor* checker) {
        FLAG_GUARD(InitialHeapSize);
        FLAG_GUARD(MaxHeapSize);
        FLAG_GUARD(MaxNewSize);
        FLAG_GUARD(MinHeapDeltaBytes);
        FLAG_GUARD(NewSize);
        FLAG_GUARD(OldSize);
<span class="line-removed">-       MinHeapSizeGuard min_heap_size_guard;</span>
  
<span class="line-modified">!       FLAG_SET_ERGO(size_t, InitialHeapSize, 100 * M);</span>
<span class="line-modified">!       FLAG_SET_ERGO(size_t, OldSize, 4 * M);</span>
<span class="line-modified">!       FLAG_SET_ERGO(size_t, NewSize, 1 * M);</span>
<span class="line-modified">!       FLAG_SET_ERGO(size_t, MaxNewSize, 80 * M);</span>
<span class="line-modified">!       Arguments::set_min_heap_size(40 * M);</span>
  
        ASSERT_NO_FATAL_FAILURE(setter1-&gt;execute());
  
        if (setter2 != NULL) {
          ASSERT_NO_FATAL_FAILURE(setter2-&gt;execute());
<span class="line-new-header">--- 52,26 ---</span>
      const size_t param2;
     public:
      BinaryExecutor(size_t val1, size_t val2) : param1(val1), param2(val2) { }
    };
  
    class TestWrapper {
     public:
      static void test(Executor* setter1, Executor* setter2, Executor* checker) {
<span class="line-added">+       FLAG_GUARD(MinHeapSize);</span>
        FLAG_GUARD(InitialHeapSize);
        FLAG_GUARD(MaxHeapSize);
        FLAG_GUARD(MaxNewSize);
        FLAG_GUARD(MinHeapDeltaBytes);
        FLAG_GUARD(NewSize);
        FLAG_GUARD(OldSize);
  
<span class="line-modified">!       MinHeapSize = 40 * M;</span>
<span class="line-modified">!       FLAG_SET_ERGO(InitialHeapSize, 100 * M);</span>
<span class="line-modified">!       FLAG_SET_ERGO(OldSize, 4 * M);</span>
<span class="line-modified">!       FLAG_SET_ERGO(NewSize, 1 * M);</span>
<span class="line-modified">!       FLAG_SET_ERGO(MaxNewSize, 80 * M);</span>
  
        ASSERT_NO_FATAL_FAILURE(setter1-&gt;execute());
  
        if (setter2 != NULL) {
          ASSERT_NO_FATAL_FAILURE(setter2-&gt;execute());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,121 ***</span>
  
    class SetNewSizeErgo : public UnaryExecutor {
     public:
      SetNewSizeErgo(size_t param) : UnaryExecutor(param) { }
      void execute() {
<span class="line-modified">!       FLAG_SET_ERGO(size_t, NewSize, param);</span>
      }
    };
  
    class CheckYoungMin : public UnaryExecutor {
     public:
      CheckYoungMin(size_t param) : UnaryExecutor(param) { }
      void execute() {
<span class="line-modified">!       MarkSweepPolicy msp;</span>
<span class="line-modified">!       msp.initialize_all();</span>
<span class="line-modified">!       ASSERT_LE(msp.min_young_size(), param);</span>
      }
    };
  
    class CheckScaledYoungInitial : public Executor {
     public:
      void execute() {
        size_t initial_heap_size = InitialHeapSize;
<span class="line-modified">!       MarkSweepPolicy msp;</span>
<span class="line-modified">!       msp.initialize_all();</span>
  
        if (InitialHeapSize &gt; initial_heap_size) {
<span class="line-modified">!         // InitialHeapSize was adapted by msp.initialize_all, e.g. due to alignment</span>
          // caused by 64K page size.
          initial_heap_size = InitialHeapSize;
        }
  
<span class="line-modified">!       size_t expected = msp.scale_by_NewRatio_aligned(initial_heap_size);</span>
<span class="line-removed">-       ASSERT_EQ(expected, msp.initial_young_size());</span>
        ASSERT_EQ(expected, NewSize);
      }
    };
  
    class SetNewSizeCmd : public UnaryExecutor {
     public:
      SetNewSizeCmd(size_t param) : UnaryExecutor(param) { }
      void execute() {
<span class="line-modified">!       FLAG_SET_CMDLINE(size_t, NewSize, param);</span>
      }
    };
  
    class CheckYoungInitial : public UnaryExecutor {
     public:
      CheckYoungInitial(size_t param) : UnaryExecutor(param) { }
      void execute() {
<span class="line-modified">!       MarkSweepPolicy msp;</span>
<span class="line-modified">!       msp.initialize_all();</span>
  
<span class="line-modified">!       ASSERT_EQ(param, msp.initial_young_size());</span>
      }
    };
  
    class SetOldSizeCmd : public UnaryExecutor {
     public:
      SetOldSizeCmd(size_t param) : UnaryExecutor(param) { }
      void execute() {
<span class="line-modified">!       FLAG_SET_CMDLINE(size_t, OldSize, param);</span>
      }
    };
  
    class SetMaxNewSizeCmd : public BinaryExecutor {
     public:
      SetMaxNewSizeCmd(size_t param1, size_t param2) : BinaryExecutor(param1, param2) { }
      void execute() {
<span class="line-modified">!       size_t heap_alignment = CollectorPolicy::compute_heap_alignment();</span>
        size_t new_size_value = align_up(MaxHeapSize, heap_alignment)
                - param1 + param2;
<span class="line-modified">!       FLAG_SET_CMDLINE(size_t, MaxNewSize, new_size_value);</span>
      }
    };
  
    class CheckOldMin : public UnaryExecutor {
     public:
      CheckOldMin(size_t param) : UnaryExecutor(param) { }
      void execute() {
<span class="line-modified">!       MarkSweepPolicy msp;</span>
<span class="line-modified">!       msp.initialize_all();</span>
<span class="line-modified">!       ASSERT_LE(msp.min_old_size(), param);</span>
      }
    };
  
    class CheckOldInitial : public Executor {
     public:
      void execute() {
<span class="line-modified">!       size_t heap_alignment = CollectorPolicy::compute_heap_alignment();</span>
  
<span class="line-modified">!       MarkSweepPolicy msp;</span>
<span class="line-modified">!       msp.initialize_all();</span>
  
        size_t expected_old_initial = align_up(InitialHeapSize, heap_alignment)
                - MaxNewSize;
  
<span class="line-modified">!       ASSERT_EQ(expected_old_initial, msp.initial_old_size());</span>
      }
    };
  
    class CheckOldInitialMaxNewSize : public BinaryExecutor {
     public:
      CheckOldInitialMaxNewSize(size_t param1, size_t param2) : BinaryExecutor(param1, param2) { }
      void execute() {
<span class="line-modified">!       size_t heap_alignment = CollectorPolicy::compute_heap_alignment();</span>
        size_t new_size_value = align_up(MaxHeapSize, heap_alignment)
                - param1 + param2;
  
<span class="line-modified">!       MarkSweepPolicy msp;</span>
<span class="line-modified">!       msp.initialize_all();</span>
  
        size_t expected_old_initial = align_up(MaxHeapSize, heap_alignment)
                - new_size_value;
  
<span class="line-modified">!       ASSERT_EQ(expected_old_initial, msp.initial_old_size());</span>
      }
    };
  };
  
  
<span class="line-new-header">--- 86,125 ---</span>
  
    class SetNewSizeErgo : public UnaryExecutor {
     public:
      SetNewSizeErgo(size_t param) : UnaryExecutor(param) { }
      void execute() {
<span class="line-modified">!       FLAG_SET_ERGO(NewSize, param);</span>
      }
    };
  
    class CheckYoungMin : public UnaryExecutor {
     public:
      CheckYoungMin(size_t param) : UnaryExecutor(param) { }
      void execute() {
<span class="line-modified">!       SerialArguments sa;</span>
<span class="line-modified">!       sa.initialize_heap_sizes();</span>
<span class="line-modified">!       ASSERT_LE(MinNewSize, param);</span>
      }
    };
  
<span class="line-added">+   static size_t scale_by_NewRatio_aligned(size_t value, size_t alignment) {</span>
<span class="line-added">+     // Accessible via friend declaration</span>
<span class="line-added">+     return GenArguments::scale_by_NewRatio_aligned(value, alignment);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    class CheckScaledYoungInitial : public Executor {
     public:
      void execute() {
        size_t initial_heap_size = InitialHeapSize;
<span class="line-modified">!       SerialArguments sa;</span>
<span class="line-modified">!       sa.initialize_heap_sizes();</span>
  
        if (InitialHeapSize &gt; initial_heap_size) {
<span class="line-modified">!         // InitialHeapSize was adapted by sa.initialize_heap_sizes, e.g. due to alignment</span>
          // caused by 64K page size.
          initial_heap_size = InitialHeapSize;
        }
  
<span class="line-modified">!       size_t expected = scale_by_NewRatio_aligned(initial_heap_size, GenAlignment);</span>
        ASSERT_EQ(expected, NewSize);
      }
    };
  
    class SetNewSizeCmd : public UnaryExecutor {
     public:
      SetNewSizeCmd(size_t param) : UnaryExecutor(param) { }
      void execute() {
<span class="line-modified">!       FLAG_SET_CMDLINE(NewSize, param);</span>
      }
    };
  
    class CheckYoungInitial : public UnaryExecutor {
     public:
      CheckYoungInitial(size_t param) : UnaryExecutor(param) { }
      void execute() {
<span class="line-modified">!       SerialArguments sa;</span>
<span class="line-modified">!       sa.initialize_heap_sizes();</span>
  
<span class="line-modified">!       ASSERT_EQ(param, NewSize);</span>
      }
    };
  
    class SetOldSizeCmd : public UnaryExecutor {
     public:
      SetOldSizeCmd(size_t param) : UnaryExecutor(param) { }
      void execute() {
<span class="line-modified">!       FLAG_SET_CMDLINE(OldSize, param);</span>
      }
    };
  
    class SetMaxNewSizeCmd : public BinaryExecutor {
     public:
      SetMaxNewSizeCmd(size_t param1, size_t param2) : BinaryExecutor(param1, param2) { }
      void execute() {
<span class="line-modified">!       size_t heap_alignment = GCArguments::compute_heap_alignment();</span>
        size_t new_size_value = align_up(MaxHeapSize, heap_alignment)
                - param1 + param2;
<span class="line-modified">!       FLAG_SET_CMDLINE(MaxNewSize, new_size_value);</span>
      }
    };
  
    class CheckOldMin : public UnaryExecutor {
     public:
      CheckOldMin(size_t param) : UnaryExecutor(param) { }
      void execute() {
<span class="line-modified">!       SerialArguments sa;</span>
<span class="line-modified">!       sa.initialize_heap_sizes();</span>
<span class="line-modified">!       ASSERT_LE(MinOldSize, param);</span>
      }
    };
  
    class CheckOldInitial : public Executor {
     public:
      void execute() {
<span class="line-modified">!       size_t heap_alignment = GCArguments::compute_heap_alignment();</span>
  
<span class="line-modified">!       SerialArguments sa;</span>
<span class="line-modified">!       sa.initialize_heap_sizes();</span>
  
        size_t expected_old_initial = align_up(InitialHeapSize, heap_alignment)
                - MaxNewSize;
  
<span class="line-modified">!       ASSERT_EQ(expected_old_initial, OldSize);</span>
      }
    };
  
    class CheckOldInitialMaxNewSize : public BinaryExecutor {
     public:
      CheckOldInitialMaxNewSize(size_t param1, size_t param2) : BinaryExecutor(param1, param2) { }
      void execute() {
<span class="line-modified">!       size_t heap_alignment = GCArguments::compute_heap_alignment();</span>
        size_t new_size_value = align_up(MaxHeapSize, heap_alignment)
                - param1 + param2;
  
<span class="line-modified">!       SerialArguments sa;</span>
<span class="line-modified">!       sa.initialize_heap_sizes();</span>
  
        size_t expected_old_initial = align_up(MaxHeapSize, heap_alignment)
                - new_size_value;
  
<span class="line-modified">!       ASSERT_EQ(expected_old_initial, OldSize);</span>
      }
    };
  };
  
  
</pre>
<center><a href="test_collectedHeap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="test_oopStorage.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
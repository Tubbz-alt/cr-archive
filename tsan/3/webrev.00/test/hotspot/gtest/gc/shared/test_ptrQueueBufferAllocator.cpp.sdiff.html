<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/gtest/gc/shared/test_ptrQueueBufferAllocator.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="test_preservedMarks.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="test_workerDataArray.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/gtest/gc/shared/test_ptrQueueBufferAllocator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/ptrQueue.hpp&quot;
 27 #include &quot;memory/allocation.hpp&quot;
 28 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<span class="line-modified"> 29 #include &quot;runtime/orderAccess.hpp&quot;</span>
 30 #include &quot;runtime/semaphore.inline.hpp&quot;
 31 #include &quot;runtime/thread.hpp&quot;
 32 #include &quot;utilities/globalCounter.inline.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 #include &quot;utilities/ostream.hpp&quot;
 35 #include &quot;threadHelper.inline.hpp&quot;
 36 #include &quot;unittest.hpp&quot;
 37 
 38 class BufferNode::TestSupport : AllStatic {
 39 public:
 40   static bool try_transfer_pending(Allocator* allocator) {
 41     return allocator-&gt;try_transfer_pending();
 42   }
 43 
 44   class CompletedList;
 45   class AllocatorThread;
 46   class ProcessorThread;
 47 };
 48 
 49 typedef BufferNode::TestSupport::CompletedList CompletedList;
</pre>
<hr />
<pre>
133   CompletedList* _cbl;
134   volatile size_t* _total_allocations;
135   volatile bool* _continue_running;
136   size_t _allocations;
137 
138 public:
139   AllocatorThread(Semaphore* post,
140                   BufferNode::Allocator* allocator,
141                   CompletedList* cbl,
142                   volatile size_t* total_allocations,
143                   volatile bool* continue_running) :
144     JavaTestThread(post),
145     _allocator(allocator),
146     _cbl(cbl),
147     _total_allocations(total_allocations),
148     _continue_running(continue_running),
149     _allocations(0)
150   {}
151 
152   virtual void main_run() {
<span class="line-modified">153     while (OrderAccess::load_acquire(_continue_running)) {</span>
154       BufferNode* node = _allocator-&gt;allocate();
155       _cbl-&gt;push(node);
156       ++_allocations;
157       ThreadBlockInVM tbiv(this); // Safepoint check.
158     }
159     tty-&gt;print_cr(&quot;allocations: &quot; SIZE_FORMAT, _allocations);
<span class="line-modified">160     Atomic::add(_allocations, _total_allocations);</span>
161   }
162 };
163 
164 // Simulate a GC thread, taking buffers from the completed buffer list
165 // and returning them to the allocator.
166 class BufferNode::TestSupport::ProcessorThread : public JavaTestThread {
167   BufferNode::Allocator* _allocator;
168   CompletedList* _cbl;
169   volatile bool* _continue_running;
170 
171 public:
172   ProcessorThread(Semaphore* post,
173                   BufferNode::Allocator* allocator,
174                   CompletedList* cbl,
175                   volatile bool* continue_running) :
176     JavaTestThread(post),
177     _allocator(allocator),
178     _cbl(cbl),
179     _continue_running(continue_running)
180   {}
181 
182   virtual void main_run() {
183     while (true) {
184       BufferNode* node = _cbl-&gt;pop();
185       if (node != NULL) {
186         _allocator-&gt;release(node);
<span class="line-modified">187       } else if (!OrderAccess::load_acquire(_continue_running)) {</span>
188         return;
189       }
190       ThreadBlockInVM tbiv(this); // Safepoint check.
191     }
192   }
193 };
194 
195 static void run_test(BufferNode::Allocator* allocator, CompletedList* cbl) {
196   const uint nthreads = 4;
197   const uint milliseconds_to_run = 1000;
198 
199   Semaphore post;
200   volatile size_t total_allocations = 0;
201   volatile bool allocator_running = true;
202   volatile bool processor_running = true;
203 
204   ProcessorThread* proc_threads[nthreads] = {};
205   for (uint i = 0; i &lt; nthreads; ++i) {
206     proc_threads[i] = new ProcessorThread(&amp;post,
207                                           allocator,
208                                           cbl,
209                                           &amp;processor_running);
210     proc_threads[i]-&gt;doit();
211   }
212 
213   AllocatorThread* alloc_threads[nthreads] = {};
214   for (uint i = 0; i &lt; nthreads; ++i) {
215     alloc_threads[i] = new AllocatorThread(&amp;post,
216                                            allocator,
217                                            cbl,
218                                            &amp;total_allocations,
219                                            &amp;allocator_running);
220     alloc_threads[i]-&gt;doit();
221   }
222 
223   JavaThread* this_thread = JavaThread::current();
224   tty-&gt;print_cr(&quot;Stressing allocator for %u ms&quot;, milliseconds_to_run);
225   {
226     ThreadInVMfromNative invm(this_thread);
<span class="line-modified">227     os::sleep(this_thread, milliseconds_to_run, true);</span>
228   }
<span class="line-modified">229   OrderAccess::release_store(&amp;allocator_running, false);</span>
230   for (uint i = 0; i &lt; nthreads; ++i) {
231     ThreadInVMfromNative invm(this_thread);
232     post.wait_with_safepoint_check(this_thread);
233   }
<span class="line-modified">234   OrderAccess::release_store(&amp;processor_running, false);</span>
235   for (uint i = 0; i &lt; nthreads; ++i) {
236     ThreadInVMfromNative invm(this_thread);
237     post.wait_with_safepoint_check(this_thread);
238   }
239   ASSERT_TRUE(BufferNode::TestSupport::try_transfer_pending(allocator));
240   tty-&gt;print_cr(&quot;total allocations: &quot; SIZE_FORMAT, total_allocations);
241   tty-&gt;print_cr(&quot;allocator free count: &quot; SIZE_FORMAT, allocator-&gt;free_count());
242 }
243 
244 const size_t buffer_size = 1024;
245 
246 TEST_VM(PtrQueueBufferAllocatorTest, stress_free_list_allocator) {
247   BufferNode::Allocator allocator(&quot;Test Allocator&quot;, buffer_size);
248   CompletedList completed;
249   run_test(&amp;allocator, &amp;completed);
250 }
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/ptrQueue.hpp&quot;
 27 #include &quot;memory/allocation.hpp&quot;
 28 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<span class="line-modified"> 29 #include &quot;runtime/atomic.hpp&quot;</span>
 30 #include &quot;runtime/semaphore.inline.hpp&quot;
 31 #include &quot;runtime/thread.hpp&quot;
 32 #include &quot;utilities/globalCounter.inline.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 #include &quot;utilities/ostream.hpp&quot;
 35 #include &quot;threadHelper.inline.hpp&quot;
 36 #include &quot;unittest.hpp&quot;
 37 
 38 class BufferNode::TestSupport : AllStatic {
 39 public:
 40   static bool try_transfer_pending(Allocator* allocator) {
 41     return allocator-&gt;try_transfer_pending();
 42   }
 43 
 44   class CompletedList;
 45   class AllocatorThread;
 46   class ProcessorThread;
 47 };
 48 
 49 typedef BufferNode::TestSupport::CompletedList CompletedList;
</pre>
<hr />
<pre>
133   CompletedList* _cbl;
134   volatile size_t* _total_allocations;
135   volatile bool* _continue_running;
136   size_t _allocations;
137 
138 public:
139   AllocatorThread(Semaphore* post,
140                   BufferNode::Allocator* allocator,
141                   CompletedList* cbl,
142                   volatile size_t* total_allocations,
143                   volatile bool* continue_running) :
144     JavaTestThread(post),
145     _allocator(allocator),
146     _cbl(cbl),
147     _total_allocations(total_allocations),
148     _continue_running(continue_running),
149     _allocations(0)
150   {}
151 
152   virtual void main_run() {
<span class="line-modified">153     while (Atomic::load_acquire(_continue_running)) {</span>
154       BufferNode* node = _allocator-&gt;allocate();
155       _cbl-&gt;push(node);
156       ++_allocations;
157       ThreadBlockInVM tbiv(this); // Safepoint check.
158     }
159     tty-&gt;print_cr(&quot;allocations: &quot; SIZE_FORMAT, _allocations);
<span class="line-modified">160     Atomic::add(_total_allocations, _allocations);</span>
161   }
162 };
163 
164 // Simulate a GC thread, taking buffers from the completed buffer list
165 // and returning them to the allocator.
166 class BufferNode::TestSupport::ProcessorThread : public JavaTestThread {
167   BufferNode::Allocator* _allocator;
168   CompletedList* _cbl;
169   volatile bool* _continue_running;
170 
171 public:
172   ProcessorThread(Semaphore* post,
173                   BufferNode::Allocator* allocator,
174                   CompletedList* cbl,
175                   volatile bool* continue_running) :
176     JavaTestThread(post),
177     _allocator(allocator),
178     _cbl(cbl),
179     _continue_running(continue_running)
180   {}
181 
182   virtual void main_run() {
183     while (true) {
184       BufferNode* node = _cbl-&gt;pop();
185       if (node != NULL) {
186         _allocator-&gt;release(node);
<span class="line-modified">187       } else if (!Atomic::load_acquire(_continue_running)) {</span>
188         return;
189       }
190       ThreadBlockInVM tbiv(this); // Safepoint check.
191     }
192   }
193 };
194 
195 static void run_test(BufferNode::Allocator* allocator, CompletedList* cbl) {
196   const uint nthreads = 4;
197   const uint milliseconds_to_run = 1000;
198 
199   Semaphore post;
200   volatile size_t total_allocations = 0;
201   volatile bool allocator_running = true;
202   volatile bool processor_running = true;
203 
204   ProcessorThread* proc_threads[nthreads] = {};
205   for (uint i = 0; i &lt; nthreads; ++i) {
206     proc_threads[i] = new ProcessorThread(&amp;post,
207                                           allocator,
208                                           cbl,
209                                           &amp;processor_running);
210     proc_threads[i]-&gt;doit();
211   }
212 
213   AllocatorThread* alloc_threads[nthreads] = {};
214   for (uint i = 0; i &lt; nthreads; ++i) {
215     alloc_threads[i] = new AllocatorThread(&amp;post,
216                                            allocator,
217                                            cbl,
218                                            &amp;total_allocations,
219                                            &amp;allocator_running);
220     alloc_threads[i]-&gt;doit();
221   }
222 
223   JavaThread* this_thread = JavaThread::current();
224   tty-&gt;print_cr(&quot;Stressing allocator for %u ms&quot;, milliseconds_to_run);
225   {
226     ThreadInVMfromNative invm(this_thread);
<span class="line-modified">227     this_thread-&gt;sleep(milliseconds_to_run);</span>
228   }
<span class="line-modified">229   Atomic::release_store(&amp;allocator_running, false);</span>
230   for (uint i = 0; i &lt; nthreads; ++i) {
231     ThreadInVMfromNative invm(this_thread);
232     post.wait_with_safepoint_check(this_thread);
233   }
<span class="line-modified">234   Atomic::release_store(&amp;processor_running, false);</span>
235   for (uint i = 0; i &lt; nthreads; ++i) {
236     ThreadInVMfromNative invm(this_thread);
237     post.wait_with_safepoint_check(this_thread);
238   }
239   ASSERT_TRUE(BufferNode::TestSupport::try_transfer_pending(allocator));
240   tty-&gt;print_cr(&quot;total allocations: &quot; SIZE_FORMAT, total_allocations);
241   tty-&gt;print_cr(&quot;allocator free count: &quot; SIZE_FORMAT, allocator-&gt;free_count());
242 }
243 
244 const size_t buffer_size = 1024;
245 
246 TEST_VM(PtrQueueBufferAllocatorTest, stress_free_list_allocator) {
247   BufferNode::Allocator allocator(&quot;Test Allocator&quot;, buffer_size);
248   CompletedList completed;
249   run_test(&amp;allocator, &amp;completed);
250 }
</pre>
</td>
</tr>
</table>
<center><a href="test_preservedMarks.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="test_workerDataArray.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
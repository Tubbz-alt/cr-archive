<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/gtest/gc/g1/test_g1FreeIdSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../classfile/test_symbolTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="test_g1HeapVerifier.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/gtest/gc/g1/test_g1FreeIdSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1FreeIdSet.hpp&quot;
 27 #include &quot;memory/allocation.hpp&quot;
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<span class="line-removed"> 30 #include &quot;runtime/orderAccess.hpp&quot;</span>
 31 #include &quot;runtime/semaphore.inline.hpp&quot;
 32 #include &quot;runtime/thread.hpp&quot;
 33 #include &quot;utilities/debug.hpp&quot;
 34 #include &quot;utilities/globalDefinitions.hpp&quot;
 35 #include &quot;utilities/ostream.hpp&quot;
 36 #include &quot;threadHelper.inline.hpp&quot;
 37 #include &quot;unittest.hpp&quot;
 38 
 39 struct G1FreeIdSet::TestSupport : AllStatic {
 40   static uint next(const G1FreeIdSet&amp; set, uint index) {
 41     assert(index &lt; set._size, &quot;precondition&quot;);
 42     return set._next[index];
 43   }
 44 
 45   static uint start(const G1FreeIdSet&amp; set) { return set._start; }
 46   static uint size(const G1FreeIdSet&amp; set) { return set._size; }
 47   static uintx mask(const G1FreeIdSet&amp; set) { return set._head_index_mask; }
 48   static uintx head(const G1FreeIdSet&amp; set) { return Atomic::load(&amp;set._head); }
 49 
 50   static uint head_index(const G1FreeIdSet&amp; set, uintx head) {
</pre>
<hr />
<pre>
 91   volatile size_t* _total_allocations;
 92   volatile bool* _continue_running;
 93   size_t _allocations;
 94   uint _thread_number;
 95 
 96 public:
 97   TestG1FreeIdSetThread(uint thread_number,
 98                         Semaphore* post,
 99                         G1FreeIdSet* set,
100                         volatile size_t* total_allocations,
101                         volatile bool* continue_running) :
102     JavaTestThread(post),
103     _set(set),
104     _total_allocations(total_allocations),
105     _continue_running(continue_running),
106     _allocations(0),
107     _thread_number(thread_number)
108   {}
109 
110   virtual void main_run() {
<span class="line-modified">111     while (OrderAccess::load_acquire(_continue_running)) {</span>
112       uint id = _set-&gt;claim_par_id();
113       _set-&gt;release_par_id(id);
114       ++_allocations;
115       ThreadBlockInVM tbiv(this); // Safepoint check.
116     }
117     tty-&gt;print_cr(&quot;%u allocations: &quot; SIZE_FORMAT, _thread_number, _allocations);
<span class="line-modified">118     Atomic::add(_allocations, _total_allocations);</span>
119   }
120 };
121 
122 TEST_VM(G1FreeIdSetTest, stress) {
123   const uint start = 5;
124   const uint size = 3;
125   const uint nthreads = size + 1;
126   const uint milliseconds_to_run = 1000;
127 
128   Semaphore post;
129   volatile size_t total_allocations = 0;
130   volatile bool continue_running = true;
131 
132   G1FreeIdSet set(start, size);
133 
134   TestG1FreeIdSetThread* threads[nthreads] = {};
135   for (uint i = 0; i &lt; nthreads; ++i) {
136     threads[i] = new TestG1FreeIdSetThread(i,
137                                            &amp;post,
138                                            &amp;set,
139                                            &amp;total_allocations,
140                                            &amp;continue_running);
141     threads[i]-&gt;doit();
142   }
143 
144   JavaThread* this_thread = JavaThread::current();
145   tty-&gt;print_cr(&quot;Stressing G1FreeIdSet for %u ms&quot;, milliseconds_to_run);
146   {
147     ThreadInVMfromNative invm(this_thread);
<span class="line-modified">148     os::sleep(this_thread, milliseconds_to_run, true);</span>
149   }
<span class="line-modified">150   OrderAccess::release_store(&amp;continue_running, false);</span>
151   for (uint i = 0; i &lt; nthreads; ++i) {
152     ThreadInVMfromNative invm(this_thread);
153     post.wait_with_safepoint_check(this_thread);
154   }
155   tty-&gt;print_cr(&quot;total allocations: &quot; SIZE_FORMAT, total_allocations);
156   tty-&gt;print_cr(&quot;final free list: &quot;);
157   uint ids[size] = {};
158   for (uint i = 0; i &lt; size; ++i) {
159     uint id = set.claim_par_id();
160     uint index = id - TestSupport::start(set);
161     ASSERT_LT(index, TestSupport::size(set));
162     tty-&gt;print_cr(&quot;  %u: %u&quot;, i, index);
163   }
164   ASSERT_EQ(size, TestSupport::head_index(set, TestSupport::head(set)));
165 }
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1FreeIdSet.hpp&quot;
 27 #include &quot;memory/allocation.hpp&quot;
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;runtime/interfaceSupport.inline.hpp&quot;

 30 #include &quot;runtime/semaphore.inline.hpp&quot;
 31 #include &quot;runtime/thread.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 #include &quot;utilities/ostream.hpp&quot;
 35 #include &quot;threadHelper.inline.hpp&quot;
 36 #include &quot;unittest.hpp&quot;
 37 
 38 struct G1FreeIdSet::TestSupport : AllStatic {
 39   static uint next(const G1FreeIdSet&amp; set, uint index) {
 40     assert(index &lt; set._size, &quot;precondition&quot;);
 41     return set._next[index];
 42   }
 43 
 44   static uint start(const G1FreeIdSet&amp; set) { return set._start; }
 45   static uint size(const G1FreeIdSet&amp; set) { return set._size; }
 46   static uintx mask(const G1FreeIdSet&amp; set) { return set._head_index_mask; }
 47   static uintx head(const G1FreeIdSet&amp; set) { return Atomic::load(&amp;set._head); }
 48 
 49   static uint head_index(const G1FreeIdSet&amp; set, uintx head) {
</pre>
<hr />
<pre>
 90   volatile size_t* _total_allocations;
 91   volatile bool* _continue_running;
 92   size_t _allocations;
 93   uint _thread_number;
 94 
 95 public:
 96   TestG1FreeIdSetThread(uint thread_number,
 97                         Semaphore* post,
 98                         G1FreeIdSet* set,
 99                         volatile size_t* total_allocations,
100                         volatile bool* continue_running) :
101     JavaTestThread(post),
102     _set(set),
103     _total_allocations(total_allocations),
104     _continue_running(continue_running),
105     _allocations(0),
106     _thread_number(thread_number)
107   {}
108 
109   virtual void main_run() {
<span class="line-modified">110     while (Atomic::load_acquire(_continue_running)) {</span>
111       uint id = _set-&gt;claim_par_id();
112       _set-&gt;release_par_id(id);
113       ++_allocations;
114       ThreadBlockInVM tbiv(this); // Safepoint check.
115     }
116     tty-&gt;print_cr(&quot;%u allocations: &quot; SIZE_FORMAT, _thread_number, _allocations);
<span class="line-modified">117     Atomic::add(_total_allocations, _allocations);</span>
118   }
119 };
120 
121 TEST_VM(G1FreeIdSetTest, stress) {
122   const uint start = 5;
123   const uint size = 3;
124   const uint nthreads = size + 1;
125   const uint milliseconds_to_run = 1000;
126 
127   Semaphore post;
128   volatile size_t total_allocations = 0;
129   volatile bool continue_running = true;
130 
131   G1FreeIdSet set(start, size);
132 
133   TestG1FreeIdSetThread* threads[nthreads] = {};
134   for (uint i = 0; i &lt; nthreads; ++i) {
135     threads[i] = new TestG1FreeIdSetThread(i,
136                                            &amp;post,
137                                            &amp;set,
138                                            &amp;total_allocations,
139                                            &amp;continue_running);
140     threads[i]-&gt;doit();
141   }
142 
143   JavaThread* this_thread = JavaThread::current();
144   tty-&gt;print_cr(&quot;Stressing G1FreeIdSet for %u ms&quot;, milliseconds_to_run);
145   {
146     ThreadInVMfromNative invm(this_thread);
<span class="line-modified">147     this_thread-&gt;sleep(milliseconds_to_run);</span>
148   }
<span class="line-modified">149   Atomic::release_store(&amp;continue_running, false);</span>
150   for (uint i = 0; i &lt; nthreads; ++i) {
151     ThreadInVMfromNative invm(this_thread);
152     post.wait_with_safepoint_check(this_thread);
153   }
154   tty-&gt;print_cr(&quot;total allocations: &quot; SIZE_FORMAT, total_allocations);
155   tty-&gt;print_cr(&quot;final free list: &quot;);
156   uint ids[size] = {};
157   for (uint i = 0; i &lt; size; ++i) {
158     uint id = set.claim_par_id();
159     uint index = id - TestSupport::start(set);
160     ASSERT_LT(index, TestSupport::size(set));
161     tty-&gt;print_cr(&quot;  %u: %u&quot;, i, index);
162   }
163   ASSERT_EQ(size, TestSupport::head_index(set, TestSupport::head(set)));
164 }
</pre>
</td>
</tr>
</table>
<center><a href="../../classfile/test_symbolTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="test_g1HeapVerifier.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
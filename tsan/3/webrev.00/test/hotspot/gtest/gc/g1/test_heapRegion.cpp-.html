<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/gtest/gc/g1/test_heapRegion.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/g1/g1BlockOffsetTable.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
 27 #include &quot;gc/g1/g1ConcurrentMarkBitMap.inline.hpp&quot;
 28 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
 29 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 30 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 31 #include &quot;runtime/vmOperations.hpp&quot;
 32 #include &quot;runtime/vmThread.hpp&quot;
 33 #include &quot;unittest.hpp&quot;
 34 
 35 class VerifyAndCountMarkClosure : public StackObj {
 36   int _count;
 37   G1CMBitMap* _bm;
 38 
 39   void ensure_marked(HeapWord* addr) {
 40     ASSERT_TRUE(_bm-&gt;is_marked(addr));
 41   }
 42 
 43 public:
 44   VerifyAndCountMarkClosure(G1CMBitMap* bm) : _count(0), _bm(bm) { }
 45 
 46   virtual size_t apply(oop object) {
 47     _count++;
 48     ensure_marked((HeapWord*) object);
 49     // Must return positive size to advance the iteration.
 50     return MinObjAlignment;
 51   }
 52 
 53   void reset() {
 54     _count = 0;
 55   }
 56 
 57   int count() {
 58     return _count;
 59   }
 60 };
 61 
 62 #define MARK_OFFSET_1 ( 17 * MinObjAlignment)
 63 #define MARK_OFFSET_2 ( 99 * MinObjAlignment)
 64 #define MARK_OFFSET_3 (337 * MinObjAlignment)
 65 
 66 class VM_HeapRegionApplyToMarkedObjectsTest : public VM_GTestExecuteAtSafepoint {
 67 public:
 68   void doit();
 69 };
 70 
 71 void VM_HeapRegionApplyToMarkedObjectsTest::doit() {
 72   G1CollectedHeap* heap = G1CollectedHeap::heap();
 73 
 74   // Using region 0 for testing.
 75   HeapRegion* region = heap-&gt;heap_region_containing(heap-&gt;bottom_addr_for_region(0));
 76 
 77   // Mark some &quot;oops&quot; in the bitmap.
 78   G1CMBitMap* bitmap = heap-&gt;concurrent_mark()-&gt;next_mark_bitmap();
 79   bitmap-&gt;mark(region-&gt;bottom());
 80   bitmap-&gt;mark(region-&gt;bottom() + MARK_OFFSET_1);
 81   bitmap-&gt;mark(region-&gt;bottom() + MARK_OFFSET_2);
 82   bitmap-&gt;mark(region-&gt;bottom() + MARK_OFFSET_3);
 83   bitmap-&gt;mark(region-&gt;end());
 84 
 85   VerifyAndCountMarkClosure cl(bitmap);
 86 
 87   HeapWord* old_top = region-&gt;top();
 88 
 89   // When top is equal to bottom the closure should not be
 90   // applied to any object because apply_to_marked_objects
 91   // will stop at HeapRegion::scan_limit which is equal to top.
 92   region-&gt;set_top(region-&gt;bottom());
 93   region-&gt;apply_to_marked_objects(bitmap, &amp;cl);
 94   EXPECT_EQ(0, cl.count());
 95   cl.reset();
 96 
 97   // Set top to offset_1 and expect only to find 1 entry (bottom)
 98   region-&gt;set_top(region-&gt;bottom() + MARK_OFFSET_1);
 99   region-&gt;apply_to_marked_objects(bitmap, &amp;cl);
100   EXPECT_EQ(1, cl.count());
101   cl.reset();
102 
103   // Set top to (offset_2 + 1) and expect only to find 3
104   // entries (bottom, offset_1 and offset_2)
105   region-&gt;set_top(region-&gt;bottom() + MARK_OFFSET_2 + MinObjAlignment);
106   region-&gt;apply_to_marked_objects(bitmap, &amp;cl);
107   EXPECT_EQ(3, cl.count());
108   cl.reset();
109 
110   // Still expect same 3 entries when top is (offset_3 - 1)
111   region-&gt;set_top(region-&gt;bottom() + MARK_OFFSET_3 - MinObjAlignment);
112   region-&gt;apply_to_marked_objects(bitmap, &amp;cl);
113   EXPECT_EQ(3, cl.count());
114   cl.reset();
115 
116   // Setting top to end should render 4 entries.
117   region-&gt;set_top(region-&gt;end());
118   region-&gt;apply_to_marked_objects(bitmap, &amp;cl);
119   EXPECT_EQ(4, cl.count());
120   cl.reset();
121 
122   region-&gt;set_top(old_top);
123 }
124 
125 TEST_VM(HeapRegion, apply_to_marked_object) {
126   if (!UseG1GC) {
127     return;
128   }
129 
130   // Run the test in our very own safepoint, because otherwise it
131   // modifies a region behind the back of a possibly using allocation
132   // or running GC.
133   VM_HeapRegionApplyToMarkedObjectsTest op;
134   ThreadInVMfromNative invm(JavaThread::current());
135   VMThread::execute(&amp;op);
136 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/gtest/gc/g1/test_g1FreeIdSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1FreeIdSet.hpp&quot;
 27 #include &quot;memory/allocation.hpp&quot;
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 30 #include &quot;runtime/orderAccess.hpp&quot;</span>
 31 #include &quot;runtime/semaphore.inline.hpp&quot;
 32 #include &quot;runtime/thread.hpp&quot;
 33 #include &quot;utilities/debug.hpp&quot;
 34 #include &quot;utilities/globalDefinitions.hpp&quot;
 35 #include &quot;utilities/ostream.hpp&quot;
 36 #include &quot;threadHelper.inline.hpp&quot;
 37 #include &quot;unittest.hpp&quot;
 38 
 39 struct G1FreeIdSet::TestSupport : AllStatic {
 40   static uint next(const G1FreeIdSet&amp; set, uint index) {
 41     assert(index &lt; set._size, &quot;precondition&quot;);
 42     return set._next[index];
 43   }
 44 
 45   static uint start(const G1FreeIdSet&amp; set) { return set._start; }
 46   static uint size(const G1FreeIdSet&amp; set) { return set._size; }
 47   static uintx mask(const G1FreeIdSet&amp; set) { return set._head_index_mask; }
 48   static uintx head(const G1FreeIdSet&amp; set) { return Atomic::load(&amp;set._head); }
 49 
 50   static uint head_index(const G1FreeIdSet&amp; set, uintx head) {
 51     return set.head_index(head);
 52   }
 53 };
 54 
 55 typedef G1FreeIdSet::TestSupport TestSupport;
 56 
 57 TEST_VM(G1FreeIdSetTest, initial_state) {
 58   const uint start = 5;
 59   const uint size = 4;
 60   G1FreeIdSet set(start, size);
 61 
 62   ASSERT_EQ(start, TestSupport::start(set));
 63   ASSERT_EQ(size, TestSupport::size(set));
 64   ASSERT_EQ(7u, TestSupport::mask(set));
 65   ASSERT_EQ(0u, TestSupport::head(set));
 66   for (uint i = 0; i &lt; size; ++i) {
 67     ASSERT_EQ(i + 1, TestSupport::next(set, i));
 68   }
 69 }
 70 
 71 TEST_VM(G1FreeIdSetTest, non_blocking_ops) {
 72   const uint start = 5;
 73   const uint size = 3;
 74   G1FreeIdSet set(start, size);
 75 
 76   ASSERT_EQ(5u, set.claim_par_id());
 77   ASSERT_EQ(1u, TestSupport::head_index(set, TestSupport::head(set)));
 78   ASSERT_EQ(6u, set.claim_par_id());
 79   ASSERT_EQ(2u, TestSupport::head_index(set, TestSupport::head(set)));
 80   ASSERT_EQ(7u, set.claim_par_id());
 81   ASSERT_EQ(3u, TestSupport::head_index(set, TestSupport::head(set)));
 82 
 83   set.release_par_id(5u);
 84   set.release_par_id(6u);
 85   ASSERT_EQ(6u, set.claim_par_id());
 86   ASSERT_EQ(5u, set.claim_par_id());
 87 }
 88 
 89 class TestG1FreeIdSetThread : public JavaTestThread {
 90   G1FreeIdSet* _set;
 91   volatile size_t* _total_allocations;
 92   volatile bool* _continue_running;
 93   size_t _allocations;
 94   uint _thread_number;
 95 
 96 public:
 97   TestG1FreeIdSetThread(uint thread_number,
 98                         Semaphore* post,
 99                         G1FreeIdSet* set,
100                         volatile size_t* total_allocations,
101                         volatile bool* continue_running) :
102     JavaTestThread(post),
103     _set(set),
104     _total_allocations(total_allocations),
105     _continue_running(continue_running),
106     _allocations(0),
107     _thread_number(thread_number)
108   {}
109 
110   virtual void main_run() {
<a name="2" id="anc2"></a><span class="line-modified">111     while (OrderAccess::load_acquire(_continue_running)) {</span>
112       uint id = _set-&gt;claim_par_id();
113       _set-&gt;release_par_id(id);
114       ++_allocations;
115       ThreadBlockInVM tbiv(this); // Safepoint check.
116     }
117     tty-&gt;print_cr(&quot;%u allocations: &quot; SIZE_FORMAT, _thread_number, _allocations);
<a name="3" id="anc3"></a><span class="line-modified">118     Atomic::add(_allocations, _total_allocations);</span>
119   }
120 };
121 
122 TEST_VM(G1FreeIdSetTest, stress) {
123   const uint start = 5;
124   const uint size = 3;
125   const uint nthreads = size + 1;
126   const uint milliseconds_to_run = 1000;
127 
128   Semaphore post;
129   volatile size_t total_allocations = 0;
130   volatile bool continue_running = true;
131 
132   G1FreeIdSet set(start, size);
133 
134   TestG1FreeIdSetThread* threads[nthreads] = {};
135   for (uint i = 0; i &lt; nthreads; ++i) {
136     threads[i] = new TestG1FreeIdSetThread(i,
137                                            &amp;post,
138                                            &amp;set,
139                                            &amp;total_allocations,
140                                            &amp;continue_running);
141     threads[i]-&gt;doit();
142   }
143 
144   JavaThread* this_thread = JavaThread::current();
145   tty-&gt;print_cr(&quot;Stressing G1FreeIdSet for %u ms&quot;, milliseconds_to_run);
146   {
147     ThreadInVMfromNative invm(this_thread);
<a name="4" id="anc4"></a><span class="line-modified">148     os::sleep(this_thread, milliseconds_to_run, true);</span>
149   }
<a name="5" id="anc5"></a><span class="line-modified">150   OrderAccess::release_store(&amp;continue_running, false);</span>
151   for (uint i = 0; i &lt; nthreads; ++i) {
152     ThreadInVMfromNative invm(this_thread);
153     post.wait_with_safepoint_check(this_thread);
154   }
155   tty-&gt;print_cr(&quot;total allocations: &quot; SIZE_FORMAT, total_allocations);
156   tty-&gt;print_cr(&quot;final free list: &quot;);
157   uint ids[size] = {};
158   for (uint i = 0; i &lt; size; ++i) {
159     uint id = set.claim_par_id();
160     uint index = id - TestSupport::start(set);
161     ASSERT_LT(index, TestSupport::size(set));
162     tty-&gt;print_cr(&quot;  %u: %u&quot;, i, index);
163   }
164   ASSERT_EQ(size, TestSupport::head_index(set, TestSupport::head(set)));
165 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
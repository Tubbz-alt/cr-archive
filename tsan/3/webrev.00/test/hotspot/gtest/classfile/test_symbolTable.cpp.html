<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/gtest/classfile/test_symbolTable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;threadHelper.inline.hpp&quot;
 28 #include &quot;unittest.hpp&quot;
 29 
 30 TEST_VM(SymbolTable, temp_new_symbol) {
 31   // Assert messages assume these symbols are unique, and the refcounts start at
 32   // one, but code does not rely on this.
 33   JavaThread* THREAD = JavaThread::current();
 34   // the thread should be in vm to use locks
 35   ThreadInVMfromNative ThreadInVMfromNative(THREAD);
 36 
 37   Symbol* abc = SymbolTable::new_symbol(&quot;abc&quot;);
 38   int abccount = abc-&gt;refcount();
 39   TempNewSymbol ss = abc;
 40   ASSERT_EQ(ss-&gt;refcount(), abccount) &lt;&lt; &quot;only one abc&quot;;
 41   ASSERT_EQ(ss-&gt;refcount(), abc-&gt;refcount()) &lt;&lt; &quot;should match TempNewSymbol&quot;;
 42 
 43   Symbol* efg = SymbolTable::new_symbol(&quot;efg&quot;);
 44   Symbol* hij = SymbolTable::new_symbol(&quot;hij&quot;);
 45   int efgcount = efg-&gt;refcount();
 46   int hijcount = hij-&gt;refcount();
 47 
 48   TempNewSymbol s1 = efg;
 49   TempNewSymbol s2 = hij;
 50   ASSERT_EQ(s1-&gt;refcount(), efgcount) &lt;&lt; &quot;one efg&quot;;
 51   ASSERT_EQ(s2-&gt;refcount(), hijcount) &lt;&lt; &quot;one hij&quot;;
 52 
 53   // Assignment operator
 54   s1 = s2;
 55   ASSERT_EQ(hij-&gt;refcount(), hijcount + 1) &lt;&lt; &quot;should be two hij&quot;;
 56   ASSERT_EQ(efg-&gt;refcount(), efgcount - 1) &lt;&lt; &quot;should be no efg&quot;;
 57 
 58   s1 = ss; // s1 is abc
 59   ASSERT_EQ(s1-&gt;refcount(), abccount + 1) &lt;&lt; &quot;should be two abc (s1 and ss)&quot;;
 60   ASSERT_EQ(hij-&gt;refcount(), hijcount) &lt;&lt; &quot;should only have one hij now (s2)&quot;;
 61 
 62   s1 = s1; // self assignment
 63   ASSERT_EQ(s1-&gt;refcount(), abccount + 1) &lt;&lt; &quot;should still be two abc (s1 and ss)&quot;;
 64 
 65   TempNewSymbol s3;
 66   Symbol* klm = SymbolTable::new_symbol(&quot;klm&quot;);
 67   int klmcount = klm-&gt;refcount();
 68   s3 = klm; // assignment
 69   ASSERT_EQ(s3-&gt;refcount(), klmcount) &lt;&lt; &quot;only one klm now&quot;;
 70 
 71   Symbol* xyz = SymbolTable::new_symbol(&quot;xyz&quot;);
 72   int xyzcount = xyz-&gt;refcount();
 73   { // inner scope
 74     TempNewSymbol s_inner = xyz;
 75   }
 76   ASSERT_EQ(xyz-&gt;refcount(), xyzcount - 1)
 77           &lt;&lt; &quot;Should have been decremented by dtor in inner scope&quot;;
 78 
 79   // Test overflowing refcount making symbol permanent
 80   Symbol* bigsym = SymbolTable::new_symbol(&quot;bigsym&quot;);
 81   for (int i = 0; i &lt; PERM_REFCOUNT + 100; i++) {
 82     bigsym-&gt;increment_refcount();
 83   }
 84   ASSERT_EQ(bigsym-&gt;refcount(), PERM_REFCOUNT) &lt;&lt; &quot;should not have overflowed&quot;;
 85 
 86   // Test that PERM_REFCOUNT is sticky
 87   for (int i = 0; i &lt; 10; i++) {
 88     bigsym-&gt;decrement_refcount();
 89   }
 90   ASSERT_EQ(bigsym-&gt;refcount(), PERM_REFCOUNT) &lt;&lt; &quot;should be sticky&quot;;
 91 }
 92 
 93 // TODO: Make two threads one decrementing the refcount and the other trying to increment.
 94 // try_increment_refcount should return false
 95 
 96 #define SYM_NAME_LENGTH 30
 97 static char symbol_name[SYM_NAME_LENGTH];
 98 
 99 class SymbolThread : public JavaTestThread {
100   public:
101   SymbolThread(Semaphore* post) : JavaTestThread(post) {}
102   virtual ~SymbolThread() {}
103   void main_run() {
104     for (int i = 0; i &lt; 1000; i++) {
105       TempNewSymbol sym = SymbolTable::new_symbol(symbol_name);
106       // Create and destroy new symbol
107       EXPECT_TRUE(sym-&gt;refcount() != 0) &lt;&lt; &quot;Symbol refcount unexpectedly zeroed&quot;;
108     }
109   }
110 };
111 
112 #define SYM_TEST_THREAD_COUNT 5
113 
114 class DriverSymbolThread : public JavaTestThread {
115 public:
116   Semaphore _done;
117   DriverSymbolThread(Semaphore* post) : JavaTestThread(post) { };
118   virtual ~DriverSymbolThread(){}
119 
120   void main_run() {
121     Semaphore done(0);
122 
123     // Find a symbol where there will probably be only one instance.
124     for (int i = 0; i &lt; 100; i++) {
125        os::snprintf(symbol_name, SYM_NAME_LENGTH, &quot;some_symbol%d&quot;, i);
126        TempNewSymbol ts = SymbolTable::new_symbol(symbol_name);
127        if (ts-&gt;refcount() == 1) {
128          EXPECT_TRUE(ts-&gt;refcount() == 1) &lt;&lt; &quot;Symbol is just created&quot;;
129          break;  // found a unique symbol
130        }
131     }
132 
133     SymbolThread* st[SYM_TEST_THREAD_COUNT];
134     for (int i = 0; i &lt; SYM_TEST_THREAD_COUNT; i++) {
135       st[i] = new SymbolThread(&amp;done);
136       st[i]-&gt;doit();
137     }
138 
139     for (int i = 0; i &lt; SYM_TEST_THREAD_COUNT; i++) {
140       done.wait();
141     }
142   }
143 };
144 
145 TEST_VM(SymbolTable, test_symbol_refcount_parallel) {
146   mt_test_doer&lt;DriverSymbolThread&gt;();
147 }
    </pre>
  </body>
</html>
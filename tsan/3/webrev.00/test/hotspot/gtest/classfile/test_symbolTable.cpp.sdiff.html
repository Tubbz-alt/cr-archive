<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/gtest/classfile/test_symbolTable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../fmw/gtest/googletest/LICENSE.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../gc/g1/test_g1FreeIdSet.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/gtest/classfile/test_symbolTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;threadHelper.inline.hpp&quot;
 28 #include &quot;unittest.hpp&quot;
 29 
 30 TEST_VM(SymbolTable, temp_new_symbol) {
 31   // Assert messages assume these symbols are unique, and the refcounts start at
 32   // one, but code does not rely on this.
 33   JavaThread* THREAD = JavaThread::current();
 34   // the thread should be in vm to use locks
 35   ThreadInVMfromNative ThreadInVMfromNative(THREAD);
 36 
<span class="line-modified"> 37   Symbol* abc = SymbolTable::new_symbol(&quot;abc&quot;, CATCH);</span>
 38   int abccount = abc-&gt;refcount();
 39   TempNewSymbol ss = abc;
 40   ASSERT_EQ(ss-&gt;refcount(), abccount) &lt;&lt; &quot;only one abc&quot;;
 41   ASSERT_EQ(ss-&gt;refcount(), abc-&gt;refcount()) &lt;&lt; &quot;should match TempNewSymbol&quot;;
 42 
<span class="line-modified"> 43   Symbol* efg = SymbolTable::new_symbol(&quot;efg&quot;, CATCH);</span>
<span class="line-modified"> 44   Symbol* hij = SymbolTable::new_symbol(&quot;hij&quot;, CATCH);</span>
 45   int efgcount = efg-&gt;refcount();
 46   int hijcount = hij-&gt;refcount();
 47 
 48   TempNewSymbol s1 = efg;
 49   TempNewSymbol s2 = hij;
 50   ASSERT_EQ(s1-&gt;refcount(), efgcount) &lt;&lt; &quot;one efg&quot;;
 51   ASSERT_EQ(s2-&gt;refcount(), hijcount) &lt;&lt; &quot;one hij&quot;;
 52 
 53   // Assignment operator
 54   s1 = s2;
 55   ASSERT_EQ(hij-&gt;refcount(), hijcount + 1) &lt;&lt; &quot;should be two hij&quot;;
 56   ASSERT_EQ(efg-&gt;refcount(), efgcount - 1) &lt;&lt; &quot;should be no efg&quot;;
 57 
 58   s1 = ss; // s1 is abc
 59   ASSERT_EQ(s1-&gt;refcount(), abccount + 1) &lt;&lt; &quot;should be two abc (s1 and ss)&quot;;
 60   ASSERT_EQ(hij-&gt;refcount(), hijcount) &lt;&lt; &quot;should only have one hij now (s2)&quot;;
 61 
 62   s1 = s1; // self assignment
 63   ASSERT_EQ(s1-&gt;refcount(), abccount + 1) &lt;&lt; &quot;should still be two abc (s1 and ss)&quot;;
 64 
 65   TempNewSymbol s3;
<span class="line-modified"> 66   Symbol* klm = SymbolTable::new_symbol(&quot;klm&quot;, CATCH);</span>
 67   int klmcount = klm-&gt;refcount();
 68   s3 = klm; // assignment
 69   ASSERT_EQ(s3-&gt;refcount(), klmcount) &lt;&lt; &quot;only one klm now&quot;;
 70 
<span class="line-modified"> 71   Symbol* xyz = SymbolTable::new_symbol(&quot;xyz&quot;, CATCH);</span>
 72   int xyzcount = xyz-&gt;refcount();
 73   { // inner scope
 74     TempNewSymbol s_inner = xyz;
 75   }
 76   ASSERT_EQ(xyz-&gt;refcount(), xyzcount - 1)
 77           &lt;&lt; &quot;Should have been decremented by dtor in inner scope&quot;;
 78 
 79   // Test overflowing refcount making symbol permanent
<span class="line-modified"> 80   Symbol* bigsym = SymbolTable::new_symbol(&quot;bigsym&quot;, CATCH);</span>
 81   for (int i = 0; i &lt; PERM_REFCOUNT + 100; i++) {
 82     bigsym-&gt;increment_refcount();
 83   }
 84   ASSERT_EQ(bigsym-&gt;refcount(), PERM_REFCOUNT) &lt;&lt; &quot;should not have overflowed&quot;;
 85 
 86   // Test that PERM_REFCOUNT is sticky
 87   for (int i = 0; i &lt; 10; i++) {
 88     bigsym-&gt;decrement_refcount();
 89   }
 90   ASSERT_EQ(bigsym-&gt;refcount(), PERM_REFCOUNT) &lt;&lt; &quot;should be sticky&quot;;
 91 }
 92 
 93 // TODO: Make two threads one decrementing the refcount and the other trying to increment.
 94 // try_increment_refcount should return false
 95 
 96 #define SYM_NAME_LENGTH 30
 97 static char symbol_name[SYM_NAME_LENGTH];
 98 
 99 class SymbolThread : public JavaTestThread {
100   public:
101   SymbolThread(Semaphore* post) : JavaTestThread(post) {}
102   virtual ~SymbolThread() {}
103   void main_run() {
<span class="line-removed">104     Thread* THREAD = Thread::current();</span>
105     for (int i = 0; i &lt; 1000; i++) {
<span class="line-modified">106       TempNewSymbol sym = SymbolTable::new_symbol(symbol_name, CATCH);</span>
107       // Create and destroy new symbol
108       EXPECT_TRUE(sym-&gt;refcount() != 0) &lt;&lt; &quot;Symbol refcount unexpectedly zeroed&quot;;
109     }
110   }
111 };
112 
113 #define SYM_TEST_THREAD_COUNT 5
114 
115 class DriverSymbolThread : public JavaTestThread {
116 public:
117   Semaphore _done;
118   DriverSymbolThread(Semaphore* post) : JavaTestThread(post) { };
119   virtual ~DriverSymbolThread(){}
120 
121   void main_run() {
122     Semaphore done(0);
123 
<span class="line-removed">124     Thread* THREAD = Thread::current();</span>
<span class="line-removed">125 </span>
126     // Find a symbol where there will probably be only one instance.
127     for (int i = 0; i &lt; 100; i++) {
128        os::snprintf(symbol_name, SYM_NAME_LENGTH, &quot;some_symbol%d&quot;, i);
<span class="line-modified">129        TempNewSymbol ts = SymbolTable::new_symbol(symbol_name, CATCH);</span>
130        if (ts-&gt;refcount() == 1) {
131          EXPECT_TRUE(ts-&gt;refcount() == 1) &lt;&lt; &quot;Symbol is just created&quot;;
132          break;  // found a unique symbol
133        }
134     }
135 
136     SymbolThread* st[SYM_TEST_THREAD_COUNT];
137     for (int i = 0; i &lt; SYM_TEST_THREAD_COUNT; i++) {
138       st[i] = new SymbolThread(&amp;done);
139       st[i]-&gt;doit();
140     }
141 
142     for (int i = 0; i &lt; SYM_TEST_THREAD_COUNT; i++) {
143       done.wait();
144     }
145   }
146 };
147 
148 TEST_VM(SymbolTable, test_symbol_refcount_parallel) {
149   mt_test_doer&lt;DriverSymbolThread&gt;();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;threadHelper.inline.hpp&quot;
 28 #include &quot;unittest.hpp&quot;
 29 
 30 TEST_VM(SymbolTable, temp_new_symbol) {
 31   // Assert messages assume these symbols are unique, and the refcounts start at
 32   // one, but code does not rely on this.
 33   JavaThread* THREAD = JavaThread::current();
 34   // the thread should be in vm to use locks
 35   ThreadInVMfromNative ThreadInVMfromNative(THREAD);
 36 
<span class="line-modified"> 37   Symbol* abc = SymbolTable::new_symbol(&quot;abc&quot;);</span>
 38   int abccount = abc-&gt;refcount();
 39   TempNewSymbol ss = abc;
 40   ASSERT_EQ(ss-&gt;refcount(), abccount) &lt;&lt; &quot;only one abc&quot;;
 41   ASSERT_EQ(ss-&gt;refcount(), abc-&gt;refcount()) &lt;&lt; &quot;should match TempNewSymbol&quot;;
 42 
<span class="line-modified"> 43   Symbol* efg = SymbolTable::new_symbol(&quot;efg&quot;);</span>
<span class="line-modified"> 44   Symbol* hij = SymbolTable::new_symbol(&quot;hij&quot;);</span>
 45   int efgcount = efg-&gt;refcount();
 46   int hijcount = hij-&gt;refcount();
 47 
 48   TempNewSymbol s1 = efg;
 49   TempNewSymbol s2 = hij;
 50   ASSERT_EQ(s1-&gt;refcount(), efgcount) &lt;&lt; &quot;one efg&quot;;
 51   ASSERT_EQ(s2-&gt;refcount(), hijcount) &lt;&lt; &quot;one hij&quot;;
 52 
 53   // Assignment operator
 54   s1 = s2;
 55   ASSERT_EQ(hij-&gt;refcount(), hijcount + 1) &lt;&lt; &quot;should be two hij&quot;;
 56   ASSERT_EQ(efg-&gt;refcount(), efgcount - 1) &lt;&lt; &quot;should be no efg&quot;;
 57 
 58   s1 = ss; // s1 is abc
 59   ASSERT_EQ(s1-&gt;refcount(), abccount + 1) &lt;&lt; &quot;should be two abc (s1 and ss)&quot;;
 60   ASSERT_EQ(hij-&gt;refcount(), hijcount) &lt;&lt; &quot;should only have one hij now (s2)&quot;;
 61 
 62   s1 = s1; // self assignment
 63   ASSERT_EQ(s1-&gt;refcount(), abccount + 1) &lt;&lt; &quot;should still be two abc (s1 and ss)&quot;;
 64 
 65   TempNewSymbol s3;
<span class="line-modified"> 66   Symbol* klm = SymbolTable::new_symbol(&quot;klm&quot;);</span>
 67   int klmcount = klm-&gt;refcount();
 68   s3 = klm; // assignment
 69   ASSERT_EQ(s3-&gt;refcount(), klmcount) &lt;&lt; &quot;only one klm now&quot;;
 70 
<span class="line-modified"> 71   Symbol* xyz = SymbolTable::new_symbol(&quot;xyz&quot;);</span>
 72   int xyzcount = xyz-&gt;refcount();
 73   { // inner scope
 74     TempNewSymbol s_inner = xyz;
 75   }
 76   ASSERT_EQ(xyz-&gt;refcount(), xyzcount - 1)
 77           &lt;&lt; &quot;Should have been decremented by dtor in inner scope&quot;;
 78 
 79   // Test overflowing refcount making symbol permanent
<span class="line-modified"> 80   Symbol* bigsym = SymbolTable::new_symbol(&quot;bigsym&quot;);</span>
 81   for (int i = 0; i &lt; PERM_REFCOUNT + 100; i++) {
 82     bigsym-&gt;increment_refcount();
 83   }
 84   ASSERT_EQ(bigsym-&gt;refcount(), PERM_REFCOUNT) &lt;&lt; &quot;should not have overflowed&quot;;
 85 
 86   // Test that PERM_REFCOUNT is sticky
 87   for (int i = 0; i &lt; 10; i++) {
 88     bigsym-&gt;decrement_refcount();
 89   }
 90   ASSERT_EQ(bigsym-&gt;refcount(), PERM_REFCOUNT) &lt;&lt; &quot;should be sticky&quot;;
 91 }
 92 
 93 // TODO: Make two threads one decrementing the refcount and the other trying to increment.
 94 // try_increment_refcount should return false
 95 
 96 #define SYM_NAME_LENGTH 30
 97 static char symbol_name[SYM_NAME_LENGTH];
 98 
 99 class SymbolThread : public JavaTestThread {
100   public:
101   SymbolThread(Semaphore* post) : JavaTestThread(post) {}
102   virtual ~SymbolThread() {}
103   void main_run() {

104     for (int i = 0; i &lt; 1000; i++) {
<span class="line-modified">105       TempNewSymbol sym = SymbolTable::new_symbol(symbol_name);</span>
106       // Create and destroy new symbol
107       EXPECT_TRUE(sym-&gt;refcount() != 0) &lt;&lt; &quot;Symbol refcount unexpectedly zeroed&quot;;
108     }
109   }
110 };
111 
112 #define SYM_TEST_THREAD_COUNT 5
113 
114 class DriverSymbolThread : public JavaTestThread {
115 public:
116   Semaphore _done;
117   DriverSymbolThread(Semaphore* post) : JavaTestThread(post) { };
118   virtual ~DriverSymbolThread(){}
119 
120   void main_run() {
121     Semaphore done(0);
122 


123     // Find a symbol where there will probably be only one instance.
124     for (int i = 0; i &lt; 100; i++) {
125        os::snprintf(symbol_name, SYM_NAME_LENGTH, &quot;some_symbol%d&quot;, i);
<span class="line-modified">126        TempNewSymbol ts = SymbolTable::new_symbol(symbol_name);</span>
127        if (ts-&gt;refcount() == 1) {
128          EXPECT_TRUE(ts-&gt;refcount() == 1) &lt;&lt; &quot;Symbol is just created&quot;;
129          break;  // found a unique symbol
130        }
131     }
132 
133     SymbolThread* st[SYM_TEST_THREAD_COUNT];
134     for (int i = 0; i &lt; SYM_TEST_THREAD_COUNT; i++) {
135       st[i] = new SymbolThread(&amp;done);
136       st[i]-&gt;doit();
137     }
138 
139     for (int i = 0; i &lt; SYM_TEST_THREAD_COUNT; i++) {
140       done.wait();
141     }
142   }
143 };
144 
145 TEST_VM(SymbolTable, test_symbol_refcount_parallel) {
146   mt_test_doer&lt;DriverSymbolThread&gt;();
</pre>
</td>
</tr>
</table>
<center><a href="../../../fmw/gtest/googletest/LICENSE.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../gc/g1/test_g1FreeIdSet.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
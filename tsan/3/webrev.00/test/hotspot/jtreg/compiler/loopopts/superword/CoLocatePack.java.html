<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/loopopts/superword/CoLocatePack.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
 1 /*
 2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 4  *
 5  * This code is free software; you can redistribute it and/or modify it
 6  * under the terms of the GNU General Public License version 2 only, as
 7  * published by the Free Software Foundation.
 8  *
 9  * This code is distributed in the hope that it will be useful, but WITHOUT
10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
12  * version 2 for more details (a copy is included in the LICENSE file that
13  * accompanied this code).
14  *
15  * You should have received a copy of the GNU General Public License version
16  * 2 along with this work; if not, write to the Free Software Foundation,
17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
18  *
19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
20  * or visit www.oracle.com if you need additional information or have any
21  * questions.
22  */
23 
24 /**
25  * @test
26  * @bug 8233032
27  * @summary Tests SuperWord::co_locate_pack() involving a load pack that relies on a sandwiched and moved StoreF node.
28  *
29  * @run main/othervm -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:UseAVX=1
30  *      -XX:CompileCommand=compileonly,compiler.loopopts.superword.CoLocatePack::test
31  *      compiler.loopopts.superword.CoLocatePack
32  */
33 package compiler.loopopts.superword;
34 
35 public class CoLocatePack {
36 
37     public static long lFld = 10;
38     public static float fFld = 11.2f;
39     public int iFld = 12;
40 
41     public void test() {
42         int iArr[] = new int[200];
43         float fArr[] = new float[200];
44 
45         /*
46          * The IR for this loop contains the following StoreF chain after unrolling once:
47          * StoreF 1 -&gt; StoreF 2 -&gt; StoreF 3 -&gt; StoreF 4 -&gt; StoreF 5 -&gt; StoreF 6
48          *
49          * The superword algorithm creates a pack for [ StoreF 2 and 5 ] and one for [ StoreF 3 and 6 ]
50          * (The pack [ StoreF 1 and 4 ] is filtered out). As a result, StoreF 3 and 4 are sandwiched between
51          * StoreF 2 and 5. SuperWord::co_locate_pack() will move both after StoreF 5 to remove any dependencies
52          * within the pack:
53          * StoreF 1 -&gt; [ StoreF 2 -&gt; StoreF 5 ] -&gt; StoreF 3 -&gt; StoreF 4 -&gt; StoreF 6
54          *
55          * Afterwards, StoreF 4 is moved before StoreF 3 to remove any dependency within [ StoreF 3 -&gt; StoreF 6 ]
56          * The resulting chain looks like this:
57          * StoreF 1 -&gt; [ StoreF 2 -&gt; StoreF 5 ] -&gt; StoreF 4 -&gt; [ StoreF 3 -&gt; StoreF 6 ]
58          *
59          * When later processing a load pack depending on StoreF 4 and 5, the first and last memory state of the load pack are
60          * determined by using the bb indices. However, those were not updated before when moving nodes around and
61          * bb_idx(4) &lt; bb_idx(5) still holds even though they swapped positions in the IR. Therefore, it wrongly uses the memory
62          * state of the first load (StoreF 5) in the pack as the last memory state. As a result, the graph walk always starts
63          * following the input of StoreF 5 (which should actually be StoreF 4) and will move beyond a loop phi as the stop
64          * condition is never met for a node having another memory state than the first one of the load pack. Eventually a
65          * bb index for a node outside of the loop is read resulting in an assertion failure.
66          *
67          * The fix uses a different approach to find the first and last memory state of a load pack without depending on bb indices.
68          */
69         for (int i = 5; i &lt; 169; i++) {
70             fArr[i + 1] += ((long)(fFld) | 1); // StoreF 1/4
71             iFld += lFld;
72             fArr[i - 1] -= 20; // StoreF 2/5
73             fFld += i;
74             fArr[i + 1] -= -117; // StoreF 3/6
75 
76             int j = 10;
77             do {
78             } while (--j &gt; 0);
79 
80             iArr[i] += 11;
81         }
82     }
83 
84     public static void main(String[] strArr) {
85         CoLocatePack _instance = new CoLocatePack();
86         for (int i = 0; i &lt; 1000; i++ ) {
87             _instance.test();
88         }
89     }
90 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/codegen/aes/TestAESBase.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package compiler.codegen.aes;
 25 
 26 import jdk.test.lib.Utils;
 27 
 28 import javax.crypto.Cipher;
 29 import javax.crypto.SecretKey;
 30 import javax.crypto.spec.GCMParameterSpec;
 31 import javax.crypto.spec.IvParameterSpec;
 32 import javax.crypto.spec.SecretKeySpec;
 33 import java.security.AlgorithmParameters;
 34 import java.util.Random;
 35 
 36 /**
 37  * @author Tom Deneau
 38  */
 39 public abstract class TestAESBase {
 40     int msgSize = Integer.getInteger(&quot;msgSize&quot;, 646);
 41     boolean checkOutput = Boolean.getBoolean(&quot;checkOutput&quot;);
 42     boolean noReinit = Boolean.getBoolean(&quot;noReinit&quot;);
 43     boolean testingMisalignment;
 44     private static final int ALIGN = 8;
 45     int encInputOffset = Integer.getInteger(&quot;encInputOffset&quot;, 0) % ALIGN;
 46     int encOutputOffset = Integer.getInteger(&quot;encOutputOffset&quot;, 0) % ALIGN;
 47     int decOutputOffset = Integer.getInteger(&quot;decOutputOffset&quot;, 0) % ALIGN;
 48     int lastChunkSize = Integer.getInteger(&quot;lastChunkSize&quot;, 32);
 49     int keySize = Integer.getInteger(&quot;keySize&quot;, 128);
 50     int inputLength;
 51     int encodeLength;
 52     int decodeLength;
 53     int decodeMsgSize;
 54     String algorithm = System.getProperty(&quot;algorithm&quot;, &quot;AES&quot;);
 55     String mode = System.getProperty(&quot;mode&quot;, &quot;CBC&quot;);
 56     String paddingStr = System.getProperty(&quot;paddingStr&quot;,
 57         (mode.equals(&quot;GCM&quot;) || mode.equals(&quot;CTR&quot;) || mode.equals(&quot;CTS&quot;)) ?
 58          &quot;NoPadding&quot; : &quot;PKCS5Padding&quot;);
 59     byte[] input;
 60     byte[] encode;
 61     byte[] expectedEncode;
 62     byte[] decode;
 63     byte[] expectedDecode;
 64     final Random random = Utils.getRandomInstance();
 65     Cipher cipher;
 66     Cipher dCipher;
 67     AlgorithmParameters algParams = null;
 68     SecretKey key;
 69     GCMParameterSpec gcm_spec;
 70     byte[] aad = {0x11, 0x22, 0x33, 0x44, 0x55};
 71     int tlen = 12;
 72     byte[] iv = new byte[16];
 73 
 74     static int numThreads = 0;
 75     int threadId;
 76 
 77     static synchronized int getThreadId() {
 78         int id = numThreads;
 79         numThreads++;
 80         return id;
 81     }
 82 
 83     abstract public void run();
 84 
 85     public void prepare() {
 86         try {
 87             System.out.println(&quot;\nalgorithm=&quot; + algorithm + &quot;, mode=&quot; + mode + &quot;, paddingStr=&quot; + paddingStr +
 88                     &quot;, msgSize=&quot; + msgSize + &quot;, keySize=&quot; + keySize + &quot;, noReinit=&quot; + noReinit +
 89                     &quot;, checkOutput=&quot; + checkOutput + &quot;, encInputOffset=&quot; + encInputOffset + &quot;, encOutputOffset=&quot; +
 90                     encOutputOffset + &quot;, decOutputOffset=&quot; + decOutputOffset + &quot;, lastChunkSize=&quot; + lastChunkSize);
 91 
 92             if (encInputOffset % ALIGN != 0 || encOutputOffset % ALIGN != 0 || decOutputOffset % ALIGN != 0)
 93                 testingMisalignment = true;
 94 
 95             int keyLenBytes = (keySize == 0 ? 16 : keySize / 8);
 96             byte keyBytes[] = new byte[keyLenBytes];
 97             if (keySize == 128)
 98                 keyBytes = new byte[]{-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7};
 99             else
100                 random.nextBytes(keyBytes);
101 
102             key = new SecretKeySpec(keyBytes, algorithm);
103             if (threadId == 0) {
104                 System.out.println(&quot;Algorithm: &quot; + key.getAlgorithm() + &quot;(&quot;
105                         + key.getEncoded().length * 8 + &quot;bit)&quot;);
106             }
107 
108             cipher = Cipher.getInstance(algorithm + &quot;/&quot; + mode + &quot;/&quot; + paddingStr, &quot;SunJCE&quot;);
109             dCipher = Cipher.getInstance(algorithm + &quot;/&quot; + mode + &quot;/&quot; + paddingStr, &quot;SunJCE&quot;);
110 
111             // CBC or CTR init
112             if (mode.equals(&quot;CBC&quot;) || mode.equals(&quot;CTR&quot;)) {
113                 IvParameterSpec initVector = new IvParameterSpec(iv);
114                 cipher.init(Cipher.ENCRYPT_MODE, key, initVector);
115                 algParams = cipher.getParameters();
116                 dCipher.init(Cipher.DECRYPT_MODE, key, initVector);
117 
118                 // GCM init
119             } else if (mode.equals(&quot;GCM&quot;)) {
120                 gcm_init(true);
121                 gcm_init(false);
122 
123                 // ECB init
124             } else {
125                 cipher.init(Cipher.ENCRYPT_MODE, key, algParams);
126                 dCipher.init(Cipher.DECRYPT_MODE, key, algParams);
127             }
128 
129             if (threadId == 0) {
130                 childShowCipher();
131             }
132 
133             inputLength = msgSize + encInputOffset;
134             if (testingMisalignment) {
135                 encodeLength = cipher.getOutputSize(msgSize - lastChunkSize) + encOutputOffset;
136                 encodeLength += cipher.getOutputSize(lastChunkSize);
137                 decodeLength = dCipher.getOutputSize(encodeLength - lastChunkSize) + decOutputOffset;
138                 decodeLength += dCipher.getOutputSize(lastChunkSize);
139             } else {
140                 encodeLength = cipher.getOutputSize(msgSize) + encOutputOffset;
141                 decodeLength = dCipher.getOutputSize(encodeLength) + decOutputOffset;
142             }
143 
144             input = new byte[inputLength];
145             for (int i = encInputOffset, j = 0; i &lt; inputLength; i++, j++) {
146                 input[i] = (byte) (j &amp; 0xff);
147             }
148 
149             // do one encode and decode in preparation
150             encode = new byte[encodeLength];
151             decode = new byte[decodeLength];
152             if (testingMisalignment) {
153                 decodeMsgSize = cipher.update(input, encInputOffset, (msgSize - lastChunkSize), encode, encOutputOffset);
154                 decodeMsgSize += cipher.doFinal(input, (encInputOffset + msgSize - lastChunkSize), lastChunkSize, encode, (encOutputOffset + decodeMsgSize));
155 
156                 int tempSize = dCipher.update(encode, encOutputOffset, (decodeMsgSize - lastChunkSize), decode, decOutputOffset);
157                 dCipher.doFinal(encode, (encOutputOffset + decodeMsgSize - lastChunkSize), lastChunkSize, decode, (decOutputOffset + tempSize));
158             } else {
159                 decodeMsgSize = cipher.doFinal(input, encInputOffset, msgSize, encode, encOutputOffset);
160                 dCipher.doFinal(encode, encOutputOffset, decodeMsgSize, decode, decOutputOffset);
161             }
162             if (checkOutput) {
163                 expectedEncode = (byte[]) encode.clone();
164                 expectedDecode = (byte[]) decode.clone();
165                 showArray(key.getEncoded(), &quot;key:    &quot;);
166                 showArray(input, &quot;input:  &quot;);
167                 showArray(encode, &quot;encode: &quot;);
168                 showArray(decode, &quot;decode: &quot;);
169             }
170         } catch (Exception e) {
171             e.printStackTrace();
172             System.exit(1);
173         }
174     }
175 
176     void showArray(byte b[], String name) {
177         System.out.format(&quot;%s [%d]: &quot;, name, b.length);
178         for (int i = 0; i &lt; Math.min(b.length, 32); i++) {
179             System.out.format(&quot;%02x &quot;, b[i] &amp; 0xff);
180         }
181         System.out.println();
182     }
183 
184     void compareArrays(byte b[], byte exp[]) {
185         if (b.length != exp.length) {
186             System.out.format(&quot;different lengths for actual and expected output arrays\n&quot;);
187             showArray(b, &quot;test: &quot;);
188             showArray(exp, &quot;exp : &quot;);
189             System.exit(1);
190         }
191         for (int i = 0; i &lt; exp.length; i++) {
192             if (b[i] != exp[i]) {
193                 System.out.format(&quot;output error at index %d: got %02x, expected %02x\n&quot;, i, b[i] &amp; 0xff, exp[i] &amp; 0xff);
194                 showArray(b, &quot;test: &quot;);
195                 showArray(exp, &quot;exp : &quot;);
196                 System.exit(1);
197             }
198         }
199     }
200 
201     void showCipher(Cipher c, String kind) {
202         System.out.println(kind + &quot; cipher provider: &quot; + cipher.getProvider());
203         System.out.println(kind + &quot; cipher algorithm: &quot; + cipher.getAlgorithm());
204     }
205 
206     abstract void childShowCipher();
207 
208     void gcm_init(boolean encrypt) throws Exception {
209         gcm_spec = new GCMParameterSpec(tlen * 8, iv);
210         if (encrypt) {
211             // Get a new instance everytime because of reuse IV restrictions
212             cipher = Cipher.getInstance(algorithm + &quot;/&quot; + mode + &quot;/&quot; + paddingStr, &quot;SunJCE&quot;);
213             cipher.init(Cipher.ENCRYPT_MODE, key, gcm_spec);
214             cipher.updateAAD(aad);
215         } else {
216             dCipher.init(Cipher.DECRYPT_MODE, key, gcm_spec);
217             dCipher.updateAAD(aad);
218 
219 
220         }
221     }
222 }
    </pre>
  </body>
</html>
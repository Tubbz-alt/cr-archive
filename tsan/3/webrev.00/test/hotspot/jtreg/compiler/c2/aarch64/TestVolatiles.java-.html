<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/compiler/c2/aarch64/TestVolatiles.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * common code to run and validate tests of code generation for
  26  * volatile ops on AArch64
  27  *
  28  * incoming args are &lt;testclass&gt; &lt;testtype&gt;
  29  *
  30  * where &lt;testclass&gt; in {TestVolatileLoad,
  31  *                       TestVolatileStore,
  32  *                       TestUnsafeVolatileLoad,
  33  *                       TestUnsafeVolatileStore,
  34  *                       TestUnsafeVolatileCAS,
  35  *                       TestUnsafeVolatileWeakCAS,
  36  *                       TestUnsafeVolatileCAE,
  37  *                       TestUnsafeVolatileGAS}
  38  * and &lt;testtype&gt; in {G1,
  39  *                    CMS,
  40  *                    CMSCondMark,
  41  *                    Serial,
  42  *                    Parallel,
  43  *                    Shenandoah,
  44  *                    ShenandoahTraversal}
  45  */
  46 
  47 
  48 package compiler.c2.aarch64;
  49 
  50 import java.util.List;
  51 import java.util.ListIterator;
  52 import java.util.Iterator;
  53 import java.util.regex.Pattern;
  54 import java.io.*;
  55 
  56 import jdk.test.lib.Asserts;
  57 import jdk.test.lib.compiler.InMemoryJavaCompiler;
  58 import jdk.test.lib.process.OutputAnalyzer;
  59 import jdk.test.lib.process.ProcessTools;
  60 import sun.hotspot.WhiteBox;
  61 
  62 // runner class that spawns a new JVM to exercises a combination of
  63 // volatile MemOp and GC. The ops are compiled with the dmb --&gt;
  64 // ldar/stlr transforms either enabled or disabled. this runner parses
  65 // the PrintOptoAssembly output checking that the generated code is
  66 // correct.
  67 
  68 public class TestVolatiles {
  69     public void runtest(String classname, String testType) throws Throwable {
  70         // n.b. clients omit the package name for the class
  71         String fullclassname = &quot;compiler.c2.aarch64.&quot; + classname;
  72         // build up a command line for the spawned JVM
  73         String[] procArgs;
  74         int argcount;
  75         // add one or two extra arguments according to test type
  76         // i.e. GC type plus GC conifg
  77         switch(testType) {
  78         case &quot;G1&quot;:
  79             argcount = 9;
  80             procArgs = new String[argcount];
  81             procArgs[argcount - 2] = &quot;-XX:+UseG1GC&quot;;
  82             break;
  83         case &quot;Parallel&quot;:
  84             argcount = 9;
  85             procArgs = new String[argcount];
  86             procArgs[argcount - 2] = &quot;-XX:+UseParallelGC&quot;;
  87             break;
  88         case &quot;Serial&quot;:
  89             argcount = 9;
  90             procArgs = new String[argcount];
  91             procArgs[argcount - 2] = &quot;-XX:+UseSerialGC&quot;;
  92             break;
  93         case &quot;CMS&quot;:
  94             argcount = 10;
  95             procArgs = new String[argcount];
  96             procArgs[argcount - 3] = &quot;-XX:+UseConcMarkSweepGC&quot;;
  97             procArgs[argcount - 2] = &quot;-XX:-UseCondCardMark&quot;;
  98             break;
  99         case &quot;CMSCondMark&quot;:
 100             argcount = 10;
 101             procArgs = new String[argcount];
 102             procArgs[argcount - 3] = &quot;-XX:+UseConcMarkSweepGC&quot;;
 103             procArgs[argcount - 2] = &quot;-XX:+UseCondCardMark&quot;;
 104             break;
 105         case &quot;Shenandoah&quot;:
 106             argcount = 10;
 107             procArgs = new String[argcount];
 108             procArgs[argcount - 3] = &quot;-XX:+UnlockExperimentalVMOptions&quot;;
 109             procArgs[argcount - 2] = &quot;-XX:+UseShenandoahGC&quot;;
 110             break;
 111         case &quot;ShenandoahTraversal&quot;:
 112             argcount = 11;
 113             procArgs = new String[argcount];
 114             procArgs[argcount - 4] = &quot;-XX:+UnlockExperimentalVMOptions&quot;;
 115             procArgs[argcount - 3] = &quot;-XX:+UseShenandoahGC&quot;;
 116             procArgs[argcount - 2] = &quot;-XX:ShenandoahGCHeuristics=traversal&quot;;
 117             break;
 118         default:
 119             throw new RuntimeException(&quot;unexpected test type &quot; + testType);
 120         }
 121 
 122         // fill in arguments common to all cases
 123 
 124         // the first round of test enables transform of barriers to
 125         // use acquiring loads and releasing stores by setting arg
 126         // zero appropriately. this arg is reset in the second run to
 127         // disable the transform.
 128 
 129         procArgs[0] = &quot;-XX:-UseBarriersForVolatile&quot;;
 130         procArgs[1] = &quot;-XX:+UseCompressedOops&quot;;
 131 
 132         procArgs[2] = &quot;-XX:-TieredCompilation&quot;;
 133         procArgs[3] = &quot;-XX:+PrintOptoAssembly&quot;;
 134         procArgs[4] = &quot;-XX:CompileCommand=compileonly,&quot; + fullclassname + &quot;::&quot; + &quot;test*&quot;;
 135         procArgs[5] = &quot;--add-exports&quot;;
 136         procArgs[6] = &quot;java.base/jdk.internal.misc=ALL-UNNAMED&quot;;
 137         procArgs[argcount - 1] = fullclassname;
 138 
 139         runtest(classname, testType, false, true, procArgs);
 140         // rerun the test class without the transform applied and
 141         // check the alternative generation is as expected
 142 
 143         procArgs[0] = &quot;-XX:+UseBarriersForVolatile&quot;;
 144         runtest(classname, testType, true, true, procArgs);
 145 
 146         if (!classname.equals(&quot;TestUnsafeVolatileGAA&quot;)) {
 147             procArgs[0] = &quot;-XX:-UseBarriersForVolatile&quot;;
 148             procArgs[1] = &quot;-XX:-UseCompressedOops&quot;;
 149             runtest(classname, testType, false, false, procArgs);
 150 
 151             procArgs[0] = &quot;-XX:+UseBarriersForVolatile&quot;;
 152             runtest(classname, testType, true, false, procArgs);
 153         }
 154     }
 155 
 156 
 157     public void runtest(String classname, String testType, boolean useBarriersForVolatile, boolean useCompressedOops, String[] procArgs) throws Throwable {
 158         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(procArgs);
 159         OutputAnalyzer output = new OutputAnalyzer(pb.start());
 160 
 161         output.stderrShouldBeEmptyIgnoreVMWarnings();
 162         output.stdoutShouldNotBeEmpty();
 163         output.shouldHaveExitValue(0);
 164 
 165         // check the output for the correct asm sequence as
 166         // appropriate to test class, test type and whether transform
 167         // was applied
 168 
 169         checkoutput(output, classname, testType, useBarriersForVolatile, useCompressedOops);
 170     }
 171 
 172     // skip through output returning a line containing the desireed
 173     // substring or null
 174     private String skipTo(Iterator&lt;String&gt; iter, String substring)
 175     {
 176         while (iter.hasNext()) {
 177             String nextLine = iter.next();
 178             if (nextLine.matches(&quot;.*&quot; + substring + &quot;.*&quot;)) {
 179                 return nextLine;
 180             }
 181         }
 182         return null;
 183     }
 184 
 185     // locate the start of compiler output for the desired method and
 186     // then check that each expected instruction occurs in the output
 187     // in the order supplied. throw an excpetion if not found.
 188     // n.b. the spawned JVM&#39;s output is included in the exception
 189     // message to make it easeir to identify what is missing.
 190 
 191     private boolean checkCompile(Iterator&lt;String&gt; iter, String methodname, String[] expected, OutputAnalyzer output, boolean do_throw)
 192     {
 193         // trace call to allow eyeball check of what we are checking against
 194         System.out.println(&quot;checkCompile(&quot; + methodname + &quot;,&quot;);
 195         String sepr = &quot;  { &quot;;
 196         for (String s : expected) {
 197             System.out.print(sepr);
 198             System.out.print(s);
 199             sepr = &quot;,\n    &quot;;
 200         }
 201         System.out.println(&quot; })&quot;);
 202 
 203         // look for the start of an opto assembly print block
 204         String match = skipTo(iter, Pattern.quote(&quot;{method}&quot;));
 205         if (match == null) {
 206             if (do_throw) {
 207                 throw new RuntimeException(&quot;Missing compiler output for &quot; + methodname + &quot;!\n\n&quot; + output.getOutput());
 208             }
 209             return false;
 210         }
 211         // check the compiled method name is right
 212         match = skipTo(iter, Pattern.quote(&quot;- name:&quot;));
 213         if (match == null) {
 214             if (do_throw) {
 215                 throw new RuntimeException(&quot;Missing compiled method name!\n\n&quot; + output.getOutput());
 216             }
 217             return false;
 218         }
 219         if (!match.contains(methodname)) {
 220             if (do_throw) {
 221                 throw new RuntimeException(&quot;Wrong method &quot; + match + &quot;!\n  -- expecting &quot; + methodname + &quot;\n\n&quot; + output.getOutput());
 222             }
 223             return false;
 224         }
 225         // make sure we can match each expected term in order
 226         for (String s : expected) {
 227             match = skipTo(iter, s);
 228             if (match == null) {
 229                 if (do_throw) {
 230                     throw new RuntimeException(&quot;Missing expected output &quot; + s + &quot;!\n\n&quot; + output.getOutput());
 231                 }
 232                 return false;
 233             }
 234         }
 235         return true;
 236     }
 237 
 238     // check for expected asm output from a volatile load
 239 
 240     private void checkload(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
 241     {
 242         Iterator&lt;String&gt; iter = output.asLines().listIterator();
 243 
 244         // we shoud see this same sequence for normal or unsafe volatile load
 245         // for both int and Object fields
 246 
 247         String[] matches;
 248 
 249         if (!useBarriersForVolatile) {
 250             matches = new String[] {
 251                 &quot;ldarw&quot;,
 252                 &quot;membar_acquire \\(elided\\)&quot;,
 253                 &quot;ret&quot;
 254             };
 255         } else {
 256             matches = new String[] {
 257                 &quot;ldrw&quot;,
 258                 &quot;membar_acquire&quot;,
 259                 &quot;dmb ish&quot;,
 260                 &quot;ret&quot;
 261             };
 262         }
 263 
 264         checkCompile(iter, &quot;testInt&quot;, matches, output, true);
 265 
 266         if (!useBarriersForVolatile) {
 267             matches = new String[] {
 268                 useCompressedOops ? &quot;ldarw?&quot; : &quot;ldar&quot;,
 269                 &quot;membar_acquire \\(elided\\)&quot;,
 270                 &quot;ret&quot;
 271             };
 272         } else {
 273             matches = new String[] {
 274                 useCompressedOops ? &quot;ldrw?&quot; : &quot;ldr&quot;,
 275                 &quot;membar_acquire&quot;,
 276                 &quot;dmb ish&quot;,
 277                 &quot;ret&quot;
 278             };
 279         }
 280 
 281         checkCompile(iter, &quot;testObj&quot;, matches, output, true);
 282 
 283     }
 284 
 285     // check for expected asm output from a volatile store
 286 
 287     private void checkstore(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
 288     {
 289         Iterator&lt;String&gt; iter = output.asLines().listIterator();
 290 
 291         String[] matches;
 292 
 293         // non object stores are straightforward
 294         if (!useBarriersForVolatile) {
 295             // this is the sequence of instructions for all cases
 296             matches = new String[] {
 297                 &quot;membar_release \\(elided\\)&quot;,
 298                 &quot;stlrw&quot;,
 299                 &quot;membar_volatile \\(elided\\)&quot;,
 300                 &quot;ret&quot;
 301             };
 302         } else {
 303             // this is the alternative sequence of instructions
 304             matches = new String[] {
 305                 &quot;membar_release&quot;,
 306                 &quot;dmb ish&quot;,
 307                 &quot;strw&quot;,
 308                 &quot;membar_volatile&quot;,
 309                 &quot;dmb ish&quot;,
 310                 &quot;ret&quot;
 311             };
 312         }
 313 
 314         checkCompile(iter, &quot;testInt&quot;, matches, output, true);
 315 
 316         // object stores will be as above except for when the GC
 317         // introduces barriers for card marking
 318 
 319         if (!useBarriersForVolatile) {
 320             switch (testType) {
 321             default:
 322                 // this is the basic sequence of instructions
 323                 matches = new String[] {
 324                     &quot;membar_release \\(elided\\)&quot;,
 325                     useCompressedOops ? &quot;stlrw?&quot; : &quot;stlr&quot;,
 326                     &quot;membar_volatile \\(elided\\)&quot;,
 327                     &quot;ret&quot;
 328                 };
 329                 break;
 330             case &quot;G1&quot;:
 331                 // a card mark volatile barrier should be generated
 332                 // before the card mark strb
 333                 matches = new String[] {
 334                     &quot;membar_release \\(elided\\)&quot;,
 335                     useCompressedOops ? &quot;stlrw?&quot; : &quot;stlr&quot;,
 336                     &quot;membar_volatile&quot;,
 337                     &quot;dmb ish&quot;,
 338                     &quot;strb&quot;,
 339                     &quot;membar_volatile \\(elided\\)&quot;,
 340                     &quot;ret&quot;
 341                 };
 342                 break;
 343             case &quot;CMSCondMark&quot;:
 344                 // a card mark volatile barrier should be generated
 345                 // before the card mark strb from the StoreCM and the
 346                 // storestore barrier from the StoreCM should be elided
 347                 matches = new String[] {
 348                     &quot;membar_release \\(elided\\)&quot;,
 349                     useCompressedOops ? &quot;stlrw?&quot; : &quot;stlr&quot;,
 350                     &quot;membar_volatile&quot;,
 351                     &quot;dmb ish&quot;,
 352                     &quot;storestore \\(elided\\)&quot;,
 353                     &quot;strb&quot;,
 354                     &quot;membar_volatile \\(elided\\)&quot;,
 355                     &quot;ret&quot;
 356                 };
 357                 break;
 358             case &quot;CMS&quot;:
 359                 // a volatile card mark membar should not be generated
 360                 // before the card mark strb from the StoreCM and the
 361                 // storestore barrier from the StoreCM should be
 362                 // generated as &quot;dmb ishst&quot;
 363                 matches = new String[] {
 364                     &quot;membar_release \\(elided\\)&quot;,
 365                     useCompressedOops ? &quot;stlrw?&quot; : &quot;stlr&quot;,
 366                     &quot;storestore&quot;,
 367                     &quot;dmb ishst&quot;,
 368                     &quot;strb&quot;,
 369                     &quot;membar_volatile \\(elided\\)&quot;,
 370                     &quot;ret&quot;
 371                 };
 372                 break;
 373             case &quot;Shenandoah&quot;:
 374             case &quot;ShenandoahTraversal&quot;:
 375                  // Shenandoah generates normal object graphs for
 376                  // volatile stores
 377                 matches = new String[] {
 378                     &quot;membar_release \\(elided\\)&quot;,
 379                     useCompressedOops ? &quot;stlrw?&quot; : &quot;stlr&quot;,
 380                     &quot;membar_volatile \\(elided\\)&quot;,
 381                     &quot;ret&quot;
 382                 };
 383                 break;
 384             }
 385         } else {
 386             switch (testType) {
 387             default:
 388                 // this is the basic sequence of instructions
 389                 matches = new String[] {
 390                     &quot;membar_release&quot;,
 391                     &quot;dmb ish&quot;,
 392                     useCompressedOops ? &quot;strw?&quot; : &quot;str&quot;,
 393                     &quot;membar_volatile&quot;,
 394                     &quot;dmb ish&quot;,
 395                     &quot;ret&quot;
 396                 };
 397                 break;
 398             case &quot;G1&quot;:
 399                 // a card mark volatile barrier should be generated
 400                 // before the card mark strb
 401                 matches = new String[] {
 402                     &quot;membar_release&quot;,
 403                     &quot;dmb ish&quot;,
 404                     useCompressedOops ? &quot;strw?&quot; : &quot;str&quot;,
 405                     &quot;membar_volatile&quot;,
 406                     &quot;dmb ish&quot;,
 407                     &quot;strb&quot;,
 408                     &quot;membar_volatile&quot;,
 409                     &quot;dmb ish&quot;,
 410                     &quot;ret&quot;
 411                 };
 412                 break;
 413             case &quot;CMSCondMark&quot;:
 414                 // a card mark volatile barrier should be generated
 415                 // before the card mark strb from the StoreCM and the
 416                 // storestore barrier from the StoreCM should be elided
 417                 matches = new String[] {
 418                     &quot;membar_release&quot;,
 419                     &quot;dmb ish&quot;,
 420                     useCompressedOops ? &quot;strw?&quot; : &quot;str&quot;,
 421                     &quot;membar_volatile&quot;,
 422                     &quot;dmb ish&quot;,
 423                     &quot;storestore \\(elided\\)&quot;,
 424                     &quot;strb&quot;,
 425                     &quot;membar_volatile&quot;,
 426                     &quot;dmb ish&quot;,
 427                     &quot;ret&quot;
 428                 };
 429                 break;
 430             case &quot;CMS&quot;:
 431                 // a volatile card mark membar should not be generated
 432                 // before the card mark strb from the StoreCM and the
 433                 // storestore barrier from the StoreCM should be generated
 434                 // as &quot;dmb ishst&quot;
 435                 matches = new String[] {
 436                     &quot;membar_release&quot;,
 437                     &quot;dmb ish&quot;,
 438                     useCompressedOops ? &quot;strw?&quot; : &quot;str&quot;,
 439                     &quot;storestore&quot;,
 440                     &quot;dmb ishst&quot;,
 441                     &quot;strb&quot;,
 442                     &quot;membar_volatile&quot;,
 443                     &quot;dmb ish&quot;,
 444                     &quot;ret&quot;
 445                 };
 446                 break;
 447 
 448             case &quot;Shenandoah&quot;:
 449             case &quot;ShenandoahTraversal&quot;:
 450                  // Shenandoah generates normal object graphs for
 451                  // volatile stores
 452                 matches = new String[] {
 453                     &quot;membar_release&quot;,
 454                     &quot;dmb ish&quot;,
 455                     useCompressedOops ? &quot;strw?&quot; : &quot;str&quot;,
 456                     &quot;membar_volatile&quot;,
 457                     &quot;dmb ish&quot;,
 458                     &quot;ret&quot;
 459                 };
 460                 break;
 461             }
 462         }
 463 
 464         checkCompile(iter, &quot;testObj&quot;, matches, output, true);
 465     }
 466 
 467     // check for expected asm output from a volatile cas
 468 
 469     private void checkcas(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
 470     {
 471         Iterator&lt;String&gt; iter = output.asLines().listIterator();
 472 
 473         String[] matches;
 474         String[][] tests = {
 475             { &quot;testInt&quot;, &quot;cmpxchgw&quot; },
 476             { &quot;testLong&quot;, &quot;cmpxchg&quot; },
 477             { &quot;testByte&quot;, &quot;cmpxchgb&quot; },
 478             { &quot;testShort&quot;, &quot;cmpxchgs&quot; },
 479         };
 480 
 481         for (String[] test : tests) {
 482             // non object stores are straightforward
 483             if (!useBarriersForVolatile) {
 484                 // this is the sequence of instructions for all cases
 485                 matches = new String[] {
 486                     &quot;membar_release \\(elided\\)&quot;,
 487                     test[1] + &quot;_acq&quot;,
 488                     &quot;membar_acquire \\(elided\\)&quot;,
 489                     &quot;ret&quot;
 490                 };
 491             } else {
 492                 // this is the alternative sequence of instructions
 493                 matches = new String[] {
 494                     &quot;membar_release&quot;,
 495                     &quot;dmb ish&quot;,
 496                     test[1] + &quot; &quot;,
 497                     &quot;membar_acquire&quot;,
 498                     &quot;dmb ish&quot;,
 499                     &quot;ret&quot;
 500                 };
 501             }
 502 
 503             checkCompile(iter, test[0], matches, output, true);
 504         }
 505 
 506         // object stores will be as above except for when the GC
 507         // introduces barriers for card marking
 508 
 509         if (!useBarriersForVolatile) {
 510             switch (testType) {
 511             default:
 512                 // this is the basic sequence of instructions
 513                 matches = new String[] {
 514                     &quot;membar_release \\(elided\\)&quot;,
 515                     useCompressedOops ? &quot;cmpxchgw?_acq&quot; : &quot;cmpxchg_acq&quot;,
 516                     &quot;strb&quot;,
 517                     &quot;membar_acquire \\(elided\\)&quot;,
 518                     &quot;ret&quot;
 519                 };
 520                 break;
 521             case &quot;G1&quot;:
 522                 // a card mark volatile barrier should be generated
 523                 // before the card mark strb
 524                 matches = new String[] {
 525                     &quot;membar_release \\(elided\\)&quot;,
 526                     useCompressedOops ? &quot;cmpxchgw?_acq&quot; : &quot;cmpxchg_acq&quot;,
 527                     &quot;membar_volatile&quot;,
 528                     &quot;dmb ish&quot;,
 529                     &quot;strb&quot;,
 530                     &quot;membar_acquire \\(elided\\)&quot;,
 531                     &quot;ret&quot;
 532                 };
 533                 break;
 534             case &quot;CMSCondMark&quot;:
 535                 // a card mark volatile barrier should be generated
 536                 // before the card mark strb from the StoreCM and the
 537                 // storestore barrier from the StoreCM should be elided
 538                 matches = new String[] {
 539                     &quot;membar_release \\(elided\\)&quot;,
 540                     useCompressedOops ? &quot;cmpxchgw?_acq&quot; : &quot;cmpxchg_acq&quot;,
 541                     &quot;membar_volatile&quot;,
 542                     &quot;dmb ish&quot;,
 543                     &quot;storestore \\(elided\\)&quot;,
 544                     &quot;strb&quot;,
 545                     &quot;membar_acquire \\(elided\\)&quot;,
 546                     &quot;ret&quot;
 547                 };
 548                 break;
 549             case &quot;CMS&quot;:
 550                 // a volatile card mark membar should not be generated
 551                 // before the card mark strb from the StoreCM and the
 552                 // storestore barrier from the StoreCM should be elided
 553                 matches = new String[] {
 554                     &quot;membar_release \\(elided\\)&quot;,
 555                     useCompressedOops ? &quot;cmpxchgw?_acq&quot; : &quot;cmpxchg_acq&quot;,
 556                     &quot;storestore&quot;,
 557                     &quot;dmb ishst&quot;,
 558                     &quot;strb&quot;,
 559                     &quot;membar_acquire \\(elided\\)&quot;,
 560                     &quot;ret&quot;
 561                 };
 562                 break;
 563             case &quot;Shenandoah&quot;:
 564             case &quot;ShenandoahTraversal&quot;:
 565                 // For volatile CAS, Shenanodoah generates normal
 566                 // graphs with a shenandoah-specific cmpxchg
 567                 matches = new String[] {
 568                     &quot;membar_release \\(elided\\)&quot;,
 569                     useCompressedOops ? &quot;cmpxchgw?_acq_shenandoah&quot; : &quot;cmpxchg_acq_shenandoah&quot;,
 570                     &quot;membar_acquire \\(elided\\)&quot;,
 571                     &quot;ret&quot;
 572                 };
 573                 break;
 574             }
 575         } else {
 576             switch (testType) {
 577             default:
 578                 // this is the basic sequence of instructions
 579                 matches = new String[] {
 580                     &quot;membar_release&quot;,
 581                     &quot;dmb ish&quot;,
 582                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 583                     &quot;membar_acquire&quot;,
 584                     &quot;dmb ish&quot;,
 585                     &quot;ret&quot;
 586                 };
 587                 break;
 588             case &quot;G1&quot;:
 589                 // a card mark volatile barrier should be generated
 590                 // before the card mark strb
 591                 matches = new String[] {
 592                     &quot;membar_release&quot;,
 593                     &quot;dmb ish&quot;,
 594                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 595                     &quot;membar_volatile&quot;,
 596                     &quot;dmb ish&quot;,
 597                     &quot;strb&quot;,
 598                     &quot;membar_acquire&quot;,
 599                     &quot;dmb ish&quot;,
 600                     &quot;ret&quot;
 601                 };
 602                 break;
 603             case &quot;CMSCondMark&quot;:
 604                 // a card mark volatile barrier should be generated
 605                 // before the card mark strb from the StoreCM and the
 606                 // storestore barrier from the StoreCM should be elided
 607                 matches = new String[] {
 608                     &quot;membar_release&quot;,
 609                     &quot;dmb ish&quot;,
 610                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 611                     &quot;membar_volatile&quot;,
 612                     &quot;dmb ish&quot;,
 613                     &quot;storestore \\(elided\\)&quot;,
 614                     &quot;strb&quot;,
 615                     &quot;membar_acquire&quot;,
 616                     &quot;dmb ish&quot;,
 617                     &quot;ret&quot;
 618                 };
 619                 break;
 620             case &quot;CMS&quot;:
 621                 // a volatile card mark membar should not be generated
 622                 // before the card mark strb from the StoreCM and the
 623                 // storestore barrier from the StoreCM should be generated
 624                 // as &quot;dmb ishst&quot;
 625                 matches = new String[] {
 626                     &quot;membar_release&quot;,
 627                     &quot;dmb ish&quot;,
 628                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 629                     &quot;storestore&quot;,
 630                     &quot;dmb ishst&quot;,
 631                     &quot;strb&quot;,
 632                     &quot;membar_acquire&quot;,
 633                     &quot;dmb ish&quot;,
 634                     &quot;ret&quot;
 635                 };
 636                 break;
 637             case &quot;Shenandoah&quot;:
 638             case &quot;ShenandoahTraversal&quot;:
 639                 // For volatile CAS, Shenanodoah generates normal
 640                 // graphs with a shenandoah-specific cmpxchg
 641                 matches = new String[] {
 642                     &quot;membar_release&quot;,
 643                     &quot;dmb ish&quot;,
 644                     useCompressedOops ? &quot;cmpxchgw?_shenandoah&quot; : &quot;cmpxchg_shenandoah&quot;,
 645                     &quot;membar_acquire&quot;,
 646                     &quot;dmb ish&quot;,
 647                     &quot;ret&quot;
 648                 };
 649                 break;
 650             }
 651         }
 652 
 653         checkCompile(iter, &quot;testObj&quot;, matches, output, true);
 654     }
 655 
 656     private void checkcae(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
 657     {
 658         ListIterator&lt;String&gt; iter = output.asLines().listIterator();
 659 
 660         String[] matches;
 661         String[][] tests = {
 662             { &quot;testInt&quot;, &quot;cmpxchgw&quot; },
 663             { &quot;testLong&quot;, &quot;cmpxchg&quot; },
 664             { &quot;testByte&quot;, &quot;cmpxchgb&quot; },
 665             { &quot;testShort&quot;, &quot;cmpxchgs&quot; },
 666         };
 667 
 668         for (String[] test : tests) {
 669             // non object stores are straightforward
 670             if (!useBarriersForVolatile) {
 671                 // this is the sequence of instructions for all cases
 672                 matches = new String[] {
 673                     &quot;membar_release \\(elided\\)&quot;,
 674                     test[1] + &quot;_acq&quot;,
 675                     &quot;membar_acquire \\(elided\\)&quot;,
 676                     &quot;ret&quot;
 677                 };
 678             } else {
 679                 // this is the alternative sequence of instructions
 680                 matches = new String[] {
 681                     &quot;membar_release&quot;,
 682                     &quot;dmb ish&quot;,
 683                     test[1] + &quot; &quot;,
 684                     &quot;membar_acquire&quot;,
 685                     &quot;dmb ish&quot;,
 686                     &quot;ret&quot;
 687                 };
 688             }
 689 
 690             checkCompile(iter, test[0], matches, output, true);
 691         }
 692 
 693         // object stores will be as above except for when the GC
 694         // introduces barriers for card marking
 695 
 696         if (!useBarriersForVolatile) {
 697             switch (testType) {
 698             default:
 699                 // this is the basic sequence of instructions
 700                 matches = new String[] {
 701                     &quot;membar_release \\(elided\\)&quot;,
 702                     &quot;strb&quot;,
 703                     useCompressedOops ? &quot;cmpxchgw?_acq&quot; : &quot;cmpxchg_acq&quot;,
 704                     &quot;membar_acquire \\(elided\\)&quot;,
 705                     &quot;ret&quot;
 706                 };
 707 
 708                 // card marking store may be scheduled before or after
 709                 // the cmpxchg so try both sequences.
 710                 int idx = iter.nextIndex();
 711                 if (!checkCompile(iter, &quot;testObj&quot;, matches, output, false)) {
 712                     iter = output.asLines().listIterator(idx);
 713 
 714                     matches = new String[] {
 715                         &quot;membar_release \\(elided\\)&quot;,
 716                         useCompressedOops ? &quot;cmpxchgw?_acq&quot; : &quot;cmpxchg_acq&quot;,
 717                         &quot;strb&quot;,
 718                         &quot;membar_acquire \\(elided\\)&quot;,
 719                         &quot;ret&quot;
 720                     };
 721 
 722                     checkCompile(iter, &quot;testObj&quot;, matches, output, true);
 723                 }
 724                 return;
 725 
 726             case &quot;G1&quot;:
 727                 // a card mark volatile barrier should be generated
 728                 // before the card mark strb
 729                 matches = new String[] {
 730                     &quot;membar_release \\(elided\\)&quot;,
 731                     useCompressedOops ? &quot;cmpxchgw?_acq&quot; : &quot;cmpxchg_acq&quot;,
 732                     &quot;membar_volatile&quot;,
 733                     &quot;dmb ish&quot;,
 734                     &quot;strb&quot;,
 735                     &quot;membar_acquire \\(elided\\)&quot;,
 736                     &quot;ret&quot;
 737                 };
 738                 break;
 739             case &quot;CMSCondMark&quot;:
 740                 // a card mark volatile barrier should be generated
 741                 // before the card mark strb from the StoreCM and the
 742                 // storestore barrier from the StoreCM should be elided
 743                 matches = new String[] {
 744                     &quot;membar_release \\(elided\\)&quot;,
 745                     useCompressedOops ? &quot;cmpxchgw?_acq&quot; : &quot;cmpxchg_acq&quot;,
 746                     &quot;membar_volatile&quot;,
 747                     &quot;dmb ish&quot;,
 748                     &quot;storestore \\(elided\\)&quot;,
 749                     &quot;strb&quot;,
 750                     &quot;membar_acquire \\(elided\\)&quot;,
 751                     &quot;ret&quot;
 752                 };
 753                 break;
 754             case &quot;CMS&quot;:
 755                 // a volatile card mark membar should not be generated
 756                 // before the card mark strb from the StoreCM and the
 757                 // storestore barrier from the StoreCM should be elided
 758                 matches = new String[] {
 759                     &quot;membar_release \\(elided\\)&quot;,
 760                     useCompressedOops ? &quot;cmpxchgw?_acq&quot; : &quot;cmpxchg_acq&quot;,
 761                     &quot;storestore&quot;,
 762                     &quot;dmb ishst&quot;,
 763                     &quot;strb&quot;,
 764                     &quot;membar_acquire \\(elided\\)&quot;,
 765                     &quot;ret&quot;
 766                 };
 767                 break;
 768             case &quot;Shenandoah&quot;:
 769             case &quot;ShenandoahTraversal&quot;:
 770                 // For volatile CAS, Shenanodoah generates normal
 771                 // graphs with a shenandoah-specific cmpxchg
 772                 matches = new String[] {
 773                     &quot;membar_release \\(elided\\)&quot;,
 774                     useCompressedOops ? &quot;cmpxchgw?_acq_shenandoah&quot; : &quot;cmpxchg_acq_shenandoah&quot;,
 775                     &quot;membar_acquire \\(elided\\)&quot;,
 776                     &quot;ret&quot;
 777                 };
 778                 break;
 779             }
 780         } else {
 781             switch (testType) {
 782             default:
 783                 // this is the basic sequence of instructions
 784                 matches = new String[] {
 785                     &quot;membar_release&quot;,
 786                     &quot;dmb ish&quot;,
 787                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 788                     &quot;membar_acquire&quot;,
 789                     &quot;dmb ish&quot;,
 790                     &quot;ret&quot;
 791                 };
 792                 break;
 793             case &quot;G1&quot;:
 794                 // a card mark volatile barrier should be generated
 795                 // before the card mark strb
 796                 matches = new String[] {
 797                     &quot;membar_release&quot;,
 798                     &quot;dmb ish&quot;,
 799                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 800                     &quot;membar_volatile&quot;,
 801                     &quot;dmb ish&quot;,
 802                     &quot;strb&quot;,
 803                     &quot;membar_acquire&quot;,
 804                     &quot;dmb ish&quot;,
 805                     &quot;ret&quot;
 806                 };
 807                 break;
 808             case &quot;CMSCondMark&quot;:
 809                 // a card mark volatile barrier should be generated
 810                 // before the card mark strb from the StoreCM and the
 811                 // storestore barrier from the StoreCM should be elided
 812                 matches = new String[] {
 813                     &quot;membar_release&quot;,
 814                     &quot;dmb ish&quot;,
 815                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 816                     &quot;membar_volatile&quot;,
 817                     &quot;dmb ish&quot;,
 818                     &quot;storestore \\(elided\\)&quot;,
 819                     &quot;strb&quot;,
 820                     &quot;membar_acquire&quot;,
 821                     &quot;dmb ish&quot;,
 822                     &quot;ret&quot;
 823                 };
 824                 break;
 825             case &quot;CMS&quot;:
 826                 // a volatile card mark membar should not be generated
 827                 // before the card mark strb from the StoreCM and the
 828                 // storestore barrier from the StoreCM should be generated
 829                 // as &quot;dmb ishst&quot;
 830                 matches = new String[] {
 831                     &quot;membar_release&quot;,
 832                     &quot;dmb ish&quot;,
 833                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 834                     &quot;storestore&quot;,
 835                     &quot;dmb ishst&quot;,
 836                     &quot;strb&quot;,
 837                     &quot;membar_acquire&quot;,
 838                     &quot;dmb ish&quot;,
 839                     &quot;ret&quot;
 840                 };
 841                 break;
 842             case &quot;Shenandoah&quot;:
 843             case &quot;ShenandoahTraversal&quot;:
 844                 // For volatile CAS, Shenanodoah generates normal
 845                 // graphs with a shenandoah-specific cmpxchg
 846                 matches = new String[] {
 847                     &quot;membar_release&quot;,
 848                     &quot;dmb ish&quot;,
 849                     useCompressedOops ? &quot;cmpxchgw?_shenandoah&quot; : &quot;cmpxchg_shenandoah&quot;,
 850                     &quot;membar_acquire&quot;,
 851                     &quot;dmb ish&quot;,
 852                     &quot;ret&quot;
 853                 };
 854                 break;
 855             }
 856         }
 857 
 858         checkCompile(iter, &quot;testObj&quot;, matches, output, true);
 859     }
 860 
 861     private void checkgas(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
 862     {
 863         Iterator&lt;String&gt; iter = output.asLines().listIterator();
 864 
 865         String[] matches;
 866         String[][] tests = {
 867             { &quot;testInt&quot;, &quot;atomic_xchgw&quot; },
 868             { &quot;testLong&quot;, &quot;atomic_xchg&quot; },
 869         };
 870 
 871         for (String[] test : tests) {
 872             // non object stores are straightforward
 873             if (!useBarriersForVolatile) {
 874                 // this is the sequence of instructions for all cases
 875                 matches = new String[] {
 876                     &quot;membar_release \\(elided\\)&quot;,
 877                     test[1] + &quot;_acq&quot;,
 878                     &quot;membar_acquire \\(elided\\)&quot;,
 879                     &quot;ret&quot;
 880                 };
 881             } else {
 882                 // this is the alternative sequence of instructions
 883                 matches = new String[] {
 884                     &quot;membar_release&quot;,
 885                     &quot;dmb ish&quot;,
 886                     test[1] + &quot; &quot;,
 887                     &quot;membar_acquire&quot;,
 888                     &quot;dmb ish&quot;,
 889                     &quot;ret&quot;
 890                 };
 891             }
 892 
 893             checkCompile(iter, test[0], matches, output, true);
 894         }
 895 
 896         // object stores will be as above except for when the GC
 897         // introduces barriers for card marking
 898 
 899         if (!useBarriersForVolatile) {
 900             switch (testType) {
 901             default:
 902                 // this is the basic sequence of instructions
 903                 matches = new String[] {
 904                     &quot;membar_release \\(elided\\)&quot;,
 905                     useCompressedOops ? &quot;atomic_xchgw?_acq&quot; : &quot;atomic_xchg_acq&quot;,
 906                     &quot;strb&quot;,
 907                     &quot;membar_acquire \\(elided\\)&quot;,
 908                     &quot;ret&quot;
 909                 };
 910                 break;
 911             case &quot;G1&quot;:
 912                 // a card mark volatile barrier should be generated
 913                 // before the card mark strb
 914                 matches = new String[] {
 915                     &quot;membar_release \\(elided\\)&quot;,
 916                     useCompressedOops ? &quot;atomic_xchgw?_acq&quot; : &quot;atomic_xchg_acq&quot;,
 917                     &quot;membar_volatile&quot;,
 918                     &quot;dmb ish&quot;,
 919                     &quot;strb&quot;,
 920                     &quot;membar_acquire \\(elided\\)&quot;,
 921                     &quot;ret&quot;
 922                 };
 923                 break;
 924             case &quot;CMSCondMark&quot;:
 925                 // a card mark volatile barrier should be generated
 926                 // before the card mark strb from the StoreCM and the
 927                 // storestore barrier from the StoreCM should be elided
 928                 matches = new String[] {
 929                     &quot;membar_release \\(elided\\)&quot;,
 930                     useCompressedOops ? &quot;atomic_xchgw?_acq&quot; : &quot;atomic_xchg_acq&quot;,
 931                     &quot;membar_volatile&quot;,
 932                     &quot;dmb ish&quot;,
 933                     &quot;storestore \\(elided\\)&quot;,
 934                     &quot;strb&quot;,
 935                     &quot;membar_acquire \\(elided\\)&quot;,
 936                     &quot;ret&quot;
 937                 };
 938                 break;
 939             case &quot;CMS&quot;:
 940                 // a volatile card mark membar should not be generated
 941                 // before the card mark strb from the StoreCM and the
 942                 // storestore barrier from the StoreCM should be elided
 943                 matches = new String[] {
 944                     &quot;membar_release \\(elided\\)&quot;,
 945                     useCompressedOops ? &quot;atomic_xchgw?_acq&quot; : &quot;atomic_xchg_acq&quot;,
 946                     &quot;storestore&quot;,
 947                     &quot;dmb ishst&quot;,
 948                     &quot;strb&quot;,
 949                     &quot;membar_acquire \\(elided\\)&quot;,
 950                     &quot;ret&quot;
 951                 };
 952                 break;
 953             case &quot;Shenandoah&quot;:
 954             case &quot;ShenandoahTraversal&quot;:
 955                 matches = new String[] {
 956                     &quot;membar_release \\(elided\\)&quot;,
 957                     useCompressedOops ? &quot;atomic_xchgw?_acq&quot; : &quot;atomic_xchg_acq&quot;,
 958                     &quot;membar_acquire \\(elided\\)&quot;,
 959                     &quot;ret&quot;
 960                 };
 961                 break;
 962             }
 963         } else {
 964             switch (testType) {
 965             default:
 966                 // this is the basic sequence of instructions
 967                 matches = new String[] {
 968                     &quot;membar_release&quot;,
 969                     &quot;dmb ish&quot;,
 970                     useCompressedOops ? &quot;atomic_xchgw? &quot; : &quot;atomic_xchg &quot;,
 971                     &quot;membar_acquire&quot;,
 972                     &quot;dmb ish&quot;,
 973                     &quot;ret&quot;
 974                 };
 975                 break;
 976             case &quot;G1&quot;:
 977                 // a card mark volatile barrier should be generated
 978                 // before the card mark strb
 979                 matches = new String[] {
 980                     &quot;membar_release&quot;,
 981                     &quot;dmb ish&quot;,
 982                     useCompressedOops ? &quot;atomic_xchgw? &quot; : &quot;atomic_xchg &quot;,
 983                     &quot;membar_volatile&quot;,
 984                     &quot;dmb ish&quot;,
 985                     &quot;strb&quot;,
 986                     &quot;membar_acquire&quot;,
 987                     &quot;dmb ish&quot;,
 988                     &quot;ret&quot;
 989                 };
 990                 break;
 991             case &quot;CMSCondMark&quot;:
 992                 // a card mark volatile barrier should be generated
 993                 // before the card mark strb from the StoreCM and the
 994                 // storestore barrier from the StoreCM should be elided
 995                 matches = new String[] {
 996                     &quot;membar_release&quot;,
 997                     &quot;dmb ish&quot;,
 998                     useCompressedOops ? &quot;atomic_xchgw? &quot; : &quot;atomic_xchg &quot;,
 999                     &quot;membar_volatile&quot;,
1000                     &quot;dmb ish&quot;,
1001                     &quot;storestore \\(elided\\)&quot;,
1002                     &quot;strb&quot;,
1003                     &quot;membar_acquire&quot;,
1004                     &quot;dmb ish&quot;,
1005                     &quot;ret&quot;
1006                 };
1007                 break;
1008             case &quot;CMS&quot;:
1009                 // a volatile card mark membar should not be generated
1010                 // before the card mark strb from the StoreCM and the
1011                 // storestore barrier from the StoreCM should be generated
1012                 // as &quot;dmb ishst&quot;
1013                 matches = new String[] {
1014                     &quot;membar_release&quot;,
1015                     &quot;dmb ish&quot;,
1016                     useCompressedOops ? &quot;atomic_xchgw? &quot; : &quot;atomic_xchg &quot;,
1017                     &quot;storestore&quot;,
1018                     &quot;dmb ishst&quot;,
1019                     &quot;strb&quot;,
1020                     &quot;membar_acquire&quot;,
1021                     &quot;dmb ish&quot;,
1022                     &quot;ret&quot;
1023                 };
1024                 break;
1025             case &quot;Shenandoah&quot;:
1026             case &quot;ShenandoahTraversal&quot;:
1027                 matches = new String[] {
1028                     &quot;membar_release&quot;,
1029                     &quot;dmb ish&quot;,
1030                     useCompressedOops ? &quot;atomic_xchgw? &quot; : &quot;atomic_xchg &quot;,
1031                     &quot;membar_acquire&quot;,
1032                     &quot;dmb ish&quot;,
1033                     &quot;ret&quot;
1034                 };
1035                 break;
1036             }
1037         }
1038 
1039         checkCompile(iter, &quot;testObj&quot;, matches, output, true);
1040     }
1041 
1042     private void checkgaa(OutputAnalyzer output, String testType, boolean useBarriersForVolatile) throws Throwable
1043     {
1044         Iterator&lt;String&gt; iter = output.asLines().listIterator();
1045 
1046         String[] matches;
1047         String[][] tests = {
1048             { &quot;testInt&quot;, &quot;get_and_addI&quot; },
1049             { &quot;testLong&quot;, &quot;get_and_addL&quot; },
1050         };
1051 
1052         for (String[] test : tests) {
1053             // non object stores are straightforward
1054             if (!useBarriersForVolatile) {
1055                 // this is the sequence of instructions for all cases
1056                 matches = new String[] {
1057                     &quot;membar_release \\(elided\\)&quot;,
1058                     test[1] + &quot;_acq&quot;,
1059                     &quot;membar_acquire \\(elided\\)&quot;,
1060                     &quot;ret&quot;
1061                 };
1062             } else {
1063                 // this is the alternative sequence of instructions
1064                 matches = new String[] {
1065                     &quot;membar_release&quot;,
1066                     &quot;dmb ish&quot;,
1067                     test[1] + &quot; &quot;,
1068                     &quot;membar_acquire&quot;,
1069                     &quot;dmb ish&quot;,
1070                     &quot;ret&quot;
1071                 };
1072             }
1073 
1074             checkCompile(iter, test[0], matches, output, true);
1075         }
1076 
1077     }
1078 
1079     // perform a check appropriate to the classname
1080 
1081     private void checkoutput(OutputAnalyzer output, String classname, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
1082     {
1083         // trace call to allow eyeball check of what is being checked
1084         System.out.println(&quot;checkoutput(&quot; +
1085                            classname + &quot;, &quot; +
1086                            testType + &quot;, &quot; +
1087                            useBarriersForVolatile + &quot;)\n&quot; +
1088                            output.getOutput());
1089 
1090         switch (classname) {
1091         case &quot;TestVolatileLoad&quot;:
1092             checkload(output, testType, useBarriersForVolatile, useCompressedOops);
1093             break;
1094         case &quot;TestVolatileStore&quot;:
1095             checkstore(output, testType, useBarriersForVolatile, useCompressedOops);
1096             break;
1097         case &quot;TestUnsafeVolatileLoad&quot;:
1098             checkload(output, testType, useBarriersForVolatile, useCompressedOops);
1099             break;
1100         case &quot;TestUnsafeVolatileStore&quot;:
1101             checkstore(output, testType, useBarriersForVolatile, useCompressedOops);
1102             break;
1103         case &quot;TestUnsafeVolatileCAS&quot;:
1104         case &quot;TestUnsafeVolatileWeakCAS&quot;:
1105             checkcas(output, testType, useBarriersForVolatile, useCompressedOops);
1106             break;
1107         case &quot;TestUnsafeVolatileCAE&quot;:
1108             checkcae(output, testType, useBarriersForVolatile, useCompressedOops);
1109             break;
1110         case &quot;TestUnsafeVolatileGAS&quot;:
1111             checkgas(output, testType, useBarriersForVolatile, useCompressedOops);
1112             break;
1113         case &quot;TestUnsafeVolatileGAA&quot;:
1114             checkgaa(output, testType, useBarriersForVolatile);
1115             break;
1116         }
1117     }
1118 }
    </pre>
  </body>
</html>
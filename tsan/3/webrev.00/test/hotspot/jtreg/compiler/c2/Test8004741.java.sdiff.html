<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/c2/Test8004741.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="Test6857159.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="aarch64/TestVolatiles.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/c2/Test8004741.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
<span class="line-modified"> 25  * @test Test8004741.java</span>
 26  * @bug 8004741
 27  * @summary Missing compiled exception handle table entry for multidimensional array allocation
 28  *
 29  * @requires !vm.graal.enabled






 30  * @run main/othervm -Xmx128m -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
 31  *    -XX:-TieredCompilation -XX:+StressCompiledExceptionHandlers
 32  *    -XX:+SafepointALot -XX:GuaranteedSafepointInterval=100

 33  *    compiler.c2.Test8004741

 34  * @run main/othervm -Xmx128m -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
 35  *    -XX:-TieredCompilation -XX:+StressCompiledExceptionHandlers

 36  *    compiler.c2.Test8004741
 37  */
 38 
 39 package compiler.c2;
 40 


 41 public class Test8004741 extends Thread {
 42 
 43   static int passed = 0;
 44 
 45   /**
 46    * Loop forever allocating 2-d arrays.
 47    * Catches and rethrows all exceptions; in the case of ThreadDeath, increments passed.
 48    * Note that passed is incremented here because this is the exception handler with
 49    * the smallest scope; we only want to declare success in the case where it is highly
 50    * likely that the test condition
 51    * (exception in 2-d array alloc interrupted by ThreadDeath)
 52    * actually occurs.
 53    */
 54   static int[][] test(int a, int b) throws Exception {
 55     int[][] ar;
 56     try {
 57       ar = new int[a][b];
 58     } catch (ThreadDeath e) {
 59       System.out.println(&quot;test got ThreadDeath&quot;);
 60       passed++;
<span class="line-modified"> 61       throw(e);</span>
 62     }
 63     return ar;
 64   }
 65 
 66   /* Cookbook wait-notify to track progress of test thread. */
 67   Object progressLock = new Object();
 68   private static final int NOT_STARTED = 0;
 69   private static final int RUNNING = 1;
 70   private static final int STOPPING = 2;
 71 
 72   int progressState = NOT_STARTED;
 73 
 74   void toState(int state) {
 75     synchronized (progressLock) {
 76       progressState = state;
 77       progressLock.notify();
 78     }
 79   }
 80 
 81   void waitFor(int state) {
 82     synchronized (progressLock) {
 83       while (progressState &lt; state) {
 84         try {
 85           progressLock.wait();
 86         } catch (InterruptedException e) {
<span class="line-modified"> 87           e.printStackTrace();</span>
<span class="line-removed"> 88           System.out.println(&quot;unexpected InterruptedException&quot;);</span>
<span class="line-removed"> 89           fail();</span>
 90         }
 91       }
 92       if (progressState &gt; state) {
<span class="line-modified"> 93         System.out.println(&quot;unexpected test state change, expected &quot; +</span>
<span class="line-removed"> 94                             state + &quot; but saw &quot; + progressState);</span>
<span class="line-removed"> 95         fail();</span>
 96       }
 97     }
 98   }
 99 
100   /**
101    * Loops running test until some sort of an exception or error,
102    * expects to see ThreadDeath.
103    */
104   public void run() {
105     try {
106       // Print before state change, so that other thread is most likely
107       // to see this thread executing calls to test() in a loop.
108       System.out.println(&quot;thread running&quot;);
109       toState(RUNNING);
110       while (true) {
111         // (2,2) (2,10) (2,100) were observed to tickle the bug;
112         test(2, 100);
113       }
114     } catch (ThreadDeath e) {
115       // nothing to say, passing was incremented by the test.
116     } catch (Throwable e) {
<span class="line-modified">117       e.printStackTrace();</span>
<span class="line-removed">118       System.out.println(&quot;unexpected Throwable &quot; + e);</span>
<span class="line-removed">119       fail();</span>
120     }
121     toState(STOPPING);
122   }
123 
124   /**
125    * Runs a single trial of the test in a thread.
126    * No single trial is definitive, since the ThreadDeath
127    * exception might not land in the tested region of code.
128    */
129   public static void threadTest() throws InterruptedException {
130     Test8004741 t = new Test8004741();
131     t.start();
132     t.waitFor(RUNNING);
133     Thread.sleep(100);
134     System.out.println(&quot;stopping thread&quot;);
135     t.stop();
136     t.waitFor(STOPPING);
137     t.join();
138   }
139 
140   public static void main(String[] args) throws Exception {
141     // Warm up &quot;test&quot;
142     // t will never be started.
143     for (int n = 0; n &lt; 11000; n++) {
144       test(2, 100);
145     }
146 
<span class="line-modified">147     // Will this sleep help ensure that the compiler is run?</span>
<span class="line-modified">148     Thread.sleep(500);</span>
<span class="line-modified">149     passed = 0;</span>

150 
151     try {
152       test(-1, 100);
<span class="line-modified">153       System.out.println(&quot;Missing NegativeArraySizeException #1&quot;);</span>
<span class="line-modified">154       fail();</span>
<span class="line-removed">155     } catch ( java.lang.NegativeArraySizeException e ) {</span>
156       System.out.println(&quot;Saw expected NegativeArraySizeException #1&quot;);
157     }
158 
159     try {
160       test(100, -1);
<span class="line-modified">161       fail();</span>
<span class="line-modified">162       System.out.println(&quot;Missing NegativeArraySizeException #2&quot;);</span>
<span class="line-removed">163       fail();</span>
<span class="line-removed">164     } catch ( java.lang.NegativeArraySizeException e ) {</span>
165       System.out.println(&quot;Saw expected NegativeArraySizeException #2&quot;);
166     }
167 
168     /* Test repetitions.  If the test succeeds-mostly, it succeeds,
169      * as long as it does not crash (the outcome if the exception range
170      * table entry for the array allocation is missing).
171      */
<span class="line-modified">172     int N = 12;</span>
<span class="line-modified">173     for (int n = 0; n &lt; N; n++) {</span>

174       threadTest();
175     }
<span class="line-removed">176 </span>
<span class="line-removed">177     if (passed &gt; N/2) {</span>
<span class="line-removed">178       System.out.println(&quot;Saw &quot; + passed + &quot; out of &quot; + N + &quot; possible ThreadDeath hits&quot;);</span>
<span class="line-removed">179       System.out.println(&quot;PASSED&quot;);</span>
<span class="line-removed">180     } else {</span>
<span class="line-removed">181       System.out.println(&quot;Too few ThreadDeath hits; expected at least &quot; + N/2 +</span>
<span class="line-removed">182                          &quot; but saw only &quot; + passed);</span>
<span class="line-removed">183       fail();</span>
<span class="line-removed">184     }</span>
<span class="line-removed">185   }</span>
<span class="line-removed">186 </span>
<span class="line-removed">187   static void fail() {</span>
<span class="line-removed">188     System.out.println(&quot;FAILED&quot;);</span>
<span class="line-removed">189     System.exit(97);</span>
190   }
<span class="line-modified">191 };</span>
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
<span class="line-modified"> 25  * @test</span>
 26  * @bug 8004741
 27  * @summary Missing compiled exception handle table entry for multidimensional array allocation
 28  *
 29  * @requires !vm.graal.enabled
<span class="line-added"> 30  * @library /test/lib</span>
<span class="line-added"> 31  *</span>
<span class="line-added"> 32  * @build sun.hotspot.WhiteBox</span>
<span class="line-added"> 33  * @run driver ClassFileInstaller sun.hotspot.WhiteBox</span>
<span class="line-added"> 34  *                                sun.hotspot.WhiteBox$WhiteBoxPermission</span>
<span class="line-added"> 35  *</span>
 36  * @run main/othervm -Xmx128m -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
 37  *    -XX:-TieredCompilation -XX:+StressCompiledExceptionHandlers
 38  *    -XX:+SafepointALot -XX:GuaranteedSafepointInterval=100
<span class="line-added"> 39  *    -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI</span>
 40  *    compiler.c2.Test8004741
<span class="line-added"> 41  *</span>
 42  * @run main/othervm -Xmx128m -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
 43  *    -XX:-TieredCompilation -XX:+StressCompiledExceptionHandlers
<span class="line-added"> 44  *    -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI</span>
 45  *    compiler.c2.Test8004741
 46  */
 47 
 48 package compiler.c2;
 49 
<span class="line-added"> 50 import sun.hotspot.WhiteBox;</span>
<span class="line-added"> 51 </span>
 52 public class Test8004741 extends Thread {
 53 
 54   static int passed = 0;
 55 
 56   /**
 57    * Loop forever allocating 2-d arrays.
 58    * Catches and rethrows all exceptions; in the case of ThreadDeath, increments passed.
 59    * Note that passed is incremented here because this is the exception handler with
 60    * the smallest scope; we only want to declare success in the case where it is highly
 61    * likely that the test condition
 62    * (exception in 2-d array alloc interrupted by ThreadDeath)
 63    * actually occurs.
 64    */
 65   static int[][] test(int a, int b) throws Exception {
 66     int[][] ar;
 67     try {
 68       ar = new int[a][b];
 69     } catch (ThreadDeath e) {
 70       System.out.println(&quot;test got ThreadDeath&quot;);
 71       passed++;
<span class="line-modified"> 72       throw e;</span>
 73     }
 74     return ar;
 75   }
 76 
 77   /* Cookbook wait-notify to track progress of test thread. */
 78   Object progressLock = new Object();
 79   private static final int NOT_STARTED = 0;
 80   private static final int RUNNING = 1;
 81   private static final int STOPPING = 2;
 82 
 83   int progressState = NOT_STARTED;
 84 
 85   void toState(int state) {
 86     synchronized (progressLock) {
 87       progressState = state;
 88       progressLock.notify();
 89     }
 90   }
 91 
 92   void waitFor(int state) {
 93     synchronized (progressLock) {
 94       while (progressState &lt; state) {
 95         try {
 96           progressLock.wait();
 97         } catch (InterruptedException e) {
<span class="line-modified"> 98           throw new Error(&quot;unexpected InterruptedException&quot;, e);</span>


 99         }
100       }
101       if (progressState &gt; state) {
<span class="line-modified">102         throw new Error(&quot;unexpected test state change, state = &quot; + state + &quot;, progressState = &quot; + progressState);</span>


103       }
104     }
105   }
106 
107   /**
108    * Loops running test until some sort of an exception or error,
109    * expects to see ThreadDeath.
110    */
111   public void run() {
112     try {
113       // Print before state change, so that other thread is most likely
114       // to see this thread executing calls to test() in a loop.
115       System.out.println(&quot;thread running&quot;);
116       toState(RUNNING);
117       while (true) {
118         // (2,2) (2,10) (2,100) were observed to tickle the bug;
119         test(2, 100);
120       }
121     } catch (ThreadDeath e) {
122       // nothing to say, passing was incremented by the test.
123     } catch (Throwable e) {
<span class="line-modified">124       throw new Error(&quot;unexpected Throwable &quot; + e, e);</span>


125     }
126     toState(STOPPING);
127   }
128 
129   /**
130    * Runs a single trial of the test in a thread.
131    * No single trial is definitive, since the ThreadDeath
132    * exception might not land in the tested region of code.
133    */
134   public static void threadTest() throws InterruptedException {
135     Test8004741 t = new Test8004741();
136     t.start();
137     t.waitFor(RUNNING);
138     Thread.sleep(100);
139     System.out.println(&quot;stopping thread&quot;);
140     t.stop();
141     t.waitFor(STOPPING);
142     t.join();
143   }
144 
145   public static void main(String[] args) throws Exception {
146     // Warm up &quot;test&quot;
147     // t will never be started.
148     for (int n = 0; n &lt; 11000; n++) {
149       test(2, 100);
150     }
151 
<span class="line-modified">152     var method = Test8004741.class.getDeclaredMethod(&quot;test&quot;, int.class, int.class);</span>
<span class="line-modified">153     if (!WhiteBox.getWhiteBox().isMethodCompiled(method)) {</span>
<span class="line-modified">154         throw new Error(&quot;test method didn&#39;t get compiled&quot;);</span>
<span class="line-added">155     }</span>
156 
157     try {
158       test(-1, 100);
<span class="line-modified">159       throw new AssertionError(&quot;Missing NegativeArraySizeException&quot;);</span>
<span class="line-modified">160     } catch (NegativeArraySizeException e) {</span>

161       System.out.println(&quot;Saw expected NegativeArraySizeException #1&quot;);
162     }
163 
164     try {
165       test(100, -1);
<span class="line-modified">166       throw new AssertionError(&quot;Missing NegativeArraySizeException&quot;);</span>
<span class="line-modified">167     } catch (NegativeArraySizeException e) {</span>


168       System.out.println(&quot;Saw expected NegativeArraySizeException #2&quot;);
169     }
170 
171     /* Test repetitions.  If the test succeeds-mostly, it succeeds,
172      * as long as it does not crash (the outcome if the exception range
173      * table entry for the array allocation is missing).
174      */
<span class="line-modified">175     passed = 0;</span>
<span class="line-modified">176     int limit = 6;</span>
<span class="line-added">177     while (passed != limit) {</span>
178       threadTest();
179     }














180   }
<span class="line-modified">181 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="Test6857159.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="aarch64/TestVolatiles.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
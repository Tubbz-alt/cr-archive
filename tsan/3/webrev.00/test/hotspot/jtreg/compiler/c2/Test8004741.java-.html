<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/compiler/c2/Test8004741.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test Test8004741.java
 26  * @bug 8004741
 27  * @summary Missing compiled exception handle table entry for multidimensional array allocation
 28  *
 29  * @requires !vm.graal.enabled
 30  * @run main/othervm -Xmx128m -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
 31  *    -XX:-TieredCompilation -XX:+StressCompiledExceptionHandlers
 32  *    -XX:+SafepointALot -XX:GuaranteedSafepointInterval=100
 33  *    compiler.c2.Test8004741
 34  * @run main/othervm -Xmx128m -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
 35  *    -XX:-TieredCompilation -XX:+StressCompiledExceptionHandlers
 36  *    compiler.c2.Test8004741
 37  */
 38 
 39 package compiler.c2;
 40 
 41 public class Test8004741 extends Thread {
 42 
 43   static int passed = 0;
 44 
 45   /**
 46    * Loop forever allocating 2-d arrays.
 47    * Catches and rethrows all exceptions; in the case of ThreadDeath, increments passed.
 48    * Note that passed is incremented here because this is the exception handler with
 49    * the smallest scope; we only want to declare success in the case where it is highly
 50    * likely that the test condition
 51    * (exception in 2-d array alloc interrupted by ThreadDeath)
 52    * actually occurs.
 53    */
 54   static int[][] test(int a, int b) throws Exception {
 55     int[][] ar;
 56     try {
 57       ar = new int[a][b];
 58     } catch (ThreadDeath e) {
 59       System.out.println(&quot;test got ThreadDeath&quot;);
 60       passed++;
 61       throw(e);
 62     }
 63     return ar;
 64   }
 65 
 66   /* Cookbook wait-notify to track progress of test thread. */
 67   Object progressLock = new Object();
 68   private static final int NOT_STARTED = 0;
 69   private static final int RUNNING = 1;
 70   private static final int STOPPING = 2;
 71 
 72   int progressState = NOT_STARTED;
 73 
 74   void toState(int state) {
 75     synchronized (progressLock) {
 76       progressState = state;
 77       progressLock.notify();
 78     }
 79   }
 80 
 81   void waitFor(int state) {
 82     synchronized (progressLock) {
 83       while (progressState &lt; state) {
 84         try {
 85           progressLock.wait();
 86         } catch (InterruptedException e) {
 87           e.printStackTrace();
 88           System.out.println(&quot;unexpected InterruptedException&quot;);
 89           fail();
 90         }
 91       }
 92       if (progressState &gt; state) {
 93         System.out.println(&quot;unexpected test state change, expected &quot; +
 94                             state + &quot; but saw &quot; + progressState);
 95         fail();
 96       }
 97     }
 98   }
 99 
100   /**
101    * Loops running test until some sort of an exception or error,
102    * expects to see ThreadDeath.
103    */
104   public void run() {
105     try {
106       // Print before state change, so that other thread is most likely
107       // to see this thread executing calls to test() in a loop.
108       System.out.println(&quot;thread running&quot;);
109       toState(RUNNING);
110       while (true) {
111         // (2,2) (2,10) (2,100) were observed to tickle the bug;
112         test(2, 100);
113       }
114     } catch (ThreadDeath e) {
115       // nothing to say, passing was incremented by the test.
116     } catch (Throwable e) {
117       e.printStackTrace();
118       System.out.println(&quot;unexpected Throwable &quot; + e);
119       fail();
120     }
121     toState(STOPPING);
122   }
123 
124   /**
125    * Runs a single trial of the test in a thread.
126    * No single trial is definitive, since the ThreadDeath
127    * exception might not land in the tested region of code.
128    */
129   public static void threadTest() throws InterruptedException {
130     Test8004741 t = new Test8004741();
131     t.start();
132     t.waitFor(RUNNING);
133     Thread.sleep(100);
134     System.out.println(&quot;stopping thread&quot;);
135     t.stop();
136     t.waitFor(STOPPING);
137     t.join();
138   }
139 
140   public static void main(String[] args) throws Exception {
141     // Warm up &quot;test&quot;
142     // t will never be started.
143     for (int n = 0; n &lt; 11000; n++) {
144       test(2, 100);
145     }
146 
147     // Will this sleep help ensure that the compiler is run?
148     Thread.sleep(500);
149     passed = 0;
150 
151     try {
152       test(-1, 100);
153       System.out.println(&quot;Missing NegativeArraySizeException #1&quot;);
154       fail();
155     } catch ( java.lang.NegativeArraySizeException e ) {
156       System.out.println(&quot;Saw expected NegativeArraySizeException #1&quot;);
157     }
158 
159     try {
160       test(100, -1);
161       fail();
162       System.out.println(&quot;Missing NegativeArraySizeException #2&quot;);
163       fail();
164     } catch ( java.lang.NegativeArraySizeException e ) {
165       System.out.println(&quot;Saw expected NegativeArraySizeException #2&quot;);
166     }
167 
168     /* Test repetitions.  If the test succeeds-mostly, it succeeds,
169      * as long as it does not crash (the outcome if the exception range
170      * table entry for the array allocation is missing).
171      */
172     int N = 12;
173     for (int n = 0; n &lt; N; n++) {
174       threadTest();
175     }
176 
177     if (passed &gt; N/2) {
178       System.out.println(&quot;Saw &quot; + passed + &quot; out of &quot; + N + &quot; possible ThreadDeath hits&quot;);
179       System.out.println(&quot;PASSED&quot;);
180     } else {
181       System.out.println(&quot;Too few ThreadDeath hits; expected at least &quot; + N/2 +
182                          &quot; but saw only &quot; + passed);
183       fail();
184     }
185   }
186 
187   static void fail() {
188     System.out.println(&quot;FAILED&quot;);
189     System.exit(97);
190   }
191 };
    </pre>
  </body>
</html>
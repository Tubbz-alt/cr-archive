<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/c2/aarch64/TestVolatiles.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * common code to run and validate tests of code generation for
  26  * volatile ops on AArch64
  27  *
  28  * incoming args are &lt;testclass&gt; &lt;testtype&gt;
  29  *
  30  * where &lt;testclass&gt; in {TestVolatileLoad,
  31  *                       TestVolatileStore,
  32  *                       TestUnsafeVolatileLoad,
  33  *                       TestUnsafeVolatileStore,
  34  *                       TestUnsafeVolatileCAS,
  35  *                       TestUnsafeVolatileWeakCAS,
  36  *                       TestUnsafeVolatileCAE,
  37  *                       TestUnsafeVolatileGAS}
  38  * and &lt;testtype&gt; in {G1,
  39  *                    Serial,
  40  *                    Parallel,
  41  *                    Shenandoah,
  42  *                    ShenandoahTraversal}
  43  */
  44 
  45 
  46 package compiler.c2.aarch64;
  47 
  48 import java.util.List;
  49 import java.util.ListIterator;
  50 import java.util.Iterator;
  51 import java.util.regex.Pattern;
  52 import java.io.*;
  53 
  54 import jdk.test.lib.Asserts;
  55 import jdk.test.lib.compiler.InMemoryJavaCompiler;
  56 import jdk.test.lib.process.OutputAnalyzer;
  57 import jdk.test.lib.process.ProcessTools;
  58 import sun.hotspot.WhiteBox;
  59 
  60 // runner class that spawns a new JVM to exercises a combination of
  61 // volatile MemOp and GC. The ops are compiled with the dmb --&gt;
  62 // ldar/stlr transforms either enabled or disabled. this runner parses
  63 // the PrintOptoAssembly output checking that the generated code is
  64 // correct.
  65 
  66 public class TestVolatiles {
  67     public void runtest(String classname, String testType) throws Throwable {
  68         // n.b. clients omit the package name for the class
  69         String fullclassname = &quot;compiler.c2.aarch64.&quot; + classname;
  70         // build up a command line for the spawned JVM
  71         String[] procArgs;
  72         int argcount;
  73         // add one or two extra arguments according to test type
  74         // i.e. GC type plus GC conifg
  75         switch(testType) {
  76         case &quot;G1&quot;:
  77             argcount = 9;
  78             procArgs = new String[argcount];
  79             procArgs[argcount - 2] = &quot;-XX:+UseG1GC&quot;;
  80             break;
  81         case &quot;Parallel&quot;:
  82             argcount = 9;
  83             procArgs = new String[argcount];
  84             procArgs[argcount - 2] = &quot;-XX:+UseParallelGC&quot;;
  85             break;
  86         case &quot;Serial&quot;:
  87             argcount = 9;
  88             procArgs = new String[argcount];
  89             procArgs[argcount - 2] = &quot;-XX:+UseSerialGC&quot;;
  90             break;
  91         case &quot;Shenandoah&quot;:
  92             argcount = 10;
  93             procArgs = new String[argcount];
  94             procArgs[argcount - 3] = &quot;-XX:+UnlockExperimentalVMOptions&quot;;
  95             procArgs[argcount - 2] = &quot;-XX:+UseShenandoahGC&quot;;
  96             break;
  97         case &quot;ShenandoahTraversal&quot;:
  98             argcount = 11;
  99             procArgs = new String[argcount];
 100             procArgs[argcount - 4] = &quot;-XX:+UnlockExperimentalVMOptions&quot;;
 101             procArgs[argcount - 3] = &quot;-XX:+UseShenandoahGC&quot;;
 102             procArgs[argcount - 2] = &quot;-XX:ShenandoahGCMode=traversal&quot;;
 103             break;
 104         default:
 105             throw new RuntimeException(&quot;unexpected test type &quot; + testType);
 106         }
 107 
 108         // fill in arguments common to all cases
 109 
 110         // the first round of test enables transform of barriers to
 111         // use acquiring loads and releasing stores by setting arg
 112         // zero appropriately. this arg is reset in the second run to
 113         // disable the transform.
 114 
 115         procArgs[0] = &quot;-XX:-UseBarriersForVolatile&quot;;
 116         procArgs[1] = &quot;-XX:+UseCompressedOops&quot;;
 117 
 118         procArgs[2] = &quot;-XX:-TieredCompilation&quot;;
 119         procArgs[3] = &quot;-XX:+PrintOptoAssembly&quot;;
 120         procArgs[4] = &quot;-XX:CompileCommand=compileonly,&quot; + fullclassname + &quot;::&quot; + &quot;test*&quot;;
 121         procArgs[5] = &quot;--add-exports&quot;;
 122         procArgs[6] = &quot;java.base/jdk.internal.misc=ALL-UNNAMED&quot;;
 123         procArgs[argcount - 1] = fullclassname;
 124 
 125         runtest(classname, testType, false, true, procArgs);
 126         // rerun the test class without the transform applied and
 127         // check the alternative generation is as expected
 128 
 129         procArgs[0] = &quot;-XX:+UseBarriersForVolatile&quot;;
 130         runtest(classname, testType, true, true, procArgs);
 131 
 132         if (!classname.equals(&quot;TestUnsafeVolatileGAA&quot;)) {
 133             procArgs[0] = &quot;-XX:-UseBarriersForVolatile&quot;;
 134             procArgs[1] = &quot;-XX:-UseCompressedOops&quot;;
 135             runtest(classname, testType, false, false, procArgs);
 136 
 137             procArgs[0] = &quot;-XX:+UseBarriersForVolatile&quot;;
 138             runtest(classname, testType, true, false, procArgs);
 139         }
 140     }
 141 
 142 
 143     public void runtest(String classname, String testType, boolean useBarriersForVolatile, boolean useCompressedOops, String[] procArgs) throws Throwable {
 144         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(procArgs);
 145         OutputAnalyzer output = new OutputAnalyzer(pb.start());
 146 
 147         output.stderrShouldBeEmptyIgnoreVMWarnings();
 148         output.stdoutShouldNotBeEmpty();
 149         output.shouldHaveExitValue(0);
 150 
 151         // check the output for the correct asm sequence as
 152         // appropriate to test class, test type and whether transform
 153         // was applied
 154 
 155         checkoutput(output, classname, testType, useBarriersForVolatile, useCompressedOops);
 156     }
 157 
 158     // skip through output returning a line containing the desireed
 159     // substring or null
 160     private String skipTo(Iterator&lt;String&gt; iter, String substring)
 161     {
 162         while (iter.hasNext()) {
 163             String nextLine = iter.next();
 164             if (nextLine.matches(&quot;.*&quot; + substring + &quot;.*&quot;)) {
 165                 return nextLine;
 166             }
 167         }
 168         return null;
 169     }
 170 
 171     // locate the start of compiler output for the desired method and
 172     // then check that each expected instruction occurs in the output
 173     // in the order supplied. throw an excpetion if not found.
 174     // n.b. the spawned JVM&#39;s output is included in the exception
 175     // message to make it easeir to identify what is missing.
 176 
 177     private boolean checkCompile(Iterator&lt;String&gt; iter, String methodname, String[] expected, OutputAnalyzer output, boolean do_throw)
 178     {
 179         // trace call to allow eyeball check of what we are checking against
 180         System.out.println(&quot;checkCompile(&quot; + methodname + &quot;,&quot;);
 181         String sepr = &quot;  { &quot;;
 182         for (String s : expected) {
 183             System.out.print(sepr);
 184             System.out.print(s);
 185             sepr = &quot;,\n    &quot;;
 186         }
 187         System.out.println(&quot; })&quot;);
 188 
 189         // look for the start of an opto assembly print block
 190         String match = skipTo(iter, Pattern.quote(&quot;{method}&quot;));
 191         if (match == null) {
 192             if (do_throw) {
 193                 throw new RuntimeException(&quot;Missing compiler output for &quot; + methodname + &quot;!\n\n&quot; + output.getOutput());
 194             }
 195             return false;
 196         }
 197         // check the compiled method name is right
 198         match = skipTo(iter, Pattern.quote(&quot;- name:&quot;));
 199         if (match == null) {
 200             if (do_throw) {
 201                 throw new RuntimeException(&quot;Missing compiled method name!\n\n&quot; + output.getOutput());
 202             }
 203             return false;
 204         }
 205         if (!match.contains(methodname)) {
 206             if (do_throw) {
 207                 throw new RuntimeException(&quot;Wrong method &quot; + match + &quot;!\n  -- expecting &quot; + methodname + &quot;\n\n&quot; + output.getOutput());
 208             }
 209             return false;
 210         }
 211         // make sure we can match each expected term in order
 212         for (String s : expected) {
 213             match = skipTo(iter, s);
 214             if (match == null) {
 215                 if (do_throw) {
 216                     throw new RuntimeException(&quot;Missing expected output &quot; + s + &quot;!\n\n&quot; + output.getOutput());
 217                 }
 218                 return false;
 219             }
 220         }
 221         return true;
 222     }
 223 
 224     // check for expected asm output from a volatile load
 225 
 226     private void checkload(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
 227     {
 228         Iterator&lt;String&gt; iter = output.asLines().listIterator();
 229 
 230         // we shoud see this same sequence for normal or unsafe volatile load
 231         // for both int and Object fields
 232 
 233         String[] matches;
 234 
 235         if (!useBarriersForVolatile) {
 236             matches = new String[] {
 237                 &quot;ldarw&quot;,
 238                 &quot;membar_acquire \\(elided\\)&quot;,
 239                 &quot;ret&quot;
 240             };
 241         } else {
 242             matches = new String[] {
 243                 &quot;ldrw&quot;,
 244                 &quot;membar_acquire&quot;,
 245                 &quot;dmb ish&quot;,
 246                 &quot;ret&quot;
 247             };
 248         }
 249 
 250         checkCompile(iter, &quot;testInt&quot;, matches, output, true);
 251 
 252         if (!useBarriersForVolatile) {
 253             matches = new String[] {
 254                 useCompressedOops ? &quot;ldarw?&quot; : &quot;ldar&quot;,
 255                 &quot;membar_acquire \\(elided\\)&quot;,
 256                 &quot;ret&quot;
 257             };
 258         } else {
 259             matches = new String[] {
 260                 useCompressedOops ? &quot;ldrw?&quot; : &quot;ldr&quot;,
 261                 &quot;membar_acquire&quot;,
 262                 &quot;dmb ish&quot;,
 263                 &quot;ret&quot;
 264             };
 265         }
 266 
 267         checkCompile(iter, &quot;testObj&quot;, matches, output, true);
 268 
 269     }
 270 
 271     // check for expected asm output from a volatile store
 272 
 273     private void checkstore(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
 274     {
 275         Iterator&lt;String&gt; iter = output.asLines().listIterator();
 276 
 277         String[] matches;
 278 
 279         // non object stores are straightforward
 280         if (!useBarriersForVolatile) {
 281             // this is the sequence of instructions for all cases
 282             matches = new String[] {
 283                 &quot;membar_release \\(elided\\)&quot;,
 284                 &quot;stlrw&quot;,
 285                 &quot;membar_volatile \\(elided\\)&quot;,
 286                 &quot;ret&quot;
 287             };
 288         } else {
 289             // this is the alternative sequence of instructions
 290             matches = new String[] {
 291                 &quot;membar_release&quot;,
 292                 &quot;dmb ish&quot;,
 293                 &quot;strw&quot;,
 294                 &quot;membar_volatile&quot;,
 295                 &quot;dmb ish&quot;,
 296                 &quot;ret&quot;
 297             };
 298         }
 299 
 300         checkCompile(iter, &quot;testInt&quot;, matches, output, true);
 301 
 302         // object stores will be as above except for when the GC
 303         // introduces barriers for card marking
 304 
 305         if (!useBarriersForVolatile) {
 306             switch (testType) {
 307             default:
 308                 // this is the basic sequence of instructions
 309                 matches = new String[] {
 310                     &quot;membar_release \\(elided\\)&quot;,
 311                     useCompressedOops ? &quot;stlrw?&quot; : &quot;stlr&quot;,
 312                     &quot;membar_volatile \\(elided\\)&quot;,
 313                     &quot;ret&quot;
 314                 };
 315                 break;
 316             case &quot;G1&quot;:
 317                 // a card mark volatile barrier should be generated
 318                 // before the card mark strb
 319                 //
 320                 // following the fix for 8225776 the G1 barrier is now
 321                 // scheduled out of line after the membar volatile and
 322                 // and subsequent return
 323                 matches = new String[] {
 324                     &quot;membar_release \\(elided\\)&quot;,
 325                     useCompressedOops ? &quot;stlrw?&quot; : &quot;stlr&quot;,
 326                     &quot;membar_volatile \\(elided\\)&quot;,
 327                     &quot;ret&quot;,
 328                     &quot;membar_volatile&quot;,
 329                     &quot;dmb ish&quot;,
 330                     &quot;strb&quot;
 331                 };
 332                 break;
 333             case &quot;Shenandoah&quot;:
 334             case &quot;ShenandoahTraversal&quot;:
 335                  // Shenandoah generates normal object graphs for
 336                  // volatile stores
 337                 matches = new String[] {
 338                     &quot;membar_release \\(elided\\)&quot;,
 339                     useCompressedOops ? &quot;stlrw?&quot; : &quot;stlr&quot;,
 340                     &quot;membar_volatile \\(elided\\)&quot;,
 341                     &quot;ret&quot;
 342                 };
 343                 break;
 344             }
 345         } else {
 346             switch (testType) {
 347             default:
 348                 // this is the basic sequence of instructions
 349                 matches = new String[] {
 350                     &quot;membar_release&quot;,
 351                     &quot;dmb ish&quot;,
 352                     useCompressedOops ? &quot;strw?&quot; : &quot;str&quot;,
 353                     &quot;membar_volatile&quot;,
 354                     &quot;dmb ish&quot;,
 355                     &quot;ret&quot;
 356                 };
 357                 break;
 358             case &quot;G1&quot;:
 359                 // a card mark volatile barrier should be generated
 360                 // before the card mark strb
 361                 //
 362                 // following the fix for 8225776 the G1 barrier is now
 363                 // scheduled out of line after the membar volatile and
 364                 // and subsequent return
 365                 matches = new String[] {
 366                     &quot;membar_release&quot;,
 367                     &quot;dmb ish&quot;,
 368                     useCompressedOops ? &quot;strw?&quot; : &quot;str&quot;,
 369                     &quot;membar_volatile&quot;,
 370                     &quot;dmb ish&quot;,
 371                     &quot;ret&quot;,
 372                     &quot;membar_volatile&quot;,
 373                     &quot;dmb ish&quot;,
 374                     &quot;strb&quot;
 375                 };
 376                 break;
 377             case &quot;CMSCondMark&quot;:
 378                 // a card mark volatile barrier should be generated
 379                 // before the card mark strb from the StoreCM and the
 380                 // storestore barrier from the StoreCM should be elided
 381                 matches = new String[] {
 382                     &quot;membar_release&quot;,
 383                     &quot;dmb ish&quot;,
 384                     useCompressedOops ? &quot;strw?&quot; : &quot;str&quot;,
 385                     &quot;membar_volatile&quot;,
 386                     &quot;dmb ish&quot;,
 387                     &quot;storestore \\(elided\\)&quot;,
 388                     &quot;strb&quot;,
 389                     &quot;membar_volatile&quot;,
 390                     &quot;dmb ish&quot;,
 391                     &quot;ret&quot;
 392                 };
 393                 break;
 394             case &quot;CMS&quot;:
 395                 // a volatile card mark membar should not be generated
 396                 // before the card mark strb from the StoreCM and the
 397                 // storestore barrier from the StoreCM should be generated
 398                 // as &quot;dmb ishst&quot;
 399                 matches = new String[] {
 400                     &quot;membar_release&quot;,
 401                     &quot;dmb ish&quot;,
 402                     useCompressedOops ? &quot;strw?&quot; : &quot;str&quot;,
 403                     &quot;storestore&quot;,
 404                     &quot;dmb ishst&quot;,
 405                     &quot;strb&quot;,
 406                     &quot;membar_volatile&quot;,
 407                     &quot;dmb ish&quot;,
 408                     &quot;ret&quot;
 409                 };
 410                 break;
 411 
 412             case &quot;Shenandoah&quot;:
 413             case &quot;ShenandoahTraversal&quot;:
 414                  // Shenandoah generates normal object graphs for
 415                  // volatile stores
 416                 matches = new String[] {
 417                     &quot;membar_release&quot;,
 418                     &quot;dmb ish&quot;,
 419                     useCompressedOops ? &quot;strw?&quot; : &quot;str&quot;,
 420                     &quot;membar_volatile&quot;,
 421                     &quot;dmb ish&quot;,
 422                     &quot;ret&quot;
 423                 };
 424                 break;
 425             }
 426         }
 427 
 428         checkCompile(iter, &quot;testObj&quot;, matches, output, true);
 429     }
 430 
 431     // check for expected asm output from a volatile cas
 432 
 433     private void checkcas(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
 434     {
 435         Iterator&lt;String&gt; iter = output.asLines().listIterator();
 436 
 437         String[] matches;
 438         String[][] tests = {
 439             { &quot;testInt&quot;, &quot;cmpxchgw&quot; },
 440             { &quot;testLong&quot;, &quot;cmpxchg&quot; },
 441             { &quot;testByte&quot;, &quot;cmpxchgb&quot; },
 442             { &quot;testShort&quot;, &quot;cmpxchgs&quot; },
 443         };
 444 
 445         for (String[] test : tests) {
 446             // non object stores are straightforward
 447             if (!useBarriersForVolatile) {
 448                 // this is the sequence of instructions for all cases
 449                 matches = new String[] {
 450                     &quot;membar_release \\(elided\\)&quot;,
 451                     test[1] + &quot;_acq&quot;,
 452                     &quot;membar_acquire \\(elided\\)&quot;,
 453                     &quot;ret&quot;
 454                 };
 455             } else {
 456                 // this is the alternative sequence of instructions
 457                 matches = new String[] {
 458                     &quot;membar_release&quot;,
 459                     &quot;dmb ish&quot;,
 460                     test[1] + &quot; &quot;,
 461                     &quot;membar_acquire&quot;,
 462                     &quot;dmb ish&quot;,
 463                     &quot;ret&quot;
 464                 };
 465             }
 466 
 467             checkCompile(iter, test[0], matches, output, true);
 468         }
 469 
 470         // object stores will be as above except for when the GC
 471         // introduces barriers for card marking
 472 
 473         if (!useBarriersForVolatile) {
 474             switch (testType) {
 475             default:
 476                 // this is the basic sequence of instructions
 477                 matches = new String[] {
 478                     &quot;membar_release \\(elided\\)&quot;,
 479                     useCompressedOops ? &quot;cmpxchgw?_acq&quot; : &quot;cmpxchg_acq&quot;,
 480                     &quot;strb&quot;,
 481                     &quot;membar_acquire \\(elided\\)&quot;,
 482                     &quot;ret&quot;
 483                 };
 484                 break;
 485             case &quot;G1&quot;:
 486                 // a card mark volatile barrier should be generated
 487                 // before the card mark strb
 488                 //
 489                 // following the fix for 8225776 the G1 barrier is now
 490                 // scheduled out of line after the membar acquire and
 491                 // and subsequent return
 492                 matches = new String[] {
 493                     &quot;membar_release \\(elided\\)&quot;,
 494                     useCompressedOops ? &quot;cmpxchgw?_acq&quot; : &quot;cmpxchg_acq&quot;,
 495                     &quot;membar_acquire \\(elided\\)&quot;,
 496                     &quot;ret&quot;,
 497                     &quot;membar_volatile&quot;,
 498                     &quot;dmb ish&quot;,
 499                     &quot;strb&quot;
 500                 };
 501                 break;
 502             case &quot;Shenandoah&quot;:
 503             case &quot;ShenandoahTraversal&quot;:
 504                 // For volatile CAS, Shenanodoah generates normal
 505                 // graphs with a shenandoah-specific cmpxchg
 506                 matches = new String[] {
 507                     &quot;membar_release \\(elided\\)&quot;,
 508                     useCompressedOops ? &quot;cmpxchgw?_acq_shenandoah&quot; : &quot;cmpxchg_acq_shenandoah&quot;,
 509                     &quot;membar_acquire \\(elided\\)&quot;,
 510                     &quot;ret&quot;
 511                 };
 512                 break;
 513             }
 514         } else {
 515             switch (testType) {
 516             default:
 517                 // this is the basic sequence of instructions
 518                 matches = new String[] {
 519                     &quot;membar_release&quot;,
 520                     &quot;dmb ish&quot;,
 521                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 522                     &quot;membar_acquire&quot;,
 523                     &quot;dmb ish&quot;,
 524                     &quot;ret&quot;
 525                 };
 526                 break;
 527             case &quot;G1&quot;:
 528                 // a card mark volatile barrier should be generated
 529                 // before the card mark strb
 530                 //
 531                 // following the fix for 8225776 the G1 barrier is now
 532                 // scheduled out of line after the membar acquire and
 533                 // and subsequent return
 534                 matches = new String[] {
 535                     &quot;membar_release&quot;,
 536                     &quot;dmb ish&quot;,
 537                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 538                     &quot;membar_acquire&quot;,
 539                     &quot;dmb ish&quot;,
 540                     &quot;ret&quot;,
 541                     &quot;membar_volatile&quot;,
 542                     &quot;dmb ish&quot;,
 543                     &quot;strb&quot;
 544                 };
 545                 break;
 546             case &quot;CMSCondMark&quot;:
 547                 // a card mark volatile barrier should be generated
 548                 // before the card mark strb from the StoreCM and the
 549                 // storestore barrier from the StoreCM should be elided
 550                 matches = new String[] {
 551                     &quot;membar_release&quot;,
 552                     &quot;dmb ish&quot;,
 553                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 554                     &quot;membar_volatile&quot;,
 555                     &quot;dmb ish&quot;,
 556                     &quot;storestore \\(elided\\)&quot;,
 557                     &quot;strb&quot;,
 558                     &quot;membar_acquire&quot;,
 559                     &quot;dmb ish&quot;,
 560                     &quot;ret&quot;
 561                 };
 562                 break;
 563             case &quot;CMS&quot;:
 564                 // a volatile card mark membar should not be generated
 565                 // before the card mark strb from the StoreCM and the
 566                 // storestore barrier from the StoreCM should be generated
 567                 // as &quot;dmb ishst&quot;
 568                 matches = new String[] {
 569                     &quot;membar_release&quot;,
 570                     &quot;dmb ish&quot;,
 571                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 572                     &quot;storestore&quot;,
 573                     &quot;dmb ishst&quot;,
 574                     &quot;strb&quot;,
 575                     &quot;membar_acquire&quot;,
 576                     &quot;dmb ish&quot;,
 577                     &quot;ret&quot;
 578                 };
 579                 break;
 580             case &quot;Shenandoah&quot;:
 581             case &quot;ShenandoahTraversal&quot;:
 582                 // For volatile CAS, Shenanodoah generates normal
 583                 // graphs with a shenandoah-specific cmpxchg
 584                 matches = new String[] {
 585                     &quot;membar_release&quot;,
 586                     &quot;dmb ish&quot;,
 587                     useCompressedOops ? &quot;cmpxchgw?_shenandoah&quot; : &quot;cmpxchg_shenandoah&quot;,
 588                     &quot;membar_acquire&quot;,
 589                     &quot;dmb ish&quot;,
 590                     &quot;ret&quot;
 591                 };
 592                 break;
 593             }
 594         }
 595 
 596         checkCompile(iter, &quot;testObj&quot;, matches, output, true);
 597     }
 598 
 599     private void checkcae(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
 600     {
 601         ListIterator&lt;String&gt; iter = output.asLines().listIterator();
 602 
 603         String[] matches;
 604         String[][] tests = {
 605             { &quot;testInt&quot;, &quot;cmpxchgw&quot; },
 606             { &quot;testLong&quot;, &quot;cmpxchg&quot; },
 607             { &quot;testByte&quot;, &quot;cmpxchgb&quot; },
 608             { &quot;testShort&quot;, &quot;cmpxchgs&quot; },
 609         };
 610 
 611         for (String[] test : tests) {
 612             // non object stores are straightforward
 613             if (!useBarriersForVolatile) {
 614                 // this is the sequence of instructions for all cases
 615                 matches = new String[] {
 616                     &quot;membar_release \\(elided\\)&quot;,
 617                     test[1] + &quot;_acq&quot;,
 618                     &quot;membar_acquire \\(elided\\)&quot;,
 619                     &quot;ret&quot;
 620                 };
 621             } else {
 622                 // this is the alternative sequence of instructions
 623                 matches = new String[] {
 624                     &quot;membar_release&quot;,
 625                     &quot;dmb ish&quot;,
 626                     test[1] + &quot; &quot;,
 627                     &quot;membar_acquire&quot;,
 628                     &quot;dmb ish&quot;,
 629                     &quot;ret&quot;
 630                 };
 631             }
 632 
 633             checkCompile(iter, test[0], matches, output, true);
 634         }
 635 
 636         // object stores will be as above except for when the GC
 637         // introduces barriers for card marking
 638 
 639         if (!useBarriersForVolatile) {
 640             switch (testType) {
 641             default:
 642                 // this is the basic sequence of instructions
 643                 matches = new String[] {
 644                     &quot;membar_release \\(elided\\)&quot;,
 645                     &quot;strb&quot;,
 646                     useCompressedOops ? &quot;cmpxchgw?_acq&quot; : &quot;cmpxchg_acq&quot;,
 647                     &quot;membar_acquire \\(elided\\)&quot;,
 648                     &quot;ret&quot;
 649                 };
 650 
 651                 // card marking store may be scheduled before or after
 652                 // the cmpxchg so try both sequences.
 653                 int idx = iter.nextIndex();
 654                 if (!checkCompile(iter, &quot;testObj&quot;, matches, output, false)) {
 655                     iter = output.asLines().listIterator(idx);
 656 
 657                     matches = new String[] {
 658                         &quot;membar_release \\(elided\\)&quot;,
 659                         useCompressedOops ? &quot;cmpxchgw?_acq&quot; : &quot;cmpxchg_acq&quot;,
 660                         &quot;strb&quot;,
 661                         &quot;membar_acquire \\(elided\\)&quot;,
 662                         &quot;ret&quot;
 663                     };
 664 
 665                     checkCompile(iter, &quot;testObj&quot;, matches, output, true);
 666                 }
 667                 return;
 668 
 669             case &quot;G1&quot;:
 670                 // a card mark volatile barrier should be generated
 671                 // before the card mark strb
 672                 //
 673                 // following the fix for 8225776 the G1 barrier is now
 674                 // scheduled out of line after the membar acquire and
 675                 // and subsequent return
 676                 matches = new String[] {
 677                     &quot;membar_release \\(elided\\)&quot;,
 678                     useCompressedOops ? &quot;cmpxchgw?_acq&quot; : &quot;cmpxchg_acq&quot;,
 679                     &quot;membar_acquire \\(elided\\)&quot;,
 680                     &quot;ret&quot;,
 681                     &quot;membar_volatile&quot;,
 682                     &quot;dmb ish&quot;,
 683                     &quot;strb&quot;
 684                 };
 685                 break;
 686             case &quot;Shenandoah&quot;:
 687             case &quot;ShenandoahTraversal&quot;:
 688                 // For volatile CAS, Shenanodoah generates normal
 689                 // graphs with a shenandoah-specific cmpxchg
 690                 matches = new String[] {
 691                     &quot;membar_release \\(elided\\)&quot;,
 692                     useCompressedOops ? &quot;cmpxchgw?_acq_shenandoah&quot; : &quot;cmpxchg_acq_shenandoah&quot;,
 693                     &quot;membar_acquire \\(elided\\)&quot;,
 694                     &quot;ret&quot;
 695                 };
 696                 break;
 697             }
 698         } else {
 699             switch (testType) {
 700             default:
 701                 // this is the basic sequence of instructions
 702                 matches = new String[] {
 703                     &quot;membar_release&quot;,
 704                     &quot;dmb ish&quot;,
 705                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 706                     &quot;membar_acquire&quot;,
 707                     &quot;dmb ish&quot;,
 708                     &quot;ret&quot;
 709                 };
 710                 break;
 711             case &quot;G1&quot;:
 712                 // a card mark volatile barrier should be generated
 713                 // before the card mark strb
 714                 //
 715                 // following the fix for 8225776 the G1 barrier is now
 716                 // scheduled out of line after the membar acquire and
 717                 // and subsequent return
 718                 matches = new String[] {
 719                     &quot;membar_release&quot;,
 720                     &quot;dmb ish&quot;,
 721                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 722                     &quot;membar_acquire&quot;,
 723                     &quot;dmb ish&quot;,
 724                     &quot;ret&quot;,
 725                     &quot;membar_volatile&quot;,
 726                     &quot;dmb ish&quot;,
 727                     &quot;strb&quot;
 728                 };
 729                 break;
 730             case &quot;CMSCondMark&quot;:
 731                 // a card mark volatile barrier should be generated
 732                 // before the card mark strb from the StoreCM and the
 733                 // storestore barrier from the StoreCM should be elided
 734                 matches = new String[] {
 735                     &quot;membar_release&quot;,
 736                     &quot;dmb ish&quot;,
 737                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 738                     &quot;membar_volatile&quot;,
 739                     &quot;dmb ish&quot;,
 740                     &quot;storestore \\(elided\\)&quot;,
 741                     &quot;strb&quot;,
 742                     &quot;membar_acquire&quot;,
 743                     &quot;dmb ish&quot;,
 744                     &quot;ret&quot;
 745                 };
 746                 break;
 747             case &quot;CMS&quot;:
 748                 // a volatile card mark membar should not be generated
 749                 // before the card mark strb from the StoreCM and the
 750                 // storestore barrier from the StoreCM should be generated
 751                 // as &quot;dmb ishst&quot;
 752                 matches = new String[] {
 753                     &quot;membar_release&quot;,
 754                     &quot;dmb ish&quot;,
 755                     useCompressedOops ? &quot;cmpxchgw? &quot; : &quot;cmpxchg &quot;,
 756                     &quot;storestore&quot;,
 757                     &quot;dmb ishst&quot;,
 758                     &quot;strb&quot;,
 759                     &quot;membar_acquire&quot;,
 760                     &quot;dmb ish&quot;,
 761                     &quot;ret&quot;
 762                 };
 763                 break;
 764             case &quot;Shenandoah&quot;:
 765             case &quot;ShenandoahTraversal&quot;:
 766                 // For volatile CAS, Shenanodoah generates normal
 767                 // graphs with a shenandoah-specific cmpxchg
 768                 matches = new String[] {
 769                     &quot;membar_release&quot;,
 770                     &quot;dmb ish&quot;,
 771                     useCompressedOops ? &quot;cmpxchgw?_shenandoah&quot; : &quot;cmpxchg_shenandoah&quot;,
 772                     &quot;membar_acquire&quot;,
 773                     &quot;dmb ish&quot;,
 774                     &quot;ret&quot;
 775                 };
 776                 break;
 777             }
 778         }
 779 
 780         checkCompile(iter, &quot;testObj&quot;, matches, output, true);
 781     }
 782 
 783     private void checkgas(OutputAnalyzer output, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
 784     {
 785         Iterator&lt;String&gt; iter = output.asLines().listIterator();
 786 
 787         String[] matches;
 788         String[][] tests = {
 789             { &quot;testInt&quot;, &quot;atomic_xchgw&quot; },
 790             { &quot;testLong&quot;, &quot;atomic_xchg&quot; },
 791         };
 792 
 793         for (String[] test : tests) {
 794             // non object stores are straightforward
 795             if (!useBarriersForVolatile) {
 796                 // this is the sequence of instructions for all cases
 797                 matches = new String[] {
 798                     &quot;membar_release \\(elided\\)&quot;,
 799                     test[1] + &quot;_acq&quot;,
 800                     &quot;membar_acquire \\(elided\\)&quot;,
 801                     &quot;ret&quot;
 802                 };
 803             } else {
 804                 // this is the alternative sequence of instructions
 805                 matches = new String[] {
 806                     &quot;membar_release&quot;,
 807                     &quot;dmb ish&quot;,
 808                     test[1] + &quot; &quot;,
 809                     &quot;membar_acquire&quot;,
 810                     &quot;dmb ish&quot;,
 811                     &quot;ret&quot;
 812                 };
 813             }
 814 
 815             checkCompile(iter, test[0], matches, output, true);
 816         }
 817 
 818         // object stores will be as above except for when the GC
 819         // introduces barriers for card marking
 820 
 821         if (!useBarriersForVolatile) {
 822             switch (testType) {
 823             default:
 824                 // this is the basic sequence of instructions
 825                 matches = new String[] {
 826                     &quot;membar_release \\(elided\\)&quot;,
 827                     useCompressedOops ? &quot;atomic_xchgw?_acq&quot; : &quot;atomic_xchg_acq&quot;,
 828                     &quot;strb&quot;,
 829                     &quot;membar_acquire \\(elided\\)&quot;,
 830                     &quot;ret&quot;
 831                 };
 832                 break;
 833             case &quot;G1&quot;:
 834                 // a card mark volatile barrier should be generated
 835                 // before the card mark strb
 836                 //
 837                 // following the fix for 8225776 the G1 barrier is now
 838                 // scheduled out of line after the membar acquire and
 839                 // and subsequent return
 840                 matches = new String[] {
 841                     &quot;membar_release \\(elided\\)&quot;,
 842                     useCompressedOops ? &quot;atomic_xchgw?_acq&quot; : &quot;atomic_xchg_acq&quot;,
 843                     &quot;membar_acquire \\(elided\\)&quot;,
 844                     &quot;ret&quot;,
 845                     &quot;membar_volatile&quot;,
 846                     &quot;dmb ish&quot;,
 847                     &quot;strb&quot;
 848                 };
 849                 break;
 850             case &quot;Shenandoah&quot;:
 851             case &quot;ShenandoahTraversal&quot;:
 852                 matches = new String[] {
 853                     &quot;membar_release \\(elided\\)&quot;,
 854                     useCompressedOops ? &quot;atomic_xchgw?_acq&quot; : &quot;atomic_xchg_acq&quot;,
 855                     &quot;membar_acquire \\(elided\\)&quot;,
 856                     &quot;ret&quot;
 857                 };
 858                 break;
 859             }
 860         } else {
 861             switch (testType) {
 862             default:
 863                 // this is the basic sequence of instructions
 864                 matches = new String[] {
 865                     &quot;membar_release&quot;,
 866                     &quot;dmb ish&quot;,
 867                     useCompressedOops ? &quot;atomic_xchgw? &quot; : &quot;atomic_xchg &quot;,
 868                     &quot;membar_acquire&quot;,
 869                     &quot;dmb ish&quot;,
 870                     &quot;ret&quot;
 871                 };
 872                 break;
 873             case &quot;G1&quot;:
 874                 // a card mark volatile barrier should be generated
 875                 // before the card mark strb
 876                 //
 877                 // following the fix for 8225776 the G1 barrier is now
 878                 // scheduled out of line after the membar acquire and
 879                 // and subsequent return
 880                 matches = new String[] {
 881                     &quot;membar_release&quot;,
 882                     &quot;dmb ish&quot;,
 883                     useCompressedOops ? &quot;atomic_xchgw? &quot; : &quot;atomic_xchg &quot;,
 884                     &quot;membar_acquire&quot;,
 885                     &quot;dmb ish&quot;,
 886                     &quot;ret&quot;,
 887                     &quot;membar_volatile&quot;,
 888                     &quot;dmb ish&quot;,
 889                     &quot;strb&quot;
 890                 };
 891                 break;
 892             case &quot;CMSCondMark&quot;:
 893                 // a card mark volatile barrier should be generated
 894                 // before the card mark strb from the StoreCM and the
 895                 // storestore barrier from the StoreCM should be elided
 896                 matches = new String[] {
 897                     &quot;membar_release&quot;,
 898                     &quot;dmb ish&quot;,
 899                     useCompressedOops ? &quot;atomic_xchgw? &quot; : &quot;atomic_xchg &quot;,
 900                     &quot;membar_volatile&quot;,
 901                     &quot;dmb ish&quot;,
 902                     &quot;storestore \\(elided\\)&quot;,
 903                     &quot;strb&quot;,
 904                     &quot;membar_acquire&quot;,
 905                     &quot;dmb ish&quot;,
 906                     &quot;ret&quot;
 907                 };
 908                 break;
 909             case &quot;CMS&quot;:
 910                 // a volatile card mark membar should not be generated
 911                 // before the card mark strb from the StoreCM and the
 912                 // storestore barrier from the StoreCM should be generated
 913                 // as &quot;dmb ishst&quot;
 914                 matches = new String[] {
 915                     &quot;membar_release&quot;,
 916                     &quot;dmb ish&quot;,
 917                     useCompressedOops ? &quot;atomic_xchgw? &quot; : &quot;atomic_xchg &quot;,
 918                     &quot;storestore&quot;,
 919                     &quot;dmb ishst&quot;,
 920                     &quot;strb&quot;,
 921                     &quot;membar_acquire&quot;,
 922                     &quot;dmb ish&quot;,
 923                     &quot;ret&quot;
 924                 };
 925                 break;
 926             case &quot;Shenandoah&quot;:
 927             case &quot;ShenandoahTraversal&quot;:
 928                 matches = new String[] {
 929                     &quot;membar_release&quot;,
 930                     &quot;dmb ish&quot;,
 931                     useCompressedOops ? &quot;atomic_xchgw? &quot; : &quot;atomic_xchg &quot;,
 932                     &quot;membar_acquire&quot;,
 933                     &quot;dmb ish&quot;,
 934                     &quot;ret&quot;
 935                 };
 936                 break;
 937             }
 938         }
 939 
 940         checkCompile(iter, &quot;testObj&quot;, matches, output, true);
 941     }
 942 
 943     private void checkgaa(OutputAnalyzer output, String testType, boolean useBarriersForVolatile) throws Throwable
 944     {
 945         Iterator&lt;String&gt; iter = output.asLines().listIterator();
 946 
 947         String[] matches;
 948         String[][] tests = {
 949             { &quot;testInt&quot;, &quot;get_and_addI&quot; },
 950             { &quot;testLong&quot;, &quot;get_and_addL&quot; },
 951         };
 952 
 953         for (String[] test : tests) {
 954             // non object stores are straightforward
 955             if (!useBarriersForVolatile) {
 956                 // this is the sequence of instructions for all cases
 957                 matches = new String[] {
 958                     &quot;membar_release \\(elided\\)&quot;,
 959                     test[1] + &quot;_acq&quot;,
 960                     &quot;membar_acquire \\(elided\\)&quot;,
 961                     &quot;ret&quot;
 962                 };
 963             } else {
 964                 // this is the alternative sequence of instructions
 965                 matches = new String[] {
 966                     &quot;membar_release&quot;,
 967                     &quot;dmb ish&quot;,
 968                     test[1] + &quot; &quot;,
 969                     &quot;membar_acquire&quot;,
 970                     &quot;dmb ish&quot;,
 971                     &quot;ret&quot;
 972                 };
 973             }
 974 
 975             checkCompile(iter, test[0], matches, output, true);
 976         }
 977 
 978     }
 979 
 980     // perform a check appropriate to the classname
 981 
 982     private void checkoutput(OutputAnalyzer output, String classname, String testType, boolean useBarriersForVolatile, boolean useCompressedOops) throws Throwable
 983     {
 984         // trace call to allow eyeball check of what is being checked
 985         System.out.println(&quot;checkoutput(&quot; +
 986                            classname + &quot;, &quot; +
 987                            testType + &quot;, &quot; +
 988                            useBarriersForVolatile + &quot;)\n&quot; +
 989                            output.getOutput());
 990 
 991         switch (classname) {
 992         case &quot;TestVolatileLoad&quot;:
 993             checkload(output, testType, useBarriersForVolatile, useCompressedOops);
 994             break;
 995         case &quot;TestVolatileStore&quot;:
 996             checkstore(output, testType, useBarriersForVolatile, useCompressedOops);
 997             break;
 998         case &quot;TestUnsafeVolatileLoad&quot;:
 999             checkload(output, testType, useBarriersForVolatile, useCompressedOops);
1000             break;
1001         case &quot;TestUnsafeVolatileStore&quot;:
1002             checkstore(output, testType, useBarriersForVolatile, useCompressedOops);
1003             break;
1004         case &quot;TestUnsafeVolatileCAS&quot;:
1005         case &quot;TestUnsafeVolatileWeakCAS&quot;:
1006             checkcas(output, testType, useBarriersForVolatile, useCompressedOops);
1007             break;
1008         case &quot;TestUnsafeVolatileCAE&quot;:
1009             checkcae(output, testType, useBarriersForVolatile, useCompressedOops);
1010             break;
1011         case &quot;TestUnsafeVolatileGAS&quot;:
1012             checkgas(output, testType, useBarriersForVolatile, useCompressedOops);
1013             break;
1014         case &quot;TestUnsafeVolatileGAA&quot;:
1015             checkgaa(output, testType, useBarriersForVolatile);
1016             break;
1017         }
1018     }
1019 }
    </pre>
  </body>
</html>
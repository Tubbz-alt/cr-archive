<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/graalunit/com.oracle.mxtool.junit/com/oracle/mxtool/junit/FindClassesByAnnotatedMethods.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2014, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package com.oracle.mxtool.junit;
 24 
 25 import java.io.BufferedInputStream;
 26 import java.io.DataInputStream;
 27 import java.io.IOException;
 28 import java.util.Collection;
 29 import java.util.Enumeration;
 30 import java.util.HashSet;
 31 import java.util.Set;
 32 import java.util.jar.JarEntry;
 33 import java.util.jar.JarFile;
 34 
 35 /**
 36  * Finds classes in given jar files that contain methods annotated by a given set of annotations.
 37  */
 38 public class FindClassesByAnnotatedMethods {
 39 
 40     /**
 41      * Finds classes in a given set of jar files that contain at least one method with an annotation
 42      * from a given set of annotations. The qualified name and containing jar file (separated by a
 43      * space) is written to {@link System#out} for each matching class.
 44      *
 45      * @param args jar file names, annotations and snippets patterns. Annotations are those starting
 46      *            with &quot;@&quot; and can be either qualified or unqualified annotation class names,
 47      *            snippets patterns are those starting with {@code &quot;snippetsPattern:&quot;} and the rest
 48      *            are jar file names
 49      */
 50     public static void main(String... args) throws Throwable {
 51         Set&lt;String&gt; qualifiedAnnotations = new HashSet&lt;&gt;();
 52         Set&lt;String&gt; unqualifiedAnnotations = new HashSet&lt;&gt;();
 53         for (String arg : args) {
 54             if (isAnnotationArg(arg)) {
 55                 String annotation = arg.substring(1);
 56                 int lastDot = annotation.lastIndexOf(&#39;.&#39;);
 57                 if (lastDot != -1) {
 58                     qualifiedAnnotations.add(annotation);
 59                 } else {
 60                     String unqualifed = annotation.substring(lastDot + 1);
 61                     unqualifiedAnnotations.add(unqualifed);
 62                 }
 63             }
 64         }
 65 
 66         for (String jarFilePath : args) {
 67             if (isSnippetArg(jarFilePath) || isAnnotationArg(jarFilePath)) {
 68                 continue;
 69             }
 70             JarFile jarFile = new JarFile(jarFilePath);
 71             Enumeration&lt;JarEntry&gt; e = jarFile.entries();
 72             int unsupportedClasses = 0;
 73             System.out.print(jarFilePath);
 74             while (e.hasMoreElements()) {
 75                 JarEntry je = e.nextElement();
 76                 if (je.isDirectory() || !je.getName().endsWith(&quot;.class&quot;) || je.getName().equals(&quot;module-info.class&quot;)) {
 77                     continue;
 78                 }
 79                 Set&lt;String&gt; methodAnnotationTypes = new HashSet&lt;&gt;();
 80                 DataInputStream stream = new DataInputStream(new BufferedInputStream(jarFile.getInputStream(je), (int) je.getSize()));
 81                 boolean isSupported = true;
 82                 try {
 83                     readClassfile(stream, methodAnnotationTypes);
 84                 } catch (UnsupportedClassVersionError ucve) {
 85                     isSupported = false;
 86                     unsupportedClasses++;
 87                 } catch (Throwable t) {
 88                     throw new InternalError(&quot;Error while parsing class from &quot; + je + &quot; in &quot; + jarFilePath, t);
 89                 }
 90                 String className = je.getName().substring(0, je.getName().length() - &quot;.class&quot;.length()).replaceAll(&quot;/&quot;, &quot;.&quot;);
 91                 if (!isSupported) {
 92                     System.out.print(&quot; !&quot; + className);
 93                 }
 94                 for (String annotationType : methodAnnotationTypes) {
 95                     if (!qualifiedAnnotations.isEmpty()) {
 96                         if (qualifiedAnnotations.contains(annotationType)) {
 97                             System.out.print(&quot; &quot; + className);
 98                         }
 99                     }
100                     if (!unqualifiedAnnotations.isEmpty()) {
101                         final int lastDot = annotationType.lastIndexOf(&#39;.&#39;);
102                         if (lastDot != -1) {
103                             String simpleName = annotationType.substring(lastDot + 1);
104                             int lastDollar = simpleName.lastIndexOf(&#39;$&#39;);
105                             if (lastDollar != -1) {
106                                 simpleName = simpleName.substring(lastDollar + 1);
107                             }
108                             if (unqualifiedAnnotations.contains(simpleName)) {
109                                 System.out.print(&quot; &quot; + className);
110                             }
111                         }
112                     }
113                 }
114             }
115             if (unsupportedClasses != 0) {
116                 System.err.printf(&quot;Warning: %d classes in %s skipped as their class file version is not supported by %s%n&quot;, unsupportedClasses, jarFilePath,
117                                 FindClassesByAnnotatedMethods.class.getSimpleName());
118             }
119             System.out.println();
120         }
121     }
122 
123     private static boolean isAnnotationArg(String arg) {
124         return arg.charAt(0) == &#39;@&#39;;
125     }
126 
127     private static boolean isSnippetArg(String arg) {
128         return arg.startsWith(&quot;snippetsPattern:&quot;);
129     }
130 
131     /*
132      * Small bytecode parser that extract annotations.
133      */
134     private static final int MAJOR_VERSION_JAVA6 = 50;
135     private static final int MAJOR_VERSION_OFFSET = 44;
136     private static final byte CONSTANT_Utf8 = 1;
137     private static final byte CONSTANT_Integer = 3;
138     private static final byte CONSTANT_Float = 4;
139     private static final byte CONSTANT_Long = 5;
140     private static final byte CONSTANT_Double = 6;
141     private static final byte CONSTANT_Class = 7;
142     private static final byte CONSTANT_Fieldref = 9;
143     private static final byte CONSTANT_String = 8;
144     private static final byte CONSTANT_Methodref = 10;
145     private static final byte CONSTANT_InterfaceMethodref = 11;
146     private static final byte CONSTANT_NameAndType = 12;
147     private static final byte CONSTANT_MethodHandle = 15;
148     private static final byte CONSTANT_MethodType = 16;
149     private static final byte CONSTANT_Dynamic = 17;
150     private static final byte CONSTANT_InvokeDynamic = 18;
151     private static final byte CONSTANT_Module = 19;
152     private static final byte CONSTANT_Package = 20;
153 
154     private static void readClassfile(DataInputStream stream, Collection&lt;String&gt; methodAnnotationTypes) throws IOException {
155         // magic
156         int magic = stream.readInt();
157         assert magic == 0xCAFEBABE;
158 
159         int minor = stream.readUnsignedShort();
160         int major = stream.readUnsignedShort();
161         if (major &lt; MAJOR_VERSION_JAVA6) {
162             throw new UnsupportedClassVersionError(&quot;Unsupported class file version: &quot; + major + &quot;.&quot; + minor);
163         }
164         // Starting with JDK8, ignore a classfile that has a newer format than the current JDK.
165         String javaVersion = System.getProperties().get(&quot;java.specification.version&quot;).toString();
166         int majorJavaVersion;
167         if (javaVersion.startsWith(&quot;1.&quot;)) {
168             javaVersion = javaVersion.substring(2);
169             majorJavaVersion = Integer.parseInt(javaVersion);
170         } else {
171             majorJavaVersion = Integer.parseInt(javaVersion);
172         }
173         if (major &gt; MAJOR_VERSION_OFFSET + majorJavaVersion) {
174             throw new UnsupportedClassVersionError(&quot;Unsupported class file version: &quot; + major + &quot;.&quot; + minor);
175         }
176 
177         String[] cp = readConstantPool(stream, major, minor);
178 
179         // access_flags, this_class, super_class
180         stream.skipBytes(6);
181 
182         // interfaces
183         stream.skipBytes(stream.readUnsignedShort() * 2);
184 
185         // fields
186         skipFields(stream);
187 
188         // methods
189         readMethods(stream, cp, methodAnnotationTypes);
190     }
191 
192     private static void skipFully(DataInputStream stream, int n) throws IOException {
193         long skipped = 0;
194         do {
195             long s = stream.skip(n - skipped);
196             skipped += s;
197             if (s == 0 &amp;&amp; skipped != n) {
198                 // Check for EOF (i.e., truncated class file)
199                 if (stream.read() == -1) {
200                     throw new IOException(&quot;truncated stream&quot;);
201                 }
202                 skipped++;
203             }
204         } while (skipped != n);
205     }
206 
207     private static String[] readConstantPool(DataInputStream stream, int major, int minor) throws IOException {
208         int count = stream.readUnsignedShort();
209         String[] cp = new String[count];
210 
211         int i = 1;
212         while (i &lt; count) {
213             byte tag = stream.readByte();
214             switch (tag) {
215                 case CONSTANT_Class:
216                 case CONSTANT_String:
217                 case CONSTANT_MethodType:
218                 case CONSTANT_Module:
219                 case CONSTANT_Package: {
220                     skipFully(stream, 2);
221                     break;
222                 }
223                 case CONSTANT_InterfaceMethodref:
224                 case CONSTANT_Methodref:
225                 case CONSTANT_Fieldref:
226                 case CONSTANT_NameAndType:
227                 case CONSTANT_Float:
228                 case CONSTANT_Integer:
229                 case CONSTANT_Dynamic:
230                 case CONSTANT_InvokeDynamic: {
231                     skipFully(stream, 4);
232                     break;
233                 }
234                 case CONSTANT_Long:
235                 case CONSTANT_Double: {
236                     skipFully(stream, 8);
237                     break;
238                 }
239                 case CONSTANT_Utf8: {
240                     cp[i] = stream.readUTF();
241                     break;
242                 }
243                 case CONSTANT_MethodHandle: {
244                     skipFully(stream, 3);
245                     break;
246                 }
247                 default: {
248                     throw new InternalError(String.format(&quot;Invalid constant pool tag: &quot; + tag + &quot;. Maybe %s needs updating for changes introduced by class file version %d.%d?&quot;,
249                                     FindClassesByAnnotatedMethods.class, major, minor));
250                 }
251             }
252             if ((tag == CONSTANT_Double) || (tag == CONSTANT_Long)) {
253                 i += 2;
254             } else {
255                 i += 1;
256             }
257         }
258         return cp;
259     }
260 
261     private static void skipAttributes(DataInputStream stream) throws IOException {
262         int attributesCount;
263         attributesCount = stream.readUnsignedShort();
264         for (int i = 0; i &lt; attributesCount; i++) {
265             stream.skipBytes(2); // name_index
266             int attributeLength = stream.readInt();
267             skipFully(stream, attributeLength);
268         }
269     }
270 
271     private static void readMethodAttributes(DataInputStream stream, String[] cp, Collection&lt;String&gt; methodAnnotationTypes) throws IOException {
272         int attributesCount;
273         attributesCount = stream.readUnsignedShort();
274         for (int i = 0; i &lt; attributesCount; i++) {
275             String attributeName = cp[stream.readUnsignedShort()];
276             int attributeLength = stream.readInt();
277 
278             if (attributeName.equals(&quot;RuntimeVisibleAnnotations&quot;)) {
279                 int numAnnotations = stream.readUnsignedShort();
280                 for (int a = 0; a != numAnnotations; a++) {
281                     readAnnotation(stream, cp, methodAnnotationTypes);
282                 }
283             } else {
284                 skipFully(stream, attributeLength);
285             }
286         }
287     }
288 
289     private static void readAnnotation(DataInputStream stream, String[] cp, Collection&lt;String&gt; methodAnnotationTypes) throws IOException {
290         int typeIndex = stream.readUnsignedShort();
291         int pairs = stream.readUnsignedShort();
292         String type = cp[typeIndex];
293         String className = type.substring(1, type.length() - 1).replace(&#39;/&#39;, &#39;.&#39;);
294         methodAnnotationTypes.add(className);
295         readAnnotationElements(stream, cp, pairs, true, methodAnnotationTypes);
296     }
297 
298     private static void readAnnotationElements(DataInputStream stream, String[] cp, int pairs, boolean withElementName, Collection&lt;String&gt; methodAnnotationTypes) throws IOException {
299         for (int p = 0; p &lt; pairs; p++) {
300             if (withElementName) {
301                 skipFully(stream, 2);
302             }
303             int tag = stream.readByte();
304             switch (tag) {
305                 case &#39;B&#39;:
306                 case &#39;C&#39;:
307                 case &#39;D&#39;:
308                 case &#39;F&#39;:
309                 case &#39;I&#39;:
310                 case &#39;J&#39;:
311                 case &#39;S&#39;:
312                 case &#39;Z&#39;:
313                 case &#39;s&#39;:
314                 case &#39;c&#39;:
315                     skipFully(stream, 2);
316                     break;
317                 case &#39;e&#39;:
318                     skipFully(stream, 4);
319                     break;
320                 case &#39;@&#39;:
321                     readAnnotation(stream, cp, methodAnnotationTypes);
322                     break;
323                 case &#39;[&#39;: {
324                     int numValues = stream.readUnsignedShort();
325                     readAnnotationElements(stream, cp, numValues, false, methodAnnotationTypes);
326                     break;
327                 }
328             }
329         }
330     }
331 
332     private static void skipFields(DataInputStream stream) throws IOException {
333         int count = stream.readUnsignedShort();
334         for (int i = 0; i &lt; count; i++) {
335             stream.skipBytes(6); // access_flags, name_index, descriptor_index
336             skipAttributes(stream);
337         }
338     }
339 
340     private static void readMethods(DataInputStream stream, String[] cp, Collection&lt;String&gt; methodAnnotationTypes) throws IOException {
341         int count = stream.readUnsignedShort();
342         for (int i = 0; i &lt; count; i++) {
343             skipFully(stream, 6); // access_flags, name_index, descriptor_index
344             readMethodAttributes(stream, cp, methodAnnotationTypes);
345         }
346     }
347 }
    </pre>
  </body>
</html>
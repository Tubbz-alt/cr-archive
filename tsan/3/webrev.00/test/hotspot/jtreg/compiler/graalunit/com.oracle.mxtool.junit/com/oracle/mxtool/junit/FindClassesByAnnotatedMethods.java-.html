<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/compiler/graalunit/com.oracle.mxtool.junit/com/oracle/mxtool/junit/FindClassesByAnnotatedMethods.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2014, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package com.oracle.mxtool.junit;
 24 
 25 import java.io.BufferedInputStream;
 26 import java.io.DataInputStream;
 27 import java.io.IOException;
 28 import java.util.Collection;
 29 import java.util.Enumeration;
 30 import java.util.HashSet;
 31 import java.util.Set;
 32 import java.util.jar.JarEntry;
 33 import java.util.jar.JarFile;
 34 
 35 /**
 36  * Finds classes in given jar files that contain methods annotated by a given set of annotations.
 37  */
 38 public class FindClassesByAnnotatedMethods {
 39 
 40     /**
 41      * Finds classes in a given set of jar files that contain at least one method with an annotation
 42      * from a given set of annotations. The qualified name and containing jar file (separated by a
 43      * space) is written to {@link System#out} for each matching class.
 44      *
 45      * @param args jar file names, annotations and snippets patterns. Annotations are those starting
 46      *            with &quot;@&quot; and can be either qualified or unqualified annotation class names,
 47      *            snippets patterns are those starting with {@code &quot;snippetsPattern:&quot;} and the rest
 48      *            are jar file names
 49      */
 50     public static void main(String... args) throws Throwable {
 51         Set&lt;String&gt; qualifiedAnnotations = new HashSet&lt;&gt;();
 52         Set&lt;String&gt; unqualifiedAnnotations = new HashSet&lt;&gt;();
 53         for (String arg : args) {
 54             if (isAnnotationArg(arg)) {
 55                 String annotation = arg.substring(1);
 56                 int lastDot = annotation.lastIndexOf(&#39;.&#39;);
 57                 if (lastDot != -1) {
 58                     qualifiedAnnotations.add(annotation);
 59                 } else {
 60                     String unqualifed = annotation.substring(lastDot + 1);
 61                     unqualifiedAnnotations.add(unqualifed);
 62                 }
 63             }
 64         }
 65 
 66         for (String jarFilePath : args) {
 67             if (isSnippetArg(jarFilePath) || isAnnotationArg(jarFilePath)) {
 68                 continue;
 69             }
 70             JarFile jarFile = new JarFile(jarFilePath);
 71             Enumeration&lt;JarEntry&gt; e = jarFile.entries();
 72             int unsupportedClasses = 0;
 73             System.out.print(jarFilePath);
 74             while (e.hasMoreElements()) {
 75                 JarEntry je = e.nextElement();
 76                 if (je.isDirectory() || !je.getName().endsWith(&quot;.class&quot;)) {
 77                     continue;
 78                 }
 79                 Set&lt;String&gt; methodAnnotationTypes = new HashSet&lt;&gt;();
 80                 DataInputStream stream = new DataInputStream(new BufferedInputStream(jarFile.getInputStream(je), (int) je.getSize()));
 81                 boolean isSupported = true;
 82                 try {
 83                     readClassfile(stream, methodAnnotationTypes);
 84                 } catch (UnsupportedClassVersionError ucve) {
 85                     isSupported = false;
 86                     unsupportedClasses++;
 87                 }
 88                 String className = je.getName().substring(0, je.getName().length() - &quot;.class&quot;.length()).replaceAll(&quot;/&quot;, &quot;.&quot;);
 89                 if (!isSupported) {
 90                     System.out.print(&quot; !&quot; + className);
 91                 }
 92                 for (String annotationType : methodAnnotationTypes) {
 93                     if (!qualifiedAnnotations.isEmpty()) {
 94                         if (qualifiedAnnotations.contains(annotationType)) {
 95                             System.out.print(&quot; &quot; + className);
 96                         }
 97                     }
 98                     if (!unqualifiedAnnotations.isEmpty()) {
 99                         final int lastDot = annotationType.lastIndexOf(&#39;.&#39;);
100                         if (lastDot != -1) {
101                             String simpleName = annotationType.substring(lastDot + 1);
102                             int lastDollar = simpleName.lastIndexOf(&#39;$&#39;);
103                             if (lastDollar != -1) {
104                                 simpleName = simpleName.substring(lastDollar + 1);
105                             }
106                             if (unqualifiedAnnotations.contains(simpleName)) {
107                                 System.out.print(&quot; &quot; + className);
108                             }
109                         }
110                     }
111                 }
112             }
113             if (unsupportedClasses != 0) {
114                 System.err.printf(&quot;Warning: %d classes in %s skipped as their class file version is not supported by %s%n&quot;, unsupportedClasses, jarFilePath,
115                                 FindClassesByAnnotatedMethods.class.getSimpleName());
116             }
117             System.out.println();
118         }
119     }
120 
121     private static boolean isAnnotationArg(String arg) {
122         return arg.charAt(0) == &#39;@&#39;;
123     }
124 
125     private static boolean isSnippetArg(String arg) {
126         return arg.startsWith(&quot;snippetsPattern:&quot;);
127     }
128 
129     /*
130      * Small bytecode parser that extract annotations.
131      */
132     private static final int MAJOR_VERSION_JAVA7 = 51;
133     private static final int MAJOR_VERSION_OFFSET = 44;
134     private static final byte CONSTANT_Utf8 = 1;
135     private static final byte CONSTANT_Integer = 3;
136     private static final byte CONSTANT_Float = 4;
137     private static final byte CONSTANT_Long = 5;
138     private static final byte CONSTANT_Double = 6;
139     private static final byte CONSTANT_Class = 7;
140     private static final byte CONSTANT_Fieldref = 9;
141     private static final byte CONSTANT_String = 8;
142     private static final byte CONSTANT_Methodref = 10;
143     private static final byte CONSTANT_InterfaceMethodref = 11;
144     private static final byte CONSTANT_NameAndType = 12;
145     private static final byte CONSTANT_MethodHandle = 15;
146     private static final byte CONSTANT_MethodType = 16;
147     private static final byte CONSTANT_Dynamic = 17;
148     private static final byte CONSTANT_InvokeDynamic = 18;
149 
150     private static void readClassfile(DataInputStream stream, Collection&lt;String&gt; methodAnnotationTypes) throws IOException {
151         // magic
152         int magic = stream.readInt();
153         assert magic == 0xCAFEBABE;
154 
155         int minor = stream.readUnsignedShort();
156         int major = stream.readUnsignedShort();
157         if (major &lt; MAJOR_VERSION_JAVA7) {
158             throw new UnsupportedClassVersionError(&quot;Unsupported class file version: &quot; + major + &quot;.&quot; + minor);
159         }
160         // Starting with JDK8, ignore a classfile that has a newer format than the current JDK.
161         String javaVersion = System.getProperties().get(&quot;java.specification.version&quot;).toString();
162         int majorJavaVersion;
163         if (javaVersion.startsWith(&quot;1.&quot;)) {
164             javaVersion = javaVersion.substring(2);
165             majorJavaVersion = Integer.parseInt(javaVersion);
166         } else {
167             majorJavaVersion = Integer.parseInt(javaVersion);
168         }
169         if (major &gt; MAJOR_VERSION_OFFSET + majorJavaVersion) {
170             throw new UnsupportedClassVersionError(&quot;Unsupported class file version: &quot; + major + &quot;.&quot; + minor);
171         }
172 
173         String[] cp = readConstantPool(stream, major, minor);
174 
175         // access_flags, this_class, super_class
176         stream.skipBytes(6);
177 
178         // interfaces
179         stream.skipBytes(stream.readUnsignedShort() * 2);
180 
181         // fields
182         skipFields(stream);
183 
184         // methods
185         readMethods(stream, cp, methodAnnotationTypes);
186     }
187 
188     private static void skipFully(DataInputStream stream, int n) throws IOException {
189         long skipped = 0;
190         do {
191             long s = stream.skip(n - skipped);
192             skipped += s;
193             if (s == 0 &amp;&amp; skipped != n) {
194                 // Check for EOF (i.e., truncated class file)
195                 if (stream.read() == -1) {
196                     throw new IOException(&quot;truncated stream&quot;);
197                 }
198                 skipped++;
199             }
200         } while (skipped != n);
201     }
202 
203     private static String[] readConstantPool(DataInputStream stream, int major, int minor) throws IOException {
204         int count = stream.readUnsignedShort();
205         String[] cp = new String[count];
206 
207         int i = 1;
208         while (i &lt; count) {
209             byte tag = stream.readByte();
210             switch (tag) {
211                 case CONSTANT_Class:
212                 case CONSTANT_String:
213                 case CONSTANT_MethodType: {
214                     skipFully(stream, 2);
215                     break;
216                 }
217                 case CONSTANT_InterfaceMethodref:
218                 case CONSTANT_Methodref:
219                 case CONSTANT_Fieldref:
220                 case CONSTANT_NameAndType:
221                 case CONSTANT_Float:
222                 case CONSTANT_Integer:
223                 case CONSTANT_Dynamic:
224                 case CONSTANT_InvokeDynamic: {
225                     skipFully(stream, 4);
226                     break;
227                 }
228                 case CONSTANT_Long:
229                 case CONSTANT_Double: {
230                     skipFully(stream, 8);
231                     break;
232                 }
233                 case CONSTANT_Utf8: {
234                     cp[i] = stream.readUTF();
235                     break;
236                 }
237                 case CONSTANT_MethodHandle: {
238                     skipFully(stream, 3);
239                     break;
240                 }
241                 default: {
242                     throw new InternalError(String.format(&quot;Invalid constant pool tag: &quot; + tag + &quot;. Maybe %s needs updating for changes introduced by class file version %d.%d?&quot;,
243                                     FindClassesByAnnotatedMethods.class, major, minor));
244                 }
245             }
246             if ((tag == CONSTANT_Double) || (tag == CONSTANT_Long)) {
247                 i += 2;
248             } else {
249                 i += 1;
250             }
251         }
252         return cp;
253     }
254 
255     private static void skipAttributes(DataInputStream stream) throws IOException {
256         int attributesCount;
257         attributesCount = stream.readUnsignedShort();
258         for (int i = 0; i &lt; attributesCount; i++) {
259             stream.skipBytes(2); // name_index
260             int attributeLength = stream.readInt();
261             skipFully(stream, attributeLength);
262         }
263     }
264 
265     private static void readMethodAttributes(DataInputStream stream, String[] cp, Collection&lt;String&gt; methodAnnotationTypes) throws IOException {
266         int attributesCount;
267         attributesCount = stream.readUnsignedShort();
268         for (int i = 0; i &lt; attributesCount; i++) {
269             String attributeName = cp[stream.readUnsignedShort()];
270             int attributeLength = stream.readInt();
271 
272             if (attributeName.equals(&quot;RuntimeVisibleAnnotations&quot;)) {
273                 int numAnnotations = stream.readUnsignedShort();
274                 for (int a = 0; a != numAnnotations; a++) {
275                     readAnnotation(stream, cp, methodAnnotationTypes);
276                 }
277             } else {
278                 skipFully(stream, attributeLength);
279             }
280         }
281     }
282 
283     private static void readAnnotation(DataInputStream stream, String[] cp, Collection&lt;String&gt; methodAnnotationTypes) throws IOException {
284         int typeIndex = stream.readUnsignedShort();
285         int pairs = stream.readUnsignedShort();
286         String type = cp[typeIndex];
287         String className = type.substring(1, type.length() - 1).replace(&#39;/&#39;, &#39;.&#39;);
288         methodAnnotationTypes.add(className);
289         readAnnotationElements(stream, cp, pairs, true, methodAnnotationTypes);
290     }
291 
292     private static void readAnnotationElements(DataInputStream stream, String[] cp, int pairs, boolean withElementName, Collection&lt;String&gt; methodAnnotationTypes) throws IOException {
293         for (int p = 0; p &lt; pairs; p++) {
294             if (withElementName) {
295                 skipFully(stream, 2);
296             }
297             int tag = stream.readByte();
298             switch (tag) {
299                 case &#39;B&#39;:
300                 case &#39;C&#39;:
301                 case &#39;D&#39;:
302                 case &#39;F&#39;:
303                 case &#39;I&#39;:
304                 case &#39;J&#39;:
305                 case &#39;S&#39;:
306                 case &#39;Z&#39;:
307                 case &#39;s&#39;:
308                 case &#39;c&#39;:
309                     skipFully(stream, 2);
310                     break;
311                 case &#39;e&#39;:
312                     skipFully(stream, 4);
313                     break;
314                 case &#39;@&#39;:
315                     readAnnotation(stream, cp, methodAnnotationTypes);
316                     break;
317                 case &#39;[&#39;: {
318                     int numValues = stream.readUnsignedShort();
319                     readAnnotationElements(stream, cp, numValues, false, methodAnnotationTypes);
320                     break;
321                 }
322             }
323         }
324     }
325 
326     private static void skipFields(DataInputStream stream) throws IOException {
327         int count = stream.readUnsignedShort();
328         for (int i = 0; i &lt; count; i++) {
329             stream.skipBytes(6); // access_flags, name_index, descriptor_index
330             skipAttributes(stream);
331         }
332     }
333 
334     private static void readMethods(DataInputStream stream, String[] cp, Collection&lt;String&gt; methodAnnotationTypes) throws IOException {
335         int count = stream.readUnsignedShort();
336         for (int i = 0; i &lt; count; i++) {
337             skipFully(stream, 6); // access_flags, name_index, descriptor_index
338             readMethodAttributes(stream, cp, methodAnnotationTypes);
339         }
340     }
341 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/graalunit/com.oracle.mxtool.junit/com/oracle/mxtool/junit/FindClassesByAnnotatedMethods.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../UtilTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MxJUnitWrapper.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/graalunit/com.oracle.mxtool.junit/com/oracle/mxtool/junit/FindClassesByAnnotatedMethods.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 56                 int lastDot = annotation.lastIndexOf(&#39;.&#39;);
 57                 if (lastDot != -1) {
 58                     qualifiedAnnotations.add(annotation);
 59                 } else {
 60                     String unqualifed = annotation.substring(lastDot + 1);
 61                     unqualifiedAnnotations.add(unqualifed);
 62                 }
 63             }
 64         }
 65 
 66         for (String jarFilePath : args) {
 67             if (isSnippetArg(jarFilePath) || isAnnotationArg(jarFilePath)) {
 68                 continue;
 69             }
 70             JarFile jarFile = new JarFile(jarFilePath);
 71             Enumeration&lt;JarEntry&gt; e = jarFile.entries();
 72             int unsupportedClasses = 0;
 73             System.out.print(jarFilePath);
 74             while (e.hasMoreElements()) {
 75                 JarEntry je = e.nextElement();
<span class="line-modified"> 76                 if (je.isDirectory() || !je.getName().endsWith(&quot;.class&quot;)) {</span>
 77                     continue;
 78                 }
 79                 Set&lt;String&gt; methodAnnotationTypes = new HashSet&lt;&gt;();
 80                 DataInputStream stream = new DataInputStream(new BufferedInputStream(jarFile.getInputStream(je), (int) je.getSize()));
 81                 boolean isSupported = true;
 82                 try {
 83                     readClassfile(stream, methodAnnotationTypes);
 84                 } catch (UnsupportedClassVersionError ucve) {
 85                     isSupported = false;
 86                     unsupportedClasses++;


 87                 }
 88                 String className = je.getName().substring(0, je.getName().length() - &quot;.class&quot;.length()).replaceAll(&quot;/&quot;, &quot;.&quot;);
 89                 if (!isSupported) {
 90                     System.out.print(&quot; !&quot; + className);
 91                 }
 92                 for (String annotationType : methodAnnotationTypes) {
 93                     if (!qualifiedAnnotations.isEmpty()) {
 94                         if (qualifiedAnnotations.contains(annotationType)) {
 95                             System.out.print(&quot; &quot; + className);
 96                         }
 97                     }
 98                     if (!unqualifiedAnnotations.isEmpty()) {
 99                         final int lastDot = annotationType.lastIndexOf(&#39;.&#39;);
100                         if (lastDot != -1) {
101                             String simpleName = annotationType.substring(lastDot + 1);
102                             int lastDollar = simpleName.lastIndexOf(&#39;$&#39;);
103                             if (lastDollar != -1) {
104                                 simpleName = simpleName.substring(lastDollar + 1);
105                             }
106                             if (unqualifiedAnnotations.contains(simpleName)) {
</pre>
<hr />
<pre>
112             }
113             if (unsupportedClasses != 0) {
114                 System.err.printf(&quot;Warning: %d classes in %s skipped as their class file version is not supported by %s%n&quot;, unsupportedClasses, jarFilePath,
115                                 FindClassesByAnnotatedMethods.class.getSimpleName());
116             }
117             System.out.println();
118         }
119     }
120 
121     private static boolean isAnnotationArg(String arg) {
122         return arg.charAt(0) == &#39;@&#39;;
123     }
124 
125     private static boolean isSnippetArg(String arg) {
126         return arg.startsWith(&quot;snippetsPattern:&quot;);
127     }
128 
129     /*
130      * Small bytecode parser that extract annotations.
131      */
<span class="line-modified">132     private static final int MAJOR_VERSION_JAVA7 = 51;</span>
133     private static final int MAJOR_VERSION_OFFSET = 44;
134     private static final byte CONSTANT_Utf8 = 1;
135     private static final byte CONSTANT_Integer = 3;
136     private static final byte CONSTANT_Float = 4;
137     private static final byte CONSTANT_Long = 5;
138     private static final byte CONSTANT_Double = 6;
139     private static final byte CONSTANT_Class = 7;
140     private static final byte CONSTANT_Fieldref = 9;
141     private static final byte CONSTANT_String = 8;
142     private static final byte CONSTANT_Methodref = 10;
143     private static final byte CONSTANT_InterfaceMethodref = 11;
144     private static final byte CONSTANT_NameAndType = 12;
145     private static final byte CONSTANT_MethodHandle = 15;
146     private static final byte CONSTANT_MethodType = 16;
147     private static final byte CONSTANT_Dynamic = 17;
148     private static final byte CONSTANT_InvokeDynamic = 18;


149 
150     private static void readClassfile(DataInputStream stream, Collection&lt;String&gt; methodAnnotationTypes) throws IOException {
151         // magic
152         int magic = stream.readInt();
153         assert magic == 0xCAFEBABE;
154 
155         int minor = stream.readUnsignedShort();
156         int major = stream.readUnsignedShort();
<span class="line-modified">157         if (major &lt; MAJOR_VERSION_JAVA7) {</span>
158             throw new UnsupportedClassVersionError(&quot;Unsupported class file version: &quot; + major + &quot;.&quot; + minor);
159         }
160         // Starting with JDK8, ignore a classfile that has a newer format than the current JDK.
161         String javaVersion = System.getProperties().get(&quot;java.specification.version&quot;).toString();
162         int majorJavaVersion;
163         if (javaVersion.startsWith(&quot;1.&quot;)) {
164             javaVersion = javaVersion.substring(2);
165             majorJavaVersion = Integer.parseInt(javaVersion);
166         } else {
167             majorJavaVersion = Integer.parseInt(javaVersion);
168         }
169         if (major &gt; MAJOR_VERSION_OFFSET + majorJavaVersion) {
170             throw new UnsupportedClassVersionError(&quot;Unsupported class file version: &quot; + major + &quot;.&quot; + minor);
171         }
172 
173         String[] cp = readConstantPool(stream, major, minor);
174 
175         // access_flags, this_class, super_class
176         stream.skipBytes(6);
177 
</pre>
<hr />
<pre>
193             if (s == 0 &amp;&amp; skipped != n) {
194                 // Check for EOF (i.e., truncated class file)
195                 if (stream.read() == -1) {
196                     throw new IOException(&quot;truncated stream&quot;);
197                 }
198                 skipped++;
199             }
200         } while (skipped != n);
201     }
202 
203     private static String[] readConstantPool(DataInputStream stream, int major, int minor) throws IOException {
204         int count = stream.readUnsignedShort();
205         String[] cp = new String[count];
206 
207         int i = 1;
208         while (i &lt; count) {
209             byte tag = stream.readByte();
210             switch (tag) {
211                 case CONSTANT_Class:
212                 case CONSTANT_String:
<span class="line-modified">213                 case CONSTANT_MethodType: {</span>


214                     skipFully(stream, 2);
215                     break;
216                 }
217                 case CONSTANT_InterfaceMethodref:
218                 case CONSTANT_Methodref:
219                 case CONSTANT_Fieldref:
220                 case CONSTANT_NameAndType:
221                 case CONSTANT_Float:
222                 case CONSTANT_Integer:
223                 case CONSTANT_Dynamic:
224                 case CONSTANT_InvokeDynamic: {
225                     skipFully(stream, 4);
226                     break;
227                 }
228                 case CONSTANT_Long:
229                 case CONSTANT_Double: {
230                     skipFully(stream, 8);
231                     break;
232                 }
233                 case CONSTANT_Utf8: {
</pre>
</td>
<td>
<hr />
<pre>
 56                 int lastDot = annotation.lastIndexOf(&#39;.&#39;);
 57                 if (lastDot != -1) {
 58                     qualifiedAnnotations.add(annotation);
 59                 } else {
 60                     String unqualifed = annotation.substring(lastDot + 1);
 61                     unqualifiedAnnotations.add(unqualifed);
 62                 }
 63             }
 64         }
 65 
 66         for (String jarFilePath : args) {
 67             if (isSnippetArg(jarFilePath) || isAnnotationArg(jarFilePath)) {
 68                 continue;
 69             }
 70             JarFile jarFile = new JarFile(jarFilePath);
 71             Enumeration&lt;JarEntry&gt; e = jarFile.entries();
 72             int unsupportedClasses = 0;
 73             System.out.print(jarFilePath);
 74             while (e.hasMoreElements()) {
 75                 JarEntry je = e.nextElement();
<span class="line-modified"> 76                 if (je.isDirectory() || !je.getName().endsWith(&quot;.class&quot;) || je.getName().equals(&quot;module-info.class&quot;)) {</span>
 77                     continue;
 78                 }
 79                 Set&lt;String&gt; methodAnnotationTypes = new HashSet&lt;&gt;();
 80                 DataInputStream stream = new DataInputStream(new BufferedInputStream(jarFile.getInputStream(je), (int) je.getSize()));
 81                 boolean isSupported = true;
 82                 try {
 83                     readClassfile(stream, methodAnnotationTypes);
 84                 } catch (UnsupportedClassVersionError ucve) {
 85                     isSupported = false;
 86                     unsupportedClasses++;
<span class="line-added"> 87                 } catch (Throwable t) {</span>
<span class="line-added"> 88                     throw new InternalError(&quot;Error while parsing class from &quot; + je + &quot; in &quot; + jarFilePath, t);</span>
 89                 }
 90                 String className = je.getName().substring(0, je.getName().length() - &quot;.class&quot;.length()).replaceAll(&quot;/&quot;, &quot;.&quot;);
 91                 if (!isSupported) {
 92                     System.out.print(&quot; !&quot; + className);
 93                 }
 94                 for (String annotationType : methodAnnotationTypes) {
 95                     if (!qualifiedAnnotations.isEmpty()) {
 96                         if (qualifiedAnnotations.contains(annotationType)) {
 97                             System.out.print(&quot; &quot; + className);
 98                         }
 99                     }
100                     if (!unqualifiedAnnotations.isEmpty()) {
101                         final int lastDot = annotationType.lastIndexOf(&#39;.&#39;);
102                         if (lastDot != -1) {
103                             String simpleName = annotationType.substring(lastDot + 1);
104                             int lastDollar = simpleName.lastIndexOf(&#39;$&#39;);
105                             if (lastDollar != -1) {
106                                 simpleName = simpleName.substring(lastDollar + 1);
107                             }
108                             if (unqualifiedAnnotations.contains(simpleName)) {
</pre>
<hr />
<pre>
114             }
115             if (unsupportedClasses != 0) {
116                 System.err.printf(&quot;Warning: %d classes in %s skipped as their class file version is not supported by %s%n&quot;, unsupportedClasses, jarFilePath,
117                                 FindClassesByAnnotatedMethods.class.getSimpleName());
118             }
119             System.out.println();
120         }
121     }
122 
123     private static boolean isAnnotationArg(String arg) {
124         return arg.charAt(0) == &#39;@&#39;;
125     }
126 
127     private static boolean isSnippetArg(String arg) {
128         return arg.startsWith(&quot;snippetsPattern:&quot;);
129     }
130 
131     /*
132      * Small bytecode parser that extract annotations.
133      */
<span class="line-modified">134     private static final int MAJOR_VERSION_JAVA6 = 50;</span>
135     private static final int MAJOR_VERSION_OFFSET = 44;
136     private static final byte CONSTANT_Utf8 = 1;
137     private static final byte CONSTANT_Integer = 3;
138     private static final byte CONSTANT_Float = 4;
139     private static final byte CONSTANT_Long = 5;
140     private static final byte CONSTANT_Double = 6;
141     private static final byte CONSTANT_Class = 7;
142     private static final byte CONSTANT_Fieldref = 9;
143     private static final byte CONSTANT_String = 8;
144     private static final byte CONSTANT_Methodref = 10;
145     private static final byte CONSTANT_InterfaceMethodref = 11;
146     private static final byte CONSTANT_NameAndType = 12;
147     private static final byte CONSTANT_MethodHandle = 15;
148     private static final byte CONSTANT_MethodType = 16;
149     private static final byte CONSTANT_Dynamic = 17;
150     private static final byte CONSTANT_InvokeDynamic = 18;
<span class="line-added">151     private static final byte CONSTANT_Module = 19;</span>
<span class="line-added">152     private static final byte CONSTANT_Package = 20;</span>
153 
154     private static void readClassfile(DataInputStream stream, Collection&lt;String&gt; methodAnnotationTypes) throws IOException {
155         // magic
156         int magic = stream.readInt();
157         assert magic == 0xCAFEBABE;
158 
159         int minor = stream.readUnsignedShort();
160         int major = stream.readUnsignedShort();
<span class="line-modified">161         if (major &lt; MAJOR_VERSION_JAVA6) {</span>
162             throw new UnsupportedClassVersionError(&quot;Unsupported class file version: &quot; + major + &quot;.&quot; + minor);
163         }
164         // Starting with JDK8, ignore a classfile that has a newer format than the current JDK.
165         String javaVersion = System.getProperties().get(&quot;java.specification.version&quot;).toString();
166         int majorJavaVersion;
167         if (javaVersion.startsWith(&quot;1.&quot;)) {
168             javaVersion = javaVersion.substring(2);
169             majorJavaVersion = Integer.parseInt(javaVersion);
170         } else {
171             majorJavaVersion = Integer.parseInt(javaVersion);
172         }
173         if (major &gt; MAJOR_VERSION_OFFSET + majorJavaVersion) {
174             throw new UnsupportedClassVersionError(&quot;Unsupported class file version: &quot; + major + &quot;.&quot; + minor);
175         }
176 
177         String[] cp = readConstantPool(stream, major, minor);
178 
179         // access_flags, this_class, super_class
180         stream.skipBytes(6);
181 
</pre>
<hr />
<pre>
197             if (s == 0 &amp;&amp; skipped != n) {
198                 // Check for EOF (i.e., truncated class file)
199                 if (stream.read() == -1) {
200                     throw new IOException(&quot;truncated stream&quot;);
201                 }
202                 skipped++;
203             }
204         } while (skipped != n);
205     }
206 
207     private static String[] readConstantPool(DataInputStream stream, int major, int minor) throws IOException {
208         int count = stream.readUnsignedShort();
209         String[] cp = new String[count];
210 
211         int i = 1;
212         while (i &lt; count) {
213             byte tag = stream.readByte();
214             switch (tag) {
215                 case CONSTANT_Class:
216                 case CONSTANT_String:
<span class="line-modified">217                 case CONSTANT_MethodType:</span>
<span class="line-added">218                 case CONSTANT_Module:</span>
<span class="line-added">219                 case CONSTANT_Package: {</span>
220                     skipFully(stream, 2);
221                     break;
222                 }
223                 case CONSTANT_InterfaceMethodref:
224                 case CONSTANT_Methodref:
225                 case CONSTANT_Fieldref:
226                 case CONSTANT_NameAndType:
227                 case CONSTANT_Float:
228                 case CONSTANT_Integer:
229                 case CONSTANT_Dynamic:
230                 case CONSTANT_InvokeDynamic: {
231                     skipFully(stream, 4);
232                     break;
233                 }
234                 case CONSTANT_Long:
235                 case CONSTANT_Double: {
236                     skipFully(stream, 8);
237                     break;
238                 }
239                 case CONSTANT_Utf8: {
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../UtilTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MxJUnitWrapper.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/test/hotspot/jtreg/compiler/graalunit/com.oracle.mxtool.junit/com/oracle/mxtool/junit/FindClassesByAnnotatedMethods.java b/test/hotspot/jtreg/compiler/graalunit/com.oracle.mxtool.junit/com/oracle/mxtool/junit/FindClassesByAnnotatedMethods.java
--- a/test/hotspot/jtreg/compiler/graalunit/com.oracle.mxtool.junit/com/oracle/mxtool/junit/FindClassesByAnnotatedMethods.java
+++ b/test/hotspot/jtreg/compiler/graalunit/com.oracle.mxtool.junit/com/oracle/mxtool/junit/FindClassesByAnnotatedMethods.java
@@ -71,21 +71,23 @@
             Enumeration<JarEntry> e = jarFile.entries();
             int unsupportedClasses = 0;
             System.out.print(jarFilePath);
             while (e.hasMoreElements()) {
                 JarEntry je = e.nextElement();
-                if (je.isDirectory() || !je.getName().endsWith(".class")) {
+                if (je.isDirectory() || !je.getName().endsWith(".class") || je.getName().equals("module-info.class")) {
                     continue;
                 }
                 Set<String> methodAnnotationTypes = new HashSet<>();
                 DataInputStream stream = new DataInputStream(new BufferedInputStream(jarFile.getInputStream(je), (int) je.getSize()));
                 boolean isSupported = true;
                 try {
                     readClassfile(stream, methodAnnotationTypes);
                 } catch (UnsupportedClassVersionError ucve) {
                     isSupported = false;
                     unsupportedClasses++;
+                } catch (Throwable t) {
+                    throw new InternalError("Error while parsing class from " + je + " in " + jarFilePath, t);
                 }
                 String className = je.getName().substring(0, je.getName().length() - ".class".length()).replaceAll("/", ".");
                 if (!isSupported) {
                     System.out.print(" !" + className);
                 }
@@ -127,11 +129,11 @@
     }
 
     /*
      * Small bytecode parser that extract annotations.
      */
-    private static final int MAJOR_VERSION_JAVA7 = 51;
+    private static final int MAJOR_VERSION_JAVA6 = 50;
     private static final int MAJOR_VERSION_OFFSET = 44;
     private static final byte CONSTANT_Utf8 = 1;
     private static final byte CONSTANT_Integer = 3;
     private static final byte CONSTANT_Float = 4;
     private static final byte CONSTANT_Long = 5;
@@ -144,19 +146,21 @@
     private static final byte CONSTANT_NameAndType = 12;
     private static final byte CONSTANT_MethodHandle = 15;
     private static final byte CONSTANT_MethodType = 16;
     private static final byte CONSTANT_Dynamic = 17;
     private static final byte CONSTANT_InvokeDynamic = 18;
+    private static final byte CONSTANT_Module = 19;
+    private static final byte CONSTANT_Package = 20;
 
     private static void readClassfile(DataInputStream stream, Collection<String> methodAnnotationTypes) throws IOException {
         // magic
         int magic = stream.readInt();
         assert magic == 0xCAFEBABE;
 
         int minor = stream.readUnsignedShort();
         int major = stream.readUnsignedShort();
-        if (major < MAJOR_VERSION_JAVA7) {
+        if (major < MAJOR_VERSION_JAVA6) {
             throw new UnsupportedClassVersionError("Unsupported class file version: " + major + "." + minor);
         }
         // Starting with JDK8, ignore a classfile that has a newer format than the current JDK.
         String javaVersion = System.getProperties().get("java.specification.version").toString();
         int majorJavaVersion;
@@ -208,11 +212,13 @@
         while (i < count) {
             byte tag = stream.readByte();
             switch (tag) {
                 case CONSTANT_Class:
                 case CONSTANT_String:
-                case CONSTANT_MethodType: {
+                case CONSTANT_MethodType:
+                case CONSTANT_Module:
+                case CONSTANT_Package: {
                     skipFully(stream, 2);
                     break;
                 }
                 case CONSTANT_InterfaceMethodref:
                 case CONSTANT_Methodref:

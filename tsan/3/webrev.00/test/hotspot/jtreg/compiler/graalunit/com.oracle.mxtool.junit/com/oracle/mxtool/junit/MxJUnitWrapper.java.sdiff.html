<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/graalunit/com.oracle.mxtool.junit/com/oracle/mxtool/junit/MxJUnitWrapper.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FindClassesByAnnotatedMethods.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextRunListener.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/graalunit/com.oracle.mxtool.junit/com/oracle/mxtool/junit/MxJUnitWrapper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package com.oracle.mxtool.junit;
 24 
 25 import java.io.BufferedReader;
 26 import java.io.File;
 27 import java.io.FileNotFoundException;
 28 import java.io.FileOutputStream;
 29 import java.io.FileReader;
 30 import java.io.IOException;
 31 import java.io.PrintStream;
<span class="line-removed"> 32 import java.lang.annotation.Annotation;</span>
<span class="line-removed"> 33 import java.lang.reflect.Method;</span>
 34 import java.util.ArrayList;
 35 import java.util.Collections;
<span class="line-removed"> 36 import java.util.HashSet;</span>
 37 import java.util.List;
 38 import java.util.Map;
<span class="line-removed"> 39 import java.util.Optional;</span>
 40 import java.util.ServiceLoader;
 41 import java.util.Set;
<span class="line-modified"> 42 import java.util.regex.Matcher;</span>
<span class="line-removed"> 43 import java.util.regex.Pattern;</span>
 44 
 45 import org.junit.internal.JUnitSystem;
 46 import org.junit.internal.RealSystem;
 47 import org.junit.runner.Description;
 48 import org.junit.runner.JUnitCore;
 49 import org.junit.runner.Request;
 50 import org.junit.runner.Result;
 51 import org.junit.runner.Runner;
 52 import org.junit.runner.notification.Failure;
 53 import org.junit.runner.notification.RunListener;
 54 import org.junit.runner.notification.RunNotifier;
 55 import org.junit.runners.ParentRunner;
 56 import org.junit.runners.model.RunnerScheduler;
 57 
 58 import junit.runner.Version;
 59 
 60 public class MxJUnitWrapper {
 61 








 62     public static class MxJUnitConfig {
 63 
 64         public boolean verbose = false;
 65         public boolean veryVerbose = false;
 66         public boolean enableTiming = false;
 67         public boolean failFast = false;
 68         public boolean color = false;
 69         public boolean eagerStackTrace = false;
 70         public boolean gcAfterTest = false;
 71         public boolean recordResults = false;
 72         public int repeatCount = 1;
 73     }
 74 
 75     private static class RepeatingRunner extends Runner {
 76 
 77         private final Runner parent;
 78         private int repeat;
 79 
 80         RepeatingRunner(Runner parent, int repeat) {
 81             this.parent = parent;
</pre>
<hr />
<pre>
119     /**
120      * Run the tests contained in the classes named in the &lt;code&gt;args&lt;/code&gt;. A single test method
121      * can be specified by adding #method after the class name. Only a single test can be run in
122      * this way. If all tests run successfully, exit with a status of 0. Otherwise exit with a
123      * status of 1. Write feedback while tests are running and write stack traces for all failed
124      * tests after the tests all complete.
125      *
126      * @param args names of classes in which to find tests to run
127      */
128     public static void main(String... args) {
129         JUnitSystem system = new RealSystem();
130         JUnitCore junitCore = new JUnitCore();
131         system.out().println(&quot;MxJUnitCore&quot;);
132         system.out().println(&quot;JUnit version &quot; + Version.id());
133 
134         MxJUnitRequest.Builder builder = new MxJUnitRequest.Builder();
135         MxJUnitConfig config = new MxJUnitConfig();
136 
137         String[] expandedArgs = expandArgs(args);
138         int i = 0;


139         while (i &lt; expandedArgs.length) {
140             String each = expandedArgs[i];
141             if (each.charAt(0) == &#39;-&#39;) {
142                 // command line arguments
143                 if (each.contentEquals(&quot;-JUnitVerbose&quot;)) {
144                     config.verbose = true;







145                 } else if (each.contentEquals(&quot;-JUnitVeryVerbose&quot;)) {

146                     config.veryVerbose = true;

147                 } else if (each.contentEquals(&quot;-JUnitFailFast&quot;)) {
148                     config.failFast = true;
149                 } else if (each.contentEquals(&quot;-JUnitEnableTiming&quot;)) {
150                     config.enableTiming = true;
151                 } else if (each.contentEquals(&quot;-JUnitColor&quot;)) {
152                     config.color = true;
153                 } else if (each.contentEquals(&quot;-JUnitEagerStackTrace&quot;)) {
154                     config.eagerStackTrace = true;
155                 } else if (each.contentEquals(&quot;-JUnitGCAfterTest&quot;)) {
156                     config.gcAfterTest = true;
157                 } else if (each.contentEquals(&quot;-JUnitRecordResults&quot;)) {
158                     config.recordResults = true;
159                 } else if (each.contentEquals(&quot;-JUnitRepeat&quot;)) {
160                     if (i + 1 &gt;= expandedArgs.length) {
161                         system.out().println(&quot;Must include argument for -JUnitRepeat&quot;);
162                         System.exit(1);
163                     }
164                     try {
165                         config.repeatCount = Integer.parseInt(expandedArgs[++i]);
166                     } catch (NumberFormatException e) {
167                         system.out().println(&quot;Expected integer argument for -JUnitRepeat. Found: &quot; + expandedArgs[i]);
168                         System.exit(1);
169                     }
170                 } else {
171                     system.out().println(&quot;Unknown command line argument: &quot; + each);
172                 }
173 
174             } else {
<span class="line-modified">175 </span>
<span class="line-removed">176                 try {</span>
<span class="line-removed">177                     builder.addTestSpec(each);</span>
<span class="line-removed">178                 } catch (MxJUnitRequest.BuilderException ex) {</span>
<span class="line-removed">179                     system.out().println(ex.getMessage());</span>
<span class="line-removed">180                     System.exit(1);</span>
<span class="line-removed">181                 }</span>
182             }
183             i++;
184         }
185 
















186         MxJUnitRequest request = builder.build();

187 
<span class="line-modified">188         if (System.getProperty(&quot;java.specification.version&quot;).compareTo(&quot;1.9&quot;) &gt;= 0) {</span>
<span class="line-modified">189             addExports(request.classes, system.out());</span>



190         }
191 
192         for (RunListener p : ServiceLoader.load(RunListener.class)) {
193             junitCore.addListener(p);
194         }
195 
196         Result result = runRequest(junitCore, system, config, request);
197         System.exit(result.wasSuccessful() ? 0 : 1);
198     }
199 
200     private static PrintStream openFile(JUnitSystem system, String name) {
201         File file = new File(name).getAbsoluteFile();
202         try {
203             FileOutputStream fos = new FileOutputStream(file);
204             return new PrintStream(fos, true);
205         } catch (FileNotFoundException e) {
206             system.out().println(&quot;Could not open &quot; + file + &quot; for writing: &quot; + e);
207             System.exit(1);
208             return null;
209         }
</pre>
<hr />
<pre>
268             request = new RepeatingRequest(request, config.repeatCount);
269         }
270 
271         if (config.enableTiming) {
272             Runtime.getRuntime().addShutdownHook(new Thread() {
273                 @Override
274                 public void run() {
275                     printTimings(timings);
276                 }
277             });
278         }
279 
280         Result result = junitCore.run(request);
281         for (Failure each : mxRequest.missingClasses) {
282             result.getFailures().add(each);
283         }
284 
285         return result;
286     }
287 
<span class="line-removed">288     private static final Pattern MODULE_PACKAGE_RE = Pattern.compile(&quot;([^/]+)/(.+)&quot;);</span>
<span class="line-removed">289 </span>
290     private static class Timing&lt;T&gt; implements Comparable&lt;Timing&lt;T&gt;&gt; {
291         final T subject;
292         final long value;
293 
294         Timing(T subject, long value) {
295             this.subject = subject;
296             this.value = value;
297         }
298 
299         public int compareTo(Timing&lt;T&gt; o) {
300             if (this.value &lt; o.value) {
301                 return -1;
302             }
303             if (this.value &gt; o.value) {
304                 return 1;
305             }
306             return 0;
307         }
308     }
309 
</pre>
<hr />
<pre>
326 
327             System.out.println();
328             System.out.printf(&quot;%d longest running test classes:%n&quot;, TIMINGS_TO_PRINT);
329             for (int i = 0; i &lt; TIMINGS_TO_PRINT &amp;&amp; i &lt; classTimes.size(); i++) {
330                 Timing&lt;Class&lt;?&gt;&gt; timing = classTimes.get(i);
331                 System.out.printf(&quot; %,10d ms    %s%n&quot;, timing.value, timing.subject.getName());
332             }
333             System.out.printf(&quot;%d longest running tests:%n&quot;, TIMINGS_TO_PRINT);
334             for (int i = 0; i &lt; TIMINGS_TO_PRINT &amp;&amp; i &lt; testTimes.size(); i++) {
335                 Timing&lt;Description&gt; timing = testTimes.get(i);
336                 System.out.printf(&quot; %,10d ms    %s%n&quot;, timing.value, timing.subject);
337             }
338             Object[] current = timings.getCurrentTestDuration();
339             if (current != null) {
340                 System.out.printf(&quot;Test %s not finished after %d ms%n&quot;, current[0], current[1]);
341             }
342 
343         }
344     }
345 
<span class="line-removed">346     /**</span>
<span class="line-removed">347      * Adds the super types of {@code cls} to {@code supertypes}.</span>
<span class="line-removed">348      */</span>
<span class="line-removed">349     private static void gatherSupertypes(Class&lt;?&gt; cls, Set&lt;Class&lt;?&gt;&gt; supertypes) {</span>
<span class="line-removed">350         if (!supertypes.contains(cls)) {</span>
<span class="line-removed">351             supertypes.add(cls);</span>
<span class="line-removed">352             Class&lt;?&gt; superclass = cls.getSuperclass();</span>
<span class="line-removed">353             if (superclass != null) {</span>
<span class="line-removed">354                 gatherSupertypes(superclass, supertypes);</span>
<span class="line-removed">355             }</span>
<span class="line-removed">356             for (Class&lt;?&gt; iface : cls.getInterfaces()) {</span>
<span class="line-removed">357                 gatherSupertypes(iface, supertypes);</span>
<span class="line-removed">358             }</span>
<span class="line-removed">359         }</span>
<span class="line-removed">360     }</span>
<span class="line-removed">361 </span>
<span class="line-removed">362     /**</span>
<span class="line-removed">363      * Updates modules specified in {@code AddExport} annotations on {@code classes} to export</span>
<span class="line-removed">364      * concealed packages to the annotation classes&#39; declaring modules.</span>
<span class="line-removed">365      */</span>
<span class="line-removed">366     private static void addExports(Set&lt;Class&lt;?&gt;&gt; classes, PrintStream out) {</span>
<span class="line-removed">367         Set&lt;Class&lt;?&gt;&gt; types = new HashSet&lt;&gt;();</span>
<span class="line-removed">368         for (Class&lt;?&gt; cls : classes) {</span>
<span class="line-removed">369             gatherSupertypes(cls, types);</span>
<span class="line-removed">370         }</span>
<span class="line-removed">371         for (Class&lt;?&gt; cls : types) {</span>
<span class="line-removed">372             Annotation[] annos = cls.getAnnotations();</span>
<span class="line-removed">373             for (Annotation a : annos) {</span>
<span class="line-removed">374                 Class&lt;? extends Annotation&gt; annotationType = a.annotationType();</span>
<span class="line-removed">375                 if (annotationType.getSimpleName().equals(&quot;AddExports&quot;)) {</span>
<span class="line-removed">376                     Optional&lt;String[]&gt; value = getElement(&quot;value&quot;, String[].class, a);</span>
<span class="line-removed">377                     if (value.isPresent()) {</span>
<span class="line-removed">378                         for (String export : value.get()) {</span>
<span class="line-removed">379                             Matcher m = MODULE_PACKAGE_RE.matcher(export);</span>
<span class="line-removed">380                             if (m.matches()) {</span>
<span class="line-removed">381                                 String moduleName = m.group(1);</span>
<span class="line-removed">382                                 String packageName = m.group(2);</span>
<span class="line-removed">383                                 JLModule module = JLModule.find(moduleName);</span>
<span class="line-removed">384                                 if (module == null) {</span>
<span class="line-removed">385                                     out.printf(&quot;%s: Cannot find module named %s specified in \&quot;AddExports\&quot; annotation: %s%n&quot;, cls.getName(), moduleName, a);</span>
<span class="line-removed">386                                 } else {</span>
<span class="line-removed">387                                     if (packageName.equals(&quot;*&quot;)) {</span>
<span class="line-removed">388                                         module.exportAllPackagesTo(JLModule.fromClass(cls));</span>
<span class="line-removed">389                                     } else {</span>
<span class="line-removed">390                                         module.addExports(packageName, JLModule.fromClass(cls));</span>
<span class="line-removed">391                                         module.addOpens(packageName, JLModule.fromClass(cls));</span>
<span class="line-removed">392                                     }</span>
<span class="line-removed">393                                 }</span>
<span class="line-removed">394                             } else {</span>
<span class="line-removed">395                                 out.printf(&quot;%s: Ignoring \&quot;AddExports\&quot; annotation with value not matching &lt;module&gt;/&lt;package&gt; pattern: %s%n&quot;, cls.getName(), a);</span>
<span class="line-removed">396                             }</span>
<span class="line-removed">397                         }</span>
<span class="line-removed">398                     } else {</span>
<span class="line-removed">399                         out.printf(&quot;%s: Ignoring \&quot;AddExports\&quot; annotation without `String value` element: %s%n&quot;, cls.getName(), a);</span>
<span class="line-removed">400                     }</span>
<span class="line-removed">401                 }</span>
<span class="line-removed">402             }</span>
<span class="line-removed">403         }</span>
<span class="line-removed">404     }</span>
<span class="line-removed">405 </span>
<span class="line-removed">406     /**</span>
<span class="line-removed">407      * Gets the value of the element named {@code name} of type {@code type} from {@code annotation}</span>
<span class="line-removed">408      * if present.</span>
<span class="line-removed">409      *</span>
<span class="line-removed">410      * @return the requested element value wrapped in an {@link Optional} or</span>
<span class="line-removed">411      *         {@link Optional#empty()} if {@code annotation} has no element named {@code name}</span>
<span class="line-removed">412      * @throws AssertionError if {@code annotation} has an element of the given name but whose type</span>
<span class="line-removed">413      *             is not {@code type} or if there&#39;s some problem reading the value via reflection</span>
<span class="line-removed">414      */</span>
<span class="line-removed">415     private static &lt;T&gt; Optional&lt;T&gt; getElement(String name, Class&lt;T&gt; type, Annotation annotation) {</span>
<span class="line-removed">416         Class&lt;? extends Annotation&gt; annotationType = annotation.annotationType();</span>
<span class="line-removed">417         Method valueAccessor;</span>
<span class="line-removed">418         try {</span>
<span class="line-removed">419             valueAccessor = annotationType.getMethod(name);</span>
<span class="line-removed">420             if (!valueAccessor.getReturnType().equals(type)) {</span>
<span class="line-removed">421                 throw new AssertionError(String.format(&quot;Element %s of %s is of type %s, not %s &quot;, name, annotationType.getName(), valueAccessor.getReturnType().getName(), type.getName()));</span>
<span class="line-removed">422             }</span>
<span class="line-removed">423         } catch (NoSuchMethodException e) {</span>
<span class="line-removed">424             return Optional.empty();</span>
<span class="line-removed">425         }</span>
<span class="line-removed">426         try {</span>
<span class="line-removed">427             return Optional.of(type.cast(valueAccessor.invoke(annotation)));</span>
<span class="line-removed">428         } catch (Exception e) {</span>
<span class="line-removed">429             throw new AssertionError(String.format(&quot;Could not read %s element from %s&quot;, name, annotation), e);</span>
<span class="line-removed">430         }</span>
<span class="line-removed">431     }</span>
<span class="line-removed">432 </span>
433     /**
434      * Expand any arguments starting with @ and return the resulting argument array.
435      *
436      * @return the expanded argument array
437      */
438     private static String[] expandArgs(String[] args) {
439         List&lt;String&gt; result = null;
440         for (int i = 0; i &lt; args.length; i++) {
441             String arg = args[i];
442             if (arg.length() &gt; 0 &amp;&amp; arg.charAt(0) == &#39;@&#39;) {
443                 if (result == null) {
444                     result = new ArrayList&lt;&gt;();
445                     for (int j = 0; j &lt; i; j++) {
446                         result.add(args[j]);
447                     }
448                     expandArg(arg.substring(1), result);
449                 }
450             } else if (result != null) {
451                 result.add(arg);
452             }
</pre>
</td>
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package com.oracle.mxtool.junit;
 24 
 25 import java.io.BufferedReader;
 26 import java.io.File;
 27 import java.io.FileNotFoundException;
 28 import java.io.FileOutputStream;
 29 import java.io.FileReader;
 30 import java.io.IOException;
 31 import java.io.PrintStream;


 32 import java.util.ArrayList;
 33 import java.util.Collections;

 34 import java.util.List;
 35 import java.util.Map;

 36 import java.util.ServiceLoader;
 37 import java.util.Set;
<span class="line-modified"> 38 import java.util.TreeSet;</span>

 39 
 40 import org.junit.internal.JUnitSystem;
 41 import org.junit.internal.RealSystem;
 42 import org.junit.runner.Description;
 43 import org.junit.runner.JUnitCore;
 44 import org.junit.runner.Request;
 45 import org.junit.runner.Result;
 46 import org.junit.runner.Runner;
 47 import org.junit.runner.notification.Failure;
 48 import org.junit.runner.notification.RunListener;
 49 import org.junit.runner.notification.RunNotifier;
 50 import org.junit.runners.ParentRunner;
 51 import org.junit.runners.model.RunnerScheduler;
 52 
 53 import junit.runner.Version;
 54 
 55 public class MxJUnitWrapper {
 56 
<span class="line-added"> 57     // Unit tests that start a JVM subprocess can use these system properties to</span>
<span class="line-added"> 58     // add --add-exports and --add-opens as necessary to the JVM command line.</span>
<span class="line-added"> 59     //</span>
<span class="line-added"> 60     // Known usages:</span>
<span class="line-added"> 61     // org.graalvm.compiler.test.SubprocessUtil.getPackageOpeningOptions()</span>
<span class="line-added"> 62     public static final String OPENED_PACKAGES_PROPERTY_NAME = &quot;com.oracle.mxtool.junit.opens&quot;;</span>
<span class="line-added"> 63     public static final String EXPORTED_PACKAGES_PROPERTY_NAME = &quot;com.oracle.mxtool.junit.exports&quot;;</span>
<span class="line-added"> 64 </span>
 65     public static class MxJUnitConfig {
 66 
 67         public boolean verbose = false;
 68         public boolean veryVerbose = false;
 69         public boolean enableTiming = false;
 70         public boolean failFast = false;
 71         public boolean color = false;
 72         public boolean eagerStackTrace = false;
 73         public boolean gcAfterTest = false;
 74         public boolean recordResults = false;
 75         public int repeatCount = 1;
 76     }
 77 
 78     private static class RepeatingRunner extends Runner {
 79 
 80         private final Runner parent;
 81         private int repeat;
 82 
 83         RepeatingRunner(Runner parent, int repeat) {
 84             this.parent = parent;
</pre>
<hr />
<pre>
122     /**
123      * Run the tests contained in the classes named in the &lt;code&gt;args&lt;/code&gt;. A single test method
124      * can be specified by adding #method after the class name. Only a single test can be run in
125      * this way. If all tests run successfully, exit with a status of 0. Otherwise exit with a
126      * status of 1. Write feedback while tests are running and write stack traces for all failed
127      * tests after the tests all complete.
128      *
129      * @param args names of classes in which to find tests to run
130      */
131     public static void main(String... args) {
132         JUnitSystem system = new RealSystem();
133         JUnitCore junitCore = new JUnitCore();
134         system.out().println(&quot;MxJUnitCore&quot;);
135         system.out().println(&quot;JUnit version &quot; + Version.id());
136 
137         MxJUnitRequest.Builder builder = new MxJUnitRequest.Builder();
138         MxJUnitConfig config = new MxJUnitConfig();
139 
140         String[] expandedArgs = expandArgs(args);
141         int i = 0;
<span class="line-added">142         List&lt;String&gt; testSpecs = new ArrayList&lt;&gt;();</span>
<span class="line-added">143         List&lt;String&gt; openPackagesSpecs = new ArrayList&lt;&gt;();</span>
144         while (i &lt; expandedArgs.length) {
145             String each = expandedArgs[i];
146             if (each.charAt(0) == &#39;-&#39;) {
147                 // command line arguments
148                 if (each.contentEquals(&quot;-JUnitVerbose&quot;)) {
149                     config.verbose = true;
<span class="line-added">150                     config.enableTiming = true;</span>
<span class="line-added">151                 } else if (each.contentEquals(&quot;-JUnitOpenPackages&quot;)) {</span>
<span class="line-added">152                     if (i + 1 &gt;= expandedArgs.length) {</span>
<span class="line-added">153                         system.out().println(&quot;Must include argument for -JUnitAddExports&quot;);</span>
<span class="line-added">154                         System.exit(1);</span>
<span class="line-added">155                     }</span>
<span class="line-added">156                     openPackagesSpecs.add(expandedArgs[++i]);</span>
157                 } else if (each.contentEquals(&quot;-JUnitVeryVerbose&quot;)) {
<span class="line-added">158                     config.verbose = true;</span>
159                     config.veryVerbose = true;
<span class="line-added">160                     config.enableTiming = true;</span>
161                 } else if (each.contentEquals(&quot;-JUnitFailFast&quot;)) {
162                     config.failFast = true;
163                 } else if (each.contentEquals(&quot;-JUnitEnableTiming&quot;)) {
164                     config.enableTiming = true;
165                 } else if (each.contentEquals(&quot;-JUnitColor&quot;)) {
166                     config.color = true;
167                 } else if (each.contentEquals(&quot;-JUnitEagerStackTrace&quot;)) {
168                     config.eagerStackTrace = true;
169                 } else if (each.contentEquals(&quot;-JUnitGCAfterTest&quot;)) {
170                     config.gcAfterTest = true;
171                 } else if (each.contentEquals(&quot;-JUnitRecordResults&quot;)) {
172                     config.recordResults = true;
173                 } else if (each.contentEquals(&quot;-JUnitRepeat&quot;)) {
174                     if (i + 1 &gt;= expandedArgs.length) {
175                         system.out().println(&quot;Must include argument for -JUnitRepeat&quot;);
176                         System.exit(1);
177                     }
178                     try {
179                         config.repeatCount = Integer.parseInt(expandedArgs[++i]);
180                     } catch (NumberFormatException e) {
181                         system.out().println(&quot;Expected integer argument for -JUnitRepeat. Found: &quot; + expandedArgs[i]);
182                         System.exit(1);
183                     }
184                 } else {
185                     system.out().println(&quot;Unknown command line argument: &quot; + each);
186                 }
187 
188             } else {
<span class="line-modified">189                 testSpecs.add(each);</span>






190             }
191             i++;
192         }
193 
<span class="line-added">194         ModuleSupport moduleSupport = new ModuleSupport(system.out());</span>
<span class="line-added">195         Set&lt;String&gt; opened = new TreeSet&lt;&gt;();</span>
<span class="line-added">196         Set&lt;String&gt; exported = new TreeSet&lt;&gt;();</span>
<span class="line-added">197         for (String spec : openPackagesSpecs) {</span>
<span class="line-added">198             moduleSupport.openPackages(spec, &quot;-JUnitOpenPackages&quot;, opened, exported);</span>
<span class="line-added">199         }</span>
<span class="line-added">200 </span>
<span class="line-added">201         for (String spec : testSpecs) {</span>
<span class="line-added">202             try {</span>
<span class="line-added">203                 builder.addTestSpec(spec);</span>
<span class="line-added">204             } catch (MxJUnitRequest.BuilderException ex) {</span>
<span class="line-added">205                 system.out().println(ex.getMessage());</span>
<span class="line-added">206                 System.exit(1);</span>
<span class="line-added">207             }</span>
<span class="line-added">208         }</span>
<span class="line-added">209 </span>
210         MxJUnitRequest request = builder.build();
<span class="line-added">211         moduleSupport.processAddExportsAnnotations(request.classes, opened, exported);</span>
212 
<span class="line-modified">213         if (!opened.isEmpty()) {</span>
<span class="line-modified">214             System.setProperty(OPENED_PACKAGES_PROPERTY_NAME, String.join(System.lineSeparator(), opened));</span>
<span class="line-added">215         }</span>
<span class="line-added">216         if (!exported.isEmpty()) {</span>
<span class="line-added">217             System.setProperty(EXPORTED_PACKAGES_PROPERTY_NAME, String.join(System.lineSeparator(), exported));</span>
218         }
219 
220         for (RunListener p : ServiceLoader.load(RunListener.class)) {
221             junitCore.addListener(p);
222         }
223 
224         Result result = runRequest(junitCore, system, config, request);
225         System.exit(result.wasSuccessful() ? 0 : 1);
226     }
227 
228     private static PrintStream openFile(JUnitSystem system, String name) {
229         File file = new File(name).getAbsoluteFile();
230         try {
231             FileOutputStream fos = new FileOutputStream(file);
232             return new PrintStream(fos, true);
233         } catch (FileNotFoundException e) {
234             system.out().println(&quot;Could not open &quot; + file + &quot; for writing: &quot; + e);
235             System.exit(1);
236             return null;
237         }
</pre>
<hr />
<pre>
296             request = new RepeatingRequest(request, config.repeatCount);
297         }
298 
299         if (config.enableTiming) {
300             Runtime.getRuntime().addShutdownHook(new Thread() {
301                 @Override
302                 public void run() {
303                     printTimings(timings);
304                 }
305             });
306         }
307 
308         Result result = junitCore.run(request);
309         for (Failure each : mxRequest.missingClasses) {
310             result.getFailures().add(each);
311         }
312 
313         return result;
314     }
315 


316     private static class Timing&lt;T&gt; implements Comparable&lt;Timing&lt;T&gt;&gt; {
317         final T subject;
318         final long value;
319 
320         Timing(T subject, long value) {
321             this.subject = subject;
322             this.value = value;
323         }
324 
325         public int compareTo(Timing&lt;T&gt; o) {
326             if (this.value &lt; o.value) {
327                 return -1;
328             }
329             if (this.value &gt; o.value) {
330                 return 1;
331             }
332             return 0;
333         }
334     }
335 
</pre>
<hr />
<pre>
352 
353             System.out.println();
354             System.out.printf(&quot;%d longest running test classes:%n&quot;, TIMINGS_TO_PRINT);
355             for (int i = 0; i &lt; TIMINGS_TO_PRINT &amp;&amp; i &lt; classTimes.size(); i++) {
356                 Timing&lt;Class&lt;?&gt;&gt; timing = classTimes.get(i);
357                 System.out.printf(&quot; %,10d ms    %s%n&quot;, timing.value, timing.subject.getName());
358             }
359             System.out.printf(&quot;%d longest running tests:%n&quot;, TIMINGS_TO_PRINT);
360             for (int i = 0; i &lt; TIMINGS_TO_PRINT &amp;&amp; i &lt; testTimes.size(); i++) {
361                 Timing&lt;Description&gt; timing = testTimes.get(i);
362                 System.out.printf(&quot; %,10d ms    %s%n&quot;, timing.value, timing.subject);
363             }
364             Object[] current = timings.getCurrentTestDuration();
365             if (current != null) {
366                 System.out.printf(&quot;Test %s not finished after %d ms%n&quot;, current[0], current[1]);
367             }
368 
369         }
370     }
371 























































































372     /**
373      * Expand any arguments starting with @ and return the resulting argument array.
374      *
375      * @return the expanded argument array
376      */
377     private static String[] expandArgs(String[] args) {
378         List&lt;String&gt; result = null;
379         for (int i = 0; i &lt; args.length; i++) {
380             String arg = args[i];
381             if (arg.length() &gt; 0 &amp;&amp; arg.charAt(0) == &#39;@&#39;) {
382                 if (result == null) {
383                     result = new ArrayList&lt;&gt;();
384                     for (int j = 0; j &lt; i; j++) {
385                         result.add(args[j]);
386                     }
387                     expandArg(arg.substring(1), result);
388                 }
389             } else if (result != null) {
390                 result.add(arg);
391             }
</pre>
</td>
</tr>
</table>
<center><a href="FindClassesByAnnotatedMethods.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextRunListener.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
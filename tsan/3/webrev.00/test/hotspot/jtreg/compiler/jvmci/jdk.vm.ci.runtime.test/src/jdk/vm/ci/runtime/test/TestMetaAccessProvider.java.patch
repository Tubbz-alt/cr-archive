diff a/test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TestMetaAccessProvider.java b/test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TestMetaAccessProvider.java
--- a/test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TestMetaAccessProvider.java
+++ b/test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TestMetaAccessProvider.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -26,11 +26,11 @@
  * @requires vm.jvmci
  * @library ../../../../../
  * @modules jdk.internal.vm.ci/jdk.vm.ci.meta
  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
  *          java.base/jdk.internal.misc
- * @run junit/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -Djvmci.Compiler=null jdk.vm.ci.runtime.test.TestMetaAccessProvider
+ * @run junit/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler jdk.vm.ci.runtime.test.TestMetaAccessProvider
  */
 
 package jdk.vm.ci.runtime.test;
 
 import jdk.vm.ci.meta.DeoptimizationAction;
@@ -66,20 +66,26 @@
                     metaAccess.encodeDeoptActionAndReason(DEOPT_ACTION, DEOPT_REASON, DEBUG_IDS[1]).asInt(),
                     metaAccess.encodeDeoptActionAndReason(DEOPT_ACTION, DEOPT_REASON, DEBUG_IDS[2]).asInt(),
                     metaAccess.encodeDeoptActionAndReason(DEOPT_ACTION, DEOPT_REASON, DEBUG_IDS[3]).asInt()
     };
 
+    private static boolean isUnsafeAnoymous(ResolvedJavaType type) {
+        return type.getHostClass() != null;
+    }
+
     @Test
     public void lookupJavaTypeTest() {
         for (Class<?> c : classes) {
             ResolvedJavaType type = metaAccess.lookupJavaType(c);
             assertNotNull(c.toString(), type);
-            assertEquals(c.toString(), type.getName(), toInternalName(c.getName()));
-            assertEquals(c.toString(), type.getName(), toInternalName(type.toJavaName()));
-            assertEquals(c.toString(), c.getName(), type.toClassName());
-            if (!type.isArray()) {
-                assertEquals(c.toString(), c.getName(), type.toJavaName());
+            if (!isUnsafeAnoymous(type)) {
+                assertEquals(c.toString(), type.getName(), toInternalName(c.getName()));
+                assertEquals(c.toString(), type.getName(), toInternalName(type.toJavaName()));
+                assertEquals(c.toString(), c.getName(), type.toClassName());
+                if (!type.isArray()) {
+                    assertEquals(c.toString(), c.getName(), type.toJavaName());
+                }
             }
         }
     }
 
     @Test(expected = IllegalArgumentException.class)
@@ -90,11 +96,13 @@
     @Test
     public void lookupJavaTypesTest() {
         ResolvedJavaType[] result = metaAccess.lookupJavaTypes(classes.toArray(new Class<?>[classes.size()]));
         int counter = 0;
         for (Class<?> aClass : classes) {
-            assertEquals("Unexpected javaType: " + result[counter] + " while expecting of class: " + aClass, result[counter].toClassName(), aClass.getName());
+            if (!isUnsafeAnoymous(result[counter])) {
+                assertEquals("Unexpected javaType: " + result[counter] + " while expecting of class: " + aClass, result[counter].toClassName(), aClass.getName());
+            }
             counter++;
         }
     }
 
     @Test(expected = NullPointerException.class)

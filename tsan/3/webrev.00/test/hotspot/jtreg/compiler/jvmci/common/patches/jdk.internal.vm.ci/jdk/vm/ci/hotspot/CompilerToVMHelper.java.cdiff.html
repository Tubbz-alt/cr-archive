<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/hotspot/jtreg/compiler/jvmci/common/patches/jdk.internal.vm.ci/jdk/vm/ci/hotspot/CompilerToVMHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../CTVMUtilities.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="PublicMetaspaceWrapperObject.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/jvmci/common/patches/jdk.internal.vm.ci/jdk/vm/ci/hotspot/CompilerToVMHelper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,18 ***</span>
<span class="line-new-header">--- 26,22 ---</span>
  import jdk.vm.ci.code.InstalledCode;
  import jdk.vm.ci.code.InvalidInstalledCodeException;
  import jdk.vm.ci.code.TargetDescription;
  import jdk.vm.ci.code.stack.InspectedFrameVisitor;
  import jdk.vm.ci.meta.ConstantPool;
<span class="line-added">+ import jdk.vm.ci.meta.JavaConstant;</span>
  import jdk.vm.ci.meta.ResolvedJavaMethod;
<span class="line-added">+ import jdk.vm.ci.meta.MetaAccessProvider;</span>
<span class="line-added">+ import jdk.vm.ci.runtime.JVMCI;</span>
  import java.lang.reflect.Executable;
  
  /**
   * A simple &quot;proxy&quot; class to get test access to CompilerToVM package-private methods
   */
  public class CompilerToVMHelper {
      public static final CompilerToVM CTVM = new CompilerToVM();
<span class="line-added">+     private static final MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();</span>
  
      public static byte[] getBytecode(HotSpotResolvedJavaMethod method) {
          return CTVM.getBytecode((HotSpotResolvedJavaMethodImpl)method);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,12 ***</span>
      public static boolean methodIsIgnoredBySecurityStackWalk(HotSpotResolvedJavaMethod method) {
          return CTVM.methodIsIgnoredBySecurityStackWalk((HotSpotResolvedJavaMethodImpl)method);
      }
  
      public static HotSpotResolvedObjectType lookupType(String name,
<span class="line-modified">!             Class&lt;?&gt; accessingClass, boolean resolve) throws ClassNotFoundException {</span>
<span class="line-modified">!         return CTVM.lookupType(name, accessingClass, resolve);</span>
      }
  
      public static HotSpotResolvedObjectType lookupTypeHelper(String name,
              Class&lt;?&gt; accessingClass, boolean resolve) {
          try {
<span class="line-new-header">--- 82,16 ---</span>
      public static boolean methodIsIgnoredBySecurityStackWalk(HotSpotResolvedJavaMethod method) {
          return CTVM.methodIsIgnoredBySecurityStackWalk((HotSpotResolvedJavaMethodImpl)method);
      }
  
      public static HotSpotResolvedObjectType lookupType(String name,
<span class="line-modified">!             Class&lt;?&gt; accessClass, boolean resolve) throws ClassNotFoundException {</span>
<span class="line-modified">!         if (accessClass == null) {</span>
<span class="line-added">+             throw new NullPointerException();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         HotSpotResolvedObjectTypeImpl accessingClass = (HotSpotResolvedObjectTypeImpl) metaAccess.lookupJavaType(accessClass);</span>
<span class="line-added">+         return (HotSpotResolvedObjectType) CTVM.lookupType(name, accessingClass, resolve);</span>
      }
  
      public static HotSpotResolvedObjectType lookupTypeHelper(String name,
              Class&lt;?&gt; accessingClass, boolean resolve) {
          try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,16 ***</span>
          } catch (ClassNotFoundException e) {
              throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);
          }
      }
  
<span class="line-removed">-     public static Object resolveConstantInPool(ConstantPool constantPool, int cpi) {</span>
<span class="line-removed">-         return CTVM.resolveConstantInPool((HotSpotConstantPool) constantPool, cpi);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      public static Object resolvePossiblyCachedConstantInPool(ConstantPool constantPool, int cpi) {
<span class="line-modified">!         return CTVM.resolvePossiblyCachedConstantInPool((HotSpotConstantPool) constantPool, cpi);</span>
      }
  
      public static int lookupNameAndTypeRefIndexInPool(ConstantPool constantPool, int cpi) {
          return CTVM.lookupNameAndTypeRefIndexInPool((HotSpotConstantPool) constantPool, cpi);
      }
<span class="line-new-header">--- 99,13 ---</span>
          } catch (ClassNotFoundException e) {
              throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);
          }
      }
  
      public static Object resolvePossiblyCachedConstantInPool(ConstantPool constantPool, int cpi) {
<span class="line-modified">!         DirectHotSpotObjectConstantImpl obj = (DirectHotSpotObjectConstantImpl) CTVM.resolvePossiblyCachedConstantInPool((HotSpotConstantPool) constantPool, cpi);</span>
<span class="line-added">+         return obj.object;</span>
      }
  
      public static int lookupNameAndTypeRefIndexInPool(ConstantPool constantPool, int cpi) {
          return CTVM.lookupNameAndTypeRefIndexInPool((HotSpotConstantPool) constantPool, cpi);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 156,11 ***</span>
          return CTVM.lookupAppendixInPool((HotSpotConstantPool) constantPool, cpi);
      }
  
      public static int installCode(TargetDescription target,
              HotSpotCompiledCode compiledCode, InstalledCode code, HotSpotSpeculationLog speculationLog) {
<span class="line-modified">!         return CTVM.installCode(target, compiledCode, code, speculationLog);</span>
      }
  
      public static int getMetadata(TargetDescription target,
              HotSpotCompiledCode compiledCode, HotSpotMetaData metaData) {
          return CTVM.getMetadata(target, compiledCode, metaData);
<span class="line-new-header">--- 161,20 ---</span>
          return CTVM.lookupAppendixInPool((HotSpotConstantPool) constantPool, cpi);
      }
  
      public static int installCode(TargetDescription target,
              HotSpotCompiledCode compiledCode, InstalledCode code, HotSpotSpeculationLog speculationLog) {
<span class="line-modified">!         byte[] speculations;</span>
<span class="line-added">+         long failedSpeculationsAddress;</span>
<span class="line-added">+         if (speculationLog != null) {</span>
<span class="line-added">+             speculations = speculationLog.getFlattenedSpeculations(true);</span>
<span class="line-added">+             failedSpeculationsAddress = speculationLog.getFailedSpeculationsAddress();</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             speculations = new byte[0];</span>
<span class="line-added">+             failedSpeculationsAddress = 0L;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return CTVM.installCode(target, compiledCode, code, failedSpeculationsAddress, speculations);</span>
      }
  
      public static int getMetadata(TargetDescription target,
              HotSpotCompiledCode compiledCode, HotSpotMetaData metaData) {
          return CTVM.getMetadata(target, compiledCode, metaData);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,13 ***</span>
      public static StackTraceElement getStackTraceElement(
              HotSpotResolvedJavaMethod method, int bci) {
          return CTVM.getStackTraceElement((HotSpotResolvedJavaMethodImpl)method, bci);
      }
  
<span class="line-modified">!     public static Object executeInstalledCode(Object[] args,</span>
<span class="line-modified">!             InstalledCode installedCode) throws InvalidInstalledCodeException {</span>
<span class="line-modified">!         return CTVM.executeInstalledCode(args, installedCode);</span>
      }
  
      public static long[] getLineNumberTable(HotSpotResolvedJavaMethod method) {
          return CTVM.getLineNumberTable((HotSpotResolvedJavaMethodImpl)method);
      }
<span class="line-new-header">--- 220,13 ---</span>
      public static StackTraceElement getStackTraceElement(
              HotSpotResolvedJavaMethod method, int bci) {
          return CTVM.getStackTraceElement((HotSpotResolvedJavaMethodImpl)method, bci);
      }
  
<span class="line-modified">!     public static Object executeHotSpotNmethod(Object[] args,</span>
<span class="line-modified">!             HotSpotNmethod nmethodMirror) throws InvalidInstalledCodeException {</span>
<span class="line-modified">!         return CTVM.executeHotSpotNmethod(args, nmethodMirror);</span>
      }
  
      public static long[] getLineNumberTable(HotSpotResolvedJavaMethod method) {
          return CTVM.getLineNumberTable((HotSpotResolvedJavaMethodImpl)method);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 231,12 ***</span>
  
      public static void reprofile(HotSpotResolvedJavaMethod method) {
          CTVM.reprofile((HotSpotResolvedJavaMethodImpl)method);
      }
  
<span class="line-modified">!     public static void invalidateInstalledCode(InstalledCode installedCode) {</span>
<span class="line-modified">!         CTVM.invalidateInstalledCode(installedCode);</span>
      }
  
      public static long[] collectCounters() {
          return CTVM.collectCounters();
      }
<span class="line-new-header">--- 245,12 ---</span>
  
      public static void reprofile(HotSpotResolvedJavaMethod method) {
          CTVM.reprofile((HotSpotResolvedJavaMethodImpl)method);
      }
  
<span class="line-modified">!     public static void invalidateHotSpotNmethod(HotSpotNmethod nmethodMirror) {</span>
<span class="line-modified">!         CTVM.invalidateHotSpotNmethod(nmethodMirror);</span>
      }
  
      public static long[] collectCounters() {
          return CTVM.collectCounters();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 280,42 ***</span>
      public static boolean shouldDebugNonSafepoints() {
          return CTVM.shouldDebugNonSafepoints();
      }
  
      public static void writeDebugOutput(byte[] bytes, int offset, int length) {
<span class="line-modified">!         CTVM.writeDebugOutput(bytes, offset, length);</span>
      }
  
      public static void flushDebugOutput() {
          CTVM.flushDebugOutput();
      }
  
<span class="line-modified">!     public static HotSpotResolvedJavaMethod getResolvedJavaMethod(Object base,</span>
              long displacement) {
          return CTVM.getResolvedJavaMethod(base, displacement);
      }
  
<span class="line-modified">!     public static HotSpotConstantPool getConstantPool(Object object) {</span>
          return CTVM.getConstantPool(object);
      }
  
<span class="line-modified">!     public static HotSpotResolvedObjectType getResolvedJavaType(Object base,</span>
              long displacement, boolean compressed) {
          return CTVM.getResolvedJavaType(base, displacement, compressed);
      }
  
      public static long getMetaspacePointer(Object o) {
<span class="line-modified">!         return ((MetaspaceWrapperObject) o).getMetaspacePointer();</span>
      }
  
      public static Class&lt;?&gt; CompilerToVMClass() {
          return CompilerToVM.class;
      }
  
<span class="line-modified">!     public static Class&lt;?&gt; getMirror(HotSpotResolvedObjectType type) {</span>
<span class="line-modified">!         return ((HotSpotResolvedJavaType) type).mirror();</span>
      }
  
      public static HotSpotResolvedObjectType fromObjectClass(Class&lt;?&gt; theClass) {
<span class="line-modified">!         return HotSpotResolvedObjectTypeImpl.fromObjectClass(theClass);</span>
      }
  }
<span class="line-new-header">--- 294,53 ---</span>
      public static boolean shouldDebugNonSafepoints() {
          return CTVM.shouldDebugNonSafepoints();
      }
  
      public static void writeDebugOutput(byte[] bytes, int offset, int length) {
<span class="line-modified">!         CTVM.writeDebugOutput(bytes, offset, length, true, true);</span>
      }
  
      public static void flushDebugOutput() {
          CTVM.flushDebugOutput();
      }
  
<span class="line-modified">!     public static HotSpotResolvedJavaMethod getResolvedJavaMethod(HotSpotObjectConstantImpl base,</span>
              long displacement) {
          return CTVM.getResolvedJavaMethod(base, displacement);
      }
  
<span class="line-modified">!     public static HotSpotConstantPool getConstantPool(MetaspaceObject object) {</span>
          return CTVM.getConstantPool(object);
      }
  
<span class="line-modified">!     public static HotSpotResolvedObjectType getResolvedJavaType(MetaspaceObject base,</span>
              long displacement, boolean compressed) {
          return CTVM.getResolvedJavaType(base, displacement, compressed);
      }
  
      public static long getMetaspacePointer(Object o) {
<span class="line-modified">!         return ((MetaspaceObject) o).getMetaspacePointer();</span>
      }
  
      public static Class&lt;?&gt; CompilerToVMClass() {
          return CompilerToVM.class;
      }
  
<span class="line-modified">!     public static JavaConstant getJavaMirror(HotSpotResolvedObjectType type) {</span>
<span class="line-modified">!         return ((HotSpotResolvedJavaType) type).getJavaMirror();</span>
      }
  
      public static HotSpotResolvedObjectType fromObjectClass(Class&lt;?&gt; theClass) {
<span class="line-modified">!           return (HotSpotResolvedObjectType) metaAccess.lookupJavaType(theClass);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public static InstalledCode getInstalledCode(ResolvedJavaMethod method, String name, long address, long entryPoint) {</span>
<span class="line-added">+         return new InstalledCodeStub((HotSpotResolvedJavaMethodImpl) method, name, address, entryPoint);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     private static class InstalledCodeStub extends HotSpotNmethod {</span>
<span class="line-added">+         private InstalledCodeStub(HotSpotResolvedJavaMethodImpl method, String name, long address, long entryPoint) {</span>
<span class="line-added">+             super(method, name, false, 0);</span>
<span class="line-added">+             this.address = address;</span>
<span class="line-added">+             this.entryPoint = entryPoint;</span>
<span class="line-added">+         }</span>
      }
  }
</pre>
<center><a href="../../../../../../CTVMUtilities.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="PublicMetaspaceWrapperObject.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/test/hotspot/jtreg/compiler/jvmci/compilerToVM/ResolvePossiblyCachedConstantInPoolTest.java b/test/hotspot/jtreg/compiler/jvmci/compilerToVM/ResolvePossiblyCachedConstantInPoolTest.java
--- a/test/hotspot/jtreg/compiler/jvmci/compilerToVM/ResolvePossiblyCachedConstantInPoolTest.java
+++ b/test/hotspot/jtreg/compiler/jvmci/compilerToVM/ResolvePossiblyCachedConstantInPoolTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,10 +22,11 @@
  */
 
 /*
  * @test
  * @bug 8138708
+ * @bug 8136421
  * @requires vm.jvmci
  * @library /test/lib /
  * @library ../common/patches
  * @modules java.base/jdk.internal.access
  *          java.base/jdk.internal.reflect
@@ -38,11 +39,11 @@
  * @build jdk.internal.vm.ci/jdk.vm.ci.hotspot.CompilerToVMHelper sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
  *                                sun.hotspot.WhiteBox$WhiteBoxPermission
  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions
  *                   -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI
- *                   -Djvmci.Compiler=null
+ *                   -XX:-UseJVMCICompiler
  *                   compiler.jvmci.compilerToVM.ResolvePossiblyCachedConstantInPoolTest
  */
 
 package compiler.jvmci.compilerToVM;
 
@@ -52,27 +53,38 @@
 import compiler.jvmci.compilerToVM.ConstantPoolTestsHelper.DummyClasses;
 import jdk.test.lib.Asserts;
 import jdk.vm.ci.hotspot.CompilerToVMHelper;
 import jdk.vm.ci.meta.ConstantPool;
 
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
 import java.util.HashMap;
 import java.util.Map;
 
+import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_METHODHANDLE;
+import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_METHODTYPE;
 import static compiler.jvmci.compilerToVM.ConstantPoolTestCase.ConstantTypes.CONSTANT_STRING;
 
 /**
  * Test for {@code jdk.vm.ci.hotspot.CompilerToVM.resolvePossiblyCachedConstantInPool} method
  */
 public class ResolvePossiblyCachedConstantInPoolTest {
 
     public static void main(String[] args) throws Exception {
         Map<ConstantTypes, Validator> typeTests = new HashMap<>();
         typeTests.put(CONSTANT_STRING, ResolvePossiblyCachedConstantInPoolTest::validateString);
+        typeTests.put(CONSTANT_METHODHANDLE, ResolvePossiblyCachedConstantInPoolTest::validateMethodHandle);
+        typeTests.put(CONSTANT_METHODTYPE, ResolvePossiblyCachedConstantInPoolTest::validateMethodType);
         ConstantPoolTestCase testCase = new ConstantPoolTestCase(typeTests);
-        // The next "Class.forName" is here for the following reason.
-        // When class is initialized, constant pool cache is available.
-        // This method works only with cached constant pool.
+        testCase.test();
+        // The next "Class.forName" and repeating "testCase.test()"
+        // are here for the following reason.
+        // The first test run is without dummy class initialization,
+        // which means no constant pool cache exists.
+        // The second run is with initialized class (with constant pool cache available).
+        // Some CompilerToVM methods require different input
+        // depending on whether CP cache exists or not.
         for (DummyClasses dummy : DummyClasses.values()) {
             Class.forName(dummy.klass.getName());
         }
         testCase.test();
     }
@@ -99,6 +111,42 @@
             stringToRefer = null; // tested method returns null for cached empty strings
         }
         String msg = String.format("Wrong string accessed by %sconstant pool index %d", cached, index);
         Asserts.assertEQ(stringToRefer, stringToVerify, msg);
     }
+
+    private static final String NOT_NULL_MSG
+            = "Object returned by resolvePossiblyCachedConstantInPool method should not be null";
+
+
+    private static void validateMethodHandle(ConstantPool constantPoolCTVM,
+                                             ConstantTypes cpType,
+                                             DummyClasses dummyClass,
+                                             int index) {
+        Object constantInPool = CompilerToVMHelper.resolvePossiblyCachedConstantInPool(constantPoolCTVM, index);
+        String msg = String.format("%s for index %d", NOT_NULL_MSG, index);
+        Asserts.assertNotNull(constantInPool, msg);
+        if (!(constantInPool instanceof MethodHandle)) {
+            msg = String.format("Wrong constant pool entry accessed by index"
+                                        + " %d: %s, but should be subclass of %s",
+                                index,
+                                constantInPool.getClass(),
+                                MethodHandle.class.getName());
+            throw new AssertionError(msg);
+        }
+    }
+
+    private static void validateMethodType(ConstantPool constantPoolCTVM,
+                                           ConstantTypes cpType,
+                                           DummyClasses dummyClass,
+                                           int index) {
+        Object constantInPool = CompilerToVMHelper.resolvePossiblyCachedConstantInPool(constantPoolCTVM, index);
+        String msg = String.format("%s for index %d", NOT_NULL_MSG, index);
+        Asserts.assertNotNull(constantInPool, msg);
+        Class mtToVerify = constantInPool.getClass();
+        Class mtToRefer = MethodType.class;
+        msg = String.format("Wrong method type class accessed by"
+                                    + " constant pool index %d",
+                            index);
+        Asserts.assertEQ(mtToRefer, mtToVerify, msg);
+    }
 }

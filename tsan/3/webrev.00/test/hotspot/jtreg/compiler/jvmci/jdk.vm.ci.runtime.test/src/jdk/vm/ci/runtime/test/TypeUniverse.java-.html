<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TypeUniverse.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.runtime.test;
 24 
 25 import jdk.internal.misc.Unsafe;
 26 import jdk.vm.ci.meta.ConstantReflectionProvider;
 27 import jdk.vm.ci.meta.JavaConstant;
 28 import jdk.vm.ci.meta.MetaAccessProvider;
 29 import jdk.vm.ci.meta.ResolvedJavaField;
 30 import jdk.vm.ci.meta.ResolvedJavaType;
 31 import jdk.vm.ci.runtime.JVMCI;
 32 import org.junit.Test;
 33 
 34 import java.io.Serializable;
 35 import java.lang.reflect.Array;
 36 import java.lang.reflect.Field;
 37 import java.lang.reflect.Method;
 38 import java.util.AbstractCollection;
 39 import java.util.AbstractList;
 40 import java.util.ArrayDeque;
 41 import java.util.ArrayList;
 42 import java.util.Collection;
 43 import java.util.Collections;
 44 import java.util.HashMap;
 45 import java.util.HashSet;
 46 import java.util.IdentityHashMap;
 47 import java.util.LinkedHashMap;
 48 import java.util.LinkedList;
 49 import java.util.List;
 50 import java.util.Map;
 51 import java.util.Queue;
 52 import java.util.Set;
 53 import java.util.TreeMap;
 54 import java.util.stream.Collectors;
 55 
 56 import static java.lang.reflect.Modifier.isFinal;
 57 import static java.lang.reflect.Modifier.isStatic;
 58 
 59 /**
 60  * Context for type related tests.
 61  */
 62 public class TypeUniverse {
 63 
 64     public static final Unsafe unsafe;
 65     public static final double JAVA_VERSION = Double.valueOf(System.getProperty(&quot;java.specification.version&quot;));
 66 
 67     public static final MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();
 68     public static final ConstantReflectionProvider constantReflection = JVMCI.getRuntime().getHostJVMCIBackend().getConstantReflection();
 69     public static final Collection&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;&gt;();
 70     public static final Set&lt;ResolvedJavaType&gt; javaTypes;
 71     public static final Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; arrayClasses = new HashMap&lt;&gt;();
 72 
 73     private static List&lt;ConstantValue&gt; constants;
 74 
 75     public class InnerClass {
 76 
 77     }
 78 
 79     public static class InnerStaticClass {
 80 
 81     }
 82 
 83     public static final class InnerStaticFinalClass {
 84 
 85     }
 86 
 87     private class PrivateInnerClass {
 88 
 89     }
 90 
 91     protected class ProtectedInnerClass {
 92 
 93     }
 94 
 95     static {
 96         Unsafe theUnsafe = null;
 97         try {
 98             theUnsafe = Unsafe.getUnsafe();
 99         } catch (Exception e) {
100             try {
101                 Field theUnsafeField = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
102                 theUnsafeField.setAccessible(true);
103                 theUnsafe = (Unsafe) theUnsafeField.get(null);
104             } catch (Exception e1) {
105                 throw (InternalError) new InternalError(&quot;unable to initialize unsafe&quot;).initCause(e1);
106             }
107         }
108         unsafe = theUnsafe;
109 
110         Class&lt;?&gt;[] initialClasses = {void.class, boolean.class, byte.class, short.class, char.class, int.class, float.class, long.class, double.class, Object.class, Class.class, boolean[].class,
111                         byte[].class, short[].class, char[].class, int[].class, float[].class, long[].class, double[].class, Object[].class, Class[].class, List[].class, boolean[][].class,
112                         byte[][].class, short[][].class, char[][].class, int[][].class, float[][].class, long[][].class, double[][].class, Object[][].class, Class[][].class, List[][].class,
113                         ClassLoader.class, String.class, Serializable.class, Cloneable.class, Test.class, TestMetaAccessProvider.class, List.class, Collection.class, Map.class, Queue.class,
114                         HashMap.class, LinkedHashMap.class, IdentityHashMap.class, AbstractCollection.class, AbstractList.class, ArrayList.class, InnerClass.class, InnerStaticClass.class,
115                         InnerStaticFinalClass.class, PrivateInnerClass.class, ProtectedInnerClass.class};
116         for (Class&lt;?&gt; c : initialClasses) {
117             addClass(c);
118         }
119 
120         javaTypes = Collections.unmodifiableSet(classes.stream().map(c -&gt; metaAccess.lookupJavaType(c)).collect(Collectors.toSet()));
121     }
122 
123     static class ConstantsUniverse {
124         static final Object[] ARRAYS = classes.stream().map(c -&gt; c != void.class &amp;&amp; !c.isArray() ? Array.newInstance(c, 42) : null).filter(o -&gt; o != null).collect(Collectors.toList()).toArray();
125         static final Object CONST1 = new ArrayList&lt;&gt;();
126         static final Object CONST2 = new ArrayList&lt;&gt;();
127         static final Object CONST3 = new IdentityHashMap&lt;&gt;();
128         static final Object CONST4 = new LinkedHashMap&lt;&gt;();
129         static final Object CONST5 = new TreeMap&lt;&gt;();
130         static final Object CONST6 = new ArrayDeque&lt;&gt;();
131         static final Object CONST7 = new LinkedList&lt;&gt;();
132         static final Object CONST8 = &quot;a string&quot;;
133         static final Object CONST9 = 42;
134         static final Object CONST10 = String.class;
135         static final Object CONST11 = String[].class;
136     }
137 
138     public static List&lt;ConstantValue&gt; constants() {
139         if (constants == null) {
140             List&lt;ConstantValue&gt; res = readConstants(JavaConstant.class);
141             res.addAll(readConstants(ConstantsUniverse.class));
142             constants = res;
143         }
144         return constants;
145     }
146 
147     public static class ConstantValue {
148         public final String name;
149         public final JavaConstant value;
150         public final Object boxed;
151 
152         public ConstantValue(String name, JavaConstant value, Object boxed) {
153             this.name = name;
154             this.value = value;
155             this.boxed = boxed;
156         }
157 
158         @Override
159         public String toString() {
160             return name + &quot;=&quot; + value;
161         }
162 
163         public String getSimpleName() {
164             return name.substring(name.lastIndexOf(&#39;.&#39;) + 1);
165         }
166     }
167 
168     /**
169      * Reads the value of all {@code static final} fields from a given class into an array of
170      * {@link ConstantValue}s.
171      */
172     public static List&lt;ConstantValue&gt; readConstants(Class&lt;?&gt; fromClass) {
173         try {
174             List&lt;ConstantValue&gt; res = new ArrayList&lt;&gt;();
175             for (Field field : fromClass.getDeclaredFields()) {
176                 if (isStatic(field.getModifiers()) &amp;&amp; isFinal(field.getModifiers())) {
177                     ResolvedJavaField javaField = metaAccess.lookupJavaField(field);
178                     Object boxed = field.get(null);
179                     if (boxed instanceof JavaConstant) {
180                         res.add(new ConstantValue(javaField.format(&quot;%H.%n&quot;), (JavaConstant) boxed, boxed));
181                     } else {
182                         JavaConstant value = constantReflection.readFieldValue(javaField, null);
183                         if (value != null) {
184                             res.add(new ConstantValue(javaField.format(&quot;%H.%n&quot;), value, boxed));
185                             if (boxed instanceof Object[]) {
186                                 Object[] arr = (Object[]) boxed;
187                                 for (int i = 0; i &lt; arr.length; i++) {
188                                     JavaConstant element = constantReflection.readArrayElement(value, i);
189                                     if (element != null) {
190                                         res.add(new ConstantValue(javaField.format(&quot;%H.%n[&quot; + i + &quot;]&quot;), element, arr[i]));
191                                     }
192                                 }
193                             }
194                         }
195                     }
196                 }
197             }
198             return res;
199         } catch (Exception e) {
200             throw new AssertionError(e);
201         }
202     }
203 
204     public synchronized Class&lt;?&gt; getArrayClass(Class&lt;?&gt; componentType) {
205         Class&lt;?&gt; arrayClass = arrayClasses.get(componentType);
206         if (arrayClass == null) {
207             arrayClass = Array.newInstance(componentType, 0).getClass();
208             arrayClasses.put(componentType, arrayClass);
209         }
210         return arrayClass;
211     }
212 
213     public static int dimensions(Class&lt;?&gt; c) {
214         if (c.getComponentType() != null) {
215             return 1 + dimensions(c.getComponentType());
216         }
217         return 0;
218     }
219 
220     private static void addClass(Class&lt;?&gt; c) {
221         if (classes.add(c)) {
222             if (c.getSuperclass() != null) {
223                 addClass(c.getSuperclass());
224             }
225             for (Class&lt;?&gt; sc : c.getInterfaces()) {
226                 addClass(sc);
227             }
228             for (Class&lt;?&gt; dc : c.getDeclaredClasses()) {
229                 addClass(dc);
230             }
231             for (Method m : c.getDeclaredMethods()) {
232                 addClass(m.getReturnType());
233                 for (Class&lt;?&gt; p : m.getParameterTypes()) {
234                     addClass(p);
235                 }
236             }
237 
238             if (c != void.class &amp;&amp; dimensions(c) &lt; 2) {
239                 Class&lt;?&gt; arrayClass = Array.newInstance(c, 0).getClass();
240                 arrayClasses.put(c, arrayClass);
241                 addClass(arrayClass);
242             }
243         }
244     }
245 }
    </pre>
  </body>
</html>
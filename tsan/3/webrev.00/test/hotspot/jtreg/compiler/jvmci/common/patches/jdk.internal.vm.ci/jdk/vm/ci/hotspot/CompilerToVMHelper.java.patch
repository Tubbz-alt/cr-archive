diff a/test/hotspot/jtreg/compiler/jvmci/common/patches/jdk.internal.vm.ci/jdk/vm/ci/hotspot/CompilerToVMHelper.java b/test/hotspot/jtreg/compiler/jvmci/common/patches/jdk.internal.vm.ci/jdk/vm/ci/hotspot/CompilerToVMHelper.java
--- a/test/hotspot/jtreg/compiler/jvmci/common/patches/jdk.internal.vm.ci/jdk/vm/ci/hotspot/CompilerToVMHelper.java
+++ b/test/hotspot/jtreg/compiler/jvmci/common/patches/jdk.internal.vm.ci/jdk/vm/ci/hotspot/CompilerToVMHelper.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -26,18 +26,22 @@
 import jdk.vm.ci.code.InstalledCode;
 import jdk.vm.ci.code.InvalidInstalledCodeException;
 import jdk.vm.ci.code.TargetDescription;
 import jdk.vm.ci.code.stack.InspectedFrameVisitor;
 import jdk.vm.ci.meta.ConstantPool;
+import jdk.vm.ci.meta.JavaConstant;
 import jdk.vm.ci.meta.ResolvedJavaMethod;
+import jdk.vm.ci.meta.MetaAccessProvider;
+import jdk.vm.ci.runtime.JVMCI;
 import java.lang.reflect.Executable;
 
 /**
  * A simple "proxy" class to get test access to CompilerToVM package-private methods
  */
 public class CompilerToVMHelper {
     public static final CompilerToVM CTVM = new CompilerToVM();
+    private static final MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();
 
     public static byte[] getBytecode(HotSpotResolvedJavaMethod method) {
         return CTVM.getBytecode((HotSpotResolvedJavaMethodImpl)method);
     }
 
@@ -78,12 +82,16 @@
     public static boolean methodIsIgnoredBySecurityStackWalk(HotSpotResolvedJavaMethod method) {
         return CTVM.methodIsIgnoredBySecurityStackWalk((HotSpotResolvedJavaMethodImpl)method);
     }
 
     public static HotSpotResolvedObjectType lookupType(String name,
-            Class<?> accessingClass, boolean resolve) throws ClassNotFoundException {
-        return CTVM.lookupType(name, accessingClass, resolve);
+            Class<?> accessClass, boolean resolve) throws ClassNotFoundException {
+        if (accessClass == null) {
+            throw new NullPointerException();
+        }
+        HotSpotResolvedObjectTypeImpl accessingClass = (HotSpotResolvedObjectTypeImpl) metaAccess.lookupJavaType(accessClass);
+        return (HotSpotResolvedObjectType) CTVM.lookupType(name, accessingClass, resolve);
     }
 
     public static HotSpotResolvedObjectType lookupTypeHelper(String name,
             Class<?> accessingClass, boolean resolve) {
         try {
@@ -91,16 +99,13 @@
         } catch (ClassNotFoundException e) {
             throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);
         }
     }
 
-    public static Object resolveConstantInPool(ConstantPool constantPool, int cpi) {
-        return CTVM.resolveConstantInPool((HotSpotConstantPool) constantPool, cpi);
-    }
-
     public static Object resolvePossiblyCachedConstantInPool(ConstantPool constantPool, int cpi) {
-        return CTVM.resolvePossiblyCachedConstantInPool((HotSpotConstantPool) constantPool, cpi);
+        DirectHotSpotObjectConstantImpl obj = (DirectHotSpotObjectConstantImpl) CTVM.resolvePossiblyCachedConstantInPool((HotSpotConstantPool) constantPool, cpi);
+        return obj.object;
     }
 
     public static int lookupNameAndTypeRefIndexInPool(ConstantPool constantPool, int cpi) {
         return CTVM.lookupNameAndTypeRefIndexInPool((HotSpotConstantPool) constantPool, cpi);
     }
@@ -156,11 +161,20 @@
         return CTVM.lookupAppendixInPool((HotSpotConstantPool) constantPool, cpi);
     }
 
     public static int installCode(TargetDescription target,
             HotSpotCompiledCode compiledCode, InstalledCode code, HotSpotSpeculationLog speculationLog) {
-        return CTVM.installCode(target, compiledCode, code, speculationLog);
+        byte[] speculations;
+        long failedSpeculationsAddress;
+        if (speculationLog != null) {
+            speculations = speculationLog.getFlattenedSpeculations(true);
+            failedSpeculationsAddress = speculationLog.getFailedSpeculationsAddress();
+        } else {
+            speculations = new byte[0];
+            failedSpeculationsAddress = 0L;
+        }
+        return CTVM.installCode(target, compiledCode, code, failedSpeculationsAddress, speculations);
     }
 
     public static int getMetadata(TargetDescription target,
             HotSpotCompiledCode compiledCode, HotSpotMetaData metaData) {
         return CTVM.getMetadata(target, compiledCode, metaData);
@@ -206,13 +220,13 @@
     public static StackTraceElement getStackTraceElement(
             HotSpotResolvedJavaMethod method, int bci) {
         return CTVM.getStackTraceElement((HotSpotResolvedJavaMethodImpl)method, bci);
     }
 
-    public static Object executeInstalledCode(Object[] args,
-            InstalledCode installedCode) throws InvalidInstalledCodeException {
-        return CTVM.executeInstalledCode(args, installedCode);
+    public static Object executeHotSpotNmethod(Object[] args,
+            HotSpotNmethod nmethodMirror) throws InvalidInstalledCodeException {
+        return CTVM.executeHotSpotNmethod(args, nmethodMirror);
     }
 
     public static long[] getLineNumberTable(HotSpotResolvedJavaMethod method) {
         return CTVM.getLineNumberTable((HotSpotResolvedJavaMethodImpl)method);
     }
@@ -231,12 +245,12 @@
 
     public static void reprofile(HotSpotResolvedJavaMethod method) {
         CTVM.reprofile((HotSpotResolvedJavaMethodImpl)method);
     }
 
-    public static void invalidateInstalledCode(InstalledCode installedCode) {
-        CTVM.invalidateInstalledCode(installedCode);
+    public static void invalidateHotSpotNmethod(HotSpotNmethod nmethodMirror) {
+        CTVM.invalidateHotSpotNmethod(nmethodMirror);
     }
 
     public static long[] collectCounters() {
         return CTVM.collectCounters();
     }
@@ -280,42 +294,53 @@
     public static boolean shouldDebugNonSafepoints() {
         return CTVM.shouldDebugNonSafepoints();
     }
 
     public static void writeDebugOutput(byte[] bytes, int offset, int length) {
-        CTVM.writeDebugOutput(bytes, offset, length);
+        CTVM.writeDebugOutput(bytes, offset, length, true, true);
     }
 
     public static void flushDebugOutput() {
         CTVM.flushDebugOutput();
     }
 
-    public static HotSpotResolvedJavaMethod getResolvedJavaMethod(Object base,
+    public static HotSpotResolvedJavaMethod getResolvedJavaMethod(HotSpotObjectConstantImpl base,
             long displacement) {
         return CTVM.getResolvedJavaMethod(base, displacement);
     }
 
-    public static HotSpotConstantPool getConstantPool(Object object) {
+    public static HotSpotConstantPool getConstantPool(MetaspaceObject object) {
         return CTVM.getConstantPool(object);
     }
 
-    public static HotSpotResolvedObjectType getResolvedJavaType(Object base,
+    public static HotSpotResolvedObjectType getResolvedJavaType(MetaspaceObject base,
             long displacement, boolean compressed) {
         return CTVM.getResolvedJavaType(base, displacement, compressed);
     }
 
     public static long getMetaspacePointer(Object o) {
-        return ((MetaspaceWrapperObject) o).getMetaspacePointer();
+        return ((MetaspaceObject) o).getMetaspacePointer();
     }
 
     public static Class<?> CompilerToVMClass() {
         return CompilerToVM.class;
     }
 
-    public static Class<?> getMirror(HotSpotResolvedObjectType type) {
-        return ((HotSpotResolvedJavaType) type).mirror();
+    public static JavaConstant getJavaMirror(HotSpotResolvedObjectType type) {
+        return ((HotSpotResolvedJavaType) type).getJavaMirror();
     }
 
     public static HotSpotResolvedObjectType fromObjectClass(Class<?> theClass) {
-        return HotSpotResolvedObjectTypeImpl.fromObjectClass(theClass);
+          return (HotSpotResolvedObjectType) metaAccess.lookupJavaType(theClass);
+    }
+
+    public static InstalledCode getInstalledCode(ResolvedJavaMethod method, String name, long address, long entryPoint) {
+        return new InstalledCodeStub((HotSpotResolvedJavaMethodImpl) method, name, address, entryPoint);
+    }
+    private static class InstalledCodeStub extends HotSpotNmethod {
+        private InstalledCodeStub(HotSpotResolvedJavaMethodImpl method, String name, long address, long entryPoint) {
+            super(method, name, false, 0);
+            this.address = address;
+            this.entryPoint = entryPoint;
+        }
     }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TypeUniverse.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TestSpeculationLog.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../meta/StableFieldTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TypeUniverse.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 34 import java.io.Serializable;
 35 import java.lang.reflect.Array;
 36 import java.lang.reflect.Field;
 37 import java.lang.reflect.Method;
 38 import java.util.AbstractCollection;
 39 import java.util.AbstractList;
 40 import java.util.ArrayDeque;
 41 import java.util.ArrayList;
 42 import java.util.Collection;
 43 import java.util.Collections;
 44 import java.util.HashMap;
 45 import java.util.HashSet;
 46 import java.util.IdentityHashMap;
 47 import java.util.LinkedHashMap;
 48 import java.util.LinkedList;
 49 import java.util.List;
 50 import java.util.Map;
 51 import java.util.Queue;
 52 import java.util.Set;
 53 import java.util.TreeMap;

 54 import java.util.stream.Collectors;
 55 
 56 import static java.lang.reflect.Modifier.isFinal;
 57 import static java.lang.reflect.Modifier.isStatic;
 58 
 59 /**
 60  * Context for type related tests.
 61  */
 62 public class TypeUniverse {
 63 
 64     public static final Unsafe unsafe;
 65     public static final double JAVA_VERSION = Double.valueOf(System.getProperty(&quot;java.specification.version&quot;));
 66 
 67     public static final MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();
 68     public static final ConstantReflectionProvider constantReflection = JVMCI.getRuntime().getHostJVMCIBackend().getConstantReflection();
 69     public static final Collection&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;&gt;();
 70     public static final Set&lt;ResolvedJavaType&gt; javaTypes;

 71     public static final Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; arrayClasses = new HashMap&lt;&gt;();
 72 
 73     private static List&lt;ConstantValue&gt; constants;
 74 
 75     public class InnerClass {
 76 
 77     }
 78 
 79     public static class InnerStaticClass {
 80 
 81     }
 82 
 83     public static final class InnerStaticFinalClass {
 84 
 85     }
 86 
 87     private class PrivateInnerClass {
 88 
 89     }
 90 
</pre>
<hr />
<pre>
 99         } catch (Exception e) {
100             try {
101                 Field theUnsafeField = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
102                 theUnsafeField.setAccessible(true);
103                 theUnsafe = (Unsafe) theUnsafeField.get(null);
104             } catch (Exception e1) {
105                 throw (InternalError) new InternalError(&quot;unable to initialize unsafe&quot;).initCause(e1);
106             }
107         }
108         unsafe = theUnsafe;
109 
110         Class&lt;?&gt;[] initialClasses = {void.class, boolean.class, byte.class, short.class, char.class, int.class, float.class, long.class, double.class, Object.class, Class.class, boolean[].class,
111                         byte[].class, short[].class, char[].class, int[].class, float[].class, long[].class, double[].class, Object[].class, Class[].class, List[].class, boolean[][].class,
112                         byte[][].class, short[][].class, char[][].class, int[][].class, float[][].class, long[][].class, double[][].class, Object[][].class, Class[][].class, List[][].class,
113                         ClassLoader.class, String.class, Serializable.class, Cloneable.class, Test.class, TestMetaAccessProvider.class, List.class, Collection.class, Map.class, Queue.class,
114                         HashMap.class, LinkedHashMap.class, IdentityHashMap.class, AbstractCollection.class, AbstractList.class, ArrayList.class, InnerClass.class, InnerStaticClass.class,
115                         InnerStaticFinalClass.class, PrivateInnerClass.class, ProtectedInnerClass.class};
116         for (Class&lt;?&gt; c : initialClasses) {
117             addClass(c);
118         }



119 
120         javaTypes = Collections.unmodifiableSet(classes.stream().map(c -&gt; metaAccess.lookupJavaType(c)).collect(Collectors.toSet()));
121     }
122 
123     static class ConstantsUniverse {
124         static final Object[] ARRAYS = classes.stream().map(c -&gt; c != void.class &amp;&amp; !c.isArray() ? Array.newInstance(c, 42) : null).filter(o -&gt; o != null).collect(Collectors.toList()).toArray();
125         static final Object CONST1 = new ArrayList&lt;&gt;();
126         static final Object CONST2 = new ArrayList&lt;&gt;();
127         static final Object CONST3 = new IdentityHashMap&lt;&gt;();
128         static final Object CONST4 = new LinkedHashMap&lt;&gt;();
129         static final Object CONST5 = new TreeMap&lt;&gt;();
130         static final Object CONST6 = new ArrayDeque&lt;&gt;();
131         static final Object CONST7 = new LinkedList&lt;&gt;();
132         static final Object CONST8 = &quot;a string&quot;;
133         static final Object CONST9 = 42;
134         static final Object CONST10 = String.class;
135         static final Object CONST11 = String[].class;
136     }
137 
138     public static List&lt;ConstantValue&gt; constants() {
</pre>
</td>
<td>
<hr />
<pre>
 34 import java.io.Serializable;
 35 import java.lang.reflect.Array;
 36 import java.lang.reflect.Field;
 37 import java.lang.reflect.Method;
 38 import java.util.AbstractCollection;
 39 import java.util.AbstractList;
 40 import java.util.ArrayDeque;
 41 import java.util.ArrayList;
 42 import java.util.Collection;
 43 import java.util.Collections;
 44 import java.util.HashMap;
 45 import java.util.HashSet;
 46 import java.util.IdentityHashMap;
 47 import java.util.LinkedHashMap;
 48 import java.util.LinkedList;
 49 import java.util.List;
 50 import java.util.Map;
 51 import java.util.Queue;
 52 import java.util.Set;
 53 import java.util.TreeMap;
<span class="line-added"> 54 import java.util.function.Predicate;</span>
 55 import java.util.stream.Collectors;
 56 
 57 import static java.lang.reflect.Modifier.isFinal;
 58 import static java.lang.reflect.Modifier.isStatic;
 59 
 60 /**
 61  * Context for type related tests.
 62  */
 63 public class TypeUniverse {
 64 
 65     public static final Unsafe unsafe;
 66     public static final double JAVA_VERSION = Double.valueOf(System.getProperty(&quot;java.specification.version&quot;));
 67 
 68     public static final MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();
 69     public static final ConstantReflectionProvider constantReflection = JVMCI.getRuntime().getHostJVMCIBackend().getConstantReflection();
 70     public static final Collection&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;&gt;();
 71     public static final Set&lt;ResolvedJavaType&gt; javaTypes;
<span class="line-added"> 72     public static final ResolvedJavaType predicateType;</span>
 73     public static final Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; arrayClasses = new HashMap&lt;&gt;();
 74 
 75     private static List&lt;ConstantValue&gt; constants;
 76 
 77     public class InnerClass {
 78 
 79     }
 80 
 81     public static class InnerStaticClass {
 82 
 83     }
 84 
 85     public static final class InnerStaticFinalClass {
 86 
 87     }
 88 
 89     private class PrivateInnerClass {
 90 
 91     }
 92 
</pre>
<hr />
<pre>
101         } catch (Exception e) {
102             try {
103                 Field theUnsafeField = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
104                 theUnsafeField.setAccessible(true);
105                 theUnsafe = (Unsafe) theUnsafeField.get(null);
106             } catch (Exception e1) {
107                 throw (InternalError) new InternalError(&quot;unable to initialize unsafe&quot;).initCause(e1);
108             }
109         }
110         unsafe = theUnsafe;
111 
112         Class&lt;?&gt;[] initialClasses = {void.class, boolean.class, byte.class, short.class, char.class, int.class, float.class, long.class, double.class, Object.class, Class.class, boolean[].class,
113                         byte[].class, short[].class, char[].class, int[].class, float[].class, long[].class, double[].class, Object[].class, Class[].class, List[].class, boolean[][].class,
114                         byte[][].class, short[][].class, char[][].class, int[][].class, float[][].class, long[][].class, double[][].class, Object[][].class, Class[][].class, List[][].class,
115                         ClassLoader.class, String.class, Serializable.class, Cloneable.class, Test.class, TestMetaAccessProvider.class, List.class, Collection.class, Map.class, Queue.class,
116                         HashMap.class, LinkedHashMap.class, IdentityHashMap.class, AbstractCollection.class, AbstractList.class, ArrayList.class, InnerClass.class, InnerStaticClass.class,
117                         InnerStaticFinalClass.class, PrivateInnerClass.class, ProtectedInnerClass.class};
118         for (Class&lt;?&gt; c : initialClasses) {
119             addClass(c);
120         }
<span class="line-added">121         Predicate&lt;String&gt; predicate = s -&gt; s.length() == 1;</span>
<span class="line-added">122         addClass(predicate.getClass());</span>
<span class="line-added">123         predicateType = metaAccess.lookupJavaType(predicate.getClass());</span>
124 
125         javaTypes = Collections.unmodifiableSet(classes.stream().map(c -&gt; metaAccess.lookupJavaType(c)).collect(Collectors.toSet()));
126     }
127 
128     static class ConstantsUniverse {
129         static final Object[] ARRAYS = classes.stream().map(c -&gt; c != void.class &amp;&amp; !c.isArray() ? Array.newInstance(c, 42) : null).filter(o -&gt; o != null).collect(Collectors.toList()).toArray();
130         static final Object CONST1 = new ArrayList&lt;&gt;();
131         static final Object CONST2 = new ArrayList&lt;&gt;();
132         static final Object CONST3 = new IdentityHashMap&lt;&gt;();
133         static final Object CONST4 = new LinkedHashMap&lt;&gt;();
134         static final Object CONST5 = new TreeMap&lt;&gt;();
135         static final Object CONST6 = new ArrayDeque&lt;&gt;();
136         static final Object CONST7 = new LinkedList&lt;&gt;();
137         static final Object CONST8 = &quot;a string&quot;;
138         static final Object CONST9 = 42;
139         static final Object CONST10 = String.class;
140         static final Object CONST11 = String[].class;
141     }
142 
143     public static List&lt;ConstantValue&gt; constants() {
</pre>
</td>
</tr>
</table>
<center><a href="TestSpeculationLog.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../meta/StableFieldTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
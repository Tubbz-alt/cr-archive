<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/ResolvedJavaTypeResolveMethodTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @requires vm.jvmci
 27  * @modules jdk.internal.vm.ci/jdk.vm.ci.meta
 28  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
 29  * @run junit/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler jdk.vm.ci.runtime.test.ResolvedJavaTypeResolveMethodTest
 30  */
 31 
 32 package jdk.vm.ci.runtime.test;
 33 
 34 import jdk.vm.ci.meta.MetaAccessProvider;
 35 import jdk.vm.ci.meta.ResolvedJavaMethod;
 36 import jdk.vm.ci.meta.ResolvedJavaType;
 37 import jdk.vm.ci.runtime.JVMCI;
 38 import org.junit.Test;
 39 
 40 import static org.junit.Assert.assertEquals;
 41 import static org.junit.Assert.assertNull;
 42 import static org.junit.Assert.assertNotNull;
 43 
 44 public class ResolvedJavaTypeResolveMethodTest {
 45     public final MetaAccessProvider metaAccess;
 46 
 47     public ResolvedJavaTypeResolveMethodTest() {
 48         metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();
 49     }
 50 
 51     protected abstract static class A {
 52         @SuppressWarnings(&quot;unused&quot;)
 53         private void priv() {
 54         }
 55 
 56         public void v1() {
 57         }
 58 
 59         public void v2() {
 60         }
 61 
 62         public abstract void abs();
 63     }
 64 
 65     protected static class B extends A implements I {
 66         @Override
 67         public void i() {
 68         }
 69 
 70         @Override
 71         public void v2() {
 72         }
 73 
 74         @Override
 75         public void abs() {
 76 
 77         }
 78     }
 79 
 80     protected static class C extends B {
 81         @Override
 82         public void d() {
 83         }
 84     }
 85 
 86     protected abstract static class D extends A {
 87 
 88     }
 89 
 90     protected static class E extends D {
 91         @Override
 92         public void abs() {
 93         }
 94     }
 95 
 96     protected interface I {
 97         void i();
 98 
 99         default void d() {
100         }
101     }
102 
103     @Test
104     public void testDefaultMethod() {
105         ResolvedJavaType i = getType(I.class);
106         ResolvedJavaType b = getType(B.class);
107         ResolvedJavaType c = getType(C.class);
108         ResolvedJavaMethod di = getMethod(i, &quot;d&quot;);
109         ResolvedJavaMethod dc = getMethod(c, &quot;d&quot;);
110 
111         assertEquals(null, i.resolveMethod(di, c));
112         assertEquals(di, b.resolveMethod(di, c));
113         assertEquals(dc, c.resolveMethod(di, c));
114     }
115 
116     @Test
117     public void testPrivateMethod() {
118         ResolvedJavaType a = getType(A.class);
119         ResolvedJavaType b = getType(B.class);
120         ResolvedJavaType c = getType(C.class);
121         ResolvedJavaMethod priv = getMethod(a, &quot;priv&quot;);
122 
123         // nestmates have access to private methods
124         assertNotNull(a.resolveMethod(priv, c));
125         assertNotNull(b.resolveMethod(priv, c));
126     }
127 
128     @Test
129     public void testAbstractMethod() {
130         ResolvedJavaType a = getType(A.class);
131         ResolvedJavaType b = getType(B.class);
132         ResolvedJavaType c = getType(C.class);
133         ResolvedJavaType d = getType(D.class);
134         ResolvedJavaType e = getType(E.class);
135         ResolvedJavaMethod absa = getMethod(a, &quot;abs&quot;);
136         ResolvedJavaMethod absb = getMethod(b, &quot;abs&quot;);
137         ResolvedJavaMethod abse = getMethod(e, &quot;abs&quot;);
138 
139         assertEquals(absa, a.resolveMethod(absa, c));
140         assertEquals(absa, d.resolveMethod(absa, c));
141 
142         assertEquals(absb, b.resolveMethod(absa, c));
143         assertEquals(absb, b.resolveMethod(absb, c));
144         assertEquals(absb, c.resolveMethod(absa, c));
145         assertEquals(absb, c.resolveMethod(absb, c));
146         assertEquals(abse, e.resolveMethod(absa, c));
147         assertNull(e.resolveMethod(absb, c));
148         assertEquals(abse, e.resolveMethod(abse, c));
149     }
150 
151     @Test
152     public void testVirtualMethod() {
153         ResolvedJavaType a = getType(A.class);
154         ResolvedJavaType b = getType(B.class);
155         ResolvedJavaType c = getType(C.class);
156         ResolvedJavaMethod v1a = getMethod(a, &quot;v1&quot;);
157         ResolvedJavaMethod v2a = getMethod(a, &quot;v2&quot;);
158         ResolvedJavaMethod v2b = getMethod(b, &quot;v2&quot;);
159 
160         assertEquals(v1a, a.resolveMethod(v1a, c));
161         assertEquals(v1a, b.resolveMethod(v1a, c));
162         assertEquals(v1a, c.resolveMethod(v1a, c));
163         assertEquals(v2a, a.resolveMethod(v2a, c));
164         assertEquals(v2b, b.resolveMethod(v2a, c));
165         assertEquals(v2b, b.resolveMethod(v2b, c));
166         assertEquals(v2b, c.resolveMethod(v2a, c));
167         assertEquals(v2b, c.resolveMethod(v2b, c));
168 
169     }
170 
171     static class ClassType {
172     }
173 
174     interface InterfaceType {
175     }
176 
177     @Test
178     public void testCloneAccessibility() {
179         /*
180          * The resolution machinery for clone on arrays has some hacks in that show up in odd places
181          * so make sure that resolveMethod works as expected.
182          */
183         ResolvedJavaType interfaceType = getType(InterfaceType.class);
184         ResolvedJavaType classType = getType(ClassType.class);
185         ResolvedJavaType arrayType = getType(double[].class);
186         ResolvedJavaMethod cloneMethod = getMethod(getType(Object.class), &quot;clone&quot;);
187         assertEquals(&quot;Can&#39;t resolve clone for class&quot;, cloneMethod, arrayType.resolveMethod(cloneMethod, classType));
188         assertEquals(&quot;Can&#39;t resolve clone for interface&quot;, cloneMethod, arrayType.resolveMethod(cloneMethod, interfaceType));
189     }
190 
191     static ResolvedJavaMethod getMethod(ResolvedJavaType type, String methodName) {
192         for (ResolvedJavaMethod method : type.getDeclaredMethods()) {
193             if (method.getName().equals(methodName)) {
194                 return method;
195             }
196         }
197         throw new IllegalArgumentException();
198     }
199 
200     protected ResolvedJavaType getType(Class&lt;?&gt; clazz) {
201         ResolvedJavaType type = metaAccess.lookupJavaType(clazz);
202         type.initialize();
203         return type;
204     }
205 }
    </pre>
  </body>
</html>
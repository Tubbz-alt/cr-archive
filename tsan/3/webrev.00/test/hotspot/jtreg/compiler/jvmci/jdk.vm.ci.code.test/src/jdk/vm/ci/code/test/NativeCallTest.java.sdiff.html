<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.code.test/src/jdk/vm/ci/code/test/NativeCallTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MaxOopMapStackOffsetTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="SimpleCodeInstallationTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.code.test/src/jdk/vm/ci/code/test/NativeCallTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 60         float b = 8.7654321f;
 61         test(&quot;FF&quot;, getFF(), float.class, new Class&lt;?&gt;[]{float.class, float.class}, new Object[]{a, b});
 62     }
 63 
 64     @Test
 65     public void testSDILDS() {
 66         float a = 1.2345678f;
 67         double b = 3.212434;
 68         int c = 43921652;
 69         long d = 412435326;
 70         double e = .31212333;
 71         float f = 8.7654321f;
 72         Class&lt;?&gt;[] argClazz = new Class[]{float.class, double.class, int.class, long.class, double.class,
 73                         float.class};
 74         test(&quot;SDILDS&quot;, getSDILDS(), float.class, argClazz, new Object[]{a, b, c, d, e, f});
 75     }
 76 
 77     @Test
 78     public void testF32SDILDS() {
 79         int sCount = 32;
<span class="line-modified"> 80         Object[] remainingArgs = new Object[]{ // Pairs of &lt;Object&gt;, &lt;Class&gt;</span>

 81                         1.2345678F, float.class,
 82                         3.212434D, double.class,
 83                         43921652, int.class,
 84                         0xCAFEBABEDEADBEEFL, long.class,
 85                         .31212333D, double.class,
 86                         8.7654321F, float.class
 87         };
 88         Class&lt;?&gt;[] argClazz = new Class[sCount + remainingArgs.length / 2];
 89         Object[] argValues = new Object[sCount + remainingArgs.length / 2];
 90         for (int i = 0; i &lt; sCount; i++) {
 91             argValues[i] = (float) i;
 92             argClazz[i] = float.class;
 93         }
 94         for (int i = 0; i &lt; remainingArgs.length; i += 2) {
 95             argValues[sCount + i / 2] = remainingArgs[i + 0];
 96             argClazz[sCount + i / 2] = (Class&lt;?&gt;) remainingArgs[i + 1];
 97         }
 98         test(&quot;F32SDILDS&quot;, getF32SDILDS(), float.class, argClazz, argValues);
 99     }
100 
101     @Test
102     public void testI32SDILDS() {
103         int sCount = 32;
<span class="line-modified">104         Object[] remainingArgs = new Object[]{ // Pairs of &lt;Object&gt;, &lt;Class&gt;</span>

105                         1.2345678F, float.class,
106                         3.212434D, double.class,
107                         43921652, int.class,
108                         0xCAFEBABEDEADBEEFL, long.class,
109                         .31212333D, double.class,
110                         8.7654321F, float.class
111         };
112         Class&lt;?&gt;[] argClazz = new Class[sCount + remainingArgs.length / 2];
113         Object[] argValues = new Object[sCount + remainingArgs.length / 2];
114         for (int i = 0; i &lt; sCount; i++) {
115             argValues[i] = i;
116             argClazz[i] = int.class;
117         }
118         for (int i = 0; i &lt; remainingArgs.length; i += 2) {
119             argValues[sCount + i / 2] = remainingArgs[i + 0];
120             argClazz[sCount + i / 2] = (Class&lt;?&gt;) remainingArgs[i + 1];
121         }
122         test(&quot;I32SDILDS&quot;, getI32SDILDS(), float.class, argClazz, argValues);
123     }
124 
</pre>
<hr />
<pre>
126         try {
127             test(asm -&gt; {
128                 JavaType[] argTypes = new JavaType[types.length];
129                 int i = 0;
130                 for (Class&lt;?&gt; clazz : types) {
131                     argTypes[i++] = metaAccess.lookupJavaType(clazz);
132                 }
133                 JavaType returnType = metaAccess.lookupJavaType(returnClazz);
134                 CallingConvention cc = codeCache.getRegisterConfig().getCallingConvention(NativeCall, returnType, argTypes, asm.valueKindFactory);
135                 asm.emitCallPrologue(cc, values);
136                 asm.emitCall(addr);
137                 asm.emitCallEpilogue(cc);
138                 asm.emitFloatRet(((RegisterValue) cc.getReturn()).getRegister());
139             }, getMethod(name, types), values);
140         } catch (Throwable e) {
141             e.printStackTrace();
142             throw e;
143         }
144     }
145 


146     public static native long getFF();
147 
148     public static native float _FF(float a, float b);
149 
150     public static float FF(float a, float b) {
151         return _FF(a, b);
152     }
153 
154     public static native long getSDILDS();
155 
156     public static native float _SDILDS(float a, double b, int c, long d, double e, float f);
157 
158     public static float SDILDS(float a, double b, int c, long d, double e, float f) {
159         return _SDILDS(a, b, c, d, e, f);
160     }
161 
162     public static native long getF32SDILDS();
163 
164     public static native float _F32SDILDS(float f00, float f01, float f02, float f03, float f04, float f05, float f06, float f07,
165                     float f08, float f09, float f0a, float f0b, float f0c, float f0d, float f0e, float f0f,
</pre>
<hr />
<pre>
170     public static float F32SDILDS(float f00, float f01, float f02, float f03, float f04, float f05, float f06, float f07,
171                     float f08, float f09, float f0a, float f0b, float f0c, float f0d, float f0e, float f0f,
172                     float f10, float f11, float f12, float f13, float f14, float f15, float f16, float f17,
173                     float f18, float f19, float f1a, float f1b, float f1c, float f1d, float f1e, float f1f,
174                     float a, double b, int c, long d, double e, float f) {
175         return _F32SDILDS(f00, f01, f02, f03, f04, f05, f06, f07,
176                         f08, f09, f0a, f0b, f0c, f0d, f0e, f0f,
177                         f10, f11, f12, f13, f14, f15, f16, f17,
178                         f18, f19, f1a, f1b, f1c, f1d, f1e, f1f,
179                         a, b, c, d, e, f);
180     }
181 
182     public static native long getD32SDILDS();
183 
184     public static native float _D32SDILDS(double d00, double d01, double d02, double d03, double d04, double d05, double d06, double d07,
185                     double d08, double d09, double d0a, double d0b, double d0c, double d0d, double d0e, double d0f,
186                     double d10, double d11, double d12, double d13, double d14, double d15, double d16, double d17,
187                     double d18, double d19, double d1a, double d1b, double d1c, double d1d, double d1e, double d1f,
188                     float a, double b, int c, long d, double e, float f);
189 

190     public static float D32SDILDS(double d00, double d01, double d02, double d03, double d04, double d05, double d06, double d07,
191                     double d08, double d09, double d0a, double d0b, double d0c, double d0d, double d0e, double d0f,
192                     double d10, double d11, double d12, double d13, double d14, double d15, double d16, double d17,
193                     double d18, double d19, double d1a, double d1b, double d1c, double d1d, double d1e, double d1f,
194                     float a, double b, int c, long d, double e, float f) {
195         return _D32SDILDS(d00, d01, d02, d03, d04, d05, d06, d07,
196                         d08, d09, d0a, d0b, d0c, d0d, d0e, d0d,
197                         d10, d11, d12, d13, d14, d15, d16, d17,
198                         d18, d19, d1a, d1b, d1c, d1d, d1e, d1f,
199                         a, b, c, d, e, f);
200     }
201 
202     public static native long getI32SDILDS();
203 
204     public static native float _I32SDILDS(int i00, int i01, int i02, int i03, int i04, int i05, int i06, int i07,
205                     int i08, int i09, int i0a, int i0b, int i0c, int i0d, int i0e, int i0f,
206                     int i10, int i11, int i12, int i13, int i14, int i15, int i16, int i17,
207                     int i18, int i19, int i1a, int i1b, int i1c, int i1d, int i1e, int i1f,
208                     float a, double b, int c, long d, double e, float f);
209 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 60         float b = 8.7654321f;
 61         test(&quot;FF&quot;, getFF(), float.class, new Class&lt;?&gt;[]{float.class, float.class}, new Object[]{a, b});
 62     }
 63 
 64     @Test
 65     public void testSDILDS() {
 66         float a = 1.2345678f;
 67         double b = 3.212434;
 68         int c = 43921652;
 69         long d = 412435326;
 70         double e = .31212333;
 71         float f = 8.7654321f;
 72         Class&lt;?&gt;[] argClazz = new Class[]{float.class, double.class, int.class, long.class, double.class,
 73                         float.class};
 74         test(&quot;SDILDS&quot;, getSDILDS(), float.class, argClazz, new Object[]{a, b, c, d, e, f});
 75     }
 76 
 77     @Test
 78     public void testF32SDILDS() {
 79         int sCount = 32;
<span class="line-modified"> 80         // Pairs of &lt;Object&gt;, &lt;Class&gt;</span>
<span class="line-added"> 81         Object[] remainingArgs = new Object[]{</span>
 82                         1.2345678F, float.class,
 83                         3.212434D, double.class,
 84                         43921652, int.class,
 85                         0xCAFEBABEDEADBEEFL, long.class,
 86                         .31212333D, double.class,
 87                         8.7654321F, float.class
 88         };
 89         Class&lt;?&gt;[] argClazz = new Class[sCount + remainingArgs.length / 2];
 90         Object[] argValues = new Object[sCount + remainingArgs.length / 2];
 91         for (int i = 0; i &lt; sCount; i++) {
 92             argValues[i] = (float) i;
 93             argClazz[i] = float.class;
 94         }
 95         for (int i = 0; i &lt; remainingArgs.length; i += 2) {
 96             argValues[sCount + i / 2] = remainingArgs[i + 0];
 97             argClazz[sCount + i / 2] = (Class&lt;?&gt;) remainingArgs[i + 1];
 98         }
 99         test(&quot;F32SDILDS&quot;, getF32SDILDS(), float.class, argClazz, argValues);
100     }
101 
102     @Test
103     public void testI32SDILDS() {
104         int sCount = 32;
<span class="line-modified">105         // Pairs of &lt;Object&gt;, &lt;Class&gt;</span>
<span class="line-added">106         Object[] remainingArgs = new Object[]{</span>
107                         1.2345678F, float.class,
108                         3.212434D, double.class,
109                         43921652, int.class,
110                         0xCAFEBABEDEADBEEFL, long.class,
111                         .31212333D, double.class,
112                         8.7654321F, float.class
113         };
114         Class&lt;?&gt;[] argClazz = new Class[sCount + remainingArgs.length / 2];
115         Object[] argValues = new Object[sCount + remainingArgs.length / 2];
116         for (int i = 0; i &lt; sCount; i++) {
117             argValues[i] = i;
118             argClazz[i] = int.class;
119         }
120         for (int i = 0; i &lt; remainingArgs.length; i += 2) {
121             argValues[sCount + i / 2] = remainingArgs[i + 0];
122             argClazz[sCount + i / 2] = (Class&lt;?&gt;) remainingArgs[i + 1];
123         }
124         test(&quot;I32SDILDS&quot;, getI32SDILDS(), float.class, argClazz, argValues);
125     }
126 
</pre>
<hr />
<pre>
128         try {
129             test(asm -&gt; {
130                 JavaType[] argTypes = new JavaType[types.length];
131                 int i = 0;
132                 for (Class&lt;?&gt; clazz : types) {
133                     argTypes[i++] = metaAccess.lookupJavaType(clazz);
134                 }
135                 JavaType returnType = metaAccess.lookupJavaType(returnClazz);
136                 CallingConvention cc = codeCache.getRegisterConfig().getCallingConvention(NativeCall, returnType, argTypes, asm.valueKindFactory);
137                 asm.emitCallPrologue(cc, values);
138                 asm.emitCall(addr);
139                 asm.emitCallEpilogue(cc);
140                 asm.emitFloatRet(((RegisterValue) cc.getReturn()).getRegister());
141             }, getMethod(name, types), values);
142         } catch (Throwable e) {
143             e.printStackTrace();
144             throw e;
145         }
146     }
147 
<span class="line-added">148     // Checkstyle: stop</span>
<span class="line-added">149 </span>
150     public static native long getFF();
151 
152     public static native float _FF(float a, float b);
153 
154     public static float FF(float a, float b) {
155         return _FF(a, b);
156     }
157 
158     public static native long getSDILDS();
159 
160     public static native float _SDILDS(float a, double b, int c, long d, double e, float f);
161 
162     public static float SDILDS(float a, double b, int c, long d, double e, float f) {
163         return _SDILDS(a, b, c, d, e, f);
164     }
165 
166     public static native long getF32SDILDS();
167 
168     public static native float _F32SDILDS(float f00, float f01, float f02, float f03, float f04, float f05, float f06, float f07,
169                     float f08, float f09, float f0a, float f0b, float f0c, float f0d, float f0e, float f0f,
</pre>
<hr />
<pre>
174     public static float F32SDILDS(float f00, float f01, float f02, float f03, float f04, float f05, float f06, float f07,
175                     float f08, float f09, float f0a, float f0b, float f0c, float f0d, float f0e, float f0f,
176                     float f10, float f11, float f12, float f13, float f14, float f15, float f16, float f17,
177                     float f18, float f19, float f1a, float f1b, float f1c, float f1d, float f1e, float f1f,
178                     float a, double b, int c, long d, double e, float f) {
179         return _F32SDILDS(f00, f01, f02, f03, f04, f05, f06, f07,
180                         f08, f09, f0a, f0b, f0c, f0d, f0e, f0f,
181                         f10, f11, f12, f13, f14, f15, f16, f17,
182                         f18, f19, f1a, f1b, f1c, f1d, f1e, f1f,
183                         a, b, c, d, e, f);
184     }
185 
186     public static native long getD32SDILDS();
187 
188     public static native float _D32SDILDS(double d00, double d01, double d02, double d03, double d04, double d05, double d06, double d07,
189                     double d08, double d09, double d0a, double d0b, double d0c, double d0d, double d0e, double d0f,
190                     double d10, double d11, double d12, double d13, double d14, double d15, double d16, double d17,
191                     double d18, double d19, double d1a, double d1b, double d1c, double d1d, double d1e, double d1f,
192                     float a, double b, int c, long d, double e, float f);
193 
<span class="line-added">194     @SuppressWarnings(&quot;unused&quot;)</span>
195     public static float D32SDILDS(double d00, double d01, double d02, double d03, double d04, double d05, double d06, double d07,
196                     double d08, double d09, double d0a, double d0b, double d0c, double d0d, double d0e, double d0f,
197                     double d10, double d11, double d12, double d13, double d14, double d15, double d16, double d17,
198                     double d18, double d19, double d1a, double d1b, double d1c, double d1d, double d1e, double d1f,
199                     float a, double b, int c, long d, double e, float f) {
200         return _D32SDILDS(d00, d01, d02, d03, d04, d05, d06, d07,
201                         d08, d09, d0a, d0b, d0c, d0d, d0e, d0d,
202                         d10, d11, d12, d13, d14, d15, d16, d17,
203                         d18, d19, d1a, d1b, d1c, d1d, d1e, d1f,
204                         a, b, c, d, e, f);
205     }
206 
207     public static native long getI32SDILDS();
208 
209     public static native float _I32SDILDS(int i00, int i01, int i02, int i03, int i04, int i05, int i06, int i07,
210                     int i08, int i09, int i0a, int i0b, int i0c, int i0d, int i0e, int i0f,
211                     int i10, int i11, int i12, int i13, int i14, int i15, int i16, int i17,
212                     int i18, int i19, int i1a, int i1b, int i1c, int i1d, int i1e, int i1f,
213                     float a, double b, int c, long d, double e, float f);
214 
</pre>
</td>
</tr>
</table>
<center><a href="MaxOopMapStackOffsetTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="SimpleCodeInstallationTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
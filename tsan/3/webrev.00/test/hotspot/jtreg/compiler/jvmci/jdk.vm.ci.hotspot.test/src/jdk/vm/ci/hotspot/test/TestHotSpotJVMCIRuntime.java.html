<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.hotspot.test/src/jdk/vm/ci/hotspot/test/TestHotSpotJVMCIRuntime.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @requires vm.jvmci
 27  * @modules jdk.internal.vm.ci/jdk.vm.ci.hotspot
 28  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
 29  *          jdk.internal.vm.ci/jdk.vm.ci.meta
 30  *          jdk.internal.vm.ci/jdk.vm.ci.code
 31  *          jdk.internal.vm.ci/jdk.vm.ci.common
 32  * @library /compiler/jvmci/jdk.vm.ci.hotspot.test/src
 33  *          /compiler/jvmci/jdk.vm.ci.code.test/src
 34  * @run testng/othervm
 35  *      -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler
 36  *      jdk.vm.ci.hotspot.test.TestHotSpotJVMCIRuntime
 37  */
 38 
 39 package jdk.vm.ci.hotspot.test;
 40 
 41 import java.util.ArrayList;
 42 import java.util.Arrays;
 43 import java.util.List;
 44 import java.util.function.Predicate;
 45 
 46 import org.testng.Assert;
 47 import org.testng.annotations.Test;
 48 
 49 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 50 import jdk.vm.ci.meta.MetaAccessProvider;
 51 import jdk.vm.ci.meta.ResolvedJavaType;
 52 
 53 public class TestHotSpotJVMCIRuntime {
 54 
 55     @Test
 56     public void writeDebugOutputTest() {
 57         HotSpotJVMCIRuntime runtime = HotSpotJVMCIRuntime.runtime();
 58 
 59         expectWriteDebugOutputFailure(runtime, null, 0, 0, true, true, NullPointerException.class);
 60         expectWriteDebugOutputFailure(runtime, null, 0, 0, true, false, -1);
 61 
 62         byte[] emptyOutput = {};
 63         byte[] nonEmptyOutput = String.format(&quot;non-empty output%n&quot;).getBytes();
 64 
 65         for (boolean canThrow : new boolean[]{true, false}) {
 66             for (byte[] output : new byte[][]{emptyOutput, nonEmptyOutput}) {
 67                 for (int offset = 0; offset &lt; output.length; offset++) {
 68                     int length = output.length - offset;
 69                     runtime.writeDebugOutput(output, offset, length, true, canThrow);
 70                 }
 71 
 72                 Object expect = canThrow ? IndexOutOfBoundsException.class : -2;
 73                 expectWriteDebugOutputFailure(runtime, output, output.length + 1, 0, true, canThrow, expect);
 74                 expectWriteDebugOutputFailure(runtime, output, 0, output.length + 1, true, canThrow, expect);
 75                 expectWriteDebugOutputFailure(runtime, output, -1, 0, true, canThrow, expect);
 76                 expectWriteDebugOutputFailure(runtime, output, 0, -1, true, canThrow, expect);
 77             }
 78         }
 79     }
 80 
 81     private static void expectWriteDebugOutputFailure(HotSpotJVMCIRuntime runtime, byte[] bytes, int offset, int length, boolean flush, boolean canThrow, Object expect) {
 82         try {
 83             int result = runtime.writeDebugOutput(bytes, offset, length, flush, canThrow);
 84             if (expect instanceof Integer) {
 85                 Assert.assertEquals((int) expect, result);
 86             } else {
 87                 Assert.fail(&quot;expected &quot; + expect + &quot;, got &quot; + result + &quot; for bytes == &quot; + Arrays.toString(bytes));
 88             }
 89         } catch (Exception e) {
 90             if (expect instanceof Integer) {
 91                 Assert.fail(&quot;expected &quot; + expect + &quot;, got &quot; + e + &quot; for bytes == &quot; + Arrays.toString(bytes));
 92             } else {
 93                 Assert.assertTrue(((Class&lt;?&gt;) expect).isInstance(e), e.toString());
 94             }
 95         }
 96     }
 97 
 98     @Test
 99     public void getIntrinsificationTrustPredicateTest() throws Exception {
100         HotSpotJVMCIRuntime runtime = HotSpotJVMCIRuntime.runtime();
101         MetaAccessProvider metaAccess = runtime.getHostJVMCIBackend().getMetaAccess();
102         Predicate&lt;ResolvedJavaType&gt; predicate = runtime.getIntrinsificationTrustPredicate(HotSpotJVMCIRuntime.class);
103         List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;(Arrays.asList(
104                         Object.class,
105                         String.class,
106                         Class.class,
107                         HotSpotJVMCIRuntime.class,
108                         VirtualObjectLayoutTest.class,
109                         TestHotSpotJVMCIRuntime.class));
110         try {
111             classes.add(Class.forName(&quot;com.sun.crypto.provider.AESCrypt&quot;));
112             classes.add(Class.forName(&quot;com.sun.crypto.provider.CipherBlockChaining&quot;));
113         } catch (ClassNotFoundException e) {
114             // Extension classes not available
115         }
116         ClassLoader jvmciLoader = HotSpotJVMCIRuntime.class.getClassLoader();
117         ClassLoader platformLoader = ClassLoader.getPlatformClassLoader();
118         for (Class&lt;?&gt; c : classes) {
119             ClassLoader cl = c.getClassLoader();
120             boolean expected = cl == null || cl == jvmciLoader || cl == platformLoader;
121             boolean actual = predicate.test(metaAccess.lookupJavaType(c));
122             Assert.assertEquals(expected, actual, c + &quot;: cl=&quot; + cl);
123         }
124     }
125 }
    </pre>
  </body>
</html>
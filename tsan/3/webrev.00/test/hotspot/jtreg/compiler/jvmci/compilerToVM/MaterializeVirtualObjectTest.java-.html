<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/compiler/jvmci/compilerToVM/MaterializeVirtualObjectTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8136421
 27  *
 28  * @requires vm.jvmci
 29  * @requires vm.opt.final.EliminateAllocations == true
 30  *
 31  * @comment no &quot;-Xcomp -XX:-TieredCompilation&quot; combination allowed until JDK-8140018 is resolved
 32  * @requires vm.compMode != &quot;Xcomp&quot; | vm.opt.TieredCompilation == null | vm.opt.TieredCompilation == true
 33  *
 34  * @library / /test/lib
 35  * @library ../common/patches
 36  * @modules java.base/jdk.internal.misc
 37  * @modules java.base/jdk.internal.org.objectweb.asm
 38  *          java.base/jdk.internal.org.objectweb.asm.tree
 39  *          jdk.internal.vm.ci/jdk.vm.ci.hotspot
 40  *          jdk.internal.vm.ci/jdk.vm.ci.code
 41  *          jdk.internal.vm.ci/jdk.vm.ci.code.stack
 42  *          jdk.internal.vm.ci/jdk.vm.ci.meta
 43  *
 44  * @build jdk.internal.vm.ci/jdk.vm.ci.hotspot.CompilerToVMHelper sun.hotspot.WhiteBox
 45  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 46  *                                sun.hotspot.WhiteBox$WhiteBoxPermission
 47  * @run main/othervm -Xmixed -Xbatch -Xbootclasspath/a:.
 48  *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
 49  *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI
 50  *                   -XX:CompileCommand=exclude,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::check
 51  *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::testFrame
 52  *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::testFrame2
 53  *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::recurse
 54  *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::testFrame3
 55  *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay
 56  *                   -Dcompiler.jvmci.compilerToVM.MaterializeVirtualObjectTest.materializeFirst=true
 57  *                   -Dcompiler.jvmci.compilerToVM.MaterializeVirtualObjectTest.invalidate=false
 58  *                   compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest
 59  * @run main/othervm -Xmixed -Xbatch -Xbootclasspath/a:.
 60  *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
 61  *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI
 62  *                   -XX:CompileCommand=exclude,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::check
 63  *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::testFrame
 64  *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::testFrame2
 65  *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::recurse
 66  *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::testFrame3
 67  *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay
 68  *                   -Dcompiler.jvmci.compilerToVM.MaterializeVirtualObjectTest.materializeFirst=false
 69  *                   -Dcompiler.jvmci.compilerToVM.MaterializeVirtualObjectTest.invalidate=false
 70  *                   compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest
 71  * @run main/othervm -Xmixed -Xbatch -Xbootclasspath/a:.
 72  *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
 73  *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI
 74  *                   -XX:CompileCommand=exclude,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::check
 75  *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::testFrame
 76  *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::testFrame2
 77  *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::recurse
 78  *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::testFrame3
 79  *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay
 80  *                   -Dcompiler.jvmci.compilerToVM.MaterializeVirtualObjectTest.materializeFirst=true
 81  *                   -Dcompiler.jvmci.compilerToVM.MaterializeVirtualObjectTest.invalidate=true
 82  *                   compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest
 83  * @run main/othervm -Xmixed -Xbatch -Xbootclasspath/a:.
 84  *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
 85  *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI
 86  *                   -XX:CompileCommand=exclude,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::check
 87  *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::testFrame
 88  *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::testFrame2
 89  *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::recurse
 90  *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest::testFrame3
 91  *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay
 92  *                   -Dcompiler.jvmci.compilerToVM.MaterializeVirtualObjectTest.materializeFirst=false
 93  *                   -Dcompiler.jvmci.compilerToVM.MaterializeVirtualObjectTest.invalidate=true
 94  *                   compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest
 95  */
 96 
 97 package compiler.jvmci.compilerToVM;
 98 
 99 import compiler.jvmci.common.CTVMUtilities;
100 import compiler.testlibrary.CompilerUtils;
101 import compiler.whitebox.CompilerWhiteBoxTest;
102 import jdk.test.lib.Asserts;
103 import jdk.vm.ci.code.stack.InspectedFrame;
104 import jdk.vm.ci.hotspot.CompilerToVMHelper;
105 import jdk.vm.ci.hotspot.HotSpotStackFrameReference;
106 import jdk.vm.ci.meta.ResolvedJavaMethod;
107 import jtreg.SkippedException;
108 import sun.hotspot.WhiteBox;
109 
110 import java.lang.reflect.Method;
111 
112 public class MaterializeVirtualObjectTest {
113     private static final WhiteBox WB;
114     private static final boolean INVALIDATE;
115     private static final int COMPILE_THRESHOLD;
116     private static final Method MATERIALIZED_METHOD;
117     private static final Method NOT_MATERIALIZED_METHOD;
118     private static final Method FRAME3_METHOD;
119     private static final ResolvedJavaMethod MATERIALIZED_RESOLVED;
120     private static final ResolvedJavaMethod NOT_MATERIALIZED_RESOLVED;
121     private static final ResolvedJavaMethod FRAME2_RESOLVED;
122     private static final ResolvedJavaMethod FRAME3_RESOLVED;
123     private static final boolean MATERIALIZE_FIRST;
124 
125     static {
126         Method method1;
127         Method method2;
128         WB = WhiteBox.getWhiteBox();
129         try {
130             method1 = MaterializeVirtualObjectTest.class.getDeclaredMethod(&quot;testFrame&quot;,
131                     String.class, int.class);
132             method2 = MaterializeVirtualObjectTest.class.getDeclaredMethod(&quot;testFrame2&quot;,
133                     String.class, int.class);
134             FRAME3_METHOD = MaterializeVirtualObjectTest.class.getDeclaredMethod(&quot;testFrame3&quot;,
135                     Helper.class, int.class);
136         } catch (NoSuchMethodException e) {
137             throw new Error(&quot;Can&#39;t get executable for test method&quot;, e);
138         }
139         ResolvedJavaMethod resolved1;
140         resolved1 = CTVMUtilities.getResolvedMethod(method1);
141         FRAME2_RESOLVED = CTVMUtilities.getResolvedMethod(method2);
142         FRAME3_RESOLVED = CTVMUtilities.getResolvedMethod(FRAME3_METHOD);
143         INVALIDATE = Boolean.getBoolean(
144                 &quot;compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest.invalidate&quot;);
145         COMPILE_THRESHOLD = WB.getBooleanVMFlag(&quot;TieredCompilation&quot;)
146                 ? CompilerWhiteBoxTest.THRESHOLD
147                 : CompilerWhiteBoxTest.THRESHOLD * 2;
148         MATERIALIZE_FIRST = Boolean.getBoolean(
149                 &quot;compiler.jvmci.compilerToVM.MaterializeVirtualObjectTest.materializeFirst&quot;);
150         MATERIALIZED_RESOLVED = MATERIALIZE_FIRST ? resolved1 : FRAME2_RESOLVED;
151         NOT_MATERIALIZED_RESOLVED = MATERIALIZE_FIRST ? FRAME2_RESOLVED : resolved1;
152         MATERIALIZED_METHOD = MATERIALIZE_FIRST ? method1 : method2;
153         NOT_MATERIALIZED_METHOD = MATERIALIZE_FIRST ? method2 : method1;
154     }
155 
156     public static void main(String[] args) {
157         int levels[] = CompilerUtils.getAvailableCompilationLevels();
158         // we need compilation level 4 to use EscapeAnalysis
159         if (levels.length &lt; 1 || levels[levels.length - 1] != 4) {
160             throw new SkippedException(&quot;Test needs compilation level 4&quot;);
161         }
162 
163         new MaterializeVirtualObjectTest().test();
164     }
165 
166     private static String getName() {
167         return &quot;CASE: invalidate=&quot; + INVALIDATE + &quot;, materializedMethod=&quot;
168                 + (MATERIALIZE_FIRST ? &quot;testFrame&quot; : &quot;testFrame2&quot;)
169                 + &quot;, notMaterializedMethod=&quot;
170                 + (MATERIALIZE_FIRST ? &quot;testFrame2&quot; : &quot;testFrame&quot;);
171     }
172 
173     private void test() {
174         System.out.println(getName());
175         Asserts.assertFalse(WB.isMethodCompiled(MATERIALIZED_METHOD),
176                 getName() + &quot; : materialized method is compiled&quot;);
177         Asserts.assertFalse(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD),
178                 getName() + &quot; : not materialized method is compiled&quot;);
179         for (int i = 0; i &lt; CompilerWhiteBoxTest.THRESHOLD; i++) {
180             testFrame(&quot;someString&quot;, i);
181         }
182         Asserts.assertTrue(WB.isMethodCompiled(MATERIALIZED_METHOD), getName()
183                 + &quot; : materialized method not compiled&quot;);
184         Asserts.assertTrue(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD),
185                 getName() + &quot; : not materialized method not compiled&quot;);
186         testFrame(&quot;someString&quot;, /* materialize */ CompilerWhiteBoxTest.THRESHOLD);
187 
188         // run second test types
189         for (int i = 0; i &lt; CompilerWhiteBoxTest.THRESHOLD; i++) {
190             testFrame(&quot;someString&quot;, i);
191         }
192         Asserts.assertTrue(WB.isMethodCompiled(MATERIALIZED_METHOD), getName()
193                 + &quot; : materialized method not compiled&quot;);
194         Asserts.assertTrue(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD),
195                 getName() + &quot; : not materialized method not compiled&quot;);
196         testFrame(&quot;someString&quot;, /* materialize */ CompilerWhiteBoxTest.THRESHOLD + 1);
197     }
198 
199     private void testFrame(String str, int iteration) {
200         Helper helper = new Helper(str);
201         testFrame2(str, iteration);
202         Asserts.assertTrue((helper.string != null) &amp;&amp; (this != null)
203                 &amp;&amp; (helper != null), String.format(&quot;%s : some locals are null&quot;, getName()));
204     }
205 
206     private void testFrame2(String str, int iteration) {
207         Helper helper = new Helper(str);
208         Helper helper2 = new Helper(&quot;bar&quot;);
209         testFrame3(helper, iteration);
210         Asserts.assertTrue((helper.string != null) &amp;&amp; (this != null) &amp;&amp; helper.string == str
211                 &amp;&amp; (helper != null), String.format(&quot;%s : some locals are null&quot;, getName()));
212         Asserts.assertTrue((helper2.string != null) &amp;&amp; (this != null)
213                 &amp;&amp; (helper2 != null), String.format(&quot;%s : some locals are null&quot;, getName()));
214     }
215 
216     private void testFrame3(Helper outerHelper, int iteration) {
217         Helper innerHelper = new Helper(&quot;foo&quot;);
218         recurse(2, iteration);
219         Asserts.assertTrue((innerHelper.string != null) &amp;&amp; (this != null)
220                 &amp;&amp; (innerHelper != null), String.format(&quot;%s : some locals are null&quot;, getName()));
221         Asserts.assertTrue((outerHelper.string != null) &amp;&amp; (this != null)
222                 &amp;&amp; (outerHelper != null), String.format(&quot;%s : some locals are null&quot;, getName()));
223     }
224 
225     private void recurse(int depth, int iteration) {
226         if (depth == 0) {
227             check(iteration);
228         } else {
229             Integer s = new Integer(depth);
230             recurse(depth - 1, iteration);
231             Asserts.assertEQ(s.intValue(), depth,
232                     String.format(&quot;different values: %s != %s&quot;, s.intValue(), depth));
233         }
234     }
235 
236     private void checkStructure(boolean materialize) {
237         boolean[] framesSeen = new boolean[2];
238         Object[] helpers = new Object[1];
239         CompilerToVMHelper.iterateFrames(
240             new ResolvedJavaMethod[] {FRAME3_RESOLVED},
241             null, /* any */
242             0,
243             f -&gt; {
244                 if (!framesSeen[1]) {
245                     Asserts.assertTrue(f.isMethod(FRAME3_RESOLVED),
246                             &quot;Expected testFrame3 first&quot;);
247                     framesSeen[1] = true;
248                     Asserts.assertTrue(f.getLocal(0) != null, &quot;this should not be null&quot;);
249                     Asserts.assertTrue(f.getLocal(1) != null, &quot;outerHelper should not be null&quot;);
250                     Asserts.assertTrue(f.getLocal(3) != null, &quot;innerHelper should not be null&quot;);
251                     Asserts.assertEQ(((Helper) f.getLocal(3)).string, &quot;foo&quot;, &quot;innerHelper.string should be foo&quot;);
252                     helpers[0] = f.getLocal(1);
253                     if (materialize) {
254                         f.materializeVirtualObjects(false);
255                     }
256                     return null; //continue
257                 } else {
258                     Asserts.assertFalse(framesSeen[0], &quot;frame3 can not have been seen&quot;);
259                     Asserts.assertTrue(f.isMethod(FRAME2_RESOLVED),
260                             &quot;Expected testFrame2 second&quot;);
261                     framesSeen[0] = true;
262                     Asserts.assertTrue(f.getLocal(0) != null, &quot;this should not be null&quot;);
263                     Asserts.assertTrue(f.getLocal(1) != null, &quot;str should not be null&quot;);
264                     Asserts.assertTrue(f.getLocal(3) != null, &quot;helper should not be null&quot;);
265                     Asserts.assertTrue(f.getLocal(4) != null, &quot;helper2 should not be null&quot;);
266                     Asserts.assertEQ(((Helper) f.getLocal(3)).string, f.getLocal(1), &quot;helper.string should be the same as str&quot;);
267                     Asserts.assertEQ(((Helper) f.getLocal(4)).string, &quot;bar&quot;, &quot;helper2.string should be foo&quot;);
268                     if (!materialize) {
269                         Asserts.assertEQ(f.getLocal(3), helpers[0], &quot;helper should be the same as frame3&#39;s outerHelper&quot;);
270                     }
271                     return f; // stop
272                 }
273             });
274         Asserts.assertTrue(framesSeen[1], &quot;frame3 should have been seen&quot;);
275         Asserts.assertTrue(framesSeen[0], &quot;frame2 should have been seen&quot;);
276     }
277 
278     private void check(int iteration) {
279         // Materialize virtual objects on last invocation
280         if (iteration == COMPILE_THRESHOLD) {
281             // get frames and check not-null
282             HotSpotStackFrameReference materialized = CompilerToVMHelper.iterateFrames(
283                 new ResolvedJavaMethod[] {MATERIALIZED_RESOLVED},
284                 null /* any */,
285                 0,
286                 f -&gt; (HotSpotStackFrameReference) f);
287             Asserts.assertNotNull(materialized, getName()
288                     + &quot; : got null frame for materialized method&quot;);
289             Asserts.assertTrue(materialized.isMethod(MATERIALIZED_RESOLVED),
290                 &quot;Expected materialized method but got &quot; + materialized);
291             InspectedFrame notMaterialized = CompilerToVMHelper.iterateFrames(
292                 new ResolvedJavaMethod[] {NOT_MATERIALIZED_RESOLVED},
293                 null /* any */,
294                 0,
295                 f -&gt; f);
296             Asserts.assertNE(materialized, notMaterialized,
297                     &quot;Got same frame pointer for both tested frames&quot;);
298             Asserts.assertTrue(notMaterialized.isMethod(NOT_MATERIALIZED_RESOLVED),
299                 &quot;Expected notMaterialized method but got &quot; + notMaterialized);
300             Asserts.assertNotNull(notMaterialized, getName()
301                     + &quot; : got null frame for not materialized method&quot;);
302             Asserts.assertTrue(WB.isMethodCompiled(MATERIALIZED_METHOD), getName()
303                 + &quot; : materialized method not compiled&quot;);
304             Asserts.assertTrue(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD),
305                 getName() + &quot; : not materialized method not compiled&quot;);
306             // check that frames has virtual objects before materialization stage
307             Asserts.assertTrue(materialized.hasVirtualObjects(), getName()
308                     + &quot;: materialized frame has no virtual object before materialization&quot;);
309             Asserts.assertTrue(notMaterialized.hasVirtualObjects(), getName()
310                     + &quot;: notMaterialized frame has no virtual object before materialization&quot;);
311             // materialize
312             CompilerToVMHelper.materializeVirtualObjects(materialized, INVALIDATE);
313             // check that only not materialized frame has virtual objects
314             Asserts.assertFalse(materialized.hasVirtualObjects(), getName()
315                     + &quot; : materialized has virtual object after materialization&quot;);
316             Asserts.assertTrue(notMaterialized.hasVirtualObjects(), getName()
317                     + &quot; : notMaterialized has no virtual object after materialization&quot;);
318             // check that materialized frame was deoptimized in case invalidate=true
319             Asserts.assertEQ(WB.isMethodCompiled(MATERIALIZED_METHOD), !INVALIDATE, getName()
320                     + &quot; : materialized method has unexpected compiled status&quot;);
321             // check that not materialized frame wasn&#39;t deoptimized
322             Asserts.assertTrue(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD), getName()
323                     + &quot; : not materialized method has unexpected compiled status&quot;);
324         } else if (iteration == COMPILE_THRESHOLD + 1) {
325             checkStructure(false);
326             checkStructure(true);
327         }
328     }
329 
330     private class Helper {
331         public String string;
332 
333         public Helper(String s) {
334             this.string = s;
335         }
336     }
337 }
    </pre>
  </body>
</html>
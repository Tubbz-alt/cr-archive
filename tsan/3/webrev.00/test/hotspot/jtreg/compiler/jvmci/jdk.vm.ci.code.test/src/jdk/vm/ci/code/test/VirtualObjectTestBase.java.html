<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.code.test/src/jdk/vm/ci/code/test/VirtualObjectTestBase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.code.test;
 24 
 25 import java.util.Arrays;
 26 
 27 import jdk.vm.ci.meta.JavaConstant;
 28 import jdk.vm.ci.meta.JavaKind;
 29 import jdk.vm.ci.meta.JavaValue;
 30 import jdk.vm.ci.meta.MetaAccessProvider;
 31 import jdk.vm.ci.meta.ResolvedJavaField;
 32 import jdk.vm.ci.meta.ResolvedJavaType;
 33 import jdk.vm.ci.runtime.JVMCI;
 34 
 35 public abstract class VirtualObjectTestBase {
 36 
 37     public static class SimpleObject {
 38         int i1;
 39         int i2;
 40         int i3;
 41         int i4;
 42         int i5;
 43         int i6;
 44     }
 45 
 46     public static JavaConstant getValue(JavaKind kind) {
 47         long dummyValue = kind.ordinal();
 48         dummyValue = dummyValue | dummyValue &lt;&lt; 8;
 49         dummyValue = dummyValue | dummyValue &lt;&lt; 16;
 50         dummyValue = dummyValue | dummyValue &lt;&lt; 32;
 51         if (kind.isNumericInteger()) {
 52             return JavaConstant.forIntegerKind(kind, dummyValue);
 53         } else if (kind == JavaKind.Float) {
 54             return JavaConstant.forDouble(Double.longBitsToDouble(dummyValue));
 55         } else if (kind == JavaKind.Float) {
 56             return JavaConstant.forFloat(Float.intBitsToFloat((int) dummyValue));
 57         } else {
 58             return JavaConstant.NULL_POINTER;
 59         }
 60     }
 61 
 62     public static JavaValue[] getJavaValues(JavaKind[] kinds) {
 63         JavaValue[] values = new JavaValue[kinds.length];
 64         for (int i = 0; i &lt; kinds.length; i++) {
 65             values[i] = getValue(kinds[i]);
 66         }
 67         return values;
 68     }
 69 
 70     /**
 71      * Subclasses are expected to override this method to provide their own verification logic using
 72      * the normal JUnit {@link org.junit.Assert} methods.
 73      *
 74      * @param klass class for the {@link jdk.vm.ci.code.VirtualObject}
 75      * @param kinds {@link JavaKind Javakinds} for values
 76      * @param values {@link JavaValue values} for materializing the
 77      *            {@link jdk.vm.ci.code.VirtualObject}
 78      * @param malformed indicates whether the resulting virtual object is considered to be properly
 79      *            formed relative to the fields of {@code klass}
 80      * @throws AssertionError if a problem is detected
 81      */
 82     protected abstract void test(ResolvedJavaType klass, JavaValue[] kinds, JavaKind[] values, boolean malformed);
 83 
 84     public void testBase() {
 85         MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();
 86 
 87         ResolvedJavaType simple = metaAccess.lookupJavaType(SimpleObject.class);
 88         ResolvedJavaField[] fields = simple.getInstanceFields(true);
 89 
 90         JavaKind[] fieldKinds = new JavaKind[fields.length];
 91         for (int i = 0; i &lt; fields.length; i++) {
 92             fieldKinds[i] = fields[i].getType().getJavaKind();
 93         }
 94 
 95         // Generate a straightforward VirtualObject with values that match to declared field types.
 96         JavaKind[] kinds = fieldKinds.clone();
 97         JavaValue[] values = getJavaValues(kinds);
 98         test(simple, values, kinds, false);
 99 
100         // Spread a long value across two int fields starting at an aligned field
101         kinds = Arrays.copyOf(fieldKinds, fieldKinds.length - 1);
102         kinds[fields[0].getOffset() % 8 == 0 ? 0 : 1] = JavaKind.Long;
103         test(simple, getJavaValues(kinds), kinds, false);
104 
105         // Produce a long value for the final int field so there is no matching int field for the
106         // second half of the long
107         kinds = fieldKinds.clone();
108         kinds[kinds.length - 1] = JavaKind.Long;
109         test(simple, getJavaValues(kinds), kinds, true);
110 
111         // Not enough values for the fields.
112         kinds = Arrays.copyOf(fieldKinds, fieldKinds.length - 1);
113         test(simple, getJavaValues(kinds), kinds, true);
114 
115         // Too many values for the fields.
116         kinds = Arrays.copyOf(fieldKinds, fieldKinds.length + 1);
117         kinds[kinds.length - 1] = JavaKind.Int;
118         test(simple, getJavaValues(kinds), kinds, true);
119     }
120 }
    </pre>
  </body>
</html>
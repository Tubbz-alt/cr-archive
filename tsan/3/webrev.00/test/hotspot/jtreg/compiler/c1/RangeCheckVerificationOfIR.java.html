<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/c1/RangeCheckVerificationOfIR.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 8238178
 27  * @summary Checks the C1 RangeCheckEliminator::Verification code for nested exceptions in loops that are always executed once on the non-exceptional path.
 28  *
 29  * @run main/othervm -Xbatch -XX:TieredStopAtLevel=1 -XX:CompileCommand=dontinline,compiler.c1.RangeCheckVerificationOfIR::throwException*
 30  *                   -XX:CompileCommand=dontinline,compiler.c1.RangeCheckVerificationOfIR::test* compiler.c1.RangeCheckVerificationOfIR
 31  */
 32 
 33 package compiler.c1;
 34 
 35 public class RangeCheckVerificationOfIR {
 36 
 37     int a;
 38     int i1;
 39     int i2;
 40     int i3;
 41 
 42     public static void main(String[] args) {
 43         RangeCheckVerificationOfIR instance = new RangeCheckVerificationOfIR();
 44         instance.resetValues();
 45         for (int i = 0; i &lt; 1000; i++) {
 46             instance.testSimple();
 47             instance.resetValues();
 48             instance.testDominatedByXhandler();
 49             instance.resetValues();
 50             instance.testThrowOneException();
 51             instance.resetValues();
 52             instance.testNestedExceptions();
 53             instance.resetValues();
 54             instance.testTriplyNestedExceptions();
 55             instance.resetValues();
 56             instance.testTriplyNestedExceptions2();
 57             instance.resetValues();
 58             instance.testTriplyNestedMultipleHandlers();
 59             instance.resetValues();
 60             instance.testTriplyNestedNoExceptionThrown();
 61             instance.resetValues();
 62         }
 63     }
 64 
 65     private void resetValues() {
 66         i1 = 0;
 67         i2 = 0;
 68         i3 = 0;
 69     }
 70 
 71     // Is handled by current code (xhandler equals a pred of loop header block)
 72     public void testSimple() {
 73         int[] iArr = new int[8];
 74         for (int i = 0; i &lt; 8; i++) {
 75             iArr[0] = 4;
 76         }
 77 
 78         while (true) {
 79             try {
 80                 throwException();
 81                 break;
 82             } catch(Exception ex1) {
 83                 i1++;
 84             }
 85         }
 86 
 87         for (int i = 0; i &lt; 10; i++) {
 88             a = 5;
 89         }
 90     }
 91 
 92     // Is handled by current code (xhandler dominates a pred of loop header block)
 93     public void testDominatedByXhandler() {
 94         int[] iArr = new int[8];
 95         for (int i = 0; i &lt; 8; i++) {
 96             iArr[0] = 4;
 97         }
 98 
 99         while (true) {
100             try {
101                 throwException();
102                 break;
103             } catch (Exception ex1) {
104                 if (i1 &lt; i2) {
105                     a = 3;
106                 } else {
107                     a = 4;
108                 }
109                 i1++;
110             }
111         }
112 
113         for (int i = 0; i &lt; 10; i++) {
114             a = 5;
115         }
116     }
117 
118     // Not a problem, since no backbranch and therefore no loop
119     public void testThrowOneException() {
120         int[] iArr = new int[8];
121         for (int i = 0; i &lt; 8; i++) {
122             iArr[0] = 4;
123         }
124 
125         try {
126             for (int i = 0; i &lt; iArr[4]; i++) {
127                 throwException();
128             }
129         } catch (Exception ex) {
130             a = 345;
131         }
132 
133         try {
134             while (true) {
135                 throwException();
136                 break;
137             }
138         } catch (Exception e) {
139             a = 45;
140         }
141 
142         for (int i = 0; i &lt; 10; i++) {
143             a = 5;
144         }
145     }
146 
147     // All following cases are not handled yet. Need to walk backbranch of loop header block
148     // to find one of the exception handlers of loop header block somewhere. Must exist.
149     public void testNestedExceptions() {
150         int[] iArr = new int[8];
151         for (int i = 0; i &lt; 8; i++) {
152             iArr[0] = 4;
153         }
154 
155         // The block from the backbranch, lets say B, is no xhandler block and not dominated by either of the two xhandler blocks, lets say
156         // E1 for the outer and E2 for the inner try/catch block: If no exception occurs in E1, then E1 is completely executed without
157         // executing E2. But if an exception occurs, then only parts of E1 is executed and E2 is executed completely.
158         // Therefore, neither of them dominates B.
159         while (true) {
160             try {
161                 throwException();
162                 break;
163             } catch (Exception ex1) {
164                 i1++;
165                 try {
166                     throwException2();
167                 } catch (Exception ex2) {
168                     if (i1 &lt; i2) {
169                         a = 3;
170                     } else {
171                         a = 4;
172                     }
173                     i2++;
174                 }
175                 if (i1 &lt; i2) {
176                     a = 3;
177                 } else {
178                     a = 4;
179                 }
180                 i1++;
181             }
182         }
183 
184         for (int i = 0; i &lt; 10; i++) {
185             a = 5;
186         }
187     }
188 
189     public void testTriplyNestedExceptions() {
190         int[] iArr = new int[8];
191         for (int i = 0; i &lt; 8; i++) {
192             iArr[0] = 4;
193         }
194 
195         while (true) {
196             try {
197                 throwException();
198                 break;
199             } catch (Exception ex1) {
200                 i1++;
201                 try {
202                     throwException2();
203                 } catch (Exception ex2) {
204                     if (i1 &lt; i2) {
205                         a = 3;
206                     } else {
207                         a = 4;
208                     }
209                     try {
210                         throwException3();
211                     } catch (Exception ex3) {
212                         i3++;
213                     }
214                     try {
215                         throwException3();
216                     } catch (Exception ex3) {
217                         i3++;
218                     }
219                     i2++;
220                 }
221                 if (i1 &lt; i2) {
222                     a = 3;
223                 } else {
224                     a = 4;
225                 }
226                 i1++;
227             }
228         }
229 
230         for (int i = 0; i &lt; 10; i++) {
231             a = 5;
232         }
233     }
234 
235     public void testTriplyNestedExceptions2() {
236         int[] iArr = new int[8];
237         for (int i = 0; i &lt; 8; i++) {
238             iArr[0] = 4;
239         }
240 
241         try {
242             for (int i = 0; i &lt; iArr[4]; i++) {
243                 throwException();
244             }
245         } catch (Exception ex) {
246             a = 345;
247         }
248 
249         while (true) {
250             try {
251                 throwException();
252                 break;
253             } catch (Exception ex1) {
254                 i1++;
255                 try {
256                     throwException2();
257                 } catch (Exception ex2) {
258                     if (i1 &lt; i2) {
259                         a = 3;
260                     } else {
261                         a = 4;
262                     }
263                     try {
264                         throwException3();
265                     } catch (Exception ex3) {
266                         i3++;
267                     }
268                     try {
269                         throwException3();
270                     } catch (Exception ex3) {
271                         i3++;
272                     }
273                     i2++;
274                 }
275                 if (i1 &lt; i2) {
276                     a = 3;
277                 } else {
278                     a = 4;
279                 }
280                 i1++;
281             }
282         }
283 
284         for (int i = 0; i &lt; 10; i++) {
285             a = 5;
286         }
287     }
288 
289     public void testTriplyNestedMultipleHandlers() {
290         int[] iArr = new int[8];
291         for (int i = 0; i &lt; 8; i++) {
292             iArr[0] = 4;
293         }
294 
295         try {
296             for (int i = 0; i &lt; iArr[4]; i++) {
297                 throwException();
298             }
299         } catch (Exception ex) {
300             a = 345;
301         }
302 
303         try {
304             while (true) {
305                 try {
306                     throwException();
307                     break;
308                 } catch (MyInnerException ie) {
309                     i1++;
310                     try {
311                         throwException2();
312                     } catch (Exception ex2) {
313                         if (i1 &lt; i2) {
314                             a = 3;
315                         } else {
316                             a = 4;
317                         }
318                         try {
319                             throwException3();
320                         } catch (Exception ex3) {
321                             i3++;
322                         }
323                         try {
324                             throwException3();
325                         } catch (Exception ex3) {
326                             i3++;
327                         }
328                         i2++;
329                     }
330                     if (i1 &lt; i2) {
331                         a = 3;
332                     } else {
333                         a = 4;
334                     }
335                     i1++;
336                 }
337             }
338         } catch (MyOuterException oe) {
339             a = 45;
340         }
341 
342         for (int i = 0; i &lt; 10; i++) {
343             a = 5;
344         }
345     }
346 
347     public void testTriplyNestedNoExceptionThrown() {
348         int[] iArr = new int[8];
349         for (int i = 0; i &lt; 8; i++) {
350             iArr[0] = 4;
351         }
352 
353         try {
354             for (int i = 0; i &lt; iArr[4]; i++) {
355                 throwException();
356             }
357         } catch (Exception ex) {
358             a = 345;
359         }
360 
361         try {
362             while (true) {
363                 try {
364                     a = 4;
365                     break;
366                 } catch (RuntimeException ie) {
367                     i1++;
368                     try {
369                         throwException2();
370                     } catch (Exception ex2) {
371                         if (i1 &lt; i2) {
372                             a = 3;
373                         } else {
374                             a = 4;
375                         }
376                         try {
377                             throwException3();
378                         } catch (Exception ex3) {
379                             i3++;
380                         }
381                         try {
382                             throwException3();
383                         } catch (Exception ex3) {
384                             i3++;
385                         }
386                         i2++;
387                     }
388                     if (i1 &lt; i2) {
389                         a = 3;
390                     } else {
391                         a = 4;
392                     }
393                     i1++;
394                 }
395             }
396         } catch (Exception e) {
397             a = 45;
398         }
399 
400         for (int i = 0; i &lt; 10; i++) {
401             a = 5;
402         }
403     }
404 
405     void throwException() throws MyInnerException, MyOuterException {
406         if (i1 &lt; 3) {
407             throw new MyInnerException();
408         }
409         if (i1 &lt; 5) {
410             throw new MyOuterException();
411         }
412     }
413 
414     public void throwException2() throws Exception {
415         if (i2 &lt; 3) {
416             throw new RuntimeException();
417         }
418     }
419 
420     public void throwException3() throws Exception {
421         if (i3 &lt; 2) {
422             throw new RuntimeException();
423         }
424     }
425 
426     class MyInnerException extends Exception { }
427 
428     class MyOuterException extends Exception { }
429 }
    </pre>
  </body>
</html>
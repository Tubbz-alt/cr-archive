<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/serviceability/AsyncGetCallTrace/libAsyncGetCallTraceTest.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2019, Google and/or its affiliates. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 #include &lt;assert.h&gt;
 26 #include &lt;dlfcn.h&gt;
 27 #include &lt;stdio.h&gt;
 28 #include &lt;stdlib.h&gt;
 29 #include &lt;string.h&gt;
 30 #include &quot;jvmti.h&quot;
 31 
 32 static jvmtiEnv* jvmti;
 33 
 34 template &lt;class T&gt;
 35 class JvmtiDeallocator {
 36  public:
 37   JvmtiDeallocator() {
 38     elem_ = NULL;
 39   }
 40 
 41   ~JvmtiDeallocator() {
 42     jvmti-&gt;Deallocate(reinterpret_cast&lt;unsigned char*&gt;(elem_));
 43   }
 44 
 45   T* get_addr() {
 46     return &amp;elem_;
 47   }
 48 
 49   T get() {
 50     return elem_;
 51   }
 52 
 53  private:
 54   T elem_;
 55 };
 56 
 57 static void GetJMethodIDs(jclass klass) {
 58   jint method_count = 0;
 59   JvmtiDeallocator&lt;jmethodID*&gt; methods;
 60   jvmtiError err = jvmti-&gt;GetClassMethods(klass, &amp;method_count, methods.get_addr());
 61 
 62   // If ever the GetClassMethods fails, just ignore it, it was worth a try.
 63   if (err != JVMTI_ERROR_NONE) {
 64     fprintf(stderr, &quot;GetJMethodIDs: Error in GetClassMethods: %d\n&quot;, err);
 65   }
 66 }
 67 
 68 // AsyncGetCallTrace needs class loading events to be turned on!
 69 static void JNICALL OnClassLoad(jvmtiEnv *jvmti, JNIEnv *jni_env,
 70                                 jthread thread, jclass klass) {
 71 }
 72 
 73 static void JNICALL OnClassPrepare(jvmtiEnv *jvmti, JNIEnv *jni_env,
 74                                    jthread thread, jclass klass) {
 75   // We need to do this to &quot;prime the pump&quot; and get jmethodIDs primed.
 76   GetJMethodIDs(klass);
 77 }
 78 
 79 static void JNICALL OnVMInit(jvmtiEnv *jvmti, JNIEnv *jni_env, jthread thread) {
 80   jint class_count = 0;
 81 
 82   // Get any previously loaded classes that won&#39;t have gone through the
 83   // OnClassPrepare callback to prime the jmethods for AsyncGetCallTrace.
 84   JvmtiDeallocator&lt;jclass*&gt; classes;
 85   jvmtiError err = jvmti-&gt;GetLoadedClasses(&amp;class_count, classes.get_addr());
 86   if (err != JVMTI_ERROR_NONE) {
 87     fprintf(stderr, &quot;OnVMInit: Error in GetLoadedClasses: %d\n&quot;, err);
 88     return;
 89   }
 90 
 91   // Prime any class already loaded and try to get the jmethodIDs set up.
 92   jclass *classList = classes.get();
 93   for (int i = 0; i &lt; class_count; ++i) {
 94     GetJMethodIDs(classList[i]);
 95   }
 96 }
 97 
 98 extern &quot;C&quot; {
 99 
100 static
101 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
102   jint res = jvm-&gt;GetEnv((void **) &amp;jvmti, JVMTI_VERSION);
103   if (res != JNI_OK || jvmti == NULL) {
104     fprintf(stderr, &quot;Error: wrong result of a valid call to GetEnv!\n&quot;);
105     return JNI_ERR;
106   }
107 
108   jvmtiError err;
109   jvmtiCapabilities caps;
110   memset(&amp;caps, 0, sizeof(caps));
111   caps.can_get_line_numbers = 1;
112   caps.can_get_source_file_name = 1;
113 
114   err = jvmti-&gt;AddCapabilities(&amp;caps);
115   if (err != JVMTI_ERROR_NONE) {
116     fprintf(stderr, &quot;AgentInitialize: Error in AddCapabilities: %d\n&quot;, err);
117     return JNI_ERR;
118   }
119 
120   jvmtiEventCallbacks callbacks;
121   memset(&amp;callbacks, 0, sizeof(callbacks));
122   callbacks.ClassLoad = &amp;OnClassLoad;
123   callbacks.VMInit = &amp;OnVMInit;
124   callbacks.ClassPrepare = &amp;OnClassPrepare;
125 
126   err = jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(jvmtiEventCallbacks));
127   if (err != JVMTI_ERROR_NONE) {
128     fprintf(stderr, &quot;AgentInitialize: Error in SetEventCallbacks: %d\n&quot;, err);
129     return JNI_ERR;
130   }
131 
132   err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL);
133   if (err != JVMTI_ERROR_NONE) {
134     fprintf(stderr, &quot;AgentInitialize: Error in SetEventNotificationMode for CLASS_LOAD: %d\n&quot;, err);
135     return JNI_ERR;
136   }
137 
138   err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL);
139   if (err != JVMTI_ERROR_NONE) {
140     fprintf(stderr,
141             &quot;AgentInitialize: Error in SetEventNotificationMode for CLASS_PREPARE: %d\n&quot;,
142             err);
143     return JNI_ERR;
144   }
145 
146   err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);
147   if (err != JVMTI_ERROR_NONE) {
148     fprintf(
149         stderr, &quot;AgentInitialize: Error in SetEventNotificationMode for VM_INIT: %d\n&quot;,
150         err);
151     return JNI_ERR;
152   }
153 
154   return JNI_OK;
155 }
156 
157 JNIEXPORT
158 jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {
159   return Agent_Initialize(jvm, options, reserved);
160 }
161 
162 JNIEXPORT
163 jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {
164   return Agent_Initialize(jvm, options, reserved);
165 }
166 
167 JNIEXPORT
168 jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {
169   return JNI_VERSION_1_8;
170 }
171 
172 // A copy of the ASGCT data structures.
173 typedef struct {
174     jint lineno;                      // line number in the source file
175     jmethodID method_id;              // method executed in this frame
176 } ASGCT_CallFrame;
177 
178 typedef struct {
179     JNIEnv *env_id;                   // Env where trace was recorded
180     jint num_frames;                  // number of frames in this trace
181     ASGCT_CallFrame *frames;          // frames
182 } ASGCT_CallTrace;
183 
184 typedef void (*ASGCTType)(ASGCT_CallTrace *, jint, void *);
185 
186 JNIEXPORT jboolean JNICALL
187 Java_MyPackage_ASGCTBaseTest_checkAsyncGetCallTraceCall(JNIEnv* env, jclass cls) {
188   ASGCTType agct = reinterpret_cast&lt;ASGCTType&gt;(dlsym(RTLD_DEFAULT, &quot;AsyncGetCallTrace&quot;));
189 
190   const int MAX_DEPTH = 16;
191   ASGCT_CallTrace trace;
192   ASGCT_CallFrame frames[MAX_DEPTH];
193   trace.frames = frames;
194   trace.env_id = env;
195   trace.num_frames = 0;
196 
197   if (agct == NULL) {
198     fprintf(stderr, &quot;AsyncGetCallTrace not found.\n&quot;);
199     return false;
200   }
201 
202   agct(&amp;trace, MAX_DEPTH, NULL);
203 
204   // For now, just check that the first frame is (-3, checkAsyncGetCallTraceCall).
205   if (trace.num_frames &lt;= 0) {
206     fprintf(stderr, &quot;The num_frames must be positive: %d\n&quot;, trace.num_frames);
207     return false;
208   }
209 
210   // AsyncGetCallTrace returns -3 as line number for a native frame.
211   if (trace.frames[0].lineno != -3) {
212     fprintf(stderr, &quot;lineno is not -3 as expected: %d\n&quot;, trace.frames[0].lineno);
213     return false;
214   }
215 
216   JvmtiDeallocator&lt;char*&gt; name;
217   if (trace.frames[0].method_id == NULL) {
218     fprintf(stderr, &quot;First frame method_id is NULL\n&quot;);
219     return false;
220   }
221 
222   jvmtiError err = jvmti-&gt;GetMethodName(trace.frames[0].method_id, name.get_addr(), NULL, NULL);
223   if (err != JVMTI_ERROR_NONE) {
224     fprintf(stderr, &quot;checkAsyncGetCallTrace: Error in GetMethodName: %d\n&quot;, err);
225     return false;
226   }
227 
228   if (name.get() == NULL) {
229     fprintf(stderr, &quot;Name is NULL\n&quot;);
230     return false;
231   }
232 
233   return strcmp(name.get(), &quot;checkAsyncGetCallTraceCall&quot;) == 0;
234 }
235 
236 }
    </pre>
  </body>
</html>
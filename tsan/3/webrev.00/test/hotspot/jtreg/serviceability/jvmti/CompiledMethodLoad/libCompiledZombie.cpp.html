<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/serviceability/jvmti/CompiledMethodLoad/libCompiledZombie.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
 1 /*
 2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 4  *
 5  * This code is free software; you can redistribute it and/or modify it
 6  * under the terms of the GNU General Public License version 2 only, as
 7  * published by the Free Software Foundation.
 8  *
 9  * This code is distributed in the hope that it will be useful, but WITHOUT
10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
12  * version 2 for more details (a copy is included in the LICENSE file that
13  * accompanied this code).
14  *
15  * You should have received a copy of the GNU General Public License version
16  * 2 along with this work; if not, write to the Free Software Foundation,
17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
18  *
19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
20  * or visit www.oracle.com if you need additional information or have any
21  * questions.
22  */
23 
24 #include &lt;stdio.h&gt;
25 #include &lt;stdlib.h&gt;
26 #include &lt;string.h&gt;
27 
28 #include &quot;jvmti.h&quot;
29 #include &quot;jni.h&quot;
30 
31 #ifdef __cplusplus
32 extern &quot;C&quot; {
33 #endif
34 
35 static int events;
36 static int total_events = 0;
37 
38 void JNICALL CompiledMethodLoad(jvmtiEnv* jvmti, jmethodID method,
39                                 jint code_size, const void* code_addr,
40                                 jint map_length, const jvmtiAddrLocationMap* map,
41                                 const void* compile_info) {
42     events++;
43     total_events++;
44 }
45 
46 // Continuously generate CompiledMethodLoad events for all currently compiled methods
47 void JNICALL GenerateEventsThread(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
48     jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL);
49     int count = 0;
50 
51     while (true) {
52         events = 0;
53         jvmti-&gt;GenerateEvents(JVMTI_EVENT_COMPILED_METHOD_LOAD);
54         if (events != 0 &amp;&amp; ++count == 200) {
55             printf(&quot;Generated %d events\n&quot;, events);
56             count = 0;
57         }
58     }
59 }
60 
61 // As soon as VM starts, run a separate Agent thread that will generate CompiledMethodLoad events
62 void JNICALL VMInit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread) {
63     jclass thread_class = jni-&gt;FindClass(&quot;java/lang/Thread&quot;);
64     jmethodID thread_constructor = jni-&gt;GetMethodID(thread_class, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
65     jthread agent_thread = jni-&gt;NewObject(thread_class, thread_constructor);
66 
67     jvmti-&gt;RunAgentThread(agent_thread, GenerateEventsThread, NULL, JVMTI_THREAD_NORM_PRIORITY);
68 }
69 
70 JNIEXPORT
71 jint JNICALL Agent_OnLoad(JavaVM* vm, char* options, void* reserved) {
72     jvmtiEnv* jvmti;
73     vm-&gt;GetEnv((void**)&amp;jvmti, JVMTI_VERSION_1_0);
74 
75     jvmtiCapabilities capabilities;
76     memset(&amp;capabilities, 0, sizeof(capabilities));
77 
78     capabilities.can_generate_compiled_method_load_events = 1;
79     jvmti-&gt;AddCapabilities(&amp;capabilities);
80 
81     jvmtiEventCallbacks callbacks;
82     memset(&amp;callbacks, 0, sizeof(callbacks));
83     callbacks.VMInit = VMInit;
84     callbacks.CompiledMethodLoad = CompiledMethodLoad;
85     jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));
86     jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);
87 
88     return 0;
89 }
90 
91 #ifdef __cplusplus
92 }
93 #endif
94 
    </pre>
  </body>
</html>
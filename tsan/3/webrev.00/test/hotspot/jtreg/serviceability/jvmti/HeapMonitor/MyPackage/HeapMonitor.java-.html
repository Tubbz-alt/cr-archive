<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/serviceability/jvmti/HeapMonitor/MyPackage/HeapMonitor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2018, Google and/or its affiliates. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 package MyPackage;
 26 
 27 import java.lang.management.ManagementFactory;
 28 import java.util.ArrayList;
 29 import java.util.List;
 30 
 31 import com.sun.management.HotSpotDiagnosticMXBean;
 32 import com.sun.management.VMOption;
 33 
 34 /** API for handling the underlying heap sampling monitoring system. */
 35 public class HeapMonitor {
 36   private static int[][] arrays;
 37   private static int allocationIterations = 1000;
 38 
 39   static {
 40     try {
 41       System.loadLibrary(&quot;HeapMonitorTest&quot;);
 42     } catch (UnsatisfiedLinkError ule) {
 43       System.err.println(&quot;Could not load HeapMonitor library&quot;);
 44       System.err.println(&quot;java.library.path: &quot; + System.getProperty(&quot;java.library.path&quot;));
 45       throw ule;
 46     }
 47   }
 48 
 49   /** Set a specific sampling interval, 0 samples every allocation. */
 50   public native static void setSamplingInterval(int interval);
 51   public native static void enableSamplingEvents();
 52   public native static boolean enableSamplingEventsForTwoThreads(Thread firstThread, Thread secondThread);
 53   public native static void disableSamplingEvents();
 54 
 55   /**
 56    * Allocate memory but first create a stack trace.
 57    *
 58    * @return list of frames for the allocation.
 59    */
 60   public static List&lt;Frame&gt; allocate() {
 61     int sum = 0;
 62     List&lt;Frame&gt; frames = new ArrayList&lt;Frame&gt;();
 63     allocate(frames);
 64     frames.add(new Frame(&quot;allocate&quot;, &quot;()Ljava/util/List;&quot;, &quot;HeapMonitor.java&quot;, 63));
 65     return frames;
 66   }
 67 
 68   private static void allocate(List&lt;Frame&gt; frames) {
 69     int sum = 0;
 70     for (int j = 0; j &lt; allocationIterations; j++) {
 71       sum += actuallyAllocate();
 72     }
 73     frames.add(new Frame(&quot;actuallyAllocate&quot;, &quot;()I&quot;, &quot;HeapMonitor.java&quot;, 98));
 74     frames.add(new Frame(&quot;allocate&quot;, &quot;(Ljava/util/List;)V&quot;, &quot;HeapMonitor.java&quot;, 71));
 75   }
 76 
 77   public static List&lt;Frame&gt; repeatAllocate(int max) {
 78     List&lt;Frame&gt; frames = null;
 79     for (int i = 0; i &lt; max; i++) {
 80       frames = allocate();
 81     }
 82     frames.add(new Frame(&quot;repeatAllocate&quot;, &quot;(I)Ljava/util/List;&quot;, &quot;HeapMonitor.java&quot;, 80));
 83     return frames;
 84   }
 85 
 86   private static int actuallyAllocate() {
 87     int sum = 0;
 88 
 89     // Let us assume that a 1-element array is 24 bytes of memory and we want
 90     // 2MB allocated.
 91     int iterations = (1 &lt;&lt; 19) / 6;
 92 
 93     if (arrays == null) {
 94       arrays = new int[iterations][];
 95     }
 96 
 97     for (int i = 0; i &lt; iterations; i++) {
 98       int tmp[] = new int[1];
 99       // Force it to be kept and, at the same time, wipe out any previous data.
100       arrays[i] = tmp;
101       sum += arrays[0][0];
102     }
103     return sum;
104   }
105 
106   private static long oneElementSize;
107   private static native long getSize(Frame[] frames, boolean checkLines);
108   private static long getSize(Frame[] frames) {
109     return getSize(frames, getCheckLines());
110   }
111 
112   // Calculate the size of a 1-element array in order to assess sampling interval
113   // via the HeapMonitorStatIntervalTest.
114   // This is done by allocating a 1-element array and then looking in the heap monitoring
115   // samples for the size of an object collected.
116   public static void calculateOneElementSize() {
117     enableSamplingEvents();
118 
119     List&lt;Frame&gt; frameList = allocate();
120     disableSamplingEvents();
121 
122     frameList.add(new Frame(&quot;calculateOneElementSize&quot;, &quot;()V&quot;, &quot;HeapMonitor.java&quot;, 119));
123     Frame[] frames = frameList.toArray(new Frame[0]);
124 
125     // Get the actual size.
126     oneElementSize = getSize(frames);
127     System.out.println(&quot;Element size is: &quot; + oneElementSize);
128 
129     if (oneElementSize == 0) {
130       throw new RuntimeException(&quot;Could get the size of a 1-element array.&quot;);
131     }
132   }
133 
134   public static int allocateSize(int totalSize) {
135     if (oneElementSize == 0) {
136       throw new RuntimeException(&quot;Size of a 1-element array was not calculated.&quot;);
137     }
138 
139     int sum = 0;
140     int iterations = (int) (totalSize / oneElementSize);
141 
142     if (arrays == null || arrays.length &lt; iterations) {
143       arrays = new int[iterations][];
144     }
145 
146     System.out.println(&quot;Allocating for &quot; + iterations);
147     for (int i = 0; i &lt; iterations; i++) {
148       int tmp[] = new int[1];
149 
150       // Force it to be kept and, at the same time, wipe out any previous data.
151       arrays[i] = tmp;
152       sum += arrays[0][0];
153     }
154 
155     return sum;
156   }
157 
158   /** Remove the reference to the global array to free data at the next GC. */
159   public static void freeStorage() {
160     arrays = null;
161   }
162 
163   public static int[][][] sampleEverything() {
164     enableSamplingEvents();
165     setSamplingInterval(0);
166 
167     // Loop around an allocation loop and wait until the tlabs have settled.
168     final int maxTries = 10;
169     int[][][] result = new int[maxTries][][];
170     for (int i = 0; i &lt; maxTries; i++) {
171       final int maxInternalTries = 400;
172       result[i] = new int[maxInternalTries][];
173 
174       resetEventStorage();
175       for (int j = 0; j &lt; maxInternalTries; j++) {
176         final int size = 1000;
177         result[i][j] = new int[size];
178       }
179 
180       int sampledEvents = sampledEvents();
181       if (sampledEvents == maxInternalTries) {
182         return result;
183       }
184     }
185 
186     throw new RuntimeException(&quot;Could not set the sampler&quot;);
187   }
188 
189   public static Frame[] allocateAndCheckFrames(boolean shouldFindFrames,
190       boolean enableSampling) {
191     if (!eventStorageIsEmpty()) {
192       throw new RuntimeException(&quot;Statistics should be null to begin with.&quot;);
193     }
194 
195     // Put sampling rate to 100k to ensure samples are collected.
196     setSamplingInterval(100 * 1024);
197 
198     if (enableSampling) {
199       enableSamplingEvents();
200     }
201 
202     List&lt;Frame&gt; frameList = allocate();
203     frameList.add(new Frame(&quot;allocateAndCheckFrames&quot;, &quot;(ZZ)[LMyPackage/Frame;&quot;, &quot;HeapMonitor.java&quot;,
204           202));
205     Frame[] frames = frameList.toArray(new Frame[0]);
206 
207     boolean foundLive = obtainedEvents(frames);
208     boolean foundGarbage = garbageContains(frames);
209     if (shouldFindFrames) {
210       if (!foundLive &amp;&amp; !foundGarbage) {
211         throw new RuntimeException(&quot;No expected events were found: &quot;
212             + foundLive + &quot;, &quot; + foundGarbage);
213       }
214     } else {
215       if (foundLive || foundGarbage) {
216         throw new RuntimeException(&quot;Were not expecting events, but found some: &quot;
217             + foundLive + &quot;, &quot; + foundGarbage);
218       }
219     }
220 
221     return frames;
222   }
223 
224   public static Frame[] allocateAndCheckFrames() {
225     return allocateAndCheckFrames(true, true);
226   }
227 
228   public native static int sampledEvents();
229   public native static boolean obtainedEvents(Frame[] frames, boolean checkLines);
230   public native static boolean garbageContains(Frame[] frames, boolean checkLines);
231   public native static boolean eventStorageIsEmpty();
232   public native static void resetEventStorage();
233   public native static int getEventStorageElementCount();
234   public native static void forceGarbageCollection();
235   public native static boolean enableVMEvents();
236 
237   private static boolean getCheckLines() {
238     boolean checkLines = true;
239 
240     // Do not check lines for Graal since it is not always &quot;precise&quot; with BCIs at uncommon traps.
241     try {
242       HotSpotDiagnosticMXBean bean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);
243 
244       VMOption enableJVMCI = bean.getVMOption(&quot;EnableJVMCI&quot;);
245       VMOption useJVMCICompiler = bean.getVMOption(&quot;UseJVMCICompiler&quot;);
246       String compiler = System.getProperty(&quot;jvmci.Compiler&quot;);
247 
248       checkLines = !(enableJVMCI.getValue().equals(&quot;true&quot;)
249           &amp;&amp; useJVMCICompiler.getValue().equals(&quot;true&quot;) &amp;&amp; compiler.equals(&quot;graal&quot;));
250     } catch (Exception e) {
251       // NOP.
252     }
253 
254     return checkLines;
255   }
256 
257   public static boolean obtainedEvents(Frame[] frames) {
258     return obtainedEvents(frames, getCheckLines());
259   }
260 
261   public static boolean garbageContains(Frame[] frames) {
262     return garbageContains(frames, getCheckLines());
263   }
264 
265   public static boolean statsHaveExpectedNumberSamples(int expected, int acceptedErrorPercentage) {
266     double actual = getEventStorageElementCount();
267     double diffPercentage = Math.abs(actual - expected) / expected;
268     return diffPercentage &lt; acceptedErrorPercentage;
269   }
270 
271   public static void setAllocationIterations(int iterations) {
272     allocationIterations = iterations;
273   }
274 }
    </pre>
  </body>
</html>
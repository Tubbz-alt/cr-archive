<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/serviceability/jvmti/SuspendWithCurrentThread/libSuspendWithCurrentThread.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 
 27 extern &quot;C&quot; {
 28 
 29 static jvmtiEnv* jvmti = NULL;
 30 static jthread* threads = NULL;
 31 static jsize threads_count = 0;
 32 static jrawMonitorID agent_monitor = NULL;
 33 
 34 #define LOG(...) \
 35   do { \
 36     printf(__VA_ARGS__); \
 37     printf(&quot;\n&quot;); \
 38     fflush(stdout); \
 39   } while (0)
 40 
 41 static void
 42 check_jvmti_status(JNIEnv* jni, jvmtiError err, const char* msg) {
 43   if (err != JVMTI_ERROR_NONE) {
 44     LOG(&quot;check_jvmti_status: JVMTI function returned error: %d&quot;, err);
 45     jni-&gt;FatalError(msg);
 46   }
 47 }
 48 
 49 static void
 50 agent_lock(JNIEnv* jni) {
 51   jvmtiError err = jvmti-&gt;RawMonitorEnter(agent_monitor);
 52   check_jvmti_status(jni, err, &quot;monitor_enter: error in JVMTI RawMonitorEnter&quot;);
 53 }
 54 
 55 static void
 56 agent_unlock(JNIEnv* jni) {
 57   jvmtiError err = jvmti-&gt;RawMonitorExit(agent_monitor);
 58   check_jvmti_status(jni, err, &quot;monitor_exit: error in JVMTI RawMonitorExit&quot;);
 59 }
 60 
 61 JNIEXPORT void JNICALL
 62 Java_SuspendWithCurrentThread_registerTestedThreads(JNIEnv *jni, jclass cls, jobjectArray threadsArr) {
 63   LOG(&quot;\nregisterTestedThreads: started&quot;);
 64   threads_count = jni-&gt;GetArrayLength(threadsArr);
 65 
 66   jvmtiError err = jvmti-&gt;Allocate((threads_count * sizeof(jthread)),
 67                                    (unsigned char**)&amp;threads);
 68   check_jvmti_status(jni, err, &quot;registerTestedThreads: error in JVMTI Allocate threads array&quot;);
 69 
 70   for (int i = 0; i &lt; threads_count; i++) {
 71     jobject elem = jni-&gt;GetObjectArrayElement(threadsArr, i);
 72     threads[i] = (jthread)jni-&gt;NewGlobalRef(elem);
 73   }
 74   LOG(&quot;registerTestedThreads: finished\n&quot;);
 75 }
 76 
 77 /* This function is executed on the suspender thread, not the Main thread */
 78 JNIEXPORT void JNICALL
 79 Java_ThreadToSuspend_init(JNIEnv *jni, jclass cls) {
 80   jvmtiError err = jvmti-&gt;CreateRawMonitor(&quot;Agent monitor&quot;, &amp;agent_monitor);
 81   check_jvmti_status(jni, err, &quot;Java_ThreadToSuspend_init: error in JVMTI CreateRawMonitor&quot;);
 82 
 83   // Main thread has to wait for the suspender thread to complete tested threads suspension
 84   agent_lock(jni);
 85 }
 86 
 87 /* This function is executed on the suspender thread which is not Main thread */
 88 JNIEXPORT void JNICALL
 89 Java_ThreadToSuspend_suspendTestedThreads(JNIEnv *jni, jclass cls) {
 90   jvmtiError* results = NULL;
 91   jvmtiError err;
 92 
 93   LOG(&quot;\nsuspendTestedThreads: started&quot;);
 94   err = jvmti-&gt;Allocate((threads_count * sizeof(jvmtiError)),
 95                         (unsigned char**)&amp;results);
 96   check_jvmti_status(jni, err, &quot;suspendTestedThreads: error in JVMTI Allocate results array&quot;);
 97 
 98   LOG(&quot;suspendTestedThreads: before JVMTI SuspendThreadList&quot;);
 99   err = jvmti-&gt;SuspendThreadList(threads_count, threads, results);
100   check_jvmti_status(jni, err, &quot;suspendTestedThreads: error in JVMTI SuspendThreadList&quot;);
101 
102   LOG(&quot;suspendTestedThreads: check and print SuspendThreadList results:&quot;);
103   for (int i = 0; i &lt; threads_count; i++) {
104     LOG(&quot;  thread #%d: (%d)&quot;, i, (int)results[i]);
105     check_jvmti_status(jni, results[i], &quot;suspendTestedThreads: error in SuspendThreadList results[i]&quot;);
106   }
107   LOG(&quot;suspendTestedThreads: finished\n&quot;);
108 
109   // Allow the Main thread to inspect the result of tested threads suspension
110   agent_unlock(jni);
111 
112   err = jvmti-&gt;Deallocate((unsigned char*)results);
113   check_jvmti_status(jni, err, &quot;suspendTestedThreads: error in JVMTI Deallocate results&quot;);
114 }
115 
116 JNIEXPORT jboolean JNICALL
117 Java_SuspendWithCurrentThread_checkTestedThreadsSuspended(JNIEnv *jni, jclass cls) {
118   LOG(&quot;checkTestedThreadsSuspended: started&quot;);
119 
120   // Block until the suspender thread competes the tested threads suspension
121   agent_lock(jni);
122   agent_unlock(jni);
123 
124   for (int i = 0; i &lt; threads_count; i++) {
125     jint state = 0;
126     jvmtiError err = jvmti-&gt;GetThreadState(threads[i], &amp;state);
127     check_jvmti_status(jni, err, &quot;checkTestedThreadsSuspended: error in GetThreadState&quot;);
128 
129     if ((state &amp; JVMTI_THREAD_STATE_SUSPENDED) == 0) {
130       LOG(&quot;thread #%d has not been suspended yet: &quot;
131              &quot;#   state: (%#x)&quot;, i, (int)state);
132       jni-&gt;FatalError(&quot;checkTestedThreadsSuspended: error: expected all tested threads suspended&quot;);
133     }
134   }
135   LOG(&quot;checkTestedThreadsSuspended: finished\n&quot;);
136   return JNI_TRUE;
137 }
138 
139 JNIEXPORT void JNICALL
140 Java_SuspendWithCurrentThread_resumeTestedThreads(JNIEnv *jni, jclass cls) {
141   jvmtiError* results = NULL;
142   jvmtiError err;
143 
144   LOG(&quot;\nresumeTestedThreads: started&quot;);
145   err = jvmti-&gt;Allocate((threads_count * sizeof(jvmtiError)),
146                         (unsigned char**)&amp;results);
147   check_jvmti_status(jni, err, &quot;resumeTestedThreads: error in JVMTI Allocate results array&quot;);
148 
149   LOG(&quot;resumeTestedThreads: before JVMTI ResumeThreadList&quot;);
150   err = jvmti-&gt;ResumeThreadList(threads_count, threads, results);
151   check_jvmti_status(jni, err, &quot;resumeTestedThreads: error in ResumeThreadList&quot;);
152 
153   LOG(&quot;resumeTestedThreads: check and print ResumeThreadList results:&quot;);
154   for (int i = 0; i &lt; threads_count; i++) {
155     LOG(&quot;  thread #%d: (%d)&quot;, i, (int)results[i]);
156     check_jvmti_status(jni, results[i], &quot;resumeTestedThreads: error in ResumeThreadList results[i]&quot;);
157   }
158 
159   err = jvmti-&gt;Deallocate((unsigned char*)results);
160   check_jvmti_status(jni, err, &quot;resumeTestedThreads: error in JVMTI Deallocate results&quot;);
161 
162   LOG(&quot;resumeTestedThreads: finished\n&quot;);
163 }
164 
165 JNIEXPORT void JNICALL
166 Java_SuspendWithCurrentThread_releaseTestedThreadsInfo(JNIEnv *jni, jclass cls) {
167   jvmtiError err;
168 
169   LOG(&quot;\nreleaseTestedThreadsInfo: started&quot;);
170   err = jvmti-&gt;DestroyRawMonitor(agent_monitor);
171   check_jvmti_status(jni, err, &quot;releaseTestedThreadsInfo: error in JVMTI DestroyRawMonitor&quot;);
172 
173   for (int i = 0; i &lt; threads_count; i++) {
174     if (threads[i] != NULL) {
175       jni-&gt;DeleteGlobalRef(threads[i]);
176     }
177   }
178   err = jvmti-&gt;Deallocate((unsigned char*)threads);
179   check_jvmti_status(jni, err, &quot;releaseTestedThreadsInfo: error in JVMTI Deallocate threads&quot;);
180 
181   LOG(&quot;releaseTestedThreadsInfo: finished\n&quot;);
182 }
183 
184 
185 /** Agent library initialization. */
186 
187 JNIEXPORT jint JNICALL
188 Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {
189   LOG(&quot;\nAgent_OnLoad started&quot;);
190 
191   // create JVMTI environment
192   if (jvm-&gt;GetEnv((void **) (&amp;jvmti), JVMTI_VERSION) != JNI_OK) {
193     return JNI_ERR;
194   }
195 
196   // add specific capabilities for suspending thread
197   jvmtiCapabilities suspendCaps;
198   memset(&amp;suspendCaps, 0, sizeof(suspendCaps));
199   suspendCaps.can_suspend = 1;
200 
201   jvmtiError err = jvmti-&gt;AddCapabilities(&amp;suspendCaps);
202   if (err != JVMTI_ERROR_NONE) {
203     return JNI_ERR;
204   }
205   LOG(&quot;Agent_OnLoad finished\n&quot;);
206   return JNI_OK;
207 }
208 
209 }
    </pre>
  </body>
</html>
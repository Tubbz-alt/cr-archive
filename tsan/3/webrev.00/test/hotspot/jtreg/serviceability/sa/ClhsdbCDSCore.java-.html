<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/serviceability/sa/ClhsdbCDSCore.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 8174994 8200613
 27  * @summary Test the clhsdb commands &#39;printmdo&#39;, &#39;printall&#39;, &#39;jstack&#39; on a CDS enabled corefile.
 28  * @requires vm.cds
 29  * @requires vm.hasSA
 30  * @requires os.family != &quot;windows&quot;
 31  * @requires vm.flavor == &quot;server&quot;
 32  * @library /test/lib
 33  * @modules java.base/jdk.internal.misc
 34  * @run main/othervm/timeout=2400 -Xmx1g ClhsdbCDSCore
 35  */
 36 
 37 import java.util.List;
 38 import java.util.ArrayList;
 39 import java.util.Arrays;
 40 import java.util.Map;
 41 import java.util.HashMap;
 42 import jdk.test.lib.process.ProcessTools;
 43 import jdk.test.lib.Platform;
 44 import jdk.test.lib.process.OutputAnalyzer;
 45 import jdk.test.lib.cds.CDSTestUtils;
 46 import jdk.test.lib.cds.CDSOptions;
 47 import java.io.IOException;
 48 import java.io.File;
 49 import java.nio.file.Files;
 50 import java.nio.file.Path;
 51 import java.nio.file.Paths;
 52 import jdk.test.lib.Asserts;
 53 import java.util.regex.Pattern;
 54 import java.util.regex.Matcher;
 55 import jdk.internal.misc.Unsafe;
 56 import java.util.Scanner;
 57 import jtreg.SkippedException;
 58 
 59 class CrashApp {
 60     public static void main(String[] args) {
 61         Unsafe.getUnsafe().putInt(0L, 0);
 62     }
 63 }
 64 
 65 public class ClhsdbCDSCore {
 66 
 67     private static final String TEST_CDS_CORE_FILE_NAME = &quot;cds_core_file&quot;;
 68     private static final String LOCATIONS_STRING = &quot;location: &quot;;
 69     private static final String RUN_SHELL_NO_LIMIT = &quot;ulimit -c unlimited &amp;&amp; &quot;;
 70     private static final String SHARED_ARCHIVE_NAME = &quot;ArchiveForClhsdbCDSCore.jsa&quot;;
 71     private static final String CORE_PATTERN_FILE_NAME = &quot;/proc/sys/kernel/core_pattern&quot;;
 72 
 73     public static void main(String[] args) throws Exception {
 74         System.out.println(&quot;Starting ClhsdbCDSCore test&quot;);
 75         cleanup();
 76 
 77         try {
 78             CDSOptions opts = (new CDSOptions()).setArchiveName(SHARED_ARCHIVE_NAME);
 79             CDSTestUtils.createArchiveAndCheck(opts);
 80 
 81             String[] jArgs = {
 82                 &quot;-Xmx512m&quot;,
 83                 &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
 84                 &quot;-XX:SharedArchiveFile=&quot; + SHARED_ARCHIVE_NAME,
 85                 &quot;-XX:+CreateCoredumpOnCrash&quot;,
 86                 &quot;-Xshare:auto&quot;,
 87                 &quot;-XX:+ProfileInterpreter&quot;,
 88                 &quot;--add-exports=java.base/jdk.internal.misc=ALL-UNNAMED&quot;,
 89                 CrashApp.class.getName()
 90             };
 91 
 92             OutputAnalyzer crashOut;
 93             try {
 94                List&lt;String&gt; options = new ArrayList&lt;&gt;();
 95                options.addAll(Arrays.asList(jArgs));
 96                crashOut =
 97                    ProcessTools.executeProcess(getTestJavaCommandlineWithPrefix(
 98                    RUN_SHELL_NO_LIMIT, options.toArray(new String[0])));
 99             } catch (Throwable t) {
100                throw new Error(&quot;Can&#39;t execute the java cds process.&quot;, t);
101             }
102 
103             System.out.println(crashOut.getOutput());
104             String crashOutputString = crashOut.getOutput();
105             String coreFileLocation = getCoreFileLocation(crashOutputString);
106             if (coreFileLocation == null) {
107                 if (Platform.isOSX()) {
108                     File coresDir = new File(&quot;/cores&quot;);
109                     if (!coresDir.isDirectory() || !coresDir.canWrite()) {
110                         throw new Error(&quot;cores is not a directory or does not have write permissions&quot;);
111                     }
112                 } else if (Platform.isLinux()) {
113                     // Check if a crash report tool is installed.
114                     File corePatternFile = new File(CORE_PATTERN_FILE_NAME);
115                     Scanner scanner = new Scanner(corePatternFile);
116                     while (scanner.hasNextLine()) {
117                         String line = scanner.nextLine();
118                         line = line.trim();
119                         System.out.println(line);
120                         if (line.startsWith(&quot;|&quot;)) {
121                             System.out.println(
122                                 &quot;\nThis system uses a crash report tool ($cat /proc/sys/kernel/core_pattern).\n&quot; +
123                                 &quot;Core files might not be generated. Please reset /proc/sys/kernel/core_pattern\n&quot; +
124                                 &quot;to enable core generation. Skipping this test.&quot;);
125                             cleanup();
126                             throw new SkippedException(&quot;This system uses a crash report tool&quot;);
127                         }
128                     }
129                 }
130                 throw new Error(&quot;Couldn&#39;t find core file location in: &#39;&quot; + crashOutputString + &quot;&#39;&quot;);
131             }
132             try {
133                 Asserts.assertGT(new File(coreFileLocation).length(), 0L, &quot;Unexpected core size&quot;);
134                 Files.move(Paths.get(coreFileLocation), Paths.get(TEST_CDS_CORE_FILE_NAME));
135             } catch (IOException ioe) {
136                 throw new Error(&quot;Can&#39;t move core file: &quot; + ioe, ioe);
137             }
138 
139             ClhsdbLauncher test = new ClhsdbLauncher();
140 
141             // Ensure that UseSharedSpaces is turned on.
142             List&lt;String&gt; cmds = List.of(&quot;flags UseSharedSpaces&quot;);
143 
144             String useSharedSpacesOutput = test.runOnCore(TEST_CDS_CORE_FILE_NAME, cmds,
145                                                           null, null);
146 
147             if (useSharedSpacesOutput == null) {
148                 // Output could be null due to attach permission issues.
149                 cleanup();
150                 throw new SkippedException(&quot;Could not determine the UseSharedSpaces value&quot;);
151             }
152 
153             if (!useSharedSpacesOutput.contains(&quot;true&quot;)) {
154                 // CDS archive is not mapped. Skip the rest of the test.
155                 cleanup();
156                 throw new SkippedException(&quot;The CDS archive is not mapped&quot;);
157             }
158 
159             cmds = List.of(&quot;printmdo -a&quot;, &quot;printall&quot;, &quot;jstack -v&quot;);
160 
161             Map&lt;String, List&lt;String&gt;&gt; expStrMap = new HashMap&lt;&gt;();
162             Map&lt;String, List&lt;String&gt;&gt; unExpStrMap = new HashMap&lt;&gt;();
163             expStrMap.put(&quot;printmdo -a&quot;, List.of(
164                 &quot;CounterData&quot;,
165                 &quot;BranchData&quot;));
166             unExpStrMap.put(&quot;printmdo -a&quot;, List.of(
167                 &quot;No suitable match for type of address&quot;));
168             expStrMap.put(&quot;printall&quot;, List.of(
169                 &quot;aload_0&quot;,
170                 &quot;_nofast_aload_0&quot;,
171                 &quot;_nofast_getfield&quot;,
172                 &quot;_nofast_putfield&quot;,
173                 &quot;Constant Pool of&quot;,
174                 &quot;public static void main\\(java.lang.String\\[\\]\\)&quot;,
175                 &quot;Bytecode&quot;,
176                 &quot;invokevirtual&quot;,
177                 &quot;checkcast&quot;,
178                 &quot;Exception Table&quot;,
179                 &quot;invokedynamic&quot;));
180             unExpStrMap.put(&quot;printall&quot;, List.of(
181                 &quot;sun.jvm.hotspot.types.WrongTypeException&quot;,
182                 &quot;illegal code&quot;,
183                 &quot;Failure occurred at bci&quot;,
184                 &quot;No suitable match for type of address&quot;));
185             expStrMap.put(&quot;jstack -v&quot;, List.of(
186                 &quot;Common-Cleaner&quot;,
187                 &quot;Method*&quot;));
188             unExpStrMap.put(&quot;jstack -v&quot;, List.of(
189                 &quot;sun.jvm.hotspot.debugger.UnmappedAddressException&quot;));
190             test.runOnCore(TEST_CDS_CORE_FILE_NAME, cmds, expStrMap, unExpStrMap);
191         } catch (SkippedException e) {
192             throw e;
193         } catch (Exception ex) {
194             throw new RuntimeException(&quot;Test ERROR &quot; + ex, ex);
195         }
196         cleanup();
197         System.out.println(&quot;Test PASSED&quot;);
198     }
199 
200     // lets search for a few possible locations using process output and return existing location
201     private static String getCoreFileLocation(String crashOutputString) {
202         Asserts.assertTrue(crashOutputString.contains(LOCATIONS_STRING),
203             &quot;Output doesn&#39;t contain the location of core file.&quot;);
204         String stringWithLocation = Arrays.stream(crashOutputString.split(&quot;\\r?\\n&quot;))
205             .filter(str -&gt; str.contains(LOCATIONS_STRING))
206             .findFirst()
207             .get();
208         stringWithLocation = stringWithLocation.substring(stringWithLocation
209             .indexOf(LOCATIONS_STRING) + LOCATIONS_STRING.length());
210         System.out.println(&quot;getCoreFileLocation found stringWithLocation = &quot; + stringWithLocation);
211         String coreWithPid;
212         if (stringWithLocation.contains(&quot;or &quot;)) {
213             Matcher m = Pattern.compile(&quot;or.* ([^ ]+[^\\)])\\)?&quot;).matcher(stringWithLocation);
214             if (!m.find()) {
215                 throw new Error(&quot;Couldn&#39;t find path to core inside location string&quot;);
216             }
217             coreWithPid = m.group(1);
218         } else {
219             coreWithPid = stringWithLocation.trim();
220         }
221         if (new File(coreWithPid).exists()) {
222             return coreWithPid;
223         }
224         String justCore = Paths.get(&quot;core&quot;).toString();
225         if (new File(justCore).exists()) {
226             return justCore;
227         }
228         Path coreWithPidPath = Paths.get(coreWithPid);
229         String justFile = coreWithPidPath.getFileName().toString();
230         if (new File(justFile).exists()) {
231             return justFile;
232         }
233         Path parent = coreWithPidPath.getParent();
234         if (parent != null) {
235             String coreWithoutPid = parent.resolve(&quot;core&quot;).toString();
236             if (new File(coreWithoutPid).exists()) {
237                 return coreWithoutPid;
238             }
239         }
240         return null;
241     }
242 
243     private static String[] getTestJavaCommandlineWithPrefix(String prefix, String... args) {
244         try {
245             String cmd = ProcessTools.getCommandLine(ProcessTools.createJavaProcessBuilder(true, args));
246             return new String[]{&quot;sh&quot;, &quot;-c&quot;, prefix + cmd};
247         } catch (Throwable t) {
248             throw new Error(&quot;Can&#39;t create process builder: &quot; + t, t);
249         }
250     }
251 
252     private static void cleanup() {
253         remove(TEST_CDS_CORE_FILE_NAME);
254         remove(SHARED_ARCHIVE_NAME);
255     }
256 
257     private static void remove(String item) {
258         File toDelete = new File(item);
259         toDelete.delete();
260     }
261 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/gc/arguments/TestTargetSurvivorRatioFlag.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="TestSurvivorRatioFlag.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TestUnrecognizedVMOptionsHandling.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/gc/arguments/TestTargetSurvivorRatioFlag.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package gc.arguments;
 25 
<span class="line-removed"> 26 import static java.lang.ref.Reference.reachabilityFence;</span>
<span class="line-removed"> 27 </span>
 28 /*
 29  * @test TestTargetSurvivorRatioFlag
 30  * @key gc
 31  * @summary Verify that option TargetSurvivorRatio affects survivor space occupancy after minor GC.
 32  * @requires vm.opt.ExplicitGCInvokesConcurrent != true
 33  * @requires vm.opt.UseJVMCICompiler != true
 34  * @requires vm.gc != &quot;Z&quot; &amp; vm.gc != &quot;Shenandoah&quot;
 35  * @library /test/lib
 36  * @library /
 37  * @modules java.base/jdk.internal.misc
 38  *          java.management
 39  * @build sun.hotspot.WhiteBox
 40  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 41  * @run driver gc.arguments.TestTargetSurvivorRatioFlag
 42  */
 43 
 44 import java.lang.management.GarbageCollectorMXBean;
 45 import java.util.Arrays;
 46 import java.util.Collections;
 47 import java.util.LinkedList;
 48 import java.util.List;
 49 import java.util.regex.Matcher;
 50 import java.util.regex.Pattern;
 51 import jdk.internal.misc.Unsafe;
 52 import jdk.test.lib.process.OutputAnalyzer;
<span class="line-removed"> 53 import jdk.test.lib.process.ProcessTools;</span>
 54 import jdk.test.lib.Utils;
 55 import sun.hotspot.WhiteBox;

 56 
 57 /* In order to test that TargetSurvivorRatio affects survivor space occupancy
 58  * we setup fixed MaxTenuringThreshold and then verifying that if size of allocated
 59  * objects is lower than (survivor_size * TargetSurvivorRatio / 100) then objects
 60  * will stay in survivor space until MaxTenuringThreshold minor GC cycles.
 61  * If more than (survivor_size * TargetSurvivorRatio / 100) objects were allocated,
 62  * then we verify that after MaxTenuringThreshold minor GC cycles survivor space
 63  * is almost empty.
 64  */
 65 public class TestTargetSurvivorRatioFlag {
 66 
 67     public static final long M = 1024 * 1024;
 68 
 69     // VM option values
 70     public static final long MAX_NEW_SIZE = 40 * M;
 71     public static final int SURVIVOR_RATIO = 8;
 72     public static final int MAX_TENURING_THRESHOLD = 15;
 73 
 74     // Value used to estimate amount of memory that should be allocated
 75     // and placed in survivor space.
</pre>
<hr />
<pre>
102         negativeTest(-1, options);
103         negativeTest(101, options);
104 
105         positiveTest(20, options);
106         positiveTest(30, options);
107         positiveTest(55, options);
108         positiveTest(70, options);
109     }
110 
111     /**
112      * Verify that VM will fail to start with specified TargetSurvivorRatio
113      *
114      * @param ratio value of TargetSurvivorRatio
115      * @param options additional VM options
116      */
117     public static void negativeTest(int ratio, LinkedList&lt;String&gt; options) throws Exception {
118         LinkedList&lt;String&gt; vmOptions = new LinkedList&lt;&gt;(options);
119         vmOptions.add(&quot;-XX:TargetSurvivorRatio=&quot; + ratio);
120         vmOptions.add(&quot;-version&quot;);
121 
<span class="line-modified">122         ProcessBuilder procBuilder = ProcessTools.createJavaProcessBuilder(vmOptions.toArray(new String[vmOptions.size()]));</span>
123         OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());
124 
125         analyzer.shouldHaveExitValue(1);
126         analyzer.shouldContain(&quot;Error: Could not create the Java Virtual Machine.&quot;);
127     }
128 
129     /**
130      * Verify that actual survivor space usage ratio conforms specified TargetSurvivorRatio
131      *
132      * @param ratio value of TargetSurvivorRatio
133      * @param options additional VM options
134      */
135     public static void positiveTest(int ratio, LinkedList&lt;String&gt; options) throws Exception {
136         LinkedList&lt;String&gt; vmOptions = new LinkedList&lt;&gt;(options);
137         Collections.addAll(vmOptions,
138                 &quot;-Xbootclasspath/a:.&quot;,
139                 &quot;--add-exports=java.base/jdk.internal.misc=ALL-UNNAMED&quot;,
140                 &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
141                 &quot;-XX:+WhiteBoxAPI&quot;,
142                 &quot;-XX:+UseAdaptiveSizePolicy&quot;,
143                 &quot;-Xlog:gc+age=trace&quot;,
144                 &quot;-XX:MaxTenuringThreshold=&quot; + MAX_TENURING_THRESHOLD,
145                 &quot;-XX:NewSize=&quot; + MAX_NEW_SIZE,
146                 &quot;-XX:MaxNewSize=&quot; + MAX_NEW_SIZE,
147                 &quot;-XX:InitialHeapSize=&quot; + 2 * MAX_NEW_SIZE,
148                 &quot;-XX:MaxHeapSize=&quot; + 2 * MAX_NEW_SIZE,
149                 &quot;-XX:SurvivorRatio=&quot; + SURVIVOR_RATIO,
150                 &quot;-XX:TargetSurvivorRatio=&quot; + ratio,
151                 // For reducing variance of survivor size.
152                 &quot;-XX:TargetPLABWastePct=&quot; + 1,
153                 TargetSurvivorRatioVerifier.class.getName(),
154                 Integer.toString(ratio)
155         );
156 
<span class="line-modified">157         ProcessBuilder procBuilder = ProcessTools.createJavaProcessBuilder(vmOptions.toArray(new String[vmOptions.size()]));</span>
158         OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());
159 
160         analyzer.shouldHaveExitValue(0);
161 
162         String output = analyzer.getOutput();
163 
164         // Test avoids verification for parallel GC
165         if (!output.contains(UNSUPPORTED_GC)) {
166             // Two tests should be done - when actual ratio is lower than TargetSurvivorRatio
167             // and when it is higher. We chech that output contains results for exactly two tests.
168             List&lt;Double&gt; ratios = parseTestOutput(output);
169 
170             if (ratios.size() != 2) {
171                 System.out.println(output);
172                 throw new RuntimeException(&quot;Expected number of ratios extraced for output is 2,&quot;
173                         + &quot; but &quot; + ratios.size() + &quot; ratios were extracted&quot;);
174             }
175 
176             // At the end of the first test survivor space usage ratio should lies between
177             // TargetSurvivorRatio and TargetSurvivorRatio - 2*DELTA
</pre>
<hr />
<pre>
282          * Allocate (&lt;b&gt;ratio&lt;/b&gt; * &lt;b&gt;maxSize&lt;/b&gt; / 100) bytes of objects
283          * and force at least &quot;MaxTenuringThreshold&quot; minor GCs.
284          *
285          * @param ratio ratio used to calculate how many objects should be allocated
286          * @param maxSize estimated max survivor space size
287          */
288         public static void allocateMemory(double ratio, long maxSize) throws Exception {
289             GarbageCollectorMXBean youngGCBean = GCTypes.YoungGCType.getYoungGCBean();
290             long garbageSize = (long) (maxSize * (ratio / 100.0));
291             int arrayLength = (int) (garbageSize / CHUNK_SIZE);
292             AllocationHelper allocator = new AllocationHelper(1, arrayLength, ARRAY_LENGTH, null);
293 
294             System.out.println(START_TEST);
295             System.gc();
296             final long initialGcId = youngGCBean.getCollectionCount();
297             // allocate memory
298             allocator.allocateMemoryAndVerify();
299 
300             // force minor GC
301             while (youngGCBean.getCollectionCount() &lt;= initialGcId + MAX_TENURING_THRESHOLD * 2) {
<span class="line-modified">302                 reachabilityFence(new byte[ARRAY_LENGTH]);</span>
303             }
304 
305             allocator.release();
306             System.out.println(END_TEST);
307         }
308 
309         /**
310          * Estimate max survivor space size.
311          *
312          * For non-G1 GC returns value reported by MemoryPoolMXBean
313          * associated with survivor space.
314          * For G1 GC return max number of survivor regions * region size.
315          * Number if survivor regions estimated from MaxNewSize and SurvivorRatio.
316          */
317         public static long getMaxSurvivorSize() {
318             if (GCTypes.YoungGCType.getYoungGCType() == GCTypes.YoungGCType.G1) {
319                 int youngLength = (int) Math.max(MAX_NEW_SIZE / wb.g1RegionSize(), 1);
320                 return (long) Math.ceil(youngLength / (double) SURVIVOR_RATIO) * wb.g1RegionSize();
321             } else {
322                 return HeapRegionUsageTool.getSurvivorUsage().getMax();
</pre>
</td>
<td>
<hr />
<pre>
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package gc.arguments;
 25 


 26 /*
 27  * @test TestTargetSurvivorRatioFlag
 28  * @key gc
 29  * @summary Verify that option TargetSurvivorRatio affects survivor space occupancy after minor GC.
 30  * @requires vm.opt.ExplicitGCInvokesConcurrent != true
 31  * @requires vm.opt.UseJVMCICompiler != true
 32  * @requires vm.gc != &quot;Z&quot; &amp; vm.gc != &quot;Shenandoah&quot;
 33  * @library /test/lib
 34  * @library /
 35  * @modules java.base/jdk.internal.misc
 36  *          java.management
 37  * @build sun.hotspot.WhiteBox
 38  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 39  * @run driver gc.arguments.TestTargetSurvivorRatioFlag
 40  */
 41 
 42 import java.lang.management.GarbageCollectorMXBean;
 43 import java.util.Arrays;
 44 import java.util.Collections;
 45 import java.util.LinkedList;
 46 import java.util.List;
 47 import java.util.regex.Matcher;
 48 import java.util.regex.Pattern;
 49 import jdk.internal.misc.Unsafe;
 50 import jdk.test.lib.process.OutputAnalyzer;

 51 import jdk.test.lib.Utils;
 52 import sun.hotspot.WhiteBox;
<span class="line-added"> 53 import static gc.testlibrary.Allocation.blackHole;</span>
 54 
 55 /* In order to test that TargetSurvivorRatio affects survivor space occupancy
 56  * we setup fixed MaxTenuringThreshold and then verifying that if size of allocated
 57  * objects is lower than (survivor_size * TargetSurvivorRatio / 100) then objects
 58  * will stay in survivor space until MaxTenuringThreshold minor GC cycles.
 59  * If more than (survivor_size * TargetSurvivorRatio / 100) objects were allocated,
 60  * then we verify that after MaxTenuringThreshold minor GC cycles survivor space
 61  * is almost empty.
 62  */
 63 public class TestTargetSurvivorRatioFlag {
 64 
 65     public static final long M = 1024 * 1024;
 66 
 67     // VM option values
 68     public static final long MAX_NEW_SIZE = 40 * M;
 69     public static final int SURVIVOR_RATIO = 8;
 70     public static final int MAX_TENURING_THRESHOLD = 15;
 71 
 72     // Value used to estimate amount of memory that should be allocated
 73     // and placed in survivor space.
</pre>
<hr />
<pre>
100         negativeTest(-1, options);
101         negativeTest(101, options);
102 
103         positiveTest(20, options);
104         positiveTest(30, options);
105         positiveTest(55, options);
106         positiveTest(70, options);
107     }
108 
109     /**
110      * Verify that VM will fail to start with specified TargetSurvivorRatio
111      *
112      * @param ratio value of TargetSurvivorRatio
113      * @param options additional VM options
114      */
115     public static void negativeTest(int ratio, LinkedList&lt;String&gt; options) throws Exception {
116         LinkedList&lt;String&gt; vmOptions = new LinkedList&lt;&gt;(options);
117         vmOptions.add(&quot;-XX:TargetSurvivorRatio=&quot; + ratio);
118         vmOptions.add(&quot;-version&quot;);
119 
<span class="line-modified">120         ProcessBuilder procBuilder = GCArguments.createJavaProcessBuilder(vmOptions.toArray(new String[vmOptions.size()]));</span>
121         OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());
122 
123         analyzer.shouldHaveExitValue(1);
124         analyzer.shouldContain(&quot;Error: Could not create the Java Virtual Machine.&quot;);
125     }
126 
127     /**
128      * Verify that actual survivor space usage ratio conforms specified TargetSurvivorRatio
129      *
130      * @param ratio value of TargetSurvivorRatio
131      * @param options additional VM options
132      */
133     public static void positiveTest(int ratio, LinkedList&lt;String&gt; options) throws Exception {
134         LinkedList&lt;String&gt; vmOptions = new LinkedList&lt;&gt;(options);
135         Collections.addAll(vmOptions,
136                 &quot;-Xbootclasspath/a:.&quot;,
137                 &quot;--add-exports=java.base/jdk.internal.misc=ALL-UNNAMED&quot;,
138                 &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
139                 &quot;-XX:+WhiteBoxAPI&quot;,
140                 &quot;-XX:+UseAdaptiveSizePolicy&quot;,
141                 &quot;-Xlog:gc+age=trace&quot;,
142                 &quot;-XX:MaxTenuringThreshold=&quot; + MAX_TENURING_THRESHOLD,
143                 &quot;-XX:NewSize=&quot; + MAX_NEW_SIZE,
144                 &quot;-XX:MaxNewSize=&quot; + MAX_NEW_SIZE,
145                 &quot;-XX:InitialHeapSize=&quot; + 2 * MAX_NEW_SIZE,
146                 &quot;-XX:MaxHeapSize=&quot; + 2 * MAX_NEW_SIZE,
147                 &quot;-XX:SurvivorRatio=&quot; + SURVIVOR_RATIO,
148                 &quot;-XX:TargetSurvivorRatio=&quot; + ratio,
149                 // For reducing variance of survivor size.
150                 &quot;-XX:TargetPLABWastePct=&quot; + 1,
151                 TargetSurvivorRatioVerifier.class.getName(),
152                 Integer.toString(ratio)
153         );
154 
<span class="line-modified">155         ProcessBuilder procBuilder = GCArguments.createJavaProcessBuilder(vmOptions.toArray(new String[vmOptions.size()]));</span>
156         OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());
157 
158         analyzer.shouldHaveExitValue(0);
159 
160         String output = analyzer.getOutput();
161 
162         // Test avoids verification for parallel GC
163         if (!output.contains(UNSUPPORTED_GC)) {
164             // Two tests should be done - when actual ratio is lower than TargetSurvivorRatio
165             // and when it is higher. We chech that output contains results for exactly two tests.
166             List&lt;Double&gt; ratios = parseTestOutput(output);
167 
168             if (ratios.size() != 2) {
169                 System.out.println(output);
170                 throw new RuntimeException(&quot;Expected number of ratios extraced for output is 2,&quot;
171                         + &quot; but &quot; + ratios.size() + &quot; ratios were extracted&quot;);
172             }
173 
174             // At the end of the first test survivor space usage ratio should lies between
175             // TargetSurvivorRatio and TargetSurvivorRatio - 2*DELTA
</pre>
<hr />
<pre>
280          * Allocate (&lt;b&gt;ratio&lt;/b&gt; * &lt;b&gt;maxSize&lt;/b&gt; / 100) bytes of objects
281          * and force at least &quot;MaxTenuringThreshold&quot; minor GCs.
282          *
283          * @param ratio ratio used to calculate how many objects should be allocated
284          * @param maxSize estimated max survivor space size
285          */
286         public static void allocateMemory(double ratio, long maxSize) throws Exception {
287             GarbageCollectorMXBean youngGCBean = GCTypes.YoungGCType.getYoungGCBean();
288             long garbageSize = (long) (maxSize * (ratio / 100.0));
289             int arrayLength = (int) (garbageSize / CHUNK_SIZE);
290             AllocationHelper allocator = new AllocationHelper(1, arrayLength, ARRAY_LENGTH, null);
291 
292             System.out.println(START_TEST);
293             System.gc();
294             final long initialGcId = youngGCBean.getCollectionCount();
295             // allocate memory
296             allocator.allocateMemoryAndVerify();
297 
298             // force minor GC
299             while (youngGCBean.getCollectionCount() &lt;= initialGcId + MAX_TENURING_THRESHOLD * 2) {
<span class="line-modified">300                 blackHole(new byte[ARRAY_LENGTH]);</span>
301             }
302 
303             allocator.release();
304             System.out.println(END_TEST);
305         }
306 
307         /**
308          * Estimate max survivor space size.
309          *
310          * For non-G1 GC returns value reported by MemoryPoolMXBean
311          * associated with survivor space.
312          * For G1 GC return max number of survivor regions * region size.
313          * Number if survivor regions estimated from MaxNewSize and SurvivorRatio.
314          */
315         public static long getMaxSurvivorSize() {
316             if (GCTypes.YoungGCType.getYoungGCType() == GCTypes.YoungGCType.G1) {
317                 int youngLength = (int) Math.max(MAX_NEW_SIZE / wb.g1RegionSize(), 1);
318                 return (long) Math.ceil(youngLength / (double) SURVIVOR_RATIO) * wb.g1RegionSize();
319             } else {
320                 return HeapRegionUsageTool.getSurvivorUsage().getMax();
</pre>
</td>
</tr>
</table>
<center><a href="TestSurvivorRatioFlag.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TestUnrecognizedVMOptionsHandling.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
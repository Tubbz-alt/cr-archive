<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/gc/arguments/TestMaxHeapSizeTools.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="TestInitialTenuringThreshold.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TestMaxMinHeapFreeRatioFlags.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/gc/arguments/TestMaxHeapSizeTools.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38     wb.printHeapSizes();
 39   }
 40 }
 41 
 42 final class MinInitialMaxValues {
 43   public long minHeapSize;
 44   public long initialHeapSize;
 45   public long maxHeapSize;
 46 
 47   public long spaceAlignment;
 48   public long heapAlignment;
 49 }
 50 
 51 class TestMaxHeapSizeTools {
 52 
 53   public static void checkMinInitialMaxHeapFlags(String gcflag) throws Exception {
 54     checkInvalidMinInitialHeapCombinations(gcflag);
 55     checkValidMinInitialHeapCombinations(gcflag);
 56     checkInvalidInitialMaxHeapCombinations(gcflag);
 57     checkValidInitialMaxHeapCombinations(gcflag);


 58   }
 59 
 60   public static void checkMinInitialErgonomics(String gcflag) throws Exception {
 61     // heap sizing ergonomics use the value NewSize + OldSize as default values
 62     // for ergonomics calculation. Retrieve these values.
 63     long[] values = new long[2];
 64     getNewOldSize(gcflag, values);
 65 
 66     // we check cases with values smaller and larger than this default value.
 67     long newPlusOldSize = values[0] + values[1];
 68     long smallValue = newPlusOldSize / 2;
 69     long largeValue = newPlusOldSize * 2;
 70     long maxHeapSize = largeValue + (2 * 1024 * 1024);
 71 
 72     // -Xms is not set
 73     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize }, values, -1, -1);



 74     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:InitialHeapSize=&quot; + smallValue }, values, -1, smallValue);
 75     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:InitialHeapSize=&quot; + largeValue }, values, -1, largeValue);
 76     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:InitialHeapSize=0&quot; }, values, -1, -1);




 77 
 78     // -Xms is set to zero
 79     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot; }, values, -1, -1);



 80     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:InitialHeapSize=&quot; + smallValue }, values, -1, smallValue);
 81     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:InitialHeapSize=&quot; + largeValue }, values, -1, largeValue);
 82     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:InitialHeapSize=0&quot; }, values, -1, -1);



 83 
 84     // -Xms is set to small value
 85     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + smallValue }, values, -1, -1);


 86     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + smallValue, &quot;-XX:InitialHeapSize=&quot; + smallValue }, values, smallValue, smallValue);
 87     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + smallValue, &quot;-XX:InitialHeapSize=&quot; + largeValue }, values, smallValue, largeValue);
 88     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + smallValue, &quot;-XX:InitialHeapSize=0&quot; }, values, smallValue, -1);
 89 
 90     // -Xms is set to large value
 91     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + largeValue }, values, largeValue, largeValue);
 92     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + largeValue, &quot;-XX:InitialHeapSize=0&quot; }, values, largeValue, -1);

 93   }
 94 
 95   private static long align_up(long value, long alignment) {
 96     long alignmentMinusOne = alignment - 1;
 97     return (value + alignmentMinusOne) &amp; ~alignmentMinusOne;
 98   }
 99 
100   private static void getNewOldSize(String gcflag, long[] values) throws Exception {
<span class="line-modified">101     ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(gcflag,</span>
102       &quot;-XX:+PrintFlagsFinal&quot;, &quot;-version&quot;);
103     OutputAnalyzer output = new OutputAnalyzer(pb.start());
104     output.shouldHaveExitValue(0);
105 
106     String stdout = output.getStdout();
107     values[0] = getFlagValue(&quot; NewSize&quot;, stdout);
108     values[1] = getFlagValue(&quot; OldSize&quot;, stdout);
109   }
110 
111   public static void checkGenMaxHeapErgo(String gcflag) throws Exception {
112     TestMaxHeapSizeTools.checkGenMaxHeapSize(gcflag, 4);
113     TestMaxHeapSizeTools.checkGenMaxHeapSize(gcflag, 5);
114   }
115 
116   private static void checkInvalidMinInitialHeapCombinations(String gcflag) throws Exception {
117     expectError(new String[] { gcflag, &quot;-XX:InitialHeapSize=1023K&quot;, &quot;-version&quot; });
118     expectError(new String[] { gcflag, &quot;-Xms64M&quot;, &quot;-XX:InitialHeapSize=32M&quot;, &quot;-version&quot; });




119   }
120 
121   private static void checkValidMinInitialHeapCombinations(String gcflag) throws Exception {
122     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=1024K&quot;, &quot;-version&quot; });
123     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-Xms4M&quot;, &quot;-version&quot; });
124     expectValid(new String[] { gcflag, &quot;-Xms4M&quot;, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-version&quot; });
125     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-Xms8M&quot;, &quot;-version&quot; });




126     // the following is not an error as -Xms sets both minimal and initial heap size
127     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=4M&quot;, &quot;-Xms8M&quot;, &quot;-version&quot; });

128   }
129 
130   private static void checkInvalidInitialMaxHeapCombinations(String gcflag) throws Exception {
131     expectError(new String[] { gcflag, &quot;-XX:MaxHeapSize=2047K&quot;, &quot;-version&quot; });
132     expectError(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-version&quot; });
133     expectError(new String[] { gcflag, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-version&quot; });
134   }
135 






136   private static void checkValidInitialMaxHeapCombinations(String gcflag) throws Exception {
137     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=4M&quot;, &quot;-XX:MaxHeapSize=8M&quot;, &quot;-version&quot; });
138     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=8M&quot;, &quot;-XX:InitialHeapSize=4M&quot;, &quot;-version&quot; });
139     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:InitialHeapSize=4M&quot;, &quot;-version&quot; });
140     // a value of &quot;0&quot; for initial heap size means auto-detect
141     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:InitialHeapSize=0M&quot;, &quot;-version&quot; });
142   }
143 








144   private static long valueAfter(String source, String match) {
145     int start = source.indexOf(match) + match.length();
146     String tail = source.substring(start).split(&quot; &quot;)[0];
147     return Long.parseLong(tail);
148   }
149 
150   /**
151    * Executes a new VM process with the given class and parameters.
152    * @param vmargs Arguments to the VM to run
153    * @param classname Name of the class to run
154    * @param arguments Arguments to the class
155    * @param useTestDotJavaDotOpts Use test.java.opts as part of the VM argument string
156    * @return The OutputAnalyzer with the results for the invocation.
157    */
158   public static OutputAnalyzer runWhiteBoxTest(String[] vmargs, String classname, String[] arguments, boolean useTestDotJavaDotOpts) throws Exception {
159     ArrayList&lt;String&gt; finalargs = new ArrayList&lt;String&gt;();
160 
161     String[] whiteboxOpts = new String[] {
162       &quot;-Xbootclasspath/a:.&quot;,
163       &quot;-XX:+UnlockDiagnosticVMOptions&quot;, &quot;-XX:+WhiteBoxAPI&quot;,
164       &quot;-cp&quot;, System.getProperty(&quot;java.class.path&quot;),
165     };
166 
167     if (useTestDotJavaDotOpts) {
168       // System.getProperty(&quot;test.java.opts&quot;) is &#39;&#39; if no options is set,
169       // we need to skip such a result
170       String[] externalVMOpts = new String[0];
171       if (System.getProperty(&quot;test.java.opts&quot;) != null &amp;&amp; System.getProperty(&quot;test.java.opts&quot;).length() != 0) {
172         externalVMOpts = System.getProperty(&quot;test.java.opts&quot;).split(&quot; &quot;);
173       }
174       finalargs.addAll(Arrays.asList(externalVMOpts));
175     }
176 
177     finalargs.addAll(Arrays.asList(vmargs));
178     finalargs.addAll(Arrays.asList(whiteboxOpts));
179     finalargs.add(classname);
180     finalargs.addAll(Arrays.asList(arguments));
181 
<span class="line-modified">182     ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(finalargs.toArray(new String[0]));</span>
183     OutputAnalyzer output = new OutputAnalyzer(pb.start());
184     output.shouldHaveExitValue(0);
185 
186     return output;
187   }
188 
189   private static void getMinInitialMaxHeap(String[] args, MinInitialMaxValues val) throws Exception {
190     OutputAnalyzer output = runWhiteBoxTest(args, ErgoArgsPrinter.class.getName(), new String[] {}, false);
191 
192     // the output we watch for has the following format:
193     //
194     // &quot;Minimum heap X Initial heap Y Maximum heap Z Min alignment A Max Alignment B&quot;
195     //
196     // where A, B, X, Y and Z are sizes in bytes.
197     // Unfortunately there is no other way to retrieve the minimum heap size and
198     // the alignments.
199 
200     Matcher m = Pattern.compile(&quot;Minimum heap \\d+ Initial heap \\d+ Maximum heap \\d+ Space alignment \\d+ Heap alignment \\d+&quot;).
201       matcher(output.getStdout());
202     if (!m.find()) {
</pre>
<hr />
<pre>
262   }
263 
264   private static long getFlagValue(String flag, String where) {
265     Matcher m = Pattern.compile(flag + &quot;\\s+:?=\\s+\\d+&quot;).matcher(where);
266     if (!m.find()) {
267       throw new RuntimeException(&quot;Could not find value for flag &quot; + flag + &quot; in output string&quot;);
268     }
269     String match = m.group();
270     return Long.parseLong(match.substring(match.lastIndexOf(&quot; &quot;) + 1, match.length()));
271   }
272 
273   private static void shouldContainOrNot(OutputAnalyzer output, boolean contains, String message) throws Exception {
274     if (contains) {
275       output.shouldContain(message);
276     } else {
277       output.shouldNotContain(message);
278     }
279   }
280 
281   private static void expect(String[] flags, boolean hasWarning, boolean hasError, int errorcode) throws Exception {
<span class="line-modified">282     ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(flags);</span>
283     OutputAnalyzer output = new OutputAnalyzer(pb.start());
284     shouldContainOrNot(output, hasWarning, &quot;Warning&quot;);
285     shouldContainOrNot(output, hasError, &quot;Error&quot;);
286     output.shouldHaveExitValue(errorcode);
287   }
288 
289   private static void expectError(String[] flags) throws Exception {
290     expect(flags, false, true, 1);
291   }
292 
293   private static void expectValid(String[] flags) throws Exception {
294     expect(flags, false, false, 0);
295   }
296 }
<span class="line-removed">297 </span>
</pre>
</td>
<td>
<hr />
<pre>
 38     wb.printHeapSizes();
 39   }
 40 }
 41 
 42 final class MinInitialMaxValues {
 43   public long minHeapSize;
 44   public long initialHeapSize;
 45   public long maxHeapSize;
 46 
 47   public long spaceAlignment;
 48   public long heapAlignment;
 49 }
 50 
 51 class TestMaxHeapSizeTools {
 52 
 53   public static void checkMinInitialMaxHeapFlags(String gcflag) throws Exception {
 54     checkInvalidMinInitialHeapCombinations(gcflag);
 55     checkValidMinInitialHeapCombinations(gcflag);
 56     checkInvalidInitialMaxHeapCombinations(gcflag);
 57     checkValidInitialMaxHeapCombinations(gcflag);
<span class="line-added"> 58     checkInvalidMinMaxHeapCombinations(gcflag);</span>
<span class="line-added"> 59     checkValidMinMaxHeapCombinations(gcflag);</span>
 60   }
 61 
 62   public static void checkMinInitialErgonomics(String gcflag) throws Exception {
 63     // heap sizing ergonomics use the value NewSize + OldSize as default values
 64     // for ergonomics calculation. Retrieve these values.
 65     long[] values = new long[2];
 66     getNewOldSize(gcflag, values);
 67 
 68     // we check cases with values smaller and larger than this default value.
 69     long newPlusOldSize = values[0] + values[1];
 70     long smallValue = newPlusOldSize / 2;
 71     long largeValue = newPlusOldSize * 2;
 72     long maxHeapSize = largeValue + (2 * 1024 * 1024);
 73 
 74     // -Xms is not set
 75     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize }, values, -1, -1);
<span class="line-added"> 76     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:MinHeapSize=&quot; + smallValue }, values, smallValue, -1);</span>
<span class="line-added"> 77     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:MinHeapSize=&quot; + largeValue }, values, largeValue, -1);</span>
<span class="line-added"> 78     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:MinHeapSize=0&quot; }, values, -1, -1);</span>
 79     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:InitialHeapSize=&quot; + smallValue }, values, -1, smallValue);
 80     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:InitialHeapSize=&quot; + largeValue }, values, -1, largeValue);
 81     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:InitialHeapSize=0&quot; }, values, -1, -1);
<span class="line-added"> 82     // Some extra checks when both are set.</span>
<span class="line-added"> 83     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:MinHeapSize=&quot; + smallValue, &quot;-XX:InitialHeapSize=&quot; + smallValue }, values, smallValue, smallValue);</span>
<span class="line-added"> 84     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:MinHeapSize=&quot; + smallValue, &quot;-XX:InitialHeapSize=&quot; + largeValue }, values, smallValue, largeValue);</span>
<span class="line-added"> 85     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:MinHeapSize=&quot; + largeValue, &quot;-XX:InitialHeapSize=&quot; + largeValue }, values, largeValue, largeValue);</span>
 86 
 87     // -Xms is set to zero
 88     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot; }, values, -1, -1);
<span class="line-added"> 89     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:MinHeapSize=&quot; + smallValue }, values, smallValue, -1);</span>
<span class="line-added"> 90     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:MinHeapSize=&quot; + largeValue }, values, largeValue, -1);</span>
<span class="line-added"> 91     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:MinHeapSize=0&quot; }, values, -1, -1);</span>
 92     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:InitialHeapSize=&quot; + smallValue }, values, -1, smallValue);
 93     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:InitialHeapSize=&quot; + largeValue }, values, -1, largeValue);
 94     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:InitialHeapSize=0&quot; }, values, -1, -1);
<span class="line-added"> 95     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:MinHeapSize=&quot; + smallValue, &quot;-XX:InitialHeapSize=&quot; + smallValue }, values, smallValue, smallValue);</span>
<span class="line-added"> 96     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:MinHeapSize=&quot; + smallValue, &quot;-XX:InitialHeapSize=&quot; + largeValue }, values, smallValue, largeValue);</span>
<span class="line-added"> 97     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:MinHeapSize=&quot; + largeValue, &quot;-XX:InitialHeapSize=&quot; + largeValue }, values, largeValue, largeValue);</span>
 98 
 99     // -Xms is set to small value
100     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + smallValue }, values, -1, -1);
<span class="line-added">101     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + smallValue, &quot;-XX:MinHeapSize=&quot; + smallValue }, values, smallValue, smallValue);</span>
<span class="line-added">102     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + smallValue, &quot;-XX:MinHeapSize=0&quot; }, values, -1, smallValue);</span>
103     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + smallValue, &quot;-XX:InitialHeapSize=&quot; + smallValue }, values, smallValue, smallValue);
104     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + smallValue, &quot;-XX:InitialHeapSize=&quot; + largeValue }, values, smallValue, largeValue);
105     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + smallValue, &quot;-XX:InitialHeapSize=0&quot; }, values, smallValue, -1);
106 
107     // -Xms is set to large value
108     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + largeValue }, values, largeValue, largeValue);
109     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + largeValue, &quot;-XX:InitialHeapSize=0&quot; }, values, largeValue, -1);
<span class="line-added">110     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + largeValue, &quot;-XX:MinHeapSize=0&quot; }, values, -1, largeValue);</span>
111   }
112 
113   private static long align_up(long value, long alignment) {
114     long alignmentMinusOne = alignment - 1;
115     return (value + alignmentMinusOne) &amp; ~alignmentMinusOne;
116   }
117 
118   private static void getNewOldSize(String gcflag, long[] values) throws Exception {
<span class="line-modified">119     ProcessBuilder pb = GCArguments.createJavaProcessBuilder(gcflag,</span>
120       &quot;-XX:+PrintFlagsFinal&quot;, &quot;-version&quot;);
121     OutputAnalyzer output = new OutputAnalyzer(pb.start());
122     output.shouldHaveExitValue(0);
123 
124     String stdout = output.getStdout();
125     values[0] = getFlagValue(&quot; NewSize&quot;, stdout);
126     values[1] = getFlagValue(&quot; OldSize&quot;, stdout);
127   }
128 
129   public static void checkGenMaxHeapErgo(String gcflag) throws Exception {
130     TestMaxHeapSizeTools.checkGenMaxHeapSize(gcflag, 4);
131     TestMaxHeapSizeTools.checkGenMaxHeapSize(gcflag, 5);
132   }
133 
134   private static void checkInvalidMinInitialHeapCombinations(String gcflag) throws Exception {
135     expectError(new String[] { gcflag, &quot;-XX:InitialHeapSize=1023K&quot;, &quot;-version&quot; });
136     expectError(new String[] { gcflag, &quot;-Xms64M&quot;, &quot;-XX:InitialHeapSize=32M&quot;, &quot;-version&quot; });
<span class="line-added">137     expectError(new String[] { gcflag, &quot;-XX:MinHeapSize=1023K&quot;, &quot;-version&quot; });</span>
<span class="line-added">138     // Note: MinHeapSize values get aligned up by HeapAlignment which is 32M with 64k pages.</span>
<span class="line-added">139     expectError(new String[] { gcflag, &quot;-Xms4M&quot;, &quot;-XX:MinHeapSize=64M&quot;, &quot;-version&quot; });</span>
<span class="line-added">140     expectError(new String[] { gcflag, &quot;-XX:MinHeapSize=8M -XX:InitialHeapSize=4m&quot; });</span>
141   }
142 
143   private static void checkValidMinInitialHeapCombinations(String gcflag) throws Exception {
144     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=1024K&quot;, &quot;-version&quot; });
145     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-Xms4M&quot;, &quot;-version&quot; });
146     expectValid(new String[] { gcflag, &quot;-Xms4M&quot;, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-version&quot; });
147     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-Xms8M&quot;, &quot;-version&quot; });
<span class="line-added">148     expectValid(new String[] { gcflag, &quot;-XX:MinHeapSize=1024K&quot;, &quot;-version&quot; });</span>
<span class="line-added">149     expectValid(new String[] { gcflag, &quot;-XX:MinHeapSize=8M&quot;, &quot;-Xms4M&quot;, &quot;-version&quot; });</span>
<span class="line-added">150     expectValid(new String[] { gcflag, &quot;-XX:MinHeapSize=8M&quot;, &quot;-Xms8M&quot;, &quot;-version&quot; });</span>
<span class="line-added">151     expectValid(new String[] { gcflag, &quot;-Xms8M&quot;, &quot;-XX:MinHeapSize=4M&quot;, &quot;-version&quot; });</span>
152     // the following is not an error as -Xms sets both minimal and initial heap size
153     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=4M&quot;, &quot;-Xms8M&quot;, &quot;-version&quot; });
<span class="line-added">154     expectValid(new String[] { gcflag, &quot;-XX:MinHeapSize=4M&quot;, &quot;-Xms8M&quot;, &quot;-version&quot; });</span>
155   }
156 
157   private static void checkInvalidInitialMaxHeapCombinations(String gcflag) throws Exception {
158     expectError(new String[] { gcflag, &quot;-XX:MaxHeapSize=2047K&quot;, &quot;-version&quot; });
159     expectError(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-version&quot; });
160     expectError(new String[] { gcflag, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-version&quot; });
161   }
162 
<span class="line-added">163   private static void checkInvalidMinMaxHeapCombinations(String gcflag) throws Exception {</span>
<span class="line-added">164     expectError(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:MinHeapSize=8M&quot;, &quot;-version&quot; });</span>
<span class="line-added">165     expectError(new String[] { gcflag, &quot;-XX:MinHeapSize=8M&quot;, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-version&quot; });</span>
<span class="line-added">166   }</span>
<span class="line-added">167 </span>
<span class="line-added">168 </span>
169   private static void checkValidInitialMaxHeapCombinations(String gcflag) throws Exception {
170     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=4M&quot;, &quot;-XX:MaxHeapSize=8M&quot;, &quot;-version&quot; });
171     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=8M&quot;, &quot;-XX:InitialHeapSize=4M&quot;, &quot;-version&quot; });
172     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:InitialHeapSize=4M&quot;, &quot;-version&quot; });
173     // a value of &quot;0&quot; for initial heap size means auto-detect
174     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:InitialHeapSize=0M&quot;, &quot;-version&quot; });
175   }
176 
<span class="line-added">177   private static void checkValidMinMaxHeapCombinations(String gcflag) throws Exception {</span>
<span class="line-added">178     expectValid(new String[] { gcflag, &quot;-XX:MinHeapSize=4M&quot;, &quot;-XX:MaxHeapSize=8M&quot;, &quot;-version&quot; });</span>
<span class="line-added">179     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=8M&quot;, &quot;-XX:MinHeapSize=4M&quot;, &quot;-version&quot; });</span>
<span class="line-added">180     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:MinHeapSize=4M&quot;, &quot;-version&quot; });</span>
<span class="line-added">181     // a value of &quot;0&quot; for min heap size means auto-detect</span>
<span class="line-added">182     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:MinHeapSize=0M&quot;, &quot;-version&quot; });</span>
<span class="line-added">183   }</span>
<span class="line-added">184 </span>
185   private static long valueAfter(String source, String match) {
186     int start = source.indexOf(match) + match.length();
187     String tail = source.substring(start).split(&quot; &quot;)[0];
188     return Long.parseLong(tail);
189   }
190 
191   /**
192    * Executes a new VM process with the given class and parameters.
193    * @param vmargs Arguments to the VM to run
194    * @param classname Name of the class to run
195    * @param arguments Arguments to the class
196    * @param useTestDotJavaDotOpts Use test.java.opts as part of the VM argument string
197    * @return The OutputAnalyzer with the results for the invocation.
198    */
199   public static OutputAnalyzer runWhiteBoxTest(String[] vmargs, String classname, String[] arguments, boolean useTestDotJavaDotOpts) throws Exception {
200     ArrayList&lt;String&gt; finalargs = new ArrayList&lt;String&gt;();
201 
202     String[] whiteboxOpts = new String[] {
203       &quot;-Xbootclasspath/a:.&quot;,
204       &quot;-XX:+UnlockDiagnosticVMOptions&quot;, &quot;-XX:+WhiteBoxAPI&quot;,
205       &quot;-cp&quot;, System.getProperty(&quot;java.class.path&quot;),
206     };
207 
208     if (useTestDotJavaDotOpts) {
209       // System.getProperty(&quot;test.java.opts&quot;) is &#39;&#39; if no options is set,
210       // we need to skip such a result
211       String[] externalVMOpts = new String[0];
212       if (System.getProperty(&quot;test.java.opts&quot;) != null &amp;&amp; System.getProperty(&quot;test.java.opts&quot;).length() != 0) {
213         externalVMOpts = System.getProperty(&quot;test.java.opts&quot;).split(&quot; &quot;);
214       }
215       finalargs.addAll(Arrays.asList(externalVMOpts));
216     }
217 
218     finalargs.addAll(Arrays.asList(vmargs));
219     finalargs.addAll(Arrays.asList(whiteboxOpts));
220     finalargs.add(classname);
221     finalargs.addAll(Arrays.asList(arguments));
222 
<span class="line-modified">223     ProcessBuilder pb = GCArguments.createJavaProcessBuilder(finalargs.toArray(new String[0]));</span>
224     OutputAnalyzer output = new OutputAnalyzer(pb.start());
225     output.shouldHaveExitValue(0);
226 
227     return output;
228   }
229 
230   private static void getMinInitialMaxHeap(String[] args, MinInitialMaxValues val) throws Exception {
231     OutputAnalyzer output = runWhiteBoxTest(args, ErgoArgsPrinter.class.getName(), new String[] {}, false);
232 
233     // the output we watch for has the following format:
234     //
235     // &quot;Minimum heap X Initial heap Y Maximum heap Z Min alignment A Max Alignment B&quot;
236     //
237     // where A, B, X, Y and Z are sizes in bytes.
238     // Unfortunately there is no other way to retrieve the minimum heap size and
239     // the alignments.
240 
241     Matcher m = Pattern.compile(&quot;Minimum heap \\d+ Initial heap \\d+ Maximum heap \\d+ Space alignment \\d+ Heap alignment \\d+&quot;).
242       matcher(output.getStdout());
243     if (!m.find()) {
</pre>
<hr />
<pre>
303   }
304 
305   private static long getFlagValue(String flag, String where) {
306     Matcher m = Pattern.compile(flag + &quot;\\s+:?=\\s+\\d+&quot;).matcher(where);
307     if (!m.find()) {
308       throw new RuntimeException(&quot;Could not find value for flag &quot; + flag + &quot; in output string&quot;);
309     }
310     String match = m.group();
311     return Long.parseLong(match.substring(match.lastIndexOf(&quot; &quot;) + 1, match.length()));
312   }
313 
314   private static void shouldContainOrNot(OutputAnalyzer output, boolean contains, String message) throws Exception {
315     if (contains) {
316       output.shouldContain(message);
317     } else {
318       output.shouldNotContain(message);
319     }
320   }
321 
322   private static void expect(String[] flags, boolean hasWarning, boolean hasError, int errorcode) throws Exception {
<span class="line-modified">323     ProcessBuilder pb = GCArguments.createJavaProcessBuilder(flags);</span>
324     OutputAnalyzer output = new OutputAnalyzer(pb.start());
325     shouldContainOrNot(output, hasWarning, &quot;Warning&quot;);
326     shouldContainOrNot(output, hasError, &quot;Error&quot;);
327     output.shouldHaveExitValue(errorcode);
328   }
329 
330   private static void expectError(String[] flags) throws Exception {
331     expect(flags, false, true, 1);
332   }
333 
334   private static void expectValid(String[] flags) throws Exception {
335     expect(flags, false, false, 0);
336   }
337 }

</pre>
</td>
</tr>
</table>
<center><a href="TestInitialTenuringThreshold.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TestMaxMinHeapFreeRatioFlags.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/gc/arguments/TestMaxHeapSizeTools.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package gc.arguments;
 25 
 26 import java.util.regex.Matcher;
 27 import java.util.regex.Pattern;
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 
 31 import jdk.test.lib.process.ProcessTools;
 32 import jdk.test.lib.process.OutputAnalyzer;
 33 import sun.hotspot.WhiteBox;
 34 
 35 class ErgoArgsPrinter {
 36   public static void main(String[] args) throws Exception {
 37     WhiteBox wb = WhiteBox.getWhiteBox();
 38     wb.printHeapSizes();
 39   }
 40 }
 41 
 42 final class MinInitialMaxValues {
 43   public long minHeapSize;
 44   public long initialHeapSize;
 45   public long maxHeapSize;
 46 
 47   public long spaceAlignment;
 48   public long heapAlignment;
 49 }
 50 
 51 class TestMaxHeapSizeTools {
 52 
 53   public static void checkMinInitialMaxHeapFlags(String gcflag) throws Exception {
 54     checkInvalidMinInitialHeapCombinations(gcflag);
 55     checkValidMinInitialHeapCombinations(gcflag);
 56     checkInvalidInitialMaxHeapCombinations(gcflag);
 57     checkValidInitialMaxHeapCombinations(gcflag);
 58   }
 59 
 60   public static void checkMinInitialErgonomics(String gcflag) throws Exception {
 61     // heap sizing ergonomics use the value NewSize + OldSize as default values
 62     // for ergonomics calculation. Retrieve these values.
 63     long[] values = new long[2];
 64     getNewOldSize(gcflag, values);
 65 
 66     // we check cases with values smaller and larger than this default value.
 67     long newPlusOldSize = values[0] + values[1];
 68     long smallValue = newPlusOldSize / 2;
 69     long largeValue = newPlusOldSize * 2;
 70     long maxHeapSize = largeValue + (2 * 1024 * 1024);
 71 
 72     // -Xms is not set
 73     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize }, values, -1, -1);
 74     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:InitialHeapSize=&quot; + smallValue }, values, -1, smallValue);
 75     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:InitialHeapSize=&quot; + largeValue }, values, -1, largeValue);
 76     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-XX:InitialHeapSize=0&quot; }, values, -1, -1);
 77 
 78     // -Xms is set to zero
 79     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot; }, values, -1, -1);
 80     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:InitialHeapSize=&quot; + smallValue }, values, -1, smallValue);
 81     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:InitialHeapSize=&quot; + largeValue }, values, -1, largeValue);
 82     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms0&quot;, &quot;-XX:InitialHeapSize=0&quot; }, values, -1, -1);
 83 
 84     // -Xms is set to small value
 85     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + smallValue }, values, -1, -1);
 86     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + smallValue, &quot;-XX:InitialHeapSize=&quot; + smallValue }, values, smallValue, smallValue);
 87     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + smallValue, &quot;-XX:InitialHeapSize=&quot; + largeValue }, values, smallValue, largeValue);
 88     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + smallValue, &quot;-XX:InitialHeapSize=0&quot; }, values, smallValue, -1);
 89 
 90     // -Xms is set to large value
 91     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + largeValue }, values, largeValue, largeValue);
 92     checkErgonomics(new String[] { gcflag, &quot;-Xmx&quot; + maxHeapSize, &quot;-Xms&quot; + largeValue, &quot;-XX:InitialHeapSize=0&quot; }, values, largeValue, -1);
 93   }
 94 
 95   private static long align_up(long value, long alignment) {
 96     long alignmentMinusOne = alignment - 1;
 97     return (value + alignmentMinusOne) &amp; ~alignmentMinusOne;
 98   }
 99 
100   private static void getNewOldSize(String gcflag, long[] values) throws Exception {
101     ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(gcflag,
102       &quot;-XX:+PrintFlagsFinal&quot;, &quot;-version&quot;);
103     OutputAnalyzer output = new OutputAnalyzer(pb.start());
104     output.shouldHaveExitValue(0);
105 
106     String stdout = output.getStdout();
107     values[0] = getFlagValue(&quot; NewSize&quot;, stdout);
108     values[1] = getFlagValue(&quot; OldSize&quot;, stdout);
109   }
110 
111   public static void checkGenMaxHeapErgo(String gcflag) throws Exception {
112     TestMaxHeapSizeTools.checkGenMaxHeapSize(gcflag, 4);
113     TestMaxHeapSizeTools.checkGenMaxHeapSize(gcflag, 5);
114   }
115 
116   private static void checkInvalidMinInitialHeapCombinations(String gcflag) throws Exception {
117     expectError(new String[] { gcflag, &quot;-XX:InitialHeapSize=1023K&quot;, &quot;-version&quot; });
118     expectError(new String[] { gcflag, &quot;-Xms64M&quot;, &quot;-XX:InitialHeapSize=32M&quot;, &quot;-version&quot; });
119   }
120 
121   private static void checkValidMinInitialHeapCombinations(String gcflag) throws Exception {
122     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=1024K&quot;, &quot;-version&quot; });
123     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-Xms4M&quot;, &quot;-version&quot; });
124     expectValid(new String[] { gcflag, &quot;-Xms4M&quot;, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-version&quot; });
125     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-Xms8M&quot;, &quot;-version&quot; });
126     // the following is not an error as -Xms sets both minimal and initial heap size
127     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=4M&quot;, &quot;-Xms8M&quot;, &quot;-version&quot; });
128   }
129 
130   private static void checkInvalidInitialMaxHeapCombinations(String gcflag) throws Exception {
131     expectError(new String[] { gcflag, &quot;-XX:MaxHeapSize=2047K&quot;, &quot;-version&quot; });
132     expectError(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-version&quot; });
133     expectError(new String[] { gcflag, &quot;-XX:InitialHeapSize=8M&quot;, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-version&quot; });
134   }
135 
136   private static void checkValidInitialMaxHeapCombinations(String gcflag) throws Exception {
137     expectValid(new String[] { gcflag, &quot;-XX:InitialHeapSize=4M&quot;, &quot;-XX:MaxHeapSize=8M&quot;, &quot;-version&quot; });
138     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=8M&quot;, &quot;-XX:InitialHeapSize=4M&quot;, &quot;-version&quot; });
139     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:InitialHeapSize=4M&quot;, &quot;-version&quot; });
140     // a value of &quot;0&quot; for initial heap size means auto-detect
141     expectValid(new String[] { gcflag, &quot;-XX:MaxHeapSize=4M&quot;, &quot;-XX:InitialHeapSize=0M&quot;, &quot;-version&quot; });
142   }
143 
144   private static long valueAfter(String source, String match) {
145     int start = source.indexOf(match) + match.length();
146     String tail = source.substring(start).split(&quot; &quot;)[0];
147     return Long.parseLong(tail);
148   }
149 
150   /**
151    * Executes a new VM process with the given class and parameters.
152    * @param vmargs Arguments to the VM to run
153    * @param classname Name of the class to run
154    * @param arguments Arguments to the class
155    * @param useTestDotJavaDotOpts Use test.java.opts as part of the VM argument string
156    * @return The OutputAnalyzer with the results for the invocation.
157    */
158   public static OutputAnalyzer runWhiteBoxTest(String[] vmargs, String classname, String[] arguments, boolean useTestDotJavaDotOpts) throws Exception {
159     ArrayList&lt;String&gt; finalargs = new ArrayList&lt;String&gt;();
160 
161     String[] whiteboxOpts = new String[] {
162       &quot;-Xbootclasspath/a:.&quot;,
163       &quot;-XX:+UnlockDiagnosticVMOptions&quot;, &quot;-XX:+WhiteBoxAPI&quot;,
164       &quot;-cp&quot;, System.getProperty(&quot;java.class.path&quot;),
165     };
166 
167     if (useTestDotJavaDotOpts) {
168       // System.getProperty(&quot;test.java.opts&quot;) is &#39;&#39; if no options is set,
169       // we need to skip such a result
170       String[] externalVMOpts = new String[0];
171       if (System.getProperty(&quot;test.java.opts&quot;) != null &amp;&amp; System.getProperty(&quot;test.java.opts&quot;).length() != 0) {
172         externalVMOpts = System.getProperty(&quot;test.java.opts&quot;).split(&quot; &quot;);
173       }
174       finalargs.addAll(Arrays.asList(externalVMOpts));
175     }
176 
177     finalargs.addAll(Arrays.asList(vmargs));
178     finalargs.addAll(Arrays.asList(whiteboxOpts));
179     finalargs.add(classname);
180     finalargs.addAll(Arrays.asList(arguments));
181 
182     ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(finalargs.toArray(new String[0]));
183     OutputAnalyzer output = new OutputAnalyzer(pb.start());
184     output.shouldHaveExitValue(0);
185 
186     return output;
187   }
188 
189   private static void getMinInitialMaxHeap(String[] args, MinInitialMaxValues val) throws Exception {
190     OutputAnalyzer output = runWhiteBoxTest(args, ErgoArgsPrinter.class.getName(), new String[] {}, false);
191 
192     // the output we watch for has the following format:
193     //
194     // &quot;Minimum heap X Initial heap Y Maximum heap Z Min alignment A Max Alignment B&quot;
195     //
196     // where A, B, X, Y and Z are sizes in bytes.
197     // Unfortunately there is no other way to retrieve the minimum heap size and
198     // the alignments.
199 
200     Matcher m = Pattern.compile(&quot;Minimum heap \\d+ Initial heap \\d+ Maximum heap \\d+ Space alignment \\d+ Heap alignment \\d+&quot;).
201       matcher(output.getStdout());
202     if (!m.find()) {
203       throw new RuntimeException(&quot;Could not find heap size string.&quot;);
204     }
205 
206     String match = m.group();
207 
208     // actual values
209     val.minHeapSize = valueAfter(match, &quot;Minimum heap &quot;);
210     val.initialHeapSize = valueAfter(match, &quot;Initial heap &quot;);
211     val.maxHeapSize = valueAfter(match, &quot;Maximum heap &quot;);
212     val.spaceAlignment = valueAfter(match, &quot;Space alignment &quot;);
213     val.heapAlignment = valueAfter(match, &quot;Heap alignment &quot;);
214   }
215 
216   /**
217    * Verify whether the VM automatically synchronizes minimum and initial heap size if only
218    * one is given for the GC specified.
219    */
220   public static void checkErgonomics(String[] args, long[] newoldsize,
221     long expectedMin, long expectedInitial) throws Exception {
222 
223     MinInitialMaxValues v = new MinInitialMaxValues();
224     getMinInitialMaxHeap(args, v);
225 
226     if ((expectedMin != -1) &amp;&amp; (align_up(expectedMin, v.heapAlignment) != v.minHeapSize)) {
227       throw new RuntimeException(&quot;Actual minimum heap size of &quot; + v.minHeapSize +
228         &quot; differs from expected minimum heap size of &quot; + expectedMin);
229     }
230 
231     if ((expectedInitial != -1) &amp;&amp; (align_up(expectedInitial, v.heapAlignment) != v.initialHeapSize)) {
232       throw new RuntimeException(&quot;Actual initial heap size of &quot; + v.initialHeapSize +
233         &quot; differs from expected initial heap size of &quot; + expectedInitial);
234     }
235 
236     // always check the invariant min &lt;= initial &lt;= max heap size
237     if (!(v.minHeapSize &lt;= v.initialHeapSize &amp;&amp; v.initialHeapSize &lt;= v.maxHeapSize)) {
238       throw new RuntimeException(&quot;Inconsistent min/initial/max heap sizes, they are &quot; +
239         v.minHeapSize + &quot;/&quot; + v.initialHeapSize + &quot;/&quot; + v.maxHeapSize);
240     }
241   }
242 
243   /**
244    * Verify whether the VM respects the given maximum heap size in MB for the
245    * GC specified.
246    * @param gcflag The garbage collector to test as command line flag. E.g. -XX:+UseG1GC
247    * @param maxHeapSize the maximum heap size to verify, in MB.
248    */
249   public static void checkGenMaxHeapSize(String gcflag, long maxHeapsize) throws Exception {
250     final long K = 1024;
251 
252     MinInitialMaxValues v = new MinInitialMaxValues();
253     getMinInitialMaxHeap(new String[] { gcflag, &quot;-XX:MaxHeapSize=&quot; + maxHeapsize + &quot;M&quot; }, v);
254 
255     long expectedHeapSize = align_up(maxHeapsize * K * K, v.heapAlignment);
256     long actualHeapSize = v.maxHeapSize;
257 
258     if (actualHeapSize &gt; expectedHeapSize) {
259       throw new RuntimeException(&quot;Heap has &quot; + actualHeapSize  +
260         &quot; bytes, expected to be less than &quot; + expectedHeapSize);
261     }
262   }
263 
264   private static long getFlagValue(String flag, String where) {
265     Matcher m = Pattern.compile(flag + &quot;\\s+:?=\\s+\\d+&quot;).matcher(where);
266     if (!m.find()) {
267       throw new RuntimeException(&quot;Could not find value for flag &quot; + flag + &quot; in output string&quot;);
268     }
269     String match = m.group();
270     return Long.parseLong(match.substring(match.lastIndexOf(&quot; &quot;) + 1, match.length()));
271   }
272 
273   private static void shouldContainOrNot(OutputAnalyzer output, boolean contains, String message) throws Exception {
274     if (contains) {
275       output.shouldContain(message);
276     } else {
277       output.shouldNotContain(message);
278     }
279   }
280 
281   private static void expect(String[] flags, boolean hasWarning, boolean hasError, int errorcode) throws Exception {
282     ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(flags);
283     OutputAnalyzer output = new OutputAnalyzer(pb.start());
284     shouldContainOrNot(output, hasWarning, &quot;Warning&quot;);
285     shouldContainOrNot(output, hasError, &quot;Error&quot;);
286     output.shouldHaveExitValue(errorcode);
287   }
288 
289   private static void expectError(String[] flags) throws Exception {
290     expect(flags, false, true, 1);
291   }
292 
293   private static void expectValid(String[] flags) throws Exception {
294     expect(flags, false, false, 0);
295   }
296 }
297 
    </pre>
  </body>
</html>
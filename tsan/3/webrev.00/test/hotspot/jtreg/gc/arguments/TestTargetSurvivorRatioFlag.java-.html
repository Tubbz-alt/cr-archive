<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/gc/arguments/TestTargetSurvivorRatioFlag.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package gc.arguments;
 25 
 26 import static java.lang.ref.Reference.reachabilityFence;
 27 
 28 /*
 29  * @test TestTargetSurvivorRatioFlag
 30  * @key gc
 31  * @summary Verify that option TargetSurvivorRatio affects survivor space occupancy after minor GC.
 32  * @requires vm.opt.ExplicitGCInvokesConcurrent != true
 33  * @requires vm.opt.UseJVMCICompiler != true
 34  * @requires vm.gc != &quot;Z&quot; &amp; vm.gc != &quot;Shenandoah&quot;
 35  * @library /test/lib
 36  * @library /
 37  * @modules java.base/jdk.internal.misc
 38  *          java.management
 39  * @build sun.hotspot.WhiteBox
 40  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 41  * @run driver gc.arguments.TestTargetSurvivorRatioFlag
 42  */
 43 
 44 import java.lang.management.GarbageCollectorMXBean;
 45 import java.util.Arrays;
 46 import java.util.Collections;
 47 import java.util.LinkedList;
 48 import java.util.List;
 49 import java.util.regex.Matcher;
 50 import java.util.regex.Pattern;
 51 import jdk.internal.misc.Unsafe;
 52 import jdk.test.lib.process.OutputAnalyzer;
 53 import jdk.test.lib.process.ProcessTools;
 54 import jdk.test.lib.Utils;
 55 import sun.hotspot.WhiteBox;
 56 
 57 /* In order to test that TargetSurvivorRatio affects survivor space occupancy
 58  * we setup fixed MaxTenuringThreshold and then verifying that if size of allocated
 59  * objects is lower than (survivor_size * TargetSurvivorRatio / 100) then objects
 60  * will stay in survivor space until MaxTenuringThreshold minor GC cycles.
 61  * If more than (survivor_size * TargetSurvivorRatio / 100) objects were allocated,
 62  * then we verify that after MaxTenuringThreshold minor GC cycles survivor space
 63  * is almost empty.
 64  */
 65 public class TestTargetSurvivorRatioFlag {
 66 
 67     public static final long M = 1024 * 1024;
 68 
 69     // VM option values
 70     public static final long MAX_NEW_SIZE = 40 * M;
 71     public static final int SURVIVOR_RATIO = 8;
 72     public static final int MAX_TENURING_THRESHOLD = 15;
 73 
 74     // Value used to estimate amount of memory that should be allocated
 75     // and placed in survivor space.
 76     public static final double DELTA = 0.25;
 77 
 78     // Max variance of observed ratio
 79     public static double VARIANCE = 1;
 80 
 81     // Messages used by debuggee
 82     public static final String UNSUPPORTED_GC = &quot;Unsupported GC&quot;;
 83     public static final String START_TEST = &quot;Start test&quot;;
 84     public static final String END_TEST = &quot;End test&quot;;
 85 
 86     // Patterns used during log parsing
 87     public static final String TENURING_DISTRIBUTION = &quot;Desired survivor size&quot;;
 88     public static final String AGE_TABLE_ENTRY = &quot;.*-[\\s]+age[\\s]+([0-9]+):[\\s]+([0-9]+)[\\s]+bytes,[\\s]+([0-9]+)[\\s]+total&quot;;
 89     public static final String MAX_SURVIVOR_SIZE = &quot;Max survivor size: ([0-9]+)&quot;;
 90 
 91     public static void main(String args[]) throws Exception {
 92 
 93         LinkedList&lt;String&gt; options = new LinkedList&lt;&gt;(Arrays.asList(Utils.getTestJavaOpts()));
 94 
 95         // Need to consider the effect of TargetPLABWastePct=1 for G1 GC
 96         if (options.contains(&quot;-XX:+UseG1GC&quot;)) {
 97             VARIANCE = 2;
 98         } else {
 99             VARIANCE = 1;
100         }
101 
102         negativeTest(-1, options);
103         negativeTest(101, options);
104 
105         positiveTest(20, options);
106         positiveTest(30, options);
107         positiveTest(55, options);
108         positiveTest(70, options);
109     }
110 
111     /**
112      * Verify that VM will fail to start with specified TargetSurvivorRatio
113      *
114      * @param ratio value of TargetSurvivorRatio
115      * @param options additional VM options
116      */
117     public static void negativeTest(int ratio, LinkedList&lt;String&gt; options) throws Exception {
118         LinkedList&lt;String&gt; vmOptions = new LinkedList&lt;&gt;(options);
119         vmOptions.add(&quot;-XX:TargetSurvivorRatio=&quot; + ratio);
120         vmOptions.add(&quot;-version&quot;);
121 
122         ProcessBuilder procBuilder = ProcessTools.createJavaProcessBuilder(vmOptions.toArray(new String[vmOptions.size()]));
123         OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());
124 
125         analyzer.shouldHaveExitValue(1);
126         analyzer.shouldContain(&quot;Error: Could not create the Java Virtual Machine.&quot;);
127     }
128 
129     /**
130      * Verify that actual survivor space usage ratio conforms specified TargetSurvivorRatio
131      *
132      * @param ratio value of TargetSurvivorRatio
133      * @param options additional VM options
134      */
135     public static void positiveTest(int ratio, LinkedList&lt;String&gt; options) throws Exception {
136         LinkedList&lt;String&gt; vmOptions = new LinkedList&lt;&gt;(options);
137         Collections.addAll(vmOptions,
138                 &quot;-Xbootclasspath/a:.&quot;,
139                 &quot;--add-exports=java.base/jdk.internal.misc=ALL-UNNAMED&quot;,
140                 &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
141                 &quot;-XX:+WhiteBoxAPI&quot;,
142                 &quot;-XX:+UseAdaptiveSizePolicy&quot;,
143                 &quot;-Xlog:gc+age=trace&quot;,
144                 &quot;-XX:MaxTenuringThreshold=&quot; + MAX_TENURING_THRESHOLD,
145                 &quot;-XX:NewSize=&quot; + MAX_NEW_SIZE,
146                 &quot;-XX:MaxNewSize=&quot; + MAX_NEW_SIZE,
147                 &quot;-XX:InitialHeapSize=&quot; + 2 * MAX_NEW_SIZE,
148                 &quot;-XX:MaxHeapSize=&quot; + 2 * MAX_NEW_SIZE,
149                 &quot;-XX:SurvivorRatio=&quot; + SURVIVOR_RATIO,
150                 &quot;-XX:TargetSurvivorRatio=&quot; + ratio,
151                 // For reducing variance of survivor size.
152                 &quot;-XX:TargetPLABWastePct=&quot; + 1,
153                 TargetSurvivorRatioVerifier.class.getName(),
154                 Integer.toString(ratio)
155         );
156 
157         ProcessBuilder procBuilder = ProcessTools.createJavaProcessBuilder(vmOptions.toArray(new String[vmOptions.size()]));
158         OutputAnalyzer analyzer = new OutputAnalyzer(procBuilder.start());
159 
160         analyzer.shouldHaveExitValue(0);
161 
162         String output = analyzer.getOutput();
163 
164         // Test avoids verification for parallel GC
165         if (!output.contains(UNSUPPORTED_GC)) {
166             // Two tests should be done - when actual ratio is lower than TargetSurvivorRatio
167             // and when it is higher. We chech that output contains results for exactly two tests.
168             List&lt;Double&gt; ratios = parseTestOutput(output);
169 
170             if (ratios.size() != 2) {
171                 System.out.println(output);
172                 throw new RuntimeException(&quot;Expected number of ratios extraced for output is 2,&quot;
173                         + &quot; but &quot; + ratios.size() + &quot; ratios were extracted&quot;);
174             }
175 
176             // At the end of the first test survivor space usage ratio should lies between
177             // TargetSurvivorRatio and TargetSurvivorRatio - 2*DELTA
178             if (ratio &lt; ratios.get(0) || ratio - ratios.get(0) &gt; VARIANCE) {
179                 System.out.println(output);
180                 throw new RuntimeException(&quot;Survivor space usage ratio expected to be close to &quot;
181                         + ratio + &quot;, but observed ratio is: &quot; + ratios.get(0));
182             }
183 
184             // After second test survivor space should be almost empty.
185             if (ratios.get(1) &gt; VARIANCE) {
186                 System.out.println(output);
187                 throw new RuntimeException(&quot;Survivor space expected to be empty due to &quot;
188                         + &quot;TargetSurvivorRatio overlimit, however observed &quot;
189                         + &quot;survivor space usage ratio is: &quot; + ratios.get(1));
190             }
191         } else {
192             System.out.println(&quot;Selected GC does not support TargetSurvivorRatio option.&quot;);
193         }
194     }
195 
196     /**
197      * Parse output produced by TargetSurvivorRatioVerifier.
198      *
199      * @param output output obtained from TargetSurvivorRatioVerifier
200      * @return list of parsed test results, where each result is an actual
201      *         survivor ratio after MaxTenuringThreshold minor GC cycles.
202      */
203     public static List&lt;Double&gt; parseTestOutput(String output) {
204         List&lt;Double&gt; ratios = new LinkedList&lt;Double&gt;();
205         String lines[] = output.split(&quot;[\n\r]&quot;);
206         boolean testStarted = false;
207         long survivorSize = 0;
208         long survivorOccupancy = 0;
209         int gcCount = 0;
210         Pattern ageTableEntry = Pattern.compile(AGE_TABLE_ENTRY);
211         Pattern maxSurvivorSize = Pattern.compile(MAX_SURVIVOR_SIZE);
212         for (String line : lines) {
213             if (Pattern.matches(MAX_SURVIVOR_SIZE, line)) {
214                 // We found estimated survivor space size
215                 Matcher m = maxSurvivorSize.matcher(line);
216                 m.find();
217                 survivorSize = Long.valueOf(m.group(1));
218             } else if (line.contains(START_TEST) &amp;&amp; !testStarted) {
219                 // Start collecting test results
220                 testStarted = true;
221                 gcCount = 0;
222             } else if (testStarted) {
223                 if (line.contains(TENURING_DISTRIBUTION)) {
224                     // We found start of output emitted by -XX:+PrintTenuringDistribution
225                     // If it is associated with &quot;MaxTenuringThreshold&quot; GC cycle, then it&#39;s
226                     // time to report observed survivor usage ratio
227                     gcCount++;
228                     double survivorRatio = survivorOccupancy / (double) survivorSize;
229                     if (gcCount == MAX_TENURING_THRESHOLD || gcCount == MAX_TENURING_THRESHOLD * 2) {
230                         ratios.add(survivorRatio * 100.0);
231                         testStarted = false;
232                     }
233                     survivorOccupancy = 0;
234                 } else if (Pattern.matches(AGE_TABLE_ENTRY, line)) {
235                     // Obtain survivor space usage from &quot;total&quot; age table log entry
236                     Matcher m = ageTableEntry.matcher(line);
237                     m.find();
238                     survivorOccupancy = Long.valueOf(m.group(3));
239                 } else if (line.contains(END_TEST)) {
240                     // It is expected to find at least MaxTenuringThreshold GC events
241                     // until test end
242                     if (gcCount &lt; MAX_TENURING_THRESHOLD) {
243                         throw new RuntimeException(&quot;Observed &quot; + gcCount + &quot; GC events, &quot;
244                                 + &quot;while it is expected to see at least &quot;
245                                 + MAX_TENURING_THRESHOLD);
246                     }
247                     testStarted = false;
248                 }
249             }
250         }
251         return ratios;
252     }
253 
254     public static class TargetSurvivorRatioVerifier {
255 
256         static final WhiteBox wb = WhiteBox.getWhiteBox();
257         static final Unsafe unsafe = Unsafe.getUnsafe();
258 
259         // Desired size of memory allocated at once
260         public static final int CHUNK_SIZE = 1024;
261         // Length of byte[] array that will have occupy CHUNK_SIZE bytes in heap
262         public static final int ARRAY_LENGTH = CHUNK_SIZE - Unsafe.ARRAY_BYTE_BASE_OFFSET;
263 
264         public static void main(String args[]) throws Exception {
265             if (args.length != 1) {
266                 throw new IllegalArgumentException(&quot;Expected 1 arg: &lt;ratio&gt;&quot;);
267             }
268             if (GCTypes.YoungGCType.getYoungGCType() == GCTypes.YoungGCType.PSNew) {
269                 System.out.println(UNSUPPORTED_GC);
270                 return;
271             }
272 
273             int ratio = Integer.valueOf(args[0]);
274             long maxSurvivorSize = getMaxSurvivorSize();
275             System.out.println(&quot;Max survivor size: &quot; + maxSurvivorSize);
276 
277             allocateMemory(ratio - DELTA, maxSurvivorSize);
278             allocateMemory(ratio + DELTA, maxSurvivorSize);
279         }
280 
281         /**
282          * Allocate (&lt;b&gt;ratio&lt;/b&gt; * &lt;b&gt;maxSize&lt;/b&gt; / 100) bytes of objects
283          * and force at least &quot;MaxTenuringThreshold&quot; minor GCs.
284          *
285          * @param ratio ratio used to calculate how many objects should be allocated
286          * @param maxSize estimated max survivor space size
287          */
288         public static void allocateMemory(double ratio, long maxSize) throws Exception {
289             GarbageCollectorMXBean youngGCBean = GCTypes.YoungGCType.getYoungGCBean();
290             long garbageSize = (long) (maxSize * (ratio / 100.0));
291             int arrayLength = (int) (garbageSize / CHUNK_SIZE);
292             AllocationHelper allocator = new AllocationHelper(1, arrayLength, ARRAY_LENGTH, null);
293 
294             System.out.println(START_TEST);
295             System.gc();
296             final long initialGcId = youngGCBean.getCollectionCount();
297             // allocate memory
298             allocator.allocateMemoryAndVerify();
299 
300             // force minor GC
301             while (youngGCBean.getCollectionCount() &lt;= initialGcId + MAX_TENURING_THRESHOLD * 2) {
302                 reachabilityFence(new byte[ARRAY_LENGTH]);
303             }
304 
305             allocator.release();
306             System.out.println(END_TEST);
307         }
308 
309         /**
310          * Estimate max survivor space size.
311          *
312          * For non-G1 GC returns value reported by MemoryPoolMXBean
313          * associated with survivor space.
314          * For G1 GC return max number of survivor regions * region size.
315          * Number if survivor regions estimated from MaxNewSize and SurvivorRatio.
316          */
317         public static long getMaxSurvivorSize() {
318             if (GCTypes.YoungGCType.getYoungGCType() == GCTypes.YoungGCType.G1) {
319                 int youngLength = (int) Math.max(MAX_NEW_SIZE / wb.g1RegionSize(), 1);
320                 return (long) Math.ceil(youngLength / (double) SURVIVOR_RATIO) * wb.g1RegionSize();
321             } else {
322                 return HeapRegionUsageTool.getSurvivorUsage().getMax();
323             }
324         }
325     }
326 }
    </pre>
  </body>
</html>
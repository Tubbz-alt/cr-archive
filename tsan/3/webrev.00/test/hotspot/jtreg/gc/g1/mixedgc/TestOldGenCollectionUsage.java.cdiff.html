<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/hotspot/jtreg/gc/g1/mixedgc/TestOldGenCollectionUsage.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestLogging.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../libCriticalNative.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/gc/g1/mixedgc/TestOldGenCollectionUsage.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 21,36 ***</span>
   * questions.
   */
  
  package gc.g1.mixedgc;
  
  /*
   * @test TestOldGenCollectionUsage.java
   * @bug 8195115
   * @summary G1 Old Gen&#39;s CollectionUsage.used is zero after mixed GC which is incorrect
   * @key gc
   * @requires vm.gc.G1
<span class="line-modified">!  * @library /test/lib</span>
   * @modules java.base/jdk.internal.misc
   * @modules java.management
   * @build sun.hotspot.WhiteBox
   * @run driver ClassFileInstaller sun.hotspot.WhiteBox
<span class="line-modified">!  * @run main/othervm -Xbootclasspath/a:. -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -verbose:gc -XX:SurvivorRatio=1 -Xmx14m -Xms14m -XX:MaxTenuringThreshold=1 -XX:InitiatingHeapOccupancyPercent=100 -XX:-G1UseAdaptiveIHOP -XX:G1MixedGCCountTarget=4 -XX:MaxGCPauseMillis=30000 -XX:G1HeapRegionSize=1m -XX:G1HeapWastePercent=0 -XX:G1MixedGCLiveThresholdPercent=100 gc.g1.mixedgc.TestOldGenCollectionUsage</span>
   */
  
<span class="line-removed">- import jdk.test.lib.Asserts;</span>
<span class="line-removed">- import sun.hotspot.WhiteBox;</span>
<span class="line-removed">- </span>
<span class="line-removed">- import java.util.ArrayList;</span>
<span class="line-removed">- import java.util.List;</span>
<span class="line-removed">- import java.lang.management.*;</span>
<span class="line-removed">- </span>
  // 8195115 says that for the &quot;G1 Old Gen&quot; MemoryPool, CollectionUsage.used
<span class="line-modified">! // is zero for G1 after a mixed collection, which is incorrect.</span>
  
  public class TestOldGenCollectionUsage {
  
      private String poolName = &quot;G1 Old Gen&quot;;
      private String collectorName = &quot;G1 Young Generation&quot;;
  
      public static void main(String [] args) throws Exception {
          TestOldGenCollectionUsage t = new TestOldGenCollectionUsage();
<span class="line-new-header">--- 21,42 ---</span>
   * questions.
   */
  
  package gc.g1.mixedgc;
  
<span class="line-added">+ import static sun.hotspot.WhiteBox.getWhiteBox;</span>
<span class="line-added">+ </span>
<span class="line-added">+ import java.lang.management.*;</span>
<span class="line-added">+ import java.util.ArrayList;</span>
<span class="line-added">+ import java.util.List;</span>
<span class="line-added">+ </span>
<span class="line-added">+ import gc.testlibrary.g1.MixedGCProvoker;</span>
<span class="line-added">+ </span>
  /*
   * @test TestOldGenCollectionUsage.java
   * @bug 8195115
   * @summary G1 Old Gen&#39;s CollectionUsage.used is zero after mixed GC which is incorrect
   * @key gc
   * @requires vm.gc.G1
<span class="line-modified">!  * @library /test/lib /</span>
   * @modules java.base/jdk.internal.misc
   * @modules java.management
   * @build sun.hotspot.WhiteBox
   * @run driver ClassFileInstaller sun.hotspot.WhiteBox
<span class="line-modified">!  * @run main/othervm -Xbootclasspath/a:. -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -verbose:gc -XX:NewSize=2m -XX:MaxNewSize=2m -Xmx14m -Xms14m -XX:+AlwaysTenure -XX:InitiatingHeapOccupancyPercent=100 -XX:-G1UseAdaptiveIHOP -XX:G1MixedGCCountTarget=4 -XX:MaxGCPauseMillis=30000 -XX:G1HeapRegionSize=1m -XX:G1HeapWastePercent=0 -XX:G1MixedGCLiveThresholdPercent=100 gc.g1.mixedgc.TestOldGenCollectionUsage</span>
   */
  
  // 8195115 says that for the &quot;G1 Old Gen&quot; MemoryPool, CollectionUsage.used
<span class="line-modified">! // is zero for G1 after a mixed collection, which is incorrect. We can not guarantee</span>
<span class="line-added">+ // that we start with an old gen occupancy of zero though due to allocation during</span>
<span class="line-added">+ // initialization. We check for &quot;increases during mixed gc&quot; instead.</span>
  
  public class TestOldGenCollectionUsage {
  
<span class="line-added">+     private static final int HeapRegionSize = 1024 * 1024;</span>
<span class="line-added">+     private static final int ObjectSize = 20_000;</span>
<span class="line-added">+ </span>
      private String poolName = &quot;G1 Old Gen&quot;;
      private String collectorName = &quot;G1 Young Generation&quot;;
  
      public static void main(String [] args) throws Exception {
          TestOldGenCollectionUsage t = new TestOldGenCollectionUsage();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,19 ***</span>
          }
          if (!foundCollector) {
              throw new RuntimeException(collectorName + &quot; not found, test with -XX:+UseG1GC&quot;);
          }
  
<span class="line-modified">!         MixedGCProvoker gcProvoker = new MixedGCProvoker();</span>
<span class="line-removed">-         gcProvoker.allocateOldObjects();</span>
  
<span class="line-modified">!         // Verify no non-zero result was stored</span>
<span class="line-modified">!         long usage = pool.getCollectionUsage().getUsed();</span>
<span class="line-modified">!         System.out.println(poolName + &quot;: usage after GC = &quot; + usage);</span>
<span class="line-modified">!         if (usage &gt; 0) {</span>
<span class="line-modified">!             throw new RuntimeException(&quot;Premature mixed collections(s)&quot;);</span>
<span class="line-removed">-         }</span>
  
          // Verify that collections were done
          long collectionCount = collector.getCollectionCount();
          System.out.println(collectorName + &quot;: collection count = &quot;
                             + collectionCount);
<span class="line-new-header">--- 99,17 ---</span>
          }
          if (!foundCollector) {
              throw new RuntimeException(collectorName + &quot; not found, test with -XX:+UseG1GC&quot;);
          }
  
<span class="line-modified">!         getWhiteBox().fullGC(); // Make sure the heap is in a known state.</span>
  
<span class="line-modified">!         var liveOldObjects = new ArrayList&lt;byte[]&gt;();</span>
<span class="line-modified">!         MixedGCProvoker.allocateOldObjects(liveOldObjects, HeapRegionSize, ObjectSize);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         long baseUsage = pool.getCollectionUsage().getUsed();</span>
<span class="line-modified">!         System.out.println(poolName + &quot;: usage after GC = &quot; + baseUsage);</span>
  
          // Verify that collections were done
          long collectionCount = collector.getCollectionCount();
          System.out.println(collectorName + &quot;: collection count = &quot;
                             + collectionCount);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,16 ***</span>
          }
          if (collectionTime &lt;= 0) {
              throw new RuntimeException(&quot;Collector has not run&quot;);
          }
  
<span class="line-modified">!         gcProvoker.provokeMixedGC();</span>
  
<span class="line-modified">!         usage = pool.getCollectionUsage().getUsed();</span>
          System.out.println(poolName + &quot;: usage after GC = &quot; + usage);
<span class="line-modified">!         if (usage &lt;= 0) {</span>
<span class="line-modified">!             throw new RuntimeException(poolName + &quot; found with zero usage&quot;);</span>
          }
  
          long newCollectionCount = collector.getCollectionCount();
          System.out.println(collectorName + &quot;: collection count = &quot;
                             + newCollectionCount);
<span class="line-new-header">--- 121,16 ---</span>
          }
          if (collectionTime &lt;= 0) {
              throw new RuntimeException(&quot;Collector has not run&quot;);
          }
  
<span class="line-modified">!         MixedGCProvoker.provokeMixedGC(liveOldObjects);</span>
  
<span class="line-modified">!         long usage = pool.getCollectionUsage().getUsed();</span>
          System.out.println(poolName + &quot;: usage after GC = &quot; + usage);
<span class="line-modified">!         if (usage &lt;= baseUsage) {</span>
<span class="line-modified">!             throw new RuntimeException(poolName + &quot; found not updating usage&quot;);</span>
          }
  
          long newCollectionCount = collector.getCollectionCount();
          System.out.println(collectorName + &quot;: collection count = &quot;
                             + newCollectionCount);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,89 ***</span>
              throw new RuntimeException(&quot;Collector has not run some more&quot;);
          }
  
          System.out.println(&quot;Test passed.&quot;);
      }
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Utility class to guarantee a mixed GC. The class allocates several arrays and</span>
<span class="line-removed">-      * promotes them to the oldgen. After that it tries to provoke mixed GC by</span>
<span class="line-removed">-      * allocating new objects.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * The necessary condition for guaranteed mixed GC is running MixedGCProvoker is</span>
<span class="line-removed">-      * running in VM with the following flags: -XX:MaxTenuringThreshold=1 -Xms12M</span>
<span class="line-removed">-      * -Xmx12M -XX:G1MixedGCLiveThresholdPercent=100 -XX:G1HeapWastePercent=0</span>
<span class="line-removed">-      * -XX:G1HeapRegionSize=1m</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public class MixedGCProvoker {</span>
<span class="line-removed">-         private final WhiteBox WB = WhiteBox.getWhiteBox();</span>
<span class="line-removed">-         private final List&lt;byte[]&gt; liveOldObjects = new ArrayList&lt;&gt;();</span>
<span class="line-removed">-         private final List&lt;byte[]&gt; newObjects = new ArrayList&lt;&gt;();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public static final int ALLOCATION_SIZE = 20000;</span>
<span class="line-removed">-         public static final int ALLOCATION_COUNT = 15;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public void allocateOldObjects() {</span>
<span class="line-removed">-             List&lt;byte[]&gt; deadOldObjects = new ArrayList&lt;&gt;();</span>
<span class="line-removed">-             // Allocates buffer and promotes it to the old gen. Mix live and dead old</span>
<span class="line-removed">-             // objects</span>
<span class="line-removed">-             for (int i = 0; i &lt; ALLOCATION_COUNT; ++i) {</span>
<span class="line-removed">-                 liveOldObjects.add(new byte[ALLOCATION_SIZE * 5]);</span>
<span class="line-removed">-                 deadOldObjects.add(new byte[ALLOCATION_SIZE * 5]);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Do two young collections, MaxTenuringThreshold=1 will force promotion.</span>
<span class="line-removed">-             // G1HeapRegionSize=1m guarantees that old gen regions will be filled.</span>
<span class="line-removed">-             WB.youngGC();</span>
<span class="line-removed">-             WB.youngGC();</span>
<span class="line-removed">-             // Check it is promoted &amp; keep alive</span>
<span class="line-removed">-             Asserts.assertTrue(WB.isObjectInOldGen(liveOldObjects),</span>
<span class="line-removed">-                                &quot;List of the objects is suppose to be in OldGen&quot;);</span>
<span class="line-removed">-             Asserts.assertTrue(WB.isObjectInOldGen(deadOldObjects),</span>
<span class="line-removed">-                                &quot;List of the objects is suppose to be in OldGen&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Waits until Concurent Mark Cycle finishes</span>
<span class="line-removed">-          * @param wb  Whitebox instance</span>
<span class="line-removed">-          * @param sleepTime sleep time</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private void waitTillCMCFinished(int sleepTime) {</span>
<span class="line-removed">-             while (WB.g1InConcurrentMark()) {</span>
<span class="line-removed">-                 if (sleepTime &gt; -1) {</span>
<span class="line-removed">-                     try {</span>
<span class="line-removed">-                         Thread.sleep(sleepTime);</span>
<span class="line-removed">-                     } catch (InterruptedException e) {</span>
<span class="line-removed">-                         System.out.println(&quot;Got InterruptedException while waiting for ConcMarkCycle to finish&quot;);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public void provokeMixedGC() {</span>
<span class="line-removed">-             waitTillCMCFinished(0);</span>
<span class="line-removed">-             WB.g1StartConcMarkCycle();</span>
<span class="line-removed">-             waitTillCMCFinished(0);</span>
<span class="line-removed">-             WB.youngGC();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             System.out.println(&quot;Allocating new objects to provoke mixed GC&quot;);</span>
<span class="line-removed">-             // Provoke a mixed collection. G1MixedGCLiveThresholdPercent=100</span>
<span class="line-removed">-             // guarantees that full old gen regions will be included.</span>
<span class="line-removed">-             for (int i = 0; i &lt; (ALLOCATION_COUNT * 20); i++) {</span>
<span class="line-removed">-                 try {</span>
<span class="line-removed">-                     newObjects.add(new byte[ALLOCATION_SIZE]);</span>
<span class="line-removed">-                 } catch (OutOfMemoryError e) {</span>
<span class="line-removed">-                     newObjects.clear();</span>
<span class="line-removed">-                     WB.youngGC();</span>
<span class="line-removed">-                     WB.youngGC();</span>
<span class="line-removed">-                     System.out.println(&quot;OutOfMemoryError is reported, stop allocating new objects&quot;);</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             // check that liveOldObjects still alive</span>
<span class="line-removed">-             Asserts.assertTrue(WB.isObjectInOldGen(liveOldObjects),</span>
<span class="line-removed">-                                &quot;List of the objects is suppose to be in OldGen&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
  }
<span class="line-new-header">--- 144,7 ---</span>
              throw new RuntimeException(&quot;Collector has not run some more&quot;);
          }
  
          System.out.println(&quot;Test passed.&quot;);
      }
  }
<span class="line-added">+ </span>
</pre>
<center><a href="TestLogging.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../libCriticalNative.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
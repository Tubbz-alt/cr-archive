diff a/test/hotspot/jtreg/gc/g1/mixedgc/TestOldGenCollectionUsage.java b/test/hotspot/jtreg/gc/g1/mixedgc/TestOldGenCollectionUsage.java
--- a/test/hotspot/jtreg/gc/g1/mixedgc/TestOldGenCollectionUsage.java
+++ b/test/hotspot/jtreg/gc/g1/mixedgc/TestOldGenCollectionUsage.java
@@ -21,36 +21,42 @@
  * questions.
  */
 
 package gc.g1.mixedgc;
 
+import static sun.hotspot.WhiteBox.getWhiteBox;
+
+import java.lang.management.*;
+import java.util.ArrayList;
+import java.util.List;
+
+import gc.testlibrary.g1.MixedGCProvoker;
+
 /*
  * @test TestOldGenCollectionUsage.java
  * @bug 8195115
  * @summary G1 Old Gen's CollectionUsage.used is zero after mixed GC which is incorrect
  * @key gc
  * @requires vm.gc.G1
- * @library /test/lib
+ * @library /test/lib /
  * @modules java.base/jdk.internal.misc
  * @modules java.management
  * @build sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
- * @run main/othervm -Xbootclasspath/a:. -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -verbose:gc -XX:SurvivorRatio=1 -Xmx14m -Xms14m -XX:MaxTenuringThreshold=1 -XX:InitiatingHeapOccupancyPercent=100 -XX:-G1UseAdaptiveIHOP -XX:G1MixedGCCountTarget=4 -XX:MaxGCPauseMillis=30000 -XX:G1HeapRegionSize=1m -XX:G1HeapWastePercent=0 -XX:G1MixedGCLiveThresholdPercent=100 gc.g1.mixedgc.TestOldGenCollectionUsage
+ * @run main/othervm -Xbootclasspath/a:. -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -verbose:gc -XX:NewSize=2m -XX:MaxNewSize=2m -Xmx14m -Xms14m -XX:+AlwaysTenure -XX:InitiatingHeapOccupancyPercent=100 -XX:-G1UseAdaptiveIHOP -XX:G1MixedGCCountTarget=4 -XX:MaxGCPauseMillis=30000 -XX:G1HeapRegionSize=1m -XX:G1HeapWastePercent=0 -XX:G1MixedGCLiveThresholdPercent=100 gc.g1.mixedgc.TestOldGenCollectionUsage
  */
 
-import jdk.test.lib.Asserts;
-import sun.hotspot.WhiteBox;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.lang.management.*;
-
 // 8195115 says that for the "G1 Old Gen" MemoryPool, CollectionUsage.used
-// is zero for G1 after a mixed collection, which is incorrect.
+// is zero for G1 after a mixed collection, which is incorrect. We can not guarantee
+// that we start with an old gen occupancy of zero though due to allocation during
+// initialization. We check for "increases during mixed gc" instead.
 
 public class TestOldGenCollectionUsage {
 
+    private static final int HeapRegionSize = 1024 * 1024;
+    private static final int ObjectSize = 20_000;
+
     private String poolName = "G1 Old Gen";
     private String collectorName = "G1 Young Generation";
 
     public static void main(String [] args) throws Exception {
         TestOldGenCollectionUsage t = new TestOldGenCollectionUsage();
@@ -93,19 +99,17 @@
         }
         if (!foundCollector) {
             throw new RuntimeException(collectorName + " not found, test with -XX:+UseG1GC");
         }
 
-        MixedGCProvoker gcProvoker = new MixedGCProvoker();
-        gcProvoker.allocateOldObjects();
+        getWhiteBox().fullGC(); // Make sure the heap is in a known state.
 
-        // Verify no non-zero result was stored
-        long usage = pool.getCollectionUsage().getUsed();
-        System.out.println(poolName + ": usage after GC = " + usage);
-        if (usage > 0) {
-            throw new RuntimeException("Premature mixed collections(s)");
-        }
+        var liveOldObjects = new ArrayList<byte[]>();
+        MixedGCProvoker.allocateOldObjects(liveOldObjects, HeapRegionSize, ObjectSize);
+
+        long baseUsage = pool.getCollectionUsage().getUsed();
+        System.out.println(poolName + ": usage after GC = " + baseUsage);
 
         // Verify that collections were done
         long collectionCount = collector.getCollectionCount();
         System.out.println(collectorName + ": collection count = "
                            + collectionCount);
@@ -117,16 +121,16 @@
         }
         if (collectionTime <= 0) {
             throw new RuntimeException("Collector has not run");
         }
 
-        gcProvoker.provokeMixedGC();
+        MixedGCProvoker.provokeMixedGC(liveOldObjects);
 
-        usage = pool.getCollectionUsage().getUsed();
+        long usage = pool.getCollectionUsage().getUsed();
         System.out.println(poolName + ": usage after GC = " + usage);
-        if (usage <= 0) {
-            throw new RuntimeException(poolName + " found with zero usage");
+        if (usage <= baseUsage) {
+            throw new RuntimeException(poolName + " found not updating usage");
         }
 
         long newCollectionCount = collector.getCollectionCount();
         System.out.println(collectorName + ": collection count = "
                            + newCollectionCount);
@@ -140,89 +144,7 @@
             throw new RuntimeException("Collector has not run some more");
         }
 
         System.out.println("Test passed.");
     }
-
-    /**
-     * Utility class to guarantee a mixed GC. The class allocates several arrays and
-     * promotes them to the oldgen. After that it tries to provoke mixed GC by
-     * allocating new objects.
-     *
-     * The necessary condition for guaranteed mixed GC is running MixedGCProvoker is
-     * running in VM with the following flags: -XX:MaxTenuringThreshold=1 -Xms12M
-     * -Xmx12M -XX:G1MixedGCLiveThresholdPercent=100 -XX:G1HeapWastePercent=0
-     * -XX:G1HeapRegionSize=1m
-     */
-    public class MixedGCProvoker {
-        private final WhiteBox WB = WhiteBox.getWhiteBox();
-        private final List<byte[]> liveOldObjects = new ArrayList<>();
-        private final List<byte[]> newObjects = new ArrayList<>();
-
-        public static final int ALLOCATION_SIZE = 20000;
-        public static final int ALLOCATION_COUNT = 15;
-
-        public void allocateOldObjects() {
-            List<byte[]> deadOldObjects = new ArrayList<>();
-            // Allocates buffer and promotes it to the old gen. Mix live and dead old
-            // objects
-            for (int i = 0; i < ALLOCATION_COUNT; ++i) {
-                liveOldObjects.add(new byte[ALLOCATION_SIZE * 5]);
-                deadOldObjects.add(new byte[ALLOCATION_SIZE * 5]);
-            }
-
-            // Do two young collections, MaxTenuringThreshold=1 will force promotion.
-            // G1HeapRegionSize=1m guarantees that old gen regions will be filled.
-            WB.youngGC();
-            WB.youngGC();
-            // Check it is promoted & keep alive
-            Asserts.assertTrue(WB.isObjectInOldGen(liveOldObjects),
-                               "List of the objects is suppose to be in OldGen");
-            Asserts.assertTrue(WB.isObjectInOldGen(deadOldObjects),
-                               "List of the objects is suppose to be in OldGen");
-        }
-
-        /**
-         * Waits until Concurent Mark Cycle finishes
-         * @param wb  Whitebox instance
-         * @param sleepTime sleep time
-         */
-        private void waitTillCMCFinished(int sleepTime) {
-            while (WB.g1InConcurrentMark()) {
-                if (sleepTime > -1) {
-                    try {
-                        Thread.sleep(sleepTime);
-                    } catch (InterruptedException e) {
-                        System.out.println("Got InterruptedException while waiting for ConcMarkCycle to finish");
-                    }
-                }
-            }
-        }
-
-        public void provokeMixedGC() {
-            waitTillCMCFinished(0);
-            WB.g1StartConcMarkCycle();
-            waitTillCMCFinished(0);
-            WB.youngGC();
-
-            System.out.println("Allocating new objects to provoke mixed GC");
-            // Provoke a mixed collection. G1MixedGCLiveThresholdPercent=100
-            // guarantees that full old gen regions will be included.
-            for (int i = 0; i < (ALLOCATION_COUNT * 20); i++) {
-                try {
-                    newObjects.add(new byte[ALLOCATION_SIZE]);
-                } catch (OutOfMemoryError e) {
-                    newObjects.clear();
-                    WB.youngGC();
-                    WB.youngGC();
-                    System.out.println("OutOfMemoryError is reported, stop allocating new objects");
-                    break;
-                }
-            }
-            // check that liveOldObjects still alive
-            Asserts.assertTrue(WB.isObjectInOldGen(liveOldObjects),
-                               "List of the objects is suppose to be in OldGen");
-        }
-
-    }
-
 }
+

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/gc/shenandoah/compiler/TestReferenceCAS.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2018, Red Hat, Inc. All rights reserved.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 /*
 25  * Run standalone with: --add-exports java.base/jdk.internal.misc=ALL-UNNAMED --add-opens java.base/jdk.internal.misc=ALL-UNNAMED
 26  */
 27 
 28 /*
 29  * @test TestReferenceCAS
 30  * @summary Shenandoah reference CAS test
 31  * @key gc
 32  * @requires vm.gc.Shenandoah
 33  * @modules java.base/jdk.internal.misc:+open
 34  *
 35  * @run main/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCHeuristics=aggressive -XX:+UseShenandoahGC                                                 TestReferenceCAS
 36  * @run main/othervm -Diters=100   -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCHeuristics=aggressive -XX:+UseShenandoahGC -Xint                                           TestReferenceCAS
 37  * @run main/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCHeuristics=aggressive -XX:+UseShenandoahGC -XX:-TieredCompilation                          TestReferenceCAS
 38  * @run main/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCHeuristics=aggressive -XX:+UseShenandoahGC -XX:TieredStopAtLevel=1                         TestReferenceCAS
 39  * @run main/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCHeuristics=aggressive -XX:+UseShenandoahGC -XX:TieredStopAtLevel=4                         TestReferenceCAS
 40  *
 41  * @run main/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCHeuristics=aggressive -XX:+UseShenandoahGC -XX:-UseCompressedOops                          TestReferenceCAS
 42  * @run main/othervm -Diters=100   -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCHeuristics=aggressive -XX:+UseShenandoahGC -XX:-UseCompressedOops -Xint                    TestReferenceCAS
 43  * @run main/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCHeuristics=aggressive -XX:+UseShenandoahGC -XX:-UseCompressedOops -XX:-TieredCompilation   TestReferenceCAS
 44  * @run main/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCHeuristics=aggressive -XX:+UseShenandoahGC -XX:-UseCompressedOops -XX:TieredStopAtLevel=1  TestReferenceCAS
 45  * @run main/othervm -Diters=20000 -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCHeuristics=aggressive -XX:+UseShenandoahGC -XX:-UseCompressedOops -XX:TieredStopAtLevel=4  TestReferenceCAS
 46  */
 47 
 48 import java.lang.reflect.Field;
 49 
 50 public class TestReferenceCAS {
 51 
 52     static final int ITERS = Integer.getInteger(&quot;iters&quot;, 1);
 53     static final int WEAK_ATTEMPTS = Integer.getInteger(&quot;weakAttempts&quot;, 10);
 54 
 55     static final jdk.internal.misc.Unsafe UNSAFE;
 56     static final long V_OFFSET;
 57 
 58     static {
 59         try {
 60             Field f = jdk.internal.misc.Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
 61             f.setAccessible(true);
 62             UNSAFE = (jdk.internal.misc.Unsafe) f.get(null);
 63         } catch (Exception e) {
 64             throw new RuntimeException(&quot;Unable to get Unsafe instance.&quot;, e);
 65         }
 66 
 67         try {
 68             Field vField = TestReferenceCAS.class.getDeclaredField(&quot;v&quot;);
 69             V_OFFSET = UNSAFE.objectFieldOffset(vField);
 70         } catch (Exception e) {
 71             throw new RuntimeException(e);
 72         }
 73     }
 74 
 75     Object v;
 76 
 77     private static void assertEquals(boolean a, boolean b, String msg) {
 78         if (a != b) {
 79             throw new RuntimeException(&quot;a (&quot; + a + &quot;) != b (&quot; + b + &quot;): &quot; + msg);
 80         }
 81     }
 82 
 83     private static void assertEquals(Object a, Object b, String msg) {
 84         if (!a.equals(b)) {
 85             throw new RuntimeException(&quot;a (&quot; + a.toString() + &quot;) != b (&quot; + b.toString() + &quot;): &quot; + msg);
 86         }
 87     }
 88 
 89     public static void main(String[] args) {
 90         TestReferenceCAS t = new TestReferenceCAS();
 91         for (int c = 0; c &lt; ITERS; c++) {
 92             testAccess(t, V_OFFSET);
 93         }
 94     }
 95 
 96     static void testAccess(Object base, long offset) {
 97         String foo = new String(&quot;foo&quot;);
 98         String bar = new String(&quot;bar&quot;);
 99         String baz = new String(&quot;baz&quot;);
100         UNSAFE.putReference(base, offset, &quot;foo&quot;);
101         {
102             String newval = bar;
103             boolean r = UNSAFE.compareAndSetReference(base, offset, &quot;foo&quot;, newval);
104             assertEquals(r, true, &quot;success compareAndSet Object&quot;);
105             assertEquals(newval, &quot;bar&quot;, &quot;must not destroy newval&quot;);
106             Object x = UNSAFE.getReference(base, offset);
107             assertEquals(x, &quot;bar&quot;, &quot;success compareAndSet Object value&quot;);
108         }
109 
110         {
111             String newval = baz;
112             boolean r = UNSAFE.compareAndSetReference(base, offset, &quot;foo&quot;, newval);
113             assertEquals(r, false, &quot;failing compareAndSet Object&quot;);
114             assertEquals(newval, &quot;baz&quot;, &quot;must not destroy newval&quot;);
115             Object x = UNSAFE.getReference(base, offset);
116             assertEquals(x, &quot;bar&quot;, &quot;failing compareAndSet Object value&quot;);
117         }
118 
119         UNSAFE.putReference(base, offset, &quot;bar&quot;);
120         {
121             String newval = foo;
122             Object r = UNSAFE.compareAndExchangeReference(base, offset, &quot;bar&quot;, newval);
123             assertEquals(r, &quot;bar&quot;, &quot;success compareAndExchange Object&quot;);
124             assertEquals(newval, &quot;foo&quot;, &quot;must not destroy newval&quot;);
125             Object x = UNSAFE.getReference(base, offset);
126             assertEquals(x, &quot;foo&quot;, &quot;success compareAndExchange Object value&quot;);
127         }
128 
129         {
130             String newval = baz;
131             Object r = UNSAFE.compareAndExchangeReference(base, offset, &quot;bar&quot;, newval);
132             assertEquals(r, &quot;foo&quot;, &quot;failing compareAndExchange Object&quot;);
133             assertEquals(newval, &quot;baz&quot;, &quot;must not destroy newval&quot;);
134             Object x = UNSAFE.getReference(base, offset);
135             assertEquals(x, &quot;foo&quot;, &quot;failing compareAndExchange Object value&quot;);
136         }
137 
138         UNSAFE.putReference(base, offset, &quot;bar&quot;);
139         {
140             String newval = foo;
141             boolean success = false;
142             for (int c = 0; c &lt; WEAK_ATTEMPTS &amp;&amp; !success; c++) {
143                 success = UNSAFE.weakCompareAndSetReference(base, offset, &quot;bar&quot;, newval);
144                 assertEquals(newval, &quot;foo&quot;, &quot;must not destroy newval&quot;);
145             }
146             assertEquals(success, true, &quot;weakCompareAndSet Object&quot;);
147             Object x = UNSAFE.getReference(base, offset);
148             assertEquals(x, &quot;foo&quot;, &quot;weakCompareAndSet Object&quot;);
149         }
150     }
151 
152 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/gc/cms/TestBubbleUpRef.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package gc.cms;
 25 
 26 import java.lang.ref.ReferenceQueue;
 27 import java.lang.ref.WeakReference;
 28 import java.util.LinkedList;
 29 import java.util.ListIterator;
 30 
 31 /*
 32  * @test
 33  * @requires vm.gc.ConcMarkSweep &amp; !vm.graal.enabled
 34  * @key cte_test
 35  * @bug 4950157
 36  * @summary Stress the behavior of ergonomics when the heap is nearly full and
 37  *          stays nearly full.
 38  * @run main/othervm
 39  *  -XX:+UseConcMarkSweepGC -XX:-CMSYield -XX:-CMSPrecleanRefLists1
 40  *  -XX:CMSInitiatingOccupancyFraction=0 -Xmx80m gc.cms.TestBubbleUpRef 16000 50 10000
 41  */
 42 
 43 /**
 44  * Test program to stress the behavior of ergonomics when the
 45  * heap is nearly full and stays nearly full.
 46  * This is a test to catch references that have been discovered
 47  * during concurrent marking and whose referents have been
 48  * cleared by the mutator.
 49  * Allocate objects with weak references until the heap is full
 50  * Free the objects.
 51  * Do work so that concurrent marking has a chance to work
 52  * Clear the referents out of the weak references
 53  * System.gc() in the hopes that it will acquire the collection
 54  * Free the weak references
 55  * Do it again.
 56  *
 57  * Use the following VM options
 58  *     -Xmx80m -XX:-CMSYield [-XX:+UseConcMarkSweepGC] -XX:-CMSPrecleanRefLists1
 59  *      -XX:CMSInitiatingOccupancyFraction=0
 60  *
 61  * Use parameter:
 62  *     args[0] - array size  (16000)
 63  *     args[1] - iterations  (50)
 64  *     args[2] - work        (10000)
 65  */
 66 class MyList extends LinkedList {
 67 
 68     int[] a;
 69 
 70     MyList(int size) {
 71         a = new int[size];
 72     }
 73 }
 74 
 75 class MyRefList extends LinkedList {
 76 
 77     WeakReference ref;
 78 
 79     MyRefList(Object o, ReferenceQueue rq) {
 80         ref = new WeakReference(o, rq);
 81     }
 82 
 83     void clearReferent() {
 84         ref.clear();
 85     }
 86 }
 87 
 88 public class TestBubbleUpRef {
 89 
 90     MyList list;
 91     MyRefList refList;
 92     ReferenceQueue rq;
 93     int refListLen;
 94     int arraySize;
 95     int iterations;
 96     int workUnits;
 97 
 98     TestBubbleUpRef(int as, int cnt, int wk) {
 99         arraySize = as;
100         iterations = cnt;
101         workUnits = wk;
102         list = new MyList(arraySize);
103         refList = new MyRefList(list, rq);
104     }
105 
106     public void fill() {
107         System.out.println(&quot;fill() &quot; + iterations + &quot; times&quot;);
108         int count = 0;
109         while (true) {
110             try {
111                 // Allocations
112                 MyList next = new MyList(arraySize);
113                 list.add(next);
114                 MyRefList nextRef = new MyRefList(next, rq);
115                 refList.add(nextRef);
116             } catch (OutOfMemoryError e) {
117                 // When the heap is full
118                 try {
119                     if (count++ &gt; iterations) {
120                         return;
121                     }
122                     System.out.println(&quot;Freeing list&quot;);
123                     while (!list.isEmpty()) {
124                         list.removeFirst();
125                     }
126                     System.out.println(&quot;Doing work&quot;);
127                     int j = 0;
128                     for (int i = 1; i &lt; workUnits; i++) {
129                         j = j + i;
130                     }
131                     System.out.println(&quot;Clearing refs&quot;);
132                     ListIterator listIt = refList.listIterator();
133                     while (listIt.hasNext()) {
134                         MyRefList next = (MyRefList) listIt.next();
135                         next.clearReferent();
136                     }
137                     System.gc();
138                     System.out.println(&quot;Freeing refs&quot;);
139                     while (!refList.isEmpty()) {
140                         refList.removeFirst();
141                     }
142                 } catch (OutOfMemoryError e2) {
143                     System.err.println(&quot;Out of Memory - 2 &quot;);
144                     continue;
145                 }
146             } catch (Exception e) {
147                 System.err.println(&quot;Unexpected exception: &quot; + e);
148                 return;
149             }
150         }
151     }
152 
153     /**
154      * Test entry point.
155      *     args[0] - array size  (is the size of the int array in a list item)
156      *     args[1] - iterations  (is the number of out-of-memory exceptions before exit)
157      *     args[2] - work        (is the work done between allocations)
158      * @param args
159      */
160     public static void main(String[] args) {
161         // Get the input parameters.
162         if (args.length != 3) {
163             throw new IllegalArgumentException(&quot;Wrong number of input argumets&quot;);
164         }
165 
166         int as = Integer.parseInt(args[0]);
167         int cnt = Integer.parseInt(args[1]);
168         int work = Integer.parseInt(args[2]);
169 
170         System.out.println(&quot;&lt;array size&gt; &quot; + as + &quot;\n&quot;
171                 + &quot;&lt;OOM&#39;s&gt; &quot; + cnt + &quot;\n&quot;
172                 + &quot;&lt;work units&gt; &quot; + work + &quot;\n&quot;);
173 
174         // Initialization
175         TestBubbleUpRef b = new TestBubbleUpRef(as, cnt, work);
176 
177         // Run the test
178         try {
179             b.fill();
180         } catch (OutOfMemoryError e) {
181             b = null; // Free memory before trying to print anything
182             System.err.println(&quot;Out of Memory - exiting &quot;);
183         } catch (Exception e) {
184             System.err.println(&quot;Exiting &quot;);
185         }
186     }
187 }
188 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/gc/survivorAlignment/SurvivorAlignmentTestMain.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package gc.survivorAlignment;
 25 
 26 import java.lang.management.ManagementFactory;
 27 import java.lang.management.MemoryPoolMXBean;
 28 import java.util.Objects;
 29 import java.util.Optional;
 30 import java.util.regex.Matcher;
 31 import java.util.regex.Pattern;
 32 
 33 import jdk.test.lib.Asserts;
 34 import com.sun.management.ThreadMXBean;
 35 import sun.hotspot.WhiteBox;
 36 import jdk.internal.misc.Unsafe;
 37 
 38 /**
 39  * Main class for tests on {@code SurvivorAlignmentInBytes} option.
 40  *
 41  * Typical usage is to obtain instance using fromArgs method, allocate objects
 42  * and verify that actual memory usage in tested heap space is close to
 43  * expected.
 44  */
 45 public class SurvivorAlignmentTestMain {
 46     enum HeapSpace {
 47         EDEN,
 48         SURVIVOR,
 49         TENURED
 50     }
 51 
 52     public static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
 53 
 54     public static final long MAX_TENURING_THRESHOLD = Optional.ofNullable(
 55             SurvivorAlignmentTestMain.WHITE_BOX.getIntxVMFlag(
 56                     &quot;MaxTenuringThreshold&quot;)).orElse(15L);
 57 
 58     /**
 59      * Regexp used to parse memory size params, like 2G, 34m or 15k.
 60      */
 61     private static final Pattern SIZE_REGEX
 62             = Pattern.compile(&quot;(?&lt;size&gt;[0-9]+)(?&lt;multiplier&gt;[GMKgmk])?&quot;);
 63 
 64     // Names of different heap spaces.
 65     private static final String DEF_NEW_EDEN = &quot;Eden Space&quot;;
 66     private static final String DEF_NEW_SURVIVOR = &quot;Survivor Space&quot;;
 67     private static final String PAR_NEW_EDEN = &quot;Par Eden Space&quot;;
 68     private static final String PAR_NEW_SURVIVOR = &quot;Par Survivor Space&quot;;
 69     private static final String PS_EDEN = &quot;PS Eden Space&quot;;
 70     private static final String PS_SURVIVOR = &quot;PS Survivor Space&quot;;
 71     private static final String G1_EDEN = &quot;G1 Eden Space&quot;;
 72     private static final String G1_SURVIVOR = &quot;G1 Survivor Space&quot;;
 73     private static final String SERIAL_TENURED = &quot;Tenured Gen&quot;;
 74     private static final String PS_TENURED = &quot;PS Old Gen&quot;;
 75     private static final String G1_TENURED = &quot;G1 Old Gen&quot;;
 76 
 77     private static final long G1_HEAP_REGION_SIZE = Optional.ofNullable(
 78             SurvivorAlignmentTestMain.WHITE_BOX.getUintxVMFlag(
 79                     &quot;G1HeapRegionSize&quot;)).orElse(-1L);
 80 
 81     private static final AlignmentHelper EDEN_SPACE_HELPER;
 82     private static final AlignmentHelper SURVIVOR_SPACE_HELPER;
 83     private static final AlignmentHelper TENURED_SPACE_HELPER;
 84     /**
 85      * Amount of memory that should be filled during a test run.
 86      */
 87     private final long memoryToFill;
 88     /**
 89      * The size of an objects that will be allocated during a test run.
 90      */
 91     private final long objectSize;
 92     /**
 93      * Amount of memory that will be actually occupied by an object in eden
 94      * space.
 95      */
 96     private final long actualObjectSize;
 97     /**
 98      * Storage for allocated objects.
 99      */
100     private final Object[] garbage;
101     /**
102      * Heap space whose memory usage is a subject of assertions during the test
103      * run.
104      */
105     private final HeapSpace testedSpace;
106 
107     private long[] baselinedThreadMemoryUsage = null;
108     private long[] threadIds = null;
109 
110     /**
111      * Initialize {@code EDEN_SPACE_HELPER}, {@code SURVIVOR_SPACE_HELPER} and
112      * {@code TENURED_SPACE_HELPER} to represent heap spaces in use.
113      *
114      * Note that regardless to GC object&#39;s alignment in survivor space is
115      * expected to be equal to {@code SurvivorAlignmentInBytes} value and
116      * alignment in other spaces is expected to be equal to
117      * {@code ObjectAlignmentInBytes} value.
118      *
119      * For G1 GC MXBeans could report memory usage only with region size
120      * precision (if an object allocated in some G1 heap region, then all region
121      * will claimed as used), so for G1&#39;s spaces precision is equal to
122      * {@code G1HeapRegionSize} value.
123      */
124     static {
125         AlignmentHelper edenHelper = null;
126         AlignmentHelper survivorHelper = null;
127         AlignmentHelper tenuredHelper = null;
128         for (MemoryPoolMXBean pool : ManagementFactory.getMemoryPoolMXBeans()) {
129             switch (pool.getName()) {
130                 case SurvivorAlignmentTestMain.DEF_NEW_EDEN:
131                 case SurvivorAlignmentTestMain.PAR_NEW_EDEN:
132                 case SurvivorAlignmentTestMain.PS_EDEN:
133                     Asserts.assertNull(edenHelper,
134                             &quot;Only one bean for eden space is expected.&quot;);
135                     edenHelper = new AlignmentHelper(
136                             AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,
137                             AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,
138                             AlignmentHelper.MIN_OBJECT_SIZE, pool);
139                     break;
140                 case SurvivorAlignmentTestMain.G1_EDEN:
141                     Asserts.assertNull(edenHelper,
142                             &quot;Only one bean for eden space is expected.&quot;);
143                     edenHelper = new AlignmentHelper(
144                             SurvivorAlignmentTestMain.G1_HEAP_REGION_SIZE,
145                             AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,
146                             AlignmentHelper.MIN_OBJECT_SIZE, pool);
147                     break;
148                 case SurvivorAlignmentTestMain.DEF_NEW_SURVIVOR:
149                 case SurvivorAlignmentTestMain.PAR_NEW_SURVIVOR:
150                 case SurvivorAlignmentTestMain.PS_SURVIVOR:
151                     Asserts.assertNull(survivorHelper,
152                             &quot;Only one bean for survivor space is expected.&quot;);
153                     survivorHelper = new AlignmentHelper(
154                             AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,
155                             AlignmentHelper.SURVIVOR_ALIGNMENT_IN_BYTES,
156                             AlignmentHelper.MIN_OBJECT_SIZE, pool);
157                     break;
158                 case SurvivorAlignmentTestMain.G1_SURVIVOR:
159                     Asserts.assertNull(survivorHelper,
160                             &quot;Only one bean for survivor space is expected.&quot;);
161                     survivorHelper = new AlignmentHelper(
162                             SurvivorAlignmentTestMain.G1_HEAP_REGION_SIZE,
163                             AlignmentHelper.SURVIVOR_ALIGNMENT_IN_BYTES,
164                             AlignmentHelper.MIN_OBJECT_SIZE, pool);
165                     break;
166                 case SurvivorAlignmentTestMain.SERIAL_TENURED:
167                 case SurvivorAlignmentTestMain.PS_TENURED:
168                 case SurvivorAlignmentTestMain.G1_TENURED:
169                     Asserts.assertNull(tenuredHelper,
170                             &quot;Only one bean for tenured space is expected.&quot;);
171                     tenuredHelper = new AlignmentHelper(
172                             AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,
173                             AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,
174                             AlignmentHelper.MIN_OBJECT_SIZE, pool);
175                     break;
176             }
177         }
178         EDEN_SPACE_HELPER = Objects.requireNonNull(edenHelper,
179                 &quot;AlignmentHelper for eden space should be initialized.&quot;);
180         SURVIVOR_SPACE_HELPER = Objects.requireNonNull(survivorHelper,
181                 &quot;AlignmentHelper for survivor space should be initialized.&quot;);
182         TENURED_SPACE_HELPER = Objects.requireNonNull(tenuredHelper,
183                 &quot;AlignmentHelper for tenured space should be initialized.&quot;);
184     }
185     /**
186      * Returns an SurvivorAlignmentTestMain instance constructed using CLI
187      * options.
188      *
189      * Following options are expected:
190      * &lt;ul&gt;
191      *     &lt;li&gt;memoryToFill&lt;/li&gt;
192      *     &lt;li&gt;objectSize&lt;/li&gt;
193      * &lt;/ul&gt;
194      *
195      * Both argument may contain multiplier suffix k, m or g.
196      */
197     public static SurvivorAlignmentTestMain fromArgs(String[] args) {
198         Asserts.assertEQ(args.length, 3, &quot;Expected three arguments: &quot;
199                 + &quot;memory size, object size and tested heap space name.&quot;);
200 
201         long memoryToFill = parseSize(args[0]);
202         long objectSize = Math.max(parseSize(args[1]),
203                 AlignmentHelper.MIN_ARRAY_SIZE);
204         HeapSpace testedSpace = HeapSpace.valueOf(args[2]);
205 
206         return new SurvivorAlignmentTestMain(memoryToFill, objectSize,
207                 testedSpace);
208     }
209 
210     /**
211      * Returns a value parsed from a string with format
212      * &amp;lt;integer&amp;gt;&amp;lt;multiplier&amp;gt;.
213      */
214     private static long parseSize(String sizeString) {
215         Matcher matcher = SIZE_REGEX.matcher(sizeString);
216         Asserts.assertTrue(matcher.matches(),
217                 &quot;sizeString should have following format \&quot;[0-9]+([MBK])?\&quot;&quot;);
218         long size = Long.valueOf(matcher.group(&quot;size&quot;));
219 
220         if (matcher.group(&quot;multiplier&quot;) != null) {
221             long K = 1024L;
222             // fall through multipliers
223             switch (matcher.group(&quot;multiplier&quot;).toLowerCase()) {
224                 case &quot;g&quot;:
225                     size *= K;
226                 case &quot;m&quot;:
227                     size *= K;
228                 case &quot;k&quot;:
229                     size *= K;
230             }
231         }
232         return size;
233     }
234 
235     private SurvivorAlignmentTestMain(long memoryToFill, long objectSize,
236             HeapSpace testedSpace) {
237         this.objectSize = objectSize;
238         this.memoryToFill = memoryToFill;
239         this.testedSpace = testedSpace;
240 
241         AlignmentHelper helper = SurvivorAlignmentTestMain.EDEN_SPACE_HELPER;
242 
243         this.actualObjectSize = helper.getObjectSizeInThisSpace(
244                 this.objectSize);
245         int arrayLength = helper.getObjectsCount(memoryToFill, this.objectSize);
246         garbage = new Object[arrayLength];
247     }
248 
249     /**
250      * Allocate byte arrays to fill {@code memoryToFill} memory.
251      */
252     public void allocate() {
253         int byteArrayLength = Math.max((int) (objectSize
254                 - Unsafe.ARRAY_BYTE_BASE_OFFSET), 0);
255 
256         for (int i = 0; i &lt; garbage.length; i++) {
257             garbage[i] = new byte[byteArrayLength];
258         }
259     }
260 
261     /**
262      * Release memory occupied after {@code allocate} call.
263      */
264     public void release() {
265         for (int i = 0; i &lt; garbage.length; i++) {
266             garbage[i] = null;
267         }
268     }
269 
270     /**
271      * Returns expected amount of memory occupied in a {@code heapSpace} by
272      * objects referenced from {@code garbage} array.
273      */
274     public long getExpectedMemoryUsage() {
275         AlignmentHelper alignmentHelper = getAlignmentHelper(testedSpace);
276         return alignmentHelper.getExpectedMemoryUsage(objectSize,
277                 garbage.length);
278     }
279 
280     /**
281      * Verifies that memory usage in a {@code heapSpace} deviates from
282      * {@code expectedUsage} for no more than {@code MAX_RELATIVE_DEVIATION}.
283      */
284     public void verifyMemoryUsage(long expectedUsage) {
285         AlignmentHelper alignmentHelper = getAlignmentHelper(testedSpace);
286 
287         long actualMemoryUsage = alignmentHelper.getActualMemoryUsage();
288         boolean otherThreadsAllocatedMemory = areOtherThreadsAllocatedMemory();
289 
290         long memoryUsageDiff = Math.abs(actualMemoryUsage - expectedUsage);
291         long maxAllowedUsageDiff
292                 = alignmentHelper.getAllowedMemoryUsageDeviation(expectedUsage);
293 
294         System.out.println(&quot;Verifying memory usage in space: &quot; + testedSpace);
295         System.out.println(&quot;Allocated objects count: &quot; + garbage.length);
296         System.out.println(&quot;Desired object size: &quot; + objectSize);
297         System.out.println(&quot;Actual object size: &quot; + actualObjectSize);
298         System.out.println(&quot;Expected object size in space: &quot;
299                 + alignmentHelper.getObjectSizeInThisSpace(objectSize));
300         System.out.println(&quot;Expected memory usage: &quot; + expectedUsage);
301         System.out.println(&quot;Actual memory usage: &quot; + actualMemoryUsage);
302         System.out.println(&quot;Memory usage diff: &quot; + memoryUsageDiff);
303         System.out.println(&quot;Max allowed usage diff: &quot; + maxAllowedUsageDiff);
304 
305         if (memoryUsageDiff &gt; maxAllowedUsageDiff
306                 &amp;&amp; otherThreadsAllocatedMemory) {
307             System.out.println(&quot;Memory usage diff is incorrect, but it seems &quot;
308                     + &quot;like someone else allocated objects&quot;);
309             return;
310         }
311 
312         Asserts.assertLTE(memoryUsageDiff, maxAllowedUsageDiff,
313                 &quot;Actual memory usage should not deviate from expected for &quot; +
314                         &quot;more then &quot; + maxAllowedUsageDiff);
315     }
316 
317     /**
318      * Baselines amount of memory allocated by each thread.
319      */
320     public void baselineMemoryAllocation() {
321         ThreadMXBean bean = (ThreadMXBean) ManagementFactory.getThreadMXBean();
322         threadIds = bean.getAllThreadIds();
323         baselinedThreadMemoryUsage = bean.getThreadAllocatedBytes(threadIds);
324     }
325 
326     /**
327      * Checks if threads other then the current thread were allocating objects
328      * after baselinedThreadMemoryUsage call.
329      *
330      * If baselinedThreadMemoryUsage was not called, then this method will return
331      * {@code false}.
332      */
333     public boolean areOtherThreadsAllocatedMemory() {
334         if (baselinedThreadMemoryUsage == null) {
335             return false;
336         }
337 
338         ThreadMXBean bean = (ThreadMXBean) ManagementFactory.getThreadMXBean();
339         long currentMemoryAllocation[]
340                 = bean.getThreadAllocatedBytes(threadIds);
341         boolean otherThreadsAllocatedMemory = false;
342 
343         System.out.println(&quot;Verifying amount of memory allocated by threads:&quot;);
344         for (int i = 0; i &lt; threadIds.length; i++) {
345             System.out.format(&quot;Thread %d%nbaseline allocation: %d&quot;
346                             + &quot;%ncurrent allocation:%d%n&quot;, threadIds[i],
347                     baselinedThreadMemoryUsage[i], currentMemoryAllocation[i]);
348             System.out.println(bean.getThreadInfo(threadIds[i]));
349 
350             long bytesAllocated = Math.abs(currentMemoryAllocation[i]
351                     - baselinedThreadMemoryUsage[i]);
352             if (bytesAllocated &gt; 0
353                     &amp;&amp; threadIds[i] != Thread.currentThread().getId()) {
354                 otherThreadsAllocatedMemory = true;
355             }
356         }
357 
358         return otherThreadsAllocatedMemory;
359     }
360 
361     @Override
362     public String toString() {
363         StringBuilder builder = new StringBuilder();
364 
365         builder.append(String.format(&quot;SurvivorAlignmentTestMain info:%n&quot;));
366         builder.append(String.format(&quot;Desired object size: %d%n&quot;, objectSize));
367         builder.append(String.format(&quot;Memory to fill: %d%n&quot;, memoryToFill));
368         builder.append(String.format(&quot;Objects to be allocated: %d%n&quot;,
369                 garbage.length));
370 
371         builder.append(String.format(&quot;Alignment helpers to be used: %n&quot;));
372         for (HeapSpace heapSpace: HeapSpace.values()) {
373             builder.append(String.format(&quot;For space %s:%n%s%n&quot;, heapSpace,
374                     getAlignmentHelper(heapSpace)));
375         }
376 
377         return builder.toString();
378     }
379 
380     /**
381      * Returns {@code AlignmentHelper} for a space {@code heapSpace}.
382      */
383     public static AlignmentHelper getAlignmentHelper(HeapSpace heapSpace) {
384         switch (heapSpace) {
385             case EDEN:
386                 return SurvivorAlignmentTestMain.EDEN_SPACE_HELPER;
387             case SURVIVOR:
388                 return SurvivorAlignmentTestMain.SURVIVOR_SPACE_HELPER;
389             case TENURED:
390                 return SurvivorAlignmentTestMain.TENURED_SPACE_HELPER;
391             default:
392                 throw new Error(&quot;Unexpected heap space: &quot; + heapSpace);
393         }
394     }
395 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/gc/survivorAlignment/SurvivorAlignmentTestMain.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package gc.survivorAlignment;
 25 
 26 import java.lang.management.ManagementFactory;
 27 import java.lang.management.MemoryPoolMXBean;
 28 import java.util.Objects;
 29 import java.util.Optional;
 30 import java.util.regex.Matcher;
 31 import java.util.regex.Pattern;
 32 
 33 import jdk.test.lib.Asserts;
 34 import com.sun.management.ThreadMXBean;
 35 import sun.hotspot.WhiteBox;
 36 import jdk.internal.misc.Unsafe;
 37 
 38 /**
 39  * Main class for tests on {@code SurvivorAlignmentInBytes} option.
 40  *
 41  * Typical usage is to obtain instance using fromArgs method, allocate objects
 42  * and verify that actual memory usage in tested heap space is close to
 43  * expected.
 44  */
 45 public class SurvivorAlignmentTestMain {
 46     enum HeapSpace {
 47         EDEN,
 48         SURVIVOR,
 49         TENURED
 50     }
 51 
 52     public static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
 53 
 54     public static final long MAX_TENURING_THRESHOLD = Optional.ofNullable(
 55             SurvivorAlignmentTestMain.WHITE_BOX.getIntxVMFlag(
 56                     &quot;MaxTenuringThreshold&quot;)).orElse(15L);
 57 
 58     /**
 59      * Regexp used to parse memory size params, like 2G, 34m or 15k.
 60      */
 61     private static final Pattern SIZE_REGEX
 62             = Pattern.compile(&quot;(?&lt;size&gt;[0-9]+)(?&lt;multiplier&gt;[GMKgmk])?&quot;);
 63 
 64     // Names of different heap spaces.
 65     private static final String DEF_NEW_EDEN = &quot;Eden Space&quot;;
 66     private static final String DEF_NEW_SURVIVOR = &quot;Survivor Space&quot;;
 67     private static final String PAR_NEW_EDEN = &quot;Par Eden Space&quot;;
 68     private static final String PAR_NEW_SURVIVOR = &quot;Par Survivor Space&quot;;
 69     private static final String PS_EDEN = &quot;PS Eden Space&quot;;
 70     private static final String PS_SURVIVOR = &quot;PS Survivor Space&quot;;
 71     private static final String G1_EDEN = &quot;G1 Eden Space&quot;;
 72     private static final String G1_SURVIVOR = &quot;G1 Survivor Space&quot;;
 73     private static final String SERIAL_TENURED = &quot;Tenured Gen&quot;;
<a name="1" id="anc1"></a><span class="line-removed"> 74     private static final String CMS_TENURED = &quot;CMS Old Gen&quot;;</span>
 75     private static final String PS_TENURED = &quot;PS Old Gen&quot;;
 76     private static final String G1_TENURED = &quot;G1 Old Gen&quot;;
 77 
 78     private static final long G1_HEAP_REGION_SIZE = Optional.ofNullable(
 79             SurvivorAlignmentTestMain.WHITE_BOX.getUintxVMFlag(
 80                     &quot;G1HeapRegionSize&quot;)).orElse(-1L);
 81 
<a name="2" id="anc2"></a><span class="line-removed"> 82     /**</span>
<span class="line-removed"> 83      * Min size of free chunk in CMS generation.</span>
<span class="line-removed"> 84      * An object allocated in CMS generation will at least occupy this amount</span>
<span class="line-removed"> 85      * of bytes.</span>
<span class="line-removed"> 86      */</span>
<span class="line-removed"> 87     private static final long CMS_MIN_FREE_CHUNK_SIZE</span>
<span class="line-removed"> 88             = 3L * Unsafe.ADDRESS_SIZE;</span>
<span class="line-removed"> 89 </span>
 90     private static final AlignmentHelper EDEN_SPACE_HELPER;
 91     private static final AlignmentHelper SURVIVOR_SPACE_HELPER;
 92     private static final AlignmentHelper TENURED_SPACE_HELPER;
 93     /**
 94      * Amount of memory that should be filled during a test run.
 95      */
 96     private final long memoryToFill;
 97     /**
 98      * The size of an objects that will be allocated during a test run.
 99      */
100     private final long objectSize;
101     /**
102      * Amount of memory that will be actually occupied by an object in eden
103      * space.
104      */
105     private final long actualObjectSize;
106     /**
107      * Storage for allocated objects.
108      */
109     private final Object[] garbage;
110     /**
111      * Heap space whose memory usage is a subject of assertions during the test
112      * run.
113      */
114     private final HeapSpace testedSpace;
115 
116     private long[] baselinedThreadMemoryUsage = null;
117     private long[] threadIds = null;
118 
119     /**
120      * Initialize {@code EDEN_SPACE_HELPER}, {@code SURVIVOR_SPACE_HELPER} and
121      * {@code TENURED_SPACE_HELPER} to represent heap spaces in use.
122      *
123      * Note that regardless to GC object&#39;s alignment in survivor space is
124      * expected to be equal to {@code SurvivorAlignmentInBytes} value and
125      * alignment in other spaces is expected to be equal to
126      * {@code ObjectAlignmentInBytes} value.
127      *
<a name="3" id="anc3"></a><span class="line-removed">128      * In CMS generation we can&#39;t allocate less then {@code MinFreeChunk} value,</span>
<span class="line-removed">129      * for other CGs we expect that object of size {@code MIN_OBJECT_SIZE}</span>
<span class="line-removed">130      * could be allocated as it is (of course, its size could be aligned</span>
<span class="line-removed">131      * according to alignment value used in a particular space).</span>
<span class="line-removed">132      *</span>
133      * For G1 GC MXBeans could report memory usage only with region size
134      * precision (if an object allocated in some G1 heap region, then all region
135      * will claimed as used), so for G1&#39;s spaces precision is equal to
136      * {@code G1HeapRegionSize} value.
137      */
138     static {
139         AlignmentHelper edenHelper = null;
140         AlignmentHelper survivorHelper = null;
141         AlignmentHelper tenuredHelper = null;
142         for (MemoryPoolMXBean pool : ManagementFactory.getMemoryPoolMXBeans()) {
143             switch (pool.getName()) {
144                 case SurvivorAlignmentTestMain.DEF_NEW_EDEN:
145                 case SurvivorAlignmentTestMain.PAR_NEW_EDEN:
146                 case SurvivorAlignmentTestMain.PS_EDEN:
147                     Asserts.assertNull(edenHelper,
148                             &quot;Only one bean for eden space is expected.&quot;);
149                     edenHelper = new AlignmentHelper(
150                             AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,
151                             AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,
152                             AlignmentHelper.MIN_OBJECT_SIZE, pool);
153                     break;
154                 case SurvivorAlignmentTestMain.G1_EDEN:
155                     Asserts.assertNull(edenHelper,
156                             &quot;Only one bean for eden space is expected.&quot;);
157                     edenHelper = new AlignmentHelper(
158                             SurvivorAlignmentTestMain.G1_HEAP_REGION_SIZE,
159                             AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,
160                             AlignmentHelper.MIN_OBJECT_SIZE, pool);
161                     break;
162                 case SurvivorAlignmentTestMain.DEF_NEW_SURVIVOR:
163                 case SurvivorAlignmentTestMain.PAR_NEW_SURVIVOR:
164                 case SurvivorAlignmentTestMain.PS_SURVIVOR:
165                     Asserts.assertNull(survivorHelper,
166                             &quot;Only one bean for survivor space is expected.&quot;);
167                     survivorHelper = new AlignmentHelper(
168                             AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,
169                             AlignmentHelper.SURVIVOR_ALIGNMENT_IN_BYTES,
170                             AlignmentHelper.MIN_OBJECT_SIZE, pool);
171                     break;
172                 case SurvivorAlignmentTestMain.G1_SURVIVOR:
173                     Asserts.assertNull(survivorHelper,
174                             &quot;Only one bean for survivor space is expected.&quot;);
175                     survivorHelper = new AlignmentHelper(
176                             SurvivorAlignmentTestMain.G1_HEAP_REGION_SIZE,
177                             AlignmentHelper.SURVIVOR_ALIGNMENT_IN_BYTES,
178                             AlignmentHelper.MIN_OBJECT_SIZE, pool);
179                     break;
180                 case SurvivorAlignmentTestMain.SERIAL_TENURED:
181                 case SurvivorAlignmentTestMain.PS_TENURED:
182                 case SurvivorAlignmentTestMain.G1_TENURED:
183                     Asserts.assertNull(tenuredHelper,
184                             &quot;Only one bean for tenured space is expected.&quot;);
185                     tenuredHelper = new AlignmentHelper(
186                             AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,
187                             AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,
188                             AlignmentHelper.MIN_OBJECT_SIZE, pool);
189                     break;
<a name="4" id="anc4"></a><span class="line-removed">190                 case SurvivorAlignmentTestMain.CMS_TENURED:</span>
<span class="line-removed">191                     Asserts.assertNull(tenuredHelper,</span>
<span class="line-removed">192                             &quot;Only one bean for tenured space is expected.&quot;);</span>
<span class="line-removed">193                     tenuredHelper = new AlignmentHelper(</span>
<span class="line-removed">194                             AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,</span>
<span class="line-removed">195                             AlignmentHelper.OBJECT_ALIGNMENT_IN_BYTES,</span>
<span class="line-removed">196                             SurvivorAlignmentTestMain.CMS_MIN_FREE_CHUNK_SIZE,</span>
<span class="line-removed">197                             pool);</span>
<span class="line-removed">198                     break;</span>
199             }
200         }
201         EDEN_SPACE_HELPER = Objects.requireNonNull(edenHelper,
202                 &quot;AlignmentHelper for eden space should be initialized.&quot;);
203         SURVIVOR_SPACE_HELPER = Objects.requireNonNull(survivorHelper,
204                 &quot;AlignmentHelper for survivor space should be initialized.&quot;);
205         TENURED_SPACE_HELPER = Objects.requireNonNull(tenuredHelper,
206                 &quot;AlignmentHelper for tenured space should be initialized.&quot;);
207     }
208     /**
209      * Returns an SurvivorAlignmentTestMain instance constructed using CLI
210      * options.
211      *
212      * Following options are expected:
213      * &lt;ul&gt;
214      *     &lt;li&gt;memoryToFill&lt;/li&gt;
215      *     &lt;li&gt;objectSize&lt;/li&gt;
216      * &lt;/ul&gt;
217      *
218      * Both argument may contain multiplier suffix k, m or g.
219      */
220     public static SurvivorAlignmentTestMain fromArgs(String[] args) {
221         Asserts.assertEQ(args.length, 3, &quot;Expected three arguments: &quot;
222                 + &quot;memory size, object size and tested heap space name.&quot;);
223 
224         long memoryToFill = parseSize(args[0]);
225         long objectSize = Math.max(parseSize(args[1]),
226                 AlignmentHelper.MIN_ARRAY_SIZE);
227         HeapSpace testedSpace = HeapSpace.valueOf(args[2]);
228 
229         return new SurvivorAlignmentTestMain(memoryToFill, objectSize,
230                 testedSpace);
231     }
232 
233     /**
234      * Returns a value parsed from a string with format
235      * &amp;lt;integer&amp;gt;&amp;lt;multiplier&amp;gt;.
236      */
237     private static long parseSize(String sizeString) {
238         Matcher matcher = SIZE_REGEX.matcher(sizeString);
239         Asserts.assertTrue(matcher.matches(),
240                 &quot;sizeString should have following format \&quot;[0-9]+([MBK])?\&quot;&quot;);
241         long size = Long.valueOf(matcher.group(&quot;size&quot;));
242 
243         if (matcher.group(&quot;multiplier&quot;) != null) {
244             long K = 1024L;
245             // fall through multipliers
246             switch (matcher.group(&quot;multiplier&quot;).toLowerCase()) {
247                 case &quot;g&quot;:
248                     size *= K;
249                 case &quot;m&quot;:
250                     size *= K;
251                 case &quot;k&quot;:
252                     size *= K;
253             }
254         }
255         return size;
256     }
257 
258     private SurvivorAlignmentTestMain(long memoryToFill, long objectSize,
259             HeapSpace testedSpace) {
260         this.objectSize = objectSize;
261         this.memoryToFill = memoryToFill;
262         this.testedSpace = testedSpace;
263 
264         AlignmentHelper helper = SurvivorAlignmentTestMain.EDEN_SPACE_HELPER;
265 
266         this.actualObjectSize = helper.getObjectSizeInThisSpace(
267                 this.objectSize);
268         int arrayLength = helper.getObjectsCount(memoryToFill, this.objectSize);
269         garbage = new Object[arrayLength];
270     }
271 
272     /**
273      * Allocate byte arrays to fill {@code memoryToFill} memory.
274      */
275     public void allocate() {
276         int byteArrayLength = Math.max((int) (objectSize
277                 - Unsafe.ARRAY_BYTE_BASE_OFFSET), 0);
278 
279         for (int i = 0; i &lt; garbage.length; i++) {
280             garbage[i] = new byte[byteArrayLength];
281         }
282     }
283 
284     /**
285      * Release memory occupied after {@code allocate} call.
286      */
287     public void release() {
288         for (int i = 0; i &lt; garbage.length; i++) {
289             garbage[i] = null;
290         }
291     }
292 
293     /**
294      * Returns expected amount of memory occupied in a {@code heapSpace} by
295      * objects referenced from {@code garbage} array.
296      */
297     public long getExpectedMemoryUsage() {
298         AlignmentHelper alignmentHelper = getAlignmentHelper(testedSpace);
299         return alignmentHelper.getExpectedMemoryUsage(objectSize,
300                 garbage.length);
301     }
302 
303     /**
304      * Verifies that memory usage in a {@code heapSpace} deviates from
305      * {@code expectedUsage} for no more than {@code MAX_RELATIVE_DEVIATION}.
306      */
307     public void verifyMemoryUsage(long expectedUsage) {
308         AlignmentHelper alignmentHelper = getAlignmentHelper(testedSpace);
309 
310         long actualMemoryUsage = alignmentHelper.getActualMemoryUsage();
311         boolean otherThreadsAllocatedMemory = areOtherThreadsAllocatedMemory();
312 
313         long memoryUsageDiff = Math.abs(actualMemoryUsage - expectedUsage);
314         long maxAllowedUsageDiff
315                 = alignmentHelper.getAllowedMemoryUsageDeviation(expectedUsage);
316 
317         System.out.println(&quot;Verifying memory usage in space: &quot; + testedSpace);
318         System.out.println(&quot;Allocated objects count: &quot; + garbage.length);
319         System.out.println(&quot;Desired object size: &quot; + objectSize);
320         System.out.println(&quot;Actual object size: &quot; + actualObjectSize);
321         System.out.println(&quot;Expected object size in space: &quot;
322                 + alignmentHelper.getObjectSizeInThisSpace(objectSize));
323         System.out.println(&quot;Expected memory usage: &quot; + expectedUsage);
324         System.out.println(&quot;Actual memory usage: &quot; + actualMemoryUsage);
325         System.out.println(&quot;Memory usage diff: &quot; + memoryUsageDiff);
326         System.out.println(&quot;Max allowed usage diff: &quot; + maxAllowedUsageDiff);
327 
328         if (memoryUsageDiff &gt; maxAllowedUsageDiff
329                 &amp;&amp; otherThreadsAllocatedMemory) {
330             System.out.println(&quot;Memory usage diff is incorrect, but it seems &quot;
331                     + &quot;like someone else allocated objects&quot;);
332             return;
333         }
334 
335         Asserts.assertLTE(memoryUsageDiff, maxAllowedUsageDiff,
336                 &quot;Actual memory usage should not deviate from expected for &quot; +
337                         &quot;more then &quot; + maxAllowedUsageDiff);
338     }
339 
340     /**
341      * Baselines amount of memory allocated by each thread.
342      */
343     public void baselineMemoryAllocation() {
344         ThreadMXBean bean = (ThreadMXBean) ManagementFactory.getThreadMXBean();
345         threadIds = bean.getAllThreadIds();
346         baselinedThreadMemoryUsage = bean.getThreadAllocatedBytes(threadIds);
347     }
348 
349     /**
350      * Checks if threads other then the current thread were allocating objects
351      * after baselinedThreadMemoryUsage call.
352      *
353      * If baselinedThreadMemoryUsage was not called, then this method will return
354      * {@code false}.
355      */
356     public boolean areOtherThreadsAllocatedMemory() {
357         if (baselinedThreadMemoryUsage == null) {
358             return false;
359         }
360 
361         ThreadMXBean bean = (ThreadMXBean) ManagementFactory.getThreadMXBean();
362         long currentMemoryAllocation[]
363                 = bean.getThreadAllocatedBytes(threadIds);
364         boolean otherThreadsAllocatedMemory = false;
365 
366         System.out.println(&quot;Verifying amount of memory allocated by threads:&quot;);
367         for (int i = 0; i &lt; threadIds.length; i++) {
368             System.out.format(&quot;Thread %d%nbaseline allocation: %d&quot;
369                             + &quot;%ncurrent allocation:%d%n&quot;, threadIds[i],
370                     baselinedThreadMemoryUsage[i], currentMemoryAllocation[i]);
371             System.out.println(bean.getThreadInfo(threadIds[i]));
372 
373             long bytesAllocated = Math.abs(currentMemoryAllocation[i]
374                     - baselinedThreadMemoryUsage[i]);
375             if (bytesAllocated &gt; 0
376                     &amp;&amp; threadIds[i] != Thread.currentThread().getId()) {
377                 otherThreadsAllocatedMemory = true;
378             }
379         }
380 
381         return otherThreadsAllocatedMemory;
382     }
383 
384     @Override
385     public String toString() {
386         StringBuilder builder = new StringBuilder();
387 
388         builder.append(String.format(&quot;SurvivorAlignmentTestMain info:%n&quot;));
389         builder.append(String.format(&quot;Desired object size: %d%n&quot;, objectSize));
390         builder.append(String.format(&quot;Memory to fill: %d%n&quot;, memoryToFill));
391         builder.append(String.format(&quot;Objects to be allocated: %d%n&quot;,
392                 garbage.length));
393 
394         builder.append(String.format(&quot;Alignment helpers to be used: %n&quot;));
395         for (HeapSpace heapSpace: HeapSpace.values()) {
396             builder.append(String.format(&quot;For space %s:%n%s%n&quot;, heapSpace,
397                     getAlignmentHelper(heapSpace)));
398         }
399 
400         return builder.toString();
401     }
402 
403     /**
404      * Returns {@code AlignmentHelper} for a space {@code heapSpace}.
405      */
406     public static AlignmentHelper getAlignmentHelper(HeapSpace heapSpace) {
407         switch (heapSpace) {
408             case EDEN:
409                 return SurvivorAlignmentTestMain.EDEN_SPACE_HELPER;
410             case SURVIVOR:
411                 return SurvivorAlignmentTestMain.SURVIVOR_SPACE_HELPER;
412             case TENURED:
413                 return SurvivorAlignmentTestMain.TENURED_SPACE_HELPER;
414             default:
415                 throw new Error(&quot;Unexpected heap space: &quot; + heapSpace);
416         }
417     }
418 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
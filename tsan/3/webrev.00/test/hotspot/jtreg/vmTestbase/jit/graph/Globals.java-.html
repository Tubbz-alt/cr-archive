<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/jit/graph/Globals.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jit.graph;
 25 import java.io.*;
 26 import java.util.*;
 27 import java.lang.*;
 28 import java.lang.reflect.*;
 29 import nsk.share.TestFailure;
 30 
 31 
 32 public final class Globals
 33 {
 34     // Minimum and Maximum number of threads
 35     public static int     NUM_THREADS      = 1;
 36     public static long    RANDOM_SEED      = System.currentTimeMillis();
 37     public static int     STATIC_LOOP      = 0;
 38     public static int     NUM_TEST_CLASSES = 7;
 39     public static long    RANDOM_LOOP      = 100;
 40     public static boolean VERBOSE          = false;
 41     private static Random indexGenerator   = null;
 42 
 43   //private static TestLoader CGTTestLoader = null;
 44     private static String [] ClassArray = null;
 45     private static Class [] ClassInstanceArray = null;
 46     private static int       maxClassIndex    = 0;
 47 
 48     private static String [] MethodName_Array = null;
 49     private static Method [] MethodInstance_Array = null;
 50 
 51     //Should be prime, so that odds of an incorrect verification reduced
 52     public static  int    [] MethodID_Array   = null;
 53 
 54 
 55     //Number of threads will be reduced as threads finish
 56     public static synchronized void decNumThreads(){NUM_THREADS--;};
 57 
 58     public static synchronized void initialize(String testListPath)
 59     {
 60 
 61         File td = new File (testListPath);
 62         if (!td.exists())
 63             {
 64                 System.err.println(&quot;File &quot; + testListPath + &quot; Not found&quot;);
 65                 System.exit(1);
 66             }
 67         if (!td.isFile())
 68             {
 69                 System.err.println(testListPath + &quot; Must be a File&quot;);
 70                 System.exit(1);
 71             }
 72 
 73         BufferedReader classList = null;
 74 
 75         try
 76           {
 77             classList = new BufferedReader(new FileReader(td));
 78           }
 79         catch (FileNotFoundException  fnfx)
 80           {
 81             System.err.println(&quot;Error finding Classlist&quot;);
 82             System.exit(1);
 83           }
 84 
 85         String line = null;
 86         try
 87             {
 88                 line = classList.readLine();
 89             }
 90         catch (IOException iox)
 91             {
 92                 System.err.println(&quot;Error reading Classlist&quot;);
 93                 System.exit(1);
 94             }
 95 
 96         try
 97             {
 98                 maxClassIndex = Math.abs(Integer.parseInt(line));//ClassArray.length;
 99             }
100         catch (NumberFormatException nfx)
101             {
102                 System.err.println(&quot;Error reading Classlist - first number must be number of methods defined&quot;);
103                 System.exit(1);
104             }
105 
106         ClassArray = new String [maxClassIndex];
107 ClassInstanceArray = new Class [maxClassIndex];
108         MethodName_Array = new String [maxClassIndex];
109         MethodInstance_Array = new Method [maxClassIndex];
110         MethodID_Array = new int [maxClassIndex];
111 
112         int i;
113         for (i = 0; (i&lt;maxClassIndex) &amp;&amp; (line != null); i++)
114             {
115                 try
116                     {
117                         line = classList.readLine();
118                     }
119                 catch (IOException iox)
120                     {
121                         System.err.println(&quot;Error reading ClasslistFile: testListPath&quot;);
122                         System.exit(1);
123                     }
124                 StringTokenizer lineTokens = new StringTokenizer(line, &quot;\t &quot;);
125                 if (lineTokens.countTokens() &lt;3)
126                   {
127                     System.out.println(&quot;Error reading ClasslistFile: Errored line&quot;);
128                     i--;
129                   }
130                 else
131                   {
132                     ClassArray[i] = lineTokens.nextToken();
133                     MethodName_Array[i] =lineTokens.nextToken();
134                     MethodID_Array[i] = Integer.parseInt(lineTokens.nextToken());
135                   }
136             }
137         maxClassIndex = i;
138 
139         indexGenerator = new Random(RANDOM_SEED);
140         if ((NUM_TEST_CLASSES &lt; ClassArray.length) &amp;&amp; (NUM_TEST_CLASSES &gt; 0))
141           maxClassIndex = NUM_TEST_CLASSES;
142         else
143           NUM_TEST_CLASSES = maxClassIndex;
144     }
145 
146     //does a binary serach to find the index for the ID of a method
147     private static int ID_BinSearch(int begin, int end, int ID)
148     {
149         if (end &lt; begin)
150             return(-1);
151 
152         int mid = (begin + end)/2;
153         int midvalue = MethodID_Array[mid];
154 
155         if (ID == midvalue)
156             return (mid);
157         else if (ID &lt; midvalue)
158             return(ID_BinSearch(begin, mid-1, ID));
159         else
160             return(ID_BinSearch(mid+1, end, ID));
161     }
162 
163 
164     //based off a static index, this function selects the method to be called
165     public static MethodData returnNextStaticMethod(int Method_ID)
166     {
167       //int i = ID_BinSearch(0, MethodID_Array.length - 1, Method_ID);
168       int i = ID_BinSearch(0, maxClassIndex - 1, Method_ID);
169 
170       return(nextStaticMethod((i==-1)?0:i));
171     }
172 
173     //this function randomly selects the next method to be called by the test class
174     public static MethodData nextRandomMethod()
175     {
176 
177         int i = indexGenerator.nextInt(maxClassIndex);
178         return(nextStaticMethod(i));
179     }
180 
181     private static MethodData nextStaticMethod(int i)
182     {
183         Class methodsClass = null;
184         Method nextMethod = null;
185 
186         try
187             {
188               //methodsClass = CGTTestLoader.findClass(ClassArray[i]);
189               methodsClass = ClassInstanceArray[i];
190               if (methodsClass == null)
191               {
192                   methodsClass = Class.forName(ClassArray[i]);
193                   ClassInstanceArray[i] = methodsClass;
194               }
195               nextMethod = MethodInstance_Array[i];
196               if (nextMethod == null )
197               {
198               nextMethod =
199                 methodsClass.getMethod(MethodName_Array[i],
200                                        new Class[]{java.util.Vector.class, java.util.Vector.class,
201                                                      java.lang.Long.class, java.lang.Integer.class});
202               //sum vector, ID vector, function depth, static function call depth
203               MethodInstance_Array[i] = nextMethod;
204               }
205             }
206         catch (ClassNotFoundException cnfx)
207             {
208                 System.out.println(&quot;Class: &quot; +ClassArray[i]+ &quot; Not Found&quot;);
209                 System.exit(-1);
210             }
211         catch (NoSuchMethodException nsmx)
212             {
213                 System.out.println(&quot;Class: &quot; +ClassArray[i]);
214                 System.out.println(&quot;Method: &quot; +MethodName_Array[i]+&quot; Not Found&quot;);
215                 System.exit(-1);
216             }
217         catch (SecurityException sx)
218             {
219                 System.out.println(&quot;Class: &quot; +ClassArray[i]);
220                 System.out.println(&quot;Method: &quot; +MethodName_Array[i]);
221                 System.out.println(&quot;Security Exception Generated, by above method call&quot;);
222                 System.exit(-1);
223             }
224         return(new MethodData(ClassArray[i], MethodName_Array[i], methodsClass, nextMethod, MethodID_Array[i]));
225     }
226 
227 
228     /*These two functions are used to verify that all function were called in the proper order*/
229 
230     //called by &quot;parent&quot; function to add childs ID to vector
231     public static void addFunctionIDToVector(int FunctionIndex, Vector IDVector)
232     {
233         IDVector.addElement(new Integer(FunctionIndex));
234     }
235 
236     //called by &quot;child&quot; to add Function Index to Vector
237     public static void appendSumToSumationVector(int FunctionIndex, Vector SummationVector)
238     {
239         if (SummationVector.isEmpty())
240             SummationVector.addElement(new Long(FunctionIndex));
241         else
242             SummationVector.addElement(new Long(((Long)SummationVector.lastElement()).longValue() + FunctionIndex));
243     }
244 
245     //This function calls a method based off of MethodData
246     public static void callMethod(MethodData methodCallStr,
247                                   Vector summation, Vector ID,
248                                   Long numFcalls, Integer staticFcalls)
249                                   throws InvocationTargetException
250 
251     {
252                 if(NUM_THREADS &gt;1)
253                     {
254                         if ((staticFcalls.intValue() + numFcalls.longValue()) %23 == 0)
255                             {
256                                 try
257                                     {
258                                         Thread.sleep(225);
259                                     }
260                                 catch (InterruptedException ie)
261                                     {}
262                                 if (VERBOSE)
263                                     System.out.println(&quot;\t\tCurrentThread:&quot; + Thread.currentThread().getName());
264                             }
265                     }
266 
267                 try
268             {
269                         methodCallStr.nextMethod.invoke(methodCallStr.instance,
270                                 new Object []{summation, ID, numFcalls, staticFcalls});
271             }
272                 catch (IllegalAccessException iax)  //should never happen with a valid testfile
273             {
274                         throw new TestFailure(&quot;Illegal Access Exception&quot;);
275             }
276                     /*
277                 catch (InvocationTargetException itx)
278                     {
279                         itx.printStackTrace();
280                         System.out.println(&quot;Invocation Target Exception&quot;);
281                         System.exit(1);
282                     }*/
283     }
284 }
    </pre>
  </body>
</html>
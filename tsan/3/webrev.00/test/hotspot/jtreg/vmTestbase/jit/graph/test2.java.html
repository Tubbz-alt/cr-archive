<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/jit/graph/test2.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jit.graph;
 25 
 26 import nsk.share.TestFailure;
 27 
 28 import java.lang.reflect.InvocationTargetException;
 29 import java.util.Vector;
 30 
 31 class test2 {
 32     private final int[] MethodID = {Globals.MethodID_Array[1], Globals.MethodID_Array[2]};
 33 
 34     public void CallCallMe(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)
 35             throws InvocationTargetException {
 36         Globals.appendSumToSummationVector(MethodID[1], summation);
 37 
 38         if (CGT.shouldFinish()) {
 39             return;
 40         }
 41 
 42         if (Globals.VERBOSE) {
 43             System.out.println(&quot;test2.CallCallMe&quot;);
 44         }
 45 
 46         if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;= 0)) {
 47             return;
 48         }
 49 
 50         MethodData methodCallStr;
 51         Long numFcalls;
 52         Integer staticFcalls;
 53         if (staticFunctionDepth.intValue() &gt; 0) {
 54             numFcalls = functionDepth;
 55             staticFcalls = new Integer(staticFunctionDepth.intValue() - 1);
 56             methodCallStr = Globals.returnNextStaticMethod(MethodID[1]);
 57 
 58             Globals.addFunctionIDToVector(methodCallStr.id, ID);
 59         } else {
 60             numFcalls = new Long(functionDepth.longValue() - 1);
 61             staticFcalls = staticFunctionDepth;
 62             Globals.addFunctionIDToVector(MethodID[0], ID);
 63             callMe(summation, ID, numFcalls, staticFcalls);
 64             return;
 65         }
 66 
 67 
 68         try {
 69             methodCallStr.nextMethod.invoke(methodCallStr.instance,
 70                     new Object[]{summation, ID, numFcalls, staticFcalls});
 71         } catch (IllegalAccessException iax) {
 72             throw new TestFailure(&quot;Illegal Access Exception&quot;);
 73         }
 74     }
 75 
 76     public void callMe(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)
 77             throws InvocationTargetException {
 78         Globals.appendSumToSummationVector(MethodID[0], summation);
 79 
 80         if (CGT.shouldFinish()) {
 81             return;
 82         }
 83 
 84         if (Globals.VERBOSE) {
 85             System.out.println(&quot;test2.callMe&quot;);
 86         }
 87 
 88         if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;= 0)) {
 89             return;
 90         }
 91 
 92         MethodData methodCallStr;
 93         Long numFcalls;
 94         Integer staticFcalls;
 95         if (staticFunctionDepth.intValue() &gt; 0) {
 96             numFcalls = functionDepth;
 97             staticFcalls = new Integer(staticFunctionDepth.intValue() - 1);
 98             methodCallStr = Globals.returnNextStaticMethod(MethodID[0]);
 99 
100         } else {
101             numFcalls = new Long(functionDepth.longValue() - 1);
102             staticFcalls = staticFunctionDepth;
103             methodCallStr = Globals.nextRandomMethod();
104         }
105 
106         Globals.addFunctionIDToVector(methodCallStr.id, ID);
107 
108 
109         try {
110             methodCallStr.nextMethod.invoke(methodCallStr.instance,
111                     new Object[]{summation, ID, numFcalls, staticFcalls});
112         } catch (IllegalAccessException iax) {
113             throw new TestFailure(&quot;Illegal Access Exception&quot;);
114         }
115 
116     }
117 }
    </pre>
  </body>
</html>
diff a/test/hotspot/jtreg/vmTestbase/jit/graph/Globals.java b/test/hotspot/jtreg/vmTestbase/jit/graph/Globals.java
--- a/test/hotspot/jtreg/vmTestbase/jit/graph/Globals.java
+++ b/test/hotspot/jtreg/vmTestbase/jit/graph/Globals.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -20,265 +20,202 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 package jit.graph;
-import java.io.*;
-import java.util.*;
-import java.lang.*;
-import java.lang.reflect.*;
+
+import jdk.test.lib.Utils;
 import nsk.share.TestFailure;
 
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Random;
+import java.util.StringTokenizer;
+import java.util.Vector;
 
-public final class Globals
-{
-    // Minimum and Maximum number of threads
-    public static int     NUM_THREADS      = 1;
-    public static long    RANDOM_SEED      = System.currentTimeMillis();
-    public static int     STATIC_LOOP      = 0;
-    public static int     NUM_TEST_CLASSES = 7;
-    public static long    RANDOM_LOOP      = 100;
-    public static boolean VERBOSE          = false;
-    private static Random indexGenerator   = null;
+public final class Globals {
 
-  //private static TestLoader CGTTestLoader = null;
-    private static String [] ClassArray = null;
-    private static Class [] ClassInstanceArray = null;
-    private static int       maxClassIndex    = 0;
 
-    private static String [] MethodName_Array = null;
-    private static Method [] MethodInstance_Array = null;
+    public static int STATIC_LOOP = 0;
+    public static int NUM_TEST_CLASSES = 7;
+    public static long RANDOM_LOOP = 100;
+    public static boolean VERBOSE = false;
 
-    //Should be prime, so that odds of an incorrect verification reduced
-    public static  int    [] MethodID_Array   = null;
+    private static final Random indexGenerator = Utils.getRandomInstance();
+    private static String[] ClassArray = null;
+    private static Class[] ClassInstanceArray = null;
+    private static int maxClassIndex = 0;
 
+    private static String[] MethodName_Array = null;
+    private static Method[] MethodInstance_Array = null;
 
-    //Number of threads will be reduced as threads finish
-    public static synchronized void decNumThreads(){NUM_THREADS--;};
+    // Should be prime, so that odds of an incorrect verification reduced
+    public static int[] MethodID_Array = null;
 
-    public static synchronized void initialize(String testListPath)
-    {
+    public static synchronized void initialize(String testListPath) {
+        File td = new File(testListPath);
+        if (!td.exists()) {
+            throw new Error("TESTBUG: File " + testListPath + " Not found");
+        }
 
-        File td = new File (testListPath);
-        if (!td.exists())
-            {
-                System.err.println("File " + testListPath + " Not found");
-                System.exit(1);
-            }
-        if (!td.isFile())
-            {
-                System.err.println(testListPath + " Must be a File");
-                System.exit(1);
-            }
+        if (!td.isFile()) {
+            throw new Error("TESTBUG: " + testListPath + " Must be a File");
+        }
 
         BufferedReader classList = null;
+        try {
+            try {
+                classList = new BufferedReader(new FileReader(td));
+            } catch (FileNotFoundException e) {
+                throw new Error("TESTBUG: Error finding Classlist", e);
+            }
 
-        try
-          {
-            classList = new BufferedReader(new FileReader(td));
-          }
-        catch (FileNotFoundException  fnfx)
-          {
-            System.err.println("Error finding Classlist");
-            System.exit(1);
-          }
-
-        String line = null;
-        try
-            {
+            String line = null;
+            try {
                 line = classList.readLine();
-            }
-        catch (IOException iox)
-            {
-                System.err.println("Error reading Classlist");
-                System.exit(1);
+            } catch (IOException e) {
+                throw new Error("TESTBUG: Error reading Classlist", e);
             }
 
-        try
-            {
-                maxClassIndex = Math.abs(Integer.parseInt(line));//ClassArray.length;
+            try {
+                // ClassArray.length;
+                maxClassIndex = Math.abs(Integer.parseInt(line));
+            } catch (NumberFormatException e) {
+                throw new Error("TESTBUG: Error reading Classlist - first number must be number of methods defined", e);
             }
-        catch (NumberFormatException nfx)
-            {
-                System.err.println("Error reading Classlist - first number must be number of methods defined");
-                System.exit(1);
-            }
-
-        ClassArray = new String [maxClassIndex];
-ClassInstanceArray = new Class [maxClassIndex];
-        MethodName_Array = new String [maxClassIndex];
-        MethodInstance_Array = new Method [maxClassIndex];
-        MethodID_Array = new int [maxClassIndex];
 
-        int i;
-        for (i = 0; (i<maxClassIndex) && (line != null); i++)
-            {
-                try
-                    {
-                        line = classList.readLine();
-                    }
-                catch (IOException iox)
-                    {
-                        System.err.println("Error reading ClasslistFile: testListPath");
-                        System.exit(1);
-                    }
+            ClassArray = new String[maxClassIndex];
+            ClassInstanceArray = new Class[maxClassIndex];
+            MethodName_Array = new String[maxClassIndex];
+            MethodInstance_Array = new Method[maxClassIndex];
+            MethodID_Array = new int[maxClassIndex];
+
+            int i;
+            for (i = 0; i < maxClassIndex; i++) {
+                try {
+                    line = classList.readLine();
+                } catch (IOException e) {
+                    throw new Error("TESTBUG: Error reading ClasslistFile: testListPath", e);
+                }
                 StringTokenizer lineTokens = new StringTokenizer(line, "\t ");
-                if (lineTokens.countTokens() <3)
-                  {
-                    System.out.println("Error reading ClasslistFile: Errored line");
-                    i--;
-                  }
-                else
-                  {
+                if (lineTokens.countTokens() < 3) {
+                    throw new Error("TESTBUG: ClasslistFile: unexpected line:" + line);
+                } else {
                     ClassArray[i] = lineTokens.nextToken();
-                    MethodName_Array[i] =lineTokens.nextToken();
+                    MethodName_Array[i] = lineTokens.nextToken();
                     MethodID_Array[i] = Integer.parseInt(lineTokens.nextToken());
-                  }
+                }
             }
-        maxClassIndex = i;
+            maxClassIndex = i;
+        } finally {
+            if (classList != null) {
+                try {
+                    classList.close();
+                } catch (IOException e) {
+                    throw new Error("can't close file", e);
+                }
+            }
+        }
 
-        indexGenerator = new Random(RANDOM_SEED);
-        if ((NUM_TEST_CLASSES < ClassArray.length) && (NUM_TEST_CLASSES > 0))
-          maxClassIndex = NUM_TEST_CLASSES;
-        else
-          NUM_TEST_CLASSES = maxClassIndex;
+        if ((NUM_TEST_CLASSES < ClassArray.length) && (NUM_TEST_CLASSES > 0)) {
+            maxClassIndex = NUM_TEST_CLASSES;
+        } else {
+            NUM_TEST_CLASSES = maxClassIndex;
+        }
     }
 
-    //does a binary serach to find the index for the ID of a method
-    private static int ID_BinSearch(int begin, int end, int ID)
-    {
-        if (end < begin)
-            return(-1);
+    // does a binary search to find the index for the ID of a method
+    private static int ID_BinSearch(int begin, int end, int ID) {
+        if (end < begin) {
+            return (-1);
+        }
 
-        int mid = (begin + end)/2;
+        int mid = (begin + end) / 2;
         int midvalue = MethodID_Array[mid];
 
-        if (ID == midvalue)
+        if (ID == midvalue) {
             return (mid);
-        else if (ID < midvalue)
-            return(ID_BinSearch(begin, mid-1, ID));
-        else
-            return(ID_BinSearch(mid+1, end, ID));
+        } else if (ID < midvalue) {
+            return (ID_BinSearch(begin, mid - 1, ID));
+        } else {
+            return (ID_BinSearch(mid + 1, end, ID));
+        }
     }
 
 
-    //based off a static index, this function selects the method to be called
-    public static MethodData returnNextStaticMethod(int Method_ID)
-    {
-      //int i = ID_BinSearch(0, MethodID_Array.length - 1, Method_ID);
-      int i = ID_BinSearch(0, maxClassIndex - 1, Method_ID);
+    // based off a static index, this function selects the method to be called
+    public static MethodData returnNextStaticMethod(int Method_ID) {
+        //int i = ID_BinSearch(0, MethodID_Array.length - 1, Method_ID);
+        int i = ID_BinSearch(0, maxClassIndex - 1, Method_ID);
 
-      return(nextStaticMethod((i==-1)?0:i));
+        return (nextStaticMethod((i == -1) ? 0 : i));
     }
 
-    //this function randomly selects the next method to be called by the test class
-    public static MethodData nextRandomMethod()
-    {
-
+    // this function randomly selects the next method to be called by the test class
+    public static MethodData nextRandomMethod() {
         int i = indexGenerator.nextInt(maxClassIndex);
-        return(nextStaticMethod(i));
+        return (nextStaticMethod(i));
     }
 
-    private static MethodData nextStaticMethod(int i)
-    {
+    private static MethodData nextStaticMethod(int i) {
         Class methodsClass = null;
         Method nextMethod = null;
 
-        try
-            {
-              //methodsClass = CGTTestLoader.findClass(ClassArray[i]);
-              methodsClass = ClassInstanceArray[i];
-              if (methodsClass == null)
-              {
-                  methodsClass = Class.forName(ClassArray[i]);
-                  ClassInstanceArray[i] = methodsClass;
-              }
-              nextMethod = MethodInstance_Array[i];
-              if (nextMethod == null )
-              {
-              nextMethod =
-                methodsClass.getMethod(MethodName_Array[i],
-                                       new Class[]{java.util.Vector.class, java.util.Vector.class,
-                                                     java.lang.Long.class, java.lang.Integer.class});
-              //sum vector, ID vector, function depth, static function call depth
-              MethodInstance_Array[i] = nextMethod;
-              }
-            }
-        catch (ClassNotFoundException cnfx)
-            {
-                System.out.println("Class: " +ClassArray[i]+ " Not Found");
-                System.exit(-1);
-            }
-        catch (NoSuchMethodException nsmx)
-            {
-                System.out.println("Class: " +ClassArray[i]);
-                System.out.println("Method: " +MethodName_Array[i]+" Not Found");
-                System.exit(-1);
+        try {
+            methodsClass = ClassInstanceArray[i];
+            if (methodsClass == null) {
+                methodsClass = Class.forName(ClassArray[i]);
+                ClassInstanceArray[i] = methodsClass;
             }
-        catch (SecurityException sx)
-            {
-                System.out.println("Class: " +ClassArray[i]);
-                System.out.println("Method: " +MethodName_Array[i]);
-                System.out.println("Security Exception Generated, by above method call");
-                System.exit(-1);
+            nextMethod = MethodInstance_Array[i];
+            if (nextMethod == null) {
+                nextMethod = methodsClass.getMethod(MethodName_Array[i],
+                        Vector.class, Vector.class,  Long.class, Integer.class);
+                // sum vector, ID vector, function depth, static function call depth
+                MethodInstance_Array[i] = nextMethod;
             }
-        return(new MethodData(ClassArray[i], MethodName_Array[i], methodsClass, nextMethod, MethodID_Array[i]));
+        } catch (ClassNotFoundException e) {
+            throw new Error("TESTBUG Class: " + ClassArray[i] + " Not Found", e);
+        } catch (NoSuchMethodException e) {
+            throw new Error("TESTBUG Method: " + ClassArray[i] + "::" + MethodName_Array[i] + " Not Found", e);
+        } catch (SecurityException e) {
+            throw new Error("TESTBUG Security Exception Generated by " + ClassArray[i] + "::" + MethodName_Array[i], e);
+        }
+        return new MethodData(ClassArray[i], MethodName_Array[i], methodsClass, nextMethod, MethodID_Array[i]);
     }
 
 
-    /*These two functions are used to verify that all function were called in the proper order*/
+    /* These two functions are used to verify that all function were called in the proper order */
 
-    //called by "parent" function to add childs ID to vector
-    public static void addFunctionIDToVector(int FunctionIndex, Vector IDVector)
-    {
-        IDVector.addElement(new Integer(FunctionIndex));
+    // called by "parent" function to add childs ID to vector
+    public static void addFunctionIDToVector(int FunctionIndex, Vector IDVector) {
+        IDVector.addElement(FunctionIndex);
     }
 
-    //called by "child" to add Function Index to Vector
-    public static void appendSumToSumationVector(int FunctionIndex, Vector SummationVector)
-    {
-        if (SummationVector.isEmpty())
-            SummationVector.addElement(new Long(FunctionIndex));
-        else
-            SummationVector.addElement(new Long(((Long)SummationVector.lastElement()).longValue() + FunctionIndex));
+    // called by "child" to add Function Index to Vector
+    public static void appendSumToSummationVector(int FunctionIndex, Vector SummationVector) {
+        if (SummationVector.isEmpty()) {
+            SummationVector.addElement((long) FunctionIndex);
+        } else {
+            SummationVector.addElement((Long) SummationVector.lastElement() + FunctionIndex);
+        }
     }
 
-    //This function calls a method based off of MethodData
+    // This function calls a method based off of MethodData
     public static void callMethod(MethodData methodCallStr,
                                   Vector summation, Vector ID,
                                   Long numFcalls, Integer staticFcalls)
-                                  throws InvocationTargetException
-
-    {
-                if(NUM_THREADS >1)
-                    {
-                        if ((staticFcalls.intValue() + numFcalls.longValue()) %23 == 0)
-                            {
-                                try
-                                    {
-                                        Thread.sleep(225);
-                                    }
-                                catch (InterruptedException ie)
-                                    {}
-                                if (VERBOSE)
-                                    System.out.println("\t\tCurrentThread:" + Thread.currentThread().getName());
-                            }
-                    }
-
-                try
-            {
-                        methodCallStr.nextMethod.invoke(methodCallStr.instance,
-                                new Object []{summation, ID, numFcalls, staticFcalls});
-            }
-                catch (IllegalAccessException iax)  //should never happen with a valid testfile
-            {
-                        throw new TestFailure("Illegal Access Exception");
-            }
-                    /*
-                catch (InvocationTargetException itx)
-                    {
-                        itx.printStackTrace();
-                        System.out.println("Invocation Target Exception");
-                        System.exit(1);
-                    }*/
+            throws InvocationTargetException {
+        try {
+            methodCallStr.nextMethod.invoke(methodCallStr.instance,
+                    summation, ID, numFcalls, staticFcalls);
+        } catch (IllegalAccessException e) {
+            // should never happen with a valid testfile
+            throw new TestFailure("Illegal Access Exception", e);
+        }
     }
 }

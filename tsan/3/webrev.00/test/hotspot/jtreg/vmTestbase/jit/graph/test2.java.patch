diff a/test/hotspot/jtreg/vmTestbase/jit/graph/test2.java b/test/hotspot/jtreg/vmTestbase/jit/graph/test2.java
--- a/test/hotspot/jtreg/vmTestbase/jit/graph/test2.java
+++ b/test/hotspot/jtreg/vmTestbase/jit/graph/test2.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -18,128 +18,100 @@
  *
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
+
 package jit.graph;
 
-import java.util.*;
-import java.lang.reflect.*;
 import nsk.share.TestFailure;
 
-class test2
-{
-    private final int[] MethodID = {Globals.MethodID_Array[1],Globals.MethodID_Array[2]};
+import java.lang.reflect.InvocationTargetException;
+import java.util.Vector;
 
-    public void CallCallMe(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)
-        throws InvocationTargetException
+class test2 {
+    private final int[] MethodID = {Globals.MethodID_Array[1], Globals.MethodID_Array[2]};
 
-    {
-        Globals.appendSumToSumationVector(MethodID[1], summation);
+    public void CallCallMe(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)
+            throws InvocationTargetException {
+        Globals.appendSumToSummationVector(MethodID[1], summation);
 
-        if (CGT.shouldFinish())
+        if (CGT.shouldFinish()) {
             return;
+        }
 
-        if (Globals.VERBOSE)
+        if (Globals.VERBOSE) {
             System.out.println("test2.CallCallMe");
+        }
+
+        if ((functionDepth.longValue() <= 0) && (staticFunctionDepth.intValue() <= 0)) {
+            return;
+        }
+
+        MethodData methodCallStr;
+        Long numFcalls;
+        Integer staticFcalls;
+        if (staticFunctionDepth.intValue() > 0) {
+            numFcalls = functionDepth;
+            staticFcalls = new Integer(staticFunctionDepth.intValue() - 1);
+            methodCallStr = Globals.returnNextStaticMethod(MethodID[1]);
+
+            Globals.addFunctionIDToVector(methodCallStr.id, ID);
+        } else {
+            numFcalls = new Long(functionDepth.longValue() - 1);
+            staticFcalls = staticFunctionDepth;
+            Globals.addFunctionIDToVector(MethodID[0], ID);
+            callMe(summation, ID, numFcalls, staticFcalls);
+            return;
+        }
+
 
-                if ((functionDepth.longValue() <= 0) && (staticFunctionDepth.intValue() <=  0))
-                    {
-                        return;
-                    }
-
-                MethodData methodCallStr;
-                Long numFcalls;
-                Integer staticFcalls;
-                if (staticFunctionDepth.intValue() > 0)
-                    {
-                        numFcalls = functionDepth;
-                        staticFcalls = new Integer(staticFunctionDepth.intValue()-1);
-                        //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[1]));
-                        methodCallStr = Globals.returnNextStaticMethod(MethodID[1]);
-
-                        Globals.addFunctionIDToVector(methodCallStr.id, ID);
-                    }
-                else
-                    {
-                        numFcalls = new Long(functionDepth.longValue()-1);
-                        staticFcalls = staticFunctionDepth;
-                        Globals.addFunctionIDToVector(MethodID[0], ID);
-                        callMe(summation, ID, numFcalls, staticFcalls);
-                        return;
-                    }
-
-
-                try
-                    {
-                        methodCallStr.nextMethod.invoke(methodCallStr.instance,
-                                                        new Object []{summation, ID, numFcalls, staticFcalls});
-                    }
-                catch (IllegalAccessException iax)
-                    {
-                        throw new TestFailure("Illegal Access Exception");
-                    }
-                /*
-                catch (InvocationTargetException itx)
-                    {
-                                throw itx;
-                    }
-                */
+        try {
+            methodCallStr.nextMethod.invoke(methodCallStr.instance,
+                    new Object[]{summation, ID, numFcalls, staticFcalls});
+        } catch (IllegalAccessException iax) {
+            throw new TestFailure("Illegal Access Exception");
+        }
     }
 
     public void callMe(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)
-        throws InvocationTargetException
-    {
-        Globals.appendSumToSumationVector(MethodID[0], summation);
+            throws InvocationTargetException {
+        Globals.appendSumToSummationVector(MethodID[0], summation);
 
-        if (CGT.shouldFinish())
+        if (CGT.shouldFinish()) {
             return;
+        }
 
-        if (Globals.VERBOSE)
+        if (Globals.VERBOSE) {
             System.out.println("test2.callMe");
+        }
 
-                if ((functionDepth.longValue() <= 0) && (staticFunctionDepth.intValue() <=  0))
-                    {
-                        return;
-                    }
-
-                MethodData methodCallStr;
-                Long numFcalls;
-                Integer staticFcalls;
-                if (staticFunctionDepth.intValue() > 0)
-            {
-                        numFcalls = functionDepth;
-                        staticFcalls = new Integer(staticFunctionDepth.intValue()-1);
-                        //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[0]));
-                        methodCallStr = Globals.returnNextStaticMethod(MethodID[0]);
-
-            }
-                else
-            {
-                        numFcalls = new Long(functionDepth.longValue() -1);
-                        staticFcalls = staticFunctionDepth;
-                        methodCallStr = Globals.nextRandomMethod();
-            }
-
-                Globals.addFunctionIDToVector(methodCallStr.id, ID);
-
-
-                try
-            {
-                        methodCallStr.nextMethod.invoke(methodCallStr.instance,
-                                new Object []{summation, ID, numFcalls, staticFcalls});
-            }
-                catch (IllegalAccessException iax)
-            {
-                        throw new TestFailure("Illegal Access Exception");
-            }
-/*
-                catch (InvocationTargetException itx)
-                    {
-                                System.out.println("itx test 2");
-
-                                throw itx;
-                    }
-                    */
+        if ((functionDepth.longValue() <= 0) && (staticFunctionDepth.intValue() <= 0)) {
+            return;
+        }
+
+        MethodData methodCallStr;
+        Long numFcalls;
+        Integer staticFcalls;
+        if (staticFunctionDepth.intValue() > 0) {
+            numFcalls = functionDepth;
+            staticFcalls = new Integer(staticFunctionDepth.intValue() - 1);
+            methodCallStr = Globals.returnNextStaticMethod(MethodID[0]);
+
+        } else {
+            numFcalls = new Long(functionDepth.longValue() - 1);
+            staticFcalls = staticFunctionDepth;
+            methodCallStr = Globals.nextRandomMethod();
+        }
+
+        Globals.addFunctionIDToVector(methodCallStr.id, ID);
+
+
+        try {
+            methodCallStr.nextMethod.invoke(methodCallStr.instance,
+                    new Object[]{summation, ID, numFcalls, staticFcalls});
+        } catch (IllegalAccessException iax) {
+            throw new TestFailure("Illegal Access Exception");
+        }
 
     }
 }

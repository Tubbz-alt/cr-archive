<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/hotspot/jtreg/vmTestbase/jit/graph/test5.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="test4.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="test6.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/jit/graph/test5.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 18,322 ***</span>
   *
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  package jit.graph;
  
<span class="line-modified">! import java.util.*;</span>
<span class="line-removed">- import java.lang.reflect.*;</span>
  import nsk.share.TestFailure;
  
<span class="line-modified">! class test5</span>
<span class="line-modified">! {</span>
<span class="line-modified">!   private final int[] MethodID = {Globals.MethodID_Array[7],</span>
<span class="line-modified">!                                   Globals.MethodID_Array[8],</span>
<span class="line-modified">!                                   Globals.MethodID_Array[9],</span>
<span class="line-modified">!                                   Globals.MethodID_Array[10]};</span>
<span class="line-modified">!   private static Random loopNumGen = new Random(Globals.RANDOM_SEED);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   private final int maxLoops = 12;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   private long factorial(int n)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     if(n&gt;1)</span>
<span class="line-modified">!       return(n*factorial(n-1));</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       return (1);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   private long fibonacci(long num1, long num2, int n)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (n &lt;= 0)</span>
<span class="line-modified">!       return(num2);</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       return (fibonacci(num2, num1+num2, n-1));</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   private long combination(int n, int r)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     if ((r==0) || (n==r))</span>
<span class="line-modified">!       return 1;</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       return(combination(n-1, r) +combination(n - 1, r - 1));</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   private int[] pascalsTriangle(int[] source, int n)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (n&gt;0)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         int sourceLength = source.length;</span>
<span class="line-modified">!         int [] temp = new int[sourceLength +1];</span>
<span class="line-modified">!         temp[0] = 1;</span>
<span class="line-modified">!         temp[sourceLength] = 1;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         int j=1;</span>
<span class="line-modified">!         for(int i = 0; i&lt;(sourceLength - 1); i++)</span>
<span class="line-modified">!           temp[j++] = source[i] + source[i+1];</span>
<span class="line-modified">! </span>
<span class="line-modified">!         return(pascalsTriangle(temp, n-1));</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       return source;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   private boolean verifyArray(int[] ArrayToBeVerified, int[] MasterArray)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (ArrayToBeVerified.length != MasterArray.length)</span>
<span class="line-modified">!       return false;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     for (int i =0; i&lt;MasterArray.length; i++)</span>
<span class="line-modified">!       if (MasterArray[i] != ArrayToBeVerified[i])</span>
<span class="line-modified">!         return false;</span>
<span class="line-modified">!     return true;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   private int[] verifyPascal(int n)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     int []   pascalOut = new int[n+1];</span>
<span class="line-modified">!     int [][] dataArray = new int[n+1][n+1];</span>
<span class="line-modified">! </span>
<span class="line-modified">!     for (int i = 0; i&lt;=n; i++)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         for (int j = 0; j&lt;=n; j++)</span>
<span class="line-modified">!           {</span>
<span class="line-modified">!             if (j==0)</span>
<span class="line-modified">!               dataArray[i][0] = 1;</span>
<span class="line-modified">!             else if (j==i)</span>
<span class="line-modified">!               dataArray[i][i] = 1;</span>
<span class="line-modified">!             else if (j&lt;i)</span>
<span class="line-modified">!               dataArray[i][j] =  dataArray[i-1][j-1] + dataArray[i-1][j];</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!       }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     int j = n;                            //could be a little more efficient</span>
<span class="line-modified">!     for (int i = 0; i&lt;=n; i++)            //but not that important</span>
<span class="line-modified">!       pascalOut[i] = dataArray[j][i];</span>
<span class="line-modified">!     return pascalOut;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   private long verifyFact(int n)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     long answer = 1;</span>
<span class="line-modified">!     for (int i=2; i&lt;=n; i++)</span>
<span class="line-modified">!         answer*=i;</span>
<span class="line-modified">!     return answer;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   private long verifyFibo(int n)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     long num1=1;</span>
<span class="line-modified">!     long num2=1;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     for (int i = 0; i&lt; n; i++)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         long temp = num1+num2;</span>
<span class="line-modified">!         num1 = num2;</span>
<span class="line-modified">!         num2 = temp;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return num2;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   private long verifyComb(int n, int r)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     return(verifyFact(n)/(verifyFact(n-r)*verifyFact(r)));</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   public void factTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">!         throws InvocationTargetException</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     Globals.appendSumToSumationVector(MethodID[0], summation);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (CGT.shouldFinish())</span>
<span class="line-modified">!       return;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (Globals.VERBOSE)</span>
<span class="line-modified">!       System.out.println(&quot;test5.factTest&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     MethodData methodCallStr;</span>
<span class="line-modified">!     Long numFcalls;</span>
<span class="line-modified">!     Integer staticFcalls;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (staticFunctionDepth.intValue() &gt; 0)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         numFcalls = functionDepth;</span>
<span class="line-modified">!         staticFcalls = new Integer(staticFunctionDepth.intValue()-1);</span>
<span class="line-modified">!         methodCallStr = Globals.returnNextStaticMethod(MethodID[0]);</span>
<span class="line-modified">!         //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[0]));</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         numFcalls = new Long(functionDepth.longValue() -1);</span>
<span class="line-modified">!         staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">!         methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">!       }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     int localNumLoops    = loopNumGen.nextInt(maxLoops);</span>
<span class="line-modified">!     long facFunctionValue = factorial(localNumLoops);</span>
<span class="line-modified">!     long facVerValue      = verifyFact(localNumLoops);</span>
<span class="line-modified">!     if (facFunctionValue != facVerValue)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         System.out.println(&quot;Factorial Computed Incorrectly&quot;);</span>
<span class="line-modified">!         System.out.println(&quot;Specific Factorial Requested &quot;+localNumLoops +&quot;!&quot;);</span>
<span class="line-modified">!         throw new TestFailure(&quot;Expected: &quot; + facVerValue + &quot; Actual &quot;+ facFunctionValue);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-modified">!     Globals.callMethod(methodCallStr,summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   public void fiboTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">!         throws InvocationTargetException</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     Globals.appendSumToSumationVector(MethodID[1], summation);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (CGT.shouldFinish())</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (Globals.VERBOSE)</span>
<span class="line-modified">!       System.out.println(&quot;test5.fiboTest&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     MethodData methodCallStr;</span>
<span class="line-modified">!     Long numFcalls;</span>
<span class="line-modified">!     Integer staticFcalls;</span>
<span class="line-modified">!     if (staticFunctionDepth.intValue() &gt; 0)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         numFcalls = functionDepth;</span>
<span class="line-modified">!         staticFcalls = new Integer(staticFunctionDepth.intValue()-1);</span>
<span class="line-modified">!         methodCallStr = Globals.returnNextStaticMethod(MethodID[1]);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         numFcalls = new Long(functionDepth.longValue() -1);</span>
<span class="line-modified">!         staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">!         methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     int localNumLoops      = loopNumGen.nextInt(maxLoops*3);</span>
<span class="line-modified">!     long fiboFunctionValue = fibonacci(1,1,localNumLoops);</span>
<span class="line-modified">!     long fiboVerValue      = verifyFibo(localNumLoops);</span>
<span class="line-modified">!     if (fiboFunctionValue != fiboVerValue)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         System.out.println(&quot;Fibonacci Series Computed Incorrectly&quot;);</span>
<span class="line-modified">!         System.out.println(&quot;Specific Digit Requested &quot;+localNumLoops);</span>
<span class="line-modified">!         throw new TestFailure(&quot;Expected: &quot; + fiboVerValue + &quot; Actual &quot;+ fiboFunctionValue);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-modified">!     Globals.callMethod(methodCallStr,summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">!   public void combTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">!         throws InvocationTargetException</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     Globals.appendSumToSumationVector(MethodID[2], summation);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (CGT.shouldFinish())</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (Globals.VERBOSE)</span>
<span class="line-modified">!       System.out.println(&quot;test5.combTest&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     MethodData methodCallStr;</span>
<span class="line-modified">!     Long numFcalls;</span>
<span class="line-modified">!     Integer staticFcalls;</span>
<span class="line-modified">!     if (staticFunctionDepth.intValue() &gt; 0)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         numFcalls = functionDepth;</span>
<span class="line-modified">!         staticFcalls = new Integer(staticFunctionDepth.intValue()-1);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         methodCallStr = Globals.returnNextStaticMethod(MethodID[2]);</span>
<span class="line-modified">!         //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[2]));</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         numFcalls = new Long(functionDepth.longValue() -1);</span>
<span class="line-modified">!         staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">!         methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     int n = loopNumGen.nextInt(maxLoops);</span>
<span class="line-modified">!     int k = (n&gt;0)?loopNumGen.nextInt(n):0;</span>
<span class="line-modified">!     long combFunctionValue = combination(n, k);</span>
<span class="line-modified">!     long combVerValue      = verifyComb(n, k);</span>
<span class="line-modified">!     if (combFunctionValue != combVerValue)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         System.out.println(&quot;Combination Computed Incorrectly&quot;);</span>
<span class="line-modified">!         System.out.println(&quot;N = &quot; + n +&quot;K = &quot; + k);</span>
<span class="line-modified">!         throw new TestFailure(&quot;Expected: &quot; + combVerValue + &quot; Actual &quot;+ combFunctionValue);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-modified">!     Globals.callMethod(methodCallStr,summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">!   public void pascalTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">!         throws InvocationTargetException</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     Globals.appendSumToSumationVector(MethodID[3], summation);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (CGT.shouldFinish())</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">! </span>
<span class="line-modified">! int [] x = new int[1 &lt;&lt; 30];</span>
<span class="line-modified">! x[1 &lt;&lt; 24] = 1;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (Globals.VERBOSE)</span>
<span class="line-modified">!       System.out.println(&quot;test5.pascalTest&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     MethodData methodCallStr;</span>
<span class="line-modified">!     Long numFcalls;</span>
<span class="line-modified">!     Integer staticFcalls;</span>
<span class="line-modified">!     if (staticFunctionDepth.intValue() &gt; 0)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         numFcalls = functionDepth;</span>
<span class="line-modified">!         staticFcalls = new Integer(staticFunctionDepth.intValue()-1);</span>
<span class="line-modified">!         methodCallStr = Globals.returnNextStaticMethod(MethodID[3]);</span>
<span class="line-modified">!         //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[3]));</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         numFcalls = new Long(functionDepth.longValue() -1);</span>
<span class="line-modified">!         staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">!         methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     int num = loopNumGen.nextInt(maxLoops);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     int[] pascalFunctionValue = pascalsTriangle(new int[] {1}, num);</span>
<span class="line-modified">!     int[] pascalVerValue      = verifyPascal(num);</span>
<span class="line-modified">!     if (!verifyArray(pascalFunctionValue, pascalVerValue))</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         String temp = new String(&quot;Expected: &quot;);</span>
<span class="line-removed">-         for (int i=0; i&lt;pascalVerValue.length; i++)</span>
<span class="line-removed">-           temp += pascalVerValue[i] +&quot;, &quot;;</span>
<span class="line-removed">-         temp+=  &quot; Actual &quot;;</span>
<span class="line-removed">-         for (int i=0; i&lt;pascalFunctionValue.length; i++)</span>
<span class="line-removed">-           temp += pascalFunctionValue[i] +&quot;, &quot;;</span>
<span class="line-removed">-         System.out.println(&quot;Pascal Tringle Row Computed Incorrectly&quot;);</span>
<span class="line-removed">-         System.out.println(&quot;Row Number &quot; + num);</span>
<span class="line-removed">-         throw new TestFailure(temp);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-removed">-     Globals.callMethod(methodCallStr,summation, ID, numFcalls, staticFcalls);</span>
<span class="line-removed">-   }</span>
  }
<span class="line-new-header">--- 18,307 ---</span>
   *
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
<span class="line-added">+ </span>
  package jit.graph;
  
<span class="line-modified">! import jdk.test.lib.Utils;</span>
  import nsk.share.TestFailure;
  
<span class="line-modified">! import java.lang.reflect.InvocationTargetException;</span>
<span class="line-modified">! import java.util.Random;</span>
<span class="line-modified">! import java.util.Vector;</span>
<span class="line-modified">! </span>
<span class="line-modified">! class test5 {</span>
<span class="line-modified">!     private final int[] MethodID = {Globals.MethodID_Array[7],</span>
<span class="line-modified">!             Globals.MethodID_Array[8],</span>
<span class="line-modified">!             Globals.MethodID_Array[9],</span>
<span class="line-modified">!             Globals.MethodID_Array[10]};</span>
<span class="line-modified">!     private static Random loopNumGen = new Random(Utils.SEED);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private final int maxLoops = 12;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private long factorial(int n) {</span>
<span class="line-modified">!         if (n &gt; 1) {</span>
<span class="line-modified">!             return (n * factorial(n - 1));</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             return (1);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private long fibonacci(long num1, long num2, int n) {</span>
<span class="line-modified">!         if (n &lt;= 0) {</span>
<span class="line-modified">!             return (num2);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             return (fibonacci(num2, num1 + num2, n - 1));</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private long combination(int n, int r) {</span>
<span class="line-modified">!         if ((r == 0) || (n == r)) {</span>
<span class="line-modified">!             return 1;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             return (combination(n - 1, r) + combination(n - 1, r - 1));</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private int[] pascalsTriangle(int[] source, int n) {</span>
<span class="line-modified">!         if (n &gt; 0) {</span>
<span class="line-modified">!             int sourceLength = source.length;</span>
<span class="line-modified">!             int[] temp = new int[sourceLength + 1];</span>
<span class="line-modified">!             temp[0] = 1;</span>
<span class="line-modified">!             temp[sourceLength] = 1;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             int j = 1;</span>
<span class="line-modified">!             for (int i = 0; i &lt; (sourceLength - 1); i++) {</span>
<span class="line-modified">!                 temp[j++] = source[i] + source[i + 1];</span>
<span class="line-modified">!             }</span>
<span class="line-modified">! </span>
<span class="line-modified">!             return pascalsTriangle(temp, n - 1);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             return source;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private boolean verifyArray(int[] ArrayToBeVerified, int[] MasterArray) {</span>
<span class="line-modified">!         if (ArrayToBeVerified.length != MasterArray.length) {</span>
<span class="line-modified">!             return false;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         for (int i = 0; i &lt; MasterArray.length; i++) {</span>
<span class="line-modified">!             if (MasterArray[i] != ArrayToBeVerified[i]) {</span>
<span class="line-modified">!                 return false;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return true;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private int[] verifyPascal(int n) {</span>
<span class="line-modified">!         int[] pascalOut = new int[n + 1];</span>
<span class="line-modified">!         int[][] dataArray = new int[n + 1][n + 1];</span>
<span class="line-modified">! </span>
<span class="line-modified">!         for (int i = 0; i &lt;= n; i++) {</span>
<span class="line-modified">!             for (int j = 0; j &lt;= n; j++) {</span>
<span class="line-modified">!                 if (j == 0) {</span>
<span class="line-modified">!                     dataArray[i][0] = 1;</span>
<span class="line-modified">!                 } else if (j == i) {</span>
<span class="line-modified">!                     dataArray[i][i] = 1;</span>
<span class="line-modified">!                 } else if (j &lt; i) {</span>
<span class="line-modified">!                     dataArray[i][j] = dataArray[i - 1][j - 1] + dataArray[i - 1][j];</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // could be a little more efficient, but not that important</span>
<span class="line-modified">!         int j = n;</span>
<span class="line-modified">!         for (int i = 0; i &lt;= n; i++) {</span>
<span class="line-modified">!             pascalOut[i] = dataArray[j][i];</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return pascalOut;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private long verifyFact(int n) {</span>
<span class="line-modified">!         long answer = 1;</span>
<span class="line-modified">!         for (int i = 2; i &lt;= n; i++) {</span>
<span class="line-modified">!             answer *= i;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return answer;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private long verifyFibo(int n) {</span>
<span class="line-modified">!         long num1 = 1;</span>
<span class="line-modified">!         long num2 = 1;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         for (int i = 0; i &lt; n; i++) {</span>
<span class="line-modified">!             long temp = num1 + num2;</span>
<span class="line-modified">!             num1 = num2;</span>
<span class="line-modified">!             num2 = temp;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         return num2;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private long verifyComb(int n, int r) {</span>
<span class="line-modified">!         return (verifyFact(n) / (verifyFact(n - r) * verifyFact(r)));</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     public void factTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">!             throws InvocationTargetException {</span>
<span class="line-modified">!         Globals.appendSumToSummationVector(MethodID[0], summation);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (CGT.shouldFinish()) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (Globals.VERBOSE) {</span>
<span class="line-modified">!             System.out.println(&quot;test5.factTest&quot;);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;= 0)) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         MethodData methodCallStr;</span>
<span class="line-modified">!         Long numFcalls;</span>
<span class="line-modified">!         Integer staticFcalls;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (staticFunctionDepth.intValue() &gt; 0) {</span>
<span class="line-modified">!             numFcalls = functionDepth;</span>
<span class="line-modified">!             staticFcalls = new Integer(staticFunctionDepth.intValue() - 1);</span>
<span class="line-modified">!             methodCallStr = Globals.returnNextStaticMethod(MethodID[0]);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             numFcalls = new Long(functionDepth.longValue() - 1);</span>
<span class="line-modified">!             staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">!             methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         int localNumLoops = loopNumGen.nextInt(maxLoops);</span>
<span class="line-modified">!         long facFunctionValue = factorial(localNumLoops);</span>
<span class="line-modified">!         long facVerValue = verifyFact(localNumLoops);</span>
<span class="line-modified">!         if (facFunctionValue != facVerValue) {</span>
<span class="line-modified">!             System.out.println(&quot;Factorial Computed Incorrectly&quot;);</span>
<span class="line-modified">!             System.out.println(&quot;Specific Factorial Requested &quot; + localNumLoops + &quot;!&quot;);</span>
<span class="line-modified">!             throw new TestFailure(&quot;Expected: &quot; + facVerValue + &quot; Actual &quot; + facFunctionValue);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-modified">!         Globals.callMethod(methodCallStr, summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     public void fiboTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">!             throws InvocationTargetException {</span>
<span class="line-modified">!         Globals.appendSumToSummationVector(MethodID[1], summation);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (CGT.shouldFinish()) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (Globals.VERBOSE) {</span>
<span class="line-modified">!             System.out.println(&quot;test5.fiboTest&quot;);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;= 0)) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         MethodData methodCallStr;</span>
<span class="line-modified">!         Long numFcalls;</span>
<span class="line-modified">!         Integer staticFcalls;</span>
<span class="line-modified">!         if (staticFunctionDepth.intValue() &gt; 0) {</span>
<span class="line-modified">!             numFcalls = functionDepth;</span>
<span class="line-modified">!             staticFcalls = new Integer(staticFunctionDepth.intValue() - 1);</span>
<span class="line-modified">!             methodCallStr = Globals.returnNextStaticMethod(MethodID[1]);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             numFcalls = new Long(functionDepth.longValue() - 1);</span>
<span class="line-modified">!             staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">!             methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         int localNumLoops = loopNumGen.nextInt(maxLoops * 3);</span>
<span class="line-modified">!         long fiboFunctionValue = fibonacci(1, 1, localNumLoops);</span>
<span class="line-modified">!         long fiboVerValue = verifyFibo(localNumLoops);</span>
<span class="line-modified">!         if (fiboFunctionValue != fiboVerValue) {</span>
<span class="line-modified">!             System.out.println(&quot;Fibonacci Series Computed Incorrectly&quot;);</span>
<span class="line-modified">!             System.out.println(&quot;Specific Digit Requested &quot; + localNumLoops);</span>
<span class="line-modified">!             throw new TestFailure(&quot;Expected: &quot; + fiboVerValue + &quot; Actual &quot; + fiboFunctionValue);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-modified">!         Globals.callMethod(methodCallStr, summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">!     public void combTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">!             throws InvocationTargetException {</span>
<span class="line-modified">!         Globals.appendSumToSummationVector(MethodID[2], summation);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (CGT.shouldFinish()) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (Globals.VERBOSE) {</span>
<span class="line-modified">!             System.out.println(&quot;test5.combTest&quot;);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;= 0)) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         MethodData methodCallStr;</span>
<span class="line-modified">!         Long numFcalls;</span>
<span class="line-modified">!         Integer staticFcalls;</span>
<span class="line-modified">!         if (staticFunctionDepth.intValue() &gt; 0) {</span>
<span class="line-modified">!             numFcalls = functionDepth;</span>
<span class="line-modified">!             staticFcalls = new Integer(staticFunctionDepth.intValue() - 1);</span>
<span class="line-modified">!             methodCallStr = Globals.returnNextStaticMethod(MethodID[2]);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             numFcalls = new Long(functionDepth.longValue() - 1);</span>
<span class="line-modified">!             staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">!             methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         int n = loopNumGen.nextInt(maxLoops);</span>
<span class="line-modified">!         int k = (n &gt; 0) ? loopNumGen.nextInt(n) : 0;</span>
<span class="line-modified">!         long combFunctionValue = combination(n, k);</span>
<span class="line-modified">!         long combVerValue = verifyComb(n, k);</span>
<span class="line-modified">!         if (combFunctionValue != combVerValue) {</span>
<span class="line-modified">!             System.out.println(&quot;Combination Computed Incorrectly&quot;);</span>
<span class="line-modified">!             System.out.println(&quot;N = &quot; + n + &quot;K = &quot; + k);</span>
<span class="line-modified">!             throw new TestFailure(&quot;Expected: &quot; + combVerValue + &quot; Actual &quot; + combFunctionValue);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-modified">!         Globals.callMethod(methodCallStr, summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">!     public void pascalTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">!             throws InvocationTargetException {</span>
<span class="line-modified">!         Globals.appendSumToSummationVector(MethodID[3], summation);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (CGT.shouldFinish()) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (Globals.VERBOSE) {</span>
<span class="line-modified">!             System.out.println(&quot;test5.pascalTest&quot;);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         int[] x = new int[1 &lt;&lt; 30];</span>
<span class="line-modified">!         x[1 &lt;&lt; 24] = 1;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;= 0)) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         MethodData methodCallStr;</span>
<span class="line-modified">!         Long numFcalls;</span>
<span class="line-modified">!         Integer staticFcalls;</span>
<span class="line-modified">!         if (staticFunctionDepth.intValue() &gt; 0) {</span>
<span class="line-modified">!             numFcalls = functionDepth;</span>
<span class="line-modified">!             staticFcalls = new Integer(staticFunctionDepth.intValue() - 1);</span>
<span class="line-modified">!             methodCallStr = Globals.returnNextStaticMethod(MethodID[3]);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             numFcalls = new Long(functionDepth.longValue() - 1);</span>
<span class="line-modified">!             staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">!             methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         int num = loopNumGen.nextInt(maxLoops);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         int[] pascalFunctionValue = pascalsTriangle(new int[]{1}, num);</span>
<span class="line-modified">!         int[] pascalVerValue = verifyPascal(num);</span>
<span class="line-modified">!         if (!verifyArray(pascalFunctionValue, pascalVerValue)) {</span>
<span class="line-modified">!             StringBuilder temp = new StringBuilder(&quot;Expected: &quot;);</span>
<span class="line-modified">!             for (int aPascalVerValue : pascalVerValue) {</span>
<span class="line-modified">!                 temp.append(aPascalVerValue)</span>
<span class="line-modified">!                     .append(&quot;, &quot;);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             temp.append(&quot; Actual &quot;);</span>
<span class="line-modified">!             for (int aPascalFunctionValue : pascalFunctionValue) {</span>
<span class="line-modified">!                 temp.append(aPascalFunctionValue)</span>
<span class="line-modified">!                     .append(&quot;, &quot;);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             System.out.println(&quot;Pascal Tringle Row Computed Incorrectly&quot;);</span>
<span class="line-modified">!             System.out.println(&quot;Row Number &quot; + num);</span>
<span class="line-modified">!             throw new TestFailure(temp.toString());</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-modified">!         Globals.callMethod(methodCallStr, summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">!     }</span>
  }
</pre>
<center><a href="test4.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="test6.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
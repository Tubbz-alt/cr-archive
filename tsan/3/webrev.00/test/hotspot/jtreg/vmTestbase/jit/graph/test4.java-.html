<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/jit/graph/test4.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jit.graph;
 24 
 25 import java.util.*;
 26 import java.lang.reflect.*;
 27 import nsk.share.TestFailure;
 28 
 29 
 30 class test4 extends test2
 31 {
 32     private final int[] MethodID = {Globals.MethodID_Array[1],Globals.MethodID_Array[5], Globals.MethodID_Array[6]};
 33 
 34     //this method verifies that a child can make a call to its parent
 35     public void CallCallMe(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)
 36         throws InvocationTargetException
 37     {
 38         Globals.appendSumToSumationVector(MethodID[1], summation);
 39 
 40         if (CGT.shouldFinish())
 41             return;
 42 
 43         if (Globals.VERBOSE)
 44             System.out.println(&quot;test4.CallCallMe&quot;);
 45 
 46         if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))
 47             {
 48                 return;
 49             }
 50 
 51         MethodData methodCallStr;
 52         Long numFcalls;
 53         Integer staticFcalls;
 54         if (staticFunctionDepth.intValue() &gt; 0)
 55             {
 56                 numFcalls = functionDepth;
 57                 staticFcalls = new Integer(staticFunctionDepth.intValue()-1);
 58                 //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[1]));
 59                 methodCallStr = Globals.returnNextStaticMethod(MethodID[1]);
 60 
 61                 Globals.addFunctionIDToVector(methodCallStr.id, ID);
 62             }
 63         else
 64             {
 65                 numFcalls = new Long(functionDepth.longValue()-1);
 66                 staticFcalls = staticFunctionDepth;
 67                 Globals.addFunctionIDToVector(MethodID[0], ID);
 68                 super.callMe(summation, ID, numFcalls, staticFcalls);
 69                 return;
 70             }
 71 
 72 
 73         Globals.callMethod(methodCallStr, summation, ID, numFcalls, staticFcalls);
 74     }
 75 
 76     //this method makes a Y fork in the method call structure
 77     public void callMe(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)
 78                 throws InvocationTargetException
 79     {
 80         Globals.appendSumToSumationVector(MethodID[2], summation);
 81 
 82         if (CGT.shouldFinish())
 83             return;
 84 
 85         if (Globals.VERBOSE)
 86             System.out.println(&quot;test4.callMe&quot;);
 87 
 88         if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))
 89             {
 90                 return;
 91             }
 92 
 93         MethodData methodCallStr;
 94         Long numFcalls;
 95         Integer staticFcalls;
 96         if (staticFunctionDepth.intValue() &gt; 0)
 97             {
 98                 numFcalls = functionDepth;
 99                 staticFcalls = new Integer(staticFunctionDepth.intValue()-1);
100                 //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[2]));
101                 methodCallStr = Globals.returnNextStaticMethod(MethodID[2]);
102 
103             }
104         else
105             {
106                 long temp = functionDepth.longValue()-2;
107                 numFcalls = new Long(temp/2);
108                 staticFcalls = staticFunctionDepth;
109 
110                 if (Globals.VERBOSE)
111                     System.out.println(&quot; test4.callMe - Starting Branch 1&quot;);
112                 methodCallStr = Globals.nextRandomMethod();
113                 Globals.addFunctionIDToVector(methodCallStr.id, ID);
114                 Globals.callMethod(methodCallStr, summation, ID, numFcalls, staticFcalls);
115 
116                 if (CGT.shouldFinish())
117                     return;
118 
119                 temp -= temp/2;
120                 if (temp &lt;0)
121                   {
122                     if (Globals.VERBOSE)
123                       System.out.println(&quot; test4.callMe - Skipping Branch 2&quot;);
124                     return;
125                   }
126                 if (Globals.VERBOSE)
127                     System.out.println(&quot; test4.callMe - Starting Branch 2&quot;);
128                 numFcalls = new Long(temp);
129                 methodCallStr = Globals.nextRandomMethod();
130             }
131         Globals.addFunctionIDToVector(methodCallStr.id, ID);
132         Globals.callMethod(methodCallStr, summation, ID, numFcalls, staticFcalls);
133     }
134 
135 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/jit/graph/test5.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jit.graph;
 24 
 25 import java.util.*;
 26 import java.lang.reflect.*;
 27 import nsk.share.TestFailure;
 28 
 29 class test5
 30 {
 31   private final int[] MethodID = {Globals.MethodID_Array[7],
 32                                   Globals.MethodID_Array[8],
 33                                   Globals.MethodID_Array[9],
 34                                   Globals.MethodID_Array[10]};
 35   private static Random loopNumGen = new Random(Globals.RANDOM_SEED);
 36 
 37   private final int maxLoops = 12;
 38 
 39   private long factorial(int n)
 40   {
 41     if(n&gt;1)
 42       return(n*factorial(n-1));
 43     else
 44       return (1);
 45   }
 46 
 47   private long fibonacci(long num1, long num2, int n)
 48   {
 49     if (n &lt;= 0)
 50       return(num2);
 51     else
 52       return (fibonacci(num2, num1+num2, n-1));
 53   }
 54 
 55   private long combination(int n, int r)
 56   {
 57     if ((r==0) || (n==r))
 58       return 1;
 59     else
 60       return(combination(n-1, r) +combination(n - 1, r - 1));
 61   }
 62 
 63   private int[] pascalsTriangle(int[] source, int n)
 64   {
 65     if (n&gt;0)
 66       {
 67         int sourceLength = source.length;
 68         int [] temp = new int[sourceLength +1];
 69         temp[0] = 1;
 70         temp[sourceLength] = 1;
 71 
 72         int j=1;
 73         for(int i = 0; i&lt;(sourceLength - 1); i++)
 74           temp[j++] = source[i] + source[i+1];
 75 
 76         return(pascalsTriangle(temp, n-1));
 77       }
 78     else
 79       return source;
 80   }
 81 
 82   private boolean verifyArray(int[] ArrayToBeVerified, int[] MasterArray)
 83   {
 84     if (ArrayToBeVerified.length != MasterArray.length)
 85       return false;
 86 
 87     for (int i =0; i&lt;MasterArray.length; i++)
 88       if (MasterArray[i] != ArrayToBeVerified[i])
 89         return false;
 90     return true;
 91   }
 92 
 93   private int[] verifyPascal(int n)
 94   {
 95     int []   pascalOut = new int[n+1];
 96     int [][] dataArray = new int[n+1][n+1];
 97 
 98     for (int i = 0; i&lt;=n; i++)
 99       {
100         for (int j = 0; j&lt;=n; j++)
101           {
102             if (j==0)
103               dataArray[i][0] = 1;
104             else if (j==i)
105               dataArray[i][i] = 1;
106             else if (j&lt;i)
107               dataArray[i][j] =  dataArray[i-1][j-1] + dataArray[i-1][j];
108           }
109       }
110 
111     int j = n;                            //could be a little more efficient
112     for (int i = 0; i&lt;=n; i++)            //but not that important
113       pascalOut[i] = dataArray[j][i];
114     return pascalOut;
115   }
116 
117   private long verifyFact(int n)
118   {
119     long answer = 1;
120     for (int i=2; i&lt;=n; i++)
121         answer*=i;
122     return answer;
123   }
124 
125   private long verifyFibo(int n)
126   {
127     long num1=1;
128     long num2=1;
129 
130     for (int i = 0; i&lt; n; i++)
131       {
132         long temp = num1+num2;
133         num1 = num2;
134         num2 = temp;
135       }
136 
137     return num2;
138   }
139 
140   private long verifyComb(int n, int r)
141   {
142     return(verifyFact(n)/(verifyFact(n-r)*verifyFact(r)));
143   }
144 
145   public void factTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)
146         throws InvocationTargetException
147   {
148     Globals.appendSumToSumationVector(MethodID[0], summation);
149 
150     if (CGT.shouldFinish())
151       return;
152 
153     if (Globals.VERBOSE)
154       System.out.println(&quot;test5.factTest&quot;);
155 
156     if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))
157       {
158         return;
159       }
160     MethodData methodCallStr;
161     Long numFcalls;
162     Integer staticFcalls;
163 
164     if (staticFunctionDepth.intValue() &gt; 0)
165       {
166         numFcalls = functionDepth;
167         staticFcalls = new Integer(staticFunctionDepth.intValue()-1);
168         methodCallStr = Globals.returnNextStaticMethod(MethodID[0]);
169         //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[0]));
170       }
171     else
172       {
173         numFcalls = new Long(functionDepth.longValue() -1);
174         staticFcalls = staticFunctionDepth;
175         methodCallStr = Globals.nextRandomMethod();
176       }
177 
178     int localNumLoops    = loopNumGen.nextInt(maxLoops);
179     long facFunctionValue = factorial(localNumLoops);
180     long facVerValue      = verifyFact(localNumLoops);
181     if (facFunctionValue != facVerValue)
182       {
183         System.out.println(&quot;Factorial Computed Incorrectly&quot;);
184         System.out.println(&quot;Specific Factorial Requested &quot;+localNumLoops +&quot;!&quot;);
185         throw new TestFailure(&quot;Expected: &quot; + facVerValue + &quot; Actual &quot;+ facFunctionValue);
186       }
187 
188     Globals.addFunctionIDToVector(methodCallStr.id, ID);
189     Globals.callMethod(methodCallStr,summation, ID, numFcalls, staticFcalls);
190   }
191 
192   public void fiboTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)
193         throws InvocationTargetException
194   {
195     Globals.appendSumToSumationVector(MethodID[1], summation);
196 
197     if (CGT.shouldFinish())
198         return;
199 
200     if (Globals.VERBOSE)
201       System.out.println(&quot;test5.fiboTest&quot;);
202 
203     if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))
204       {
205         return;
206       }
207     MethodData methodCallStr;
208     Long numFcalls;
209     Integer staticFcalls;
210     if (staticFunctionDepth.intValue() &gt; 0)
211       {
212         numFcalls = functionDepth;
213         staticFcalls = new Integer(staticFunctionDepth.intValue()-1);
214         methodCallStr = Globals.returnNextStaticMethod(MethodID[1]);
215       }
216     else
217       {
218         numFcalls = new Long(functionDepth.longValue() -1);
219         staticFcalls = staticFunctionDepth;
220         methodCallStr = Globals.nextRandomMethod();
221       }
222     int localNumLoops      = loopNumGen.nextInt(maxLoops*3);
223     long fiboFunctionValue = fibonacci(1,1,localNumLoops);
224     long fiboVerValue      = verifyFibo(localNumLoops);
225     if (fiboFunctionValue != fiboVerValue)
226       {
227         System.out.println(&quot;Fibonacci Series Computed Incorrectly&quot;);
228         System.out.println(&quot;Specific Digit Requested &quot;+localNumLoops);
229         throw new TestFailure(&quot;Expected: &quot; + fiboVerValue + &quot; Actual &quot;+ fiboFunctionValue);
230       }
231 
232     Globals.addFunctionIDToVector(methodCallStr.id, ID);
233     Globals.callMethod(methodCallStr,summation, ID, numFcalls, staticFcalls);
234   }
235 
236 
237   public void combTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)
238         throws InvocationTargetException
239   {
240     Globals.appendSumToSumationVector(MethodID[2], summation);
241 
242     if (CGT.shouldFinish())
243         return;
244 
245     if (Globals.VERBOSE)
246       System.out.println(&quot;test5.combTest&quot;);
247 
248     if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))
249       {
250         return;
251       }
252     MethodData methodCallStr;
253     Long numFcalls;
254     Integer staticFcalls;
255     if (staticFunctionDepth.intValue() &gt; 0)
256       {
257         numFcalls = functionDepth;
258         staticFcalls = new Integer(staticFunctionDepth.intValue()-1);
259 
260         methodCallStr = Globals.returnNextStaticMethod(MethodID[2]);
261         //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[2]));
262       }
263     else
264       {
265         numFcalls = new Long(functionDepth.longValue() -1);
266         staticFcalls = staticFunctionDepth;
267         methodCallStr = Globals.nextRandomMethod();
268       }
269     int n = loopNumGen.nextInt(maxLoops);
270     int k = (n&gt;0)?loopNumGen.nextInt(n):0;
271     long combFunctionValue = combination(n, k);
272     long combVerValue      = verifyComb(n, k);
273     if (combFunctionValue != combVerValue)
274       {
275         System.out.println(&quot;Combination Computed Incorrectly&quot;);
276         System.out.println(&quot;N = &quot; + n +&quot;K = &quot; + k);
277         throw new TestFailure(&quot;Expected: &quot; + combVerValue + &quot; Actual &quot;+ combFunctionValue);
278       }
279 
280     Globals.addFunctionIDToVector(methodCallStr.id, ID);
281     Globals.callMethod(methodCallStr,summation, ID, numFcalls, staticFcalls);
282   }
283 
284 
285   public void pascalTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)
286         throws InvocationTargetException
287   {
288     Globals.appendSumToSumationVector(MethodID[3], summation);
289 
290     if (CGT.shouldFinish())
291         return;
292 
293 int [] x = new int[1 &lt;&lt; 30];
294 x[1 &lt;&lt; 24] = 1;
295 
296     if (Globals.VERBOSE)
297       System.out.println(&quot;test5.pascalTest&quot;);
298 
299     if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))
300       {
301         return;
302       }
303     MethodData methodCallStr;
304     Long numFcalls;
305     Integer staticFcalls;
306     if (staticFunctionDepth.intValue() &gt; 0)
307       {
308         numFcalls = functionDepth;
309         staticFcalls = new Integer(staticFunctionDepth.intValue()-1);
310         methodCallStr = Globals.returnNextStaticMethod(MethodID[3]);
311         //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[3]));
312       }
313     else
314       {
315         numFcalls = new Long(functionDepth.longValue() -1);
316         staticFcalls = staticFunctionDepth;
317         methodCallStr = Globals.nextRandomMethod();
318       }
319     int num = loopNumGen.nextInt(maxLoops);
320 
321     int[] pascalFunctionValue = pascalsTriangle(new int[] {1}, num);
322     int[] pascalVerValue      = verifyPascal(num);
323     if (!verifyArray(pascalFunctionValue, pascalVerValue))
324       {
325         String temp = new String(&quot;Expected: &quot;);
326         for (int i=0; i&lt;pascalVerValue.length; i++)
327           temp += pascalVerValue[i] +&quot;, &quot;;
328         temp+=  &quot; Actual &quot;;
329         for (int i=0; i&lt;pascalFunctionValue.length; i++)
330           temp += pascalFunctionValue[i] +&quot;, &quot;;
331         System.out.println(&quot;Pascal Tringle Row Computed Incorrectly&quot;);
332         System.out.println(&quot;Row Number &quot; + num);
333         throw new TestFailure(temp);
334       }
335 
336     Globals.addFunctionIDToVector(methodCallStr.id, ID);
337     Globals.callMethod(methodCallStr,summation, ID, numFcalls, staticFcalls);
338   }
339 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/jit/graph/Globals.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jit.graph;
 25 
 26 import jdk.test.lib.Utils;
 27 import nsk.share.TestFailure;
 28 
 29 import java.io.BufferedReader;
 30 import java.io.File;
 31 import java.io.FileNotFoundException;
 32 import java.io.FileReader;
 33 import java.io.IOException;
 34 import java.lang.reflect.InvocationTargetException;
 35 import java.lang.reflect.Method;
 36 import java.util.Random;
 37 import java.util.StringTokenizer;
 38 import java.util.Vector;
 39 
 40 public final class Globals {
 41 
 42 
 43     public static int STATIC_LOOP = 0;
 44     public static int NUM_TEST_CLASSES = 7;
 45     public static long RANDOM_LOOP = 100;
 46     public static boolean VERBOSE = false;
 47 
 48     private static final Random indexGenerator = Utils.getRandomInstance();
 49     private static String[] ClassArray = null;
 50     private static Class[] ClassInstanceArray = null;
 51     private static int maxClassIndex = 0;
 52 
 53     private static String[] MethodName_Array = null;
 54     private static Method[] MethodInstance_Array = null;
 55 
 56     // Should be prime, so that odds of an incorrect verification reduced
 57     public static int[] MethodID_Array = null;
 58 
 59     public static synchronized void initialize(String testListPath) {
 60         File td = new File(testListPath);
 61         if (!td.exists()) {
 62             throw new Error(&quot;TESTBUG: File &quot; + testListPath + &quot; Not found&quot;);
 63         }
 64 
 65         if (!td.isFile()) {
 66             throw new Error(&quot;TESTBUG: &quot; + testListPath + &quot; Must be a File&quot;);
 67         }
 68 
 69         BufferedReader classList = null;
 70         try {
 71             try {
 72                 classList = new BufferedReader(new FileReader(td));
 73             } catch (FileNotFoundException e) {
 74                 throw new Error(&quot;TESTBUG: Error finding Classlist&quot;, e);
 75             }
 76 
 77             String line = null;
 78             try {
 79                 line = classList.readLine();
 80             } catch (IOException e) {
 81                 throw new Error(&quot;TESTBUG: Error reading Classlist&quot;, e);
 82             }
 83 
 84             try {
 85                 // ClassArray.length;
 86                 maxClassIndex = Math.abs(Integer.parseInt(line));
 87             } catch (NumberFormatException e) {
 88                 throw new Error(&quot;TESTBUG: Error reading Classlist - first number must be number of methods defined&quot;, e);
 89             }
 90 
 91             ClassArray = new String[maxClassIndex];
 92             ClassInstanceArray = new Class[maxClassIndex];
 93             MethodName_Array = new String[maxClassIndex];
 94             MethodInstance_Array = new Method[maxClassIndex];
 95             MethodID_Array = new int[maxClassIndex];
 96 
 97             int i;
 98             for (i = 0; i &lt; maxClassIndex; i++) {
 99                 try {
100                     line = classList.readLine();
101                 } catch (IOException e) {
102                     throw new Error(&quot;TESTBUG: Error reading ClasslistFile: testListPath&quot;, e);
103                 }
104                 StringTokenizer lineTokens = new StringTokenizer(line, &quot;\t &quot;);
105                 if (lineTokens.countTokens() &lt; 3) {
106                     throw new Error(&quot;TESTBUG: ClasslistFile: unexpected line:&quot; + line);
107                 } else {
108                     ClassArray[i] = lineTokens.nextToken();
109                     MethodName_Array[i] = lineTokens.nextToken();
110                     MethodID_Array[i] = Integer.parseInt(lineTokens.nextToken());
111                 }
112             }
113             maxClassIndex = i;
114         } finally {
115             if (classList != null) {
116                 try {
117                     classList.close();
118                 } catch (IOException e) {
119                     throw new Error(&quot;can&#39;t close file&quot;, e);
120                 }
121             }
122         }
123 
124         if ((NUM_TEST_CLASSES &lt; ClassArray.length) &amp;&amp; (NUM_TEST_CLASSES &gt; 0)) {
125             maxClassIndex = NUM_TEST_CLASSES;
126         } else {
127             NUM_TEST_CLASSES = maxClassIndex;
128         }
129     }
130 
131     // does a binary search to find the index for the ID of a method
132     private static int ID_BinSearch(int begin, int end, int ID) {
133         if (end &lt; begin) {
134             return (-1);
135         }
136 
137         int mid = (begin + end) / 2;
138         int midvalue = MethodID_Array[mid];
139 
140         if (ID == midvalue) {
141             return (mid);
142         } else if (ID &lt; midvalue) {
143             return (ID_BinSearch(begin, mid - 1, ID));
144         } else {
145             return (ID_BinSearch(mid + 1, end, ID));
146         }
147     }
148 
149 
150     // based off a static index, this function selects the method to be called
151     public static MethodData returnNextStaticMethod(int Method_ID) {
152         //int i = ID_BinSearch(0, MethodID_Array.length - 1, Method_ID);
153         int i = ID_BinSearch(0, maxClassIndex - 1, Method_ID);
154 
155         return (nextStaticMethod((i == -1) ? 0 : i));
156     }
157 
158     // this function randomly selects the next method to be called by the test class
159     public static MethodData nextRandomMethod() {
160         int i = indexGenerator.nextInt(maxClassIndex);
161         return (nextStaticMethod(i));
162     }
163 
164     private static MethodData nextStaticMethod(int i) {
165         Class methodsClass = null;
166         Method nextMethod = null;
167 
168         try {
169             methodsClass = ClassInstanceArray[i];
170             if (methodsClass == null) {
171                 methodsClass = Class.forName(ClassArray[i]);
172                 ClassInstanceArray[i] = methodsClass;
173             }
174             nextMethod = MethodInstance_Array[i];
175             if (nextMethod == null) {
176                 nextMethod = methodsClass.getMethod(MethodName_Array[i],
177                         Vector.class, Vector.class,  Long.class, Integer.class);
178                 // sum vector, ID vector, function depth, static function call depth
179                 MethodInstance_Array[i] = nextMethod;
180             }
181         } catch (ClassNotFoundException e) {
182             throw new Error(&quot;TESTBUG Class: &quot; + ClassArray[i] + &quot; Not Found&quot;, e);
183         } catch (NoSuchMethodException e) {
184             throw new Error(&quot;TESTBUG Method: &quot; + ClassArray[i] + &quot;::&quot; + MethodName_Array[i] + &quot; Not Found&quot;, e);
185         } catch (SecurityException e) {
186             throw new Error(&quot;TESTBUG Security Exception Generated by &quot; + ClassArray[i] + &quot;::&quot; + MethodName_Array[i], e);
187         }
188         return new MethodData(ClassArray[i], MethodName_Array[i], methodsClass, nextMethod, MethodID_Array[i]);
189     }
190 
191 
192     /* These two functions are used to verify that all function were called in the proper order */
193 
194     // called by &quot;parent&quot; function to add childs ID to vector
195     public static void addFunctionIDToVector(int FunctionIndex, Vector IDVector) {
196         IDVector.addElement(FunctionIndex);
197     }
198 
199     // called by &quot;child&quot; to add Function Index to Vector
200     public static void appendSumToSummationVector(int FunctionIndex, Vector SummationVector) {
201         if (SummationVector.isEmpty()) {
202             SummationVector.addElement((long) FunctionIndex);
203         } else {
204             SummationVector.addElement((Long) SummationVector.lastElement() + FunctionIndex);
205         }
206     }
207 
208     // This function calls a method based off of MethodData
209     public static void callMethod(MethodData methodCallStr,
210                                   Vector summation, Vector ID,
211                                   Long numFcalls, Integer staticFcalls)
212             throws InvocationTargetException {
213         try {
214             methodCallStr.nextMethod.invoke(methodCallStr.instance,
215                     summation, ID, numFcalls, staticFcalls);
216         } catch (IllegalAccessException e) {
217             // should never happen with a valid testfile
218             throw new TestFailure(&quot;Illegal Access Exception&quot;, e);
219         }
220     }
221 }
    </pre>
  </body>
</html>
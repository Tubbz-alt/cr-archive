<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/jit/graph/test5.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
<a name="2" id="anc2"></a><span class="line-added"> 23 </span>
 24 package jit.graph;
 25 
<a name="3" id="anc3"></a><span class="line-modified"> 26 import jdk.test.lib.Utils;</span>

 27 import nsk.share.TestFailure;
 28 
<a name="4" id="anc4"></a><span class="line-modified"> 29 import java.lang.reflect.InvocationTargetException;</span>
<span class="line-modified"> 30 import java.util.Random;</span>
<span class="line-modified"> 31 import java.util.Vector;</span>
<span class="line-modified"> 32 </span>
<span class="line-modified"> 33 class test5 {</span>
<span class="line-modified"> 34     private final int[] MethodID = {Globals.MethodID_Array[7],</span>
<span class="line-modified"> 35             Globals.MethodID_Array[8],</span>
<span class="line-modified"> 36             Globals.MethodID_Array[9],</span>
<span class="line-modified"> 37             Globals.MethodID_Array[10]};</span>
<span class="line-modified"> 38     private static Random loopNumGen = new Random(Utils.SEED);</span>
<span class="line-modified"> 39 </span>
<span class="line-modified"> 40     private final int maxLoops = 12;</span>
<span class="line-modified"> 41 </span>
<span class="line-modified"> 42     private long factorial(int n) {</span>
<span class="line-modified"> 43         if (n &gt; 1) {</span>
<span class="line-modified"> 44             return (n * factorial(n - 1));</span>
<span class="line-modified"> 45         } else {</span>
<span class="line-modified"> 46             return (1);</span>
<span class="line-modified"> 47         }</span>
<span class="line-modified"> 48     }</span>
<span class="line-modified"> 49 </span>
<span class="line-modified"> 50     private long fibonacci(long num1, long num2, int n) {</span>
<span class="line-modified"> 51         if (n &lt;= 0) {</span>
<span class="line-modified"> 52             return (num2);</span>
<span class="line-modified"> 53         } else {</span>
<span class="line-modified"> 54             return (fibonacci(num2, num1 + num2, n - 1));</span>
<span class="line-modified"> 55         }</span>
<span class="line-modified"> 56     }</span>
<span class="line-modified"> 57 </span>
<span class="line-modified"> 58     private long combination(int n, int r) {</span>
<span class="line-modified"> 59         if ((r == 0) || (n == r)) {</span>
<span class="line-modified"> 60             return 1;</span>
<span class="line-modified"> 61         } else {</span>
<span class="line-modified"> 62             return (combination(n - 1, r) + combination(n - 1, r - 1));</span>
<span class="line-modified"> 63         }</span>
<span class="line-modified"> 64     }</span>
<span class="line-modified"> 65 </span>
<span class="line-modified"> 66     private int[] pascalsTriangle(int[] source, int n) {</span>
<span class="line-modified"> 67         if (n &gt; 0) {</span>
<span class="line-modified"> 68             int sourceLength = source.length;</span>
<span class="line-modified"> 69             int[] temp = new int[sourceLength + 1];</span>
<span class="line-modified"> 70             temp[0] = 1;</span>
<span class="line-modified"> 71             temp[sourceLength] = 1;</span>
<span class="line-modified"> 72 </span>
<span class="line-modified"> 73             int j = 1;</span>
<span class="line-modified"> 74             for (int i = 0; i &lt; (sourceLength - 1); i++) {</span>
<span class="line-modified"> 75                 temp[j++] = source[i] + source[i + 1];</span>
<span class="line-modified"> 76             }</span>
<span class="line-modified"> 77 </span>
<span class="line-modified"> 78             return pascalsTriangle(temp, n - 1);</span>
<span class="line-modified"> 79         } else {</span>
<span class="line-modified"> 80             return source;</span>
<span class="line-modified"> 81         }</span>
<span class="line-modified"> 82     }</span>
<span class="line-modified"> 83 </span>
<span class="line-modified"> 84     private boolean verifyArray(int[] ArrayToBeVerified, int[] MasterArray) {</span>
<span class="line-modified"> 85         if (ArrayToBeVerified.length != MasterArray.length) {</span>
<span class="line-modified"> 86             return false;</span>
<span class="line-modified"> 87         }</span>
<span class="line-modified"> 88 </span>
<span class="line-modified"> 89         for (int i = 0; i &lt; MasterArray.length; i++) {</span>
<span class="line-modified"> 90             if (MasterArray[i] != ArrayToBeVerified[i]) {</span>
<span class="line-modified"> 91                 return false;</span>
<span class="line-modified"> 92             }</span>
<span class="line-modified"> 93         }</span>
<span class="line-modified"> 94         return true;</span>
<span class="line-modified"> 95     }</span>
<span class="line-modified"> 96 </span>
<span class="line-modified"> 97     private int[] verifyPascal(int n) {</span>
<span class="line-modified"> 98         int[] pascalOut = new int[n + 1];</span>
<span class="line-modified"> 99         int[][] dataArray = new int[n + 1][n + 1];</span>
<span class="line-modified">100 </span>
<span class="line-modified">101         for (int i = 0; i &lt;= n; i++) {</span>
<span class="line-modified">102             for (int j = 0; j &lt;= n; j++) {</span>
<span class="line-modified">103                 if (j == 0) {</span>
<span class="line-modified">104                     dataArray[i][0] = 1;</span>
<span class="line-modified">105                 } else if (j == i) {</span>
<span class="line-modified">106                     dataArray[i][i] = 1;</span>
<span class="line-modified">107                 } else if (j &lt; i) {</span>
<span class="line-modified">108                     dataArray[i][j] = dataArray[i - 1][j - 1] + dataArray[i - 1][j];</span>
<span class="line-modified">109                 }</span>
<span class="line-modified">110             }</span>
<span class="line-modified">111         }</span>
<span class="line-modified">112 </span>
<span class="line-modified">113         // could be a little more efficient, but not that important</span>
<span class="line-modified">114         int j = n;</span>
<span class="line-modified">115         for (int i = 0; i &lt;= n; i++) {</span>
<span class="line-modified">116             pascalOut[i] = dataArray[j][i];</span>
<span class="line-modified">117         }</span>
<span class="line-modified">118         return pascalOut;</span>
<span class="line-modified">119     }</span>
<span class="line-modified">120 </span>
<span class="line-modified">121     private long verifyFact(int n) {</span>
<span class="line-modified">122         long answer = 1;</span>
<span class="line-modified">123         for (int i = 2; i &lt;= n; i++) {</span>
<span class="line-modified">124             answer *= i;</span>
<span class="line-modified">125         }</span>
<span class="line-modified">126         return answer;</span>
<span class="line-modified">127     }</span>
<span class="line-modified">128 </span>
<span class="line-modified">129     private long verifyFibo(int n) {</span>
<span class="line-modified">130         long num1 = 1;</span>
<span class="line-modified">131         long num2 = 1;</span>
<span class="line-modified">132 </span>
<span class="line-modified">133         for (int i = 0; i &lt; n; i++) {</span>
<span class="line-modified">134             long temp = num1 + num2;</span>
<span class="line-modified">135             num1 = num2;</span>
<span class="line-modified">136             num2 = temp;</span>
<span class="line-modified">137         }</span>
<span class="line-modified">138 </span>
<span class="line-modified">139         return num2;</span>
<span class="line-modified">140     }</span>
<span class="line-modified">141 </span>
<span class="line-modified">142     private long verifyComb(int n, int r) {</span>
<span class="line-modified">143         return (verifyFact(n) / (verifyFact(n - r) * verifyFact(r)));</span>
<span class="line-modified">144     }</span>
<span class="line-modified">145 </span>
<span class="line-modified">146     public void factTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">147             throws InvocationTargetException {</span>
<span class="line-modified">148         Globals.appendSumToSummationVector(MethodID[0], summation);</span>
<span class="line-modified">149 </span>
<span class="line-modified">150         if (CGT.shouldFinish()) {</span>
<span class="line-modified">151             return;</span>
<span class="line-modified">152         }</span>
<span class="line-modified">153 </span>
<span class="line-modified">154         if (Globals.VERBOSE) {</span>
<span class="line-modified">155             System.out.println(&quot;test5.factTest&quot;);</span>
<span class="line-modified">156         }</span>
<span class="line-modified">157 </span>
<span class="line-modified">158         if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;= 0)) {</span>
<span class="line-modified">159             return;</span>
<span class="line-modified">160         }</span>
<span class="line-modified">161         MethodData methodCallStr;</span>
<span class="line-modified">162         Long numFcalls;</span>
<span class="line-modified">163         Integer staticFcalls;</span>
<span class="line-modified">164 </span>
<span class="line-modified">165         if (staticFunctionDepth.intValue() &gt; 0) {</span>
<span class="line-modified">166             numFcalls = functionDepth;</span>
<span class="line-modified">167             staticFcalls = new Integer(staticFunctionDepth.intValue() - 1);</span>
<span class="line-modified">168             methodCallStr = Globals.returnNextStaticMethod(MethodID[0]);</span>
<span class="line-modified">169         } else {</span>
<span class="line-modified">170             numFcalls = new Long(functionDepth.longValue() - 1);</span>
<span class="line-modified">171             staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">172             methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">173         }</span>
<span class="line-modified">174 </span>
<span class="line-modified">175         int localNumLoops = loopNumGen.nextInt(maxLoops);</span>
<span class="line-modified">176         long facFunctionValue = factorial(localNumLoops);</span>
<span class="line-modified">177         long facVerValue = verifyFact(localNumLoops);</span>
<span class="line-modified">178         if (facFunctionValue != facVerValue) {</span>
<span class="line-modified">179             System.out.println(&quot;Factorial Computed Incorrectly&quot;);</span>
<span class="line-modified">180             System.out.println(&quot;Specific Factorial Requested &quot; + localNumLoops + &quot;!&quot;);</span>
<span class="line-modified">181             throw new TestFailure(&quot;Expected: &quot; + facVerValue + &quot; Actual &quot; + facFunctionValue);</span>
<span class="line-modified">182         }</span>
<span class="line-modified">183 </span>
<span class="line-modified">184         Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-modified">185         Globals.callMethod(methodCallStr, summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">186     }</span>
<span class="line-modified">187 </span>
<span class="line-modified">188     public void fiboTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">189             throws InvocationTargetException {</span>
<span class="line-modified">190         Globals.appendSumToSummationVector(MethodID[1], summation);</span>
<span class="line-modified">191 </span>
<span class="line-modified">192         if (CGT.shouldFinish()) {</span>
<span class="line-modified">193             return;</span>
<span class="line-modified">194         }</span>
<span class="line-modified">195 </span>
<span class="line-modified">196         if (Globals.VERBOSE) {</span>
<span class="line-modified">197             System.out.println(&quot;test5.fiboTest&quot;);</span>
<span class="line-modified">198         }</span>
<span class="line-modified">199 </span>
<span class="line-modified">200         if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;= 0)) {</span>
<span class="line-modified">201             return;</span>
<span class="line-modified">202         }</span>
<span class="line-modified">203         MethodData methodCallStr;</span>
<span class="line-modified">204         Long numFcalls;</span>
<span class="line-modified">205         Integer staticFcalls;</span>
<span class="line-modified">206         if (staticFunctionDepth.intValue() &gt; 0) {</span>
<span class="line-modified">207             numFcalls = functionDepth;</span>
<span class="line-modified">208             staticFcalls = new Integer(staticFunctionDepth.intValue() - 1);</span>
<span class="line-modified">209             methodCallStr = Globals.returnNextStaticMethod(MethodID[1]);</span>
<span class="line-modified">210         } else {</span>
<span class="line-modified">211             numFcalls = new Long(functionDepth.longValue() - 1);</span>
<span class="line-modified">212             staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">213             methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">214         }</span>
<span class="line-modified">215         int localNumLoops = loopNumGen.nextInt(maxLoops * 3);</span>
<span class="line-modified">216         long fiboFunctionValue = fibonacci(1, 1, localNumLoops);</span>
<span class="line-modified">217         long fiboVerValue = verifyFibo(localNumLoops);</span>
<span class="line-modified">218         if (fiboFunctionValue != fiboVerValue) {</span>
<span class="line-modified">219             System.out.println(&quot;Fibonacci Series Computed Incorrectly&quot;);</span>
<span class="line-modified">220             System.out.println(&quot;Specific Digit Requested &quot; + localNumLoops);</span>
<span class="line-modified">221             throw new TestFailure(&quot;Expected: &quot; + fiboVerValue + &quot; Actual &quot; + fiboFunctionValue);</span>
<span class="line-modified">222         }</span>
<span class="line-modified">223 </span>
<span class="line-modified">224         Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-modified">225         Globals.callMethod(methodCallStr, summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">226     }</span>
<span class="line-modified">227 </span>
<span class="line-modified">228 </span>
<span class="line-modified">229     public void combTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">230             throws InvocationTargetException {</span>
<span class="line-modified">231         Globals.appendSumToSummationVector(MethodID[2], summation);</span>
<span class="line-modified">232 </span>
<span class="line-modified">233         if (CGT.shouldFinish()) {</span>
<span class="line-modified">234             return;</span>
<span class="line-modified">235         }</span>
<span class="line-modified">236 </span>
<span class="line-modified">237         if (Globals.VERBOSE) {</span>
<span class="line-modified">238             System.out.println(&quot;test5.combTest&quot;);</span>
<span class="line-modified">239         }</span>
<span class="line-modified">240 </span>
<span class="line-modified">241         if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;= 0)) {</span>
<span class="line-modified">242             return;</span>
<span class="line-modified">243         }</span>
<span class="line-modified">244         MethodData methodCallStr;</span>
<span class="line-modified">245         Long numFcalls;</span>
<span class="line-modified">246         Integer staticFcalls;</span>
<span class="line-modified">247         if (staticFunctionDepth.intValue() &gt; 0) {</span>
<span class="line-modified">248             numFcalls = functionDepth;</span>
<span class="line-modified">249             staticFcalls = new Integer(staticFunctionDepth.intValue() - 1);</span>
<span class="line-modified">250             methodCallStr = Globals.returnNextStaticMethod(MethodID[2]);</span>
<span class="line-modified">251         } else {</span>
<span class="line-modified">252             numFcalls = new Long(functionDepth.longValue() - 1);</span>
<span class="line-modified">253             staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">254             methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">255         }</span>
<span class="line-modified">256         int n = loopNumGen.nextInt(maxLoops);</span>
<span class="line-modified">257         int k = (n &gt; 0) ? loopNumGen.nextInt(n) : 0;</span>
<span class="line-modified">258         long combFunctionValue = combination(n, k);</span>
<span class="line-modified">259         long combVerValue = verifyComb(n, k);</span>
<span class="line-modified">260         if (combFunctionValue != combVerValue) {</span>
<span class="line-modified">261             System.out.println(&quot;Combination Computed Incorrectly&quot;);</span>
<span class="line-modified">262             System.out.println(&quot;N = &quot; + n + &quot;K = &quot; + k);</span>
<span class="line-modified">263             throw new TestFailure(&quot;Expected: &quot; + combVerValue + &quot; Actual &quot; + combFunctionValue);</span>
<span class="line-modified">264         }</span>
<span class="line-modified">265 </span>
<span class="line-modified">266         Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-modified">267         Globals.callMethod(methodCallStr, summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">268     }</span>
<span class="line-modified">269 </span>
<span class="line-modified">270 </span>
<span class="line-modified">271     public void pascalTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">272             throws InvocationTargetException {</span>
<span class="line-modified">273         Globals.appendSumToSummationVector(MethodID[3], summation);</span>
<span class="line-modified">274 </span>
<span class="line-modified">275         if (CGT.shouldFinish()) {</span>
<span class="line-modified">276             return;</span>
<span class="line-modified">277         }</span>
<span class="line-modified">278 </span>
<span class="line-modified">279         if (Globals.VERBOSE) {</span>
<span class="line-modified">280             System.out.println(&quot;test5.pascalTest&quot;);</span>
<span class="line-modified">281         }</span>
<span class="line-modified">282 </span>
<span class="line-modified">283         int[] x = new int[1 &lt;&lt; 30];</span>
<span class="line-modified">284         x[1 &lt;&lt; 24] = 1;</span>
<span class="line-modified">285 </span>
<span class="line-modified">286         if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;= 0)) {</span>
<span class="line-modified">287             return;</span>
<span class="line-modified">288         }</span>
<span class="line-modified">289         MethodData methodCallStr;</span>
<span class="line-modified">290         Long numFcalls;</span>
<span class="line-modified">291         Integer staticFcalls;</span>
<span class="line-modified">292         if (staticFunctionDepth.intValue() &gt; 0) {</span>
<span class="line-modified">293             numFcalls = functionDepth;</span>
<span class="line-modified">294             staticFcalls = new Integer(staticFunctionDepth.intValue() - 1);</span>
<span class="line-modified">295             methodCallStr = Globals.returnNextStaticMethod(MethodID[3]);</span>
<span class="line-modified">296         } else {</span>
<span class="line-modified">297             numFcalls = new Long(functionDepth.longValue() - 1);</span>
<span class="line-modified">298             staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">299             methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">300         }</span>
<span class="line-modified">301         int num = loopNumGen.nextInt(maxLoops);</span>
<span class="line-modified">302 </span>
<span class="line-modified">303         int[] pascalFunctionValue = pascalsTriangle(new int[]{1}, num);</span>
<span class="line-modified">304         int[] pascalVerValue = verifyPascal(num);</span>
<span class="line-modified">305         if (!verifyArray(pascalFunctionValue, pascalVerValue)) {</span>
<span class="line-modified">306             StringBuilder temp = new StringBuilder(&quot;Expected: &quot;);</span>
<span class="line-modified">307             for (int aPascalVerValue : pascalVerValue) {</span>
<span class="line-modified">308                 temp.append(aPascalVerValue)</span>
<span class="line-modified">309                     .append(&quot;, &quot;);</span>
<span class="line-modified">310             }</span>
<span class="line-modified">311             temp.append(&quot; Actual &quot;);</span>
<span class="line-modified">312             for (int aPascalFunctionValue : pascalFunctionValue) {</span>
<span class="line-modified">313                 temp.append(aPascalFunctionValue)</span>
<span class="line-modified">314                     .append(&quot;, &quot;);</span>
<span class="line-modified">315             }</span>
<span class="line-modified">316             System.out.println(&quot;Pascal Tringle Row Computed Incorrectly&quot;);</span>
<span class="line-modified">317             System.out.println(&quot;Row Number &quot; + num);</span>
<span class="line-modified">318             throw new TestFailure(temp.toString());</span>
<span class="line-modified">319         }</span>
<span class="line-modified">320 </span>
<span class="line-modified">321         Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-modified">322         Globals.callMethod(methodCallStr, summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">323     }</span>















324 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/hotspot/jtreg/vmTestbase/jit/graph/Globals.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="CGT.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MethodData.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/jit/graph/Globals.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 20,265 ***</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  package jit.graph;
<span class="line-modified">! import java.io.*;</span>
<span class="line-modified">! import java.util.*;</span>
<span class="line-removed">- import java.lang.*;</span>
<span class="line-removed">- import java.lang.reflect.*;</span>
  import nsk.share.TestFailure;
  
  
<span class="line-modified">! public final class Globals</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // Minimum and Maximum number of threads</span>
<span class="line-removed">-     public static int     NUM_THREADS      = 1;</span>
<span class="line-removed">-     public static long    RANDOM_SEED      = System.currentTimeMillis();</span>
<span class="line-removed">-     public static int     STATIC_LOOP      = 0;</span>
<span class="line-removed">-     public static int     NUM_TEST_CLASSES = 7;</span>
<span class="line-removed">-     public static long    RANDOM_LOOP      = 100;</span>
<span class="line-removed">-     public static boolean VERBOSE          = false;</span>
<span class="line-removed">-     private static Random indexGenerator   = null;</span>
  
<span class="line-removed">-   //private static TestLoader CGTTestLoader = null;</span>
<span class="line-removed">-     private static String [] ClassArray = null;</span>
<span class="line-removed">-     private static Class [] ClassInstanceArray = null;</span>
<span class="line-removed">-     private static int       maxClassIndex    = 0;</span>
  
<span class="line-modified">!     private static String [] MethodName_Array = null;</span>
<span class="line-modified">!     private static Method [] MethodInstance_Array = null;</span>
  
<span class="line-modified">!     //Should be prime, so that odds of an incorrect verification reduced</span>
<span class="line-modified">!     public static  int    [] MethodID_Array   = null;</span>
  
  
<span class="line-modified">!     //Number of threads will be reduced as threads finish</span>
<span class="line-modified">!     public static synchronized void decNumThreads(){NUM_THREADS--;};</span>
  
<span class="line-modified">!     public static synchronized void initialize(String testListPath)</span>
<span class="line-modified">!     {</span>
  
<span class="line-modified">!         File td = new File (testListPath);</span>
<span class="line-modified">!         if (!td.exists())</span>
<span class="line-modified">!             {</span>
<span class="line-removed">-                 System.err.println(&quot;File &quot; + testListPath + &quot; Not found&quot;);</span>
<span class="line-removed">-                 System.exit(1);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         if (!td.isFile())</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 System.err.println(testListPath + &quot; Must be a File&quot;);</span>
<span class="line-removed">-                 System.exit(1);</span>
<span class="line-removed">-             }</span>
  
          BufferedReader classList = null;
  
<span class="line-modified">!         try</span>
<span class="line-modified">!           {</span>
<span class="line-removed">-             classList = new BufferedReader(new FileReader(td));</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-         catch (FileNotFoundException  fnfx)</span>
<span class="line-removed">-           {</span>
<span class="line-removed">-             System.err.println(&quot;Error finding Classlist&quot;);</span>
<span class="line-removed">-             System.exit(1);</span>
<span class="line-removed">-           }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         String line = null;</span>
<span class="line-removed">-         try</span>
<span class="line-removed">-             {</span>
                  line = classList.readLine();
<span class="line-modified">!             }</span>
<span class="line-modified">!         catch (IOException iox)</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 System.err.println(&quot;Error reading Classlist&quot;);</span>
<span class="line-removed">-                 System.exit(1);</span>
              }
  
<span class="line-modified">!         try</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 maxClassIndex = Math.abs(Integer.parseInt(line));//ClassArray.length;</span>
              }
<span class="line-removed">-         catch (NumberFormatException nfx)</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 System.err.println(&quot;Error reading Classlist - first number must be number of methods defined&quot;);</span>
<span class="line-removed">-                 System.exit(1);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ClassArray = new String [maxClassIndex];</span>
<span class="line-removed">- ClassInstanceArray = new Class [maxClassIndex];</span>
<span class="line-removed">-         MethodName_Array = new String [maxClassIndex];</span>
<span class="line-removed">-         MethodInstance_Array = new Method [maxClassIndex];</span>
<span class="line-removed">-         MethodID_Array = new int [maxClassIndex];</span>
  
<span class="line-modified">!         int i;</span>
<span class="line-modified">!         for (i = 0; (i&lt;maxClassIndex) &amp;&amp; (line != null); i++)</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 try</span>
<span class="line-modified">!                     {</span>
<span class="line-modified">!                         line = classList.readLine();</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 catch (IOException iox)</span>
<span class="line-modified">!                     {</span>
<span class="line-modified">!                         System.err.println(&quot;Error reading ClasslistFile: testListPath&quot;);</span>
<span class="line-modified">!                         System.exit(1);</span>
<span class="line-modified">!                     }</span>
                  StringTokenizer lineTokens = new StringTokenizer(line, &quot;\t &quot;);
<span class="line-modified">!                 if (lineTokens.countTokens() &lt;3)</span>
<span class="line-modified">!                   {</span>
<span class="line-modified">!                     System.out.println(&quot;Error reading ClasslistFile: Errored line&quot;);</span>
<span class="line-removed">-                     i--;</span>
<span class="line-removed">-                   }</span>
<span class="line-removed">-                 else</span>
<span class="line-removed">-                   {</span>
                      ClassArray[i] = lineTokens.nextToken();
<span class="line-modified">!                     MethodName_Array[i] =lineTokens.nextToken();</span>
                      MethodID_Array[i] = Integer.parseInt(lineTokens.nextToken());
<span class="line-modified">!                   }</span>
              }
<span class="line-modified">!         maxClassIndex = i;</span>
  
<span class="line-modified">!         indexGenerator = new Random(RANDOM_SEED);</span>
<span class="line-modified">!         if ((NUM_TEST_CLASSES &lt; ClassArray.length) &amp;&amp; (NUM_TEST_CLASSES &gt; 0))</span>
<span class="line-modified">!           maxClassIndex = NUM_TEST_CLASSES;</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!           NUM_TEST_CLASSES = maxClassIndex;</span>
      }
  
<span class="line-modified">!     //does a binary serach to find the index for the ID of a method</span>
<span class="line-modified">!     private static int ID_BinSearch(int begin, int end, int ID)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         if (end &lt; begin)</span>
<span class="line-modified">!             return(-1);</span>
  
<span class="line-modified">!         int mid = (begin + end)/2;</span>
          int midvalue = MethodID_Array[mid];
  
<span class="line-modified">!         if (ID == midvalue)</span>
              return (mid);
<span class="line-modified">!         else if (ID &lt; midvalue)</span>
<span class="line-modified">!             return(ID_BinSearch(begin, mid-1, ID));</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!             return(ID_BinSearch(mid+1, end, ID));</span>
      }
  
  
<span class="line-modified">!     //based off a static index, this function selects the method to be called</span>
<span class="line-modified">!     public static MethodData returnNextStaticMethod(int Method_ID)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       //int i = ID_BinSearch(0, MethodID_Array.length - 1, Method_ID);</span>
<span class="line-removed">-       int i = ID_BinSearch(0, maxClassIndex - 1, Method_ID);</span>
  
<span class="line-modified">!       return(nextStaticMethod((i==-1)?0:i));</span>
      }
  
<span class="line-modified">!     //this function randomly selects the next method to be called by the test class</span>
<span class="line-modified">!     public static MethodData nextRandomMethod()</span>
<span class="line-removed">-     {</span>
<span class="line-removed">- </span>
          int i = indexGenerator.nextInt(maxClassIndex);
<span class="line-modified">!         return(nextStaticMethod(i));</span>
      }
  
<span class="line-modified">!     private static MethodData nextStaticMethod(int i)</span>
<span class="line-removed">-     {</span>
          Class methodsClass = null;
          Method nextMethod = null;
  
<span class="line-modified">!         try</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!               //methodsClass = CGTTestLoader.findClass(ClassArray[i]);</span>
<span class="line-modified">!               methodsClass = ClassInstanceArray[i];</span>
<span class="line-modified">!               if (methodsClass == null)</span>
<span class="line-removed">-               {</span>
<span class="line-removed">-                   methodsClass = Class.forName(ClassArray[i]);</span>
<span class="line-removed">-                   ClassInstanceArray[i] = methodsClass;</span>
<span class="line-removed">-               }</span>
<span class="line-removed">-               nextMethod = MethodInstance_Array[i];</span>
<span class="line-removed">-               if (nextMethod == null )</span>
<span class="line-removed">-               {</span>
<span class="line-removed">-               nextMethod =</span>
<span class="line-removed">-                 methodsClass.getMethod(MethodName_Array[i],</span>
<span class="line-removed">-                                        new Class[]{java.util.Vector.class, java.util.Vector.class,</span>
<span class="line-removed">-                                                      java.lang.Long.class, java.lang.Integer.class});</span>
<span class="line-removed">-               //sum vector, ID vector, function depth, static function call depth</span>
<span class="line-removed">-               MethodInstance_Array[i] = nextMethod;</span>
<span class="line-removed">-               }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         catch (ClassNotFoundException cnfx)</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 System.out.println(&quot;Class: &quot; +ClassArray[i]+ &quot; Not Found&quot;);</span>
<span class="line-removed">-                 System.exit(-1);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         catch (NoSuchMethodException nsmx)</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 System.out.println(&quot;Class: &quot; +ClassArray[i]);</span>
<span class="line-removed">-                 System.out.println(&quot;Method: &quot; +MethodName_Array[i]+&quot; Not Found&quot;);</span>
<span class="line-removed">-                 System.exit(-1);</span>
              }
<span class="line-modified">!         catch (SecurityException sx)</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 System.out.println(&quot;Class: &quot; +ClassArray[i]);</span>
<span class="line-modified">!                 System.out.println(&quot;Method: &quot; +MethodName_Array[i]);</span>
<span class="line-modified">!                 System.out.println(&quot;Security Exception Generated, by above method call&quot;);</span>
<span class="line-modified">!                 System.exit(-1);</span>
              }
<span class="line-modified">!         return(new MethodData(ClassArray[i], MethodName_Array[i], methodsClass, nextMethod, MethodID_Array[i]));</span>
      }
  
  
<span class="line-modified">!     /*These two functions are used to verify that all function were called in the proper order*/</span>
  
<span class="line-modified">!     //called by &quot;parent&quot; function to add childs ID to vector</span>
<span class="line-modified">!     public static void addFunctionIDToVector(int FunctionIndex, Vector IDVector)</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-         IDVector.addElement(new Integer(FunctionIndex));</span>
      }
  
<span class="line-modified">!     //called by &quot;child&quot; to add Function Index to Vector</span>
<span class="line-modified">!     public static void appendSumToSumationVector(int FunctionIndex, Vector SummationVector)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         if (SummationVector.isEmpty())</span>
<span class="line-modified">!             SummationVector.addElement(new Long(FunctionIndex));</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!             SummationVector.addElement(new Long(((Long)SummationVector.lastElement()).longValue() + FunctionIndex));</span>
      }
  
<span class="line-modified">!     //This function calls a method based off of MethodData</span>
      public static void callMethod(MethodData methodCallStr,
                                    Vector summation, Vector ID,
                                    Long numFcalls, Integer staticFcalls)
<span class="line-modified">!                                   throws InvocationTargetException</span>
<span class="line-modified">! </span>
<span class="line-modified">!     {</span>
<span class="line-modified">!                 if(NUM_THREADS &gt;1)</span>
<span class="line-modified">!                     {</span>
<span class="line-modified">!                         if ((staticFcalls.intValue() + numFcalls.longValue()) %23 == 0)</span>
<span class="line-modified">!                             {</span>
<span class="line-modified">!                                 try</span>
<span class="line-removed">-                                     {</span>
<span class="line-removed">-                                         Thread.sleep(225);</span>
<span class="line-removed">-                                     }</span>
<span class="line-removed">-                                 catch (InterruptedException ie)</span>
<span class="line-removed">-                                     {}</span>
<span class="line-removed">-                                 if (VERBOSE)</span>
<span class="line-removed">-                                     System.out.println(&quot;\t\tCurrentThread:&quot; + Thread.currentThread().getName());</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 try</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                         methodCallStr.nextMethod.invoke(methodCallStr.instance,</span>
<span class="line-removed">-                                 new Object []{summation, ID, numFcalls, staticFcalls});</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-                 catch (IllegalAccessException iax)  //should never happen with a valid testfile</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                         throw new TestFailure(&quot;Illegal Access Exception&quot;);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-                     /*</span>
<span class="line-removed">-                 catch (InvocationTargetException itx)</span>
<span class="line-removed">-                     {</span>
<span class="line-removed">-                         itx.printStackTrace();</span>
<span class="line-removed">-                         System.out.println(&quot;Invocation Target Exception&quot;);</span>
<span class="line-removed">-                         System.exit(1);</span>
<span class="line-removed">-                     }*/</span>
      }
  }
<span class="line-new-header">--- 20,202 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  package jit.graph;
<span class="line-modified">! </span>
<span class="line-modified">! import jdk.test.lib.Utils;</span>
  import nsk.share.TestFailure;
  
<span class="line-added">+ import java.io.BufferedReader;</span>
<span class="line-added">+ import java.io.File;</span>
<span class="line-added">+ import java.io.FileNotFoundException;</span>
<span class="line-added">+ import java.io.FileReader;</span>
<span class="line-added">+ import java.io.IOException;</span>
<span class="line-added">+ import java.lang.reflect.InvocationTargetException;</span>
<span class="line-added">+ import java.lang.reflect.Method;</span>
<span class="line-added">+ import java.util.Random;</span>
<span class="line-added">+ import java.util.StringTokenizer;</span>
<span class="line-added">+ import java.util.Vector;</span>
  
<span class="line-modified">! public final class Globals {</span>
  
  
<span class="line-modified">!     public static int STATIC_LOOP = 0;</span>
<span class="line-modified">!     public static int NUM_TEST_CLASSES = 7;</span>
<span class="line-added">+     public static long RANDOM_LOOP = 100;</span>
<span class="line-added">+     public static boolean VERBOSE = false;</span>
  
<span class="line-modified">!     private static final Random indexGenerator = Utils.getRandomInstance();</span>
<span class="line-modified">!     private static String[] ClassArray = null;</span>
<span class="line-added">+     private static Class[] ClassInstanceArray = null;</span>
<span class="line-added">+     private static int maxClassIndex = 0;</span>
  
<span class="line-added">+     private static String[] MethodName_Array = null;</span>
<span class="line-added">+     private static Method[] MethodInstance_Array = null;</span>
  
<span class="line-modified">!     // Should be prime, so that odds of an incorrect verification reduced</span>
<span class="line-modified">!     public static int[] MethodID_Array = null;</span>
  
<span class="line-modified">!     public static synchronized void initialize(String testListPath) {</span>
<span class="line-modified">!         File td = new File(testListPath);</span>
<span class="line-added">+         if (!td.exists()) {</span>
<span class="line-added">+             throw new Error(&quot;TESTBUG: File &quot; + testListPath + &quot; Not found&quot;);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         if (!td.isFile()) {</span>
<span class="line-modified">!             throw new Error(&quot;TESTBUG: &quot; + testListPath + &quot; Must be a File&quot;);</span>
<span class="line-modified">!         }</span>
  
          BufferedReader classList = null;
<span class="line-added">+         try {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 classList = new BufferedReader(new FileReader(td));</span>
<span class="line-added">+             } catch (FileNotFoundException e) {</span>
<span class="line-added">+                 throw new Error(&quot;TESTBUG: Error finding Classlist&quot;, e);</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             String line = null;</span>
<span class="line-modified">!             try {</span>
                  line = classList.readLine();
<span class="line-modified">!             } catch (IOException e) {</span>
<span class="line-modified">!                 throw new Error(&quot;TESTBUG: Error reading Classlist&quot;, e);</span>
              }
  
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 // ClassArray.length;</span>
<span class="line-modified">!                 maxClassIndex = Math.abs(Integer.parseInt(line));</span>
<span class="line-added">+             } catch (NumberFormatException e) {</span>
<span class="line-added">+                 throw new Error(&quot;TESTBUG: Error reading Classlist - first number must be number of methods defined&quot;, e);</span>
              }
  
<span class="line-modified">!             ClassArray = new String[maxClassIndex];</span>
<span class="line-modified">!             ClassInstanceArray = new Class[maxClassIndex];</span>
<span class="line-modified">!             MethodName_Array = new String[maxClassIndex];</span>
<span class="line-modified">!             MethodInstance_Array = new Method[maxClassIndex];</span>
<span class="line-modified">!             MethodID_Array = new int[maxClassIndex];</span>
<span class="line-modified">! </span>
<span class="line-modified">!             int i;</span>
<span class="line-modified">!             for (i = 0; i &lt; maxClassIndex; i++) {</span>
<span class="line-modified">!                 try {</span>
<span class="line-modified">!                     line = classList.readLine();</span>
<span class="line-modified">!                 } catch (IOException e) {</span>
<span class="line-modified">!                     throw new Error(&quot;TESTBUG: Error reading ClasslistFile: testListPath&quot;, e);</span>
<span class="line-added">+                 }</span>
                  StringTokenizer lineTokens = new StringTokenizer(line, &quot;\t &quot;);
<span class="line-modified">!                 if (lineTokens.countTokens() &lt; 3) {</span>
<span class="line-modified">!                     throw new Error(&quot;TESTBUG: ClasslistFile: unexpected line:&quot; + line);</span>
<span class="line-modified">!                 } else {</span>
                      ClassArray[i] = lineTokens.nextToken();
<span class="line-modified">!                     MethodName_Array[i] = lineTokens.nextToken();</span>
                      MethodID_Array[i] = Integer.parseInt(lineTokens.nextToken());
<span class="line-modified">!                 }</span>
              }
<span class="line-modified">!             maxClassIndex = i;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             if (classList != null) {</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     classList.close();</span>
<span class="line-added">+                 } catch (IOException e) {</span>
<span class="line-added">+                     throw new Error(&quot;can&#39;t close file&quot;, e);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         if ((NUM_TEST_CLASSES &lt; ClassArray.length) &amp;&amp; (NUM_TEST_CLASSES &gt; 0)) {</span>
<span class="line-modified">!             maxClassIndex = NUM_TEST_CLASSES;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             NUM_TEST_CLASSES = maxClassIndex;</span>
<span class="line-modified">!         }</span>
      }
  
<span class="line-modified">!     // does a binary search to find the index for the ID of a method</span>
<span class="line-modified">!     private static int ID_BinSearch(int begin, int end, int ID) {</span>
<span class="line-modified">!         if (end &lt; begin) {</span>
<span class="line-modified">!             return (-1);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         int mid = (begin + end) / 2;</span>
          int midvalue = MethodID_Array[mid];
  
<span class="line-modified">!         if (ID == midvalue) {</span>
              return (mid);
<span class="line-modified">!         } else if (ID &lt; midvalue) {</span>
<span class="line-modified">!             return (ID_BinSearch(begin, mid - 1, ID));</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             return (ID_BinSearch(mid + 1, end, ID));</span>
<span class="line-added">+         }</span>
      }
  
  
<span class="line-modified">!     // based off a static index, this function selects the method to be called</span>
<span class="line-modified">!     public static MethodData returnNextStaticMethod(int Method_ID) {</span>
<span class="line-modified">!         //int i = ID_BinSearch(0, MethodID_Array.length - 1, Method_ID);</span>
<span class="line-modified">!         int i = ID_BinSearch(0, maxClassIndex - 1, Method_ID);</span>
  
<span class="line-modified">!         return (nextStaticMethod((i == -1) ? 0 : i));</span>
      }
  
<span class="line-modified">!     // this function randomly selects the next method to be called by the test class</span>
<span class="line-modified">!     public static MethodData nextRandomMethod() {</span>
          int i = indexGenerator.nextInt(maxClassIndex);
<span class="line-modified">!         return (nextStaticMethod(i));</span>
      }
  
<span class="line-modified">!     private static MethodData nextStaticMethod(int i) {</span>
          Class methodsClass = null;
          Method nextMethod = null;
  
<span class="line-modified">!         try {</span>
<span class="line-modified">!             methodsClass = ClassInstanceArray[i];</span>
<span class="line-modified">!             if (methodsClass == null) {</span>
<span class="line-modified">!                 methodsClass = Class.forName(ClassArray[i]);</span>
<span class="line-modified">!                 ClassInstanceArray[i] = methodsClass;</span>
              }
<span class="line-modified">!             nextMethod = MethodInstance_Array[i];</span>
<span class="line-modified">!             if (nextMethod == null) {</span>
<span class="line-modified">!                 nextMethod = methodsClass.getMethod(MethodName_Array[i],</span>
<span class="line-modified">!                         Vector.class, Vector.class,  Long.class, Integer.class);</span>
<span class="line-modified">!                 // sum vector, ID vector, function depth, static function call depth</span>
<span class="line-modified">!                 MethodInstance_Array[i] = nextMethod;</span>
              }
<span class="line-modified">!         } catch (ClassNotFoundException e) {</span>
<span class="line-added">+             throw new Error(&quot;TESTBUG Class: &quot; + ClassArray[i] + &quot; Not Found&quot;, e);</span>
<span class="line-added">+         } catch (NoSuchMethodException e) {</span>
<span class="line-added">+             throw new Error(&quot;TESTBUG Method: &quot; + ClassArray[i] + &quot;::&quot; + MethodName_Array[i] + &quot; Not Found&quot;, e);</span>
<span class="line-added">+         } catch (SecurityException e) {</span>
<span class="line-added">+             throw new Error(&quot;TESTBUG Security Exception Generated by &quot; + ClassArray[i] + &quot;::&quot; + MethodName_Array[i], e);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return new MethodData(ClassArray[i], MethodName_Array[i], methodsClass, nextMethod, MethodID_Array[i]);</span>
      }
  
  
<span class="line-modified">!     /* These two functions are used to verify that all function were called in the proper order */</span>
  
<span class="line-modified">!     // called by &quot;parent&quot; function to add childs ID to vector</span>
<span class="line-modified">!     public static void addFunctionIDToVector(int FunctionIndex, Vector IDVector) {</span>
<span class="line-modified">!         IDVector.addElement(FunctionIndex);</span>
      }
  
<span class="line-modified">!     // called by &quot;child&quot; to add Function Index to Vector</span>
<span class="line-modified">!     public static void appendSumToSummationVector(int FunctionIndex, Vector SummationVector) {</span>
<span class="line-modified">!         if (SummationVector.isEmpty()) {</span>
<span class="line-modified">!             SummationVector.addElement((long) FunctionIndex);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             SummationVector.addElement((Long) SummationVector.lastElement() + FunctionIndex);</span>
<span class="line-modified">!         }</span>
      }
  
<span class="line-modified">!     // This function calls a method based off of MethodData</span>
      public static void callMethod(MethodData methodCallStr,
                                    Vector summation, Vector ID,
                                    Long numFcalls, Integer staticFcalls)
<span class="line-modified">!             throws InvocationTargetException {</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             methodCallStr.nextMethod.invoke(methodCallStr.instance,</span>
<span class="line-modified">!                     summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">!         } catch (IllegalAccessException e) {</span>
<span class="line-modified">!             // should never happen with a valid testfile</span>
<span class="line-modified">!             throw new TestFailure(&quot;Illegal Access Exception&quot;, e);</span>
<span class="line-modified">!         }</span>
      }
  }
</pre>
<center><a href="CGT.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MethodData.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
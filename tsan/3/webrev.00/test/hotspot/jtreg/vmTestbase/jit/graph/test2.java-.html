<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/jit/graph/test2.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jit.graph;
 24 
 25 import java.util.*;
 26 import java.lang.reflect.*;
 27 import nsk.share.TestFailure;
 28 
 29 class test2
 30 {
 31     private final int[] MethodID = {Globals.MethodID_Array[1],Globals.MethodID_Array[2]};
 32 
 33     public void CallCallMe(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)
 34         throws InvocationTargetException
 35 
 36     {
 37         Globals.appendSumToSumationVector(MethodID[1], summation);
 38 
 39         if (CGT.shouldFinish())
 40             return;
 41 
 42         if (Globals.VERBOSE)
 43             System.out.println(&quot;test2.CallCallMe&quot;);
 44 
 45                 if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))
 46                     {
 47                         return;
 48                     }
 49 
 50                 MethodData methodCallStr;
 51                 Long numFcalls;
 52                 Integer staticFcalls;
 53                 if (staticFunctionDepth.intValue() &gt; 0)
 54                     {
 55                         numFcalls = functionDepth;
 56                         staticFcalls = new Integer(staticFunctionDepth.intValue()-1);
 57                         //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[1]));
 58                         methodCallStr = Globals.returnNextStaticMethod(MethodID[1]);
 59 
 60                         Globals.addFunctionIDToVector(methodCallStr.id, ID);
 61                     }
 62                 else
 63                     {
 64                         numFcalls = new Long(functionDepth.longValue()-1);
 65                         staticFcalls = staticFunctionDepth;
 66                         Globals.addFunctionIDToVector(MethodID[0], ID);
 67                         callMe(summation, ID, numFcalls, staticFcalls);
 68                         return;
 69                     }
 70 
 71 
 72                 try
 73                     {
 74                         methodCallStr.nextMethod.invoke(methodCallStr.instance,
 75                                                         new Object []{summation, ID, numFcalls, staticFcalls});
 76                     }
 77                 catch (IllegalAccessException iax)
 78                     {
 79                         throw new TestFailure(&quot;Illegal Access Exception&quot;);
 80                     }
 81                 /*
 82                 catch (InvocationTargetException itx)
 83                     {
 84                                 throw itx;
 85                     }
 86                 */
 87     }
 88 
 89     public void callMe(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)
 90         throws InvocationTargetException
 91     {
 92         Globals.appendSumToSumationVector(MethodID[0], summation);
 93 
 94         if (CGT.shouldFinish())
 95             return;
 96 
 97         if (Globals.VERBOSE)
 98             System.out.println(&quot;test2.callMe&quot;);
 99 
100                 if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))
101                     {
102                         return;
103                     }
104 
105                 MethodData methodCallStr;
106                 Long numFcalls;
107                 Integer staticFcalls;
108                 if (staticFunctionDepth.intValue() &gt; 0)
109             {
110                         numFcalls = functionDepth;
111                         staticFcalls = new Integer(staticFunctionDepth.intValue()-1);
112                         //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[0]));
113                         methodCallStr = Globals.returnNextStaticMethod(MethodID[0]);
114 
115             }
116                 else
117             {
118                         numFcalls = new Long(functionDepth.longValue() -1);
119                         staticFcalls = staticFunctionDepth;
120                         methodCallStr = Globals.nextRandomMethod();
121             }
122 
123                 Globals.addFunctionIDToVector(methodCallStr.id, ID);
124 
125 
126                 try
127             {
128                         methodCallStr.nextMethod.invoke(methodCallStr.instance,
129                                 new Object []{summation, ID, numFcalls, staticFcalls});
130             }
131                 catch (IllegalAccessException iax)
132             {
133                         throw new TestFailure(&quot;Illegal Access Exception&quot;);
134             }
135 /*
136                 catch (InvocationTargetException itx)
137                     {
138                                 System.out.println(&quot;itx test 2&quot;);
139 
140                                 throw itx;
141                     }
142                     */
143 
144     }
145 }
    </pre>
  </body>
</html>
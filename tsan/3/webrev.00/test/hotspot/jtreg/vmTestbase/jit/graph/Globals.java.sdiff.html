<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/jit/graph/Globals.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="CGT.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MethodData.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/jit/graph/Globals.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jit.graph;
<span class="line-modified"> 25 import java.io.*;</span>
<span class="line-modified"> 26 import java.util.*;</span>
<span class="line-removed"> 27 import java.lang.*;</span>
<span class="line-removed"> 28 import java.lang.reflect.*;</span>
 29 import nsk.share.TestFailure;
 30 










 31 
<span class="line-modified"> 32 public final class Globals</span>
<span class="line-removed"> 33 {</span>
<span class="line-removed"> 34     // Minimum and Maximum number of threads</span>
<span class="line-removed"> 35     public static int     NUM_THREADS      = 1;</span>
<span class="line-removed"> 36     public static long    RANDOM_SEED      = System.currentTimeMillis();</span>
<span class="line-removed"> 37     public static int     STATIC_LOOP      = 0;</span>
<span class="line-removed"> 38     public static int     NUM_TEST_CLASSES = 7;</span>
<span class="line-removed"> 39     public static long    RANDOM_LOOP      = 100;</span>
<span class="line-removed"> 40     public static boolean VERBOSE          = false;</span>
<span class="line-removed"> 41     private static Random indexGenerator   = null;</span>
 42 
<span class="line-removed"> 43   //private static TestLoader CGTTestLoader = null;</span>
<span class="line-removed"> 44     private static String [] ClassArray = null;</span>
<span class="line-removed"> 45     private static Class [] ClassInstanceArray = null;</span>
<span class="line-removed"> 46     private static int       maxClassIndex    = 0;</span>
 47 
<span class="line-modified"> 48     private static String [] MethodName_Array = null;</span>
<span class="line-modified"> 49     private static Method [] MethodInstance_Array = null;</span>


 50 
<span class="line-modified"> 51     //Should be prime, so that odds of an incorrect verification reduced</span>
<span class="line-modified"> 52     public static  int    [] MethodID_Array   = null;</span>


 53 


 54 
<span class="line-modified"> 55     //Number of threads will be reduced as threads finish</span>
<span class="line-modified"> 56     public static synchronized void decNumThreads(){NUM_THREADS--;};</span>
 57 
<span class="line-modified"> 58     public static synchronized void initialize(String testListPath)</span>
<span class="line-modified"> 59     {</span>



 60 
<span class="line-modified"> 61         File td = new File (testListPath);</span>
<span class="line-modified"> 62         if (!td.exists())</span>
<span class="line-modified"> 63             {</span>
<span class="line-removed"> 64                 System.err.println(&quot;File &quot; + testListPath + &quot; Not found&quot;);</span>
<span class="line-removed"> 65                 System.exit(1);</span>
<span class="line-removed"> 66             }</span>
<span class="line-removed"> 67         if (!td.isFile())</span>
<span class="line-removed"> 68             {</span>
<span class="line-removed"> 69                 System.err.println(testListPath + &quot; Must be a File&quot;);</span>
<span class="line-removed"> 70                 System.exit(1);</span>
<span class="line-removed"> 71             }</span>
 72 
 73         BufferedReader classList = null;






 74 
<span class="line-modified"> 75         try</span>
<span class="line-modified"> 76           {</span>
<span class="line-removed"> 77             classList = new BufferedReader(new FileReader(td));</span>
<span class="line-removed"> 78           }</span>
<span class="line-removed"> 79         catch (FileNotFoundException  fnfx)</span>
<span class="line-removed"> 80           {</span>
<span class="line-removed"> 81             System.err.println(&quot;Error finding Classlist&quot;);</span>
<span class="line-removed"> 82             System.exit(1);</span>
<span class="line-removed"> 83           }</span>
<span class="line-removed"> 84 </span>
<span class="line-removed"> 85         String line = null;</span>
<span class="line-removed"> 86         try</span>
<span class="line-removed"> 87             {</span>
 88                 line = classList.readLine();
<span class="line-modified"> 89             }</span>
<span class="line-modified"> 90         catch (IOException iox)</span>
<span class="line-removed"> 91             {</span>
<span class="line-removed"> 92                 System.err.println(&quot;Error reading Classlist&quot;);</span>
<span class="line-removed"> 93                 System.exit(1);</span>
 94             }
 95 
<span class="line-modified"> 96         try</span>
<span class="line-modified"> 97             {</span>
<span class="line-modified"> 98                 maxClassIndex = Math.abs(Integer.parseInt(line));//ClassArray.length;</span>


 99             }
<span class="line-removed">100         catch (NumberFormatException nfx)</span>
<span class="line-removed">101             {</span>
<span class="line-removed">102                 System.err.println(&quot;Error reading Classlist - first number must be number of methods defined&quot;);</span>
<span class="line-removed">103                 System.exit(1);</span>
<span class="line-removed">104             }</span>
<span class="line-removed">105 </span>
<span class="line-removed">106         ClassArray = new String [maxClassIndex];</span>
<span class="line-removed">107 ClassInstanceArray = new Class [maxClassIndex];</span>
<span class="line-removed">108         MethodName_Array = new String [maxClassIndex];</span>
<span class="line-removed">109         MethodInstance_Array = new Method [maxClassIndex];</span>
<span class="line-removed">110         MethodID_Array = new int [maxClassIndex];</span>
111 
<span class="line-modified">112         int i;</span>
<span class="line-modified">113         for (i = 0; (i&lt;maxClassIndex) &amp;&amp; (line != null); i++)</span>
<span class="line-modified">114             {</span>
<span class="line-modified">115                 try</span>
<span class="line-modified">116                     {</span>
<span class="line-modified">117                         line = classList.readLine();</span>
<span class="line-modified">118                     }</span>
<span class="line-modified">119                 catch (IOException iox)</span>
<span class="line-modified">120                     {</span>
<span class="line-modified">121                         System.err.println(&quot;Error reading ClasslistFile: testListPath&quot;);</span>
<span class="line-modified">122                         System.exit(1);</span>
<span class="line-modified">123                     }</span>

124                 StringTokenizer lineTokens = new StringTokenizer(line, &quot;\t &quot;);
<span class="line-modified">125                 if (lineTokens.countTokens() &lt;3)</span>
<span class="line-modified">126                   {</span>
<span class="line-modified">127                     System.out.println(&quot;Error reading ClasslistFile: Errored line&quot;);</span>
<span class="line-removed">128                     i--;</span>
<span class="line-removed">129                   }</span>
<span class="line-removed">130                 else</span>
<span class="line-removed">131                   {</span>
132                     ClassArray[i] = lineTokens.nextToken();
<span class="line-modified">133                     MethodName_Array[i] =lineTokens.nextToken();</span>
134                     MethodID_Array[i] = Integer.parseInt(lineTokens.nextToken());
<span class="line-modified">135                   }</span>
136             }
<span class="line-modified">137         maxClassIndex = i;</span>









138 
<span class="line-modified">139         indexGenerator = new Random(RANDOM_SEED);</span>
<span class="line-modified">140         if ((NUM_TEST_CLASSES &lt; ClassArray.length) &amp;&amp; (NUM_TEST_CLASSES &gt; 0))</span>
<span class="line-modified">141           maxClassIndex = NUM_TEST_CLASSES;</span>
<span class="line-modified">142         else</span>
<span class="line-modified">143           NUM_TEST_CLASSES = maxClassIndex;</span>
144     }
145 
<span class="line-modified">146     //does a binary serach to find the index for the ID of a method</span>
<span class="line-modified">147     private static int ID_BinSearch(int begin, int end, int ID)</span>
<span class="line-modified">148     {</span>
<span class="line-modified">149         if (end &lt; begin)</span>
<span class="line-modified">150             return(-1);</span>
151 
<span class="line-modified">152         int mid = (begin + end)/2;</span>
153         int midvalue = MethodID_Array[mid];
154 
<span class="line-modified">155         if (ID == midvalue)</span>
156             return (mid);
<span class="line-modified">157         else if (ID &lt; midvalue)</span>
<span class="line-modified">158             return(ID_BinSearch(begin, mid-1, ID));</span>
<span class="line-modified">159         else</span>
<span class="line-modified">160             return(ID_BinSearch(mid+1, end, ID));</span>

161     }
162 
163 
<span class="line-modified">164     //based off a static index, this function selects the method to be called</span>
<span class="line-modified">165     public static MethodData returnNextStaticMethod(int Method_ID)</span>
<span class="line-modified">166     {</span>
<span class="line-modified">167       //int i = ID_BinSearch(0, MethodID_Array.length - 1, Method_ID);</span>
<span class="line-removed">168       int i = ID_BinSearch(0, maxClassIndex - 1, Method_ID);</span>
169 
<span class="line-modified">170       return(nextStaticMethod((i==-1)?0:i));</span>
171     }
172 
<span class="line-modified">173     //this function randomly selects the next method to be called by the test class</span>
<span class="line-modified">174     public static MethodData nextRandomMethod()</span>
<span class="line-removed">175     {</span>
<span class="line-removed">176 </span>
177         int i = indexGenerator.nextInt(maxClassIndex);
<span class="line-modified">178         return(nextStaticMethod(i));</span>
179     }
180 
<span class="line-modified">181     private static MethodData nextStaticMethod(int i)</span>
<span class="line-removed">182     {</span>
183         Class methodsClass = null;
184         Method nextMethod = null;
185 
<span class="line-modified">186         try</span>
<span class="line-modified">187             {</span>
<span class="line-modified">188               //methodsClass = CGTTestLoader.findClass(ClassArray[i]);</span>
<span class="line-modified">189               methodsClass = ClassInstanceArray[i];</span>
<span class="line-modified">190               if (methodsClass == null)</span>
<span class="line-removed">191               {</span>
<span class="line-removed">192                   methodsClass = Class.forName(ClassArray[i]);</span>
<span class="line-removed">193                   ClassInstanceArray[i] = methodsClass;</span>
<span class="line-removed">194               }</span>
<span class="line-removed">195               nextMethod = MethodInstance_Array[i];</span>
<span class="line-removed">196               if (nextMethod == null )</span>
<span class="line-removed">197               {</span>
<span class="line-removed">198               nextMethod =</span>
<span class="line-removed">199                 methodsClass.getMethod(MethodName_Array[i],</span>
<span class="line-removed">200                                        new Class[]{java.util.Vector.class, java.util.Vector.class,</span>
<span class="line-removed">201                                                      java.lang.Long.class, java.lang.Integer.class});</span>
<span class="line-removed">202               //sum vector, ID vector, function depth, static function call depth</span>
<span class="line-removed">203               MethodInstance_Array[i] = nextMethod;</span>
<span class="line-removed">204               }</span>
<span class="line-removed">205             }</span>
<span class="line-removed">206         catch (ClassNotFoundException cnfx)</span>
<span class="line-removed">207             {</span>
<span class="line-removed">208                 System.out.println(&quot;Class: &quot; +ClassArray[i]+ &quot; Not Found&quot;);</span>
<span class="line-removed">209                 System.exit(-1);</span>
<span class="line-removed">210             }</span>
<span class="line-removed">211         catch (NoSuchMethodException nsmx)</span>
<span class="line-removed">212             {</span>
<span class="line-removed">213                 System.out.println(&quot;Class: &quot; +ClassArray[i]);</span>
<span class="line-removed">214                 System.out.println(&quot;Method: &quot; +MethodName_Array[i]+&quot; Not Found&quot;);</span>
<span class="line-removed">215                 System.exit(-1);</span>
216             }
<span class="line-modified">217         catch (SecurityException sx)</span>
<span class="line-modified">218             {</span>
<span class="line-modified">219                 System.out.println(&quot;Class: &quot; +ClassArray[i]);</span>
<span class="line-modified">220                 System.out.println(&quot;Method: &quot; +MethodName_Array[i]);</span>
<span class="line-modified">221                 System.out.println(&quot;Security Exception Generated, by above method call&quot;);</span>
<span class="line-modified">222                 System.exit(-1);</span>
223             }
<span class="line-modified">224         return(new MethodData(ClassArray[i], MethodName_Array[i], methodsClass, nextMethod, MethodID_Array[i]));</span>







225     }
226 
227 
<span class="line-modified">228     /*These two functions are used to verify that all function were called in the proper order*/</span>
229 
<span class="line-modified">230     //called by &quot;parent&quot; function to add childs ID to vector</span>
<span class="line-modified">231     public static void addFunctionIDToVector(int FunctionIndex, Vector IDVector)</span>
<span class="line-modified">232     {</span>
<span class="line-removed">233         IDVector.addElement(new Integer(FunctionIndex));</span>
234     }
235 
<span class="line-modified">236     //called by &quot;child&quot; to add Function Index to Vector</span>
<span class="line-modified">237     public static void appendSumToSumationVector(int FunctionIndex, Vector SummationVector)</span>
<span class="line-modified">238     {</span>
<span class="line-modified">239         if (SummationVector.isEmpty())</span>
<span class="line-modified">240             SummationVector.addElement(new Long(FunctionIndex));</span>
<span class="line-modified">241         else</span>
<span class="line-modified">242             SummationVector.addElement(new Long(((Long)SummationVector.lastElement()).longValue() + FunctionIndex));</span>
243     }
244 
<span class="line-modified">245     //This function calls a method based off of MethodData</span>
246     public static void callMethod(MethodData methodCallStr,
247                                   Vector summation, Vector ID,
248                                   Long numFcalls, Integer staticFcalls)
<span class="line-modified">249                                   throws InvocationTargetException</span>
<span class="line-modified">250 </span>
<span class="line-modified">251     {</span>
<span class="line-modified">252                 if(NUM_THREADS &gt;1)</span>
<span class="line-modified">253                     {</span>
<span class="line-modified">254                         if ((staticFcalls.intValue() + numFcalls.longValue()) %23 == 0)</span>
<span class="line-modified">255                             {</span>
<span class="line-modified">256                                 try</span>
<span class="line-removed">257                                     {</span>
<span class="line-removed">258                                         Thread.sleep(225);</span>
<span class="line-removed">259                                     }</span>
<span class="line-removed">260                                 catch (InterruptedException ie)</span>
<span class="line-removed">261                                     {}</span>
<span class="line-removed">262                                 if (VERBOSE)</span>
<span class="line-removed">263                                     System.out.println(&quot;\t\tCurrentThread:&quot; + Thread.currentThread().getName());</span>
<span class="line-removed">264                             }</span>
<span class="line-removed">265                     }</span>
<span class="line-removed">266 </span>
<span class="line-removed">267                 try</span>
<span class="line-removed">268             {</span>
<span class="line-removed">269                         methodCallStr.nextMethod.invoke(methodCallStr.instance,</span>
<span class="line-removed">270                                 new Object []{summation, ID, numFcalls, staticFcalls});</span>
<span class="line-removed">271             }</span>
<span class="line-removed">272                 catch (IllegalAccessException iax)  //should never happen with a valid testfile</span>
<span class="line-removed">273             {</span>
<span class="line-removed">274                         throw new TestFailure(&quot;Illegal Access Exception&quot;);</span>
<span class="line-removed">275             }</span>
<span class="line-removed">276                     /*</span>
<span class="line-removed">277                 catch (InvocationTargetException itx)</span>
<span class="line-removed">278                     {</span>
<span class="line-removed">279                         itx.printStackTrace();</span>
<span class="line-removed">280                         System.out.println(&quot;Invocation Target Exception&quot;);</span>
<span class="line-removed">281                         System.exit(1);</span>
<span class="line-removed">282                     }*/</span>
283     }
284 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jit.graph;
<span class="line-modified"> 25 </span>
<span class="line-modified"> 26 import jdk.test.lib.Utils;</span>


 27 import nsk.share.TestFailure;
 28 
<span class="line-added"> 29 import java.io.BufferedReader;</span>
<span class="line-added"> 30 import java.io.File;</span>
<span class="line-added"> 31 import java.io.FileNotFoundException;</span>
<span class="line-added"> 32 import java.io.FileReader;</span>
<span class="line-added"> 33 import java.io.IOException;</span>
<span class="line-added"> 34 import java.lang.reflect.InvocationTargetException;</span>
<span class="line-added"> 35 import java.lang.reflect.Method;</span>
<span class="line-added"> 36 import java.util.Random;</span>
<span class="line-added"> 37 import java.util.StringTokenizer;</span>
<span class="line-added"> 38 import java.util.Vector;</span>
 39 
<span class="line-modified"> 40 public final class Globals {</span>









 41 




 42 
<span class="line-modified"> 43     public static int STATIC_LOOP = 0;</span>
<span class="line-modified"> 44     public static int NUM_TEST_CLASSES = 7;</span>
<span class="line-added"> 45     public static long RANDOM_LOOP = 100;</span>
<span class="line-added"> 46     public static boolean VERBOSE = false;</span>
 47 
<span class="line-modified"> 48     private static final Random indexGenerator = Utils.getRandomInstance();</span>
<span class="line-modified"> 49     private static String[] ClassArray = null;</span>
<span class="line-added"> 50     private static Class[] ClassInstanceArray = null;</span>
<span class="line-added"> 51     private static int maxClassIndex = 0;</span>
 52 
<span class="line-added"> 53     private static String[] MethodName_Array = null;</span>
<span class="line-added"> 54     private static Method[] MethodInstance_Array = null;</span>
 55 
<span class="line-modified"> 56     // Should be prime, so that odds of an incorrect verification reduced</span>
<span class="line-modified"> 57     public static int[] MethodID_Array = null;</span>
 58 
<span class="line-modified"> 59     public static synchronized void initialize(String testListPath) {</span>
<span class="line-modified"> 60         File td = new File(testListPath);</span>
<span class="line-added"> 61         if (!td.exists()) {</span>
<span class="line-added"> 62             throw new Error(&quot;TESTBUG: File &quot; + testListPath + &quot; Not found&quot;);</span>
<span class="line-added"> 63         }</span>
 64 
<span class="line-modified"> 65         if (!td.isFile()) {</span>
<span class="line-modified"> 66             throw new Error(&quot;TESTBUG: &quot; + testListPath + &quot; Must be a File&quot;);</span>
<span class="line-modified"> 67         }</span>








 68 
 69         BufferedReader classList = null;
<span class="line-added"> 70         try {</span>
<span class="line-added"> 71             try {</span>
<span class="line-added"> 72                 classList = new BufferedReader(new FileReader(td));</span>
<span class="line-added"> 73             } catch (FileNotFoundException e) {</span>
<span class="line-added"> 74                 throw new Error(&quot;TESTBUG: Error finding Classlist&quot;, e);</span>
<span class="line-added"> 75             }</span>
 76 
<span class="line-modified"> 77             String line = null;</span>
<span class="line-modified"> 78             try {</span>











 79                 line = classList.readLine();
<span class="line-modified"> 80             } catch (IOException e) {</span>
<span class="line-modified"> 81                 throw new Error(&quot;TESTBUG: Error reading Classlist&quot;, e);</span>



 82             }
 83 
<span class="line-modified"> 84             try {</span>
<span class="line-modified"> 85                 // ClassArray.length;</span>
<span class="line-modified"> 86                 maxClassIndex = Math.abs(Integer.parseInt(line));</span>
<span class="line-added"> 87             } catch (NumberFormatException e) {</span>
<span class="line-added"> 88                 throw new Error(&quot;TESTBUG: Error reading Classlist - first number must be number of methods defined&quot;, e);</span>
 89             }











 90 
<span class="line-modified"> 91             ClassArray = new String[maxClassIndex];</span>
<span class="line-modified"> 92             ClassInstanceArray = new Class[maxClassIndex];</span>
<span class="line-modified"> 93             MethodName_Array = new String[maxClassIndex];</span>
<span class="line-modified"> 94             MethodInstance_Array = new Method[maxClassIndex];</span>
<span class="line-modified"> 95             MethodID_Array = new int[maxClassIndex];</span>
<span class="line-modified"> 96 </span>
<span class="line-modified"> 97             int i;</span>
<span class="line-modified"> 98             for (i = 0; i &lt; maxClassIndex; i++) {</span>
<span class="line-modified"> 99                 try {</span>
<span class="line-modified">100                     line = classList.readLine();</span>
<span class="line-modified">101                 } catch (IOException e) {</span>
<span class="line-modified">102                     throw new Error(&quot;TESTBUG: Error reading ClasslistFile: testListPath&quot;, e);</span>
<span class="line-added">103                 }</span>
104                 StringTokenizer lineTokens = new StringTokenizer(line, &quot;\t &quot;);
<span class="line-modified">105                 if (lineTokens.countTokens() &lt; 3) {</span>
<span class="line-modified">106                     throw new Error(&quot;TESTBUG: ClasslistFile: unexpected line:&quot; + line);</span>
<span class="line-modified">107                 } else {</span>




108                     ClassArray[i] = lineTokens.nextToken();
<span class="line-modified">109                     MethodName_Array[i] = lineTokens.nextToken();</span>
110                     MethodID_Array[i] = Integer.parseInt(lineTokens.nextToken());
<span class="line-modified">111                 }</span>
112             }
<span class="line-modified">113             maxClassIndex = i;</span>
<span class="line-added">114         } finally {</span>
<span class="line-added">115             if (classList != null) {</span>
<span class="line-added">116                 try {</span>
<span class="line-added">117                     classList.close();</span>
<span class="line-added">118                 } catch (IOException e) {</span>
<span class="line-added">119                     throw new Error(&quot;can&#39;t close file&quot;, e);</span>
<span class="line-added">120                 }</span>
<span class="line-added">121             }</span>
<span class="line-added">122         }</span>
123 
<span class="line-modified">124         if ((NUM_TEST_CLASSES &lt; ClassArray.length) &amp;&amp; (NUM_TEST_CLASSES &gt; 0)) {</span>
<span class="line-modified">125             maxClassIndex = NUM_TEST_CLASSES;</span>
<span class="line-modified">126         } else {</span>
<span class="line-modified">127             NUM_TEST_CLASSES = maxClassIndex;</span>
<span class="line-modified">128         }</span>
129     }
130 
<span class="line-modified">131     // does a binary search to find the index for the ID of a method</span>
<span class="line-modified">132     private static int ID_BinSearch(int begin, int end, int ID) {</span>
<span class="line-modified">133         if (end &lt; begin) {</span>
<span class="line-modified">134             return (-1);</span>
<span class="line-modified">135         }</span>
136 
<span class="line-modified">137         int mid = (begin + end) / 2;</span>
138         int midvalue = MethodID_Array[mid];
139 
<span class="line-modified">140         if (ID == midvalue) {</span>
141             return (mid);
<span class="line-modified">142         } else if (ID &lt; midvalue) {</span>
<span class="line-modified">143             return (ID_BinSearch(begin, mid - 1, ID));</span>
<span class="line-modified">144         } else {</span>
<span class="line-modified">145             return (ID_BinSearch(mid + 1, end, ID));</span>
<span class="line-added">146         }</span>
147     }
148 
149 
<span class="line-modified">150     // based off a static index, this function selects the method to be called</span>
<span class="line-modified">151     public static MethodData returnNextStaticMethod(int Method_ID) {</span>
<span class="line-modified">152         //int i = ID_BinSearch(0, MethodID_Array.length - 1, Method_ID);</span>
<span class="line-modified">153         int i = ID_BinSearch(0, maxClassIndex - 1, Method_ID);</span>

154 
<span class="line-modified">155         return (nextStaticMethod((i == -1) ? 0 : i));</span>
156     }
157 
<span class="line-modified">158     // this function randomly selects the next method to be called by the test class</span>
<span class="line-modified">159     public static MethodData nextRandomMethod() {</span>


160         int i = indexGenerator.nextInt(maxClassIndex);
<span class="line-modified">161         return (nextStaticMethod(i));</span>
162     }
163 
<span class="line-modified">164     private static MethodData nextStaticMethod(int i) {</span>

165         Class methodsClass = null;
166         Method nextMethod = null;
167 
<span class="line-modified">168         try {</span>
<span class="line-modified">169             methodsClass = ClassInstanceArray[i];</span>
<span class="line-modified">170             if (methodsClass == null) {</span>
<span class="line-modified">171                 methodsClass = Class.forName(ClassArray[i]);</span>
<span class="line-modified">172                 ClassInstanceArray[i] = methodsClass;</span>

























173             }
<span class="line-modified">174             nextMethod = MethodInstance_Array[i];</span>
<span class="line-modified">175             if (nextMethod == null) {</span>
<span class="line-modified">176                 nextMethod = methodsClass.getMethod(MethodName_Array[i],</span>
<span class="line-modified">177                         Vector.class, Vector.class,  Long.class, Integer.class);</span>
<span class="line-modified">178                 // sum vector, ID vector, function depth, static function call depth</span>
<span class="line-modified">179                 MethodInstance_Array[i] = nextMethod;</span>
180             }
<span class="line-modified">181         } catch (ClassNotFoundException e) {</span>
<span class="line-added">182             throw new Error(&quot;TESTBUG Class: &quot; + ClassArray[i] + &quot; Not Found&quot;, e);</span>
<span class="line-added">183         } catch (NoSuchMethodException e) {</span>
<span class="line-added">184             throw new Error(&quot;TESTBUG Method: &quot; + ClassArray[i] + &quot;::&quot; + MethodName_Array[i] + &quot; Not Found&quot;, e);</span>
<span class="line-added">185         } catch (SecurityException e) {</span>
<span class="line-added">186             throw new Error(&quot;TESTBUG Security Exception Generated by &quot; + ClassArray[i] + &quot;::&quot; + MethodName_Array[i], e);</span>
<span class="line-added">187         }</span>
<span class="line-added">188         return new MethodData(ClassArray[i], MethodName_Array[i], methodsClass, nextMethod, MethodID_Array[i]);</span>
189     }
190 
191 
<span class="line-modified">192     /* These two functions are used to verify that all function were called in the proper order */</span>
193 
<span class="line-modified">194     // called by &quot;parent&quot; function to add childs ID to vector</span>
<span class="line-modified">195     public static void addFunctionIDToVector(int FunctionIndex, Vector IDVector) {</span>
<span class="line-modified">196         IDVector.addElement(FunctionIndex);</span>

197     }
198 
<span class="line-modified">199     // called by &quot;child&quot; to add Function Index to Vector</span>
<span class="line-modified">200     public static void appendSumToSummationVector(int FunctionIndex, Vector SummationVector) {</span>
<span class="line-modified">201         if (SummationVector.isEmpty()) {</span>
<span class="line-modified">202             SummationVector.addElement((long) FunctionIndex);</span>
<span class="line-modified">203         } else {</span>
<span class="line-modified">204             SummationVector.addElement((Long) SummationVector.lastElement() + FunctionIndex);</span>
<span class="line-modified">205         }</span>
206     }
207 
<span class="line-modified">208     // This function calls a method based off of MethodData</span>
209     public static void callMethod(MethodData methodCallStr,
210                                   Vector summation, Vector ID,
211                                   Long numFcalls, Integer staticFcalls)
<span class="line-modified">212             throws InvocationTargetException {</span>
<span class="line-modified">213         try {</span>
<span class="line-modified">214             methodCallStr.nextMethod.invoke(methodCallStr.instance,</span>
<span class="line-modified">215                     summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">216         } catch (IllegalAccessException e) {</span>
<span class="line-modified">217             // should never happen with a valid testfile</span>
<span class="line-modified">218             throw new TestFailure(&quot;Illegal Access Exception&quot;, e);</span>
<span class="line-modified">219         }</span>


























220     }
221 }
</pre>
</td>
</tr>
</table>
<center><a href="CGT.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MethodData.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
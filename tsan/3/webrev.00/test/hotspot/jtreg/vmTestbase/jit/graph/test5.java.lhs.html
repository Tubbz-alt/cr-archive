<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/jit/graph/test5.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
<a name="2" id="anc2"></a>
 23 package jit.graph;
 24 
<a name="3" id="anc3"></a><span class="line-modified"> 25 import java.util.*;</span>
<span class="line-removed"> 26 import java.lang.reflect.*;</span>
 27 import nsk.share.TestFailure;
 28 
<a name="4" id="anc4"></a><span class="line-modified"> 29 class test5</span>
<span class="line-modified"> 30 {</span>
<span class="line-modified"> 31   private final int[] MethodID = {Globals.MethodID_Array[7],</span>
<span class="line-modified"> 32                                   Globals.MethodID_Array[8],</span>
<span class="line-modified"> 33                                   Globals.MethodID_Array[9],</span>
<span class="line-modified"> 34                                   Globals.MethodID_Array[10]};</span>
<span class="line-modified"> 35   private static Random loopNumGen = new Random(Globals.RANDOM_SEED);</span>
<span class="line-modified"> 36 </span>
<span class="line-modified"> 37   private final int maxLoops = 12;</span>
<span class="line-modified"> 38 </span>
<span class="line-modified"> 39   private long factorial(int n)</span>
<span class="line-modified"> 40   {</span>
<span class="line-modified"> 41     if(n&gt;1)</span>
<span class="line-modified"> 42       return(n*factorial(n-1));</span>
<span class="line-modified"> 43     else</span>
<span class="line-modified"> 44       return (1);</span>
<span class="line-modified"> 45   }</span>
<span class="line-modified"> 46 </span>
<span class="line-modified"> 47   private long fibonacci(long num1, long num2, int n)</span>
<span class="line-modified"> 48   {</span>
<span class="line-modified"> 49     if (n &lt;= 0)</span>
<span class="line-modified"> 50       return(num2);</span>
<span class="line-modified"> 51     else</span>
<span class="line-modified"> 52       return (fibonacci(num2, num1+num2, n-1));</span>
<span class="line-modified"> 53   }</span>
<span class="line-modified"> 54 </span>
<span class="line-modified"> 55   private long combination(int n, int r)</span>
<span class="line-modified"> 56   {</span>
<span class="line-modified"> 57     if ((r==0) || (n==r))</span>
<span class="line-modified"> 58       return 1;</span>
<span class="line-modified"> 59     else</span>
<span class="line-modified"> 60       return(combination(n-1, r) +combination(n - 1, r - 1));</span>
<span class="line-modified"> 61   }</span>
<span class="line-modified"> 62 </span>
<span class="line-modified"> 63   private int[] pascalsTriangle(int[] source, int n)</span>
<span class="line-modified"> 64   {</span>
<span class="line-modified"> 65     if (n&gt;0)</span>
<span class="line-modified"> 66       {</span>
<span class="line-modified"> 67         int sourceLength = source.length;</span>
<span class="line-modified"> 68         int [] temp = new int[sourceLength +1];</span>
<span class="line-modified"> 69         temp[0] = 1;</span>
<span class="line-modified"> 70         temp[sourceLength] = 1;</span>
<span class="line-modified"> 71 </span>
<span class="line-modified"> 72         int j=1;</span>
<span class="line-modified"> 73         for(int i = 0; i&lt;(sourceLength - 1); i++)</span>
<span class="line-modified"> 74           temp[j++] = source[i] + source[i+1];</span>
<span class="line-modified"> 75 </span>
<span class="line-modified"> 76         return(pascalsTriangle(temp, n-1));</span>
<span class="line-modified"> 77       }</span>
<span class="line-modified"> 78     else</span>
<span class="line-modified"> 79       return source;</span>
<span class="line-modified"> 80   }</span>
<span class="line-modified"> 81 </span>
<span class="line-modified"> 82   private boolean verifyArray(int[] ArrayToBeVerified, int[] MasterArray)</span>
<span class="line-modified"> 83   {</span>
<span class="line-modified"> 84     if (ArrayToBeVerified.length != MasterArray.length)</span>
<span class="line-modified"> 85       return false;</span>
<span class="line-modified"> 86 </span>
<span class="line-modified"> 87     for (int i =0; i&lt;MasterArray.length; i++)</span>
<span class="line-modified"> 88       if (MasterArray[i] != ArrayToBeVerified[i])</span>
<span class="line-modified"> 89         return false;</span>
<span class="line-modified"> 90     return true;</span>
<span class="line-modified"> 91   }</span>
<span class="line-modified"> 92 </span>
<span class="line-modified"> 93   private int[] verifyPascal(int n)</span>
<span class="line-modified"> 94   {</span>
<span class="line-modified"> 95     int []   pascalOut = new int[n+1];</span>
<span class="line-modified"> 96     int [][] dataArray = new int[n+1][n+1];</span>
<span class="line-modified"> 97 </span>
<span class="line-modified"> 98     for (int i = 0; i&lt;=n; i++)</span>
<span class="line-modified"> 99       {</span>
<span class="line-modified">100         for (int j = 0; j&lt;=n; j++)</span>
<span class="line-modified">101           {</span>
<span class="line-modified">102             if (j==0)</span>
<span class="line-modified">103               dataArray[i][0] = 1;</span>
<span class="line-modified">104             else if (j==i)</span>
<span class="line-modified">105               dataArray[i][i] = 1;</span>
<span class="line-modified">106             else if (j&lt;i)</span>
<span class="line-modified">107               dataArray[i][j] =  dataArray[i-1][j-1] + dataArray[i-1][j];</span>
<span class="line-modified">108           }</span>
<span class="line-modified">109       }</span>
<span class="line-modified">110 </span>
<span class="line-modified">111     int j = n;                            //could be a little more efficient</span>
<span class="line-modified">112     for (int i = 0; i&lt;=n; i++)            //but not that important</span>
<span class="line-modified">113       pascalOut[i] = dataArray[j][i];</span>
<span class="line-modified">114     return pascalOut;</span>
<span class="line-modified">115   }</span>
<span class="line-modified">116 </span>
<span class="line-modified">117   private long verifyFact(int n)</span>
<span class="line-modified">118   {</span>
<span class="line-modified">119     long answer = 1;</span>
<span class="line-modified">120     for (int i=2; i&lt;=n; i++)</span>
<span class="line-modified">121         answer*=i;</span>
<span class="line-modified">122     return answer;</span>
<span class="line-modified">123   }</span>
<span class="line-modified">124 </span>
<span class="line-modified">125   private long verifyFibo(int n)</span>
<span class="line-modified">126   {</span>
<span class="line-modified">127     long num1=1;</span>
<span class="line-modified">128     long num2=1;</span>
<span class="line-modified">129 </span>
<span class="line-modified">130     for (int i = 0; i&lt; n; i++)</span>
<span class="line-modified">131       {</span>
<span class="line-modified">132         long temp = num1+num2;</span>
<span class="line-modified">133         num1 = num2;</span>
<span class="line-modified">134         num2 = temp;</span>
<span class="line-modified">135       }</span>
<span class="line-modified">136 </span>
<span class="line-modified">137     return num2;</span>
<span class="line-modified">138   }</span>
<span class="line-modified">139 </span>
<span class="line-modified">140   private long verifyComb(int n, int r)</span>
<span class="line-modified">141   {</span>
<span class="line-modified">142     return(verifyFact(n)/(verifyFact(n-r)*verifyFact(r)));</span>
<span class="line-modified">143   }</span>
<span class="line-modified">144 </span>
<span class="line-modified">145   public void factTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">146         throws InvocationTargetException</span>
<span class="line-modified">147   {</span>
<span class="line-modified">148     Globals.appendSumToSumationVector(MethodID[0], summation);</span>
<span class="line-modified">149 </span>
<span class="line-modified">150     if (CGT.shouldFinish())</span>
<span class="line-modified">151       return;</span>
<span class="line-modified">152 </span>
<span class="line-modified">153     if (Globals.VERBOSE)</span>
<span class="line-modified">154       System.out.println(&quot;test5.factTest&quot;);</span>
<span class="line-modified">155 </span>
<span class="line-modified">156     if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))</span>
<span class="line-modified">157       {</span>
<span class="line-modified">158         return;</span>
<span class="line-modified">159       }</span>
<span class="line-modified">160     MethodData methodCallStr;</span>
<span class="line-modified">161     Long numFcalls;</span>
<span class="line-modified">162     Integer staticFcalls;</span>
<span class="line-modified">163 </span>
<span class="line-modified">164     if (staticFunctionDepth.intValue() &gt; 0)</span>
<span class="line-modified">165       {</span>
<span class="line-modified">166         numFcalls = functionDepth;</span>
<span class="line-modified">167         staticFcalls = new Integer(staticFunctionDepth.intValue()-1);</span>
<span class="line-modified">168         methodCallStr = Globals.returnNextStaticMethod(MethodID[0]);</span>
<span class="line-modified">169         //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[0]));</span>
<span class="line-modified">170       }</span>
<span class="line-modified">171     else</span>
<span class="line-modified">172       {</span>
<span class="line-modified">173         numFcalls = new Long(functionDepth.longValue() -1);</span>
<span class="line-modified">174         staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">175         methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">176       }</span>
<span class="line-modified">177 </span>
<span class="line-modified">178     int localNumLoops    = loopNumGen.nextInt(maxLoops);</span>
<span class="line-modified">179     long facFunctionValue = factorial(localNumLoops);</span>
<span class="line-modified">180     long facVerValue      = verifyFact(localNumLoops);</span>
<span class="line-modified">181     if (facFunctionValue != facVerValue)</span>
<span class="line-modified">182       {</span>
<span class="line-modified">183         System.out.println(&quot;Factorial Computed Incorrectly&quot;);</span>
<span class="line-modified">184         System.out.println(&quot;Specific Factorial Requested &quot;+localNumLoops +&quot;!&quot;);</span>
<span class="line-modified">185         throw new TestFailure(&quot;Expected: &quot; + facVerValue + &quot; Actual &quot;+ facFunctionValue);</span>
<span class="line-modified">186       }</span>
<span class="line-modified">187 </span>
<span class="line-modified">188     Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-modified">189     Globals.callMethod(methodCallStr,summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">190   }</span>
<span class="line-modified">191 </span>
<span class="line-modified">192   public void fiboTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">193         throws InvocationTargetException</span>
<span class="line-modified">194   {</span>
<span class="line-modified">195     Globals.appendSumToSumationVector(MethodID[1], summation);</span>
<span class="line-modified">196 </span>
<span class="line-modified">197     if (CGT.shouldFinish())</span>
<span class="line-modified">198         return;</span>
<span class="line-modified">199 </span>
<span class="line-modified">200     if (Globals.VERBOSE)</span>
<span class="line-modified">201       System.out.println(&quot;test5.fiboTest&quot;);</span>
<span class="line-modified">202 </span>
<span class="line-modified">203     if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))</span>
<span class="line-modified">204       {</span>
<span class="line-modified">205         return;</span>
<span class="line-modified">206       }</span>
<span class="line-modified">207     MethodData methodCallStr;</span>
<span class="line-modified">208     Long numFcalls;</span>
<span class="line-modified">209     Integer staticFcalls;</span>
<span class="line-modified">210     if (staticFunctionDepth.intValue() &gt; 0)</span>
<span class="line-modified">211       {</span>
<span class="line-modified">212         numFcalls = functionDepth;</span>
<span class="line-modified">213         staticFcalls = new Integer(staticFunctionDepth.intValue()-1);</span>
<span class="line-modified">214         methodCallStr = Globals.returnNextStaticMethod(MethodID[1]);</span>
<span class="line-modified">215       }</span>
<span class="line-modified">216     else</span>
<span class="line-modified">217       {</span>
<span class="line-modified">218         numFcalls = new Long(functionDepth.longValue() -1);</span>
<span class="line-modified">219         staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">220         methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">221       }</span>
<span class="line-modified">222     int localNumLoops      = loopNumGen.nextInt(maxLoops*3);</span>
<span class="line-modified">223     long fiboFunctionValue = fibonacci(1,1,localNumLoops);</span>
<span class="line-modified">224     long fiboVerValue      = verifyFibo(localNumLoops);</span>
<span class="line-modified">225     if (fiboFunctionValue != fiboVerValue)</span>
<span class="line-modified">226       {</span>
<span class="line-modified">227         System.out.println(&quot;Fibonacci Series Computed Incorrectly&quot;);</span>
<span class="line-modified">228         System.out.println(&quot;Specific Digit Requested &quot;+localNumLoops);</span>
<span class="line-modified">229         throw new TestFailure(&quot;Expected: &quot; + fiboVerValue + &quot; Actual &quot;+ fiboFunctionValue);</span>
<span class="line-modified">230       }</span>
<span class="line-modified">231 </span>
<span class="line-modified">232     Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-modified">233     Globals.callMethod(methodCallStr,summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">234   }</span>
<span class="line-modified">235 </span>
<span class="line-modified">236 </span>
<span class="line-modified">237   public void combTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">238         throws InvocationTargetException</span>
<span class="line-modified">239   {</span>
<span class="line-modified">240     Globals.appendSumToSumationVector(MethodID[2], summation);</span>
<span class="line-modified">241 </span>
<span class="line-modified">242     if (CGT.shouldFinish())</span>
<span class="line-modified">243         return;</span>
<span class="line-modified">244 </span>
<span class="line-modified">245     if (Globals.VERBOSE)</span>
<span class="line-modified">246       System.out.println(&quot;test5.combTest&quot;);</span>
<span class="line-modified">247 </span>
<span class="line-modified">248     if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))</span>
<span class="line-modified">249       {</span>
<span class="line-modified">250         return;</span>
<span class="line-modified">251       }</span>
<span class="line-modified">252     MethodData methodCallStr;</span>
<span class="line-modified">253     Long numFcalls;</span>
<span class="line-modified">254     Integer staticFcalls;</span>
<span class="line-modified">255     if (staticFunctionDepth.intValue() &gt; 0)</span>
<span class="line-modified">256       {</span>
<span class="line-modified">257         numFcalls = functionDepth;</span>
<span class="line-modified">258         staticFcalls = new Integer(staticFunctionDepth.intValue()-1);</span>
<span class="line-modified">259 </span>
<span class="line-modified">260         methodCallStr = Globals.returnNextStaticMethod(MethodID[2]);</span>
<span class="line-modified">261         //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[2]));</span>
<span class="line-modified">262       }</span>
<span class="line-modified">263     else</span>
<span class="line-modified">264       {</span>
<span class="line-modified">265         numFcalls = new Long(functionDepth.longValue() -1);</span>
<span class="line-modified">266         staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">267         methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">268       }</span>
<span class="line-modified">269     int n = loopNumGen.nextInt(maxLoops);</span>
<span class="line-modified">270     int k = (n&gt;0)?loopNumGen.nextInt(n):0;</span>
<span class="line-modified">271     long combFunctionValue = combination(n, k);</span>
<span class="line-modified">272     long combVerValue      = verifyComb(n, k);</span>
<span class="line-modified">273     if (combFunctionValue != combVerValue)</span>
<span class="line-modified">274       {</span>
<span class="line-modified">275         System.out.println(&quot;Combination Computed Incorrectly&quot;);</span>
<span class="line-modified">276         System.out.println(&quot;N = &quot; + n +&quot;K = &quot; + k);</span>
<span class="line-modified">277         throw new TestFailure(&quot;Expected: &quot; + combVerValue + &quot; Actual &quot;+ combFunctionValue);</span>
<span class="line-modified">278       }</span>
<span class="line-modified">279 </span>
<span class="line-modified">280     Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-modified">281     Globals.callMethod(methodCallStr,summation, ID, numFcalls, staticFcalls);</span>
<span class="line-modified">282   }</span>
<span class="line-modified">283 </span>
<span class="line-modified">284 </span>
<span class="line-modified">285   public void pascalTest(Vector summation, Vector ID, Long functionDepth, Integer staticFunctionDepth)</span>
<span class="line-modified">286         throws InvocationTargetException</span>
<span class="line-modified">287   {</span>
<span class="line-modified">288     Globals.appendSumToSumationVector(MethodID[3], summation);</span>
<span class="line-modified">289 </span>
<span class="line-modified">290     if (CGT.shouldFinish())</span>
<span class="line-modified">291         return;</span>
<span class="line-modified">292 </span>
<span class="line-modified">293 int [] x = new int[1 &lt;&lt; 30];</span>
<span class="line-modified">294 x[1 &lt;&lt; 24] = 1;</span>
<span class="line-modified">295 </span>
<span class="line-modified">296     if (Globals.VERBOSE)</span>
<span class="line-modified">297       System.out.println(&quot;test5.pascalTest&quot;);</span>
<span class="line-modified">298 </span>
<span class="line-modified">299     if ((functionDepth.longValue() &lt;= 0) &amp;&amp; (staticFunctionDepth.intValue() &lt;=  0))</span>
<span class="line-modified">300       {</span>
<span class="line-modified">301         return;</span>
<span class="line-modified">302       }</span>
<span class="line-modified">303     MethodData methodCallStr;</span>
<span class="line-modified">304     Long numFcalls;</span>
<span class="line-modified">305     Integer staticFcalls;</span>
<span class="line-modified">306     if (staticFunctionDepth.intValue() &gt; 0)</span>
<span class="line-modified">307       {</span>
<span class="line-modified">308         numFcalls = functionDepth;</span>
<span class="line-modified">309         staticFcalls = new Integer(staticFunctionDepth.intValue()-1);</span>
<span class="line-modified">310         methodCallStr = Globals.returnNextStaticMethod(MethodID[3]);</span>
<span class="line-modified">311         //methodCallStr = Globals.nextStaticMethod(Globals.getIndexFromID(MethodID[3]));</span>
<span class="line-modified">312       }</span>
<span class="line-modified">313     else</span>
<span class="line-modified">314       {</span>
<span class="line-modified">315         numFcalls = new Long(functionDepth.longValue() -1);</span>
<span class="line-modified">316         staticFcalls = staticFunctionDepth;</span>
<span class="line-modified">317         methodCallStr = Globals.nextRandomMethod();</span>
<span class="line-modified">318       }</span>
<span class="line-modified">319     int num = loopNumGen.nextInt(maxLoops);</span>
<span class="line-modified">320 </span>
<span class="line-modified">321     int[] pascalFunctionValue = pascalsTriangle(new int[] {1}, num);</span>
<span class="line-modified">322     int[] pascalVerValue      = verifyPascal(num);</span>
<span class="line-modified">323     if (!verifyArray(pascalFunctionValue, pascalVerValue))</span>
<span class="line-removed">324       {</span>
<span class="line-removed">325         String temp = new String(&quot;Expected: &quot;);</span>
<span class="line-removed">326         for (int i=0; i&lt;pascalVerValue.length; i++)</span>
<span class="line-removed">327           temp += pascalVerValue[i] +&quot;, &quot;;</span>
<span class="line-removed">328         temp+=  &quot; Actual &quot;;</span>
<span class="line-removed">329         for (int i=0; i&lt;pascalFunctionValue.length; i++)</span>
<span class="line-removed">330           temp += pascalFunctionValue[i] +&quot;, &quot;;</span>
<span class="line-removed">331         System.out.println(&quot;Pascal Tringle Row Computed Incorrectly&quot;);</span>
<span class="line-removed">332         System.out.println(&quot;Row Number &quot; + num);</span>
<span class="line-removed">333         throw new TestFailure(temp);</span>
<span class="line-removed">334       }</span>
<span class="line-removed">335 </span>
<span class="line-removed">336     Globals.addFunctionIDToVector(methodCallStr.id, ID);</span>
<span class="line-removed">337     Globals.callMethod(methodCallStr,summation, ID, numFcalls, staticFcalls);</span>
<span class="line-removed">338   }</span>
339 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
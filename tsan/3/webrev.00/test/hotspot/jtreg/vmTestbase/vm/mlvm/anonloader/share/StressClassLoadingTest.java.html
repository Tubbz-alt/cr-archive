<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/vm/mlvm/anonloader/share/StressClassLoadingTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package vm.mlvm.anonloader.share;
 25 
 26 import java.io.File;
 27 import java.util.Objects;
 28 import java.util.concurrent.atomic.AtomicBoolean;
 29 import java.nio.file.Files;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import nsk.share.test.Stresser;
 33 import vm.share.options.Option;
 34 import vm.share.options.OptionSupport;
 35 import vm.share.options.IgnoreUnknownArgumentsHandler;
 36 import vm.mlvm.share.Env;
 37 import vm.mlvm.share.MlvmTest;
 38 import vm.mlvm.share.CustomClassLoaders;
 39 import vm.share.FileUtils;
 40 import vm.share.UnsafeAccess;
 41 
 42 /**
 43  * Does stress-testing of class loading subsystem.
 44  * This class should be subclassed by the tests
 45  * to provide test class data.
 46  *
 47  * &lt;p&gt;StressClassLoadingTest performs a number of iterations
 48  * (the default value is 100 000).
 49  * Each iteration gets class bytes from the subclass
 50  * and loads it into JVM using either:
 51  * &lt;ul&gt;
 52  *    &lt;li&gt;a custom {@link java.lang.ClassLoader} implementation or
 53  *    &lt;li&gt;{@link sun.misc.Unsafe#defineAnonymousClass} call.
 54  * &lt;/ul&gt;
 55  *
 56  * &lt;p&gt;Loading is done in a separate thread. If this thread is stuck,
 57  * it is killed after some timeout (default is 10 seconds, please see
 58  * -parseTimeout option). The class file is saved as hangXX.class, where XX
 59  * starts at 00 and is increased on every hangup.
 60  * A prefix can be added to the file name using {@link #setFileNamePrefix}
 61  *
 62  * &lt;p&gt;The test fails, if there were hangups.
 63  *
 64  * &lt;p&gt;By default, before loading class, the bytes are
 65  * saved to {@code _AnonkTestee01.class} file in the current directory.
 66  * If JVM crashes, the bytecodes can be analysed.
 67  * Class saving is controlled by -saveClassFile option.
 68  * A prefix can be added to the file name using {@link #setFileNamePrefix}
 69  * function.
 70  *
 71  * &lt;p&gt;There is a tool to load the saved .class file.
 72  * The tool tries to load class using a number of class loaders. For more
 73  * information, please see tool documentation: {@link vm.mlvm.tools.LoadClass}.
 74  *
 75  * @see vm.mlvm.tools.LoadClass
 76  */
 77 public abstract class StressClassLoadingTest extends MlvmTest {
 78     private static final String RESCUE_FILE_NAME = &quot;_AnonkTestee01.class&quot;;
 79     private static final String HUNG_CLASS_FILE_NAME = &quot;hang.class&quot;;
 80 
 81     @Option(name = &quot;iterations&quot;, default_value = &quot;100000&quot;,
 82             description = &quot;How many times generate a class and parse it&quot;)
 83     private static int iterations;
 84 
 85     @Option(name = &quot;saveClassFile&quot;, default_value = &quot;true&quot;,
 86             description = &quot;Save generated class file before loading.&quot;
 87                     + &quot; Useful when VM crashes on loading&quot;)
 88     private static boolean saveClassFile;
 89 
 90     @Option(name = &quot;parseTimeout&quot;, default_value = &quot;10000&quot;,
 91             description = &quot;Timeout in millisectionds to detect hung parser&quot;
 92                     + &quot; thread. The parser thread is killed after the timeout&quot;)
 93     private static int parseTimeout;
 94 
 95     @Option(name = &quot;unsafeLoad&quot;, default_value = &quot;false&quot;,
 96             description = &quot;An option for adhoc experiments: load class via &quot;
 97                     + &quot;Unsafe.defineAnonymousClass(). Since in this way the &quot;
 98                     + &quot;loading process skips several security checks, if the &quot;
 99                     + &quot;class is not valid, crashes and assertions are normal.&quot;)
100     private static boolean unsafeLoad;
101 
102     private String fileNamePrefix = &quot;&quot;;
103 
104     private final static AtomicBoolean classFileMessagePrinted
105             = new AtomicBoolean(false);
106 
107     /**
108      * Sets prefix for names of the files, created by test:
109      * _AnonkTestee01.class and hangXX.class.
110      *
111      * @param p a prefix to add before file name.
112      * @throws java.lang.NullPointerException if p is null
113      */
114     public void setFileNamePrefix(String p) {
115         Objects.requireNonNull(p);
116         fileNamePrefix = p;
117     }
118 
119     static volatile boolean optionsSetup = false;
120     public static void setupOptions(Object instance) {
121         if (!optionsSetup) {
122             synchronized (StressClassLoadingTest.class) {
123                 if (!optionsSetup) {
124                     OptionSupport.setup(instance, Env.getArgParser().getRawArguments(), new IgnoreUnknownArgumentsHandler());
125                     optionsSetup = true;
126 
127                     Env.traceNormal(&quot;StressClassLoadingTest options: iterations: &quot; + iterations);
128                     Env.traceNormal(&quot;StressClassLoadingTest options: unsafeLoad: &quot; + unsafeLoad);
129                     Env.traceNormal(&quot;StressClassLoadingTest options: parseTimeout: &quot; + parseTimeout);
130                     Env.traceNormal(&quot;StressClassLoadingTest options: saveClassFile: &quot; + saveClassFile);
131                 }
132             }
133         }
134     }
135 
136     public boolean run() throws Exception {
137         setupOptions(this);
138 
139         Stresser stresser = createStresser();
140         stresser.start(iterations);
141 
142         while (stresser.continueExecution()) {
143             stresser.iteration();
144 
145             byte[] classBytes = generateClassBytes();
146             Class&lt;?&gt; hostClass = getHostClass();
147             String className = hostClass.getName();
148             File rescueFile = new File(String.format(&quot;%s_%d_%s&quot;,
149                     fileNamePrefix, stresser.getIteration(), RESCUE_FILE_NAME));
150             if (saveClassFile) {
151                 // Write out the class file being loaded.  It&#39;s useful
152                 // to have if the JVM crashes.
153                 FileUtils.writeBytesToFile(rescueFile, classBytes);
154                 if (classFileMessagePrinted.compareAndSet(false, true)) {
155                     Env.traceImportant(&quot;If the JVM crashes then &quot;
156                             + &quot;the class file causing the crash is saved as *_*_&quot;
157                             + RESCUE_FILE_NAME);
158                 }
159             }
160 
161             Thread parserThread  = new Thread() {
162                 public void run() {
163                     try {
164                         Class&lt;?&gt; c;
165                         if (unsafeLoad) {
166                             c = UnsafeAccess.unsafe.defineAnonymousClass(hostClass, classBytes, null);
167                         } else {
168                             c = CustomClassLoaders.makeClassBytesLoader(classBytes, className)
169                                     .loadClass(className);
170                         }
171                         UnsafeAccess.unsafe.ensureClassInitialized(c);
172                     } catch (Throwable e) {
173                         Env.traceVerbose(e, &quot;parser caught exception&quot;);
174                     }
175                 }
176             };
177 
178             parserThread.start();
179             parserThread.join(parseTimeout);
180 
181             if (parserThread.isAlive()) {
182                 Env.traceImportant(&quot;parser thread may be hung!&quot;);
183                 StackTraceElement[] stack = parserThread.getStackTrace();
184                 Env.traceImportant(&quot;parser thread stack len: &quot; + stack.length);
185                 Env.traceImportant(parserThread + &quot; stack trace:&quot;);
186                 for (int i = 0; i &lt; stack.length; ++i) {
187                     Env.traceImportant(parserThread + &quot;\tat &quot; + stack[i]);
188                 }
189 
190                 Path savedClassPath = Paths.get(fileNamePrefix + HUNG_CLASS_FILE_NAME);
191 
192                 if (saveClassFile) {
193                     Files.move(rescueFile.toPath(), savedClassPath);
194                     Env.traceImportant(&quot;There was a possible hangup during parsing.&quot;
195                         + &quot; The class file, which produced the possible hangup, was saved as &quot;
196                         + fileNamePrefix + HUNG_CLASS_FILE_NAME
197                         + &quot;... in the test directory. You may want to analyse it &quot;
198                         + &quot;if this test times out.&quot;);
199                 }
200 
201                 parserThread.join(); // Wait until either thread finishes or test times out.
202                 if (saveClassFile) {
203                     savedClassPath.toFile().delete();
204                 }
205             } else if (saveClassFile) {
206                 rescueFile.delete();
207             }
208         }
209 
210         stresser.finish();
211         return true;
212     }
213 
214     /**
215      * Generated class bytes. The method is called for each iteration.
216      *
217      * @return Byte array with the generated class
218      */
219     protected abstract byte[] generateClassBytes();
220 
221     /**
222      * Returns a host class for the generated class.
223      *
224      * @return A host class that for the generated class
225      */
226     protected abstract Class&lt;?&gt; getHostClass();
227 }
    </pre>
  </body>
</html>
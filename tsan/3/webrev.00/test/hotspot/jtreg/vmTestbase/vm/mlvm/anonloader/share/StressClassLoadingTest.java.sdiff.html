<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/vm/mlvm/anonloader/share/StressClassLoadingTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../nsk/stress/thread/thread006.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../stress/parallelLoad/Test.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/vm/mlvm/anonloader/share/StressClassLoadingTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package vm.mlvm.anonloader.share;
 25 
 26 import java.io.File;
 27 import java.util.Objects;
 28 import java.util.concurrent.atomic.AtomicBoolean;
 29 import java.nio.file.Files;

 30 import java.nio.file.Paths;
 31 import nsk.share.test.Stresser;
 32 import vm.share.options.Option;
 33 import vm.share.options.OptionSupport;
 34 import vm.share.options.IgnoreUnknownArgumentsHandler;
 35 import vm.mlvm.share.Env;
 36 import vm.mlvm.share.MlvmTest;
 37 import vm.mlvm.share.CustomClassLoaders;
 38 import vm.share.FileUtils;
 39 import vm.share.UnsafeAccess;
 40 
 41 /**
 42  * Does stress-testing of class loading subsystem.
 43  * This class should be subclassed by the tests
 44  * to provide test class data.
 45  *
 46  * &lt;p&gt;StressClassLoadingTest performs a number of iterations
 47  * (the default value is 100 000).
 48  * Each iteration gets class bytes from the subclass
 49  * and loads it into JVM using either:
</pre>
<hr />
<pre>
 58  * starts at 00 and is increased on every hangup.
 59  * A prefix can be added to the file name using {@link #setFileNamePrefix}
 60  *
 61  * &lt;p&gt;The test fails, if there were hangups.
 62  *
 63  * &lt;p&gt;By default, before loading class, the bytes are
 64  * saved to {@code _AnonkTestee01.class} file in the current directory.
 65  * If JVM crashes, the bytecodes can be analysed.
 66  * Class saving is controlled by -saveClassFile option.
 67  * A prefix can be added to the file name using {@link #setFileNamePrefix}
 68  * function.
 69  *
 70  * &lt;p&gt;There is a tool to load the saved .class file.
 71  * The tool tries to load class using a number of class loaders. For more
 72  * information, please see tool documentation: {@link vm.mlvm.tools.LoadClass}.
 73  *
 74  * @see vm.mlvm.tools.LoadClass
 75  */
 76 public abstract class StressClassLoadingTest extends MlvmTest {
 77     private static final String RESCUE_FILE_NAME = &quot;_AnonkTestee01.class&quot;;
<span class="line-modified"> 78     private static final String HUNG_CLASS_FILE_NAME = &quot;hang%02d.class&quot;;</span>
 79 
 80     @Option(name = &quot;iterations&quot;, default_value = &quot;100000&quot;,
 81             description = &quot;How many times generate a class and parse it&quot;)
 82     private static int iterations;
 83 
 84     @Option(name = &quot;saveClassFile&quot;, default_value = &quot;true&quot;,
 85             description = &quot;Save generated class file before loading.&quot;
 86                     + &quot; Useful when VM crashes on loading&quot;)
 87     private static boolean saveClassFile;
 88 
 89     @Option(name = &quot;parseTimeout&quot;, default_value = &quot;10000&quot;,
 90             description = &quot;Timeout in millisectionds to detect hung parser&quot;
 91                     + &quot; thread. The parser thread is killed after the timeout&quot;)
 92     private static int parseTimeout;
 93 
 94     @Option(name = &quot;unsafeLoad&quot;, default_value = &quot;false&quot;,
 95             description = &quot;An option for adhoc experiments: load class via &quot;
 96                     + &quot;Unsafe.defineAnonymousClass(). Since in this way the &quot;
 97                     + &quot;loading process skips several security checks, if the &quot;
 98                     + &quot;class is not valid, crashes and assertions are normal.&quot;)
</pre>
<hr />
<pre>
118     static volatile boolean optionsSetup = false;
119     public static void setupOptions(Object instance) {
120         if (!optionsSetup) {
121             synchronized (StressClassLoadingTest.class) {
122                 if (!optionsSetup) {
123                     OptionSupport.setup(instance, Env.getArgParser().getRawArguments(), new IgnoreUnknownArgumentsHandler());
124                     optionsSetup = true;
125 
126                     Env.traceNormal(&quot;StressClassLoadingTest options: iterations: &quot; + iterations);
127                     Env.traceNormal(&quot;StressClassLoadingTest options: unsafeLoad: &quot; + unsafeLoad);
128                     Env.traceNormal(&quot;StressClassLoadingTest options: parseTimeout: &quot; + parseTimeout);
129                     Env.traceNormal(&quot;StressClassLoadingTest options: saveClassFile: &quot; + saveClassFile);
130                 }
131             }
132         }
133     }
134 
135     public boolean run() throws Exception {
136         setupOptions(this);
137 
<span class="line-removed">138         int hangNum = 0;</span>
<span class="line-removed">139 </span>
140         Stresser stresser = createStresser();
141         stresser.start(iterations);
142 
143         while (stresser.continueExecution()) {
144             stresser.iteration();
145 
146             byte[] classBytes = generateClassBytes();
147             Class&lt;?&gt; hostClass = getHostClass();
148             String className = hostClass.getName();
149             File rescueFile = new File(String.format(&quot;%s_%d_%s&quot;,
150                     fileNamePrefix, stresser.getIteration(), RESCUE_FILE_NAME));
151             if (saveClassFile) {
152                 // Write out the class file being loaded.  It&#39;s useful
153                 // to have if the JVM crashes.
154                 FileUtils.writeBytesToFile(rescueFile, classBytes);
155                 if (classFileMessagePrinted.compareAndSet(false, true)) {
156                     Env.traceImportant(&quot;If the JVM crashes then &quot;
157                             + &quot;the class file causing the crash is saved as *_*_&quot;
158                             + RESCUE_FILE_NAME);
159                 }
160             }
161 
162             Thread parserThread  = new Thread() {
163                 public void run() {
164                     try {
165                         Class&lt;?&gt; c;
166                         if (unsafeLoad) {
167                             c = UnsafeAccess.unsafe.defineAnonymousClass(hostClass, classBytes, null);
168                         } else {
169                             c = CustomClassLoaders.makeClassBytesLoader(classBytes, className)
170                                     .loadClass(className);
171                         }
172                         UnsafeAccess.unsafe.ensureClassInitialized(c);
173                     } catch (Throwable e) {
174                         Env.traceVerbose(e, &quot;parser caught exception&quot;);
175                     }
176                 }
177             };
178 
<span class="line-removed">179             parserThread.setDaemon(true);</span>
180             parserThread.start();
181             parserThread.join(parseTimeout);
182 
183             if (parserThread.isAlive()) {
<span class="line-modified">184                 Env.complain(&quot;Killing parser thread&quot;);</span>
185                 StackTraceElement[] stack = parserThread.getStackTrace();

186                 Env.traceImportant(parserThread + &quot; stack trace:&quot;);
187                 for (int i = 0; i &lt; stack.length; ++i) {
188                     Env.traceImportant(parserThread + &quot;\tat &quot; + stack[i]);
189                 }
190 












191                 if (saveClassFile) {
<span class="line-modified">192                     Files.move(rescueFile.toPath(), Paths.get(fileNamePrefix</span>
<span class="line-removed">193                             + String.format(HUNG_CLASS_FILE_NAME, hangNum)));</span>
194                 }
<span class="line-removed">195                 ++hangNum;</span>
196             } else if (saveClassFile) {
197                 rescueFile.delete();
198             }
199         }
200 
201         stresser.finish();
<span class="line-removed">202 </span>
<span class="line-removed">203         if (hangNum &gt; 0) {</span>
<span class="line-removed">204             Env.complain(&quot;There were &quot; + hangNum + &quot; hangups during parsing.&quot;</span>
<span class="line-removed">205                     + &quot; The class files, which produced hangup were saved as &quot;</span>
<span class="line-removed">206                     + fileNamePrefix + String.format(HUNG_CLASS_FILE_NAME, 0)</span>
<span class="line-removed">207                     + &quot;... in the test directory. You may want to analyse them.&quot;</span>
<span class="line-removed">208                     + &quot; Failing this test because of hangups.&quot;);</span>
<span class="line-removed">209             return false;</span>
<span class="line-removed">210         }</span>
<span class="line-removed">211 </span>
212         return true;
213     }
214 
215     /**
216      * Generated class bytes. The method is called for each iteration.
217      *
218      * @return Byte array with the generated class
219      */
220     protected abstract byte[] generateClassBytes();
221 
222     /**
223      * Returns a host class for the generated class.
224      *
225      * @return A host class that for the generated class
226      */
227     protected abstract Class&lt;?&gt; getHostClass();
228 }
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package vm.mlvm.anonloader.share;
 25 
 26 import java.io.File;
 27 import java.util.Objects;
 28 import java.util.concurrent.atomic.AtomicBoolean;
 29 import java.nio.file.Files;
<span class="line-added"> 30 import java.nio.file.Path;</span>
 31 import java.nio.file.Paths;
 32 import nsk.share.test.Stresser;
 33 import vm.share.options.Option;
 34 import vm.share.options.OptionSupport;
 35 import vm.share.options.IgnoreUnknownArgumentsHandler;
 36 import vm.mlvm.share.Env;
 37 import vm.mlvm.share.MlvmTest;
 38 import vm.mlvm.share.CustomClassLoaders;
 39 import vm.share.FileUtils;
 40 import vm.share.UnsafeAccess;
 41 
 42 /**
 43  * Does stress-testing of class loading subsystem.
 44  * This class should be subclassed by the tests
 45  * to provide test class data.
 46  *
 47  * &lt;p&gt;StressClassLoadingTest performs a number of iterations
 48  * (the default value is 100 000).
 49  * Each iteration gets class bytes from the subclass
 50  * and loads it into JVM using either:
</pre>
<hr />
<pre>
 59  * starts at 00 and is increased on every hangup.
 60  * A prefix can be added to the file name using {@link #setFileNamePrefix}
 61  *
 62  * &lt;p&gt;The test fails, if there were hangups.
 63  *
 64  * &lt;p&gt;By default, before loading class, the bytes are
 65  * saved to {@code _AnonkTestee01.class} file in the current directory.
 66  * If JVM crashes, the bytecodes can be analysed.
 67  * Class saving is controlled by -saveClassFile option.
 68  * A prefix can be added to the file name using {@link #setFileNamePrefix}
 69  * function.
 70  *
 71  * &lt;p&gt;There is a tool to load the saved .class file.
 72  * The tool tries to load class using a number of class loaders. For more
 73  * information, please see tool documentation: {@link vm.mlvm.tools.LoadClass}.
 74  *
 75  * @see vm.mlvm.tools.LoadClass
 76  */
 77 public abstract class StressClassLoadingTest extends MlvmTest {
 78     private static final String RESCUE_FILE_NAME = &quot;_AnonkTestee01.class&quot;;
<span class="line-modified"> 79     private static final String HUNG_CLASS_FILE_NAME = &quot;hang.class&quot;;</span>
 80 
 81     @Option(name = &quot;iterations&quot;, default_value = &quot;100000&quot;,
 82             description = &quot;How many times generate a class and parse it&quot;)
 83     private static int iterations;
 84 
 85     @Option(name = &quot;saveClassFile&quot;, default_value = &quot;true&quot;,
 86             description = &quot;Save generated class file before loading.&quot;
 87                     + &quot; Useful when VM crashes on loading&quot;)
 88     private static boolean saveClassFile;
 89 
 90     @Option(name = &quot;parseTimeout&quot;, default_value = &quot;10000&quot;,
 91             description = &quot;Timeout in millisectionds to detect hung parser&quot;
 92                     + &quot; thread. The parser thread is killed after the timeout&quot;)
 93     private static int parseTimeout;
 94 
 95     @Option(name = &quot;unsafeLoad&quot;, default_value = &quot;false&quot;,
 96             description = &quot;An option for adhoc experiments: load class via &quot;
 97                     + &quot;Unsafe.defineAnonymousClass(). Since in this way the &quot;
 98                     + &quot;loading process skips several security checks, if the &quot;
 99                     + &quot;class is not valid, crashes and assertions are normal.&quot;)
</pre>
<hr />
<pre>
119     static volatile boolean optionsSetup = false;
120     public static void setupOptions(Object instance) {
121         if (!optionsSetup) {
122             synchronized (StressClassLoadingTest.class) {
123                 if (!optionsSetup) {
124                     OptionSupport.setup(instance, Env.getArgParser().getRawArguments(), new IgnoreUnknownArgumentsHandler());
125                     optionsSetup = true;
126 
127                     Env.traceNormal(&quot;StressClassLoadingTest options: iterations: &quot; + iterations);
128                     Env.traceNormal(&quot;StressClassLoadingTest options: unsafeLoad: &quot; + unsafeLoad);
129                     Env.traceNormal(&quot;StressClassLoadingTest options: parseTimeout: &quot; + parseTimeout);
130                     Env.traceNormal(&quot;StressClassLoadingTest options: saveClassFile: &quot; + saveClassFile);
131                 }
132             }
133         }
134     }
135 
136     public boolean run() throws Exception {
137         setupOptions(this);
138 


139         Stresser stresser = createStresser();
140         stresser.start(iterations);
141 
142         while (stresser.continueExecution()) {
143             stresser.iteration();
144 
145             byte[] classBytes = generateClassBytes();
146             Class&lt;?&gt; hostClass = getHostClass();
147             String className = hostClass.getName();
148             File rescueFile = new File(String.format(&quot;%s_%d_%s&quot;,
149                     fileNamePrefix, stresser.getIteration(), RESCUE_FILE_NAME));
150             if (saveClassFile) {
151                 // Write out the class file being loaded.  It&#39;s useful
152                 // to have if the JVM crashes.
153                 FileUtils.writeBytesToFile(rescueFile, classBytes);
154                 if (classFileMessagePrinted.compareAndSet(false, true)) {
155                     Env.traceImportant(&quot;If the JVM crashes then &quot;
156                             + &quot;the class file causing the crash is saved as *_*_&quot;
157                             + RESCUE_FILE_NAME);
158                 }
159             }
160 
161             Thread parserThread  = new Thread() {
162                 public void run() {
163                     try {
164                         Class&lt;?&gt; c;
165                         if (unsafeLoad) {
166                             c = UnsafeAccess.unsafe.defineAnonymousClass(hostClass, classBytes, null);
167                         } else {
168                             c = CustomClassLoaders.makeClassBytesLoader(classBytes, className)
169                                     .loadClass(className);
170                         }
171                         UnsafeAccess.unsafe.ensureClassInitialized(c);
172                     } catch (Throwable e) {
173                         Env.traceVerbose(e, &quot;parser caught exception&quot;);
174                     }
175                 }
176             };
177 

178             parserThread.start();
179             parserThread.join(parseTimeout);
180 
181             if (parserThread.isAlive()) {
<span class="line-modified">182                 Env.traceImportant(&quot;parser thread may be hung!&quot;);</span>
183                 StackTraceElement[] stack = parserThread.getStackTrace();
<span class="line-added">184                 Env.traceImportant(&quot;parser thread stack len: &quot; + stack.length);</span>
185                 Env.traceImportant(parserThread + &quot; stack trace:&quot;);
186                 for (int i = 0; i &lt; stack.length; ++i) {
187                     Env.traceImportant(parserThread + &quot;\tat &quot; + stack[i]);
188                 }
189 
<span class="line-added">190                 Path savedClassPath = Paths.get(fileNamePrefix + HUNG_CLASS_FILE_NAME);</span>
<span class="line-added">191 </span>
<span class="line-added">192                 if (saveClassFile) {</span>
<span class="line-added">193                     Files.move(rescueFile.toPath(), savedClassPath);</span>
<span class="line-added">194                     Env.traceImportant(&quot;There was a possible hangup during parsing.&quot;</span>
<span class="line-added">195                         + &quot; The class file, which produced the possible hangup, was saved as &quot;</span>
<span class="line-added">196                         + fileNamePrefix + HUNG_CLASS_FILE_NAME</span>
<span class="line-added">197                         + &quot;... in the test directory. You may want to analyse it &quot;</span>
<span class="line-added">198                         + &quot;if this test times out.&quot;);</span>
<span class="line-added">199                 }</span>
<span class="line-added">200 </span>
<span class="line-added">201                 parserThread.join(); // Wait until either thread finishes or test times out.</span>
202                 if (saveClassFile) {
<span class="line-modified">203                     savedClassPath.toFile().delete();</span>

204                 }

205             } else if (saveClassFile) {
206                 rescueFile.delete();
207             }
208         }
209 
210         stresser.finish();










211         return true;
212     }
213 
214     /**
215      * Generated class bytes. The method is called for each iteration.
216      *
217      * @return Byte array with the generated class
218      */
219     protected abstract byte[] generateClassBytes();
220 
221     /**
222      * Returns a host class for the generated class.
223      *
224      * @return A host class that for the generated class
225      */
226     protected abstract Class&lt;?&gt; getHostClass();
227 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../nsk/stress/thread/thread006.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../stress/parallelLoad/Test.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
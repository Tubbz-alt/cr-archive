<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jdi/EventIterator/nextEvent/nextevent001.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.EventIterator.nextEvent;
 25 
 26 import nsk.share.*;
 27 import nsk.share.jdi.*;
 28 
 29 import com.sun.jdi.*;
 30 import com.sun.jdi.event.*;
 31 import com.sun.jdi.request.*;
 32 
 33 import java.util.*;
 34 import java.io.*;
 35 
 36 /**
 37  * The test for the implementation of an object of the type     &lt;BR&gt;
 38  * EventIterator.                                               &lt;BR&gt;
 39  *                                                              &lt;BR&gt;
 40  * The test checks that results of the method                   &lt;BR&gt;
 41  * &lt;code&gt;com.sun.jdi.EventIterator.nextEvent()&lt;/code&gt;           &lt;BR&gt;
 42  * complies with its spec.                                      &lt;BR&gt;
 43  * &lt;BR&gt;
 44  * For each type of Events except for ClassUnloadEvent,                 &lt;BR&gt;
 45  * the cases to check are as follows:                                   &lt;BR&gt;
 46  * - the method returns Event object if there is an Event to return;    &lt;BR&gt;
 47  * - NoSuchElementException is thrown if no more events to return;      &lt;BR&gt;
 48  * - doesn&#39;t throw other Exceptions.                                    &lt;BR&gt;
 49  * &lt;BR&gt;
 50  * The test has three phases and works as follows.              &lt;BR&gt;
 51  * &lt;BR&gt;
 52  * In first phase,                                                      &lt;BR&gt;
 53  * upon launching debuggee&#39;s VM which will be suspended,                &lt;BR&gt;
 54  * a debugger waits for the VMStartEvent within a predefined            &lt;BR&gt;
 55  * time interval. If no the VMStartEvent received, the test is FAILED.  &lt;BR&gt;
 56  * Upon getting the VMStartEvent, it saves its EventSet into            &lt;BR&gt;
 57  * a special array and makes the request for debuggee&#39;s                 &lt;BR&gt;
 58  * ClassPrepareEvent with SUSPEND_EVENT_THREAD, resumes the VM,         &lt;BR&gt;
 59  * and waits for the event within the predefined time interval.         &lt;BR&gt;
 60  * If no the ClassPrepareEvent received, the test is FAILED.            &lt;BR&gt;
 61  * Upon getting the ClassPrepareEvent,                                  &lt;BR&gt;
 62  * the debugger saves its EventSet into the array and                   &lt;BR&gt;
 63  * sets up the breakpoint with SUSPEND_EVENT_THREAD                     &lt;BR&gt;
 64  * within debuggee&#39;s special methodForCommunication().                  &lt;BR&gt;
 65  * &lt;BR&gt;
 66  * In second phase the debugger and the debuggee perform the following. &lt;BR&gt;
 67  * - The debugger creates ThreadStartRequest and ThreadDeathRequest,    &lt;BR&gt;
 68  *   resumes the debuggee, and                                          &lt;BR&gt;
 69  *   waits for corresponding ThreadStartEvent and ThreadDeathEvent.     &lt;BR&gt;
 70  * - The debuggee creates new thread,  named &quot;thread2&quot;,                 &lt;BR&gt;
 71  *   whose running creates the above events.                            &lt;BR&gt;
 72  * - Upon getting the events, the debugger saves their sets in the array,&lt;BR&gt;
 73  *   resumes the debuggee and waits for the BreakpointEvent.            &lt;BR&gt;
 74  * - The debuggee creates a number of threads, one for each             &lt;BR&gt;
 75  *   following event: AccessWatchpoint, ModificationWatchpoint,         &lt;BR&gt;
 76  *   MethodEntry, MethodExit, Step, Exception, and Breakpoint,          &lt;BR&gt;
 77  *   and invokes the methodForCommunication to be suspended and         &lt;BR&gt;
 78  *   to inform the debugger with the event.                             &lt;BR&gt;
 79  * - Upon getting the BreakpointForCommunication, the debugger          &lt;BR&gt;
 80  *   gets ThreadReferences mirroring all tested threads in the debuggee,&lt;BR&gt;
 81  *   sets up Requests within them to get EventSets to check up on,      &lt;BR&gt;
 82  *   resumes the debuggee, waits for events, and upon getting them,     &lt;BR&gt;
 83  *   saves its EventSets into the array.                                &lt;BR&gt;
 84  * &lt;BR&gt;
 85  * In third phase,at the end                                            &lt;BR&gt;
 86  * the debuggee changes the value of the &quot;instruction&quot;                  &lt;BR&gt;
 87  * to inform the debugger of checks finished, and ends.                 &lt;BR&gt;
 88  * The debugger waits for VMDeathEvent and VMDisconnectEvent, and       &lt;BR&gt;
 89  * upon getting them, saves their EventSets into the array.             &lt;BR&gt;
 90  * Finally, the debugger, using the array of EventSets,                 &lt;BR&gt;
 91  * checks up on their EventIterators.                                   &lt;BR&gt;
 92  * &lt;BR&gt;
 93  * Note. To inform each other of needed actions, the debugger and       &lt;BR&gt;
 94  *       and the debuggee use debuggee&#39;s variable &quot;instruction&quot;.        &lt;BR&gt;
 95  * &lt;BR&gt;
 96  */
 97 
 98 public class nextevent001 {
 99 
100     //----------------------------------------------------- templete section
101     static final int PASSED = 0;
102     static final int FAILED = 2;
103     static final int PASS_BASE = 95;
104 
105     //----------------------------------------------------- templete parameters
106     static final String
107     sHeader1 = &quot;\n==&gt; nsk/jdi/EventIterator/nextEvent/nextevent001 &quot;,
108     sHeader2 = &quot;--&gt; debugger: &quot;,
109     sHeader3 = &quot;##&gt; debugger: &quot;;
110 
111     //----------------------------------------------------- main method
112 
113     public static void main (String argv[]) {
114 
115         int result = run(argv, System.out);
116 
117         System.exit(result + PASS_BASE);
118     }
119 
120     public static int run (String argv[], PrintStream out) {
121 
122         int exitCode = new nextevent001().runThis(argv, out);
123 
124         if (exitCode != PASSED) {
125             System.out.println(&quot;TEST FAILED&quot;);
126         }
127         return testExitCode;
128     }
129 
130     //--------------------------------------------------   log procedures
131 
132     private static Log  logHandler;
133 
134     private static void log1(String message) {
135         logHandler.display(sHeader1 + message);
136     }
137     private static void log2(String message) {
138         logHandler.display(sHeader2 + message);
139     }
140     private static void log3(String message) {
141         logHandler.complain(sHeader3 + message);
142     }
143 
144     //  ************************************************    test parameters
145 
146     private String debuggeeName =
147         &quot;nsk.jdi.EventIterator.nextEvent.nextevent001a&quot;;
148 
149     private String testedClassName =
150       &quot;nsk.jdi.EventIterator.nextEvent.TestClass&quot;;
151 
152     //====================================================== test program
153     //------------------------------------------------------ common section
154 
155     static Debugee          debuggee;
156     static ArgumentHandler  argsHandler;
157 
158     static int waitTime;
159 
160     static VirtualMachine      vm            = null;
161     static EventRequestManager eventRManager = null;
162     static EventQueue          eventQueue    = null;
163     static EventSet            eventSet      = null;
164     static EventIterator       eventIterator = null;
165 
166     static ReferenceType       debuggeeClass = null;
167 
168     static int  testExitCode = PASSED;
169 
170 
171     //  Event #:
172     //  0-6  : AccessWatchpoint, ModificationWatchpoint, Breakpoint, Exception,
173     //         MethodEntry, MethodExit, Step
174     //  7-8  : ClassPrepare, ClassUnload
175     //  9-10 : ThreadDeath, ThreadStart
176     // 11-13 : VMDeath, VMDisconnect, VMStart
177 
178     EventSet     eventSets[] = new EventSet [14];
179     EventRequest eRequests[] = new EventRequest[14];
180 
181     int eventFlags[] = { 0,0,0,0, 0,0,0,0, 3,0,0,0, 1,1 };
182 
183     //------------------------------------------------------ methods
184 
185     private int runThis (String argv[], PrintStream out) {
186 
187         argsHandler     = new ArgumentHandler(argv);
188         logHandler      = new Log(out, argsHandler);
189         Binder binder   = new Binder(argsHandler, logHandler);
190 
191         waitTime        = argsHandler.getWaitTime() * 60000;
192 
193         try {
194             log2(&quot;launching a debuggee :&quot;);
195             log2(&quot;       &quot; + debuggeeName);
196             if (argsHandler.verbose()) {
197                 debuggee = binder.bindToDebugeeNoWait(debuggeeName + &quot; -vbs&quot;);
198             } else {
199                 debuggee = binder.bindToDebugeeNoWait(debuggeeName);
200             }
201             if (debuggee == null) {
202                 log3(&quot;ERROR: no debuggee launched&quot;);
203                 return FAILED;
204             }
205             log2(&quot;debuggee launched&quot;);
206         } catch ( Exception e ) {
207             log3(&quot;ERROR: Exception : &quot; + e);
208             log2(&quot;       test cancelled&quot;);
209             return FAILED;
210         }
211 
212         debuggee.redirectOutput(logHandler);
213 
214         vm = debuggee.VM();
215 
216         eventQueue = vm.eventQueue();
217         if (eventQueue == null) {
218             log3(&quot;ERROR: eventQueue == null : TEST ABORTED&quot;);
219             vm.exit(PASS_BASE);
220             return FAILED;
221         }
222 
223         log2(&quot;invocation of the method runTest()&quot;);
224         switch (runTest()) {
225 
226             case 0 :  log2(&quot;test phase has finished normally&quot;);
227                       log2(&quot;   waiting for the debuggee to finish ...&quot;);
228                       debuggee.waitFor();
229 
230                       log2(&quot;......getting the debuggee&#39;s exit status&quot;);
231                       int status = debuggee.getStatus();
232                       if (status != PASS_BASE) {
233                           log3(&quot;ERROR: debuggee returned UNEXPECTED exit status: &quot; +
234                               status + &quot; != PASS_BASE&quot;);
235                           testExitCode = FAILED;
236                       } else {
237                           log2(&quot;......debuggee returned expected exit status: &quot; +
238                               status + &quot; == PASS_BASE&quot;);
239                       }
240                       break;
241 
242             default : log3(&quot;ERROR: runTest() returned unexpected value&quot;);
243 
244             case 1 :  log3(&quot;test phase has not finished normally: debuggee is still alive&quot;);
245                       log2(&quot;......forcing: vm.exit();&quot;);
246                       testExitCode = FAILED;
247                       try {
248                           vm.exit(PASS_BASE);
249                       } catch ( Exception e ) {
250                           log3(&quot;ERROR: Exception : e&quot;);
251                       }
252                       break;
253 
254             case 2 :  log3(&quot;test cancelled due to VMDisconnectedException&quot;);
255                       log2(&quot;......trying: vm.process().destroy();&quot;);
256                       testExitCode = FAILED;
257                       try {
258                           Process vmProcess = vm.process();
259                           if (vmProcess != null) {
260                               vmProcess.destroy();
261                           }
262                       } catch ( Exception e ) {
263                           log3(&quot;ERROR: Exception : e&quot;);
264                       }
265                       break;
266             }
267 
268         return testExitCode;
269     }
270 
271 
272    /*
273     * Return value: 0 - normal end of the test
274     *               1 - ubnormal end of the test
275     *               2 - VMDisconnectedException while test phase
276     */
277 
278     private int runTest() {
279 
280         try {
281             log2(&quot;waiting for VMStartEvent&quot;);
282             getEventSet();
283 //
284             eventSets[13] = eventSet;
285             if (eventIterator.nextEvent() instanceof VMStartEvent) {
286                 log2(&quot;VMStartEvent received; test begins&quot;);
287 
288                 testRun();
289 
290                 log2(&quot;waiting for VMDeathEvent&quot;);
291                 getEventSet();
292                 eventSets[11] = eventSet;
293                 if ( !(eventIterator.nextEvent() instanceof VMDeathEvent) ) {
294                     log3(&quot;ERROR: last event is not the VMDeathEvent&quot;);
295                     return 1;
296                 }
297 
298                 log2(&quot;waiting for VMDisconnectEvent&quot;);
299                 getEventSet();
300 //
301                 eventSets[12] = eventSet;
302                 if ( !(eventIterator.nextEvent() instanceof VMDisconnectEvent) ) {
303                     log3(&quot;ERROR: last event is not the VMDisconnectEvent&quot;);
304                     return 1;
305                 }
306 
307                 check();
308                 return 0;
309             } else {
310                 log3(&quot;ERROR: first event is not the VMStartEvent&quot;);
311                 return 1;
312             }
313         } catch ( VMDisconnectedException e ) {
314             log3(&quot;ERROR: VMDisconnectedException : &quot; + e);
315             return 2;
316         } catch ( Exception e ) {
317             log3(&quot;ERROR: Exception : &quot; + e);
318             return 1;
319         }
320 
321     }
322 
323     private void testRun()
324                  throws JDITestRuntimeException, Exception {
325 
326         eventRManager = vm.eventRequestManager();
327 
328         ClassPrepareRequest cpRequest = eventRManager.createClassPrepareRequest();
329         cpRequest.setSuspendPolicy( EventRequest.SUSPEND_EVENT_THREAD);
330         cpRequest.addClassFilter(debuggeeName);
331 
332         log2(&quot;......setting up ClassPrepareRequest&quot;);
333         eRequests[7] = cpRequest;
334 
335         cpRequest.enable();
336         vm.resume();
337 
338         getEventSet();
339         eventSets[7] = eventSet;
340 
341         cpRequest.disable();
342 
343         ClassPrepareEvent event = (ClassPrepareEvent) eventIterator.next();
344         debuggeeClass = event.referenceType();
345 
346         if (!debuggeeClass.name().equals(debuggeeName))
347            throw new JDITestRuntimeException(&quot;** Unexpected ClassName for ClassPrepareEvent **&quot;);
348 
349         log2(&quot;      received: ClassPrepareEvent for debuggeeClass&quot;);
350 
351         log2(&quot;......setting up ClassPrepareEvent&quot;);
352 
353         String bPointMethod = &quot;methodForCommunication&quot;;
354         String lineForComm  = &quot;lineForComm&quot;;
355         BreakpointRequest bpRequest;
356 
357         ThreadReference mainThread = debuggee.threadByNameOrThrow(&quot;main&quot;);
358 
359         bpRequest = settingBreakpoint(mainThread,
360                                       debuggeeClass,
361                                       bPointMethod, lineForComm, &quot;zero&quot;);
362         bpRequest.enable();
363 
364     //------------------------------------------------------  testing section
365 
366         log1(&quot;     TESTING BEGINS&quot;);
367 
368         {
369             log2(&quot;......setting up ThreadStartRequest&quot;);
370             ThreadStartRequest tsr = eventRManager.createThreadStartRequest();
371             tsr.addCountFilter(1);
372             tsr.setSuspendPolicy(EventRequest.SUSPEND_ALL);
373             tsr.putProperty(&quot;number&quot;, &quot;ThreadStartRequest&quot;);
374             tsr.enable();
375 
376             eRequests[10] = tsr;
377 
378             log2(&quot;......setting up ThreadDeathRequest&quot;);
379             ThreadDeathRequest tdr = eventRManager.createThreadDeathRequest();
380             tdr.addCountFilter(1);
381             tdr.setSuspendPolicy(EventRequest.SUSPEND_ALL);
382             tsr.putProperty(&quot;number&quot;, &quot;ThreadDeathRequest&quot;);
383             tdr.enable();
384 
385             eRequests[9] = tdr;
386 
387             log2(&quot;......vm.resume();&quot;);
388             vm.resume();
389 
390             log2(&quot;......waiting for ThreadStartEvent&quot;);
391             getEventSet();
392             eventSets[10] = eventSet;
393 
394             Event receivedEvent = eventIterator.nextEvent();
395             if ( !(receivedEvent instanceof ThreadStartEvent) ) {
396                 testExitCode = FAILED;
397                 log3(&quot;ERROR: new event is not ThreadStartEvent: &quot; + receivedEvent);
398                 return;
399             }
400             tsr.disable();
401 
402             log2(&quot;......vm.resume();&quot;);
403             vm.resume();
404 
405             log2(&quot;......waiting for ThreadDeathEvent&quot;);
406             getEventSet();
407             eventSets[9] = eventSet;
408             receivedEvent = eventIterator.nextEvent();
409             if ( !(receivedEvent instanceof ThreadDeathEvent) ) {
410                 testExitCode = FAILED;
411                 log3(&quot;ERROR: new event is not ThreadDeathEvent: &quot; + receivedEvent);
412                 return;
413             }
414             tdr.disable();
415         }
416 
417         for (int i = 0; ; i++) {
418 
419             vm.resume();
420             breakpointForCommunication();
421 
422             int instruction = ((IntegerValue)
423                                (debuggeeClass.getValue(debuggeeClass.fieldByName(&quot;instruction&quot;)))).value();
424 
425             if (instruction == 0) {
426                 vm.resume();
427                 break;
428             }
429 
430             log1(&quot;:::::: case: # &quot; + i);
431 
432             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ variable part
433 
434             String bpLineName        = &quot;breakpointLine&quot;;
435             String bpMethodName      = &quot;method&quot;;
436             String awFieldName       = &quot;awFieldName&quot;;
437             String mwFieldName       = &quot;mwFieldName&quot;;
438 
439             String namesArray = &quot;threadNames&quot;;
440 
441             String threadNames[] = {
442                     &quot;awThread&quot;  ,
443                     &quot;mwThread&quot;  ,
444                     &quot;bpThread&quot;  ,
445                     &quot;excThread&quot; ,
446                     &quot;menThread&quot; ,
447                     &quot;mexThread&quot; ,
448                     &quot;stThread&quot;
449                };
450 
451             int flags = 0;
452 
453             ThreadReference eventThreads[] = new ThreadReference[threadNames.length];
454 
455 
456             List allThreads = vm.allThreads();
457 
458             log2(&quot;......getting: ArrayReference namesRef = (ArrayReference) debuggeeClass.getValue(debuggeeClass.fieldByName(namesArray));&quot;);
459             ArrayReference namesRef = (ArrayReference)
460                          debuggeeClass.getValue(debuggeeClass.fieldByName(namesArray));
461             log2(&quot;       namesRef.length() == &quot; + namesRef.length());
462 
463             log2(&quot;......getting and chcking up on debuggee threads&#39; names&quot;);
464             for (int n1 = 0; n1 &lt; namesRef.length(); n1++) {
465 
466                 log2(&quot;      String name = ((StringReference) namesRef.getValue(n1)).value();&quot;);
467                 String name = ((StringReference) namesRef.getValue(n1)).value();
468 
469                 label0: {
470                     for (int n2 = 0; n2 &lt; threadNames.length; n2++) {
471 
472                         if (name.equals(threadNames[n2])) {
473                             ListIterator li  = allThreads.listIterator();
474                             for (; li.hasNext(); ) {
475                                 ThreadReference thread = (ThreadReference) li.next();
476                                 if (thread.name().equals(name)) {
477                                     eventThreads[n1] =  thread;
478                                     break;
479                                 }
480                             }
481                             break label0;
482                         }
483                     }
484                     testExitCode = FAILED;
485                     log3(&quot;ERROR: no thread found in the debuggee : &quot; + name);
486                 }
487             }
488             if (testExitCode == FAILED)
489                 break;
490 
491 
492             log2(&quot;......ReferenceType testClass = (ReferenceType) (vm.classesByName(testedClassName)).get(0);&quot;);
493             ReferenceType testClass = (ReferenceType) (vm.classesByName(testedClassName)).get(0);
494 
495             log2(&quot;......setting up Requests&quot;);
496             for ( int n3 = 0; n3 &lt; namesRef.length(); n3++) {
497                  switch (n3) {
498                       case 0:
499                              if (vm.canWatchFieldAccess()) {
500                                  String awName = ( (StringReference) testClass.getValue(
501                                              testClass.fieldByName(awFieldName))).value();
502                                  eRequests[n3] = settingAccessWatchpoint(eventThreads[n3],
503                                               testClass, awName, threadNames[n3]);
504                                  eRequests[n3].enable();
505                                  flags |= 1;
506                              }
507                              break;
508 
509                       case 1:
510                              if (vm.canWatchFieldModification() ) {
511                                  String mwName = ( (StringReference) testClass.getValue(
512                                              testClass.fieldByName(mwFieldName))).value();
513                                  eRequests[n3] = settingModificationWatchpoint(eventThreads[n3],
514                                               testClass, mwName, threadNames[n3]);
515                                  eRequests[n3].enable();
516                                  flags |= 1&lt;&lt;1;
517                              }
518                              break;
519 
520                       case 2:
521                              eRequests[n3] = settingBreakpoint(eventThreads[n3], testClass,
522                                                bpMethodName, bpLineName, threadNames[n3]);
523                              eRequests[n3].setSuspendPolicy( EventRequest.SUSPEND_NONE);
524                              eRequests[n3].enable();
525                              flags |= 1&lt;&lt;2;
526                              break;
527 
528                       case 3:
529                              eRequests[n3] = settingException(eventThreads[n3], debuggeeClass, //testClass,
530                                                                 threadNames[n3]);
531                              eRequests[n3].enable();
532                              flags |= 1&lt;&lt;3;
533                              break;
534 
535                       case 4:
536                              eRequests[n3] = settingMethodEntry(eventThreads[n3], testClass,
537                                                                 threadNames[n3]);
538                              eRequests[n3].enable();
539                              flags |= 1&lt;&lt;4;
540                              break;
541 
542                       case 5:
543                              eRequests[n3] = settingMethodExit(eventThreads[n3], testClass,
544                                                                 threadNames[n3]);
545                              eRequests[n3].enable();
546                              flags |= 1&lt;&lt;5;
547                              break;
548 
549                       case 6:
550                              eRequests[n3] = settingStep(eventThreads[n3], threadNames[n3]);
551                              eRequests[n3].enable();
552                              flags |= 1&lt;&lt;6;
553                              break;
554 
555                       default:
556                              throw new JDITestRuntimeException(&quot;** default case while prepareing requests**&quot;);
557                 }
558             }
559 
560             log2(&quot;:::::::::vm.resume();&quot;);
561             vm.resume();
562 
563             Event  event1     = null;
564             int    flagsCopy  = flags;
565             String eName      = null;
566             int    index      = 0;
567 
568             log2(&quot;......getting and checking up on Events&quot;);
569             for (int n4 = 0; n4 &lt; namesRef.length(); n4++) {
570                 int flag;
571 
572                 getEventSet();
573                 event1 = eventIterator.nextEvent();
574 
575                 if (event1 instanceof AccessWatchpointEvent) {
576                     index = 0;
577                 } else if (event1 instanceof ModificationWatchpointEvent ) {
578                     index = 1;
579                 } else if (event1 instanceof BreakpointEvent ) {
580                     index = 2;
581                 } else if (event1 instanceof ExceptionEvent ) {
582                     index = 3;
583                 } else if (event1 instanceof MethodEntryEvent ) {
584                     index = 4;
585                 } else if (event1 instanceof MethodExitEvent ) {
586                     index = 5;
587                 } else if (event1 instanceof StepEvent ) {
588                     index = 6;
589                 } else {
590                     log3(&quot;ERROR: else clause in detecting type of event1&quot;);
591                     testExitCode = FAILED;
592                 }
593 
594                 flag = 1 &lt;&lt; index;
595                 if ((flagsCopy &amp; flag) == 0) {
596                     log3(&quot;ERROR: event duplication: &quot; + eName);
597                     testExitCode = FAILED;
598                 } else {
599                     flagsCopy ^= flag;
600                     flags |= flag;
601                 }
602 
603                 eventSets[index] = eventSet;
604             }
605 
606             if (testExitCode == FAILED)
607                 break;
608 
609             breakpointForCommunication();
610 
611             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
612         }
613         log1(&quot;    TESTING ENDS&quot;);
614         return;
615     }
616 
617    /*
618     * private BreakpointRequest settingBreakpoint(ThreadReference, ReferenceType,
619     *                                             String, String, String)
620     *
621     * It sets up a breakpoint at given line number within a given method in a given class
622     * for a given thread.
623     *
624     * Return value: BreakpointRequest object  in case of success
625     *
626     * JDITestRuntimeException   in case of an Exception thrown within the method
627     */
628 
629     private BreakpointRequest settingBreakpoint ( ThreadReference thread,
630                                                   ReferenceType testedClass,
631                                                   String methodName,
632                                                   String bpLine,
633                                                   String property)
634             throws JDITestRuntimeException {
635 
636         log2(&quot;......setting up a breakpoint:&quot;);
637         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
638                         &quot;; method: &quot; + methodName + &quot;; line: &quot; + bpLine);
639 
640         List              alllineLocations = null;
641         Location          lineLocation     = null;
642         BreakpointRequest breakpRequest    = null;
643 
644         try {
645             Method  method  = (Method) testedClass.methodsByName(methodName).get(0);
646 
647             alllineLocations = method.allLineLocations();
648 
649             int n =
650                 ( (IntegerValue) testedClass.getValue(testedClass.fieldByName(bpLine) ) ).value();
651             if (n &gt; alllineLocations.size()) {
652                 log3(&quot;ERROR:  TEST_ERROR_IN_settingBreakpoint(): number is out of bound of method&#39;s lines&quot;);
653             } else {
654                 lineLocation = (Location) alllineLocations.get(n);
655                 try {
656                     breakpRequest = eventRManager.createBreakpointRequest(lineLocation);
657                     breakpRequest.putProperty(&quot;number&quot;, property);
658                     breakpRequest.addThreadFilter(thread);
659                     breakpRequest.setSuspendPolicy( EventRequest.SUSPEND_EVENT_THREAD);
660                 } catch ( Exception e1 ) {
661                     log3(&quot;ERROR: inner Exception within settingBreakpoint() : &quot; + e1);
662                     breakpRequest    = null;
663                 }
664             }
665         } catch ( Exception e2 ) {
666             log3(&quot;ERROR: ATTENTION:  outer Exception within settingBreakpoint() : &quot; + e2);
667             breakpRequest    = null;
668         }
669 
670         if (breakpRequest == null) {
671             log2(&quot;      A BREAKPOINT HAS NOT BEEN SET UP&quot;);
672             throw new JDITestRuntimeException(&quot;**FAILURE to set up a breakpoint**&quot;);
673         }
674 
675         log2(&quot;      a breakpoint has been set up&quot;);
676         return breakpRequest;
677     }
678 
679 
680     private void getEventSet()
681                  throws JDITestRuntimeException {
682         try {
683 //            log2(&quot;       eventSet = eventQueue.remove(waitTime);&quot;);
684             eventSet = eventQueue.remove(waitTime);
685             if (eventSet == null) {
686                 throw new JDITestRuntimeException(&quot;** TIMEOUT while waiting for event **&quot;);
687             }
688 //            log2(&quot;       eventIterator = eventSet.eventIterator;&quot;);
689             eventIterator = eventSet.eventIterator();
690         } catch ( Exception e ) {
691             throw new JDITestRuntimeException(&quot;** EXCEPTION while waiting for event ** : &quot; + e);
692         }
693     }
694 
695 
696     private void breakpointForCommunication()
697                  throws JDITestRuntimeException {
698 
699         log2(&quot;breakpointForCommunication&quot;);
700         getEventSet();
701 
702         if (eventIterator.nextEvent() instanceof BreakpointEvent)
703             return;
704 
705         throw new JDITestRuntimeException(&quot;** event IS NOT a breakpoint **&quot;);
706     }
707 
708     // ============================== test&#39;s additional methods
709 
710     private AccessWatchpointRequest settingAccessWatchpoint (
711                                                   ThreadReference thread,
712                                                   ReferenceType testedClass,
713                                                   String fieldName,
714                                                   String property)
715             throws JDITestRuntimeException {
716 
717         log2(&quot;......setting up AccessWatchpoint:&quot;);
718         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
719                              &quot;; fieldName: &quot; + fieldName);
720 
721         AccessWatchpointRequest awRequest = null;
722         try {
723             Field field = testedClass.fieldByName(fieldName);
724             awRequest = eventRManager.createAccessWatchpointRequest(field);
725             awRequest.putProperty(&quot;number&quot;, property);
726             awRequest.addThreadFilter(thread);
727             awRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
728         } catch ( Exception e ) {
729             log3(&quot;ERROR: ATTENTION: Exception within settingAccessWatchpoint() : &quot; + e);
730             log3(&quot;       AN ACCESSWATCHPOINT HAS NOT BEEN SET UP&quot;);
731             throw new JDITestRuntimeException(&quot;** FAILURE to set up an AccessWatchpoint **&quot;);
732         }
733 
734         log2(&quot;      an AccessWatchpoint has been set up&quot;);
735         return awRequest;
736     }
737 
738     private ModificationWatchpointRequest settingModificationWatchpoint (
739                                                   ThreadReference thread,
740                                                   ReferenceType testedClass,
741                                                   String fieldName,
742                                                   String property)
743             throws JDITestRuntimeException {
744 
745         log2(&quot;......setting up ModificationWatchpoint:&quot;);
746         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
747                              &quot;; fieldName: &quot; + fieldName);
748 
749         ModificationWatchpointRequest mwRequest = null;
750         try {
751             Field field = testedClass.fieldByName(fieldName);
752             mwRequest = eventRManager.createModificationWatchpointRequest(field);
753             mwRequest.putProperty(&quot;number&quot;, property);
754             mwRequest.addThreadFilter(thread);
755             mwRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
756         } catch ( Exception e ) {
757             log3(&quot;ERROR: ATTENTION: Exception within settingModificationWatchpoint() : &quot; + e);
758             log3(&quot;       AN ModificationWATCHPOINT HAS NOT BEEN SET UP&quot;);
759             throw new JDITestRuntimeException(&quot;** FAILURE to set up an AccessWatchpoint **&quot;);
760         }
761 
762         log2(&quot;      a ModificationWatchpoint has been set up&quot;);
763         return mwRequest;
764     }
765 
766     private MethodEntryRequest settingMethodEntry ( ThreadReference thread,
767                                                     ReferenceType testedClass,
768                                                     String property)
769             throws JDITestRuntimeException {
770 
771         log2(&quot;......setting up MethodEntry:&quot;);
772         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
773                              &quot;; property: &quot; + property);
774 
775         MethodEntryRequest menRequest = null;
776         try {
777             menRequest = eventRManager.createMethodEntryRequest();
778             menRequest.putProperty(&quot;number&quot;, property);
779             menRequest.addThreadFilter(thread);
780             menRequest.addClassFilter(testedClass);
781             menRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
782         } catch ( Exception e ) {
783             log3(&quot;ERROR: ATTENTION: Exception within settingMethodEntry() : &quot; + e);
784             log3(&quot;       A MethodEntry HAS NOT BEEN SET UP&quot;);
785             throw new JDITestRuntimeException(&quot;** FAILURE to set up a MethodEntry **&quot;);
786         }
787 
788         log2(&quot;      a MethodEntry has been set up&quot;);
789         return menRequest;
790     }
791 
792     private MethodExitRequest settingMethodExit ( ThreadReference thread,
793                                                   ReferenceType testedClass,
794                                                   String property)
795             throws JDITestRuntimeException {
796 
797         log2(&quot;......setting up MethodExit:&quot;);
798         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
799                              &quot;; property: &quot; + property);
800 
801         MethodExitRequest mexRequest = null;
802         try {
803             mexRequest = eventRManager.createMethodExitRequest();
804             mexRequest.putProperty(&quot;number&quot;, property);
805             mexRequest.addThreadFilter(thread);
806             mexRequest.addClassFilter(testedClass);
807             mexRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
808         } catch ( Exception e ) {
809             log3(&quot;ERROR: ATTENTION: Exception within settingMethodExit() : &quot; + e);
810             log3(&quot;       A MethodExit HAS NOT BEEN SET UP&quot;);
811             throw new JDITestRuntimeException(&quot;** FAILURE to set up a MethodExit **&quot;);
812         }
813 
814         log2(&quot;      a MethodExit has been set up&quot;);
815         return mexRequest;
816     }
817 
818     private StepRequest settingStep ( ThreadReference thread, String property)
819             throws JDITestRuntimeException {
820 
821         log2(&quot;......setting up Step:&quot;);
822         log2(&quot;       thread: &quot; + thread + &quot;; property: &quot; + property);
823 
824         StepRequest stRequest = null;
825         try {
826             stRequest = eventRManager.createStepRequest(thread, StepRequest.STEP_LINE, StepRequest.STEP_OVER);
827             stRequest.putProperty(&quot;number&quot;, property);
828             stRequest.addCountFilter(1);
829             stRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
830         } catch ( Exception e ) {
831             log3(&quot;ERROR: ATTENTION: Exception within settingStep() : &quot; + e);
832             log3(&quot;       A Step HAS NOT BEEN SET UP&quot;);
833             throw new JDITestRuntimeException(&quot;** FAILURE to set up a Step **&quot;);
834         }
835 
836         log2(&quot;      a Step has been set up&quot;);
837         return stRequest;
838     }
839 
840 
841     private ExceptionRequest settingException ( ThreadReference thread,
842                                                 ReferenceType testedClass,
843                                                 String property)
844             throws JDITestRuntimeException {
845 
846         log2(&quot;......setting up Exception:&quot;);
847         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
848                              &quot;; property: &quot; + property);
849 
850         ExceptionRequest excRequest = null;
851         try {
852             excRequest = eventRManager.createExceptionRequest(null, true, true);
853             excRequest.putProperty(&quot;number&quot;, property);
854             excRequest.addThreadFilter(thread);
855             excRequest.addClassFilter(testedClass);
856             excRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
857         } catch ( Exception e ) {
858             log3(&quot;ERROR: ATTENTION: Exception within settingException() : &quot; + e);
859             log3(&quot;       A Exception HAS NOT BEEN SET UP&quot;);
860             throw new JDITestRuntimeException(&quot;** FAILURE to set up a Exception **&quot;);
861         }
862 
863         log2(&quot;      a Exception has been set up&quot;);
864         return excRequest;
865     }
866 
867     private void checkingEventIterator(EventIterator eIterator) {
868 
869         log2(&quot;......checking up on eIterator.nextEvent()&quot;);
870 
871         try {
872             log2(&quot;......first time: Event testedEvent = eIterator.nextEvent();&quot;);
873             log2(&quot;        no Exception to be thrown is expected&quot;);
874             Event testedEvent = eIterator.nextEvent();
875         } catch (Exception e) {
876                 log3(&quot;ERROR: Exception while: testedEvent = eIterator.nextEvent(); :: &quot; + e);
877                 testExitCode = FAILED;
878         }
879         try {
880             log2(&quot;......second time: Event testedEvent = eIterator.nextEvent();&quot;);
881             log2(&quot;        NoSuchElementException is expected&quot;);
882             Event testedEvent = eIterator.nextEvent();
883             log3(&quot;ERROR: no NoSuchElementException while: testedEvent = eIterator.nextEvent();&quot;);
884             testExitCode = FAILED;
885         } catch (NoSuchElementException e) {
886             log2(&quot;        NoSuchElementException&quot;);
887         } catch (Exception e) {
888             log3(&quot;ERROR: unexpected Exception :: &quot; + e);
889             testExitCode = FAILED;
890         }
891     }
892 
893     private void check() {
894 
895         log2(&quot;......performing the check;&quot;);
896         for (int k = 0; k &lt; eventFlags.length; k++) {
897 
898             log2(&quot;......new check case ::  k == &quot; + k);
899             switch (eventFlags[k]) {
900 
901             case 0:
902             case 1:
903             case 2:
904                    checkingEventIterator(eventSets[k].eventIterator());
905                    break;
906 
907             case 3:
908                    break;
909 
910             default:
911                     log3(&quot;ERROR: unexpected default case&quot;);
912                     testExitCode = FAILED;
913                     throw new JDITestRuntimeException(&quot;** FAILURE within check() **&quot;);
914             }
915         }
916     }
917 
918 }
    </pre>
  </body>
</html>
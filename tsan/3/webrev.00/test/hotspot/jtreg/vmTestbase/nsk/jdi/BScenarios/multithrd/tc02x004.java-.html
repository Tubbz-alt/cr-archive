<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/jdi/BScenarios/multithrd/tc02x004.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.BScenarios.multithrd;
 25 
 26 import nsk.share.*;
 27 import nsk.share.jpda.*;
 28 import nsk.share.jdi.*;
 29 
 30 import com.sun.jdi.*;
 31 import com.sun.jdi.request.*;
 32 import com.sun.jdi.event.*;
 33 
 34 import java.util.*;
 35 import java.io.*;
 36 
 37 /**
 38  * This test is from the group of so-called Borland&#39;s scenarios and
 39  * implements the following test case:                                  &lt;br&gt;
 40  *     Suite 2 - Breakpoints (multiple threads)                         &lt;br&gt;
 41  *     Test case:      TC2                                              &lt;br&gt;
 42  *     Description:    Class breakpoint                                 &lt;br&gt;
 43  *     Steps:          1.Add class breakpoint: singlethread.Class1      &lt;br&gt;
 44  *                     2.Debug Main                                     &lt;br&gt;
 45  *                       X. Stops on line 13 in Class1.java             &lt;br&gt;
 46  *
 47  * When the test is starting debugee, debugger creates &lt;code&gt;MethodEntryRequest&lt;/code&gt;.
 48  * After &lt;code&gt;MethodEntryEvent&lt;/code&gt; arrived, debugger checks line number of one&#39;s
 49  * location. It should be 73th line, that is constructor of &lt;code&gt;tc02x004aClass1&lt;/code&gt;
 50  * class. Every thread must generate &lt;code&gt;MethodEntryEvent&lt;/code&gt;.
 51  *
 52  * In case, when at least one event doesn&#39;t arrive during waittime
 53  * interval or line number of event is wrong, test fails.
 54  */
 55 
 56 public class tc02x004 {
 57 
 58     public final static String SGL_READY = &quot;ready&quot;;
 59     public final static String SGL_PERFORM = &quot;perform&quot;;
 60     public final static String SGL_QUIT = &quot;quit&quot;;
 61 
 62     private final static String prefix = &quot;nsk.jdi.BScenarios.multithrd.&quot;;
 63     private final static String debuggerName = prefix + &quot;tc02x004&quot;;
 64     private final static String debugeeName = debuggerName + &quot;a&quot;;
 65     private final static String testedClassName = debugeeName + &quot;Class1&quot;;
 66 
 67     private static int exitStatus;
 68     private static Log log;
 69     private static Debugee debugee;
 70     private static long waitTime;
 71     private static int brkpEventCount = 0;
 72     MethodEntryRequest mthdReq;
 73     EventRequestManager evm;
 74 
 75     private ClassType debugeeClass;
 76 
 77     private static void display(String msg) {
 78         log.display(msg);
 79     }
 80 
 81     private static void complain(String msg) {
 82         log.complain(&quot;debugger FAILURE&gt; &quot; + msg + &quot;\n&quot;);
 83     }
 84 
 85     public static void main(String argv[]) {
 86         System.exit(Consts.JCK_STATUS_BASE + run(argv, System.out));
 87     }
 88 
 89     public static int run(String argv[], PrintStream out) {
 90 
 91         exitStatus = Consts.TEST_PASSED;
 92 
 93         tc02x004 thisTest = new tc02x004();
 94 
 95         ArgumentHandler argHandler = new ArgumentHandler(argv);
 96         log = new Log(out, argHandler);
 97 
 98         waitTime = argHandler.getWaitTime() * 60000;
 99 
100         Binder binder = new Binder(argHandler, log);
101         debugee = binder.bindToDebugee(debugeeName);
102         debugee.redirectStderr(log.getOutStream());
103         thisTest.evm = debugee.getEventRequestManager();
104 
105         try {
106             thisTest.execTest();
107         } catch (Throwable e) {
108             complain(&quot;Unexpected &quot; + e);
109             exitStatus = Consts.TEST_FAILED;
110             e.printStackTrace();
111             thisTest.evm.deleteEventRequest(thisTest.mthdReq);
112         } finally {
113             debugee.resume();
114         }
115         display(&quot;Test finished. exitStatus = &quot; + exitStatus);
116 
117         return exitStatus;
118     }
119 
120     private void execTest() throws Failure {
121 
122         display(&quot;\nTEST BEGINS&quot;);
123         display(&quot;===========&quot;);
124         debugee.resume();
125 
126         EventSet eventSet = null;
127         EventIterator eventIterator = null;
128         Event event;
129         long totalTime = waitTime;
130         long tmp, begin = System.currentTimeMillis(),
131              delta = 0;
132         boolean exit = false;
133 
134         mthdReq = evm.createMethodEntryRequest();
135         mthdReq.addClassFilter(testedClassName);
136         mthdReq.enable();
137         debugee.resume();
138 
139         while (totalTime &gt; 0 &amp;&amp; !exit) {
140             if (eventIterator == null || !eventIterator.hasNext()) {
141                 try {
142                     eventSet = debugee.VM().eventQueue().remove(totalTime);
143                 } catch (InterruptedException e) {
144                     new Failure(e);
145                 }
146                 if (eventSet != null) {
147                     eventIterator = eventSet.eventIterator();
148                 } else {
149                     eventIterator = null;
150                 }
151             }
152             if (eventIterator != null) {
153                 while (eventIterator.hasNext()) {
154                     event = eventIterator.nextEvent();
155 
156                     if (event instanceof MethodEntryEvent) {
157                         display(&quot; event ===&gt;&gt;&gt; &quot; + (brkpEventCount+1) + &quot; MethodEntryEvent arrived&quot;);
158                         hitClassBreakpoint((MethodEntryEvent )event);
159                         debugee.resume();
160 
161                     } else if (event instanceof VMDeathEvent) {
162                         exit = true;
163                         break;
164                     } else if (event instanceof VMDisconnectEvent) {
165                         exit = true;
166                         break;
167                     } // if
168                 } // while
169             } // if
170             exit = exit || (brkpEventCount == tc02x004a.threadCount);
171             tmp = System.currentTimeMillis();
172             delta = tmp - begin;
173             totalTime -= delta;
174                 begin = tmp;
175         }
176 
177         if (totalTime &lt;= 0) {
178             complain(&quot;out of wait time...&quot;);
179             exitStatus = Consts.TEST_FAILED;
180         }
181         if (brkpEventCount &lt; tc02x004a.threadCount) {
182             complain(&quot;expecting &quot; + tc02x004a.threadCount
183                         + &quot; breakpoint events, but &quot;
184                         + brkpEventCount + &quot; events arrived.&quot;);
185             exitStatus = Consts.TEST_FAILED;
186         }
187 
188         display(&quot;=============&quot;);
189         display(&quot;TEST FINISHES\n&quot;);
190     }
191 
192     private void hitClassBreakpoint(MethodEntryEvent event) {
193         ThreadReference thrd = event.thread();
194 
195         display(&quot;event info:&quot;);
196         display(&quot;\tthread\t- &quot; + event.thread().name());
197         try {
198             display(&quot;\tsource\t- &quot; + event.location().sourceName());
199         } catch (AbsentInformationException e) {
200         }
201         display(&quot;\tmethod\t- &quot; + event.location().method().name());
202         display(&quot;\tline\t- &quot; + event.location().lineNumber());
203 
204         display(&quot;thread:\t&quot; + event.thread().name());
205         try {
206             display(&quot;source:\t&quot; + event.location().sourceName());
207         } catch (AbsentInformationException e) {
208         }
209         display(&quot;method:\t&quot; + event.location().method().name());
210         display(&quot;line:\t&quot; + event.location().lineNumber());
211         if (event.location().lineNumber() == tc02x004a.checkClassBrkpLine) {
212             display(&quot;ClassBreakpoint stops on the expected line &quot;
213                         + event.location().lineNumber() + &quot; in method &quot;
214                         + event.method().name());
215         } else {
216             complain(&quot;ClassBreakpoint stops on line &quot; + event.location().lineNumber()
217                         + &quot; in method &quot; + event.method().name()
218                         + &quot;, expected line number is &quot;
219                         + tc02x004a.checkClassBrkpLine);
220             exitStatus = Consts.TEST_FAILED;
221         }
222 
223         display(&quot;&quot;);
224 
225         brkpEventCount++;
226     }
227 }
    </pre>
  </body>
</html>
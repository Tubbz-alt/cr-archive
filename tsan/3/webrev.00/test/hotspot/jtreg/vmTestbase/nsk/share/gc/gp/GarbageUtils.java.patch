diff a/test/hotspot/jtreg/vmTestbase/nsk/share/gc/gp/GarbageUtils.java b/test/hotspot/jtreg/vmTestbase/nsk/share/gc/gp/GarbageUtils.java
--- a/test/hotspot/jtreg/vmTestbase/nsk/share/gc/gp/GarbageUtils.java
+++ b/test/hotspot/jtreg/vmTestbase/nsk/share/gc/gp/GarbageUtils.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,10 +24,11 @@
 package nsk.share.gc.gp;
 
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.lang.invoke.*;
 import java.util.*;
 import nsk.share.gc.gp.array.*;
 import nsk.share.gc.gp.string.*;
 import nsk.share.gc.gp.list.*;
 import nsk.share.gc.gp.tree.*;
@@ -55,14 +56,14 @@
             OOM_TYPE(String... expectedStrings) {
                 this.expectedStrings = expectedStrings;
             }
 
             /**
-                         * Returns true if the given error message matches
-                         * one of expected strings.
-                         */
-                        public boolean accept(String errorMessage) {
+             * Returns true if the given error message matches
+             * one of expected strings.
+             */
+            public boolean accept(String errorMessage) {
                 if (expectedStrings == null || expectedStrings.length == 0 || errorMessage == null) {
                     return true;
                 }
                 for (String s: expectedStrings) {
                     if (errorMessage.indexOf(s) != -1) {
@@ -71,17 +72,18 @@
                 }
                 return false;
             }
         };
 
-        // Force loading of OOM_TYPE and calling of enum contrusctors when loading GarbageUtils class.
+        // Force loading of OOM_TYPE and calling of enum constructors when loading GarbageUtils class.
         public static final Object[] thisIsGarbageArray_theOnlyPurposeForCreatingItAndDeclaringItPublicIsToInitializeIntancesOfOOMEnumberation = new Object[] { OOM_TYPE.ANY, OOM_TYPE.HEAP, OOM_TYPE.METASPACE };
 
         // Force early loading of classes that might otherwise unexpectedly fail
         // class loading during testing due to high memory pressure.
         public static final StringWriter preloadStringWriter = new StringWriter(1);
         public static final PrintWriter preloadPrintWriter = new PrintWriter(preloadStringWriter);
+        public static final Throwable preloadThrowable = new Throwable("preload");
 
         private GarbageUtils() {
         }
 
         /**
@@ -191,10 +193,40 @@
          */
         public static int eatMemory(ExecutionController stresser, GarbageProducer gp, long initialFactor, long minMemoryChunk, long factor) {
             return eatMemory(stresser, gp, initialFactor, minMemoryChunk, factor, OOM_TYPE.ANY);
         }
 
+         static int numberOfOOMEs = 0;
+
+         /**
+          * Minimal wrapper of the main implementation. Catches any OOM
+          * that might be thrown when rematerializing Objects when deoptimizing.
+          *
+          * It is Important that the impl is not inlined.
+          */
+
+         public static int eatMemory(ExecutionController stresser, GarbageProducer gp, long initialFactor, long minMemoryChunk, long factor, OOM_TYPE type) {
+            try {
+               // Using a methodhandle invoke of eatMemoryImpl to prevent inlining of it
+               MethodHandles.Lookup lookup = MethodHandles.lookup();
+               MethodType mt = MethodType.methodType(
+                     int.class,
+                     ExecutionController.class,
+                     GarbageProducer.class,
+                     long.class,
+                     long.class,
+                     long.class,
+                     OOM_TYPE.class);
+               MethodHandle eat = lookup.findStatic(GarbageUtils.class, "eatMemoryImpl", mt);
+               return (int) eat.invoke(stresser, gp, initialFactor, minMemoryChunk, factor, type);
+            } catch (OutOfMemoryError e) {
+               return numberOfOOMEs++;
+            } catch (Throwable t) {
+               throw new RuntimeException(t);
+            }
+         }
+
         /**
          * Eat memory using given garbage producer.
          *
          * Note that this method can throw Failure if any exception
          * is thrown while eating memory. To avoid OOM while allocating
@@ -208,15 +240,14 @@
          * @param minMemoryChunk determines when to stop
          * @param factor factor to divide the array size by. A value of 0 means that method returns after first  OOME
          * @param type of OutOfMemory Exception: Java heap space or Metadata space
          * @return number of OOME occured
          */
-        public static int eatMemory(ExecutionController stresser, GarbageProducer gp, long initialFactor, long minMemoryChunk, long factor, OOM_TYPE type) {
-                int numberOfOOMEs = 0;
+
+         public static int eatMemoryImpl(ExecutionController stresser, GarbageProducer gp, long initialFactor, long minMemoryChunk, long factor, OOM_TYPE type) {
+                numberOfOOMEs = 0;
                 try {
-                        StringWriter sw = new StringWriter(10000);
-                        PrintWriter pw = new PrintWriter(sw);
                         byte[] someMemory = new byte[200000]; //200 Kb
                         try {
                                 Runtime runtime = Runtime.getRuntime();
                                 long maxMemory = runtime.maxMemory();
                                 long maxMemoryChunk = maxMemory / initialFactor;
@@ -239,17 +270,15 @@
                                                     allocations = 0;
                                                 }
                                         } catch (OutOfMemoryError e) {
                                             someMemory = null;
                                             if (type != OOM_TYPE.ANY) {
-                                                e.printStackTrace(pw);
-                                                pw.close();
-                                                if (type.accept(sw.toString())) {
+                                                if (type.accept(e.toString())) {
                                                     numberOfOOMEs++;
                                                 } else {
                                                     // Trying to catch situation when Java generates OOM different type that test trying to catch
-                                                    throw new TestBug("Test throw OOM of unexpected type." + sw.toString());
+                                                    throw new TestBug("Test throw OOM of unexpected type." + e.toString());
                                                 }
                                             } else {
                                                numberOfOOMEs++;
                                             }
                                             allocations = 0;
@@ -261,17 +290,15 @@
                                         }
                                 }
                         } catch (OutOfMemoryError e) {
                             someMemory = null;
                             if (type != OOM_TYPE.ANY) {
-                                e.printStackTrace(pw);
-                                pw.close();
-                                if (type.accept(sw.toString())) {
+                                if (type.accept(e.toString())) {
                                     numberOfOOMEs++;
                                 } else {
                                     // Trying to catch situation when Java generates OOM different type that test trying to catch
-                                    throw new TestBug("Test throw OOM of unexpected type." + sw.toString());
+                                    throw new TestBug("Test throw OOM of unexpected type." + e.toString());
                                 }
                             } else {
                                 numberOfOOMEs++;
                             }
                          // all memory is eaten now even before we start, just return

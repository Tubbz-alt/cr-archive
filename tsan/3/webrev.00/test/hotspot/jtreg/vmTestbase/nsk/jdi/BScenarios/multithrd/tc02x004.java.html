<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jdi/BScenarios/multithrd/tc02x004.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.BScenarios.multithrd;
 25 
 26 import jdk.test.lib.Utils;
 27 import nsk.share.*;
 28 import nsk.share.jpda.*;
 29 import nsk.share.jdi.*;
 30 
 31 import com.sun.jdi.*;
 32 import com.sun.jdi.request.*;
 33 import com.sun.jdi.event.*;
 34 
 35 import java.util.*;
 36 import java.io.*;
 37 
 38 /**
 39  * This test is from the group of so-called Borland&#39;s scenarios and
 40  * implements the following test case:                                  &lt;br&gt;
 41  *     Suite 2 - Breakpoints (multiple threads)                         &lt;br&gt;
 42  *     Test case:      TC2                                              &lt;br&gt;
 43  *     Description:    Class breakpoint                                 &lt;br&gt;
 44  *     Steps:          1.Add class breakpoint: singlethread.Class1      &lt;br&gt;
 45  *                     2.Debug Main                                     &lt;br&gt;
 46  *                       X. Stops on line 13 in Class1.java             &lt;br&gt;
 47  *
 48  * When the test is starting debugee, debugger creates &lt;code&gt;MethodEntryRequest&lt;/code&gt;.
 49  * After &lt;code&gt;MethodEntryEvent&lt;/code&gt; arrived, debugger checks line number of one&#39;s
 50  * location. It should be 73th line, that is constructor of &lt;code&gt;tc02x004aClass1&lt;/code&gt;
 51  * class. Every thread must generate &lt;code&gt;MethodEntryEvent&lt;/code&gt;.
 52  *
 53  * In case, when at least one event doesn&#39;t arrive during waittime
 54  * interval or line number of event is wrong, test fails.
 55  */
 56 
 57 public class tc02x004 {
 58 
 59     public final static String SGL_READY = &quot;ready&quot;;
 60     public final static String SGL_PERFORM = &quot;perform&quot;;
 61     public final static String SGL_QUIT = &quot;quit&quot;;
 62 
 63     private final static String prefix = &quot;nsk.jdi.BScenarios.multithrd.&quot;;
 64     private final static String debuggerName = prefix + &quot;tc02x004&quot;;
 65     private final static String debugeeName = debuggerName + &quot;a&quot;;
 66     private final static String testedClassName = debugeeName + &quot;Class1&quot;;
 67 
 68     private static int exitStatus;
 69     private static Log log;
 70     private static Debugee debugee;
 71     private static long waitTime;
 72     private static int brkpEventCount = 0;
 73     MethodEntryRequest mthdReq;
 74     EventRequestManager evm;
 75 
 76     private ClassType debugeeClass;
 77 
 78     private static void display(String msg) {
 79         log.display(msg);
 80     }
 81 
 82     private static void complain(String msg) {
 83         log.complain(&quot;debugger FAILURE&gt; &quot; + msg + &quot;\n&quot;);
 84     }
 85 
 86     public static void main(String argv[]) {
 87         System.exit(Consts.JCK_STATUS_BASE + run(argv, System.out));
 88     }
 89 
 90     public static int run(String argv[], PrintStream out) {
 91 
 92         exitStatus = Consts.TEST_PASSED;
 93 
 94         tc02x004 thisTest = new tc02x004();
 95 
 96         ArgumentHandler argHandler = new ArgumentHandler(argv);
 97         log = new Log(out, argHandler);
 98 
 99         waitTime = Utils.adjustTimeout(argHandler.getWaitTime() * 60000);
100 
101         Binder binder = new Binder(argHandler, log);
102         debugee = binder.bindToDebugee(debugeeName);
103         debugee.redirectStderr(log.getOutStream());
104         thisTest.evm = debugee.getEventRequestManager();
105 
106         try {
107             thisTest.execTest();
108         } catch (Throwable e) {
109             complain(&quot;Unexpected &quot; + e);
110             exitStatus = Consts.TEST_FAILED;
111             e.printStackTrace();
112             thisTest.evm.deleteEventRequest(thisTest.mthdReq);
113         } finally {
114             debugee.resume();
115         }
116         display(&quot;Test finished. exitStatus = &quot; + exitStatus);
117 
118         debugee.endDebugee();
119         return exitStatus;
120     }
121 
122     private void execTest() throws Failure {
123 
124         display(&quot;\nTEST BEGINS&quot;);
125         display(&quot;===========&quot;);
126         debugee.resume();
127 
128         EventSet eventSet = null;
129         EventIterator eventIterator = null;
130         Event event;
131         long totalTime = waitTime;
132         long tmp, begin = System.currentTimeMillis(),
133              delta = 0;
134         boolean exit = false;
135 
136         mthdReq = evm.createMethodEntryRequest();
137         mthdReq.addClassFilter(testedClassName);
138         mthdReq.enable();
139         debugee.resume();
140 
141         while (totalTime &gt; 0 &amp;&amp; !exit) {
142             if (eventIterator == null || !eventIterator.hasNext()) {
143                 try {
144                     eventSet = debugee.VM().eventQueue().remove(totalTime);
145                 } catch (InterruptedException e) {
146                     new Failure(e);
147                 }
148                 if (eventSet != null) {
149                     eventIterator = eventSet.eventIterator();
150                 } else {
151                     eventIterator = null;
152                 }
153             }
154             if (eventIterator != null) {
155                 while (eventIterator.hasNext()) {
156                     event = eventIterator.nextEvent();
157 
158                     if (event instanceof MethodEntryEvent) {
159                         display(&quot; event ===&gt;&gt;&gt; &quot; + (brkpEventCount+1) + &quot; MethodEntryEvent arrived&quot;);
160                         hitClassBreakpoint((MethodEntryEvent )event);
161                         debugee.resume();
162 
163                     } else if (event instanceof VMDeathEvent) {
164                         exit = true;
165                         break;
166                     } else if (event instanceof VMDisconnectEvent) {
167                         exit = true;
168                         break;
169                     } // if
170                 } // while
171             } // if
172             exit = exit || (brkpEventCount == tc02x004a.threadCount);
173             tmp = System.currentTimeMillis();
174             delta = tmp - begin;
175             totalTime -= delta;
176                 begin = tmp;
177         }
178 
179         if (totalTime &lt;= 0) {
180             complain(&quot;out of wait time...&quot;);
181             exitStatus = Consts.TEST_FAILED;
182         }
183         if (brkpEventCount &lt; tc02x004a.threadCount) {
184             complain(&quot;expecting &quot; + tc02x004a.threadCount
185                         + &quot; breakpoint events, but &quot;
186                         + brkpEventCount + &quot; events arrived.&quot;);
187             exitStatus = Consts.TEST_FAILED;
188         }
189 
190         display(&quot;=============&quot;);
191         display(&quot;TEST FINISHES\n&quot;);
192     }
193 
194     private void hitClassBreakpoint(MethodEntryEvent event) {
195         ThreadReference thrd = event.thread();
196 
197         display(&quot;event info:&quot;);
198         display(&quot;\tthread\t- &quot; + event.thread().name());
199         try {
200             display(&quot;\tsource\t- &quot; + event.location().sourceName());
201         } catch (AbsentInformationException e) {
202         }
203         display(&quot;\tmethod\t- &quot; + event.location().method().name());
204         display(&quot;\tline\t- &quot; + event.location().lineNumber());
205 
206         display(&quot;thread:\t&quot; + event.thread().name());
207         try {
208             display(&quot;source:\t&quot; + event.location().sourceName());
209         } catch (AbsentInformationException e) {
210         }
211         display(&quot;method:\t&quot; + event.location().method().name());
212         display(&quot;line:\t&quot; + event.location().lineNumber());
213         if (event.location().lineNumber() == tc02x004a.checkClassBrkpLine) {
214             display(&quot;ClassBreakpoint stops on the expected line &quot;
215                         + event.location().lineNumber() + &quot; in method &quot;
216                         + event.method().name());
217         } else {
218             complain(&quot;ClassBreakpoint stops on line &quot; + event.location().lineNumber()
219                         + &quot; in method &quot; + event.method().name()
220                         + &quot;, expected line number is &quot;
221                         + tc02x004a.checkClassBrkpLine);
222             exitStatus = Consts.TEST_FAILED;
223         }
224 
225         display(&quot;&quot;);
226 
227         brkpEventCount++;
228     }
229 }
    </pre>
  </body>
</html>
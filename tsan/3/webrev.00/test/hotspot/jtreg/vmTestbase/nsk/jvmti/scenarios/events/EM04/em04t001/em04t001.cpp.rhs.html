<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM04/em04t001/em04t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &lt;stdlib.h&gt;
 26 #include &quot;jvmti.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 #include &quot;JVMTITools.h&quot;
 31 #include &quot;nsk_list.h&quot;
<a name="2" id="anc2"></a>
 32 
 33 extern &quot;C&quot; {
 34 
 35 /* ============================================================================= */
 36 
 37 /* scaffold objects */
 38 static jvmtiEnv *jvmti = NULL;
 39 static jlong timeout = 0;
 40 const void *plist = NULL;
 41 
 42 #define NAME_LENGTH 50
 43 
 44 typedef struct nsk_jvmti_DCG_paramsStruct {
 45     char name[NAME_LENGTH];
 46     const void *address;
 47     jint length;
 48     int sign;
 49 } nsk_jvmti_DCG_params;
 50 
<a name="3" id="anc3"></a><span class="line-modified"> 51 static jrawMonitorID syncLock = NULL;</span>
<span class="line-modified"> 52 static volatile int callbacksEnabled = NSK_TRUE;</span>
 53 /* ============================================================================= */
 54 
 55 /* callbacks */
 56 void JNICALL
 57 cbDynamicCodeGenerated1(jvmtiEnv *jvmti_env, const char *name,
 58                             const void *address, jint length) {
 59     nsk_jvmti_DCG_params *rec;
 60     int b;
 61 
<a name="4" id="anc4"></a><span class="line-added"> 62     jvmti-&gt;RawMonitorEnter(syncLock);</span>
<span class="line-added"> 63     if (!callbacksEnabled) {</span>
<span class="line-added"> 64         jvmti-&gt;RawMonitorExit(syncLock);</span>
<span class="line-added"> 65         return;</span>
<span class="line-added"> 66     }</span>
<span class="line-added"> 67 </span>
 68     rec = (nsk_jvmti_DCG_params *)malloc(sizeof(nsk_jvmti_DCG_params));
 69     strncpy(rec-&gt;name, name, NAME_LENGTH);
 70     rec-&gt;name[NAME_LENGTH - 1] = &#39;\0&#39;;
 71     rec-&gt;address = address;
 72     rec-&gt;length = length;
 73     rec-&gt;sign = 0;
 74 
 75     NSK_DISPLAY3(&quot;received: 0x%p %7d %s\n&quot;, rec-&gt;address, rec-&gt;length, rec-&gt;name);
 76 
<a name="5" id="anc5"></a>

 77     b = NSK_VERIFY(nsk_list_add(plist, rec));
 78 
<a name="6" id="anc6"></a>

 79     if (!b) {
 80         nsk_jvmti_setFailStatus();
 81         free((void *)rec);
 82     }
<a name="7" id="anc7"></a><span class="line-added"> 83     jvmti-&gt;RawMonitorExit(syncLock);</span>
 84 }
 85 
 86 void JNICALL
 87 cbDynamicCodeGenerated2(jvmtiEnv *jvmti_env, const char *name,
 88                             const void *address, jint length) {
 89 
 90     int i;
 91     nsk_jvmti_DCG_params *rec;
<a name="8" id="anc8"></a><span class="line-added"> 92 </span>
<span class="line-added"> 93     jvmti-&gt;RawMonitorEnter(syncLock);</span>
<span class="line-added"> 94     if (!callbacksEnabled) {</span>
<span class="line-added"> 95         jvmti-&gt;RawMonitorExit(syncLock);</span>
<span class="line-added"> 96         return;</span>
<span class="line-added"> 97     }</span>
<span class="line-added"> 98 </span>
 99     int count = nsk_list_getCount(plist);
100     int compLength = NAME_LENGTH - 1;
101 
102     for (i = 0; i &lt; count; i ++) {
103         rec = (nsk_jvmti_DCG_params *)nsk_list_get(plist, i);
104         if ((rec-&gt;address == address) &amp;&amp; (rec-&gt;length == length)) {
105             rec-&gt;sign = 1;
106             NSK_DISPLAY3(&quot;checked: 0x%p %7d %s\n&quot;, rec-&gt;address, rec-&gt;length,
107                                 rec-&gt;name);
108             if (strncmp(rec-&gt;name, name, compLength) != 0) {
109                 NSK_DISPLAY2(&quot;\t&lt;%s&gt; was renamed to &lt;%s&gt;\n&quot;, rec-&gt;name, name);
110             }
<a name="9" id="anc9"></a><span class="line-added">111             jvmti-&gt;RawMonitorExit(syncLock);</span>
112             return;
113         }
114 
115     }
116     NSK_DISPLAY3(&quot;NOT FOUND: 0x%p %7d %s\n&quot;, address, length, name);
<a name="10" id="anc10"></a><span class="line-added">117     jvmti-&gt;RawMonitorExit(syncLock);</span>
118 
119 }
120 
121 /* ============================================================================= */
122 
123 static int
124 enableEvent(jvmtiEventMode enable, jvmtiEvent event) {
125     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(enable, event, NULL))) {
126         nsk_jvmti_setFailStatus();
127         return NSK_FALSE;
128     }
129 
130     return NSK_TRUE;
131 }
132 
133 int setCallBacks(int stage) {
134 
135     jvmtiEventCallbacks eventCallbacks;
136     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
137 
138     eventCallbacks.DynamicCodeGenerated = (stage == 1) ?
139                             cbDynamicCodeGenerated1 : cbDynamicCodeGenerated2;
140 
141     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
142         return NSK_FALSE;
143 
144     return NSK_TRUE;
145 }
146 
147 /* ============================================================================= */
148 
149 /** Agent algorithm. */
150 static void JNICALL
151 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
152 
153     NSK_DISPLAY0(&quot;Wait for debuggee to become ready\n&quot;);
154     if (!nsk_jvmti_waitForSync(timeout))
155         return;
156 
157     /* stage 2 */
158     if (!setCallBacks(2)) {
159         return;
160     }
161 
162     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GenerateEvents(JVMTI_EVENT_DYNAMIC_CODE_GENERATED)))
163         nsk_jvmti_setFailStatus();
164 
<a name="11" id="anc11"></a><span class="line-added">165     jvmti-&gt;RawMonitorEnter(syncLock);</span>
<span class="line-added">166     callbacksEnabled = NSK_FALSE;</span>
<span class="line-added">167 </span>
168     {
169         int i;
170         const nsk_jvmti_DCG_params *rec;
171         int count = nsk_list_getCount(plist);
172 
173         for (i = 0; i &lt; count; i++) {
174             rec = (const nsk_jvmti_DCG_params *)nsk_list_get(plist, 0);
175             if (!rec-&gt;sign) {
176                 NSK_COMPLAIN3(&quot;missed event for\n\t0x%p %7d %s\n&quot;, rec-&gt;address, rec-&gt;length, rec-&gt;name);
177                 nsk_jvmti_setFailStatus();
178             }
179             free((void *)rec);
180             nsk_list_remove(plist, 0);
181         }
182 
183     }
184 
<a name="12" id="anc12"></a><span class="line-added">185     jvmti-&gt;RawMonitorExit(syncLock);</span>
<span class="line-added">186 </span>
187     NSK_DISPLAY0(&quot;Let debuggee to finish\n&quot;);
188     if (!nsk_jvmti_resumeSync())
189         return;
190 
191 }
192 
193 /* ============================================================================= */
194 
195 /** Agent library initialization. */
196 #ifdef STATIC_BUILD
197 JNIEXPORT jint JNICALL Agent_OnLoad_em04t001(JavaVM *jvm, char *options, void *reserved) {
198     return Agent_Initialize(jvm, options, reserved);
199 }
200 JNIEXPORT jint JNICALL Agent_OnAttach_em04t001(JavaVM *jvm, char *options, void *reserved) {
201     return Agent_Initialize(jvm, options, reserved);
202 }
203 JNIEXPORT jint JNI_OnLoad_em04t001(JavaVM *jvm, char *options, void *reserved) {
204     return JNI_VERSION_1_8;
205 }
206 #endif
207 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
208 
<a name="13" id="anc13"></a>



209     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
210         return JNI_ERR;
211 
212     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
213 
214     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
215     if (!NSK_VERIFY(jvmti != NULL))
216         return JNI_ERR;
217 
<a name="14" id="anc14"></a><span class="line-added">218     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock))) {</span>
<span class="line-added">219         nsk_jvmti_setFailStatus();</span>
<span class="line-added">220         return JNI_ERR;</span>
<span class="line-added">221     }</span>
<span class="line-added">222 </span>
223     plist = (const void *)nsk_list_create();
224     if (!NSK_VERIFY(plist != NULL))
225         return JNI_ERR;
226 
227     NSK_DISPLAY1(&quot;plist = 0x%p\n&quot;, plist);
228 
229     if (!setCallBacks(1)) {
230         return JNI_ERR;
231     }
232 
233     if (!enableEvent(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT)
234             || !enableEvent(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH)
235             || !enableEvent(JVMTI_ENABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED)) {
236         return JNI_ERR;
237     }
238 
239     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
240         return JNI_ERR;
241 
242     return JNI_OK;
243 }
244 
245 /* ============================================================================= */
246 
247 JNIEXPORT void JNICALL
248 #ifdef STATIC_BUILD
249 Agent_OnUnload_em04t001(JavaVM *jvm)
250 #else
251 Agent_OnUnload(JavaVM *jvm)
252 #endif
253 {
254 
255     if (!NSK_VERIFY(nsk_list_destroy(plist))) {
256         nsk_jvmti_setFailStatus();
257     }
258 
<a name="15" id="anc15"></a><span class="line-modified">259     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock))) {</span>
<span class="line-modified">260         nsk_jvmti_setFailStatus();</span>

261     }
262 }
263 
264 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
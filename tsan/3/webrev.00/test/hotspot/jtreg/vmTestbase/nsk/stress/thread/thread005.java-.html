<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/stress/thread/thread005.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @key stress
 27  *
 28  * @summary converted from VM testbase nsk/stress/thread/thread005.
 29  * VM testbase keywords: [stress, diehard, slow, nonconcurrent, quick]
 30  * VM testbase readme:
 31  * DESCRIPTION
 32  *     Try many threads starting simultaneously.
 33  *
 34  * @run main/othervm nsk.stress.thread.thread005 500 2m 5s
 35  */
 36 
 37 package nsk.stress.thread;
 38 
 39 import java.io.PrintStream;
 40 
 41 /**
 42  * Try many threads starting simultaneously.
 43  */
 44 public class thread005 extends Thread {
 45     /**
 46      * Enable/disable printing of debugging info.
 47      */
 48     private static boolean DEBUG_MODE = false;
 49 
 50     /**
 51      * The number of threads that the tested JVM must support.
 52      */
 53     private static int THREADS_EXPECTED = 1000;
 54 
 55     /**
 56      * Timeout (in milliseconds) after which all threads must halt.
 57      */
 58     private static long TIMEOUT = 300000; // 5 minutes
 59 
 60     /**
 61      * Wait few seconds to allow child threads actually start.
 62      */
 63     private static long YIELD_TIME = 5000; // 5 seconds
 64 
 65     /**
 66      * Once &lt;code&gt;arg&lt;/code&gt; is ``XXXs&#39;&#39;, or ``XXXm&#39;&#39;, or ``XXXms&#39;&#39;,
 67      * return the given number of seconds, minutes, or milliseconds
 68      * correspondingly.
 69      */
 70     private static long parseTime(String arg) {
 71         for (int i = arg.lastIndexOf(&quot;ms&quot;); i &gt; -1; )
 72             return Long.parseLong(arg.substring(0, i));
 73         for (int i = arg.lastIndexOf(&quot;s&quot;); i &gt; -1; )
 74             return Long.parseLong(arg.substring(0, i)) * 1000;
 75         for (int i = arg.lastIndexOf(&quot;m&quot;); i &gt; -1; )
 76             return Long.parseLong(arg.substring(0, i)) * 60000;
 77         throw new IllegalArgumentException(
 78                 &quot;cannot recognize time scale: &quot; + arg);
 79     }
 80 
 81     /**
 82      * Re-invoke to &lt;code&gt;run(args,out)&lt;/code&gt; to follow JCK style.
 83      */
 84     public static void main(String args[]) {
 85         int exitCode = run(args, System.out);
 86         System.exit(exitCode + 95);
 87     }
 88 
 89     /**
 90      * JavaTest-like entry: &lt;code&gt;args[]&lt;/code&gt; may reset
 91      * &lt;code&gt;THREADS_EXPECTED&lt;/code&gt; and &lt;code&gt;TIMEOUT&lt;/code&gt;
 92      * values.
 93      */
 94     public static int run(String args[], PrintStream out) {
 95         if (args.length &gt; 0)
 96             THREADS_EXPECTED = Integer.parseInt(args[0]);
 97         if (args.length &gt; 1)
 98             TIMEOUT = parseTime(args[1]);
 99         if (args.length &gt; 2)
100             YIELD_TIME = parseTime(args[2]);
101         if (args.length &gt; 3)
102             DEBUG_MODE = args[3].toLowerCase().startsWith(&quot;-v&quot;);
103         if (args.length &gt; 4) {
104             out.println(&quot;#&quot;);
105             out.println(&quot;# Too namy command-line arguments!&quot;);
106             out.println(&quot;#&quot;);
107             return 2;
108         }
109 
110         if (DEBUG_MODE) {
111             out.println(
112                     &quot;Start &quot; + THREADS_EXPECTED + &quot; threads, &quot;
113                             + &quot;halt after &quot; + TIMEOUT + &quot; milliseconds:&quot;);
114         }
115 
116         Thread thread[] = new Thread[THREADS_EXPECTED];
117         for (int i = 0; i &lt; THREADS_EXPECTED; i++)
118             try {
119                 thread[i] = new thread005();
120                 thread[i].start();
121                 if (DEBUG_MODE)
122                     out.println(&quot;Threads started: &quot; + (i + 1));
123             } catch (OutOfMemoryError oome) {
124                 oome.printStackTrace(out);
125                 out.println(&quot;#&quot;);
126                 out.println(&quot;# The test have FAILED:&quot;);
127                 out.println(&quot;# Only &quot; + i + &quot; threads could start,&quot;);
128                 out.println(&quot;# while at least &quot; + THREADS_EXPECTED +
129                         &quot; were expected.&quot;);
130                 out.println(&quot;#&quot;);
131                 return 2;
132             }
133 
134         // Actually start:
135         GO = true;
136         // ...and let them go:
137         try {
138             doSleep(YIELD_TIME);
139         } catch (InterruptedException ie) {
140             ie.printStackTrace(out);
141             out.println(&quot;#&quot;);
142             out.println(&quot;# OOPS! Could not let threads actually start!&quot;);
143             out.println(&quot;#&quot;);
144             return 2;
145         }
146         STOP = true;
147 
148         if (DEBUG_MODE)
149             out.println(&quot;The test have PASSED.&quot;);
150         return 0;
151     }
152 
153     private static boolean GO = false;
154     private static boolean STOP = false;
155 
156     /**
157      * The thread activity: do nothing special, but do not
158      * free CPU time so that the thread&#39;s memory could not
159      * be moved to swap file.
160      */
161     public void run() {
162         while (!GO &amp;&amp; !timeout())
163             yield();
164         while (!STOP &amp;&amp; !timeout())
165             ;
166     }
167 
168     private static long startTime = System.currentTimeMillis();
169 
170     /**
171      * Check if timeout for this test is exceeded.
172      */
173     private boolean timeout() {
174         long elapsedTime = System.currentTimeMillis() - startTime;
175         return elapsedTime &gt; TIMEOUT;
176     }
177 
178     /**
179      * Yield to other threads for the given amount of
180      * &lt;code&gt;time&lt;/code&gt; (milliseconds).
181      */
182     private static void doSleep(long time) throws InterruptedException {
183         //
184         // Since Java 2, the method Thread.sleep() doesn&#39;t guarantee
185         // to yield to other threads. So, call Object.wait() to yield:
186         //
187         Object lock = new Object(); // local scope, nobody can notify it
188         synchronized (lock) {
189             lock.wait(time);
190         }
191     }
192 }
    </pre>
  </body>
</html>
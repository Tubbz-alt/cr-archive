<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jdi/EventRequestManager/createStepRequest/crstepreq004.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.EventRequestManager.createStepRequest;
 25 
 26 import nsk.share.*;
 27 import nsk.share.jpda.*;
 28 import nsk.share.jdi.*;
 29 
 30 import com.sun.jdi.*;
 31 import com.sun.jdi.connect.*;
 32 import com.sun.jdi.request.*;
 33 import com.sun.jdi.event.*;
 34 import java.io.*;
 35 import java.util.*;
 36 
 37 /**
 38  */
 39 public class crstepreq004 {
 40 
 41     //----------------------------------------------------- immutable common fields
 42 
 43     static final int PASSED    = 0;
 44     static final int FAILED    = 2;
 45     static final int PASS_BASE = 95;
 46     static final int quit      = -1;
 47 
 48     private int instruction = 1;
 49     private int waitTime;
 50     private static int exitCode = PASSED;
 51 
 52     private ArgumentHandler     argHandler;
 53     private Log                 log;
 54     private Debugee             debuggee;
 55     private VirtualMachine      vm;
 56     private ReferenceType       debuggeeClass;
 57 
 58     private EventRequestManager eventRManager;
 59     private EventSet            eventSet;
 60     private EventIterator       eventIterator;
 61 
 62     //------------------------------------------------------ mutable common fields
 63 
 64     private final static String prefix = &quot;nsk.jdi.EventRequestManager.createStepRequest&quot;;
 65     private final static String className = &quot;.crstepreq004&quot;;
 66     private final static String debuggerName = prefix + className;
 67     private final static String debuggeeName = debuggerName + &quot;a&quot;;
 68 
 69     //------------------------------------------------------ immutable common methods
 70 
 71     public static void main (String argv[]) {
 72         System.exit(run(argv, System.out) + PASS_BASE);
 73     }
 74 
 75     //------------------------------------------------------ test specific fields
 76 
 77     static final int lineForBreakInThread = 146;
 78     static final int[] checkedLines = { 160, 160, 193 };
 79     static final int[] checkedLinesAlt = { 161, 161, 193 };
 80 
 81     //------------------------------------------------------ mutable common methods
 82 
 83     public static int run (String argv[], PrintStream out) {
 84 
 85         int exitStatus = new crstepreq004().runThis(argv, out);
 86         System.out.println (exitStatus == PASSED ? &quot;TEST PASSED&quot; : &quot;TEST FAILED&quot;);
 87         return exitCode;
 88     }
 89 
 90     private int runThis(String argv[], PrintStream out) {
 91 
 92         argHandler = new ArgumentHandler(argv);
 93         log = new Log(out, argHandler);
 94         waitTime = argHandler.getWaitTime() * 60000;
 95 
 96         try {
 97 
 98             Binder binder = new Binder(argHandler, log);
 99             debuggee = binder.bindToDebugee(debuggeeName);
100             debuggee.redirectStdout(log, &quot;debuggee stdout&gt; &quot;);
101             debuggee.redirectStderr(log, &quot;debuggee stderr&gt; &quot;);
102             debuggee.createIOPipe();
103             eventRManager = debuggee.getEventRequestManager();
104 
105             vm = debuggee.VM();
106             eventRManager = vm.eventRequestManager();
107 
108             debuggeeClass = waitForDebuggeeClassPrepared();
109 
110             execTest();
111 
112             debuggee.resume();
113             getEventSet();
114             if (eventIterator.nextEvent() instanceof VMDeathEvent) {
115                 display(&quot;Waiting for the debuggee&#39;s finish...&quot;);
116                 debuggee.waitFor();
117 
118                 display(&quot;Getting the debuggee&#39;s exit status.&quot;);
119                 int status = debuggee.getStatus();
120                 if (status != (PASSED + PASS_BASE)) {
121                     complain(&quot;Debuggee returned UNEXPECTED exit status: &quot; + status);
122                     exitCode = Consts.TEST_FAILED;
123                 }
124             } else {
125                 throw new TestBug(&quot;Last event is not the VMDeathEvent&quot;);
126             }
127 
128         } catch (VMDisconnectedException e) {
129             exitCode = Consts.TEST_FAILED;
130             complain(&quot;The test cancelled due to VMDisconnectedException.&quot;);
131             e.printStackTrace(out);
132             display(&quot;Trying: vm.process().destroy();&quot;);
133             if (vm != null) {
134                 Process vmProcess = vm.process();
135                 if (vmProcess != null) {
136                     vmProcess.destroy();
137                 }
138             }
139 
140         } catch (Exception e) {
141             exitCode = Consts.TEST_FAILED;
142             complain(&quot;Unexpected Exception: &quot; + e.getMessage());
143             e.printStackTrace(out);
144             complain(&quot;The test has not finished normally. Forcing: vm.exit().&quot;);
145             if (vm != null) {
146                 vm.exit(PASSED + PASS_BASE);
147             }
148             debuggee.resume();
149             getEventSet();
150         }
151 
152         return exitCode;
153     }
154 
155     //--------------------------------------------------------- mutable common methods
156 
157     private void execTest() {
<a name="1" id="anc1"></a><span class="line-modified">158         ThreadReference mainThread = threadByName(&quot;main&quot;);</span>
159 
160         BreakpointRequest bpRequest = setBreakpoint( mainThread,
161                                                      debuggeeClass,
162                                                      &quot;methodForCommunication&quot;,
163                                                      lineForBreakInThread,
164                                                      &quot;breakpointForCommunication&quot;);
165         bpRequest.enable();
166 
167         display(&quot;TESTING BEGINS&quot;);
168 
169         label0:
170         for (int testCase = 0; instruction != quit; testCase++) {
171 
172 //            waitForEvent(bpRequest);
173             instruction = getInstruction();
174             if (instruction == quit) {
175                 vm.resume();
176                 break;
177             }
178 
179             display(&quot;:: case: # &quot; + testCase);
180 
181             switch (testCase) {
182             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ test case section
183                  case 0:
184                      display(&quot;Step request will be created with size == StepRequest.STEP_LINE, depth == StepRequest.STEP_INTO&quot;);
185                      setAndCheckStepEvent ( bpRequest,
186                                             &quot;StepRequest0&quot;,
187                                             &quot;thread2&quot;,
188                                             testCase,
189                                             StepRequest.STEP_INTO);
190                      break;
191 
192                  case 1:
193                      display(&quot;Step request will be created with size == StepRequest.STEP_LINE, depth == StepRequest.STEP_OVER&quot;);
194                      setAndCheckStepEvent ( bpRequest,
195                                             &quot;StepRequest1&quot;,
196                                             &quot;thread2&quot;,
197                                             testCase,
198                                             StepRequest.STEP_OVER);
199                      break;
200                  case 2:
201                      display(&quot;Step request will be created with size == StepRequest.STEP_LINE, depth == StepRequest.STEP_OUT&quot;);
202                      setAndCheckStepEvent ( bpRequest,
203                                             &quot;StepRequest2&quot;,
204                                             &quot;thread2&quot;,
205                                             testCase,
206                                             StepRequest.STEP_OUT);
207             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ end of section
208                  default:
209                      instruction = quit;
210                      setInstruction(&quot;quit&quot;);
211             }
212         }
213         display(&quot;TESTING ENDS&quot;);
214     }
215 
216     //--------------------------------------------------------- test specific methodss
217 
218     private StepRequest setStepRequest ( ThreadReference thread, int size, int depth, String property ) {
219         display(&quot;Setting a step request in  thread: &quot; + thread);
220         StepRequest stepRequest = null;
221 
222         try {
223             stepRequest = eventRManager.createStepRequest(thread, size, depth);
224             stepRequest.putProperty(&quot;number&quot;, property);
225         } catch ( Exception e1 ) {
226             complain(&quot;setStepRequest(): unexpected Exception while creating StepRequest: &quot; + e1);
227             throw new Failure(&quot;setStep(): A StepRequest has not been set up.&quot;);
228         }
229 
230         display(&quot;setStepRequest(): A StepRequest has been set up.&quot;);
231         return stepRequest;
232     }
233 
234     private void setAndCheckStepEvent ( BreakpointRequest bpRequest,
235                                         String caseProperty,
236                                         String threadName,
237                                         int testCaseIndex,
238                                         int stepDepth) {
239         display(&quot;Wait for brakepoint event in &quot; + threadName);
240         BreakpointEvent bpEvent = (BreakpointEvent)waitForEvent(bpRequest);
241 
242         // check location of breakpoint event
243         int lineOfEvent = ((LocatableEvent)bpEvent).location().lineNumber();
244         if (lineOfEvent != lineForBreakInThread) {
245             complain(&quot;Wrong line number of BreakpointEvent for &quot; + threadName);
246             complain(&quot;\texpected value : &quot; + lineForBreakInThread + &quot;; got one : &quot; + lineOfEvent);
247             exitCode = FAILED;
248         }
249 
<a name="2" id="anc2"></a><span class="line-modified">250         ThreadReference thread = threadByName(threadName);</span>
251         StepRequest stepRequest = setStepRequest( thread,
252                                                   StepRequest.STEP_LINE,
253                                                   stepDepth,
254                                                   caseProperty);
255         stepRequest.enable();
256 
257         display(&quot;waiting for StepEvent in &quot; + threadName);
258         Event newEvent = waitForEvent(stepRequest);
259         if (newEvent instanceof StepEvent) {
260             String property = (String) newEvent.request().getProperty(&quot;number&quot;);
261             display(&quot;got new StepEvent with property &#39;number&#39; == &quot; + property);
262 
263             if ( !property.equals(caseProperty) ) {
264                 complain(&quot;property is not : &quot; + caseProperty);
265                 exitCode = FAILED;
266             }
267             // check location of step event
268             lineOfEvent = ((LocatableEvent)newEvent).location().lineNumber();
269             boolean isCorrectLine = lineOfEvent == checkedLines[testCaseIndex] || lineOfEvent == checkedLinesAlt[testCaseIndex];
270             if (!isCorrectLine) {
271                 switch (stepDepth) {
272                      case StepRequest.STEP_INTO:
273                          complain(&quot;Wrong line number of StepEvent for request with depth == StepRequest.STEP_INTO:&quot; );
274                          break;
275                      case StepRequest.STEP_OVER:
276                          complain(&quot;Wrong line number of StepEvent for request with depth == StepRequest.STEP_OVER:&quot; );
277                          break;
278                      case StepRequest.STEP_OUT:
279                          complain(&quot;Wrong line number of StepEvent for request with depth == StepRequest.STEP_OUT:&quot; );
280                          break;
281                 }
282                 String msg = &quot;\texpected line %d or %d; got %d&quot;;
283                 complain(String.format(msg, checkedLines[testCaseIndex], checkedLinesAlt[testCaseIndex], lineOfEvent));
284                 exitCode = FAILED;
285             }
286 
287         } else if (newEvent instanceof BreakpointEvent) {
288             vm.resume();
289             exitCode = FAILED;
290             complain(&quot;got unexpected BreakpointEvent, but StepEvent is not received&quot;);
291         } else if (newEvent instanceof VMDeathEvent) {
292             exitCode = FAILED;
293             throw new Failure(&quot;got unexpected VMDeathtEvent, but StepEvent is not received&quot;);
294         }
295 
296         stepRequest.disable();
297         eventRManager.deleteEventRequest(stepRequest);
298         stepRequest = null;
299         display(&quot;request for StepEvent in &quot; + threadName + &quot; is deleted&quot;);
300     }
301 
302     //--------------------------------------------------------- immutable common methods
303 
304     void display(String msg) {
305         log.display(&quot;debugger &gt; &quot; + msg);
306     }
307 
308     void complain(String msg) {
309         log.complain(&quot;debugger FAILURE &gt; &quot; + msg);
310     }
311 
312    /**
313     * Sets up a breakpoint at given line number within a given method in a given class
314     * for a given thread.
315     *
316     * Returns a BreakpointRequest object in case of success, otherwise throws Failure.
317     */
318     private BreakpointRequest setBreakpoint ( ThreadReference thread,
319                                               ReferenceType testedClass,
320                                               String methodName,
321                                               int bpLine,
322                                               String property) {
323 
324         display(&quot;Setting a breakpoint in :&quot;);
325         display(&quot;  thread: &quot; + thread + &quot;; class: &quot; + testedClass +
326                 &quot;; method: &quot; + methodName + &quot;; line: &quot; + bpLine + &quot;; property: &quot; + property);
327 
328         List allLineLocations = null;
329         Location lineLocation = null;
330         BreakpointRequest breakpRequest = null;
331 
332         try {
333             Method  method  = (Method) testedClass.methodsByName(methodName).get(0);
334 
335             allLineLocations = method.allLineLocations();
336 
337             display(&quot;Getting location for breakpoint...&quot;);
338             Iterator locIterator = allLineLocations.iterator();
339             while (locIterator.hasNext()) {
340                 Location curLocation = (Location)locIterator.next();
341                 int curNumber = curLocation.lineNumber();
342                 if (curLocation.lineNumber() == bpLine) {
343                     lineLocation = curLocation;
344                     break;
345                 }
346             }
347             if (lineLocation == null) {
348                 throw new TestBug(&quot;Incorrect line number of methods&#39; location&quot;);
349             }
350 
351             try {
352                 breakpRequest = eventRManager.createBreakpointRequest(lineLocation);
353                 if (thread != null) {
354                     breakpRequest.addThreadFilter(thread);
355                 }
356                 breakpRequest.putProperty(&quot;number&quot;, property);
357             } catch ( Exception e1 ) {
358                 complain(&quot;setBreakpoint(): unexpected Exception while creating BreakpointRequest: &quot; + e1);
359                 breakpRequest = null;
360             }
361         } catch ( Exception e2 ) {
362             complain(&quot;setBreakpoint(): unexpected Exception while getting locations: &quot; + e2);
363             breakpRequest = null;
364         }
365 
366         if (breakpRequest == null) {
367             throw new Failure(&quot;setBreakpoint(): A breakpoint has not been set up.&quot;);
368         }
369 
370         display(&quot;setBreakpoint(): A breakpoint has been set up.&quot;);
371         return breakpRequest;
372     }
373 
374     private Event waitForEvent (EventRequest eventRequest) {
375 
376         vm.resume();
377         Event resultEvent = null;
378         try {
379             eventSet = null;
380             eventIterator = null;
381             eventSet = vm.eventQueue().remove(waitTime);
382             if (eventSet == null) {
383                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
384             }
385             eventIterator = eventSet.eventIterator();
386             while (eventIterator.hasNext()) {
387                 Event curEvent = eventIterator.nextEvent();
388                 if (curEvent instanceof VMDisconnectEvent) {
389                     throw new Failure(&quot;Unexpected VMDisconnectEvent received.&quot;);
390                 } else {
391                     EventRequest evRequest = curEvent.request();
392                     if (evRequest != null &amp;&amp; evRequest.equals(eventRequest)) {
393                         display(&quot;Requested event received: &quot; + curEvent.toString() +
394                             &quot;; request property: &quot; + (String) curEvent.request().getProperty(&quot;number&quot;));
395                         resultEvent = curEvent;
396                         break;
397                     } else {
398                         throw new Failure(&quot;Unexpected event received: &quot; + curEvent.toString());
399                     }
400                 }
401             }
402         } catch (Exception e) {
403             throw new Failure(&quot;Unexpected exception while waiting for an event: &quot; + e);
404         }
405         return resultEvent;
406     }
407 
408 
409     private void getEventSet() {
410         try {
411             eventSet = vm.eventQueue().remove(waitTime);
412             if (eventSet == null) {
413                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
414             }
415             eventIterator = eventSet.eventIterator();
416         } catch (Exception e) {
417             throw new Failure(&quot;getEventSet(): Unexpected exception while waiting for an event: &quot; + e);
418         }
419     }
420 
<a name="3" id="anc3"></a><span class="line-removed">421 </span>
<span class="line-removed">422     private ThreadReference threadByName(String name) throws Failure{</span>
<span class="line-removed">423         List all = vm.allThreads();</span>
<span class="line-removed">424         ListIterator li = all.listIterator();</span>
<span class="line-removed">425 </span>
<span class="line-removed">426         while (li.hasNext()) {</span>
<span class="line-removed">427             ThreadReference thread = (ThreadReference) li.next();</span>
<span class="line-removed">428             if (thread.name().equals(name))</span>
<span class="line-removed">429                 return thread;</span>
<span class="line-removed">430         }</span>
<span class="line-removed">431         throw new Failure(&quot;Thread with searching for name is not found: &quot; + name);</span>
<span class="line-removed">432     }</span>
<span class="line-removed">433 </span>
434     private ReferenceType waitForDebuggeeClassPrepared () {
435         display(&quot;Creating request for ClassPrepareEvent for debuggee.&quot;);
436         ClassPrepareRequest cpRequest = eventRManager.createClassPrepareRequest();
437         cpRequest.addClassFilter(debuggeeName);
438         cpRequest.addCountFilter(1);
439         cpRequest.enable();
440 
441         ClassPrepareEvent event = (ClassPrepareEvent) waitForEvent(cpRequest);
442         cpRequest.disable();
443 
444         if (!event.referenceType().name().equals(debuggeeName)) {
445            throw new Failure(&quot;Unexpected class name for ClassPrepareEvent : &quot; + debuggeeClass.name());
446         }
447         return event.referenceType();
448     }
449 
450     private int getInstruction () {
451         if (debuggeeClass == null) {
452             throw new Failure(&quot;getInstruction() :: debuggeeClass reference is null&quot;);
453         }
454         return ((IntegerValue) (debuggeeClass.getValue(debuggeeClass.fieldByName(&quot;instruction&quot;)))).value();
455     }
456 
457     private void setInstruction (String instructionField) {
458         if (debuggeeClass == null) {
459             throw new Failure(&quot;getInstruction() :: debuggeeClass reference is null&quot;);
460         }
461         Field instrField = debuggeeClass.fieldByName(&quot;instruction&quot;);
462         IntegerValue instrValue = (IntegerValue) (debuggeeClass.getValue(debuggeeClass.fieldByName(instructionField)));
463         try {
464             ((ClassType)debuggeeClass).setValue(instrField, instrValue );
465         } catch (InvalidTypeException e1) {
466             throw new Failure(&quot;Caught unexpected InvalidTypeException while setting value &#39;&quot; + instructionField + &quot;&#39; for instruction field&quot;);
467         } catch (ClassNotLoadedException e2) {
468             throw new Failure(&quot;Caught unexpected ClassNotLoadedException while setting value &#39;&quot; + instructionField + &quot;&#39; for instruction field&quot;);
469         }
470     }
471 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/contention/TC04/tc04t001.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jvmti.scenarios.contention.TC04;
 25 
 26 import java.io.PrintStream;
 27 
 28 import nsk.share.*;
 29 import nsk.share.jvmti.*;
 30 
 31 public class tc04t001 extends DebugeeClass {
 32 
 33     final static int THREADS_LIMIT = 2;
 34 
 35     // run test from command line
 36     public static void main(String argv[]) {
 37         argv = nsk.share.jvmti.JVMTITest.commonInit(argv);
 38 
 39         // JCK-compatible exit
 40         System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);
 41     }
 42 
 43     // run test from JCK-compatible environment
 44     public static int run(String argv[], PrintStream out) {
 45         return new tc04t001().runIt(argv, out);
 46     }
 47 
 48     /* =================================================================== */
 49 
 50     // scaffold objects
 51     ArgumentHandler argHandler = null;
 52     Log log = null;
 53     int status = Consts.TEST_PASSED;
 54     long timeout = 0;
 55 
 56     // run debuggee
 57     public int runIt(String argv[], PrintStream out) {
 58         argHandler = new ArgumentHandler(argv);
 59         log = new Log(out, argHandler);
 60         timeout = argHandler.getWaitTime() * 60 * 1000;
 61         log.display(&quot;Timeout = &quot; + timeout + &quot; msc.&quot;);
 62 
 63         tc04t001Thread threads[] = new tc04t001Thread[THREADS_LIMIT];
 64         status = checkStatus(status);
 65         for (int i = 0; i &lt; THREADS_LIMIT; i++) {
 66             threads[i] = new tc04t001Thread(i);
 67             threads[i].start();
 68         }
 69 
 70         try {
 71             for (int i = 0; i &lt; THREADS_LIMIT; i++) {
 72                 threads[i].join(timeout/THREADS_LIMIT);
 73             }
 74         } catch (InterruptedException e) {
 75             throw new Failure(e);
 76         }
 77 
 78         status = checkStatus(status);
 79 
 80         log.display(&quot;Debugee finished, value: &quot; + tc04t001Thread.value);
 81         if (tc04t001Thread.value !=
 82                 THREADS_LIMIT*tc04t001Thread.INCREMENT_LIMIT) {
 83             log.complain(&quot;Wrong value: &quot; + tc04t001Thread.value +
 84                 &quot;, expected: &quot; + THREADS_LIMIT*tc04t001Thread.INCREMENT_LIMIT);
 85             status = Consts.TEST_FAILED;
 86         }
 87 
 88 /* DEBUG -- to check if the threads taking turns in right order
 89         boolean race = false;
 90         for (int i = 1; i &lt; 2*tc04t001Thread.INCREMENT_LIMIT; i++) {
 91              if (tc04t001Thread.passOrder[i] == tc04t001Thread.passOrder[i-1]) {
 92                 race = true;
 93                 System.out.println(&quot;Race condition in the test:&quot;);
 94                 System.out.println(&quot;passOrder[&quot; + (i-1) + &quot;]:&quot;
 95                     + tc04t001Thread.passOrder[i-1]);
 96                 System.out.println(&quot;passOrder[&quot; + (i) + &quot;]:&quot;
 97                     + tc04t001Thread.passOrder[i]);
 98              }
 99         }
100         if (race)
101             System.out.println(&quot;There was a race condition in the test.&quot;);
102 */
103 
104         return status;
105     }
106 }
107 
108 /* =================================================================== */
109 
110 class tc04t001Thread extends Thread {
111 
112     final static int INCREMENT_LIMIT = 100;
113     final static int DELAY = 1000;
114 
115     static volatile int value = 0;
116 
117     static Flicker flicker = new Flicker();
118 /* DEBUG -- to check if the threads taking turns in right order
119     static volatile int iter = 0;
120     static volatile int passOrder[] =
121         new int[INCREMENT_LIMIT*tc04t001.THREADS_LIMIT];
122 */
123 
124     private int id;
125 
126     public tc04t001Thread(int i) {
127         super(&quot;Debuggee Thread &quot; + i);
128         id = i;
129     }
130 
131     public synchronized void run() {
132         for (int i = 0; i &lt; INCREMENT_LIMIT; i++) {
133             flicker.waitFor(id);
134             increment(id);
135             try {
136                 wait(1);
137             } catch (InterruptedException e) {}
138         }
139     }
140 
141     static synchronized void increment(int i) {
142 /* DEBUG -- to check if the threads taking turns in right order
143         passOrder[iter++] = i;
144 */
145         flicker.unlock(i);
146         int temp = value;
147         for (int j = 0; j &lt; DELAY; j++) ;
148         try {
149             sleep(500);
150         } catch (InterruptedException e) {}
151         value = temp + 1;
152     }
153 }
154 
155 class Flicker {
156 
157     private int owner = -1;
158 
159     public synchronized void waitFor(int owner) {
160         while (this.owner == owner) {
161             try {
162                 wait();
163             } catch (InterruptedException e) {}
164         }
165     }
166 
167     public synchronized void unlock(int owner) {
168         if (this.owner == owner)
169             throw new IllegalStateException(&quot;the same owner: &quot; + owner);
170 
171         this.owner = owner;
172         notifyAll();
173     }
174 }
    </pre>
  </body>
</html>
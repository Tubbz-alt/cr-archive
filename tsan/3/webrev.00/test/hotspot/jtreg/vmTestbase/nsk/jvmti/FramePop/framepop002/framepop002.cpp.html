<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/FramePop/framepop002/framepop002.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdio.h&gt;
 25 #include &lt;stdlib.h&gt;
 26 #include &lt;string.h&gt;
 27 #include &quot;jvmti.h&quot;
 28 #include &quot;agent_common.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 #include &quot;jvmti_tools.h&quot;
 31 
 32 extern &quot;C&quot; {
 33 
 34 
 35 #define PASSED 0
 36 #define STATUS_FAILED 2
 37 #define MAX_THREADS 32
 38 
 39 typedef struct item *item_t;
 40 struct item {
 41     item_t next;
 42     jmethodID method;
 43     int depth;
 44 } item;
 45 
 46 typedef struct thr {
 47     jthread thread;
 48     item_t tos;
 49 } thr;
 50 
 51 static jvmtiEnv *jvmti = NULL;
 52 static jvmtiCapabilities caps;
 53 static jvmtiEventCallbacks callbacks;
 54 static jrawMonitorID event_lock;
 55 static jint result = PASSED;
 56 static jboolean printdump = JNI_FALSE;
 57 static jboolean watch_events = JNI_FALSE;
 58 
 59 static int pop_count = 0;
 60 static int push_count = 0;
 61 static int thr_count = 0;
 62 static int max_depth = 0;
 63 static thr threads[MAX_THREADS];
 64 
 65 static volatile int callbacksEnabled = NSK_FALSE;
 66 static jrawMonitorID agent_lock;
 67 
 68 static
 69 int isTestThread(jvmtiEnv *jvmti_env, jthread thr) {
 70     jvmtiError err;
 71     jvmtiThreadInfo inf;
 72     const char* TEST_THREAD_NAME_BASE = &quot;Test Thread&quot;;
 73 
 74     err = jvmti_env-&gt;GetThreadInfo(thr, &amp;inf);
 75     if (err != JVMTI_ERROR_NONE) {
 76          printf(&quot;(GetThreadInfo) unexpected error: %s (%d)\n&quot;, TranslateError(err), err);
 77          result = STATUS_FAILED;
 78          return 0;
 79     }
 80     return strncmp(inf.name, TEST_THREAD_NAME_BASE, strlen(TEST_THREAD_NAME_BASE)) == 0;
 81 }
 82 
 83 static
 84 void printInfo(jvmtiEnv *jvmti_env, jthread thr, jmethodID method, int depth) {
 85     jvmtiError err;
 86     jvmtiThreadInfo inf;
 87     char *clsig, *name, *sig, *generic;
 88     jclass cls;
 89 
 90     err = jvmti_env-&gt;GetThreadInfo(thr, &amp;inf);
 91     if (err != JVMTI_ERROR_NONE) {
 92         printf(&quot;(GetThreadInfo) unexpected error: %s (%d)\n&quot;,
 93                TranslateError(err), err);
 94         result = STATUS_FAILED;
 95     }
 96 
 97     err = jvmti_env-&gt;GetMethodDeclaringClass(method, &amp;cls);
 98     if (err != JVMTI_ERROR_NONE) {
 99         printf(&quot;(GetMethodDeclaringClass) unexpected error: %s (%d)\n&quot;,
100                TranslateError(err), err);
101         result = STATUS_FAILED;
102     }
103 
104     err = jvmti_env-&gt;GetClassSignature(cls, &amp;clsig, &amp;generic);
105     if (err != JVMTI_ERROR_NONE) {
106         printf(&quot;(GetClassSignature) unexpected error: %s (%d)\n&quot;,
107                TranslateError(err), err);
108         result = STATUS_FAILED;
109     }
110 
111     err = jvmti_env-&gt;GetMethodName(method, &amp;name, &amp;sig, &amp;generic);
112     if (err != JVMTI_ERROR_NONE) {
113         printf(&quot;(GetMethodName) unexpected error: %s (%d)\n&quot;,
114                TranslateError(err), err);
115         result = STATUS_FAILED;
116     }
117 
118     printf(&quot;  %s: %s.%s%s, depth = %d\n&quot;, inf.name, clsig, name, sig, depth);
119 
120     jvmti_env-&gt;Deallocate((unsigned char *)sig);
121     jvmti_env-&gt;Deallocate((unsigned char *)name);
122     jvmti_env-&gt;Deallocate((unsigned char *)clsig);
123     jvmti_env-&gt;Deallocate((unsigned char *)inf.name);
124 }
125 
126 static
127 void pop(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr, jmethodID method, int depth) {
128     item_t old;
129     int i, count = 0;
130 
131     for (i = 0; i &lt; thr_count; i++) {
132         if (env-&gt;IsSameObject(threads[i].thread, thr)) {
133             break;
134         }
135     }
136 
137     if (i == thr_count) {
138         watch_events = JNI_FALSE;
139         printf(&quot;Unknown thread:\n&quot;);
140         printInfo(jvmti_env, thr, method, depth);
141         result = STATUS_FAILED;
142         return;
143     }
144 
145     if (threads[i].tos == NULL) {
146         watch_events = JNI_FALSE;
147         printf(&quot;Stack underflow:\n&quot;);
148         printInfo(jvmti_env, thr, method, depth);
149         result = STATUS_FAILED;
150         return;
151     }
152 
153     do {
154         pop_count++;
155         old = threads[i].tos;
156         threads[i].tos = threads[i].tos-&gt;next;
157         if (old-&gt;method == method &amp;&amp; old-&gt;depth == depth) {
158             free(old);
159             return;
160         }
161         free(old);
162     } while (threads[i].tos != NULL);
163 
164     watch_events = JNI_FALSE;
165     printf(&quot;Frame pop does not match any entry:\n&quot;);
166     printInfo(jvmti_env, thr, method, depth);
167     result = STATUS_FAILED;
168 }
169 
170 static
171 void push(JNIEnv *env, jthread thr, jmethodID method, int depth) {
172     item_t new_item;
173     int i;
174 
175     for (i = 0; i &lt; thr_count; i++) {
176         if (env-&gt;IsSameObject(threads[i].thread, thr)) {
177             break;
178         }
179     }
180 
181     if (i == thr_count) {
182         thr_count++;
183         if (thr_count == MAX_THREADS) {
184             watch_events = JNI_FALSE;
185             printf(&quot;Out of threads\n&quot;);
186             result = STATUS_FAILED;
187             return;
188         }
189         threads[i].thread = env-&gt;NewGlobalRef(thr);
190         threads[i].tos = NULL;
191     }
192 
193     new_item = (item_t)malloc(sizeof(item));
194     if (new_item == NULL) {
195         watch_events = JNI_FALSE;
196         printf(&quot;Out of memory\n&quot;);
197         result = STATUS_FAILED;
198         return;
199     }
200 
201     new_item-&gt;next = threads[i].tos;
202     new_item-&gt;method = method;
203     new_item-&gt;depth = depth;
204     threads[i].tos = new_item;
205     push_count++;
206     max_depth = (max_depth &lt; depth) ? depth : max_depth;
207 }
208 
209 void JNICALL MethodEntry(jvmtiEnv *jvmti_env, JNIEnv *env,
210         jthread thr, jmethodID method) {
211     jvmtiError err;
212     jboolean isNative;
213     jint frameCount;
214 
215     if (watch_events == JNI_FALSE) return;
216 
217     jvmti-&gt;RawMonitorEnter(agent_lock);
218 
219     if (!callbacksEnabled) {
220         jvmti-&gt;RawMonitorExit(agent_lock);
221         return;
222     }
223 
224     err = jvmti_env-&gt;GetFrameCount(thr, &amp;frameCount);
225     if (err != JVMTI_ERROR_NONE) {
226         printf(&quot;(GetFrameCount#entry) unexpected error: %s (%d)\n&quot;,
227                TranslateError(err), err);
228         printInfo(jvmti_env, thr, method, frameCount);
229         result = STATUS_FAILED;
230         jvmti-&gt;RawMonitorExit(agent_lock);
231         return;
232     }
233 
234     err = jvmti_env-&gt;IsMethodNative(method, &amp;isNative);
235     if (err != JVMTI_ERROR_NONE) {
236         printf(&quot;(IsMethodNative) unexpected error: %s (%d)\n&quot;,
237                TranslateError(err), err);
238         printInfo(jvmti_env, thr, method, frameCount);
239         result = STATUS_FAILED;
240     }
241 
242     if (isTestThread(jvmti_env, thr)) {
243         if (printdump == JNI_TRUE) {
244             printf(&quot;&gt;&gt;&gt; %sMethod entry\n&gt;&gt;&gt;&quot;,
245                    (isNative == JNI_TRUE) ? &quot;Native &quot; : &quot;&quot;);
246             printInfo(jvmti_env, thr, method, frameCount);
247         }
248         if (isNative == JNI_FALSE) {
249             err = jvmti_env-&gt;RawMonitorEnter(event_lock);
250             if (err != JVMTI_ERROR_NONE) {
251                 printf(&quot;(RawMonitorEnter) unexpected error: %s (%d)\n&quot;,
252                        TranslateError(err), err);
253                 printInfo(jvmti_env, thr, method, frameCount);
254                 result = STATUS_FAILED;
255             }
256             push((JNIEnv *)env, thr, method, frameCount);
257             err = jvmti_env-&gt;RawMonitorExit(event_lock);
258             if (err != JVMTI_ERROR_NONE) {
259                 printf(&quot;(RawMonitorExit) unexpected error: %s (%d)\n&quot;,
260                        TranslateError(err), err);
261                 printInfo(jvmti_env, thr, method, frameCount);
262                 result = STATUS_FAILED;
263             }
264             err = jvmti_env-&gt;NotifyFramePop(thr, 0);
265             if (err != JVMTI_ERROR_NONE) {
266                 printf(&quot;(NotifyFramePop) unexpected error: %s (%d)\n&quot;,
267                        TranslateError(err), err);
268                 printInfo(jvmti_env, thr, method, frameCount);
269                 result = STATUS_FAILED;
270             }
271         }
272     }
273 
274     jvmti-&gt;RawMonitorExit(agent_lock);
275 }
276 
277 void JNICALL VMStart(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {
278     jvmti-&gt;RawMonitorEnter(agent_lock);
279 
280     callbacksEnabled = NSK_TRUE;
281 
282     jvmti-&gt;RawMonitorExit(agent_lock);
283 }
284 
285 
286 void JNICALL VMDeath(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {
287     jvmti-&gt;RawMonitorEnter(agent_lock);
288 
289     callbacksEnabled = NSK_FALSE;
290 
291     jvmti-&gt;RawMonitorExit(agent_lock);
292 }
293 
294 void JNICALL FramePop(jvmtiEnv *jvmti_env, JNIEnv *env,
295         jthread thr, jmethodID method, jboolean wasPopedByException) {
296     jvmtiError err;
297     jint frameCount;
298 
299     jvmti-&gt;RawMonitorEnter(agent_lock);
300 
301     if (!callbacksEnabled) {
302         jvmti-&gt;RawMonitorExit(agent_lock);
303         return;
304     }
305     err = jvmti_env-&gt;GetFrameCount(thr, &amp;frameCount);
306     if (err != JVMTI_ERROR_NONE) {
307         printf(&quot;(GetFrameCount#entry) unexpected error: %s (%d)\n&quot;,
308                TranslateError(err), err);
309         printInfo(jvmti_env, thr, method, frameCount);
310         result = STATUS_FAILED;
311         jvmti-&gt;RawMonitorExit(agent_lock);
312         return;
313     }
314 
315     if (isTestThread(jvmti_env, thr)) {
316         if (printdump == JNI_TRUE) {
317             printf(&quot;&gt;&gt;&gt; Frame Pop\n&gt;&gt;&gt;&quot;);
318             printInfo(jvmti_env, thr, method, frameCount);
319         }
320         err = jvmti_env-&gt;RawMonitorEnter(event_lock);
321         if (err != JVMTI_ERROR_NONE) {
322             printf(&quot;(RawMonitorEnter) unexpected error: %s (%d)\n&quot;,
323                    TranslateError(err), err);
324             printInfo(jvmti_env, thr, method, frameCount);
325             result = STATUS_FAILED;
326         }
327         pop(jvmti_env, (JNIEnv *)env, thr, method, frameCount);
328         err = jvmti_env-&gt;RawMonitorExit(event_lock);
329         if (err != JVMTI_ERROR_NONE) {
330             printf(&quot;(RawMonitorExit) unexpected error: %s (%d)\n&quot;,
331                    TranslateError(err), err);
332             printInfo(jvmti_env, thr, method, frameCount);
333             result = STATUS_FAILED;
334         }
335     }
336 
337     jvmti-&gt;RawMonitorExit(agent_lock);
338 }
339 
340 #ifdef STATIC_BUILD
341 JNIEXPORT jint JNICALL Agent_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {
342     return Agent_Initialize(jvm, options, reserved);
343 }
344 JNIEXPORT jint JNICALL Agent_OnAttach_framepop002(JavaVM *jvm, char *options, void *reserved) {
345     return Agent_Initialize(jvm, options, reserved);
346 }
347 JNIEXPORT jint JNI_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {
348     return JNI_VERSION_1_8;
349 }
350 #endif
351 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
352     jvmtiError err;
353     jint res;
354 
355     if (options != NULL &amp;&amp; strcmp(options, &quot;printdump&quot;) == 0) {
356         printdump = JNI_TRUE;
357     }
358 
359     res = jvm-&gt;GetEnv((void **) &amp;jvmti, JVMTI_VERSION_1_1);
360     if (res != JNI_OK || jvmti == NULL) {
361         printf(&quot;Wrong result of a valid call to GetEnv!\n&quot;);
362         return JNI_ERR;
363     }
364 
365     err = jvmti-&gt;CreateRawMonitor(&quot;_event_lock&quot;, &amp;event_lock);
366     if (err != JVMTI_ERROR_NONE) {
367         printf(&quot;(CreateRawMonitor) unexpected error: %s (%d)\n&quot;,
368                TranslateError(err), err);
369         return JNI_ERR;
370     }
371 
372     err = jvmti-&gt;GetPotentialCapabilities(&amp;caps);
373     if (err != JVMTI_ERROR_NONE) {
374         printf(&quot;(GetPotentialCapabilities) unexpected error: %s (%d)\n&quot;,
375                TranslateError(err), err);
376         return JNI_ERR;
377     }
378 
379     err = jvmti-&gt;AddCapabilities(&amp;caps);
380     if (err != JVMTI_ERROR_NONE) {
381         printf(&quot;(AddCapabilities) unexpected error: %s (%d)\n&quot;,
382                TranslateError(err), err);
383         return JNI_ERR;
384     }
385 
386     err = jvmti-&gt;GetCapabilities(&amp;caps);
387     if (err != JVMTI_ERROR_NONE) {
388         printf(&quot;(GetCapabilities) unexpected error: %s (%d)\n&quot;,
389                TranslateError(err), err);
390         return JNI_ERR;
391     }
392 
393     if (caps.can_generate_frame_pop_events &amp;&amp;
394             caps.can_generate_method_entry_events) {
395         callbacks.MethodEntry = &amp;MethodEntry;
396         callbacks.FramePop = &amp;FramePop;
397         callbacks.VMStart = &amp;VMStart;
398         callbacks.VMDeath = &amp;VMDeath;
399 
400         err = jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));
401         if (err != JVMTI_ERROR_NONE) {
402             printf(&quot;(SetEventCallbacks) unexpected error: %s (%d)\n&quot;,
403                    TranslateError(err), err);
404             return JNI_ERR;
405         }
406         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL)))
407             return JNI_ERR;
408         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))
409             return JNI_ERR;
410 
411         if (jvmti-&gt;CreateRawMonitor(&quot;agent_lock&quot;, &amp;agent_lock) != JVMTI_ERROR_NONE) {
412             return JNI_ERR;
413         }
414 
415     } else {
416         printf(&quot;Warning: FramePop or MethodEntry event is not implemented\n&quot;);
417     }
418 
419     return JNI_OK;
420 }
421 
422 JNIEXPORT void JNICALL Java_nsk_jvmti_FramePop_framepop002_getReady(JNIEnv *env, jclass cls) {
423     jvmtiError err;
424 
425     if (!caps.can_generate_frame_pop_events ||
426             !caps.can_generate_method_entry_events) {
427         return ;
428     }
429 
430     err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE,
431          JVMTI_EVENT_METHOD_ENTRY, NULL);
432     if (err != JVMTI_ERROR_NONE) {
433         printf(&quot;Failed to enable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\n&quot;,
434                TranslateError(err), err);
435         result = STATUS_FAILED;
436     }
437     err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE,
438          JVMTI_EVENT_FRAME_POP, NULL);
439     if (err != JVMTI_ERROR_NONE) {
440         printf(&quot;Failed to enable JVMTI_EVENT_FRAME_POP event: %s (%d)\n&quot;,
441                TranslateError(err), err);
442         result = STATUS_FAILED;
443     }
444     watch_events = JNI_TRUE;
445 }
446 
447 JNIEXPORT jint JNICALL Java_nsk_jvmti_FramePop_framepop002_check(JNIEnv *env, jclass cls) {
448     jvmtiError err;
449 
450     watch_events = JNI_FALSE;
451     err = jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE,
452          JVMTI_EVENT_FRAME_POP, NULL);
453     if (err != JVMTI_ERROR_NONE) {
454         printf(&quot;Failed to disable JVMTI_EVENT_FRAME_POP event: %s (%d)\n&quot;,
455                TranslateError(err), err);
456         result = STATUS_FAILED;
457     }
458     err = jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE,
459          JVMTI_EVENT_METHOD_ENTRY, NULL);
460     if (err != JVMTI_ERROR_NONE) {
461         printf(&quot;Failed to disable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\n&quot;,
462                TranslateError(err), err);
463         result = STATUS_FAILED;
464     }
465 
466     if (printdump == JNI_TRUE) {
467         printf(&quot;%d threads, %d method entrys, %d frame pops, max depth = %d\n&quot;,
468                thr_count, push_count, pop_count, max_depth);
469     }
470 
471     return result;
472 }
473 
474 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/unit/FollowReferences/followref003/followref003.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &lt;string.h&gt;
  25 #include &quot;jvmti.h&quot;
  26 #include &quot;agent_common.h&quot;
  27 #include &quot;jni_tools.h&quot;
  28 #include &quot;jvmti_tools.h&quot;
  29 
  30 extern &quot;C&quot; {
  31 
  32 /* ============================================================================= */
  33 
  34 static jlong timeout = 0;
  35 
  36 #define INFO_NONE       0x00
  37 #define INFO_ALL        0xFF
  38 #define INFO_OBJREF     0x01
  39 #define INFO_STACKREF   0x02
  40 #define INFO_HEAPROOT   0x04
  41 #define INFO_HEAPOBJ    0x08
  42 
  43 static unsigned int info = INFO_ALL;
  44 
  45 #define DEBUGEE_CLASS_NAME      &quot;nsk/jvmti/unit/FollowReferences/followref003&quot;
  46 #define ROOT_OBJECT_CLASS_NAME  &quot;nsk/jvmti/unit/FollowReferences/followref003RootTestedClass&quot;
  47 #define ROOT_OBJECT_CLASS_SIG   &quot;L&quot; ROOT_OBJECT_CLASS_NAME &quot;;&quot;
  48 #define CHAIN_OBJECT_CLASS_NAME &quot;nsk/jvmti/unit/FollowReferences/followref003TestedClass&quot;
  49 #define CHAIN_OBJECT_CLASS_SIG  &quot;L&quot; CHAIN_OBJECT_CLASS_NAME &quot;;&quot;
  50 
  51 #define OBJECT_FIELD_NAME               &quot;object&quot;
  52 #define REACHABLE_CHAIN_FIELD_NAME      &quot;reachableChain&quot;
  53 #define UNREACHABLE_CHAIN_FIELD_NAME    &quot;unreachableChain&quot;
  54 #define TAIL_FIELD_NAME                 &quot;tail&quot;
  55 
  56 
  57 #define DEFAULT_CHAIN_LENGTH 3
  58 #define MAXDEPTH 50
  59 #define MAXSLOT  16
  60 
  61 typedef struct ObjectDescStruct {
  62     jlong tag;
  63     jlong class_tag;
  64     jlong exp_class_tag;
  65     jint exp_found;
  66     jint found;
  67 } ObjectDesc;
  68 
  69 static int chainLength   = 0;
  70 static int objectsCount  = 0;
  71 static int fakeUserData  = 0;
  72 static int userDataError = 0;
  73 
  74 static ObjectDesc* objectDescList = NULL;
  75 
  76 #define TARG_THREAD_TAG  11
  77 #define FIRST_THREAD_TAG (TARG_THREAD_TAG + 1)
  78 
  79 #define TARG_FRAME_DEPTH  1
  80 
  81 static jlong rootClassTag   = 9;
  82 static jlong chainClassTag  = 99;
  83 static jlong thrObjectTag   = FIRST_THREAD_TAG;
  84 static jlong rootObjectTag  = 55;
  85 static jlong chainObjectTag = 100;
  86 
  87 
  88 /* Java method frame slots interesting to check */
  89 #define ARGV_STRING_ARR_SLOT   1
  90 #define FIRST_PRIM_ARR_SLOT    3
  91 #define LAST_PRIM_ARR_SLOT     10
  92 #define DUMMY_STRING_ARR_SLOT  11
  93 
  94 
  95 static jvmtiHeapCallbacks heapCallbacks;
  96 
  97 static const char* ref_kind_str[28] = {
  98    &quot;unknown_0&quot;,
  99    &quot;REFERENCE_CLASS&quot;,
 100    &quot;REFERENCE_FIELD&quot;,
 101    &quot;REFERENCE_ARRAY_ELEMENT&quot;,
 102    &quot;REFERENCE_CLASS_LOADER&quot;,
 103    &quot;REFERENCE_SIGNERS&quot;,
 104    &quot;REFERENCE_PROTECTION_DOMAIN&quot;,
 105    &quot;REFERENCE_INTERFACE&quot;,
 106    &quot;REFERENCE_STATIC_FIELD&quot;,
 107    &quot;REFERENCE_CONSTANT_POOL&quot;,
 108    &quot;unknown_10&quot;, &quot;unknown_11&quot;, &quot;unknown_12&quot;,
 109    &quot;unknown_13&quot;, &quot;unknown_14&quot;, &quot;unknown_15&quot;, &quot;unknown_16&quot;,
 110    &quot;unknown_17&quot;, &quot;unknown_18&quot;, &quot;unknown_19&quot;, &quot;unknown_20&quot;,
 111    &quot;REFERENCE_JNI_GLOBAL&quot;,
 112    &quot;REFERENCE_SYSTEM_CLASS&quot;,
 113    &quot;REFERENCE_MONITOR&quot;,
 114    &quot;REFERENCE_STACK_LOCAL&quot;,
 115    &quot;REFERENCE_JNI_LOCAL&quot;,
 116    &quot;REFERENCE_THREAD&quot;,
 117    &quot;REFERENCE_OTHER&quot;
 118 };
 119 
 120 
 121 #define DEREF(ptr) (((ptr) == NULL ? 0 : *(ptr)))
 122 
 123 
 124 /* ============================================================================= */
 125 
 126 /** Obtain chain of tested objects and tag them recursively. */
 127 static int getChainObjects(jvmtiEnv* jvmti, JNIEnv* jni, jobject firstObject,
 128                            jfieldID firstField, const char firstFieldName[],
 129                            jfieldID nextField, const char nextFieldName[],
 130                            int count, ObjectDesc objectDescList[],
 131                            jlong tag, int reachable) {
 132     jobject obj = NULL;
 133     jlong objTag = (reachable ? tag : -tag);
 134 
 135     if (count &lt;= 0)
 136         return NSK_TRUE;
 137 
 138     count--;
 139     tag++;
 140 
 141     if (!NSK_JNI_VERIFY(jni, (obj = jni-&gt;GetObjectField(firstObject, firstField)) != NULL)) {
 142         nsk_jvmti_setFailStatus();
 143         return NSK_FALSE;
 144     }
 145 
 146     objectDescList[count].tag = objTag;
 147 
 148     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(obj, objTag))) {
 149         nsk_jvmti_setFailStatus();
 150     }
 151     printf(&quot;        tag=%-5ld object=0x%p\n&quot;, (long)objTag, (void*)obj);
 152     fflush(0);
 153     if (!getChainObjects(jvmti, jni, obj, nextField, nextFieldName,
 154                                 nextField, nextFieldName,
 155                                 count, objectDescList, tag, reachable)) {
 156         return NSK_FALSE;
 157     }
 158 
 159     NSK_TRACE(jni-&gt;DeleteLocalRef(obj));
 160     return NSK_TRUE;
 161 }
 162 
 163 /** Obtain all tested objects from debugee class and tag them recursively. */
 164 static int getTestedObjects(jvmtiEnv* jvmti, JNIEnv* jni, int chainLength,
 165                             int *objectsCount, ObjectDesc* *objectDescList,
 166                             jobject* rootObject) {
 167     jclass debugeeClass = NULL;
 168     jclass rootObjectClass = NULL;
 169     jclass chainObjectClass = NULL;
 170 
 171     jfieldID objectField = NULL;
 172     jfieldID reachableChainField = NULL;
 173     jfieldID unreachableChainField = NULL;
 174     jfieldID tailField = NULL;
 175 
 176     *objectsCount = 1 + 2 * chainLength;
 177 
 178     printf(&quot;Allocate memory for objects list: %d objects\n&quot;, *objectsCount);
 179     fflush(0);
 180     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Allocate((*objectsCount * sizeof(ObjectDesc)),
 181                                           (unsigned char**)objectDescList))) {
 182         nsk_jvmti_setFailStatus();
 183         return NSK_FALSE;
 184     }
 185     printf(&quot;  ... allocated array: 0x%p\n&quot;, (void*)objectDescList);
 186     fflush(0);
 187 
 188     {
 189         int k;
 190         for (k = 0; k &lt; *objectsCount; k++) {
 191             (*objectDescList)[k].tag = 0;
 192             (*objectDescList)[k].exp_class_tag = chainClassTag;
 193             (*objectDescList)[k].exp_found = 0;
 194             (*objectDescList)[k].found = 0;
 195         }
 196     }
 197     (*objectDescList)[0].exp_class_tag = rootClassTag;
 198 
 199     printf(&quot;Find debugee class: %s\n&quot;, DEBUGEE_CLASS_NAME);
 200     fflush(0);
 201     if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni-&gt;FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {
 202         nsk_jvmti_setFailStatus();
 203         return NSK_FALSE;
 204     }
 205     printf(&quot;  ... found class: 0x%p\n&quot;, (void*)debugeeClass);
 206 
 207     printf(&quot;Find root object class: %s\n&quot;, ROOT_OBJECT_CLASS_NAME);
 208     fflush(0);
 209     if (!NSK_JNI_VERIFY(jni, (rootObjectClass = jni-&gt;FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {
 210         nsk_jvmti_setFailStatus();
 211         return NSK_FALSE;
 212     }
 213     printf(&quot;  ... found class: 0x%p\n&quot;, (void*)rootObjectClass);
 214 
 215     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(rootObjectClass, rootClassTag))) {
 216         nsk_jvmti_setFailStatus();
 217     }
 218     printf(&quot;        tag=%-5ld rootClass=0x%p\n&quot;,
 219            (long)rootClassTag, (void*)rootObjectClass);
 220 
 221     printf(&quot;Find chain object class: %s\n&quot;, CHAIN_OBJECT_CLASS_NAME);
 222     fflush(0);
 223     if (!NSK_JNI_VERIFY(jni, (chainObjectClass =
 224             jni-&gt;FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {
 225         nsk_jvmti_setFailStatus();
 226         return NSK_FALSE;
 227     }
 228     printf(&quot;  ... found class: 0x%p\n&quot;,
 229            (void*)chainObjectClass);
 230 
 231     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(chainObjectClass, chainClassTag))) {
 232         nsk_jvmti_setFailStatus();
 233     }
 234     printf(&quot;        tag=%-5ld chainClass=0x%p\n&quot;,
 235            (long)chainClassTag, (void*)chainObjectClass);
 236 
 237     printf(&quot;Find static field in debugee class: %s\n&quot;, OBJECT_FIELD_NAME);
 238     fflush(0);
 239     if (!NSK_JNI_VERIFY(jni, (objectField =
 240             jni-&gt;GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {
 241         nsk_jvmti_setFailStatus();
 242         return NSK_FALSE;
 243     }
 244     printf(&quot;  ... got fieldID: 0x%p\n&quot;, (void*)objectField);
 245 
 246     printf(&quot;Find instance field in root object class: %s\n&quot;, REACHABLE_CHAIN_FIELD_NAME);
 247     fflush(0);
 248     if (!NSK_JNI_VERIFY(jni, (reachableChainField =
 249             jni-&gt;GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {
 250         nsk_jvmti_setFailStatus();
 251         return NSK_FALSE;
 252     }
 253     printf(&quot;  ... got fieldID: 0x%p\n&quot;, (void*)reachableChainField);
 254 
 255     printf(&quot;Find instance field in root object class: %s\n&quot;, UNREACHABLE_CHAIN_FIELD_NAME);
 256     fflush(0);
 257     if (!NSK_JNI_VERIFY(jni, (unreachableChainField =
 258             jni-&gt;GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {
 259         nsk_jvmti_setFailStatus();
 260         return NSK_FALSE;
 261     }
 262     printf(&quot;  ... got fieldID: 0x%p\n&quot;, (void*)unreachableChainField);
 263 
 264     printf(&quot;Find instance field in chain object class: %s\n&quot;, TAIL_FIELD_NAME);
 265     fflush(0);
 266     if (!NSK_JNI_VERIFY(jni, (tailField =
 267             jni-&gt;GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {
 268         nsk_jvmti_setFailStatus();
 269         return NSK_FALSE;
 270     }
 271     printf(&quot;  ... got fieldID: 0x%p\n&quot;, (void*)tailField);
 272 
 273     printf(&quot;Get root object from static field: %s\n&quot;, OBJECT_FIELD_NAME);
 274     fflush(0);
 275     if (!NSK_JNI_VERIFY(jni, (*rootObject =
 276             jni-&gt;GetStaticObjectField(debugeeClass, objectField)) != NULL)) {
 277         nsk_jvmti_setFailStatus();
 278         return NSK_FALSE;
 279     }
 280     printf(&quot;  ... got object: 0x%p\n&quot;, (void*)*rootObject);
 281     fflush(0);
 282 
 283     if (!NSK_JNI_VERIFY(jni, (*rootObject = jni-&gt;NewGlobalRef(*rootObject)) != NULL)) {
 284         nsk_jvmti_setFailStatus();
 285         return NSK_FALSE;
 286     }
 287     printf(&quot;  ... global ref: 0x%p\n&quot;, (void*)*rootObject);
 288 
 289     printf(&quot;Obtain and tag chain objects:\n&quot;);
 290 
 291     printf(&quot;    root tested object\n&quot;);
 292     fflush(0);
 293     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(*rootObject, rootObjectTag))) {
 294         nsk_jvmti_setFailStatus();
 295     }
 296     printf(&quot;        tag=%-5ld object=0x%p\n&quot;,
 297            (long)rootObjectTag, (void*)*rootObject);
 298 
 299     /* Root object must be reported 1 time */
 300     (*objectDescList)[0].exp_found = 1;
 301     (*objectDescList)[0].tag = rootObjectTag;
 302 
 303     printf(&quot;    reachable objects chain: %d objects\n&quot;, chainLength);
 304     fflush(0);
 305     if (!getChainObjects(jvmti, jni, *rootObject,
 306                                 reachableChainField, REACHABLE_CHAIN_FIELD_NAME,
 307                                 tailField, TAIL_FIELD_NAME,
 308                                 chainLength, (*objectDescList) + 1,
 309                                 chainObjectTag, NSK_TRUE)) {
 310         nsk_jvmti_setFailStatus();
 311         return NSK_FALSE;
 312     }
 313 
 314     /* First unreachable object must be reported once
 315      * as JVMTI_HEAP_REFERENCE_STACK_LOCAL */
 316     (*objectDescList)[2 * chainLength].exp_found = 1;
 317 
 318     printf(&quot;    unreachable objects chain: %d objects\n&quot;, chainLength);
 319     if (!getChainObjects(jvmti, jni, *rootObject,
 320                                 unreachableChainField, UNREACHABLE_CHAIN_FIELD_NAME,
 321                                 tailField, TAIL_FIELD_NAME,
 322                                 chainLength, (*objectDescList) + 1 + chainLength,
 323                                 chainObjectTag, NSK_FALSE)) {
 324         nsk_jvmti_setFailStatus();
 325         return NSK_FALSE;
 326     }
 327 
 328     return NSK_TRUE;
 329 }
 330 
 331 /** Check if tagged objects were iterated. */
 332 static int checkTestedObjects(jvmtiEnv* jvmti, JNIEnv* jni,
 333                               int chainLength, ObjectDesc objectDescList[]) {
 334     int success = NSK_TRUE;
 335     int i, idx;
 336 
 337     printf(&quot;Following tagged objects were iterated:\n&quot;);
 338 
 339     printf(&quot;Root tested object:\n&quot;);
 340     printf(&quot;   tag:                 %ld\n&quot;
 341            &quot;   expected to iterate: %d times\n&quot;
 342            &quot;   iterated:            %d times\n&quot;,
 343            (long) objectDescList[0].tag,
 344                   objectDescList[0].exp_found,
 345                   objectDescList[0].found);
 346     if (objectDescList[0].found != objectDescList[0].exp_found) {
 347         NSK_COMPLAIN1(&quot;Root tested object unexpectedly iterated %d times\n&quot;,
 348                       objectDescList[0].found);
 349         nsk_jvmti_setFailStatus();
 350     }
 351 
 352     printf(&quot;\nReachable objects:\n&quot;);
 353     fflush(0);
 354     for (i = 0; i &lt; chainLength; i++) {
 355         idx = i + 1;
 356         printf(&quot;Reachable object:\n&quot;
 357                &quot;   tag:                 %-3ld\n&quot;
 358                &quot;   expected to iterate: %d times\n&quot;
 359                &quot;   iterated:            %d times\n&quot;,
 360                 (long) objectDescList[idx].tag,
 361                        objectDescList[idx].exp_found,
 362                        objectDescList[idx].found);
 363         if (objectDescList[i + 1].found &lt;= 0 &amp;&amp; objectDescList[i + 1].exp_found &gt; 0) {
 364             NSK_COMPLAIN0(&quot;Reachable object was not iterated\n&quot;);
 365             nsk_jvmti_setFailStatus();
 366         }
 367         if (objectDescList[idx].found != objectDescList[idx].exp_found) {
 368             NSK_COMPLAIN0(&quot;Reachable object was iterated unexpected number of times\n&quot;);
 369             nsk_jvmti_setFailStatus();
 370         }
 371     }
 372 
 373     printf(&quot;\nUnreachable objects:\n&quot;);
 374     for (i = 0; i &lt; chainLength; i++) {
 375         idx = i + 1 + chainLength;
 376 
 377         printf(&quot;Unreachable object:\n&quot;
 378                &quot;   tag:                 %ld\n&quot;
 379                &quot;   expected to iterate: %d times\n&quot;
 380                &quot;   iterated:            %d times\n&quot;,
 381                 (long) objectDescList[idx].tag,
 382                        objectDescList[idx].exp_found,
 383                        objectDescList[idx].found);
 384         if (objectDescList[idx].found &gt; 0 &amp;&amp; objectDescList[idx].exp_found == 0) {
 385             NSK_COMPLAIN0(&quot;Unreachable object was iterated\n&quot;);
 386             nsk_jvmti_setFailStatus();
 387         }
 388         fflush(0);
 389     }
 390 
 391     return NSK_TRUE;
 392 }
 393 
 394 /** Release references to the tested objects and free allocated memory. */
 395 static int releaseTestedObjects(jvmtiEnv* jvmti, JNIEnv* jni, int chainLength,
 396                                 ObjectDesc* objectDescList, jobject rootObject) {
 397     if (rootObject != NULL) {
 398         printf(&quot;Release object reference to root tested object: 0x%p\n&quot;, rootObject);
 399         NSK_TRACE(jni-&gt;DeleteGlobalRef(rootObject));
 400     }
 401 
 402     if (objectDescList != NULL) {
 403         printf(&quot;Deallocate objects list: 0x%p\n&quot;, (void*)objectDescList);
 404         if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)objectDescList))) {
 405             nsk_jvmti_setFailStatus();
 406         }
 407     }
 408 
 409     fflush(0);
 410     return NSK_TRUE;
 411 }
 412 
 413 /* ============================================================================= */
 414 
 415 /* Some diagnostics happen in the first FollowReferences call only */
 416 static int first_followref = 1;
 417 
 418 typedef struct ThreadDescStruct {
 419     jlong tag;
 420     jlong id;
 421 } ThreadDesc;
 422 
 423 #define MAX_THREADS 1024
 424 static ThreadDesc thrDesc [MAX_THREADS] = {};
 425 
 426 static jlong registerThread(jlong thr_id, jlong thr_tag) {
 427     if (thr_id &lt;= 0 || thr_id &gt;= MAX_THREADS) {
 428         NSK_COMPLAIN1(&quot;Unexpected thread ID: %ld\n&quot;, thr_id);
 429         nsk_jvmti_setFailStatus();
 430         return 0;
 431     }
 432     if (thrDesc[thr_id].id == 0) {
 433         /* need to set the first occurence info */
 434         thrDesc[thr_id].id  = thr_id;
 435         thrDesc[thr_id].tag = thr_tag;
 436     } else if (thr_tag != thrDesc[thr_id].tag) {
 437         NSK_COMPLAIN3(&quot;Thread tag doesn&#39;t match the first occurence: thr_id= %ld\n&quot;
 438                &quot;\t first thr_tag=%#lx, curr thr_tag=%#lx\n&quot;,
 439                thr_id, thrDesc[thr_id].tag, thr_tag);
 440         nsk_jvmti_setFailStatus();
 441         return 0;
 442     }
 443     return thr_id;
 444 } /* registerThread */
 445 
 446 typedef struct FrameDescStruct {
 447     jlong     thr_id;
 448     jint      depth;
 449     jmethodID method;
 450 } FrameDesc;
 451 
 452 #define MAX_FRAMES  256
 453 static FrameDesc frameDesc[MAX_FRAMES] = {};
 454 static int curr_frame_id = 0;  /* Index 0 should not be used */
 455 
 456 /* returns frame slot number in the table of frames */
 457 static int registerFrame(jlong thr_id, jint depth, jmethodID method,
 458                          jvmtiHeapReferenceKind ref_kind)
 459 {
 460     int idx;
 461     int failed = 0;
 462 
 463     FrameDesc *fr;
 464     if (depth &lt; 0 || depth &gt; MAXDEPTH) {
 465         NSK_COMPLAIN1(&quot;Incorrect frame depth: %ld\n&quot;, depth);
 466         failed = 1;
 467     }
 468     /* JNI_LOCAL references from native methods may not have a jmethodID.
 469      * (Do we have to clarify this in the JVMTI spec?)
 470      * Do not consider the test as failing in such a case.
 471      */
 472     if (method == NULL &amp;&amp; ref_kind != JVMTI_HEAP_REFERENCE_JNI_LOCAL) {
 473         NSK_COMPLAIN0(&quot;methodID must not be NULL\n&quot;);
 474         failed = 1;
 475     }
 476     if (failed) {
 477         nsk_jvmti_setFailStatus();
 478         return 0;
 479     }
 480 
 481     /* Check if this frame was registered */
 482     for (idx = 1; idx &lt;= curr_frame_id; idx++) {
 483         fr = &amp;frameDesc[idx];
 484         if (fr-&gt;thr_id == thr_id &amp;&amp; fr-&gt;depth == depth &amp;&amp; fr-&gt;method == method) {
 485             return idx;
 486         }
 487     }
 488     if (++curr_frame_id &gt;= MAX_FRAMES) {
 489         NSK_COMPLAIN1(&quot;Internal: Insufficient frames table size: %ld\n&quot;, MAX_FRAMES);
 490         return 0;
 491     }
 492     fr = &amp;frameDesc[curr_frame_id];
 493     fr-&gt;thr_id = thr_id;
 494     fr-&gt;depth  = depth;
 495     fr-&gt;method = method;
 496 
 497     return curr_frame_id;
 498 } /* registerFrame */
 499 
 500 
 501 typedef struct LocalDescStruct {
 502     jint      frame_id;
 503     jlocation location;
 504     jint      slot;
 505     jlong     tag;
 506 } LocalDesc;
 507 
 508 #define MAX_LOCALS   100
 509 static LocalDesc locDesc [MAX_LOCALS] = {};
 510 static int curr_local_idx = 0;  /* Index 0 should not be used */
 511 
 512 /* returns frame slot number in the table of frames */
 513 static int registerLocal(jint frame_id, jlocation location, jint slot, jlong tag) {
 514     int idx;
 515     LocalDesc *loc;
 516     int failed = 0;
 517 
 518     if (slot &lt; 0 || slot &gt; MAXSLOT) {
 519         NSK_COMPLAIN1(&quot;Incorrect stack local slot#: %ld\n&quot;, slot);
 520         failed = 1;
 521     }
 522     if ((jlong) location == -1L) {
 523         NSK_COMPLAIN0(&quot;Location must not be -1\n&quot;);
 524         failed = 1;
 525     }
 526 
 527     if (failed) {
 528         nsk_jvmti_setFailStatus();
 529         return 0;
 530     }
 531 
 532     /* Check if this local was registered */
 533     for (idx = 1; idx &lt;= curr_local_idx; idx++) {
 534         loc = &amp;locDesc[idx];
 535         if (loc-&gt;frame_id == frame_id &amp;&amp;
 536             loc-&gt;slot == slot) {
 537             if (first_followref) {
 538                 /* Do this check on the first FollowReferences call only */
 539                 FrameDesc *fr = &amp;frameDesc[frame_id];
 540                 printf(&quot;Second report of the local: &quot;
 541                        &quot;loc_idx=%d, frame_id=%d, slot=%d\n&quot;,
 542                        idx, frame_id, slot);
 543                 printf(&quot;\t thr_id=%&quot; LL &quot;d, depth=%d, meth=0x%p\n&quot;,
 544                        fr-&gt;thr_id, fr-&gt;depth, fr-&gt;method);
 545                 failed = 1;
 546             }
 547             if (loc-&gt;tag != tag) {
 548                 NSK_COMPLAIN2(&quot;Tag mismatch:      expected %#lx, passed: %#lx\n&quot;,
 549                                loc-&gt;tag, tag);
 550                 failed = 1;
 551             }
 552             if (loc-&gt;location != location) {
 553                 NSK_COMPLAIN2(&quot;Location mismatch: expected %ld, passed: %ld\n&quot;,
 554                                (long) loc-&gt;location, (long) location);
 555                 failed = 1;
 556             }
 557             if (failed) {
 558                 nsk_jvmti_setFailStatus();
 559                 return 0;
 560             }
 561             return idx;
 562         }
 563     }
 564     if (++curr_local_idx &gt;= MAX_LOCALS) {
 565         printf(&quot;Internal: Insufficient locals table size: %d\n&quot;, MAX_FRAMES);
 566         return 0;
 567     }
 568     loc = &amp;locDesc[curr_local_idx];
 569     loc-&gt;frame_id = frame_id;
 570     loc-&gt;location = location;
 571     loc-&gt;slot     = slot;
 572     loc-&gt;tag      = tag;
 573 
 574     return curr_local_idx;
 575 } /* registerLocal */
 576 
 577 
 578 /** heapReferenceCallback for heap iterator. */
 579 jint JNICALL heapReferenceCallback(
 580      jvmtiHeapReferenceKind        ref_kind,
 581      const jvmtiHeapReferenceInfo* reference_info,
 582      jlong                         class_tag,
 583      jlong                         referrer_class_tag,
 584      jlong                         size,
 585      jlong*                        tag_ptr,
 586      jlong*                        referrer_tag_ptr,
 587      jint                          length,
 588      void*                         user_data)
 589 {
 590     jint depth         = -1;
 591     jint slot          = -1;
 592     jint index         = -1;
 593     jmethodID method   = (jmethodID) NULL;
 594     jlocation location = (jlocation)(-1);
 595     jlong tag          = DEREF(tag_ptr);
 596     jlong ref_tag      = DEREF(referrer_tag_ptr);
 597     jlong thr_tag      = -1;
 598     jlong thr_id       = -1;
 599     jlong thr_idx      = -1;
 600     int res            = -1;
 601     int meth_idx       = -1;
 602 
 603     switch (ref_kind) {
 604         case JVMTI_HEAP_REFERENCE_CONSTANT_POOL:
 605             index = reference_info-&gt;constant_pool.index;
 606             break;
 607         case JVMTI_HEAP_REFERENCE_FIELD:
 608         case JVMTI_HEAP_REFERENCE_STATIC_FIELD:
 609             index = reference_info-&gt;field.index;
 610             break;
 611         case JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT:
 612             index = reference_info-&gt;array.index;
 613             break;
 614         case JVMTI_HEAP_REFERENCE_STACK_LOCAL:
 615             thr_tag  = reference_info-&gt;stack_local.thread_tag;
 616             thr_id   = reference_info-&gt;stack_local.thread_id;
 617             depth    = reference_info-&gt;stack_local.depth;
 618             method   = reference_info-&gt;stack_local.method;
 619             location = reference_info-&gt;stack_local.location;
 620             slot     = reference_info-&gt;stack_local.slot;
 621             index    = slot | depth &lt;&lt; 16;
 622             break;
 623         case JVMTI_HEAP_REFERENCE_JNI_LOCAL:
 624             thr_tag  = reference_info-&gt;jni_local.thread_tag;
 625             thr_id   = reference_info-&gt;jni_local.thread_id;
 626             depth    = reference_info-&gt;jni_local.depth;
 627             method   = reference_info-&gt;jni_local.method;
 628             index    = depth;
 629             break;
 630         default:
 631             // TODO: check that realy should be done w/ other jvmtiHeapReferenceKind
 632             break;
 633     }
 634 
 635     if (ref_kind == JVMTI_HEAP_REFERENCE_OTHER      ||
 636         ref_kind == JVMTI_HEAP_REFERENCE_JNI_GLOBAL ||
 637         ref_kind == JVMTI_HEAP_REFERENCE_SYSTEM_CLASS) {
 638         return 0; /* Skip it as there is a plan to test it differently */
 639     }
 640 
 641     if (ref_kind == JVMTI_HEAP_REFERENCE_THREAD) {
 642         /* Target thread has been tagged already */
 643         if (tag == 0) {
 644             tag = *tag_ptr = thrObjectTag++;
 645             /* Just want to report new tag for thread object */
 646             printf(&quot;     heapReferenceCallback: ref=%s, tag=%-3ld, size=%-3ld\n&quot;,
 647                    ref_kind_str[ref_kind],
 648                    (long) *tag_ptr,
 649                    (long) size);
 650         }
 651 
 652         fflush(0);
 653         return 0;
 654     }
 655 
 656     printf(&quot;     heapReferenceCallback: ref=%s, class_tag=%-3ld, tag=%-3ld,&quot;
 657            &quot; size=%-3ld, len=%-2d\n&quot;
 658            &quot;\t\t ref_tag=%-&quot; LL &quot;d, thr_tag=%-3ld, thr_id=%&quot; LL &quot;d, &quot;
 659            &quot;meth=0x%p, loc=%ld, idx=%#x\n&quot;,
 660            ref_kind_str[ref_kind],
 661            (long) class_tag,
 662            (long) tag,
 663            (long) size,
 664            (int) length,
 665            ref_tag,
 666            (long) thr_tag,
 667            thr_id,
 668            method,
 669            (long) location,
 670            (int) index);
 671     fflush(0);
 672 
 673     if (tag_ptr == NULL) {
 674         NSK_COMPLAIN1(&quot;NULL tag_ptr is passed to heapReferenceCallback:&quot;
 675                       &quot; tag_ptr=0x%p\n&quot;, (void*)tag_ptr);
 676         nsk_jvmti_setFailStatus();
 677     }
 678 
 679     if (tag_ptr != NULL &amp;&amp; tag != 0) {
 680         int found = 0;
 681         int i;
 682 
 683         for (i = 0; i &lt; objectsCount; i++) {
 684             if (*tag_ptr == objectDescList[i].tag) {
 685                 found++;
 686                 objectDescList[i].found++;
 687 
 688                 if (*tag_ptr &lt; 0 &amp;&amp; *tag_ptr != -chainObjectTag &amp;&amp;
 689                     ref_kind != JVMTI_HEAP_REFERENCE_STACK_LOCAL)
 690                 {
 691                     NSK_COMPLAIN0(&quot;Unreachable tagged object is &quot;
 692                                   &quot;passed to heapReferenceCallback\n&quot;);
 693                     nsk_jvmti_setFailStatus();
 694                     break;
 695                 }
 696                 break;
 697             }
 698         }
 699 
 700         if (ref_kind != JVMTI_HEAP_REFERENCE_CLASS &amp;&amp;
 701             ref_kind != JVMTI_HEAP_REFERENCE_JNI_LOCAL &amp;&amp; found &lt;= 0 &amp;&amp;
 702             tag &lt; FIRST_THREAD_TAG &amp;&amp; tag &gt; (thrObjectTag - 1))
 703         {
 704             NSK_COMPLAIN0(&quot;Unknown tagged object is passed &quot;
 705                           &quot;to heapReferenceCallback\n&quot;);
 706             nsk_jvmti_setFailStatus();
 707         }
 708     }
 709 
 710     if (user_data != &amp;fakeUserData &amp;&amp; !userDataError) {
 711        NSK_COMPLAIN2(&quot;Unexpected user_data is passed &quot;
 712                      &quot;to heapReferenceCallback:\n&quot;
 713                       &quot;   expected:       0x%p\n&quot;
 714                       &quot;   actual:         0x%p\n&quot;,
 715                       user_data,
 716                       &amp;fakeUserData);
 717         nsk_jvmti_setFailStatus();
 718         userDataError++;
 719     }
 720 
 721     switch (ref_kind) {
 722         case JVMTI_HEAP_REFERENCE_CLASS: {
 723             int i;
 724             if (tag == 0) {
 725                 return 0;
 726             }
 727             if (tag != rootClassTag &amp;&amp; tag != chainClassTag) {
 728                 NSK_COMPLAIN0(&quot;Unknown tagged class is passed &quot;
 729                               &quot;to heapReferenceCallback\n&quot;);
 730                 nsk_jvmti_setFailStatus();
 731                 break;
 732             }
 733             for (i = 0; i &lt; objectsCount; i++) {
 734                if (ref_tag == objectDescList[i].tag) {
 735                    if (objectDescList[i].exp_class_tag != tag) {
 736                        NSK_COMPLAIN2(&quot;Wrong tag in heapReferenceCallback&quot;
 737                                      &quot;/JVMTI_HEAP_REFERENCE_CLASS:\n&quot;
 738                                      &quot;Expected: %-3ld\n&quot;
 739                                      &quot;Passed:   %-3ld\n&quot;,
 740                                       objectDescList[i].exp_class_tag,
 741                                       tag);
 742                        nsk_jvmti_setFailStatus();
 743                    }
 744                    break;
 745                }
 746             }
 747             break;
 748         }
 749 
 750         case JVMTI_HEAP_REFERENCE_STATIC_FIELD:
 751             if (tag != rootObjectTag || class_tag != rootClassTag) {
 752                  NSK_COMPLAIN1(&quot;This reference kind was not expected: %s\n&quot;,
 753                                ref_kind_str[ref_kind]);
 754                  fflush(0);
 755                  nsk_jvmti_setFailStatus();
 756             }
 757             break;
 758 
 759         case JVMTI_HEAP_REFERENCE_STACK_LOCAL:
 760             // Skip local references from non-main (e.g. compiler) threads.
 761             if (thr_tag == TARG_THREAD_TAG) {
 762                 thr_idx  = registerThread(thr_id, thr_tag);
 763                 meth_idx = registerFrame(thr_id, depth, method, ref_kind);
 764                 if (meth_idx &gt; 0) {
 765                     jint loc_idx  = registerLocal(meth_idx, location, slot, tag);
 766                 }
 767             }
 768             /* This part is kind of hack. It has some expectations about stack layout */
 769             if (thr_tag == TARG_THREAD_TAG &amp;&amp;
 770                 reference_info-&gt;stack_local.depth == TARG_FRAME_DEPTH) {
 771                if (length != -1) {
 772                    jint exp_len = length;
 773 
 774                    if (reference_info-&gt;stack_local.slot == ARGV_STRING_ARR_SLOT) {
 775                        exp_len = 0;
 776                    }
 777                    else if (reference_info-&gt;stack_local.slot &gt;= FIRST_PRIM_ARR_SLOT &amp;&amp;
 778                             reference_info-&gt;stack_local.slot &lt;= LAST_PRIM_ARR_SLOT) {
 779                        exp_len = 2;
 780                    }
 781                    else if (reference_info-&gt;stack_local.slot == DUMMY_STRING_ARR_SLOT) {
 782                        exp_len = 3;
 783                    }
 784                    if (length != exp_len) {
 785                        NSK_COMPLAIN2(&quot;Wrong length of the local array:&quot;
 786                                      &quot; expected: %-d, found: %-d\n\n&quot;, exp_len, length);
 787                    }
 788                 } else { /* length == -1 */
 789                     if ((reference_info-&gt;stack_local.slot &gt;= FIRST_PRIM_ARR_SLOT &amp;&amp;
 790                          reference_info-&gt;stack_local.slot &lt;= DUMMY_STRING_ARR_SLOT) ||
 791                          reference_info-&gt;stack_local.slot == ARGV_STRING_ARR_SLOT) {
 792                        NSK_COMPLAIN0(&quot;Length of array must not be -1\n&quot;);
 793                     }
 794                 }
 795                if (length == 0
 796                     &amp;&amp; reference_info-&gt;stack_local.slot != ARGV_STRING_ARR_SLOT
 797                     &amp;&amp; reference_info-&gt;stack_local.slot &lt; FIRST_PRIM_ARR_SLOT
 798                     &amp;&amp; reference_info-&gt;stack_local.slot &gt; DUMMY_STRING_ARR_SLOT) {
 799                    NSK_COMPLAIN1(&quot;Wrong length of the local variable:&quot;
 800                                  &quot; expected: -1, found: %-d\n\n&quot;, length);
 801                    nsk_jvmti_setFailStatus();
 802                }
 803             }
 804             break;
 805         case JVMTI_HEAP_REFERENCE_JNI_LOCAL:
 806             // Skip JNI local references from non-main (e.g. compiler) threads.
 807             if (thr_tag == TARG_THREAD_TAG) {
 808                 thr_idx  = registerThread(thr_id, thr_tag);
 809                 meth_idx = registerFrame(thr_id, depth, method, ref_kind);
 810             }
 811             break;
 812 
<a name="1" id="anc1"></a><span class="line-modified"> 813         case JVMTI_REFERENCE_ARRAY_ELEMENT:</span>
 814         case JVMTI_HEAP_REFERENCE_JNI_GLOBAL:
 815         case JVMTI_HEAP_REFERENCE_SYSTEM_CLASS:
 816         case JVMTI_HEAP_REFERENCE_MONITOR:
 817         case JVMTI_HEAP_REFERENCE_OTHER:
 818             /* These reference kinds are expected */
 819             break;
 820 
 821         default: {
 822             NSK_COMPLAIN1(&quot;This reference kind was not expected: %s\n\n&quot;,
 823                            ref_kind_str[ref_kind]);
 824             fflush(0);
 825             nsk_jvmti_setFailStatus();
 826             break;
 827         }
 828     }
 829     return 0;
 830 }
 831 
 832 jint JNICALL primitiveFieldCallback
 833     (jvmtiHeapReferenceKind        ref_kind,
 834      const jvmtiHeapReferenceInfo* reference_info,
 835      jlong                         class_tag,
 836      jlong*                        tag_ptr,
 837      jvalue                        value,
 838      jvmtiPrimitiveType            value_type,
 839      void*                         user_data)
 840 {
 841     printf(&quot; primitiveFieldCallback: ref=%s, class_tag=%-3ld, tag=%-3ld, type=%c\n&quot;,
 842            ref_kind_str[ref_kind],
 843            (long) class_tag,
 844            (long) DEREF(tag_ptr),
 845            (int) value_type);
 846     fflush(0);
 847     return 0;
 848 }
 849 
 850 jint JNICALL arrayPrimitiveValueCallback
 851     (jlong class_tag, jlong size, jlong* tag_ptr, jint element_count,
 852      jvmtiPrimitiveType element_type, const void* elements, void* user_data)
 853 {
 854     printf(&quot; arrayPrimitiveValueCallback: class_tag=%-3ld, tag=%-3ld, len=%d, type=%c\n&quot;,
 855            (long) class_tag,
 856            (long) DEREF(tag_ptr),
 857            (int) element_count,
 858            (int) element_type);
 859     fflush(0);
 860     return 0;
 861 }
 862 
 863 jint JNICALL stringPrimitiveValueCallback
 864     (jlong class_tag, jlong size, jlong* tag_ptr, const jchar* value,
 865      jint value_length, void* user_data)
 866 {
 867     printf(&quot;stringPrimitiveValueCallback: class_tag=%-3ld, tag=%-3ld, len=%d\n&quot;,
 868            (long) class_tag,
 869            (long) DEREF(tag_ptr),
 870            (int) value_length);
 871     fflush(0);
 872     return 0;
 873 }
 874 
 875 
 876 /* ============================================================================= */
 877 static jthread getTargetThread(jvmtiEnv *jvmti) {
 878     static const char *target_thread_name = &quot;main&quot;;
 879     jint i;
 880     jint thread_count = -1;
 881     jthread *threads = NULL;
 882 
 883     jvmti-&gt;GetAllThreads(&amp;thread_count, &amp;threads);
 884 
 885     for (i = 0; i &lt; thread_count; i++) {
 886         jvmtiThreadInfo thread_info;
 887         jvmti-&gt;GetThreadInfo(threads[i], &amp;thread_info);
 888 
 889         if (strcmp(thread_info.name, target_thread_name) == 0) {
 890             return threads[i];
 891         }
 892     }
 893 
 894     return NULL;
 895 }
 896 
 897 static jvmtiError setTagForTargetThread(jvmtiEnv *jvmti, jlong tag) {
 898     jthread target_thread = getTargetThread(jvmti);
 899     return jvmti-&gt;SetTag(target_thread, tag);
 900 }
 901 
 902 /** Agent algorithm. */
 903 static void JNICALL
 904 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
 905     jobject rootObject = NULL;
 906 
 907     printf(&quot;Wait for tested objects created\n&quot;);
 908     fflush(0);
 909     if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout))) {
 910         return;
 911     }
 912 
 913     printf(&quot;&gt;&gt;&gt; Obtain and tag tested objects from debugee class\n&quot;);
 914     fflush(0);
 915     {
 916         if (!NSK_VERIFY(getTestedObjects(jvmti, jni, chainLength, &amp;objectsCount,
 917                                          &amp;objectDescList, &amp;rootObject))) {
 918             return;
 919         }
 920     }
 921 
 922     printf(&quot;&gt;&gt;&gt; Let debugee to clean links to unreachable objects\n&quot;);
 923     fflush(0);
 924     {
 925         if (!NSK_VERIFY(nsk_jvmti_resumeSync())) {
 926             return;
 927         }
 928         if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout))) {
 929             return;
 930         }
 931     }
 932 
 933     if (!NSK_JVMTI_VERIFY(setTagForTargetThread(jvmti, TARG_THREAD_TAG))) {
 934         nsk_jvmti_setFailStatus();
 935         return;
 936     }
 937 
 938     printf(&quot;\n\n&gt;&gt;&gt; Start 1-st iteration starting from the heap root\n&quot;);
 939     fflush(0);
 940     {
 941         if (!NSK_JVMTI_VERIFY(jvmti-&gt;FollowReferences((jint)   0,     /* heap_filter    */
 942                                                       (jclass)  NULL, /* class          */
 943                                                       (jobject) NULL, /* initial_object */
 944                                                       &amp;heapCallbacks,
 945                                                       (const void *) &amp;fakeUserData))) {
 946              nsk_jvmti_setFailStatus();
 947              return;
 948         }
 949     }
 950 
 951     printf(&quot;&gt;&gt;&gt; Check if reachable objects were iterated\n&quot;);
 952     fflush(0);
 953     {
 954         if (!checkTestedObjects(jvmti, jni, chainLength, objectDescList)) {
 955             nsk_jvmti_setFailStatus();
 956         }
 957     }
 958 
 959     {            /* Reinstall the expectations */
 960         int k;
 961         for (k = 0; k &lt; objectsCount; k++) {
 962             (objectDescList)[k].exp_found = 0;
 963             (objectDescList)[k].found = 0;
 964         }
 965         /* Heap root object must be reported 2 times */
 966         objectDescList[0].exp_found = 2;
 967 
 968         /* First unreachable object must be reported once
 969          * as JVMTI_HEAP_REFERENCE_STACK_LOCAL */
 970         objectDescList[2 * chainLength].exp_found = 1;
 971     }
 972 
 973     printf(&quot;\n\n&gt;&gt;&gt; Start 2-nd iteration starting from the heap root\n&quot;);
 974     fflush(0);
 975     first_followref = 0;
 976     {
 977         jint heap_filter = JVMTI_HEAP_FILTER_UNTAGGED
 978                          | JVMTI_HEAP_FILTER_CLASS_UNTAGGED;
 979         if (!NSK_JVMTI_VERIFY(jvmti-&gt;FollowReferences(heap_filter,
 980                                                       (jclass)  NULL, /* class          */
 981                                                       (jobject) NULL, /* initial_object */
 982                                                       &amp;heapCallbacks,
 983                                                       (const void *) &amp;fakeUserData))) {
 984              nsk_jvmti_setFailStatus();
 985              return;
 986         }
 987     }
 988 
 989     printf(&quot;&gt;&gt;&gt; Check that both reachable and unreachable &quot;
 990            &quot;objects were not iterated\n&quot;);
 991     fflush(0);
 992     {
 993         if (!checkTestedObjects(jvmti, jni, chainLength, objectDescList)) {
 994             nsk_jvmti_setFailStatus();
 995         }
 996     }
 997 
 998 
 999     printf(&quot;&gt;&gt;&gt; Clean used data\n&quot;);
1000     fflush(0);
1001     {
1002         if (!NSK_VERIFY(releaseTestedObjects(jvmti, jni, chainLength,
1003                         objectDescList, rootObject))) {
1004             return;
1005         }
1006     }
1007 
1008     printf(&quot;Let debugee to finish\n&quot;);
1009     fflush(0);
1010     if (!NSK_VERIFY(nsk_jvmti_resumeSync()))
1011         return;
1012 }
1013 
1014 /* ============================================================================= */
1015 
1016 /** Agent library initialization. */
1017 #ifdef STATIC_BUILD
1018 JNIEXPORT jint JNICALL Agent_OnLoad_followref003(JavaVM *jvm, char *options, void *reserved) {
1019     return Agent_Initialize(jvm, options, reserved);
1020 }
1021 JNIEXPORT jint JNICALL Agent_OnAttach_followref003(JavaVM *jvm, char *options, void *reserved) {
1022     return Agent_Initialize(jvm, options, reserved);
1023 }
1024 JNIEXPORT jint JNI_OnLoad_followref003(JavaVM *jvm, char *options, void *reserved) {
1025     return JNI_VERSION_1_8;
1026 }
1027 #endif
1028 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
1029     jvmtiEnv* jvmti = NULL;
1030 
1031     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
1032         return JNI_ERR;
1033 
1034     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
1035 
1036     {
1037         const char* infoOpt = nsk_jvmti_findOptionValue(&quot;info&quot;);
1038         if (infoOpt != NULL) {
1039             if (strcmp(infoOpt, &quot;none&quot;) == 0)
1040                 info = INFO_NONE;
1041             else if (strcmp(infoOpt, &quot;all&quot;) == 0)
1042                 info = INFO_ALL;
1043             else if (strcmp(infoOpt, &quot;objref&quot;) == 0)
1044                 info = INFO_OBJREF;
1045             else if (strcmp(infoOpt, &quot;stackref&quot;) == 0)
1046                 info = INFO_STACKREF;
1047             else if (strcmp(infoOpt, &quot;heaproot&quot;) == 0)
1048                 info = INFO_HEAPROOT;
1049             else if (strcmp(infoOpt, &quot;heapobj&quot;) == 0)
1050                 info = INFO_HEAPOBJ;
1051             else {
1052                 printf(&quot;Unknown option value: info=%s\n&quot;, infoOpt);
1053                 fflush(0);
1054                 return JNI_ERR;
1055             }
1056         }
1057     }
1058 
1059     chainLength = nsk_jvmti_findOptionIntValue(&quot;objects&quot;, DEFAULT_CHAIN_LENGTH);
1060     if (!NSK_VERIFY(chainLength &gt; 0))
1061         return JNI_ERR;
1062 
1063     if (!NSK_VERIFY((jvmti =
1064             nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))
1065         return JNI_ERR;
1066 
1067     {
1068         jvmtiCapabilities caps;
1069 
1070         memset(&amp;caps, 0, sizeof(caps));
1071         caps.can_tag_objects = 1;
1072         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps))) {
1073             return JNI_ERR;
1074         }
1075     }
1076 
1077     /* Setting Heap Callbacks */
1078     heapCallbacks.heap_iteration_callback         = NULL;
1079     heapCallbacks.heap_reference_callback         = heapReferenceCallback;
1080     heapCallbacks.primitive_field_callback        = primitiveFieldCallback;
1081     heapCallbacks.array_primitive_value_callback  = arrayPrimitiveValueCallback;
1082     heapCallbacks.string_primitive_value_callback = stringPrimitiveValueCallback;
1083 
1084     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
1085         return JNI_ERR;
1086 
1087     return JNI_OK;
1088 }
1089 
1090 /* ============================================================================= */
1091 
1092 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/hotswap/HS203/hs203t001/hs203t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 #include &lt;stdio.h&gt;
 24 #include &lt;string.h&gt;
 25 #include &lt;jvmti.h&gt;
 26 #include &quot;agent_common.h&quot;
 27 #include &lt;jni.h&gt;
 28 #include &quot;jvmti_tools.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 /*
 31     README
 32         ******
 33         HS203: Hotswap + pop frame within events
 34         T001:
 35         1. Set a breakpoint.
 36         2. Upon reaching the breakpoint, enable SingleStep.
 37         3. Redefine a class within SingleStep callback. Stepping should
 38         be continued in obsolete method.
 39         4. Pop a currently executed frame. Stepping should be continued
 40         on invoke instruction.
 41 */
 42 extern &quot;C&quot; {
 43 
 44 #define FILE_NAME &quot;nsk/jvmti/scenarios/hotswap/HS203/hs203t001/MyThread&quot;
 45 
 46 #define SEARCH_NAME &quot;nsk/jvmti/scenarios/hotswap/HS203/hs203t001/MyThread&quot;
 47 #define CLASS_NAME &quot;Lnsk/jvmti/scenarios/hotswap/HS203/hs203t001/MyThread;&quot;
 48 #define METHOD_NAME &quot;doThisFunction&quot;
 49 #define METHOD_SIGN &quot;()V&quot;
 50 
 51 static jint redefineNumber;
 52 static jvmtiEnv * jvmti;
 53 
 54 JNIEXPORT void JNICALL
 55     callbackClassLoad(jvmtiEnv *jvmti,
 56             JNIEnv* jni,
 57             jthread thread,
 58             jclass klass) {
 59         char * className;
 60         char * generic;
 61         redefineNumber=0;
 62         jvmti-&gt;GetClassSignature(klass, &amp;className, &amp;generic);
 63         if (strcmp(className,CLASS_NAME) == 0) {
 64             jmethodID method;
 65             method = jni-&gt;GetMethodID(klass,METHOD_NAME,METHOD_SIGN);
 66             if (method != NULL) {
 67                 jlocation start;
 68                 jlocation end;
 69                 jvmtiError err ;
 70                 err=jvmti-&gt;GetMethodLocation(method, &amp;start, &amp;end);
 71                 if (err == JVMTI_ERROR_NONE) {
 72                     nsk_printf(&quot;Agent:: NO ERRORS FOUND \n&quot;);
 73                     err= jvmti-&gt;SetBreakpoint(method, start);
 74                     if (err == JVMTI_ERROR_NONE) {
 75                         nsk_printf(&quot; Class Name %s \n&quot;, className);
 76                         nsk_printf(&quot;Agent:: Breakpoint set \n&quot;);
 77                     } else {
 78                         nsk_printf(&quot; ## Error occured %s \n&quot;,TranslateError(err));
 79                     }
 80                 } else {
 81                     nsk_printf(&quot;Agent:: ***ERROR OCCURED .. in METHOD LOCATION FINDER \n&quot;);
 82                 }
 83             } else {
 84                 nsk_printf(&quot;Agent:: ***ERROR OCCURED .. COUND NOT FIND THE METHOD AND SIGNATURE SPECIFIED \n&quot;);
 85             }
 86         }
 87     }
 88 
 89 void JNICALL callbackSingleStep(jvmtiEnv *jvmti, JNIEnv* jni,
 90         jthread thread,
 91         jmethodID method,
 92         jlocation location) {
 93     jclass threadClass;
 94     jvmtiError err;
 95     char fileName[512];
 96     threadClass = jni-&gt;FindClass(SEARCH_NAME);
 97     nsk_jvmti_getFileName(redefineNumber, FILE_NAME, fileName,
 98                     sizeof(fileName)/sizeof(char));
 99     nsk_printf(&quot; %d..&quot;,redefineNumber);
100     if (nsk_jvmti_redefineClass(jvmti, threadClass, fileName) == NSK_TRUE) {
101         nsk_printf(&quot;\nMyClass :: Successfully redefined..\n&quot;);
102     } else {
103         nsk_printf(&quot;\nMyClass :: Failed to redefine ..\n&quot;);
104     }
105     nsk_printf(&quot; End of REDEFINE CLASS LOADER \n&quot;);
106     err=jvmti-&gt;SuspendThread(thread);
107     if (err == JVMTI_ERROR_NONE) {
108         nsk_printf(&quot;Agent:: Succeded in suspending..\n&quot;);
109     } else {
110         nsk_printf(&quot; ## Error occured %s \n&quot;,TranslateError(err));
111     }
112 }
113 
114 void JNICALL
115 callbackBreakpoint(jvmtiEnv *jvmti,
116         JNIEnv* jni,
117         jthread thread,
118         jmethodID method,
119         jlocation location) {
120     nsk_printf(&quot;Agent::... BreakPoint Reached..\n&quot;);
121     if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_SINGLE_STEP,thread) == NSK_TRUE) {
122         nsk_printf(&quot; ....   Enabled..\n&quot;);
123     }
124     return;
125 }
126 
127 #ifdef STATIC_BUILD
128 JNIEXPORT jint JNICALL Agent_OnLoad_hs203t001(JavaVM *jvm, char *options, void *reserved) {
129     return Agent_Initialize(jvm, options, reserved);
130 }
131 JNIEXPORT jint JNICALL Agent_OnAttach_hs203t001(JavaVM *jvm, char *options, void *reserved) {
132     return Agent_Initialize(jvm, options, reserved);
133 }
134 JNIEXPORT jint JNI_OnLoad_hs203t001(JavaVM *jvm, char *options, void *reserved) {
135     return JNI_VERSION_1_8;
136 }
137 #endif
138 jint  Agent_Initialize(JavaVM *vm, char *options, void *reserved) {
139     jint rc ;
140     nsk_printf(&quot;Agent:: VM.. Started..\n&quot;);
141     rc=vm-&gt;GetEnv((void **)&amp;jvmti, JVMTI_VERSION_1_1);
142     if (rc != JNI_OK) {
143         nsk_printf(&quot;Agent:: Could not load JVMTI interface \n&quot;);
144         return JNI_ERR;
145     } else {
146         jvmtiCapabilities caps;
147         jvmtiEventCallbacks eventCallbacks;
148         if (nsk_jvmti_parseOptions(options) == NSK_FALSE) {
149             nsk_printf(&quot;# error agent Failed to parse options \n&quot;);
150             return JNI_ERR;
151         }
152         memset(&amp;caps, 0, sizeof(caps));
153         caps.can_redefine_classes = 1;
154         caps.can_suspend=1;
155         caps.can_pop_frame=1;
156         caps.can_generate_breakpoint_events=1;
157         caps.can_generate_all_class_hook_events=1;
158         caps.can_generate_single_step_events=1;
159         jvmti-&gt;AddCapabilities(&amp;caps);
160         memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
161         eventCallbacks.ClassLoad =callbackClassLoad;
162         eventCallbacks.Breakpoint = callbackBreakpoint;
163         eventCallbacks.SingleStep =callbackSingleStep;
164         rc=jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks));
165         if (rc != JVMTI_ERROR_NONE) {
166             nsk_printf(&quot; Agent:: Error occured while setting event call back \n&quot;);
167             return JNI_ERR;
168         }
169         if ((nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_LOAD, NULL) == NSK_TRUE) &amp;&amp;
170                 (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT,NULL) == NSK_TRUE)) {
171             nsk_printf(&quot;Agent :: NOTIFICATIONS ARE ENABLED \n&quot;);
172         } else {
173             nsk_printf(&quot; Error in Eanableing Notifications..&quot;);
174         }
175     }
176     return JNI_OK;
177 }
178 
179 
180 JNIEXPORT jboolean JNICALL
181 Java_nsk_jvmti_scenarios_hotswap_HS203_hs203t001_hs203t001_popThreadFrame(JNIEnv * jni,
182         jclass clas,
183         jthread thread) {
184     jvmtiError err ;
185     jboolean retvalue;
186     jint state;
187     nsk_printf(&quot;Agent:: POPING THE FRAME....\n&quot;);
188     retvalue = JNI_FALSE;
189     nsk_printf(&quot; Here &quot;);
190     jvmti-&gt;GetThreadState(thread, &amp;state);
191     nsk_printf(&quot; Here &quot;);
192     if (state &amp; JVMTI_THREAD_STATE_SUSPENDED) {
193         err = jvmti-&gt;PopFrame(thread);
194         if (err == JVMTI_ERROR_NONE) {
195             nsk_printf(&quot;Agent:: NO Errors poped very well ..\n&quot;);
196             retvalue = JNI_TRUE;
197         } else {
198             nsk_printf(&quot; Here -3&quot;);
199             nsk_printf(&quot; ## Error occured %s \n&quot;,TranslateError(err));
200         }
201     } else {
202         nsk_printf(&quot;Agent:: Thread was not suspened.. check for capabilities, and java method signature &quot;);
203     }
204     return retvalue;
205 }
206 
207 JNIEXPORT jboolean JNICALL
208 Java_nsk_jvmti_scenarios_hotswap_HS203_hs203t001_hs203t001_resumeThread(JNIEnv * jni,
209         jclass clas,
210         jthread thread) {
211     jvmtiError err ;
212     jboolean retvalue;
213     retvalue = JNI_FALSE;
214     err =jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE,JVMTI_EVENT_SINGLE_STEP,thread);
215     if (err == JVMTI_ERROR_NONE) {
216         nsk_printf(&quot; Agent:: cleared Single Step event&quot;);
217     } else {
218         nsk_printf(&quot; Agent :: Failed to clear Single Step Event&quot;);
219     }
220     err =jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE,JVMTI_EVENT_BREAKPOINT,thread);
221     if (err == JVMTI_ERROR_NONE) {
222         nsk_printf(&quot; Agent:: cleared Break point event&quot;);
223     } else {
224         nsk_printf(&quot; Agent :: Failed to clear Single Step Event&quot;);
225     }
226     err = jvmti-&gt;ResumeThread(thread);
227     if (err == JVMTI_ERROR_NONE) {
228         nsk_printf(&quot; Agent:: Thread Resumed..&quot;);
229     } else {
230         nsk_printf(&quot; Failed.. to Resume the thread.&quot;);
231     }
232     return retvalue;
233 }
234 
235 }
    </pre>
  </body>
</html>
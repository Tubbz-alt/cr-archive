<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/unit/GetLocalVariable/getlocal003/getlocal003.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdio.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &quot;jvmti.h&quot;
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;agent_common.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 
 34 #define STATUS_PASSED 0
 35 #define STATUS_FAILED 2
 36 
 37 static jvmtiEnv *jvmti = NULL;
 38 static jvmtiEventCallbacks callbacks;
 39 static jint result = STATUS_PASSED;
 40 static jboolean printdump = JNI_FALSE;
 41 static jmethodID mid = NULL;
 42 static jvmtiLocalVariableEntry *table = NULL;
 43 static jint entryCount = 0;
 44 static jint methodExitCnt = -1;
 45 
 46 void print_LocalVariableEntry(jvmtiLocalVariableEntry *lvt_elem) {
 47   printf(&quot;\n Var name: %s, slot: %d&quot;, lvt_elem-&gt;name, lvt_elem-&gt;slot);
 48   printf(&quot;, start_bci: %&quot; LL &quot;d&quot;, lvt_elem-&gt;start_location);
 49   printf(&quot;, end_bci: %&quot; LL &quot;d&quot;,   lvt_elem-&gt;start_location + lvt_elem-&gt;length);
 50   printf(&quot;, signature: %s\n&quot;, lvt_elem-&gt;signature);
 51 }
 52 
 53 static void
 54 test_locals(jvmtiEnv *jvmti, jthread thr, jlocation location) {
 55     jvmtiError err;
 56     jint intVal;
 57     jlong longVal;
 58     jfloat floatVal;
 59     jdouble doubleVal;
 60     jobject obj;
 61     jint i;
 62 
 63     for (i = 0; i &lt; entryCount; i++) {
 64         if (table[i].start_location &gt; location ||
 65             table[i].start_location + table[i].length &lt; location) {
 66             continue;  /* The local variable is not visible */
 67         }
 68         print_LocalVariableEntry(&amp;table[i]);
 69         char sig = table[i].signature[0];
<a name="2" id="anc2"></a>
 70 
 71         if (sig == &#39;Z&#39; || sig == &#39;B&#39; || sig == &#39;C&#39; || sig == &#39;S&#39;) {
 72             sig = &#39;I&#39;; // covered by GetLocalInt
 73         }
<a name="3" id="anc3"></a><span class="line-modified"> 74         err = jvmti-&gt;GetLocalInt(thr, 0, table[i].slot, &amp;intVal);</span>
 75         printf(&quot; GetLocalInt:     %s (%d)\n&quot;, TranslateError(err), err);
 76         if (err != JVMTI_ERROR_NONE &amp;&amp; sig == &#39;I&#39;) {
 77             printf(&quot;FAIL: GetLocalInt failed to get value of int\n&quot;);
 78             result = STATUS_FAILED;
 79         } else if (err != JVMTI_ERROR_TYPE_MISMATCH &amp;&amp; sig != &#39;I&#39;) {
 80             printf(&quot;FAIL: GetLocalInt did not return JVMTI_ERROR_TYPE_MISMATCH for non-int\n&quot;);
 81             result = STATUS_FAILED;
 82         }
 83 
<a name="4" id="anc4"></a><span class="line-modified"> 84         err = jvmti-&gt;GetLocalLong(thr, 0, table[i].slot, &amp;longVal);</span>
 85         printf(&quot; GetLocalLong:    %s (%d)\n&quot;, TranslateError(err), err);
 86         if (err != JVMTI_ERROR_NONE &amp;&amp; sig == &#39;J&#39;) {
 87             printf(&quot;FAIL: GetLocalLong failed to get value of long\n&quot;);
 88             result = STATUS_FAILED;
<a name="5" id="anc5"></a><span class="line-modified"> 89         } else if (err != JVMTI_ERROR_TYPE_MISMATCH &amp;&amp; sig != &#39;J&#39;) {</span>
<span class="line-modified"> 90             printf(&quot;FAIL: GetLocalLong did not return JVMTI_ERROR_TYPE_MISMATCH for non-long\n&quot;);</span>



 91             result = STATUS_FAILED;
 92         }
 93 
<a name="6" id="anc6"></a><span class="line-modified"> 94         err = jvmti-&gt;GetLocalFloat(thr, 0, table[i].slot, &amp;floatVal);</span>
 95         printf(&quot; GetLocalFloat:   %s (%d)\n&quot;, TranslateError(err), err);
<a name="7" id="anc7"></a><span class="line-modified"> 96         if (err != JVMTI_ERROR_NONE &amp;&amp; table[i].signature[0] == &#39;F&#39;) {</span>
 97             printf(&quot;FAIL: GetLocalFloat failed to get value of float\n&quot;);
 98             result = STATUS_FAILED;
<a name="8" id="anc8"></a><span class="line-modified"> 99         } else if (err != JVMTI_ERROR_TYPE_MISMATCH &amp;&amp; table[i].signature[0] != &#39;F&#39;) {</span>
100             printf(&quot;FAIL: GetLocalFloat did not return JVMTI_ERROR_TYPE_MISMATCH for non-float\n&quot;);
101             result = STATUS_FAILED;
102         }
103 
<a name="9" id="anc9"></a><span class="line-modified">104         err = jvmti-&gt;GetLocalDouble(thr, 0, table[i].slot, &amp;doubleVal);</span>
105         printf(&quot; GetLocalDouble:  %s (%d)\n&quot;, TranslateError(err), err);
<a name="10" id="anc10"></a><span class="line-modified">106         if (err != JVMTI_ERROR_NONE &amp;&amp; table[i].signature[0] == &#39;D&#39;) {</span>
107             printf(&quot;FAIL: GetLocalDouble failed to get value of double\n&quot;);
108             result = STATUS_FAILED;
<a name="11" id="anc11"></a><span class="line-modified">109         } else if (err != JVMTI_ERROR_TYPE_MISMATCH &amp;&amp; table[i].signature[0] != &#39;D&#39;) {</span>
<span class="line-modified">110             printf(&quot;FAIL: GetLocalDouble did not return JVMTI_ERROR_TYPE_MISMATCH for non-double\n&quot;);</span>



111             result = STATUS_FAILED;
112         }
113 
<a name="12" id="anc12"></a><span class="line-modified">114         err = jvmti-&gt;GetLocalObject(thr, 0, table[i].slot, &amp;obj);</span>
115         printf(&quot; GetLocalObject:  %s (%d)\n&quot;, TranslateError(err), err);
<a name="13" id="anc13"></a><span class="line-modified">116         if (err != JVMTI_ERROR_NONE &amp;&amp; table[i].signature[0] == &#39;L&#39;) {</span>
117             printf(&quot;FAIL: GetLocalObject failed to get value of object\n&quot;);
118             result = STATUS_FAILED;
<a name="14" id="anc14"></a><span class="line-modified">119         } else if (err != JVMTI_ERROR_TYPE_MISMATCH &amp;&amp; table[i].signature[0] != &#39;L&#39;) {</span>
120             printf(&quot;FAIL: GetLocalObject did not return JVMTI_ERROR_TYPE_MISMATCH for non-object\n&quot;);
121             result = STATUS_FAILED;
122         }
123     }
124 }
125 
126 static void JNICALL
127 MethodExit(jvmtiEnv *jvmti_env,
128            JNIEnv *env,
129            jthread thr,
130            jmethodID method,
131            jboolean was_poped_by_exception,
132            jvalue return_value) {
133 
134     jvmtiError err;
135     jlocation location;
136     jmethodID frame_method = NULL;
137 
138     if (mid != method) {
139         return;
140     }
141     err = jvmti-&gt;GetFrameLocation(thr, 0, &amp;frame_method, &amp;location);
142     if (err != JVMTI_ERROR_NONE) {
143         printf(&quot;\t failure: %s (%d)\n&quot;, TranslateError(err), err);
144         result = STATUS_FAILED;
145         return;
146     }
147     if (frame_method != method) {
148         printf(&quot;\t failure: GetFrameLocation returned wrong jmethodID\n&quot;);
149         result = STATUS_FAILED;
150         return;
151     }
152 
153     printf(&quot;\n MethodExit: BEGIN %d\n&quot;,  ++methodExitCnt);
154 
155     test_locals(jvmti, thr, location);
156 
157     printf(&quot;\n MethodExit: END %d\n\n&quot;, methodExitCnt);
158     fflush(stdout);
159 }
160 
161 #ifdef STATIC_BUILD
162 JNIEXPORT jint JNICALL Agent_OnLoad_getlocal003(JavaVM *jvm, char *options, void *reserved) {
163     return Agent_Initialize(jvm, options, reserved);
164 }
165 JNIEXPORT jint JNICALL Agent_OnAttach_getlocal003(JavaVM *jvm, char *options, void *reserved) {
166     return Agent_Initialize(jvm, options, reserved);
167 }
168 JNIEXPORT jint JNI_OnLoad_getlocal003(JavaVM *jvm, char *options, void *reserved) {
169     return JNI_VERSION_1_8;
170 }
171 #endif
172 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
173     jint res;
174     jvmtiError err;
175     static jvmtiCapabilities caps;
176 
177     if (options != NULL &amp;&amp; strcmp(options, &quot;printdump&quot;) == 0) {
178         printdump = JNI_TRUE;
179     }
180 
181     res = jvm-&gt;GetEnv((void **) &amp;jvmti, JVMTI_VERSION_1_1);
182     if (res != JNI_OK || jvmti == NULL) {
183         printf(&quot;Wrong result of a valid call to GetEnv!\n&quot;);
184         return JNI_ERR;
185     }
186 
187     err = jvmti-&gt;GetPotentialCapabilities(&amp;caps);
188     if (err != JVMTI_ERROR_NONE) {
189         printf(&quot;(GetPotentialCapabilities) unexpected error: %s (%d)\n&quot;,
190                TranslateError(err), err);
191         return JNI_ERR;
192     }
193 
194     err = jvmti-&gt;AddCapabilities(&amp;caps);
195     if (err != JVMTI_ERROR_NONE) {
196         printf(&quot;(AddCapabilities) unexpected error: %s (%d)\n&quot;,
197                TranslateError(err), err);
198         return JNI_ERR;
199     }
200 
201     err = jvmti-&gt;GetCapabilities(&amp;caps);
202     if (err != JVMTI_ERROR_NONE) {
203         printf(&quot;(GetCapabilities) unexpected error: %s (%d)\n&quot;,
204                TranslateError(err), err);
205         return JNI_ERR;
206     }
207 
208     if (!caps.can_access_local_variables) {
209         printf(&quot;Warning: Access to local variables is not implemented\n&quot;);
210         return JNI_ERR;
211     }
212     if (!caps.can_generate_method_exit_events) {
213         printf(&quot;Warning: MethodExit event is not implemented\n&quot;);
214         return JNI_ERR;
215     }
216     callbacks.MethodExit = &amp;MethodExit;
217     err = jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));
218     if (err != JVMTI_ERROR_NONE) {
219         printf(&quot;(SetEventCallbacks) unexpected error: %s (%d)\n&quot;,
220                TranslateError(err), err);
221         return JNI_ERR;
222     }
223     return JNI_OK;
224 }
225 
<a name="15" id="anc15"></a>
































226 JNIEXPORT void JNICALL
227 Java_nsk_jvmti_unit_GetLocalVariable_getlocal003_getMeth(JNIEnv *env, jclass cls) {
228     jvmtiError err;
<a name="16" id="anc16"></a>


229 
230     if (jvmti == NULL) {
231         printf(&quot;JVMTI client was not properly loaded!\n&quot;);
232         result = STATUS_FAILED;
233         return;
234     }
235 
236     mid = env-&gt;GetStaticMethodID(cls, &quot;staticMeth&quot;, &quot;(I)I&quot;);
237     if (mid == NULL) {
238         printf(&quot;Cannot find Method ID for staticMeth\n&quot;);
239         result = STATUS_FAILED;
240         return;
241     }
242 
243     err = jvmti-&gt;GetLocalVariableTable(mid, &amp;entryCount, &amp;table);
244     if (err != JVMTI_ERROR_NONE) {
245         printf(&quot;(GetLocalVariableTable) unexpected error: %s (%d)\n&quot;,
246                TranslateError(err), err);
247         result = STATUS_FAILED;
248         return;
249     }
250 
251     err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, NULL);
252     if (err != JVMTI_ERROR_NONE) {
253         printf(&quot;Failed to enable metod exit event: %s (%d)\n&quot;,
254                TranslateError(err), err);
255         result = STATUS_FAILED;
256     }
<a name="17" id="anc17"></a>

















257     fflush(stdout);
258 }
259 
260 JNIEXPORT void JNICALL
261 Java_nsk_jvmti_unit_GetLocalVariable_getlocal003_checkLoc(JNIEnv *env,
262         jclass cls, jthread thr) {
263     jvmtiError err;
264     jvmtiLocalVariableEntry *table;
265     jint entryCount;
266     jmethodID mid;
267     jint locVar;
268     jint i, j;
269     int  overlap = 0;
270 
271     if (jvmti == NULL) {
272         printf(&quot;JVMTI client was not properly loaded!\n&quot;);
273         result = STATUS_FAILED;
274         return;
275     }
276     printf(&quot;\n checkLoc: START\n&quot;);
277 
278     mid = env-&gt;GetStaticMethodID(cls, &quot;staticMeth&quot;, &quot;(I)I&quot;);
279     if (mid == NULL) {
280         printf(&quot;Cannot find Method ID for staticMeth\n&quot;);
281         result = STATUS_FAILED;
282         return;
283     }
284 
285     err = jvmti-&gt;GetLocalVariableTable(mid, &amp;entryCount, &amp;table);
286     if (err != JVMTI_ERROR_NONE) {
287         printf(&quot;(GetLocalVariableTable) unexpected error: %s (%d)\n&quot;,
288                TranslateError(err), err);
289         result = STATUS_FAILED;
290         return;
291     }
292 
293     for (i = 0; i &lt; entryCount; i++) {
294         print_LocalVariableEntry(&amp;table[i]);
295 
296         err = jvmti-&gt;GetLocalInt(thr, 1, table[i].slot, &amp;locVar);
297 
298         if (strcmp(table[i].name, &quot;intArg&quot;) == 0) {
299             if (err != JVMTI_ERROR_NONE) {
300                 printf(&quot; GetLocalInt: %s (%d)\n&quot;, TranslateError(err), err);
301                 printf(&quot; failure: JVMTI_ERROR_NONE is expected\n&quot;);
302                 result = STATUS_FAILED;
303             }
304         }
305         else if (strcmp(table[i].name, &quot;pi&quot;) == 0) {
306             if (err != JVMTI_ERROR_TYPE_MISMATCH) {
307                 printf(&quot; GetLocalInt: %s (%d)\n&quot;, TranslateError(err), err);
308                 printf(&quot; failure: JVMTI_ERROR_TYPE_MISMATCH is expected\n&quot;);
309                 result = STATUS_FAILED;
310             }
311         } else {
312             if (err != JVMTI_ERROR_INVALID_SLOT) {
313                 printf(&quot; GetLocalInt: %s (%d)\n&quot;, TranslateError(err), err);
314                 printf(&quot; failure: JVMTI_ERROR_INVALID_SLOT is expected\n&quot;);
315                 result = STATUS_FAILED;
316             }
317         }
318         if (table[i].slot != 2) {
319            continue;
320         }
321 
322         for (j = 0; j &lt; entryCount; j++) {
323            /* We do cross checks between all variables having slot #2.
324             * No overlapping between location ranges are allowed.
325             */
326            if (table[j].slot != 2 || i == j) {
327               continue;
328            }
329            if (table[i].start_location &gt; table[j].start_location + table[j].length ||
330                table[j].start_location &gt; table[i].start_location + table[i].length
331            ) {
332                continue; /* Everything is Ok */
333            }
334 
335            printf(&quot; failure: locations of vars with slot #2 are overlapped:\n&quot;);
336            print_LocalVariableEntry(&amp;table[i]);
337            print_LocalVariableEntry(&amp;table[j]);
338            overlap++;
339            result = STATUS_FAILED;
340         }
341     }
342     if (!overlap) {
343         printf(&quot;\n Success: locations of vars with slot #2 are NOT overlapped\n&quot;);
344     }
345     printf(&quot;\n checkLoc: END\n\n&quot;);
346     fflush(stdout);
347 }
348 
349 JNIEXPORT jint JNICALL
350 Java_nsk_jvmti_unit_GetLocalVariable_getlocal003_getRes(JNIEnv *env, jclass cls) {
351     return result;
352 }
353 
354 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
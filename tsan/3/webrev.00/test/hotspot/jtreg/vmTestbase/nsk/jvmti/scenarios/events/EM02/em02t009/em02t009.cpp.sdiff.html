<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t009/em02t009.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../em02t008/em02t008.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../em02t010/em02t010.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t009/em02t009.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 52     int i;
 53     const char* str;
 54     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 55 
 56     NSK_DISPLAY0(&quot;\n&quot;);
 57     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 58     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 59     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 60         if (currentCounts[i] &gt; 0) {
 61             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 62             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 63         }
 64     }
 65 }
 66 
 67 /* ========================================================================== */
 68 
 69 int checkEvents(int step) {
 70     int i;
 71     jvmtiEvent curr;
<span class="line-modified"> 72     int result = NSK_TRUE;</span>
 73     int *currentCounts;
 74     int isExpected = 0;
 75 
 76     switch (step) {
 77         case 1:
 78             currentCounts = &amp;eventCount[0];
 79             break;
 80 
 81         case 2:
 82         case 3:
 83             currentCounts = &amp;newEventCount[0];
 84             break;
 85 
 86         default:
 87             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified"> 88             return NSK_FALSE;</span>
 89     }
 90 
 91     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 92 
 93         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 94 
 95         switch (step) {
 96             case 1:
 97                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
 98                                 || (curr == JVMTI_EVENT_METHOD_ENTRY)
 99                                 || (curr == JVMTI_EVENT_METHOD_EXIT));
100                 break;
101 
102             case 2:
103                 isExpected = ((curr == JVMTI_EVENT_METHOD_ENTRY)
104                                 || (curr == JVMTI_EVENT_METHOD_EXIT));
105                 break;
106 
107             case 3:
108                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
109                 break;
110         }
111 
112         if (isExpected) {
113             if (curr == JVMTI_EVENT_VM_INIT || curr == JVMTI_EVENT_VM_DEATH) {
114                 if (currentCounts[i] &lt; 1) {
115                         NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
116                                             currentCounts[i],
117                                             TranslateEvent(curr));
<span class="line-modified">118                     result = NSK_FALSE;</span>
119                 }
120             } else {
121                 if (currentCounts[i] != NUMBER_OF_INVOCATIONS) {
122                     NSK_COMPLAIN3(&quot;Unexpected number of %s events %d, expected value is %d\n&quot;,
123                                         TranslateEvent(curr),
124                                         currentCounts[i],
125                                         NUMBER_OF_INVOCATIONS);
<span class="line-modified">126                     result = NSK_FALSE;</span>
127                 }
128             }
129         } else {
130 
131             if (currentCounts[i] &gt; 0) {
132                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
133                                     TranslateEvent(curr),
134                                     currentCounts[i]);
<span class="line-modified">135                 result = NSK_FALSE;</span>
136             }
137         }
138     }
139 
140     return result;
141 }
142 
143 static void
144 changeCount(jvmtiEvent event, int *currentCounts) {
145 
146     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
147         nsk_jvmti_setFailStatus();
148 
149     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
150 
151     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
152         nsk_jvmti_setFailStatus();
153 
154 }
155 
</pre>
<hr />
<pre>
361 void JNICALL
362 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
363     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
364 }
365 
366 void JNICALL
367 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
368 
369     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
370 }
371 
372 void JNICALL
373 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
374                     jobject object, jclass object_klass, jlong size) {
375 
376     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
377 }
378 
379 /* ============================================================================= */
380 
<span class="line-modified">381 static int enableEvent(jvmtiEvent event) {</span>
382 
383     if (nsk_jvmti_isOptionalEvent(event)
384             &amp;&amp; (event != JVMTI_EVENT_METHOD_ENTRY)
385             &amp;&amp; (event != JVMTI_EVENT_METHOD_EXIT)) {
386         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
387                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
388             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
389                 TranslateEvent(event));
<span class="line-modified">390             return NSK_FALSE;</span>
391         }
392     } else {
393         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
394             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
395                 TranslateEvent(event));
<span class="line-modified">396             return NSK_FALSE;</span>
397         }
398     }
399 
<span class="line-modified">400     return NSK_TRUE;</span>
401 }
402 
403 /**
404  * Enable or disable tested events.
405  */
<span class="line-modified">406 static int enableEventList() {</span>
407 
408     int i, result;
409 
410     result = enableEvent(JVMTI_EVENT_VM_INIT);
411 
412     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
413 
414     /* enabling optional events */
415     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
416         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
417 
418         if (nsk_jvmti_isOptionalEvent(event))
419             result = result &amp;&amp; enableEvent(event);
420     }
421 
<span class="line-modified">422     if (result == NSK_FALSE) {</span>
423         nsk_jvmti_setFailStatus();
<span class="line-modified">424         return NSK_FALSE;</span>
425     }
426 
<span class="line-modified">427     return NSK_TRUE;</span>
428 }
429 
430 /* ============================================================================= */
431 
<span class="line-modified">432 static int</span>
<span class="line-removed">433 setCallBacks(int step) {</span>
434 
435     int i;
436 
437     jvmtiEventCallbacks eventCallbacks;
438     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
439 
440     switch (step) {
441         case 1:
442             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
443                 eventCount[i] = 0;
444             }
445 
446             eventCallbacks.VMInit                    = cbVMInit;
447             eventCallbacks.Exception                 = cbException;
448             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
449             eventCallbacks.SingleStep                = cbSingleStep;
450             eventCallbacks.FramePop                  = cbFramePop;
451             eventCallbacks.Breakpoint                = cbBreakpoint;
452             eventCallbacks.FieldAccess               = cbFieldAccess;
453             eventCallbacks.FieldModification         = cbFieldModification;
</pre>
<hr />
<pre>
468 
469         case 2:
470             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
471                 newEventCount[i] = 0;
472             }
473 
474             eventCallbacks.MethodEntry               = cbNewMethodEntry;
475             eventCallbacks.MethodExit                = cbNewMethodExit;
476             break;
477 
478         case 3:
479             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
480                 newEventCount[i] = 0;
481             }
482 
483             eventCallbacks.VMDeath                   = cbVMDeath;
484             break;
485 
486     }
487     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">488         return NSK_FALSE;</span>
489 
<span class="line-modified">490     return NSK_TRUE;</span>
491 }
492 
493 /* ============================================================================= */
494 
495 /** Agent algorithm. */
496 static void JNICALL
497 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
498 
499     int i;
500 
501     for (i = 1; i &lt;= STEP_NUMBER; i++) {
502 
503         if (!nsk_jvmti_waitForSync(timeout))
504             return;
505 
506         if (i &lt; STEP_NUMBER) {
507             showEventStatistics(i);
508             if (!checkEvents(i))
509                 nsk_jvmti_setFailStatus();
510 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 52     int i;
 53     const char* str;
 54     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 55 
 56     NSK_DISPLAY0(&quot;\n&quot;);
 57     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 58     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 59     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 60         if (currentCounts[i] &gt; 0) {
 61             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 62             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 63         }
 64     }
 65 }
 66 
 67 /* ========================================================================== */
 68 
 69 int checkEvents(int step) {
 70     int i;
 71     jvmtiEvent curr;
<span class="line-modified"> 72     bool result = true;</span>
 73     int *currentCounts;
 74     int isExpected = 0;
 75 
 76     switch (step) {
 77         case 1:
 78             currentCounts = &amp;eventCount[0];
 79             break;
 80 
 81         case 2:
 82         case 3:
 83             currentCounts = &amp;newEventCount[0];
 84             break;
 85 
 86         default:
 87             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified"> 88             return false;</span>
 89     }
 90 
 91     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 92 
 93         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 94 
 95         switch (step) {
 96             case 1:
 97                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
 98                                 || (curr == JVMTI_EVENT_METHOD_ENTRY)
 99                                 || (curr == JVMTI_EVENT_METHOD_EXIT));
100                 break;
101 
102             case 2:
103                 isExpected = ((curr == JVMTI_EVENT_METHOD_ENTRY)
104                                 || (curr == JVMTI_EVENT_METHOD_EXIT));
105                 break;
106 
107             case 3:
108                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
109                 break;
110         }
111 
112         if (isExpected) {
113             if (curr == JVMTI_EVENT_VM_INIT || curr == JVMTI_EVENT_VM_DEATH) {
114                 if (currentCounts[i] &lt; 1) {
115                         NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
116                                             currentCounts[i],
117                                             TranslateEvent(curr));
<span class="line-modified">118                     result = false;</span>
119                 }
120             } else {
121                 if (currentCounts[i] != NUMBER_OF_INVOCATIONS) {
122                     NSK_COMPLAIN3(&quot;Unexpected number of %s events %d, expected value is %d\n&quot;,
123                                         TranslateEvent(curr),
124                                         currentCounts[i],
125                                         NUMBER_OF_INVOCATIONS);
<span class="line-modified">126                     result = false;</span>
127                 }
128             }
129         } else {
130 
131             if (currentCounts[i] &gt; 0) {
132                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
133                                     TranslateEvent(curr),
134                                     currentCounts[i]);
<span class="line-modified">135                 result = false;</span>
136             }
137         }
138     }
139 
140     return result;
141 }
142 
143 static void
144 changeCount(jvmtiEvent event, int *currentCounts) {
145 
146     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
147         nsk_jvmti_setFailStatus();
148 
149     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
150 
151     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
152         nsk_jvmti_setFailStatus();
153 
154 }
155 
</pre>
<hr />
<pre>
361 void JNICALL
362 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
363     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
364 }
365 
366 void JNICALL
367 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
368 
369     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
370 }
371 
372 void JNICALL
373 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
374                     jobject object, jclass object_klass, jlong size) {
375 
376     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
377 }
378 
379 /* ============================================================================= */
380 
<span class="line-modified">381 static bool enableEvent(jvmtiEvent event) {</span>
382 
383     if (nsk_jvmti_isOptionalEvent(event)
384             &amp;&amp; (event != JVMTI_EVENT_METHOD_ENTRY)
385             &amp;&amp; (event != JVMTI_EVENT_METHOD_EXIT)) {
386         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
387                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
388             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
389                 TranslateEvent(event));
<span class="line-modified">390             return false;</span>
391         }
392     } else {
393         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
394             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
395                 TranslateEvent(event));
<span class="line-modified">396             return false;</span>
397         }
398     }
399 
<span class="line-modified">400     return true;</span>
401 }
402 
403 /**
404  * Enable or disable tested events.
405  */
<span class="line-modified">406 static bool enableEventList() {</span>
407 
408     int i, result;
409 
410     result = enableEvent(JVMTI_EVENT_VM_INIT);
411 
412     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
413 
414     /* enabling optional events */
415     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
416         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
417 
418         if (nsk_jvmti_isOptionalEvent(event))
419             result = result &amp;&amp; enableEvent(event);
420     }
421 
<span class="line-modified">422     if (!result) {</span>
423         nsk_jvmti_setFailStatus();
<span class="line-modified">424         return false;</span>
425     }
426 
<span class="line-modified">427     return true;</span>
428 }
429 
430 /* ============================================================================= */
431 
<span class="line-modified">432 static bool setCallBacks(int step) {</span>

433 
434     int i;
435 
436     jvmtiEventCallbacks eventCallbacks;
437     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
438 
439     switch (step) {
440         case 1:
441             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
442                 eventCount[i] = 0;
443             }
444 
445             eventCallbacks.VMInit                    = cbVMInit;
446             eventCallbacks.Exception                 = cbException;
447             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
448             eventCallbacks.SingleStep                = cbSingleStep;
449             eventCallbacks.FramePop                  = cbFramePop;
450             eventCallbacks.Breakpoint                = cbBreakpoint;
451             eventCallbacks.FieldAccess               = cbFieldAccess;
452             eventCallbacks.FieldModification         = cbFieldModification;
</pre>
<hr />
<pre>
467 
468         case 2:
469             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
470                 newEventCount[i] = 0;
471             }
472 
473             eventCallbacks.MethodEntry               = cbNewMethodEntry;
474             eventCallbacks.MethodExit                = cbNewMethodExit;
475             break;
476 
477         case 3:
478             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
479                 newEventCount[i] = 0;
480             }
481 
482             eventCallbacks.VMDeath                   = cbVMDeath;
483             break;
484 
485     }
486     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">487         return false;</span>
488 
<span class="line-modified">489     return true;</span>
490 }
491 
492 /* ============================================================================= */
493 
494 /** Agent algorithm. */
495 static void JNICALL
496 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
497 
498     int i;
499 
500     for (i = 1; i &lt;= STEP_NUMBER; i++) {
501 
502         if (!nsk_jvmti_waitForSync(timeout))
503             return;
504 
505         if (i &lt; STEP_NUMBER) {
506             showEventStatistics(i);
507             if (!checkEvents(i))
508                 nsk_jvmti_setFailStatus();
509 
</pre>
</td>
</tr>
</table>
<center><a href="../em02t008/em02t008.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../em02t010/em02t010.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
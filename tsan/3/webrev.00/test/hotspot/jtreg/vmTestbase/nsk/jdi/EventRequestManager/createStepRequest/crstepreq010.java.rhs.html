<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jdi/EventRequestManager/createStepRequest/crstepreq010.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.EventRequestManager.createStepRequest;
 25 
 26 import nsk.share.*;
 27 import nsk.share.jpda.*;
 28 import nsk.share.jdi.*;
 29 
 30 import com.sun.jdi.*;
 31 import com.sun.jdi.connect.*;
 32 import com.sun.jdi.request.*;
 33 import com.sun.jdi.event.*;
 34 import java.io.*;
 35 import java.util.*;
 36 
 37 /**
 38  */
 39 public class crstepreq010 {
 40 
 41     //----------------------------------------------------- immutable common fields
 42 
 43     static final int PASSED    = 0;
 44     static final int FAILED    = 2;
 45     static final int PASS_BASE = 95;
 46     static final int quit      = -1;
 47 
 48     private int instruction = 1;
 49     private int waitTime;
 50     private static int exitCode = PASSED;
 51 
 52     private ArgumentHandler     argHandler;
 53     private Log                 log;
 54     private Debugee             debuggee;
 55     private VirtualMachine      vm;
 56     private ReferenceType       debuggeeClass;
 57 
 58     private EventRequestManager eventRManager;
 59     private EventSet            eventSet;
 60     private EventIterator       eventIterator;
 61 
 62     //------------------------------------------------------ mutable common fields
 63 
 64     private final static String prefix = &quot;nsk.jdi.EventRequestManager.createStepRequest&quot;;
 65     private final static String className = &quot;.crstepreq010&quot;;
 66     private final static String debuggerName = prefix + className;
 67     private final static String debuggeeName = debuggerName + &quot;a&quot;;
 68     static final int lineForBreak = 62;
 69 
 70     //------------------------------------------------------ immutable common methods
 71 
 72     public static void main (String argv[]) {
 73         System.exit(run(argv, System.out) + PASS_BASE);
 74     }
 75 
 76     //------------------------------------------------------ test specific fields
 77 
 78     static final int maxCase = 5;
 79     static final String[] brakeMethods = {
 80         &quot;caseRun&quot;,
 81         &quot;m01&quot;,
 82         &quot;m02&quot;,
 83         &quot;m03&quot;,
 84         &quot;caseRun&quot;
 85                                         };
 86     static final int[][] checkedLines = {
 87         { 152, 152, 152},
 88         { 182, 182, 182},
 89         { 187, 187, 187},
 90         { 193, 193, 193},
 91         { 169, 169, 196}
 92                                         };
 93 
 94     static final String debuggeeThreadName = prefix + &quot;.Thread0crstepreq010a&quot;;
 95 
 96     //------------------------------------------------------ mutable common methods
 97 
 98     public static int run (String argv[], PrintStream out) {
 99 
100         int exitStatus = new crstepreq010().runThis(argv, out);
101         System.out.println (exitStatus == PASSED ? &quot;TEST PASSED&quot; : &quot;TEST FAILED&quot;);
102         return exitCode;
103     }
104 
105     private int runThis(String argv[], PrintStream out) {
106 
107         argHandler = new ArgumentHandler(argv);
108         log = new Log(out, argHandler);
109         waitTime = argHandler.getWaitTime() * 60000;
110 
111         try {
112 
113             Binder binder = new Binder(argHandler, log);
114             debuggee = binder.bindToDebugee(debuggeeName);
115             debuggee.redirectStderr(log, &quot;&quot;);
116             eventRManager = debuggee.getEventRequestManager();
117 
118             vm = debuggee.VM();
119             eventRManager = vm.eventRequestManager();
120 
121             debuggeeClass = waitForDebuggeeClassPrepared();
122 
123             execTest();
124 
125             debuggee.resume();
126             getEventSet();
127             if (eventIterator.nextEvent() instanceof VMDeathEvent) {
128                 display(&quot;Waiting for the debuggee&#39;s finish...&quot;);
129                 debuggee.waitFor();
130 
131                 display(&quot;Getting the debuggee&#39;s exit status.&quot;);
132                 int status = debuggee.getStatus();
133                 if (status != (PASSED + PASS_BASE)) {
134                     complain(&quot;Debuggee returned UNEXPECTED exit status: &quot; + status);
135                     exitCode = Consts.TEST_FAILED;
136                 }
137             } else {
138                 throw new TestBug(&quot;Last event is not the VMDeathEvent&quot;);
139             }
140 
141         } catch (VMDisconnectedException e) {
142             exitCode = Consts.TEST_FAILED;
143             complain(&quot;The test cancelled due to VMDisconnectedException.&quot;);
144             e.printStackTrace(out);
145             display(&quot;Trying: vm.process().destroy();&quot;);
146             if (vm != null) {
147                 Process vmProcess = vm.process();
148                 if (vmProcess != null) {
149                     vmProcess.destroy();
150                 }
151             }
152 
153         } catch (Exception e) {
154             exitCode = Consts.TEST_FAILED;
155             complain(&quot;Unexpected Exception: &quot; + e.getMessage());
156             e.printStackTrace(out);
157             complain(&quot;The test has not finished normally. Forcing: vm.exit().&quot;);
158             if (vm != null) {
159                 vm.exit(PASSED + PASS_BASE);
160             }
161             debuggee.resume();
162             getEventSet();
163         }
164 
165         return exitCode;
166     }
167 
168     //--------------------------------------------------------- mutable common methods
169 
170     private void execTest() {
171         BreakpointRequest bpRequest = setBreakpoint( null,
172                                                      debuggeeClass,
173                                                      &quot;methodForCommunication&quot;,
174                                                      lineForBreak,
175                                                      &quot;breakForCommunication&quot;);
176         bpRequest.enable();
177 
178         StepRequest stepRequest = null;
179 
180         display(&quot;TESTING BEGINS&quot;);
181         for (int testCase = 0; testCase &lt; maxCase &amp;&amp; instruction != quit; testCase++) {
182 
183             instruction = getInstruction();
184             if (instruction == quit) {
185                 vm.resume();
186                 break;
187             }
188 
189             display(&quot;:: CASE # &quot; + testCase);
190             stepRequest = setStepRequest( bpRequest,
191                                           &quot;thread&quot; + testCase,
192                                           testCase,
193                                           &quot;stepRequest&quot; + testCase );
194 
195             checkStepEvent( stepRequest,
196                             &quot;thread&quot; + testCase,
197                             testCase );
198         }
199         display(&quot;TESTING ENDS&quot;);
200     }
201 
202     //--------------------------------------------------------- test specific methods
203 
204     private StepRequest setStepRequest ( BreakpointRequest bpRequest,
205                                          String threadName,
206                                          int testCase,
207                                          String property ) {
208         StepRequest stepRequest = null;
209         for (;;) {
210             display(&quot;Wait for initial brakepoint event in &quot; + threadName);
211             BreakpointEvent bpEvent = (BreakpointEvent)waitForEvent(bpRequest);
212 
213             // check location of breakpoint event
214             int lineOfEvent = ((LocatableEvent)bpEvent).location().lineNumber();
215             if (lineOfEvent != lineForBreak) {
216                 complain(&quot;Wrong line number of initial brakepoint event for &quot; + threadName);
217                 complain(&quot;\texpected value : &quot; + lineForBreak + &quot;; got one : &quot; + lineOfEvent);
218                 break;
219             }
220 
221             display(&quot;Getting mirror of thread: &quot; + threadName);
<a name="1" id="anc1"></a><span class="line-modified">222             ThreadReference thread = debuggee.threadByNameOrThrow(threadName);</span>
223 
224             display(&quot;Getting ReferenceType of thread: &quot; + threadName);
225             ReferenceType debuggeeThread = debuggee.classByName(debuggeeThreadName);
226 
227             // set second breakpoint to suspend checked thread at the right location before
228             // setting step request
229             BreakpointRequest bpRequest1 = setBreakpoint( thread,
230                                                          debuggeeThread,
231                                                          brakeMethods[testCase],
232                                                          checkedLines[testCase][0],
233                                                          &quot;&quot;);
234             bpRequest1.addCountFilter(1);
235             bpRequest1.enable();
236 
237             display(&quot;Wait for additional brakepoint event in &quot; + threadName);
238             bpEvent = (BreakpointEvent)waitForEvent(bpRequest1);
239 
240             // check location of breakpoint event
241             lineOfEvent = ((LocatableEvent)bpEvent).location().lineNumber();
242             if (lineOfEvent != checkedLines[testCase][0]) {
243                 complain(&quot;Wrong line number of additional brakepoint event for &quot; + threadName);
244                 complain(&quot;\texpected value : &quot; + checkedLines[testCase][0] + &quot;; got one : &quot; + lineOfEvent);
245                 break;
246             }
247 
248             display(&quot;Setting a step request in  thread: &quot; + thread);
249             try {
250                 stepRequest = eventRManager.createStepRequest ( thread,
251                                                                 StepRequest.STEP_MIN,
252                                                                 StepRequest.STEP_INTO );
253                 stepRequest.putProperty(&quot;number&quot;, property);
254             } catch ( Exception e1 ) {
255                 complain(&quot;setStepRequest(): unexpected Exception while creating StepRequest: &quot; + e1);
256                 break;
257             }
258             break;
259         }
260         if (stepRequest == null) {
261             throw new Failure(&quot;setStepRequest(): StepRequest has not been set up.&quot;);
262         }
263         display(&quot;setStepRequest(): StepRequest has been set up.&quot;);
264         return stepRequest;
265     }
266 
267     private void checkStepEvent ( StepRequest stepRequest,
268                                   String threadName,
269                                   int testCase ) {
270         stepRequest.enable();
271 
272         display(&quot;waiting for first StepEvent in &quot; + threadName);
273         Event newEvent = waitForEvent(stepRequest);
274         display(&quot;got first StepEvent&quot;);
275 
276         display(&quot;CHECK1 for line location of first StepEvent.&quot;);
277         int lineOfEvent = ((LocatableEvent)newEvent).location().lineNumber();
278         if (lineOfEvent != checkedLines[testCase][1]) {
279             complain(&quot;CHECK1 for line location of first StepEvent FAILED for CASE # &quot; + testCase);
280             complain(&quot;\texpected value : &quot; + checkedLines[testCase][1] + &quot;; got one : &quot; + lineOfEvent);
281             exitCode = FAILED;
282         } else {
283             display(&quot;CHECK1 PASSED&quot;);
284         }
285 
286         display(&quot;waiting for second StepEvent in &quot; + threadName);
287         newEvent = waitForEvent(stepRequest);
288         display(&quot;got second StepEvent&quot;);
289 
290         display(&quot;CHECK2 for line location of second StepEvent.&quot;);
291         lineOfEvent = ((LocatableEvent)newEvent).location().lineNumber();
292         if (lineOfEvent != checkedLines[testCase][2]) {
293             complain(&quot;CHECK2 for line location of second StepEvent FAILED for CASE # &quot; + testCase);
294             complain(&quot;\texpected value : &quot; + checkedLines[testCase][2] + &quot;; got one : &quot; + lineOfEvent);
295             exitCode = FAILED;
296         } else {
297             display(&quot;CHECK2 PASSED&quot;);
298         }
299 
300         stepRequest.disable();
301         eventRManager.deleteEventRequest(stepRequest);
302         stepRequest = null;
303         display(&quot;request for StepEvent in &quot; + threadName + &quot; is deleted&quot;);
304     }
305 
306     //--------------------------------------------------------- immutable common methods
307 
308     void display(String msg) {
309         log.display(&quot;debugger &gt; &quot; + msg);
310     }
311 
312     void complain(String msg) {
313         log.complain(&quot;debugger FAILURE &gt; &quot; + msg);
314     }
315 
316    /**
317     * Sets up a breakpoint at given line number within a given method in a given class
318     * for a given thread.
319     *
320     * Returns a BreakpointRequest object in case of success, otherwise throws Failure.
321     */
322     private BreakpointRequest setBreakpoint ( ThreadReference thread,
323                                               ReferenceType testedClass,
324                                               String methodName,
325                                               int bpLine,
326                                               String property) {
327 
328         display(&quot;Setting a breakpoint in :&quot;);
329         display(&quot;  thread: &quot; + thread + &quot;; class: &quot; + testedClass +
330                 &quot;; method: &quot; + methodName + &quot;; line: &quot; + bpLine + &quot;; property: &quot; + property);
331 
332         List allLineLocations = null;
333         Location lineLocation = null;
334         BreakpointRequest breakpRequest = null;
335 
336         try {
337             Method  method  = (Method) testedClass.methodsByName(methodName).get(0);
338 
339             allLineLocations = method.allLineLocations();
340 
341             display(&quot;Getting location for breakpoint...&quot;);
342             Iterator locIterator = allLineLocations.iterator();
343             while (locIterator.hasNext()) {
344                 Location curLocation = (Location)locIterator.next();
345                 int curNumber = curLocation.lineNumber();
346                 if (curLocation.lineNumber() == bpLine) {
347                     lineLocation = curLocation;
348                     break;
349                 }
350             }
351             if (lineLocation == null) {
352                 throw new TestBug(&quot;Incorrect line number of methods&#39; location&quot;);
353             }
354 
355             try {
356                 breakpRequest = eventRManager.createBreakpointRequest(lineLocation);
357                 if (thread != null) {
358                     breakpRequest.addThreadFilter(thread);
359                 }
360                 breakpRequest.putProperty(&quot;number&quot;, property);
361             } catch ( Exception e1 ) {
362                 complain(&quot;setBreakpoint(): unexpected Exception while creating BreakpointRequest: &quot; + e1);
363                 breakpRequest = null;
364             }
365         } catch ( Exception e2 ) {
366             complain(&quot;setBreakpoint(): unexpected Exception while getting locations: &quot; + e2);
367             breakpRequest = null;
368         }
369 
370         if (breakpRequest == null) {
371             throw new Failure(&quot;setBreakpoint(): A breakpoint has not been set up.&quot;);
372         }
373 
374         display(&quot;setBreakpoint(): A breakpoint has been set up.&quot;);
375         return breakpRequest;
376     }
377 
378     private Event waitForEvent (EventRequest eventRequest) {
379         vm.resume();
380         Event resultEvent = null;
381         try {
382             eventSet = null;
383             eventIterator = null;
384             eventSet = vm.eventQueue().remove(waitTime);
385             if (eventSet == null) {
386                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
387             }
388             eventIterator = eventSet.eventIterator();
389             while (eventIterator.hasNext()) {
390                 Event curEvent = eventIterator.nextEvent();
391                 if (curEvent instanceof VMDisconnectEvent) {
392                     throw new Failure(&quot;Unexpected VMDisconnectEvent received.&quot;);
393                 } else {
394                     EventRequest evRequest = curEvent.request();
395                     if (evRequest != null &amp;&amp; evRequest.equals(eventRequest)) {
396                         display(&quot;Requested event received: &quot; + curEvent.toString() +
397                             &quot;; request property: &quot; + (String) curEvent.request().getProperty(&quot;number&quot;));
398                         resultEvent = curEvent;
399                         break;
400                     } else {
401                         throw new Failure(&quot;Unexpected event received: &quot; + curEvent.toString());
402                     }
403                 }
404             }
405         } catch (Exception e) {
406             throw new Failure(&quot;Unexpected exception while waiting for an event: &quot; + e);
407         }
408         return resultEvent;
409     }
410 
411     private Event waitForEvent () {
412         vm.resume();
413         Event resultEvent = null;
414         try {
415             eventSet = null;
416             eventIterator = null;
417             eventSet = vm.eventQueue().remove(waitTime);
418             if (eventSet == null) {
419                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
420             }
421             eventIterator = eventSet.eventIterator();
422             while (eventIterator.hasNext()) {
423                 resultEvent = eventIterator.nextEvent();
424                 if (resultEvent instanceof VMDisconnectEvent) {
425                     throw new Failure(&quot;Unexpected VMDisconnectEvent received.&quot;);
426                 }
427             }
428         } catch (Exception e) {
429             throw new Failure(&quot;Unexpected exception while waiting for an event: &quot; + e);
430         }
431         return resultEvent;
432     }
433 
434     private void getEventSet() {
435         try {
436             eventSet = vm.eventQueue().remove(waitTime);
437             if (eventSet == null) {
438                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
439             }
440             eventIterator = eventSet.eventIterator();
441         } catch (Exception e) {
442             throw new Failure(&quot;getEventSet(): Unexpected exception while waiting for an event: &quot; + e);
443         }
444     }
445 
<a name="2" id="anc2"></a>












446     private ReferenceType waitForDebuggeeClassPrepared () {
447         display(&quot;Creating request for ClassPrepareEvent for debuggee.&quot;);
448         ClassPrepareRequest cpRequest = eventRManager.createClassPrepareRequest();
449         cpRequest.addClassFilter(debuggeeName);
450         cpRequest.addCountFilter(1);
451         cpRequest.enable();
452 
453         ClassPrepareEvent event = (ClassPrepareEvent) waitForEvent(cpRequest);
454         cpRequest.disable();
455 
456         if (!event.referenceType().name().equals(debuggeeName)) {
457            throw new Failure(&quot;Unexpected class name for ClassPrepareEvent : &quot; + debuggeeClass.name());
458         }
459         return event.referenceType();
460     }
461 
462     private int getInstruction () {
463         if (debuggeeClass == null) {
464             throw new Failure(&quot;getInstruction() :: debuggeeClass reference is null&quot;);
465         }
466         return ((IntegerValue) (debuggeeClass.getValue(debuggeeClass.fieldByName(&quot;instruction&quot;)))).value();
467     }
468 
469     private void setInstruction (String instructionField) {
470         if (debuggeeClass == null) {
471             throw new Failure(&quot;getInstruction() :: debuggeeClass reference is null&quot;);
472         }
473         Field instrField = debuggeeClass.fieldByName(&quot;instruction&quot;);
474         IntegerValue instrValue = (IntegerValue) (debuggeeClass.getValue(debuggeeClass.fieldByName(instructionField)));
475         try {
476             ((ClassType)debuggeeClass).setValue(instrField, instrValue );
477         } catch (InvalidTypeException e1) {
478             throw new Failure(&quot;Caught unexpected InvalidTypeException while setting value &#39;&quot; + instructionField + &quot;&#39; for instruction field&quot;);
479         } catch (ClassNotLoadedException e2) {
480             throw new Failure(&quot;Caught unexpected ClassNotLoadedException while setting value &#39;&quot; + instructionField + &quot;&#39; for instruction field&quot;);
481         }
482     }
483 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/contention/TC02/tc02t001.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jvmti.scenarios.contention.TC02;
 25 
 26 import java.io.PrintStream;
 27 
 28 import nsk.share.*;
 29 import nsk.share.jvmti.*;
 30 
 31 //    THIS CLASS IS LINE NUMBER SENSITIVE
 32 
 33 class tc02t001Thread extends Thread {
 34     public Wicket startingBarrier = new Wicket();
 35     public Wicket waitingBarrier1 = new Wicket();
 36     public Wicket waitingBarrier2 = new Wicket();
 37     public Wicket waitingBarrier3 = new Wicket();
 38     public Object M = new Object();
 39 
 40     public tc02t001Thread(String name) {
 41         super(name);
 42     }
 43 
 44     public void run() {
 45         startingBarrier.unlock();
 46 
 47         waitingBarrier1.waitFor();
 48         synchronized (M) { // tc02t001.c::lines[0]
 49             M.notify();
 50         }
 51 
 52         waitingBarrier2.waitFor();
 53         synchronized (M) { // tc02t001.c::lines[1]
 54             M.notify();
 55         }
 56 
 57         waitingBarrier3.waitFor();
 58         synchronized (M) { // tc02t001.c::lines[2]
 59             M.notify();
 60         }
 61     }
 62 }
 63 
 64 /* =================================================================== */
 65 
 66 public class tc02t001 extends DebugeeClass {
 67 
 68     // run test from command line
 69     public static void main(String argv[]) {
 70         argv = nsk.share.jvmti.JVMTITest.commonInit(argv);
 71 
 72         // JCK-compatible exit
 73         System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);
 74     }
 75 
 76     // run test from JCK-compatible environment
 77     public static int run(String argv[], PrintStream out) {
 78         return new tc02t001().runIt(argv, out);
 79     }
 80 
 81     /* =================================================================== */
 82 
 83     // scaffold objects
 84     ArgumentHandler argHandler = null;
 85     Log log = null;
 86     int status = Consts.TEST_PASSED;
 87     static long timeout = 0;
 88 
 89     private static volatile int lastEnterEventsCount;
 90     private static native   int enterEventsCount();
 91 
 92     // tested thread
 93     tc02t001Thread thread = null;
 94 
 95     static void log (String msg) { System.out.println(msg); }
 96 
 97     private void waitForContendedEnterEvent() {
 98         try {
 99             for (int j = 0; j &lt; (timeout / 20); j++) {
100                 Thread.sleep(20);
101                 if (enterEventsCount() &gt; lastEnterEventsCount) {
102                     log(&quot;Got expected MonitorContendedEnter event\n&quot;);
103                     break;
104                 }
105             }
106             if (enterEventsCount() == lastEnterEventsCount) {
107                 String msg = &quot;Timeout in waiting for a MonitorContendedEnter event&quot;;
108                 throw new RuntimeException(msg);
109             }
110             thread.M.wait(timeout);
111         } catch (InterruptedException e) {
112             throw new Failure(e);
113         }
114     }
115 
116     // run debuggee
117     public int runIt(String argv[], PrintStream out) {
118         argHandler = new ArgumentHandler(argv);
119         log = new Log(out, argHandler);
120         timeout = argHandler.getWaitTime() * 60 * 1000;
121         log.display(&quot;Timeout = &quot; + timeout + &quot; msc.&quot;);
122 
123         thread = new tc02t001Thread(&quot;Debuggee Thread&quot;);
124         synchronized (thread.M) {
125             thread.start();
126             thread.startingBarrier.waitFor();
127             status = checkStatus(status);
128 
129             lastEnterEventsCount = enterEventsCount();
130             thread.waitingBarrier1.unlock();
131             log(&quot;Waiting for MonitorEnterEvent #1&quot;);
132             waitForContendedEnterEvent();
133 
134             lastEnterEventsCount = enterEventsCount();
135             thread.waitingBarrier2.unlock();
136             log(&quot;Waiting for MonitorEnterEvent #2&quot;);
137             waitForContendedEnterEvent();
138 
139             lastEnterEventsCount = enterEventsCount();
140             thread.waitingBarrier3.unlock();
141             log(&quot;Waiting for MonitorEnterEvent #3&quot;);
142             waitForContendedEnterEvent();
143         }
144 
145         try {
146             thread.join(timeout);
147         } catch (InterruptedException e) {
148             throw new Failure(e);
149         }
150 
151         log.display(&quot;Debugee finished&quot;);
152         status = checkStatus(status);
153 
154         return status;
155     }
156 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/share/jvmti/jvmti_tools.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../jpda/StateTestThread.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../locks/LockingThread.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/share/jvmti/jvmti_tools.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
506                 jvmtiClassDefinition classDef;
507                 classDef.klass = classToRedefine;
508                 classDef.class_byte_count= size;
509                 classDef.class_bytes = classBytes;
510                 error = jvmti-&gt;RedefineClasses(1,&amp;classDef);
511                 if (error != JVMTI_ERROR_NONE) {
512                     nsk_printf(&quot;# error occured while redefining %s &quot;,
513                             TranslateError(error));
514                     return NSK_FALSE;
515                 }
516             }
517         }
518     }
519     redefineSucceed= NSK_TRUE;
520     return NSK_TRUE;
521 }
522 
523 JNIEXPORT jboolean JNICALL
524 Java_nsk_share_jvmti_RedefineAgent_redefineAttempted(JNIEnv *jni,  jobject obj) {
525 
<span class="line-modified">526     if (redefineAttempted == NSK_TRUE) {</span>
527         return JNI_TRUE;
528     }else {
529         return JNI_FALSE;
530     }
531 }
532 
533 
534 JNIEXPORT jboolean JNICALL
535 Java_nsk_share_jvmti_RedefineAgent_isRedefined(JNIEnv * jni,  jobject obj) {
536 
<span class="line-modified">537     if (redefineSucceed == NSK_TRUE) {</span>
538         return JNI_TRUE;
539     }else {
540         return JNI_FALSE;
541     }
542 }
543 /**
544  * This jni method is a Java wrapper for agent status.
545  */
546 JNIEXPORT jboolean JNICALL
547 Java_nsk_share_jvmti_RedefineAgent_agentStatus(JNIEnv * jni,  jobject obj) {
<span class="line-modified">548     if (agentFailed == NSK_TRUE) {</span>
549         return JNI_FALSE;
550     } else {
551         return JNI_TRUE;
552     }
553 }
554 
555 void nsk_jvmti_getFileName(int redefineCnt, const char * dir,  char * buf, size_t bufsize) {
556    snprintf(buf, bufsize, PATH_FORMAT, DIR_NAME, redefineCnt, dir);
557    buf[bufsize-1] = &#39;\0&#39;;
558 }
559 
560 int nsk_jvmti_enableNotification(jvmtiEnv *jvmti,jvmtiEvent event, jthread thread) {
561     jvmtiError rc=JVMTI_ERROR_NONE;
562     rc = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, thread);
563     if (rc != JVMTI_ERROR_NONE) {
564         nsk_printf(&quot;# error Failed to set Notification for Event \n &quot;);
565         return NSK_FALSE;
566     }
567     return NSK_TRUE;
568 }
569 
570 int nsk_jvmti_disableNotification(jvmtiEnv *jvmti,jvmtiEvent event, jthread thread) {
571   jvmtiError rc=JVMTI_ERROR_NONE;
572   rc = jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE, event, thread);
573   if (rc != JVMTI_ERROR_NONE) {
574       nsk_printf(&quot; Failed to disaable Notification for Event &quot;);
575       return NSK_FALSE;
576   }
577   return NSK_TRUE;
578 }
579 
580 void nsk_jvmti_agentFailed() {
581     agentFailed = NSK_TRUE;
582 }
583 
584 int isThreadExpected(jvmtiEnv *jvmti, jthread thread) {
585     static const char *vm_jfr_buffer_thread_name = &quot;VM JFR Buffer Thread&quot;;
586     static const char *jfr_request_timer_thread_name = &quot;JFR request timer&quot;;




587 
588     jvmtiThreadInfo threadinfo;
589     NSK_JVMTI_VERIFY(jvmti-&gt;GetThreadInfo(thread, &amp;threadinfo));
590 
591     if (strcmp(threadinfo.name, vm_jfr_buffer_thread_name) == 0)
592         return 0;
593 
594     if (strcmp(threadinfo.name, jfr_request_timer_thread_name) == 0)
595         return 0;
596 







597     return 1;
598 }
599 
600 #define SLEEP_DELAY 10L
601 
602 int suspendThreadAtMethod(jvmtiEnv *jvmti, jclass cls, jobject thread, jmethodID testMethod) {
603     printf(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Invoke SuspendThread()\n&quot;);
604 
605     jvmtiError err = jvmti-&gt;SuspendThread(thread);
606     if (err != JVMTI_ERROR_NONE) {
607         printf(&quot;%s: Failed to call SuspendThread(): error=%d: %s\n&quot;,
608                __FILE__, err, TranslateError(err));
609         return NSK_FALSE;
610     }
611 
612     int result = NSK_TRUE;
613     jmethodID method = NULL;
614     jlocation loc;
615 
616     // We need to ensure that the thread is suspended at the right place when the top
</pre>
</td>
<td>
<hr />
<pre>
506                 jvmtiClassDefinition classDef;
507                 classDef.klass = classToRedefine;
508                 classDef.class_byte_count= size;
509                 classDef.class_bytes = classBytes;
510                 error = jvmti-&gt;RedefineClasses(1,&amp;classDef);
511                 if (error != JVMTI_ERROR_NONE) {
512                     nsk_printf(&quot;# error occured while redefining %s &quot;,
513                             TranslateError(error));
514                     return NSK_FALSE;
515                 }
516             }
517         }
518     }
519     redefineSucceed= NSK_TRUE;
520     return NSK_TRUE;
521 }
522 
523 JNIEXPORT jboolean JNICALL
524 Java_nsk_share_jvmti_RedefineAgent_redefineAttempted(JNIEnv *jni,  jobject obj) {
525 
<span class="line-modified">526     if (redefineAttempted) {</span>
527         return JNI_TRUE;
528     }else {
529         return JNI_FALSE;
530     }
531 }
532 
533 
534 JNIEXPORT jboolean JNICALL
535 Java_nsk_share_jvmti_RedefineAgent_isRedefined(JNIEnv * jni,  jobject obj) {
536 
<span class="line-modified">537     if (redefineSucceed) {</span>
538         return JNI_TRUE;
539     }else {
540         return JNI_FALSE;
541     }
542 }
543 /**
544  * This jni method is a Java wrapper for agent status.
545  */
546 JNIEXPORT jboolean JNICALL
547 Java_nsk_share_jvmti_RedefineAgent_agentStatus(JNIEnv * jni,  jobject obj) {
<span class="line-modified">548     if (agentFailed) {</span>
549         return JNI_FALSE;
550     } else {
551         return JNI_TRUE;
552     }
553 }
554 
555 void nsk_jvmti_getFileName(int redefineCnt, const char * dir,  char * buf, size_t bufsize) {
556    snprintf(buf, bufsize, PATH_FORMAT, DIR_NAME, redefineCnt, dir);
557    buf[bufsize-1] = &#39;\0&#39;;
558 }
559 
560 int nsk_jvmti_enableNotification(jvmtiEnv *jvmti,jvmtiEvent event, jthread thread) {
561     jvmtiError rc=JVMTI_ERROR_NONE;
562     rc = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, thread);
563     if (rc != JVMTI_ERROR_NONE) {
564         nsk_printf(&quot;# error Failed to set Notification for Event \n &quot;);
565         return NSK_FALSE;
566     }
567     return NSK_TRUE;
568 }
569 
570 int nsk_jvmti_disableNotification(jvmtiEnv *jvmti,jvmtiEvent event, jthread thread) {
571   jvmtiError rc=JVMTI_ERROR_NONE;
572   rc = jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE, event, thread);
573   if (rc != JVMTI_ERROR_NONE) {
574       nsk_printf(&quot; Failed to disaable Notification for Event &quot;);
575       return NSK_FALSE;
576   }
577   return NSK_TRUE;
578 }
579 
580 void nsk_jvmti_agentFailed() {
581     agentFailed = NSK_TRUE;
582 }
583 
584 int isThreadExpected(jvmtiEnv *jvmti, jthread thread) {
585     static const char *vm_jfr_buffer_thread_name = &quot;VM JFR Buffer Thread&quot;;
586     static const char *jfr_request_timer_thread_name = &quot;JFR request timer&quot;;
<span class="line-added">587     static const char *graal_management_bean_registration_thread_name =</span>
<span class="line-added">588                                             &quot;HotSpotGraalManagement Bean Registration&quot;;</span>
<span class="line-added">589     static const char *graal_compiler_thread_name_prefix = &quot;JVMCI CompilerThread&quot;;</span>
<span class="line-added">590     static const size_t prefixLength = strlen(graal_compiler_thread_name_prefix);</span>
591 
592     jvmtiThreadInfo threadinfo;
593     NSK_JVMTI_VERIFY(jvmti-&gt;GetThreadInfo(thread, &amp;threadinfo));
594 
595     if (strcmp(threadinfo.name, vm_jfr_buffer_thread_name) == 0)
596         return 0;
597 
598     if (strcmp(threadinfo.name, jfr_request_timer_thread_name) == 0)
599         return 0;
600 
<span class="line-added">601     if (strcmp(threadinfo.name, graal_management_bean_registration_thread_name) == 0)</span>
<span class="line-added">602         return 0;</span>
<span class="line-added">603 </span>
<span class="line-added">604     if ((strlen(threadinfo.name) &gt; prefixLength) &amp;&amp;</span>
<span class="line-added">605          strncmp(threadinfo.name, graal_compiler_thread_name_prefix, prefixLength) == 0)</span>
<span class="line-added">606         return 0;</span>
<span class="line-added">607 </span>
608     return 1;
609 }
610 
611 #define SLEEP_DELAY 10L
612 
613 int suspendThreadAtMethod(jvmtiEnv *jvmti, jclass cls, jobject thread, jmethodID testMethod) {
614     printf(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Invoke SuspendThread()\n&quot;);
615 
616     jvmtiError err = jvmti-&gt;SuspendThread(thread);
617     if (err != JVMTI_ERROR_NONE) {
618         printf(&quot;%s: Failed to call SuspendThread(): error=%d: %s\n&quot;,
619                __FILE__, err, TranslateError(err));
620         return NSK_FALSE;
621     }
622 
623     int result = NSK_TRUE;
624     jmethodID method = NULL;
625     jlocation loc;
626 
627     // We need to ensure that the thread is suspended at the right place when the top
</pre>
</td>
</tr>
</table>
<center><a href="../jpda/StateTestThread.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../locks/LockingThread.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
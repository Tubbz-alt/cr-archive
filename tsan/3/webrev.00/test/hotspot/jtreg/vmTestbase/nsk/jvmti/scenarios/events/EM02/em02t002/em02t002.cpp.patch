diff a/test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t002/em02t002.cpp b/test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t002/em02t002.cpp
--- a/test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t002/em02t002.cpp
+++ b/test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t002/em02t002.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -67,16 +67,16 @@
 
 /**
  * Testcase: check tested events.
  *   - check if expected events received for each method
  *
- * Returns NSK_TRUE if test may continue; or NSK_FALSE for test break.
+ * Returns true if test may continue; or false for test break.
  */
-int checkEvents(int step) {
+bool checkEvents(int step) {
     int i;
     jvmtiEvent curr;
-    int result = NSK_TRUE;
+    bool result = true;
     int *currentCounts;
     int isExpected = 0;
 
     int ind_start = JVMTI_EVENT_GARBAGE_COLLECTION_START - JVMTI_MIN_EVENT_TYPE_VAL;
     int ind_fnsh = JVMTI_EVENT_GARBAGE_COLLECTION_FINISH - JVMTI_MIN_EVENT_TYPE_VAL;
@@ -91,21 +91,21 @@
             currentCounts = &newEventCount[0];
             break;
 
         default:
             NSK_COMPLAIN1("Unexpected step no: %d\n", step);
-            return NSK_FALSE;
+            return false;
     }
 
     if (currentCounts[ind_start] != currentCounts[ind_fnsh]) {
 
         NSK_COMPLAIN0("Amounts of events are not equal\n");
         NSK_COMPLAIN1("\tGARBAGE_COLLECTION_START:\t%6d\n",
                             currentCounts[ind_start]);
         NSK_COMPLAIN1("\tGARBAGE_COLLECTION_FINISH:\t%6d\n",
                             currentCounts[ind_fnsh]);
-        return NSK_FALSE;
+        return false;
     }
 
     for (i = 0; i < JVMTI_EVENT_COUNT; i++) {
 
         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
@@ -130,18 +130,18 @@
         if (isExpected) {
             if (currentCounts[i] < 1) {
                     NSK_COMPLAIN2("Unexpected events number %7d for %s\n\texpected value must be greater than 1\n",
                                         currentCounts[i],
                                         TranslateEvent(curr));
-                result = NSK_FALSE;
+                result = false;
             }
         } else {
             if (currentCounts[i] > 0) {
                 NSK_COMPLAIN2("Unexpected event %s was sent %d times\n",
                                     TranslateEvent(curr),
                                     currentCounts[i]);
-                result = NSK_FALSE;
+                result = false;
             }
         }
     }
 
     return result;
@@ -336,35 +336,35 @@
     handlerMC2(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH);
 }
 
 /* ============================================================================= */
 
-static int enableEvent(jvmtiEvent event) {
+static bool enableEvent(jvmtiEvent event) {
 
     if (nsk_jvmti_isOptionalEvent(event)
             && (event != JVMTI_EVENT_GARBAGE_COLLECTION_START)
             && (event != JVMTI_EVENT_GARBAGE_COLLECTION_FINISH)) {
         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
                 jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
             NSK_COMPLAIN1("Unexpected error enabling %s\n",
                 TranslateEvent(event));
-            return NSK_FALSE;
+            return false;
         }
     } else {
         if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
             NSK_COMPLAIN1("Unexpected error enabling %s\n",
                 TranslateEvent(event));
-            return NSK_FALSE;
+            return false;
         }
     }
 
-    return NSK_TRUE;
+    return true;
 }
 
-static int enableEventList() {
+static bool enableEventList() {
     int i;
-    int result = NSK_TRUE;
+    bool result = true;
 
     NSK_DISPLAY0("Enable events\n");
 
     result = enableEvent(JVMTI_EVENT_VM_INIT);
 
@@ -376,22 +376,21 @@
 
         if (nsk_jvmti_isOptionalEvent(event))
             result = result && enableEvent(event);
     }
 
-    if (result == NSK_FALSE) {
+    if (!result) {
         nsk_jvmti_setFailStatus();
-        return NSK_FALSE;
+        return false;
     }
 
-    return NSK_TRUE;
+    return true;
 }
 
 /* ============================================================================= */
 
-static int
-setCallBacks(int step) {
+static bool setCallBacks(int step) {
 
     int i;
 
     jvmtiEventCallbacks eventCallbacks;
     memset(&eventCallbacks, 0, sizeof(eventCallbacks));
@@ -445,13 +444,13 @@
             eventCallbacks.VMDeath                   = cbVMDeath;
             break;
 
     }
     if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&eventCallbacks, sizeof(eventCallbacks))))
-        return NSK_FALSE;
+        return false;
 
-    return NSK_TRUE;
+    return true;
 }
 
 /* ============================================================================= */
 
 /** Agent algorithm. */

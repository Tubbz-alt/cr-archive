<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jdi/ListeningConnector/startListening/startlis001.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.ListeningConnector.startListening;
 25 
 26 import com.sun.jdi.Bootstrap;
 27 import com.sun.jdi.connect.*;
 28 import com.sun.jdi.VirtualMachine;
 29 
 30 import java.io.*;
 31 
 32 import java.net.InetAddress;
 33 import java.net.UnknownHostException;
 34 
<a name="2" id="anc2"></a><span class="line-added"> 35 import java.util.Arrays;</span>
 36 import java.util.Iterator;
<a name="3" id="anc3"></a><span class="line-added"> 37 import java.util.LinkedList;</span>
 38 import java.util.List;
 39 import java.util.Map;
<a name="4" id="anc4"></a><span class="line-added"> 40 import java.util.stream.Collectors;</span>
 41 
 42 import nsk.share.*;
 43 import nsk.share.jpda.*;
 44 import nsk.share.jdi.*;
 45 
 46 
 47 /**
 48  * The test exercises JDI function &lt;code&gt;ListeningConnector.startListening&lt;/code&gt;.
 49  * The &lt;b&gt;Socket Listening Connector&lt;/b&gt; is using as listening
 50  * connector.&lt;br&gt;
 51  * The test cases include:
 52  * &lt;li&gt; checking that listening address returned by
 53  * &lt;code&gt;ListeningConnector.startListening()&lt;/code&gt; matches the address
 54  * which was set via connector&#39;s arguments;
 55  * &lt;li&gt; checking that address generated by
 56  * &lt;code&gt;ListeningConnector.startListening()&lt;/code&gt; is valid i.e.
 57  * debugee VM is accessible via this address.
 58  */
 59 public class startlis001 {
 60     static final int PASSED = 0;
 61     static final int FAILED = 2;
 62     static final int JCK_STATUS_BASE = 95;
 63     static final String CONNECTOR_NAME =
 64         &quot;com.sun.jdi.SocketListen&quot;;
 65     static final String DEBUGEE_CLASS =
 66         &quot;nsk.jdi.ListeningConnector.startListening.startlis001t&quot;;
 67 
 68     private Log log;
 69 
 70     private VirtualMachine vm;
 71     private ListeningConnector connector;
 72     private Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; connArgs;
 73     private PrintStream out;
 74 
 75     IORedirector outRedirector;
 76     IORedirector errRedirector;
 77 
 78     boolean totalRes = true;
 79 
 80     public static void main (String argv[]) {
 81         System.exit(run(argv,System.out) + JCK_STATUS_BASE);
 82     }
 83 
 84     public static int run(String argv[], PrintStream out) {
 85         return new startlis001().runIt(argv, out);
 86     }
 87 
 88     private int runIt(String argv[], PrintStream out) {
 89         String port;
 90         String addr;
<a name="5" id="anc5"></a>
 91         ArgumentHandler argHandler = new ArgumentHandler(argv);
 92 
 93 // pass if CONNECTOR_NAME is not implemented
 94 // on this platform
 95         if (argHandler.shouldPass(CONNECTOR_NAME))
 96             return PASSED;
 97         this.out = out;
 98         log = new Log(out, argHandler);
 99 
100         long timeout = argHandler.getWaitTime() * 60 * 1000;
101 
<a name="6" id="anc6"></a><span class="line-modified">102         /* Check that listening address returned by ListeningConnector.startListening()</span>
<span class="line-modified">103          * matches the address which was set via connector&#39;s arguments.</span>
<span class="line-added">104          * Empty host address causes listening for local connections only (loopback interface).</span>
<span class="line-added">105          * */</span>
<span class="line-added">106         String hostname = &quot;localhost&quot;;</span>
<span class="line-added">107         List&lt;String&gt; validAddresses = new LinkedList&lt;&gt;();</span>
<span class="line-added">108         validAddresses.add(hostname);</span>
109         try {
<a name="7" id="anc7"></a><span class="line-modified">110             Arrays.stream(InetAddress.getAllByName(hostname))</span>
<span class="line-added">111                     .forEach(address -&gt; validAddresses.add(address.getHostAddress()));</span>
112         } catch (UnknownHostException e) {
113             log.complain(&quot;FAILURE: caught UnknownHostException &quot; +
<a name="8" id="anc8"></a><span class="line-modified">114                     e.getMessage());</span>
115             totalRes = false;
116         }
<a name="9" id="anc9"></a><span class="line-modified">117 </span>

118         port = argHandler.getTransportPortIfNotDynamic();
119 
120         initConnector(port);
121         if ((addr = startListen()) == null) {
122             log.complain(&quot;Test case #1 FAILED: unable to start listening&quot;);
123             totalRes = false;
<a name="10" id="anc10"></a><span class="line-modified">124         } else {</span>
<span class="line-modified">125             String validAddrList = validAddresses.stream()</span>
<span class="line-added">126                     .map(value -&gt; value + &quot;:&quot; + port)</span>
<span class="line-added">127                     .collect(Collectors.joining(&quot; or &quot;));</span>
128             log.display(&quot;Test case #1: start listening the address &quot; + addr);
<a name="11" id="anc11"></a><span class="line-modified">129             log.display(&quot;Expected addresses: &quot; + validAddrList);</span>
<span class="line-modified">130             final String listenAddr = addr;</span>
<span class="line-modified">131             boolean isValid = validAddresses.stream()</span>
<span class="line-modified">132                     .anyMatch(value -&gt; listenAddr.startsWith(value) &amp;&amp; (port == null || listenAddr.endsWith(port)));</span>
<span class="line-added">133             if (!isValid) {</span>
134                 log.complain(&quot;Test case #1 FAILED: listening address &quot; + addr +
<a name="12" id="anc12"></a><span class="line-modified">135                     &quot;\ndoes not match expected address:\n&quot; + validAddrList);</span>


136                 totalRes = false;
137             }
138             if (!stopListen()) {
139                 log.complain(&quot;TEST: unable to stop listening #1&quot;);
140                 totalRes = false;
141             }
142             else
143                log.display(&quot;Test case #1 PASSED: listening address matches expected address&quot;);
144         }
145 
<a name="13" id="anc13"></a><span class="line-modified">146         /* Check that an address generated by ListeningConnector.startListening()</span>
<span class="line-modified">147            is valid i.e. debugee VM is accessible via this address */</span>
148         initConnector(null);
149         if ((addr = startListen()) == null) {
150             log.complain(&quot;Test case #2 FAILED: unable to start listening&quot;);
151             return FAILED;
152         }
153         else
154             log.display(&quot;Test case #2: start listening the address &quot; + addr);
155 
156         String java = argHandler.getLaunchExecPath()
157                           + &quot; &quot; + argHandler.getLaunchOptions();
158 
159         String cmd = java +
160             &quot; -Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=n,address=&quot; +
161             addr + &quot; &quot; + DEBUGEE_CLASS;
162 
163         Binder binder = new Binder(argHandler, log);
164         Debugee debugee = null;
165 
166         log.display(&quot;command: &quot; + cmd);
167         try {
168             debugee = binder.startLocalDebugee(cmd);
169             debugee.redirectOutput(log);
170         } catch (Exception e) {
171             stopListen();
172             throw new Failure(e);
173         }
174 
175         if ((vm = attachTarget()) == null) {
176             log.complain(&quot;Test case #2 FAILED: unable to attach the debugee VM&quot;);
177             debugee.close();
178             stopListen();
179             return FAILED;
180         }
181         else
182             log.display(&quot;Test case #2 PASSED: successfully attach the debugee VM&quot;);
183 
184         if (!stopListen()) {
185             log.complain(&quot;TEST: unable to stop listening #2&quot;);
186             debugee.close();
187             return FAILED;
188         }
189 
190         debugee.setupVM(vm);
191         debugee.waitForVMInit(timeout);
192 
193         log.display(&quot;\nResuming debugee VM&quot;);
194         debugee.resume();
195 
196         log.display(&quot;\nWaiting for debugee VM exit&quot;);
197         int code = debugee.waitFor();
198         if (code != (JCK_STATUS_BASE+PASSED)) {
199             log.complain(&quot;Debugee VM has crashed: exit code=&quot; +
200                 code);
201             return FAILED;
202         }
203         log.display(&quot;Debugee VM: exit code=&quot; + code);
204 
205         if (totalRes) return PASSED;
206         else return FAILED;
207     }
208 
209     private VirtualMachine attachTarget() {
210         try {
211             return connector.accept(connArgs);
212         } catch (IOException e) {
213             log.complain(&quot;FAILURE: caught IOException: &quot; +
214                 e.getMessage());
215             e.printStackTrace(out);
216             return null;
217         } catch (IllegalConnectorArgumentsException e) {
218             log.complain(&quot;FAILURE: Illegal connector arguments: &quot; +
219                 e.getMessage());
220             e.printStackTrace(out);
221             return null;
222         } catch (Exception e) {
223             log.complain(&quot;FAILURE: Exception: &quot; +
224                 e.getMessage());
225             e.printStackTrace(out);
226             return null;
227         }
228     }
229 
230     private void initConnector(String port) {
231         Connector.Argument arg;
232 
233         connector = (ListeningConnector)
234             findConnector(CONNECTOR_NAME);
235 
236         connArgs = connector.defaultArguments();
237         Iterator cArgsValIter = connArgs.keySet().iterator();
238         while (cArgsValIter.hasNext()) {
239             String argKey = (String) cArgsValIter.next();
240             String argVal = null;
241 
242             if ((arg = (Connector.Argument) connArgs.get(argKey)) == null) {
243                 log.complain(&quot;Argument &quot; + argKey.toString() +
244                     &quot;is not defined for the connector: &quot; +
245                     connector.name());
246             }
247             if (arg.name().equals(&quot;port&quot;) &amp;&amp; port != null)
248                 arg.setValue(port);
249 
250             log.display(&quot;\targument name=&quot; + arg.name());
251             if ((argVal = arg.value()) != null)
252                 log.display(&quot;\t\tvalue=&quot; + argVal);
253             else log.display(&quot;\t\tvalue=NULL&quot;);
254         }
255     }
256 
257     private String startListen() {
258         try {
259             return connector.startListening(connArgs);
260         } catch (IOException e) {
261             log.complain(&quot;FAILURE: caught IOException: &quot; +
262                 e.getMessage());
263             e.printStackTrace(out);
264             return null;
265         } catch (IllegalConnectorArgumentsException e) {
266             log.complain(&quot;FAILURE: Illegal connector arguments: &quot; +
267                 e.getMessage());
268             e.printStackTrace(out);
269             return null;
270         } catch (Exception e) {
271             log.complain(&quot;FAILURE: Exception: &quot; + e.getMessage());
272             e.printStackTrace(out);
273             return null;
274         }
275     }
276 
277     private boolean stopListen() {
278         try {
279             connector.stopListening(connArgs);
280         } catch (IOException e) {
281             log.complain(&quot;FAILURE: caught IOException: &quot; +
282                 e.getMessage());
283             e.printStackTrace(out);
284             return false;
285         } catch (IllegalConnectorArgumentsException e) {
286             log.complain(&quot;FAILURE: Illegal connector arguments: &quot; +
287                 e.getMessage());
288             e.printStackTrace(out);
289             return false;
290         } catch (Exception e) {
291             log.complain(&quot;FAILURE: Exception: &quot; + e.getMessage());
292             e.printStackTrace(out);
293             return false;
294         }
295 
296         return true;
297     }
298 
299     private Connector findConnector(String connectorName) {
300         List connectors = Bootstrap.virtualMachineManager().allConnectors();
301         Iterator iter = connectors.iterator();
302 
303         while (iter.hasNext()) {
304             Connector connector = (Connector) iter.next();
305             if (connector.name().equals(connectorName)) {
306                 log.display(&quot;Connector name=&quot; + connector.name() +
307                     &quot;\n\tdescription=&quot; + connector.description() +
308                     &quot;\n\ttransport=&quot; + connector.transport().name());
309                 return connector;
310             }
311         }
312         throw new Error(&quot;No appropriate connector&quot;);
313     }
314 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/share/jdi/Binder.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package nsk.share.jdi;
  25 
  26 import nsk.share.*;
  27 import nsk.share.jpda.*;
  28 
  29 import com.sun.jdi.*;
  30 import com.sun.jdi.connect.*;
  31 
  32 import com.sun.jdi.connect.Connector.Argument;
  33 import java.io.*;
  34 import java.net.*;
  35 import java.util.*;
  36 
  37 /**
  38  * This class provides debugger with connection to debugee VM
  39  * using JDI connectors.
  40  *&lt;p&gt;
  41  * This class provides abilities to launch and bind to debugee VM
  42  * as described for base &lt;code&gt;DebugeeBinder&lt;/code&gt; class,
  43  * using JDI connectors and &lt;code&gt;com.sun.VirtualMachine&lt;/code&gt; mirror.
  44  * &lt;p&gt;
  45  * When &lt;code&gt;Binder&lt;/code&gt; is asked to bind to debugee by invoking
  46  * &lt;code&gt;bindToBebugee()&lt;/code&gt; method it uses
  47  * &lt;code&gt;com.sun.jdi.Connector&lt;/code&gt; object corresponding to
  48  * value of command line options &lt;code&gt;-connector&lt;/code&gt; and
  49  * &lt;code&gt;-transport&lt;/code&gt; to launch and connect to debugee VM.
  50  * After debugee is launched and connection is established
  51  * &lt;code&gt;Binder&lt;/code&gt; uses &lt;code&gt;com.sun.jdi.VirtualMachine&lt;/code&gt;
  52  * object to construct &lt;code&gt;Debugee&lt;/code&gt; object, that
  53  * provides abilities to interact with debugee VM.
  54  *
  55  * @see Debugee
  56  * @see DebugeeBinder
  57  */
  58 public class Binder extends DebugeeBinder {
  59 
  60     /**
  61      * Default message prefix for &lt;code&gt;Binder&lt;/code&gt; object.
  62      */
  63     public static final String LOG_PREFIX = &quot;binder&gt; &quot;;
  64 
  65     /**
  66      * Get version string.
  67      */
  68     public static String getVersion () {
  69         return &quot;@(#)Binder.java 1.14 03/10/08&quot;;
  70     }
  71 
  72     // -------------------------------------------------- //
  73 
  74     /**
  75      * Handler of command line arguments.
  76      */
  77     private ArgumentHandler argumentHandler = null;
  78 
  79     /**
  80      * Return &lt;code&gt;argumentHandler&lt;/code&gt; of this binder.
  81      */
  82     public ArgumentHandler getArgumentHandler() {
  83         return argumentHandler;
  84     }
  85 
  86     // -------------------------------------------------- //
  87 
  88     /**
  89      * Make &lt;code&gt;Binder&lt;/code&gt; object and pass raw command line arguments.
  90      *
  91      * @deprecated  Use newer
  92      *              &lt;code&gt;Binder(ArgumentHandler,Log)&lt;/code&gt;
  93      *              constructor.
  94      */
  95     public Binder (String args[]) {
  96         this(args, new Log(System.err));
  97     }
  98 
  99     /**
 100      * Make &lt;code&gt;Binder&lt;/code&gt; object for raw command line arguments
 101      * and specified &lt;code&gt;log&lt;/code&gt; object.
 102      *
 103      * @deprecated  Use newer
 104      *              &lt;code&gt;Binder(ArgumentHandler,Log)&lt;/code&gt;
 105      *              constructor.
 106      */
 107     public Binder (String args[], Log log) {
 108         this(new ArgumentHandler(args), log);
 109     }
 110 
 111     /**
 112      * Make &lt;code&gt;Binder&lt;/code&gt; object for specified command line arguments
 113      * and &lt;code&gt;log&lt;/code&gt; object.
 114      */
 115     public Binder (ArgumentHandler argumentHandler, Log log) {
 116         super(argumentHandler, log);
 117         this.argumentHandler = argumentHandler;
 118     }
 119 
 120     // -------------------------------------------------- //
 121 
 122     /**
 123      * Make initial &lt;code&gt;Debugee&lt;/code&gt; object for local debuggee process
 124      * started with launching connector.
 125      */
 126     public Debugee makeLocalDebugee(Process process) {
 127         LocalLaunchedDebugee debugee = new LocalLaunchedDebugee(process, this);
 128 
 129         Finalizer finalizer = new Finalizer(debugee);
 130         finalizer.activate();
 131 
 132         return debugee;
 133     }
 134 
 135     /**
 136      * Launch local debuggee process with specified command line
 137      * and make initial &lt;code&gt;Debugee&lt;/code&gt; object.
 138      */
 139     public Debugee startLocalDebugee(String cmd) {
 140         Process process = null;
 141 
 142         try {
 143             process = launchProcess(cmd);
 144         } catch (IOException e) {
 145             e.printStackTrace(log.getOutStream());
 146             throw new Failure(&quot;Caught exception while launching local debuggee VM process:\n\t&quot;
 147                             + e);
 148         }
 149 
 150         return makeLocalDebugee(process);
 151     }
 152 
 153     /**
 154      * Make debuggee wrapper for already launched debuggee VM.
 155      * After enwraping debugee&#39;s output is redirected to Binder&#39;s log,
 156      * VMStartEvent is received and debuggee is initialized.
 157      */
 158     public Debugee enwrapDebugee(VirtualMachine vm, Process proc) {
 159         Debugee debugee = makeLocalDebugee(proc);
 160 
 161         display(&quot;Redirecting VM output&quot;);
 162         debugee.redirectOutput(log);
 163         debugee.setupVM(vm);
 164 
 165         long timeout = argumentHandler.getWaitTime() * 60 * 1000; // milliseconds
 166 
 167         display(&quot;Waiting for VM initialized&quot;);
 168         debugee.waitForVMInit(timeout);
 169 
 170         return debugee;
 171     }
 172 
 173     /**
 174      * Launch debugee VM and establish connection to it without waiting for VMStartEvent.
 175      * After launching debugee&#39;s output is redirected to Binder&#39;s log,
 176      * but VMStartEvent is not received and so debuggee is not fully initialized.
 177      *
 178      * @see #bindToDebugee(String)
 179      */
 180     public Debugee bindToDebugeeNoWait(String classToExecute) {
 181 
 182         VirtualMachineManager vmm = Bootstrap.virtualMachineManager();
 183         display(&quot;VirtualMachineManager: version &quot;
 184                 + vmm.majorInterfaceVersion() + &quot;.&quot;
 185                 + vmm.minorInterfaceVersion());
 186 
 187         Debugee debugee = null;
 188 
 189         String classPath = null;
 190 //        classPath = System.getProperty(&quot;java.class.path&quot;);
 191 
 192         prepareForPipeConnection(argumentHandler);
 193 
 194         if (argumentHandler.isLaunchedLocally()) {
 195 
 196             if (argumentHandler.isDefaultConnector()) {
 197                 debugee = localDefaultLaunchDebugee(vmm, classToExecute, classPath);
 198             } else if (argumentHandler.isRawLaunchingConnector()) {
 199                 debugee = localRawLaunchDebugee(vmm, classToExecute, classPath);
 200             } else if (argumentHandler.isLaunchingConnector()) {
 201                 debugee = localLaunchDebugee(vmm, classToExecute, classPath);
 202             } else if (argumentHandler.isAttachingConnector()) {
 203                 debugee = localLaunchAndAttachDebugee(vmm, classToExecute, classPath);
 204             } else if (argumentHandler.isListeningConnector()) {
 205                 debugee = localLaunchAndListenDebugee(vmm, classToExecute, classPath);
 206             } else {
 207                 throw new TestBug(&quot;Unexpected connector type for local debugee launch mode&quot;
 208                                   + argumentHandler.getConnectorType());
 209             }
 210 
 211         } else if (argumentHandler.isLaunchedRemotely()) {
 212 
 213             connectToBindServer(classToExecute);
 214 
 215             if (argumentHandler.isAttachingConnector()) {
 216                 debugee = remoteLaunchAndAttachDebugee(vmm, classToExecute, classPath);
 217             } else if (argumentHandler.isListeningConnector()) {
 218                 debugee = remoteLaunchAndListenDebugee(vmm, classToExecute, classPath);
 219             } else {
 220                 throw new TestBug(&quot;Unexpected connector type for remote debugee launch mode&quot;
 221                                   + argumentHandler.getConnectorType());
 222             }
 223 
 224         } else if (argumentHandler.isLaunchedManually()) {
 225 
 226             if (argumentHandler.isAttachingConnector()) {
 227                 debugee = manualLaunchAndAttachDebugee(vmm, classToExecute, classPath);
 228             } else if (argumentHandler.isListeningConnector()) {
 229                 debugee = manualLaunchAndListenDebugee(vmm, classToExecute, classPath);
 230             } else {
 231                 throw new TestBug(&quot;Unexpected connector type for manual debugee launch mode&quot;
 232                                   + argumentHandler.getConnectorType());
 233             }
 234 
 235         } else {
 236             throw new Failure(&quot;Unexpected debugee launching mode: &quot; + argumentHandler.getLaunchMode());
 237         }
 238 
 239         return debugee;
 240     }
 241 
 242     /**
 243      * Launch debugee VM and establish JDI connection.
 244      * After launching debugee&#39;s output is redirected to Binder&#39;s log,
 245      * VMStart event is received and debuggee is initialized.
 246      *
 247      * @see #bindToDebugeeNoWait(String)
 248      */
 249     public Debugee bindToDebugee(String classToExecute) {
 250         Debugee debugee = bindToDebugeeNoWait(classToExecute);
 251 
 252         if(argumentHandler.getOptions().getProperty(&quot;traceAll&quot;) != null)
 253             debugee.VM().setDebugTraceMode(VirtualMachine.TRACE_ALL);
 254 
 255         long timeout = argumentHandler.getWaitTime() * 60 * 1000; // milliseconds
 256 
 257         display(&quot;Waiting for VM initialized&quot;);
 258         debugee.waitForVMInit(timeout);
 259 
 260         return debugee;
 261     }
 262 
 263     // -------------------------------------------------- //
 264 
 265     /**
 266      * Launch debugee locally via the default LaunchingConnector.
 267      */
 268     private Debugee localDefaultLaunchDebugee (VirtualMachineManager vmm,
 269                                                 String classToExecute,
 270                                                 String classPath) {
 271         display(&quot;Finding connector: &quot; + &quot;default&quot; );
 272         LaunchingConnector connector = vmm.defaultConnector();
 273         Map&lt;String,? extends Argument&gt; arguments = setupLaunchingConnector(connector, classToExecute, classPath);
 274 
 275         VirtualMachine vm;
 276         try {
 277             display(&quot;Launching debugee&quot;);
 278             vm = connector.launch(arguments);
 279         } catch (IllegalConnectorArgumentsException e) {
 280             e.printStackTrace(log.getOutStream());
 281             throw new TestBug(&quot;Wrong connector arguments used to launch debuggee VM:\n\t&quot; + e);
 282         } catch (VMStartException e) {
 283             e.printStackTrace(log.getOutStream());
 284             String msg = readVMStartExceptionOutput(e, log.getOutStream());
 285             throw new Failure(&quot;Caught exception while starting debugee VM:\n\t&quot; + e + &quot;\n&quot; + msg);
 286         } catch (IOException e) {
 287             e.printStackTrace(log.getOutStream());
 288             throw new Failure(&quot;Caught exception while launching debugee VM:\n\t&quot; + e);
 289         };
 290 
 291         Process process = vm.process();
 292         Debugee debugee = makeLocalDebugee(process);
 293         debugee.redirectOutput(log);
 294         debugee.setupVM(vm);
 295 
 296         return debugee;
 297     }
 298 
 299 
 300     /**
 301      * Launch debugee locally via the default LaunchingConnector.
 302      */
 303     private Debugee localLaunchDebugee (VirtualMachineManager vmm,
 304                                             String classToExecute,
 305                                             String classPath) {
 306 
 307         display(&quot;Finding connector: &quot; + argumentHandler.getConnectorName() );
 308         LaunchingConnector connector =
 309             (LaunchingConnector) findConnector(argumentHandler.getConnectorName(),
 310                                                 vmm.launchingConnectors());
 311         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupLaunchingConnector(connector, classToExecute, classPath);
 312 
 313         VirtualMachine vm;
 314         try {
 315             display(&quot;Launching debugee&quot;);
 316             vm = connector.launch(arguments);
 317         } catch (IllegalConnectorArgumentsException e) {
 318             e.printStackTrace(log.getOutStream());
 319             throw new TestBug(&quot;Wrong connector arguments used to launch debuggee VM:\n\t&quot; + e);
 320         } catch (VMStartException e) {
 321             e.printStackTrace(log.getOutStream());
 322             String msg = readVMStartExceptionOutput(e, log.getOutStream());
 323             throw new Failure(&quot;Caught exception while starting debugee VM:\n\t&quot; + e + &quot;\nProcess output:\n\t&quot; + msg);
 324         } catch (IOException e) {
 325             e.printStackTrace(log.getOutStream());
 326             throw new Failure(&quot;Caught exception while launching debugee VM:\n\t&quot; + e);
 327         };
 328 
 329         Process process = vm.process();
 330         Debugee debugee = makeLocalDebugee(process);
 331         debugee.redirectOutput(log);
 332         debugee.setupVM(vm);
 333 
 334         return debugee;
 335     }
 336 
 337     /**
 338      * Launch debugee locally via the RawLaunchingConnector.
 339      */
 340     private Debugee localRawLaunchDebugee (VirtualMachineManager vmm,
 341                                             String classToExecute,
 342                                             String classPath) {
 343         display(&quot;Finding connector: &quot; + argumentHandler.getConnectorName() );
 344         LaunchingConnector connector =
 345             (LaunchingConnector) findConnector(argumentHandler.getConnectorName(),
 346                                                 vmm.launchingConnectors());
 347         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupRawLaunchingConnector(connector, classToExecute, classPath);
 348 
 349         VirtualMachine vm;
 350         try {
 351             display(&quot;Launching debugee&quot;);
 352             vm = connector.launch(arguments);
 353         } catch (IllegalConnectorArgumentsException e) {
 354             e.printStackTrace(log.getOutStream());
 355             throw new TestBug(&quot;Wrong connector arguments used to launch debuggee VM:\n\t&quot; + e);
 356         } catch (VMStartException e) {
 357             e.printStackTrace(log.getOutStream());
 358             String msg = readVMStartExceptionOutput(e, log.getOutStream());
 359             throw new Failure(&quot;Caught exception while starting debugee VM:\n\t&quot; + e + &quot;\nProcess output:\n\t&quot; + msg);
 360         } catch (IOException e) {
 361             e.printStackTrace(log.getOutStream());
 362             throw new Failure(&quot;Caught exception while launching debugee VM:\n\t&quot; + e);
 363         };
 364 
 365         Process process = vm.process();
 366         Debugee debugee = makeLocalDebugee(process);
 367         debugee.redirectOutput(log);
 368         debugee.setupVM(vm);
 369 
 370         return debugee;
 371     }
 372 
 373     /**
 374      * Launch debugee VM locally as a local process and connect to it using
 375      * &lt;code&gt;AttachingConnector&lt;/code&gt;.
 376      */
 377     private Debugee localLaunchAndAttachDebugee (VirtualMachineManager vmm,
 378                                                     String classToExecute,
 379                                                     String classPath) {
 380         display(&quot;FindingConnector: &quot; + argumentHandler.getConnectorName() );
 381         AttachingConnector connector =
 382             (AttachingConnector) findConnector(argumentHandler.getConnectorName(),
 383                                                 vmm.attachingConnectors());
 384         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupAttachingConnector(connector, classToExecute, classPath);
 385 
 386         String address = makeTransportAddress();
 387         String[] cmdLineArgs = makeCommandLineArgs(classToExecute, address);
 388         String javaCmdLine = makeCommandLineString(classToExecute, address, &quot;\&quot;&quot;);
 389 
 390         display(&quot;Starting java process:\n\t&quot; + javaCmdLine);
 391         Debugee debugee = startLocalDebugee(cmdLineArgs);
 392         debugee.redirectOutput(log);
 393 
 394         display(&quot;Attaching to debugee&quot;);
 395         VirtualMachine vm = null;
 396         IOException ioe = null;
 397         for (int i = 0; i &lt; CONNECT_TRIES; i++) {
 398             try {
 399                 vm = connector.attach(arguments);
 400                 display(&quot;Debugee attached&quot;);
 401                 debugee.setupVM(vm);
 402                 return debugee;
 403             } catch (IOException e) {
 404                 display(&quot;Attempt #&quot; + i + &quot; to connect to debugee VM failed:\n\t&quot; + e);
 405                 ioe = e;
 406                 if (debugee.terminated()) {
 407                     throw new Failure(&quot;Unable to connect to debuggee VM: VM process is terminated&quot;);
 408                 }
 409                 try {
 410                     Thread.currentThread().sleep(CONNECT_TRY_DELAY);
 411                 } catch (InterruptedException ie) {
 412                     ie.printStackTrace(log.getOutStream());
 413                     throw new Failure(&quot;Thread interrupted while pausing connection attempts:\n\t&quot;
 414                                     + ie);
 415                 }
 416             } catch (IllegalConnectorArgumentsException e) {
 417                 e.printStackTrace(log.getOutStream());
 418                 throw new TestBug(&quot;Wrong connector arguments used to attach to debuggee VM:\n\t&quot; + e);
 419             }
 420         }
 421         throw new Failure(&quot;Unable to connect to debugee VM after &quot; + CONNECT_TRIES
 422                         + &quot; tries:\n\t&quot; + ioe);
 423     }
 424 
 425     /**
 426      * Launch debugee VM locally as a local process and connect to it using
 427      * &lt;code&gt;ListeningConnector&lt;/code&gt;.
 428      */
 429     private Debugee localLaunchAndListenDebugee (VirtualMachineManager vmm,
 430                                                     String classToExecute,
 431                                                     String classPath) {
 432         display(&quot;Finding connector: &quot; + argumentHandler.getConnectorName() );
 433         ListeningConnector connector =
 434             (ListeningConnector) findConnector(argumentHandler.getConnectorName(),
 435                                                 vmm.listeningConnectors());
 436         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupListeningConnector(connector, classToExecute, classPath);
 437 
 438         String address = null;
 439         try {
 440             display(&quot;Listening for connection from debugee&quot;);
 441             address = connector.startListening(arguments);
 442         } catch (IllegalConnectorArgumentsException e) {
 443             e.printStackTrace(log.getOutStream());
 444             throw new TestBug(&quot;Wrong connector arguments used to listen debuggee VM:\n\t&quot; + e);
 445         } catch (IOException e) {
 446             e.printStackTrace(log.getOutStream());
 447             throw new Failure(&quot;Caught exception while starting listening debugee VM:\n\t&quot; + e);
 448         };
 449 
 450         String[] cmdLineArgs = makeCommandLineArgs(classToExecute, address);
 451         String javaCmdLine = makeCommandLineString(classToExecute, address, &quot;\&quot;&quot;);
 452 
 453         display(&quot;Starting java process:\n\t&quot; + javaCmdLine);
 454         Debugee debugee = startLocalDebugee(cmdLineArgs);
 455         debugee.redirectOutput(log);
 456 
 457         display(&quot;Waiting for connection from debugee&quot;);
 458         VirtualMachine vm = null;
 459         IOException ioe = null;
 460         for (int i = 0; i &lt; CONNECT_TRIES; i++) {
 461             try {
 462                 vm = connector.accept(arguments);
 463                 connector.stopListening(arguments);
 464                 display(&quot;Debugee attached&quot;);
 465                 debugee.setupVM(vm);
 466                 return debugee;
 467             } catch (IOException e) {
 468                 display(&quot;Attempt #&quot; + i + &quot; to listen debugee VM failed:\n\t&quot; + e);
 469                 ioe = e;
 470                 if (debugee.terminated()) {
 471                     throw new Failure(&quot;Unable to connect to debuggee VM: VM process is terminated&quot;);
 472                 }
 473                 try {
 474                     Thread.currentThread().sleep(CONNECT_TRY_DELAY);
 475                 } catch (InterruptedException ie) {
 476                     ie.printStackTrace(log.getOutStream());
 477                     throw new Failure(&quot;Thread interrupted while pausing connection attempts:\n\t&quot;
 478                                     + ie);
 479                 }
 480             } catch (IllegalConnectorArgumentsException e) {
 481                 e.printStackTrace(log.getOutStream());
 482                 throw new TestBug(&quot;Wrong connector arguments used to listen debuggee VM:\n\t&quot; + e);
 483             }
 484         }
 485         throw new Failure(&quot;Unable to connect to debugee VM after &quot; + CONNECT_TRIES
 486                         + &quot; tries:\n\t&quot; + ioe);
 487     }
 488 
 489     // -------------------------------------------------- //
 490 
 491     /**
 492      * Launch debugee VM remotely via &lt;code&gt;BindServer&lt;/code&gt; and connect to it using
 493      * &lt;code&gt;AttachingConnector&lt;/code&gt;.
 494      */
 495     private Debugee remoteLaunchAndAttachDebugee (VirtualMachineManager vmm,
 496                                                     String classToExecute,
 497                                                     String classPath) {
 498         display(&quot;Finding connector: &quot; + argumentHandler.getConnectorName() );
 499         AttachingConnector connector =
 500             (AttachingConnector) findConnector(argumentHandler.getConnectorName(),
 501                                                 vmm.attachingConnectors());
 502 
 503         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupAttachingConnector(connector, classToExecute, classPath);
 504 
 505         String address = makeTransportAddress();
 506         String[] cmdLineArgs = makeCommandLineArgs(classToExecute, address);
 507         String javaCmdLine = makeCommandLineString(classToExecute, address, &quot;\&quot;&quot;);
 508 
 509         display(&quot;Starting remote java process:\n\t&quot; + javaCmdLine);
 510         Debugee debugee = startRemoteDebugee(cmdLineArgs);
 511 
 512         display(&quot;Attaching to debugee&quot;);
 513         VirtualMachine vm;
 514         IOException ioe = null;
 515         for (int i = 0; i &lt; CONNECT_TRIES; i++) {
 516             try {
 517                 vm = connector.attach(arguments);
 518                 display(&quot;Debugee attached&quot;);
 519                 debugee.setupVM(vm);
 520                 return debugee;
 521             } catch (IOException e) {
 522                 display(&quot;Attempt #&quot; + i + &quot; to connect to debugee VM failed:\n\t&quot; + e);
 523                 ioe = e;
 524                 if (debugee.terminated()) {
 525                     throw new Failure(&quot;Unable to connect to debuggee VM: VM process is terminated&quot;);
 526                 }
 527                 try {
 528                     Thread.currentThread().sleep(CONNECT_TRY_DELAY);
 529                 } catch (InterruptedException ie) {
 530                     ie.printStackTrace(log.getOutStream());
 531                     throw new Failure(&quot;Thread interrupted while pausing connection attempts:\n\t&quot;
 532                                     + ie);
 533                 }
 534             } catch (IllegalConnectorArgumentsException e) {
 535                 e.printStackTrace(log.getOutStream());
 536                 throw new TestBug(&quot;Wrong connector arguments used to attach to debuggee VM:\n\t&quot; + e);
 537             }
 538         }
 539         throw new Failure(&quot;Unable to connect to debugee VM after &quot; + CONNECT_TRIES
 540                         + &quot; tries:\n\t&quot; + ioe);
 541     }
 542 
 543     /**
 544      * Launch debugee VM remotely via &lt;code&gt;BindServer&lt;/code&gt; and connect to it using
 545      * &lt;code&gt;ListeningConnector&lt;/code&gt;.
 546      */
 547     private Debugee remoteLaunchAndListenDebugee (VirtualMachineManager vmm,
 548                                                     String classToExecute,
 549                                                     String classPath) {
 550         display(&quot;Finding connector: &quot; + argumentHandler.getConnectorName() );
 551         ListeningConnector connector =
 552             (ListeningConnector) findConnector(argumentHandler.getConnectorName(),
 553                                                 vmm.listeningConnectors());
 554         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupListeningConnector(connector, classToExecute, classPath);
 555 
 556         String address = null;
 557         try {
 558             display(&quot;Listening for connection from debugee&quot;);
 559             address = connector.startListening(arguments);
 560         } catch (IllegalConnectorArgumentsException e) {
 561             e.printStackTrace(log.getOutStream());
 562             throw new TestBug(&quot;Wrong connector arguments used to listen debuggee VM:\n\t&quot; + e);
 563         } catch (IOException e) {
 564             e.printStackTrace(log.getOutStream());
 565             throw new Failure(&quot;Caught exception while starting listening debugee VM:\n\t&quot; + e);
 566         };
 567 
 568         String[] cmdLineArgs = makeCommandLineArgs(classToExecute, address);
 569         String javaCmdLine = makeCommandLineString(classToExecute, address, &quot;\&quot;&quot;);
 570 
 571         display(&quot;Starting remote java process:\n\t&quot; + javaCmdLine);
 572         Debugee debugee = startRemoteDebugee(cmdLineArgs);
 573 
 574         display(&quot;Waiting for connection from debugee&quot;);
 575         VirtualMachine vm;
 576         IOException ioe = null;
 577         for (int i = 0; i &lt; CONNECT_TRIES; i++) {
 578             try {
 579                 vm = connector.accept(arguments);
 580                 connector.stopListening(arguments);
 581                 display(&quot;Debugee attached&quot;);
 582                 debugee.setupVM(vm);
 583                 return debugee;
 584             } catch (IOException e) {
 585                 display(&quot;Attempt #&quot; + i + &quot; to listen debugee VM failed:\n\t&quot; + e);
 586                 ioe = e;
 587                 if (debugee.terminated()) {
 588                     throw new Failure(&quot;Unable to connect to debuggee VM: VM process is terminated&quot;);
 589                 }
 590                 try {
 591                     Thread.currentThread().sleep(CONNECT_TRY_DELAY);
 592                 } catch (InterruptedException ie) {
 593                     ie.printStackTrace(log.getOutStream());
 594                     throw new Failure(&quot;Thread interrupted while pausing connection attempts:\n\t&quot;
 595                                     + ie);
 596                 }
 597             } catch (IllegalConnectorArgumentsException e) {
 598                 e.printStackTrace(log.getOutStream());
 599                 throw new TestBug(&quot;Wrong connector arguments used to listen debuggee VM:\n\t&quot; + e);
 600             }
 601         }
 602         throw new Failure(&quot;Unable to connect to debugee VM after &quot; + CONNECT_TRIES
 603                         + &quot; tries:\n\t&quot; + ioe);
 604     }
 605 
 606     // -------------------------------------------------- //
 607 
 608     /**
 609      * Prompt to manually launch debugee VM and connect to it using
 610      * &lt;code&gt;AttachingConnector&lt;/code&gt;.
 611      */
 612     private Debugee manualLaunchAndAttachDebugee (VirtualMachineManager vmm,
 613                                                     String classToExecute,
 614                                                     String classPath) {
 615         display(&quot;Finding connector: &quot; + argumentHandler.getConnectorName() );
 616         AttachingConnector connector =
 617             (AttachingConnector) findConnector(argumentHandler.getConnectorName(),
 618                                                 vmm.attachingConnectors());
 619         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupAttachingConnector(connector, classToExecute, classPath);
 620 
 621         String address = makeTransportAddress();
 622         String javaCmdLine = makeCommandLineString(classToExecute, address, &quot;\&quot;&quot;);
 623 
 624         display(&quot;Starting manual java process:\n\t&quot; + javaCmdLine);
 625         ManualLaunchedDebugee debugee = startManualDebugee(javaCmdLine);
 626 
 627         VirtualMachine vm;
 628         try {
 629             display(&quot;Attaching to debugee&quot;);
 630             vm = connector.attach(arguments);
 631         } catch (IllegalConnectorArgumentsException e) {
 632             e.printStackTrace(log.getOutStream());
 633             throw new TestBug(&quot;Wrong connector arguments used to attach to debuggee VM:\n\t&quot; + e);
 634         } catch (IOException e) {
 635             e.printStackTrace(log.getOutStream());
 636             throw new Failure(&quot;Caught exception while attaching to debugee VM:\n\t&quot; + e);
 637         };
 638         display(&quot;Debugee attached&quot;);
 639 
 640         debugee.setupVM(vm);
 641         return debugee;
 642     }
 643 
 644     /**
 645      * Prompt to manually launch debugee VM and connect to it using
 646      * &lt;code&gt;ListeningConnector&lt;/code&gt;.
 647      */
 648     private Debugee manualLaunchAndListenDebugee (VirtualMachineManager vmm,
 649                                                     String classToExecute,
 650                                                     String classPath) {
 651         display(&quot;Finding connector: &quot; + argumentHandler.getConnectorName() );
 652         ListeningConnector connector =
 653             (ListeningConnector) findConnector(argumentHandler.getConnectorName(),
 654                                                 vmm.listeningConnectors());
 655         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupListeningConnector(connector, classToExecute, classPath);
 656 
 657         VirtualMachine vm;
 658         try {
 659             display(&quot;Listening for connection from debugee&quot;);
 660             String address = connector.startListening(arguments);
 661             String javaCmdLine = makeCommandLineString(classToExecute, address, &quot;\&quot;&quot;);
 662             display(&quot;Starting manual java process:\n\t&quot; + javaCmdLine);
 663             ManualLaunchedDebugee debugee = startManualDebugee(javaCmdLine);
 664             display(&quot;Waiting for connection from debugee&quot;);
 665             vm = connector.accept(arguments);
 666             display(&quot;Debugee attached&quot;);
 667             connector.stopListening(arguments);
 668             debugee.setupVM(vm);
 669             return debugee;
 670         } catch (IllegalConnectorArgumentsException e) {
 671             e.printStackTrace(log.getOutStream());
 672             throw new TestBug(&quot;Wrong connector arguments used to listen debuggee VM:\n\t&quot; + e);
 673         } catch (IOException e) {
 674             e.printStackTrace(log.getOutStream());
 675             throw new Failure(&quot;Caught exception while listening to debugee VM:\n\t&quot; + e);
 676         }
 677     }
 678 
 679     // -------------------------------------------------- //
 680 
 681     /**
 682      * Make proper arguments for LaunchingConnector.
 683      */
 684     private Map&lt;String,? extends Argument&gt; setupLaunchingConnector(LaunchingConnector connector,
 685                                                 String classToExecute,
 686                                                 String classPath) {
 687         display(&quot;LaunchingConnector:&quot;);
 688         display(&quot;    name: &quot; + connector.name());
 689         display(&quot;    description: &quot; + connector.description());
 690         display(&quot;    transport: &quot; + connector.transport());
 691 
 692         Hashtable&lt;String,? extends Argument&gt; arguments = new Hashtable&lt;String,Argument&gt;(connector.defaultArguments());
 693 
 694         Connector.Argument arg;
 695 
 696         arg = (Connector.StringArgument) arguments.get(&quot;quote&quot;);
 697         String quote = arg.value();
 698 
 699         String cmdline = classToExecute + &quot; &quot; +
 700                 ArgumentHandler.joinArguments(argumentHandler.getRawArguments(), quote);
 701 
 702         arg = (Connector.StringArgument) arguments.get(&quot;main&quot;);
 703         arg.setValue(cmdline);
 704 
 705         if (! argumentHandler.willDebugeeSuspended()) {
 706             Connector.BooleanArgument barg = (Connector.BooleanArgument) arguments.get(&quot;suspend&quot;);
 707             barg.setValue(true);
 708         }
 709 
 710 /*
 711         if (! argumentHandler.isJVMDIStrictMode()) {
 712             arg = (Connector.StringArgument) arguments.get(&quot;options&quot;);
 713             arg.setValue(&quot;strict=y&quot;);
 714         }
 715  */
 716 
 717         if (! argumentHandler.isDefaultDebugeeJavaHome()) {
 718             arg = (Connector.StringArgument) arguments.get(&quot;home&quot;);
 719             arg.setValue(argumentHandler.getDebugeeJavaHome());
 720         }
 721 
 722         if (! argumentHandler.isDefaultLaunchExecName()) {
 723             arg = (Connector.StringArgument) arguments.get(&quot;vmexec&quot;);
 724             arg.setValue(argumentHandler.getLaunchExecName());
 725         }
 726 
 727         String vmArgs = &quot;&quot;;
 728 
 729         String vmUserArgs = argumentHandler.getLaunchOptions();
 730 
 731         if (vmUserArgs != null) {
 732             vmArgs = vmUserArgs;
 733         }
 734 
 735 /*
 736         if (classPath != null) {
 737             vmArgs += &quot; -classpath &quot; + quote + classPath + quote;
 738         }
 739  */
 740 
 741         if (vmArgs.length() &gt; 0) {
 742             arg = (Connector.StringArgument) arguments.get(&quot;options&quot;);
 743             arg.setValue(vmArgs);
 744         }
 745 
 746         display(&quot;Connector arguments:&quot;);
 747         Iterator iterator = arguments.values().iterator();
 748         while (iterator.hasNext()) {
 749             display(&quot;    &quot; + iterator.next());
 750         }
 751         return arguments;
 752     }
 753 
 754     /**
 755      * Make proper arguments for RawLaunchingConnector.
 756      */
 757     private Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; setupRawLaunchingConnector(LaunchingConnector connector,
 758                                                 String classToExecute,
 759                                                 String classPath) {
 760         display(&quot;RawLaunchingConnector:&quot;);
 761         display(&quot;    name: &quot; + connector.name());
 762         display(&quot;    description: &quot; + connector.description());
 763         display(&quot;    transport: &quot; + connector.transport());
 764 
 765         Hashtable&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = new Hashtable&lt;java.lang.String, com.sun.jdi.connect.Connector.Argument&gt;(connector.defaultArguments());
 766 
 767         String connectorAddress;
 768         String vmAddress;
 769 
 770         if (argumentHandler.isSocketTransport()) {
 771             connectorAddress = argumentHandler.getTransportPort();
 772             vmAddress = argumentHandler.getDebugeeHost()
 773                         + &quot;:&quot; + argumentHandler.getTransportPort();
 774         } else if (argumentHandler.isShmemTransport() ) {
 775             connectorAddress = argumentHandler.getTransportSharedName();
 776             vmAddress=connectorAddress;
 777         } else {
 778             throw new TestBug(&quot;Undefined transport type for AttachingConnector&quot;);
 779         }
 780 
 781         Connector.Argument arg;
 782 
 783         arg = (Connector.StringArgument) arguments.get(&quot;quote&quot;);
 784         String quote = arg.value();
 785 
 786         String javaCmdLine = makeCommandLineString(classToExecute, quote);
 787 
 788         arg = (Connector.StringArgument) arguments.get(&quot;command&quot;);
 789         arg.setValue(javaCmdLine);
 790 
 791         arg = (Connector.StringArgument) arguments.get(&quot;address&quot;);
 792         arg.setValue(connectorAddress);
 793 
 794         display(&quot;Connector arguments:&quot;);
 795         Iterator iterator = arguments.values().iterator();
 796         while (iterator.hasNext()) {
 797             display(&quot;    &quot; + iterator.next());
 798         }
 799         return arguments;
 800     }
 801 
 802     /**
 803      * Make proper arguments for AttachingConnector.
 804      */
 805     private Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; setupAttachingConnector(AttachingConnector connector,
 806                                                 String classToExecute,
 807                                                 String classPath) {
 808         display(&quot;AttachingConnector:&quot;);
 809         display(&quot;    name: &quot; + connector.name());
 810         display(&quot;    description: &quot; + connector.description());
 811         display(&quot;    transport: &quot; + connector.transport());
 812 
 813         Hashtable&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = new Hashtable&lt;java.lang.String,com.sun.jdi.connect.Connector.Argument&gt;(connector.defaultArguments());
 814 
 815         Connector.Argument arg;
 816         if (argumentHandler.isSocketTransport()) {
 817             arg = (Connector.StringArgument) arguments.get(&quot;hostname&quot;);
 818             arg.setValue(argumentHandler.getDebugeeHost());
 819             Connector.IntegerArgument iarg = (Connector.IntegerArgument) arguments.get(&quot;port&quot;);
 820             iarg.setValue(argumentHandler.getTransportPortNumber());
 821         } else {
 822             arg = (Connector.StringArgument) arguments.get(&quot;name&quot;);
 823             arg.setValue(argumentHandler.getTransportSharedName());
 824         }
 825 
 826         display(&quot;Connector arguments:&quot;);
 827         Iterator iterator = arguments.values().iterator();
 828         while (iterator.hasNext()) {
 829             display(&quot;    &quot; + iterator.next());
 830         }
 831         return arguments;
 832     }
 833 
 834     /**
 835      * Make proper arguments for ListeningConnector.
 836      */
 837     private Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; setupListeningConnector(ListeningConnector connector,
 838                                                 String classToExecute,
 839                                                 String classPath) {
 840         display(&quot;ListeningConnector:&quot;);
 841         display(&quot;    name: &quot; + connector.name());
 842         display(&quot;    description: &quot; + connector.description());
 843         display(&quot;    transport: &quot; + connector.transport());
 844 
 845         Hashtable&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = new Hashtable&lt;java.lang.String,com.sun.jdi.connect.Connector.Argument&gt;(connector.defaultArguments());
 846 
 847         Connector.Argument arg;
 848         if (argumentHandler.isSocketTransport()) {
 849             if (!argumentHandler.isTransportAddressDynamic()) {
 850                 int port = argumentHandler.getTransportPortNumber();
 851                 Connector.IntegerArgument iarg = (Connector.IntegerArgument) arguments.get(&quot;port&quot;);
 852                 iarg.setValue(port);
 853             }
 854         } else {
 855             String sharedName = argumentHandler.getTransportSharedName();
 856             arg = (Connector.StringArgument) arguments.get(&quot;name&quot;);
 857             arg.setValue(sharedName);
 858         }
 859 
 860         display(&quot;Connector arguments:&quot;);
 861         Iterator iterator = arguments.values().iterator();
 862         while (iterator.hasNext()) {
 863             display(&quot;    &quot; + iterator.next());
 864         }
 865         return arguments;
 866     }
 867 
 868     // -------------------------------------------------- //
 869 
 870     /**
 871      * Find connector by name from given connectors list.
 872      */
 873     private Connector findConnector(String connectorName, List connectors) {
 874         Iterator iter = connectors.iterator();
 875 
 876         while (iter.hasNext()) {
 877             Connector connector = (Connector) iter.next();
 878             if (connector.name().equals(connectorName)) {
 879                 return connector;
 880             }
 881         }
 882         throw new Failure(&quot;JDI connector not found: &quot; + connectorName);
 883     }
 884 
 885     // -------------------------------------------------- //
 886 
 887     /**
 888      * Launch local debuggee process with specified command line arguments
 889      * and make initial &lt;code&gt;Debugee&lt;/code&gt; mirror.
 890      */
 891     protected Debugee startLocalDebugee(String[] cmdArgs) {
 892         Process process = null;
 893 
 894         try {
 895             process = launchProcess(cmdArgs);
 896         } catch (IOException e) {
 897             e.printStackTrace(log.getOutStream());
 898             throw new Failure(&quot;Caught exception while launching local debuggee VM process:\n\t&quot;
 899                             + e);
 900         }
 901 
 902         return makeLocalDebugee(process);
 903     }
 904 
 905     /**
 906      * Launch remote debuggee process with specified command line arguments
 907      * and make initial &lt;code&gt;Debugee&lt;/code&gt; mirror.
 908      */
 909     protected RemoteLaunchedDebugee startRemoteDebugee(String[] cmdArgs) {
 910         try {
 911             launchRemoteProcess(cmdArgs);
 912         } catch (IOException e) {
 913             e.printStackTrace(log.getOutStream());
 914             throw new Failure(&quot;Caught exception while launching remote debuggee VM process:\n\t&quot;
 915                             + e);
 916         }
 917 
 918         RemoteLaunchedDebugee debugee = new RemoteLaunchedDebugee(this);
 919 
 920         Finalizer finalizer = new Finalizer(debugee);
 921         finalizer.activate();
 922 
 923         return debugee;
 924     }
 925 
 926     /**
 927      * Launch manual debuggee process with specified command line arguments
 928      * and make initial &lt;code&gt;Debugee&lt;/code&gt; mirror.
 929      */
 930     protected ManualLaunchedDebugee startManualDebugee(String cmd) {
 931         ManualLaunchedDebugee debugee = new ManualLaunchedDebugee(this);
 932         debugee.launchDebugee(cmd);
 933 
 934         Finalizer finalizer = new Finalizer(debugee);
 935         finalizer.activate();
 936 
 937         return debugee;
 938     }
 939 
 940     public static String readVMStartExceptionOutput(VMStartException e, PrintStream log) {
 941         StringBuffer msg = new StringBuffer();
 942         try (InputStream is = e.process().getInputStream()) {
 943             msg.append(&quot;\tstdout: &quot;).append(new String(readAllBytes(is))).append(&#39;\n&#39;);
 944         } catch (IOException e1) {
 945             log.println(&quot;Could not read normal output from launched process:&quot; + e1);
 946         }
 947         try (InputStream is = e.process().getErrorStream()) {
 948             msg.append(&quot;\tstderr: &quot;).append(new String(readAllBytes(is)));
 949         } catch (IOException e1) {
 950             log.println(&quot;Could not read error output from launched process:&quot; + e1);
 951         }
 952         return msg.toString();
 953     }
 954 
 955     /**
 956      * Copied from the JDK 9 implementation in InputStream.java
 957      */
 958     private static byte[] readAllBytes(InputStream is) throws IOException {
 959         final int DEFAULT_BUFFER_SIZE = 8192;
 960         final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;
 961 
 962         byte[] buf = new byte[DEFAULT_BUFFER_SIZE];
 963         int capacity = buf.length;
 964         int nread = 0;
 965         int n;
 966         for (;;) {
 967             // read to EOF which may read more or less than initial buffer size
 968             while ((n = is.read(buf, nread, capacity - nread)) &gt; 0)
 969                 nread += n;
 970 
 971             // if the last call to read returned -1, then we&#39;re done
 972             if (n &lt; 0)
 973                 break;
 974 
 975             // need to allocate a larger buffer
 976             if (capacity &lt;= MAX_BUFFER_SIZE - capacity) {
 977                 capacity = capacity &lt;&lt; 1;
 978             } else {
 979                 if (capacity == MAX_BUFFER_SIZE)
 980                     throw new OutOfMemoryError(&quot;Required array size too large&quot;);
 981                 capacity = MAX_BUFFER_SIZE;
 982             }
 983             buf = Arrays.copyOf(buf, capacity);
 984         }
 985         return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);
 986     }
 987 
 988 }
 989 
 990 
 991 /**
 992  * Mirror of locally launched debugee.
 993  */
 994 final class LocalLaunchedDebugee extends Debugee {
 995 
 996     /** Enwrap the locally started VM process. */
 997     public LocalLaunchedDebugee (Process process, Binder binder) {
 998         super(binder);
 999         this.process = process;
1000         checkTermination = true;
1001     }
1002 
1003     // ---------------------------------------------- //
1004 
1005     /** Return exit status of the debugee VM. */
1006     public int getStatus () {
1007         return process.exitValue();
1008     }
1009 
1010     /** Check whether the debugee VM has been terminated. */
1011     public boolean terminated () {
1012         if (process == null)
1013             return true;
1014 
1015         try {
1016             int value = process.exitValue();
1017             return true;
1018         } catch (IllegalThreadStateException e) {
1019             return false;
1020         }
1021     }
1022 
1023     // ---------------------------------------------- //
1024 
1025     /** Kill the debugee VM. */
1026     protected void killDebugee () {
1027         super.killDebugee();
1028         if (!terminated()) {
1029             log.display(&quot;Killing debugee VM process&quot;);
1030             process.destroy();
1031         }
1032     }
1033 
1034     /** Wait until the debugee VM shutdown or crash. */
1035     protected int waitForDebugee () throws InterruptedException {
1036         int code = process.waitFor();
1037         return code;
1038     }
1039 
1040     /** Get a pipe to write to the debugee&#39;s stdin stream. */
1041     protected OutputStream getInPipe () {
1042         return process.getOutputStream();
1043     }
1044 
1045     /** Get a pipe to read the debugee&#39;s stdout stream. */
1046     protected InputStream getOutPipe () {
1047         return process.getInputStream();
1048     }
1049 
1050     /** Get a pipe to read the debugee&#39;s stderr stream. */
1051     protected InputStream getErrPipe () {
1052         return process.getErrorStream();
1053     }
1054 }
1055 
1056 
1057 /**
1058  * Mirror of remotely launched debugee.
1059  */
1060 final class RemoteLaunchedDebugee extends Debugee {
1061 
1062     /** Enwrap the remotely started VM process. */
1063     public RemoteLaunchedDebugee (Binder binder) {
1064         super(binder);
1065     }
1066 
1067     // ---------------------------------------------- //
1068 
1069     /** Return exit status of the debugee VM. */
1070     public int getStatus () {
1071         return binder.getRemoteProcessStatus();
1072     }
1073 
1074     /** Check whether the debugee VM has been terminated. */
1075     public boolean terminated () {
1076         return binder.isRemoteProcessTerminated();
1077     }
1078 
1079     // ---------------------------------------------- //
1080 
1081     /** Kill the debugee VM. */
1082     protected void killDebugee () {
1083         super.killDebugee();
1084         if (!terminated()) {
1085             binder.killRemoteProcess();
1086         }
1087     }
1088 
1089     /** Wait until the debugee VM shutdown or crash. */
1090     protected int waitForDebugee () {
1091         return binder.waitForRemoteProcess();
1092     }
1093 
1094     /** Get a pipe to write to the debugee&#39;s stdin stream. */
1095     protected OutputStream getInPipe () {
1096         return null;
1097     }
1098 
1099     /** Get a pipe to read the debugee&#39;s stdout stream. */
1100     protected InputStream getOutPipe () {
1101         return null;
1102     }
1103 
1104     /** Get a pipe to read the debugee&#39;s stderr stream. */
1105     protected InputStream getErrPipe () {
1106         return null;
1107     }
1108 
1109     public void redirectStdout(OutputStream out) {
1110     }
1111 
1112     public void redirectStdout(Log log, String prefix) {
1113     }
1114 
1115     public void redirectStderr(OutputStream out) {
1116     }
1117 
1118     public void redirectStderr(Log log, String prefix) {
1119     }
1120 }
1121 
1122 
1123 /**
1124  * Mirror of manually launched debugee.
1125  */
1126 final class ManualLaunchedDebugee extends Debugee {
1127     /** Enwrap the manually started VM process. */
1128     public ManualLaunchedDebugee (Binder binder) {
1129         super(binder);
1130         makeInputReader();
1131     }
1132 
1133     // ---------------------------------------------- //
1134 
1135     private int exitCode = 0;
1136     private boolean finished = false;
1137     private static BufferedReader bin = null;
1138 
1139     public void launchDebugee(String commandLine) {
1140         makeInputReader();
1141 
1142         putMessage(&quot;Launch target VM using such command line:\n&quot;
1143                     + commandLine);
1144         String answer = askQuestion(&quot;Has the VM successfully started? (yes/no)&quot;, &quot;yes&quot;);
1145         for ( ; ; ) {
1146             if (answer.equals(&quot;yes&quot;))
1147                 break;
1148             if (answer.equals(&quot;no&quot;))
1149                 throw new Failure (&quot;Unable to manually launch debugee VM&quot;);
1150             answer = askQuestion(&quot;Wrong answer. Please type yes or no&quot;, &quot;yes&quot;);
1151         }
1152     }
1153 
1154     private static void makeInputReader() {
1155         if (bin == null) {
1156             bin = new BufferedReader(new InputStreamReader(System.in));
1157         }
1158     }
1159 
1160     private static void destroyInputReader() {
1161         if (bin != null) {
1162             try {
1163                 bin.close();
1164             } catch (IOException e) {
1165 //                e.printStackTrace(log.getOutStream());
1166                 throw new Failure(&quot;Caught exception while closing input stream:\n\t&quot; + e);
1167             }
1168             bin = null;
1169         }
1170     }
1171 
1172     private static void putMessage(String msg) {
1173         System.out.println(&quot;\n&gt;&gt;&gt; &quot; + msg);
1174     }
1175 
1176     private static String askQuestion(String question, String defaultAnswer) {
1177         try {
1178             System.out.print(&quot;\n&gt;&gt;&gt; &quot; + question);
1179             System.out.print(&quot; [&quot; + defaultAnswer + &quot;] &quot;);
1180             System.out.flush();
1181             String answer = bin.readLine();
1182             if (answer.equals(&quot;&quot;))
1183                 return defaultAnswer;
1184             return answer;
1185         } catch (IOException e) {
1186 //            e.printStackTrace(log.getOutStream());
1187             throw new Failure(&quot;Caught exception while reading answer:\n\t&quot; + e);
1188         }
1189     }
1190 
1191     /** Return exit status of the debugee VM. */
1192     public int getStatus () {
1193         if (! finished) {
1194             throw new Failure(&quot;Unable to get status of debugee VM: process still alive&quot;);
1195         }
1196         return exitCode;
1197     }
1198 
1199     /** Check whether the debugee VM has been terminated. */
1200     public boolean terminated () {
1201         return finished;
1202     }
1203 
1204     // ---------------------------------------------- //
1205 
1206     /** Kill the debugee VM. */
1207     protected void killDebugee () {
1208         super.killDebugee();
1209         if (!terminated()) {
1210             putMessage(&quot;Kill launched VM&quot;);
1211             String answer = askQuestion(&quot;Has the VM successfully terminated? (yes/no)&quot;, &quot;yes&quot;);
1212             for ( ; ; ) {
1213                 if (answer.equals(&quot;yes&quot;)) {
1214                     finished = true;
1215                     break;
1216                 }
1217                 if (answer.equals(&quot;no&quot;))
1218                     throw new Failure (&quot;Unable to manually kill debugee VM&quot;);
1219                 answer = askQuestion(&quot;Wrong answer. Please type yes or no&quot;, &quot;yes&quot;);
1220             }
1221         }
1222     }
1223 
1224     /** Wait until the debugee VM shutdown or crash. */
1225     protected int waitForDebugee () {
1226         putMessage(&quot;Wait for launched VM to exit.&quot;);
1227         String answer = askQuestion(&quot;What is VM exit code?&quot;, &quot;95&quot;);
1228         for ( ; ; ) {
1229             try {
1230                 exitCode = Integer.parseInt(answer);
1231                 break;
1232             } catch (NumberFormatException e) {
1233                 answer = askQuestion(&quot;Wrong answer. Please type integer value&quot;, &quot;95&quot;);
1234             }
1235         }
1236         finished = true;
1237         return exitCode;
1238     }
1239 
1240     /** Get a pipe to write to the debugee&#39;s stdin stream. */
1241     protected OutputStream getInPipe () {
1242         return null;
1243     }
1244 
1245     /** Get a pipe to read the debugee&#39;s stdout stream. */
1246     protected InputStream getOutPipe () {
1247         return null;
1248     }
1249 
1250     /** Get a pipe to read the debugee&#39;s stderr stream. */
1251     protected InputStream getErrPipe () {
1252         return null;
1253     }
1254 
1255     public void redirectStdout(OutputStream out) {
1256     }
1257 
1258     public void redirectStdout(Log log, String prefix) {
1259     }
1260 
1261     public void redirectStderr(OutputStream out) {
1262     }
1263 
1264     public void redirectStderr(Log log, String prefix) {
1265     }
1266 
1267     public void close() {
1268         destroyInputReader();
1269         super.close();
1270     }
1271 }
    </pre>
  </body>
</html>
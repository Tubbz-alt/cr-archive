<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/bcinstr/BI01/bi01t002/bi01t002.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 /* scaffold objects */
 33 static jvmtiEnv *jvmti = NULL;
 34 static jlong timeout = 0;
 35 
 36 #define TESTED_CLASS_NAME   &quot;nsk/jvmti/scenarios/bcinstr/BI01/bi01t002a&quot;
 37 #define TOTAL_INSTRUMENTED_CLASSES 2
 38 
 39 static int clsLoadedIdx=0;
 40 static jint newClassSize[TOTAL_INSTRUMENTED_CLASSES];
 41 static unsigned char* newClassBytes[TOTAL_INSTRUMENTED_CLASSES];
 42 static jvmtiClassDefinition oldClassDef[TOTAL_INSTRUMENTED_CLASSES];
 43 
 44 /* ============================================================================= */
 45 /*
 46  * Class:     nsk_jvmti_scenarios_bcinstr_BI01_bi01t002
 47  * Method:    setNewByteCode
 48  * Signature: (I[B)Z
 49  */
 50 JNIEXPORT jboolean JNICALL
 51 Java_nsk_jvmti_scenarios_bcinstr_BI01_bi01t002_setNewByteCode(JNIEnv *jni_env,
 52                         jobject o, jint ind, jbyteArray byteCode) {
 53 
 54     jbyte* elements;
 55     jboolean isCopy;
 56 
 57     newClassSize[ind] = jni_env-&gt;GetArrayLength(byteCode);
 58     if (!NSK_JNI_VERIFY(jni_env, newClassSize[ind] &gt; 0)) {
 59         nsk_jvmti_setFailStatus();
 60         return NSK_FALSE;
 61     }
 62     NSK_DISPLAY1(&quot;\t... got array size: %d\n&quot;, newClassSize[ind]);
 63 
 64     elements = jni_env-&gt;GetByteArrayElements(byteCode, &amp;isCopy);
 65     if (!NSK_JNI_VERIFY(jni_env, elements != NULL)) {
 66         nsk_jvmti_setFailStatus();
 67         return NSK_FALSE;
 68     }
 69     NSK_DISPLAY1(&quot;\t... got elements list: 0x%p\n&quot;, (void*)elements);
 70 
 71     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Allocate(newClassSize[ind], &amp;newClassBytes[ind]))) {
 72         nsk_jvmti_setFailStatus();
 73         return NSK_FALSE;
 74     }
 75     NSK_DISPLAY1(&quot;\t... created bytes array: 0x%p\n&quot;, (void*)newClassBytes[ind]);
 76 
 77     {
 78         int j;
 79         for (j = 0; j &lt; newClassSize[ind]; j++)
 80             newClassBytes[ind][j] = (unsigned char)elements[j];
 81     }
 82     NSK_DISPLAY1(&quot;\t... copied bytecode: %d bytes\n&quot;, (int)newClassSize[ind]);
 83 
 84     NSK_DISPLAY1(&quot;\t... release elements list: 0x%p\n&quot;, (void*)elements);
 85     NSK_TRACE(jni_env-&gt;ReleaseByteArrayElements(byteCode, elements, JNI_ABORT));
 86     NSK_DISPLAY0(&quot;\t... released\n&quot;);
 87     return NSK_TRUE;
 88 }
 89 
 90 /* ============================================================================= */
 91 /*
 92  * Class:     nsk_jvmti_scenarios_bcinstr_BI01_bi01t002
 93  * Method:    setClass
 94  * Signature: (ILjava/lang/Class;)V
 95  */
 96 JNIEXPORT void JNICALL
 97 Java_nsk_jvmti_scenarios_bcinstr_BI01_bi01t002_setClass(JNIEnv *jni_env,
 98                         jobject o, jint ind, jclass cls) {
 99 
100     oldClassDef[ind].klass = (jclass) jni_env-&gt;NewGlobalRef(cls);
101     if (!NSK_JNI_VERIFY(jni_env, oldClassDef[ind].klass != NULL)) {
102         nsk_jvmti_setFailStatus();
103     }
104 }
105 
106 /* ============================================================================= */
107 
108 /** Callback function for ClassFileLoadHook event. */
109 JNIEXPORT void JNICALL
110 cbClassFileLoadHook(jvmtiEnv *jvmti_env, JNIEnv* jni_env,
111             jclass class_being_redefined, jobject loader, const char* name,
112             jobject protection_domain, jint class_data_len,
113             const unsigned char* class_data, jint* new_class_data_len,
114             unsigned char** new_class_data) {
115 
116     if (name == NULL || strcmp(name, TESTED_CLASS_NAME)) {
117         return;
118     }
119 
120     NSK_DISPLAY3(&quot;CLASS_FILE_LOAD_HOOK event: %s\n\treceived bytecode: 0x%p:%d\n&quot;,
121                         name, (void *)class_data, class_data_len);
122     if (nsk_getVerboseMode()) {
123         nsk_printHexBytes(&quot;   &quot;, 16, class_data_len, class_data);
124     }
125 
126     {
127         /*store original byte code, it will be used to do final redefinition*/
128         int j;
129         unsigned char *arr;
130 
131         oldClassDef[clsLoadedIdx].class_byte_count = class_data_len;
132         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Allocate(class_data_len, &amp;arr))) {
133             nsk_jvmti_setFailStatus();
134             return;
135         }
136         for (j = 0; j &lt; class_data_len; j++) {
137             arr[j] = class_data[j];
138         }
139         oldClassDef[clsLoadedIdx].class_bytes = arr;
140     }
141 
142     *new_class_data_len = newClassSize[clsLoadedIdx];
143     *new_class_data = newClassBytes[clsLoadedIdx];
144 
145     NSK_DISPLAY2(&quot;Replace with new bytecode: 0x%p:%d\n&quot;,
146                                 (void*)newClassBytes[clsLoadedIdx],
147                                 (int)newClassSize[clsLoadedIdx]);
148     if (nsk_getVerboseMode()) {
149         nsk_printHexBytes(&quot;   &quot;, 16, newClassSize[clsLoadedIdx],
150                                 newClassBytes[clsLoadedIdx]);
151     }
152 }
153 
154 /* ============================================================================= */
155 
156 /** Agent algorithm. */
157 static void JNICALL
158 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
159 
160     int i;
161 
162     /*Wait for debuggee to read new byte codes nsk_jvmti_waitForSync#1*/
163     NSK_DISPLAY0(&quot;Wait for debuggee to read new byte codes nsk_jvmti_waitForSync#1\n&quot;);
164     if (!nsk_jvmti_waitForSync(timeout))
165         return;
166 
167     for (clsLoadedIdx=0; clsLoadedIdx &lt; TOTAL_INSTRUMENTED_CLASSES; clsLoadedIdx++) {
168 
169         if (!nsk_jvmti_resumeSync())
170             return;
171 
172         NSK_DISPLAY1(&quot;Wait for debuggee to load tested class by classLoader[%d]\n&quot;,
173                             (clsLoadedIdx+1));
174         /*Wait for debuggee to load next class nsk_jvmti_waitForSync#2*/
175         if (!nsk_jvmti_waitForSync(timeout))
176             return;
177     }
178 
179     if (!nsk_jvmti_resumeSync())
180         return;
181 
182     /*Wait for debuggee to check instrumentation code works nsk_jvmti_waitForSync#3*/
183     NSK_DISPLAY0(&quot;Wait for debuggee to check instrumentation code works nsk_jvmti_waitForSync#3\n&quot;);
184     if (!nsk_jvmti_waitForSync(timeout))
185         return;
186 
187     NSK_DISPLAY0(&quot;Notification disabled for CLASS_FILE_LOAD_HOOK event\n&quot;);
188     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE,
189                                                           JVMTI_EVENT_CLASS_FILE_LOAD_HOOK,
190                                                           NULL))) {
191         nsk_jvmti_setFailStatus();
192         return;
193     }
194 
195     if (!nsk_jvmti_resumeSync())
196         return;
197 
198     /*Wait for debuggee to set classes to be redefined nsk_jvmti_waitForSync#4*/
199     NSK_DISPLAY0(&quot;Wait for debuggee to set classes to be redefined nsk_jvmti_waitForSync#4\n&quot;);
200     if (!nsk_jvmti_waitForSync(timeout))
201         return;
202 
203     NSK_DISPLAY0(&quot;Redfine class with old byte code\n&quot;);
204     for (i = 0; i &lt; TOTAL_INSTRUMENTED_CLASSES; i++) {
205         NSK_DISPLAY4(&quot;class definition %d:\n\t0x%p, 0x%p:%d\n&quot;,
206                         i,
207                         oldClassDef[i].klass,
208                         oldClassDef[i].class_bytes,
209                         oldClassDef[i].class_byte_count);
210         if (nsk_getVerboseMode()) {
211             nsk_printHexBytes(&quot;   &quot;, 16, oldClassDef[i].class_byte_count,
212                                     oldClassDef[i].class_bytes);
213         }
214     }
215     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RedefineClasses(TOTAL_INSTRUMENTED_CLASSES, oldClassDef))) {
216         nsk_jvmti_setFailStatus();
217         return;
218     }
219 
220     if (!nsk_jvmti_resumeSync())
221         return;
222 
223     /*Wait for debuggee to check old byte code works nsk_jvmti_waitForSync#5*/
224     NSK_DISPLAY0(&quot;Wait for debuggee to check old byte code works nsk_jvmti_waitForSync#5\n&quot;);
225     if (!nsk_jvmti_waitForSync(timeout))
226         return;
227 
228     for (i = 0; i &lt; TOTAL_INSTRUMENTED_CLASSES; i++) {
229         agentJNI-&gt;DeleteGlobalRef(oldClassDef[i].klass);
230     }
231 
232     NSK_DISPLAY0(&quot;Let debuggee to finish\n&quot;);
233     if (!nsk_jvmti_resumeSync())
234         return;
235 
236 }
237 
238 /* ============================================================================= */
239 
240 /** Agent library initialization. */
241 #ifdef STATIC_BUILD
242 JNIEXPORT jint JNICALL Agent_OnLoad_bi01t002(JavaVM *jvm, char *options, void *reserved) {
243     return Agent_Initialize(jvm, options, reserved);
244 }
245 JNIEXPORT jint JNICALL Agent_OnAttach_bi01t002(JavaVM *jvm, char *options, void *reserved) {
246     return Agent_Initialize(jvm, options, reserved);
247 }
248 JNIEXPORT jint JNI_OnLoad_bi01t002(JavaVM *jvm, char *options, void *reserved) {
249     return JNI_VERSION_1_8;
250 }
251 #endif
252 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
253 
254     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
255         return JNI_ERR;
256 
257     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
258 
259     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
260     if (!NSK_VERIFY(jvmti != NULL))
261         return JNI_ERR;
262 
263     {
264         jvmtiCapabilities caps;
265         memset(&amp;caps, 0, sizeof(caps));
266 
267         caps.can_redefine_classes = 1;
268         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
269             return JNI_ERR;
270     }
271 
272     NSK_DISPLAY0(&quot;Set callback for CLASS_FILE_LOAD_HOOK event\n&quot;);
273     {
274         jvmtiEventCallbacks callbacks;
275         jint size = (jint)sizeof(callbacks);
276 
277         memset(&amp;callbacks, 0, size);
278         callbacks.ClassFileLoadHook = cbClassFileLoadHook;
279         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;callbacks, size))) {
280             return JNI_ERR;
281         }
282     }
283 
284     NSK_DISPLAY0(&quot;Set notification enabled for CLASS_FILE_LOAD_HOOK event\n&quot;);
285     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE,
286                                                           JVMTI_EVENT_CLASS_FILE_LOAD_HOOK,
287                                                           NULL))) {
288         nsk_jvmti_setFailStatus();
289         return NSK_FALSE;
290     }
291 
292     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
293         return JNI_ERR;
294 
295     return JNI_OK;
296 }
297 
298 /* ============================================================================= */
299 
300 
301 }
    </pre>
  </body>
</html>
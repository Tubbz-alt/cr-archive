<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jdi/EventRequest/hashCode/hashcode001.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.EventRequest.hashCode;
 25 
 26 import nsk.share.*;
 27 import nsk.share.jpda.*;
 28 import nsk.share.jdi.*;
 29 
 30 import com.sun.jdi.*;
 31 import com.sun.jdi.request.*;
 32 import com.sun.jdi.event.*;
 33 import com.sun.jdi.connect.*;
 34 import java.io.*;
 35 import java.util.*;
 36 
 37 /**
 38  * The debugger application of the test.
 39  */
 40 public class hashcode001 {
 41 
 42     //------------------------------------------------------- immutable common fields
 43 
 44     final static String SIGNAL_READY = &quot;ready&quot;;
 45     final static String SIGNAL_GO    = &quot;go&quot;;
 46     final static String SIGNAL_QUIT  = &quot;quit&quot;;
 47 
 48     private static int waitTime;
 49     private static int exitStatus;
 50     private static ArgumentHandler     argHandler;
 51     private static Log                 log;
 52     private static Debugee             debuggee;
 53     private static ReferenceType       debuggeeClass;
 54 
 55     //------------------------------------------------------- mutable common fields
 56 
 57     private final static String prefix = &quot;nsk.jdi.EventRequest.hashCode.&quot;;
 58     private final static String className = &quot;hashcode001&quot;;
 59     private final static String debuggerName = prefix + className;
 60     private final static String debuggeeName = debuggerName + &quot;a&quot;;
 61 
 62     //------------------------------------------------------- test specific fields
 63 
 64     private final static String methodName = &quot;main&quot;;
 65     private final static String fieldName = &quot;exitStatus&quot;;
 66 
 67     //------------------------------------------------------- immutable common methods
 68 
 69     public static void main(String argv[]) {
 70         System.exit(Consts.JCK_STATUS_BASE + run(argv, System.out));
 71     }
 72 
 73     private static void display(String msg) {
 74         log.display(&quot;debugger &gt; &quot; + msg);
 75     }
 76 
 77     private static void complain(String msg) {
 78         log.complain(&quot;debugger FAILURE &gt; &quot; + msg);
 79     }
 80 
 81     public static int run(String argv[], PrintStream out) {
 82 
 83         exitStatus = Consts.TEST_PASSED;
 84 
 85         argHandler = new ArgumentHandler(argv);
 86         log = new Log(out, argHandler);
 87         waitTime = argHandler.getWaitTime() * 60000;
 88 
 89         debuggee = Debugee.prepareDebugee(argHandler, log, debuggeeName);
 90 
 91         debuggeeClass = debuggee.classByName(debuggeeName);
 92         if ( debuggeeClass == null ) {
 93             complain(&quot;Class &#39;&quot; + debuggeeName + &quot;&#39; not found.&quot;);
 94             exitStatus = Consts.TEST_FAILED;
 95         }
 96 
 97         execTest();
 98 
 99         debuggee.quit();
100 
101         return exitStatus;
102     }
103 
104     //------------------------------------------------------ mutable common method
105 
106     private static void execTest() {
107 
108         EventRequestManager eventRequestManager = debuggee.VM().eventRequestManager();
109         EventRequest eventRequest;
110 
111         display(&quot;Checking hashCode() method for EventRequest objects&quot;);
112 
113         for (int i = 0; i &lt; 12; i++) {
114 
115             switch (i) {
116 
117                 case 0:
118                        ThreadReference thread = debuggee.threadByNameOrThrow(methodName);
119 
120                        display(&quot;.....setting up StepRequest&quot;);
121                        eventRequest = eventRequestManager.createStepRequest
122                                       (thread, StepRequest.STEP_MIN, StepRequest.STEP_INTO);
123                        break;
124 
125                 case 1:
126                        display(&quot;.....setting up AccessWatchpointRequest&quot;);
127                        eventRequest = eventRequestManager.createAccessWatchpointRequest
128                                       (debuggeeClass.fieldByName(fieldName));
129                        break;
130 
131                 case 2:
132                        display(&quot;.....setting up ModificationWatchpointRequest&quot;);
133                        eventRequest = eventRequestManager.createModificationWatchpointRequest
134                                       (debuggeeClass.fieldByName(fieldName));
135                        break;
136 
137                 case 3:
138                        display(&quot;.....setting up ClassPrepareRequest&quot;);
139                        eventRequest = eventRequestManager.createClassPrepareRequest();
140                        break;
141 
142                 case 4:
143                        display(&quot;.....setting up ClassUnloadRequest&quot;);
144                        eventRequest = eventRequestManager.createClassUnloadRequest();
145                        break;
146 
147                 case 5:
148                        display(&quot;.....setting up MethodEntryRequest&quot;);
149                        eventRequest = eventRequestManager.createMethodEntryRequest();
150                        break;
151 
152                 case 6:
153                        display(&quot;.....setting up MethodExitRequest&quot;);
154                        eventRequest = eventRequestManager.createMethodExitRequest();
155                        break;
156 
157                 case 7:
158                        display(&quot;.....setting up ThreadDeathRequest&quot;);
159                        eventRequest = eventRequestManager.createThreadDeathRequest();
160                        break;
161 
162                 case 8:
163                        display(&quot;.....setting up ThreadStartRequest&quot;);
164                        eventRequest = eventRequestManager.createThreadStartRequest();
165                        break;
166 
167                 case 9:
168                        display(&quot;.....setting up VMDeathRequest&quot;);
169                        eventRequest = eventRequestManager.createVMDeathRequest();
170                        break;
171 
172                 case 10:
173                        display(&quot;.....setting up ExceptionRequest&quot;);
174                        eventRequest = eventRequestManager.createExceptionRequest( null, true, true );
175                        break;
176 
177                 case 11:
178                        display(&quot;.....setting up BreakpointRequest&quot;);
179                        Method method = methodByName(debuggeeClass, methodName);
180                        List locs = null;
181                        try {
182                            locs = method.allLineLocations();
183                        } catch(AbsentInformationException e) {
184                            throw new Failure(&quot;Unexpected AbsentInformationException while getting &quot;);
185                        }
186                        Location location = (Location)locs.get(0);
187                        eventRequest = eventRequestManager.createBreakpointRequest(location);
188                        break;
189 
190                 default:
191                         throw new Failure(&quot;Wrong test case : &quot; + i);
192             }
193 
194             int hCode = eventRequest.hashCode();
195 
196             if (hCode == 0) {
197                 complain(&quot;hashCode() returns 0 for EventRequest object &quot; + eventRequest);
198                 exitStatus = Consts.TEST_FAILED;
199             }
200 
201             int hCode1 = eventRequest.hashCode();
202             if (hCode != hCode1) {
203                 complain(&quot;hashCode() is not consistent for EventRequest object &quot; + eventRequest +
204                     &quot;\n\t first value :&quot; + hCode + &quot; ; second value : &quot; + hCode1);
205                 exitStatus = Consts.TEST_FAILED;
206             }
207 
208             display(&quot;hashCode() returns &quot; + hCode + &quot; for EventRequest object : &quot; +  eventRequest);
209             eventRequestManager.deleteEventRequest(eventRequest);
210         }
211 
212 
213         display(&quot;Checking completed!&quot;);
214         debuggee.resume();
215     }
216 
217     //--------------------------------------------------------- test specific methods
218 
219     private static Method methodByName(ReferenceType refType, String methodName) {
220         List methodList = refType.methodsByName(methodName);
221         if (methodList == null) return null;
222 
223         Method method = (Method) methodList.get(0);
224         return method;
225     }
226 
227 }
228 //--------------------------------------------------------- test specific classes
    </pre>
  </body>
</html>
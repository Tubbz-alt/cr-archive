<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/SingleStep/singlestep001/singlestep001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdio.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &lt;jvmti.h&gt;
 27 #include &quot;agent_common.h&quot;
 28 
 29 #include &quot;nsk_tools.h&quot;
 30 #include &quot;JVMTITools.h&quot;
 31 #include &quot;jvmti_tools.h&quot;
 32 #include &quot;jni_tools.h&quot;
 33 
 34 extern &quot;C&quot; {
 35 
 36 #define STATUS_FAILED 2
 37 #define PASSED 0
 38 
 39 #define METH_NUM 2
 40 
 41 static const char *METHODS[] = {
 42     &quot;bpMethod&quot;,
 43     &quot;runThis&quot;
 44 };
 45 
 46 static const char *METHOD_SIGS[] = {
 47     &quot;()V&quot;,
 48     &quot;([Ljava/lang/String;Ljava/io/PrintStream;)I&quot;
 49 };
 50 
 51 static volatile long stepEv[] = { 0, 0 };
 52 
 53 static const char *CLASS_SIG =
 54     &quot;Lnsk/jvmti/SingleStep/singlestep001;&quot;;
 55 
 56 static volatile jint result = PASSED;
 57 static jvmtiEnv *jvmti = NULL;
 58 static jvmtiEventCallbacks callbacks;
 59 
 60 static volatile int callbacksEnabled = NSK_FALSE;
 61 static jrawMonitorID agent_lock;
 62 
 63 static void setBP(jvmtiEnv *jvmti_env, JNIEnv *env, jclass klass) {
 64     jmethodID mid;
 65 
 66     if (!NSK_JNI_VERIFY(env, (mid = env-&gt;GetMethodID(klass, METHODS[0], METHOD_SIGS[0])) != NULL))
 67         env-&gt;FatalError(&quot;failed to get ID for the java method\n&quot;);
 68 
 69     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;SetBreakpoint(mid, 0)))
 70         env-&gt;FatalError(&quot;failed to set breakpoint\n&quot;);
 71 }
 72 
 73 /** callback functions **/
 74 void JNICALL
 75 ClassLoad(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread, jclass klass) {
 76     char *sig, *generic;
 77 
 78     jvmti-&gt;RawMonitorEnter(agent_lock);
 79 
 80     if (callbacksEnabled) {
 81         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetClassSignature(klass, &amp;sig, &amp;generic)))
 82             env-&gt;FatalError(&quot;failed to obtain a class signature\n&quot;);
 83 
 84         if (sig != NULL &amp;&amp; (strcmp(sig, CLASS_SIG) == 0)) {
 85             NSK_DISPLAY1(
 86                 &quot;ClassLoad event received for the class \&quot;%s\&quot;\n&quot;
 87                 &quot;\tsetting breakpoint ...\n&quot;,
 88                 sig);
 89             setBP(jvmti_env, env, klass);
 90         }
 91     }
 92 
 93     jvmti-&gt;RawMonitorExit(agent_lock);
 94 }
 95 
 96 void JNICALL
 97 Breakpoint(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr, jmethodID method,
 98         jlocation loc) {
 99     jclass klass;
100     char *sig, *generic;
101 
102     jvmti-&gt;RawMonitorEnter(agent_lock);
103 
104     if (!callbacksEnabled) {
105         jvmti-&gt;RawMonitorExit(agent_lock);
106         return;
107     }
108 
109     NSK_DISPLAY0(&quot;Breakpoint event received\n&quot;);
110     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodDeclaringClass(method, &amp;klass)))
111         NSK_COMPLAIN0(&quot;TEST FAILURE: unable to get method declaring class\n\n&quot;);
112 
113     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetClassSignature(klass, &amp;sig, &amp;generic)))
114         env-&gt;FatalError(&quot;Breakpoint: failed to obtain a class signature\n&quot;);
115 
116     if (sig != NULL &amp;&amp; (strcmp(sig, CLASS_SIG) == 0)) {
117         NSK_DISPLAY1(&quot;method declaring class \&quot;%s\&quot;\n\tenabling SingleStep events ...\n&quot;,
118             sig);
119         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, thr))) {
120             result = STATUS_FAILED;
121             NSK_COMPLAIN0(&quot;TEST FAILURE: cannot enable SingleStep events\n\n&quot;);
122         }
123     } else {
124         result = STATUS_FAILED;
125         NSK_COMPLAIN1(&quot;TEST FAILURE: unexpected breakpoint event in method of class \&quot;%s\&quot;\n\n&quot;,
126             sig);
127     }
128     jvmti-&gt;RawMonitorExit(agent_lock);
129 }
130 
131 void JNICALL
132 SingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
133         jmethodID method, jlocation location) {
134     jclass klass;
135     char *sig, *generic, *methNam, *methSig;
136 
137     if (result == STATUS_FAILED) {
138         return;
139     }
140 
141     NSK_DISPLAY0(&quot;&gt;&gt;&gt;&gt; SingleStep event received\n&quot;);
142 
143     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodName(method, &amp;methNam, &amp;methSig, NULL))) {
144         result = STATUS_FAILED;
145         NSK_COMPLAIN0(&quot;TEST FAILED: unable to get method name during SingleStep callback\n\n&quot;);
146         return;
147     }
148     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodDeclaringClass(method, &amp;klass))) {
149         result = STATUS_FAILED;
150         NSK_COMPLAIN0(&quot;TEST FAILED: unable to get method declaring class during SingleStep callback\n\n&quot;);
151         return;
152     }
153     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetClassSignature(klass, &amp;sig, &amp;generic))) {
154         result = STATUS_FAILED;
155         NSK_COMPLAIN0(&quot;TEST FAILED: unable to obtain a class signature during SingleStep callback\n\n&quot;);
156         return;
157     }
158 
159     if (sig != NULL) {
160         NSK_DISPLAY3(
161             &quot;\tmethod name: \&quot;%s\&quot;\n&quot;
162             &quot;\tsignature: \&quot;%s\&quot;\n&quot;
163             &quot;\tmethod declaring class: \&quot;%s\&quot;\n&quot;,
164             methNam, methSig, sig);
165 
166         if (stepEv[1] == 1) {
167             result = STATUS_FAILED;
168             NSK_COMPLAIN0(&quot;TEST FAILED: SingleStep event received after disabling the event generation\n\n&quot;);
169         }
170         else if ((strcmp(methNam,METHODS[0]) == 0) &amp;&amp;
171                 (strcmp(methSig,METHOD_SIGS[0]) == 0) &amp;&amp;
172                 (strcmp(sig,CLASS_SIG) == 0)) {
173             stepEv[0]++;
174             NSK_DISPLAY1(&quot;CHECK PASSED: SingleStep event received for the method \&quot;%s\&quot; as expected\n&quot;,
175                 methNam);
176         }
177         else if ((strcmp(methNam,METHODS[1]) == 0) &amp;&amp;
178                 (strcmp(methSig,METHOD_SIGS[1]) == 0) &amp;&amp;
179                 (strcmp(sig,CLASS_SIG) == 0)) {
180             stepEv[1]++;
181             NSK_DISPLAY1(
182                 &quot;CHECK PASSED: SingleStep event received for the method \&quot;%s\&quot; as expected\n&quot;
183                 &quot;\tdisabling the event generation\n&quot;,
184                 methNam);
185             if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, thread))) {
186                 result = STATUS_FAILED;
187                 NSK_COMPLAIN0(&quot;TEST FAILED: cannot disable SingleStep events\n\n&quot;);
188             }
189         }
190     }
191 
192     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*) methNam))) {
193         result = STATUS_FAILED;
194         NSK_COMPLAIN0(&quot;TEST FAILED: unable to deallocate memory pointed to method name\n\n&quot;);
195     }
196     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*) methSig))) {
197         result = STATUS_FAILED;
198         NSK_COMPLAIN0(&quot;TEST FAILED: unable to deallocate memory pointed to method signature\n\n&quot;);
199     }
200 
201     NSK_DISPLAY0(&quot;&lt;&lt;&lt;&lt;\n\n&quot;);
202 }
203 
204 void JNICALL
205 VMStart(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {
206     jvmti-&gt;RawMonitorEnter(agent_lock);
207 
208     callbacksEnabled = NSK_TRUE;
209 
210     jvmti-&gt;RawMonitorExit(agent_lock);
211 }
212 
213 void JNICALL
214 VMDeath(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {
215     jvmti-&gt;RawMonitorEnter(agent_lock);
216 
217     callbacksEnabled = NSK_FALSE;
218 
219     jvmti-&gt;RawMonitorExit(agent_lock);
220 }
221 /************************/
222 
223 JNIEXPORT jint JNICALL
224 Java_nsk_jvmti_SingleStep_singlestep001_check(
225         JNIEnv *env, jobject obj) {
226     int i;
227 
228     for (i=0; i&lt;METH_NUM; i++)
229         if (stepEv[i] == 0) {
230             result = STATUS_FAILED;
231             NSK_COMPLAIN1(&quot;TEST FAILED: no SingleStep events for the method \&quot;%s\&quot;\n\n&quot;,
232                 METHODS[i]);
233         }
234 
235     return result;
236 }
237 
238 #ifdef STATIC_BUILD
239 JNIEXPORT jint JNICALL Agent_OnLoad_singlestep001(JavaVM *jvm, char *options, void *reserved) {
240     return Agent_Initialize(jvm, options, reserved);
241 }
242 JNIEXPORT jint JNICALL Agent_OnAttach_singlestep001(JavaVM *jvm, char *options, void *reserved) {
243     return Agent_Initialize(jvm, options, reserved);
244 }
245 JNIEXPORT jint JNI_OnLoad_singlestep001(JavaVM *jvm, char *options, void *reserved) {
246     return JNI_VERSION_1_8;
247 }
248 #endif
249 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
250     jvmtiCapabilities caps;
251 
252     /* init framework and parse options */
253     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
254         return JNI_ERR;
255 
256     /* create JVMTI environment */
257     if (!NSK_VERIFY((jvmti =
258             nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))
259         return JNI_ERR;
260 
261     /* add capability to generate compiled method events */
262     memset(&amp;caps, 0, sizeof(jvmtiCapabilities));
263     caps.can_generate_breakpoint_events = 1;
264     caps.can_generate_single_step_events = 1;
265     if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
266         return JNI_ERR;
267 
268     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetCapabilities(&amp;caps)))
269         return JNI_ERR;
270 
271     if (!caps.can_generate_single_step_events)
272         NSK_DISPLAY0(&quot;Warning: generation of single step events is not implemented\n&quot;);
273 
274     /* set event callback */
275     NSK_DISPLAY0(&quot;setting event callbacks ...\n&quot;);
276     (void) memset(&amp;callbacks, 0, sizeof(callbacks));
277     callbacks.ClassLoad = &amp;ClassLoad;
278     callbacks.Breakpoint = &amp;Breakpoint;
279     callbacks.SingleStep = &amp;SingleStep;
280     callbacks.VMStart = &amp;VMStart;
281     callbacks.VMDeath = &amp;VMDeath;
282     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks))))
283         return JNI_ERR;
284 
285     NSK_DISPLAY0(&quot;setting event callbacks done\nenabling JVMTI events ...\n&quot;);
286     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL)))
287         return JNI_ERR;
288     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))
289         return JNI_ERR;
290     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL)))
291         return JNI_ERR;
292     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL)))
293         return JNI_ERR;
294     NSK_DISPLAY0(&quot;enabling the events done\n\n&quot;);
295 
296     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;agent lock&quot;, &amp;agent_lock)))
297         return JNI_ERR;
298 
299     return JNI_OK;
300 }
301 
302 }
    </pre>
  </body>
</html>
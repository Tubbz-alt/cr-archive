<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/jdi/EventSet/eventIterator/eventiterator003.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.EventSet.eventIterator;
 25 
 26 import nsk.share.*;
 27 import nsk.share.jdi.*;
 28 
 29 import com.sun.jdi.*;
 30 import com.sun.jdi.event.*;
 31 import com.sun.jdi.request.*;
 32 
 33 import java.util.*;
 34 import java.io.*;
 35 
 36 /**
 37  * The test for the implementation of an object of the type     &lt;BR&gt;
 38  * EventSet.                                                    &lt;BR&gt;
 39  *                                                              &lt;BR&gt;
 40  * The test checks that results of the method                   &lt;BR&gt;
 41  * &lt;code&gt;com.sun.jdi.EventSet.eventIterator()&lt;/code&gt;            &lt;BR&gt;
 42  * complies with its spec.                                      &lt;BR&gt;
 43  * &lt;BR&gt;
 44  * The test checks that for ThreadStartEvent and                &lt;BR&gt;
 45  * ThreadDeathEvent sets:                                       &lt;BR&gt;
 46  *  - the method returns non-null object;                       &lt;BR&gt;
 47  *  - object&#39;s class is subclass of class Iterator.             &lt;BR&gt;
 48  * &lt;BR&gt;
 49  * The test has three phases and works as follows.              &lt;BR&gt;
 50  * &lt;BR&gt;
 51  * In first phase,                                                      &lt;BR&gt;
 52  * upon launching debuggee&#39;s VM which will be suspended,                &lt;BR&gt;
 53  * a debugger waits for the VMStartEvent within a predefined            &lt;BR&gt;
 54  * time interval. If no the VMStartEvent received, the test is FAILED.  &lt;BR&gt;
 55  * Upon getting the VMStartEvent, it makes the request for debuggee&#39;s   &lt;BR&gt;
 56  * ClassPrepareEvent with SUSPEND_EVENT_THREAD, resumes the VM,         &lt;BR&gt;
 57  * and waits for the event within the predefined time interval.         &lt;BR&gt;
 58  * If no the ClassPrepareEvent received, the test is FAILED.            &lt;BR&gt;
 59  * Upon getting the ClassPrepareEvent,                                  &lt;BR&gt;
 60  * the debugger sets up the breakpoint with SUSPEND_EVENT_THREAD        &lt;BR&gt;
 61  * within debuggee&#39;s special methodForCommunication().                  &lt;BR&gt;
 62  * &lt;BR&gt;
 63  * In second phase the debugger and the debuggee perform the following. &lt;BR&gt;
 64  * - The debugger creates ThreadStartRequest,resumes the debuggee, and  &lt;BR&gt;
 65  *   waits for corresponding ThreadStartEvent.                          &lt;BR&gt;
 66  * - The debuggee starts new thread,  named &quot;thread2&quot;,                  &lt;BR&gt;
 67  *   whose running creates the needed events.                           &lt;BR&gt;
 68  * - Upon getting the ThreadStartEvent, the debugger checks up on it,   &lt;BR&gt;
 69  *   creates ThreadDeathRequest, resumes the debuggee, and              &lt;BR&gt;
 70  *   waits for corresponding ThreadDeathEvent.                          &lt;BR&gt;
 71  *   Upon getting the ThreadDeathEvent, the debugger checks up on it.   &lt;BR&gt;
 72  * &lt;BR&gt;
 73  * In third phase, the debugger and the debuggee end.                   &lt;BR&gt;
 74  * &lt;BR&gt;
 75  */
 76 
 77 public class eventiterator003 {
 78 
 79     //----------------------------------------------------- templete section
 80     static final int PASSED = 0;
 81 
 82     static final int FAILED = 2;
 83 
 84     static final int PASS_BASE = 95;
 85 
 86     //----------------------------------------------------- templete parameters
 87     static final String sHeader1 = &quot;\n==&gt; nsk/jdi/EventSet/eventIterator/eventiterator003 &quot;,
 88             sHeader2 = &quot;--&gt; debugger: &quot;, sHeader3 = &quot;##&gt; debugger: &quot;;
 89 
 90     //----------------------------------------------------- main method
 91 
 92     public static void main(String argv[]) {
 93 
 94         int result = run(argv, System.out);
 95 
 96         System.exit(result + PASS_BASE);
 97     }
 98 
 99     public static int run(String argv[], PrintStream out) {
100 
101         int exitCode = new eventiterator003().runThis(argv, out);
102 
103         if (exitCode != PASSED) {
104             System.out.println(&quot;TEST FAILED&quot;);
105         }
106         return testExitCode;
107     }
108 
109     //--------------------------------------------------   log procedures
110 
111     private static Log logHandler;
112 
113     private static void log1(String message) {
114         logHandler.display(sHeader1 + message);
115     }
116 
117     private static void log2(String message) {
118         logHandler.display(sHeader2 + message);
119     }
120 
121     private static void log3(String message) {
122         logHandler.complain(sHeader3 + message);
123     }
124 
125     //  ************************************************    test parameters
126 
127     private String debuggeeName = &quot;nsk.jdi.EventSet.eventIterator.eventiterator003a&quot;;
128 
129     private String testedClassName = &quot;nsk.jdi.EventSet.eventIterator.TestClass&quot;;
130 
131     //====================================================== test program
132     //------------------------------------------------------ common section
133 
134     static Debugee debuggee;
135 
136     static ArgumentHandler argsHandler;
137 
138     static int waitTime;
139 
140     static VirtualMachine vm = null;
141 
142     static EventRequestManager eventRManager = null;
143 
144     static EventQueue eventQueue = null;
145 
146     static EventSet eventSet = null;
147 
148     static EventIterator eventIterator = null;
149 
150     static ReferenceType debuggeeClass = null;
151 
152     static int testExitCode = PASSED;
153 
154     class JDITestRuntimeException extends RuntimeException {
155         JDITestRuntimeException(String str) {
156             super(&quot;JDITestRuntimeException : &quot; + str);
157         }
158     }
159 
160     //------------------------------------------------------ methods
161 
162     private int runThis(String argv[], PrintStream out) {
163 
164         argsHandler = new ArgumentHandler(argv);
165         logHandler = new Log(out, argsHandler);
166         Binder binder = new Binder(argsHandler, logHandler);
167 
168         waitTime = argsHandler.getWaitTime() * 60000;
169 
170         try {
171             log2(&quot;launching a debuggee :&quot;);
172             log2(&quot;       &quot; + debuggeeName);
173             if (argsHandler.verbose()) {
174                 debuggee = binder.bindToDebugee(debuggeeName + &quot; -vbs&quot;);
175             } else {
176                 debuggee = binder.bindToDebugee(debuggeeName);
177             }
178             if (debuggee == null) {
179                 log3(&quot;ERROR: no debuggee launched&quot;);
180                 return FAILED;
181             }
182             log2(&quot;debuggee launched&quot;);
183         } catch (Exception e) {
184             log3(&quot;ERROR: Exception : &quot; + e);
185             log2(&quot;       test cancelled&quot;);
186             return FAILED;
187         }
188 
189         debuggee.redirectOutput(logHandler);
190 
191         vm = debuggee.VM();
192 
193         eventQueue = vm.eventQueue();
194         if (eventQueue == null) {
195             log3(&quot;ERROR: eventQueue == null : TEST ABORTED&quot;);
196             vm.exit(PASS_BASE);
197             return FAILED;
198         }
199 
200         log2(&quot;invocation of the method runTest()&quot;);
201         switch (runTest()) {
202 
203         case 0:
204             log2(&quot;test phase has finished normally&quot;);
205             log2(&quot;   waiting for the debuggee to finish ...&quot;);
206             debuggee.waitFor();
207 
208             log2(&quot;......getting the debuggee&#39;s exit status&quot;);
209             int status = debuggee.getStatus();
210             if (status != PASS_BASE) {
211                 log3(&quot;ERROR: debuggee returned UNEXPECTED exit status: &quot; + status + &quot; != PASS_BASE&quot;);
212                 testExitCode = FAILED;
213             } else {
214                 log2(&quot;......debuggee returned expected exit status: &quot; + status + &quot; == PASS_BASE&quot;);
215             }
216             break;
217 
218         default:
219             log3(&quot;ERROR: runTest() returned unexpected value&quot;);
220 
221         case 1:
222             log3(&quot;test phase has not finished normally: debuggee is still alive&quot;);
223             log2(&quot;......forcing: vm.exit();&quot;);
224             testExitCode = FAILED;
225             try {
226                 vm.exit(PASS_BASE);
227             } catch (Exception e) {
228                 log3(&quot;ERROR: Exception : e&quot;);
229             }
230             break;
231 
232         case 2:
233             log3(&quot;test cancelled due to VMDisconnectedException&quot;);
234             log2(&quot;......trying: vm.process().destroy();&quot;);
235             testExitCode = FAILED;
236             try {
237                 Process vmProcess = vm.process();
238                 if (vmProcess != null) {
239                     vmProcess.destroy();
240                 }
241             } catch (Exception e) {
242                 log3(&quot;ERROR: Exception : e&quot;);
243             }
244             break;
245         }
246 
247         return testExitCode;
248     }
249 
250     /*
251      * Return value: 0 - normal end of the test
252      *               1 - ubnormal end of the test
253      *               2 - VMDisconnectedException while test phase
254      */
255 
256     private int runTest() {
257 
258         try {
259             testRun();
260 
261             log2(&quot;waiting for VMDeathEvent&quot;);
262             getEventSet();
263 
264             if (!(eventIterator.nextEvent() instanceof VMDeathEvent)) {
265                 log3(&quot;ERROR: last event is not the VMDeathEvent&quot;);
266                 return 1;
267             }
268 
269             log2(&quot;waiting for VMDisconnectEvent&quot;);
270             getEventSet();
271 
272             if (!(eventIterator.nextEvent() instanceof VMDisconnectEvent)) {
273                 log3(&quot;ERROR: last event is not the VMDisconnectEvent&quot;);
274                 return 1;
275             }
276 
277             return 0;
278 
279         } catch (VMDisconnectedException e) {
280             log3(&quot;ERROR: VMDisconnectedException : &quot; + e);
281             e.printStackTrace(logHandler.getOutStream());
282             return 2;
283         } catch (Exception e) {
284             log3(&quot;ERROR: Exception : &quot; + e);
285             return 1;
286         }
287 
288     }
289 
290     private void testRun() throws JDITestRuntimeException, Exception {
291 
292         eventRManager = vm.eventRequestManager();
293 
294         ClassPrepareRequest cpRequest = eventRManager.createClassPrepareRequest();
295         cpRequest.setSuspendPolicy(EventRequest.SUSPEND_EVENT_THREAD);
296         cpRequest.addClassFilter(debuggeeName);
297         cpRequest.enable();
298         vm.resume();
299         getEventSet();
300         cpRequest.disable();
301 
302         ClassPrepareEvent event = (ClassPrepareEvent) eventIterator.next();
303         debuggeeClass = event.referenceType();
304 
305         if (!debuggeeClass.name().equals(debuggeeName))
306             throw new JDITestRuntimeException(&quot;** Unexpected ClassName for ClassPrepareEvent **&quot;);
307 
308         log2(&quot;      received: ClassPrepareEvent for debuggeeClass&quot;);
309 
310         String bPointMethod = &quot;methodForCommunication&quot;;
311         String lineForComm = &quot;lineForComm&quot;;
312         BreakpointRequest bpRequest;
313 
314         ThreadReference mainThread = threadByName(&quot;main&quot;);
315 
316         bpRequest = settingBreakpoint(mainThread, debuggeeClass, bPointMethod, lineForComm, &quot;zero&quot;);
317         bpRequest.enable();
318 
319         //------------------------------------------------------  testing section
320 
321         log1(&quot;     TESTING BEGINS&quot;);
322 
323         String thread2Name = &quot;thread2&quot;;
324 
325         EventRequest eRequest = null;
326 
327         label0: {
328 
329             vm.resume();
330             breakpointForCommunication();
331 
332             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ variable part
333 
334             ThreadReference tr = (ThreadReference) debuggeeClass.getValue(debuggeeClass.fieldByName(thread2Name));
335 
336             log2(&quot;......setting up ThreadStartRequest&quot;);
337             eRequest = settingThreadStartRequest(tr, EventRequest.SUSPEND_EVENT_THREAD, &quot;ThreadStartRequest&quot;);
338             eRequest.enable();
339             vm.resume();
340             log2(&quot;......getting EventSet&quot;);
341             getEventSet();
342             eRequest.disable();
343 
344             String str = (String) eventIterator.nextEvent().request().getProperty(&quot;number&quot;);
345             if (!str.equals(&quot;ThreadStartRequest&quot;)) {
346                 testExitCode = FAILED;
347                 log3(&quot;ERROR: new event doesn&#39;t corresponds to ThreadStartRequest required&quot;);
348                 break label0;
349             }
350 
351             log2(&quot;......checking up on EventIterator&quot;);
352             if (eventIterator == null) {
353                 testExitCode = FAILED;
354                 log3(&quot;ERROR: eventIterator == null&quot;);
355             }
356             if (!(eventIterator instanceof Iterator)) {
357                 testExitCode = FAILED;
358                 log3(&quot;ERROR: eventIterator is NOT instanceof Iterator&quot;);
359             }
360 
361             log2(&quot;......setting up ThreadDeathRequest&quot;);
362             // suspend policy &#39;SUSPEND_ALL&#39; should be used for ThreadDeathRequest (see 6609499)
363             eRequest = settingThreadDeathRequest(tr, EventRequest.SUSPEND_ALL, &quot;ThreadDeathRequest&quot;);
364             eRequest.enable();
365             eventSet.resume();
366             log2(&quot;......getting EventSet&quot;);
367             getEventSet();
368             eRequest.disable();
369 
370             str = (String) eventIterator.nextEvent().request().getProperty(&quot;number&quot;);
371             if (!str.equals(&quot;ThreadDeathRequest&quot;)) {
372                 testExitCode = FAILED;
373                 log3(&quot;ERROR: new event doesn&#39;t corresponds to ThreadDeathRequest required&quot;);
374                 break label0;
375             }
376 
377             log2(&quot;......checking up on EventIterator&quot;);
378             if (eventIterator == null) {
379                 testExitCode = FAILED;
380                 log3(&quot;ERROR: eventIterator == null&quot;);
381             }
382             if (!(eventIterator instanceof Iterator)) {
383                 testExitCode = FAILED;
384                 log3(&quot;ERROR: eventIterator is NOT instanceof Iterator&quot;);
385             }
386 
387             eventSet.resume();
388             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
389         }
390 
391         log1(&quot;    TESTING ENDS&quot;);
392         return;
393     }
394 
395     private ThreadReference threadByName(String name) throws JDITestRuntimeException {
396 
397         List all = vm.allThreads();
398         ListIterator li = all.listIterator();
399 
400         for (; li.hasNext();) {
401             ThreadReference thread = (ThreadReference) li.next();
402             if (thread.name().equals(name))
403                 return thread;
404         }
405         throw new JDITestRuntimeException(&quot;** Thread IS NOT found ** : &quot; + name);
406     }
407 
408     /*
409      * private BreakpointRequest settingBreakpoint(ThreadReference, ReferenceType,
410      *                                             String, String, String)
411      *
412      * It sets up a breakpoint at given line number within a given method in a given class
413      * for a given thread.
414      *
415      * Return value: BreakpointRequest object  in case of success
416      *
417      * JDITestRuntimeException   in case of an Exception thrown within the method
418      */
419 
420     private BreakpointRequest settingBreakpoint(ThreadReference thread, ReferenceType testedClass, String methodName,
421             String bpLine, String property) throws JDITestRuntimeException {
422 
423         log2(&quot;......setting up a breakpoint:&quot;);
424         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass + &quot;; method: &quot; + methodName + &quot;; line: &quot; + bpLine);
425 
426         List alllineLocations = null;
427         Location lineLocation = null;
428         BreakpointRequest breakpRequest = null;
429 
430         try {
431             Method method = (Method) testedClass.methodsByName(methodName).get(0);
432 
433             alllineLocations = method.allLineLocations();
434 
435             int n = ((IntegerValue) testedClass.getValue(testedClass.fieldByName(bpLine))).value();
436             if (n &gt; alllineLocations.size()) {
437                 log3(&quot;ERROR:  TEST_ERROR_IN_settingBreakpoint(): number is out of bound of method&#39;s lines&quot;);
438             } else {
439                 lineLocation = (Location) alllineLocations.get(n);
440                 try {
441                     breakpRequest = eventRManager.createBreakpointRequest(lineLocation);
442                     breakpRequest.putProperty(&quot;number&quot;, property);
443                     breakpRequest.addThreadFilter(thread);
444                     breakpRequest.setSuspendPolicy(EventRequest.SUSPEND_EVENT_THREAD);
445                 } catch (Exception e1) {
446                     log3(&quot;ERROR: inner Exception within settingBreakpoint() : &quot; + e1);
447                     breakpRequest = null;
448                 }
449             }
450         } catch (Exception e2) {
451             log3(&quot;ERROR: ATTENTION:  outer Exception within settingBreakpoint() : &quot; + e2);
452             breakpRequest = null;
453         }
454 
455         if (breakpRequest == null) {
456             log2(&quot;      A BREAKPOINT HAS NOT BEEN SET UP&quot;);
457             throw new JDITestRuntimeException(&quot;**FAILURE to set up a breakpoint**&quot;);
458         }
459 
460         log2(&quot;      a breakpoint has been set up&quot;);
461         return breakpRequest;
462     }
463 
464     private void getEventSet() throws JDITestRuntimeException {
465         try {
466             eventSet = eventQueue.remove(waitTime);
467             if (eventSet == null) {
468                 throw new JDITestRuntimeException(&quot;** TIMEOUT while waiting for event **&quot;);
469             }
470             eventIterator = eventSet.eventIterator();
471         } catch (Exception e) {
472             throw new JDITestRuntimeException(&quot;** EXCEPTION while waiting for event ** : &quot; + e);
473         }
474     }
475 
476     private void breakpointForCommunication() throws JDITestRuntimeException {
477 
478         log2(&quot;breakpointForCommunication&quot;);
479         getEventSet();
480 
481         if (eventIterator.nextEvent() instanceof BreakpointEvent)
482             return;
483 
484         throw new JDITestRuntimeException(&quot;** event IS NOT a breakpoint **&quot;);
485     }
486 
487     // ============================== test&#39;s additional methods
488 
489     private ThreadStartRequest settingThreadStartRequest(ThreadReference thread, int suspendPolicy, String property)
490             throws JDITestRuntimeException {
491         try {
492             ThreadStartRequest tsr = eventRManager.createThreadStartRequest();
493             tsr.addThreadFilter(thread);
494             tsr.addCountFilter(1);
495             tsr.setSuspendPolicy(suspendPolicy);
496             tsr.putProperty(&quot;number&quot;, property);
497             return tsr;
498         } catch (Exception e) {
499             log3(&quot;ERROR: ATTENTION: Exception within settingThreadStartRequest() : &quot; + e);
500             log3(&quot;       ThreadStartRequest HAS NOT BEEN SET UP&quot;);
501             throw new JDITestRuntimeException(&quot;** FAILURE to set up ThreadStartRequest **&quot;);
502         }
503     }
504 
505     private ThreadDeathRequest settingThreadDeathRequest(ThreadReference thread, int suspendPolicy, String property)
506             throws JDITestRuntimeException {
507         try {
508             ThreadDeathRequest tdr = eventRManager.createThreadDeathRequest();
509             tdr.addThreadFilter(thread);
510             tdr.addCountFilter(1);
511             tdr.setSuspendPolicy(suspendPolicy);
512             tdr.putProperty(&quot;number&quot;, property);
513             return tdr;
514         } catch (Exception e) {
515             log3(&quot;ERROR: ATTENTION: Exception within settingThreadDeathRequest() : &quot; + e);
516             log3(&quot;       ThreadDeathRequest HAS NOT BEEN SET UP&quot;);
517             throw new JDITestRuntimeException(&quot;** FAILURE to set up ThreadDeathRequest **&quot;);
518         }
519     }
520 
521 }
    </pre>
  </body>
</html>
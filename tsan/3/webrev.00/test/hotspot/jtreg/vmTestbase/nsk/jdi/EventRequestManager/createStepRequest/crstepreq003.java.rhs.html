<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jdi/EventRequestManager/createStepRequest/crstepreq003.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.EventRequestManager.createStepRequest;
 25 
 26 import nsk.share.*;
 27 import nsk.share.jpda.*;
 28 import nsk.share.jdi.*;
 29 
 30 import com.sun.jdi.*;
 31 import com.sun.jdi.connect.*;
 32 import com.sun.jdi.request.*;
 33 import com.sun.jdi.event.*;
 34 import java.io.*;
 35 import java.util.*;
 36 
 37 /**
 38  */
 39 public class crstepreq003 {
 40 
 41     //----------------------------------------------------- immutable common fields
 42 
 43     static final int PASSED    = 0;
 44     static final int FAILED    = 2;
 45     static final int PASS_BASE = 95;
 46     static final int quit      = -1;
 47 
 48     private int instruction = 1;
 49     private int waitTime;
 50     private static int exitCode = PASSED;
 51 
 52     private ArgumentHandler     argHandler;
 53     private Log                 log;
 54     private Debugee             debuggee;
 55     private VirtualMachine      vm;
 56     private ReferenceType       debuggeeClass;
 57 
 58     private EventRequestManager eventRManager;
 59     private EventSet            eventSet;
 60     private EventIterator       eventIterator;
 61 
 62     //------------------------------------------------------ mutable common fields
 63 
 64     private final static String prefix = &quot;nsk.jdi.EventRequestManager.createStepRequest&quot;;
 65     private final static String className = &quot;.crstepreq003&quot;;
 66     private final static String debuggerName = prefix + className;
 67     private final static String debuggeeName = debuggerName + &quot;a&quot;;
 68 
 69     //------------------------------------------------------ immutable common methods
 70 
 71     public static void main (String argv[]) {
 72         System.exit(run(argv, System.out) + PASS_BASE);
 73     }
 74 
 75     //------------------------------------------------------ test specific fields
 76 
 77     static final int lineForBreakInThread    = 137;
 78     static final int[] checkedLines = { 138, 138, 178 };
 79 
 80     //------------------------------------------------------ mutable common methods
 81 
 82     public static int run (String argv[], PrintStream out) {
 83 
 84         int exitStatus = new crstepreq003().runThis(argv, out);
 85         System.out.println (exitStatus == PASSED ? &quot;TEST PASSED&quot; : &quot;TEST FAILED&quot;);
 86         return exitCode;
 87     }
 88 
 89     private int runThis(String argv[], PrintStream out) {
 90 
 91         argHandler = new ArgumentHandler(argv);
 92         log = new Log(out, argHandler);
 93         waitTime = argHandler.getWaitTime() * 60000;
 94 
 95         try {
 96 
 97             Binder binder = new Binder(argHandler, log);
 98             debuggee = binder.bindToDebugee(debuggeeName);
 99             debuggee.redirectStdout(log, &quot;debuggee stdout&gt; &quot;);
100             debuggee.redirectStderr(log, &quot;debuggee stderr&gt; &quot;);
101             debuggee.createIOPipe();
102             eventRManager = debuggee.getEventRequestManager();
103 
104             vm = debuggee.VM();
105             eventRManager = vm.eventRequestManager();
106 
107             debuggeeClass = waitForDebuggeeClassPrepared();
108 
109             execTest();
110 
111             debuggee.resume();
112             getEventSet();
113             if (eventIterator.nextEvent() instanceof VMDeathEvent) {
114                 display(&quot;Waiting for the debuggee&#39;s finish...&quot;);
115                 debuggee.waitFor();
116 
117                 display(&quot;Getting the debuggee&#39;s exit status.&quot;);
118                 int status = debuggee.getStatus();
119                 if (status != (PASSED + PASS_BASE)) {
120                     complain(&quot;Debuggee returned UNEXPECTED exit status: &quot; + status);
121                     exitCode = Consts.TEST_FAILED;
122                 }
123             } else {
124                 throw new TestBug(&quot;Last event is not the VMDeathEvent&quot;);
125             }
126 
127         } catch (VMDisconnectedException e) {
128             exitCode = Consts.TEST_FAILED;
129             complain(&quot;The test cancelled due to VMDisconnectedException.&quot;);
130             e.printStackTrace(out);
131             display(&quot;Trying: vm.process().destroy();&quot;);
132             if (vm != null) {
133                 Process vmProcess = vm.process();
134                 if (vmProcess != null) {
135                     vmProcess.destroy();
136                 }
137             }
138 
139         } catch (Exception e) {
140             exitCode = Consts.TEST_FAILED;
141             complain(&quot;Unexpected Exception: &quot; + e.getMessage());
142             e.printStackTrace(out);
143             complain(&quot;The test has not finished normally. Forcing: vm.exit().&quot;);
144             if (vm != null) {
145                 vm.exit(PASSED + PASS_BASE);
146             }
147             debuggee.resume();
148             getEventSet();
149         }
150 
151         return exitCode;
152     }
153 
154     //--------------------------------------------------------- mutable common methods
155 
156     private void execTest() {
<a name="1" id="anc1"></a><span class="line-modified">157         ThreadReference mainThread = debuggee.threadByNameOrThrow(&quot;main&quot;);</span>
158 /*
159         BreakpointRequest bpRequest = setBreakpoint( mainThread,
160                                                      debuggeeClass,
161                                                      &quot;methodForCommunication&quot;,
162                                                      2,
163                                                      &quot;breakpointForCommunication&quot;);
164 */
165         BreakpointRequest bpRequest = setBreakpoint( null,
166                                                      debuggeeClass,
167                                                      &quot;breakInThread&quot;,
168                                                      lineForBreakInThread,
169                                                      &quot;breakInThread&quot;);
170         bpRequest.enable();
171 
172         display(&quot;TESTING BEGINS&quot;);
173 
174         label0:
175         for (int testCase = 0; instruction != quit; testCase++) {
176 
177 //            waitForEvent(bpRequest);
178             instruction = getInstruction();
179             if (instruction == quit) {
180                 vm.resume();
181                 break;
182             }
183 
184             display(&quot;:: case: # &quot; + testCase);
185 
186             switch (testCase) {
187             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ test case section
188                  case 0:
189                      display(&quot;Step request will be created with size == StepRequest.STEP_LINE, depth == StepRequest.STEP_INTO&quot;);
190                      setAndCheckStepEvent ( bpRequest,
191                                             &quot;StepRequest0&quot;,
192                                             &quot;thread0&quot;,
193                                             checkedLines[testCase],
194                                             StepRequest.STEP_INTO);
195                      break;
196 
197                  case 1:
198                      display(&quot;Step request will be created with size == StepRequest.STEP_LINE, depth == StepRequest.STEP_OVER&quot;);
199                      setAndCheckStepEvent ( bpRequest,
200                                             &quot;StepRequest1&quot;,
201                                             &quot;thread1&quot;,
202                                             checkedLines[testCase],
203                                             StepRequest.STEP_OVER);
204                      break;
205                  case 2:
206                      display(&quot;Step request will be created with size == StepRequest.STEP_LINE, depth == StepRequest.STEP_OUT&quot;);
207                      setAndCheckStepEvent ( bpRequest,
208                                             &quot;StepRequest2&quot;,
209                                             &quot;thread2&quot;,
210                                             checkedLines[testCase],
211                                             StepRequest.STEP_OUT);
212             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ end of section
213                  default:
214                      instruction = quit;
215                      setInstruction(&quot;quit&quot;);
216             }
217         }
218         display(&quot;TESTING ENDS&quot;);
219     }
220 
221     //--------------------------------------------------------- test specific methodss
222 
223     private StepRequest setStepRequest ( ThreadReference thread, int size, int depth, String property ) {
224         display(&quot;Setting a step request in  thread: &quot; + thread);
225         StepRequest stepRequest = null;
226 
227         try {
228             stepRequest = eventRManager.createStepRequest(thread, size, depth);
229             stepRequest.putProperty(&quot;number&quot;, property);
230         } catch ( Exception e1 ) {
231             complain(&quot;setStepRequest(): unexpected Exception while creating StepRequest: &quot; + e1);
232             throw new Failure(&quot;setStep(): A StepRequest has not been set up.&quot;);
233         }
234 
235         display(&quot;setStepRequest(): A StepRequest has been set up.&quot;);
236         return stepRequest;
237     }
238 
239     private void setAndCheckStepEvent ( BreakpointRequest bpRequest,
240                                         String caseProperty,
241                                         String threadName,
242                                         int lineOfStepEvent,
243                                         int stepDepth             ) {
244         display(&quot;Wait for brakepoint event in &quot; + threadName);
245         BreakpointEvent bpEvent = (BreakpointEvent)waitForEvent(bpRequest);
246 
247         // check location of breakpoint event
248         int lineOfEvent = ((LocatableEvent)bpEvent).location().lineNumber();
249         if (lineOfEvent != lineForBreakInThread) {
250             complain(&quot;Wrong line number of BreakpointEvent for &quot; + threadName);
251             complain(&quot;\texpected value : &quot; + lineForBreakInThread + &quot;; got one : &quot; + lineOfEvent);
252             exitCode = FAILED;
253         }
254 
<a name="2" id="anc2"></a><span class="line-modified">255         ThreadReference thread = debuggee.threadByNameOrThrow(threadName);</span>
256         StepRequest stepRequest = setStepRequest( thread,
257                                                   StepRequest.STEP_LINE,
258                                                   stepDepth,
259                                                   caseProperty);
260         stepRequest.enable();
261 
262         display(&quot;waiting for StepEvent in &quot; + threadName);
263         Event newEvent = waitForEvent(stepRequest);
264         if (newEvent instanceof StepEvent) {
265             String property = (String) newEvent.request().getProperty(&quot;number&quot;);
266             display(&quot;got new StepEvent with property &#39;number&#39; == &quot; + property);
267 
268             if ( !property.equals(caseProperty) ) {
269                 complain(&quot;property is not : &quot; + caseProperty);
270                 exitCode = FAILED;
271             }
272             // check location of step event
273             lineOfEvent = ((LocatableEvent)newEvent).location().lineNumber();
274             if (lineOfEvent != lineOfStepEvent) {
275                 switch (stepDepth) {
276                      case StepRequest.STEP_INTO:
277                          complain(&quot;Wrong line number of StepEvent for request with depth == StepRequest.STEP_INTO:&quot; );
278                          break;
279                      case StepRequest.STEP_OVER:
280                          complain(&quot;Wrong line number of StepEvent for request with depth == StepRequest.STEP_OVER:&quot; );
281                          break;
282                      case StepRequest.STEP_OUT:
283                          complain(&quot;Wrong line number of StepEvent for request with depth == StepRequest.STEP_OUT:&quot; );
284                          break;
285                 }
286                 complain(&quot;\texpected value : &quot; + lineOfStepEvent + &quot;; got one : &quot; + lineOfEvent);
287                 exitCode = FAILED;
288             }
289 
290         } else if (newEvent instanceof BreakpointEvent) {
291             vm.resume();
292             exitCode = FAILED;
293             complain(&quot;got unexpected BreakpointEvent, but StepEvent is not received&quot;);
294         } else if (newEvent instanceof VMDeathEvent) {
295             exitCode = FAILED;
296             throw new Failure(&quot;got unexpected VMDeathtEvent, but StepEvent is not received&quot;);
297         }
298 
299         stepRequest.disable();
300         eventRManager.deleteEventRequest(stepRequest);
301         stepRequest = null;
302         display(&quot;request for StepEvent in &quot; + threadName + &quot; is deleted&quot;);
303     }
304 
305     //--------------------------------------------------------- immutable common methods
306 
307     void display(String msg) {
308         log.display(&quot;debugger &gt; &quot; + msg);
309     }
310 
311     void complain(String msg) {
312         log.complain(&quot;debugger FAILURE &gt; &quot; + msg);
313     }
314 
315    /**
316     * Sets up a breakpoint at given line number within a given method in a given class
317     * for a given thread.
318     *
319     * Returns a BreakpointRequest object in case of success, otherwise throws Failure.
320     */
321     private BreakpointRequest setBreakpoint ( ThreadReference thread,
322                                               ReferenceType testedClass,
323                                               String methodName,
324                                               int bpLine,
325                                               String property) {
326 
327         display(&quot;Setting a breakpoint in :&quot;);
328         display(&quot;  thread: &quot; + thread + &quot;; class: &quot; + testedClass +
329                 &quot;; method: &quot; + methodName + &quot;; line: &quot; + bpLine + &quot;; property: &quot; + property);
330 
331         List allLineLocations = null;
332         Location lineLocation = null;
333         BreakpointRequest breakpRequest = null;
334 
335         try {
336             Method  method  = (Method) testedClass.methodsByName(methodName).get(0);
337 
338             allLineLocations = method.allLineLocations();
339 
340             display(&quot;Getting location for breakpoint...&quot;);
341             Iterator locIterator = allLineLocations.iterator();
342             while (locIterator.hasNext()) {
343                 Location curLocation = (Location)locIterator.next();
344                 int curNumber = curLocation.lineNumber();
345                 if (curLocation.lineNumber() == bpLine) {
346                     lineLocation = curLocation;
347                     break;
348                 }
349             }
350             if (lineLocation == null) {
351                 throw new TestBug(&quot;Incorrect line number of methods&#39; location&quot;);
352             }
353 
354             try {
355                 breakpRequest = eventRManager.createBreakpointRequest(lineLocation);
356                 if (thread != null) {
357                     breakpRequest.addThreadFilter(thread);
358                 }
359                 breakpRequest.putProperty(&quot;number&quot;, property);
360             } catch ( Exception e1 ) {
361                 complain(&quot;setBreakpoint(): unexpected Exception while creating BreakpointRequest: &quot; + e1);
362                 breakpRequest = null;
363             }
364         } catch ( Exception e2 ) {
365             complain(&quot;setBreakpoint(): unexpected Exception while getting locations: &quot; + e2);
366             breakpRequest = null;
367         }
368 
369         if (breakpRequest == null) {
370             throw new Failure(&quot;setBreakpoint(): A breakpoint has not been set up.&quot;);
371         }
372 
373         display(&quot;setBreakpoint(): A breakpoint has been set up.&quot;);
374         return breakpRequest;
375     }
376 
377     private Event waitForEvent (EventRequest eventRequest) {
378 
379         vm.resume();
380         Event resultEvent = null;
381         try {
382             eventSet = null;
383             eventIterator = null;
384             eventSet = vm.eventQueue().remove(waitTime);
385             if (eventSet == null) {
386                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
387             }
388             eventIterator = eventSet.eventIterator();
389             while (eventIterator.hasNext()) {
390                 Event curEvent = eventIterator.nextEvent();
391                 if (curEvent instanceof VMDisconnectEvent) {
392                     throw new Failure(&quot;Unexpected VMDisconnectEvent received.&quot;);
393                 } else {
394                     EventRequest evRequest = curEvent.request();
395                     if (evRequest != null &amp;&amp; evRequest.equals(eventRequest)) {
396                         display(&quot;Requested event received: &quot; + curEvent.toString() +
397                             &quot;; request property: &quot; + (String) curEvent.request().getProperty(&quot;number&quot;));
398                         resultEvent = curEvent;
399                         break;
400                     } else {
401                         throw new Failure(&quot;Unexpected event received: &quot; + curEvent.toString());
402                     }
403                 }
404             }
405         } catch (Exception e) {
406             throw new Failure(&quot;Unexpected exception while waiting for an event: &quot; + e);
407         }
408         return resultEvent;
409     }
410 
411 
412     private void getEventSet() {
413         try {
414             eventSet = vm.eventQueue().remove(waitTime);
415             if (eventSet == null) {
416                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
417             }
418             eventIterator = eventSet.eventIterator();
419         } catch (Exception e) {
420             throw new Failure(&quot;getEventSet(): Unexpected exception while waiting for an event: &quot; + e);
421         }
422     }
423 
<a name="3" id="anc3"></a>












424     private ReferenceType waitForDebuggeeClassPrepared () {
425         display(&quot;Creating request for ClassPrepareEvent for debuggee.&quot;);
426         ClassPrepareRequest cpRequest = eventRManager.createClassPrepareRequest();
427         cpRequest.addClassFilter(debuggeeName);
428         cpRequest.addCountFilter(1);
429         cpRequest.enable();
430 
431         ClassPrepareEvent event = (ClassPrepareEvent) waitForEvent(cpRequest);
432         cpRequest.disable();
433 
434         if (!event.referenceType().name().equals(debuggeeName)) {
435            throw new Failure(&quot;Unexpected class name for ClassPrepareEvent : &quot; + debuggeeClass.name());
436         }
437         return event.referenceType();
438     }
439 
440     private int getInstruction () {
441         if (debuggeeClass == null) {
442             throw new Failure(&quot;getInstruction() :: debuggeeClass reference is null&quot;);
443         }
444         return ((IntegerValue) (debuggeeClass.getValue(debuggeeClass.fieldByName(&quot;instruction&quot;)))).value();
445     }
446 
447     private void setInstruction (String instructionField) {
448         if (debuggeeClass == null) {
449             throw new Failure(&quot;getInstruction() :: debuggeeClass reference is null&quot;);
450         }
451         Field instrField = debuggeeClass.fieldByName(&quot;instruction&quot;);
452         IntegerValue instrValue = (IntegerValue) (debuggeeClass.getValue(debuggeeClass.fieldByName(instructionField)));
453         try {
454             ((ClassType)debuggeeClass).setValue(instrField, instrValue );
455         } catch (InvalidTypeException e1) {
456             throw new Failure(&quot;Caught unexpected InvalidTypeException while setting value &#39;&quot; + instructionField + &quot;&#39; for instruction field&quot;);
457         } catch (ClassNotLoadedException e2) {
458             throw new Failure(&quot;Caught unexpected ClassNotLoadedException while setting value &#39;&quot; + instructionField + &quot;&#39; for instruction field&quot;);
459         }
460     }
461 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
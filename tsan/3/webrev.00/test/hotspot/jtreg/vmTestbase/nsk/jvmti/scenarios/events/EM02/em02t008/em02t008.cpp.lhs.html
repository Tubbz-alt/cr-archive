<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t008/em02t008.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* ============================================================================= */
 34 
 35 /* scaffold objects */
 36 static jvmtiEnv *jvmti = NULL;
 37 static jlong timeout = 0;
 38 static jrawMonitorID syncLock = NULL;
 39 
 40 /* constant names */
 41 #define STEP_NUMBER 3
 42 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 43 
 44 static int eventCount[JVMTI_EVENT_COUNT];
 45 static int newEventCount[JVMTI_EVENT_COUNT];
 46 
 47 /* ============================================================================= */
 48 
 49 static void
 50 showEventStatistics(int step) {
 51     int i;
 52     const char* str;
 53     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 54 
 55     NSK_DISPLAY0(&quot;\n&quot;);
 56     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 57     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 58     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 59         if (currentCounts[i] &gt; 0) {
 60             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 61             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 62         }
 63     }
 64 }
 65 
 66 /* ========================================================================== */
 67 
 68 int checkEvents(int step) {
 69     int i;
 70     jvmtiEvent curr;
<a name="2" id="anc2"></a><span class="line-modified"> 71     int result = NSK_TRUE;</span>
 72     int *currentCounts;
 73     int isExpected = 0;
 74 
 75     switch (step) {
 76         case 1:
 77             currentCounts = &amp;eventCount[0];
 78             break;
 79 
 80         case 2:
 81         case 3:
 82             currentCounts = &amp;newEventCount[0];
 83             break;
 84 
 85         default:
 86             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<a name="3" id="anc3"></a><span class="line-modified"> 87             return NSK_FALSE;</span>
 88     }
 89 
 90     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 91 
 92         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 93 
 94         switch (step) {
 95             case 1:
 96                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
 97                                 || (curr == JVMTI_EVENT_EXCEPTION)
 98                                 || (curr == JVMTI_EVENT_EXCEPTION_CATCH));
 99                 break;
100 
101             case 2:
102                 isExpected = ((curr == JVMTI_EVENT_EXCEPTION)
103                                 || (curr == JVMTI_EVENT_EXCEPTION_CATCH));
104                 break;
105 
106             case 3:
107                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
108                 break;
109         }
110 
111         if (isExpected) {
112             if (currentCounts[i] &lt; 1) {
113                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
114                                         currentCounts[i],
115                                         TranslateEvent(curr));
<a name="4" id="anc4"></a><span class="line-modified">116                 result = NSK_FALSE;</span>
117             }
118         } else {
119 
120             if (currentCounts[i] &gt; 0) {
121                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
122                                     TranslateEvent(curr),
123                                     currentCounts[i]);
<a name="5" id="anc5"></a><span class="line-modified">124                 result = NSK_FALSE;</span>
125             }
126         }
127     }
128 
129     return result;
130 }
131 
132 static void
133 changeCount(jvmtiEvent event, int *currentCounts) {
134 
135     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
136         nsk_jvmti_setFailStatus();
137 
138     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
139 
140     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
141         nsk_jvmti_setFailStatus();
142 
143 }
144 
145 /* ============================================================================= */
146 
147 /* callbacks */
148 JNIEXPORT void JNICALL
149 cbVMInit(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread) {
150     changeCount(JVMTI_EVENT_VM_INIT, &amp;eventCount[0]);
151 }
152 
153 JNIEXPORT void JNICALL
154 cbVMDeath(jvmtiEnv* jvmti, JNIEnv* jni_env) {
155     changeCount(JVMTI_EVENT_VM_DEATH, &amp;newEventCount[0]);
156     showEventStatistics(STEP_NUMBER);
157     if (!checkEvents(STEP_NUMBER))
158         nsk_jvmti_setFailStatus();
159 
160     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock)))
161         nsk_jvmti_setFailStatus();
162 
163 }
164 
165 void JNICALL
166 cbException(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
167                 jmethodID method, jlocation location, jobject exception,
168                 jmethodID catch_method, jlocation catch_location) {
169 
170     jvmtiThreadInfo info_ptr;
171 
172     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetThreadInfo(thread, &amp;info_ptr))) {
173         nsk_jvmti_setFailStatus();
174         return;
175     }
176 
177     if (!strncmp(info_ptr.name,&quot;em02t008&quot;, 8)) {
178         NSK_DISPLAY1(&quot;\tThread: %s\n&quot;, info_ptr.name);
179 
180         changeCount(JVMTI_EVENT_EXCEPTION, &amp;eventCount[0]);
181     }
182 
183     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)info_ptr.name))) {
184         nsk_jvmti_setFailStatus();
185     }
186 }
187 
188 void JNICALL
189 cbNewException(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
190                 jmethodID method, jlocation location, jobject exception,
191                 jmethodID catch_method, jlocation catch_location) {
192 
193     jvmtiThreadInfo info_ptr;
194 
195     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetThreadInfo(thread, &amp;info_ptr))) {
196         nsk_jvmti_setFailStatus();
197         return;
198     }
199 
200     if (!strncmp(info_ptr.name,&quot;em02t008&quot;, 8)) {
201         NSK_DISPLAY1(&quot;\tThread: %s\n&quot;, info_ptr.name);
202 
203         changeCount(JVMTI_EVENT_EXCEPTION, &amp;newEventCount[0]);
204     }
205 
206     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)info_ptr.name))) {
207         nsk_jvmti_setFailStatus();
208     }
209 }
210 
211 void JNICALL
212 cbExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
213                 jmethodID method, jlocation location, jobject exception) {
214 
215     jvmtiThreadInfo info_ptr;
216 
217     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetThreadInfo(thread, &amp;info_ptr))) {
218         nsk_jvmti_setFailStatus();
219         return;
220     }
221 
222     if (!strncmp(info_ptr.name,&quot;em02t008&quot;, 8)) {
223         NSK_DISPLAY1(&quot;\tThread: %s\n&quot;, info_ptr.name);
224 
225         changeCount(JVMTI_EVENT_EXCEPTION_CATCH, &amp;eventCount[0]);
226     }
227 
228     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)info_ptr.name))) {
229         nsk_jvmti_setFailStatus();
230     }
231 }
232 
233 void JNICALL
234 cbNewExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
235                 jmethodID method, jlocation location, jobject exception) {
236 
237     jvmtiThreadInfo info_ptr;
238 
239     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetThreadInfo(thread, &amp;info_ptr))) {
240         nsk_jvmti_setFailStatus();
241         return;
242     }
243 
244     if (!strncmp(info_ptr.name,&quot;em02t008&quot;, 8)) {
245         NSK_DISPLAY1(&quot;\tThread: %s\n&quot;, info_ptr.name);
246 
247         changeCount(JVMTI_EVENT_EXCEPTION_CATCH, &amp;newEventCount[0]);
248     }
249 
250     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)info_ptr.name))) {
251         nsk_jvmti_setFailStatus();
252     }
253 }
254 
255 void JNICALL
256 cbSingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
257                 jmethodID method, jlocation location) {
258 
259     changeCount(JVMTI_EVENT_SINGLE_STEP, &amp;eventCount[0]);
260 }
261 
262 void JNICALL
263 cbFramePop(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
264                 jmethodID method, jboolean was_popped_by_exception) {
265     changeCount(JVMTI_EVENT_FRAME_POP, &amp;eventCount[0]);
266 }
267 
268 void JNICALL
269 cbBreakpoint(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
270                 jmethodID method, jlocation location) {
271     changeCount(JVMTI_EVENT_BREAKPOINT, &amp;eventCount[0]);
272 }
273 
274 void JNICALL
275 cbFieldAccess(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
276                 jmethodID method, jlocation location, jclass field_klass,
277                 jobject object, jfieldID field) {
278     changeCount(JVMTI_EVENT_FIELD_ACCESS, &amp;eventCount[0]);
279 }
280 
281 void JNICALL
282 cbFieldModification(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
283                 jmethodID method, jlocation location, jclass field_klass,
284                 jobject object, jfieldID field, char signature_type,
285                 jvalue new_value) {
286     changeCount(JVMTI_EVENT_FIELD_MODIFICATION, &amp;eventCount[0]);
287 }
288 
289 void JNICALL
290 cbMethodEntry(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
291                 jmethodID method) {
292     changeCount(JVMTI_EVENT_METHOD_ENTRY, &amp;eventCount[0]);
293 }
294 
295 void JNICALL
296 cbMethodExit(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
297                 jmethodID method, jboolean was_popped_by_exception,
298                 jvalue return_value) {
299     changeCount(JVMTI_EVENT_METHOD_EXIT, &amp;eventCount[0]);
300 }
301 
302 void JNICALL
303 cbNativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env,jthread thread,
304                 jmethodID method, void* address, void** new_address_ptr) {
305     changeCount(JVMTI_EVENT_NATIVE_METHOD_BIND, &amp;eventCount[0]);
306 }
307 
308 void JNICALL
309 cbMonitorWait(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
310                     jobject object, jlong tout) {
311 
312     changeCount(JVMTI_EVENT_MONITOR_WAIT, &amp;eventCount[0]);
313 }
314 
315 void JNICALL
316 cbMonitorWaited(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
317                     jobject object, jboolean timed_out) {
318 
319     changeCount(JVMTI_EVENT_MONITOR_WAITED, &amp;eventCount[0]);
320 }
321 
322 JNIEXPORT void JNICALL
323 cbMonitorContendedEnter(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread,
324                             jobject object) {
325 
326     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTER, &amp;eventCount[0]);
327 }
328 
329 void JNICALL
330 cbMonitorContendedEntered(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
331                             jobject object) {
332 
333     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, &amp;eventCount[0]);
334 }
335 
336 void JNICALL
337 cbCompiledMethodLoad(jvmtiEnv *jvmti_env, jmethodID method, jint code_size,
338                 const void* code_addr, jint map_length,
339                 const jvmtiAddrLocationMap* map, const void* compile_info) {
340     changeCount(JVMTI_EVENT_COMPILED_METHOD_LOAD, &amp;eventCount[0]);
341 }
342 
343 void JNICALL
344 cbCompiledMethodUnload(jvmtiEnv *jvmti_env, jmethodID method,
345                 const void* code_addr) {
346     changeCount(JVMTI_EVENT_COMPILED_METHOD_UNLOAD, &amp;eventCount[0]);
347 }
348 
349 void JNICALL
350 cbGarbageCollectionStart(jvmtiEnv *jvmti_env) {
351     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_START, &amp;eventCount[0]);
352 }
353 
354 void JNICALL
355 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
356     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
357 }
358 
359 void JNICALL
360 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
361 
362     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
363 }
364 
365 void JNICALL
366 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
367                     jobject object, jclass object_klass, jlong size) {
368 
369     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
370 }
371 
372 /* ============================================================================= */
373 
<a name="6" id="anc6"></a><span class="line-modified">374 static int enableEvent(jvmtiEvent event) {</span>
375 
376     if (nsk_jvmti_isOptionalEvent(event)
377             &amp;&amp; (event != JVMTI_EVENT_EXCEPTION)
378             &amp;&amp; (event != JVMTI_EVENT_EXCEPTION_CATCH)) {
379         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
380                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
381             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
382                 TranslateEvent(event));
<a name="7" id="anc7"></a><span class="line-modified">383             return NSK_FALSE;</span>
384         }
385     } else {
386         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
387             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
388                 TranslateEvent(event));
<a name="8" id="anc8"></a><span class="line-modified">389             return NSK_FALSE;</span>
390         }
391     }
392 
<a name="9" id="anc9"></a><span class="line-modified">393     return NSK_TRUE;</span>
394 }
395 
396 /**
397  * Enable or disable tested events.
398  */
<a name="10" id="anc10"></a><span class="line-modified">399 static int enableEventList() {</span>
400 
401     int i, result;
402 
403     result = enableEvent(JVMTI_EVENT_VM_INIT);
404 
405     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
406 
407     /* enabling optional events */
408     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
409         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
410 
411         if (nsk_jvmti_isOptionalEvent(event))
412             result = result &amp;&amp; enableEvent(event);
413     }
414 
<a name="11" id="anc11"></a><span class="line-modified">415     if (result == NSK_FALSE) {</span>
416         nsk_jvmti_setFailStatus();
<a name="12" id="anc12"></a><span class="line-modified">417         return NSK_FALSE;</span>
418     }
419 
<a name="13" id="anc13"></a><span class="line-modified">420     return NSK_TRUE;</span>
421 }
422 
423 /* ============================================================================= */
424 
<a name="14" id="anc14"></a><span class="line-modified">425 static int</span>
<span class="line-removed">426 setCallBacks(int step) {</span>
427 
428     int i;
429 
430     jvmtiEventCallbacks eventCallbacks;
431     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
432 
433     switch (step) {
434         case 1:
435             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
436                 eventCount[i] = 0;
437             }
438 
439             eventCallbacks.VMInit                    = cbVMInit;
440             eventCallbacks.Exception                 = cbException;
441             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
442             eventCallbacks.SingleStep                = cbSingleStep;
443             eventCallbacks.FramePop                  = cbFramePop;
444             eventCallbacks.Breakpoint                = cbBreakpoint;
445             eventCallbacks.FieldAccess               = cbFieldAccess;
446             eventCallbacks.FieldModification         = cbFieldModification;
447             eventCallbacks.MethodEntry               = cbMethodEntry;
448             eventCallbacks.MethodExit                = cbMethodExit;
449             eventCallbacks.NativeMethodBind          = cbNativeMethodBind;
450             eventCallbacks.CompiledMethodLoad        = cbCompiledMethodLoad;
451             eventCallbacks.CompiledMethodUnload      = cbCompiledMethodUnload;
452             eventCallbacks.MonitorWait               = cbMonitorWait;
453             eventCallbacks.MonitorWaited             = cbMonitorWaited;
454             eventCallbacks.MonitorContendedEnter     = cbMonitorContendedEnter;
455             eventCallbacks.MonitorContendedEntered   = cbMonitorContendedEntered;
456             eventCallbacks.GarbageCollectionStart    = cbGarbageCollectionStart;
457             eventCallbacks.GarbageCollectionFinish   = cbGarbageCollectionFinish;
458             eventCallbacks.ObjectFree                = cbObjectFree;
459             eventCallbacks.VMObjectAlloc             = cbVMObjectAlloc;
460             break;
461 
462         case 2:
463             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
464                 newEventCount[i] = 0;
465             }
466 
467             eventCallbacks.Exception                 = cbNewException;
468             eventCallbacks.ExceptionCatch            = cbNewExceptionCatch;
469             break;
470 
471         case 3:
472             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
473                 newEventCount[i] = 0;
474             }
475 
476             eventCallbacks.VMDeath                   = cbVMDeath;
477             break;
478 
479     }
480     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<a name="15" id="anc15"></a><span class="line-modified">481         return NSK_FALSE;</span>
482 
<a name="16" id="anc16"></a><span class="line-modified">483     return NSK_TRUE;</span>
484 }
485 
486 /* ============================================================================= */
487 
488 /** Agent algorithm. */
489 static void JNICALL
490 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
491 
492     int i;
493 
494     for (i = 1; i &lt;= STEP_NUMBER; i++) {
495 
496         if (!nsk_jvmti_waitForSync(timeout))
497             return;
498 
499         if (i &lt; STEP_NUMBER) {
500             showEventStatistics(i);
501             if (!checkEvents(i))
502                 nsk_jvmti_setFailStatus();
503 
504             if (!setCallBacks(i + 1)) {
505                 return;
506             }
507         }
508 
509         if (!nsk_jvmti_resumeSync())
510             return;
511     }
512 
513 }
514 
515 /* ============================================================================= */
516 
517 /** Agent library initialization. */
518 #ifdef STATIC_BUILD
519 JNIEXPORT jint JNICALL Agent_OnLoad_em02t008(JavaVM *jvm, char *options, void *reserved) {
520     return Agent_Initialize(jvm, options, reserved);
521 }
522 JNIEXPORT jint JNICALL Agent_OnAttach_em02t008(JavaVM *jvm, char *options, void *reserved) {
523     return Agent_Initialize(jvm, options, reserved);
524 }
525 JNIEXPORT jint JNI_OnLoad_em02t008(JavaVM *jvm, char *options, void *reserved) {
526     return JNI_VERSION_1_8;
527 }
528 #endif
529 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
530 
531     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
532         return JNI_ERR;
533 
534     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
535 
536     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
537     if (!NSK_VERIFY(jvmti != NULL))
538         return JNI_ERR;
539 
540     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock))) {
541         nsk_jvmti_setFailStatus();
542         return JNI_ERR;
543     }
544 
545     {
546         jvmtiCapabilities caps;
547         memset(&amp;caps, 0, sizeof(caps));
548 
549         caps.can_generate_exception_events = 1;
550         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
551             return JNI_ERR;
552     }
553 
554     if (!setCallBacks(1)) {
555         return JNI_ERR;
556     }
557 
558     if (!enableEventList()) {
559         return JNI_ERR;
560     }
561 
562     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
563         return JNI_ERR;
564 
565     return JNI_OK;
566 }
567 
568 /* ============================================================================= */
569 
570 
571 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
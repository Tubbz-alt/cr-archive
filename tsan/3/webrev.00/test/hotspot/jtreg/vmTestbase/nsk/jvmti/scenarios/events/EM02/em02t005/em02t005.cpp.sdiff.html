<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t005/em02t005.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../em02t004/em02t004.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../em02t006/em02t006.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t005/em02t005.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 53     int i;
 54     const char* str;
 55     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 56 
 57     NSK_DISPLAY0(&quot;\n&quot;);
 58     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 59     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 60     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 61         if (currentCounts[i] &gt; 0) {
 62             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 63             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 64         }
 65     }
 66 }
 67 
 68 /* ========================================================================== */
 69 
 70 int checkEvents(int step) {
 71     int i;
 72     jvmtiEvent curr;
<span class="line-modified"> 73     int result = NSK_TRUE;</span>
 74     int *currentCounts;
 75     int isExpected = 0;
 76 
 77     switch (step) {
 78         case 1:
 79             currentCounts = &amp;eventCount[0];
 80             break;
 81 
 82         case 2:
 83         case 3:
 84             currentCounts = &amp;newEventCount[0];
 85             break;
 86 
 87         default:
 88             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified"> 89             return NSK_FALSE;</span>
 90     }
 91 
 92     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 93 
 94         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 95 
 96         switch (step) {
 97             case 1:
 98                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
 99                                 || (curr == JVMTI_EVENT_VM_OBJECT_ALLOC));
100                 break;
101 
102             case 2:
103                 isExpected = (curr == JVMTI_EVENT_VM_OBJECT_ALLOC);
104                 break;
105 
106             case 3:
107                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
108                 break;
109         }
110 
111         if (isExpected) {
112             if (currentCounts[i] &lt; 0) {
113                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be non-negative\n&quot;,
114                                         currentCounts[i],
115                                         TranslateEvent(curr));
<span class="line-modified">116                 result = NSK_FALSE;</span>
117             }
118 
119         } else {
120 
121             if (currentCounts[i] &gt; 0) {
122                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
123                                     TranslateEvent(curr),
124                                     currentCounts[i]);
<span class="line-modified">125                 result = NSK_FALSE;</span>
126             }
127         }
128     }
129 
130     return result;
131 }
132 
133 static void
134 changeCount(jvmtiEvent event, int *currentCounts) {
135 
136     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
137         nsk_jvmti_setFailStatus();
138 
139     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
140 
141     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
142         nsk_jvmti_setFailStatus();
143 
144 }
145 
</pre>
<hr />
<pre>
357     if (phase != JVMTI_PHASE_LIVE) {
358         NSK_COMPLAIN4(&quot;%25s was sent during %s(%d)\n\tclass: %s\n&quot;,
359                     TranslateEvent(JVMTI_EVENT_VM_OBJECT_ALLOC),
360                     TranslatePhase(phase),
361                     phase,
362                     sign_ptr);
363         nsk_jvmti_setFailStatus();
364     }
365 
366     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)sign_ptr))) {
367         nsk_jvmti_setFailStatus();
368     }
369     if (gen_ptr != NULL)
370         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)gen_ptr))) {
371             nsk_jvmti_setFailStatus();
372         }
373 }
374 
375 /* ============================================================================= */
376 
<span class="line-modified">377 static int enableEvent(jvmtiEvent event) {</span>
378 
379     if (nsk_jvmti_isOptionalEvent(event)
380             &amp;&amp; (event != JVMTI_EVENT_VM_OBJECT_ALLOC)) {
381         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
382                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
383             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
384                 TranslateEvent(event));
<span class="line-modified">385             return NSK_FALSE;</span>
386         }
387     } else {
388         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
389             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
390                 TranslateEvent(event));
<span class="line-modified">391             return NSK_FALSE;</span>
392         }
393     }
394 
<span class="line-modified">395     return NSK_TRUE;</span>
396 }
397 
398 /**
399  * Enable or disable tested events.
400  */
<span class="line-modified">401 static int enableEventList() {</span>
402 
403     int i, result;
404 
405     result = enableEvent(JVMTI_EVENT_VM_INIT);
406 
407     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
408 
409     /* enabling optional events */
410     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
411         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
412 
413         if (nsk_jvmti_isOptionalEvent(event))
414             result = result &amp;&amp; enableEvent(event);
415     }
416 
<span class="line-modified">417     if (result == NSK_FALSE) {</span>
418         nsk_jvmti_setFailStatus();
<span class="line-modified">419         return NSK_FALSE;</span>
420     }
421 
<span class="line-modified">422     return NSK_TRUE;</span>
423 }
424 
425 /* ============================================================================= */
426 
<span class="line-modified">427 static int</span>
<span class="line-removed">428 setCallBacks(int step) {</span>
429 
430     int i;
431 
432     jvmtiEventCallbacks eventCallbacks;
433     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
434 
435     switch (step) {
436         case 1:
437             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
438                 eventCount[i] = 0;
439             }
440 
441             eventCallbacks.VMInit                    = cbVMInit;
442             eventCallbacks.Exception                 = cbException;
443             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
444             eventCallbacks.SingleStep                = cbSingleStep;
445             eventCallbacks.FramePop                  = cbFramePop;
446             eventCallbacks.Breakpoint                = cbBreakpoint;
447             eventCallbacks.FieldAccess               = cbFieldAccess;
448             eventCallbacks.FieldModification         = cbFieldModification;
</pre>
<hr />
<pre>
462             break;
463 
464         case 2:
465             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
466                 newEventCount[i] = 0;
467             }
468 
469             eventCallbacks.VMObjectAlloc             = cbNewVMObjectAlloc;
470             break;
471 
472         case 3:
473             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
474                 newEventCount[i] = 0;
475             }
476 
477             eventCallbacks.VMDeath                   = cbVMDeath;
478             break;
479 
480     }
481     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">482         return NSK_FALSE;</span>
483 
<span class="line-modified">484     return NSK_TRUE;</span>
485 }
486 
487 /* ============================================================================= */
488 
489 /** Agent algorithm. */
490 static void JNICALL
491 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
492 
493     int i;
494 
495     for (i = 1; i &lt;= STEP_NUMBER; i++) {
496 
497         if (!nsk_jvmti_waitForSync(timeout))
498             return;
499 
500         if (i &lt; STEP_NUMBER) {
501             showEventStatistics(i);
502             if (!checkEvents(i))
503                 nsk_jvmti_setFailStatus();
504 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 53     int i;
 54     const char* str;
 55     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 56 
 57     NSK_DISPLAY0(&quot;\n&quot;);
 58     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 59     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 60     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 61         if (currentCounts[i] &gt; 0) {
 62             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 63             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 64         }
 65     }
 66 }
 67 
 68 /* ========================================================================== */
 69 
 70 int checkEvents(int step) {
 71     int i;
 72     jvmtiEvent curr;
<span class="line-modified"> 73     bool result = true;</span>
 74     int *currentCounts;
 75     int isExpected = 0;
 76 
 77     switch (step) {
 78         case 1:
 79             currentCounts = &amp;eventCount[0];
 80             break;
 81 
 82         case 2:
 83         case 3:
 84             currentCounts = &amp;newEventCount[0];
 85             break;
 86 
 87         default:
 88             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified"> 89             return false;</span>
 90     }
 91 
 92     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 93 
 94         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 95 
 96         switch (step) {
 97             case 1:
 98                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
 99                                 || (curr == JVMTI_EVENT_VM_OBJECT_ALLOC));
100                 break;
101 
102             case 2:
103                 isExpected = (curr == JVMTI_EVENT_VM_OBJECT_ALLOC);
104                 break;
105 
106             case 3:
107                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
108                 break;
109         }
110 
111         if (isExpected) {
112             if (currentCounts[i] &lt; 0) {
113                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be non-negative\n&quot;,
114                                         currentCounts[i],
115                                         TranslateEvent(curr));
<span class="line-modified">116                 result = false;</span>
117             }
118 
119         } else {
120 
121             if (currentCounts[i] &gt; 0) {
122                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
123                                     TranslateEvent(curr),
124                                     currentCounts[i]);
<span class="line-modified">125                 result = false;</span>
126             }
127         }
128     }
129 
130     return result;
131 }
132 
133 static void
134 changeCount(jvmtiEvent event, int *currentCounts) {
135 
136     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
137         nsk_jvmti_setFailStatus();
138 
139     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
140 
141     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
142         nsk_jvmti_setFailStatus();
143 
144 }
145 
</pre>
<hr />
<pre>
357     if (phase != JVMTI_PHASE_LIVE) {
358         NSK_COMPLAIN4(&quot;%25s was sent during %s(%d)\n\tclass: %s\n&quot;,
359                     TranslateEvent(JVMTI_EVENT_VM_OBJECT_ALLOC),
360                     TranslatePhase(phase),
361                     phase,
362                     sign_ptr);
363         nsk_jvmti_setFailStatus();
364     }
365 
366     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)sign_ptr))) {
367         nsk_jvmti_setFailStatus();
368     }
369     if (gen_ptr != NULL)
370         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)gen_ptr))) {
371             nsk_jvmti_setFailStatus();
372         }
373 }
374 
375 /* ============================================================================= */
376 
<span class="line-modified">377 static bool enableEvent(jvmtiEvent event) {</span>
378 
379     if (nsk_jvmti_isOptionalEvent(event)
380             &amp;&amp; (event != JVMTI_EVENT_VM_OBJECT_ALLOC)) {
381         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
382                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
383             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
384                 TranslateEvent(event));
<span class="line-modified">385             return false;</span>
386         }
387     } else {
388         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
389             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
390                 TranslateEvent(event));
<span class="line-modified">391             return false;</span>
392         }
393     }
394 
<span class="line-modified">395     return true;</span>
396 }
397 
398 /**
399  * Enable or disable tested events.
400  */
<span class="line-modified">401 static bool enableEventList() {</span>
402 
403     int i, result;
404 
405     result = enableEvent(JVMTI_EVENT_VM_INIT);
406 
407     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
408 
409     /* enabling optional events */
410     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
411         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
412 
413         if (nsk_jvmti_isOptionalEvent(event))
414             result = result &amp;&amp; enableEvent(event);
415     }
416 
<span class="line-modified">417     if (!result) {</span>
418         nsk_jvmti_setFailStatus();
<span class="line-modified">419         return false;</span>
420     }
421 
<span class="line-modified">422     return true;</span>
423 }
424 
425 /* ============================================================================= */
426 
<span class="line-modified">427 static bool setCallBacks(int step) {</span>

428 
429     int i;
430 
431     jvmtiEventCallbacks eventCallbacks;
432     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
433 
434     switch (step) {
435         case 1:
436             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
437                 eventCount[i] = 0;
438             }
439 
440             eventCallbacks.VMInit                    = cbVMInit;
441             eventCallbacks.Exception                 = cbException;
442             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
443             eventCallbacks.SingleStep                = cbSingleStep;
444             eventCallbacks.FramePop                  = cbFramePop;
445             eventCallbacks.Breakpoint                = cbBreakpoint;
446             eventCallbacks.FieldAccess               = cbFieldAccess;
447             eventCallbacks.FieldModification         = cbFieldModification;
</pre>
<hr />
<pre>
461             break;
462 
463         case 2:
464             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
465                 newEventCount[i] = 0;
466             }
467 
468             eventCallbacks.VMObjectAlloc             = cbNewVMObjectAlloc;
469             break;
470 
471         case 3:
472             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
473                 newEventCount[i] = 0;
474             }
475 
476             eventCallbacks.VMDeath                   = cbVMDeath;
477             break;
478 
479     }
480     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">481         return false;</span>
482 
<span class="line-modified">483     return true;</span>
484 }
485 
486 /* ============================================================================= */
487 
488 /** Agent algorithm. */
489 static void JNICALL
490 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
491 
492     int i;
493 
494     for (i = 1; i &lt;= STEP_NUMBER; i++) {
495 
496         if (!nsk_jvmti_waitForSync(timeout))
497             return;
498 
499         if (i &lt; STEP_NUMBER) {
500             showEventStatistics(i);
501             if (!checkEvents(i))
502                 nsk_jvmti_setFailStatus();
503 
</pre>
</td>
</tr>
</table>
<center><a href="../em02t004/em02t004.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../em02t006/em02t006.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
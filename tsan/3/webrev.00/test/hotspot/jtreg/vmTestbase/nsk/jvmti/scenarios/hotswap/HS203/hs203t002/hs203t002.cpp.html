<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/hotswap/HS203/hs203t002/hs203t002.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 #include &lt;stdio.h&gt;
 24 #include &lt;jvmti.h&gt;
 25 #include &quot;agent_common.h&quot;
 26 #include &lt;jni.h&gt;
 27 #include &lt;string.h&gt;
 28 #include &quot;jvmti_tools.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 
 31 /*
 32    T002:
 33    1. Set a breakpoint in method b().
 34    2. Call method a() which calls b().
 35    Upon reaching the breakpoint, enable SingleStep.
 36    3. Redefine class within SingleStep callback. New class version
 37    contains the same method b() and the changed method a(). Stepping
 38    should be continued in the method b().
 39    4. Pop a currently executed frame. Stepping should be continued
 40    on invoke instruction of the obsolete method a().
 41    5. Pop a frame once more. Stepping should be continued
 42    on invoke instruction of main method and then in the changed
 43    method b().
 44 */
 45 
 46 extern &quot;C&quot; {
 47 
 48 #define FILE_NAME &quot;nsk/jvmti/scenarios/hotswap/HS203/hs203t002/MyThread&quot;
 49 #define SEARCH_NAME &quot;nsk/jvmti/scenarios/hotswap/HS203/hs203t002/MyThread&quot;
 50 #define METHOD_NAME &quot;doTask2&quot;
 51 #define METHOD_SIGN &quot;()V&quot;
 52 #define CLASS_NAME &quot;Lnsk/jvmti/scenarios/hotswap/HS203/hs203t002/MyThread;&quot;
 53 static jint redefineNumber;
 54 static jvmtiEnv * jvmti;
 55 
 56 JNIEXPORT void JNICALL
 57 callbackClassLoad(jvmtiEnv *jvmti,
 58                                         JNIEnv* jni,
 59                                         jthread thread,
 60                                         jclass klass) {
 61     char * className;
 62     char * generic;
 63     redefineNumber=0;
 64     jvmti-&gt;GetClassSignature(klass, &amp;className, &amp;generic);
 65     if (strcmp(className,CLASS_NAME) == 0) {
 66         jmethodID method;
 67         method = jni-&gt;GetMethodID(klass,METHOD_NAME,METHOD_SIGN);
 68         if (method != NULL) {
 69             jlocation start;
 70             jlocation end;
 71             jvmtiError err ;
 72             err=jvmti-&gt;GetMethodLocation(method, &amp;start, &amp;end);
 73             if (err == JVMTI_ERROR_NONE) {
 74                 nsk_printf(&quot;Agent:: NO ERRORS FOUND \n&quot;);
 75                 err= jvmti-&gt;SetBreakpoint(method, start);
 76                 if (err == JVMTI_ERROR_NONE) {
 77                     nsk_printf(&quot;Agent:: Breakpoint set \n&quot;);
 78                 } else {
 79                     nsk_printf(&quot;Agent:: ***ERROR OCCURED ... in SET BREAK POINT ERROR \n&quot;);
 80                 }
 81             } else {
 82                 nsk_printf(&quot;Agent:: ***ERROR OCCURED .. in METHOD LOCATION FINDER \n&quot;);
 83             }
 84         } else {
 85             nsk_printf(&quot;Agent:: ***ERROR OCCURED .. COUND NOT FIND THE METHOD AND SIGNATURE SPECIFIED \n&quot;);
 86         }
 87     }
 88 }
 89 
 90 void JNICALL callbackSingleStep(jvmtiEnv *jvmti,
 91         JNIEnv* jni, jthread thread,
 92         jmethodID method, jlocation location) {
 93     jclass threadClass;
 94     jvmtiError err;
 95     char fileName[512];
 96 
 97     threadClass = jni-&gt;FindClass(SEARCH_NAME);
 98     nsk_printf(&quot; %d..&quot;,redefineNumber);
 99     nsk_jvmti_getFileName(redefineNumber, FILE_NAME, fileName, sizeof(fileName)/sizeof(char));
100 
101     if (nsk_jvmti_redefineClass(jvmti, threadClass,fileName)) {
102         nsk_printf(&quot;Agent:: Redefined..\n&quot;);
103     } else {
104         nsk_printf(&quot; Failed to redefine..\n&quot;);
105         return;
106     }
107     err=jvmti-&gt;SuspendThread(thread);
108     if (err == JVMTI_ERROR_NONE) {
109         nsk_printf(&quot;Agent:: Succeded in suspending..\n&quot;);
110     } else {
111         nsk_printf(&quot; ## Error occured %s \n&quot;,TranslateError(err));
112     }
113 }
114 
115 void JNICALL callbackBreakpoint(jvmtiEnv *jvmti,
116                                                                 JNIEnv* jni,
117                                                                 jthread thread,
118                                                                 jmethodID method,
119                                                                 jlocation location) {
120     nsk_printf(&quot;Agent::... BreakPoint Reached..\n&quot;);
121     if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_SINGLE_STEP,thread) == JNI_OK) {
122         nsk_printf(&quot; ....   Enabled..\n&quot;);
123     }
124     return;
125 }
126 
127 
128 #ifdef STATIC_BUILD
129 JNIEXPORT jint JNICALL Agent_OnLoad_hs203t002(JavaVM *jvm, char *options, void *reserved) {
130     return Agent_Initialize(jvm, options, reserved);
131 }
132 JNIEXPORT jint JNICALL Agent_OnAttach_hs203t002(JavaVM *jvm, char *options, void *reserved) {
133     return Agent_Initialize(jvm, options, reserved);
134 }
135 JNIEXPORT jint JNI_OnLoad_hs203t002(JavaVM *jvm, char *options, void *reserved) {
136     return JNI_VERSION_1_8;
137 }
138 #endif
139 jint Agent_Initialize(JavaVM *vm, char *options, void *reserved) {
140         jint rc ;
141     nsk_printf(&quot;Agent:: VM.. Started..\n&quot;);
142     rc=vm-&gt;GetEnv((void **)&amp;jvmti, JVMTI_VERSION_1_1);
143     if (rc != JNI_OK) {
144         nsk_printf(&quot;Agent:: Could not load JVMTI interface \n&quot;);
145         return JNI_ERR;
146     } else {
147         jvmtiCapabilities caps;
148         jvmtiEventCallbacks eventCallbacks;
149         if (!nsk_jvmti_parseOptions(options)) {
150             nsk_printf(&quot;# error agent Failed to parse options \n&quot;);
151             return JNI_ERR;
152         }
153         memset(&amp;caps, 0, sizeof(caps));
154         caps.can_redefine_classes = 1;
155         caps.can_suspend=1;
156         caps.can_pop_frame=1;
157         caps.can_generate_breakpoint_events=1;
158         caps.can_generate_all_class_hook_events=1;
159         caps.can_generate_single_step_events=1;
160         jvmti-&gt;AddCapabilities(&amp;caps);
161 
162         memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
163         eventCallbacks.ClassLoad =callbackClassLoad;
164         eventCallbacks.Breakpoint = callbackBreakpoint;
165         eventCallbacks.SingleStep =callbackSingleStep;
166         rc=jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks));
167         if (rc != JVMTI_ERROR_NONE) {
168             nsk_printf(&quot; Agent:: Error occured while setting event call back \n&quot;);
169             return JNI_ERR;
170         }
171         if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_LOAD, NULL) &amp;&amp;
172                 nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT, NULL)) {
173             nsk_printf(&quot;Agent :: NOTIFICATIONS ARE ENABLED \n&quot;);
174         } else {
175             nsk_printf(&quot; Error in Eanableing Notifications..&quot;);
176         }
177     }
178     return JNI_OK;
179 }
180 
181 
182 JNIEXPORT jboolean JNICALL
183 Java_nsk_jvmti_scenarios_hotswap_HS203_hs203t002_hs203t002_popThreadFrame(JNIEnv * jni,
184         jclass clas,
185         jthread thread) {
186     jvmtiError err ;
187     jboolean retvalue;
188     jint state;
189     nsk_printf(&quot;Agent:: POPING THE FRAME....\n&quot;);
190     retvalue = JNI_FALSE;
191     jvmti-&gt;GetThreadState(thread, &amp;state);
192     if (state &amp; JVMTI_THREAD_STATE_SUSPENDED) {
193         err = jvmti-&gt;PopFrame(thread);
194         if (err == JVMTI_ERROR_NONE) {
195             nsk_printf(&quot;Agent:: NO Errors poped very well ..\n&quot;);
196             retvalue = JNI_TRUE;
197         } else {
198             nsk_printf(&quot; ## Error occured %s \n&quot;,TranslateError(err));
199         }
200     } else {
201         nsk_printf(&quot;Agent:: Thread was not suspened.. check for capabilities, and java method signature \n&quot;);
202     }
203     return retvalue;
204 }
205 
206 JNIEXPORT jboolean JNICALL
207 Java_nsk_jvmti_scenarios_hotswap_HS203_hs203t002_hs203t002_resumeThread(JNIEnv * jni,
208         jclass clas,
209         jthread thread) {
210     jvmtiError err ;
211     jboolean retvalue;
212     retvalue = JNI_FALSE;
213     err =jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE,JVMTI_EVENT_SINGLE_STEP,thread);
214     if (err == JVMTI_ERROR_NONE) {
215         nsk_printf(&quot; Agent:: cleared Single Step event&quot;);
216     } else {
217         nsk_printf(&quot; Agent :: Failed to clear Single Step Event&quot;);
218     }
219     err =jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE,JVMTI_EVENT_BREAKPOINT,thread);
220     if (err == JVMTI_ERROR_NONE) {
221         nsk_printf(&quot; Agent:: cleared Break point event&quot;);
222     } else {
223         nsk_printf(&quot; Agent :: Failed to clear Single Step Event&quot;);
224     }
225     err = jvmti-&gt;ResumeThread(thread);
226     if (err == JVMTI_ERROR_NONE) {
227         nsk_printf(&quot; Agent:: Thread Resumed..&quot;);
228     } else {
229         nsk_printf(&quot; Failed.. to Resume the thread.&quot;);
230     }
231     return retvalue;
232 }
233 
234 JNIEXPORT jboolean JNICALL
235 Java_nsk_jvmti_scenarios_hotswap_HS203_hs203t002_hs203t002_suspendThread(JNIEnv * jni,
236         jclass clas,
237         jthread thread) {
238     jvmtiError err ;
239     jboolean retvalue;
240     retvalue = JNI_FALSE;
241     err = jvmti-&gt;SuspendThread(thread);
242     if (err == JVMTI_ERROR_NONE) {
243         nsk_printf(&quot; Agent:: Thread suspended..&quot;);
244         retvalue= JNI_TRUE;
245     } else {
246         nsk_printf(&quot; ## Error occured %s \n&quot;,TranslateError(err));
247     }
248     return retvalue;
249 }
250 
251 }
    </pre>
  </body>
</html>
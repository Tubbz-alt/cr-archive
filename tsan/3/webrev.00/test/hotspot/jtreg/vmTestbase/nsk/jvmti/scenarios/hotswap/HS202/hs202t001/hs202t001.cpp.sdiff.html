<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/hotswap/HS202/hs202t001/hs202t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../HS104/hs104t002/hs104t002.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../hs202t002/hs202t002.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/hotswap/HS202/hs202t001/hs202t001.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 56     if (strcmp(className,CLASS_NAME) == 0) {
 57         jmethodID method;
 58         method = jni-&gt;GetMethodID(klass, METHOD_NAME, METHOD_SIGN);
 59         if (method == NULL) {
 60             nsk_printf(&quot;Agent:: Method is null &quot;);
 61         } else {
 62             jlocation start;
 63             jlocation end;
 64             jvmtiError err ;
 65             err=jvmti-&gt;GetMethodLocation(method, &amp;start, &amp;end);
 66             if (err != JVMTI_ERROR_NONE) {
 67                 nsk_printf(&quot; ## Error occured %s \n&quot;,TranslateError(err));
 68             }else {
 69                 nsk_printf(&quot;\n Start = %d and end = %d &quot;, start , end);
 70                 nsk_printf(&quot; setting break points..&quot;);
 71                 err= jvmti-&gt;SetBreakpoint(method, start);
 72                 if (err != JVMTI_ERROR_NONE) {
 73                     nsk_printf(&quot; ## Error occured %s \n&quot;,TranslateError(err));
 74                 } else  {
 75                     nsk_printf(&quot; NO ERRORS &quot;);
<span class="line-modified"> 76                     if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT, NULL) == NSK_TRUE) {</span>
 77                         nsk_printf(&quot; Enabled.. notification event ..\n&quot;);
 78                     }
 79                 }
 80             }
 81         }
 82     }
 83 }
 84 
 85 /*
 86  *This event call back will be called when a filed
 87  *threadState is beeing upodated or beeing used in
 88  *the program java flow.
 89  *In this current example the code will be called
 90  */
 91 void JNICALL callbackSingleStep(jvmtiEnv *jvmti_env,
 92         JNIEnv* jni,
 93         jthread thread,
 94         jmethodID method,
 95         jlocation location) {
 96     jvmtiError err;
</pre>
<hr />
<pre>
 99     char * generic ;
100     err = JVMTI_ERROR_NONE;
101     jvmti_env-&gt;GetMethodName(method, &amp;name, &amp;signature, &amp;generic);
102     if (strcmp(name,METHOD_NAME) == 0) { /* same method */
103         jclass cls;
104         jmethodID mem ;
105         jvmti_env-&gt;GetMethodDeclaringClass(method, &amp;cls);
106         mem=jni-&gt;GetMethodID(cls,METHOD_NOTIFYALL,&quot;()V&quot;);
107         jni-&gt;CallVoidMethod(thread,mem);
108     }
109 
110 }
111 
112 void JNICALL callbackBreakpoint(jvmtiEnv *jvmti_env,
113         JNIEnv* jni_env,
114         jthread thread,
115         jmethodID method,
116         jlocation location) {
117     jvmtiError err;
118     err = JVMTI_ERROR_NONE;
<span class="line-modified">119     if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_SINGLE_STEP, NULL) == NSK_TRUE) {</span>
120         nsk_printf(&quot; Enabled.. notification event ..&quot;);
121     }
122     err= jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE,
123             JVMTI_EVENT_BREAKPOINT, NULL);
124     if (err == JVMTI_ERROR_NONE) {
125         nsk_printf(&quot; Disabled notification..&quot;);
126     }
127 
128 }
129 
130 
131 #ifdef STATIC_BUILD
132 JNIEXPORT jint JNICALL Agent_OnLoad_hs202t001(JavaVM *jvm, char *options, void *reserved) {
133     return Agent_Initialize(jvm, options, reserved);
134 }
135 JNIEXPORT jint JNICALL Agent_OnAttach_hs202t001(JavaVM *jvm, char *options, void *reserved) {
136     return Agent_Initialize(jvm, options, reserved);
137 }
138 JNIEXPORT jint JNI_OnLoad_hs202t001(JavaVM *jvm, char *options, void *reserved) {
139     return JNI_VERSION_1_8;
140 }
141 #endif
142 jint  Agent_Initialize(JavaVM *vm, char *options, void *reserved) {
143     jvmtiError rc;
144     jint code;
145     nsk_printf(&quot;Agent:: VM.. Started..\n&quot;);
146     code = vm-&gt;GetEnv((void **)&amp;jvmti, JVMTI_VERSION_1_1);
147     if (code != JNI_OK) {
148         nsk_printf(&quot;Agent:: Could not load JVMTI interface \n&quot;);
149         return JNI_ERR;
150     } else {
151         jvmtiCapabilities caps;
152         jvmtiEventCallbacks eventCallbacks;
153         memset(&amp;caps, 0, sizeof(caps));
<span class="line-modified">154         if (nsk_jvmti_parseOptions(options) == NSK_FALSE) {</span>
155             nsk_printf(&quot;# error agent Failed to parse options \n&quot;);
156             return JNI_ERR;
157         }
158         caps.can_redefine_classes = 1;
159         caps.can_suspend = 1;
160         caps.can_pop_frame = 1;
161         caps.can_generate_all_class_hook_events = 1;
162         caps.can_generate_compiled_method_load_events = 1;
163         caps.can_generate_breakpoint_events=1;
164         caps.can_generate_single_step_events=1;
165         jvmti-&gt;AddCapabilities(&amp;caps);
166         memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
167         eventCallbacks.ClassPrepare =callbackClassPrepare;
168         eventCallbacks.SingleStep =callbackSingleStep;
169         eventCallbacks.Breakpoint =callbackBreakpoint;
170         rc = jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks));
171         if (rc != JVMTI_ERROR_NONE) {
172             nsk_printf(&quot; ## Error occured %s \n&quot;,TranslateError(rc));
173             return JNI_ERR;
174         }
<span class="line-modified">175         if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_PREPARE, NULL) == NSK_TRUE) {</span>
176             nsk_printf(&quot;Agent :: NOTIFICATIONS ARE ENABLED \n&quot;);
177         } else {
178             nsk_printf(&quot; Error in Eanableing Notifications..&quot;);
179         }
180     }
181     return JNI_OK;
182 }
183 
184 JNIEXPORT jboolean JNICALL
185 Java_nsk_jvmti_scenarios_hotswap_HS202_hs202t001_hs202t001_popThreadFrame(JNIEnv * jni,
186         jclass clas,
187         jthread thread) {
188     jvmtiError err ;
189     jboolean retvalue;
190     jint state;
191     nsk_printf(&quot;Agent:: POPING THE FRAME....\n&quot;);
192     retvalue = JNI_FALSE;
193     jvmti-&gt;GetThreadState(thread, &amp;state);
194     if (state &amp; JVMTI_THREAD_STATE_SUSPENDED) {
195         err = jvmti-&gt;PopFrame(thread);
</pre>
</td>
<td>
<hr />
<pre>
 56     if (strcmp(className,CLASS_NAME) == 0) {
 57         jmethodID method;
 58         method = jni-&gt;GetMethodID(klass, METHOD_NAME, METHOD_SIGN);
 59         if (method == NULL) {
 60             nsk_printf(&quot;Agent:: Method is null &quot;);
 61         } else {
 62             jlocation start;
 63             jlocation end;
 64             jvmtiError err ;
 65             err=jvmti-&gt;GetMethodLocation(method, &amp;start, &amp;end);
 66             if (err != JVMTI_ERROR_NONE) {
 67                 nsk_printf(&quot; ## Error occured %s \n&quot;,TranslateError(err));
 68             }else {
 69                 nsk_printf(&quot;\n Start = %d and end = %d &quot;, start , end);
 70                 nsk_printf(&quot; setting break points..&quot;);
 71                 err= jvmti-&gt;SetBreakpoint(method, start);
 72                 if (err != JVMTI_ERROR_NONE) {
 73                     nsk_printf(&quot; ## Error occured %s \n&quot;,TranslateError(err));
 74                 } else  {
 75                     nsk_printf(&quot; NO ERRORS &quot;);
<span class="line-modified"> 76                     if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT, NULL)) {</span>
 77                         nsk_printf(&quot; Enabled.. notification event ..\n&quot;);
 78                     }
 79                 }
 80             }
 81         }
 82     }
 83 }
 84 
 85 /*
 86  *This event call back will be called when a filed
 87  *threadState is beeing upodated or beeing used in
 88  *the program java flow.
 89  *In this current example the code will be called
 90  */
 91 void JNICALL callbackSingleStep(jvmtiEnv *jvmti_env,
 92         JNIEnv* jni,
 93         jthread thread,
 94         jmethodID method,
 95         jlocation location) {
 96     jvmtiError err;
</pre>
<hr />
<pre>
 99     char * generic ;
100     err = JVMTI_ERROR_NONE;
101     jvmti_env-&gt;GetMethodName(method, &amp;name, &amp;signature, &amp;generic);
102     if (strcmp(name,METHOD_NAME) == 0) { /* same method */
103         jclass cls;
104         jmethodID mem ;
105         jvmti_env-&gt;GetMethodDeclaringClass(method, &amp;cls);
106         mem=jni-&gt;GetMethodID(cls,METHOD_NOTIFYALL,&quot;()V&quot;);
107         jni-&gt;CallVoidMethod(thread,mem);
108     }
109 
110 }
111 
112 void JNICALL callbackBreakpoint(jvmtiEnv *jvmti_env,
113         JNIEnv* jni_env,
114         jthread thread,
115         jmethodID method,
116         jlocation location) {
117     jvmtiError err;
118     err = JVMTI_ERROR_NONE;
<span class="line-modified">119     if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_SINGLE_STEP, NULL)) {</span>
120         nsk_printf(&quot; Enabled.. notification event ..&quot;);
121     }
122     err= jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE,
123             JVMTI_EVENT_BREAKPOINT, NULL);
124     if (err == JVMTI_ERROR_NONE) {
125         nsk_printf(&quot; Disabled notification..&quot;);
126     }
127 
128 }
129 
130 
131 #ifdef STATIC_BUILD
132 JNIEXPORT jint JNICALL Agent_OnLoad_hs202t001(JavaVM *jvm, char *options, void *reserved) {
133     return Agent_Initialize(jvm, options, reserved);
134 }
135 JNIEXPORT jint JNICALL Agent_OnAttach_hs202t001(JavaVM *jvm, char *options, void *reserved) {
136     return Agent_Initialize(jvm, options, reserved);
137 }
138 JNIEXPORT jint JNI_OnLoad_hs202t001(JavaVM *jvm, char *options, void *reserved) {
139     return JNI_VERSION_1_8;
140 }
141 #endif
142 jint  Agent_Initialize(JavaVM *vm, char *options, void *reserved) {
143     jvmtiError rc;
144     jint code;
145     nsk_printf(&quot;Agent:: VM.. Started..\n&quot;);
146     code = vm-&gt;GetEnv((void **)&amp;jvmti, JVMTI_VERSION_1_1);
147     if (code != JNI_OK) {
148         nsk_printf(&quot;Agent:: Could not load JVMTI interface \n&quot;);
149         return JNI_ERR;
150     } else {
151         jvmtiCapabilities caps;
152         jvmtiEventCallbacks eventCallbacks;
153         memset(&amp;caps, 0, sizeof(caps));
<span class="line-modified">154         if (!nsk_jvmti_parseOptions(options)) {</span>
155             nsk_printf(&quot;# error agent Failed to parse options \n&quot;);
156             return JNI_ERR;
157         }
158         caps.can_redefine_classes = 1;
159         caps.can_suspend = 1;
160         caps.can_pop_frame = 1;
161         caps.can_generate_all_class_hook_events = 1;
162         caps.can_generate_compiled_method_load_events = 1;
163         caps.can_generate_breakpoint_events=1;
164         caps.can_generate_single_step_events=1;
165         jvmti-&gt;AddCapabilities(&amp;caps);
166         memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
167         eventCallbacks.ClassPrepare =callbackClassPrepare;
168         eventCallbacks.SingleStep =callbackSingleStep;
169         eventCallbacks.Breakpoint =callbackBreakpoint;
170         rc = jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks));
171         if (rc != JVMTI_ERROR_NONE) {
172             nsk_printf(&quot; ## Error occured %s \n&quot;,TranslateError(rc));
173             return JNI_ERR;
174         }
<span class="line-modified">175         if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_PREPARE, NULL)) {</span>
176             nsk_printf(&quot;Agent :: NOTIFICATIONS ARE ENABLED \n&quot;);
177         } else {
178             nsk_printf(&quot; Error in Eanableing Notifications..&quot;);
179         }
180     }
181     return JNI_OK;
182 }
183 
184 JNIEXPORT jboolean JNICALL
185 Java_nsk_jvmti_scenarios_hotswap_HS202_hs202t001_hs202t001_popThreadFrame(JNIEnv * jni,
186         jclass clas,
187         jthread thread) {
188     jvmtiError err ;
189     jboolean retvalue;
190     jint state;
191     nsk_printf(&quot;Agent:: POPING THE FRAME....\n&quot;);
192     retvalue = JNI_FALSE;
193     jvmti-&gt;GetThreadState(thread, &amp;state);
194     if (state &amp; JVMTI_THREAD_STATE_SUSPENDED) {
195         err = jvmti-&gt;PopFrame(thread);
</pre>
</td>
</tr>
</table>
<center><a href="../../HS104/hs104t002/hs104t002.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../hs202t002/hs202t002.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
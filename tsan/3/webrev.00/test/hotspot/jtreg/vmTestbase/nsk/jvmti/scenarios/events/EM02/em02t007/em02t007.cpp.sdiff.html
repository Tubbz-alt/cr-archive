<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t007/em02t007.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../em02t006/em02t006.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../em02t008/em02t008.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t007/em02t007.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 54     int i;
 55     const char* str;
 56     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 57 
 58     NSK_DISPLAY0(&quot;\n&quot;);
 59     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 60     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 61     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 62         if (currentCounts[i] &gt; 0) {
 63             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 64             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 65         }
 66     }
 67 }
 68 
 69 /* ========================================================================== */
 70 
 71 int checkEvents(int step) {
 72     int i;
 73     jvmtiEvent curr;
<span class="line-modified"> 74     int result = NSK_TRUE;</span>
 75     int *currentCounts;
 76     int isExpected = 0;
 77 
 78     switch (step) {
 79         case 1:
 80             currentCounts = &amp;eventCount[0];
 81             break;
 82 
 83         case 2:
 84         case 3:
 85             currentCounts = &amp;newEventCount[0];
 86             break;
 87 
 88         default:
 89             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified"> 90             return NSK_FALSE;</span>
 91     }
 92 
 93     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 94 
 95         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 96 
 97         switch (step) {
 98             case 1:
 99                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
100                                 || (curr == JVMTI_EVENT_SINGLE_STEP));
101                 break;
102 
103             case 2:
104                 isExpected = (curr == JVMTI_EVENT_SINGLE_STEP);
105                 break;
106 
107             case 3:
108                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
109                 break;
110         }
111 
112         if (isExpected) {
113             if (currentCounts[i] &lt; 0) {
114                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
115                                         currentCounts[i],
116                                         TranslateEvent(curr));
<span class="line-modified">117                 result = NSK_FALSE;</span>
118             }
119         } else {
120 
121             if (currentCounts[i] &gt; 0) {
122                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
123                                     TranslateEvent(curr),
124                                     currentCounts[i]);
<span class="line-modified">125                 result = NSK_FALSE;</span>
126             }
127         }
128     }
129 
130     return result;
131 }
132 
133 static void
134 changeCount(jvmtiEvent event, int *currentCounts) {
135 
136     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
137         nsk_jvmti_setFailStatus();
138 
139     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
140 
141     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
142         nsk_jvmti_setFailStatus();
143 
144 }
145 
</pre>
<hr />
<pre>
335 
336 void JNICALL
337 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
338 
339     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
340     if (tag &lt; 1 || tag &gt; OBJECT_NUMBER) {
341         NSK_COMPLAIN1(&quot;Unexpected tag value %lld\n&quot;, tag);
342         nsk_jvmti_setFailStatus();
343     }
344 }
345 
346 void JNICALL
347 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
348                     jobject object, jclass object_klass, jlong size) {
349 
350     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
351 }
352 
353 /* ============================================================================= */
354 
<span class="line-modified">355 static int enableEvent(jvmtiEvent event) {</span>
356 
357     if (nsk_jvmti_isOptionalEvent(event)
358             &amp;&amp; (event != JVMTI_EVENT_SINGLE_STEP)) {
359         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
360                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
361             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
362                 TranslateEvent(event));
<span class="line-modified">363             return NSK_FALSE;</span>
364         }
365     } else {
366         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
367             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
368                 TranslateEvent(event));
<span class="line-modified">369             return NSK_FALSE;</span>
370         }
371     }
372 
<span class="line-modified">373     return NSK_TRUE;</span>
374 }
375 
376 /**
377  * Enable or disable tested events.
378  */
<span class="line-modified">379 static int enableEventList() {</span>
380 
381     int i, result;
382 
383     result = enableEvent(JVMTI_EVENT_VM_INIT);
384 
385     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
386 
387     /* enabling optional events */
388     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
389         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
390 
391         if (nsk_jvmti_isOptionalEvent(event))
392             result = result &amp;&amp; enableEvent(event);
393     }
394 
<span class="line-modified">395     if (result == NSK_FALSE) {</span>
396         nsk_jvmti_setFailStatus();
<span class="line-modified">397         return NSK_FALSE;</span>
398     }
399 
<span class="line-modified">400     return NSK_TRUE;</span>
401 }
402 
403 /* ============================================================================= */
404 
<span class="line-modified">405 static int</span>
<span class="line-removed">406 setCallBacks(int step) {</span>
407 
408     int i;
409 
410     jvmtiEventCallbacks eventCallbacks;
411     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
412 
413     switch (step) {
414         case 1:
415             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
416                 eventCount[i] = 0;
417             }
418 
419             eventCallbacks.VMInit                    = cbVMInit;
420             eventCallbacks.Exception                 = cbException;
421             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
422             eventCallbacks.SingleStep                = cbSingleStep;
423             eventCallbacks.FramePop                  = cbFramePop;
424             eventCallbacks.Breakpoint                = cbBreakpoint;
425             eventCallbacks.FieldAccess               = cbFieldAccess;
426             eventCallbacks.FieldModification         = cbFieldModification;
</pre>
<hr />
<pre>
447             eventCallbacks.SingleStep                = cbNewSingleStep;
448             break;
449 
450         case 3:
451             /* comparing number of JVMTI_EVENT_SINGLE_STEP events for steps*/
452             if (eventCount[singleStepIdx] != newEventCount[singleStepIdx]) {
453                 NSK_COMPLAIN2(&quot;Number of JVMTI_EVENT_SINGLE_STEP events must be the same\n\t1-st callback=%d; 2-nd callback=%d\n&quot;,
454                                     eventCount[singleStepIdx],
455                                     newEventCount[singleStepIdx]);
456             }
457 
458             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
459                 newEventCount[i] = 0;
460             }
461 
462             eventCallbacks.VMDeath                   = cbVMDeath;
463             break;
464 
465     }
466     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">467         return NSK_FALSE;</span>
468 
<span class="line-modified">469     return NSK_TRUE;</span>
470 }
471 
472 /* ============================================================================= */
473 
474 /** Agent algorithm. */
475 static void JNICALL
476 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
477 
478     int i;
479 
480     for (i = 1; i &lt;= STEP_NUMBER; i++) {
481 
482         if (!nsk_jvmti_waitForSync(timeout))
483             return;
484 
485         NSK_DISPLAY0(&quot;Check received events\n&quot;);
486 
487         if (i &lt; STEP_NUMBER) {
488             showEventStatistics(i);
489             if (!checkEvents(i))
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 54     int i;
 55     const char* str;
 56     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 57 
 58     NSK_DISPLAY0(&quot;\n&quot;);
 59     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 60     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 61     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 62         if (currentCounts[i] &gt; 0) {
 63             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 64             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 65         }
 66     }
 67 }
 68 
 69 /* ========================================================================== */
 70 
 71 int checkEvents(int step) {
 72     int i;
 73     jvmtiEvent curr;
<span class="line-modified"> 74     bool result = true;</span>
 75     int *currentCounts;
 76     int isExpected = 0;
 77 
 78     switch (step) {
 79         case 1:
 80             currentCounts = &amp;eventCount[0];
 81             break;
 82 
 83         case 2:
 84         case 3:
 85             currentCounts = &amp;newEventCount[0];
 86             break;
 87 
 88         default:
 89             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified"> 90             return false;</span>
 91     }
 92 
 93     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 94 
 95         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 96 
 97         switch (step) {
 98             case 1:
 99                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
100                                 || (curr == JVMTI_EVENT_SINGLE_STEP));
101                 break;
102 
103             case 2:
104                 isExpected = (curr == JVMTI_EVENT_SINGLE_STEP);
105                 break;
106 
107             case 3:
108                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
109                 break;
110         }
111 
112         if (isExpected) {
113             if (currentCounts[i] &lt; 0) {
114                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
115                                         currentCounts[i],
116                                         TranslateEvent(curr));
<span class="line-modified">117                 result = false;</span>
118             }
119         } else {
120 
121             if (currentCounts[i] &gt; 0) {
122                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
123                                     TranslateEvent(curr),
124                                     currentCounts[i]);
<span class="line-modified">125                 result = false;</span>
126             }
127         }
128     }
129 
130     return result;
131 }
132 
133 static void
134 changeCount(jvmtiEvent event, int *currentCounts) {
135 
136     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
137         nsk_jvmti_setFailStatus();
138 
139     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
140 
141     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
142         nsk_jvmti_setFailStatus();
143 
144 }
145 
</pre>
<hr />
<pre>
335 
336 void JNICALL
337 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
338 
339     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
340     if (tag &lt; 1 || tag &gt; OBJECT_NUMBER) {
341         NSK_COMPLAIN1(&quot;Unexpected tag value %lld\n&quot;, tag);
342         nsk_jvmti_setFailStatus();
343     }
344 }
345 
346 void JNICALL
347 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
348                     jobject object, jclass object_klass, jlong size) {
349 
350     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
351 }
352 
353 /* ============================================================================= */
354 
<span class="line-modified">355 static bool enableEvent(jvmtiEvent event) {</span>
356 
357     if (nsk_jvmti_isOptionalEvent(event)
358             &amp;&amp; (event != JVMTI_EVENT_SINGLE_STEP)) {
359         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
360                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
361             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
362                 TranslateEvent(event));
<span class="line-modified">363             return false;</span>
364         }
365     } else {
366         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
367             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
368                 TranslateEvent(event));
<span class="line-modified">369             return false;</span>
370         }
371     }
372 
<span class="line-modified">373     return true;</span>
374 }
375 
376 /**
377  * Enable or disable tested events.
378  */
<span class="line-modified">379 static bool enableEventList() {</span>
380 
381     int i, result;
382 
383     result = enableEvent(JVMTI_EVENT_VM_INIT);
384 
385     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
386 
387     /* enabling optional events */
388     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
389         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
390 
391         if (nsk_jvmti_isOptionalEvent(event))
392             result = result &amp;&amp; enableEvent(event);
393     }
394 
<span class="line-modified">395     if (!result) {</span>
396         nsk_jvmti_setFailStatus();
<span class="line-modified">397         return false;</span>
398     }
399 
<span class="line-modified">400     return true;</span>
401 }
402 
403 /* ============================================================================= */
404 
<span class="line-modified">405 static bool setCallBacks(int step) {</span>

406 
407     int i;
408 
409     jvmtiEventCallbacks eventCallbacks;
410     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
411 
412     switch (step) {
413         case 1:
414             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
415                 eventCount[i] = 0;
416             }
417 
418             eventCallbacks.VMInit                    = cbVMInit;
419             eventCallbacks.Exception                 = cbException;
420             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
421             eventCallbacks.SingleStep                = cbSingleStep;
422             eventCallbacks.FramePop                  = cbFramePop;
423             eventCallbacks.Breakpoint                = cbBreakpoint;
424             eventCallbacks.FieldAccess               = cbFieldAccess;
425             eventCallbacks.FieldModification         = cbFieldModification;
</pre>
<hr />
<pre>
446             eventCallbacks.SingleStep                = cbNewSingleStep;
447             break;
448 
449         case 3:
450             /* comparing number of JVMTI_EVENT_SINGLE_STEP events for steps*/
451             if (eventCount[singleStepIdx] != newEventCount[singleStepIdx]) {
452                 NSK_COMPLAIN2(&quot;Number of JVMTI_EVENT_SINGLE_STEP events must be the same\n\t1-st callback=%d; 2-nd callback=%d\n&quot;,
453                                     eventCount[singleStepIdx],
454                                     newEventCount[singleStepIdx]);
455             }
456 
457             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
458                 newEventCount[i] = 0;
459             }
460 
461             eventCallbacks.VMDeath                   = cbVMDeath;
462             break;
463 
464     }
465     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">466         return false;</span>
467 
<span class="line-modified">468     return true;</span>
469 }
470 
471 /* ============================================================================= */
472 
473 /** Agent algorithm. */
474 static void JNICALL
475 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
476 
477     int i;
478 
479     for (i = 1; i &lt;= STEP_NUMBER; i++) {
480 
481         if (!nsk_jvmti_waitForSync(timeout))
482             return;
483 
484         NSK_DISPLAY0(&quot;Check received events\n&quot;);
485 
486         if (i &lt; STEP_NUMBER) {
487             showEventStatistics(i);
488             if (!checkEvents(i))
</pre>
</td>
</tr>
</table>
<center><a href="../em02t006/em02t006.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../em02t008/em02t008.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
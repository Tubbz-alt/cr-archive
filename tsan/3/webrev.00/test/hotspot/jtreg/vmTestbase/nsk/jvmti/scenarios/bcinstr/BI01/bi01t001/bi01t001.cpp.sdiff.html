<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/bcinstr/BI01/bi01t001/bi01t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../allocation/AP04/ap04t003/libap04t003.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="libbi01t001.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/bcinstr/BI01/bi01t001/bi01t001.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;

 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 /* scaffold objects */
 33 static jvmtiEnv *jvmti = NULL;
 34 static jlong timeout = 0;
 35 
 36 #define TESTED_CLASS_NAME   &quot;nsk/jvmti/scenarios/bcinstr/BI01/bi01t001a&quot;
 37 
 38 static jint newClassSize;
 39 static unsigned char* newClassBytes;
 40 static jvmtiClassDefinition oldClassDef;
 41 
 42 /* ============================================================================= */
 43 /*
 44  * Class:     nsk_jvmti_scenarios_bcinstr_BI01_bi01t001
 45  * Method:    setNewByteCode
 46  * Signature: ([B)Z
 47  */
 48 JNIEXPORT jboolean JNICALL
 49 Java_nsk_jvmti_scenarios_bcinstr_BI01_bi01t001_setNewByteCode(JNIEnv *jni_env,
<span class="line-modified"> 50                         jobject o, jbyteArray byteCode) {</span>
<span class="line-modified"> 51 </span>

 52     jbyte* elements;
 53     jboolean isCopy;
 54 
<span class="line-modified"> 55     newClassSize = jni_env-&gt;GetArrayLength(byteCode);</span>
<span class="line-modified"> 56     if (!NSK_JNI_VERIFY(jni_env, newClassSize &gt; 0)) {</span>
 57         nsk_jvmti_setFailStatus();
 58         return NSK_FALSE;
 59     }
 60     NSK_DISPLAY1(&quot;\t... got array size: %d\n&quot;, newClassSize);
 61 
<span class="line-modified"> 62     elements = jni_env-&gt;GetByteArrayElements(byteCode, &amp;isCopy);</span>
<span class="line-removed"> 63     if (!NSK_JNI_VERIFY(jni_env, elements != NULL)) {</span>
<span class="line-removed"> 64         nsk_jvmti_setFailStatus();</span>
<span class="line-removed"> 65         return NSK_FALSE;</span>
<span class="line-removed"> 66     }</span>
 67     NSK_DISPLAY1(&quot;\t... got elements list: 0x%p\n&quot;, (void*)elements);
 68 
 69     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Allocate(newClassSize, &amp;newClassBytes))) {
 70         nsk_jvmti_setFailStatus();
 71         return NSK_FALSE;
 72     }
 73     NSK_DISPLAY1(&quot;\t... created bytes array: 0x%p\n&quot;, (void*)newClassBytes);
 74 
 75     {
 76         int j;
 77         for (j = 0; j &lt; newClassSize; j++)
 78             newClassBytes[j] = (unsigned char)elements[j];
 79     }
 80     NSK_DISPLAY1(&quot;\t... copied bytecode: %d bytes\n&quot;, (int)newClassSize);
 81 
 82     NSK_DISPLAY1(&quot;\t... release elements list: 0x%p\n&quot;, (void*)elements);
<span class="line-modified"> 83     NSK_TRACE(jni_env-&gt;ReleaseByteArrayElements(byteCode, elements, JNI_ABORT));</span>
 84     NSK_DISPLAY0(&quot;\t... released\n&quot;);
 85     return NSK_TRUE;
 86 }
 87 
 88 /* ============================================================================= */
 89 /*
 90  * Class:     nsk_jvmti_scenarios_bcinstr_BI01_bi01t001
 91  * Method:    setClass
 92  * Signature: (Ljava/lang/Class;)V
 93  */
 94 JNIEXPORT void JNICALL
 95 Java_nsk_jvmti_scenarios_bcinstr_BI01_bi01t001_setClass(JNIEnv *jni_env,
 96                         jobject o, jclass cls) {
<span class="line-modified"> 97 </span>
<span class="line-modified"> 98     oldClassDef.klass = (jclass) jni_env-&gt;NewGlobalRef(cls);</span>
<span class="line-removed"> 99     if (!NSK_JNI_VERIFY(jni_env, oldClassDef.klass != NULL)) {</span>
<span class="line-removed">100         nsk_jvmti_setFailStatus();</span>
<span class="line-removed">101     }</span>
102 }
103 
104 /* ============================================================================= */
105 
106 /** Callback function for ClassFileLoadHook event. */
107 JNIEXPORT void JNICALL
108 cbClassFileLoadHook(jvmtiEnv *jvmti_env, JNIEnv* jni_env,
109             jclass class_being_redefined, jobject loader, const char* name,
110             jobject protection_domain, jint class_data_len,
111             const unsigned char* class_data, jint* new_class_data_len,
112             unsigned char** new_class_data) {
113 
114     if (name == NULL || strcmp(name, TESTED_CLASS_NAME)) {
115         return;
116     }
117 
118     NSK_DISPLAY3(&quot;CLASS_FILE_LOAD_HOOK event: %s\n\treceived bytecode: 0x%p:%d\n&quot;,
119                         name, (void *)class_data, class_data_len);
120     if (nsk_getVerboseMode()) {
121         nsk_printHexBytes(&quot;   &quot;, 16, class_data_len, class_data);
</pre>
<hr />
<pre>
137         oldClassDef.class_bytes = arr;
138     }
139 
140     *new_class_data_len = newClassSize;
141     *new_class_data = newClassBytes;
142 
143     NSK_DISPLAY2(&quot;Replace with new bytecode: 0x%p:%d\n&quot;,
144                                 (void*)newClassBytes,
145                                 (int)newClassSize);
146     if (nsk_getVerboseMode()) {
147         nsk_printHexBytes(&quot;   &quot;, 16, newClassSize,
148                                 newClassBytes);
149     }
150 }
151 
152 /* ============================================================================= */
153 
154 /** Agent algorithm. */
155 static void JNICALL
156 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {

157 
158     /*Wait for debuggee to read new byte codes nsk_jvmti_waitForSync#1*/
159     NSK_DISPLAY0(&quot;Wait for debuggee to read new byte codes nsk_jvmti_waitForSync#1\n&quot;);
160     if (!nsk_jvmti_waitForSync(timeout))
161         return;
162 
163     if (!nsk_jvmti_resumeSync())
164         return;
165 
166     NSK_DISPLAY0(&quot;Wait for debuggee to load tested class by classLoader\n&quot;);
167     /*Wait for debuggee to load next class nsk_jvmti_waitForSync#2*/
168     if (!nsk_jvmti_waitForSync(timeout))
169         return;
170 
171     if (!nsk_jvmti_resumeSync())
172         return;
173 
174     /*Wait for debuggee to check instrumentation code works nsk_jvmti_waitForSync#3*/
175     NSK_DISPLAY0(&quot;Wait for debuggee to check instrumentation code works nsk_jvmti_waitForSync#3\n&quot;);
176     if (!nsk_jvmti_waitForSync(timeout))
</pre>
<hr />
<pre>
197                     oldClassDef.klass,
198                     oldClassDef.class_bytes,
199                     oldClassDef.class_byte_count);
200     if (nsk_getVerboseMode()) {
201         nsk_printHexBytes(&quot;   &quot;, 16, oldClassDef.class_byte_count,
202                                 oldClassDef.class_bytes);
203     }
204     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RedefineClasses(1, &amp;oldClassDef))) {
205         nsk_jvmti_setFailStatus();
206         return;
207     }
208 
209     if (!nsk_jvmti_resumeSync())
210         return;
211 
212     /*Wait for debuggee to check old byte code works nsk_jvmti_waitForSync#5*/
213     NSK_DISPLAY0(&quot;Wait for debuggee to check old byte code works nsk_jvmti_waitForSync#5\n&quot;);
214     if (!nsk_jvmti_waitForSync(timeout))
215         return;
216 
<span class="line-modified">217     agentJNI-&gt;DeleteGlobalRef(oldClassDef.klass);</span>
218 
219     NSK_DISPLAY0(&quot;Let debuggee to finish\n&quot;);
220     if (!nsk_jvmti_resumeSync())
221         return;
222 
223 }
224 
225 /* ============================================================================= */
226 
227 /** Agent library initialization. */
228 #ifdef STATIC_BUILD
229 JNIEXPORT jint JNICALL Agent_OnLoad_bi01t001(JavaVM *jvm, char *options, void *reserved) {
230     return Agent_Initialize(jvm, options, reserved);
231 }
232 JNIEXPORT jint JNICALL Agent_OnAttach_bi01t001(JavaVM *jvm, char *options, void *reserved) {
233     return Agent_Initialize(jvm, options, reserved);
234 }
235 JNIEXPORT jint JNI_OnLoad_bi01t001(JavaVM *jvm, char *options, void *reserved) {
236     return JNI_VERSION_1_8;
237 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
<span class="line-added"> 27 #include &quot;ExceptionCheckingJniEnv.hpp&quot;</span>
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* scaffold objects */
 34 static jvmtiEnv *jvmti = NULL;
 35 static jlong timeout = 0;
 36 
 37 #define TESTED_CLASS_NAME   &quot;nsk/jvmti/scenarios/bcinstr/BI01/bi01t001a&quot;
 38 
 39 static jint newClassSize;
 40 static unsigned char* newClassBytes;
 41 static jvmtiClassDefinition oldClassDef;
 42 
 43 /* ============================================================================= */
 44 /*
 45  * Class:     nsk_jvmti_scenarios_bcinstr_BI01_bi01t001
 46  * Method:    setNewByteCode
 47  * Signature: ([B)Z
 48  */
 49 JNIEXPORT jboolean JNICALL
 50 Java_nsk_jvmti_scenarios_bcinstr_BI01_bi01t001_setNewByteCode(JNIEnv *jni_env,
<span class="line-modified"> 51                                                               jobject o,</span>
<span class="line-modified"> 52                                                               jbyteArray byteCode) {</span>
<span class="line-added"> 53     ExceptionCheckingJniEnvPtr ec_jni(jni_env);</span>
 54     jbyte* elements;
 55     jboolean isCopy;
 56 
<span class="line-modified"> 57     newClassSize = ec_jni-&gt;GetArrayLength(byteCode, TRACE_JNI_CALL);</span>
<span class="line-modified"> 58     if (newClassSize &lt;= 0) {</span>
 59         nsk_jvmti_setFailStatus();
 60         return NSK_FALSE;
 61     }
 62     NSK_DISPLAY1(&quot;\t... got array size: %d\n&quot;, newClassSize);
 63 
<span class="line-modified"> 64     elements = ec_jni-&gt;GetByteArrayElements(byteCode, &amp;isCopy, TRACE_JNI_CALL);</span>




 65     NSK_DISPLAY1(&quot;\t... got elements list: 0x%p\n&quot;, (void*)elements);
 66 
 67     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Allocate(newClassSize, &amp;newClassBytes))) {
 68         nsk_jvmti_setFailStatus();
 69         return NSK_FALSE;
 70     }
 71     NSK_DISPLAY1(&quot;\t... created bytes array: 0x%p\n&quot;, (void*)newClassBytes);
 72 
 73     {
 74         int j;
 75         for (j = 0; j &lt; newClassSize; j++)
 76             newClassBytes[j] = (unsigned char)elements[j];
 77     }
 78     NSK_DISPLAY1(&quot;\t... copied bytecode: %d bytes\n&quot;, (int)newClassSize);
 79 
 80     NSK_DISPLAY1(&quot;\t... release elements list: 0x%p\n&quot;, (void*)elements);
<span class="line-modified"> 81     ec_jni-&gt;ReleaseByteArrayElements(byteCode, elements, JNI_ABORT, TRACE_JNI_CALL);</span>
 82     NSK_DISPLAY0(&quot;\t... released\n&quot;);
 83     return NSK_TRUE;
 84 }
 85 
 86 /* ============================================================================= */
 87 /*
 88  * Class:     nsk_jvmti_scenarios_bcinstr_BI01_bi01t001
 89  * Method:    setClass
 90  * Signature: (Ljava/lang/Class;)V
 91  */
 92 JNIEXPORT void JNICALL
 93 Java_nsk_jvmti_scenarios_bcinstr_BI01_bi01t001_setClass(JNIEnv *jni_env,
 94                         jobject o, jclass cls) {
<span class="line-modified"> 95     ExceptionCheckingJniEnvPtr ec_jni(jni_env);</span>
<span class="line-modified"> 96     oldClassDef.klass = (jclass) ec_jni-&gt;NewGlobalRef(cls, TRACE_JNI_CALL);</span>



 97 }
 98 
 99 /* ============================================================================= */
100 
101 /** Callback function for ClassFileLoadHook event. */
102 JNIEXPORT void JNICALL
103 cbClassFileLoadHook(jvmtiEnv *jvmti_env, JNIEnv* jni_env,
104             jclass class_being_redefined, jobject loader, const char* name,
105             jobject protection_domain, jint class_data_len,
106             const unsigned char* class_data, jint* new_class_data_len,
107             unsigned char** new_class_data) {
108 
109     if (name == NULL || strcmp(name, TESTED_CLASS_NAME)) {
110         return;
111     }
112 
113     NSK_DISPLAY3(&quot;CLASS_FILE_LOAD_HOOK event: %s\n\treceived bytecode: 0x%p:%d\n&quot;,
114                         name, (void *)class_data, class_data_len);
115     if (nsk_getVerboseMode()) {
116         nsk_printHexBytes(&quot;   &quot;, 16, class_data_len, class_data);
</pre>
<hr />
<pre>
132         oldClassDef.class_bytes = arr;
133     }
134 
135     *new_class_data_len = newClassSize;
136     *new_class_data = newClassBytes;
137 
138     NSK_DISPLAY2(&quot;Replace with new bytecode: 0x%p:%d\n&quot;,
139                                 (void*)newClassBytes,
140                                 (int)newClassSize);
141     if (nsk_getVerboseMode()) {
142         nsk_printHexBytes(&quot;   &quot;, 16, newClassSize,
143                                 newClassBytes);
144     }
145 }
146 
147 /* ============================================================================= */
148 
149 /** Agent algorithm. */
150 static void JNICALL
151 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
<span class="line-added">152     ExceptionCheckingJniEnvPtr ec_jni(agentJNI);</span>
153 
154     /*Wait for debuggee to read new byte codes nsk_jvmti_waitForSync#1*/
155     NSK_DISPLAY0(&quot;Wait for debuggee to read new byte codes nsk_jvmti_waitForSync#1\n&quot;);
156     if (!nsk_jvmti_waitForSync(timeout))
157         return;
158 
159     if (!nsk_jvmti_resumeSync())
160         return;
161 
162     NSK_DISPLAY0(&quot;Wait for debuggee to load tested class by classLoader\n&quot;);
163     /*Wait for debuggee to load next class nsk_jvmti_waitForSync#2*/
164     if (!nsk_jvmti_waitForSync(timeout))
165         return;
166 
167     if (!nsk_jvmti_resumeSync())
168         return;
169 
170     /*Wait for debuggee to check instrumentation code works nsk_jvmti_waitForSync#3*/
171     NSK_DISPLAY0(&quot;Wait for debuggee to check instrumentation code works nsk_jvmti_waitForSync#3\n&quot;);
172     if (!nsk_jvmti_waitForSync(timeout))
</pre>
<hr />
<pre>
193                     oldClassDef.klass,
194                     oldClassDef.class_bytes,
195                     oldClassDef.class_byte_count);
196     if (nsk_getVerboseMode()) {
197         nsk_printHexBytes(&quot;   &quot;, 16, oldClassDef.class_byte_count,
198                                 oldClassDef.class_bytes);
199     }
200     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RedefineClasses(1, &amp;oldClassDef))) {
201         nsk_jvmti_setFailStatus();
202         return;
203     }
204 
205     if (!nsk_jvmti_resumeSync())
206         return;
207 
208     /*Wait for debuggee to check old byte code works nsk_jvmti_waitForSync#5*/
209     NSK_DISPLAY0(&quot;Wait for debuggee to check old byte code works nsk_jvmti_waitForSync#5\n&quot;);
210     if (!nsk_jvmti_waitForSync(timeout))
211         return;
212 
<span class="line-modified">213     ec_jni-&gt;DeleteGlobalRef(oldClassDef.klass, TRACE_JNI_CALL);</span>
214 
215     NSK_DISPLAY0(&quot;Let debuggee to finish\n&quot;);
216     if (!nsk_jvmti_resumeSync())
217         return;
218 
219 }
220 
221 /* ============================================================================= */
222 
223 /** Agent library initialization. */
224 #ifdef STATIC_BUILD
225 JNIEXPORT jint JNICALL Agent_OnLoad_bi01t001(JavaVM *jvm, char *options, void *reserved) {
226     return Agent_Initialize(jvm, options, reserved);
227 }
228 JNIEXPORT jint JNICALL Agent_OnAttach_bi01t001(JavaVM *jvm, char *options, void *reserved) {
229     return Agent_Initialize(jvm, options, reserved);
230 }
231 JNIEXPORT jint JNI_OnLoad_bi01t001(JavaVM *jvm, char *options, void *reserved) {
232     return JNI_VERSION_1_8;
233 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../allocation/AP04/ap04t003/libap04t003.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="libbi01t001.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/allocation/AP04/ap04t003/ap04t003.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdio.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &lt;jvmti.h&gt;
 27 #include &quot;agent_common.h&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 28 #include &quot;ExceptionCheckingJniEnv.hpp&quot;</span>
 29 #include &quot;nsk_tools.h&quot;
 30 #include &quot;jni_tools.h&quot;
 31 #include &quot;JVMTITools.h&quot;
 32 #include &quot;jvmti_tools.h&quot;
 33 
 34 extern &quot;C&quot; {
 35 
 36 #define OBJ_MAX_COUNT 100000
 37 
 38 static JNIEnv *jni = NULL;
 39 static jvmtiEnv *jvmti = NULL;
 40 static jvmtiEventCallbacks callbacks;
 41 static jvmtiCapabilities caps;
 42 
 43 static jlong timeout = 0;
 44 
 45 static const char* DEBUGEE_SIGNATURE = &quot;Lnsk/jvmti/scenarios/allocation/AP04/ap04t003;&quot;;
 46 static const char* ROOT_SIGNATURE    = &quot;[Lnsk/jvmti/scenarios/allocation/AP04/ap04t003;&quot;;
 47 
 48 static jclass debugeeClass = NULL;
 49 static jfieldID rootFieldID;
 50 
 51 static jrawMonitorID startLock = NULL;
 52 static jrawMonitorID runLock = NULL;
 53 static jrawMonitorID endLock = NULL;
 54 
 55 static volatile int iterationCount = 0;
 56 static volatile int objectCount = 0;
 57 
 58 /***********************************************************************/
 59 
 60 static jrawMonitorID counterMonitor_ptr = NULL;
 61 
 62 static void increaseCounter(volatile int* counterPtr) {
 63 
 64     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(counterMonitor_ptr))) {
 65         nsk_jvmti_setFailStatus();
 66     }
 67 
 68     (*counterPtr)++;
 69 
 70     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(counterMonitor_ptr))) {
 71         nsk_jvmti_setFailStatus();
 72     }
 73 }
 74 
 75 static void setCounter(volatile int* counterPtr, int value) {
 76 
 77     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(counterMonitor_ptr))) {
 78         nsk_jvmti_setFailStatus();
 79     }
 80 
 81     *counterPtr = value;
 82 
 83     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(counterMonitor_ptr))) {
 84         nsk_jvmti_setFailStatus();
 85     }
 86 }
 87 
 88 static int getCounter(volatile int* counterPtr) {
 89     int result;
 90 
 91     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(counterMonitor_ptr))) {
 92         nsk_jvmti_setFailStatus();
 93     }
 94 
 95     result = *counterPtr;
 96 
 97     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(counterMonitor_ptr))) {
 98         nsk_jvmti_setFailStatus();
 99     }
100 
101     return result;
102 }
103 
104 /***********************************************************************/
105 
106 void notifyThread() {
107 
108     /* enter and notify runLock */
109     {
110         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(runLock))) {
111             nsk_jvmti_setFailStatus();
112         }
113         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorNotify(runLock))) {
114             nsk_jvmti_setFailStatus();
115         }
116         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(runLock))) {
117             nsk_jvmti_setFailStatus();
118         }
119     }
120 }
121 
122 jvmtiIterationControl JNICALL
123 heapObjectCallback(jlong  class_tag,
124                    jlong  size,
125                    jlong* tag_ptr,
126                    void*  user_data) {
127 
128     if (getCounter(&amp;iterationCount) == 0) {
129         notifyThread();
130     }
131     increaseCounter(&amp;iterationCount);
132 
133     if (*tag_ptr &gt; 0) {
134         increaseCounter(&amp;objectCount);
135     }
136 
137     return JVMTI_ITERATION_CONTINUE;
138 }
139 
140 /* jvmtiHeapRootCallback */
141 jvmtiIterationControl JNICALL
142 heapRootCallback(jvmtiHeapRootKind root_kind,
143                  jlong class_tag,
144                  jlong size,
145                  jlong* tag_ptr,
146                  void* user_data) {
147 
148     if (getCounter(&amp;iterationCount) == 0) {
149         notifyThread();
150     }
151     increaseCounter(&amp;iterationCount);
152 
153     if (*tag_ptr &gt; 0) {
154         increaseCounter(&amp;objectCount);
155     }
156 
157     return JVMTI_ITERATION_CONTINUE;
158 }
159 
160 /* jvmtiStackReferenceCallback */
161 jvmtiIterationControl JNICALL
162 stackReferenceCallback(jvmtiHeapRootKind root_kind,
163                        jlong     class_tag,
164                        jlong     size,
165                        jlong*    tag_ptr,
166                        jlong     thread_tag,
167                        jint      depth,
168                        jmethodID method,
169                        jint      slot,
170                        void*     user_data) {
171 
172     if (getCounter(&amp;iterationCount) == 0) {
173         notifyThread();
174     }
175     increaseCounter(&amp;iterationCount);
176 
177     if (*tag_ptr &gt; 0) {
178         increaseCounter(&amp;objectCount);
179     }
180 
181     return JVMTI_ITERATION_CONTINUE;
182 }
183 
184 
185 /* jvmtiObjectReferenceCallback */
186 jvmtiIterationControl JNICALL
187 objectReferenceCallback(jvmtiObjectReferenceKind reference_kind,
188                         jlong  class_tag,
189                         jlong  size,
190                         jlong* tag_ptr,
191                         jlong  referrer_tag,
192                         jint   referrer_index,
193                         void*  user_data) {
194 
195     if (getCounter(&amp;iterationCount) == 0) {
196         notifyThread();
197     }
198     increaseCounter(&amp;iterationCount);
199 
200     if (*tag_ptr &gt; 0) {
201         increaseCounter(&amp;objectCount);
202     }
203 
204     return JVMTI_ITERATION_CONTINUE;
205 }
206 
207 /********* Agent thread modifying tags of objects ************/
208 
209 /** Body of new agent thread: modify tags of tagged object. */
210 void JNICALL agent_start(jvmtiEnv* jvmti, JNIEnv* jni, void *p) {
211 
212     jint taggedObjectsCount = 0;
213     jobject* taggedObjectsList = NULL;
214 
215     NSK_DISPLAY0(&quot;Agent thread: started.\n&quot;);
216 
217     /* obtain tagged objects list */
218     {
219         jlong tag = (jlong)1;
220 
221         if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetObjectsWithTags(
222                 1, &amp;tag, &amp;taggedObjectsCount, &amp;taggedObjectsList, NULL))) {
223             nsk_jvmti_setFailStatus();
224             return;
225         }
226     }
227 
228     NSK_DISPLAY1(&quot;Agent thread: got tagged objects: %d\n&quot;, (int)taggedObjectsCount);
229 
230     if (!NSK_VERIFY(taggedObjectsCount == OBJ_MAX_COUNT)) {
231         nsk_jvmti_setFailStatus();
232         return;
233     }
234 
235     /* enter runLock */
236     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(runLock))) {
237         nsk_jvmti_setFailStatus();
238     }
239 
240     /* enter and notify startLock */
241     {
242         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(startLock))) {
243             nsk_jvmti_setFailStatus();
244         }
245         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorNotify(startLock))) {
246             nsk_jvmti_setFailStatus();
247         }
248         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(startLock))) {
249             nsk_jvmti_setFailStatus();
250         }
251     }
252 
253     NSK_DISPLAY0(&quot;Agent thread: wait for run notification\n&quot;);
254 
255     /* wait on runLock */
256     {
257         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorWait(runLock, timeout))) {
258             nsk_jvmti_setFailStatus();
259         }
260         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(runLock))) {
261             nsk_jvmti_setFailStatus();
262         }
263     }
264 
265     NSK_DISPLAY0(&quot;Agent thread: modify tags of each even object.\n&quot;);
266 
267     /* modify tags of each even object */
268     {
269         int modified = 0;
270         int i;
271         for (i = 0; i &lt; taggedObjectsCount; i+=2) {
272             if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(taggedObjectsList[i], 0))) {
273                 nsk_jvmti_setFailStatus();
274                 continue;
275             }
276             modified++;
277         }
278 
279         NSK_DISPLAY2(&quot;Agent thread: tags modified: %d of %d\n&quot;,
280                                             modified, (int)taggedObjectsCount);
281     }
282 
283     /* destroy objects list */
284     {
285         if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)taggedObjectsList))) {
286             nsk_jvmti_setFailStatus();
287         }
288     }
289 
290     /* enter and notify endLock */
291     {
292         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(endLock))) {
293             nsk_jvmti_setFailStatus();
294         }
295         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorNotify(endLock))) {
296             nsk_jvmti_setFailStatus();
297         }
298         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(endLock))) {
299             nsk_jvmti_setFailStatus();
300         }
301     }
302 
303     NSK_DISPLAY0(&quot;Agent thread: finished.\n&quot;);
304 }
305 
306 /***********************************************************************/
307 
<a name="3" id="anc3"></a><span class="line-modified">308 static int startThread(jthread threadObj) {</span>
309     int success = NSK_TRUE;
310 
311     /* enter startLock */
312     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(startLock))) {
313         nsk_jvmti_setFailStatus();
314     }
315 
316     /* start thread */
317     if (!NSK_JVMTI_VERIFY(
318             jvmti-&gt;RunAgentThread(threadObj, agent_start, NULL, JVMTI_THREAD_NORM_PRIORITY))) {
319         success = NSK_FALSE;
320         nsk_jvmti_setFailStatus();
321     } else {
322         /* wait on startLock */
323         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorWait(startLock, timeout))) {
324             nsk_jvmti_setFailStatus();
325         }
326     }
327 
328     /* exit starLock */
329     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(startLock))) {
330         nsk_jvmti_setFailStatus();
331     }
332 
333     return success;
334 }
335 
336 /** Create thread object for new agent thread. */
<a name="4" id="anc4"></a><span class="line-modified">337 static jthread newThreadObj(JNIEnv* jni_env) {</span>
<span class="line-added">338     ExceptionCheckingJniEnvPtr ec_jni(jni_env);</span>
339     jclass thrClass;
340     jmethodID cid;
<a name="5" id="anc5"></a>






341 
<a name="6" id="anc6"></a><span class="line-modified">342     thrClass = ec_jni-&gt;FindClass(&quot;java/lang/Thread&quot;, TRACE_JNI_CALL);</span>
<span class="line-modified">343     cid = ec_jni-&gt;GetMethodID(thrClass, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, TRACE_JNI_CALL);</span>
<span class="line-modified">344     return ec_jni-&gt;NewObject(thrClass, cid, TRACE_JNI_CALL);</span>










345 }
346 
347 /***********************************************************************/
348 
349 /** Clean counters and start new agent thread with agent_start() body. */
<a name="7" id="anc7"></a><span class="line-modified">350 static int prepareToIteration(JNIEnv* jni) {</span>
351     jthread threadObj = NULL;
352 
353     setCounter(&amp;iterationCount, 0);
354     setCounter(&amp;objectCount, 0);
355 
356     threadObj = newThreadObj(jni);
<a name="8" id="anc8"></a>



357 
358     /* enter endLock */
359     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(endLock))) {
360         nsk_jvmti_setFailStatus();
361     }
362 
363     NSK_DISPLAY0(&quot;Starting new agent thread...\n&quot;);
<a name="9" id="anc9"></a><span class="line-modified">364     return startThread(threadObj);</span>
365 }
366 
367 /** Wait for new agent thread to complete. */
<a name="10" id="anc10"></a><span class="line-modified">368 static void afterIteration() {</span>
369 
370     /* notify new agent thread (in case if not yet notified) */
371     notifyThread();
372 
373     NSK_DISPLAY0(&quot;Wait for new agent thread to complete\n&quot;);
374 
375     /* wait on endLock */
376     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorWait(endLock, timeout))) {
377         nsk_jvmti_setFailStatus();
378     }
379 
380     /* exit endLock */
381     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(endLock))) {
382         nsk_jvmti_setFailStatus();
383     }
384 }
385 
386 /***********************************************************************/
387 
388 JNIEXPORT void JNICALL
389 Java_nsk_jvmti_scenarios_allocation_AP04_ap04t003_setTag(JNIEnv* jni,
390                                                          jclass  klass,
391                                                          jobject target, /* object to be tagged */
392                                                          jlong   tag) {
393 
394     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(target, tag))) {
395         nsk_jvmti_setFailStatus();
396     }
397 }
398 
399 JNIEXPORT void JNICALL
400 Java_nsk_jvmti_scenarios_allocation_AP04_ap04t003_runIterateOverHeap(JNIEnv* jni,
401                                                                      jclass  klass) {
402     int modified = 0;
403     int found = 0;
404 
405     if (!prepareToIteration(jni))
406         return;
407 
408     NSK_DISPLAY0(&quot;Calling IterateOverHeap...\n&quot;);
409     if (!NSK_JVMTI_VERIFY(jvmti-&gt;IterateOverHeap(JVMTI_HEAP_OBJECT_TAGGED,
410                                                  heapObjectCallback,
411                                                  NULL /*user_data*/))) {
412         nsk_jvmti_setFailStatus();
413     }
414     NSK_DISPLAY0(&quot;IterateOverHeap finished.\n&quot;);
415 
<a name="11" id="anc11"></a><span class="line-modified">416     afterIteration();</span>
417 
418     found = getCounter(&amp;objectCount);
419     NSK_DISPLAY1(&quot;Found tagged objects: %d\n&quot;, found);
420 
421     modified = OBJ_MAX_COUNT - found;
422     if (modified &gt; 0) {
423         NSK_COMPLAIN2(&quot;Tags were modified by other thread during heap iteration: %d of %d\n&quot;,
424                                                         modified, OBJ_MAX_COUNT);
425         nsk_jvmti_setFailStatus();
426     }
427 }
428 
429 JNIEXPORT void JNICALL
430 Java_nsk_jvmti_scenarios_allocation_AP04_ap04t003_runIterateOverReachableObjects(JNIEnv* jni,
431                                                                                  jclass  klass) {
432     int modified = 0;
433     int found = 0;
434 
435     if (!prepareToIteration(jni))
436         return;
437 
438     NSK_DISPLAY0(&quot;Calling IterateOverReachableObjects...\n&quot;);
439     if (!NSK_JVMTI_VERIFY(jvmti-&gt;IterateOverReachableObjects(heapRootCallback,
440                                                              stackReferenceCallback,
441                                                              objectReferenceCallback,
442                                                              NULL /*user_data*/))) {
443         nsk_jvmti_setFailStatus();
444     }
445     NSK_DISPLAY0(&quot;IterateOverReachableObjects finished.\n&quot;);
446 
<a name="12" id="anc12"></a><span class="line-modified">447     afterIteration();</span>
448 
449     found = getCounter(&amp;objectCount);
450     NSK_DISPLAY1(&quot;Found tagged objects: %d\n&quot;, found);
451 
452     modified = OBJ_MAX_COUNT - found;
453     if (modified &gt; 0) {
454         NSK_COMPLAIN2(&quot;Tags were modified by other thread during heap iteration: %d of %d\n&quot;,
455                                                         modified, OBJ_MAX_COUNT);
456         nsk_jvmti_setFailStatus();
457     }
458 }
459 
460 JNIEXPORT void JNICALL
461 Java_nsk_jvmti_scenarios_allocation_AP04_ap04t003_runIterateOverInstancesOfClass(JNIEnv* jni,
462                                                                                  jclass  klass) {
463     int modified = 0;
464     int found = 0;
465 
466     if (!prepareToIteration(jni))
467         return;
468 
469     NSK_DISPLAY0(&quot;Calling IterateOverInstancesOfClass...\n&quot;);
470     if (!NSK_JVMTI_VERIFY(jvmti-&gt;IterateOverInstancesOfClass(debugeeClass,
471                                                              JVMTI_HEAP_OBJECT_TAGGED,
472                                                              heapObjectCallback,
473                                                              NULL /*user_data*/))) {
474         nsk_jvmti_setFailStatus();
475     }
476     NSK_DISPLAY0(&quot;IterateOverInstancesOfClass finished.\n&quot;);
477 
<a name="13" id="anc13"></a><span class="line-modified">478     afterIteration();</span>
479 
480     found = getCounter(&amp;objectCount);
481     NSK_DISPLAY1(&quot;Found tagged objects: %d\n&quot;, found);
482 
483     modified = OBJ_MAX_COUNT - found;
484     if (modified &gt; 0) {
485         NSK_COMPLAIN2(&quot;Tags were modified by other thread during heap iteration: %d of %d\n&quot;,
486                                                         modified, OBJ_MAX_COUNT);
487         nsk_jvmti_setFailStatus();
488     }
489 }
490 
491 JNIEXPORT void JNICALL
<a name="14" id="anc14"></a><span class="line-modified">492 Java_nsk_jvmti_scenarios_allocation_AP04_ap04t003_runIterateOverObjectsReachableFromObject(JNIEnv* jni_env,</span>
493                                                                                            jclass  klass) {
<a name="15" id="anc15"></a><span class="line-added">494     ExceptionCheckingJniEnvPtr ec_jni(jni_env);</span>
495     jobject root = NULL;
496     int modified = 0;
497     int found = 0;
498 
<a name="16" id="anc16"></a><span class="line-modified">499     root = ec_jni-&gt;GetStaticObjectField(debugeeClass, rootFieldID, TRACE_JNI_CALL);</span>





500 
<a name="17" id="anc17"></a><span class="line-modified">501     if (!prepareToIteration(jni_env))</span>
502         return;
503 
504     NSK_DISPLAY0(&quot;Calling IterateOverObjectsReachableFromObject...\n&quot;);
505     if (!NSK_JVMTI_VERIFY(jvmti-&gt;IterateOverObjectsReachableFromObject(root,
506                                                                        objectReferenceCallback,
507                                                                        NULL /*user_data*/))) {
508         nsk_jvmti_setFailStatus();
509     }
510     NSK_DISPLAY0(&quot;IterateOverObjectsReachableFromObject finished.\n&quot;);
511 
<a name="18" id="anc18"></a><span class="line-modified">512     afterIteration();</span>
513 
514     found = getCounter(&amp;objectCount);
515     NSK_DISPLAY1(&quot;Found tagged objects: %d\n&quot;, found);
516 
517     modified = OBJ_MAX_COUNT - found;
518     if (modified &gt; 0) {
519         NSK_COMPLAIN2(&quot;Tags were modified by other thread during heap iteration: %d of %d\n&quot;,
520                                                         modified, OBJ_MAX_COUNT);
521         nsk_jvmti_setFailStatus();
522     }
523 }
524 
525 static void JNICALL
<a name="19" id="anc19"></a><span class="line-modified">526 agentProc(jvmtiEnv* jvmti, JNIEnv* jni_env, void* arg) {</span>
<span class="line-modified">527     ExceptionCheckingJniEnvPtr ec_jni(jni_env);</span>
528     NSK_DISPLAY0(&quot;Wait for debugee start\n\n&quot;);
529     if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout)))
530         return;
531 
532     NSK_DISPLAY1(&quot;Find debugee class: %s\n&quot;, DEBUGEE_SIGNATURE);
533     debugeeClass = nsk_jvmti_classBySignature(DEBUGEE_SIGNATURE);
534     if (debugeeClass == NULL) {
535         nsk_jvmti_setFailStatus();
536         return;
537     }
538 
<a name="20" id="anc20"></a><span class="line-modified">539     debugeeClass = (jclass) ec_jni-&gt;NewGlobalRef(debugeeClass, TRACE_JNI_CALL);</span>


540 
541     NSK_DISPLAY1(&quot;Find ID of &#39;root&#39; field: %s\n&quot;, ROOT_SIGNATURE);
<a name="21" id="anc21"></a><span class="line-modified">542     rootFieldID = ec_jni-&gt;GetStaticFieldID(debugeeClass, &quot;root&quot;,</span>
<span class="line-modified">543                                         ROOT_SIGNATURE, TRACE_JNI_CALL);</span>



544 
545     NSK_DISPLAY0(&quot;Let debugee to run test cases\n&quot;);
546     if (!NSK_VERIFY(nsk_jvmti_resumeSync()))
547         return;
548 
549     NSK_DISPLAY0(&quot;Wait for completion of test cases\n\n&quot;);
550     if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout)))
551         return;
552 
<a name="22" id="anc22"></a><span class="line-modified">553     ec_jni-&gt;DeleteGlobalRef(debugeeClass, TRACE_JNI_CALL);</span>
554     NSK_TRACE(jvmti-&gt;DestroyRawMonitor(counterMonitor_ptr));
555     NSK_TRACE(jvmti-&gt;DestroyRawMonitor(startLock));
556     NSK_TRACE(jvmti-&gt;DestroyRawMonitor(runLock));
557     NSK_TRACE(jvmti-&gt;DestroyRawMonitor(endLock));
558 
559     NSK_DISPLAY0(&quot;Let debugee to finish\n&quot;);
560     if (!NSK_VERIFY(nsk_jvmti_resumeSync()))
561         return;
562 }
563 
564 #ifdef STATIC_BUILD
565 JNIEXPORT jint JNICALL Agent_OnLoad_ap04t003(JavaVM *jvm, char *options, void *reserved) {
566     return Agent_Initialize(jvm, options, reserved);
567 }
568 JNIEXPORT jint JNICALL Agent_OnAttach_ap04t003(JavaVM *jvm, char *options, void *reserved) {
569     return Agent_Initialize(jvm, options, reserved);
570 }
571 JNIEXPORT jint JNI_OnLoad_ap04t003(JavaVM *jvm, char *options, void *reserved) {
572     return JNI_VERSION_1_8;
573 }
574 #endif
575 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
576     /* init framework and parse options */
577     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
578         return JNI_ERR;
579 
580     /* create JVMTI environment */
581     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
582     if (!NSK_VERIFY(jvmti != NULL))
583         return JNI_ERR;
584 
585     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;counterMonitor&quot;, &amp;counterMonitor_ptr))) {
586         return JNI_ERR;
587     }
588 
589     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;startLock&quot;, &amp;startLock))) {
590         return JNI_ERR;
591     }
592     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;runLock&quot;, &amp;runLock))) {
593         return JNI_ERR;
594     }
595     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;endLock&quot;, &amp;endLock))) {
596         return JNI_ERR;
597     }
598 
599     memset(&amp;caps, 0, sizeof(jvmtiCapabilities));
600     caps.can_tag_objects = 1;
601 
602     if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
603         return JNI_ERR;
604 
605     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetCapabilities(&amp;caps)))
606         return JNI_ERR;
607 
608     if (!caps.can_tag_objects)
609         NSK_DISPLAY0(&quot;Warning: tagging objects is not available\n&quot;);
610 
611     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
612         return JNI_ERR;
613     NSK_DISPLAY0(&quot;agentProc has been set\n\n&quot;);
614 
615     return JNI_OK;
616 }
617 
618 }
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
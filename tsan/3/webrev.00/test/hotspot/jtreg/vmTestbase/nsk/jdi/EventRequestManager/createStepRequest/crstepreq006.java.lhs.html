<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jdi/EventRequestManager/createStepRequest/crstepreq006.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.EventRequestManager.createStepRequest;
 25 
 26 import nsk.share.*;
 27 import nsk.share.jpda.*;
 28 import nsk.share.jdi.*;
 29 
 30 import com.sun.jdi.*;
 31 import com.sun.jdi.connect.*;
 32 import com.sun.jdi.request.*;
 33 import com.sun.jdi.event.*;
 34 import java.io.*;
 35 import java.util.*;
 36 
 37 /**
 38  */
 39 public class crstepreq006 {
 40 
 41     //----------------------------------------------------- immutable common fields
 42 
 43     static final int PASSED    = 0;
 44     static final int FAILED    = 2;
 45     static final int PASS_BASE = 95;
 46     static final int quit      = -1;
 47 
 48     private int instruction = 1;
 49     private int waitTime;
 50     private static int exitCode = PASSED;
 51 
 52     private ArgumentHandler     argHandler;
 53     private Log                 log;
 54     private Debugee             debuggee;
 55     private VirtualMachine      vm;
 56     private ReferenceType       debuggeeClass;
 57 
 58     private EventRequestManager eventRManager;
 59     private EventSet            eventSet;
 60     private EventIterator       eventIterator;
 61 
 62     //------------------------------------------------------ mutable common fields
 63 
 64     private final static String prefix = &quot;nsk.jdi.EventRequestManager.createStepRequest&quot;;
 65     private final static String className = &quot;.crstepreq006&quot;;
 66     private final static String debuggerName = prefix + className;
 67     private final static String debuggeeName = debuggerName + &quot;a&quot;;
 68     static final int lineForBreak = 62;
 69 
 70     //------------------------------------------------------ immutable common methods
 71 
 72     public static void main (String argv[]) {
 73         System.exit(run(argv, System.out) + PASS_BASE);
 74     }
 75 
 76     //------------------------------------------------------ test specific fields
 77 
 78     static final int maxCase = 3;
 79     static final String[] brakeMethods = {
 80         &quot;m00&quot;,
 81         &quot;m00&quot;,
 82         &quot;m00&quot;
 83                                         };
 84     static final int[][] checkedLines = {
 85         { 167, 171, 151},
 86         { 167, 175, 156},
 87         { 167, 178, 187}
 88                                         };
 89 
 90     static final String debuggeeThreadName = prefix + &quot;.Thread0crstepreq006a&quot;;
 91 
 92     //------------------------------------------------------ mutable common methods
 93 
 94     public static int run (String argv[], PrintStream out) {
 95 
 96         int exitStatus = new crstepreq006().runThis(argv, out);
 97         System.out.println (exitStatus == PASSED ? &quot;TEST PASSED&quot; : &quot;TEST FAILED&quot;);
 98         return exitCode;
 99     }
100 
101     private int runThis(String argv[], PrintStream out) {
102 
103         argHandler = new ArgumentHandler(argv);
104         log = new Log(out, argHandler);
105         waitTime = argHandler.getWaitTime() * 60000;
106 
107         try {
108 
109             Binder binder = new Binder(argHandler, log);
110             debuggee = binder.bindToDebugee(debuggeeName);
111             debuggee.redirectStderr(log, &quot;&quot;);
112             eventRManager = debuggee.getEventRequestManager();
113 
114             vm = debuggee.VM();
115             eventRManager = vm.eventRequestManager();
116 
117             debuggeeClass = waitForDebuggeeClassPrepared();
118 
119             execTest();
120 
121             debuggee.resume();
122             getEventSet();
123             if (eventIterator.nextEvent() instanceof VMDeathEvent) {
124                 display(&quot;Waiting for the debuggee&#39;s finish...&quot;);
125                 debuggee.waitFor();
126 
127                 display(&quot;Getting the debuggee&#39;s exit status.&quot;);
128                 int status = debuggee.getStatus();
129                 if (status != (PASSED + PASS_BASE)) {
130                     complain(&quot;Debuggee returned UNEXPECTED exit status: &quot; + status);
131                     exitCode = Consts.TEST_FAILED;
132                 }
133             } else {
134                 throw new TestBug(&quot;Last event is not the VMDeathEvent&quot;);
135             }
136 
137         } catch (VMDisconnectedException e) {
138             exitCode = Consts.TEST_FAILED;
139             complain(&quot;The test cancelled due to VMDisconnectedException.&quot;);
140             e.printStackTrace(out);
141             display(&quot;Trying: vm.process().destroy();&quot;);
142             if (vm != null) {
143                 Process vmProcess = vm.process();
144                 if (vmProcess != null) {
145                     vmProcess.destroy();
146                 }
147             }
148 
149         } catch (Exception e) {
150             exitCode = Consts.TEST_FAILED;
151             complain(&quot;Unexpected Exception: &quot; + e.getMessage());
152             e.printStackTrace(out);
153             complain(&quot;The test has not finished normally. Forcing: vm.exit().&quot;);
154             if (vm != null) {
155                 vm.exit(PASSED + PASS_BASE);
156             }
157             debuggee.resume();
158             getEventSet();
159         }
160 
161         return exitCode;
162     }
163 
164     //--------------------------------------------------------- mutable common methods
165 
166     private void execTest() {
167         BreakpointRequest bpRequest = setBreakpoint( null,
168                                                      debuggeeClass,
169                                                      &quot;methodForCommunication&quot;,
170                                                      lineForBreak,
171                                                      &quot;breakForCommunication&quot;);
172         bpRequest.enable();
173 
174         StepRequest stepRequest = null;
175 
176         display(&quot;TESTING BEGINS&quot;);
177         for (int testCase = 0; testCase &lt; maxCase &amp;&amp; instruction != quit; testCase++) {
178 
179             instruction = getInstruction();
180             if (instruction == quit) {
181                 vm.resume();
182                 break;
183             }
184 
185             display(&quot;:: CASE # &quot; + testCase);
186             stepRequest = setStepRequest( bpRequest,
187                                           &quot;thread&quot; + testCase,
188                                           testCase,
189                                           &quot;stepRequest&quot; + testCase );
190 
191             checkStepEvent( stepRequest,
192                             &quot;thread&quot; + testCase,
193                             testCase );
194         }
195         display(&quot;TESTING ENDS&quot;);
196     }
197 
198     //--------------------------------------------------------- test specific methods
199 
200     private StepRequest setStepRequest ( BreakpointRequest bpRequest,
201                                          String threadName,
202                                          int testCase,
203                                          String property ) {
204         StepRequest stepRequest = null;
205         for (;;) {
206             display(&quot;Wait for initial brakepoint event in &quot; + threadName);
207             BreakpointEvent bpEvent = (BreakpointEvent)waitForEvent(bpRequest);
208 
209             // check location of breakpoint event
210             int lineOfEvent = ((LocatableEvent)bpEvent).location().lineNumber();
211             if (lineOfEvent != lineForBreak) {
212                 complain(&quot;Wrong line number of initial brakepoint event for &quot; + threadName);
213                 complain(&quot;\texpected value : &quot; + lineForBreak + &quot;; got one : &quot; + lineOfEvent);
214                 break;
215             }
216 
217             display(&quot;Getting mirror of thread: &quot; + threadName);
<a name="1" id="anc1"></a><span class="line-modified">218             ThreadReference thread = threadByName(threadName);</span>
219 
220             display(&quot;Getting ReferenceType of thread: &quot; + threadName);
221             ReferenceType debuggeeThread = debuggee.classByName(debuggeeThreadName);
222 
223             // set second breakpoint to suspend checked thread at the right location before
224             // setting step request
225             BreakpointRequest bpRequest1 = setBreakpoint( thread,
226                                                          debuggeeThread,
227                                                          brakeMethods[testCase],
228                                                          checkedLines[testCase][0],
229                                                          &quot;&quot;);
230             bpRequest1.addCountFilter(1);
231             bpRequest1.enable();
232 
233             display(&quot;Wait for additional brakepoint event in &quot; + threadName);
234             bpEvent = (BreakpointEvent)waitForEvent(bpRequest1);
235 
236             // check location of breakpoint event
237             lineOfEvent = ((LocatableEvent)bpEvent).location().lineNumber();
238             if (lineOfEvent != checkedLines[testCase][0]) {
239                 complain(&quot;Wrong line number of additional brakepoint event for &quot; + threadName);
240                 complain(&quot;\texpected value : &quot; + checkedLines[testCase][0] + &quot;; got one : &quot; + lineOfEvent);
241                 break;
242             }
243 
244             display(&quot;Setting a step request in  thread: &quot; + thread);
245             try {
246                 stepRequest = eventRManager.createStepRequest ( thread,
247                                                                 StepRequest.STEP_LINE,
248                                                                 StepRequest.STEP_OUT );
249                 stepRequest.putProperty(&quot;number&quot;, property);
250             } catch ( Exception e1 ) {
251                 complain(&quot;setStepRequest(): unexpected Exception while creating StepRequest: &quot; + e1);
252                 break;
253             }
254             break;
255         }
256         if (stepRequest == null) {
257             throw new Failure(&quot;setStepRequest(): StepRequest has not been set up.&quot;);
258         }
259         display(&quot;setStepRequest(): StepRequest has been set up.&quot;);
260         return stepRequest;
261     }
262 
263     private void checkStepEvent ( StepRequest stepRequest,
264                                   String threadName,
265                                   int testCase ) {
266         stepRequest.enable();
267 
268         display(&quot;waiting for first StepEvent in &quot; + threadName);
269         Event newEvent = waitForEvent(stepRequest);
270         display(&quot;got first StepEvent&quot;);
271 
272         display(&quot;CHECK1 for line location of first StepEvent.&quot;);
273         int lineOfEvent = ((LocatableEvent)newEvent).location().lineNumber();
274         if (lineOfEvent != checkedLines[testCase][1]) {
275             complain(&quot;CHECK1 for line location of first StepEvent FAILED for CASE # &quot; + testCase);
276             complain(&quot;\texpected value : &quot; + checkedLines[testCase][1] + &quot;; got one : &quot; + lineOfEvent);
277             exitCode = FAILED;
278         } else {
279             display(&quot;CHECK1 PASSED&quot;);
280         }
281 
282         display(&quot;waiting for second StepEvent in &quot; + threadName);
283         newEvent = waitForEvent(stepRequest);
284         display(&quot;got second StepEvent&quot;);
285 
286         display(&quot;CHECK2 for line location of second StepEvent.&quot;);
287         lineOfEvent = ((LocatableEvent)newEvent).location().lineNumber();
288         if (lineOfEvent != checkedLines[testCase][2]) {
289             complain(&quot;CHECK2 for line location of second StepEvent FAILED for CASE # &quot; + testCase);
290             complain(&quot;\texpected value : &quot; + checkedLines[testCase][2] + &quot;; got one : &quot; + lineOfEvent);
291             exitCode = FAILED;
292         } else {
293             display(&quot;CHECK2 PASSED&quot;);
294         }
295 
296         stepRequest.disable();
297         eventRManager.deleteEventRequest(stepRequest);
298         stepRequest = null;
299         display(&quot;request for StepEvent in &quot; + threadName + &quot; is deleted&quot;);
300     }
301 
302     //--------------------------------------------------------- immutable common methods
303 
304     void display(String msg) {
305         log.display(&quot;debugger &gt; &quot; + msg);
306     }
307 
308     void complain(String msg) {
309         log.complain(&quot;debugger FAILURE &gt; &quot; + msg);
310     }
311 
312    /**
313     * Sets up a breakpoint at given line number within a given method in a given class
314     * for a given thread.
315     *
316     * Returns a BreakpointRequest object in case of success, otherwise throws Failure.
317     */
318     private BreakpointRequest setBreakpoint ( ThreadReference thread,
319                                               ReferenceType testedClass,
320                                               String methodName,
321                                               int bpLine,
322                                               String property) {
323 
324         display(&quot;Setting a breakpoint in :&quot;);
325         display(&quot;  thread: &quot; + thread + &quot;; class: &quot; + testedClass +
326                 &quot;; method: &quot; + methodName + &quot;; line: &quot; + bpLine + &quot;; property: &quot; + property);
327 
328         List allLineLocations = null;
329         Location lineLocation = null;
330         BreakpointRequest breakpRequest = null;
331 
332         try {
333             Method  method  = (Method) testedClass.methodsByName(methodName).get(0);
334 
335             allLineLocations = method.allLineLocations();
336 
337             display(&quot;Getting location for breakpoint...&quot;);
338             Iterator locIterator = allLineLocations.iterator();
339             while (locIterator.hasNext()) {
340                 Location curLocation = (Location)locIterator.next();
341                 int curNumber = curLocation.lineNumber();
342                 if (curLocation.lineNumber() == bpLine) {
343                     lineLocation = curLocation;
344                     break;
345                 }
346             }
347             if (lineLocation == null) {
348                 throw new TestBug(&quot;Incorrect line number of methods&#39; location&quot;);
349             }
350 
351             try {
352                 breakpRequest = eventRManager.createBreakpointRequest(lineLocation);
353                 if (thread != null) {
354                     breakpRequest.addThreadFilter(thread);
355                 }
356                 breakpRequest.putProperty(&quot;number&quot;, property);
357             } catch ( Exception e1 ) {
358                 complain(&quot;setBreakpoint(): unexpected Exception while creating BreakpointRequest: &quot; + e1);
359                 breakpRequest = null;
360             }
361         } catch ( Exception e2 ) {
362             complain(&quot;setBreakpoint(): unexpected Exception while getting locations: &quot; + e2);
363             breakpRequest = null;
364         }
365 
366         if (breakpRequest == null) {
367             throw new Failure(&quot;setBreakpoint(): A breakpoint has not been set up.&quot;);
368         }
369 
370         display(&quot;setBreakpoint(): A breakpoint has been set up.&quot;);
371         return breakpRequest;
372     }
373 
374     private Event waitForEvent (EventRequest eventRequest) {
375         vm.resume();
376         Event resultEvent = null;
377         try {
378             eventSet = null;
379             eventIterator = null;
380             eventSet = vm.eventQueue().remove(waitTime);
381             if (eventSet == null) {
382                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
383             }
384             eventIterator = eventSet.eventIterator();
385             while (eventIterator.hasNext()) {
386                 Event curEvent = eventIterator.nextEvent();
387                 if (curEvent instanceof VMDisconnectEvent) {
388                     throw new Failure(&quot;Unexpected VMDisconnectEvent received.&quot;);
389                 } else {
390                     EventRequest evRequest = curEvent.request();
391                     if (evRequest != null &amp;&amp; evRequest.equals(eventRequest)) {
392                         display(&quot;Requested event received: &quot; + curEvent.toString() +
393                             &quot;; request property: &quot; + (String) curEvent.request().getProperty(&quot;number&quot;));
394                         resultEvent = curEvent;
395                         break;
396                     } else {
397                         throw new Failure(&quot;Unexpected event received: &quot; + curEvent.toString());
398                     }
399                 }
400             }
401         } catch (Exception e) {
402             throw new Failure(&quot;Unexpected exception while waiting for an event: &quot; + e);
403         }
404         return resultEvent;
405     }
406 
407     private Event waitForEvent () {
408         vm.resume();
409         Event resultEvent = null;
410         try {
411             eventSet = null;
412             eventIterator = null;
413             eventSet = vm.eventQueue().remove(waitTime);
414             if (eventSet == null) {
415                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
416             }
417             eventIterator = eventSet.eventIterator();
418             while (eventIterator.hasNext()) {
419                 resultEvent = eventIterator.nextEvent();
420                 if (resultEvent instanceof VMDisconnectEvent) {
421                     throw new Failure(&quot;Unexpected VMDisconnectEvent received.&quot;);
422                 }
423             }
424         } catch (Exception e) {
425             throw new Failure(&quot;Unexpected exception while waiting for an event: &quot; + e);
426         }
427         return resultEvent;
428     }
429 
430     private void getEventSet() {
431         try {
432             eventSet = vm.eventQueue().remove(waitTime);
433             if (eventSet == null) {
434                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
435             }
436             eventIterator = eventSet.eventIterator();
437         } catch (Exception e) {
438             throw new Failure(&quot;getEventSet(): Unexpected exception while waiting for an event: &quot; + e);
439         }
440     }
441 
<a name="2" id="anc2"></a><span class="line-removed">442 </span>
<span class="line-removed">443     private ThreadReference threadByName(String name) throws Failure{</span>
<span class="line-removed">444         List all = vm.allThreads();</span>
<span class="line-removed">445         ListIterator li = all.listIterator();</span>
<span class="line-removed">446 </span>
<span class="line-removed">447         while (li.hasNext()) {</span>
<span class="line-removed">448             ThreadReference thread = (ThreadReference) li.next();</span>
<span class="line-removed">449             if (thread.name().equals(name))</span>
<span class="line-removed">450                 return thread;</span>
<span class="line-removed">451         }</span>
<span class="line-removed">452         throw new Failure(&quot;Thread with searching for name is not found: &quot; + name);</span>
<span class="line-removed">453     }</span>
<span class="line-removed">454 </span>
455     private ReferenceType waitForDebuggeeClassPrepared () {
456         display(&quot;Creating request for ClassPrepareEvent for debuggee.&quot;);
457         ClassPrepareRequest cpRequest = eventRManager.createClassPrepareRequest();
458         cpRequest.addClassFilter(debuggeeName);
459         cpRequest.addCountFilter(1);
460         cpRequest.enable();
461 
462         ClassPrepareEvent event = (ClassPrepareEvent) waitForEvent(cpRequest);
463         cpRequest.disable();
464 
465         if (!event.referenceType().name().equals(debuggeeName)) {
466            throw new Failure(&quot;Unexpected class name for ClassPrepareEvent : &quot; + debuggeeClass.name());
467         }
468         return event.referenceType();
469     }
470 
471     private int getInstruction () {
472         if (debuggeeClass == null) {
473             throw new Failure(&quot;getInstruction() :: debuggeeClass reference is null&quot;);
474         }
475         return ((IntegerValue) (debuggeeClass.getValue(debuggeeClass.fieldByName(&quot;instruction&quot;)))).value();
476     }
477 
478     private void setInstruction (String instructionField) {
479         if (debuggeeClass == null) {
480             throw new Failure(&quot;getInstruction() :: debuggeeClass reference is null&quot;);
481         }
482         Field instrField = debuggeeClass.fieldByName(&quot;instruction&quot;);
483         IntegerValue instrValue = (IntegerValue) (debuggeeClass.getValue(debuggeeClass.fieldByName(instructionField)));
484         try {
485             ((ClassType)debuggeeClass).setValue(instrField, instrValue );
486         } catch (InvalidTypeException e1) {
487             throw new Failure(&quot;Caught unexpected InvalidTypeException while setting value &#39;&quot; + instructionField + &quot;&#39; for instruction field&quot;);
488         } catch (ClassNotLoadedException e2) {
489             throw new Failure(&quot;Caught unexpected ClassNotLoadedException while setting value &#39;&quot; + instructionField + &quot;&#39; for instruction field&quot;);
490         }
491     }
492 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/FramePop/framepop002/framepop002.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../Breakpoint/breakpoint001/breakpoint001.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../GetThreadState/thrstat001/thrstat001.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/FramePop/framepop002/framepop002.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 45 
 46 typedef struct thr {
 47     jthread thread;
 48     item_t tos;
 49 } thr;
 50 
 51 static jvmtiEnv *jvmti = NULL;
 52 static jvmtiCapabilities caps;
 53 static jvmtiEventCallbacks callbacks;
 54 static jrawMonitorID event_lock;
 55 static jint result = PASSED;
 56 static jboolean printdump = JNI_FALSE;
 57 static jboolean watch_events = JNI_FALSE;
 58 
 59 static int pop_count = 0;
 60 static int push_count = 0;
 61 static int thr_count = 0;
 62 static int max_depth = 0;
 63 static thr threads[MAX_THREADS];
 64 



 65 static
 66 int isTestThread(jvmtiEnv *jvmti_env, jthread thr) {
 67     jvmtiError err;
 68     jvmtiThreadInfo inf;
 69     const char* TEST_THREAD_NAME_BASE = &quot;Test Thread&quot;;
 70 
 71     err = jvmti_env-&gt;GetThreadInfo(thr, &amp;inf);
 72     if (err != JVMTI_ERROR_NONE) {
 73          printf(&quot;(GetThreadInfo) unexpected error: %s (%d)\n&quot;, TranslateError(err), err);
 74          result = STATUS_FAILED;
 75          return 0;
 76     }
 77     return strncmp(inf.name, TEST_THREAD_NAME_BASE, strlen(TEST_THREAD_NAME_BASE)) == 0;
 78 }
 79 
 80 static
 81 void printInfo(jvmtiEnv *jvmti_env, jthread thr, jmethodID method, int depth) {
 82     jvmtiError err;
 83     jvmtiThreadInfo inf;
 84     char *clsig, *name, *sig, *generic;
</pre>
<hr />
<pre>
194         result = STATUS_FAILED;
195         return;
196     }
197 
198     new_item-&gt;next = threads[i].tos;
199     new_item-&gt;method = method;
200     new_item-&gt;depth = depth;
201     threads[i].tos = new_item;
202     push_count++;
203     max_depth = (max_depth &lt; depth) ? depth : max_depth;
204 }
205 
206 void JNICALL MethodEntry(jvmtiEnv *jvmti_env, JNIEnv *env,
207         jthread thr, jmethodID method) {
208     jvmtiError err;
209     jboolean isNative;
210     jint frameCount;
211 
212     if (watch_events == JNI_FALSE) return;
213 







214     err = jvmti_env-&gt;GetFrameCount(thr, &amp;frameCount);
215     if (err != JVMTI_ERROR_NONE) {
216         printf(&quot;(GetFrameCount#entry) unexpected error: %s (%d)\n&quot;,
217                TranslateError(err), err);
218         printInfo(jvmti_env, thr, method, frameCount);
219         result = STATUS_FAILED;

220         return;
221     }
222 
223     err = jvmti_env-&gt;IsMethodNative(method, &amp;isNative);
224     if (err != JVMTI_ERROR_NONE) {
225         printf(&quot;(IsMethodNative) unexpected error: %s (%d)\n&quot;,
226                TranslateError(err), err);
227         printInfo(jvmti_env, thr, method, frameCount);
228         result = STATUS_FAILED;
229     }
230 
231     if (isTestThread(jvmti_env, thr)) {
232         if (printdump == JNI_TRUE) {
233             printf(&quot;&gt;&gt;&gt; %sMethod entry\n&gt;&gt;&gt;&quot;,
234                    (isNative == JNI_TRUE) ? &quot;Native &quot; : &quot;&quot;);
235             printInfo(jvmti_env, thr, method, frameCount);
236         }
237         if (isNative == JNI_FALSE) {
238             err = jvmti_env-&gt;RawMonitorEnter(event_lock);
239             if (err != JVMTI_ERROR_NONE) {
</pre>
<hr />
<pre>
242                 printInfo(jvmti_env, thr, method, frameCount);
243                 result = STATUS_FAILED;
244             }
245             push((JNIEnv *)env, thr, method, frameCount);
246             err = jvmti_env-&gt;RawMonitorExit(event_lock);
247             if (err != JVMTI_ERROR_NONE) {
248                 printf(&quot;(RawMonitorExit) unexpected error: %s (%d)\n&quot;,
249                        TranslateError(err), err);
250                 printInfo(jvmti_env, thr, method, frameCount);
251                 result = STATUS_FAILED;
252             }
253             err = jvmti_env-&gt;NotifyFramePop(thr, 0);
254             if (err != JVMTI_ERROR_NONE) {
255                 printf(&quot;(NotifyFramePop) unexpected error: %s (%d)\n&quot;,
256                        TranslateError(err), err);
257                 printInfo(jvmti_env, thr, method, frameCount);
258                 result = STATUS_FAILED;
259             }
260         }
261     }



















262 }
263 
264 void JNICALL FramePop(jvmtiEnv *jvmti_env, JNIEnv *env,
265         jthread thr, jmethodID method, jboolean wasPopedByException) {
266     jvmtiError err;
267     jint frameCount;
268 






269     err = jvmti_env-&gt;GetFrameCount(thr, &amp;frameCount);
270     if (err != JVMTI_ERROR_NONE) {
271         printf(&quot;(GetFrameCount#entry) unexpected error: %s (%d)\n&quot;,
272                TranslateError(err), err);
273         printInfo(jvmti_env, thr, method, frameCount);
274         result = STATUS_FAILED;

275         return;
276     }
277 
278     if (isTestThread(jvmti_env, thr)) {
279         if (printdump == JNI_TRUE) {
280             printf(&quot;&gt;&gt;&gt; Frame Pop\n&gt;&gt;&gt;&quot;);
281             printInfo(jvmti_env, thr, method, frameCount);
282         }
283         err = jvmti_env-&gt;RawMonitorEnter(event_lock);
284         if (err != JVMTI_ERROR_NONE) {
285             printf(&quot;(RawMonitorEnter) unexpected error: %s (%d)\n&quot;,
286                    TranslateError(err), err);
287             printInfo(jvmti_env, thr, method, frameCount);
288             result = STATUS_FAILED;
289         }
290         pop(jvmti_env, (JNIEnv *)env, thr, method, frameCount);
291         err = jvmti_env-&gt;RawMonitorExit(event_lock);
292         if (err != JVMTI_ERROR_NONE) {
293             printf(&quot;(RawMonitorExit) unexpected error: %s (%d)\n&quot;,
294                    TranslateError(err), err);
295             printInfo(jvmti_env, thr, method, frameCount);
296             result = STATUS_FAILED;
297         }
298     }


299 }
300 
301 #ifdef STATIC_BUILD
302 JNIEXPORT jint JNICALL Agent_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {
303     return Agent_Initialize(jvm, options, reserved);
304 }
305 JNIEXPORT jint JNICALL Agent_OnAttach_framepop002(JavaVM *jvm, char *options, void *reserved) {
306     return Agent_Initialize(jvm, options, reserved);
307 }
308 JNIEXPORT jint JNI_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {
309     return JNI_VERSION_1_8;
310 }
311 #endif
312 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
313     jvmtiError err;
314     jint res;
315 
316     if (options != NULL &amp;&amp; strcmp(options, &quot;printdump&quot;) == 0) {
317         printdump = JNI_TRUE;
318     }
</pre>
<hr />
<pre>
338     }
339 
340     err = jvmti-&gt;AddCapabilities(&amp;caps);
341     if (err != JVMTI_ERROR_NONE) {
342         printf(&quot;(AddCapabilities) unexpected error: %s (%d)\n&quot;,
343                TranslateError(err), err);
344         return JNI_ERR;
345     }
346 
347     err = jvmti-&gt;GetCapabilities(&amp;caps);
348     if (err != JVMTI_ERROR_NONE) {
349         printf(&quot;(GetCapabilities) unexpected error: %s (%d)\n&quot;,
350                TranslateError(err), err);
351         return JNI_ERR;
352     }
353 
354     if (caps.can_generate_frame_pop_events &amp;&amp;
355             caps.can_generate_method_entry_events) {
356         callbacks.MethodEntry = &amp;MethodEntry;
357         callbacks.FramePop = &amp;FramePop;



358         err = jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));
359         if (err != JVMTI_ERROR_NONE) {
360             printf(&quot;(SetEventCallbacks) unexpected error: %s (%d)\n&quot;,
361                    TranslateError(err), err);
362             return JNI_ERR;
363         }









364     } else {
365         printf(&quot;Warning: FramePop or MethodEntry event is not implemented\n&quot;);
366     }
367 
368     return JNI_OK;
369 }
370 
371 JNIEXPORT void JNICALL Java_nsk_jvmti_FramePop_framepop002_getReady(JNIEnv *env, jclass cls) {
372     jvmtiError err;
373 
374     if (!caps.can_generate_frame_pop_events ||
375             !caps.can_generate_method_entry_events) {
376         return ;
377     }
378 
379     err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE,
380          JVMTI_EVENT_METHOD_ENTRY, NULL);
381     if (err != JVMTI_ERROR_NONE) {
382         printf(&quot;Failed to enable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\n&quot;,
383                TranslateError(err), err);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 45 
 46 typedef struct thr {
 47     jthread thread;
 48     item_t tos;
 49 } thr;
 50 
 51 static jvmtiEnv *jvmti = NULL;
 52 static jvmtiCapabilities caps;
 53 static jvmtiEventCallbacks callbacks;
 54 static jrawMonitorID event_lock;
 55 static jint result = PASSED;
 56 static jboolean printdump = JNI_FALSE;
 57 static jboolean watch_events = JNI_FALSE;
 58 
 59 static int pop_count = 0;
 60 static int push_count = 0;
 61 static int thr_count = 0;
 62 static int max_depth = 0;
 63 static thr threads[MAX_THREADS];
 64 
<span class="line-added"> 65 static volatile int callbacksEnabled = NSK_FALSE;</span>
<span class="line-added"> 66 static jrawMonitorID agent_lock;</span>
<span class="line-added"> 67 </span>
 68 static
 69 int isTestThread(jvmtiEnv *jvmti_env, jthread thr) {
 70     jvmtiError err;
 71     jvmtiThreadInfo inf;
 72     const char* TEST_THREAD_NAME_BASE = &quot;Test Thread&quot;;
 73 
 74     err = jvmti_env-&gt;GetThreadInfo(thr, &amp;inf);
 75     if (err != JVMTI_ERROR_NONE) {
 76          printf(&quot;(GetThreadInfo) unexpected error: %s (%d)\n&quot;, TranslateError(err), err);
 77          result = STATUS_FAILED;
 78          return 0;
 79     }
 80     return strncmp(inf.name, TEST_THREAD_NAME_BASE, strlen(TEST_THREAD_NAME_BASE)) == 0;
 81 }
 82 
 83 static
 84 void printInfo(jvmtiEnv *jvmti_env, jthread thr, jmethodID method, int depth) {
 85     jvmtiError err;
 86     jvmtiThreadInfo inf;
 87     char *clsig, *name, *sig, *generic;
</pre>
<hr />
<pre>
197         result = STATUS_FAILED;
198         return;
199     }
200 
201     new_item-&gt;next = threads[i].tos;
202     new_item-&gt;method = method;
203     new_item-&gt;depth = depth;
204     threads[i].tos = new_item;
205     push_count++;
206     max_depth = (max_depth &lt; depth) ? depth : max_depth;
207 }
208 
209 void JNICALL MethodEntry(jvmtiEnv *jvmti_env, JNIEnv *env,
210         jthread thr, jmethodID method) {
211     jvmtiError err;
212     jboolean isNative;
213     jint frameCount;
214 
215     if (watch_events == JNI_FALSE) return;
216 
<span class="line-added">217     jvmti-&gt;RawMonitorEnter(agent_lock);</span>
<span class="line-added">218 </span>
<span class="line-added">219     if (!callbacksEnabled) {</span>
<span class="line-added">220         jvmti-&gt;RawMonitorExit(agent_lock);</span>
<span class="line-added">221         return;</span>
<span class="line-added">222     }</span>
<span class="line-added">223 </span>
224     err = jvmti_env-&gt;GetFrameCount(thr, &amp;frameCount);
225     if (err != JVMTI_ERROR_NONE) {
226         printf(&quot;(GetFrameCount#entry) unexpected error: %s (%d)\n&quot;,
227                TranslateError(err), err);
228         printInfo(jvmti_env, thr, method, frameCount);
229         result = STATUS_FAILED;
<span class="line-added">230         jvmti-&gt;RawMonitorExit(agent_lock);</span>
231         return;
232     }
233 
234     err = jvmti_env-&gt;IsMethodNative(method, &amp;isNative);
235     if (err != JVMTI_ERROR_NONE) {
236         printf(&quot;(IsMethodNative) unexpected error: %s (%d)\n&quot;,
237                TranslateError(err), err);
238         printInfo(jvmti_env, thr, method, frameCount);
239         result = STATUS_FAILED;
240     }
241 
242     if (isTestThread(jvmti_env, thr)) {
243         if (printdump == JNI_TRUE) {
244             printf(&quot;&gt;&gt;&gt; %sMethod entry\n&gt;&gt;&gt;&quot;,
245                    (isNative == JNI_TRUE) ? &quot;Native &quot; : &quot;&quot;);
246             printInfo(jvmti_env, thr, method, frameCount);
247         }
248         if (isNative == JNI_FALSE) {
249             err = jvmti_env-&gt;RawMonitorEnter(event_lock);
250             if (err != JVMTI_ERROR_NONE) {
</pre>
<hr />
<pre>
253                 printInfo(jvmti_env, thr, method, frameCount);
254                 result = STATUS_FAILED;
255             }
256             push((JNIEnv *)env, thr, method, frameCount);
257             err = jvmti_env-&gt;RawMonitorExit(event_lock);
258             if (err != JVMTI_ERROR_NONE) {
259                 printf(&quot;(RawMonitorExit) unexpected error: %s (%d)\n&quot;,
260                        TranslateError(err), err);
261                 printInfo(jvmti_env, thr, method, frameCount);
262                 result = STATUS_FAILED;
263             }
264             err = jvmti_env-&gt;NotifyFramePop(thr, 0);
265             if (err != JVMTI_ERROR_NONE) {
266                 printf(&quot;(NotifyFramePop) unexpected error: %s (%d)\n&quot;,
267                        TranslateError(err), err);
268                 printInfo(jvmti_env, thr, method, frameCount);
269                 result = STATUS_FAILED;
270             }
271         }
272     }
<span class="line-added">273 </span>
<span class="line-added">274     jvmti-&gt;RawMonitorExit(agent_lock);</span>
<span class="line-added">275 }</span>
<span class="line-added">276 </span>
<span class="line-added">277 void JNICALL VMStart(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {</span>
<span class="line-added">278     jvmti-&gt;RawMonitorEnter(agent_lock);</span>
<span class="line-added">279 </span>
<span class="line-added">280     callbacksEnabled = NSK_TRUE;</span>
<span class="line-added">281 </span>
<span class="line-added">282     jvmti-&gt;RawMonitorExit(agent_lock);</span>
<span class="line-added">283 }</span>
<span class="line-added">284 </span>
<span class="line-added">285 </span>
<span class="line-added">286 void JNICALL VMDeath(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {</span>
<span class="line-added">287     jvmti-&gt;RawMonitorEnter(agent_lock);</span>
<span class="line-added">288 </span>
<span class="line-added">289     callbacksEnabled = NSK_FALSE;</span>
<span class="line-added">290 </span>
<span class="line-added">291     jvmti-&gt;RawMonitorExit(agent_lock);</span>
292 }
293 
294 void JNICALL FramePop(jvmtiEnv *jvmti_env, JNIEnv *env,
295         jthread thr, jmethodID method, jboolean wasPopedByException) {
296     jvmtiError err;
297     jint frameCount;
298 
<span class="line-added">299     jvmti-&gt;RawMonitorEnter(agent_lock);</span>
<span class="line-added">300 </span>
<span class="line-added">301     if (!callbacksEnabled) {</span>
<span class="line-added">302         jvmti-&gt;RawMonitorExit(agent_lock);</span>
<span class="line-added">303         return;</span>
<span class="line-added">304     }</span>
305     err = jvmti_env-&gt;GetFrameCount(thr, &amp;frameCount);
306     if (err != JVMTI_ERROR_NONE) {
307         printf(&quot;(GetFrameCount#entry) unexpected error: %s (%d)\n&quot;,
308                TranslateError(err), err);
309         printInfo(jvmti_env, thr, method, frameCount);
310         result = STATUS_FAILED;
<span class="line-added">311         jvmti-&gt;RawMonitorExit(agent_lock);</span>
312         return;
313     }
314 
315     if (isTestThread(jvmti_env, thr)) {
316         if (printdump == JNI_TRUE) {
317             printf(&quot;&gt;&gt;&gt; Frame Pop\n&gt;&gt;&gt;&quot;);
318             printInfo(jvmti_env, thr, method, frameCount);
319         }
320         err = jvmti_env-&gt;RawMonitorEnter(event_lock);
321         if (err != JVMTI_ERROR_NONE) {
322             printf(&quot;(RawMonitorEnter) unexpected error: %s (%d)\n&quot;,
323                    TranslateError(err), err);
324             printInfo(jvmti_env, thr, method, frameCount);
325             result = STATUS_FAILED;
326         }
327         pop(jvmti_env, (JNIEnv *)env, thr, method, frameCount);
328         err = jvmti_env-&gt;RawMonitorExit(event_lock);
329         if (err != JVMTI_ERROR_NONE) {
330             printf(&quot;(RawMonitorExit) unexpected error: %s (%d)\n&quot;,
331                    TranslateError(err), err);
332             printInfo(jvmti_env, thr, method, frameCount);
333             result = STATUS_FAILED;
334         }
335     }
<span class="line-added">336 </span>
<span class="line-added">337     jvmti-&gt;RawMonitorExit(agent_lock);</span>
338 }
339 
340 #ifdef STATIC_BUILD
341 JNIEXPORT jint JNICALL Agent_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {
342     return Agent_Initialize(jvm, options, reserved);
343 }
344 JNIEXPORT jint JNICALL Agent_OnAttach_framepop002(JavaVM *jvm, char *options, void *reserved) {
345     return Agent_Initialize(jvm, options, reserved);
346 }
347 JNIEXPORT jint JNI_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {
348     return JNI_VERSION_1_8;
349 }
350 #endif
351 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
352     jvmtiError err;
353     jint res;
354 
355     if (options != NULL &amp;&amp; strcmp(options, &quot;printdump&quot;) == 0) {
356         printdump = JNI_TRUE;
357     }
</pre>
<hr />
<pre>
377     }
378 
379     err = jvmti-&gt;AddCapabilities(&amp;caps);
380     if (err != JVMTI_ERROR_NONE) {
381         printf(&quot;(AddCapabilities) unexpected error: %s (%d)\n&quot;,
382                TranslateError(err), err);
383         return JNI_ERR;
384     }
385 
386     err = jvmti-&gt;GetCapabilities(&amp;caps);
387     if (err != JVMTI_ERROR_NONE) {
388         printf(&quot;(GetCapabilities) unexpected error: %s (%d)\n&quot;,
389                TranslateError(err), err);
390         return JNI_ERR;
391     }
392 
393     if (caps.can_generate_frame_pop_events &amp;&amp;
394             caps.can_generate_method_entry_events) {
395         callbacks.MethodEntry = &amp;MethodEntry;
396         callbacks.FramePop = &amp;FramePop;
<span class="line-added">397         callbacks.VMStart = &amp;VMStart;</span>
<span class="line-added">398         callbacks.VMDeath = &amp;VMDeath;</span>
<span class="line-added">399 </span>
400         err = jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));
401         if (err != JVMTI_ERROR_NONE) {
402             printf(&quot;(SetEventCallbacks) unexpected error: %s (%d)\n&quot;,
403                    TranslateError(err), err);
404             return JNI_ERR;
405         }
<span class="line-added">406         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL)))</span>
<span class="line-added">407             return JNI_ERR;</span>
<span class="line-added">408         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))</span>
<span class="line-added">409             return JNI_ERR;</span>
<span class="line-added">410 </span>
<span class="line-added">411         if (jvmti-&gt;CreateRawMonitor(&quot;agent_lock&quot;, &amp;agent_lock) != JVMTI_ERROR_NONE) {</span>
<span class="line-added">412             return JNI_ERR;</span>
<span class="line-added">413         }</span>
<span class="line-added">414 </span>
415     } else {
416         printf(&quot;Warning: FramePop or MethodEntry event is not implemented\n&quot;);
417     }
418 
419     return JNI_OK;
420 }
421 
422 JNIEXPORT void JNICALL Java_nsk_jvmti_FramePop_framepop002_getReady(JNIEnv *env, jclass cls) {
423     jvmtiError err;
424 
425     if (!caps.can_generate_frame_pop_events ||
426             !caps.can_generate_method_entry_events) {
427         return ;
428     }
429 
430     err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE,
431          JVMTI_EVENT_METHOD_ENTRY, NULL);
432     if (err != JVMTI_ERROR_NONE) {
433         printf(&quot;Failed to enable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\n&quot;,
434                TranslateError(err), err);
</pre>
</td>
</tr>
</table>
<center><a href="../../Breakpoint/breakpoint001/breakpoint001.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../GetThreadState/thrstat001/thrstat001.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
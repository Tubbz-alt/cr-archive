<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t001/em02t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
 27 #include &quot;ExceptionCheckingJniEnv.hpp&quot;
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 #include &quot;JVMTITools.h&quot;
 31 
 32 extern &quot;C&quot; {
 33 
 34 /* ============================================================================= */
 35 
 36 /* scaffold objects */
 37 static JNIEnv* jni = NULL;
 38 static jvmtiEnv *jvmti = NULL;
 39 static jlong timeout = 0;
 40 static jrawMonitorID syncLock = NULL;
 41 
 42 /* constant names */
 43 #define DEBUGEE_CLASS_NAME      &quot;nsk/jvmti/scenarios/events/EM02/em02t001&quot;
 44 #define START_FIELD_NAME        &quot;startingMonitor&quot;
 45 #define END_FIELD_NAME          &quot;endingMonitor&quot;
 46 #define MAIN_THREAD_NAME        &quot;main&quot;
 47 #define THREAD_FIELD_NAME       &quot;debuggeeThread&quot;
 48 #define OBJECT_FIELD_SIG        &quot;Ljava/lang/Object;&quot;
 49 #define THREAD_FIELD_SIG        &quot;Ljava/lang/Thread;&quot;
 50 
 51 static jthread mainThread = NULL;
 52 static jthread debuggeeThread = NULL;
 53 static jobject startObject = NULL;
 54 static jobject endObject = NULL;
 55 
 56 #define STEP_AMOUNT 3
 57 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 58 static int eventCount[JVMTI_EVENT_COUNT];
 59 static int newEventCount[JVMTI_EVENT_COUNT];
 60 
 61 /* ============================================================================= */
 62 
 63 static jthread
 64 findThread(const char *threadName) {
 65     jvmtiThreadInfo info;
 66     jthread *threads = NULL;
 67     jint threads_count = 0;
 68     jthread returnValue = NULL;
 69     int i;
 70 
 71     /* get all live threads */
 72     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetAllThreads(&amp;threads_count, &amp;threads)))
 73         return NULL;
 74 
 75     if (!NSK_VERIFY(threads != NULL))
 76         return NULL;
 77 
 78     /* find tested thread */
 79     for (i = 0; i &lt; threads_count; i++) {
 80         if (!NSK_VERIFY(threads[i] != NULL))
 81             break;
 82 
 83         /* get thread information */
 84         if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetThreadInfo(threads[i], &amp;info)))
 85             break;
 86 
 87         /* find by name */
 88         if (info.name != NULL &amp;&amp; (strcmp(info.name, threadName) == 0)) {
 89             returnValue = threads[i];
 90         }
 91     }
 92 
 93     /* deallocate threads list */
 94     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)threads)))
 95         return NULL;
 96 
 97     return returnValue;
 98 }
 99 
100 /* ============================================================================= */
101 
102 static jobject
103 getStaticObjField(const char* className, const char* objFieldName,
104                     const char* signature) {
105 
106     ExceptionCheckingJniEnvPtr ec_jni(jni);
107     jfieldID fieldID;
108     jclass klass = NULL;
109 
110     klass = ec_jni-&gt;FindClass(className, TRACE_JNI_CALL);
111     fieldID = ec_jni-&gt;GetStaticFieldID(klass, objFieldName, signature, TRACE_JNI_CALL);
112     return ec_jni-&gt;GetStaticObjectField(klass, fieldID, TRACE_JNI_CALL);
113 }
114 
115 /* ============================================================================= */
116 
117 static bool prepare() {
118 
119     ExceptionCheckingJniEnvPtr ec_jni(jni);
120     mainThread = findThread(MAIN_THREAD_NAME);
121     if (!NSK_VERIFY(mainThread != NULL)) {
122         NSK_COMPLAIN1(&quot;&lt;%s&gt; thread not found\n&quot;, MAIN_THREAD_NAME);
123         return false;
124     }
125 
126     /* make thread accessable for a long time */
127     mainThread = ec_jni-&gt;NewGlobalRef(mainThread, TRACE_JNI_CALL);
128     startObject = getStaticObjField(DEBUGEE_CLASS_NAME, START_FIELD_NAME, OBJECT_FIELD_SIG);
129     if (!NSK_VERIFY(startObject != NULL))
130         return false;
131 
132     /*make object accessable for a long time*/
133     startObject = ec_jni-&gt;NewGlobalRef(startObject, TRACE_JNI_CALL);
134 
135     endObject = getStaticObjField(DEBUGEE_CLASS_NAME, END_FIELD_NAME, OBJECT_FIELD_SIG);
136     if (!NSK_VERIFY(endObject != NULL))
137         return false;
138 
139     /*make object accessable for a long time*/
140     endObject = ec_jni-&gt;NewGlobalRef(endObject, TRACE_JNI_CALL);
141 
142     debuggeeThread = (jthread) getStaticObjField(DEBUGEE_CLASS_NAME,
143                                                  THREAD_FIELD_NAME,
144                                                  THREAD_FIELD_SIG);
145     if (!NSK_VERIFY(debuggeeThread != NULL))
146         return false;
147 
148     /* make thread accessable for a long time */
149     debuggeeThread = ec_jni-&gt;NewGlobalRef(debuggeeThread, TRACE_JNI_CALL);
150     return true;
151 }
152 
153 /* ============================================================================= */
154 
155 static bool clean() {
156 
157     ExceptionCheckingJniEnvPtr ec_jni(jni);
158     /* disable MonitorContendedEnter event */
159     if (!NSK_JVMTI_VERIFY(
160             jvmti-&gt;SetEventNotificationMode(
161                 JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)))
162         nsk_jvmti_setFailStatus();
163 
164     /* dispose global references */
165     ec_jni-&gt;DeleteGlobalRef(startObject, TRACE_JNI_CALL);
166     ec_jni-&gt;DeleteGlobalRef(endObject, TRACE_JNI_CALL);
167     ec_jni-&gt;DeleteGlobalRef(debuggeeThread, TRACE_JNI_CALL);
168     ec_jni-&gt;DeleteGlobalRef(mainThread, TRACE_JNI_CALL);
169 
170     startObject = NULL;
171     endObject = NULL;
172     debuggeeThread = NULL;
173     mainThread = NULL;
174 
175     return true;
176 }
177 
178 /* ========================================================================== */
179 
180 static void
181 showEventStatistics(int step /*int *currentCounts*/) {
182     int i;
183     const char* str;
184     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
185 
186     NSK_DISPLAY0(&quot;\n&quot;);
187     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
188     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
189     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
190         if (currentCounts[i] &gt; 0) {
191             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
192             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
193         }
194     }
195 }
196 
197 /* ========================================================================== */
198 
199 /* get thread information */
200 static void
201 showThreadInfo(jthread thread) {
202     jvmtiThreadInfo info;
203     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetThreadInfo(thread, &amp;info)))
204         return;
205 
206     NSK_DISPLAY2(&quot;\tthread (%s): %p\n&quot;, info.name, thread);
207 }
208 
209 /* ============================================================================= */
210 
211 static void
212 changeCount(jvmtiEvent event, int *currentCounts) {
213 
214     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
215         nsk_jvmti_setFailStatus();
216 
217     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
218 
219     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
220         nsk_jvmti_setFailStatus();
221 
222 }
223 
224 /* ============================================================================= */
225 
226 bool checkEvents(int step) {
227     int i;
228     jvmtiEvent curr;
229     bool result = true;
230     int *currentCounts;
231     int isExpected = 0;
232 
233     switch (step) {
234         case 1:
235             currentCounts = &amp;eventCount[0];
236             break;
237 
238         case 2:
239         case 3:
240             currentCounts = &amp;newEventCount[0];
241             break;
242 
243         default:
244             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
245             return false;
246     }
247 
248     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
249 
250         curr = (jvmtiEvent)(i + JVMTI_MIN_EVENT_TYPE_VAL);
251 
252         switch (step) {
253             case 1:
254                 isExpected = ((curr == JVMTI_EVENT_MONITOR_CONTENDED_ENTER)
255                                 || (curr == JVMTI_EVENT_MONITOR_CONTENDED_ENTERED)
256                                 || (curr == JVMTI_EVENT_MONITOR_WAIT)
257                                 || (curr == JVMTI_EVENT_MONITOR_WAITED)
258                                 || (curr == JVMTI_EVENT_VM_INIT));
259                 break;
260 
261             case 2:
262                 isExpected = ((curr == JVMTI_EVENT_MONITOR_CONTENDED_ENTER)
263                                 || (curr == JVMTI_EVENT_MONITOR_CONTENDED_ENTERED)
264                                 || (curr == JVMTI_EVENT_MONITOR_WAIT)
265                                 || (curr == JVMTI_EVENT_MONITOR_WAITED));
266                 break;
267 
268             case 3:
269                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
270                 break;
271         }
272 
273         if (isExpected) {
274             if (currentCounts[i] != 1) {
275                     nsk_jvmti_setFailStatus();
276                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value is 1\n&quot;,
277                                         currentCounts[i],
278                                         TranslateEvent(curr));
279                 result = false;
280             }
281         } else {
282             if (currentCounts[i] &gt; 0) {
283                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
284                                     TranslateEvent(curr),
285                                     currentCounts[i]);
286                 result = false;
287             }
288         }
289     }
290 
291     return result;
292 }
293 
294 /* ============================================================================= */
295 
296 /* callbacks */
297 JNIEXPORT void JNICALL
298 cbVMInit(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread) {
299     changeCount(JVMTI_EVENT_VM_INIT, &amp;eventCount[0]);
300 }
301 
302 JNIEXPORT void JNICALL
303 cbVMDeath(jvmtiEnv* jvmti, JNIEnv* jni_env) {
304     changeCount(JVMTI_EVENT_VM_DEATH, &amp;newEventCount[0]);
305     showEventStatistics(STEP_AMOUNT);
306     if (!checkEvents(STEP_AMOUNT)) {
307         nsk_jvmti_setFailStatus();
308     }
309 
310     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock)))
311         nsk_jvmti_setFailStatus();
312 
313 }
314 
315 void JNICALL
316 cbException(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
317                 jmethodID method, jlocation location, jobject exception,
318                 jmethodID catch_method, jlocation catch_location) {
319     changeCount(JVMTI_EVENT_EXCEPTION, &amp;eventCount[0]);
320 }
321 
322 void JNICALL
323 cbExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
324                 jmethodID method, jlocation location, jobject exception) {
325     changeCount(JVMTI_EVENT_EXCEPTION_CATCH, &amp;eventCount[0]);
326 }
327 
328 void JNICALL
329 cbSingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
330                 jmethodID method, jlocation location) {
331     changeCount(JVMTI_EVENT_SINGLE_STEP, &amp;eventCount[0]);
332 }
333 
334 void JNICALL
335 cbFramePop(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
336                 jmethodID method, jboolean was_popped_by_exception) {
337     changeCount(JVMTI_EVENT_FRAME_POP, &amp;eventCount[0]);
338 }
339 
340 void JNICALL
341 cbBreakpoint(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
342                 jmethodID method, jlocation location) {
343     changeCount(JVMTI_EVENT_BREAKPOINT, &amp;eventCount[0]);
344 }
345 
346 void JNICALL
347 cbFieldAccess(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
348                 jmethodID method, jlocation location, jclass field_klass,
349                 jobject object, jfieldID field) {
350     changeCount(JVMTI_EVENT_FIELD_ACCESS, &amp;eventCount[0]);
351 }
352 
353 void JNICALL
354 cbFieldModification(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
355                 jmethodID method, jlocation location, jclass field_klass,
356                 jobject object, jfieldID field, char signature_type,
357                 jvalue new_value) {
358     changeCount(JVMTI_EVENT_FIELD_MODIFICATION, &amp;eventCount[0]);
359 }
360 
361 void JNICALL
362 cbMethodEntry(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
363                 jmethodID method) {
364     changeCount(JVMTI_EVENT_METHOD_ENTRY, &amp;eventCount[0]);
365 }
366 
367 void JNICALL
368 cbMethodExit(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
369                 jmethodID method, jboolean was_popped_by_exception,
370                 jvalue return_value) {
371     changeCount(JVMTI_EVENT_METHOD_EXIT, &amp;eventCount[0]);
372 }
373 
374 void JNICALL
375 cbNativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env,jthread thread,
376                 jmethodID method, void* address, void** new_address_ptr) {
377     changeCount(JVMTI_EVENT_NATIVE_METHOD_BIND, &amp;eventCount[0]);
378 }
379 
380 void JNICALL
381 cbCompiledMethodLoad(jvmtiEnv *jvmti_env, jmethodID method, jint code_size,
382                 const void* code_addr, jint map_length,
383                 const jvmtiAddrLocationMap* map, const void* compile_info) {
384     changeCount(JVMTI_EVENT_COMPILED_METHOD_LOAD, &amp;eventCount[0]);
385 }
386 
387 void JNICALL
388 cbCompiledMethodUnload(jvmtiEnv *jvmti_env, jmethodID method,
389                 const void* code_addr) {
390     changeCount(JVMTI_EVENT_COMPILED_METHOD_UNLOAD, &amp;eventCount[0]);
391 }
392 
393 void
394 handlerMC1(jvmtiEvent event, jvmtiEnv* jvmti, JNIEnv* jni_env,
395                             jthread thread, jobject object,
396                             jthread expectedThread, jobject expectedObject) {
397     ExceptionCheckingJniEnvPtr ec_jni(jni_env);
398 
399     if (expectedThread == NULL || expectedObject == NULL)
400         return;
401 
402     /* check if event is for tested thread and for tested object */
403     if (ec_jni-&gt;IsSameObject(expectedThread, thread, TRACE_JNI_CALL) &amp;&amp;
404             ec_jni-&gt;IsSameObject(expectedObject, object, TRACE_JNI_CALL)) {
405 
406         NSK_DISPLAY1(&quot;---&gt;%-40s is received\n&quot;, TranslateEvent(event));
407 
408         showThreadInfo(thread);
409         if (ec_jni-&gt;IsSameObject(expectedObject, endObject, TRACE_JNI_CALL))
410             NSK_DISPLAY0(&quot;\tobject: &#39;endingMonitor&#39;\n&quot;);
411         else
412             NSK_DISPLAY0(&quot;\tobject: &#39;startingMonitor&#39;\n&quot;);
413 
414         changeCount(event, &amp;eventCount[0]);
415     }
416 }
417 
418 void JNICALL
419 cbMonitorWait(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
420                     jobject object, jlong tout) {
421 
422     handlerMC1(JVMTI_EVENT_MONITOR_WAIT,
423                                 jvmti, jni_env,
424                                 thread, object,
425                                 mainThread, startObject);
426 }
427 
428 void JNICALL
429 cbMonitorWaited(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
430                     jobject object, jboolean timed_out) {
431 
432     handlerMC1(JVMTI_EVENT_MONITOR_WAITED,
433                                 jvmti, jni_env,
434                                 thread, object,
435                                 mainThread, startObject);
436 }
437 
438 JNIEXPORT void JNICALL
439 cbMonitorContendedEnter(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread,
440                             jobject object) {
441 
442     handlerMC1(JVMTI_EVENT_MONITOR_CONTENDED_ENTER,
443                                 jvmti, jni_env,
444                                 thread, object,
445                                 debuggeeThread, endObject);
446 }
447 
448 void JNICALL
449 cbMonitorContendedEntered(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
450                             jobject object) {
451 
452     handlerMC1(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED,
453                                 jvmti_env, jni_env,
454                                 thread, object,
455                                 debuggeeThread, endObject);
456 }
457 
458 void JNICALL
459 cbGarbageCollectionStart(jvmtiEnv *jvmti_env) {
460     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_START, &amp;eventCount[0]);
461 }
462 
463 void JNICALL
464 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
465     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
466 }
467 
468 void JNICALL
469 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
470     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
471 }
472 
473 void JNICALL
474 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
475                     jobject object, jclass object_klass, jlong size) {
476 
477     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
478 }
479 
480 void
481 handlerMC2(jvmtiEvent event, jvmtiEnv* jvmti, JNIEnv* jni_env,
482                             jthread thread, jobject object,
483                             jthread expectedThread, jobject expectedObject) {
484     ExceptionCheckingJniEnvPtr ec_jni(jni_env);
485 
486     if (expectedThread == NULL || expectedObject == NULL)
487         return;
488 
489     /* check if event is for tested thread and for tested object */
490     if (ec_jni-&gt;IsSameObject(expectedThread, thread, TRACE_JNI_CALL) &amp;&amp;
491             ec_jni-&gt;IsSameObject(expectedObject, object, TRACE_JNI_CALL)) {
492 
493         NSK_DISPLAY1(&quot;---&gt;%-40s is received (new callbacks)\n&quot;, TranslateEvent(event));
494 
495         showThreadInfo(thread);
496         if (ec_jni-&gt;IsSameObject(expectedObject, endObject, TRACE_JNI_CALL))
497             NSK_DISPLAY0(&quot;\tobject: &#39;endingMonitor&#39;\n&quot;);
498         else
499             NSK_DISPLAY0(&quot;\tobject: &#39;startingMonitor&#39;\n&quot;);
500 
501 
502         changeCount(event, &amp;newEventCount[0]);
503     }
504 }
505 
506 void JNICALL
507 cbNewMonitorWait(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
508                     jobject object, jlong tout) {
509 
510     handlerMC2(JVMTI_EVENT_MONITOR_WAIT,
511                                 jvmti_env, jni_env,
512                                 thread, object,
513                                 mainThread, startObject);
514 }
515 
516 void JNICALL
517 cbNewMonitorWaited(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
518                     jobject object, jboolean timed_out) {
519 
520     handlerMC2(JVMTI_EVENT_MONITOR_WAITED,
521                                 jvmti, jni_env,
522                                 thread, object,
523                                 mainThread, startObject);
524 }
525 
526 void JNICALL
527 cbNewMonitorContendedEntered(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
528                             jobject object) {
529 
530     handlerMC2(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED,
531                                 jvmti, jni_env,
532                                 thread, object,
533                                 debuggeeThread, endObject);
534 }
535 
536 JNIEXPORT void JNICALL
537 cbNewMonitorContendedEnter(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread,
538                             jobject object) {
539 
540     handlerMC2(JVMTI_EVENT_MONITOR_CONTENDED_ENTER,
541                                 jvmti, jni_env,
542                                 thread, object,
543                                 debuggeeThread, endObject);
544 }
545 
546 /* ============================================================================= */
547 
548 static bool enableEvent(jvmtiEvent event) {
549 
550     if (nsk_jvmti_isOptionalEvent(event)
551             &amp;&amp; (event != JVMTI_EVENT_MONITOR_CONTENDED_ENTER)
552             &amp;&amp; (event != JVMTI_EVENT_MONITOR_CONTENDED_ENTERED)
553             &amp;&amp; (event != JVMTI_EVENT_MONITOR_WAIT)
554             &amp;&amp; (event != JVMTI_EVENT_MONITOR_WAITED)) {
555         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
556                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
557             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
558                 TranslateEvent(event));
559             return false;
560         }
561     } else {
562         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
563             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
564                 TranslateEvent(event));
565             return false;
566         }
567     }
568 
569     return true;
570 }
571 
572 static bool enableEventList() {
573     int i;
574     bool result = true;
575 
576     NSK_DISPLAY0(&quot;Enable events\n&quot;);
577 
578     result = enableEvent(JVMTI_EVENT_VM_INIT);
579 
580     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
581 
582     /* enabling optional events */
583     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
584         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
585 
586         if (nsk_jvmti_isOptionalEvent(event))
587             result = result &amp;&amp; enableEvent(event);
588     }
589 
590     if (!result) {
591         nsk_jvmti_setFailStatus();
592         return false;
593     }
594 
595     return true;
596 }
597 
598 /* ============================================================================= */
599 
600 static bool setCallBacks(int step) {
601 
602     int i;
603 
604     jvmtiEventCallbacks eventCallbacks;
605     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
606 
607     NSK_DISPLAY0(&quot;\n&quot;);
608     NSK_DISPLAY1(&quot;===============step %d===============\n&quot;, step);
609     NSK_DISPLAY0(&quot;\n&quot;);
610     switch (step) {
611         case 1:
612             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
613                 eventCount[i] = 0;
614             }
615 
616             eventCallbacks.VMInit                    = cbVMInit;
617             eventCallbacks.Exception                 = cbException;
618             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
619             eventCallbacks.SingleStep                = cbSingleStep;
620             eventCallbacks.FramePop                  = cbFramePop;
621             eventCallbacks.Breakpoint                = cbBreakpoint;
622             eventCallbacks.FieldAccess               = cbFieldAccess;
623             eventCallbacks.FieldModification         = cbFieldModification;
624             eventCallbacks.MethodEntry               = cbMethodEntry;
625             eventCallbacks.MethodExit                = cbMethodExit;
626             eventCallbacks.NativeMethodBind          = cbNativeMethodBind;
627             eventCallbacks.CompiledMethodLoad        = cbCompiledMethodLoad;
628             eventCallbacks.CompiledMethodUnload      = cbCompiledMethodUnload;
629             eventCallbacks.MonitorWait               = cbMonitorWait;
630             eventCallbacks.MonitorWaited             = cbMonitorWaited;
631             eventCallbacks.MonitorContendedEnter     = cbMonitorContendedEnter;
632             eventCallbacks.MonitorContendedEntered   = cbMonitorContendedEntered;
633             eventCallbacks.GarbageCollectionStart    = cbGarbageCollectionStart;
634             eventCallbacks.GarbageCollectionFinish   = cbGarbageCollectionFinish;
635             eventCallbacks.ObjectFree                = cbObjectFree;
636             eventCallbacks.VMObjectAlloc             = cbVMObjectAlloc;
637             break;
638 
639         case 2:
640             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
641                 newEventCount[i] = 0;
642             }
643 
644             eventCallbacks.MonitorWait               = cbNewMonitorWait;
645             eventCallbacks.MonitorWaited             = cbNewMonitorWaited;
646             eventCallbacks.MonitorContendedEnter     = cbNewMonitorContendedEnter;
647             eventCallbacks.MonitorContendedEntered   = cbNewMonitorContendedEntered;
648             break;
649 
650         case 3:
651             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
652                 newEventCount[i] = 0;
653             }
654 
655             eventCallbacks.VMDeath                   = cbVMDeath;
656             break;
657 
658     }
659     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
660         return false;
661 
662     return true;
663 }
664 
665 /* ============================================================================= */
666 
667 /** Agent algorithm. */
668 static void JNICALL
669 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
670 
671     int i;
672     jni = agentJNI;
673 
674     for (i = 1; i &lt;= STEP_AMOUNT; i++) {
675         if (i &gt; 1) {
676             NSK_DISPLAY0(&quot;Check received events\n&quot;);
677 
678             showEventStatistics(i-1);
679             if (!checkEvents(i-1)) {
680                 nsk_jvmti_setFailStatus();
681             }
682 
683             if (!setCallBacks(i)) {
684                 return;
685             }
686 
687             if (!nsk_jvmti_resumeSync())
688                 return;
689         }
690 
691         NSK_DISPLAY0(&quot;Wait for debuggee to become ready\n&quot;);
692         if (!nsk_jvmti_waitForSync(timeout))
693             return;
694 
695         prepare();
696 
697         if (!nsk_jvmti_resumeSync())
698             return;
699 
700 
701         NSK_DISPLAY0(&quot;Waiting events\n&quot;); /* thread started */
702         if (!nsk_jvmti_waitForSync(timeout))
703             return;
704 
705         if (!nsk_jvmti_resumeSync())
706             return;
707 
708         if (!nsk_jvmti_waitForSync(timeout))
709             return;
710 
711     }
712 
713     if (!clean()) {
714         nsk_jvmti_setFailStatus();
715         return;
716     }
717 
718     NSK_DISPLAY0(&quot;Let debuggee to finish\n&quot;);
719     if (!nsk_jvmti_resumeSync())
720         return;
721 
722 }
723 
724 /* ============================================================================= */
725 
726 /** Agent library initialization. */
727 #ifdef STATIC_BUILD
728 JNIEXPORT jint JNICALL Agent_OnLoad_em02t001(JavaVM *jvm, char *options, void *reserved) {
729     return Agent_Initialize(jvm, options, reserved);
730 }
731 JNIEXPORT jint JNICALL Agent_OnAttach_em02t001(JavaVM *jvm, char *options, void *reserved) {
732     return Agent_Initialize(jvm, options, reserved);
733 }
734 JNIEXPORT jint JNI_OnLoad_em02t001(JavaVM *jvm, char *options, void *reserved) {
735     return JNI_VERSION_1_8;
736 }
737 #endif
738 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
739 
740     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
741         return JNI_ERR;
742 
743     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
744 
745     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
746     if (!NSK_VERIFY(jvmti != NULL))
747         return JNI_ERR;
748 
749     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock))) {
750         nsk_jvmti_setFailStatus();
751         return JNI_ERR;
752     }
753 
754     {
755         jvmtiCapabilities caps;
756         memset(&amp;caps, 0, sizeof(caps));
757 
758         caps.can_generate_monitor_events = 1;
759         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
760             return JNI_ERR;
761     }
762 
763     if (!setCallBacks(1)) {
764         return JNI_ERR;
765     }
766 
767     nsk_jvmti_showPossessedCapabilities(jvmti);
768 
769     if (!enableEventList()) {
770         return JNI_ERR;
771     }
772 
773     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
774         return JNI_ERR;
775 
776     return JNI_OK;
777 }
778 
779 /* ============================================================================= */
780 
781 
782 }
    </pre>
  </body>
</html>
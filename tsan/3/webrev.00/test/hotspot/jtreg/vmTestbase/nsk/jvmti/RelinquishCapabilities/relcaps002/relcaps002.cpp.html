<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/RelinquishCapabilities/relcaps002/relcaps002.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdlib.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &quot;jvmti.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* ============================================================================= */
 34 
 35 static jlong timeout = 0;
 36 
 37 #define STATUS_FAIL     97
 38 
 39 #define EVENTS_COUNT    2
 40 
 41 static jvmtiEvent events[EVENTS_COUNT] = {
 42     JVMTI_EVENT_VM_INIT,
 43     JVMTI_EVENT_VM_DEATH
 44 };
 45 
 46 static jvmtiCapabilities initCaps;
 47 
 48 /* ============================================================================= */
 49 
 50 /** Prints capabilities structure as raw bits. */
 51 static void printRawCapabilities(const jvmtiCapabilities* caps) {
 52     const unsigned char* p = (const unsigned char*)caps;
 53     size_t size = sizeof(jvmtiCapabilities);
 54     size_t i;
 55     int j, k;
 56 
 57     nsk_printf(&quot;            &quot;);
 58     for (j = 0; j &lt; 16; j++) {
 59         nsk_printf(&quot; %1X&quot;, j);
 60     }
 61     nsk_printf(&quot;\n&quot;);
 62 
 63     for (i = 0; i &lt; size; i += 2) {
 64         int prefix = (int) i / 2;
 65 
 66         nsk_printf(&quot;    0x%03X.: &quot;, prefix);
 67         for (k = 0; k &lt; 2; k++) {
 68             unsigned char b = *(p++);
 69 
 70             for (j = 0; j &lt; 8; j++) {
 71                 int bit = b % 2;
 72                 b /= 2;
 73                 nsk_printf(&quot; %1d&quot;, bit);
 74             }
 75         }
 76         nsk_printf(&quot;\n&quot;);
 77     }
 78 }
 79 
 80 #define PRINT_CAP(caps, name)  nsk_printf(&quot;    %-40s: %d\n&quot;, #name, (int)caps-&gt;name)
 81 
 82 /** Print values of known capabilities. */
 83 static void printKnownCapabilities(const jvmtiCapabilities* caps) {
 84     PRINT_CAP(caps, can_tag_objects);
 85     PRINT_CAP(caps, can_generate_field_modification_events);
 86     PRINT_CAP(caps, can_generate_field_access_events);
 87     PRINT_CAP(caps, can_get_bytecodes);
 88     PRINT_CAP(caps, can_get_synthetic_attribute);
 89     PRINT_CAP(caps, can_get_owned_monitor_info);
 90     PRINT_CAP(caps, can_get_current_contended_monitor);
 91     PRINT_CAP(caps, can_get_monitor_info);
 92     PRINT_CAP(caps, can_pop_frame);
 93     PRINT_CAP(caps, can_redefine_classes);
 94     PRINT_CAP(caps, can_signal_thread);
 95     PRINT_CAP(caps, can_get_source_file_name);
 96     PRINT_CAP(caps, can_get_line_numbers);
 97     PRINT_CAP(caps, can_get_source_debug_extension);
 98     PRINT_CAP(caps, can_access_local_variables);
 99     PRINT_CAP(caps, can_maintain_original_method_order);
100     PRINT_CAP(caps, can_generate_single_step_events);
101     PRINT_CAP(caps, can_generate_exception_events);
102     PRINT_CAP(caps, can_generate_frame_pop_events);
103     PRINT_CAP(caps, can_generate_breakpoint_events);
104     PRINT_CAP(caps, can_suspend);
105     /* :1 */
106     PRINT_CAP(caps, can_get_current_thread_cpu_time);
107     PRINT_CAP(caps, can_get_thread_cpu_time);
108     PRINT_CAP(caps, can_generate_method_entry_events);
109     PRINT_CAP(caps, can_generate_method_exit_events);
110     PRINT_CAP(caps, can_generate_all_class_hook_events);
111     PRINT_CAP(caps, can_generate_compiled_method_load_events);
112     PRINT_CAP(caps, can_generate_monitor_events);
113     PRINT_CAP(caps, can_generate_vm_object_alloc_events);
114     PRINT_CAP(caps, can_generate_native_method_bind_events);
115     PRINT_CAP(caps, can_generate_garbage_collection_events);
116     PRINT_CAP(caps, can_generate_object_free_events);
117     /* :15 */
118     /* :16 */
119     /* :16 */
120     /* :16 */
121     /* :16 */
122     /* :16 */
123 }
124 
125 #define CHECK_CAP(initCaps, caps, name)                                         \
126     if (caps-&gt;name != 0) {                                                      \
127         success = false;                                                        \
128         NSK_COMPLAIN4(&quot;GetCapabilities() in %s returned capability after add and relinguish all potential capabilities:\n&quot;  \
129                       &quot;#   capability: %s\n&quot;                                    \
130                       &quot;#   got value:  %d\n&quot;                                    \
131                       &quot;#   expected:   %d\n&quot;,                                   \
132                         where, #name, (int)caps-&gt;name, 0)       ;               \
133     }
134 
135 /**
136  * Check value of known capabilities.
137  * @returns false if any error occured.
138  */
139 static bool checkCapabilitiesValue(jvmtiCapabilities* caps, jvmtiCapabilities* initCaps, const char where[]) {
140     bool success = true;
141 
142     CHECK_CAP(initCaps, caps, can_tag_objects);
143     CHECK_CAP(initCaps, caps, can_generate_field_modification_events);
144     CHECK_CAP(initCaps, caps, can_generate_field_access_events);
145     CHECK_CAP(initCaps, caps, can_get_bytecodes);
146     CHECK_CAP(initCaps, caps, can_get_synthetic_attribute);
147     CHECK_CAP(initCaps, caps, can_get_owned_monitor_info);
148     CHECK_CAP(initCaps, caps, can_get_current_contended_monitor);
149     CHECK_CAP(initCaps, caps, can_get_monitor_info);
150     CHECK_CAP(initCaps, caps, can_pop_frame);
151     CHECK_CAP(initCaps, caps, can_redefine_classes);
152     CHECK_CAP(initCaps, caps, can_signal_thread);
153     CHECK_CAP(initCaps, caps, can_get_source_file_name);
154     CHECK_CAP(initCaps, caps, can_get_line_numbers);
155     CHECK_CAP(initCaps, caps, can_get_source_debug_extension);
156     CHECK_CAP(initCaps, caps, can_access_local_variables);
157     CHECK_CAP(initCaps, caps, can_maintain_original_method_order);
158     CHECK_CAP(initCaps, caps, can_generate_single_step_events);
159     CHECK_CAP(initCaps, caps, can_generate_exception_events);
160     CHECK_CAP(initCaps, caps, can_generate_frame_pop_events);
161     CHECK_CAP(initCaps, caps, can_generate_breakpoint_events);
162     CHECK_CAP(initCaps, caps, can_suspend);
163     /* :1 */
164     CHECK_CAP(initCaps, caps, can_get_current_thread_cpu_time);
165     CHECK_CAP(initCaps, caps, can_get_thread_cpu_time);
166     CHECK_CAP(initCaps, caps, can_generate_method_entry_events);
167     CHECK_CAP(initCaps, caps, can_generate_method_exit_events);
168     CHECK_CAP(initCaps, caps, can_generate_all_class_hook_events);
169     CHECK_CAP(initCaps, caps, can_generate_compiled_method_load_events);
170     CHECK_CAP(initCaps, caps, can_generate_monitor_events);
171     CHECK_CAP(initCaps, caps, can_generate_vm_object_alloc_events);
172     CHECK_CAP(initCaps, caps, can_generate_native_method_bind_events);
173     CHECK_CAP(initCaps, caps, can_generate_garbage_collection_events);
174     CHECK_CAP(initCaps, caps, can_generate_object_free_events);
175     /* :15 */
176     /* :16 */
177     /* :16 */
178     /* :16 */
179     /* :16 */
180     /* :16 */
181 
182     return success;
183 }
184 
185 /**
186  * Get and check current capabilities.
187  * @returns false if any error occured.
188  */
189 static bool checkCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* initCaps, const char where[]) {
190     bool success = true;
191     jvmtiCapabilities caps;
192 
193     memset(&amp;caps, 0, sizeof(jvmtiCapabilities));
194 
195     NSK_DISPLAY0(&quot;GetCapabilities() for current JVMTI env\n&quot;);
196     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetCapabilities(&amp;caps))) {
197         return false;
198     }
199 
200     NSK_DISPLAY0(&quot;Got raw capabilities:\n&quot;);
201     printRawCapabilities(&amp;caps);
202 
203     NSK_DISPLAY0(&quot;Known capabilities:\n&quot;);
204     printKnownCapabilities(&amp;caps);
205 
206     NSK_DISPLAY0(&quot;Checking capabilities value:\n&quot;);
207     success = checkCapabilitiesValue(&amp;caps, initCaps, where);
208     NSK_DISPLAY0(&quot;  ... checked\n&quot;);
209 
210     return success;
211 }
212 
213 /**
214  * Add given capabilities list.
215  * @returns false if any error occured.
216  */
217 static bool addCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* caps) {
218     NSK_DISPLAY0(&quot;AddCapabilities() for current JVMTI env\n&quot;);
219     if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(caps))) {
220         return false;
221     }
222     NSK_DISPLAY0(&quot;  ... set\n&quot;);
223 
224     return true;
225 }
226 
227 /**
228  * Remove given capabilities list.
229  * @returns false if any error occured.
230  */
231 static bool removeCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* caps, const char where[]) {
232     NSK_DISPLAY0(&quot;RelinquishCapabilities() for current JVMTI env\n&quot;);
233     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RelinquishCapabilities(caps))) {
234         return false;
235     }
236     NSK_DISPLAY0(&quot;  ... relinguished\n&quot;);
237 
238     return true;
239 }
240 
241 /**
242  * Get potential capabilities to the given list.
243  * @returns false if any error occured.
244  */
245 static bool getPotentialCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* caps) {
246     NSK_DISPLAY0(&quot;GetPotentialCapabilities() for current JVMTI env\n&quot;);
247     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetPotentialCapabilities(caps))) {
248         return false;
249     }
250 
251     NSK_DISPLAY0(&quot;Got raw capabilities:\n&quot;);
252     printRawCapabilities(caps);
253 
254     NSK_DISPLAY0(&quot;Known capabilities:\n&quot;);
255     printKnownCapabilities(caps);
256 
257     return true;
258 }
259 
260 /* ============================================================================= */
261 
262 /** Agent algorithm. */
263 static void JNICALL
264 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
265     NSK_DISPLAY0(&quot;Wait for debugee to become ready\n&quot;);
266     if (!nsk_jvmti_waitForSync(timeout))
267         return;
268 
269     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #0: Remove all potential capabilities in agent thread\n&quot;);
270     if (!removeCapabilities(jvmti, &amp;initCaps, &quot;agent thread&quot;)) {
271         nsk_jvmti_setFailStatus();
272     }
273 
274     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #3: Check capabilities in agent thread\n&quot;);
275     if (!checkCapabilities(jvmti, &amp;initCaps, &quot;agent thread&quot;)) {
276         nsk_jvmti_setFailStatus();
277     }
278 
279     NSK_DISPLAY0(&quot;Let debugee to finish\n&quot;);
280     if (!nsk_jvmti_resumeSync())
281         return;
282 }
283 
284 /* ============================================================================= */
285 
286 /**
287  * Callback for VM_INIT event.
288  */
289 JNIEXPORT void JNICALL
290 callbackVMInit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread) {
291 }
292 
293 /**
294  * Callback for VM_DEATH event.
295  */
296 JNIEXPORT void JNICALL
297 callbackVMDeath(jvmtiEnv* jvmti, JNIEnv* jni) {
298     bool success = true;
299 
300     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #4: Check capabilities in VM_DEATH callback\n&quot;);
301     success = checkCapabilities(jvmti, &amp;initCaps, &quot;VM_DEATH callback&quot;);
302 
303     NSK_DISPLAY1(&quot;Disable events: %d events\n&quot;, EVENTS_COUNT);
304     if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {
305         success = false;
306     } else {
307         NSK_DISPLAY0(&quot;  ... disabled\n&quot;);
308     }
309 
310     if (success != true) {
311         NSK_DISPLAY1(&quot;Exit with FAIL exit status: %d\n&quot;, STATUS_FAIL);
312         NSK_BEFORE_TRACE(exit(STATUS_FAIL));
313     }
314 }
315 
316 /* ============================================================================= */
317 
318 /** Agent library initialization. */
319 #ifdef STATIC_BUILD
320 JNIEXPORT jint JNICALL Agent_OnLoad_relcaps002(JavaVM *jvm, char *options, void *reserved) {
321     return Agent_Initialize(jvm, options, reserved);
322 }
323 JNIEXPORT jint JNICALL Agent_OnAttach_relcaps002(JavaVM *jvm, char *options, void *reserved) {
324     return Agent_Initialize(jvm, options, reserved);
325 }
326 JNIEXPORT jint JNI_OnLoad_relcaps002(JavaVM *jvm, char *options, void *reserved) {
327     return JNI_VERSION_1_8;
328 }
329 #endif
330 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
331     jvmtiEnv* jvmti = NULL;
332 
333     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
334         return JNI_ERR;
335 
336     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
337 
338     if (!NSK_VERIFY((jvmti =
339             nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))
340         return JNI_ERR;
341 
342     {
343         jvmtiEventCallbacks eventCallbacks;
344 
345         memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
346         eventCallbacks.VMInit = callbackVMInit;
347         eventCallbacks.VMDeath = callbackVMDeath;
348         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks)))) {
349             return JNI_ERR;
350         }
351 
352     }
353 
354     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
355         return JNI_ERR;
356 
357     memset(&amp;initCaps, 0, sizeof(jvmtiCapabilities));
358     if (!getPotentialCapabilities(jvmti, &amp;initCaps)) {
359         return JNI_ERR;
360     }
361 
362     if (!addCapabilities(jvmti, &amp;initCaps)) {
363         return JNI_ERR;
364     }
365 
366     NSK_DISPLAY1(&quot;Enable events: %d events\n&quot;, EVENTS_COUNT);
367     if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {
368         NSK_DISPLAY0(&quot;  ... enabled\n&quot;);
369     }
370 
371     return JNI_OK;
372 }
373 
374 /* ============================================================================= */
375 
376 }
    </pre>
  </body>
</html>
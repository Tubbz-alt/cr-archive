<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/hotswap/HS204/hs204t004/hs204t004.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 #include &lt;stdio.h&gt;
 24 #include &lt;jvmti.h&gt;
 25 #include &quot;agent_common.h&quot;
 26 #include &lt;jni.h&gt;
 27 #include &lt;string.h&gt;
 28 #include &quot;jvmti_tools.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 
 31 /*
 32 1. Enable event ClassPrepare.
 33 2. Upon ClassPrepare occurrence, enable FieldAccessWatch for a field to be initialized by the initializer.
 34 3. Upon accessing the field by the initializer, redefine the class and pop a currently executed
 35  frame of the initializer within incoming FieldAccess callback.
 36 */
 37 extern &quot;C&quot; {
 38 
 39 #define METHOD_NAME &quot;loadClass&quot;
 40 #define SIGNATURE &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;
 41 #define FILE_NAME &quot;nsk/jvmti/scenarios/hotswap/HS204/hs204t004/MyClassLoader&quot;
 42 #define CLASS_LOADER_CLASS_NAME &quot;Lnsk/jvmti/scenarios/hotswap/HS204/hs204t004/MyClassLoader;&quot;
 43 /* for redefine..*/
 44 static jint redefineNumber;
 45 static jvmtiEnv * jvmti;
 46 static jclass cloader;
 47 
 48 JNIEXPORT void JNICALL
 49 callbackClassLoad(jvmtiEnv *jvmti_env,
 50                         JNIEnv* jni,
 51                         jthread thread,
 52                         jclass klass) {
 53     char * className;
 54     char * generic;
 55     redefineNumber=0;
 56     jvmti-&gt;GetClassSignature(klass, &amp;className, &amp;generic);
 57     if (strcmp(className, CLASS_LOADER_CLASS_NAME) == 0) {
 58         if (klass != NULL) {
 59             jmethodID method;
 60             cloader = klass;
 61             method = jni-&gt;GetMethodID(klass,METHOD_NAME,SIGNATURE);
 62             if (method != NULL) {
 63                 jlocation start;
 64                 jlocation end;
 65                 jvmtiError err ;
 66                 err=jvmti-&gt;GetMethodLocation(method, &amp;start, &amp;end);
 67                 if (err == JVMTI_ERROR_NONE) {
 68                     nsk_printf(&quot;Agent:: NO ERRORS FOUND \n&quot;);
 69                     err= jvmti-&gt;SetBreakpoint(method, start+1);
 70                     if (err == JVMTI_ERROR_NONE) {
 71                         nsk_printf(&quot;Agent:: Breakpoint set \n&quot;);
 72                     } else {
 73                         nsk_printf(&quot;Agent:: ***ERROR OCCURED ... in SET BREAK POINT ERROR \n&quot;);
 74                     }
 75                 } else {
 76                     nsk_printf(&quot;Agent:: ***ERROR OCCURED .. in METHOD LOCATION FINDER \n&quot;);
 77                 }
 78             } else {
 79                 nsk_printf(&quot;Agent:: ***ERROR OCCURED .. COUND NOT FIND THE METHOD AND SIGNATURE SPECIFIED \n&quot;);
 80             }
 81         } else {
 82             nsk_printf(&quot;Agent:: ***ERROR OCCURED .. CLASS SPECIFIED WAS NOT FOUND \n&quot;);
 83         }
 84     }
 85 }
 86 
 87 void JNICALL callbackBreakpoint(jvmtiEnv *jvmti_env,
 88         JNIEnv* jni,
 89         jthread thread,
 90         jmethodID method,
 91         jlocation loc) {
 92     jvmtiError err ;
 93     jclass clas;
 94     char fileName[512];
 95     clas = jni-&gt;FindClass(CLASS_LOADER_CLASS_NAME);
 96     nsk_printf(&quot;Agent::  Break Pont Reached..\n&quot;);
 97     /* Redefine the class loader and then pop the
 98        frame and resume the thread..*/
 99     nsk_jvmti_getFileName(redefineNumber, FILE_NAME, fileName, sizeof(fileName)/sizeof(char));
<a name="1" id="anc1"></a><span class="line-modified">100     if (nsk_jvmti_redefineClass(jvmti_env, clas, fileName) == NSK_TRUE) {</span>
101         nsk_printf(&quot;\nMyClass :: Successfully redefined..\n&quot;);
102     } else {
103         nsk_printf(&quot;\nMyClass :: Failed to redefine ..\n&quot;);
104     }
105     nsk_printf(&quot; End of REDEFINE CLASS LOADER \n&quot;);
106     err=jvmti-&gt;SuspendThread(thread);
107     if (err == JVMTI_ERROR_NONE) {
108         nsk_printf(&quot;Agent:: Succeded in suspending..\n&quot;);
109     } else if (err == JVMTI_ERROR_THREAD_SUSPENDED) {
110         nsk_printf(&quot;Agent:: JVMTI_ERROR_THREAD_SUSPENDED \n&quot;);
111     } else if (err == JVMTI_ERROR_INVALID_THREAD) {
112         nsk_printf(&quot;Agent:: JVMTI_ERROR_INVALID_THREAD \n&quot;);
113     } else if (err == JVMTI_ERROR_THREAD_NOT_ALIVE) {
114         nsk_printf(&quot;Agent:: JVMTI_ERROR_THREAD_NOT_ALIVE \n&quot;);
115     } else {
116         nsk_printf(&quot; Else error &quot;);
117     }
118 }
119 
120 
121 #ifdef STATIC_BUILD
122 JNIEXPORT jint JNICALL Agent_OnLoad_hs204t004(JavaVM *jvm, char *options, void *reserved) {
123     return Agent_Initialize(jvm, options, reserved);
124 }
125 JNIEXPORT jint JNICALL Agent_OnAttach_hs204t004(JavaVM *jvm, char *options, void *reserved) {
126     return Agent_Initialize(jvm, options, reserved);
127 }
128 JNIEXPORT jint JNI_OnLoad_hs204t004(JavaVM *jvm, char *options, void *reserved) {
129     return JNI_VERSION_1_8;
130 }
131 #endif
132 jint   Agent_Initialize(JavaVM *vm, char *options, void *reserved) {
133       jint rc ;
134       nsk_printf(&quot;Agent:: VM.. Started..\n&quot;);
135       rc=vm-&gt;GetEnv((void **)&amp;jvmti, JVMTI_VERSION_1_1);
136       if (rc != JNI_OK) {
137           nsk_printf(&quot;Agent:: Could not load JVMTI interface \n&quot;);
138           return JNI_ERR;
139       } else {
140           jvmtiCapabilities caps;
141           jvmtiEventCallbacks eventCallbacks;
142           memset(&amp;caps, 0, sizeof(caps));
143           if (!nsk_jvmti_parseOptions(options)) {
144               nsk_printf(&quot; NSK Failed to parse..&quot;);
145               return JNI_ERR;
146           }
147           caps.can_redefine_classes = 1;
148           caps.can_suspend=1;
149           caps.can_pop_frame=1;
150           caps.can_generate_breakpoint_events=1;
151           caps.can_generate_all_class_hook_events=1;
152           jvmti-&gt;AddCapabilities(&amp;caps);
153           memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
154           eventCallbacks.ClassLoad =callbackClassLoad;
155           eventCallbacks.Breakpoint = callbackBreakpoint;
156           rc=jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks));
157           if (rc != JVMTI_ERROR_NONE) {
158               nsk_printf(&quot; Agent:: Error occured while setting event call back \n&quot;);
159               return JNI_ERR;
160           }
161           nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_LOAD, NULL);
162           nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT, NULL);
163       }
164       return JNI_OK;
165   }
166 
167 JNIEXPORT jboolean JNICALL
168 Java_nsk_jvmti_scenarios_hotswap_HS204_hs204t004_hs204t004_popFrame(JNIEnv * jni,
169         jclass clas,
170         jthread thread) {
171     jvmtiError err ;
172     jboolean retvalue;
173     jint state;
174     nsk_printf(&quot;Agent:: POPING THE FRAME....\n&quot;);
175     retvalue = JNI_FALSE;
176     jvmti-&gt;GetThreadState(thread, &amp;state);
177     if (state &amp; JVMTI_THREAD_STATE_IN_NATIVE) nsk_printf(&quot;JVMTI_THREAD_STATE_IN_NATIVE&quot;);
178     if (state &amp; JVMTI_THREAD_STATE_INTERRUPTED) nsk_printf(&quot;JVMTI_THREAD_STATE_INTERRUPTED&quot;);
179     if (state &amp; JVMTI_THREAD_STATE_WAITING) nsk_printf(&quot; JVMTI_THREAD_STATE_WAITING&quot;);
180     if (state &amp; JVMTI_THREAD_STATE_SUSPENDED) {
181         nsk_printf(&quot;Agent:: Thread state .. JVMTI_THREAD_STATE_SUSPENDED \n&quot;);
182         err = jvmti-&gt;PopFrame(thread);
183         if (err == JVMTI_ERROR_NONE) {
184             nsk_printf(&quot;Agent:: NO Errors poped very well ..\n&quot;);
185             err = jvmti-&gt;ResumeThread(thread);
186             if (err == JVMTI_ERROR_NONE) {
187                 retvalue = JNI_TRUE;
188             } else {
189                 nsk_printf(&quot;Agent:: Error occured in resuming a thread..\n&quot;);
190             }
191         } else {
192             nsk_printf(&quot;Agent:: some other error ..%s \n&quot;,TranslateError(err));
193         }
194     } else {
195         nsk_printf(&quot;Agent:: Thread is not suspended ..\n&quot;);
196     }
197     return retvalue;
198 }
199 
200 
201 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t007/em02t007.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* ============================================================================= */
 34 
 35 /* scaffold objects */
 36 static jvmtiEnv *jvmti = NULL;
 37 static jlong timeout = 0;
 38 static jrawMonitorID syncLock = NULL;
 39 
 40 /* constant names */
 41 #define STEP_NUMBER 3
 42 #define OBJECT_NUMBER 100
 43 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 44 
 45 static int eventCount[JVMTI_EVENT_COUNT];
 46 static int newEventCount[JVMTI_EVENT_COUNT];
 47 static int singleStepIdx = JVMTI_EVENT_SINGLE_STEP - JVMTI_MIN_EVENT_TYPE_VAL;
 48 
 49 /* ============================================================================= */
 50 
 51 
 52 static void
 53 showEventStatistics(int step) {
 54     int i;
 55     const char* str;
 56     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 57 
 58     NSK_DISPLAY0(&quot;\n&quot;);
 59     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 60     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 61     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 62         if (currentCounts[i] &gt; 0) {
 63             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 64             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 65         }
 66     }
 67 }
 68 
 69 /* ========================================================================== */
 70 
 71 int checkEvents(int step) {
 72     int i;
 73     jvmtiEvent curr;
 74     bool result = true;
 75     int *currentCounts;
 76     int isExpected = 0;
 77 
 78     switch (step) {
 79         case 1:
 80             currentCounts = &amp;eventCount[0];
 81             break;
 82 
 83         case 2:
 84         case 3:
 85             currentCounts = &amp;newEventCount[0];
 86             break;
 87 
 88         default:
 89             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
 90             return false;
 91     }
 92 
 93     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 94 
 95         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 96 
 97         switch (step) {
 98             case 1:
 99                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
100                                 || (curr == JVMTI_EVENT_SINGLE_STEP));
101                 break;
102 
103             case 2:
104                 isExpected = (curr == JVMTI_EVENT_SINGLE_STEP);
105                 break;
106 
107             case 3:
108                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
109                 break;
110         }
111 
112         if (isExpected) {
113             if (currentCounts[i] &lt; 0) {
114                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
115                                         currentCounts[i],
116                                         TranslateEvent(curr));
117                 result = false;
118             }
119         } else {
120 
121             if (currentCounts[i] &gt; 0) {
122                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
123                                     TranslateEvent(curr),
124                                     currentCounts[i]);
125                 result = false;
126             }
127         }
128     }
129 
130     return result;
131 }
132 
133 static void
134 changeCount(jvmtiEvent event, int *currentCounts) {
135 
136     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
137         nsk_jvmti_setFailStatus();
138 
139     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
140 
141     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
142         nsk_jvmti_setFailStatus();
143 
144 }
145 
146 /* ============================================================================= */
147 
148 /* callbacks */
149 JNIEXPORT void JNICALL
150 cbVMInit(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread) {
151     changeCount(JVMTI_EVENT_VM_INIT, &amp;eventCount[0]);
152 }
153 
154 JNIEXPORT void JNICALL
155 cbVMDeath(jvmtiEnv* jvmti, JNIEnv* jni_env) {
156     changeCount(JVMTI_EVENT_VM_DEATH, &amp;newEventCount[0]);
157     showEventStatistics(STEP_NUMBER);
158     if (!checkEvents(STEP_NUMBER))
159         nsk_jvmti_setFailStatus();
160 
161     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock)))
162         nsk_jvmti_setFailStatus();
163 
164 }
165 
166 void JNICALL
167 cbException(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
168                 jmethodID method, jlocation location, jobject exception,
169                 jmethodID catch_method, jlocation catch_location) {
170     changeCount(JVMTI_EVENT_EXCEPTION, &amp;eventCount[0]);
171 }
172 
173 void JNICALL
174 cbExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
175                 jmethodID method, jlocation location, jobject exception) {
176     changeCount(JVMTI_EVENT_EXCEPTION_CATCH, &amp;eventCount[0]);
177 }
178 
179 void JNICALL
180 cbSingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
181                 jmethodID method, jlocation location) {
182     char *name;
183     char *sign;
184     char *genc;
185 
186     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodName(method, &amp;name, &amp;sign, &amp;genc))) {
187         nsk_jvmti_setFailStatus();
188         return;
189     }
190 
191     if (!strncmp(name,&quot;javaMethod&quot;, 8)) {
192         NSK_DISPLAY2(&quot;\tMethod: %s, location: %lld\n&quot;,
193                             name, location);
194         changeCount(JVMTI_EVENT_SINGLE_STEP, &amp;eventCount[0]);
195     }
196 
197     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)name))) {
198         nsk_jvmti_setFailStatus();
199     }
200     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)sign))) {
201         nsk_jvmti_setFailStatus();
202     }
203     if (genc != NULL)
204         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)genc))) {
205             nsk_jvmti_setFailStatus();
206         }
207 }
208 
209 void JNICALL
210 cbNewSingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
211                 jmethodID method, jlocation location) {
212     char *name;
213     char *sign;
214     char *genc;
215 
216     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodName(method, &amp;name, &amp;sign, &amp;genc))) {
217         nsk_jvmti_setFailStatus();
218         return;
219     }
220 
221     if (!strncmp(name,&quot;javaMethod&quot;, 8)) {
222         NSK_DISPLAY2(&quot;\tMethod: %s, location: %lld\n&quot;,
223                             name, location);
224         changeCount(JVMTI_EVENT_SINGLE_STEP, &amp;newEventCount[0]);
225     }
226 
227     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)name))) {
228         nsk_jvmti_setFailStatus();
229     }
230     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)sign))) {
231         nsk_jvmti_setFailStatus();
232     }
233     if (genc != NULL)
234         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)genc))) {
235             nsk_jvmti_setFailStatus();
236         }
237 }
238 
239 void JNICALL
240 cbFramePop(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
241                 jmethodID method, jboolean was_popped_by_exception) {
242     changeCount(JVMTI_EVENT_FRAME_POP, &amp;eventCount[0]);
243 }
244 
245 void JNICALL
246 cbBreakpoint(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
247                 jmethodID method, jlocation location) {
248     changeCount(JVMTI_EVENT_BREAKPOINT, &amp;eventCount[0]);
249 }
250 
251 void JNICALL
252 cbFieldAccess(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
253                 jmethodID method, jlocation location, jclass field_klass,
254                 jobject object, jfieldID field) {
255     changeCount(JVMTI_EVENT_FIELD_ACCESS, &amp;eventCount[0]);
256 }
257 
258 void JNICALL
259 cbFieldModification(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
260                 jmethodID method, jlocation location, jclass field_klass,
261                 jobject object, jfieldID field, char signature_type,
262                 jvalue new_value) {
263     changeCount(JVMTI_EVENT_FIELD_MODIFICATION, &amp;eventCount[0]);
264 }
265 
266 void JNICALL
267 cbMethodEntry(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
268                 jmethodID method) {
269     changeCount(JVMTI_EVENT_METHOD_ENTRY, &amp;eventCount[0]);
270 }
271 
272 void JNICALL
273 cbMethodExit(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
274                 jmethodID method, jboolean was_popped_by_exception,
275                 jvalue return_value) {
276     changeCount(JVMTI_EVENT_METHOD_EXIT, &amp;eventCount[0]);
277 }
278 
279 void JNICALL
280 cbNativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env,jthread thread,
281                 jmethodID method, void* address, void** new_address_ptr) {
282     changeCount(JVMTI_EVENT_NATIVE_METHOD_BIND, &amp;eventCount[0]);
283 }
284 
285 void JNICALL
286 cbMonitorWait(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
287                     jobject object, jlong tout) {
288 
289     changeCount(JVMTI_EVENT_MONITOR_WAIT, &amp;eventCount[0]);
290 }
291 
292 void JNICALL
293 cbMonitorWaited(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
294                     jobject object, jboolean timed_out) {
295 
296     changeCount(JVMTI_EVENT_MONITOR_WAITED, &amp;eventCount[0]);
297 }
298 
299 JNIEXPORT void JNICALL
300 cbMonitorContendedEnter(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread,
301                             jobject object) {
302 
303     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTER, &amp;eventCount[0]);
304 }
305 
306 void JNICALL
307 cbMonitorContendedEntered(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
308                             jobject object) {
309 
310     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, &amp;eventCount[0]);
311 }
312 
313 void JNICALL
314 cbCompiledMethodLoad(jvmtiEnv *jvmti_env, jmethodID method, jint code_size,
315                 const void* code_addr, jint map_length,
316                 const jvmtiAddrLocationMap* map, const void* compile_info) {
317     changeCount(JVMTI_EVENT_COMPILED_METHOD_LOAD, &amp;eventCount[0]);
318 }
319 
320 void JNICALL
321 cbCompiledMethodUnload(jvmtiEnv *jvmti_env, jmethodID method,
322                 const void* code_addr) {
323     changeCount(JVMTI_EVENT_COMPILED_METHOD_UNLOAD, &amp;eventCount[0]);
324 }
325 
326 void JNICALL
327 cbGarbageCollectionStart(jvmtiEnv *jvmti_env) {
328     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_START, &amp;eventCount[0]);
329 }
330 
331 void JNICALL
332 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
333     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
334 }
335 
336 void JNICALL
337 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
338 
339     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
340     if (tag &lt; 1 || tag &gt; OBJECT_NUMBER) {
341         NSK_COMPLAIN1(&quot;Unexpected tag value %lld\n&quot;, tag);
342         nsk_jvmti_setFailStatus();
343     }
344 }
345 
346 void JNICALL
347 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
348                     jobject object, jclass object_klass, jlong size) {
349 
350     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
351 }
352 
353 /* ============================================================================= */
354 
355 static bool enableEvent(jvmtiEvent event) {
356 
357     if (nsk_jvmti_isOptionalEvent(event)
358             &amp;&amp; (event != JVMTI_EVENT_SINGLE_STEP)) {
359         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
360                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
361             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
362                 TranslateEvent(event));
363             return false;
364         }
365     } else {
366         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
367             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
368                 TranslateEvent(event));
369             return false;
370         }
371     }
372 
373     return true;
374 }
375 
376 /**
377  * Enable or disable tested events.
378  */
379 static bool enableEventList() {
380 
381     int i, result;
382 
383     result = enableEvent(JVMTI_EVENT_VM_INIT);
384 
385     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
386 
387     /* enabling optional events */
388     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
389         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
390 
391         if (nsk_jvmti_isOptionalEvent(event))
392             result = result &amp;&amp; enableEvent(event);
393     }
394 
395     if (!result) {
396         nsk_jvmti_setFailStatus();
397         return false;
398     }
399 
400     return true;
401 }
402 
403 /* ============================================================================= */
404 
405 static bool setCallBacks(int step) {
406 
407     int i;
408 
409     jvmtiEventCallbacks eventCallbacks;
410     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
411 
412     switch (step) {
413         case 1:
414             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
415                 eventCount[i] = 0;
416             }
417 
418             eventCallbacks.VMInit                    = cbVMInit;
419             eventCallbacks.Exception                 = cbException;
420             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
421             eventCallbacks.SingleStep                = cbSingleStep;
422             eventCallbacks.FramePop                  = cbFramePop;
423             eventCallbacks.Breakpoint                = cbBreakpoint;
424             eventCallbacks.FieldAccess               = cbFieldAccess;
425             eventCallbacks.FieldModification         = cbFieldModification;
426             eventCallbacks.MethodEntry               = cbMethodEntry;
427             eventCallbacks.MethodExit                = cbMethodExit;
428             eventCallbacks.NativeMethodBind          = cbNativeMethodBind;
429             eventCallbacks.CompiledMethodLoad        = cbCompiledMethodLoad;
430             eventCallbacks.CompiledMethodUnload      = cbCompiledMethodUnload;
431             eventCallbacks.MonitorWait               = cbMonitorWait;
432             eventCallbacks.MonitorWaited             = cbMonitorWaited;
433             eventCallbacks.MonitorContendedEnter     = cbMonitorContendedEnter;
434             eventCallbacks.MonitorContendedEntered   = cbMonitorContendedEntered;
435             eventCallbacks.GarbageCollectionStart    = cbGarbageCollectionStart;
436             eventCallbacks.GarbageCollectionFinish   = cbGarbageCollectionFinish;
437             eventCallbacks.ObjectFree                = cbObjectFree;
438             eventCallbacks.VMObjectAlloc             = cbVMObjectAlloc;
439             break;
440 
441         case 2:
442             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
443                 newEventCount[i] = 0;
444             }
445 
446             eventCallbacks.SingleStep                = cbNewSingleStep;
447             break;
448 
449         case 3:
450             /* comparing number of JVMTI_EVENT_SINGLE_STEP events for steps*/
451             if (eventCount[singleStepIdx] != newEventCount[singleStepIdx]) {
452                 NSK_COMPLAIN2(&quot;Number of JVMTI_EVENT_SINGLE_STEP events must be the same\n\t1-st callback=%d; 2-nd callback=%d\n&quot;,
453                                     eventCount[singleStepIdx],
454                                     newEventCount[singleStepIdx]);
455             }
456 
457             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
458                 newEventCount[i] = 0;
459             }
460 
461             eventCallbacks.VMDeath                   = cbVMDeath;
462             break;
463 
464     }
465     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
466         return false;
467 
468     return true;
469 }
470 
471 /* ============================================================================= */
472 
473 /** Agent algorithm. */
474 static void JNICALL
475 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
476 
477     int i;
478 
479     for (i = 1; i &lt;= STEP_NUMBER; i++) {
480 
481         if (!nsk_jvmti_waitForSync(timeout))
482             return;
483 
484         NSK_DISPLAY0(&quot;Check received events\n&quot;);
485 
486         if (i &lt; STEP_NUMBER) {
487             showEventStatistics(i);
488             if (!checkEvents(i))
489                 nsk_jvmti_setFailStatus();
490 
491             if (!setCallBacks(i + 1)) {
492                 return;
493             }
494         }
495 
496         if (!nsk_jvmti_resumeSync())
497             return;
498     }
499 
500 }
501 
502 /* ============================================================================= */
503 
504 /** Agent library initialization. */
505 #ifdef STATIC_BUILD
506 JNIEXPORT jint JNICALL Agent_OnLoad_em02t007(JavaVM *jvm, char *options, void *reserved) {
507     return Agent_Initialize(jvm, options, reserved);
508 }
509 JNIEXPORT jint JNICALL Agent_OnAttach_em02t007(JavaVM *jvm, char *options, void *reserved) {
510     return Agent_Initialize(jvm, options, reserved);
511 }
512 JNIEXPORT jint JNI_OnLoad_em02t007(JavaVM *jvm, char *options, void *reserved) {
513     return JNI_VERSION_1_8;
514 }
515 #endif
516 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
517 
518     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
519         return JNI_ERR;
520 
521     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
522 
523     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
524     if (!NSK_VERIFY(jvmti != NULL))
525         return JNI_ERR;
526 
527     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock))) {
528         nsk_jvmti_setFailStatus();
529         return JNI_ERR;
530     }
531 
532     {
533         jvmtiCapabilities caps;
534         memset(&amp;caps, 0, sizeof(caps));
535 
536         caps.can_generate_single_step_events = 1;
537         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
538             return JNI_ERR;
539     }
540 
541     if (!setCallBacks(1)) {
542         return JNI_ERR;
543     }
544 
545     if (!enableEventList()) {
546         return JNI_ERR;
547     }
548 
549     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
550         return JNI_ERR;
551 
552     return JNI_OK;
553 }
554 
555 /* ============================================================================= */
556 
557 
558 }
    </pre>
  </body>
</html>
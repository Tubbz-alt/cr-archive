<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t010/em02t010.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../em02t009/em02t009.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="libem02t010.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t010/em02t010.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;

 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* ============================================================================= */
 34 
 35 /* scaffold objects */
 36 static jvmtiEnv *jvmti = NULL;
 37 static jlong timeout = 0;
 38 static jrawMonitorID syncLock = NULL;
 39 
 40 /* constant names */
 41 #define STEP_NUMBER 3
 42 #define CLASS_NAME &quot;nsk/jvmti/scenarios/events/EM02/em02t010&quot;
 43 #define FIELD_ACC_NAME &quot;testedField_acc&quot;
 44 #define FIELD_MOD_NAME &quot;testedField_mod&quot;
 45 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 46 #define NUMBER_OF_INVOCATIONS 1000
</pre>
<hr />
<pre>
 55     int i;
 56     const char* str;
 57     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 58 
 59     NSK_DISPLAY0(&quot;\n&quot;);
 60     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 61     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 62     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 63         if (currentCounts[i] &gt; 0) {
 64             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 65             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 66         }
 67     }
 68 }
 69 
 70 /* ========================================================================== */
 71 
 72 int checkEvents(int step) {
 73     int i;
 74     jvmtiEvent curr;
<span class="line-modified"> 75     int result = NSK_TRUE;</span>
 76     int *currentCounts;
 77     int isExpected = 0;
 78 
 79     switch (step) {
 80         case 1:
 81             currentCounts = &amp;eventCount[0];
 82             break;
 83 
 84         case 2:
 85         case 3:
 86             currentCounts = &amp;newEventCount[0];
 87             break;
 88 
 89         default:
 90             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified"> 91             return NSK_FALSE;</span>
 92     }
 93 
 94     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 95 
 96         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 97 
 98         switch (step) {
 99             case 1:
100                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
101                                 || (curr == JVMTI_EVENT_FIELD_MODIFICATION)
102                                 || (curr == JVMTI_EVENT_FIELD_ACCESS));
103                 break;
104 
105             case 2:
106                 isExpected = ((curr == JVMTI_EVENT_FIELD_MODIFICATION)
107                                 || (curr == JVMTI_EVENT_FIELD_ACCESS));
108                 break;
109 
110             case 3:
111                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
112                 break;
113         }
114 
115         if (isExpected) {
116             if (curr == JVMTI_EVENT_FIELD_MODIFICATION ||
117                                 curr == JVMTI_EVENT_FIELD_ACCESS) {
118                 if (currentCounts[i] != NUMBER_OF_INVOCATIONS) {
119                     NSK_COMPLAIN3(&quot;Unexpected number of %s events %d, expected value is %d\n&quot;,
120                                         TranslateEvent(curr),
121                                         currentCounts[i],
122                                         NUMBER_OF_INVOCATIONS);
<span class="line-modified">123                     result = NSK_FALSE;</span>
124                 }
125             } else {
126                 if (currentCounts[i] &lt; 1) {
127                         NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
128                                             currentCounts[i],
129                                             TranslateEvent(curr));
<span class="line-modified">130                     result = NSK_FALSE;</span>
131                 }
132             }
133 
134         } else {
135 
136             if (currentCounts[i] &gt; 0) {
137                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
138                                     TranslateEvent(curr),
139                                     currentCounts[i]);
<span class="line-modified">140                 result = NSK_FALSE;</span>
141             }
142         }
143     }
144 
145     return result;
146 }
147 
148 static void
149 changeCount(jvmtiEvent event, int *currentCounts) {
150 
151     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
152         nsk_jvmti_setFailStatus();
153 
154     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
155 
156     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
157         nsk_jvmti_setFailStatus();
158 
159 }
160 
</pre>
<hr />
<pre>
316 void JNICALL
317 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
318     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
319 }
320 
321 void JNICALL
322 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
323 
324     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
325 }
326 
327 void JNICALL
328 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
329                     jobject object, jclass object_klass, jlong size) {
330 
331     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
332 }
333 
334 /* ============================================================================= */
335 
<span class="line-modified">336 static int enableEvent(jvmtiEvent event) {</span>
337 
338     if (nsk_jvmti_isOptionalEvent(event)
339             &amp;&amp; (event != JVMTI_EVENT_FIELD_MODIFICATION)
340             &amp;&amp; (event != JVMTI_EVENT_FIELD_ACCESS)) {
341         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
342                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
343             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
344                 TranslateEvent(event));
<span class="line-modified">345             return NSK_FALSE;</span>
346         }
347     } else {
348         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
349             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
350                 TranslateEvent(event));
<span class="line-modified">351             return NSK_FALSE;</span>
352         }
353     }
354 
<span class="line-modified">355     return NSK_TRUE;</span>
356 }
357 
358 /**
359  * Enable or disable tested events.
360  */
<span class="line-modified">361 static int enableEventList() {</span>
362 
363     int i, result;
364 
365     result = enableEvent(JVMTI_EVENT_VM_INIT);
366 
367     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
368 
369     /* enabling optional events */
370     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
371         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
372 
373         if (nsk_jvmti_isOptionalEvent(event))
374             result = result &amp;&amp; enableEvent(event);
375     }
376 
<span class="line-modified">377     if (result == NSK_FALSE) {</span>
378         nsk_jvmti_setFailStatus();
<span class="line-modified">379         return NSK_FALSE;</span>
380     }
381 
<span class="line-modified">382     return NSK_TRUE;</span>
383 }
384 
385 /* ============================================================================= */
386 
<span class="line-modified">387 static int</span>
<span class="line-removed">388 setCallBacks(int step) {</span>
389 
390     int i;
391 
392     jvmtiEventCallbacks eventCallbacks;
393     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
394 
395     switch (step) {
396         case 1:
397             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
398                 eventCount[i] = 0;
399             }
400 
401             eventCallbacks.VMInit                    = cbVMInit;
402             eventCallbacks.Exception                 = cbException;
403             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
404             eventCallbacks.SingleStep                = cbSingleStep;
405             eventCallbacks.FramePop                  = cbFramePop;
406             eventCallbacks.Breakpoint                = cbBreakpoint;
407             eventCallbacks.FieldAccess               = cbFieldAccess;
408             eventCallbacks.FieldModification         = cbFieldModification;
</pre>
<hr />
<pre>
423 
424         case 2:
425             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
426                 newEventCount[i] = 0;
427             }
428 
429             eventCallbacks.FieldAccess               = cbNewFieldAccess;
430             eventCallbacks.FieldModification         = cbNewFieldModification;
431             break;
432 
433         case 3:
434             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
435                 newEventCount[i] = 0;
436             }
437 
438             eventCallbacks.VMDeath                   = cbVMDeath;
439             break;
440 
441     }
442     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">443         return NSK_FALSE;</span>
444 
<span class="line-modified">445     return NSK_TRUE;</span>
446 }
447 
448 /* ============================================================================= */
449 
450 /** Agent algorithm. */
451 static void JNICALL
452 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
453 

454     int i;
455     jfieldID field_accID, field_modID;
456     jclass cls;
457 
458 
459     if (!nsk_jvmti_waitForSync(timeout))
460         return;
461 
<span class="line-modified">462     cls = agentJNI-&gt;FindClass(CLASS_NAME);</span>
<span class="line-modified">463     if (!NSK_JNI_VERIFY(agentJNI, cls != NULL))</span>
<span class="line-modified">464         return;</span>
<span class="line-removed">465 </span>
<span class="line-removed">466     field_accID = agentJNI-&gt;GetStaticFieldID(cls, FIELD_ACC_NAME, &quot;I&quot;);</span>
<span class="line-removed">467     if (!NSK_JNI_VERIFY(agentJNI, field_accID != NULL))</span>
<span class="line-removed">468         return;</span>
<span class="line-removed">469 </span>
<span class="line-removed">470     field_modID = agentJNI-&gt;GetStaticFieldID(cls, FIELD_MOD_NAME, &quot;I&quot;);</span>
<span class="line-removed">471     if (!NSK_JNI_VERIFY(agentJNI, field_modID != NULL))</span>
<span class="line-removed">472         return;</span>
473 
474     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetFieldModificationWatch(cls, field_modID)))
475         return;
476 
477     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetFieldAccessWatch(cls, field_accID)))
478         return;
479 
480     if (!nsk_jvmti_resumeSync())
481         return;
482 
483     for (i = 1; i &lt;= STEP_NUMBER; i++) {
484 
485         if (!nsk_jvmti_waitForSync(timeout))
486             return;
487 
488         if (i &lt; STEP_NUMBER) {
489             showEventStatistics(i);
490             if (!checkEvents(i))
491                 nsk_jvmti_setFailStatus();
492 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
<span class="line-added"> 27 #include &quot;ExceptionCheckingJniEnv.hpp&quot;</span>
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 #include &quot;JVMTITools.h&quot;
 31 
 32 extern &quot;C&quot; {
 33 
 34 /* ============================================================================= */
 35 
 36 /* scaffold objects */
 37 static jvmtiEnv *jvmti = NULL;
 38 static jlong timeout = 0;
 39 static jrawMonitorID syncLock = NULL;
 40 
 41 /* constant names */
 42 #define STEP_NUMBER 3
 43 #define CLASS_NAME &quot;nsk/jvmti/scenarios/events/EM02/em02t010&quot;
 44 #define FIELD_ACC_NAME &quot;testedField_acc&quot;
 45 #define FIELD_MOD_NAME &quot;testedField_mod&quot;
 46 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 47 #define NUMBER_OF_INVOCATIONS 1000
</pre>
<hr />
<pre>
 56     int i;
 57     const char* str;
 58     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 59 
 60     NSK_DISPLAY0(&quot;\n&quot;);
 61     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 62     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 63     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 64         if (currentCounts[i] &gt; 0) {
 65             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 66             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 67         }
 68     }
 69 }
 70 
 71 /* ========================================================================== */
 72 
 73 int checkEvents(int step) {
 74     int i;
 75     jvmtiEvent curr;
<span class="line-modified"> 76     bool result = true;</span>
 77     int *currentCounts;
 78     int isExpected = 0;
 79 
 80     switch (step) {
 81         case 1:
 82             currentCounts = &amp;eventCount[0];
 83             break;
 84 
 85         case 2:
 86         case 3:
 87             currentCounts = &amp;newEventCount[0];
 88             break;
 89 
 90         default:
 91             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified"> 92             return false;</span>
 93     }
 94 
 95     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 96 
 97         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 98 
 99         switch (step) {
100             case 1:
101                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
102                                 || (curr == JVMTI_EVENT_FIELD_MODIFICATION)
103                                 || (curr == JVMTI_EVENT_FIELD_ACCESS));
104                 break;
105 
106             case 2:
107                 isExpected = ((curr == JVMTI_EVENT_FIELD_MODIFICATION)
108                                 || (curr == JVMTI_EVENT_FIELD_ACCESS));
109                 break;
110 
111             case 3:
112                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
113                 break;
114         }
115 
116         if (isExpected) {
117             if (curr == JVMTI_EVENT_FIELD_MODIFICATION ||
118                                 curr == JVMTI_EVENT_FIELD_ACCESS) {
119                 if (currentCounts[i] != NUMBER_OF_INVOCATIONS) {
120                     NSK_COMPLAIN3(&quot;Unexpected number of %s events %d, expected value is %d\n&quot;,
121                                         TranslateEvent(curr),
122                                         currentCounts[i],
123                                         NUMBER_OF_INVOCATIONS);
<span class="line-modified">124                     result = false;</span>
125                 }
126             } else {
127                 if (currentCounts[i] &lt; 1) {
128                         NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
129                                             currentCounts[i],
130                                             TranslateEvent(curr));
<span class="line-modified">131                     result = false;</span>
132                 }
133             }
134 
135         } else {
136 
137             if (currentCounts[i] &gt; 0) {
138                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
139                                     TranslateEvent(curr),
140                                     currentCounts[i]);
<span class="line-modified">141                 result = false;</span>
142             }
143         }
144     }
145 
146     return result;
147 }
148 
149 static void
150 changeCount(jvmtiEvent event, int *currentCounts) {
151 
152     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
153         nsk_jvmti_setFailStatus();
154 
155     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
156 
157     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
158         nsk_jvmti_setFailStatus();
159 
160 }
161 
</pre>
<hr />
<pre>
317 void JNICALL
318 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
319     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
320 }
321 
322 void JNICALL
323 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
324 
325     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
326 }
327 
328 void JNICALL
329 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
330                     jobject object, jclass object_klass, jlong size) {
331 
332     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
333 }
334 
335 /* ============================================================================= */
336 
<span class="line-modified">337 static bool enableEvent(jvmtiEvent event) {</span>
338 
339     if (nsk_jvmti_isOptionalEvent(event)
340             &amp;&amp; (event != JVMTI_EVENT_FIELD_MODIFICATION)
341             &amp;&amp; (event != JVMTI_EVENT_FIELD_ACCESS)) {
342         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
343                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
344             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
345                 TranslateEvent(event));
<span class="line-modified">346             return false;</span>
347         }
348     } else {
349         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
350             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
351                 TranslateEvent(event));
<span class="line-modified">352             return false;</span>
353         }
354     }
355 
<span class="line-modified">356     return true;</span>
357 }
358 
359 /**
360  * Enable or disable tested events.
361  */
<span class="line-modified">362 static bool enableEventList() {</span>
363 
364     int i, result;
365 
366     result = enableEvent(JVMTI_EVENT_VM_INIT);
367 
368     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
369 
370     /* enabling optional events */
371     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
372         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
373 
374         if (nsk_jvmti_isOptionalEvent(event))
375             result = result &amp;&amp; enableEvent(event);
376     }
377 
<span class="line-modified">378     if (!result) {</span>
379         nsk_jvmti_setFailStatus();
<span class="line-modified">380         return false;</span>
381     }
382 
<span class="line-modified">383     return true;</span>
384 }
385 
386 /* ============================================================================= */
387 
<span class="line-modified">388 static bool setCallBacks(int step) {</span>

389 
390     int i;
391 
392     jvmtiEventCallbacks eventCallbacks;
393     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
394 
395     switch (step) {
396         case 1:
397             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
398                 eventCount[i] = 0;
399             }
400 
401             eventCallbacks.VMInit                    = cbVMInit;
402             eventCallbacks.Exception                 = cbException;
403             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
404             eventCallbacks.SingleStep                = cbSingleStep;
405             eventCallbacks.FramePop                  = cbFramePop;
406             eventCallbacks.Breakpoint                = cbBreakpoint;
407             eventCallbacks.FieldAccess               = cbFieldAccess;
408             eventCallbacks.FieldModification         = cbFieldModification;
</pre>
<hr />
<pre>
423 
424         case 2:
425             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
426                 newEventCount[i] = 0;
427             }
428 
429             eventCallbacks.FieldAccess               = cbNewFieldAccess;
430             eventCallbacks.FieldModification         = cbNewFieldModification;
431             break;
432 
433         case 3:
434             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
435                 newEventCount[i] = 0;
436             }
437 
438             eventCallbacks.VMDeath                   = cbVMDeath;
439             break;
440 
441     }
442     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">443         return false;</span>
444 
<span class="line-modified">445     return true;</span>
446 }
447 
448 /* ============================================================================= */
449 
450 /** Agent algorithm. */
451 static void JNICALL
452 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
453 
<span class="line-added">454     ExceptionCheckingJniEnvPtr ec_jni(agentJNI);</span>
455     int i;
456     jfieldID field_accID, field_modID;
457     jclass cls;
458 
459 
460     if (!nsk_jvmti_waitForSync(timeout))
461         return;
462 
<span class="line-modified">463     cls = ec_jni-&gt;FindClass(CLASS_NAME, TRACE_JNI_CALL);</span>
<span class="line-modified">464     field_accID = ec_jni-&gt;GetStaticFieldID(cls, FIELD_ACC_NAME, &quot;I&quot;, TRACE_JNI_CALL);</span>
<span class="line-modified">465     field_modID = ec_jni-&gt;GetStaticFieldID(cls, FIELD_MOD_NAME, &quot;I&quot;, TRACE_JNI_CALL);</span>








466 
467     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetFieldModificationWatch(cls, field_modID)))
468         return;
469 
470     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetFieldAccessWatch(cls, field_accID)))
471         return;
472 
473     if (!nsk_jvmti_resumeSync())
474         return;
475 
476     for (i = 1; i &lt;= STEP_NUMBER; i++) {
477 
478         if (!nsk_jvmti_waitForSync(timeout))
479             return;
480 
481         if (i &lt; STEP_NUMBER) {
482             showEventStatistics(i);
483             if (!checkEvents(i))
484                 nsk_jvmti_setFailStatus();
485 
</pre>
</td>
</tr>
</table>
<center><a href="../em02t009/em02t009.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="libem02t010.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/extension/EX03/ex03t001/ex03t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 static JNIEnv *jni = NULL;
 33 static jvmtiEnv* jvmti = NULL;
 34 static jlong timeout = 0;
 35 static jboolean eventEnabled = JNI_FALSE;
 36 static volatile jboolean eventReceived1 = JNI_FALSE, eventReceived2 = JNI_FALSE;
 37 static jclass checkedClass;
 38 static jrawMonitorID eventMon;
 39 
 40 
 41 /* ============================================================================= */
 42 
 43 static void JNICALL
<a name="2" id="anc2"></a><span class="line-modified"> 44 ClassUnload(jvmtiEnv* jvmti_env, JNIEnv* jni_env, const char* name, ...) {</span>
<span class="line-modified"> 45     // The name argument should never be null</span>
<span class="line-modified"> 46     if (name == NULL) {</span>





 47         nsk_jvmti_setFailStatus();
<a name="3" id="anc3"></a><span class="line-modified"> 48         NSK_COMPLAIN0(&quot;ClassUnload: &#39;name&#39; input parameter is NULL.\n&quot;);</span>
<span class="line-modified"> 49     } else {</span>
<span class="line-added"> 50         NSK_DISPLAY1(&quot;Class unloaded %s\n&quot;, name);</span>
 51     }
<a name="4" id="anc4"></a><span class="line-added"> 52 </span>
 53     NSK_DISPLAY0(&quot;Received ClassUnload event.\n&quot;);
 54     if (eventEnabled == JNI_TRUE) {
 55         eventReceived1 = JNI_TRUE;
 56     } else {
 57         eventReceived2 = JNI_TRUE;
 58     }
 59 
 60     /* Notify main agent thread */
 61     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(eventMon))) {
 62         nsk_jvmti_setFailStatus();
 63     }
 64     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorNotify(eventMon))) {
 65         nsk_jvmti_setFailStatus();
 66     }
 67     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(eventMon))) {
 68         nsk_jvmti_setFailStatus();
 69     }
 70 }
 71 
 72 jboolean isClassUnloadingEnabled() {
 73     jint extCount, i;
 74     jvmtiExtensionFunctionInfo* extList;
 75     jboolean found = JNI_FALSE;
 76     jboolean enabled = JNI_FALSE;
 77     jvmtiError err;
 78 
 79     NSK_DISPLAY0(&quot;Get extension functions list\n&quot;);
 80 
 81     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetExtensionFunctions(&amp;extCount, &amp;extList))) {
 82         nsk_jvmti_setFailStatus();
 83         return JNI_FALSE;
 84     }
 85 
 86     for (i = 0; i &lt; extCount; i++) {
 87         if (strcmp(extList[i].id, (char*)&quot;com.sun.hotspot.functions.IsClassUnloadingEnabled&quot;) == 0) {
 88             found = JNI_TRUE;
 89 
 90             err = (*extList[i].func)(jvmti, &amp;enabled);
 91             if (err != JVMTI_ERROR_NONE) {
 92                 NSK_COMPLAIN1(&quot;Error during invocation of IsClassUnloadingEnabled function: %d\n&quot;, err);
 93                 nsk_jvmti_setFailStatus();
 94                 return JNI_FALSE;
 95             }
 96         }
 97     }
 98     if (found == JNI_FALSE) {
 99         NSK_COMPLAIN0(&quot;IsClassUnloadingEnabled was not found among extension functions.\n&quot;);
100         nsk_jvmti_setFailStatus();
101         return JNI_FALSE;
102     }
103 
104     return enabled;
105 }
106 
<a name="5" id="anc5"></a><span class="line-added">107 jboolean checkParams(jvmtiExtensionEventInfo event) {</span>
<span class="line-added">108     // Check parameters are:</span>
<span class="line-added">109     // JNIEnv *jni_env, const char* name</span>
<span class="line-added">110     if (event.param_count != 2 ||</span>
<span class="line-added">111           event.params[0].kind != JVMTI_KIND_IN_PTR ||</span>
<span class="line-added">112           event.params[0].base_type != JVMTI_TYPE_JNIENV ||</span>
<span class="line-added">113           event.params[1].kind != JVMTI_KIND_IN_PTR ||</span>
<span class="line-added">114           event.params[1].base_type != JVMTI_TYPE_CCHAR) {</span>
<span class="line-added">115         return JNI_FALSE;</span>
<span class="line-added">116     } else {</span>
<span class="line-added">117         return JNI_TRUE;</span>
<span class="line-added">118     }</span>
<span class="line-added">119 }</span>
<span class="line-added">120 </span>
121 jboolean enableClassUnloadEvent (jboolean enable) {
122     jint extCount, i;
123     jvmtiExtensionEventInfo* extList;
124     jboolean found = JNI_FALSE;
125 
126     NSK_DISPLAY0(&quot;Get extension events list\n&quot;);
127     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetExtensionEvents(&amp;extCount, &amp;extList))) {
128         nsk_jvmti_setFailStatus();
129         return JNI_FALSE;
130     }
131 
132     for (i = 0; i &lt; extCount; i++) {
133         if (strcmp(extList[i].id, (char*)&quot;com.sun.hotspot.events.ClassUnload&quot;) == 0) {
134             found = JNI_TRUE;
135 
<a name="6" id="anc6"></a><span class="line-added">136             NSK_DISPLAY1(&quot;%s&quot;, extList[i].short_description);</span>
<span class="line-added">137 </span>
<span class="line-added">138             if (!checkParams(extList[i])) {</span>
<span class="line-added">139                 NSK_COMPLAIN0(&quot;ClassUnload event has wrong parameters.&quot;);</span>
<span class="line-added">140                 nsk_jvmti_setFailStatus();</span>
<span class="line-added">141                 return JNI_FALSE;</span>
<span class="line-added">142             }</span>
<span class="line-added">143 </span>
144             if (!NSK_JVMTI_VERIFY(
145                     jvmti-&gt;SetExtensionEventCallback(extList[i].extension_event_index,
146                                                      enable ? (jvmtiExtensionEvent)ClassUnload : NULL))) {
147                 nsk_jvmti_setFailStatus();
148                 return JNI_FALSE;
149             }
150             eventEnabled = enable;
151             if (enable == JNI_TRUE) {
152                 NSK_DISPLAY1(&quot;%s callback enabled\n&quot;, extList[i].id);
153             } else {
154                 NSK_DISPLAY1(&quot;%s callback disabled\n&quot;, extList[i].id);
155             }
156         }
157     }
158     if (found == JNI_FALSE) {
159         NSK_COMPLAIN0(&quot;ClassUnload event was not found among extension events.\n&quot;);
160         nsk_jvmti_setFailStatus();
161         return JNI_FALSE;
162     }
163     return JNI_TRUE;
164 }
165 
166 
167 /* ============================================================================= */
168 
169 /** Agent algorithm. */
170 static void JNICALL
171 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
172     do {
173         if (isClassUnloadingEnabled() == JNI_FALSE) {
174             NSK_COMPLAIN0(&quot;ClassUnloadingEnabled returned false.\n&quot;);
175             nsk_jvmti_setFailStatus();
176         }
177 
178         NSK_DISPLAY0(&quot;Wait for loading of ex03t001a class.\n&quot;);
179         if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout)))
180             return;
181 
182         if (enableClassUnloadEvent(JNI_TRUE) == JNI_FALSE) {
183             NSK_COMPLAIN0(&quot;Cannot set up ClassUnload event callback.\n&quot;);
184             break;
185         }
186 
187         NSK_DISPLAY0(&quot;Let debugee to unload ex03t001a class.\n&quot;);
188         if (!NSK_VERIFY(nsk_jvmti_resumeSync()))
189             break;
190 
191         /* Wait for notifying from event&#39;s thread */
192         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(eventMon))) {
193             nsk_jvmti_setFailStatus();
194         }
195         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorWait(eventMon, timeout))) {
196             nsk_jvmti_setFailStatus();
197         }
198         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(eventMon))) {
199             nsk_jvmti_setFailStatus();
200         }
201 
202         NSK_DISPLAY0(&quot;Wait for loading of ex03t001b class.\n&quot;);
203         if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout)))
204             return;
205 
206         if (enableClassUnloadEvent(JNI_FALSE) == JNI_FALSE) {
207             NSK_COMPLAIN0(&quot;Cannot set off ClassUnload event callback.\n&quot;);
208             break;
209         }
210 
211         NSK_DISPLAY0(&quot;Let debugee to unload ex03t001b class.\n&quot;);
212         if (!NSK_VERIFY(nsk_jvmti_resumeSync()))
213             return;
214 
215         /* Wait during 10 secs for notifying from event&#39;s thread */
216         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(eventMon))) {
217             nsk_jvmti_setFailStatus();
218         }
219         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorWait(eventMon, 10000))) {
220             nsk_jvmti_setFailStatus();
221         }
222         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(eventMon))) {
223             nsk_jvmti_setFailStatus();
224         }
225 
226         if (eventReceived1 == JNI_FALSE) {
227             nsk_jvmti_setFailStatus();
228             NSK_COMPLAIN0(&quot;Expected ClassUnload event was not received.\n&quot;);
229         }
230 
231         if (eventReceived2 == JNI_TRUE) {
232             nsk_jvmti_setFailStatus();
233             NSK_COMPLAIN0(&quot;Received unexpected ClassUnload event.\n&quot;);
234         }
235 
236         if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout)))
237             return;
238 
239     } while (0);
240 
241     NSK_TRACE(jvmti-&gt;DestroyRawMonitor(eventMon));
242 
243     NSK_DISPLAY0(&quot;Let debugee to finish\n&quot;);
244     if (!NSK_VERIFY(nsk_jvmti_resumeSync()))
245         return;
246 }
247 
248 /* ============================================================================= */
249 
250 /** Agent library initialization. */
251 #ifdef STATIC_BUILD
252 JNIEXPORT jint JNICALL Agent_OnLoad_ex03t001(JavaVM *jvm, char *options, void *reserved) {
253     return Agent_Initialize(jvm, options, reserved);
254 }
255 JNIEXPORT jint JNICALL Agent_OnAttach_ex03t001(JavaVM *jvm, char *options, void *reserved) {
256     return Agent_Initialize(jvm, options, reserved);
257 }
258 JNIEXPORT jint JNI_OnLoad_ex03t001(JavaVM *jvm, char *options, void *reserved) {
259     return JNI_VERSION_1_8;
260 }
261 #endif
262 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
263 
264     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
265         return JNI_ERR;
266 
267     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
268 
269     if (!NSK_VERIFY((jvmti =
270             nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))
271         return JNI_ERR;
272 
273     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;eventMon&quot;, &amp;eventMon))) {
274         return JNI_ERR;
275     }
276 
277     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
278         return JNI_ERR;
279 
280     return JNI_OK;
281 }
282 
283 /* ============================================================================= */
284 
285 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
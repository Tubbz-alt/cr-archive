<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/extension/EX03/ex03t001/ex03t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 static JNIEnv *jni = NULL;
 33 static jvmtiEnv* jvmti = NULL;
 34 static jlong timeout = 0;
 35 static jboolean eventEnabled = JNI_FALSE;
 36 static volatile jboolean eventReceived1 = JNI_FALSE, eventReceived2 = JNI_FALSE;
 37 static jclass checkedClass;
 38 static jrawMonitorID eventMon;
 39 
 40 
 41 /* ============================================================================= */
 42 
 43 static void JNICALL
 44 ClassUnload(jvmtiEnv* jvmti_env, JNIEnv *jni_env, jthread thread, jclass klass, ...) {
 45     /*
 46      * With the CMS GC the event can be posted on
 47      * a ConcurrentGC thread that is not a JavaThread.
 48      * In this case the thread argument can be NULL, so that,
 49      * we should not expect the thread argument to be non-NULL.
 50      */
 51     if (klass == NULL) {
 52         nsk_jvmti_setFailStatus();
 53         NSK_COMPLAIN0(&quot;ClassUnload: &#39;klass&#39; input parameter is NULL.\n&quot;);
 54 
 55     }
 56     NSK_DISPLAY0(&quot;Received ClassUnload event.\n&quot;);
 57     if (eventEnabled == JNI_TRUE) {
 58         eventReceived1 = JNI_TRUE;
 59     } else {
 60         eventReceived2 = JNI_TRUE;
 61     }
 62 
 63     /* Notify main agent thread */
 64     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(eventMon))) {
 65         nsk_jvmti_setFailStatus();
 66     }
 67     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorNotify(eventMon))) {
 68         nsk_jvmti_setFailStatus();
 69     }
 70     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(eventMon))) {
 71         nsk_jvmti_setFailStatus();
 72     }
 73 }
 74 
 75 jboolean isClassUnloadingEnabled() {
 76     jint extCount, i;
 77     jvmtiExtensionFunctionInfo* extList;
 78     jboolean found = JNI_FALSE;
 79     jboolean enabled = JNI_FALSE;
 80     jvmtiError err;
 81 
 82     NSK_DISPLAY0(&quot;Get extension functions list\n&quot;);
 83 
 84     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetExtensionFunctions(&amp;extCount, &amp;extList))) {
 85         nsk_jvmti_setFailStatus();
 86         return JNI_FALSE;
 87     }
 88 
 89     for (i = 0; i &lt; extCount; i++) {
 90         if (strcmp(extList[i].id, (char*)&quot;com.sun.hotspot.functions.IsClassUnloadingEnabled&quot;) == 0) {
 91             found = JNI_TRUE;
 92 
 93             err = (*extList[i].func)(jvmti, &amp;enabled);
 94             if (err != JVMTI_ERROR_NONE) {
 95                 NSK_COMPLAIN1(&quot;Error during invocation of IsClassUnloadingEnabled function: %d\n&quot;, err);
 96                 nsk_jvmti_setFailStatus();
 97                 return JNI_FALSE;
 98             }
 99         }
100     }
101     if (found == JNI_FALSE) {
102         NSK_COMPLAIN0(&quot;IsClassUnloadingEnabled was not found among extension functions.\n&quot;);
103         nsk_jvmti_setFailStatus();
104         return JNI_FALSE;
105     }
106 
107     return enabled;
108 }
109 
110 jboolean enableClassUnloadEvent (jboolean enable) {
111     jint extCount, i;
112     jvmtiExtensionEventInfo* extList;
113     jboolean found = JNI_FALSE;
114 
115     NSK_DISPLAY0(&quot;Get extension events list\n&quot;);
116     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetExtensionEvents(&amp;extCount, &amp;extList))) {
117         nsk_jvmti_setFailStatus();
118         return JNI_FALSE;
119     }
120 
121     for (i = 0; i &lt; extCount; i++) {
122         if (strcmp(extList[i].id, (char*)&quot;com.sun.hotspot.events.ClassUnload&quot;) == 0) {
123             found = JNI_TRUE;
124 
125             if (!NSK_JVMTI_VERIFY(
126                     jvmti-&gt;SetExtensionEventCallback(extList[i].extension_event_index,
127                                                      enable ? (jvmtiExtensionEvent)ClassUnload : NULL))) {
128                 nsk_jvmti_setFailStatus();
129                 return JNI_FALSE;
130             }
131             eventEnabled = enable;
132             if (enable == JNI_TRUE) {
133                 NSK_DISPLAY1(&quot;%s callback enabled\n&quot;, extList[i].id);
134             } else {
135                 NSK_DISPLAY1(&quot;%s callback disabled\n&quot;, extList[i].id);
136             }
137         }
138     }
139     if (found == JNI_FALSE) {
140         NSK_COMPLAIN0(&quot;ClassUnload event was not found among extension events.\n&quot;);
141         nsk_jvmti_setFailStatus();
142         return JNI_FALSE;
143     }
144     return JNI_TRUE;
145 }
146 
147 
148 /* ============================================================================= */
149 
150 /** Agent algorithm. */
151 static void JNICALL
152 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
153     do {
154         if (isClassUnloadingEnabled() == JNI_FALSE) {
155             NSK_COMPLAIN0(&quot;ClassUnloadingEnabled returned false.\n&quot;);
156             nsk_jvmti_setFailStatus();
157         }
158 
159         NSK_DISPLAY0(&quot;Wait for loading of ex03t001a class.\n&quot;);
160         if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout)))
161             return;
162 
163         if (enableClassUnloadEvent(JNI_TRUE) == JNI_FALSE) {
164             NSK_COMPLAIN0(&quot;Cannot set up ClassUnload event callback.\n&quot;);
165             break;
166         }
167 
168         NSK_DISPLAY0(&quot;Let debugee to unload ex03t001a class.\n&quot;);
169         if (!NSK_VERIFY(nsk_jvmti_resumeSync()))
170             break;
171 
172         /* Wait for notifying from event&#39;s thread */
173         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(eventMon))) {
174             nsk_jvmti_setFailStatus();
175         }
176         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorWait(eventMon, timeout))) {
177             nsk_jvmti_setFailStatus();
178         }
179         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(eventMon))) {
180             nsk_jvmti_setFailStatus();
181         }
182 
183         NSK_DISPLAY0(&quot;Wait for loading of ex03t001b class.\n&quot;);
184         if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout)))
185             return;
186 
187         if (enableClassUnloadEvent(JNI_FALSE) == JNI_FALSE) {
188             NSK_COMPLAIN0(&quot;Cannot set off ClassUnload event callback.\n&quot;);
189             break;
190         }
191 
192         NSK_DISPLAY0(&quot;Let debugee to unload ex03t001b class.\n&quot;);
193         if (!NSK_VERIFY(nsk_jvmti_resumeSync()))
194             return;
195 
196         /* Wait during 10 secs for notifying from event&#39;s thread */
197         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(eventMon))) {
198             nsk_jvmti_setFailStatus();
199         }
200         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorWait(eventMon, 10000))) {
201             nsk_jvmti_setFailStatus();
202         }
203         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(eventMon))) {
204             nsk_jvmti_setFailStatus();
205         }
206 
207         if (eventReceived1 == JNI_FALSE) {
208             nsk_jvmti_setFailStatus();
209             NSK_COMPLAIN0(&quot;Expected ClassUnload event was not received.\n&quot;);
210         }
211 
212         if (eventReceived2 == JNI_TRUE) {
213             nsk_jvmti_setFailStatus();
214             NSK_COMPLAIN0(&quot;Received unexpected ClassUnload event.\n&quot;);
215         }
216 
217         if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout)))
218             return;
219 
220     } while (0);
221 
222     NSK_TRACE(jvmti-&gt;DestroyRawMonitor(eventMon));
223 
224     NSK_DISPLAY0(&quot;Let debugee to finish\n&quot;);
225     if (!NSK_VERIFY(nsk_jvmti_resumeSync()))
226         return;
227 }
228 
229 /* ============================================================================= */
230 
231 /** Agent library initialization. */
232 #ifdef STATIC_BUILD
233 JNIEXPORT jint JNICALL Agent_OnLoad_ex03t001(JavaVM *jvm, char *options, void *reserved) {
234     return Agent_Initialize(jvm, options, reserved);
235 }
236 JNIEXPORT jint JNICALL Agent_OnAttach_ex03t001(JavaVM *jvm, char *options, void *reserved) {
237     return Agent_Initialize(jvm, options, reserved);
238 }
239 JNIEXPORT jint JNI_OnLoad_ex03t001(JavaVM *jvm, char *options, void *reserved) {
240     return JNI_VERSION_1_8;
241 }
242 #endif
243 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
244 
245     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
246         return JNI_ERR;
247 
248     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
249 
250     if (!NSK_VERIFY((jvmti =
251             nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))
252         return JNI_ERR;
253 
254     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;eventMon&quot;, &amp;eventMon))) {
255         return JNI_ERR;
256     }
257 
258     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
259         return JNI_ERR;
260 
261     return JNI_OK;
262 }
263 
264 /* ============================================================================= */
265 
266 }
    </pre>
  </body>
</html>
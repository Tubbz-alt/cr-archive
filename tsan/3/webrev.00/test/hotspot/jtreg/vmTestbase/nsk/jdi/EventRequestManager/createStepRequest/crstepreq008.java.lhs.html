<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jdi/EventRequestManager/createStepRequest/crstepreq008.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.EventRequestManager.createStepRequest;
 25 
 26 import nsk.share.*;
 27 import nsk.share.jpda.*;
 28 import nsk.share.jdi.*;
 29 
 30 import com.sun.jdi.*;
 31 import com.sun.jdi.connect.*;
 32 import com.sun.jdi.request.*;
 33 import com.sun.jdi.event.*;
 34 import java.io.*;
 35 import java.util.*;
 36 
 37 /**
 38  */
 39 public class crstepreq008 {
 40 
 41     //----------------------------------------------------- immutable common fields
 42 
 43     static final int PASSED    = 0;
 44     static final int FAILED    = 2;
 45     static final int PASS_BASE = 95;
 46     static final int quit      = -1;
 47 
 48     private int instruction = 1;
 49     private int waitTime;
 50     private static int exitCode = PASSED;
 51 
 52     private ArgumentHandler     argHandler;
 53     private Log                 log;
 54     private Debugee             debuggee;
 55     private VirtualMachine      vm;
 56     private ReferenceType       debuggeeClass;
 57 
 58     private EventRequestManager eventRManager;
 59     private EventSet            eventSet;
 60     private EventIterator       eventIterator;
 61 
 62     //------------------------------------------------------ mutable common fields
 63 
 64     private final static String prefix = &quot;nsk.jdi.EventRequestManager.createStepRequest&quot;;
 65     private final static String className = &quot;.crstepreq008&quot;;
 66     private final static String debuggerName = prefix + className;
 67     private final static String debuggeeName = debuggerName + &quot;a&quot;;
 68     static final int lineForBreak = 62;
 69 
 70     //------------------------------------------------------ immutable common methods
 71 
 72     public static void main (String argv[]) {
 73         System.exit(run(argv, System.out) + PASS_BASE);
 74     }
 75 
 76     //------------------------------------------------------ test specific fields
 77 
 78     static final int maxCase = 4;
 79     static final String[] brakeMethods = {
 80         &quot;caseRun&quot;,
 81         &quot;m00&quot;,
 82         &quot;m02&quot;,
 83         &quot;m02&quot;
 84                                         };
 85     static final int[][] checkedLines = {
 86         { 152, 152, 152},
 87         { 174, 174, 174},
 88         { 182, 182, 183},
 89         { 183, 183, 183}
 90                                         };
 91 
 92     static final String debuggeeThreadName = prefix + &quot;.Thread0crstepreq008a&quot;;
 93 
 94     //------------------------------------------------------ mutable common methods
 95 
 96     public static int run (String argv[], PrintStream out) {
 97 
 98         int exitStatus = new crstepreq008().runThis(argv, out);
 99         System.out.println (exitStatus == PASSED ? &quot;TEST PASSED&quot; : &quot;TEST FAILED&quot;);
100         return exitCode;
101     }
102 
103     private int runThis(String argv[], PrintStream out) {
104 
105         argHandler = new ArgumentHandler(argv);
106         log = new Log(out, argHandler);
107         waitTime = argHandler.getWaitTime() * 60000;
108 
109         try {
110 
111             Binder binder = new Binder(argHandler, log);
112             debuggee = binder.bindToDebugee(debuggeeName);
113             debuggee.redirectStderr(log, &quot;&quot;);
114             eventRManager = debuggee.getEventRequestManager();
115 
116             vm = debuggee.VM();
117             eventRManager = vm.eventRequestManager();
118 
119             debuggeeClass = waitForDebuggeeClassPrepared();
120 
121             execTest();
122 
123             debuggee.resume();
124             getEventSet();
125             if (eventIterator.nextEvent() instanceof VMDeathEvent) {
126                 display(&quot;Waiting for the debuggee&#39;s finish...&quot;);
127                 debuggee.waitFor();
128 
129                 display(&quot;Getting the debuggee&#39;s exit status.&quot;);
130                 int status = debuggee.getStatus();
131                 if (status != (PASSED + PASS_BASE)) {
132                     complain(&quot;Debuggee returned UNEXPECTED exit status: &quot; + status);
133                     exitCode = Consts.TEST_FAILED;
134                 }
135             } else {
136                 throw new TestBug(&quot;Last event is not the VMDeathEvent&quot;);
137             }
138 
139         } catch (VMDisconnectedException e) {
140             exitCode = Consts.TEST_FAILED;
141             complain(&quot;The test cancelled due to VMDisconnectedException.&quot;);
142             e.printStackTrace(out);
143             display(&quot;Trying: vm.process().destroy();&quot;);
144             if (vm != null) {
145                 Process vmProcess = vm.process();
146                 if (vmProcess != null) {
147                     vmProcess.destroy();
148                 }
149             }
150 
151         } catch (Exception e) {
152             exitCode = Consts.TEST_FAILED;
153             complain(&quot;Unexpected Exception: &quot; + e.getMessage());
154             e.printStackTrace(out);
155             complain(&quot;The test has not finished normally. Forcing: vm.exit().&quot;);
156             if (vm != null) {
157                 vm.exit(PASSED + PASS_BASE);
158             }
159             debuggee.resume();
160             getEventSet();
161         }
162 
163         return exitCode;
164     }
165 
166     //--------------------------------------------------------- mutable common methods
167 
168     private void execTest() {
169         BreakpointRequest bpRequest = setBreakpoint( null,
170                                                      debuggeeClass,
171                                                      &quot;methodForCommunication&quot;,
172                                                      lineForBreak,
173                                                      &quot;breakForCommunication&quot;);
174         bpRequest.enable();
175 
176         StepRequest stepRequest = null;
177 
178         display(&quot;TESTING BEGINS&quot;);
179         for (int testCase = 0; testCase &lt; maxCase &amp;&amp; instruction != quit; testCase++) {
180 
181             instruction = getInstruction();
182             if (instruction == quit) {
183                 vm.resume();
184                 break;
185             }
186 
187             display(&quot;:: CASE # &quot; + testCase);
188             stepRequest = setStepRequest( bpRequest,
189                                           &quot;thread&quot; + testCase,
190                                           testCase,
191                                           &quot;stepRequest&quot; + testCase );
192 
193             checkStepEvent( stepRequest,
194                             &quot;thread&quot; + testCase,
195                             testCase );
196         }
197         display(&quot;TESTING ENDS&quot;);
198     }
199 
200     //--------------------------------------------------------- test specific methods
201 
202     private StepRequest setStepRequest ( BreakpointRequest bpRequest,
203                                          String threadName,
204                                          int testCase,
205                                          String property ) {
206         StepRequest stepRequest = null;
207         for (;;) {
208             display(&quot;Wait for initial brakepoint event in &quot; + threadName);
209             BreakpointEvent bpEvent = (BreakpointEvent)waitForEvent(bpRequest);
210 
211             // check location of breakpoint event
212             int lineOfEvent = ((LocatableEvent)bpEvent).location().lineNumber();
213             if (lineOfEvent != lineForBreak) {
214                 complain(&quot;Wrong line number of initial brakepoint event for &quot; + threadName);
215                 complain(&quot;\texpected value : &quot; + lineForBreak + &quot;; got one : &quot; + lineOfEvent);
216                 break;
217             }
218 
219             display(&quot;Getting mirror of thread: &quot; + threadName);
<a name="1" id="anc1"></a><span class="line-modified">220             ThreadReference thread = threadByName(threadName);</span>
221 
222             display(&quot;Getting ReferenceType of thread: &quot; + threadName);
223             ReferenceType debuggeeThread = debuggee.classByName(debuggeeThreadName);
224 
225             // set second breakpoint to suspend checked thread at the right location before
226             // setting step request
227             BreakpointRequest bpRequest1 = setBreakpoint( thread,
228                                                          debuggeeThread,
229                                                          brakeMethods[testCase],
230                                                          checkedLines[testCase][0],
231                                                          &quot;&quot;);
232             bpRequest1.addCountFilter(1);
233             bpRequest1.enable();
234 
235             display(&quot;Wait for additional brakepoint event in &quot; + threadName);
236             bpEvent = (BreakpointEvent)waitForEvent(bpRequest1);
237 
238             // check location of breakpoint event
239             lineOfEvent = ((LocatableEvent)bpEvent).location().lineNumber();
240             if (lineOfEvent != checkedLines[testCase][0]) {
241                 complain(&quot;Wrong line number of additional brakepoint event for &quot; + threadName);
242                 complain(&quot;\texpected value : &quot; + checkedLines[testCase][0] + &quot;; got one : &quot; + lineOfEvent);
243                 break;
244             }
245 
246             display(&quot;Setting a step request in  thread: &quot; + thread);
247             try {
248                 stepRequest = eventRManager.createStepRequest ( thread,
249                                                                 StepRequest.STEP_MIN,
250                                                                 StepRequest.STEP_OVER );
251                 stepRequest.putProperty(&quot;number&quot;, property);
252             } catch ( Exception e1 ) {
253                 complain(&quot;setStepRequest(): unexpected Exception while creating StepRequest: &quot; + e1);
254                 break;
255             }
256             break;
257         }
258         if (stepRequest == null) {
259             throw new Failure(&quot;setStepRequest(): StepRequest has not been set up.&quot;);
260         }
261         display(&quot;setStepRequest(): StepRequest has been set up.&quot;);
262         return stepRequest;
263     }
264 
265     private void checkStepEvent ( StepRequest stepRequest,
266                                   String threadName,
267                                   int testCase ) {
268         stepRequest.enable();
269 
270         display(&quot;waiting for first StepEvent in &quot; + threadName);
271         Event newEvent = waitForEvent(stepRequest);
272         display(&quot;got first StepEvent&quot;);
273 
274         display(&quot;CHECK1 for line location of first StepEvent.&quot;);
275         int lineOfEvent = ((LocatableEvent)newEvent).location().lineNumber();
276         if (lineOfEvent != checkedLines[testCase][1]) {
277             complain(&quot;CHECK1 for line location of first StepEvent FAILED for CASE # &quot; + testCase);
278             complain(&quot;\texpected value : &quot; + checkedLines[testCase][1] + &quot;; got one : &quot; + lineOfEvent);
279             exitCode = FAILED;
280         } else {
281             display(&quot;CHECK1 PASSED&quot;);
282         }
283 
284         display(&quot;waiting for second StepEvent in &quot; + threadName);
285         newEvent = waitForEvent(stepRequest);
286         display(&quot;got second StepEvent&quot;);
287 
288         display(&quot;CHECK2 for line location of second StepEvent.&quot;);
289         lineOfEvent = ((LocatableEvent)newEvent).location().lineNumber();
290         if (lineOfEvent != checkedLines[testCase][2]) {
291             complain(&quot;CHECK2 for line location of second StepEvent FAILED for CASE # &quot; + testCase);
292             complain(&quot;\texpected value : &quot; + checkedLines[testCase][2] + &quot;; got one : &quot; + lineOfEvent);
293             exitCode = FAILED;
294         } else {
295             display(&quot;CHECK2 PASSED&quot;);
296         }
297 
298         stepRequest.disable();
299         eventRManager.deleteEventRequest(stepRequest);
300         stepRequest = null;
301         display(&quot;request for StepEvent in &quot; + threadName + &quot; is deleted&quot;);
302     }
303 
304     //--------------------------------------------------------- immutable common methods
305 
306     void display(String msg) {
307         log.display(&quot;debugger &gt; &quot; + msg);
308     }
309 
310     void complain(String msg) {
311         log.complain(&quot;debugger FAILURE &gt; &quot; + msg);
312     }
313 
314    /**
315     * Sets up a breakpoint at given line number within a given method in a given class
316     * for a given thread.
317     *
318     * Returns a BreakpointRequest object in case of success, otherwise throws Failure.
319     */
320     private BreakpointRequest setBreakpoint ( ThreadReference thread,
321                                               ReferenceType testedClass,
322                                               String methodName,
323                                               int bpLine,
324                                               String property) {
325 
326         display(&quot;Setting a breakpoint in :&quot;);
327         display(&quot;  thread: &quot; + thread + &quot;; class: &quot; + testedClass +
328                 &quot;; method: &quot; + methodName + &quot;; line: &quot; + bpLine + &quot;; property: &quot; + property);
329 
330         List allLineLocations = null;
331         Location lineLocation = null;
332         BreakpointRequest breakpRequest = null;
333 
334         try {
335             Method  method  = (Method) testedClass.methodsByName(methodName).get(0);
336 
337             allLineLocations = method.allLineLocations();
338 
339             display(&quot;Getting location for breakpoint...&quot;);
340             Iterator locIterator = allLineLocations.iterator();
341             while (locIterator.hasNext()) {
342                 Location curLocation = (Location)locIterator.next();
343                 int curNumber = curLocation.lineNumber();
344                 if (curLocation.lineNumber() == bpLine) {
345                     lineLocation = curLocation;
346                     break;
347                 }
348             }
349             if (lineLocation == null) {
350                 throw new TestBug(&quot;Incorrect line number of methods&#39; location&quot;);
351             }
352 
353             try {
354                 breakpRequest = eventRManager.createBreakpointRequest(lineLocation);
355                 if (thread != null) {
356                     breakpRequest.addThreadFilter(thread);
357                 }
358                 breakpRequest.putProperty(&quot;number&quot;, property);
359             } catch ( Exception e1 ) {
360                 complain(&quot;setBreakpoint(): unexpected Exception while creating BreakpointRequest: &quot; + e1);
361                 breakpRequest = null;
362             }
363         } catch ( Exception e2 ) {
364             complain(&quot;setBreakpoint(): unexpected Exception while getting locations: &quot; + e2);
365             breakpRequest = null;
366         }
367 
368         if (breakpRequest == null) {
369             throw new Failure(&quot;setBreakpoint(): A breakpoint has not been set up.&quot;);
370         }
371 
372         display(&quot;setBreakpoint(): A breakpoint has been set up.&quot;);
373         return breakpRequest;
374     }
375 
376     private Event waitForEvent (EventRequest eventRequest) {
377         vm.resume();
378         Event resultEvent = null;
379         try {
380             eventSet = null;
381             eventIterator = null;
382             eventSet = vm.eventQueue().remove(waitTime);
383             if (eventSet == null) {
384                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
385             }
386             eventIterator = eventSet.eventIterator();
387             while (eventIterator.hasNext()) {
388                 Event curEvent = eventIterator.nextEvent();
389                 if (curEvent instanceof VMDisconnectEvent) {
390                     throw new Failure(&quot;Unexpected VMDisconnectEvent received.&quot;);
391                 } else {
392                     EventRequest evRequest = curEvent.request();
393                     if (evRequest != null &amp;&amp; evRequest.equals(eventRequest)) {
394                         display(&quot;Requested event received: &quot; + curEvent.toString() +
395                             &quot;; request property: &quot; + (String) curEvent.request().getProperty(&quot;number&quot;));
396                         resultEvent = curEvent;
397                         break;
398                     } else {
399                         throw new Failure(&quot;Unexpected event received: &quot; + curEvent.toString());
400                     }
401                 }
402             }
403         } catch (Exception e) {
404             throw new Failure(&quot;Unexpected exception while waiting for an event: &quot; + e);
405         }
406         return resultEvent;
407     }
408 
409     private Event waitForEvent () {
410         vm.resume();
411         Event resultEvent = null;
412         try {
413             eventSet = null;
414             eventIterator = null;
415             eventSet = vm.eventQueue().remove(waitTime);
416             if (eventSet == null) {
417                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
418             }
419             eventIterator = eventSet.eventIterator();
420             while (eventIterator.hasNext()) {
421                 resultEvent = eventIterator.nextEvent();
422                 if (resultEvent instanceof VMDisconnectEvent) {
423                     throw new Failure(&quot;Unexpected VMDisconnectEvent received.&quot;);
424                 }
425             }
426         } catch (Exception e) {
427             throw new Failure(&quot;Unexpected exception while waiting for an event: &quot; + e);
428         }
429         return resultEvent;
430     }
431 
432     private void getEventSet() {
433         try {
434             eventSet = vm.eventQueue().remove(waitTime);
435             if (eventSet == null) {
436                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
437             }
438             eventIterator = eventSet.eventIterator();
439         } catch (Exception e) {
440             throw new Failure(&quot;getEventSet(): Unexpected exception while waiting for an event: &quot; + e);
441         }
442     }
443 
<a name="2" id="anc2"></a><span class="line-removed">444 </span>
<span class="line-removed">445     private ThreadReference threadByName(String name) throws Failure{</span>
<span class="line-removed">446         List all = vm.allThreads();</span>
<span class="line-removed">447         ListIterator li = all.listIterator();</span>
<span class="line-removed">448 </span>
<span class="line-removed">449         while (li.hasNext()) {</span>
<span class="line-removed">450             ThreadReference thread = (ThreadReference) li.next();</span>
<span class="line-removed">451             if (thread.name().equals(name))</span>
<span class="line-removed">452                 return thread;</span>
<span class="line-removed">453         }</span>
<span class="line-removed">454         throw new Failure(&quot;Thread with searching for name is not found: &quot; + name);</span>
<span class="line-removed">455     }</span>
<span class="line-removed">456 </span>
457     private ReferenceType waitForDebuggeeClassPrepared () {
458         display(&quot;Creating request for ClassPrepareEvent for debuggee.&quot;);
459         ClassPrepareRequest cpRequest = eventRManager.createClassPrepareRequest();
460         cpRequest.addClassFilter(debuggeeName);
461         cpRequest.addCountFilter(1);
462         cpRequest.enable();
463 
464         ClassPrepareEvent event = (ClassPrepareEvent) waitForEvent(cpRequest);
465         cpRequest.disable();
466 
467         if (!event.referenceType().name().equals(debuggeeName)) {
468            throw new Failure(&quot;Unexpected class name for ClassPrepareEvent : &quot; + debuggeeClass.name());
469         }
470         return event.referenceType();
471     }
472 
473     private int getInstruction () {
474         if (debuggeeClass == null) {
475             throw new Failure(&quot;getInstruction() :: debuggeeClass reference is null&quot;);
476         }
477         return ((IntegerValue) (debuggeeClass.getValue(debuggeeClass.fieldByName(&quot;instruction&quot;)))).value();
478     }
479 
480     private void setInstruction (String instructionField) {
481         if (debuggeeClass == null) {
482             throw new Failure(&quot;getInstruction() :: debuggeeClass reference is null&quot;);
483         }
484         Field instrField = debuggeeClass.fieldByName(&quot;instruction&quot;);
485         IntegerValue instrValue = (IntegerValue) (debuggeeClass.getValue(debuggeeClass.fieldByName(instructionField)));
486         try {
487             ((ClassType)debuggeeClass).setValue(instrField, instrValue );
488         } catch (InvalidTypeException e1) {
489             throw new Failure(&quot;Caught unexpected InvalidTypeException while setting value &#39;&quot; + instructionField + &quot;&#39; for instruction field&quot;);
490         } catch (ClassNotLoadedException e2) {
491             throw new Failure(&quot;Caught unexpected ClassNotLoadedException while setting value &#39;&quot; + instructionField + &quot;&#39; for instruction field&quot;);
492         }
493     }
494 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
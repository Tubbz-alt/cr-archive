<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t005/em02t005.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* ============================================================================= */
 34 
 35 /* scaffold objects */
 36 static jvmtiEnv *jvmti = NULL;
 37 static jlong timeout = 0;
 38 static jrawMonitorID syncLock = NULL;
 39 
 40 /* constant names */
 41 #define STEP_NUMBER 3
 42 #define EXPECTED_CLASS_NAME &quot;Lnsk/jvmti/scenarios/events/EM02/em02t005a;&quot;
 43 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 44 #define NUMBER_OF_INVOCATIONS 1000
 45 
 46 static int eventCount[JVMTI_EVENT_COUNT];
 47 static int newEventCount[JVMTI_EVENT_COUNT];
 48 
 49 /* ============================================================================= */
 50 
 51 static void
 52 showEventStatistics(int step) {
 53     int i;
 54     const char* str;
 55     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 56 
 57     NSK_DISPLAY0(&quot;\n&quot;);
 58     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 59     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 60     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 61         if (currentCounts[i] &gt; 0) {
 62             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 63             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 64         }
 65     }
 66 }
 67 
 68 /* ========================================================================== */
 69 
 70 int checkEvents(int step) {
 71     int i;
 72     jvmtiEvent curr;
 73     int result = NSK_TRUE;
 74     int *currentCounts;
 75     int isExpected = 0;
 76 
 77     switch (step) {
 78         case 1:
 79             currentCounts = &amp;eventCount[0];
 80             break;
 81 
 82         case 2:
 83         case 3:
 84             currentCounts = &amp;newEventCount[0];
 85             break;
 86 
 87         default:
 88             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
 89             return NSK_FALSE;
 90     }
 91 
 92     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 93 
 94         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 95 
 96         switch (step) {
 97             case 1:
 98                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
 99                                 || (curr == JVMTI_EVENT_VM_OBJECT_ALLOC));
100                 break;
101 
102             case 2:
103                 isExpected = (curr == JVMTI_EVENT_VM_OBJECT_ALLOC);
104                 break;
105 
106             case 3:
107                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
108                 break;
109         }
110 
111         if (isExpected) {
112             if (currentCounts[i] &lt; 0) {
113                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be non-negative\n&quot;,
114                                         currentCounts[i],
115                                         TranslateEvent(curr));
116                 result = NSK_FALSE;
117             }
118 
119         } else {
120 
121             if (currentCounts[i] &gt; 0) {
122                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
123                                     TranslateEvent(curr),
124                                     currentCounts[i]);
125                 result = NSK_FALSE;
126             }
127         }
128     }
129 
130     return result;
131 }
132 
133 static void
134 changeCount(jvmtiEvent event, int *currentCounts) {
135 
136     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
137         nsk_jvmti_setFailStatus();
138 
139     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
140 
141     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
142         nsk_jvmti_setFailStatus();
143 
144 }
145 
146 /* ============================================================================= */
147 
148 /* callbacks */
149 JNIEXPORT void JNICALL
150 cbVMInit(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread) {
151     changeCount(JVMTI_EVENT_VM_INIT, &amp;eventCount[0]);
152 }
153 
154 JNIEXPORT void JNICALL
155 cbVMDeath(jvmtiEnv* jvmti, JNIEnv* jni_env) {
156     changeCount(JVMTI_EVENT_VM_DEATH, &amp;newEventCount[0]);
157     showEventStatistics(STEP_NUMBER);
158     if (!checkEvents(STEP_NUMBER))
159         nsk_jvmti_setFailStatus();
160 
161     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock)))
162         nsk_jvmti_setFailStatus();
163 
164 }
165 
166 void JNICALL
167 cbException(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
168                 jmethodID method, jlocation location, jobject exception,
169                 jmethodID catch_method, jlocation catch_location) {
170 
171     changeCount(JVMTI_EVENT_EXCEPTION, &amp;eventCount[0]);
172 }
173 
174 void JNICALL
175 cbExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
176                 jmethodID method, jlocation location, jobject exception) {
177 
178     changeCount(JVMTI_EVENT_EXCEPTION_CATCH, &amp;eventCount[0]);
179 }
180 
181 void JNICALL
182 cbSingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
183                 jmethodID method, jlocation location) {
184 
185     changeCount(JVMTI_EVENT_SINGLE_STEP, &amp;eventCount[0]);
186 }
187 
188 void JNICALL
189 cbFramePop(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
190                 jmethodID method, jboolean was_popped_by_exception) {
191     changeCount(JVMTI_EVENT_FRAME_POP, &amp;eventCount[0]);
192 }
193 
194 void JNICALL
195 cbBreakpoint(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
196                 jmethodID method, jlocation location) {
197     changeCount(JVMTI_EVENT_BREAKPOINT, &amp;eventCount[0]);
198 }
199 
200 void JNICALL
201 cbFieldAccess(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
202                 jmethodID method, jlocation location, jclass field_klass,
203                 jobject object, jfieldID field) {
204 
205     changeCount(JVMTI_EVENT_FIELD_ACCESS, &amp;eventCount[0]);
206 }
207 
208 void JNICALL
209 cbFieldModification(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
210                 jmethodID method, jlocation location, jclass field_klass,
211                 jobject object, jfieldID field, char signature_type,
212                 jvalue new_value) {
213 
214     changeCount(JVMTI_EVENT_FIELD_MODIFICATION, &amp;eventCount[0]);
215 }
216 
217 void JNICALL
218 cbMethodEntry(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
219                 jmethodID method) {
220 
221     changeCount(JVMTI_EVENT_METHOD_ENTRY, &amp;eventCount[0]);
222 }
223 
224 void JNICALL
225 cbMethodExit(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
226                 jmethodID method, jboolean was_popped_by_exception,
227                 jvalue return_value) {
228 
229     changeCount(JVMTI_EVENT_METHOD_EXIT, &amp;eventCount[0]);
230 }
231 
232 void JNICALL
233 cbNativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env,jthread thread,
234                 jmethodID method, void* address, void** new_address_ptr) {
235     changeCount(JVMTI_EVENT_NATIVE_METHOD_BIND, &amp;eventCount[0]);
236 }
237 
238 void JNICALL
239 cbMonitorWait(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
240                     jobject object, jlong tout) {
241 
242     changeCount(JVMTI_EVENT_MONITOR_WAIT, &amp;eventCount[0]);
243 }
244 
245 void JNICALL
246 cbMonitorWaited(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
247                     jobject object, jboolean timed_out) {
248 
249     changeCount(JVMTI_EVENT_MONITOR_WAITED, &amp;eventCount[0]);
250 }
251 
252 JNIEXPORT void JNICALL
253 cbMonitorContendedEnter(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread,
254                             jobject object) {
255 
256     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTER, &amp;eventCount[0]);
257 }
258 
259 void JNICALL
260 cbMonitorContendedEntered(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
261                             jobject object) {
262 
263     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, &amp;eventCount[0]);
264 }
265 
266 void JNICALL
267 cbCompiledMethodLoad(jvmtiEnv *jvmti_env, jmethodID method, jint code_size,
268                 const void* code_addr, jint map_length,
269                 const jvmtiAddrLocationMap* map, const void* compile_info) {
270     changeCount(JVMTI_EVENT_COMPILED_METHOD_LOAD, &amp;eventCount[0]);
271 }
272 
273 void JNICALL
274 cbCompiledMethodUnload(jvmtiEnv *jvmti_env, jmethodID method,
275                 const void* code_addr) {
276     changeCount(JVMTI_EVENT_COMPILED_METHOD_UNLOAD, &amp;eventCount[0]);
277 }
278 
279 void JNICALL
280 cbGarbageCollectionStart(jvmtiEnv *jvmti_env) {
281     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_START, &amp;eventCount[0]);
282 }
283 
284 void JNICALL
285 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
286     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
287 }
288 
289 void JNICALL
290 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
291 
292     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
293 }
294 
295 void JNICALL
296 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
297                     jobject object, jclass object_klass, jlong size) {
298 
299     char *sign_ptr;
300     char *gen_ptr;
301 
302     jvmtiPhase phase;
303 
304     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetClassSignature(object_klass, &amp;sign_ptr, &amp;gen_ptr))) {
305         nsk_jvmti_setFailStatus();
306         return;
307     }
308 
309     if (strcmp(sign_ptr, EXPECTED_CLASS_NAME) == 0) {
310         changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
311     }
312 
313     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetPhase(&amp;phase))) {
314         nsk_jvmti_setFailStatus();
315     }
316 
317     if (phase != JVMTI_PHASE_LIVE) {
318         NSK_COMPLAIN4(&quot;%25s was sent during %s(%d)\n\tclass: %s\n&quot;,
319                     TranslateEvent(JVMTI_EVENT_VM_OBJECT_ALLOC),
320                     TranslatePhase(phase),
321                     phase,
322                     sign_ptr);
323         nsk_jvmti_setFailStatus();
324     }
325 
326     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)sign_ptr))) {
327         nsk_jvmti_setFailStatus();
328     }
329     if (gen_ptr != NULL)
330         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)gen_ptr))) {
331             nsk_jvmti_setFailStatus();
332         }
333 }
334 
335 void JNICALL
336 cbNewVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
337                     jobject object, jclass object_klass, jlong size) {
338 
339     char *sign_ptr;
340     char *gen_ptr;
341 
342     jvmtiPhase phase;
343 
344     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetClassSignature(object_klass, &amp;sign_ptr, &amp;gen_ptr))) {
345         nsk_jvmti_setFailStatus();
346         return;
347     }
348 
349     if (strcmp(sign_ptr, EXPECTED_CLASS_NAME) == 0) {
350         changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;newEventCount[0]);
351     }
352 
353     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetPhase(&amp;phase))) {
354         nsk_jvmti_setFailStatus();
355     }
356 
357     if (phase != JVMTI_PHASE_LIVE) {
358         NSK_COMPLAIN4(&quot;%25s was sent during %s(%d)\n\tclass: %s\n&quot;,
359                     TranslateEvent(JVMTI_EVENT_VM_OBJECT_ALLOC),
360                     TranslatePhase(phase),
361                     phase,
362                     sign_ptr);
363         nsk_jvmti_setFailStatus();
364     }
365 
366     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)sign_ptr))) {
367         nsk_jvmti_setFailStatus();
368     }
369     if (gen_ptr != NULL)
370         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)gen_ptr))) {
371             nsk_jvmti_setFailStatus();
372         }
373 }
374 
375 /* ============================================================================= */
376 
377 static int enableEvent(jvmtiEvent event) {
378 
379     if (nsk_jvmti_isOptionalEvent(event)
380             &amp;&amp; (event != JVMTI_EVENT_VM_OBJECT_ALLOC)) {
381         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
382                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
383             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
384                 TranslateEvent(event));
385             return NSK_FALSE;
386         }
387     } else {
388         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
389             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
390                 TranslateEvent(event));
391             return NSK_FALSE;
392         }
393     }
394 
395     return NSK_TRUE;
396 }
397 
398 /**
399  * Enable or disable tested events.
400  */
401 static int enableEventList() {
402 
403     int i, result;
404 
405     result = enableEvent(JVMTI_EVENT_VM_INIT);
406 
407     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
408 
409     /* enabling optional events */
410     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
411         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
412 
413         if (nsk_jvmti_isOptionalEvent(event))
414             result = result &amp;&amp; enableEvent(event);
415     }
416 
417     if (result == NSK_FALSE) {
418         nsk_jvmti_setFailStatus();
419         return NSK_FALSE;
420     }
421 
422     return NSK_TRUE;
423 }
424 
425 /* ============================================================================= */
426 
427 static int
428 setCallBacks(int step) {
429 
430     int i;
431 
432     jvmtiEventCallbacks eventCallbacks;
433     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
434 
435     switch (step) {
436         case 1:
437             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
438                 eventCount[i] = 0;
439             }
440 
441             eventCallbacks.VMInit                    = cbVMInit;
442             eventCallbacks.Exception                 = cbException;
443             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
444             eventCallbacks.SingleStep                = cbSingleStep;
445             eventCallbacks.FramePop                  = cbFramePop;
446             eventCallbacks.Breakpoint                = cbBreakpoint;
447             eventCallbacks.FieldAccess               = cbFieldAccess;
448             eventCallbacks.FieldModification         = cbFieldModification;
449             eventCallbacks.MethodEntry               = cbMethodEntry;
450             eventCallbacks.MethodExit                = cbMethodExit;
451             eventCallbacks.NativeMethodBind          = cbNativeMethodBind;
452             eventCallbacks.CompiledMethodLoad        = cbCompiledMethodLoad;
453             eventCallbacks.CompiledMethodUnload      = cbCompiledMethodUnload;
454             eventCallbacks.MonitorWait               = cbMonitorWait;
455             eventCallbacks.MonitorWaited             = cbMonitorWaited;
456             eventCallbacks.MonitorContendedEnter     = cbMonitorContendedEnter;
457             eventCallbacks.MonitorContendedEntered   = cbMonitorContendedEntered;
458             eventCallbacks.GarbageCollectionStart    = cbGarbageCollectionStart;
459             eventCallbacks.GarbageCollectionFinish   = cbGarbageCollectionFinish;
460             eventCallbacks.ObjectFree                = cbObjectFree;
461             eventCallbacks.VMObjectAlloc             = cbVMObjectAlloc;
462             break;
463 
464         case 2:
465             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
466                 newEventCount[i] = 0;
467             }
468 
469             eventCallbacks.VMObjectAlloc             = cbNewVMObjectAlloc;
470             break;
471 
472         case 3:
473             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
474                 newEventCount[i] = 0;
475             }
476 
477             eventCallbacks.VMDeath                   = cbVMDeath;
478             break;
479 
480     }
481     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
482         return NSK_FALSE;
483 
484     return NSK_TRUE;
485 }
486 
487 /* ============================================================================= */
488 
489 /** Agent algorithm. */
490 static void JNICALL
491 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
492 
493     int i;
494 
495     for (i = 1; i &lt;= STEP_NUMBER; i++) {
496 
497         if (!nsk_jvmti_waitForSync(timeout))
498             return;
499 
500         if (i &lt; STEP_NUMBER) {
501             showEventStatistics(i);
502             if (!checkEvents(i))
503                 nsk_jvmti_setFailStatus();
504 
505             if (!setCallBacks(i + 1)) {
506                 return;
507             }
508         }
509 
510         if (!nsk_jvmti_resumeSync())
511             return;
512     }
513 
514 }
515 
516 /* ============================================================================= */
517 
518 /** Agent library initialization. */
519 #ifdef STATIC_BUILD
520 JNIEXPORT jint JNICALL Agent_OnLoad_em02t005(JavaVM *jvm, char *options, void *reserved) {
521     return Agent_Initialize(jvm, options, reserved);
522 }
523 JNIEXPORT jint JNICALL Agent_OnAttach_em02t005(JavaVM *jvm, char *options, void *reserved) {
524     return Agent_Initialize(jvm, options, reserved);
525 }
526 JNIEXPORT jint JNI_OnLoad_em02t005(JavaVM *jvm, char *options, void *reserved) {
527     return JNI_VERSION_1_8;
528 }
529 #endif
530 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
531 
532     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
533         return JNI_ERR;
534 
535     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
536 
537     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
538     if (!NSK_VERIFY(jvmti != NULL))
539         return JNI_ERR;
540 
541 
542     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock))) {
543         nsk_jvmti_setFailStatus();
544         return JNI_ERR;
545     }
546 
547     {
548         jvmtiCapabilities caps;
549         memset(&amp;caps, 0, sizeof(caps));
550 
551         caps.can_generate_vm_object_alloc_events = 1;
552         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
553             return JNI_ERR;
554     }
555 
556     if (!setCallBacks(1)) {
557         return JNI_ERR;
558     }
559 
560     if (!enableEventList()) {
561         return JNI_ERR;
562     }
563 
564     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
565         return JNI_ERR;
566 
567     return JNI_OK;
568 }
569 
570 /* ============================================================================= */
571 
572 
573 }
    </pre>
  </body>
</html>
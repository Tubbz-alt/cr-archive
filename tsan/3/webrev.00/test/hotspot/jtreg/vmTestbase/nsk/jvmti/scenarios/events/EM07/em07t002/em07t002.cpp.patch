diff a/test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM07/em07t002/em07t002.cpp b/test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM07/em07t002/em07t002.cpp
--- a/test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM07/em07t002/em07t002.cpp
+++ b/test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM07/em07t002/em07t002.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -42,10 +42,11 @@
 static int methodLoadCount = 0;
 static int methodUnloadCount = 0;
 
 #define NAME_LENGTH 50
 const void *plist = NULL;
+static volatile int callbacksEnabled = NSK_TRUE;
 
 typedef struct nsk_jvmti_CompiledMethodIDStruct {
     jmethodID method;
     const void* code_addr;
     char name[NAME_LENGTH];
@@ -61,12 +62,19 @@
                 const jvmtiAddrLocationMap* map, const void* compile_info) {
     char *name;
     char *sign;
     char *genc;
 
+    jvmti->RawMonitorEnter(syncLock);
+    if (!callbacksEnabled) {
+        jvmti->RawMonitorExit(syncLock);
+        return;
+    }
+
     if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &sign, &genc))) {
         nsk_jvmti_setFailStatus();
+        jvmti->RawMonitorExit(syncLock);
         return;
     }
 
     if (!strncmp(name,"javaMethod", 8)) {
         nsk_jvmti_CompiledMethod *rec =
@@ -103,42 +111,46 @@
     }
     if (genc != NULL)
         if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*)genc))) {
             nsk_jvmti_setFailStatus();
         }
+
+    jvmti->RawMonitorExit(syncLock);
+
 }
 
 void JNICALL
 cbCompiledMethodUnload(jvmtiEnv *jvmti_env, jmethodID method,
                 const void* code_addr) {
 
     nsk_jvmti_CompiledMethod *rec;
 
+    jvmti->RawMonitorEnter(syncLock);
+    if (!callbacksEnabled) {
+        jvmti->RawMonitorExit(syncLock);
+        return;
+    }
     int count = nsk_list_getCount(plist);
+
     int i;
 
     for (i = 0; i < count; i ++) {
         rec = (nsk_jvmti_CompiledMethod *)nsk_list_get(plist, i);
         if ((rec->code_addr == code_addr) && (rec->method == method)) {
             NSK_DISPLAY0(">>>JVMTI_EVENT_COMPILED_METHOD_UNLOAD received for\n");
             NSK_DISPLAY1("\t\tmethod: %s\n", rec->name);
 
-            if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorEnter(syncLock)))
-                nsk_jvmti_setFailStatus();
-
             methodUnloadCount++;
 
-            if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorExit(syncLock)))
-                nsk_jvmti_setFailStatus();
-
             free(rec);
             nsk_list_remove(plist, i);
+            jvmti->RawMonitorExit(syncLock);
             return;
         }
 
     }
-
+    jvmti->RawMonitorExit(syncLock);
 }
 
 /* ============================================================================= */
 
 static int
@@ -208,10 +220,13 @@
         NSK_DISPLAY0("Let debuggee to continue\n");
         if (!nsk_jvmti_resumeSync())
             return;
     }
 
+    jvmti->RawMonitorEnter(syncLock);
+    callbacksEnabled = NSK_FALSE;
+
     {
         int count = nsk_list_getCount(plist);
 
         while (count > 0) {
             free((void *)nsk_list_get(plist, 0));
@@ -219,10 +234,12 @@
             count = nsk_list_getCount(plist);
         }
 
     }
 
+    jvmti->RawMonitorExit(syncLock);
+
     if (!NSK_JVMTI_VERIFY(jvmti->DestroyRawMonitor(syncLock)))
         nsk_jvmti_setFailStatus();
 
 }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/hotswap/HS204/hs204t002/hs204t002.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 #include &lt;stdio.h&gt;
 24 #include &lt;jvmti.h&gt;
 25 #include &quot;agent_common.h&quot;
 26 #include &lt;jni.h&gt;
 27 #include &lt;string.h&gt;
 28 #include &quot;jvmti_tools.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 /*
 31  *1. Enable event ClassPrepare.
 32  *2. Upon occurrence of ClassPrepare, set a breakpoint in class static
 33  * initializer.
 34  *3. Upon reaching the breakpoint, redefine the class and pop
 35  *a currently executed frame of the static initializer.
 36 */
 37 extern &quot;C&quot; {
 38 #define FILE_NAME &quot;nsk/jvmti/scenarios/hotswap/HS204/hs204t002/MyThread&quot;
 39 
 40 #define SEARCH_NAME &quot;nsk/jvmti/scenarios/hotswap/HS204/hs204t002/MyThread&quot;
 41 #define CLASS_NAME &quot;Lnsk/jvmti/scenarios/hotswap/HS204/hs204t002/MyThread;&quot;
 42 #define METHOD_NAME &quot;&lt;init&gt;&quot;
 43 #define METHOD_SIGNATURE &quot;()V&quot;
 44 static jint redefineNumber;
 45 static jvmtiEnv * jvmti;
 46 
 47 JNIEXPORT void JNICALL
 48 callbackClassPrepare(jvmtiEnv *jvmti,
 49                                   JNIEnv* jni,
 50                                   jthread thread,
 51                                   jclass klass) {
 52     char * className;
 53     char * generic;
 54     redefineNumber=0;
 55     jvmti-&gt;GetClassSignature(klass, &amp;className, &amp;generic);
 56     /* printf(&quot;Agent::Class Name %s \n&quot;,className); */
 57     if ((strcmp(className, CLASS_NAME) == 0)) {
 58         jclass cls;
 59         cls = jni-&gt;FindClass(SEARCH_NAME);
 60         if (cls == NULL) {
 61             printf(&quot;Agent::CLS is null&quot;);
 62         } else {
 63             jmethodID method;
 64             method = jni-&gt;GetMethodID(cls, METHOD_NAME,METHOD_SIGNATURE);
 65             if (method == NULL) {
 66                 printf(&quot;Agent::Method is null &quot;);
 67             } else {
 68                 jlocation start;
 69                 jlocation end;
 70                 jvmtiError err ;
 71                 err=jvmti-&gt;GetMethodLocation(method, &amp;start, &amp;end);
 72                 if (err != JVMTI_ERROR_NONE) {
 73                     printf(&quot;Agent::Errors in finding start and end for the method \n&quot;);
 74                 } else {
 75                     printf(&quot;Agent Start = %&quot; LL &quot;d and end = %&quot; LL &quot;d \n&quot;, start , end);
 76                     printf(&quot;Agent::setting break points..&quot;);
 77                     err= jvmti-&gt;SetBreakpoint(method, start+1);
 78                     if (err == JVMTI_ERROR_DUPLICATE) {
 79                         printf(&quot;Agent::JVMTI_ERROR_DUPLICATE&quot;);
 80                     } else if (err == JVMTI_ERROR_INVALID_METHODID) {
 81                         printf(&quot;Agent::JVMTI_ERROR_INVALID_METHODID &quot;);
 82                     } else if (err == JVMTI_ERROR_INVALID_LOCATION) {
 83                         printf(&quot;Agent::JVMTI_ERROR_INVALID_LOCATION &quot;);
 84                     } else if (err == JVMTI_ERROR_NONE) {
 85                         printf(&quot;Agent::NO ERRORS &quot;);
 86                     } else {
 87                         printf(&quot;Agent::VERY VERY INVALID STATE &quot;);
 88                     }
 89                 }
 90             }
 91         }
 92     }
 93     return;
 94 }
 95 void JNICALL callbackBreakpoint(jvmtiEnv *jvmti_env,
 96         JNIEnv* jni,
 97         jthread thread,
 98         jmethodID method,
 99         jlocation loc) {
100     jclass cls;
101     char fileName[512];
102 
103     nsk_jvmti_getFileName(redefineNumber, FILE_NAME, fileName,
104                         sizeof(fileName)/sizeof(char));
105     cls = jni-&gt;FindClass(SEARCH_NAME);
106     printf(&quot;Agent::  Break Pont Reached..&quot;);
107     if (nsk_jvmti_redefineClass(jvmti, cls, fileName) == NSK_TRUE) {
108         nsk_printf(&quot;\nMyClass :: Successfully redefined..\n&quot;);
109     } else {
110         nsk_printf(&quot;\nMyClass :: Failed to redefine ..\n&quot;);
111     }
112 }
113 
114 
115 #ifdef STATIC_BUILD
116 JNIEXPORT jint JNICALL Agent_OnLoad_hs204t002(JavaVM *jvm, char *options, void *reserved) {
117     return Agent_Initialize(jvm, options, reserved);
118 }
119 JNIEXPORT jint JNICALL Agent_OnAttach_hs204t002(JavaVM *jvm, char *options, void *reserved) {
120     return Agent_Initialize(jvm, options, reserved);
121 }
122 JNIEXPORT jint JNI_OnLoad_hs204t002(JavaVM *jvm, char *options, void *reserved) {
123     return JNI_VERSION_1_8;
124 }
125 #endif
126 jint Agent_Initialize(JavaVM *vm, char *options, void *reserved) {
127 
128     jint rc ;
129     printf(&quot;Agent:: VM.. Started..\n&quot;);
130     rc=vm-&gt;GetEnv((void **)&amp;jvmti, JVMTI_VERSION_1_1);
131     if (rc != JNI_OK) {
132         printf(&quot;Agent:: Could not load JVMTI interface \n&quot;);
133         return JNI_ERR;
134     } else {
135         jvmtiCapabilities caps;
136         jvmtiEventCallbacks eventCallbacks;
137         memset(&amp;caps, 0, sizeof(caps));
138         if (!nsk_jvmti_parseOptions(options)) {
139             nsk_printf(&quot; NSK Failed to parse..&quot;);
140             return JNI_ERR;
141         }
142         /*
143            required to set a prepareClassLoad not required call
144            and setBreakPoint is required.
145            and redefine is required..
146          */
147         caps.can_redefine_classes = 1;
148         caps.can_generate_breakpoint_events=1;
149         caps.can_redefine_classes = 1;
150         jvmti-&gt;AddCapabilities(&amp;caps);
151         memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
152         eventCallbacks.ClassPrepare = callbackClassPrepare;
153         eventCallbacks.Breakpoint = callbackBreakpoint;
154         rc=jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks));
155 
156         if (rc != JVMTI_ERROR_NONE) {
157             printf(&quot;Agent:: Error occured while setting event call back \n&quot;);
158             return JNI_ERR;
159         }
160 
161         nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE , NULL);
162         nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_BREAKPOINT, NULL);
163     }
164     return JNI_OK;
165 }
166 
167 }
    </pre>
  </body>
</html>
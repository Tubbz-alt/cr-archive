<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/sampling/SP06/sp06t003/sp06t003.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 /* ============================================================================= */
 33 
 34 /* scaffold objects */
 35 static JNIEnv* jni = NULL;
 36 static jvmtiEnv *jvmti = NULL;
 37 static jlong timeout = 0;
 38 
 39 /* constants */
 40 #define THREADS_COUNT   6
 41 #define EVENTS_COUNT    2
 42 #define MAX_NAME_LENGTH 100
 43 #define MAX_STACK_SIZE  100
 44 
 45 /* tested events */
 46 static jvmtiEvent eventsList[EVENTS_COUNT] = {
 47     JVMTI_EVENT_COMPILED_METHOD_LOAD,
 48     JVMTI_EVENT_COMPILED_METHOD_UNLOAD
 49 };
 50 
 51 /* thread description structure */
 52 typedef struct {
 53     char threadName[MAX_NAME_LENGTH];
 54     char methodName[MAX_NAME_LENGTH];
 55     char methodSig[MAX_NAME_LENGTH];
 56     jthread thread;
 57     jclass cls;
 58     jmethodID method;
 59     jlocation location;
 60     int methodCompiled;
 61 } ThreadDesc;
 62 
 63 /* descriptions of tested threads */
 64 static ThreadDesc threadsDesc[THREADS_COUNT] = {
 65     { &quot;threadRunning&quot;, &quot;testedMethod&quot;, &quot;(ZI)V&quot;, NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },
 66     { &quot;threadEntering&quot;, &quot;testedMethod&quot;, &quot;(ZI)V&quot;, NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },
 67     { &quot;threadWaiting&quot;, &quot;testedMethod&quot;, &quot;(ZI)V&quot;, NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },
 68     { &quot;threadSleeping&quot;, &quot;testedMethod&quot;, &quot;(ZI)V&quot;, NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },
 69     { &quot;threadRunningInterrupted&quot;, &quot;testedMethod&quot;, &quot;(ZI)V&quot;, NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },
 70     { &quot;threadRunningNative&quot;, &quot;testedMethod&quot;, &quot;(ZI)V&quot;, NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE }
 71 };
 72 
 73 /* indexes of known threads */
 74 static const int interruptedThreadIndex = THREADS_COUNT - 2;
 75 static const int nativeThreadIndex = THREADS_COUNT - 1;
 76 
 77 /* ============================================================================= */
 78 
 79 /* testcase(s) */
 80 static int prepare();
 81 static int generateEvents();
 82 static int checkThreads(int suspended, const char* kind);
 83 static int suspendThreadsIndividually(int suspend);
 84 static int clean();
 85 
 86 /* ============================================================================= */
 87 
 88 /** Agent algorithm. */
 89 static void JNICALL
 90 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
 91     jni = agentJNI;
 92 
 93     NSK_DISPLAY0(&quot;Wait for debuggee to become ready\n&quot;);
 94     if (!nsk_jvmti_waitForSync(timeout))
 95         return;
 96 
 97     {
 98         NSK_DISPLAY0(&quot;Prepare data\n&quot;);
 99         if (!prepare()) {
100             nsk_jvmti_setFailStatus();
101             return;
102         }
103 
104         NSK_DISPLAY0(&quot;Generate missed events\n&quot;);
105         if (!generateEvents())
106             return;
107 
108         NSK_DISPLAY0(&quot;Testcase #1: check stack frames of not suspended threads\n&quot;);
109         if (!checkThreads(NSK_FALSE, &quot;not suspended&quot;))
110             return;
111 
112         NSK_DISPLAY0(&quot;Suspend each thread\n&quot;);
113         if (!suspendThreadsIndividually(NSK_TRUE))
114             return;
115 
116         NSK_DISPLAY0(&quot;Testcase #2: check stack frames of suspended threads\n&quot;);
117         if (!checkThreads(NSK_TRUE, &quot;suspended&quot;))
118             return;
119 
120         NSK_DISPLAY0(&quot;Resume each thread\n&quot;);
121         if (!suspendThreadsIndividually(NSK_FALSE))
122             return;
123 
124         NSK_DISPLAY0(&quot;Testcase #3: check stack frames of resumed threads\n&quot;);
125         if (!checkThreads(NSK_FALSE, &quot;resumed&quot;))
126             return;
127 
128         NSK_DISPLAY0(&quot;Clean data\n&quot;);
129         if (!clean()) {
130             nsk_jvmti_setFailStatus();
131             return;
132         }
133     }
134 
135     NSK_DISPLAY0(&quot;Let debuggee to finish\n&quot;);
136     if (!nsk_jvmti_resumeSync())
137         return;
138 }
139 
140 /* ============================================================================= */
141 
142 /**
143  * Generate missed events (COMPILED_METHOD_LOAD only).
144  */
145 static int generateEvents() {
146     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GenerateEvents(JVMTI_EVENT_COMPILED_METHOD_LOAD))) {
147         nsk_jvmti_setFailStatus();
148         return NSK_FALSE;
149     }
150     return NSK_TRUE;
151 }
152 
153 /**
154  * Prepare data.
155  *    - clean threads list
156  *    - get all live threads
157  *    - get threads name
158  *    - find tested threads
159  *    - make global refs
160  *    - enable events
161  */
162 static int prepare() {
163     jthread *allThreadsList = NULL;
164     jint allThreadsCount = 0;
165     int found = 0;
166     int i;
167 
168     NSK_DISPLAY1(&quot;Find tested threads: %d\n&quot;, THREADS_COUNT);
169 
170     /* clean threads list */
171     for (i = 0; i &lt; THREADS_COUNT; i++) {
172         threadsDesc[i].thread = (jthread)NULL;
173         threadsDesc[i].method = (jmethodID)NULL;
174         threadsDesc[i].location = NSK_JVMTI_INVALID_JLOCATION;
175         threadsDesc[i].methodCompiled = NSK_FALSE;
176     }
177 
178     /* get all live threads */
179     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetAllThreads(&amp;allThreadsCount, &amp;allThreadsList)))
180         return NSK_FALSE;
181 
182     if (!NSK_VERIFY(allThreadsCount &gt; 0 &amp;&amp; allThreadsList != NULL))
183         return NSK_FALSE;
184 
185     /* find tested threads */
186     for (i = 0; i &lt; allThreadsCount; i++) {
187         jvmtiThreadInfo threadInfo;
188 
189         if (!NSK_VERIFY(allThreadsList[i] != NULL))
190             return NSK_FALSE;
191 
192         if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetThreadInfo(allThreadsList[i], &amp;threadInfo)))
193             return NSK_FALSE;
194 
195         if (threadInfo.name != NULL) {
196             int j;
197 
198             for (j = 0; j &lt; THREADS_COUNT; j++) {
199                 if (strcmp(threadInfo.name, threadsDesc[j].threadName) == 0) {
200                     threadsDesc[j].thread = allThreadsList[i];
201                     NSK_DISPLAY3(&quot;    thread #%d (%s): 0x%p\n&quot;,
202                                             j, threadInfo.name, (void*)threadsDesc[j].thread);
203                 }
204             }
205         }
206     }
207 
208     /* deallocate all threads list */
209     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)allThreadsList)))
210         return NSK_FALSE;
211 
212     /* check if all tested threads found */
213     found = 0;
214     for (i = 0; i &lt; THREADS_COUNT; i++) {
215         if (threadsDesc[i].thread == NULL) {
216             NSK_COMPLAIN2(&quot;Not found tested thread #%d (%s)\n&quot;, i, threadsDesc[i].threadName);
217         } else {
218             found++;
219         }
220     }
221 
222     if (found &lt; THREADS_COUNT)
223         return NSK_FALSE;
224 
225     /* get threads class and frame method */
226     NSK_DISPLAY0(&quot;Find tested methods:\n&quot;);
227     for (i = 0; i &lt; THREADS_COUNT; i++) {
228 
229         if (!NSK_JNI_VERIFY(jni, (threadsDesc[i].cls =
230                 jni-&gt;GetObjectClass(threadsDesc[i].thread)) != NULL))
231             return NSK_FALSE;
232 
233         if (!NSK_JNI_VERIFY(jni, (threadsDesc[i].method =
234                 jni-&gt;GetMethodID(threadsDesc[i].cls, threadsDesc[i].methodName, threadsDesc[i].methodSig)) != NULL))
235             return NSK_FALSE;
236 
237         NSK_DISPLAY4(&quot;    thread #%d (%s): 0x%p (%s)\n&quot;,
238                                 i, threadsDesc[i].threadName,
239                                 (void*)threadsDesc[i].method,
240                                 threadsDesc[i].methodName);
241     }
242 
243     /* make global refs */
244     for (i = 0; i &lt; THREADS_COUNT; i++) {
245         if (!NSK_JNI_VERIFY(jni, (threadsDesc[i].thread = (jthread)
246                 jni-&gt;NewGlobalRef(threadsDesc[i].thread)) != NULL))
247             return NSK_FALSE;
248         if (!NSK_JNI_VERIFY(jni, (threadsDesc[i].cls = (jclass)
249                 jni-&gt;NewGlobalRef(threadsDesc[i].cls)) != NULL))
250             return NSK_FALSE;
251     }
252 
253     NSK_DISPLAY0(&quot;Enable tested events\n&quot;);
254     if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL))
255         return NSK_FALSE;
256 
257     return NSK_TRUE;
258 }
259 
260 /**
261  * Suspend or resume tested threads.
262  */
263 static int suspendThreadsIndividually(int suspend) {
264     int i;
265 
266     for (i = 0; i &lt; THREADS_COUNT; i++) {
267         if (suspend) {
268             NSK_DISPLAY2(&quot;    suspend thread #%d (%s)\n&quot;, i, threadsDesc[i].threadName);
269             if (!NSK_JVMTI_VERIFY(jvmti-&gt;SuspendThread(threadsDesc[i].thread)))
270                 nsk_jvmti_setFailStatus();
271         } else {
272             NSK_DISPLAY2(&quot;    resume thread #%d (%s)\n&quot;, i, threadsDesc[i].threadName);
273             if (!NSK_JVMTI_VERIFY(jvmti-&gt;ResumeThread(threadsDesc[i].thread)))
274                 nsk_jvmti_setFailStatus();
275         }
276     }
277     return NSK_TRUE;
278 }
279 
280 /**
281  * Testcase: check tested threads.
282  *    - call GetFrameCount() and then GetStackTrace()
283  *    - for each stack frame of common depth GetFrameLocation()
284  *    - compare frame ifno returned by GetFrameLocation() and GetStackTrace()
285  *    - find expected frame for tested method
286  *
287  * Returns NSK_TRUE if test may continue; or NSK_FALSE for test break.
288  */
289 static int checkThreads(int suspended, const char* kind0) {
290     char kind[256] = &quot;&quot;;
291     int i;
292 
293     /* check each thread */
294     for (i = 0; i &lt; THREADS_COUNT; i++) {
295         jint frameCount = 0;
296         jint frameStackSize = 0;
297         jvmtiFrameInfo frameStack[MAX_STACK_SIZE];
298         int found = 0;
299         int j;
300 
301         /* make proper kind */
302         strcpy(kind, threadsDesc[i].methodCompiled ? &quot;compiled &quot; : &quot;not compiled &quot;);
303         strcat(kind, kind0);
304         NSK_DISPLAY2(&quot;  thread #%d (%s):\n&quot;, i, threadsDesc[i].threadName);
305 
306         /* get frame count */
307         if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetFrameCount(threadsDesc[i].thread, &amp;frameCount))) {
308             nsk_jvmti_setFailStatus();
309             return NSK_TRUE;
310         }
311         NSK_DISPLAY1(&quot;    frameCount:  %d\n&quot;, (int)frameCount);
312 
313         /* get stack trace */
314         if (!NSK_JVMTI_VERIFY(
315                 jvmti-&gt;GetStackTrace(threadsDesc[i].thread, 0, MAX_STACK_SIZE, frameStack, &amp;frameStackSize))) {
316             nsk_jvmti_setFailStatus();
317             return NSK_TRUE;
318         }
319         NSK_DISPLAY1(&quot;    stack depth: %d\n&quot;, (int)frameStackSize);
320 
321         found = 0;
322         for (j = 0; j &lt; frameStackSize; j++) {
323             jmethodID qMethod = (jmethodID)NULL;
324             jlocation qLocation = NSK_JVMTI_INVALID_JLOCATION;
325 
326             NSK_DISPLAY3(&quot;      %d frame: method: 0x%p, location: %ld\n&quot;,
327                                         j, (void*)frameStack[j].method,
328                                         (long)frameStack[j].location);
329             /* query frame location */
330             if (!NSK_JVMTI_VERIFY(
331                     jvmti-&gt;GetFrameLocation(threadsDesc[i].thread, j, &amp;qMethod, &amp;qLocation))
<a name="1" id="anc1"></a><span class="line-modified">332                 &amp;&amp; (suspended == NSK_TRUE)) {</span>
333                 nsk_jvmti_setFailStatus();
334                 continue;
335             }
336 
337             NSK_DISPLAY2(&quot;      queried: method: 0x%p, location: %ld\n&quot;,
338                                         (void*)qMethod, (long)qLocation);
339 
340             /* check frame equality */
<a name="2" id="anc2"></a><span class="line-modified">341             if ((suspended == NSK_TRUE) &amp;&amp; (frameStack[j].method != qMethod)) {</span>
342                 NSK_COMPLAIN6(&quot;Different method in stack frame #%d for %s thread #%d (%s):\n&quot;
343                             &quot;#   GetStackTrace():    0x%p\n&quot;
344                             &quot;#   GetFrameLocation(): 0x%p\n&quot;,
345                             j, kind, i, threadsDesc[i].threadName,
346                             (void*)frameStack[j].method, (void*)qMethod);
347                 nsk_jvmti_setFailStatus();
348             }
<a name="3" id="anc3"></a><span class="line-modified">349             if ((suspended == NSK_TRUE) &amp;&amp; (frameStack[j].location != qLocation)) {</span>
350                 NSK_COMPLAIN6(&quot;Different location in stack frame #%d for %s thread #%d (%s):\n&quot;
351                             &quot;#   GetStackTrace():    %ld\n&quot;
352                             &quot;#   GetFrameLocation(): %ld\n&quot;,
353                             j, kind, i, threadsDesc[i].threadName,
354                             (long)frameStack[j].location, (long)qLocation);
355                 nsk_jvmti_setFailStatus();
356             }
357 
358             /* find expected method */
359             if (frameStack[j].method == threadsDesc[i].method) {
360                 found++;
361                 NSK_DISPLAY1(&quot;        found expected method: %s\n&quot;,
362                                                 threadsDesc[i].methodName);
363             }
364         }
365 
366         /* check if expected method frame found */
367         if (found &lt;= 0) {
368             NSK_COMPLAIN3(&quot;No expected method frame for %s thread #%d (%s)\n&quot;,
369                                 kind, i, threadsDesc[i].threadName);
370             nsk_jvmti_setFailStatus();
371         }
372     }
373 
374     /* test may continue */
375     return NSK_TRUE;
376 }
377 
378 /**
379  * Clean data.
380  *   - disable events
381  *   - dispose global references to tested threads
382  */
383 static int clean() {
384     int i;
385 
386     NSK_DISPLAY0(&quot;Disable events\n&quot;);
387     if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL))
388         return NSK_FALSE;
389 
390     NSK_DISPLAY0(&quot;Dispose global references to threads\n&quot;);
391     for (i = 0; i &lt; THREADS_COUNT; i++) {
392         NSK_TRACE(jni-&gt;DeleteGlobalRef(threadsDesc[i].thread));
393         NSK_TRACE(jni-&gt;DeleteGlobalRef(threadsDesc[i].cls));
394     }
395 
396     return NSK_TRUE;
397 }
398 
399 /* ============================================================================= */
400 
401 /**
402  * COMPILED_METHOD_LOAD callback.
403  *   - turn on flag that method is compiled
404  */
405 JNIEXPORT void JNICALL
406 callbackCompiledMethodLoad(jvmtiEnv* jvmti, jmethodID method,
407                             jint code_size, const void* code_addr,
408                             jint map_length, const jvmtiAddrLocationMap* map,
409                             const void* compile_info) {
410     int i;
411 
412     /* check if event is for tested method and turn flag on */
413     for (i = 0; i &lt; THREADS_COUNT; i++) {
414         if (threadsDesc[i].method == method) {
415             threadsDesc[i].methodCompiled = NSK_TRUE;
416 
417             NSK_DISPLAY2(&quot;  COMPILED_METHOD_LOAD for method #%d (%s):\n&quot;,
418                                 i, threadsDesc[i].methodName);
419             NSK_DISPLAY1(&quot;    methodID:   0x%p\n&quot;,
420                                 (void*)threadsDesc[i].method);
421             NSK_DISPLAY1(&quot;    code_size:  %d\n&quot;,
422                                 (int)code_size);
423             NSK_DISPLAY1(&quot;    map_length: %d\n&quot;,
424                                 (int)map_length);
425             break;
426         }
427     }
428 }
429 
430 /**
431  * COMPILED_METHOD_UNLOAD callback.
432  *   - turn off flag that method is compiled
433  */
434 JNIEXPORT void JNICALL
435 callbackCompiledMethodUnload(jvmtiEnv* jvmti, jmethodID method,
436                              const void* code_addr) {
437     int i;
438 
439     /* check if event is for tested method and turn flag off */
440     for (i = 0; i &lt; THREADS_COUNT; i++) {
441         if (threadsDesc[i].method == method) {
442             threadsDesc[i].methodCompiled = NSK_FALSE;
443 
444             NSK_DISPLAY2(&quot;  COMPILED_METHOD_UNLOAD for method #%d (%s):\n&quot;,
445                                 i, threadsDesc[i].methodName);
446             NSK_DISPLAY1(&quot;    methodID:   0x%p\n&quot;,
447                                 (void*)threadsDesc[i].method);
448             break;
449         }
450     }
451 }
452 
453 /* ============================================================================= */
454 
455 volatile int testedThreadReady = NSK_FALSE;
456 volatile int testedThreadShouldFinish = NSK_FALSE;
457 
458 /** Native running method in tested thread */
459 JNIEXPORT void JNICALL
460 Java_nsk_jvmti_scenarios_sampling_SP06_sp06t003ThreadRunningNative_testedMethod(JNIEnv* jni,
461                                                                             jobject obj,
462                                                                             jboolean simulate,
463                                                                             jint i) {
464     if (!simulate) {
465         volatile int k = 0, n = 1000;
466 
467         /* run in a continous loop */
468         testedThreadReady = NSK_TRUE;
469         while (!testedThreadShouldFinish) {
470             if (n &lt;= 0)
471                 n = 1000;
472             if (k &gt;= n)
473                 k = 0;
474             k++;
475         }
476     }
477 }
478 
479 /** Wait for native method is running. */
480 JNIEXPORT jboolean JNICALL
481 Java_nsk_jvmti_scenarios_sampling_SP06_sp06t003ThreadRunningNative_checkReady(JNIEnv* jni,
482                                                                             jobject obj) {
483     while (!testedThreadReady) {
484         nsk_jvmti_sleep(1000);
485     }
486     return testedThreadReady ? JNI_TRUE : JNI_FALSE;
487 }
488 
489 /** Let native method to finish. */
490 JNIEXPORT void JNICALL
491 Java_nsk_jvmti_scenarios_sampling_SP06_sp06t003ThreadRunningNative_letFinish(JNIEnv* jni,
492                                                                             jobject obj) {
493     testedThreadShouldFinish = NSK_TRUE;
494 }
495 
496 /* ============================================================================= */
497 
498 /** Agent library initialization. */
499 #ifdef STATIC_BUILD
500 JNIEXPORT jint JNICALL Agent_OnLoad_sp06t003(JavaVM *jvm, char *options, void *reserved) {
501     return Agent_Initialize(jvm, options, reserved);
502 }
503 JNIEXPORT jint JNICALL Agent_OnAttach_sp06t003(JavaVM *jvm, char *options, void *reserved) {
504     return Agent_Initialize(jvm, options, reserved);
505 }
506 JNIEXPORT jint JNI_OnLoad_sp06t003(JavaVM *jvm, char *options, void *reserved) {
507     return JNI_VERSION_1_8;
508 }
509 #endif
510 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
511 
512     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
513         return JNI_ERR;
514 
515     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
516 
517     if (!NSK_VERIFY((jvmti =
518             nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))
519         return JNI_ERR;
520 
521     {
522         jvmtiCapabilities caps;
523         memset(&amp;caps, 0, sizeof(caps));
524         caps.can_suspend = 1;
525         caps.can_generate_compiled_method_load_events = 1;
526         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
527             return JNI_ERR;
528     }
529 
530     {
531         jvmtiEventCallbacks eventCallbacks;
532         memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
533         eventCallbacks.CompiledMethodLoad = callbackCompiledMethodLoad;
534         eventCallbacks.CompiledMethodUnload = callbackCompiledMethodUnload;
535         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
536             return JNI_ERR;
537     }
538 
539     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
540         return JNI_ERR;
541 
542     return JNI_OK;
543 }
544 
545 /* ============================================================================= */
546 
547 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
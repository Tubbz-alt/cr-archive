<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM04/em04t001/em04t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../EM02/em02t012/libem02t012.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../EM07/em07t002/em07t002.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM04/em04t001/em04t001.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &lt;stdlib.h&gt;
 26 #include &quot;jvmti.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 #include &quot;JVMTITools.h&quot;
 31 #include &quot;nsk_list.h&quot;
<span class="line-removed"> 32 #include &quot;nsk_mutex.h&quot;</span>
 33 
 34 extern &quot;C&quot; {
 35 
 36 /* ============================================================================= */
 37 
 38 /* scaffold objects */
 39 static jvmtiEnv *jvmti = NULL;
 40 static jlong timeout = 0;
 41 const void *plist = NULL;
 42 
 43 #define NAME_LENGTH 50
 44 
 45 typedef struct nsk_jvmti_DCG_paramsStruct {
 46     char name[NAME_LENGTH];
 47     const void *address;
 48     jint length;
 49     int sign;
 50 } nsk_jvmti_DCG_params;
 51 
<span class="line-modified"> 52 static MUTEX* mutex = NULL;</span>
<span class="line-modified"> 53 </span>
 54 /* ============================================================================= */
 55 
 56 /* callbacks */
 57 void JNICALL
 58 cbDynamicCodeGenerated1(jvmtiEnv *jvmti_env, const char *name,
 59                             const void *address, jint length) {
 60     nsk_jvmti_DCG_params *rec;
 61     int b;
 62 






 63     rec = (nsk_jvmti_DCG_params *)malloc(sizeof(nsk_jvmti_DCG_params));
 64     strncpy(rec-&gt;name, name, NAME_LENGTH);
 65     rec-&gt;name[NAME_LENGTH - 1] = &#39;\0&#39;;
 66     rec-&gt;address = address;
 67     rec-&gt;length = length;
 68     rec-&gt;sign = 0;
 69 
 70     NSK_DISPLAY3(&quot;received: 0x%p %7d %s\n&quot;, rec-&gt;address, rec-&gt;length, rec-&gt;name);
 71 
<span class="line-removed"> 72     MUTEX_acquire(mutex);</span>
<span class="line-removed"> 73 </span>
 74     b = NSK_VERIFY(nsk_list_add(plist, rec));
 75 
<span class="line-removed"> 76     MUTEX_release(mutex);</span>
<span class="line-removed"> 77 </span>
 78     if (!b) {
 79         nsk_jvmti_setFailStatus();
 80         free((void *)rec);
 81     }

 82 }
 83 
 84 void JNICALL
 85 cbDynamicCodeGenerated2(jvmtiEnv *jvmti_env, const char *name,
 86                             const void *address, jint length) {
 87 
 88     int i;
 89     nsk_jvmti_DCG_params *rec;







 90     int count = nsk_list_getCount(plist);
 91     int compLength = NAME_LENGTH - 1;
 92 
 93     for (i = 0; i &lt; count; i ++) {
 94         rec = (nsk_jvmti_DCG_params *)nsk_list_get(plist, i);
 95         if ((rec-&gt;address == address) &amp;&amp; (rec-&gt;length == length)) {
 96             rec-&gt;sign = 1;
 97             NSK_DISPLAY3(&quot;checked: 0x%p %7d %s\n&quot;, rec-&gt;address, rec-&gt;length,
 98                                 rec-&gt;name);
 99             if (strncmp(rec-&gt;name, name, compLength) != 0) {
100                 NSK_DISPLAY2(&quot;\t&lt;%s&gt; was renamed to &lt;%s&gt;\n&quot;, rec-&gt;name, name);
101             }

102             return;
103         }
104 
105     }
106     NSK_DISPLAY3(&quot;NOT FOUND: 0x%p %7d %s\n&quot;, address, length, name);

107 
108 }
109 
110 /* ============================================================================= */
111 
112 static int
113 enableEvent(jvmtiEventMode enable, jvmtiEvent event) {
114     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(enable, event, NULL))) {
115         nsk_jvmti_setFailStatus();
116         return NSK_FALSE;
117     }
118 
119     return NSK_TRUE;
120 }
121 
122 int setCallBacks(int stage) {
123 
124     jvmtiEventCallbacks eventCallbacks;
125     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
126 
</pre>
<hr />
<pre>
134 }
135 
136 /* ============================================================================= */
137 
138 /** Agent algorithm. */
139 static void JNICALL
140 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
141 
142     NSK_DISPLAY0(&quot;Wait for debuggee to become ready\n&quot;);
143     if (!nsk_jvmti_waitForSync(timeout))
144         return;
145 
146     /* stage 2 */
147     if (!setCallBacks(2)) {
148         return;
149     }
150 
151     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GenerateEvents(JVMTI_EVENT_DYNAMIC_CODE_GENERATED)))
152         nsk_jvmti_setFailStatus();
153 



154     {
155         int i;
156         const nsk_jvmti_DCG_params *rec;
157         int count = nsk_list_getCount(plist);
158 
159         for (i = 0; i &lt; count; i++) {
160             rec = (const nsk_jvmti_DCG_params *)nsk_list_get(plist, 0);
161             if (!rec-&gt;sign) {
162                 NSK_COMPLAIN3(&quot;missed event for\n\t0x%p %7d %s\n&quot;, rec-&gt;address, rec-&gt;length, rec-&gt;name);
163                 nsk_jvmti_setFailStatus();
164             }
165             free((void *)rec);
166             nsk_list_remove(plist, 0);
167         }
168 
169     }
170 


171     NSK_DISPLAY0(&quot;Let debuggee to finish\n&quot;);
172     if (!nsk_jvmti_resumeSync())
173         return;
174 
175 }
176 
177 /* ============================================================================= */
178 
179 /** Agent library initialization. */
180 #ifdef STATIC_BUILD
181 JNIEXPORT jint JNICALL Agent_OnLoad_em04t001(JavaVM *jvm, char *options, void *reserved) {
182     return Agent_Initialize(jvm, options, reserved);
183 }
184 JNIEXPORT jint JNICALL Agent_OnAttach_em04t001(JavaVM *jvm, char *options, void *reserved) {
185     return Agent_Initialize(jvm, options, reserved);
186 }
187 JNIEXPORT jint JNI_OnLoad_em04t001(JavaVM *jvm, char *options, void *reserved) {
188     return JNI_VERSION_1_8;
189 }
190 #endif
191 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
192 
<span class="line-removed">193     mutex = MUTEX_create();</span>
<span class="line-removed">194     if (!mutex)</span>
<span class="line-removed">195         return JNI_ERR;</span>
<span class="line-removed">196 </span>
197     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
198         return JNI_ERR;
199 
200     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
201 
202     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
203     if (!NSK_VERIFY(jvmti != NULL))
204         return JNI_ERR;
205 





206     plist = (const void *)nsk_list_create();
207     if (!NSK_VERIFY(plist != NULL))
208         return JNI_ERR;
209 
210     NSK_DISPLAY1(&quot;plist = 0x%p\n&quot;, plist);
211 
212     if (!setCallBacks(1)) {
213         return JNI_ERR;
214     }
215 
216     if (!enableEvent(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT)
217             || !enableEvent(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH)
218             || !enableEvent(JVMTI_ENABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED)) {
219         return JNI_ERR;
220     }
221 
222     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
223         return JNI_ERR;
224 
225     return JNI_OK;
226 }
227 
228 /* ============================================================================= */
229 
230 JNIEXPORT void JNICALL
231 #ifdef STATIC_BUILD
232 Agent_OnUnload_em04t001(JavaVM *jvm)
233 #else
234 Agent_OnUnload(JavaVM *jvm)
235 #endif
236 {
237 
238     if (!NSK_VERIFY(nsk_list_destroy(plist))) {
239         nsk_jvmti_setFailStatus();
240     }
241 
<span class="line-modified">242     if (mutex) {</span>
<span class="line-modified">243         MUTEX_destroy(mutex);</span>
<span class="line-removed">244         mutex = NULL;</span>
245     }
246 }
247 
248 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &lt;stdlib.h&gt;
 26 #include &quot;jvmti.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 #include &quot;JVMTITools.h&quot;
 31 #include &quot;nsk_list.h&quot;

 32 
 33 extern &quot;C&quot; {
 34 
 35 /* ============================================================================= */
 36 
 37 /* scaffold objects */
 38 static jvmtiEnv *jvmti = NULL;
 39 static jlong timeout = 0;
 40 const void *plist = NULL;
 41 
 42 #define NAME_LENGTH 50
 43 
 44 typedef struct nsk_jvmti_DCG_paramsStruct {
 45     char name[NAME_LENGTH];
 46     const void *address;
 47     jint length;
 48     int sign;
 49 } nsk_jvmti_DCG_params;
 50 
<span class="line-modified"> 51 static jrawMonitorID syncLock = NULL;</span>
<span class="line-modified"> 52 static volatile int callbacksEnabled = NSK_TRUE;</span>
 53 /* ============================================================================= */
 54 
 55 /* callbacks */
 56 void JNICALL
 57 cbDynamicCodeGenerated1(jvmtiEnv *jvmti_env, const char *name,
 58                             const void *address, jint length) {
 59     nsk_jvmti_DCG_params *rec;
 60     int b;
 61 
<span class="line-added"> 62     jvmti-&gt;RawMonitorEnter(syncLock);</span>
<span class="line-added"> 63     if (!callbacksEnabled) {</span>
<span class="line-added"> 64         jvmti-&gt;RawMonitorExit(syncLock);</span>
<span class="line-added"> 65         return;</span>
<span class="line-added"> 66     }</span>
<span class="line-added"> 67 </span>
 68     rec = (nsk_jvmti_DCG_params *)malloc(sizeof(nsk_jvmti_DCG_params));
 69     strncpy(rec-&gt;name, name, NAME_LENGTH);
 70     rec-&gt;name[NAME_LENGTH - 1] = &#39;\0&#39;;
 71     rec-&gt;address = address;
 72     rec-&gt;length = length;
 73     rec-&gt;sign = 0;
 74 
 75     NSK_DISPLAY3(&quot;received: 0x%p %7d %s\n&quot;, rec-&gt;address, rec-&gt;length, rec-&gt;name);
 76 


 77     b = NSK_VERIFY(nsk_list_add(plist, rec));
 78 


 79     if (!b) {
 80         nsk_jvmti_setFailStatus();
 81         free((void *)rec);
 82     }
<span class="line-added"> 83     jvmti-&gt;RawMonitorExit(syncLock);</span>
 84 }
 85 
 86 void JNICALL
 87 cbDynamicCodeGenerated2(jvmtiEnv *jvmti_env, const char *name,
 88                             const void *address, jint length) {
 89 
 90     int i;
 91     nsk_jvmti_DCG_params *rec;
<span class="line-added"> 92 </span>
<span class="line-added"> 93     jvmti-&gt;RawMonitorEnter(syncLock);</span>
<span class="line-added"> 94     if (!callbacksEnabled) {</span>
<span class="line-added"> 95         jvmti-&gt;RawMonitorExit(syncLock);</span>
<span class="line-added"> 96         return;</span>
<span class="line-added"> 97     }</span>
<span class="line-added"> 98 </span>
 99     int count = nsk_list_getCount(plist);
100     int compLength = NAME_LENGTH - 1;
101 
102     for (i = 0; i &lt; count; i ++) {
103         rec = (nsk_jvmti_DCG_params *)nsk_list_get(plist, i);
104         if ((rec-&gt;address == address) &amp;&amp; (rec-&gt;length == length)) {
105             rec-&gt;sign = 1;
106             NSK_DISPLAY3(&quot;checked: 0x%p %7d %s\n&quot;, rec-&gt;address, rec-&gt;length,
107                                 rec-&gt;name);
108             if (strncmp(rec-&gt;name, name, compLength) != 0) {
109                 NSK_DISPLAY2(&quot;\t&lt;%s&gt; was renamed to &lt;%s&gt;\n&quot;, rec-&gt;name, name);
110             }
<span class="line-added">111             jvmti-&gt;RawMonitorExit(syncLock);</span>
112             return;
113         }
114 
115     }
116     NSK_DISPLAY3(&quot;NOT FOUND: 0x%p %7d %s\n&quot;, address, length, name);
<span class="line-added">117     jvmti-&gt;RawMonitorExit(syncLock);</span>
118 
119 }
120 
121 /* ============================================================================= */
122 
123 static int
124 enableEvent(jvmtiEventMode enable, jvmtiEvent event) {
125     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(enable, event, NULL))) {
126         nsk_jvmti_setFailStatus();
127         return NSK_FALSE;
128     }
129 
130     return NSK_TRUE;
131 }
132 
133 int setCallBacks(int stage) {
134 
135     jvmtiEventCallbacks eventCallbacks;
136     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
137 
</pre>
<hr />
<pre>
145 }
146 
147 /* ============================================================================= */
148 
149 /** Agent algorithm. */
150 static void JNICALL
151 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
152 
153     NSK_DISPLAY0(&quot;Wait for debuggee to become ready\n&quot;);
154     if (!nsk_jvmti_waitForSync(timeout))
155         return;
156 
157     /* stage 2 */
158     if (!setCallBacks(2)) {
159         return;
160     }
161 
162     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GenerateEvents(JVMTI_EVENT_DYNAMIC_CODE_GENERATED)))
163         nsk_jvmti_setFailStatus();
164 
<span class="line-added">165     jvmti-&gt;RawMonitorEnter(syncLock);</span>
<span class="line-added">166     callbacksEnabled = NSK_FALSE;</span>
<span class="line-added">167 </span>
168     {
169         int i;
170         const nsk_jvmti_DCG_params *rec;
171         int count = nsk_list_getCount(plist);
172 
173         for (i = 0; i &lt; count; i++) {
174             rec = (const nsk_jvmti_DCG_params *)nsk_list_get(plist, 0);
175             if (!rec-&gt;sign) {
176                 NSK_COMPLAIN3(&quot;missed event for\n\t0x%p %7d %s\n&quot;, rec-&gt;address, rec-&gt;length, rec-&gt;name);
177                 nsk_jvmti_setFailStatus();
178             }
179             free((void *)rec);
180             nsk_list_remove(plist, 0);
181         }
182 
183     }
184 
<span class="line-added">185     jvmti-&gt;RawMonitorExit(syncLock);</span>
<span class="line-added">186 </span>
187     NSK_DISPLAY0(&quot;Let debuggee to finish\n&quot;);
188     if (!nsk_jvmti_resumeSync())
189         return;
190 
191 }
192 
193 /* ============================================================================= */
194 
195 /** Agent library initialization. */
196 #ifdef STATIC_BUILD
197 JNIEXPORT jint JNICALL Agent_OnLoad_em04t001(JavaVM *jvm, char *options, void *reserved) {
198     return Agent_Initialize(jvm, options, reserved);
199 }
200 JNIEXPORT jint JNICALL Agent_OnAttach_em04t001(JavaVM *jvm, char *options, void *reserved) {
201     return Agent_Initialize(jvm, options, reserved);
202 }
203 JNIEXPORT jint JNI_OnLoad_em04t001(JavaVM *jvm, char *options, void *reserved) {
204     return JNI_VERSION_1_8;
205 }
206 #endif
207 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
208 




209     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
210         return JNI_ERR;
211 
212     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
213 
214     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
215     if (!NSK_VERIFY(jvmti != NULL))
216         return JNI_ERR;
217 
<span class="line-added">218     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock))) {</span>
<span class="line-added">219         nsk_jvmti_setFailStatus();</span>
<span class="line-added">220         return JNI_ERR;</span>
<span class="line-added">221     }</span>
<span class="line-added">222 </span>
223     plist = (const void *)nsk_list_create();
224     if (!NSK_VERIFY(plist != NULL))
225         return JNI_ERR;
226 
227     NSK_DISPLAY1(&quot;plist = 0x%p\n&quot;, plist);
228 
229     if (!setCallBacks(1)) {
230         return JNI_ERR;
231     }
232 
233     if (!enableEvent(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT)
234             || !enableEvent(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH)
235             || !enableEvent(JVMTI_ENABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED)) {
236         return JNI_ERR;
237     }
238 
239     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
240         return JNI_ERR;
241 
242     return JNI_OK;
243 }
244 
245 /* ============================================================================= */
246 
247 JNIEXPORT void JNICALL
248 #ifdef STATIC_BUILD
249 Agent_OnUnload_em04t001(JavaVM *jvm)
250 #else
251 Agent_OnUnload(JavaVM *jvm)
252 #endif
253 {
254 
255     if (!NSK_VERIFY(nsk_list_destroy(plist))) {
256         nsk_jvmti_setFailStatus();
257     }
258 
<span class="line-modified">259     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock))) {</span>
<span class="line-modified">260         nsk_jvmti_setFailStatus();</span>

261     }
262 }
263 
264 }
</pre>
</td>
</tr>
</table>
<center><a href="../../EM02/em02t012/libem02t012.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../EM07/em07t002/em07t002.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
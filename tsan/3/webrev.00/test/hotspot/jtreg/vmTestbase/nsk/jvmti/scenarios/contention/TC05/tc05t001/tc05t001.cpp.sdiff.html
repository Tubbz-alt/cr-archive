<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/contention/TC05/tc05t001/tc05t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TestDescription.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../events/EM01/em01t001/em01t001.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/contention/TC05/tc05t001/tc05t001.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdlib.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &quot;jni_tools.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 /* ========================================================================== */
 33 
 34 static const jlong EXPECTED_TIMEOUT = 1;
 35 /*
 36  * The expected timeout accuracy was already increased from 100000 to 300000.
 37  * Please, do not increase it anymore if the test still fails with the message:
 38  *  &quot;(waitedTime - waitTime) &gt;= (EXPECTED_TIMEOUT * 1000000) - EXPECTED_TIMEOUT_ACCURACY_NS&quot;
 39  */
 40 static const jlong EXPECTED_TIMEOUT_ACCURACY_NS = 300000;
 41 
<span class="line-modified"> 42 static const jlong EXPECTED_ACCURACY = 10;</span>




 43 
 44 /* scaffold objects */
 45 static jlong timeout = 0;
 46 
 47 /* test objects */
 48 static jthread thread = NULL;
 49 static jobject object_M = NULL;
 50 static volatile int waitEventsCount = 0;
 51 static volatile int waitedEventsCount = 0;
 52 static jlong waitTime = 0;
 53 static jlong waitThreadCpuTime = 0;
 54 static jlong waitedTime = 0;
 55 static jlong waitedThreadCpuTime = 0;
 56 
 57 /* ========================================================================== */
 58 
 59 void JNICALL
 60 MonitorWait(jvmtiEnv *jvmti, JNIEnv* jni,
 61         jthread thr, jobject obj, jlong tout) {
 62     char buffer[32];
</pre>
<hr />
<pre>
247 
248     /* resume debugee to catch MonitorContendedEntered events */
249     if (!(NSK_VERIFY(nsk_jvmti_resumeSync()) &amp;&amp;
250           NSK_VERIFY(nsk_jvmti_waitForSync(timeout))))
251         return;
252 
253     NSK_DISPLAY1(&quot;Number of MonitorWait events: %d\n&quot;, waitEventsCount);
254     if (!(NSK_VERIFY(waitEventsCount == 1))) {
255         nsk_jvmti_setFailStatus();
256     }
257 
258     NSK_DISPLAY1(&quot;Number of MonitorWaited events: %d\n&quot;, waitedEventsCount);
259     if (!(NSK_VERIFY(waitedEventsCount == 1))) {
260         nsk_jvmti_setFailStatus();
261     }
262 
263     NSK_DISPLAY1(&quot;Time frame between the events: %s ns\n&quot;,
264         jlong_to_string(waitedTime - waitTime, buffer));
265     if (!(NSK_VERIFY((waitedTime - waitTime) &gt;= (EXPECTED_TIMEOUT * 1000000) - EXPECTED_TIMEOUT_ACCURACY_NS))) {
266 #if (defined(WIN32) || defined(_WIN32))
<span class="line-modified">267         /* Do not fail on Windows as spurious wakeups are expected. The JDK-6313903 was closed as &quot;Won&#39;t Fix&quot;. */</span>
268 #else
269         nsk_jvmti_setFailStatus();
270 #endif
271         printf(&quot;waitedTime: %&quot; LL &quot;d,  waitTime: %&quot; LL &quot;d, waitedTime - waitTime: %&quot; LL &quot;d\n&quot;,
272                 waitedTime, waitTime, waitedTime - waitTime);
273     }
274 
275     NSK_DISPLAY1(&quot;Thread CPU time between the events: %s ns\n&quot;,
276         jlong_to_string(waitedThreadCpuTime - waitThreadCpuTime, buffer));
277     if (!(NSK_VERIFY((waitedThreadCpuTime - waitThreadCpuTime)
278             &lt; (EXPECTED_ACCURACY * 1000000)))) {
279         nsk_jvmti_setFailStatus();
280         printf(&quot;waitedThreadCpuTime: %&quot; LL &quot;d, waitThreadCpuTime: %&quot; LL &quot;d, waitedThreadCpuTime - waitThreadCpuTime: %&quot; LL &quot;d\n&quot;,
281                 waitedThreadCpuTime, waitThreadCpuTime, waitedThreadCpuTime - waitThreadCpuTime);
282     }
283 
284     if (!clean(jvmti, jni)) {
285         nsk_jvmti_setFailStatus();
286         return;
287     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdlib.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &quot;jni_tools.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 /* ========================================================================== */
 33 
 34 static const jlong EXPECTED_TIMEOUT = 1;
 35 /*
 36  * The expected timeout accuracy was already increased from 100000 to 300000.
 37  * Please, do not increase it anymore if the test still fails with the message:
 38  *  &quot;(waitedTime - waitTime) &gt;= (EXPECTED_TIMEOUT * 1000000) - EXPECTED_TIMEOUT_ACCURACY_NS&quot;
 39  */
 40 static const jlong EXPECTED_TIMEOUT_ACCURACY_NS = 300000;
 41 
<span class="line-modified"> 42 #if (defined(WIN32) || defined(_WIN32))</span>
<span class="line-added"> 43 static const jlong EXPECTED_ACCURACY = 16; // 16ms is longest clock update interval</span>
<span class="line-added"> 44 #else</span>
<span class="line-added"> 45 static const jlong EXPECTED_ACCURACY = 10; // high frequency clock updates expected</span>
<span class="line-added"> 46 #endif</span>
 47 
 48 /* scaffold objects */
 49 static jlong timeout = 0;
 50 
 51 /* test objects */
 52 static jthread thread = NULL;
 53 static jobject object_M = NULL;
 54 static volatile int waitEventsCount = 0;
 55 static volatile int waitedEventsCount = 0;
 56 static jlong waitTime = 0;
 57 static jlong waitThreadCpuTime = 0;
 58 static jlong waitedTime = 0;
 59 static jlong waitedThreadCpuTime = 0;
 60 
 61 /* ========================================================================== */
 62 
 63 void JNICALL
 64 MonitorWait(jvmtiEnv *jvmti, JNIEnv* jni,
 65         jthread thr, jobject obj, jlong tout) {
 66     char buffer[32];
</pre>
<hr />
<pre>
251 
252     /* resume debugee to catch MonitorContendedEntered events */
253     if (!(NSK_VERIFY(nsk_jvmti_resumeSync()) &amp;&amp;
254           NSK_VERIFY(nsk_jvmti_waitForSync(timeout))))
255         return;
256 
257     NSK_DISPLAY1(&quot;Number of MonitorWait events: %d\n&quot;, waitEventsCount);
258     if (!(NSK_VERIFY(waitEventsCount == 1))) {
259         nsk_jvmti_setFailStatus();
260     }
261 
262     NSK_DISPLAY1(&quot;Number of MonitorWaited events: %d\n&quot;, waitedEventsCount);
263     if (!(NSK_VERIFY(waitedEventsCount == 1))) {
264         nsk_jvmti_setFailStatus();
265     }
266 
267     NSK_DISPLAY1(&quot;Time frame between the events: %s ns\n&quot;,
268         jlong_to_string(waitedTime - waitTime, buffer));
269     if (!(NSK_VERIFY((waitedTime - waitTime) &gt;= (EXPECTED_TIMEOUT * 1000000) - EXPECTED_TIMEOUT_ACCURACY_NS))) {
270 #if (defined(WIN32) || defined(_WIN32))
<span class="line-modified">271         /* Do not fail on Windows as early returns are expected and wait() treats them as spurious wakeups. */</span>
272 #else
273         nsk_jvmti_setFailStatus();
274 #endif
275         printf(&quot;waitedTime: %&quot; LL &quot;d,  waitTime: %&quot; LL &quot;d, waitedTime - waitTime: %&quot; LL &quot;d\n&quot;,
276                 waitedTime, waitTime, waitedTime - waitTime);
277     }
278 
279     NSK_DISPLAY1(&quot;Thread CPU time between the events: %s ns\n&quot;,
280         jlong_to_string(waitedThreadCpuTime - waitThreadCpuTime, buffer));
281     if (!(NSK_VERIFY((waitedThreadCpuTime - waitThreadCpuTime)
282             &lt; (EXPECTED_ACCURACY * 1000000)))) {
283         nsk_jvmti_setFailStatus();
284         printf(&quot;waitedThreadCpuTime: %&quot; LL &quot;d, waitThreadCpuTime: %&quot; LL &quot;d, waitedThreadCpuTime - waitThreadCpuTime: %&quot; LL &quot;d\n&quot;,
285                 waitedThreadCpuTime, waitThreadCpuTime, waitedThreadCpuTime - waitThreadCpuTime);
286     }
287 
288     if (!clean(jvmti, jni)) {
289         nsk_jvmti_setFailStatus();
290         return;
291     }
</pre>
</td>
</tr>
</table>
<center><a href="TestDescription.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../events/EM01/em01t001/em01t001.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
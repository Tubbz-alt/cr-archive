<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/bcinstr/BI01/bi01t001/bi01t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
<a name="2" id="anc2"></a>
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 /* scaffold objects */
 33 static jvmtiEnv *jvmti = NULL;
 34 static jlong timeout = 0;
 35 
 36 #define TESTED_CLASS_NAME   &quot;nsk/jvmti/scenarios/bcinstr/BI01/bi01t001a&quot;
 37 
 38 static jint newClassSize;
 39 static unsigned char* newClassBytes;
 40 static jvmtiClassDefinition oldClassDef;
 41 
 42 /* ============================================================================= */
 43 /*
 44  * Class:     nsk_jvmti_scenarios_bcinstr_BI01_bi01t001
 45  * Method:    setNewByteCode
 46  * Signature: ([B)Z
 47  */
 48 JNIEXPORT jboolean JNICALL
 49 Java_nsk_jvmti_scenarios_bcinstr_BI01_bi01t001_setNewByteCode(JNIEnv *jni_env,
<a name="3" id="anc3"></a><span class="line-modified"> 50                         jobject o, jbyteArray byteCode) {</span>
<span class="line-modified"> 51 </span>

 52     jbyte* elements;
 53     jboolean isCopy;
 54 
<a name="4" id="anc4"></a><span class="line-modified"> 55     newClassSize = jni_env-&gt;GetArrayLength(byteCode);</span>
<span class="line-modified"> 56     if (!NSK_JNI_VERIFY(jni_env, newClassSize &gt; 0)) {</span>
 57         nsk_jvmti_setFailStatus();
 58         return NSK_FALSE;
 59     }
 60     NSK_DISPLAY1(&quot;\t... got array size: %d\n&quot;, newClassSize);
 61 
<a name="5" id="anc5"></a><span class="line-modified"> 62     elements = jni_env-&gt;GetByteArrayElements(byteCode, &amp;isCopy);</span>
<span class="line-removed"> 63     if (!NSK_JNI_VERIFY(jni_env, elements != NULL)) {</span>
<span class="line-removed"> 64         nsk_jvmti_setFailStatus();</span>
<span class="line-removed"> 65         return NSK_FALSE;</span>
<span class="line-removed"> 66     }</span>
 67     NSK_DISPLAY1(&quot;\t... got elements list: 0x%p\n&quot;, (void*)elements);
 68 
 69     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Allocate(newClassSize, &amp;newClassBytes))) {
 70         nsk_jvmti_setFailStatus();
 71         return NSK_FALSE;
 72     }
 73     NSK_DISPLAY1(&quot;\t... created bytes array: 0x%p\n&quot;, (void*)newClassBytes);
 74 
 75     {
 76         int j;
 77         for (j = 0; j &lt; newClassSize; j++)
 78             newClassBytes[j] = (unsigned char)elements[j];
 79     }
 80     NSK_DISPLAY1(&quot;\t... copied bytecode: %d bytes\n&quot;, (int)newClassSize);
 81 
 82     NSK_DISPLAY1(&quot;\t... release elements list: 0x%p\n&quot;, (void*)elements);
<a name="6" id="anc6"></a><span class="line-modified"> 83     NSK_TRACE(jni_env-&gt;ReleaseByteArrayElements(byteCode, elements, JNI_ABORT));</span>
 84     NSK_DISPLAY0(&quot;\t... released\n&quot;);
 85     return NSK_TRUE;
 86 }
 87 
 88 /* ============================================================================= */
 89 /*
 90  * Class:     nsk_jvmti_scenarios_bcinstr_BI01_bi01t001
 91  * Method:    setClass
 92  * Signature: (Ljava/lang/Class;)V
 93  */
 94 JNIEXPORT void JNICALL
 95 Java_nsk_jvmti_scenarios_bcinstr_BI01_bi01t001_setClass(JNIEnv *jni_env,
 96                         jobject o, jclass cls) {
<a name="7" id="anc7"></a><span class="line-modified"> 97 </span>
<span class="line-modified"> 98     oldClassDef.klass = (jclass) jni_env-&gt;NewGlobalRef(cls);</span>
<span class="line-removed"> 99     if (!NSK_JNI_VERIFY(jni_env, oldClassDef.klass != NULL)) {</span>
<span class="line-removed">100         nsk_jvmti_setFailStatus();</span>
<span class="line-removed">101     }</span>
102 }
103 
104 /* ============================================================================= */
105 
106 /** Callback function for ClassFileLoadHook event. */
107 JNIEXPORT void JNICALL
108 cbClassFileLoadHook(jvmtiEnv *jvmti_env, JNIEnv* jni_env,
109             jclass class_being_redefined, jobject loader, const char* name,
110             jobject protection_domain, jint class_data_len,
111             const unsigned char* class_data, jint* new_class_data_len,
112             unsigned char** new_class_data) {
113 
114     if (name == NULL || strcmp(name, TESTED_CLASS_NAME)) {
115         return;
116     }
117 
118     NSK_DISPLAY3(&quot;CLASS_FILE_LOAD_HOOK event: %s\n\treceived bytecode: 0x%p:%d\n&quot;,
119                         name, (void *)class_data, class_data_len);
120     if (nsk_getVerboseMode()) {
121         nsk_printHexBytes(&quot;   &quot;, 16, class_data_len, class_data);
122     }
123 
124     {
125         /*store original byte code, it will be used to do final redefinition*/
126         int j;
127         unsigned char *arr;
128 
129         oldClassDef.class_byte_count = class_data_len;
130         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Allocate(class_data_len, &amp;arr))) {
131             nsk_jvmti_setFailStatus();
132             return;
133         }
134         for (j = 0; j &lt; class_data_len; j++) {
135             arr[j] = class_data[j];
136         }
137         oldClassDef.class_bytes = arr;
138     }
139 
140     *new_class_data_len = newClassSize;
141     *new_class_data = newClassBytes;
142 
143     NSK_DISPLAY2(&quot;Replace with new bytecode: 0x%p:%d\n&quot;,
144                                 (void*)newClassBytes,
145                                 (int)newClassSize);
146     if (nsk_getVerboseMode()) {
147         nsk_printHexBytes(&quot;   &quot;, 16, newClassSize,
148                                 newClassBytes);
149     }
150 }
151 
152 /* ============================================================================= */
153 
154 /** Agent algorithm. */
155 static void JNICALL
156 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
<a name="8" id="anc8"></a>
157 
158     /*Wait for debuggee to read new byte codes nsk_jvmti_waitForSync#1*/
159     NSK_DISPLAY0(&quot;Wait for debuggee to read new byte codes nsk_jvmti_waitForSync#1\n&quot;);
160     if (!nsk_jvmti_waitForSync(timeout))
161         return;
162 
163     if (!nsk_jvmti_resumeSync())
164         return;
165 
166     NSK_DISPLAY0(&quot;Wait for debuggee to load tested class by classLoader\n&quot;);
167     /*Wait for debuggee to load next class nsk_jvmti_waitForSync#2*/
168     if (!nsk_jvmti_waitForSync(timeout))
169         return;
170 
171     if (!nsk_jvmti_resumeSync())
172         return;
173 
174     /*Wait for debuggee to check instrumentation code works nsk_jvmti_waitForSync#3*/
175     NSK_DISPLAY0(&quot;Wait for debuggee to check instrumentation code works nsk_jvmti_waitForSync#3\n&quot;);
176     if (!nsk_jvmti_waitForSync(timeout))
177         return;
178 
179     NSK_DISPLAY0(&quot;Notification disabled for CLASS_FILE_LOAD_HOOK event\n&quot;);
180     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE,
181                                                           JVMTI_EVENT_CLASS_FILE_LOAD_HOOK,
182                                                           NULL))) {
183         nsk_jvmti_setFailStatus();
184         return;
185     }
186 
187     if (!nsk_jvmti_resumeSync())
188         return;
189 
190     /*Wait for debuggee to set classes to be redefined nsk_jvmti_waitForSync#4*/
191     NSK_DISPLAY0(&quot;Wait for debuggee to set classes to be redefined nsk_jvmti_waitForSync#4\n&quot;);
192     if (!nsk_jvmti_waitForSync(timeout))
193         return;
194 
195     NSK_DISPLAY0(&quot;Redfine class with old byte code\n&quot;);
196     NSK_DISPLAY3(&quot;class definition:\n\t0x%p, 0x%p:%d\n&quot;,
197                     oldClassDef.klass,
198                     oldClassDef.class_bytes,
199                     oldClassDef.class_byte_count);
200     if (nsk_getVerboseMode()) {
201         nsk_printHexBytes(&quot;   &quot;, 16, oldClassDef.class_byte_count,
202                                 oldClassDef.class_bytes);
203     }
204     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RedefineClasses(1, &amp;oldClassDef))) {
205         nsk_jvmti_setFailStatus();
206         return;
207     }
208 
209     if (!nsk_jvmti_resumeSync())
210         return;
211 
212     /*Wait for debuggee to check old byte code works nsk_jvmti_waitForSync#5*/
213     NSK_DISPLAY0(&quot;Wait for debuggee to check old byte code works nsk_jvmti_waitForSync#5\n&quot;);
214     if (!nsk_jvmti_waitForSync(timeout))
215         return;
216 
<a name="9" id="anc9"></a><span class="line-modified">217     agentJNI-&gt;DeleteGlobalRef(oldClassDef.klass);</span>
218 
219     NSK_DISPLAY0(&quot;Let debuggee to finish\n&quot;);
220     if (!nsk_jvmti_resumeSync())
221         return;
222 
223 }
224 
225 /* ============================================================================= */
226 
227 /** Agent library initialization. */
228 #ifdef STATIC_BUILD
229 JNIEXPORT jint JNICALL Agent_OnLoad_bi01t001(JavaVM *jvm, char *options, void *reserved) {
230     return Agent_Initialize(jvm, options, reserved);
231 }
232 JNIEXPORT jint JNICALL Agent_OnAttach_bi01t001(JavaVM *jvm, char *options, void *reserved) {
233     return Agent_Initialize(jvm, options, reserved);
234 }
235 JNIEXPORT jint JNI_OnLoad_bi01t001(JavaVM *jvm, char *options, void *reserved) {
236     return JNI_VERSION_1_8;
237 }
238 #endif
239 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
240 
241     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
242         return JNI_ERR;
243 
244     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
245 
246     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
247     if (!NSK_VERIFY(jvmti != NULL))
248         return JNI_ERR;
249 
250     {
251         jvmtiCapabilities caps;
252         memset(&amp;caps, 0, sizeof(caps));
253 
254         caps.can_redefine_classes = 1;
255         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
256             return JNI_ERR;
257     }
258 
259     NSK_DISPLAY0(&quot;Set callback for CLASS_FILE_LOAD_HOOK event\n&quot;);
260     {
261         jvmtiEventCallbacks callbacks;
262         jint size = (jint)sizeof(callbacks);
263 
264         memset(&amp;callbacks, 0, size);
265         callbacks.ClassFileLoadHook = cbClassFileLoadHook;
266         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;callbacks, size))) {
267             return JNI_ERR;
268         }
269     }
270 
271     NSK_DISPLAY0(&quot;Set notification enabled for CLASS_FILE_LOAD_HOOK event\n&quot;);
272     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE,
273                                                           JVMTI_EVENT_CLASS_FILE_LOAD_HOOK,
274                                                           NULL))) {
275         nsk_jvmti_setFailStatus();
276         return NSK_FALSE;
277     }
278 
279     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
280         return JNI_ERR;
281 
282     return JNI_OK;
283 }
284 
285 /* ============================================================================= */
286 
287 
288 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
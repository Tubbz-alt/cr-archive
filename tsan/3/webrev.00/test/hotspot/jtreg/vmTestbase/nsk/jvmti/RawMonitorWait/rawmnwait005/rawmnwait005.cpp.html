<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/RawMonitorWait/rawmnwait005/rawmnwait005.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdio.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &quot;jvmti.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;JVMTITools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 
 33 #define PASSED 0
 34 #define STATUS_FAILED 2
 35 #define MILLIS_PER_MINUTE (60 * 1000)
 36 
 37 static jvmtiEnv *jvmti = NULL;
 38 static jvmtiCapabilities caps;
 39 static jint result = PASSED;
 40 static jboolean printdump = JNI_TRUE;
 41 static jrawMonitorID monitor;
 42 static jrawMonitorID wait_lock;
 43 static jlong wait_time;
 44 
 45 #ifdef STATIC_BUILD
 46 JNIEXPORT jint JNICALL Agent_OnLoad_rawmnwait005(JavaVM *jvm, char *options, void *reserved) {
 47     return Agent_Initialize(jvm, options, reserved);
 48 }
 49 JNIEXPORT jint JNICALL Agent_OnAttach_rawmnwait005(JavaVM *jvm, char *options, void *reserved) {
 50     return Agent_Initialize(jvm, options, reserved);
 51 }
 52 JNIEXPORT jint JNI_OnLoad_rawmnwait005(JavaVM *jvm, char *options, void *reserved) {
 53     return JNI_VERSION_1_8;
 54 }
 55 #endif
 56 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
 57     jint res;
 58     jvmtiError err;
 59 
 60     if (options != NULL &amp;&amp; strcmp(options, &quot;printdump&quot;) == 0) {
 61         printdump = JNI_TRUE;
 62     }
 63 
 64     res = jvm-&gt;GetEnv((void **) &amp;jvmti, JVMTI_VERSION_1_1);
 65     if (res != JNI_OK || jvmti == NULL) {
 66         printf(&quot;Wrong result of a valid call to GetEnv!\n&quot;);
 67         return JNI_ERR;
 68     }
 69 
 70     err = jvmti-&gt;GetPotentialCapabilities(&amp;caps);
 71     if (err != JVMTI_ERROR_NONE) {
 72         printf(&quot;(GetPotentialCapabilities) unexpected error: %s (%d)\n&quot;,
 73                TranslateError(err), err);
 74         return JNI_ERR;
 75     }
 76 
 77     err = jvmti-&gt;AddCapabilities(&amp;caps);
 78     if (err != JVMTI_ERROR_NONE) {
 79         printf(&quot;(AddCapabilities) unexpected error: %s (%d)\n&quot;,
 80                TranslateError(err), err);
 81         return JNI_ERR;
 82     }
 83 
 84     err = jvmti-&gt;GetCapabilities(&amp;caps);
 85     if (err != JVMTI_ERROR_NONE) {
 86         printf(&quot;(GetCapabilities) unexpected error: %s (%d)\n&quot;,
 87                TranslateError(err), err);
 88         return JNI_ERR;
 89     }
 90 
 91     if (!caps.can_signal_thread) {
 92         printf(&quot;Warning: InterruptThread is not implemented\n&quot;);
 93     }
 94 
 95     return JNI_OK;
 96 }
 97 
 98 static void JNICALL
 99 test_thread(jvmtiEnv* jvmti, JNIEnv* jni, void *unused) {
100     jvmtiError err;
101     const char* const thread_name = &quot;test thread&quot;;
102 
103     // Once we hold this monitor we know we can&#39;t get interrupted
104     // until we have called wait().
105     err = jvmti-&gt;RawMonitorEnter(monitor);
106     if (err != JVMTI_ERROR_NONE) {
107         printf(&quot;(RawMonitorEnter#test) unexpected error: %s (%d)\n&quot;,
108                TranslateError(err), err);
109         result = STATUS_FAILED;
110     }
111     if (printdump == JNI_TRUE) {
112         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;monitor&#39; ...\n&quot;, thread_name);
113     }
114 
115     // We can&#39;t get this monitor until the main thread has called wait() on it.
116     err = jvmti-&gt;RawMonitorEnter(wait_lock);
117     if (err != JVMTI_ERROR_NONE) {
118         printf(&quot;(RawMonitorEnter#wait) unexpected error: %s (%d)\n&quot;,
119                TranslateError(err), err);
120         result = STATUS_FAILED;
121         return;
122     }
123 
124     if (printdump == JNI_TRUE) {
125         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;wait_lock&#39; ...\n&quot;, thread_name);
126         printf(&quot;&gt;&gt;&gt; [%s] notifying main thread (wait_lock.notify) ...\n&quot;, thread_name);
127     }
128 
129     err = jvmti-&gt;RawMonitorNotify(wait_lock);
130     if (err != JVMTI_ERROR_NONE) {
131         printf(&quot;(RawMonitorWait#wait) unexpected error: %s (%d)\n&quot;,
132                TranslateError(err), err);
133         result = STATUS_FAILED;
134         return;
135     }
136     err = jvmti-&gt;RawMonitorExit(wait_lock);
137     if (err != JVMTI_ERROR_NONE) {
138         printf(&quot;(RawMonitorExit#wait) unexpected error: %s (%d)\n&quot;,
139                TranslateError(err), err);
140         result = STATUS_FAILED;
141         return;
142     }
143 
144     if (printdump == JNI_TRUE) {
145         printf(&quot;&gt;&gt;&gt; [%s] waiting for interrupt ...\n&quot;, thread_name);
146     }
147 
148     err = jvmti-&gt;RawMonitorWait(monitor, wait_time);
149     if (err != JVMTI_ERROR_INTERRUPT) {
150         printf(&quot;Error expected: JVMTI_ERROR_INTERRUPT,\n&quot;);
151         printf(&quot;\tactual: %s (%d)\n&quot;, TranslateError(err), err);
152         result = STATUS_FAILED;
153     }
154 
155     err = jvmti-&gt;RawMonitorExit(monitor);
156     if (err != JVMTI_ERROR_NONE) {
157         printf(&quot;(RawMonitorExit#test) unexpected error: %s (%d)\n&quot;,
158                TranslateError(err), err);
159         result = STATUS_FAILED;
160     }
161 
162     // We can&#39;t reacquire this monitor until the main thread is waiting for us to
163     // complete.
164     err = jvmti-&gt;RawMonitorEnter(wait_lock);
165     if (err != JVMTI_ERROR_NONE) {
166         printf(&quot;(RawMonitorEnter#wait) unexpected error: %s (%d)\n&quot;,
167                TranslateError(err), err);
168         result = STATUS_FAILED;
169         return;
170     }
171 
172     if (printdump == JNI_TRUE) {
173         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;wait_lock&#39; ...\n&quot;, thread_name);
174         printf(&quot;&gt;&gt;&gt; [%s] notifying main thread we are done ...\n&quot;, thread_name);
175     }
176 
177     err = jvmti-&gt;RawMonitorNotify(wait_lock);
178     if (err != JVMTI_ERROR_NONE) {
179         printf(&quot;(RawMonitorWait#wait) unexpected error: %s (%d)\n&quot;,
180                TranslateError(err), err);
181         result = STATUS_FAILED;
182         return;
183     }
184     err = jvmti-&gt;RawMonitorExit(wait_lock);
185     if (err != JVMTI_ERROR_NONE) {
186         printf(&quot;(RawMonitorExit#wait) unexpected error: %s (%d)\n&quot;,
187                TranslateError(err), err);
188         result = STATUS_FAILED;
189         return;
190     }
191 
192     if (printdump == JNI_TRUE) {
193         printf(&quot;&gt;&gt;&gt; [%s] all done\n&quot;, thread_name);
194     }
195 }
196 
197 JNIEXPORT jint JNICALL
198 Java_nsk_jvmti_RawMonitorWait_rawmnwait005_check(JNIEnv *env,
199         jclass cls, jthread thr, jint wtime) {
200     jvmtiError err;
201     const char* const thread_name = &quot;main thread&quot;;
202 
203     if (!caps.can_signal_thread) {
204         return result;
205     }
206 
207     wait_time = wtime * MILLIS_PER_MINUTE;
208 
209     if (jvmti == NULL) {
210         printf(&quot;JVMTI client was not properly loaded!\n&quot;);
211         return STATUS_FAILED;
212     }
213 
214     err = jvmti-&gt;CreateRawMonitor(&quot;test monitor&quot;, &amp;monitor);
215     if (err != JVMTI_ERROR_NONE) {
216         printf(&quot;(CreateRawMonitor#test) unexpected error: %s (%d)\n&quot;,
217                TranslateError(err), err);
218         return STATUS_FAILED;
219     }
220 
221     // &#39;wait_lock&#39; is used to notify current thread when child thread (&#39;test_thread&#39;)
222     //  is ready. This in particular means &#39;test_thread&#39; is waiting for notification
223     //  of the raw monitor &#39;monitor&#39; and current thread can now interrupt &#39;test_thread&#39;.
224     //
225     err = jvmti-&gt;CreateRawMonitor(&quot;wait lock&quot;, &amp;wait_lock);
226     if (err != JVMTI_ERROR_NONE) {
227         printf(&quot;(CreateRawMonitor#wait) unexpected error: %s (%d)\n&quot;,
228                TranslateError(err), err);
229         return STATUS_FAILED;
230     }
231 
232     // get exclusive ownership of &#39;wait_lock&#39; monitor before
233     //  starting &#39;test_thread&#39; to avoid following race condition:
234     //   &#39;test_thread&#39;     |   current thread
235     //   -------------------------------------
236     //                     | RunAgentThread(..., test_thread, ...)
237     //    wait_lock.enter  |
238     //    wait_lock.notify |
239     //                     | wait_lock.enter
240     //                     | wait_lock.wait(0)
241     //    ...              |
242     //                     |  ... will wait forever ...
243     //
244     // See also 6399368 test bug.
245     //
246     err = jvmti-&gt;RawMonitorEnter(wait_lock);
247     if (err != JVMTI_ERROR_NONE) {
248         printf(&quot;(RawMonitorEnter#wait) unexpected error: %s (%d)\n&quot;,
249                TranslateError(err), err);
250         return STATUS_FAILED;
251     }
252     if (printdump == JNI_TRUE) {
253         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;wait_lock&#39; ... \n&quot;, thread_name);
254     }
255 
256     if (printdump == JNI_TRUE) {
257         printf(&quot;&gt;&gt;&gt; [%s] starting test thread ...\n&quot;, thread_name);
258     }
259 
260     // This starts a daemon thread, so we need to synchronize with it
261     // before we terminate - else the test will end before it checks
262     // it was interrupted!
263 
264     err = jvmti-&gt;RunAgentThread(thr, test_thread, NULL,
265                                 JVMTI_THREAD_NORM_PRIORITY);
266     if (err != JVMTI_ERROR_NONE) {
267         printf(&quot;(RunDebugThread) unexpected error: %s (%d)\n&quot;,
268                TranslateError(err), err);
269         return STATUS_FAILED;
270     }
271 
272     if (printdump == JNI_TRUE) {
273         printf(&quot;&gt;&gt;&gt; [%s] waiting for test thread to run (do wait_lock.wait)...\n&quot;, thread_name);
274     }
275     err = jvmti-&gt;RawMonitorWait(wait_lock, (jlong)0);
276     if (err != JVMTI_ERROR_NONE) {
277         printf(&quot;(RawMonitorWait#wait) unexpected error: %s (%d)\n&quot;,
278                TranslateError(err), err);
279         return STATUS_FAILED;
280     }
281     if (printdump == JNI_TRUE) {
282         printf(&quot;&gt;&gt;&gt; [%s] got notification from test thread ...\n&quot;, thread_name);
283     }
284 
285     // Keep the wait_lock so we can wait again at the end.
286 
287     err = jvmti-&gt;RawMonitorEnter(monitor);
288     if (err != JVMTI_ERROR_NONE) {
289         printf(&quot;(RawMonitorEnter#test) unexpected error: %s (%d)\n&quot;,
290                TranslateError(err), err);
291         return STATUS_FAILED;
292     }
293     if (printdump == JNI_TRUE) {
294         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;monitor&#39; ... \n&quot;, thread_name);
295     }
296 
297     if (printdump == JNI_TRUE) {
298         printf(&quot;&gt;&gt;&gt; [%s] interrupting test thread ...\n&quot;, thread_name);
299     }
300 
301     err = jvmti-&gt;InterruptThread(thr);
302     if (err != JVMTI_ERROR_NONE) {
303         printf(&quot;(InterruptThread) unexpected error: %s (%d)\n&quot;,
304                TranslateError(err), err);
305         result = STATUS_FAILED;
306     }
307 
308     err = jvmti-&gt;RawMonitorExit(monitor);
309     if (err != JVMTI_ERROR_NONE) {
310         printf(&quot;(RawMonitorExit#test) unexpected error: %s (%d)\n&quot;,
311                TranslateError(err), err);
312         result = STATUS_FAILED;
313     }
314 
315     if (printdump == JNI_TRUE) {
316         printf(&quot;&gt;&gt;&gt; [%s] waiting for test thread to complete its wait and notify us ...\n&quot;, thread_name);
317     }
318     err = jvmti-&gt;RawMonitorWait(wait_lock, (jlong)0);
319     if (err != JVMTI_ERROR_NONE) {
320         printf(&quot;(RawMonitorWait#wait) unexpected error: %s (%d)\n&quot;,
321                TranslateError(err), err);
322         return STATUS_FAILED;
323     }
324     if (printdump == JNI_TRUE) {
325         printf(&quot;&gt;&gt;&gt; [%s] got final notification from test thread ...\n&quot;, thread_name);
326     }
327 
328     err = jvmti-&gt;RawMonitorExit(wait_lock);
329     if (err != JVMTI_ERROR_NONE) {
330         printf(&quot;(RawMonitorExit#wait) unexpected error: %s (%d)\n&quot;,
331                TranslateError(err), err);
332         return STATUS_FAILED;
333     }
334 
335     if (printdump == JNI_TRUE) {
336         printf(&quot;&gt;&gt;&gt; [%s] all done\n&quot;, thread_name);
337     }
338 
339     return result;
340 }
341 
342 }
    </pre>
  </body>
</html>
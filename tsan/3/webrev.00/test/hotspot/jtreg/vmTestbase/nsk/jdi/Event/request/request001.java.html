<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jdi/Event/request/request001.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.Event.request;
 25 
 26 import nsk.share.*;
 27 import nsk.share.jdi.*;
 28 
 29 import com.sun.jdi.*;
 30 import com.sun.jdi.event.*;
 31 import com.sun.jdi.request.*;
 32 
 33 import java.util.*;
 34 import java.io.*;
 35 
 36 /**
 37  * The test for the implementation of an object of the type     &lt;BR&gt;
 38  * Event.                                                       &lt;BR&gt;
 39  *                                                              &lt;BR&gt;
 40  * The test checks that results of the method                   &lt;BR&gt;
 41  * &lt;code&gt;com.sun.jdi.Event.request()&lt;/code&gt;                     &lt;BR&gt;
 42  * complies with its spec.                                      &lt;BR&gt;
 43  * &lt;BR&gt;
 44  * The test checks that for all Event objects,                  &lt;BR&gt;
 45  * except for ClassUnloadEvent, the method returns              &lt;BR&gt;
 46  * either the EventRequest that requested this event            &lt;BR&gt;
 47  * or null if event does not have a corresponding request.      &lt;BR&gt;
 48  * &lt;BR&gt;
 49  * The test has three phases and works as follows.              &lt;BR&gt;
 50  * &lt;BR&gt;
 51  * In first phase,                                                      &lt;BR&gt;
 52  * upon launching debuggee&#39;s VM which will be suspended,                &lt;BR&gt;
 53  * a debugger waits for the VMStartEvent within a predefined            &lt;BR&gt;
 54  * time interval. If no the VMStartEvent received, the test is FAILED.  &lt;BR&gt;
 55  * Upon getting the VMStartEvent, it saves its EventSet into            &lt;BR&gt;
 56  * a special array and makes the request for debuggee&#39;s                 &lt;BR&gt;
 57  * ClassPrepareEvent with SUSPEND_EVENT_THREAD, resumes the VM,         &lt;BR&gt;
 58  * and waits for the event within the predefined time interval.         &lt;BR&gt;
 59  * If no the ClassPrepareEvent received, the test is FAILED.            &lt;BR&gt;
 60  * Upon getting the ClassPrepareEvent,                                  &lt;BR&gt;
 61  * the debugger saves its EVENTSet into the array and                   &lt;BR&gt;
 62  * sets up the breakpoint with SUSPEND_EVENT_THREAD                     &lt;BR&gt;
 63  * within debuggee&#39;s special methodForCommunication().                  &lt;BR&gt;
 64  * &lt;BR&gt;
 65  * In second phase the debugger and the debuggee perform the following. &lt;BR&gt;
 66  * - The debugger creates ThreadStartRequest, ThreadDeathRequest, and   &lt;BR&gt;
 67  *   an extra VMDeathRequest, resumes the debuggee, and                 &lt;BR&gt;
 68  *   waits for corresponding ThreadStartEvent and ThreadDeathEvent.     &lt;BR&gt;
 69  * - The debuggee creates new thread,  named &quot;thread2&quot;,                 &lt;BR&gt;
 70  *   whose running creates the above events.                            &lt;BR&gt;
 71  * - Upon getting the events, the debugger saves their sets in the array,&lt;BR&gt;
 72  *   resumes the debuggee and waits for the BreakpointEvent.            &lt;BR&gt;
 73  * - The debuggee creates a number of threads, one for each             &lt;BR&gt;
 74  *   following event: AccessWatchpoint, ModificationWatchpoint,         &lt;BR&gt;
 75  *   MethodEntry, MethodExit, Step, Exception, and Breakpoint,          &lt;BR&gt;
 76  *   and invokes the methodForCommunication to be suspended and         &lt;BR&gt;
 77  *   to inform the debugger with the event.                             &lt;BR&gt;
 78  * - Upon getting the BreakpointForCommunication, the debugger          &lt;BR&gt;
 79  *   gets ThreadReferences mirroring all tested threads in the debuggee,&lt;BR&gt;
 80  *   sets up Requests within them to get EventSETS to check up on,      &lt;BR&gt;
 81  *   resumes the debuggee, waits for events, and upon getting them,     &lt;BR&gt;
 82  *   saves its EventSets into the array.                                &lt;BR&gt;
 83  * &lt;BR&gt;
 84  * In third phase,at the end                                            &lt;BR&gt;
 85  * the debuggee changes the value of the &quot;instruction&quot;                  &lt;BR&gt;
 86  * to inform the debugger of checks finished, and ends.                 &lt;BR&gt;
 87  * The debugger waits for VMDeathEvents and VMDisconnectEvents, and     &lt;BR&gt;
 88  * upon getting them, saves their EventSets into the array.             &lt;BR&gt;
 89  * Finally, the debugger, using the array of EventSets,                 &lt;BR&gt;
 90  * compares Requests from Events to ones set up.                        &lt;BR&gt;
 91  * If any mismatch, the test FAILED.                                    &lt;BR&gt;
 92  * &lt;BR&gt;
 93  * Note. To inform each other of needed actions, the debugger and       &lt;BR&gt;
 94  *       and the debuggee use debuggee&#39;s variable &quot;instruction&quot;.        &lt;BR&gt;
 95  * &lt;BR&gt;
 96  */
 97 
 98 public class request001 {
 99 
100     //----------------------------------------------------- templete section
101     static final int PASSED = 0;
102     static final int FAILED = 2;
103     static final int PASS_BASE = 95;
104 
105     //----------------------------------------------------- templete parameters
106     static final String
107     sHeader1 = &quot;\n==&gt; nsk/jdi/Event/request/request001 &quot;,
108     sHeader2 = &quot;--&gt; debugger: &quot;,
109     sHeader3 = &quot;##&gt; debugger: &quot;;
110 
111     //----------------------------------------------------- main method
112 
113     public static void main (String argv[]) {
114 
115         int result = run(argv, System.out);
116 
117         System.exit(result + PASS_BASE);
118     }
119 
120     public static int run (String argv[], PrintStream out) {
121 
122         int exitCode = new request001().runThis(argv, out);
123 
124         if (exitCode != PASSED) {
125             System.out.println(&quot;TEST FAILED&quot;);
126         }
127         return testExitCode;
128     }
129 
130     //--------------------------------------------------   log procedures
131 
132     private static Log  logHandler;
133 
134     private static void log1(String message) {
135         logHandler.display(sHeader1 + message);
136     }
137     private static void log2(String message) {
138         logHandler.display(sHeader2 + message);
139     }
140     private static void log3(String message) {
141         logHandler.complain(sHeader3 + message);
142     }
143 
144     //  ************************************************    test parameters
145 
146     private String debuggeeName =
147         &quot;nsk.jdi.Event.request.request001a&quot;;
148 
149     private String testedClassName =
150       &quot;nsk.jdi.Event.request.TestClass&quot;;
151 
152     //====================================================== test program
153     //------------------------------------------------------ common section
154 
155     static Debugee          debuggee;
156     static ArgumentHandler  argsHandler;
157 
158     static int waitTime;
159 
160     static VirtualMachine      vm            = null;
161     static EventRequestManager eventRManager = null;
162     static EventQueue          eventQueue    = null;
163     static EventSet            eventSet      = null;
164     static EventIterator       eventIterator = null;
165 
166     static ReferenceType       debuggeeClass = null;
167 
168     static int  testExitCode = PASSED;
169 
170 
171 
172     //  Event #:
173     //  0-6  : AccessWatchpoint, ModificationWatchpoint, Breakpoint, Exception,
174     //         MethodEntry, MethodExit, Step
175     //  7-8  : ClassPrepare, ClassUnload
176     //  9-10 : ThreadDeath, ThreadStart
177     // 11-13 : VMDeath, VMDisconnect, VMStart
178 
179     EventSet     eventSets[] = new EventSet [14];
180     EventRequest eRequests[] = new EventRequest[14];
181 
182     int eventFlags[] = { 0,0,0,0, 0,0,0,0, 3,0,0,0, 1,1 };
183 
184     //------------------------------------------------------ methods
185 
186     private int runThis (String argv[], PrintStream out) {
187 
188         argsHandler     = new ArgumentHandler(argv);
189         logHandler      = new Log(out, argsHandler);
190         Binder binder   = new Binder(argsHandler, logHandler);
191 
192         waitTime        = argsHandler.getWaitTime() * 60000;
193 
194         try {
195             log2(&quot;launching a debuggee :&quot;);
196             log2(&quot;       &quot; + debuggeeName);
197             if (argsHandler.verbose()) {
198                 debuggee = binder.bindToDebugeeNoWait(debuggeeName + &quot; -vbs&quot;);
199             } else {
200                 debuggee = binder.bindToDebugeeNoWait(debuggeeName);
201             }
202             if (debuggee == null) {
203                 log3(&quot;ERROR: no debuggee launched&quot;);
204                 return FAILED;
205             }
206             log2(&quot;debuggee launched&quot;);
207         } catch ( Exception e ) {
208             log3(&quot;ERROR: Exception : &quot; + e);
209             log2(&quot;       test cancelled&quot;);
210             return FAILED;
211         }
212 
213         debuggee.redirectOutput(logHandler);
214 
215         vm = debuggee.VM();
216 
217         eventQueue = vm.eventQueue();
218         if (eventQueue == null) {
219             log3(&quot;ERROR: eventQueue == null : TEST ABORTED&quot;);
220             vm.exit(PASS_BASE);
221             return FAILED;
222         }
223 
224         log2(&quot;invocation of the method runTest()&quot;);
225         switch (runTest()) {
226 
227             case 0 :  log2(&quot;test phase has finished normally&quot;);
228                       log2(&quot;   waiting for the debuggee to finish ...&quot;);
229                       debuggee.waitFor();
230 
231                       log2(&quot;......getting the debuggee&#39;s exit status&quot;);
232                       int status = debuggee.getStatus();
233                       if (status != PASS_BASE) {
234                           log3(&quot;ERROR: debuggee returned UNEXPECTED exit status: &quot; +
235                               status + &quot; != PASS_BASE&quot;);
236                           testExitCode = FAILED;
237                       } else {
238                           log2(&quot;......debuggee returned expected exit status: &quot; +
239                               status + &quot; == PASS_BASE&quot;);
240                       }
241                       break;
242 
243             default : log3(&quot;ERROR: runTest() returned unexpected value&quot;);
244 
245             case 1 :  log3(&quot;test phase has not finished normally: debuggee is still alive&quot;);
246                       log2(&quot;......forcing: vm.exit();&quot;);
247                       testExitCode = FAILED;
248                       try {
249                           vm.exit(PASS_BASE);
250                       } catch ( Exception e ) {
251                           log3(&quot;ERROR: Exception : e&quot;);
252                       }
253                       break;
254 
255             case 2 :  log3(&quot;test cancelled due to VMDisconnectedException&quot;);
256                       log2(&quot;......trying: vm.process().destroy();&quot;);
257                       testExitCode = FAILED;
258                       try {
259                           Process vmProcess = vm.process();
260                           if (vmProcess != null) {
261                               vmProcess.destroy();
262                           }
263                       } catch ( Exception e ) {
264                           log3(&quot;ERROR: Exception : e&quot;);
265                       }
266                       break;
267             }
268 
269         return testExitCode;
270     }
271 
272 
273    /*
274     * Return value: 0 - normal end of the test
275     *               1 - ubnormal end of the test
276     *               2 - VMDisconnectedException while test phase
277     */
278 
279     private int runTest() {
280 
281         try {
282             log2(&quot;waiting for VMStartEvent&quot;);
283             getEventSet();
284 //
285             eventSets[13] = eventSet;
286             if (eventIterator.nextEvent() instanceof VMStartEvent) {
287                 log2(&quot;VMStartEvent received; test begins&quot;);
288 
289                 testRun();
290 
291                 log2(&quot;waiting for VMDeathEvent&quot;);
292                 getEventSet();
293                 eventSets[11] = eventSet;
294                 if ( !(eventIterator.nextEvent() instanceof VMDeathEvent) ) {
295                     log3(&quot;ERROR: last event is not the VMDeathEvent&quot;);
296                     return 1;
297                 }
298 
299                 log2(&quot;waiting for VMDisconnectEvent&quot;);
300                 getEventSet();
301 //
302                 eventSets[12] = eventSet;
303                 if ( !(eventIterator.nextEvent() instanceof VMDisconnectEvent) ) {
304                     log3(&quot;ERROR: last event is not the VMDisconnectEvent&quot;);
305                     return 1;
306                 }
307 
308                 check();
309                 return 0;
310             } else {
311                 log3(&quot;ERROR: first event is not the VMStartEvent&quot;);
312                 return 1;
313             }
314         } catch ( VMDisconnectedException e ) {
315             log3(&quot;ERROR: VMDisconnectedException : &quot; + e);
316             return 2;
317         } catch ( Exception e ) {
318             log3(&quot;ERROR: Exception : &quot; + e);
319             return 1;
320         }
321 
322     }
323 
324     private void testRun()
325                  throws JDITestRuntimeException, Exception {
326 
327         eventRManager = vm.eventRequestManager();
328 
329         ClassPrepareRequest cpRequest = eventRManager.createClassPrepareRequest();
330         cpRequest.setSuspendPolicy( EventRequest.SUSPEND_EVENT_THREAD);
331         cpRequest.addClassFilter(debuggeeName);
332 
333         log2(&quot;......setting up ClassPrepareRequest&quot;);
334         eRequests[7] = cpRequest;
335 
336         cpRequest.enable();
337         vm.resume();
338 
339         getEventSet();
340         eventSets[7] = eventSet;
341 
342         cpRequest.disable();
343 
344         ClassPrepareEvent event = (ClassPrepareEvent) eventIterator.next();
345         debuggeeClass = event.referenceType();
346 
347         if (!debuggeeClass.name().equals(debuggeeName))
348            throw new JDITestRuntimeException(&quot;** Unexpected ClassName for ClassPrepareEvent **&quot;);
349 
350         log2(&quot;      received: ClassPrepareEvent for debuggeeClass&quot;);
351 
352         log2(&quot;......setting up ClassPrepareEvent&quot;);
353 
354         String bPointMethod = &quot;methodForCommunication&quot;;
355         String lineForComm  = &quot;lineForComm&quot;;
356         BreakpointRequest bpRequest;
357 
358         ThreadReference mainThread = debuggee.threadByNameOrThrow(&quot;main&quot;);
359 
360         bpRequest = settingBreakpoint(mainThread,
361                                       debuggeeClass,
362                                       bPointMethod, lineForComm, &quot;zero&quot;);
363         bpRequest.enable();
364 
365     //------------------------------------------------------  testing section
366 
367         log1(&quot;     TESTING BEGINS&quot;);
368 
369         {
370             log2(&quot;...... setting up VMDeathRequest&quot;);
371             if (vm.canRequestVMDeathEvent()) {
372                 VMDeathRequest vmdr = eventRManager.createVMDeathRequest();
373                 vmdr.putProperty(&quot;number&quot;, &quot;VMDeathRequest&quot;);
374                 vmdr.setSuspendPolicy(EventRequest.SUSPEND_NONE);
375                 vmdr.enable();
376                 eRequests[11] = vmdr;
377             } else {
378                 eventFlags[11] = 2;
379             }
380 
381             log2(&quot;......setting up ThreadStartRequest&quot;);
382             ThreadStartRequest tsr = eventRManager.createThreadStartRequest();
383             tsr.addCountFilter(1);
384             tsr.setSuspendPolicy(EventRequest.SUSPEND_ALL);
385             tsr.putProperty(&quot;number&quot;, &quot;ThreadStartRequest&quot;);
386             tsr.enable();
387 
388             eRequests[10] = tsr;
389 
390             log2(&quot;......setting up ThreadDeathRequest&quot;);
391             ThreadDeathRequest tdr = eventRManager.createThreadDeathRequest();
392             tdr.addCountFilter(1);
393             tdr.setSuspendPolicy(EventRequest.SUSPEND_ALL);
394             tsr.putProperty(&quot;number&quot;, &quot;ThreadDeathRequest&quot;);
395             tdr.enable();
396 
397             eRequests[9] = tdr;
398 
399             log2(&quot;......vm.resume();&quot;);
400             vm.resume();
401 
402             log2(&quot;......waiting for ThreadStartEvent&quot;);
403             getEventSet();
404             eventSets[10] = eventSet;
405 
406             Event receivedEvent = eventIterator.nextEvent();
407             if ( !(receivedEvent instanceof ThreadStartEvent) ) {
408                 testExitCode = FAILED;
409                 log3(&quot;ERROR: new event is not ThreadStartEvent: &quot; + receivedEvent);
410                 return;
411             }
412             tsr.disable();
413 
414             log2(&quot;......vm.resume();&quot;);
415             vm.resume();
416 
417             log2(&quot;......waiting for ThreadDeathEvent&quot;);
418             getEventSet();
419             eventSets[9] = eventSet;
420             receivedEvent = eventIterator.nextEvent();
421             if ( !(receivedEvent instanceof ThreadDeathEvent) ) {
422                 testExitCode = FAILED;
423                 log3(&quot;ERROR: new event is not ThreadDeathEvent: &quot; + receivedEvent);
424                 return;
425             }
426             tdr.disable();
427         }
428 
429         for (int i = 0; ; i++) {
430 
431             vm.resume();
432             breakpointForCommunication();
433 
434             int instruction = ((IntegerValue)
435                                (debuggeeClass.getValue(debuggeeClass.fieldByName(&quot;instruction&quot;)))).value();
436 
437             if (instruction == 0) {
438                 vm.resume();
439                 break;
440             }
441 
442             log1(&quot;:::::: case: # &quot; + i);
443 
444             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ variable part
445 
446             String bpLineName        = &quot;breakpointLine&quot;;
447             String bpMethodName      = &quot;method&quot;;
448             String awFieldName       = &quot;awFieldName&quot;;
449             String mwFieldName       = &quot;mwFieldName&quot;;
450 
451             String namesArray = &quot;threadNames&quot;;
452 
453             String threadNames[] = {
454                     &quot;awThread&quot;  ,
455                     &quot;mwThread&quot;  ,
456                     &quot;bpThread&quot;  ,
457                     &quot;excThread&quot; ,
458                     &quot;menThread&quot; ,
459                     &quot;mexThread&quot; ,
460                     &quot;stThread&quot;
461                };
462 
463             int flags = 0;
464 
465             ThreadReference eventThreads[] = new ThreadReference[threadNames.length];
466 
467 
468             List allThreads = vm.allThreads();
469 
470             log2(&quot;......getting: ArrayReference namesRef = (ArrayReference) debuggeeClass.getValue(debuggeeClass.fieldByName(namesArray));&quot;);
471             ArrayReference namesRef = (ArrayReference)
472                          debuggeeClass.getValue(debuggeeClass.fieldByName(namesArray));
473             log2(&quot;       namesRef.length() == &quot; + namesRef.length());
474 
475             log2(&quot;......getting and checking up on debuggee threads&#39; names&quot;);
476             for (int n1 = 0; n1 &lt; namesRef.length(); n1++) {
477 
478                 log2(&quot;      String name = ((StringReference) namesRef.getValue(n1)).value();&quot;);
479                 String name = ((StringReference) namesRef.getValue(n1)).value();
480 
481                 label0: {
482                     for (int n2 = 0; n2 &lt; threadNames.length; n2++) {
483 
484                         if (name.equals(threadNames[n2])) {
485                             ListIterator li  = allThreads.listIterator();
486                             for (; li.hasNext(); ) {
487                                 ThreadReference thread = (ThreadReference) li.next();
488                                 if (thread.name().equals(name)) {
489                                     eventThreads[n1] =  thread;
490                                     break;
491                                 }
492                             }
493                             break label0;
494                         }
495                     }
496                     testExitCode = FAILED;
497                     log3(&quot;ERROR: no thread found in the debuggee : &quot; + name);
498                 }
499             }
500             if (testExitCode == FAILED)
501                 break;
502 
503 
504             log2(&quot;......ReferenceType testClass = (ReferenceType) (vm.classesByName(testedClassName)).get(0);&quot;);
505             ReferenceType testClass = (ReferenceType) (vm.classesByName(testedClassName)).get(0);
506 
507             log2(&quot;......setting up Requests&quot;);
508             for ( int n3 = 0; n3 &lt; namesRef.length(); n3++) {
509                  switch (n3) {
510                       case 0:
511                              if (vm.canWatchFieldAccess()) {
512                                  String awName = ( (StringReference) testClass.getValue(
513                                              testClass.fieldByName(awFieldName))).value();
514                                  eRequests[n3] = settingAccessWatchpoint(eventThreads[n3],
515                                               testClass, awName, threadNames[n3]);
516                                  eRequests[n3].enable();
517                                  flags |= 1;
518                              }
519                              break;
520 
521                       case 1:
522                              if (vm.canWatchFieldModification() ) {
523                                  String mwName = ( (StringReference) testClass.getValue(
524                                              testClass.fieldByName(mwFieldName))).value();
525                                  eRequests[n3] = settingModificationWatchpoint(eventThreads[n3],
526                                               testClass, mwName, threadNames[n3]);
527                                  eRequests[n3].enable();
528                                  flags |= 1&lt;&lt;1;
529                              }
530                              break;
531 
532                       case 2:
533                              eRequests[n3] = settingBreakpoint(eventThreads[n3], testClass,
534                                                bpMethodName, bpLineName, threadNames[n3]);
535                              eRequests[n3].setSuspendPolicy( EventRequest.SUSPEND_NONE);
536                              eRequests[n3].enable();
537                              flags |= 1&lt;&lt;2;
538                              break;
539 
540                       case 3:
541                              eRequests[n3] = settingException(eventThreads[n3], debuggeeClass,
542                                                                 threadNames[n3]);
543                              eRequests[n3].enable();
544                              flags |= 1&lt;&lt;3;
545                              break;
546 
547                       case 4:
548                              eRequests[n3] = settingMethodEntry(eventThreads[n3], testClass,
549                                                                 threadNames[n3]);
550                              eRequests[n3].enable();
551                              flags |= 1&lt;&lt;4;
552                              break;
553 
554                       case 5:
555                              eRequests[n3] = settingMethodExit(eventThreads[n3], testClass,
556                                                                 threadNames[n3]);
557                              eRequests[n3].enable();
558                              flags |= 1&lt;&lt;5;
559                              break;
560 
561                       case 6:
562                              eRequests[n3] = settingStep(eventThreads[n3], threadNames[n3]);
563                              eRequests[n3].enable();
564                              flags |= 1&lt;&lt;6;
565                              break;
566 
567                       default:
568                              throw new JDITestRuntimeException(&quot;** default case while prepareing requests**&quot;);
569                 }
570             }
571 
572             log2(&quot;:::::::::vm.resume();&quot;);
573             vm.resume();
574 
575             Event  event1     = null;
576             int    flagsCopy  = flags;
577             String eName      = null;
578             int    index      = 0;
579 
580             log2(&quot;......getting and checking up on Events&quot;);
581             for (int n4 = 0; n4 &lt; namesRef.length(); n4++) {
582                 int flag;
583 
584                 getEventSet();
585                 event1 = eventIterator.nextEvent();
586 
587                 if (event1 instanceof AccessWatchpointEvent) {
588                     index = 0;
589                 } else if (event1 instanceof ModificationWatchpointEvent ) {
590                     index = 1;
591                 } else if (event1 instanceof BreakpointEvent ) {
592                     index = 2;
593                 } else if (event1 instanceof ExceptionEvent ) {
594                     index = 3;
595                 } else if (event1 instanceof MethodEntryEvent ) {
596                     index = 4;
597                 } else if (event1 instanceof MethodExitEvent ) {
598                     index = 5;
599                 } else if (event1 instanceof StepEvent ) {
600                     index = 6;
601                 } else {
602                     log3(&quot;ERROR: else clause in detecting type of event1&quot;);
603                     testExitCode = FAILED;
604                 }
605 
606                 flag = 1 &lt;&lt; index;
607                 if ((flagsCopy &amp; flag) == 0) {
608                     log3(&quot;ERROR: event duplication: &quot; + eName);
609                     testExitCode = FAILED;
610                 } else {
611                     flagsCopy ^= flag;
612                     flags |= flag;
613                 }
614 
615                 eventSets[index] = eventSet;
616             }
617 
618             if (testExitCode == FAILED)
619                 break;
620 
621             breakpointForCommunication();
622 
623             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
624         }
625         log1(&quot;    TESTING ENDS&quot;);
626         return;
627     }
628 
629    /*
630     * private BreakpointRequest settingBreakpoint(ThreadReference, ReferenceType,
631     *                                             String, String, String)
632     *
633     * It sets up a breakpoint at given line number within a given method in a given class
634     * for a given thread.
635     *
636     * Return value: BreakpointRequest object  in case of success
637     *
638     * JDITestRuntimeException   in case of an Exception thrown within the method
639     */
640 
641     private BreakpointRequest settingBreakpoint ( ThreadReference thread,
642                                                   ReferenceType testedClass,
643                                                   String methodName,
644                                                   String bpLine,
645                                                   String property)
646             throws JDITestRuntimeException {
647 
648         log2(&quot;......setting up a breakpoint:&quot;);
649         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
650                         &quot;; method: &quot; + methodName + &quot;; line: &quot; + bpLine);
651 
652         List              alllineLocations = null;
653         Location          lineLocation     = null;
654         BreakpointRequest breakpRequest    = null;
655 
656         try {
657             Method  method  = (Method) testedClass.methodsByName(methodName).get(0);
658 
659             alllineLocations = method.allLineLocations();
660 
661             int n =
662                 ( (IntegerValue) testedClass.getValue(testedClass.fieldByName(bpLine) ) ).value();
663             if (n &gt; alllineLocations.size()) {
664                 log3(&quot;ERROR:  TEST_ERROR_IN_settingBreakpoint(): number is out of bound of method&#39;s lines&quot;);
665             } else {
666                 lineLocation = (Location) alllineLocations.get(n);
667                 try {
668                     breakpRequest = eventRManager.createBreakpointRequest(lineLocation);
669                     breakpRequest.putProperty(&quot;number&quot;, property);
670                     breakpRequest.addThreadFilter(thread);
671                     breakpRequest.setSuspendPolicy( EventRequest.SUSPEND_EVENT_THREAD);
672                 } catch ( Exception e1 ) {
673                     log3(&quot;ERROR: inner Exception within settingBreakpoint() : &quot; + e1);
674                     breakpRequest    = null;
675                 }
676             }
677         } catch ( Exception e2 ) {
678             log3(&quot;ERROR: ATTENTION:  outer Exception within settingBreakpoint() : &quot; + e2);
679             breakpRequest    = null;
680         }
681 
682         if (breakpRequest == null) {
683             log2(&quot;      A BREAKPOINT HAS NOT BEEN SET UP&quot;);
684             throw new JDITestRuntimeException(&quot;**FAILURE to set up a breakpoint**&quot;);
685         }
686 
687         log2(&quot;      a breakpoint has been set up&quot;);
688         return breakpRequest;
689     }
690 
691 
692     private void getEventSet()
693                  throws JDITestRuntimeException {
694         try {
695             eventSet = eventQueue.remove(waitTime);
696             if (eventSet == null) {
697                 throw new JDITestRuntimeException(&quot;** TIMEOUT while waiting for event **&quot;);
698             }
699             eventIterator = eventSet.eventIterator();
700         } catch ( Exception e ) {
701             throw new JDITestRuntimeException(&quot;** EXCEPTION while waiting for event ** : &quot; + e);
702         }
703     }
704 
705 
706     private void breakpointForCommunication()
707                  throws JDITestRuntimeException {
708 
709         log2(&quot;breakpointForCommunication&quot;);
710         getEventSet();
711 
712         if (eventIterator.nextEvent() instanceof BreakpointEvent)
713             return;
714 
715         throw new JDITestRuntimeException(&quot;** event IS NOT a breakpoint **&quot;);
716     }
717 
718     // ============================== test&#39;s additional methods
719 
720     private AccessWatchpointRequest settingAccessWatchpoint (
721                                                   ThreadReference thread,
722                                                   ReferenceType testedClass,
723                                                   String fieldName,
724                                                   String property)
725             throws JDITestRuntimeException {
726 
727         log2(&quot;......setting up AccessWatchpoint:&quot;);
728         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
729                              &quot;; fieldName: &quot; + fieldName);
730 
731         AccessWatchpointRequest awRequest = null;
732         try {
733             Field field = testedClass.fieldByName(fieldName);
734             awRequest = eventRManager.createAccessWatchpointRequest(field);
735             awRequest.putProperty(&quot;number&quot;, property);
736             awRequest.addThreadFilter(thread);
737             awRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
738         } catch ( Exception e ) {
739             log3(&quot;ERROR: ATTENTION: Exception within settingAccessWatchpoint() : &quot; + e);
740             log3(&quot;       AN ACCESSWATCHPOINT HAS NOT BEEN SET UP&quot;);
741             throw new JDITestRuntimeException(&quot;** FAILURE to set up an AccessWatchpoint **&quot;);
742         }
743 
744         log2(&quot;      an AccessWatchpoint has been set up&quot;);
745         return awRequest;
746     }
747 
748     private ModificationWatchpointRequest settingModificationWatchpoint (
749                                                   ThreadReference thread,
750                                                   ReferenceType testedClass,
751                                                   String fieldName,
752                                                   String property)
753             throws JDITestRuntimeException {
754 
755         log2(&quot;......setting up ModificationWatchpoint:&quot;);
756         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
757                              &quot;; fieldName: &quot; + fieldName);
758 
759         ModificationWatchpointRequest mwRequest = null;
760         try {
761             Field field = testedClass.fieldByName(fieldName);
762             mwRequest = eventRManager.createModificationWatchpointRequest(field);
763             mwRequest.putProperty(&quot;number&quot;, property);
764             mwRequest.addThreadFilter(thread);
765             mwRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
766         } catch ( Exception e ) {
767             log3(&quot;ERROR: ATTENTION: Exception within settingModificationWatchpoint() : &quot; + e);
768             log3(&quot;       AN ModificationWATCHPOINT HAS NOT BEEN SET UP&quot;);
769             throw new JDITestRuntimeException(&quot;** FAILURE to set up an AccessWatchpoint **&quot;);
770         }
771 
772         log2(&quot;      a ModificationWatchpoint has been set up&quot;);
773         return mwRequest;
774     }
775 
776     private MethodEntryRequest settingMethodEntry ( ThreadReference thread,
777                                                     ReferenceType testedClass,
778                                                     String property)
779             throws JDITestRuntimeException {
780 
781         log2(&quot;......setting up MethodEntry:&quot;);
782         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
783                              &quot;; property: &quot; + property);
784 
785         MethodEntryRequest menRequest = null;
786         try {
787             menRequest = eventRManager.createMethodEntryRequest();
788             menRequest.putProperty(&quot;number&quot;, property);
789             menRequest.addThreadFilter(thread);
790             menRequest.addClassFilter(testedClass);
791             menRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
792         } catch ( Exception e ) {
793             log3(&quot;ERROR: ATTENTION: Exception within settingMethodEntry() : &quot; + e);
794             log3(&quot;       A MethodEntry HAS NOT BEEN SET UP&quot;);
795             throw new JDITestRuntimeException(&quot;** FAILURE to set up a MethodEntry **&quot;);
796         }
797 
798         log2(&quot;      a MethodEntry has been set up&quot;);
799         return menRequest;
800     }
801 
802     private MethodExitRequest settingMethodExit ( ThreadReference thread,
803                                                   ReferenceType testedClass,
804                                                   String property)
805             throws JDITestRuntimeException {
806 
807         log2(&quot;......setting up MethodExit:&quot;);
808         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
809                              &quot;; property: &quot; + property);
810 
811         MethodExitRequest mexRequest = null;
812         try {
813             mexRequest = eventRManager.createMethodExitRequest();
814             mexRequest.putProperty(&quot;number&quot;, property);
815             mexRequest.addThreadFilter(thread);
816             mexRequest.addClassFilter(testedClass);
817             mexRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
818         } catch ( Exception e ) {
819             log3(&quot;ERROR: ATTENTION: Exception within settingMethodExit() : &quot; + e);
820             log3(&quot;       A MethodExit HAS NOT BEEN SET UP&quot;);
821             throw new JDITestRuntimeException(&quot;** FAILURE to set up a MethodExit **&quot;);
822         }
823 
824         log2(&quot;      a MethodExit has been set up&quot;);
825         return mexRequest;
826     }
827 
828     private StepRequest settingStep ( ThreadReference thread, String property)
829             throws JDITestRuntimeException {
830 
831         log2(&quot;......setting up Step:&quot;);
832         log2(&quot;       thread: &quot; + thread + &quot;; property: &quot; + property);
833 
834         StepRequest stRequest = null;
835         try {
836             stRequest = eventRManager.createStepRequest(thread, StepRequest.STEP_LINE, StepRequest.STEP_OVER);
837             stRequest.putProperty(&quot;number&quot;, property);
838             stRequest.addCountFilter(1);
839             stRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
840         } catch ( Exception e ) {
841             log3(&quot;ERROR: ATTENTION: Exception within settingStep() : &quot; + e);
842             log3(&quot;       A Step HAS NOT BEEN SET UP&quot;);
843             throw new JDITestRuntimeException(&quot;** FAILURE to set up a Step **&quot;);
844         }
845 
846         log2(&quot;      a Step has been set up&quot;);
847         return stRequest;
848     }
849 
850 
851     private ExceptionRequest settingException ( ThreadReference thread,
852                                                 ReferenceType testedClass,
853                                                 String property)
854             throws JDITestRuntimeException {
855 
856         log2(&quot;......setting up Exception:&quot;);
857         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
858                              &quot;; property: &quot; + property);
859 
860         ExceptionRequest excRequest = null;
861         try {
862             excRequest = eventRManager.createExceptionRequest(null, true, true);
863             excRequest.putProperty(&quot;number&quot;, property);
864             excRequest.addThreadFilter(thread);
865             excRequest.addClassFilter(testedClass);
866             excRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
867         } catch ( Exception e ) {
868             log3(&quot;ERROR: ATTENTION: Exception within settingException() : &quot; + e);
869             log3(&quot;       A Exception HAS NOT BEEN SET UP&quot;);
870             throw new JDITestRuntimeException(&quot;** FAILURE to set up a Exception **&quot;);
871         }
872 
873         log2(&quot;      a Exception has been set up&quot;);
874         return excRequest;
875     }
876 
877     private void check() {
878 
879         EventSet      evSet = null;
880         EventIterator evI   = null;
881         EventRequest  eR    = null;
882 
883         log2(&quot;......performing the check;&quot;);
884         for (int k = 0; k &lt; eventFlags.length; k++) {
885 
886             switch (eventFlags[k]) {
887 
888             case 0:
889                    evSet = eventSets[k];
890                    evI   = evSet.eventIterator();
891                    if (eRequests[k].equals(evI.nextEvent().request()))
892                        break;
893                    testExitCode = FAILED;
894                    log3(&quot;ERROR: eventRequest is not equal to event.request() : k == &quot; + k);
895                    break;
896 
897 
898             case 1:
899                    evSet = eventSets[k];
900                    evI   = evSet.eventIterator();
901                    if (evI.nextEvent().request() == null)
902                        break;
903                    testExitCode = FAILED;
904                    log3(&quot;ERROR: event.request() != null : k == &quot; + k);
905                    break;
906 
907             case 2:
908                    evSet = eventSets[k];
909                    evI   = evSet.eventIterator();
910                    try {
911                        eR = evI.nextEvent().request();
912                        if (eR == null) {
913                            if ( !eRequests[k].equals(evI.nextEvent().request()) ) {
914                                testExitCode = FAILED;
915                                log3(&quot;ERROR: eventRequest is not equal to event.request() : k == &quot; + k);
916                            }
917                        } else {
918                            if ( !eRequests[k].equals(eR) ) {
919                                testExitCode = FAILED;
920                                log3(&quot;ERROR: eventRequest is not equal to event.request() : k == &quot; + k);
921                            } else if (evI.nextEvent().request() != null) {
922                                testExitCode = FAILED;
923                                log3(&quot;ERROR: eventRequest != null : k == &quot; + k);
924                            }
925                        }
926                    } catch ( Exception e ) {
927                        log3(&quot;ERROR: Unexpected Exception : &quot; + e + &quot; :: k == &quot; + k);
928                        testExitCode = FAILED;
929                    }
930                    break;
931 
932             case 3:
933                    break;
934 
935             default:
936                     log3(&quot;ERROR: unexpected default case&quot;);
937                     testExitCode = FAILED;
938                     throw new JDITestRuntimeException(&quot;** FAILURE within check() **&quot;);
939             }
940         }
941     }
942 
943 }
    </pre>
  </body>
</html>
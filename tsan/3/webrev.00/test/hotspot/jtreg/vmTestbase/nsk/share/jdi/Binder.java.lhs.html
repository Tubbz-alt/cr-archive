<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/share/jdi/Binder.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package nsk.share.jdi;
  25 
  26 import nsk.share.*;
  27 import nsk.share.jpda.*;
  28 
  29 import com.sun.jdi.*;
  30 import com.sun.jdi.connect.*;
  31 
  32 import com.sun.jdi.connect.Connector.Argument;
  33 import java.io.*;
  34 import java.net.*;
  35 import java.util.*;
  36 
  37 /**
  38  * This class provides debugger with connection to debugee VM
  39  * using JDI connectors.
  40  *&lt;p&gt;
  41  * This class provides abilities to launch and bind to debugee VM
  42  * as described for base &lt;code&gt;DebugeeBinder&lt;/code&gt; class,
  43  * using JDI connectors and &lt;code&gt;com.sun.VirtualMachine&lt;/code&gt; mirror.
  44  * &lt;p&gt;
  45  * When &lt;code&gt;Binder&lt;/code&gt; is asked to bind to debugee by invoking
  46  * &lt;code&gt;bindToBebugee()&lt;/code&gt; method it uses
  47  * &lt;code&gt;com.sun.jdi.Connector&lt;/code&gt; object corresponding to
  48  * value of command line options &lt;code&gt;-connector&lt;/code&gt; and
  49  * &lt;code&gt;-transport&lt;/code&gt; to launch and connect to debugee VM.
  50  * After debugee is launched and connection is established
  51  * &lt;code&gt;Binder&lt;/code&gt; uses &lt;code&gt;com.sun.jdi.VirtualMachine&lt;/code&gt;
  52  * object to construct &lt;code&gt;Debugee&lt;/code&gt; object, that
  53  * provides abilities to interact with debugee VM.
  54  *
  55  * @see Debugee
  56  * @see DebugeeBinder
  57  */
  58 public class Binder extends DebugeeBinder {
  59 
  60     /**
  61      * Default message prefix for &lt;code&gt;Binder&lt;/code&gt; object.
  62      */
  63     public static final String LOG_PREFIX = &quot;binder&gt; &quot;;
  64 
  65     /**
  66      * Get version string.
  67      */
  68     public static String getVersion () {
  69         return &quot;@(#)Binder.java 1.14 03/10/08&quot;;
  70     }
  71 
  72     // -------------------------------------------------- //
  73 
  74     /**
  75      * Handler of command line arguments.
  76      */
  77     private ArgumentHandler argumentHandler = null;
  78 
  79     /**
  80      * Return &lt;code&gt;argumentHandler&lt;/code&gt; of this binder.
  81      */
  82     public ArgumentHandler getArgumentHandler() {
  83         return argumentHandler;
  84     }
  85 
  86     // -------------------------------------------------- //
  87 
  88     /**
  89      * Make &lt;code&gt;Binder&lt;/code&gt; object and pass raw command line arguments.
  90      *
  91      * @deprecated  Use newer
  92      *              &lt;code&gt;Binder(ArgumentHandler,Log)&lt;/code&gt;
  93      *              constructor.
  94      */
  95     public Binder (String args[]) {
  96         this(args, new Log(System.err));
  97     }
  98 
  99     /**
 100      * Make &lt;code&gt;Binder&lt;/code&gt; object for raw command line arguments
 101      * and specified &lt;code&gt;log&lt;/code&gt; object.
 102      *
 103      * @deprecated  Use newer
 104      *              &lt;code&gt;Binder(ArgumentHandler,Log)&lt;/code&gt;
 105      *              constructor.
 106      */
 107     public Binder (String args[], Log log) {
 108         this(new ArgumentHandler(args), log);
 109     }
 110 
 111     /**
 112      * Make &lt;code&gt;Binder&lt;/code&gt; object for specified command line arguments
 113      * and &lt;code&gt;log&lt;/code&gt; object.
 114      */
 115     public Binder (ArgumentHandler argumentHandler, Log log) {
 116         super(argumentHandler, log);
 117         this.argumentHandler = argumentHandler;
 118     }
 119 
 120     // -------------------------------------------------- //
 121 
 122     /**
 123      * Make initial &lt;code&gt;Debugee&lt;/code&gt; object for local debuggee process
 124      * started with launching connector.
 125      */
 126     public Debugee makeLocalDebugee(Process process) {
 127         LocalLaunchedDebugee debugee = new LocalLaunchedDebugee(process, this);
 128 
 129         Finalizer finalizer = new Finalizer(debugee);
 130         finalizer.activate();
 131 
 132         return debugee;
 133     }
 134 
 135     /**
 136      * Launch local debuggee process with specified command line
 137      * and make initial &lt;code&gt;Debugee&lt;/code&gt; object.
 138      */
 139     public Debugee startLocalDebugee(String cmd) {
 140         Process process = null;
 141 
 142         try {
 143             process = launchProcess(cmd);
 144         } catch (IOException e) {
 145             e.printStackTrace(log.getOutStream());
 146             throw new Failure(&quot;Caught exception while launching local debuggee VM process:\n\t&quot;
 147                             + e);
 148         }
 149 
 150         return makeLocalDebugee(process);
 151     }
 152 
 153     /**
 154      * Make debuggee wrapper for already launched debuggee VM.
 155      * After enwraping debugee&#39;s output is redirected to Binder&#39;s log,
 156      * VMStartEvent is received and debuggee is initialized.
 157      */
 158     public Debugee enwrapDebugee(VirtualMachine vm, Process proc) {
 159         Debugee debugee = makeLocalDebugee(proc);
 160 
 161         display(&quot;Redirecting VM output&quot;);
 162         debugee.redirectOutput(log);
 163         debugee.setupVM(vm);
 164 
 165         long timeout = argumentHandler.getWaitTime() * 60 * 1000; // milliseconds
 166 
 167         display(&quot;Waiting for VM initialized&quot;);
 168         debugee.waitForVMInit(timeout);
 169 
 170         return debugee;
 171     }
 172 
 173     /**
 174      * Launch debugee VM and establish connection to it without waiting for VMStartEvent.
 175      * After launching debugee&#39;s output is redirected to Binder&#39;s log,
 176      * but VMStartEvent is not received and so debuggee is not fully initialized.
 177      *
 178      * @see #bindToDebugee(String)
 179      */
 180     public Debugee bindToDebugeeNoWait(String classToExecute) {
 181 
 182         VirtualMachineManager vmm = Bootstrap.virtualMachineManager();
 183         display(&quot;VirtualMachineManager: version &quot;
 184                 + vmm.majorInterfaceVersion() + &quot;.&quot;
 185                 + vmm.minorInterfaceVersion());
 186 
 187         Debugee debugee = null;
 188 
 189         String classPath = null;
 190 //        classPath = System.getProperty(&quot;java.class.path&quot;);
 191 
 192         prepareForPipeConnection(argumentHandler);
 193 
 194         if (argumentHandler.isLaunchedLocally()) {
 195 
 196             if (argumentHandler.isDefaultConnector()) {
 197                 debugee = localDefaultLaunchDebugee(vmm, classToExecute, classPath);
 198             } else if (argumentHandler.isRawLaunchingConnector()) {
 199                 debugee = localRawLaunchDebugee(vmm, classToExecute, classPath);
 200             } else if (argumentHandler.isLaunchingConnector()) {
 201                 debugee = localLaunchDebugee(vmm, classToExecute, classPath);
 202             } else if (argumentHandler.isAttachingConnector()) {
 203                 debugee = localLaunchAndAttachDebugee(vmm, classToExecute, classPath);
<a name="2" id="anc2"></a><span class="line-removed"> 204             } else if (argumentHandler.isLaunchingConnector()) {</span>
<span class="line-removed"> 205                 debugee = localLaunchDebugee(vmm, classToExecute, classPath);</span>
 206             } else if (argumentHandler.isListeningConnector()) {
 207                 debugee = localLaunchAndListenDebugee(vmm, classToExecute, classPath);
 208             } else {
 209                 throw new TestBug(&quot;Unexpected connector type for local debugee launch mode&quot;
 210                                   + argumentHandler.getConnectorType());
 211             }
 212 
 213         } else if (argumentHandler.isLaunchedRemotely()) {
 214 
 215             connectToBindServer(classToExecute);
 216 
 217             if (argumentHandler.isAttachingConnector()) {
 218                 debugee = remoteLaunchAndAttachDebugee(vmm, classToExecute, classPath);
 219             } else if (argumentHandler.isListeningConnector()) {
 220                 debugee = remoteLaunchAndListenDebugee(vmm, classToExecute, classPath);
 221             } else {
 222                 throw new TestBug(&quot;Unexpected connector type for remote debugee launch mode&quot;
 223                                   + argumentHandler.getConnectorType());
 224             }
 225 
 226         } else if (argumentHandler.isLaunchedManually()) {
 227 
 228             if (argumentHandler.isAttachingConnector()) {
 229                 debugee = manualLaunchAndAttachDebugee(vmm, classToExecute, classPath);
 230             } else if (argumentHandler.isListeningConnector()) {
 231                 debugee = manualLaunchAndListenDebugee(vmm, classToExecute, classPath);
 232             } else {
 233                 throw new TestBug(&quot;Unexpected connector type for manual debugee launch mode&quot;
 234                                   + argumentHandler.getConnectorType());
 235             }
 236 
 237         } else {
 238             throw new Failure(&quot;Unexpected debugee launching mode: &quot; + argumentHandler.getLaunchMode());
 239         }
 240 
 241         return debugee;
 242     }
 243 
 244     /**
 245      * Launch debugee VM and establish JDI connection.
 246      * After launching debugee&#39;s output is redirected to Binder&#39;s log,
 247      * VMStart event is received and debuggee is initialized.
 248      *
 249      * @see #bindToDebugeeNoWait(String)
 250      */
 251     public Debugee bindToDebugee(String classToExecute) {
 252         Debugee debugee = bindToDebugeeNoWait(classToExecute);
 253 
 254         if(argumentHandler.getOptions().getProperty(&quot;traceAll&quot;) != null)
 255             debugee.VM().setDebugTraceMode(VirtualMachine.TRACE_ALL);
 256 
 257         long timeout = argumentHandler.getWaitTime() * 60 * 1000; // milliseconds
 258 
 259         display(&quot;Waiting for VM initialized&quot;);
 260         debugee.waitForVMInit(timeout);
 261 
 262         return debugee;
 263     }
 264 
 265     // -------------------------------------------------- //
 266 
 267     /**
 268      * Launch debugee locally via the default LaunchingConnector.
 269      */
 270     private Debugee localDefaultLaunchDebugee (VirtualMachineManager vmm,
 271                                                 String classToExecute,
 272                                                 String classPath) {
 273         display(&quot;Finding connector: &quot; + &quot;default&quot; );
 274         LaunchingConnector connector = vmm.defaultConnector();
 275         Map&lt;String,? extends Argument&gt; arguments = setupLaunchingConnector(connector, classToExecute, classPath);
 276 
 277         VirtualMachine vm;
 278         try {
 279             display(&quot;Launching debugee&quot;);
 280             vm = connector.launch(arguments);
 281         } catch (IllegalConnectorArgumentsException e) {
 282             e.printStackTrace(log.getOutStream());
 283             throw new TestBug(&quot;Wrong connector arguments used to launch debuggee VM:\n\t&quot; + e);
 284         } catch (VMStartException e) {
 285             e.printStackTrace(log.getOutStream());
 286             String msg = readVMStartExceptionOutput(e, log.getOutStream());
 287             throw new Failure(&quot;Caught exception while starting debugee VM:\n\t&quot; + e + &quot;\n&quot; + msg);
 288         } catch (IOException e) {
 289             e.printStackTrace(log.getOutStream());
 290             throw new Failure(&quot;Caught exception while launching debugee VM:\n\t&quot; + e);
 291         };
 292 
 293         Process process = vm.process();
 294         Debugee debugee = makeLocalDebugee(process);
 295         debugee.redirectOutput(log);
 296         debugee.setupVM(vm);
 297 
 298         return debugee;
 299     }
 300 
 301 
 302     /**
 303      * Launch debugee locally via the default LaunchingConnector.
 304      */
 305     private Debugee localLaunchDebugee (VirtualMachineManager vmm,
 306                                             String classToExecute,
 307                                             String classPath) {
 308 
 309         display(&quot;Finding connector: &quot; + argumentHandler.getConnectorName() );
 310         LaunchingConnector connector =
 311             (LaunchingConnector) findConnector(argumentHandler.getConnectorName(),
 312                                                 vmm.launchingConnectors());
 313         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupLaunchingConnector(connector, classToExecute, classPath);
 314 
 315         VirtualMachine vm;
 316         try {
 317             display(&quot;Launching debugee&quot;);
 318             vm = connector.launch(arguments);
 319         } catch (IllegalConnectorArgumentsException e) {
 320             e.printStackTrace(log.getOutStream());
 321             throw new TestBug(&quot;Wrong connector arguments used to launch debuggee VM:\n\t&quot; + e);
 322         } catch (VMStartException e) {
 323             e.printStackTrace(log.getOutStream());
 324             String msg = readVMStartExceptionOutput(e, log.getOutStream());
 325             throw new Failure(&quot;Caught exception while starting debugee VM:\n\t&quot; + e + &quot;\nProcess output:\n\t&quot; + msg);
 326         } catch (IOException e) {
 327             e.printStackTrace(log.getOutStream());
 328             throw new Failure(&quot;Caught exception while launching debugee VM:\n\t&quot; + e);
 329         };
 330 
 331         Process process = vm.process();
 332         Debugee debugee = makeLocalDebugee(process);
 333         debugee.redirectOutput(log);
 334         debugee.setupVM(vm);
 335 
 336         return debugee;
 337     }
 338 
 339     /**
 340      * Launch debugee locally via the RawLaunchingConnector.
 341      */
 342     private Debugee localRawLaunchDebugee (VirtualMachineManager vmm,
 343                                             String classToExecute,
 344                                             String classPath) {
 345         display(&quot;Finding connector: &quot; + argumentHandler.getConnectorName() );
 346         LaunchingConnector connector =
 347             (LaunchingConnector) findConnector(argumentHandler.getConnectorName(),
 348                                                 vmm.launchingConnectors());
 349         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupRawLaunchingConnector(connector, classToExecute, classPath);
 350 
 351         VirtualMachine vm;
 352         try {
 353             display(&quot;Launching debugee&quot;);
 354             vm = connector.launch(arguments);
 355         } catch (IllegalConnectorArgumentsException e) {
 356             e.printStackTrace(log.getOutStream());
 357             throw new TestBug(&quot;Wrong connector arguments used to launch debuggee VM:\n\t&quot; + e);
 358         } catch (VMStartException e) {
 359             e.printStackTrace(log.getOutStream());
 360             String msg = readVMStartExceptionOutput(e, log.getOutStream());
 361             throw new Failure(&quot;Caught exception while starting debugee VM:\n\t&quot; + e + &quot;\nProcess output:\n\t&quot; + msg);
 362         } catch (IOException e) {
 363             e.printStackTrace(log.getOutStream());
 364             throw new Failure(&quot;Caught exception while launching debugee VM:\n\t&quot; + e);
 365         };
 366 
 367         Process process = vm.process();
 368         Debugee debugee = makeLocalDebugee(process);
 369         debugee.redirectOutput(log);
 370         debugee.setupVM(vm);
 371 
 372         return debugee;
 373     }
 374 
 375     /**
 376      * Launch debugee VM locally as a local process and connect to it using
 377      * &lt;code&gt;AttachingConnector&lt;/code&gt;.
 378      */
 379     private Debugee localLaunchAndAttachDebugee (VirtualMachineManager vmm,
 380                                                     String classToExecute,
 381                                                     String classPath) {
 382         display(&quot;FindingConnector: &quot; + argumentHandler.getConnectorName() );
 383         AttachingConnector connector =
 384             (AttachingConnector) findConnector(argumentHandler.getConnectorName(),
 385                                                 vmm.attachingConnectors());
 386         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupAttachingConnector(connector, classToExecute, classPath);
 387 
 388         String address = makeTransportAddress();
 389         String[] cmdLineArgs = makeCommandLineArgs(classToExecute, address);
 390         String javaCmdLine = makeCommandLineString(classToExecute, address, &quot;\&quot;&quot;);
 391 
 392         display(&quot;Starting java process:\n\t&quot; + javaCmdLine);
 393         Debugee debugee = startLocalDebugee(cmdLineArgs);
 394         debugee.redirectOutput(log);
 395 
 396         display(&quot;Attaching to debugee&quot;);
 397         VirtualMachine vm = null;
 398         IOException ioe = null;
 399         for (int i = 0; i &lt; CONNECT_TRIES; i++) {
 400             try {
 401                 vm = connector.attach(arguments);
 402                 display(&quot;Debugee attached&quot;);
 403                 debugee.setupVM(vm);
 404                 return debugee;
 405             } catch (IOException e) {
 406                 display(&quot;Attempt #&quot; + i + &quot; to connect to debugee VM failed:\n\t&quot; + e);
 407                 ioe = e;
 408                 if (debugee.terminated()) {
 409                     throw new Failure(&quot;Unable to connect to debuggee VM: VM process is terminated&quot;);
 410                 }
 411                 try {
 412                     Thread.currentThread().sleep(CONNECT_TRY_DELAY);
 413                 } catch (InterruptedException ie) {
 414                     ie.printStackTrace(log.getOutStream());
 415                     throw new Failure(&quot;Thread interrupted while pausing connection attempts:\n\t&quot;
 416                                     + ie);
 417                 }
 418             } catch (IllegalConnectorArgumentsException e) {
 419                 e.printStackTrace(log.getOutStream());
 420                 throw new TestBug(&quot;Wrong connector arguments used to attach to debuggee VM:\n\t&quot; + e);
 421             }
 422         }
 423         throw new Failure(&quot;Unable to connect to debugee VM after &quot; + CONNECT_TRIES
 424                         + &quot; tries:\n\t&quot; + ioe);
 425     }
 426 
 427     /**
 428      * Launch debugee VM locally as a local process and connect to it using
 429      * &lt;code&gt;ListeningConnector&lt;/code&gt;.
 430      */
 431     private Debugee localLaunchAndListenDebugee (VirtualMachineManager vmm,
 432                                                     String classToExecute,
 433                                                     String classPath) {
 434         display(&quot;Finding connector: &quot; + argumentHandler.getConnectorName() );
 435         ListeningConnector connector =
 436             (ListeningConnector) findConnector(argumentHandler.getConnectorName(),
 437                                                 vmm.listeningConnectors());
 438         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupListeningConnector(connector, classToExecute, classPath);
 439 
 440         String address = null;
 441         try {
 442             display(&quot;Listening for connection from debugee&quot;);
 443             address = connector.startListening(arguments);
 444         } catch (IllegalConnectorArgumentsException e) {
 445             e.printStackTrace(log.getOutStream());
 446             throw new TestBug(&quot;Wrong connector arguments used to listen debuggee VM:\n\t&quot; + e);
 447         } catch (IOException e) {
 448             e.printStackTrace(log.getOutStream());
 449             throw new Failure(&quot;Caught exception while starting listening debugee VM:\n\t&quot; + e);
 450         };
 451 
 452         String[] cmdLineArgs = makeCommandLineArgs(classToExecute, address);
 453         String javaCmdLine = makeCommandLineString(classToExecute, address, &quot;\&quot;&quot;);
 454 
 455         display(&quot;Starting java process:\n\t&quot; + javaCmdLine);
 456         Debugee debugee = startLocalDebugee(cmdLineArgs);
 457         debugee.redirectOutput(log);
 458 
 459         display(&quot;Waiting for connection from debugee&quot;);
 460         VirtualMachine vm = null;
 461         IOException ioe = null;
 462         for (int i = 0; i &lt; CONNECT_TRIES; i++) {
 463             try {
 464                 vm = connector.accept(arguments);
 465                 connector.stopListening(arguments);
 466                 display(&quot;Debugee attached&quot;);
 467                 debugee.setupVM(vm);
 468                 return debugee;
 469             } catch (IOException e) {
 470                 display(&quot;Attempt #&quot; + i + &quot; to listen debugee VM failed:\n\t&quot; + e);
 471                 ioe = e;
 472                 if (debugee.terminated()) {
 473                     throw new Failure(&quot;Unable to connect to debuggee VM: VM process is terminated&quot;);
 474                 }
 475                 try {
 476                     Thread.currentThread().sleep(CONNECT_TRY_DELAY);
 477                 } catch (InterruptedException ie) {
 478                     ie.printStackTrace(log.getOutStream());
 479                     throw new Failure(&quot;Thread interrupted while pausing connection attempts:\n\t&quot;
 480                                     + ie);
 481                 }
 482             } catch (IllegalConnectorArgumentsException e) {
 483                 e.printStackTrace(log.getOutStream());
 484                 throw new TestBug(&quot;Wrong connector arguments used to listen debuggee VM:\n\t&quot; + e);
 485             }
 486         }
 487         throw new Failure(&quot;Unable to connect to debugee VM after &quot; + CONNECT_TRIES
 488                         + &quot; tries:\n\t&quot; + ioe);
 489     }
 490 
 491     // -------------------------------------------------- //
 492 
 493     /**
 494      * Launch debugee VM remotely via &lt;code&gt;BindServer&lt;/code&gt; and connect to it using
 495      * &lt;code&gt;AttachingConnector&lt;/code&gt;.
 496      */
 497     private Debugee remoteLaunchAndAttachDebugee (VirtualMachineManager vmm,
 498                                                     String classToExecute,
 499                                                     String classPath) {
 500         display(&quot;Finding connector: &quot; + argumentHandler.getConnectorName() );
 501         AttachingConnector connector =
 502             (AttachingConnector) findConnector(argumentHandler.getConnectorName(),
 503                                                 vmm.attachingConnectors());
 504 
 505         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupAttachingConnector(connector, classToExecute, classPath);
 506 
 507         String address = makeTransportAddress();
 508         String[] cmdLineArgs = makeCommandLineArgs(classToExecute, address);
 509         String javaCmdLine = makeCommandLineString(classToExecute, address, &quot;\&quot;&quot;);
 510 
 511         display(&quot;Starting remote java process:\n\t&quot; + javaCmdLine);
 512         Debugee debugee = startRemoteDebugee(cmdLineArgs);
 513 
 514         display(&quot;Attaching to debugee&quot;);
 515         VirtualMachine vm;
 516         IOException ioe = null;
 517         for (int i = 0; i &lt; CONNECT_TRIES; i++) {
 518             try {
 519                 vm = connector.attach(arguments);
 520                 display(&quot;Debugee attached&quot;);
 521                 debugee.setupVM(vm);
 522                 return debugee;
 523             } catch (IOException e) {
 524                 display(&quot;Attempt #&quot; + i + &quot; to connect to debugee VM failed:\n\t&quot; + e);
 525                 ioe = e;
 526                 if (debugee.terminated()) {
 527                     throw new Failure(&quot;Unable to connect to debuggee VM: VM process is terminated&quot;);
 528                 }
 529                 try {
 530                     Thread.currentThread().sleep(CONNECT_TRY_DELAY);
 531                 } catch (InterruptedException ie) {
 532                     ie.printStackTrace(log.getOutStream());
 533                     throw new Failure(&quot;Thread interrupted while pausing connection attempts:\n\t&quot;
 534                                     + ie);
 535                 }
 536             } catch (IllegalConnectorArgumentsException e) {
 537                 e.printStackTrace(log.getOutStream());
 538                 throw new TestBug(&quot;Wrong connector arguments used to attach to debuggee VM:\n\t&quot; + e);
 539             }
 540         }
 541         throw new Failure(&quot;Unable to connect to debugee VM after &quot; + CONNECT_TRIES
 542                         + &quot; tries:\n\t&quot; + ioe);
 543     }
 544 
 545     /**
 546      * Launch debugee VM remotely via &lt;code&gt;BindServer&lt;/code&gt; and connect to it using
 547      * &lt;code&gt;ListeningConnector&lt;/code&gt;.
 548      */
 549     private Debugee remoteLaunchAndListenDebugee (VirtualMachineManager vmm,
 550                                                     String classToExecute,
 551                                                     String classPath) {
 552         display(&quot;Finding connector: &quot; + argumentHandler.getConnectorName() );
 553         ListeningConnector connector =
 554             (ListeningConnector) findConnector(argumentHandler.getConnectorName(),
 555                                                 vmm.listeningConnectors());
 556         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupListeningConnector(connector, classToExecute, classPath);
 557 
 558         String address = null;
 559         try {
 560             display(&quot;Listening for connection from debugee&quot;);
 561             address = connector.startListening(arguments);
 562         } catch (IllegalConnectorArgumentsException e) {
 563             e.printStackTrace(log.getOutStream());
 564             throw new TestBug(&quot;Wrong connector arguments used to listen debuggee VM:\n\t&quot; + e);
 565         } catch (IOException e) {
 566             e.printStackTrace(log.getOutStream());
 567             throw new Failure(&quot;Caught exception while starting listening debugee VM:\n\t&quot; + e);
 568         };
 569 
 570         String[] cmdLineArgs = makeCommandLineArgs(classToExecute, address);
 571         String javaCmdLine = makeCommandLineString(classToExecute, address, &quot;\&quot;&quot;);
 572 
 573         display(&quot;Starting remote java process:\n\t&quot; + javaCmdLine);
 574         Debugee debugee = startRemoteDebugee(cmdLineArgs);
 575 
 576         display(&quot;Waiting for connection from debugee&quot;);
 577         VirtualMachine vm;
 578         IOException ioe = null;
 579         for (int i = 0; i &lt; CONNECT_TRIES; i++) {
 580             try {
 581                 vm = connector.accept(arguments);
 582                 connector.stopListening(arguments);
 583                 display(&quot;Debugee attached&quot;);
 584                 debugee.setupVM(vm);
 585                 return debugee;
 586             } catch (IOException e) {
 587                 display(&quot;Attempt #&quot; + i + &quot; to listen debugee VM failed:\n\t&quot; + e);
 588                 ioe = e;
 589                 if (debugee.terminated()) {
 590                     throw new Failure(&quot;Unable to connect to debuggee VM: VM process is terminated&quot;);
 591                 }
 592                 try {
 593                     Thread.currentThread().sleep(CONNECT_TRY_DELAY);
 594                 } catch (InterruptedException ie) {
 595                     ie.printStackTrace(log.getOutStream());
 596                     throw new Failure(&quot;Thread interrupted while pausing connection attempts:\n\t&quot;
 597                                     + ie);
 598                 }
 599             } catch (IllegalConnectorArgumentsException e) {
 600                 e.printStackTrace(log.getOutStream());
 601                 throw new TestBug(&quot;Wrong connector arguments used to listen debuggee VM:\n\t&quot; + e);
 602             }
 603         }
 604         throw new Failure(&quot;Unable to connect to debugee VM after &quot; + CONNECT_TRIES
 605                         + &quot; tries:\n\t&quot; + ioe);
 606     }
 607 
 608     // -------------------------------------------------- //
 609 
 610     /**
 611      * Prompt to manually launch debugee VM and connect to it using
 612      * &lt;code&gt;AttachingConnector&lt;/code&gt;.
 613      */
 614     private Debugee manualLaunchAndAttachDebugee (VirtualMachineManager vmm,
 615                                                     String classToExecute,
 616                                                     String classPath) {
 617         display(&quot;Finding connector: &quot; + argumentHandler.getConnectorName() );
 618         AttachingConnector connector =
 619             (AttachingConnector) findConnector(argumentHandler.getConnectorName(),
 620                                                 vmm.attachingConnectors());
 621         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupAttachingConnector(connector, classToExecute, classPath);
 622 
 623         String address = makeTransportAddress();
 624         String javaCmdLine = makeCommandLineString(classToExecute, address, &quot;\&quot;&quot;);
 625 
 626         display(&quot;Starting manual java process:\n\t&quot; + javaCmdLine);
 627         ManualLaunchedDebugee debugee = startManualDebugee(javaCmdLine);
 628 
 629         VirtualMachine vm;
 630         try {
 631             display(&quot;Attaching to debugee&quot;);
 632             vm = connector.attach(arguments);
 633         } catch (IllegalConnectorArgumentsException e) {
 634             e.printStackTrace(log.getOutStream());
 635             throw new TestBug(&quot;Wrong connector arguments used to attach to debuggee VM:\n\t&quot; + e);
 636         } catch (IOException e) {
 637             e.printStackTrace(log.getOutStream());
 638             throw new Failure(&quot;Caught exception while attaching to debugee VM:\n\t&quot; + e);
 639         };
 640         display(&quot;Debugee attached&quot;);
 641 
 642         debugee.setupVM(vm);
 643         return debugee;
 644     }
 645 
 646     /**
 647      * Prompt to manually launch debugee VM and connect to it using
 648      * &lt;code&gt;ListeningConnector&lt;/code&gt;.
 649      */
 650     private Debugee manualLaunchAndListenDebugee (VirtualMachineManager vmm,
 651                                                     String classToExecute,
 652                                                     String classPath) {
 653         display(&quot;Finding connector: &quot; + argumentHandler.getConnectorName() );
 654         ListeningConnector connector =
 655             (ListeningConnector) findConnector(argumentHandler.getConnectorName(),
 656                                                 vmm.listeningConnectors());
 657         Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = setupListeningConnector(connector, classToExecute, classPath);
 658 
 659         VirtualMachine vm;
 660         try {
 661             display(&quot;Listening for connection from debugee&quot;);
 662             String address = connector.startListening(arguments);
 663             String javaCmdLine = makeCommandLineString(classToExecute, address, &quot;\&quot;&quot;);
 664             display(&quot;Starting manual java process:\n\t&quot; + javaCmdLine);
 665             ManualLaunchedDebugee debugee = startManualDebugee(javaCmdLine);
 666             display(&quot;Waiting for connection from debugee&quot;);
 667             vm = connector.accept(arguments);
 668             display(&quot;Debugee attached&quot;);
 669             connector.stopListening(arguments);
 670             debugee.setupVM(vm);
 671             return debugee;
 672         } catch (IllegalConnectorArgumentsException e) {
 673             e.printStackTrace(log.getOutStream());
 674             throw new TestBug(&quot;Wrong connector arguments used to listen debuggee VM:\n\t&quot; + e);
 675         } catch (IOException e) {
 676             e.printStackTrace(log.getOutStream());
 677             throw new Failure(&quot;Caught exception while listening to debugee VM:\n\t&quot; + e);
 678         }
 679     }
 680 
 681     // -------------------------------------------------- //
 682 
 683     /**
 684      * Make proper arguments for LaunchingConnector.
 685      */
 686     private Map&lt;String,? extends Argument&gt; setupLaunchingConnector(LaunchingConnector connector,
 687                                                 String classToExecute,
 688                                                 String classPath) {
 689         display(&quot;LaunchingConnector:&quot;);
 690         display(&quot;    name: &quot; + connector.name());
 691         display(&quot;    description: &quot; + connector.description());
 692         display(&quot;    transport: &quot; + connector.transport());
 693 
 694         Hashtable&lt;String,? extends Argument&gt; arguments = new Hashtable&lt;String,Argument&gt;(connector.defaultArguments());
 695 
 696         Connector.Argument arg;
 697 
 698         arg = (Connector.StringArgument) arguments.get(&quot;quote&quot;);
 699         String quote = arg.value();
 700 
 701         String cmdline = classToExecute + &quot; &quot; +
 702                 ArgumentHandler.joinArguments(argumentHandler.getRawArguments(), quote);
 703 
 704         arg = (Connector.StringArgument) arguments.get(&quot;main&quot;);
 705         arg.setValue(cmdline);
 706 
 707         if (! argumentHandler.willDebugeeSuspended()) {
 708             Connector.BooleanArgument barg = (Connector.BooleanArgument) arguments.get(&quot;suspend&quot;);
 709             barg.setValue(true);
 710         }
 711 
 712 /*
 713         if (! argumentHandler.isJVMDIStrictMode()) {
 714             arg = (Connector.StringArgument) arguments.get(&quot;options&quot;);
 715             arg.setValue(&quot;strict=y&quot;);
 716         }
 717  */
 718 
 719         if (! argumentHandler.isDefaultDebugeeJavaHome()) {
 720             arg = (Connector.StringArgument) arguments.get(&quot;home&quot;);
 721             arg.setValue(argumentHandler.getDebugeeJavaHome());
 722         }
 723 
 724         if (! argumentHandler.isDefaultLaunchExecName()) {
 725             arg = (Connector.StringArgument) arguments.get(&quot;vmexec&quot;);
 726             arg.setValue(argumentHandler.getLaunchExecName());
 727         }
 728 
 729         String vmArgs = &quot;&quot;;
 730 
 731         String vmUserArgs = argumentHandler.getLaunchOptions();
 732 
 733         if (vmUserArgs != null) {
 734             vmArgs = vmUserArgs;
 735         }
 736 
 737 /*
 738         if (classPath != null) {
 739             vmArgs += &quot; -classpath &quot; + quote + classPath + quote;
 740         }
 741  */
 742 
 743         if (vmArgs.length() &gt; 0) {
 744             arg = (Connector.StringArgument) arguments.get(&quot;options&quot;);
 745             arg.setValue(vmArgs);
 746         }
 747 
 748         display(&quot;Connector arguments:&quot;);
 749         Iterator iterator = arguments.values().iterator();
 750         while (iterator.hasNext()) {
 751             display(&quot;    &quot; + iterator.next());
 752         }
 753         return arguments;
 754     }
 755 
 756     /**
 757      * Make proper arguments for RawLaunchingConnector.
 758      */
 759     private Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; setupRawLaunchingConnector(LaunchingConnector connector,
 760                                                 String classToExecute,
 761                                                 String classPath) {
 762         display(&quot;RawLaunchingConnector:&quot;);
 763         display(&quot;    name: &quot; + connector.name());
 764         display(&quot;    description: &quot; + connector.description());
 765         display(&quot;    transport: &quot; + connector.transport());
 766 
 767         Hashtable&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = new Hashtable&lt;java.lang.String, com.sun.jdi.connect.Connector.Argument&gt;(connector.defaultArguments());
 768 
 769         String connectorAddress;
 770         String vmAddress;
 771 
 772         if (argumentHandler.isSocketTransport()) {
 773             connectorAddress = argumentHandler.getTransportPort();
 774             vmAddress = argumentHandler.getDebugeeHost()
 775                         + &quot;:&quot; + argumentHandler.getTransportPort();
 776         } else if (argumentHandler.isShmemTransport() ) {
 777             connectorAddress = argumentHandler.getTransportSharedName();
 778             vmAddress=connectorAddress;
 779         } else {
 780             throw new TestBug(&quot;Undefined transport type for AttachingConnector&quot;);
 781         }
 782 
 783         Connector.Argument arg;
 784 
 785         arg = (Connector.StringArgument) arguments.get(&quot;quote&quot;);
 786         String quote = arg.value();
 787 
 788         String javaCmdLine = makeCommandLineString(classToExecute, quote);
 789 
 790         arg = (Connector.StringArgument) arguments.get(&quot;command&quot;);
 791         arg.setValue(javaCmdLine);
 792 
 793         arg = (Connector.StringArgument) arguments.get(&quot;address&quot;);
 794         arg.setValue(connectorAddress);
 795 
 796         display(&quot;Connector arguments:&quot;);
 797         Iterator iterator = arguments.values().iterator();
 798         while (iterator.hasNext()) {
 799             display(&quot;    &quot; + iterator.next());
 800         }
 801         return arguments;
 802     }
 803 
 804     /**
 805      * Make proper arguments for AttachingConnector.
 806      */
 807     private Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; setupAttachingConnector(AttachingConnector connector,
 808                                                 String classToExecute,
 809                                                 String classPath) {
 810         display(&quot;AttachingConnector:&quot;);
 811         display(&quot;    name: &quot; + connector.name());
 812         display(&quot;    description: &quot; + connector.description());
 813         display(&quot;    transport: &quot; + connector.transport());
 814 
 815         Hashtable&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = new Hashtable&lt;java.lang.String,com.sun.jdi.connect.Connector.Argument&gt;(connector.defaultArguments());
 816 
 817         Connector.Argument arg;
 818         if (argumentHandler.isSocketTransport()) {
 819             arg = (Connector.StringArgument) arguments.get(&quot;hostname&quot;);
 820             arg.setValue(argumentHandler.getDebugeeHost());
 821             Connector.IntegerArgument iarg = (Connector.IntegerArgument) arguments.get(&quot;port&quot;);
 822             iarg.setValue(argumentHandler.getTransportPortNumber());
 823         } else {
 824             arg = (Connector.StringArgument) arguments.get(&quot;name&quot;);
 825             arg.setValue(argumentHandler.getTransportSharedName());
 826         }
 827 
 828         display(&quot;Connector arguments:&quot;);
 829         Iterator iterator = arguments.values().iterator();
 830         while (iterator.hasNext()) {
 831             display(&quot;    &quot; + iterator.next());
 832         }
 833         return arguments;
 834     }
 835 
 836     /**
 837      * Make proper arguments for ListeningConnector.
 838      */
 839     private Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; setupListeningConnector(ListeningConnector connector,
 840                                                 String classToExecute,
 841                                                 String classPath) {
 842         display(&quot;ListeningConnector:&quot;);
 843         display(&quot;    name: &quot; + connector.name());
 844         display(&quot;    description: &quot; + connector.description());
 845         display(&quot;    transport: &quot; + connector.transport());
 846 
 847         Hashtable&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; arguments = new Hashtable&lt;java.lang.String,com.sun.jdi.connect.Connector.Argument&gt;(connector.defaultArguments());
 848 
 849         Connector.Argument arg;
 850         if (argumentHandler.isSocketTransport()) {
 851             if (!argumentHandler.isTransportAddressDynamic()) {
 852                 int port = argumentHandler.getTransportPortNumber();
 853                 Connector.IntegerArgument iarg = (Connector.IntegerArgument) arguments.get(&quot;port&quot;);
 854                 iarg.setValue(port);
 855             }
 856         } else {
 857             String sharedName = argumentHandler.getTransportSharedName();
 858             arg = (Connector.StringArgument) arguments.get(&quot;name&quot;);
 859             arg.setValue(sharedName);
 860         }
 861 
 862         display(&quot;Connector arguments:&quot;);
 863         Iterator iterator = arguments.values().iterator();
 864         while (iterator.hasNext()) {
 865             display(&quot;    &quot; + iterator.next());
 866         }
 867         return arguments;
 868     }
 869 
 870     // -------------------------------------------------- //
 871 
 872     /**
 873      * Find connector by name from given connectors list.
 874      */
 875     private Connector findConnector(String connectorName, List connectors) {
 876         Iterator iter = connectors.iterator();
 877 
 878         while (iter.hasNext()) {
 879             Connector connector = (Connector) iter.next();
 880             if (connector.name().equals(connectorName)) {
 881                 return connector;
 882             }
 883         }
 884         throw new Failure(&quot;JDI connector not found: &quot; + connectorName);
 885     }
 886 
 887     // -------------------------------------------------- //
 888 
 889     /**
 890      * Launch local debuggee process with specified command line arguments
 891      * and make initial &lt;code&gt;Debugee&lt;/code&gt; mirror.
 892      */
 893     protected Debugee startLocalDebugee(String[] cmdArgs) {
 894         Process process = null;
 895 
 896         try {
 897             process = launchProcess(cmdArgs);
 898         } catch (IOException e) {
 899             e.printStackTrace(log.getOutStream());
 900             throw new Failure(&quot;Caught exception while launching local debuggee VM process:\n\t&quot;
 901                             + e);
 902         }
 903 
 904         return makeLocalDebugee(process);
 905     }
 906 
 907     /**
 908      * Launch remote debuggee process with specified command line arguments
 909      * and make initial &lt;code&gt;Debugee&lt;/code&gt; mirror.
 910      */
 911     protected RemoteLaunchedDebugee startRemoteDebugee(String[] cmdArgs) {
 912         try {
 913             launchRemoteProcess(cmdArgs);
 914         } catch (IOException e) {
 915             e.printStackTrace(log.getOutStream());
 916             throw new Failure(&quot;Caught exception while launching remote debuggee VM process:\n\t&quot;
 917                             + e);
 918         }
 919 
 920         RemoteLaunchedDebugee debugee = new RemoteLaunchedDebugee(this);
 921 
 922         Finalizer finalizer = new Finalizer(debugee);
 923         finalizer.activate();
 924 
 925         return debugee;
 926     }
 927 
 928     /**
 929      * Launch manual debuggee process with specified command line arguments
 930      * and make initial &lt;code&gt;Debugee&lt;/code&gt; mirror.
 931      */
 932     protected ManualLaunchedDebugee startManualDebugee(String cmd) {
 933         ManualLaunchedDebugee debugee = new ManualLaunchedDebugee(this);
 934         debugee.launchDebugee(cmd);
 935 
 936         Finalizer finalizer = new Finalizer(debugee);
 937         finalizer.activate();
 938 
 939         return debugee;
 940     }
 941 
 942     public static String readVMStartExceptionOutput(VMStartException e, PrintStream log) {
 943         StringBuffer msg = new StringBuffer();
 944         try (InputStream is = e.process().getInputStream()) {
 945             msg.append(&quot;\tstdout: &quot;).append(new String(readAllBytes(is))).append(&#39;\n&#39;);
 946         } catch (IOException e1) {
 947             log.println(&quot;Could not read normal output from launched process:&quot; + e1);
 948         }
 949         try (InputStream is = e.process().getErrorStream()) {
 950             msg.append(&quot;\tstderr: &quot;).append(new String(readAllBytes(is)));
 951         } catch (IOException e1) {
 952             log.println(&quot;Could not read error output from launched process:&quot; + e1);
 953         }
 954         return msg.toString();
 955     }
 956 
 957     /**
 958      * Copied from the JDK 9 implementation in InputStream.java
 959      */
 960     private static byte[] readAllBytes(InputStream is) throws IOException {
 961         final int DEFAULT_BUFFER_SIZE = 8192;
 962         final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;
 963 
 964         byte[] buf = new byte[DEFAULT_BUFFER_SIZE];
 965         int capacity = buf.length;
 966         int nread = 0;
 967         int n;
 968         for (;;) {
 969             // read to EOF which may read more or less than initial buffer size
 970             while ((n = is.read(buf, nread, capacity - nread)) &gt; 0)
 971                 nread += n;
 972 
 973             // if the last call to read returned -1, then we&#39;re done
 974             if (n &lt; 0)
 975                 break;
 976 
 977             // need to allocate a larger buffer
 978             if (capacity &lt;= MAX_BUFFER_SIZE - capacity) {
 979                 capacity = capacity &lt;&lt; 1;
 980             } else {
 981                 if (capacity == MAX_BUFFER_SIZE)
 982                     throw new OutOfMemoryError(&quot;Required array size too large&quot;);
 983                 capacity = MAX_BUFFER_SIZE;
 984             }
 985             buf = Arrays.copyOf(buf, capacity);
 986         }
 987         return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);
 988     }
 989 
 990 }
 991 
 992 
 993 /**
 994  * Mirror of locally launched debugee.
 995  */
 996 final class LocalLaunchedDebugee extends Debugee {
 997 
 998     /** Enwrap the locally started VM process. */
 999     public LocalLaunchedDebugee (Process process, Binder binder) {
1000         super(binder);
1001         this.process = process;
1002         checkTermination = true;
1003     }
1004 
1005     // ---------------------------------------------- //
1006 
1007     /** Return exit status of the debugee VM. */
1008     public int getStatus () {
1009         return process.exitValue();
1010     }
1011 
1012     /** Check whether the debugee VM has been terminated. */
1013     public boolean terminated () {
1014         if (process == null)
1015             return true;
1016 
1017         try {
1018             int value = process.exitValue();
1019             return true;
1020         } catch (IllegalThreadStateException e) {
1021             return false;
1022         }
1023     }
1024 
1025     // ---------------------------------------------- //
1026 
1027     /** Kill the debugee VM. */
1028     protected void killDebugee () {
1029         super.killDebugee();
1030         if (!terminated()) {
1031             log.display(&quot;Killing debugee VM process&quot;);
1032             process.destroy();
1033         }
1034     }
1035 
1036     /** Wait until the debugee VM shutdown or crash. */
1037     protected int waitForDebugee () throws InterruptedException {
1038         int code = process.waitFor();
1039         return code;
1040     }
1041 
1042     /** Get a pipe to write to the debugee&#39;s stdin stream. */
1043     protected OutputStream getInPipe () {
1044         return process.getOutputStream();
1045     }
1046 
1047     /** Get a pipe to read the debugee&#39;s stdout stream. */
1048     protected InputStream getOutPipe () {
1049         return process.getInputStream();
1050     }
1051 
1052     /** Get a pipe to read the debugee&#39;s stderr stream. */
1053     protected InputStream getErrPipe () {
1054         return process.getErrorStream();
1055     }
1056 }
1057 
1058 
1059 /**
1060  * Mirror of remotely launched debugee.
1061  */
1062 final class RemoteLaunchedDebugee extends Debugee {
1063 
1064     /** Enwrap the remotely started VM process. */
1065     public RemoteLaunchedDebugee (Binder binder) {
1066         super(binder);
1067     }
1068 
1069     // ---------------------------------------------- //
1070 
1071     /** Return exit status of the debugee VM. */
1072     public int getStatus () {
1073         return binder.getRemoteProcessStatus();
1074     }
1075 
1076     /** Check whether the debugee VM has been terminated. */
1077     public boolean terminated () {
1078         return binder.isRemoteProcessTerminated();
1079     }
1080 
1081     // ---------------------------------------------- //
1082 
1083     /** Kill the debugee VM. */
1084     protected void killDebugee () {
1085         super.killDebugee();
1086         if (!terminated()) {
1087             binder.killRemoteProcess();
1088         }
1089     }
1090 
1091     /** Wait until the debugee VM shutdown or crash. */
1092     protected int waitForDebugee () {
1093         return binder.waitForRemoteProcess();
1094     }
1095 
1096     /** Get a pipe to write to the debugee&#39;s stdin stream. */
1097     protected OutputStream getInPipe () {
1098         return null;
1099     }
1100 
1101     /** Get a pipe to read the debugee&#39;s stdout stream. */
1102     protected InputStream getOutPipe () {
1103         return null;
1104     }
1105 
1106     /** Get a pipe to read the debugee&#39;s stderr stream. */
1107     protected InputStream getErrPipe () {
1108         return null;
1109     }
1110 
1111     public void redirectStdout(OutputStream out) {
1112     }
1113 
1114     public void redirectStdout(Log log, String prefix) {
1115     }
1116 
1117     public void redirectStderr(OutputStream out) {
1118     }
1119 
1120     public void redirectStderr(Log log, String prefix) {
1121     }
1122 }
1123 
1124 
1125 /**
1126  * Mirror of manually launched debugee.
1127  */
1128 final class ManualLaunchedDebugee extends Debugee {
1129     /** Enwrap the manually started VM process. */
1130     public ManualLaunchedDebugee (Binder binder) {
1131         super(binder);
1132         makeInputReader();
1133     }
1134 
1135     // ---------------------------------------------- //
1136 
1137     private int exitCode = 0;
1138     private boolean finished = false;
1139     private static BufferedReader bin = null;
1140 
1141     public void launchDebugee(String commandLine) {
1142         makeInputReader();
1143 
1144         putMessage(&quot;Launch target VM using such command line:\n&quot;
1145                     + commandLine);
1146         String answer = askQuestion(&quot;Has the VM successfully started? (yes/no)&quot;, &quot;yes&quot;);
1147         for ( ; ; ) {
1148             if (answer.equals(&quot;yes&quot;))
1149                 break;
1150             if (answer.equals(&quot;no&quot;))
1151                 throw new Failure (&quot;Unable to manually launch debugee VM&quot;);
1152             answer = askQuestion(&quot;Wrong answer. Please type yes or no&quot;, &quot;yes&quot;);
1153         }
1154     }
1155 
1156     private static void makeInputReader() {
1157         if (bin == null) {
1158             bin = new BufferedReader(new InputStreamReader(System.in));
1159         }
1160     }
1161 
1162     private static void destroyInputReader() {
1163         if (bin != null) {
1164             try {
1165                 bin.close();
1166             } catch (IOException e) {
1167 //                e.printStackTrace(log.getOutStream());
1168                 throw new Failure(&quot;Caught exception while closing input stream:\n\t&quot; + e);
1169             }
1170             bin = null;
1171         }
1172     }
1173 
1174     private static void putMessage(String msg) {
1175         System.out.println(&quot;\n&gt;&gt;&gt; &quot; + msg);
1176     }
1177 
1178     private static String askQuestion(String question, String defaultAnswer) {
1179         try {
1180             System.out.print(&quot;\n&gt;&gt;&gt; &quot; + question);
1181             System.out.print(&quot; [&quot; + defaultAnswer + &quot;] &quot;);
1182             System.out.flush();
1183             String answer = bin.readLine();
1184             if (answer.equals(&quot;&quot;))
1185                 return defaultAnswer;
1186             return answer;
1187         } catch (IOException e) {
1188 //            e.printStackTrace(log.getOutStream());
1189             throw new Failure(&quot;Caught exception while reading answer:\n\t&quot; + e);
1190         }
1191     }
1192 
1193     /** Return exit status of the debugee VM. */
1194     public int getStatus () {
1195         if (! finished) {
1196             throw new Failure(&quot;Unable to get status of debugee VM: process still alive&quot;);
1197         }
1198         return exitCode;
1199     }
1200 
1201     /** Check whether the debugee VM has been terminated. */
1202     public boolean terminated () {
1203         return finished;
1204     }
1205 
1206     // ---------------------------------------------- //
1207 
1208     /** Kill the debugee VM. */
1209     protected void killDebugee () {
1210         super.killDebugee();
1211         if (!terminated()) {
1212             putMessage(&quot;Kill launched VM&quot;);
1213             String answer = askQuestion(&quot;Has the VM successfully terminated? (yes/no)&quot;, &quot;yes&quot;);
1214             for ( ; ; ) {
1215                 if (answer.equals(&quot;yes&quot;)) {
1216                     finished = true;
1217                     break;
1218                 }
1219                 if (answer.equals(&quot;no&quot;))
1220                     throw new Failure (&quot;Unable to manually kill debugee VM&quot;);
1221                 answer = askQuestion(&quot;Wrong answer. Please type yes or no&quot;, &quot;yes&quot;);
1222             }
1223         }
1224     }
1225 
1226     /** Wait until the debugee VM shutdown or crash. */
1227     protected int waitForDebugee () {
1228         putMessage(&quot;Wait for launched VM to exit.&quot;);
1229         String answer = askQuestion(&quot;What is VM exit code?&quot;, &quot;95&quot;);
1230         for ( ; ; ) {
1231             try {
1232                 exitCode = Integer.parseInt(answer);
1233                 break;
1234             } catch (NumberFormatException e) {
1235                 answer = askQuestion(&quot;Wrong answer. Please type integer value&quot;, &quot;95&quot;);
1236             }
1237         }
1238         finished = true;
1239         return exitCode;
1240     }
1241 
1242     /** Get a pipe to write to the debugee&#39;s stdin stream. */
1243     protected OutputStream getInPipe () {
1244         return null;
1245     }
1246 
1247     /** Get a pipe to read the debugee&#39;s stdout stream. */
1248     protected InputStream getOutPipe () {
1249         return null;
1250     }
1251 
1252     /** Get a pipe to read the debugee&#39;s stderr stream. */
1253     protected InputStream getErrPipe () {
1254         return null;
1255     }
1256 
1257     public void redirectStdout(OutputStream out) {
1258     }
1259 
1260     public void redirectStdout(Log log, String prefix) {
1261     }
1262 
1263     public void redirectStderr(OutputStream out) {
1264     }
1265 
1266     public void redirectStderr(Log log, String prefix) {
1267     }
1268 
1269     public void close() {
1270         destroyInputReader();
1271         super.close();
1272     }
1273 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
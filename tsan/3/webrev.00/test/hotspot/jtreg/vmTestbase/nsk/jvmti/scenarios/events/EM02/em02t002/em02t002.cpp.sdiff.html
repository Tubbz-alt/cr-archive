<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t002/em02t002.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../em02t001/libem02t001.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../em02t003/em02t003.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t002/em02t002.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 52     const char* str;
 53     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 54 
 55     NSK_DISPLAY0(&quot;\n&quot;);
 56     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 57     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 58     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 59         if (currentCounts[i] &gt; 0) {
 60             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 61             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 62         }
 63     }
 64 }
 65 
 66 /* ========================================================================== */
 67 
 68 /**
 69  * Testcase: check tested events.
 70  *   - check if expected events received for each method
 71  *
<span class="line-modified"> 72  * Returns NSK_TRUE if test may continue; or NSK_FALSE for test break.</span>
 73  */
<span class="line-modified"> 74 int checkEvents(int step) {</span>
 75     int i;
 76     jvmtiEvent curr;
<span class="line-modified"> 77     int result = NSK_TRUE;</span>
 78     int *currentCounts;
 79     int isExpected = 0;
 80 
 81     int ind_start = JVMTI_EVENT_GARBAGE_COLLECTION_START - JVMTI_MIN_EVENT_TYPE_VAL;
 82     int ind_fnsh = JVMTI_EVENT_GARBAGE_COLLECTION_FINISH - JVMTI_MIN_EVENT_TYPE_VAL;
 83 
 84     switch (step) {
 85         case 1:
 86             currentCounts = &amp;eventCount[0];
 87             break;
 88 
 89         case 2:
 90         case 3:
 91             currentCounts = &amp;newEventCount[0];
 92             break;
 93 
 94         default:
 95             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified"> 96             return NSK_FALSE;</span>
 97     }
 98 
 99     if (currentCounts[ind_start] != currentCounts[ind_fnsh]) {
100 
101         NSK_COMPLAIN0(&quot;Amounts of events are not equal\n&quot;);
102         NSK_COMPLAIN1(&quot;\tGARBAGE_COLLECTION_START:\t%6d\n&quot;,
103                             currentCounts[ind_start]);
104         NSK_COMPLAIN1(&quot;\tGARBAGE_COLLECTION_FINISH:\t%6d\n&quot;,
105                             currentCounts[ind_fnsh]);
<span class="line-modified">106         return NSK_FALSE;</span>
107     }
108 
109     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
110 
111         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
112 
113         switch (step) {
114             case 1:
115                 isExpected = ((curr == JVMTI_EVENT_GARBAGE_COLLECTION_START)
116                            || (curr == JVMTI_EVENT_GARBAGE_COLLECTION_FINISH)
117                            || (curr == JVMTI_EVENT_VM_INIT));
118                 break;
119 
120             case 2:
121                 isExpected = ((curr == JVMTI_EVENT_GARBAGE_COLLECTION_START)
122                            || (curr == JVMTI_EVENT_GARBAGE_COLLECTION_FINISH));
123                 break;
124 
125             case 3:
126                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
127                 break;
128         }
129 
130         if (isExpected) {
131             if (currentCounts[i] &lt; 1) {
132                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
133                                         currentCounts[i],
134                                         TranslateEvent(curr));
<span class="line-modified">135                 result = NSK_FALSE;</span>
136             }
137         } else {
138             if (currentCounts[i] &gt; 0) {
139                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
140                                     TranslateEvent(curr),
141                                     currentCounts[i]);
<span class="line-modified">142                 result = NSK_FALSE;</span>
143             }
144         }
145     }
146 
147     return result;
148 }
149 
150 static void
151 changeCount(jvmtiEvent event, int *currentCounts) {
152 
153     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
154         nsk_jvmti_setFailStatus();
155 
156     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
157 
158     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
159         nsk_jvmti_setFailStatus();
160 
161 }
162 
</pre>
<hr />
<pre>
321 void
322 handlerMC2(jvmtiEvent event) {
323 
324     changeCount(event, &amp;newEventCount[0]);
325 }
326 
327 void JNICALL
328 cbNewGarbageCollectionStart(jvmtiEnv *jvmti_env) {
329 
330     handlerMC2(JVMTI_EVENT_GARBAGE_COLLECTION_START);
331 }
332 
333 void JNICALL
334 cbNewGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
335 
336     handlerMC2(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH);
337 }
338 
339 /* ============================================================================= */
340 
<span class="line-modified">341 static int enableEvent(jvmtiEvent event) {</span>
342 
343     if (nsk_jvmti_isOptionalEvent(event)
344             &amp;&amp; (event != JVMTI_EVENT_GARBAGE_COLLECTION_START)
345             &amp;&amp; (event != JVMTI_EVENT_GARBAGE_COLLECTION_FINISH)) {
346         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
347                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
348             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
349                 TranslateEvent(event));
<span class="line-modified">350             return NSK_FALSE;</span>
351         }
352     } else {
353         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
354             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
355                 TranslateEvent(event));
<span class="line-modified">356             return NSK_FALSE;</span>
357         }
358     }
359 
<span class="line-modified">360     return NSK_TRUE;</span>
361 }
362 
<span class="line-modified">363 static int enableEventList() {</span>
364     int i;
<span class="line-modified">365     int result = NSK_TRUE;</span>
366 
367     NSK_DISPLAY0(&quot;Enable events\n&quot;);
368 
369     result = enableEvent(JVMTI_EVENT_VM_INIT);
370 
371     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
372 
373     /* enabling optional events */
374     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
375         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
376 
377         if (nsk_jvmti_isOptionalEvent(event))
378             result = result &amp;&amp; enableEvent(event);
379     }
380 
<span class="line-modified">381     if (result == NSK_FALSE) {</span>
382         nsk_jvmti_setFailStatus();
<span class="line-modified">383         return NSK_FALSE;</span>
384     }
385 
<span class="line-modified">386     return NSK_TRUE;</span>
387 }
388 
389 /* ============================================================================= */
390 
<span class="line-modified">391 static int</span>
<span class="line-removed">392 setCallBacks(int step) {</span>
393 
394     int i;
395 
396     jvmtiEventCallbacks eventCallbacks;
397     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
398 
399     NSK_DISPLAY0(&quot;\n&quot;);
400     NSK_DISPLAY1(&quot;===============step %d===============\n&quot;, step);
401     NSK_DISPLAY0(&quot;\n&quot;);
402     switch (step) {
403         case 1:
404             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
405                 eventCount[i] = 0;
406             }
407 
408             eventCallbacks.VMInit                    = cbVMInit;
409             eventCallbacks.Exception                 = cbException;
410             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
411             eventCallbacks.SingleStep                = cbSingleStep;
412             eventCallbacks.FramePop                  = cbFramePop;
</pre>
<hr />
<pre>
430 
431         case 2:
432             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
433                 newEventCount[i] = 0;
434             }
435 
436             eventCallbacks.GarbageCollectionStart    = cbNewGarbageCollectionStart;
437             eventCallbacks.GarbageCollectionFinish   = cbNewGarbageCollectionFinish;
438             break;
439 
440         case 3:
441             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
442                 newEventCount[i] = 0;
443             }
444 
445             eventCallbacks.VMDeath                   = cbVMDeath;
446             break;
447 
448     }
449     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">450         return NSK_FALSE;</span>
451 
<span class="line-modified">452     return NSK_TRUE;</span>
453 }
454 
455 /* ============================================================================= */
456 
457 /** Agent algorithm. */
458 static void JNICALL
459 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
460 
461     int i;
462 
463     for (i = 1; i &lt;= STEP_AMOUNT; i++) {
464         if (i &gt; 1) {
465             NSK_DISPLAY0(&quot;Check received events\n&quot;);
466 
467             showEventStatistics(i-1);
468             if (!checkEvents(i-1))
469                 nsk_jvmti_setFailStatus();
470 
471             if (!setCallBacks(i)) {
472                 return;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 52     const char* str;
 53     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 54 
 55     NSK_DISPLAY0(&quot;\n&quot;);
 56     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 57     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 58     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 59         if (currentCounts[i] &gt; 0) {
 60             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 61             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 62         }
 63     }
 64 }
 65 
 66 /* ========================================================================== */
 67 
 68 /**
 69  * Testcase: check tested events.
 70  *   - check if expected events received for each method
 71  *
<span class="line-modified"> 72  * Returns true if test may continue; or false for test break.</span>
 73  */
<span class="line-modified"> 74 bool checkEvents(int step) {</span>
 75     int i;
 76     jvmtiEvent curr;
<span class="line-modified"> 77     bool result = true;</span>
 78     int *currentCounts;
 79     int isExpected = 0;
 80 
 81     int ind_start = JVMTI_EVENT_GARBAGE_COLLECTION_START - JVMTI_MIN_EVENT_TYPE_VAL;
 82     int ind_fnsh = JVMTI_EVENT_GARBAGE_COLLECTION_FINISH - JVMTI_MIN_EVENT_TYPE_VAL;
 83 
 84     switch (step) {
 85         case 1:
 86             currentCounts = &amp;eventCount[0];
 87             break;
 88 
 89         case 2:
 90         case 3:
 91             currentCounts = &amp;newEventCount[0];
 92             break;
 93 
 94         default:
 95             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified"> 96             return false;</span>
 97     }
 98 
 99     if (currentCounts[ind_start] != currentCounts[ind_fnsh]) {
100 
101         NSK_COMPLAIN0(&quot;Amounts of events are not equal\n&quot;);
102         NSK_COMPLAIN1(&quot;\tGARBAGE_COLLECTION_START:\t%6d\n&quot;,
103                             currentCounts[ind_start]);
104         NSK_COMPLAIN1(&quot;\tGARBAGE_COLLECTION_FINISH:\t%6d\n&quot;,
105                             currentCounts[ind_fnsh]);
<span class="line-modified">106         return false;</span>
107     }
108 
109     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
110 
111         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
112 
113         switch (step) {
114             case 1:
115                 isExpected = ((curr == JVMTI_EVENT_GARBAGE_COLLECTION_START)
116                            || (curr == JVMTI_EVENT_GARBAGE_COLLECTION_FINISH)
117                            || (curr == JVMTI_EVENT_VM_INIT));
118                 break;
119 
120             case 2:
121                 isExpected = ((curr == JVMTI_EVENT_GARBAGE_COLLECTION_START)
122                            || (curr == JVMTI_EVENT_GARBAGE_COLLECTION_FINISH));
123                 break;
124 
125             case 3:
126                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
127                 break;
128         }
129 
130         if (isExpected) {
131             if (currentCounts[i] &lt; 1) {
132                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
133                                         currentCounts[i],
134                                         TranslateEvent(curr));
<span class="line-modified">135                 result = false;</span>
136             }
137         } else {
138             if (currentCounts[i] &gt; 0) {
139                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
140                                     TranslateEvent(curr),
141                                     currentCounts[i]);
<span class="line-modified">142                 result = false;</span>
143             }
144         }
145     }
146 
147     return result;
148 }
149 
150 static void
151 changeCount(jvmtiEvent event, int *currentCounts) {
152 
153     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
154         nsk_jvmti_setFailStatus();
155 
156     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
157 
158     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
159         nsk_jvmti_setFailStatus();
160 
161 }
162 
</pre>
<hr />
<pre>
321 void
322 handlerMC2(jvmtiEvent event) {
323 
324     changeCount(event, &amp;newEventCount[0]);
325 }
326 
327 void JNICALL
328 cbNewGarbageCollectionStart(jvmtiEnv *jvmti_env) {
329 
330     handlerMC2(JVMTI_EVENT_GARBAGE_COLLECTION_START);
331 }
332 
333 void JNICALL
334 cbNewGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
335 
336     handlerMC2(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH);
337 }
338 
339 /* ============================================================================= */
340 
<span class="line-modified">341 static bool enableEvent(jvmtiEvent event) {</span>
342 
343     if (nsk_jvmti_isOptionalEvent(event)
344             &amp;&amp; (event != JVMTI_EVENT_GARBAGE_COLLECTION_START)
345             &amp;&amp; (event != JVMTI_EVENT_GARBAGE_COLLECTION_FINISH)) {
346         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
347                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
348             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
349                 TranslateEvent(event));
<span class="line-modified">350             return false;</span>
351         }
352     } else {
353         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
354             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
355                 TranslateEvent(event));
<span class="line-modified">356             return false;</span>
357         }
358     }
359 
<span class="line-modified">360     return true;</span>
361 }
362 
<span class="line-modified">363 static bool enableEventList() {</span>
364     int i;
<span class="line-modified">365     bool result = true;</span>
366 
367     NSK_DISPLAY0(&quot;Enable events\n&quot;);
368 
369     result = enableEvent(JVMTI_EVENT_VM_INIT);
370 
371     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
372 
373     /* enabling optional events */
374     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
375         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
376 
377         if (nsk_jvmti_isOptionalEvent(event))
378             result = result &amp;&amp; enableEvent(event);
379     }
380 
<span class="line-modified">381     if (!result) {</span>
382         nsk_jvmti_setFailStatus();
<span class="line-modified">383         return false;</span>
384     }
385 
<span class="line-modified">386     return true;</span>
387 }
388 
389 /* ============================================================================= */
390 
<span class="line-modified">391 static bool setCallBacks(int step) {</span>

392 
393     int i;
394 
395     jvmtiEventCallbacks eventCallbacks;
396     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
397 
398     NSK_DISPLAY0(&quot;\n&quot;);
399     NSK_DISPLAY1(&quot;===============step %d===============\n&quot;, step);
400     NSK_DISPLAY0(&quot;\n&quot;);
401     switch (step) {
402         case 1:
403             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
404                 eventCount[i] = 0;
405             }
406 
407             eventCallbacks.VMInit                    = cbVMInit;
408             eventCallbacks.Exception                 = cbException;
409             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
410             eventCallbacks.SingleStep                = cbSingleStep;
411             eventCallbacks.FramePop                  = cbFramePop;
</pre>
<hr />
<pre>
429 
430         case 2:
431             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
432                 newEventCount[i] = 0;
433             }
434 
435             eventCallbacks.GarbageCollectionStart    = cbNewGarbageCollectionStart;
436             eventCallbacks.GarbageCollectionFinish   = cbNewGarbageCollectionFinish;
437             break;
438 
439         case 3:
440             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
441                 newEventCount[i] = 0;
442             }
443 
444             eventCallbacks.VMDeath                   = cbVMDeath;
445             break;
446 
447     }
448     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">449         return false;</span>
450 
<span class="line-modified">451     return true;</span>
452 }
453 
454 /* ============================================================================= */
455 
456 /** Agent algorithm. */
457 static void JNICALL
458 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
459 
460     int i;
461 
462     for (i = 1; i &lt;= STEP_AMOUNT; i++) {
463         if (i &gt; 1) {
464             NSK_DISPLAY0(&quot;Check received events\n&quot;);
465 
466             showEventStatistics(i-1);
467             if (!checkEvents(i-1))
468                 nsk_jvmti_setFailStatus();
469 
470             if (!setCallBacks(i)) {
471                 return;
</pre>
</td>
</tr>
</table>
<center><a href="../em02t001/libem02t001.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../em02t003/em02t003.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
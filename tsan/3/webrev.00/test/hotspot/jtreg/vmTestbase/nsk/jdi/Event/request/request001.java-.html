<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/jdi/Event/request/request001.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.Event.request;
 25 
 26 import nsk.share.*;
 27 import nsk.share.jdi.*;
 28 
 29 import com.sun.jdi.*;
 30 import com.sun.jdi.event.*;
 31 import com.sun.jdi.request.*;
 32 
 33 import java.util.*;
 34 import java.io.*;
 35 
 36 /**
 37  * The test for the implementation of an object of the type     &lt;BR&gt;
 38  * Event.                                                       &lt;BR&gt;
 39  *                                                              &lt;BR&gt;
 40  * The test checks that results of the method                   &lt;BR&gt;
 41  * &lt;code&gt;com.sun.jdi.Event.request()&lt;/code&gt;                     &lt;BR&gt;
 42  * complies with its spec.                                      &lt;BR&gt;
 43  * &lt;BR&gt;
 44  * The test checks that for all Event objects,                  &lt;BR&gt;
 45  * except for ClassUnloadEvent, the method returns              &lt;BR&gt;
 46  * either the EventRequest that requested this event            &lt;BR&gt;
 47  * or null if event does not have a corresponding request.      &lt;BR&gt;
 48  * &lt;BR&gt;
 49  * The test has three phases and works as follows.              &lt;BR&gt;
 50  * &lt;BR&gt;
 51  * In first phase,                                                      &lt;BR&gt;
 52  * upon launching debuggee&#39;s VM which will be suspended,                &lt;BR&gt;
 53  * a debugger waits for the VMStartEvent within a predefined            &lt;BR&gt;
 54  * time interval. If no the VMStartEvent received, the test is FAILED.  &lt;BR&gt;
 55  * Upon getting the VMStartEvent, it saves its EventSet into            &lt;BR&gt;
 56  * a special array and makes the request for debuggee&#39;s                 &lt;BR&gt;
 57  * ClassPrepareEvent with SUSPEND_EVENT_THREAD, resumes the VM,         &lt;BR&gt;
 58  * and waits for the event within the predefined time interval.         &lt;BR&gt;
 59  * If no the ClassPrepareEvent received, the test is FAILED.            &lt;BR&gt;
 60  * Upon getting the ClassPrepareEvent,                                  &lt;BR&gt;
 61  * the debugger saves its EVENTSet into the array and                   &lt;BR&gt;
 62  * sets up the breakpoint with SUSPEND_EVENT_THREAD                     &lt;BR&gt;
 63  * within debuggee&#39;s special methodForCommunication().                  &lt;BR&gt;
 64  * &lt;BR&gt;
 65  * In second phase the debugger and the debuggee perform the following. &lt;BR&gt;
 66  * - The debugger creates ThreadStartRequest, ThreadDeathRequest, and   &lt;BR&gt;
 67  *   an extra VMDeathRequest, resumes the debuggee, and                 &lt;BR&gt;
 68  *   waits for corresponding ThreadStartEvent and ThreadDeathEvent.     &lt;BR&gt;
 69  * - The debuggee creates new thread,  named &quot;thread2&quot;,                 &lt;BR&gt;
 70  *   whose running creates the above events.                            &lt;BR&gt;
 71  * - Upon getting the events, the debugger saves their sets in the array,&lt;BR&gt;
 72  *   resumes the debuggee and waits for the BreakpointEvent.            &lt;BR&gt;
 73  * - The debuggee creates a number of threads, one for each             &lt;BR&gt;
 74  *   following event: AccessWatchpoint, ModificationWatchpoint,         &lt;BR&gt;
 75  *   MethodEntry, MethodExit, Step, Exception, and Breakpoint,          &lt;BR&gt;
 76  *   and invokes the methodForCommunication to be suspended and         &lt;BR&gt;
 77  *   to inform the debugger with the event.                             &lt;BR&gt;
 78  * - Upon getting the BreakpointForCommunication, the debugger          &lt;BR&gt;
 79  *   gets ThreadReferences mirroring all tested threads in the debuggee,&lt;BR&gt;
 80  *   sets up Requests within them to get EventSETS to check up on,      &lt;BR&gt;
 81  *   resumes the debuggee, waits for events, and upon getting them,     &lt;BR&gt;
 82  *   saves its EventSets into the array.                                &lt;BR&gt;
 83  * &lt;BR&gt;
 84  * In third phase,at the end                                            &lt;BR&gt;
 85  * the debuggee changes the value of the &quot;instruction&quot;                  &lt;BR&gt;
 86  * to inform the debugger of checks finished, and ends.                 &lt;BR&gt;
 87  * The debugger waits for VMDeathEvents and VMDisconnectEvents, and     &lt;BR&gt;
 88  * upon getting them, saves their EventSets into the array.             &lt;BR&gt;
 89  * Finally, the debugger, using the array of EventSets,                 &lt;BR&gt;
 90  * compares Requests from Events to ones set up.                        &lt;BR&gt;
 91  * If any mismatch, the test FAILED.                                    &lt;BR&gt;
 92  * &lt;BR&gt;
 93  * Note. To inform each other of needed actions, the debugger and       &lt;BR&gt;
 94  *       and the debuggee use debuggee&#39;s variable &quot;instruction&quot;.        &lt;BR&gt;
 95  * &lt;BR&gt;
 96  */
 97 
 98 public class request001 {
 99 
100     //----------------------------------------------------- templete section
101     static final int PASSED = 0;
102     static final int FAILED = 2;
103     static final int PASS_BASE = 95;
104 
105     //----------------------------------------------------- templete parameters
106     static final String
107     sHeader1 = &quot;\n==&gt; nsk/jdi/Event/request/request001 &quot;,
108     sHeader2 = &quot;--&gt; debugger: &quot;,
109     sHeader3 = &quot;##&gt; debugger: &quot;;
110 
111     //----------------------------------------------------- main method
112 
113     public static void main (String argv[]) {
114 
115         int result = run(argv, System.out);
116 
117         System.exit(result + PASS_BASE);
118     }
119 
120     public static int run (String argv[], PrintStream out) {
121 
122         int exitCode = new request001().runThis(argv, out);
123 
124         if (exitCode != PASSED) {
125             System.out.println(&quot;TEST FAILED&quot;);
126         }
127         return testExitCode;
128     }
129 
130     //--------------------------------------------------   log procedures
131 
132     private static Log  logHandler;
133 
134     private static void log1(String message) {
135         logHandler.display(sHeader1 + message);
136     }
137     private static void log2(String message) {
138         logHandler.display(sHeader2 + message);
139     }
140     private static void log3(String message) {
141         logHandler.complain(sHeader3 + message);
142     }
143 
144     //  ************************************************    test parameters
145 
146     private String debuggeeName =
147         &quot;nsk.jdi.Event.request.request001a&quot;;
148 
149     private String testedClassName =
150       &quot;nsk.jdi.Event.request.TestClass&quot;;
151 
152     //====================================================== test program
153     //------------------------------------------------------ common section
154 
155     static Debugee          debuggee;
156     static ArgumentHandler  argsHandler;
157 
158     static int waitTime;
159 
160     static VirtualMachine      vm            = null;
161     static EventRequestManager eventRManager = null;
162     static EventQueue          eventQueue    = null;
163     static EventSet            eventSet      = null;
164     static EventIterator       eventIterator = null;
165 
166     static ReferenceType       debuggeeClass = null;
167 
168     static int  testExitCode = PASSED;
169 
170 
171     class JDITestRuntimeException extends RuntimeException {
172         JDITestRuntimeException(String str) {
173             super(&quot;JDITestRuntimeException : &quot; + str);
174         }
175     }
176 
177 
178     //  Event #:
179     //  0-6  : AccessWatchpoint, ModificationWatchpoint, Breakpoint, Exception,
180     //         MethodEntry, MethodExit, Step
181     //  7-8  : ClassPrepare, ClassUnload
182     //  9-10 : ThreadDeath, ThreadStart
183     // 11-13 : VMDeath, VMDisconnect, VMStart
184 
185     EventSet     eventSets[] = new EventSet [14];
186     EventRequest eRequests[] = new EventRequest[14];
187 
188     int eventFlags[] = { 0,0,0,0, 0,0,0,0, 3,0,0,0, 1,1 };
189 
190     //------------------------------------------------------ methods
191 
192     private int runThis (String argv[], PrintStream out) {
193 
194         argsHandler     = new ArgumentHandler(argv);
195         logHandler      = new Log(out, argsHandler);
196         Binder binder   = new Binder(argsHandler, logHandler);
197 
198         waitTime        = argsHandler.getWaitTime() * 60000;
199 
200         try {
201             log2(&quot;launching a debuggee :&quot;);
202             log2(&quot;       &quot; + debuggeeName);
203             if (argsHandler.verbose()) {
204                 debuggee = binder.bindToDebugeeNoWait(debuggeeName + &quot; -vbs&quot;);
205             } else {
206                 debuggee = binder.bindToDebugeeNoWait(debuggeeName);
207             }
208             if (debuggee == null) {
209                 log3(&quot;ERROR: no debuggee launched&quot;);
210                 return FAILED;
211             }
212             log2(&quot;debuggee launched&quot;);
213         } catch ( Exception e ) {
214             log3(&quot;ERROR: Exception : &quot; + e);
215             log2(&quot;       test cancelled&quot;);
216             return FAILED;
217         }
218 
219         debuggee.redirectOutput(logHandler);
220 
221         vm = debuggee.VM();
222 
223         eventQueue = vm.eventQueue();
224         if (eventQueue == null) {
225             log3(&quot;ERROR: eventQueue == null : TEST ABORTED&quot;);
226             vm.exit(PASS_BASE);
227             return FAILED;
228         }
229 
230         log2(&quot;invocation of the method runTest()&quot;);
231         switch (runTest()) {
232 
233             case 0 :  log2(&quot;test phase has finished normally&quot;);
234                       log2(&quot;   waiting for the debuggee to finish ...&quot;);
235                       debuggee.waitFor();
236 
237                       log2(&quot;......getting the debuggee&#39;s exit status&quot;);
238                       int status = debuggee.getStatus();
239                       if (status != PASS_BASE) {
240                           log3(&quot;ERROR: debuggee returned UNEXPECTED exit status: &quot; +
241                               status + &quot; != PASS_BASE&quot;);
242                           testExitCode = FAILED;
243                       } else {
244                           log2(&quot;......debuggee returned expected exit status: &quot; +
245                               status + &quot; == PASS_BASE&quot;);
246                       }
247                       break;
248 
249             default : log3(&quot;ERROR: runTest() returned unexpected value&quot;);
250 
251             case 1 :  log3(&quot;test phase has not finished normally: debuggee is still alive&quot;);
252                       log2(&quot;......forcing: vm.exit();&quot;);
253                       testExitCode = FAILED;
254                       try {
255                           vm.exit(PASS_BASE);
256                       } catch ( Exception e ) {
257                           log3(&quot;ERROR: Exception : e&quot;);
258                       }
259                       break;
260 
261             case 2 :  log3(&quot;test cancelled due to VMDisconnectedException&quot;);
262                       log2(&quot;......trying: vm.process().destroy();&quot;);
263                       testExitCode = FAILED;
264                       try {
265                           Process vmProcess = vm.process();
266                           if (vmProcess != null) {
267                               vmProcess.destroy();
268                           }
269                       } catch ( Exception e ) {
270                           log3(&quot;ERROR: Exception : e&quot;);
271                       }
272                       break;
273             }
274 
275         return testExitCode;
276     }
277 
278 
279    /*
280     * Return value: 0 - normal end of the test
281     *               1 - ubnormal end of the test
282     *               2 - VMDisconnectedException while test phase
283     */
284 
285     private int runTest() {
286 
287         try {
288             log2(&quot;waiting for VMStartEvent&quot;);
289             getEventSet();
290 //
291             eventSets[13] = eventSet;
292             if (eventIterator.nextEvent() instanceof VMStartEvent) {
293                 log2(&quot;VMStartEvent received; test begins&quot;);
294 
295                 testRun();
296 
297                 log2(&quot;waiting for VMDeathEvent&quot;);
298                 getEventSet();
299                 eventSets[11] = eventSet;
300                 if ( !(eventIterator.nextEvent() instanceof VMDeathEvent) ) {
301                     log3(&quot;ERROR: last event is not the VMDeathEvent&quot;);
302                     return 1;
303                 }
304 
305                 log2(&quot;waiting for VMDisconnectEvent&quot;);
306                 getEventSet();
307 //
308                 eventSets[12] = eventSet;
309                 if ( !(eventIterator.nextEvent() instanceof VMDisconnectEvent) ) {
310                     log3(&quot;ERROR: last event is not the VMDisconnectEvent&quot;);
311                     return 1;
312                 }
313 
314                 check();
315                 return 0;
316             } else {
317                 log3(&quot;ERROR: first event is not the VMStartEvent&quot;);
318                 return 1;
319             }
320         } catch ( VMDisconnectedException e ) {
321             log3(&quot;ERROR: VMDisconnectedException : &quot; + e);
322             return 2;
323         } catch ( Exception e ) {
324             log3(&quot;ERROR: Exception : &quot; + e);
325             return 1;
326         }
327 
328     }
329 
330     private void testRun()
331                  throws JDITestRuntimeException, Exception {
332 
333         eventRManager = vm.eventRequestManager();
334 
335         ClassPrepareRequest cpRequest = eventRManager.createClassPrepareRequest();
336         cpRequest.setSuspendPolicy( EventRequest.SUSPEND_EVENT_THREAD);
337         cpRequest.addClassFilter(debuggeeName);
338 
339         log2(&quot;......setting up ClassPrepareRequest&quot;);
340         eRequests[7] = cpRequest;
341 
342         cpRequest.enable();
343         vm.resume();
344 
345         getEventSet();
346         eventSets[7] = eventSet;
347 
348         cpRequest.disable();
349 
350         ClassPrepareEvent event = (ClassPrepareEvent) eventIterator.next();
351         debuggeeClass = event.referenceType();
352 
353         if (!debuggeeClass.name().equals(debuggeeName))
354            throw new JDITestRuntimeException(&quot;** Unexpected ClassName for ClassPrepareEvent **&quot;);
355 
356         log2(&quot;      received: ClassPrepareEvent for debuggeeClass&quot;);
357 
358         log2(&quot;......setting up ClassPrepareEvent&quot;);
359 
360         String bPointMethod = &quot;methodForCommunication&quot;;
361         String lineForComm  = &quot;lineForComm&quot;;
362         BreakpointRequest bpRequest;
363 
364         ThreadReference mainThread = threadByName(&quot;main&quot;);
365 
366         bpRequest = settingBreakpoint(mainThread,
367                                       debuggeeClass,
368                                       bPointMethod, lineForComm, &quot;zero&quot;);
369         bpRequest.enable();
370 
371     //------------------------------------------------------  testing section
372 
373         log1(&quot;     TESTING BEGINS&quot;);
374 
375         {
376             log2(&quot;...... setting up VMDeathRequest&quot;);
377             if (vm.canRequestVMDeathEvent()) {
378                 VMDeathRequest vmdr = eventRManager.createVMDeathRequest();
379                 vmdr.putProperty(&quot;number&quot;, &quot;VMDeathRequest&quot;);
380                 vmdr.setSuspendPolicy(EventRequest.SUSPEND_NONE);
381                 vmdr.enable();
382                 eRequests[11] = vmdr;
383             } else {
384                 eventFlags[11] = 2;
385             }
386 
387             log2(&quot;......setting up ThreadStartRequest&quot;);
388             ThreadStartRequest tsr = eventRManager.createThreadStartRequest();
389             tsr.addCountFilter(1);
390             tsr.setSuspendPolicy(EventRequest.SUSPEND_ALL);
391             tsr.putProperty(&quot;number&quot;, &quot;ThreadStartRequest&quot;);
392             tsr.enable();
393 
394             eRequests[10] = tsr;
395 
396             log2(&quot;......setting up ThreadDeathRequest&quot;);
397             ThreadDeathRequest tdr = eventRManager.createThreadDeathRequest();
398             tdr.addCountFilter(1);
399             tdr.setSuspendPolicy(EventRequest.SUSPEND_ALL);
400             tsr.putProperty(&quot;number&quot;, &quot;ThreadDeathRequest&quot;);
401             tdr.enable();
402 
403             eRequests[9] = tdr;
404 
405             log2(&quot;......vm.resume();&quot;);
406             vm.resume();
407 
408             log2(&quot;......waiting for ThreadStartEvent&quot;);
409             getEventSet();
410             eventSets[10] = eventSet;
411 
412             Event receivedEvent = eventIterator.nextEvent();
413             if ( !(receivedEvent instanceof ThreadStartEvent) ) {
414                 testExitCode = FAILED;
415                 log3(&quot;ERROR: new event is not ThreadStartEvent: &quot; + receivedEvent);
416                 return;
417             }
418             tsr.disable();
419 
420             log2(&quot;......vm.resume();&quot;);
421             vm.resume();
422 
423             log2(&quot;......waiting for ThreadDeathEvent&quot;);
424             getEventSet();
425             eventSets[9] = eventSet;
426             receivedEvent = eventIterator.nextEvent();
427             if ( !(receivedEvent instanceof ThreadDeathEvent) ) {
428                 testExitCode = FAILED;
429                 log3(&quot;ERROR: new event is not ThreadDeathEvent: &quot; + receivedEvent);
430                 return;
431             }
432             tdr.disable();
433         }
434 
435         for (int i = 0; ; i++) {
436 
437             vm.resume();
438             breakpointForCommunication();
439 
440             int instruction = ((IntegerValue)
441                                (debuggeeClass.getValue(debuggeeClass.fieldByName(&quot;instruction&quot;)))).value();
442 
443             if (instruction == 0) {
444                 vm.resume();
445                 break;
446             }
447 
448             log1(&quot;:::::: case: # &quot; + i);
449 
450             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ variable part
451 
452             String bpLineName        = &quot;breakpointLine&quot;;
453             String bpMethodName      = &quot;method&quot;;
454             String awFieldName       = &quot;awFieldName&quot;;
455             String mwFieldName       = &quot;mwFieldName&quot;;
456 
457             String namesArray = &quot;threadNames&quot;;
458 
459             String threadNames[] = {
460                     &quot;awThread&quot;  ,
461                     &quot;mwThread&quot;  ,
462                     &quot;bpThread&quot;  ,
463                     &quot;excThread&quot; ,
464                     &quot;menThread&quot; ,
465                     &quot;mexThread&quot; ,
466                     &quot;stThread&quot;
467                };
468 
469             int flags = 0;
470 
471             ThreadReference eventThreads[] = new ThreadReference[threadNames.length];
472 
473 
474             List allThreads = vm.allThreads();
475 
476             log2(&quot;......getting: ArrayReference namesRef = (ArrayReference) debuggeeClass.getValue(debuggeeClass.fieldByName(namesArray));&quot;);
477             ArrayReference namesRef = (ArrayReference)
478                          debuggeeClass.getValue(debuggeeClass.fieldByName(namesArray));
479             log2(&quot;       namesRef.length() == &quot; + namesRef.length());
480 
481             log2(&quot;......getting and checking up on debuggee threads&#39; names&quot;);
482             for (int n1 = 0; n1 &lt; namesRef.length(); n1++) {
483 
484                 log2(&quot;      String name = ((StringReference) namesRef.getValue(n1)).value();&quot;);
485                 String name = ((StringReference) namesRef.getValue(n1)).value();
486 
487                 label0: {
488                     for (int n2 = 0; n2 &lt; threadNames.length; n2++) {
489 
490                         if (name.equals(threadNames[n2])) {
491                             ListIterator li  = allThreads.listIterator();
492                             for (; li.hasNext(); ) {
493                                 ThreadReference thread = (ThreadReference) li.next();
494                                 if (thread.name().equals(name)) {
495                                     eventThreads[n1] =  thread;
496                                     break;
497                                 }
498                             }
499                             break label0;
500                         }
501                     }
502                     testExitCode = FAILED;
503                     log3(&quot;ERROR: no thread found in the debuggee : &quot; + name);
504                 }
505             }
506             if (testExitCode == FAILED)
507                 break;
508 
509 
510             log2(&quot;......ReferenceType testClass = (ReferenceType) (vm.classesByName(testedClassName)).get(0);&quot;);
511             ReferenceType testClass = (ReferenceType) (vm.classesByName(testedClassName)).get(0);
512 
513             log2(&quot;......setting up Requests&quot;);
514             for ( int n3 = 0; n3 &lt; namesRef.length(); n3++) {
515                  switch (n3) {
516                       case 0:
517                              if (vm.canWatchFieldAccess()) {
518                                  String awName = ( (StringReference) testClass.getValue(
519                                              testClass.fieldByName(awFieldName))).value();
520                                  eRequests[n3] = settingAccessWatchpoint(eventThreads[n3],
521                                               testClass, awName, threadNames[n3]);
522                                  eRequests[n3].enable();
523                                  flags |= 1;
524                              }
525                              break;
526 
527                       case 1:
528                              if (vm.canWatchFieldModification() ) {
529                                  String mwName = ( (StringReference) testClass.getValue(
530                                              testClass.fieldByName(mwFieldName))).value();
531                                  eRequests[n3] = settingModificationWatchpoint(eventThreads[n3],
532                                               testClass, mwName, threadNames[n3]);
533                                  eRequests[n3].enable();
534                                  flags |= 1&lt;&lt;1;
535                              }
536                              break;
537 
538                       case 2:
539                              eRequests[n3] = settingBreakpoint(eventThreads[n3], testClass,
540                                                bpMethodName, bpLineName, threadNames[n3]);
541                              eRequests[n3].setSuspendPolicy( EventRequest.SUSPEND_NONE);
542                              eRequests[n3].enable();
543                              flags |= 1&lt;&lt;2;
544                              break;
545 
546                       case 3:
547                              eRequests[n3] = settingException(eventThreads[n3], debuggeeClass,
548                                                                 threadNames[n3]);
549                              eRequests[n3].enable();
550                              flags |= 1&lt;&lt;3;
551                              break;
552 
553                       case 4:
554                              eRequests[n3] = settingMethodEntry(eventThreads[n3], testClass,
555                                                                 threadNames[n3]);
556                              eRequests[n3].enable();
557                              flags |= 1&lt;&lt;4;
558                              break;
559 
560                       case 5:
561                              eRequests[n3] = settingMethodExit(eventThreads[n3], testClass,
562                                                                 threadNames[n3]);
563                              eRequests[n3].enable();
564                              flags |= 1&lt;&lt;5;
565                              break;
566 
567                       case 6:
568                              eRequests[n3] = settingStep(eventThreads[n3], threadNames[n3]);
569                              eRequests[n3].enable();
570                              flags |= 1&lt;&lt;6;
571                              break;
572 
573                       default:
574                              throw new JDITestRuntimeException(&quot;** default case while prepareing requests**&quot;);
575                 }
576             }
577 
578             log2(&quot;:::::::::vm.resume();&quot;);
579             vm.resume();
580 
581             Event  event1     = null;
582             int    flagsCopy  = flags;
583             String eName      = null;
584             int    index      = 0;
585 
586             log2(&quot;......getting and checking up on Events&quot;);
587             for (int n4 = 0; n4 &lt; namesRef.length(); n4++) {
588                 int flag;
589 
590                 getEventSet();
591                 event1 = eventIterator.nextEvent();
592 
593                 if (event1 instanceof AccessWatchpointEvent) {
594                     index = 0;
595                 } else if (event1 instanceof ModificationWatchpointEvent ) {
596                     index = 1;
597                 } else if (event1 instanceof BreakpointEvent ) {
598                     index = 2;
599                 } else if (event1 instanceof ExceptionEvent ) {
600                     index = 3;
601                 } else if (event1 instanceof MethodEntryEvent ) {
602                     index = 4;
603                 } else if (event1 instanceof MethodExitEvent ) {
604                     index = 5;
605                 } else if (event1 instanceof StepEvent ) {
606                     index = 6;
607                 } else {
608                     log3(&quot;ERROR: else clause in detecting type of event1&quot;);
609                     testExitCode = FAILED;
610                 }
611 
612                 flag = 1 &lt;&lt; index;
613                 if ((flagsCopy &amp; flag) == 0) {
614                     log3(&quot;ERROR: event duplication: &quot; + eName);
615                     testExitCode = FAILED;
616                 } else {
617                     flagsCopy ^= flag;
618                     flags |= flag;
619                 }
620 
621                 eventSets[index] = eventSet;
622             }
623 
624             if (testExitCode == FAILED)
625                 break;
626 
627             breakpointForCommunication();
628 
629             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
630         }
631         log1(&quot;    TESTING ENDS&quot;);
632         return;
633     }
634 
635     private ThreadReference threadByName(String name)
636                  throws JDITestRuntimeException {
637 
638         List         all = vm.allThreads();
639         ListIterator li  = all.listIterator();
640 
641         for (; li.hasNext(); ) {
642             ThreadReference thread = (ThreadReference) li.next();
643             if (thread.name().equals(name))
644                 return thread;
645         }
646         throw new JDITestRuntimeException(&quot;** Thread IS NOT found ** : &quot; + name);
647     }
648 
649    /*
650     * private BreakpointRequest settingBreakpoint(ThreadReference, ReferenceType,
651     *                                             String, String, String)
652     *
653     * It sets up a breakpoint at given line number within a given method in a given class
654     * for a given thread.
655     *
656     * Return value: BreakpointRequest object  in case of success
657     *
658     * JDITestRuntimeException   in case of an Exception thrown within the method
659     */
660 
661     private BreakpointRequest settingBreakpoint ( ThreadReference thread,
662                                                   ReferenceType testedClass,
663                                                   String methodName,
664                                                   String bpLine,
665                                                   String property)
666             throws JDITestRuntimeException {
667 
668         log2(&quot;......setting up a breakpoint:&quot;);
669         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
670                         &quot;; method: &quot; + methodName + &quot;; line: &quot; + bpLine);
671 
672         List              alllineLocations = null;
673         Location          lineLocation     = null;
674         BreakpointRequest breakpRequest    = null;
675 
676         try {
677             Method  method  = (Method) testedClass.methodsByName(methodName).get(0);
678 
679             alllineLocations = method.allLineLocations();
680 
681             int n =
682                 ( (IntegerValue) testedClass.getValue(testedClass.fieldByName(bpLine) ) ).value();
683             if (n &gt; alllineLocations.size()) {
684                 log3(&quot;ERROR:  TEST_ERROR_IN_settingBreakpoint(): number is out of bound of method&#39;s lines&quot;);
685             } else {
686                 lineLocation = (Location) alllineLocations.get(n);
687                 try {
688                     breakpRequest = eventRManager.createBreakpointRequest(lineLocation);
689                     breakpRequest.putProperty(&quot;number&quot;, property);
690                     breakpRequest.addThreadFilter(thread);
691                     breakpRequest.setSuspendPolicy( EventRequest.SUSPEND_EVENT_THREAD);
692                 } catch ( Exception e1 ) {
693                     log3(&quot;ERROR: inner Exception within settingBreakpoint() : &quot; + e1);
694                     breakpRequest    = null;
695                 }
696             }
697         } catch ( Exception e2 ) {
698             log3(&quot;ERROR: ATTENTION:  outer Exception within settingBreakpoint() : &quot; + e2);
699             breakpRequest    = null;
700         }
701 
702         if (breakpRequest == null) {
703             log2(&quot;      A BREAKPOINT HAS NOT BEEN SET UP&quot;);
704             throw new JDITestRuntimeException(&quot;**FAILURE to set up a breakpoint**&quot;);
705         }
706 
707         log2(&quot;      a breakpoint has been set up&quot;);
708         return breakpRequest;
709     }
710 
711 
712     private void getEventSet()
713                  throws JDITestRuntimeException {
714         try {
715             eventSet = eventQueue.remove(waitTime);
716             if (eventSet == null) {
717                 throw new JDITestRuntimeException(&quot;** TIMEOUT while waiting for event **&quot;);
718             }
719             eventIterator = eventSet.eventIterator();
720         } catch ( Exception e ) {
721             throw new JDITestRuntimeException(&quot;** EXCEPTION while waiting for event ** : &quot; + e);
722         }
723     }
724 
725 
726     private void breakpointForCommunication()
727                  throws JDITestRuntimeException {
728 
729         log2(&quot;breakpointForCommunication&quot;);
730         getEventSet();
731 
732         if (eventIterator.nextEvent() instanceof BreakpointEvent)
733             return;
734 
735         throw new JDITestRuntimeException(&quot;** event IS NOT a breakpoint **&quot;);
736     }
737 
738     // ============================== test&#39;s additional methods
739 
740     private AccessWatchpointRequest settingAccessWatchpoint (
741                                                   ThreadReference thread,
742                                                   ReferenceType testedClass,
743                                                   String fieldName,
744                                                   String property)
745             throws JDITestRuntimeException {
746 
747         log2(&quot;......setting up AccessWatchpoint:&quot;);
748         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
749                              &quot;; fieldName: &quot; + fieldName);
750 
751         AccessWatchpointRequest awRequest = null;
752         try {
753             Field field = testedClass.fieldByName(fieldName);
754             awRequest = eventRManager.createAccessWatchpointRequest(field);
755             awRequest.putProperty(&quot;number&quot;, property);
756             awRequest.addThreadFilter(thread);
757             awRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
758         } catch ( Exception e ) {
759             log3(&quot;ERROR: ATTENTION: Exception within settingAccessWatchpoint() : &quot; + e);
760             log3(&quot;       AN ACCESSWATCHPOINT HAS NOT BEEN SET UP&quot;);
761             throw new JDITestRuntimeException(&quot;** FAILURE to set up an AccessWatchpoint **&quot;);
762         }
763 
764         log2(&quot;      an AccessWatchpoint has been set up&quot;);
765         return awRequest;
766     }
767 
768     private ModificationWatchpointRequest settingModificationWatchpoint (
769                                                   ThreadReference thread,
770                                                   ReferenceType testedClass,
771                                                   String fieldName,
772                                                   String property)
773             throws JDITestRuntimeException {
774 
775         log2(&quot;......setting up ModificationWatchpoint:&quot;);
776         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
777                              &quot;; fieldName: &quot; + fieldName);
778 
779         ModificationWatchpointRequest mwRequest = null;
780         try {
781             Field field = testedClass.fieldByName(fieldName);
782             mwRequest = eventRManager.createModificationWatchpointRequest(field);
783             mwRequest.putProperty(&quot;number&quot;, property);
784             mwRequest.addThreadFilter(thread);
785             mwRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
786         } catch ( Exception e ) {
787             log3(&quot;ERROR: ATTENTION: Exception within settingModificationWatchpoint() : &quot; + e);
788             log3(&quot;       AN ModificationWATCHPOINT HAS NOT BEEN SET UP&quot;);
789             throw new JDITestRuntimeException(&quot;** FAILURE to set up an AccessWatchpoint **&quot;);
790         }
791 
792         log2(&quot;      a ModificationWatchpoint has been set up&quot;);
793         return mwRequest;
794     }
795 
796     private MethodEntryRequest settingMethodEntry ( ThreadReference thread,
797                                                     ReferenceType testedClass,
798                                                     String property)
799             throws JDITestRuntimeException {
800 
801         log2(&quot;......setting up MethodEntry:&quot;);
802         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
803                              &quot;; property: &quot; + property);
804 
805         MethodEntryRequest menRequest = null;
806         try {
807             menRequest = eventRManager.createMethodEntryRequest();
808             menRequest.putProperty(&quot;number&quot;, property);
809             menRequest.addThreadFilter(thread);
810             menRequest.addClassFilter(testedClass);
811             menRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
812         } catch ( Exception e ) {
813             log3(&quot;ERROR: ATTENTION: Exception within settingMethodEntry() : &quot; + e);
814             log3(&quot;       A MethodEntry HAS NOT BEEN SET UP&quot;);
815             throw new JDITestRuntimeException(&quot;** FAILURE to set up a MethodEntry **&quot;);
816         }
817 
818         log2(&quot;      a MethodEntry has been set up&quot;);
819         return menRequest;
820     }
821 
822     private MethodExitRequest settingMethodExit ( ThreadReference thread,
823                                                   ReferenceType testedClass,
824                                                   String property)
825             throws JDITestRuntimeException {
826 
827         log2(&quot;......setting up MethodExit:&quot;);
828         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
829                              &quot;; property: &quot; + property);
830 
831         MethodExitRequest mexRequest = null;
832         try {
833             mexRequest = eventRManager.createMethodExitRequest();
834             mexRequest.putProperty(&quot;number&quot;, property);
835             mexRequest.addThreadFilter(thread);
836             mexRequest.addClassFilter(testedClass);
837             mexRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
838         } catch ( Exception e ) {
839             log3(&quot;ERROR: ATTENTION: Exception within settingMethodExit() : &quot; + e);
840             log3(&quot;       A MethodExit HAS NOT BEEN SET UP&quot;);
841             throw new JDITestRuntimeException(&quot;** FAILURE to set up a MethodExit **&quot;);
842         }
843 
844         log2(&quot;      a MethodExit has been set up&quot;);
845         return mexRequest;
846     }
847 
848     private StepRequest settingStep ( ThreadReference thread, String property)
849             throws JDITestRuntimeException {
850 
851         log2(&quot;......setting up Step:&quot;);
852         log2(&quot;       thread: &quot; + thread + &quot;; property: &quot; + property);
853 
854         StepRequest stRequest = null;
855         try {
856             stRequest = eventRManager.createStepRequest(thread, StepRequest.STEP_LINE, StepRequest.STEP_OVER);
857             stRequest.putProperty(&quot;number&quot;, property);
858             stRequest.addCountFilter(1);
859             stRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
860         } catch ( Exception e ) {
861             log3(&quot;ERROR: ATTENTION: Exception within settingStep() : &quot; + e);
862             log3(&quot;       A Step HAS NOT BEEN SET UP&quot;);
863             throw new JDITestRuntimeException(&quot;** FAILURE to set up a Step **&quot;);
864         }
865 
866         log2(&quot;      a Step has been set up&quot;);
867         return stRequest;
868     }
869 
870 
871     private ExceptionRequest settingException ( ThreadReference thread,
872                                                 ReferenceType testedClass,
873                                                 String property)
874             throws JDITestRuntimeException {
875 
876         log2(&quot;......setting up Exception:&quot;);
877         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
878                              &quot;; property: &quot; + property);
879 
880         ExceptionRequest excRequest = null;
881         try {
882             excRequest = eventRManager.createExceptionRequest(null, true, true);
883             excRequest.putProperty(&quot;number&quot;, property);
884             excRequest.addThreadFilter(thread);
885             excRequest.addClassFilter(testedClass);
886             excRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
887         } catch ( Exception e ) {
888             log3(&quot;ERROR: ATTENTION: Exception within settingException() : &quot; + e);
889             log3(&quot;       A Exception HAS NOT BEEN SET UP&quot;);
890             throw new JDITestRuntimeException(&quot;** FAILURE to set up a Exception **&quot;);
891         }
892 
893         log2(&quot;      a Exception has been set up&quot;);
894         return excRequest;
895     }
896 
897     private void check() {
898 
899         EventSet      evSet = null;
900         EventIterator evI   = null;
901         EventRequest  eR    = null;
902 
903         log2(&quot;......performing the check;&quot;);
904         for (int k = 0; k &lt; eventFlags.length; k++) {
905 
906             switch (eventFlags[k]) {
907 
908             case 0:
909                    evSet = eventSets[k];
910                    evI   = evSet.eventIterator();
911                    if (eRequests[k].equals(evI.nextEvent().request()))
912                        break;
913                    testExitCode = FAILED;
914                    log3(&quot;ERROR: eventRequest is not equal to event.request() : k == &quot; + k);
915                    break;
916 
917 
918             case 1:
919                    evSet = eventSets[k];
920                    evI   = evSet.eventIterator();
921                    if (evI.nextEvent().request() == null)
922                        break;
923                    testExitCode = FAILED;
924                    log3(&quot;ERROR: event.request() != null : k == &quot; + k);
925                    break;
926 
927             case 2:
928                    evSet = eventSets[k];
929                    evI   = evSet.eventIterator();
930                    try {
931                        eR = evI.nextEvent().request();
932                        if (eR == null) {
933                            if ( !eRequests[k].equals(evI.nextEvent().request()) ) {
934                                testExitCode = FAILED;
935                                log3(&quot;ERROR: eventRequest is not equal to event.request() : k == &quot; + k);
936                            }
937                        } else {
938                            if ( !eRequests[k].equals(eR) ) {
939                                testExitCode = FAILED;
940                                log3(&quot;ERROR: eventRequest is not equal to event.request() : k == &quot; + k);
941                            } else if (evI.nextEvent().request() != null) {
942                                testExitCode = FAILED;
943                                log3(&quot;ERROR: eventRequest != null : k == &quot; + k);
944                            }
945                        }
946                    } catch ( Exception e ) {
947                        log3(&quot;ERROR: Unexpected Exception : &quot; + e + &quot; :: k == &quot; + k);
948                        testExitCode = FAILED;
949                    }
950                    break;
951 
952             case 3:
953                    break;
954 
955             default:
956                     log3(&quot;ERROR: unexpected default case&quot;);
957                     testExitCode = FAILED;
958                     throw new JDITestRuntimeException(&quot;** FAILURE within check() **&quot;);
959             }
960         }
961     }
962 
963 }
    </pre>
  </body>
</html>
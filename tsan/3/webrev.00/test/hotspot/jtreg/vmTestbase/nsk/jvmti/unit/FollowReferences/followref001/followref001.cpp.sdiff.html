<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/unit/FollowReferences/followref001/followref001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../scenarios/sampling/SP06/sp06t003/sp06t003.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../followref003/followref003.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/unit/FollowReferences/followref001/followref001.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 84    &quot;JVMTI_HEAP_REFERENCE_STATIC_FIELD&quot;,
 85    &quot;JVMTI_HEAP_REFERENCE_CONSTANT_POOL&quot;,
 86    &quot;JVMTI_HEAP_REFERENCE_SUPERCLASS&quot;,
 87    &quot;unknown_11&quot;, &quot;unknown_12&quot;, &quot;unknown_13&quot;, &quot;unknown_14&quot;, &quot;unknown_15&quot;,
 88    &quot;unknown_16&quot;, &quot;unknown_17&quot;, &quot;unknown_18&quot;, &quot;unknown_19&quot;, &quot;unknown_20&quot;,
 89    &quot;JVMTI_HEAP_REFERENCE_JNI_GLOBAL&quot;,
 90    &quot;JVMTI_HEAP_REFERENCE_SYSTEM_CLASS&quot;,
 91    &quot;JVMTI_HEAP_REFERENCE_MONITOR&quot;,
 92    &quot;JVMTI_HEAP_REFERENCE_STACK_LOCAL&quot;,
 93    &quot;JVMTI_HEAP_REFERENCE_JNI_LOCAL&quot;,
 94    &quot;JVMTI_HEAP_REFERENCE_THREAD&quot;,
 95    &quot;JVMTI_HEAP_REFERENCE_OTHER&quot;
 96 };
 97 
 98 #define DEREF(ptr) (((ptr) == NULL ? 0 : *(ptr)))
 99 
100 
101 /* ============================================================================= */
102 
103 static int get_reference_index(jvmtiHeapReferenceKind   reference_kind,
<span class="line-modified">104                                const jvmtiHeapReferenceInfo* reference_info)</span>
<span class="line-removed">105 {</span>
106     int referrer_index = 0;
107 
108     switch (reference_kind) {
109         case JVMTI_HEAP_REFERENCE_CONSTANT_POOL:
110             referrer_index = reference_info-&gt;constant_pool.index;
111             break;
112         case JVMTI_HEAP_REFERENCE_FIELD:
113         case JVMTI_HEAP_REFERENCE_STATIC_FIELD:
114             referrer_index = reference_info-&gt;field.index;
115             break;
116         case JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT:
117             referrer_index = reference_info-&gt;array.index;
118             break;
119         case JVMTI_HEAP_REFERENCE_STACK_LOCAL:
120             referrer_index = reference_info-&gt;stack_local.slot;
121             /* Fall through */
122         case JVMTI_HEAP_REFERENCE_JNI_LOCAL:
123             referrer_index |= reference_info-&gt;stack_local.depth &lt;&lt; 16;
124             break;
125         default:
126             // TODO: check that realy should be done w/ other jvmtiHeapReferenceKind
127             break;
128     }
129 
130     return referrer_index;
131 } /* get_reference_index */
132 
133 
134 /** Initialize objectDescList. */
<span class="line-modified">135 static int initObjectDescList(jvmtiEnv*    jvmti,</span>
<span class="line-modified">136                               int          chainLength,</span>
<span class="line-modified">137                               int*         objectsCount,</span>
<span class="line-modified">138                               ObjectDesc** objectDescList)</span>
<span class="line-removed">139 {</span>
140     /* root object + reachable and unreachable object chains */
141     *objectsCount = 1 + 2 * chainLength;
142 
143     printf(&quot;Allocate memory for objects list: %d objects\n&quot;, *objectsCount);
144     fflush(0);
145     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Allocate((*objectsCount * sizeof(ObjectDesc)),
146                                           (unsigned char**) objectDescList))) {
147         nsk_jvmti_setFailStatus();
<span class="line-modified">148         return NSK_FALSE;</span>
149     }
150     printf(&quot;  ... allocated array: 0x%p\n&quot;, (void*)objectDescList);
151     fflush(0);
152 
153     {
154         int k;
155         for (k = 0; k &lt; *objectsCount; k++) {
156             (*objectDescList)[k].tag = 0;
157             (*objectDescList)[k].exp_class_tag = CHAIN_CLASS_TAG;
158             (*objectDescList)[k].exp_found = 0;
159             (*objectDescList)[k].found = 0;
160         }
161     }
162     (*objectDescList)[0].exp_class_tag = ROOT_CLASS_TAG;
163     (*objectDescList)[0].tag           = ROOT_OBJECT_TAG;
164 
165     /* Object with tag=100 must be referenced 2 times */
166     (*objectDescList)[chainLength].exp_found = 1;
167 
168 
<span class="line-modified">169      return NSK_TRUE;</span>
170 } /* initObjectDescList */
171 
172 
173 /** Find and tag classes. */
<span class="line-modified">174 static int getAndTagClasses(jvmtiEnv*    jvmti,</span>
<span class="line-modified">175                             JNIEnv*      jni,</span>
<span class="line-modified">176                             jclass*      debugeeClass,</span>
<span class="line-modified">177                             jclass*      rootObjectClass,</span>
<span class="line-modified">178                             jclass*      chainObjectClass)</span>
<span class="line-removed">179 {</span>
180 
181     if (!NSK_JNI_VERIFY(jni, (*debugeeClass = jni-&gt;FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {
182         nsk_jvmti_setFailStatus();
<span class="line-modified">183         return NSK_FALSE;</span>
184     }
185     printf(&quot;\nFound debugee class: 0x%p\n  %s\n&quot;,
186            (void*) *debugeeClass, DEBUGEE_CLASS_NAME);
187     fflush(0);
188 
189     if (!NSK_JNI_VERIFY(jni, (*rootObjectClass =
190             jni-&gt;FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {
191         nsk_jvmti_setFailStatus();
<span class="line-modified">192         return NSK_FALSE;</span>
193     }
194 
195     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(*rootObjectClass, ROOT_CLASS_TAG))) {
196         nsk_jvmti_setFailStatus();
197     }
198 
199     printf(&quot;\nFound root object class: 0x%p, tag=%ld\n  %s\n&quot;,
200            (void*) *rootObjectClass,(long) ROOT_CLASS_TAG,
201            ROOT_OBJECT_CLASS_NAME);
202     fflush(0);
203 
204 
205     if (!NSK_JNI_VERIFY(jni, (*chainObjectClass =
206             jni-&gt;FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {
207         nsk_jvmti_setFailStatus();
<span class="line-modified">208         return NSK_FALSE;</span>
209     }
210 
211     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(*chainObjectClass, CHAIN_CLASS_TAG))) {
212         nsk_jvmti_setFailStatus();
213     }
214     printf(&quot;\nFound chain object class: 0x%p, tag=%ld\n  %s\n&quot;,
215            (void*) *chainObjectClass, (long) CHAIN_CLASS_TAG,
216            CHAIN_OBJECT_CLASS_NAME);
217     fflush(0);
218 
<span class="line-modified">219      return NSK_TRUE;</span>
220 } /* getAndTagClasses */
221 
222 
223 /** Obtain chain of tested objects and tag them recursively. */
<span class="line-modified">224 static int getFieldsAndObjects(jvmtiEnv*  jvmti,</span>
<span class="line-modified">225                              JNIEnv*     jni,</span>
<span class="line-modified">226                              jclass      debugeeClass,</span>
<span class="line-modified">227                              jclass      rootObjectClass,</span>
<span class="line-modified">228                              jclass      chainObjectClass,</span>
<span class="line-modified">229                              jobject*    rootObjectPtr,</span>
<span class="line-modified">230                              jfieldID*   reachableChainField,</span>
<span class="line-modified">231                              jfieldID*   unreachableChainField,</span>
<span class="line-modified">232                              jfieldID*   nextField)</span>
<span class="line-removed">233 {</span>
234     jfieldID rootObjectField = NULL;
235 
236     if (!NSK_JNI_VERIFY(jni, (rootObjectField =
237             jni-&gt;GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {
238         nsk_jvmti_setFailStatus();
<span class="line-modified">239         return NSK_FALSE;</span>
240     }
241     printf(&quot;\nFound fieldID: 0x%p - \&#39;%s\&#39; static field in debugee class\n&quot;,
242            (void*) rootObjectField, OBJECT_FIELD_NAME);
243     fflush(0);
244 
245     if (!NSK_JNI_VERIFY(jni, (*reachableChainField =
246             jni-&gt;GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {
247         nsk_jvmti_setFailStatus();
<span class="line-modified">248         return NSK_FALSE;</span>
249     }
250     printf(&quot;\nFound fieldID: 0x%p - \&#39;%s\&#39; field in root object class\n&quot;,
251            (void*) reachableChainField, REACHABLE_CHAIN_FIELD_NAME);
252     fflush(0);
253 
254     if (!NSK_JNI_VERIFY(jni, (*unreachableChainField =
255             jni-&gt;GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {
256         nsk_jvmti_setFailStatus();
<span class="line-modified">257         return NSK_FALSE;</span>
258     }
259 
260     printf(&quot;\nFound fieldID: 0x%p - \&#39;%s\&#39; field in root object class\n&quot;,
261            (void*) unreachableChainField, UNREACHABLE_CHAIN_FIELD_NAME);
262     fflush(0);
263 
264     if (!NSK_JNI_VERIFY(jni, (*nextField =
265             jni-&gt;GetFieldID(chainObjectClass, NEXT_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {
266         nsk_jvmti_setFailStatus();
<span class="line-modified">267         return NSK_FALSE;</span>
268     }
269     printf(&quot;\nFound fieldID: 0x%p - \&#39;%s\&#39; field in chain object class\n&quot;,
270            (void*) nextField, NEXT_FIELD_NAME);
271     fflush(0);
272 
273     if (!NSK_JNI_VERIFY(jni, (*rootObjectPtr =
274             jni-&gt;GetStaticObjectField(debugeeClass, rootObjectField)) != NULL)) {
275         nsk_jvmti_setFailStatus();
<span class="line-modified">276         return NSK_FALSE;</span>
277     }
278     printf(&quot;\nFound root object: 0x%p\n&quot;, (void*) *rootObjectPtr);
279     fflush(0);
280 
281     if (!NSK_JNI_VERIFY(jni, (*rootObjectPtr = jni-&gt;NewGlobalRef(*rootObjectPtr)) != NULL)) {
282         nsk_jvmti_setFailStatus();
<span class="line-modified">283         return NSK_FALSE;</span>
284     }
285     printf(&quot;Created root object global ref: 0x%p\n&quot;, (void*)*rootObjectPtr);
286     fflush(0);
287 
<span class="line-modified">288      return NSK_TRUE;</span>
289 } /* getFieldsAndObjects */
290 
291 
292 /** Obtain chain of tested objects and tag them recursively. */
<span class="line-modified">293 static int getAndTagChainObjects(</span>
294     jvmtiEnv*  jvmti,
295     JNIEnv*    jni,
296     jobject    currObj,
297     jfieldID   refField,
298     jfieldID   nextField,
299     int        count,
300     ObjectDesc objectDescList[],
301     jlong      tag,
<span class="line-modified">302     int        reachable)</span>
<span class="line-removed">303 {</span>
304     jobject nextObj = NULL;
305     jlong objTag = (reachable ? tag : -tag);
306 
307     if (count &lt;= 0) {
<span class="line-modified">308         return NSK_TRUE;</span>
309     }
310 
311     count--;
312     tag++;
313 
314     if (!NSK_JNI_VERIFY(jni, (nextObj = jni-&gt;GetObjectField(currObj, refField)) != NULL)) {
315         nsk_jvmti_setFailStatus();
<span class="line-modified">316         return NSK_FALSE;</span>
317     }
318 
319     objectDescList[count].tag = objTag;
320     if (reachable) {
321         objectDescList[count].exp_found++;
322     }
323 
324     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(nextObj, objTag))) {
325         nsk_jvmti_setFailStatus();
326     }
327     printf(&quot;        tag=%-5ld object=0x%p\n&quot;, (long)objTag, (void*)nextObj);
328     fflush(0);
329 
330     /* To continue traversing objects in the chain */
331     if (!getAndTagChainObjects(jvmti,
332                                jni,
333                                nextObj,
334                                nextField,
335                                nextField,
336                                count,
337                                objectDescList,
338                                tag,
339                                reachable)
340     ) {
<span class="line-modified">341         return NSK_FALSE;</span>
342     }
343 
344     NSK_TRACE(jni-&gt;DeleteLocalRef(nextObj));
345 
<span class="line-modified">346     return NSK_TRUE;</span>
347 } /* getAndTagChainObjects */
348 
349 /** Obtain all tested objects from debugee class and tag them recursively. */
350 static int getAndTagTestedObjects(
351     jvmtiEnv*    jvmti,
352     JNIEnv*      jni,
353     int          chainLength,
354     int*         objectsCount,
355     ObjectDesc** objectDescList,
356     jobject*     rootObjectPtr)
357 {
358     jclass   debugeeClass          = NULL;
359     jclass   rootObjectClass       = NULL;
360     jclass   chainObjectClass      = NULL;
361 
362     jfieldID reachableChainField   = NULL;
363     jfieldID unreachableChainField = NULL;
364     jfieldID nextField             = NULL;
365 
<span class="line-modified">366     if (initObjectDescList(jvmti,</span>
<span class="line-modified">367                            chainLength,</span>
<span class="line-modified">368                            objectsCount,</span>
<span class="line-modified">369                            objectDescList) == NSK_FALSE) {</span>
<span class="line-modified">370         return NSK_FALSE;</span>
371     }
372 
<span class="line-modified">373     if (getAndTagClasses(jvmti,</span>
<span class="line-modified">374                          jni,</span>
<span class="line-modified">375                          &amp;debugeeClass,</span>
<span class="line-modified">376                          &amp;rootObjectClass,</span>
<span class="line-modified">377                          &amp;chainObjectClass) == NSK_FALSE) {</span>
<span class="line-modified">378         return NSK_FALSE;</span>
379     }
380 
<span class="line-modified">381     if (getFieldsAndObjects(jvmti,</span>
<span class="line-modified">382                             jni,</span>
<span class="line-modified">383                             debugeeClass,</span>
<span class="line-modified">384                             rootObjectClass,</span>
<span class="line-modified">385                             chainObjectClass,</span>
<span class="line-modified">386                             rootObjectPtr,</span>
<span class="line-modified">387                             &amp;reachableChainField,</span>
<span class="line-modified">388                             &amp;unreachableChainField,</span>
<span class="line-modified">389                             &amp;nextField) == NSK_FALSE) {</span>
<span class="line-modified">390         return NSK_FALSE;</span>
391     }
392 
393     printf(&quot;\nObtain and tag chain objects:\n&quot;);
394     printf(&quot;    root tested object:\n&quot;);
395 
396     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(*rootObjectPtr, ROOT_OBJECT_TAG))
397     ) {
398         nsk_jvmti_setFailStatus();
399     }
400     printf(&quot;        tag=%-5ld  object = 0x%p\n&quot;,
401            (long) ROOT_OBJECT_TAG, (void*) *rootObjectPtr);
402 
403     printf(&quot;    reachable objects chain: %d objects\n&quot;, chainLength);
404     fflush(0);
405 
406     if (!getAndTagChainObjects(jvmti,
407                                jni,
408                                *rootObjectPtr,
409                                reachableChainField,
410                                nextField,
411                                chainLength,
412                                (*objectDescList) + 1,
413                                CHAIN_OBJECT_TAG,
<span class="line-modified">414                                NSK_TRUE)  /* reachable objects */</span>
415     ) {
416         nsk_jvmti_setFailStatus();
<span class="line-modified">417         return NSK_FALSE;</span>
418     }
419 
420     printf(&quot;    unreachable objects chain: %d objects\n&quot;, chainLength);
421     if (!getAndTagChainObjects(jvmti,
422                                jni,
423                                *rootObjectPtr,
424                                unreachableChainField,
425                                nextField,
426                                chainLength,
427                                (*objectDescList) + 1 + chainLength,
428                                CHAIN_OBJECT_TAG,
<span class="line-modified">429                                NSK_FALSE) /* unreachable objects */</span>
430     ) {
431         nsk_jvmti_setFailStatus();
<span class="line-modified">432         return NSK_FALSE;</span>
433     }
434 
<span class="line-modified">435     return NSK_TRUE;</span>
436 } /* getAndTagTestedObjects */
437 
438 /** Check if tagged objects were iterated. */
<span class="line-modified">439 static int checkTestedObjects(jvmtiEnv*  jvmti,</span>
<span class="line-modified">440                               JNIEnv*    jni,</span>
<span class="line-modified">441                               int        chainLength,</span>
<span class="line-modified">442                               ObjectDesc objectDescList[])</span>
443 {
<span class="line-modified">444     int success = NSK_TRUE;</span>
445     int i, idx;
446 
447     printf(&quot;Following tagged objects were iterated:\n&quot;);
448 
449     printf(&quot;Root tested object:\n&quot;);
450     printf(&quot;   tag:                 %ld\n&quot;
451            &quot;   expected to iterate: %d times\n&quot;
452            &quot;   iterated:            %d times\n&quot;,
453            (long) objectDescList[0].tag,
454                   objectDescList[0].exp_found,
455                   objectDescList[0].found);
456     if (objectDescList[0].found != objectDescList[0].exp_found) {
457         NSK_COMPLAIN1(&quot;Root tested object unexpectedly iterated %d times\n&quot;,
458                       objectDescList[0].found);
459         nsk_jvmti_setFailStatus();
460     }
461 
462     printf(&quot;\nReachable objects:\n&quot;);
463     fflush(0);
464     for (i = 0; i &lt; chainLength; i++) {
</pre>
<hr />
<pre>
481     }
482 
483     printf(&quot;\nUnreachable objects:\n&quot;);
484     for (i = 0; i &lt; chainLength; i++) {
485         idx = i + 1 + chainLength;
486 
487         printf(&quot;Unreachable object:\n&quot;
488                &quot;   tag:                 %ld\n&quot;
489                &quot;   expected to iterate: %d times\n&quot;
490                &quot;   iterated:            %d times\n&quot;,
491                 (long) objectDescList[idx].tag,
492                        objectDescList[idx].exp_found,
493                        objectDescList[idx].found);
494         if (objectDescList[idx].found &gt; 0) {
495             NSK_COMPLAIN0(&quot;Unreachable object was iterated\n&quot;);
496             nsk_jvmti_setFailStatus();
497         }
498         fflush(0);
499     }
500 
<span class="line-modified">501     return NSK_TRUE;</span>
502 } /* checkTestedObjects */
503 
504 
505 /** Release references to the tested objects and free allocated memory. */
<span class="line-modified">506 static int releaseTestedObjects(jvmtiEnv*   jvmti,</span>
<span class="line-modified">507                                 JNIEnv*     jni,</span>
<span class="line-modified">508                                 int         chainLength,</span>
<span class="line-modified">509                                 ObjectDesc* objectDescList,</span>
<span class="line-modified">510                                 jobject     rootObject)</span>
511 {
512     if (rootObject != NULL) {
513         printf(&quot;Release object reference to root tested object: 0x%p\n&quot;, rootObject);
514         NSK_TRACE(jni-&gt;DeleteGlobalRef(rootObject));
515     }
516 
517     if (objectDescList != NULL) {
518         printf(&quot;Deallocate objects list: 0x%p\n&quot;, (void*)objectDescList);
519         if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)objectDescList))) {
520             nsk_jvmti_setFailStatus();
521         }
522     }
523 
524     fflush(0);
<span class="line-removed">525     return NSK_TRUE;</span>
526 } /* releaseTestedObjects */
527 
528 
529 /* ============================================================================= */
530 
531 /** heapReferenceCallback for heap iterator. */
532 jint JNICALL heapReferenceCallback(
533      jvmtiHeapReferenceKind        reference_kind,
534      const jvmtiHeapReferenceInfo* reference_info,
535      jlong                         class_tag,
536      jlong                         referrer_class_tag,
537      jlong                         size,
538      jlong*                        tag_ptr,
539      jlong*                        referrer_tag_ptr,
540      jint                          length,
541      void*                         user_data)
542 {
543     jint referrer_index = 0;
544     jlong tag;
545     jlong ref_tag;
</pre>
<hr />
<pre>
767 
768     if (!NSK_JVMTI_VERIFY(jvmti-&gt;FollowReferences((jint)   0,    /* heap_filter    */
769                                                   (jclass) NULL, /* class          */
770                                                   rootObject,    /* initial_object */
771                                                   &amp;heapCallbacks,
772                                                   (const void *) &amp;fakeUserData))) {
773          nsk_jvmti_setFailStatus();
774          return;
775     }
776 
777     printf(&quot;&gt;&gt;&gt; Check if reachable objects were iterated:\n&quot;);
778     fflush(0);
779 
780     if (!checkTestedObjects(jvmti, jni, chainLength, objectDescList)) {
781         nsk_jvmti_setFailStatus();
782     }
783 
784     printf(&quot;&gt;&gt;&gt; Clean used data\n&quot;);
785     fflush(0);
786 
<span class="line-modified">787     if (!NSK_VERIFY(releaseTestedObjects(jvmti, jni, chainLength,</span>
<span class="line-removed">788                                          objectDescList, rootObject))) {</span>
<span class="line-removed">789         return;</span>
<span class="line-removed">790     }</span>
791 
792     printf(&quot;&gt;&gt;&gt; Let debugee to finish\n&quot;);
793     fflush(0);
794     if (!NSK_VERIFY(nsk_jvmti_resumeSync())) {
795         return;
796     }
797 } /* agentProc */
798 
799 
800 /* ============================================================================= */
801 
802 /** Agent library initialization. */
803 #ifdef STATIC_BUILD
804 JNIEXPORT jint JNICALL Agent_OnLoad_followref001(JavaVM *jvm, char *options, void *reserved) {
805     return Agent_Initialize(jvm, options, reserved);
806 }
807 JNIEXPORT jint JNICALL Agent_OnAttach_followref001(JavaVM *jvm, char *options, void *reserved) {
808     return Agent_Initialize(jvm, options, reserved);
809 }
810 JNIEXPORT jint JNI_OnLoad_followref001(JavaVM *jvm, char *options, void *reserved) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 84    &quot;JVMTI_HEAP_REFERENCE_STATIC_FIELD&quot;,
 85    &quot;JVMTI_HEAP_REFERENCE_CONSTANT_POOL&quot;,
 86    &quot;JVMTI_HEAP_REFERENCE_SUPERCLASS&quot;,
 87    &quot;unknown_11&quot;, &quot;unknown_12&quot;, &quot;unknown_13&quot;, &quot;unknown_14&quot;, &quot;unknown_15&quot;,
 88    &quot;unknown_16&quot;, &quot;unknown_17&quot;, &quot;unknown_18&quot;, &quot;unknown_19&quot;, &quot;unknown_20&quot;,
 89    &quot;JVMTI_HEAP_REFERENCE_JNI_GLOBAL&quot;,
 90    &quot;JVMTI_HEAP_REFERENCE_SYSTEM_CLASS&quot;,
 91    &quot;JVMTI_HEAP_REFERENCE_MONITOR&quot;,
 92    &quot;JVMTI_HEAP_REFERENCE_STACK_LOCAL&quot;,
 93    &quot;JVMTI_HEAP_REFERENCE_JNI_LOCAL&quot;,
 94    &quot;JVMTI_HEAP_REFERENCE_THREAD&quot;,
 95    &quot;JVMTI_HEAP_REFERENCE_OTHER&quot;
 96 };
 97 
 98 #define DEREF(ptr) (((ptr) == NULL ? 0 : *(ptr)))
 99 
100 
101 /* ============================================================================= */
102 
103 static int get_reference_index(jvmtiHeapReferenceKind   reference_kind,
<span class="line-modified">104                                const jvmtiHeapReferenceInfo* reference_info) {</span>

105     int referrer_index = 0;
106 
107     switch (reference_kind) {
108         case JVMTI_HEAP_REFERENCE_CONSTANT_POOL:
109             referrer_index = reference_info-&gt;constant_pool.index;
110             break;
111         case JVMTI_HEAP_REFERENCE_FIELD:
112         case JVMTI_HEAP_REFERENCE_STATIC_FIELD:
113             referrer_index = reference_info-&gt;field.index;
114             break;
115         case JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT:
116             referrer_index = reference_info-&gt;array.index;
117             break;
118         case JVMTI_HEAP_REFERENCE_STACK_LOCAL:
119             referrer_index = reference_info-&gt;stack_local.slot;
120             /* Fall through */
121         case JVMTI_HEAP_REFERENCE_JNI_LOCAL:
122             referrer_index |= reference_info-&gt;stack_local.depth &lt;&lt; 16;
123             break;
124         default:
125             // TODO: check that realy should be done w/ other jvmtiHeapReferenceKind
126             break;
127     }
128 
129     return referrer_index;
130 } /* get_reference_index */
131 
132 
133 /** Initialize objectDescList. */
<span class="line-modified">134 static bool initObjectDescList(jvmtiEnv*    jvmti,</span>
<span class="line-modified">135                                int          chainLength,</span>
<span class="line-modified">136                                int*         objectsCount,</span>
<span class="line-modified">137                                ObjectDesc** objectDescList) {</span>

138     /* root object + reachable and unreachable object chains */
139     *objectsCount = 1 + 2 * chainLength;
140 
141     printf(&quot;Allocate memory for objects list: %d objects\n&quot;, *objectsCount);
142     fflush(0);
143     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Allocate((*objectsCount * sizeof(ObjectDesc)),
144                                           (unsigned char**) objectDescList))) {
145         nsk_jvmti_setFailStatus();
<span class="line-modified">146         return false;</span>
147     }
148     printf(&quot;  ... allocated array: 0x%p\n&quot;, (void*)objectDescList);
149     fflush(0);
150 
151     {
152         int k;
153         for (k = 0; k &lt; *objectsCount; k++) {
154             (*objectDescList)[k].tag = 0;
155             (*objectDescList)[k].exp_class_tag = CHAIN_CLASS_TAG;
156             (*objectDescList)[k].exp_found = 0;
157             (*objectDescList)[k].found = 0;
158         }
159     }
160     (*objectDescList)[0].exp_class_tag = ROOT_CLASS_TAG;
161     (*objectDescList)[0].tag           = ROOT_OBJECT_TAG;
162 
163     /* Object with tag=100 must be referenced 2 times */
164     (*objectDescList)[chainLength].exp_found = 1;
165 
166 
<span class="line-modified">167      return true;</span>
168 } /* initObjectDescList */
169 
170 
171 /** Find and tag classes. */
<span class="line-modified">172 static bool getAndTagClasses(jvmtiEnv*    jvmti,</span>
<span class="line-modified">173                              JNIEnv*      jni,</span>
<span class="line-modified">174                              jclass*      debugeeClass,</span>
<span class="line-modified">175                              jclass*      rootObjectClass,</span>
<span class="line-modified">176                              jclass*      chainObjectClass) {</span>

177 
178     if (!NSK_JNI_VERIFY(jni, (*debugeeClass = jni-&gt;FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {
179         nsk_jvmti_setFailStatus();
<span class="line-modified">180         return false;</span>
181     }
182     printf(&quot;\nFound debugee class: 0x%p\n  %s\n&quot;,
183            (void*) *debugeeClass, DEBUGEE_CLASS_NAME);
184     fflush(0);
185 
186     if (!NSK_JNI_VERIFY(jni, (*rootObjectClass =
187             jni-&gt;FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {
188         nsk_jvmti_setFailStatus();
<span class="line-modified">189         return false;</span>
190     }
191 
192     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(*rootObjectClass, ROOT_CLASS_TAG))) {
193         nsk_jvmti_setFailStatus();
194     }
195 
196     printf(&quot;\nFound root object class: 0x%p, tag=%ld\n  %s\n&quot;,
197            (void*) *rootObjectClass,(long) ROOT_CLASS_TAG,
198            ROOT_OBJECT_CLASS_NAME);
199     fflush(0);
200 
201 
202     if (!NSK_JNI_VERIFY(jni, (*chainObjectClass =
203             jni-&gt;FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {
204         nsk_jvmti_setFailStatus();
<span class="line-modified">205         return false;</span>
206     }
207 
208     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(*chainObjectClass, CHAIN_CLASS_TAG))) {
209         nsk_jvmti_setFailStatus();
210     }
211     printf(&quot;\nFound chain object class: 0x%p, tag=%ld\n  %s\n&quot;,
212            (void*) *chainObjectClass, (long) CHAIN_CLASS_TAG,
213            CHAIN_OBJECT_CLASS_NAME);
214     fflush(0);
215 
<span class="line-modified">216      return true;</span>
217 } /* getAndTagClasses */
218 
219 
220 /** Obtain chain of tested objects and tag them recursively. */
<span class="line-modified">221 static bool getFieldsAndObjects(jvmtiEnv*  jvmti,</span>
<span class="line-modified">222                                 JNIEnv*    jni,</span>
<span class="line-modified">223                                 jclass     debugeeClass,</span>
<span class="line-modified">224                                 jclass     rootObjectClass,</span>
<span class="line-modified">225                                 jclass     chainObjectClass,</span>
<span class="line-modified">226                                 jobject*   rootObjectPtr,</span>
<span class="line-modified">227                                 jfieldID*  reachableChainField,</span>
<span class="line-modified">228                                 jfieldID*  unreachableChainField,</span>
<span class="line-modified">229                                 jfieldID*  nextField) {</span>

230     jfieldID rootObjectField = NULL;
231 
232     if (!NSK_JNI_VERIFY(jni, (rootObjectField =
233             jni-&gt;GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {
234         nsk_jvmti_setFailStatus();
<span class="line-modified">235         return false;</span>
236     }
237     printf(&quot;\nFound fieldID: 0x%p - \&#39;%s\&#39; static field in debugee class\n&quot;,
238            (void*) rootObjectField, OBJECT_FIELD_NAME);
239     fflush(0);
240 
241     if (!NSK_JNI_VERIFY(jni, (*reachableChainField =
242             jni-&gt;GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {
243         nsk_jvmti_setFailStatus();
<span class="line-modified">244         return false;</span>
245     }
246     printf(&quot;\nFound fieldID: 0x%p - \&#39;%s\&#39; field in root object class\n&quot;,
247            (void*) reachableChainField, REACHABLE_CHAIN_FIELD_NAME);
248     fflush(0);
249 
250     if (!NSK_JNI_VERIFY(jni, (*unreachableChainField =
251             jni-&gt;GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {
252         nsk_jvmti_setFailStatus();
<span class="line-modified">253         return false;</span>
254     }
255 
256     printf(&quot;\nFound fieldID: 0x%p - \&#39;%s\&#39; field in root object class\n&quot;,
257            (void*) unreachableChainField, UNREACHABLE_CHAIN_FIELD_NAME);
258     fflush(0);
259 
260     if (!NSK_JNI_VERIFY(jni, (*nextField =
261             jni-&gt;GetFieldID(chainObjectClass, NEXT_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {
262         nsk_jvmti_setFailStatus();
<span class="line-modified">263         return false;</span>
264     }
265     printf(&quot;\nFound fieldID: 0x%p - \&#39;%s\&#39; field in chain object class\n&quot;,
266            (void*) nextField, NEXT_FIELD_NAME);
267     fflush(0);
268 
269     if (!NSK_JNI_VERIFY(jni, (*rootObjectPtr =
270             jni-&gt;GetStaticObjectField(debugeeClass, rootObjectField)) != NULL)) {
271         nsk_jvmti_setFailStatus();
<span class="line-modified">272         return false;</span>
273     }
274     printf(&quot;\nFound root object: 0x%p\n&quot;, (void*) *rootObjectPtr);
275     fflush(0);
276 
277     if (!NSK_JNI_VERIFY(jni, (*rootObjectPtr = jni-&gt;NewGlobalRef(*rootObjectPtr)) != NULL)) {
278         nsk_jvmti_setFailStatus();
<span class="line-modified">279         return false;</span>
280     }
281     printf(&quot;Created root object global ref: 0x%p\n&quot;, (void*)*rootObjectPtr);
282     fflush(0);
283 
<span class="line-modified">284      return true;</span>
285 } /* getFieldsAndObjects */
286 
287 
288 /** Obtain chain of tested objects and tag them recursively. */
<span class="line-modified">289 static bool getAndTagChainObjects(</span>
290     jvmtiEnv*  jvmti,
291     JNIEnv*    jni,
292     jobject    currObj,
293     jfieldID   refField,
294     jfieldID   nextField,
295     int        count,
296     ObjectDesc objectDescList[],
297     jlong      tag,
<span class="line-modified">298     bool       reachable) {</span>

299     jobject nextObj = NULL;
300     jlong objTag = (reachable ? tag : -tag);
301 
302     if (count &lt;= 0) {
<span class="line-modified">303         return true;</span>
304     }
305 
306     count--;
307     tag++;
308 
309     if (!NSK_JNI_VERIFY(jni, (nextObj = jni-&gt;GetObjectField(currObj, refField)) != NULL)) {
310         nsk_jvmti_setFailStatus();
<span class="line-modified">311         return false;</span>
312     }
313 
314     objectDescList[count].tag = objTag;
315     if (reachable) {
316         objectDescList[count].exp_found++;
317     }
318 
319     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(nextObj, objTag))) {
320         nsk_jvmti_setFailStatus();
321     }
322     printf(&quot;        tag=%-5ld object=0x%p\n&quot;, (long)objTag, (void*)nextObj);
323     fflush(0);
324 
325     /* To continue traversing objects in the chain */
326     if (!getAndTagChainObjects(jvmti,
327                                jni,
328                                nextObj,
329                                nextField,
330                                nextField,
331                                count,
332                                objectDescList,
333                                tag,
334                                reachable)
335     ) {
<span class="line-modified">336         return false;</span>
337     }
338 
339     NSK_TRACE(jni-&gt;DeleteLocalRef(nextObj));
340 
<span class="line-modified">341     return true;</span>
342 } /* getAndTagChainObjects */
343 
344 /** Obtain all tested objects from debugee class and tag them recursively. */
345 static int getAndTagTestedObjects(
346     jvmtiEnv*    jvmti,
347     JNIEnv*      jni,
348     int          chainLength,
349     int*         objectsCount,
350     ObjectDesc** objectDescList,
351     jobject*     rootObjectPtr)
352 {
353     jclass   debugeeClass          = NULL;
354     jclass   rootObjectClass       = NULL;
355     jclass   chainObjectClass      = NULL;
356 
357     jfieldID reachableChainField   = NULL;
358     jfieldID unreachableChainField = NULL;
359     jfieldID nextField             = NULL;
360 
<span class="line-modified">361     if (!initObjectDescList(jvmti,</span>
<span class="line-modified">362                             chainLength,</span>
<span class="line-modified">363                             objectsCount,</span>
<span class="line-modified">364                             objectDescList)) {</span>
<span class="line-modified">365         return false;</span>
366     }
367 
<span class="line-modified">368     if (!getAndTagClasses(jvmti,</span>
<span class="line-modified">369                           jni,</span>
<span class="line-modified">370                           &amp;debugeeClass,</span>
<span class="line-modified">371                           &amp;rootObjectClass,</span>
<span class="line-modified">372                           &amp;chainObjectClass)) {</span>
<span class="line-modified">373         return false;</span>
374     }
375 
<span class="line-modified">376     if (!getFieldsAndObjects(jvmti,</span>
<span class="line-modified">377                              jni,</span>
<span class="line-modified">378                              debugeeClass,</span>
<span class="line-modified">379                              rootObjectClass,</span>
<span class="line-modified">380                              chainObjectClass,</span>
<span class="line-modified">381                              rootObjectPtr,</span>
<span class="line-modified">382                              &amp;reachableChainField,</span>
<span class="line-modified">383                              &amp;unreachableChainField,</span>
<span class="line-modified">384                              &amp;nextField)) {</span>
<span class="line-modified">385         return false;</span>
386     }
387 
388     printf(&quot;\nObtain and tag chain objects:\n&quot;);
389     printf(&quot;    root tested object:\n&quot;);
390 
391     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(*rootObjectPtr, ROOT_OBJECT_TAG))
392     ) {
393         nsk_jvmti_setFailStatus();
394     }
395     printf(&quot;        tag=%-5ld  object = 0x%p\n&quot;,
396            (long) ROOT_OBJECT_TAG, (void*) *rootObjectPtr);
397 
398     printf(&quot;    reachable objects chain: %d objects\n&quot;, chainLength);
399     fflush(0);
400 
401     if (!getAndTagChainObjects(jvmti,
402                                jni,
403                                *rootObjectPtr,
404                                reachableChainField,
405                                nextField,
406                                chainLength,
407                                (*objectDescList) + 1,
408                                CHAIN_OBJECT_TAG,
<span class="line-modified">409                                true)  /* reachable objects */</span>
410     ) {
411         nsk_jvmti_setFailStatus();
<span class="line-modified">412         return false;</span>
413     }
414 
415     printf(&quot;    unreachable objects chain: %d objects\n&quot;, chainLength);
416     if (!getAndTagChainObjects(jvmti,
417                                jni,
418                                *rootObjectPtr,
419                                unreachableChainField,
420                                nextField,
421                                chainLength,
422                                (*objectDescList) + 1 + chainLength,
423                                CHAIN_OBJECT_TAG,
<span class="line-modified">424                                false) /* unreachable objects */</span>
425     ) {
426         nsk_jvmti_setFailStatus();
<span class="line-modified">427         return false;</span>
428     }
429 
<span class="line-modified">430     return true;</span>
431 } /* getAndTagTestedObjects */
432 
433 /** Check if tagged objects were iterated. */
<span class="line-modified">434 static bool checkTestedObjects(jvmtiEnv*  jvmti,</span>
<span class="line-modified">435                                JNIEnv*    jni,</span>
<span class="line-modified">436                                int        chainLength,</span>
<span class="line-modified">437                                ObjectDesc objectDescList[])</span>
438 {
<span class="line-modified">439     bool success = true;</span>
440     int i, idx;
441 
442     printf(&quot;Following tagged objects were iterated:\n&quot;);
443 
444     printf(&quot;Root tested object:\n&quot;);
445     printf(&quot;   tag:                 %ld\n&quot;
446            &quot;   expected to iterate: %d times\n&quot;
447            &quot;   iterated:            %d times\n&quot;,
448            (long) objectDescList[0].tag,
449                   objectDescList[0].exp_found,
450                   objectDescList[0].found);
451     if (objectDescList[0].found != objectDescList[0].exp_found) {
452         NSK_COMPLAIN1(&quot;Root tested object unexpectedly iterated %d times\n&quot;,
453                       objectDescList[0].found);
454         nsk_jvmti_setFailStatus();
455     }
456 
457     printf(&quot;\nReachable objects:\n&quot;);
458     fflush(0);
459     for (i = 0; i &lt; chainLength; i++) {
</pre>
<hr />
<pre>
476     }
477 
478     printf(&quot;\nUnreachable objects:\n&quot;);
479     for (i = 0; i &lt; chainLength; i++) {
480         idx = i + 1 + chainLength;
481 
482         printf(&quot;Unreachable object:\n&quot;
483                &quot;   tag:                 %ld\n&quot;
484                &quot;   expected to iterate: %d times\n&quot;
485                &quot;   iterated:            %d times\n&quot;,
486                 (long) objectDescList[idx].tag,
487                        objectDescList[idx].exp_found,
488                        objectDescList[idx].found);
489         if (objectDescList[idx].found &gt; 0) {
490             NSK_COMPLAIN0(&quot;Unreachable object was iterated\n&quot;);
491             nsk_jvmti_setFailStatus();
492         }
493         fflush(0);
494     }
495 
<span class="line-modified">496     return true;</span>
497 } /* checkTestedObjects */
498 
499 
500 /** Release references to the tested objects and free allocated memory. */
<span class="line-modified">501 static void releaseTestedObjects(jvmtiEnv*   jvmti,</span>
<span class="line-modified">502                                  JNIEnv*     jni,</span>
<span class="line-modified">503                                  int         chainLength,</span>
<span class="line-modified">504                                  ObjectDesc* objectDescList,</span>
<span class="line-modified">505                                  jobject     rootObject)</span>
506 {
507     if (rootObject != NULL) {
508         printf(&quot;Release object reference to root tested object: 0x%p\n&quot;, rootObject);
509         NSK_TRACE(jni-&gt;DeleteGlobalRef(rootObject));
510     }
511 
512     if (objectDescList != NULL) {
513         printf(&quot;Deallocate objects list: 0x%p\n&quot;, (void*)objectDescList);
514         if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)objectDescList))) {
515             nsk_jvmti_setFailStatus();
516         }
517     }
518 
519     fflush(0);

520 } /* releaseTestedObjects */
521 
522 
523 /* ============================================================================= */
524 
525 /** heapReferenceCallback for heap iterator. */
526 jint JNICALL heapReferenceCallback(
527      jvmtiHeapReferenceKind        reference_kind,
528      const jvmtiHeapReferenceInfo* reference_info,
529      jlong                         class_tag,
530      jlong                         referrer_class_tag,
531      jlong                         size,
532      jlong*                        tag_ptr,
533      jlong*                        referrer_tag_ptr,
534      jint                          length,
535      void*                         user_data)
536 {
537     jint referrer_index = 0;
538     jlong tag;
539     jlong ref_tag;
</pre>
<hr />
<pre>
761 
762     if (!NSK_JVMTI_VERIFY(jvmti-&gt;FollowReferences((jint)   0,    /* heap_filter    */
763                                                   (jclass) NULL, /* class          */
764                                                   rootObject,    /* initial_object */
765                                                   &amp;heapCallbacks,
766                                                   (const void *) &amp;fakeUserData))) {
767          nsk_jvmti_setFailStatus();
768          return;
769     }
770 
771     printf(&quot;&gt;&gt;&gt; Check if reachable objects were iterated:\n&quot;);
772     fflush(0);
773 
774     if (!checkTestedObjects(jvmti, jni, chainLength, objectDescList)) {
775         nsk_jvmti_setFailStatus();
776     }
777 
778     printf(&quot;&gt;&gt;&gt; Clean used data\n&quot;);
779     fflush(0);
780 
<span class="line-modified">781     releaseTestedObjects(jvmti, jni, chainLength, objectDescList, rootObject);</span>



782 
783     printf(&quot;&gt;&gt;&gt; Let debugee to finish\n&quot;);
784     fflush(0);
785     if (!NSK_VERIFY(nsk_jvmti_resumeSync())) {
786         return;
787     }
788 } /* agentProc */
789 
790 
791 /* ============================================================================= */
792 
793 /** Agent library initialization. */
794 #ifdef STATIC_BUILD
795 JNIEXPORT jint JNICALL Agent_OnLoad_followref001(JavaVM *jvm, char *options, void *reserved) {
796     return Agent_Initialize(jvm, options, reserved);
797 }
798 JNIEXPORT jint JNICALL Agent_OnAttach_followref001(JavaVM *jvm, char *options, void *reserved) {
799     return Agent_Initialize(jvm, options, reserved);
800 }
801 JNIEXPORT jint JNI_OnLoad_followref001(JavaVM *jvm, char *options, void *reserved) {
</pre>
</td>
</tr>
</table>
<center><a href="../../../scenarios/sampling/SP06/sp06t003/sp06t003.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../followref003/followref003.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
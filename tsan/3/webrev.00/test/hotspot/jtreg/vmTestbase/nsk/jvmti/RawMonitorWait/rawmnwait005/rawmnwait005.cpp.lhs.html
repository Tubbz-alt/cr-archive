<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/RawMonitorWait/rawmnwait005/rawmnwait005.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdio.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &quot;jvmti.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;JVMTITools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 
 33 #define PASSED 0
 34 #define STATUS_FAILED 2
 35 #define MILLIS_PER_MINUTE (60 * 1000)
 36 
 37 static jvmtiEnv *jvmti = NULL;
 38 static jvmtiCapabilities caps;
 39 static jint result = PASSED;
<a name="2" id="anc2"></a><span class="line-modified"> 40 static jboolean printdump = JNI_FALSE;</span>
 41 static jrawMonitorID monitor;
 42 static jrawMonitorID wait_lock;
 43 static jlong wait_time;
 44 
 45 #ifdef STATIC_BUILD
 46 JNIEXPORT jint JNICALL Agent_OnLoad_rawmnwait005(JavaVM *jvm, char *options, void *reserved) {
 47     return Agent_Initialize(jvm, options, reserved);
 48 }
 49 JNIEXPORT jint JNICALL Agent_OnAttach_rawmnwait005(JavaVM *jvm, char *options, void *reserved) {
 50     return Agent_Initialize(jvm, options, reserved);
 51 }
 52 JNIEXPORT jint JNI_OnLoad_rawmnwait005(JavaVM *jvm, char *options, void *reserved) {
 53     return JNI_VERSION_1_8;
 54 }
 55 #endif
 56 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
 57     jint res;
 58     jvmtiError err;
 59 
 60     if (options != NULL &amp;&amp; strcmp(options, &quot;printdump&quot;) == 0) {
 61         printdump = JNI_TRUE;
 62     }
 63 
 64     res = jvm-&gt;GetEnv((void **) &amp;jvmti, JVMTI_VERSION_1_1);
 65     if (res != JNI_OK || jvmti == NULL) {
 66         printf(&quot;Wrong result of a valid call to GetEnv!\n&quot;);
 67         return JNI_ERR;
 68     }
 69 
 70     err = jvmti-&gt;GetPotentialCapabilities(&amp;caps);
 71     if (err != JVMTI_ERROR_NONE) {
 72         printf(&quot;(GetPotentialCapabilities) unexpected error: %s (%d)\n&quot;,
 73                TranslateError(err), err);
 74         return JNI_ERR;
 75     }
 76 
 77     err = jvmti-&gt;AddCapabilities(&amp;caps);
 78     if (err != JVMTI_ERROR_NONE) {
 79         printf(&quot;(AddCapabilities) unexpected error: %s (%d)\n&quot;,
 80                TranslateError(err), err);
 81         return JNI_ERR;
 82     }
 83 
 84     err = jvmti-&gt;GetCapabilities(&amp;caps);
 85     if (err != JVMTI_ERROR_NONE) {
 86         printf(&quot;(GetCapabilities) unexpected error: %s (%d)\n&quot;,
 87                TranslateError(err), err);
 88         return JNI_ERR;
 89     }
 90 
 91     if (!caps.can_signal_thread) {
 92         printf(&quot;Warning: InterruptThread is not implemented\n&quot;);
 93     }
 94 
 95     return JNI_OK;
 96 }
 97 
 98 static void JNICALL
 99 test_thread(jvmtiEnv* jvmti, JNIEnv* jni, void *unused) {
100     jvmtiError err;
101     const char* const thread_name = &quot;test thread&quot;;
102 
<a name="3" id="anc3"></a>

103     err = jvmti-&gt;RawMonitorEnter(monitor);
104     if (err != JVMTI_ERROR_NONE) {
105         printf(&quot;(RawMonitorEnter#test) unexpected error: %s (%d)\n&quot;,
106                TranslateError(err), err);
107         result = STATUS_FAILED;
108     }
109     if (printdump == JNI_TRUE) {
110         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;monitor&#39; ...\n&quot;, thread_name);
111     }
112 
<a name="4" id="anc4"></a>
113     err = jvmti-&gt;RawMonitorEnter(wait_lock);
114     if (err != JVMTI_ERROR_NONE) {
115         printf(&quot;(RawMonitorEnter#wait) unexpected error: %s (%d)\n&quot;,
116                TranslateError(err), err);
117         result = STATUS_FAILED;
118         return;
119     }
120 
121     if (printdump == JNI_TRUE) {
122         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;wait_lock&#39; ...\n&quot;, thread_name);
123         printf(&quot;&gt;&gt;&gt; [%s] notifying main thread (wait_lock.notify) ...\n&quot;, thread_name);
124     }
125 
126     err = jvmti-&gt;RawMonitorNotify(wait_lock);
127     if (err != JVMTI_ERROR_NONE) {
128         printf(&quot;(RawMonitorWait#wait) unexpected error: %s (%d)\n&quot;,
129                TranslateError(err), err);
130         result = STATUS_FAILED;
131         return;
132     }
133     err = jvmti-&gt;RawMonitorExit(wait_lock);
134     if (err != JVMTI_ERROR_NONE) {
135         printf(&quot;(RawMonitorExit#wait) unexpected error: %s (%d)\n&quot;,
136                TranslateError(err), err);
137         result = STATUS_FAILED;
138         return;
139     }
140 
141     if (printdump == JNI_TRUE) {
142         printf(&quot;&gt;&gt;&gt; [%s] waiting for interrupt ...\n&quot;, thread_name);
143     }
144 
145     err = jvmti-&gt;RawMonitorWait(monitor, wait_time);
146     if (err != JVMTI_ERROR_INTERRUPT) {
147         printf(&quot;Error expected: JVMTI_ERROR_INTERRUPT,\n&quot;);
148         printf(&quot;\tactual: %s (%d)\n&quot;, TranslateError(err), err);
149         result = STATUS_FAILED;
150     }
151 
152     err = jvmti-&gt;RawMonitorExit(monitor);
153     if (err != JVMTI_ERROR_NONE) {
154         printf(&quot;(RawMonitorExit#test) unexpected error: %s (%d)\n&quot;,
155                TranslateError(err), err);
156         result = STATUS_FAILED;
157     }
158 
<a name="5" id="anc5"></a>





























159     if (printdump == JNI_TRUE) {
160         printf(&quot;&gt;&gt;&gt; [%s] all done\n&quot;, thread_name);
161     }
162 }
163 
164 JNIEXPORT jint JNICALL
165 Java_nsk_jvmti_RawMonitorWait_rawmnwait005_check(JNIEnv *env,
166         jclass cls, jthread thr, jint wtime) {
167     jvmtiError err;
168     const char* const thread_name = &quot;main thread&quot;;
169 
170     if (!caps.can_signal_thread) {
171         return result;
172     }
173 
174     wait_time = wtime * MILLIS_PER_MINUTE;
175 
176     if (jvmti == NULL) {
177         printf(&quot;JVMTI client was not properly loaded!\n&quot;);
178         return STATUS_FAILED;
179     }
180 
181     err = jvmti-&gt;CreateRawMonitor(&quot;test monitor&quot;, &amp;monitor);
182     if (err != JVMTI_ERROR_NONE) {
183         printf(&quot;(CreateRawMonitor#test) unexpected error: %s (%d)\n&quot;,
184                TranslateError(err), err);
185         return STATUS_FAILED;
186     }
187 
188     // &#39;wait_lock&#39; is used to notify current thread when child thread (&#39;test_thread&#39;)
189     //  is ready. This in particular means &#39;test_thread&#39; is waiting for notification
190     //  of the raw monitor &#39;monitor&#39; and current thread can now interrupt &#39;test_thread&#39;.
191     //
192     err = jvmti-&gt;CreateRawMonitor(&quot;wait lock&quot;, &amp;wait_lock);
193     if (err != JVMTI_ERROR_NONE) {
194         printf(&quot;(CreateRawMonitor#wait) unexpected error: %s (%d)\n&quot;,
195                TranslateError(err), err);
196         return STATUS_FAILED;
197     }
198 
199     // get exclusive ownership of &#39;wait_lock&#39; monitor before
200     //  starting &#39;test_thread&#39; to avoid following race condition:
201     //   &#39;test_thread&#39;     |   current thread
202     //   -------------------------------------
203     //                     | RunAgentThread(..., test_thread, ...)
204     //    wait_lock.enter  |
205     //    wait_lock.notify |
206     //                     | wait_lock.enter
207     //                     | wait_lock.wait(0)
208     //    ...              |
209     //                     |  ... will wait forever ...
210     //
211     // See also 6399368 test bug.
212     //
213     err = jvmti-&gt;RawMonitorEnter(wait_lock);
214     if (err != JVMTI_ERROR_NONE) {
215         printf(&quot;(RawMonitorEnter#wait) unexpected error: %s (%d)\n&quot;,
216                TranslateError(err), err);
217         return STATUS_FAILED;
218     }
219     if (printdump == JNI_TRUE) {
220         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;wait_lock&#39; ... \n&quot;, thread_name);
221     }
222 
223     if (printdump == JNI_TRUE) {
224         printf(&quot;&gt;&gt;&gt; [%s] starting test thread ...\n&quot;, thread_name);
225     }
<a name="6" id="anc6"></a>




226     err = jvmti-&gt;RunAgentThread(thr, test_thread, NULL,
227                                 JVMTI_THREAD_NORM_PRIORITY);
228     if (err != JVMTI_ERROR_NONE) {
229         printf(&quot;(RunDebugThread) unexpected error: %s (%d)\n&quot;,
230                TranslateError(err), err);
231         return STATUS_FAILED;
232     }
233 
234     if (printdump == JNI_TRUE) {
235         printf(&quot;&gt;&gt;&gt; [%s] waiting for test thread to run (do wait_lock.wait)...\n&quot;, thread_name);
236     }
237     err = jvmti-&gt;RawMonitorWait(wait_lock, (jlong)0);
238     if (err != JVMTI_ERROR_NONE) {
239         printf(&quot;(RawMonitorWait#wait) unexpected error: %s (%d)\n&quot;,
240                TranslateError(err), err);
241         return STATUS_FAILED;
242     }
243     if (printdump == JNI_TRUE) {
244         printf(&quot;&gt;&gt;&gt; [%s] got notification from test thread ...\n&quot;, thread_name);
245     }
246 
<a name="7" id="anc7"></a><span class="line-modified">247     err = jvmti-&gt;RawMonitorExit(wait_lock);</span>
<span class="line-removed">248     if (err != JVMTI_ERROR_NONE) {</span>
<span class="line-removed">249         printf(&quot;(RawMonitorExit#wait) unexpected error: %s (%d)\n&quot;,</span>
<span class="line-removed">250                TranslateError(err), err);</span>
<span class="line-removed">251         return STATUS_FAILED;</span>
<span class="line-removed">252     }</span>
253 
254     err = jvmti-&gt;RawMonitorEnter(monitor);
255     if (err != JVMTI_ERROR_NONE) {
256         printf(&quot;(RawMonitorEnter#test) unexpected error: %s (%d)\n&quot;,
257                TranslateError(err), err);
258         return STATUS_FAILED;
259     }
260     if (printdump == JNI_TRUE) {
261         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;monitor&#39; ... \n&quot;, thread_name);
262     }
263 
264     if (printdump == JNI_TRUE) {
265         printf(&quot;&gt;&gt;&gt; [%s] interrupting test thread ...\n&quot;, thread_name);
266     }
267 
268     err = jvmti-&gt;InterruptThread(thr);
269     if (err != JVMTI_ERROR_NONE) {
270         printf(&quot;(InterruptThread) unexpected error: %s (%d)\n&quot;,
271                TranslateError(err), err);
272         result = STATUS_FAILED;
273     }
274 
275     err = jvmti-&gt;RawMonitorExit(monitor);
276     if (err != JVMTI_ERROR_NONE) {
277         printf(&quot;(RawMonitorExit#test) unexpected error: %s (%d)\n&quot;,
278                TranslateError(err), err);
279         result = STATUS_FAILED;
280     }
281 
<a name="8" id="anc8"></a>



















282     if (printdump == JNI_TRUE) {
283         printf(&quot;&gt;&gt;&gt; [%s] all done\n&quot;, thread_name);
284     }
285 
286     return result;
287 }
288 
289 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
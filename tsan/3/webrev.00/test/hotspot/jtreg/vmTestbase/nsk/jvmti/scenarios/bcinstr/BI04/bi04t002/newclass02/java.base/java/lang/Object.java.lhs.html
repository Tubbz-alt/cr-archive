<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/bcinstr/BI04/bi04t002/newclass02/java.base/java/lang/Object.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package java.lang;
 25 
 26 import nsk.jvmti.scenarios.bcinstr.BI04.bi04t002a;
 27 
 28 /**
 29  * Class &lt;code&gt;Object&lt;/code&gt; is the root of the class hierarchy.
 30  * Every class has &lt;code&gt;Object&lt;/code&gt; as a superclass. All objects,
 31  * including arrays, implement the methods of this class.
 32  *
 33  * @author  unascribed
 34  * @version 1.67, 02/03/04
 35  * @see     java.lang.Class
 36  * @since   JDK1.0
 37  */
 38 public class Object {
 39 
<a name="1" id="anc1"></a><span class="line-removed"> 40     private static native void registerNatives();</span>
<span class="line-removed"> 41     static {</span>
<span class="line-removed"> 42         registerNatives();</span>
<span class="line-removed"> 43     }</span>
<span class="line-removed"> 44 </span>
 45     /**
 46      * Returns the runtime class of an object. That &lt;tt&gt;Class&lt;/tt&gt;
 47      * object is the object that is locked by &lt;tt&gt;static synchronized&lt;/tt&gt;
 48      * methods of the represented class.
 49      *
 50      * @return The &lt;code&gt;java.lang.Class&lt;/code&gt; object that represents
 51      *         the runtime class of the object.  The result is of type
 52      *         {@code Class&lt;? extends X&gt;} where X is the
 53      *         static type of the expression on which
 54      *         &lt;code&gt;getClass&lt;/code&gt; is called.
 55      */
 56     public final native Class&lt;? extends Object&gt; getClass();
 57 
 58     /**
 59      * Returns a hash code value for the object. This method is
 60      * supported for the benefit of hashtables such as those provided by
 61      * &lt;code&gt;java.util.Hashtable&lt;/code&gt;.
 62      * &lt;p&gt;
 63      * The general contract of &lt;code&gt;hashCode&lt;/code&gt; is:
 64      * &lt;ul&gt;
 65      * &lt;li&gt;Whenever it is invoked on the same object more than once during
 66      *     an execution of a Java application, the &lt;tt&gt;hashCode&lt;/tt&gt; method
 67      *     must consistently return the same integer, provided no information
 68      *     used in &lt;tt&gt;equals&lt;/tt&gt; comparisons on the object is modified.
 69      *     This integer need not remain consistent from one execution of an
 70      *     application to another execution of the same application.
 71      * &lt;li&gt;If two objects are equal according to the &lt;tt&gt;equals(Object)&lt;/tt&gt;
 72      *     method, then calling the &lt;code&gt;hashCode&lt;/code&gt; method on each of
 73      *     the two objects must produce the same integer result.
 74      * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal
 75      *     according to the {@link java.lang.Object#equals(java.lang.Object)}
 76      *     method, then calling the &lt;tt&gt;hashCode&lt;/tt&gt; method on each of the
 77      *     two objects must produce distinct integer results.  However, the
 78      *     programmer should be aware that producing distinct integer results
 79      *     for unequal objects may improve the performance of hashtables.
 80      * &lt;/ul&gt;
 81      * &lt;p&gt;
 82      * As much as is reasonably practical, the hashCode method defined by
 83      * class &lt;tt&gt;Object&lt;/tt&gt; does return distinct integers for distinct
 84      * objects. (This is typically implemented by converting the internal
 85      * address of the object into an integer, but this implementation
 86      * technique is not required by the
 87      * Java&lt;font size=&quot;-2&quot;&gt;&lt;sup&gt;TM&lt;/sup&gt;&lt;/font&gt; programming language.)
 88      *
 89      * @return  a hash code value for this object.
 90      * @see     java.lang.Object#equals(java.lang.Object)
 91      * @see     java.util.Hashtable
 92      */
 93     public native int hashCode();
 94 
 95     /**
 96      * Indicates whether some other object is &quot;equal to&quot; this one.
 97      * &lt;p&gt;
 98      * The &lt;code&gt;equals&lt;/code&gt; method implements an equivalence relation
 99      * on non-null object references:
100      * &lt;ul&gt;
101      * &lt;li&gt;It is &lt;i&gt;reflexive&lt;/i&gt;: for any non-null reference value
102      *     &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.equals(x)&lt;/code&gt; should return
103      *     &lt;code&gt;true&lt;/code&gt;.
104      * &lt;li&gt;It is &lt;i&gt;symmetric&lt;/i&gt;: for any non-null reference values
105      *     &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;x.equals(y)&lt;/code&gt;
106      *     should return &lt;code&gt;true&lt;/code&gt; if and only if
107      *     &lt;code&gt;y.equals(x)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.
108      * &lt;li&gt;It is &lt;i&gt;transitive&lt;/i&gt;: for any non-null reference values
109      *     &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, if
110      *     &lt;code&gt;x.equals(y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; and
111      *     &lt;code&gt;y.equals(z)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, then
112      *     &lt;code&gt;x.equals(z)&lt;/code&gt; should return &lt;code&gt;true&lt;/code&gt;.
113      * &lt;li&gt;It is &lt;i&gt;consistent&lt;/i&gt;: for any non-null reference values
114      *     &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, multiple invocations of
115      *     &lt;tt&gt;x.equals(y)&lt;/tt&gt; consistently return &lt;code&gt;true&lt;/code&gt;
116      *     or consistently return &lt;code&gt;false&lt;/code&gt;, provided no
117      *     information used in &lt;code&gt;equals&lt;/code&gt; comparisons on the
118      *     objects is modified.
119      * &lt;li&gt;For any non-null reference value &lt;code&gt;x&lt;/code&gt;,
120      *     &lt;code&gt;x.equals(null)&lt;/code&gt; should return &lt;code&gt;false&lt;/code&gt;.
121      * &lt;/ul&gt;
122      * &lt;p&gt;
123      * The &lt;tt&gt;equals&lt;/tt&gt; method for class &lt;code&gt;Object&lt;/code&gt; implements
124      * the most discriminating possible equivalence relation on objects;
125      * that is, for any non-null reference values &lt;code&gt;x&lt;/code&gt; and
126      * &lt;code&gt;y&lt;/code&gt;, this method returns &lt;code&gt;true&lt;/code&gt; if and only
127      * if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; refer to the same object
128      * (&lt;code&gt;x == y&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;).
129      * &lt;p&gt;
130      * Note that it is generally necessary to override the &lt;tt&gt;hashCode&lt;/tt&gt;
131      * method whenever this method is overridden, so as to maintain the
132      * general contract for the &lt;tt&gt;hashCode&lt;/tt&gt; method, which states
133      * that equal objects must have equal hash codes.
134      *
135      * @param   obj   the reference object with which to compare.
136      * @return  &lt;code&gt;true&lt;/code&gt; if this object is the same as the obj
137      *          argument; &lt;code&gt;false&lt;/code&gt; otherwise.
138      * @see     #hashCode()
139      * @see     java.util.Hashtable
140      */
141     public boolean equals(Object obj) {
142         bi04t002a.instrInvoke(bi04t002a.INSTR_EQUALS);
143         return (this == obj);
144     }
145 
146     /**
147      * Creates and returns a copy of this object.  The precise meaning
148      * of &quot;copy&quot; may depend on the class of the object. The general
149      * intent is that, for any object &lt;tt&gt;x&lt;/tt&gt;, the expression:
150      * &lt;blockquote&gt;
151      * &lt;pre&gt;
152      * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;
153      * will be true, and that the expression:
154      * &lt;blockquote&gt;
155      * &lt;pre&gt;
156      * x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;
157      * will be &lt;tt&gt;true&lt;/tt&gt;, but these are not absolute requirements.
158      * While it is typically the case that:
159      * &lt;blockquote&gt;
160      * &lt;pre&gt;
161      * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;
162      * will be &lt;tt&gt;true&lt;/tt&gt;, this is not an absolute requirement.
163      * &lt;p&gt;
164      * By convention, the returned object should be obtained by calling
165      * &lt;tt&gt;super.clone&lt;/tt&gt;.  If a class and all of its superclasses (except
166      * &lt;tt&gt;Object&lt;/tt&gt;) obey this convention, it will be the case that
167      * &lt;tt&gt;x.clone().getClass() == x.getClass()&lt;/tt&gt;.
168      * &lt;p&gt;
169      * By convention, the object returned by this method should be independent
170      * of this object (which is being cloned).  To achieve this independence,
171      * it may be necessary to modify one or more fields of the object returned
172      * by &lt;tt&gt;super.clone&lt;/tt&gt; before returning it.  Typically, this means
173      * copying any mutable objects that comprise the internal &quot;deep structure&quot;
174      * of the object being cloned and replacing the references to these
175      * objects with references to the copies.  If a class contains only
176      * primitive fields or references to immutable objects, then it is usually
177      * the case that no fields in the object returned by &lt;tt&gt;super.clone&lt;/tt&gt;
178      * need to be modified.
179      * &lt;p&gt;
180      * The method &lt;tt&gt;clone&lt;/tt&gt; for class &lt;tt&gt;Object&lt;/tt&gt; performs a
181      * specific cloning operation. First, if the class of this object does
182      * not implement the interface &lt;tt&gt;Cloneable&lt;/tt&gt;, then a
183      * &lt;tt&gt;CloneNotSupportedException&lt;/tt&gt; is thrown. Note that all arrays
184      * are considered to implement the interface &lt;tt&gt;Cloneable&lt;/tt&gt;.
185      * Otherwise, this method creates a new instance of the class of this
186      * object and initializes all its fields with exactly the contents of
187      * the corresponding fields of this object, as if by assignment; the
188      * contents of the fields are not themselves cloned. Thus, this method
189      * performs a &quot;shallow copy&quot; of this object, not a &quot;deep copy&quot; operation.
190      * &lt;p&gt;
191      * The class &lt;tt&gt;Object&lt;/tt&gt; does not itself implement the interface
192      * &lt;tt&gt;Cloneable&lt;/tt&gt;, so calling the &lt;tt&gt;clone&lt;/tt&gt; method on an object
193      * whose class is &lt;tt&gt;Object&lt;/tt&gt; will result in throwing an
194      * exception at run time.
195      *
196      * @return     a clone of this instance.
197      * @exception  CloneNotSupportedException  if the object&#39;s class does not
198      *               support the &lt;code&gt;Cloneable&lt;/code&gt; interface. Subclasses
199      *               that override the &lt;code&gt;clone&lt;/code&gt; method can also
200      *               throw this exception to indicate that an instance cannot
201      *               be cloned.
202      * @see java.lang.Cloneable
203      */
204     protected native Object clone() throws CloneNotSupportedException;
205 
206     /**
207      * Returns a string representation of the object. In general, the
208      * &lt;code&gt;toString&lt;/code&gt; method returns a string that
209      * &quot;textually represents&quot; this object. The result should
210      * be a concise but informative representation that is easy for a
211      * person to read.
212      * It is recommended that all subclasses override this method.
213      * &lt;p&gt;
214      * The &lt;code&gt;toString&lt;/code&gt; method for class &lt;code&gt;Object&lt;/code&gt;
215      * returns a string consisting of the name of the class of which the
216      * object is an instance, the at-sign character `&lt;code&gt;@&lt;/code&gt;&#39;, and
217      * the unsigned hexadecimal representation of the hash code of the
218      * object. In other words, this method returns a string equal to the
219      * value of:
220      * &lt;blockquote&gt;
221      * &lt;pre&gt;
222      * getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode())
223      * &lt;/pre&gt;&lt;/blockquote&gt;
224      *
225      * @return  a string representation of the object.
226      */
227     public String toString() {
228         bi04t002a.instrInvoke(bi04t002a.INSTR_TOSTRING);
229         return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
230     }
231 
232     /**
233      * Wakes up a single thread that is waiting on this object&#39;s
234      * monitor. If any threads are waiting on this object, one of them
235      * is chosen to be awakened. The choice is arbitrary and occurs at
236      * the discretion of the implementation. A thread waits on an object&#39;s
237      * monitor by calling one of the &lt;code&gt;wait&lt;/code&gt; methods.
238      * &lt;p&gt;
239      * The awakened thread will not be able to proceed until the current
240      * thread relinquishes the lock on this object. The awakened thread will
241      * compete in the usual manner with any other threads that might be
242      * actively competing to synchronize on this object; for example, the
243      * awakened thread enjoys no reliable privilege or disadvantage in being
244      * the next thread to lock this object.
245      * &lt;p&gt;
246      * This method should only be called by a thread that is the owner
247      * of this object&#39;s monitor. A thread becomes the owner of the
248      * object&#39;s monitor in one of three ways:
249      * &lt;ul&gt;
250      * &lt;li&gt;By executing a synchronized instance method of that object.
251      * &lt;li&gt;By executing the body of a &lt;code&gt;synchronized&lt;/code&gt; statement
252      *     that synchronizes on the object.
253      * &lt;li&gt;For objects of type &lt;code&gt;Class,&lt;/code&gt; by executing a
254      *     synchronized static method of that class.
255      * &lt;/ul&gt;
256      * &lt;p&gt;
257      * Only one thread at a time can own an object&#39;s monitor.
258      *
259      * @exception  IllegalMonitorStateException  if the current thread is not
260      *               the owner of this object&#39;s monitor.
261      * @see        java.lang.Object#notifyAll()
262      * @see        java.lang.Object#wait()
263      */
264     public final native void notify();
265 
266     /**
267      * Wakes up all threads that are waiting on this object&#39;s monitor. A
268      * thread waits on an object&#39;s monitor by calling one of the
269      * &lt;code&gt;wait&lt;/code&gt; methods.
270      * &lt;p&gt;
271      * The awakened threads will not be able to proceed until the current
272      * thread relinquishes the lock on this object. The awakened threads
273      * will compete in the usual manner with any other threads that might
274      * be actively competing to synchronize on this object; for example,
275      * the awakened threads enjoy no reliable privilege or disadvantage in
276      * being the next thread to lock this object.
277      * &lt;p&gt;
278      * This method should only be called by a thread that is the owner
279      * of this object&#39;s monitor. See the &lt;code&gt;notify&lt;/code&gt; method for a
280      * description of the ways in which a thread can become the owner of
281      * a monitor.
282      *
283      * @exception  IllegalMonitorStateException  if the current thread is not
284      *               the owner of this object&#39;s monitor.
285      * @see        java.lang.Object#notify()
286      * @see        java.lang.Object#wait()
287      */
288     public final native void notifyAll();
289 
290     /**
291      * Causes current thread to wait until either another thread invokes the
292      * {@link java.lang.Object#notify()} method or the
293      * {@link java.lang.Object#notifyAll()} method for this object, or a
294      * specified amount of time has elapsed.
295      * &lt;p&gt;
296      * The current thread must own this object&#39;s monitor.
297      * &lt;p&gt;
298      * This method causes the current thread (call it &lt;var&gt;T&lt;/var&gt;) to
299      * place itself in the wait set for this object and then to relinquish
300      * any and all synchronization claims on this object. Thread &lt;var&gt;T&lt;/var&gt;
301      * becomes disabled for thread scheduling purposes and lies dormant
302      * until one of four things happens:
303      * &lt;ul&gt;
304      * &lt;li&gt;Some other thread invokes the &lt;tt&gt;notify&lt;/tt&gt; method for this
305      * object and thread &lt;var&gt;T&lt;/var&gt; happens to be arbitrarily chosen as
306      * the thread to be awakened.
307      * &lt;li&gt;Some other thread invokes the &lt;tt&gt;notifyAll&lt;/tt&gt; method for this
308      * object.
309      * &lt;li&gt;Some other thread {@link java.lang.Thread#interrupt() interrupts}
310      * thread &lt;var&gt;T&lt;/var&gt;.
311      * &lt;li&gt;The specified amount of real time has elapsed, more or less.  If
312      * &lt;tt&gt;timeout&lt;/tt&gt; is zero, however, then real time is not taken into
313      * consideration and the thread simply waits until notified.
314      * &lt;/ul&gt;
315      * The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this
316      * object and re-enabled for thread scheduling. It then competes in the
317      * usual manner with other threads for the right to synchronize on the
318      * object; once it has gained control of the object, all its
319      * synchronization claims on the object are restored to the status quo
320      * ante - that is, to the situation as of the time that the &lt;tt&gt;wait&lt;/tt&gt;
321      * method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the
322      * invocation of the &lt;tt&gt;wait&lt;/tt&gt; method. Thus, on return from the
323      * &lt;tt&gt;wait&lt;/tt&gt; method, the synchronization state of the object and of
324      * thread &lt;tt&gt;T&lt;/tt&gt; is exactly as it was when the &lt;tt&gt;wait&lt;/tt&gt; method
325      * was invoked.
326      * &lt;p&gt;
327      * A thread can also wake up without being notified, interrupted, or
328      * timing out, a so-called &lt;i&gt;spurious wakeup&lt;/i&gt;.  While this will rarely
329      * occur in practice, applications must guard against it by testing for
330      * the condition that should have caused the thread to be awakened, and
331      * continuing to wait if the condition is not satisfied.  In other words,
332      * waits should always occur in loops, like this one:
333      * &lt;pre&gt;
334      *     synchronized (obj) {
335      *         while (&amp;lt;condition does not hold&amp;gt;)
336      *             obj.wait(timeout);
337      *         ... // Perform action appropriate to condition
338      *     }
339      * &lt;/pre&gt;
340      * (For more information on this topic, see Section 3.2.3 in Doug Lea&#39;s
341      * &quot;Concurrent Programming in Java (Second Edition)&quot; (Addison-Wesley,
342      * 2000), or Item 50 in Joshua Bloch&#39;s &quot;Effective Java Programming
343      * Language Guide&quot; (Addison-Wesley, 2001).
344      * &lt;p&gt;
345      * If the current thread is
346      * {@link java.lang.Thread#interrupt() interrupted} by another thread
347      * while it is waiting, then an &lt;tt&gt;InterruptedException&lt;/tt&gt; is thrown.
348      * This exception is not thrown until the lock status of this object has
349      * been restored as described above.
350      * &lt;p&gt;
351      * Note that the &lt;tt&gt;wait&lt;/tt&gt; method, as it places the current thread
352      * into the wait set for this object, unlocks only this object; any
353      * other objects on which the current thread may be synchronized remain
354      * locked while the thread waits.
355      * &lt;p&gt;
356      * This method should only be called by a thread that is the owner
357      * of this object&#39;s monitor. See the &lt;code&gt;notify&lt;/code&gt; method for a
358      * description of the ways in which a thread can become the owner of
359      * a monitor.
360      *
361      * @param      timeout   the maximum time to wait in milliseconds.
362      * @exception  IllegalArgumentException      if the value of timeout is
363      *               negative.
364      * @exception  IllegalMonitorStateException  if the current thread is not
365      *               the owner of the object&#39;s monitor.
366      * @exception  InterruptedException if another thread interrupted the
367      *             current thread before or while the current thread
368      *             was waiting for a notification.  The &lt;i&gt;interrupted
369      *             status&lt;/i&gt; of the current thread is cleared when
370      *             this exception is thrown.
371      * @see        java.lang.Object#notify()
372      * @see        java.lang.Object#notifyAll()
373      */
374     public final native void wait(long timeout) throws InterruptedException;
375 
376     /**
377      * Causes current thread to wait until another thread invokes the
378      * {@link java.lang.Object#notify()} method or the
379      * {@link java.lang.Object#notifyAll()} method for this object, or
380      * some other thread interrupts the current thread, or a certain
381      * amount of real time has elapsed.
382      * &lt;p&gt;
383      * This method is similar to the &lt;code&gt;wait&lt;/code&gt; method of one
384      * argument, but it allows finer control over the amount of time to
385      * wait for a notification before giving up. The amount of real time,
386      * measured in nanoseconds, is given by:
387      * &lt;blockquote&gt;
388      * &lt;pre&gt;
389      * 1000000*timeout+nanos&lt;/pre&gt;&lt;/blockquote&gt;
390      * &lt;p&gt;
391      * In all other respects, this method does the same thing as the
392      * method {@link #wait(long)} of one argument. In particular,
393      * &lt;tt&gt;wait(0, 0)&lt;/tt&gt; means the same thing as &lt;tt&gt;wait(0)&lt;/tt&gt;.
394      * &lt;p&gt;
395      * The current thread must own this object&#39;s monitor. The thread
396      * releases ownership of this monitor and waits until either of the
397      * following two conditions has occurred:
398      * &lt;ul&gt;
399      * &lt;li&gt;Another thread notifies threads waiting on this object&#39;s monitor
400      *     to wake up either through a call to the &lt;code&gt;notify&lt;/code&gt; method
401      *     or the &lt;code&gt;notifyAll&lt;/code&gt; method.
402      * &lt;li&gt;The timeout period, specified by &lt;code&gt;timeout&lt;/code&gt;
403      *     milliseconds plus &lt;code&gt;nanos&lt;/code&gt; nanoseconds arguments, has
404      *     elapsed.
405      * &lt;/ul&gt;
406      * &lt;p&gt;
407      * The thread then waits until it can re-obtain ownership of the
408      * monitor and resumes execution.
409      * &lt;p&gt;
410      * As in the one argument version, interrupts and spurious wakeups are
411      * possible, and this method should always be used in a loop:
412      * &lt;pre&gt;
413      *     synchronized (obj) {
414      *         while (&amp;lt;condition does not hold&amp;gt;)
415      *             obj.wait(timeout, nanos);
416      *         ... // Perform action appropriate to condition
417      *     }
418      * &lt;/pre&gt;
419      * This method should only be called by a thread that is the owner
420      * of this object&#39;s monitor. See the &lt;code&gt;notify&lt;/code&gt; method for a
421      * description of the ways in which a thread can become the owner of
422      * a monitor.
423      *
424      * @param      timeout   the maximum time to wait in milliseconds.
425      * @param      nanos      additional time, in nanoseconds range
426      *                       0-999999.
427      * @exception  IllegalArgumentException      if the value of timeout is
428      *                      negative or the value of nanos is
429      *                      not in the range 0-999999.
430      * @exception  IllegalMonitorStateException  if the current thread is not
431      *               the owner of this object&#39;s monitor.
432      * @exception  InterruptedException if another thread interrupted the
433      *             current thread before or while the current thread
434      *             was waiting for a notification.  The &lt;i&gt;interrupted
435      *             status&lt;/i&gt; of the current thread is cleared when
436      *             this exception is thrown.
437      */
438     public final void wait(long timeout, int nanos) throws InterruptedException {
439 
440         bi04t002a.instrInvoke(bi04t002a.INSTR_WAIT_JI);
441 
442         if (timeout &lt; 0) {
443             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
444         }
445 
446         if (nanos &lt; 0 || nanos &gt; 999999) {
447             throw new IllegalArgumentException(
448                                 &quot;nanosecond timeout value out of range&quot;);
449         }
450 
451             if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; timeout == 0)) {
452                 timeout++;
453             }
454 
455             wait(timeout);
456     }
457 
458     /**
459      * Causes current thread to wait until another thread invokes the
460      * {@link java.lang.Object#notify()} method or the
461      * {@link java.lang.Object#notifyAll()} method for this object.
462      * In other words, this method behaves exactly as if it simply
463      * performs the call &lt;tt&gt;wait(0)&lt;/tt&gt;.
464      * &lt;p&gt;
465      * The current thread must own this object&#39;s monitor. The thread
466      * releases ownership of this monitor and waits until another thread
467      * notifies threads waiting on this object&#39;s monitor to wake up
468      * either through a call to the &lt;code&gt;notify&lt;/code&gt; method or the
469      * &lt;code&gt;notifyAll&lt;/code&gt; method. The thread then waits until it can
470      * re-obtain ownership of the monitor and resumes execution.
471      * &lt;p&gt;
472      * As in the one argument version, interrupts and spurious wakeups are
473      * possible, and this method should always be used in a loop:
474      * &lt;pre&gt;
475      *     synchronized (obj) {
476      *         while (&amp;lt;condition does not hold&amp;gt;)
477      *             obj.wait();
478      *         ... // Perform action appropriate to condition
479      *     }
480      * &lt;/pre&gt;
481      * This method should only be called by a thread that is the owner
482      * of this object&#39;s monitor. See the &lt;code&gt;notify&lt;/code&gt; method for a
483      * description of the ways in which a thread can become the owner of
484      * a monitor.
485      *
486      * @exception  IllegalMonitorStateException  if the current thread is not
487      *               the owner of the object&#39;s monitor.
488      * @exception  InterruptedException if another thread interrupted the
489      *             current thread before or while the current thread
490      *             was waiting for a notification.  The &lt;i&gt;interrupted
491      *             status&lt;/i&gt; of the current thread is cleared when
492      *             this exception is thrown.
493      * @see        java.lang.Object#notify()
494      * @see        java.lang.Object#notifyAll()
495      */
496     public final void wait() throws InterruptedException {
497         bi04t002a.instrInvoke(bi04t002a.INSTR_WAIT);
498         wait(0);
499     }
500 
501     /**
502      * Called by the garbage collector on an object when garbage collection
503      * determines that there are no more references to the object.
504      * A subclass overrides the &lt;code&gt;finalize&lt;/code&gt; method to dispose of
505      * system resources or to perform other cleanup.
506      * &lt;p&gt;
507      * The general contract of &lt;tt&gt;finalize&lt;/tt&gt; is that it is invoked
508      * if and when the Java&lt;font size=&quot;-2&quot;&gt;&lt;sup&gt;TM&lt;/sup&gt;&lt;/font&gt; virtual
509      * machine has determined that there is no longer any
510      * means by which this object can be accessed by any thread that has
511      * not yet died, except as a result of an action taken by the
512      * finalization of some other object or class which is ready to be
513      * finalized. The &lt;tt&gt;finalize&lt;/tt&gt; method may take any action, including
514      * making this object available again to other threads; the usual purpose
515      * of &lt;tt&gt;finalize&lt;/tt&gt;, however, is to perform cleanup actions before
516      * the object is irrevocably discarded. For example, the finalize method
517      * for an object that represents an input/output connection might perform
518      * explicit I/O transactions to break the connection before the object is
519      * permanently discarded.
520      * &lt;p&gt;
521      * The &lt;tt&gt;finalize&lt;/tt&gt; method of class &lt;tt&gt;Object&lt;/tt&gt; performs no
522      * special action; it simply returns normally. Subclasses of
523      * &lt;tt&gt;Object&lt;/tt&gt; may override this definition.
524      * &lt;p&gt;
525      * The Java programming language does not guarantee which thread will
526      * invoke the &lt;tt&gt;finalize&lt;/tt&gt; method for any given object. It is
527      * guaranteed, however, that the thread that invokes finalize will not
528      * be holding any user-visible synchronization locks when finalize is
529      * invoked. If an uncaught exception is thrown by the finalize method,
530      * the exception is ignored and finalization of that object terminates.
531      * &lt;p&gt;
532      * After the &lt;tt&gt;finalize&lt;/tt&gt; method has been invoked for an object, no
533      * further action is taken until the Java virtual machine has again
534      * determined that there is no longer any means by which this object can
535      * be accessed by any thread that has not yet died, including possible
536      * actions by other objects or classes which are ready to be finalized,
537      * at which point the object may be discarded.
538      * &lt;p&gt;
539      * The &lt;tt&gt;finalize&lt;/tt&gt; method is never invoked more than once by a Java
540      * virtual machine for any given object.
541      * &lt;p&gt;
542      * Any exception thrown by the &lt;code&gt;finalize&lt;/code&gt; method causes
543      * the finalization of this object to be halted, but is otherwise
544      * ignored.
545      *
546      * @throws Throwable the &lt;code&gt;Exception&lt;/code&gt; raised by this method
547      */
548     protected void finalize() throws Throwable { }
549 
550 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/sampling/SP02/sp02t003/sp02t003.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 /* ============================================================================= */
 33 
 34 /* scaffold objects */
 35 static JNIEnv* jni = NULL;
 36 static jvmtiEnv *jvmti = NULL;
 37 static jlong timeout = 0;
 38 
 39 /* constants */
 40 #define THREADS_COUNT   6
 41 #define MAX_NAME_LENGTH 100
 42 #define MAX_STACK_SIZE  100
 43 
 44 /* thread description structure */
 45 typedef struct {
 46     char threadName[MAX_NAME_LENGTH];
 47     char methodName[MAX_NAME_LENGTH];
 48     char methodSig[MAX_NAME_LENGTH];
 49     jthread thread;
 50     jclass cls;
 51     jmethodID method;
 52     jlocation location;
 53 } ThreadDesc;
 54 
 55 /* descriptions of tested threads */
 56 static ThreadDesc threadsDesc[THREADS_COUNT] = {
 57     { &quot;threadRunning&quot;, &quot;testedMethod&quot;, &quot;()V&quot;, NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },
 58     { &quot;threadEntering&quot;, &quot;testedMethod&quot;, &quot;()V&quot;, NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },
 59     { &quot;threadWaiting&quot;, &quot;testedMethod&quot;, &quot;()V&quot;, NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },
 60     { &quot;threadSleeping&quot;, &quot;testedMethod&quot;, &quot;()V&quot;, NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },
 61     { &quot;threadRunningInterrupted&quot;, &quot;testedMethod&quot;, &quot;()V&quot;, NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },
 62     { &quot;threadRunningNative&quot;, &quot;testedMethod&quot;, &quot;()V&quot;, NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION }
 63 };
 64 
 65 /* indexes of known threads */
 66 static const int interruptedThreadIndex = THREADS_COUNT - 2;
 67 static const int nativeThreadIndex = THREADS_COUNT - 1;
 68 
 69 /* ============================================================================= */
 70 
 71 /* testcase(s) */
 72 static int prepare();
 73 static int checkThreads(int suspended, const char* kind);
 74 static int suspendThreadsIndividually(int suspend);
 75 static int clean();
 76 
 77 /* ============================================================================= */
 78 
 79 /** Agent algorithm. */
 80 static void JNICALL
 81 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
 82     jni = agentJNI;
 83 
 84     /* wait for initial sync */
 85     if (!nsk_jvmti_waitForSync(timeout))
 86         return;
 87 
 88     /* perform testcase(s) */
 89     {
 90         /* prepare data: find threads */
 91         NSK_DISPLAY0(&quot;Prepare data\n&quot;);
 92         if (!prepare()) {
 93             nsk_jvmti_setFailStatus();
 94             return;
 95         }
 96 
 97         /* testcase #1: check not suspended threads */
 98         NSK_DISPLAY0(&quot;Testcase #1: check stack frames of not suspended threads\n&quot;);
 99         if (!checkThreads(NSK_FALSE, &quot;not suspended&quot;))
100             return;
101 
102         /* suspend threads */
103         NSK_DISPLAY0(&quot;Suspend each thread\n&quot;);
104         if (!suspendThreadsIndividually(NSK_TRUE))
105             return;
106 
107         /* testcase #2: check suspended threads */
108         NSK_DISPLAY0(&quot;Testcase #2: check stack frames of suspended threads\n&quot;);
109         if (!checkThreads(NSK_TRUE, &quot;suspended&quot;))
110             return;
111 
112         /* resume threads */
113         NSK_DISPLAY0(&quot;Resume each thread\n&quot;);
114         if (!suspendThreadsIndividually(NSK_FALSE))
115             return;
116 
117         /* testcase #3: check resumed threads */
118         NSK_DISPLAY0(&quot;Testcase #3: check stack frames of resumed threads\n&quot;);
119         if (!checkThreads(NSK_FALSE, &quot;resumed&quot;))
120             return;
121 
122         /* clean date: delete threads references */
123         NSK_DISPLAY0(&quot;Clean data\n&quot;);
124         if (!clean()) {
125             nsk_jvmti_setFailStatus();
126             return;
127         }
128     }
129 
130     /* resume debugee after last sync */
131     if (!nsk_jvmti_resumeSync())
132         return;
133 }
134 
135 /* ============================================================================= */
136 
137 /**
138  * Prepare data:
139  *    - clean threads list
140  *    - get all live threads
141  *    - get threads name
142  *    - find tested threads
143  *    - find tested methos
144  *    - make global refs
145  */
146 static int prepare() {
147     jthread *allThreadsList = NULL;
148     jint allThreadsCount = 0;
149     int found = 0;
150     int i;
151 
152     NSK_DISPLAY1(&quot;Find tested threads: %d\n&quot;, THREADS_COUNT);
153 
154     /* clean threads list */
155     for (i = 0; i &lt; THREADS_COUNT; i++) {
156         threadsDesc[i].thread = (jthread)NULL;
157         threadsDesc[i].method = (jmethodID)NULL;
158         threadsDesc[i].location = NSK_JVMTI_INVALID_JLOCATION;
159     }
160 
161     /* get all live threads */
162     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetAllThreads(&amp;allThreadsCount, &amp;allThreadsList)))
163         return NSK_FALSE;
164 
165     if (!NSK_VERIFY(allThreadsCount &gt; 0 &amp;&amp; allThreadsList != NULL))
166         return NSK_FALSE;
167 
168     /* find tested threads */
169     for (i = 0; i &lt; allThreadsCount; i++) {
170         jvmtiThreadInfo threadInfo;
171 
172         if (!NSK_VERIFY(allThreadsList[i] != NULL))
173             return NSK_FALSE;
174 
175         /* get thread name (info) */
176         if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetThreadInfo(allThreadsList[i], &amp;threadInfo)))
177             return NSK_FALSE;
178 
179         /* find by name */
180         if (threadInfo.name != NULL) {
181             int j;
182 
183             for (j = 0; j &lt; THREADS_COUNT; j++) {
184                 if (strcmp(threadInfo.name, threadsDesc[j].threadName) == 0) {
185                     threadsDesc[j].thread = allThreadsList[i];
186                     NSK_DISPLAY3(&quot;    thread #%d (%s): %p\n&quot;,
187                                             j, threadInfo.name, (void*)threadsDesc[j].thread);
188                 }
189             }
190         }
191     }
192 
193     /* deallocate all threads list */
194     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)allThreadsList)))
195         return NSK_FALSE;
196 
197     /* check if all tested threads found */
198     found = 0;
199     for (i = 0; i &lt; THREADS_COUNT; i++) {
200         if (threadsDesc[i].thread == NULL) {
201             NSK_COMPLAIN2(&quot;Not found tested thread #%d (%s)\n&quot;, i, threadsDesc[i].threadName);
202         } else {
203             found++;
204         }
205     }
206 
207     if (found &lt; THREADS_COUNT)
208         return NSK_FALSE;
209 
210     /* get threads class and frame method */
211     NSK_DISPLAY0(&quot;Find tested methods:\n&quot;);
212     for (i = 0; i &lt; THREADS_COUNT; i++) {
213         /* get thread class */
214         if (!NSK_JNI_VERIFY(jni, (threadsDesc[i].cls =
215                 jni-&gt;GetObjectClass(threadsDesc[i].thread)) != NULL))
216             return NSK_FALSE;
217         /* get frame method */
218         if (!NSK_JNI_VERIFY(jni, (threadsDesc[i].method =
219                 jni-&gt;GetMethodID(threadsDesc[i].cls, threadsDesc[i].methodName, threadsDesc[i].methodSig)) != NULL))
220             return NSK_FALSE;
221 
222         NSK_DISPLAY4(&quot;    thread #%d (%s): %p (%s)\n&quot;,
223                                 i, threadsDesc[i].threadName,
224                                 (void*)threadsDesc[i].method,
225                                 threadsDesc[i].methodName);
226     }
227 
228     /* make global refs */
229     for (i = 0; i &lt; THREADS_COUNT; i++) {
230         if (!NSK_JNI_VERIFY(jni, (threadsDesc[i].thread = (jthread)
231                 jni-&gt;NewGlobalRef(threadsDesc[i].thread)) != NULL))
232             return NSK_FALSE;
233         if (!NSK_JNI_VERIFY(jni, (threadsDesc[i].cls = (jclass)
234                 jni-&gt;NewGlobalRef(threadsDesc[i].cls)) != NULL))
235             return NSK_FALSE;
236     }
237 
238     return NSK_TRUE;
239 }
240 
241 /**
242  * Suspend or resume tested threads.
243  */
244 static int suspendThreadsIndividually(int suspend) {
245     int i;
246 
247     for (i = 0; i &lt; THREADS_COUNT; i++) {
248         if (suspend) {
249             NSK_DISPLAY2(&quot;    suspend thread #%d (%s)\n&quot;, i, threadsDesc[i].threadName);
250             if (!NSK_JVMTI_VERIFY(jvmti-&gt;SuspendThread(threadsDesc[i].thread)))
251                 nsk_jvmti_setFailStatus();
252         } else {
253             NSK_DISPLAY2(&quot;    resume thread #%d (%s)\n&quot;, i, threadsDesc[i].threadName);
254             if (!NSK_JVMTI_VERIFY(jvmti-&gt;ResumeThread(threadsDesc[i].thread)))
255                 nsk_jvmti_setFailStatus();
256         }
257     }
258     return NSK_TRUE;
259 }
260 
261 /**
262  * Testcase: check tested threads
263  *    - call GetFrameCount() and then GetStackTrace()
264  *    - for each stack frame of common depth GetFrameLocation()
265  *    - compare frame ifno returned by GetFrameLocation() and GetStackTrace()
266  *    - find expected frame for tested method
267  *
268  * Returns NSK_TRUE if test may continue; or NSK_FALSE for test break.
269  */
270 static int checkThreads(int suspended, const char* kind) {
271     int i;
272 
273     /* check each thread */
274     for (i = 0; i &lt; THREADS_COUNT; i++) {
275         jint frameCount = 0;
276         jint frameStackSize = 0;
277         jvmtiFrameInfo frameStack[MAX_STACK_SIZE];
278         int found = 0;
279         int j;
280 
281         NSK_DISPLAY2(&quot;  thread #%d (%s):\n&quot;, i, threadsDesc[i].threadName);
282 
283         /* get frame count */
284         if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetFrameCount(threadsDesc[i].thread, &amp;frameCount))) {
285             nsk_jvmti_setFailStatus();
286             return NSK_TRUE;
287         }
288         NSK_DISPLAY1(&quot;    frameCount:  %d\n&quot;, (int)frameCount);
289 
290         /* get stack trace */
291         if (!NSK_JVMTI_VERIFY(
292                 jvmti-&gt;GetStackTrace(threadsDesc[i].thread, 0, MAX_STACK_SIZE, frameStack, &amp;frameStackSize))) {
293             nsk_jvmti_setFailStatus();
294             return NSK_TRUE;
295         }
296         NSK_DISPLAY1(&quot;    stack depth: %d\n&quot;, (int)frameStackSize);
297 
298         found = 0;
299         for (j = 0; j &lt; frameStackSize; j++) {
300             jmethodID qMethod = (jmethodID)NULL;
301             jlocation qLocation = NSK_JVMTI_INVALID_JLOCATION;
302 
303             NSK_DISPLAY3(&quot;      %d frame: method: %p, location: %ld\n&quot;,
304                                         j, (void*)frameStack[j].method,
305                                         (long)frameStack[j].location);
306             /* query frame location */
307             if (!NSK_JVMTI_VERIFY(
308                     jvmti-&gt;GetFrameLocation(threadsDesc[i].thread, j, &amp;qMethod, &amp;qLocation))
309                 &amp;&amp; (suspended == NSK_TRUE)) {
310                 nsk_jvmti_setFailStatus();
311                 continue;
312             }
313 
314             NSK_DISPLAY2(&quot;      queried: method: %p, location: %ld\n&quot;,
315                                         (void*)qMethod, (long)qLocation);
316 
317             /* check frame equality */
318             if ((suspended == NSK_TRUE) &amp;&amp; (frameStack[j].method != qMethod)) {
319                 NSK_COMPLAIN6(&quot;Different method in stack frame #%d for %s thread #%d (%s):\n&quot;
320                             &quot;#   GetStackTrace():    %p\n&quot;
321                             &quot;#   GetFrameLocation(): %p\n&quot;,
322                             j, kind, i, threadsDesc[i].threadName,
323                             (void*)frameStack[j].method, (void*)qMethod);
324                 nsk_jvmti_setFailStatus();
325             }
326             if ((suspended == NSK_TRUE) &amp;&amp; (frameStack[j].location != qLocation)) {
327                 NSK_COMPLAIN6(&quot;Different location in stack frame #%d for %s thread #%d (%s):\n&quot;
328                             &quot;#   GetStackTrace():    %ld\n&quot;
329                             &quot;#   GetFrameLocation(): %ld\n&quot;,
330                             j, kind, i, threadsDesc[i].threadName,
331                             (long)frameStack[j].location, (long)qLocation);
332                 nsk_jvmti_setFailStatus();
333             }
334 
335             /* find expected method */
336             if (frameStack[j].method == threadsDesc[i].method) {
337                 found++;
338                 NSK_DISPLAY1(&quot;        found expected method: %s\n&quot;,
339                                                 threadsDesc[i].methodName);
340             }
341         }
342 
343         /* check if expected method frame found */
344         if (found &lt;= 0) {
345             NSK_COMPLAIN3(&quot;No expected method frame for %s thread #%d (%s)\n&quot;,
346                                 kind, i, threadsDesc[i].threadName);
347             nsk_jvmti_setFailStatus();
348         }
349     }
350 
351     /* test may continue */
352     return NSK_TRUE;
353 }
354 
355 /**
356  * Clean data:
357  *   - dispose global references to tested threads
358  */
359 static int clean() {
360     int i;
361 
362     /* dispose global references to threads */
363     for (i = 0; i &lt; THREADS_COUNT; i++) {
364         NSK_TRACE(jni-&gt;DeleteGlobalRef(threadsDesc[i].thread));
365         NSK_TRACE(jni-&gt;DeleteGlobalRef(threadsDesc[i].cls));
366     }
367 
368     return NSK_TRUE;
369 }
370 
371 /* ============================================================================= */
372 
373 static volatile int testedThreadRunning = NSK_FALSE;
374 static volatile int testedThreadShouldFinish = NSK_FALSE;
375 
376 /** Native running method in tested thread. */
377 JNIEXPORT void JNICALL
378 Java_nsk_jvmti_scenarios_sampling_SP02_sp02t003ThreadRunningNative_testedMethod(JNIEnv* jni,
379                                                                                 jobject obj) {
380     volatile int i = 0, n = 1000;
381 
382     /* run in a loop */
383     testedThreadRunning = NSK_TRUE;
384     while (!testedThreadShouldFinish) {
385         if (n &lt;= 0)
386             n = 1000;
387         if (i &gt;= n)
388             i = 0;
389         i++;
390     }
391     testedThreadRunning = NSK_FALSE;
392 }
393 
394 /** Wait for native method is running. */
395 JNIEXPORT jboolean JNICALL
396 Java_nsk_jvmti_scenarios_sampling_SP02_sp02t003ThreadRunningNative_checkReady(JNIEnv* jni,
397                                                                             jobject obj) {
398     while (!testedThreadRunning) {
399         nsk_jvmti_sleep(1000);
400     }
401     return testedThreadRunning ? JNI_TRUE : JNI_FALSE;
402 }
403 
404 /** Let native method to finish. */
405 JNIEXPORT void JNICALL
406 Java_nsk_jvmti_scenarios_sampling_SP02_sp02t003ThreadRunningNative_letFinish(JNIEnv* jni,
407                                                                             jobject obj) {
408     testedThreadShouldFinish = NSK_TRUE;
409 }
410 
411 /* ============================================================================= */
412 
413 /** Agent library initialization. */
414 #ifdef STATIC_BUILD
415 JNIEXPORT jint JNICALL Agent_OnLoad_sp02t003(JavaVM *jvm, char *options, void *reserved) {
416     return Agent_Initialize(jvm, options, reserved);
417 }
418 JNIEXPORT jint JNICALL Agent_OnAttach_sp02t003(JavaVM *jvm, char *options, void *reserved) {
419     return Agent_Initialize(jvm, options, reserved);
420 }
421 JNIEXPORT jint JNI_OnLoad_sp02t003(JavaVM *jvm, char *options, void *reserved) {
422     return JNI_VERSION_1_8;
423 }
424 #endif
425 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
426 
427     /** Init framework and parse options. */
428     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
429         return JNI_ERR;
430 
431     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
432 
433     /* create JVMTI environment */
434     if (!NSK_VERIFY((jvmti =
435             nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))
436         return JNI_ERR;
437 
438     /* add specific capabilities for suspending thread */    {
439         jvmtiCapabilities suspendCaps;
440         memset(&amp;suspendCaps, 0, sizeof(suspendCaps));
441         suspendCaps.can_suspend = 1;
442         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;suspendCaps)))
443             return JNI_ERR;
444     }
445 
446     /* register agent proc and arg */
447     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
448         return JNI_ERR;
449 
450     return JNI_OK;
451 }
452 
453 /* ============================================================================= */
454 
455 }
    </pre>
  </body>
</html>
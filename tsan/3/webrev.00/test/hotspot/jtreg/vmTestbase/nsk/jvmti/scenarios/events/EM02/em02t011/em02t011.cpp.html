<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t011/em02t011.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
 27 #include &quot;ExceptionCheckingJniEnv.hpp&quot;
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 #include &quot;JVMTITools.h&quot;
 31 
 32 extern &quot;C&quot; {
 33 
 34 /* ============================================================================= */
 35 
 36 /* scaffold objects */
 37 static jvmtiEnv *jvmti = NULL;
 38 static jlong timeout = 0;
 39 static jrawMonitorID syncLock = NULL;
 40 
 41 /* constant names */
 42 #define STEP_NUMBER 3
 43 #define CLASS_NAME &quot;nsk/jvmti/scenarios/events/EM02/em02t011&quot;
 44 #define METHOD_NAME &quot;javaMethod&quot;
 45 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 46 #define NUMBER_OF_INVOCATIONS 1000
 47 
 48 static int eventCount[JVMTI_EVENT_COUNT];
 49 static int newEventCount[JVMTI_EVENT_COUNT];
 50 
 51 /* ============================================================================= */
 52 
 53 static void
 54 showEventStatistics(int step) {
 55     int i;
 56     const char* str;
 57     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 58 
 59     NSK_DISPLAY0(&quot;\n&quot;);
 60     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 61     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 62     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 63         if (currentCounts[i] &gt; 0) {
 64             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 65             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 66         }
 67     }
 68 }
 69 
 70 /* ========================================================================== */
 71 
 72 int checkEvents(int step) {
 73     int i;
 74     jvmtiEvent curr;
 75     bool result = true;
 76     int *currentCounts;
 77     int isExpected = 0;
 78 
 79     switch (step) {
 80         case 1:
 81             currentCounts = &amp;eventCount[0];
 82             break;
 83 
 84         case 2:
 85         case 3:
 86             currentCounts = &amp;newEventCount[0];
 87             break;
 88 
 89         default:
 90             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
 91             return false;
 92     }
 93 
 94     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 95 
 96         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 97 
 98         switch (step) {
 99             case 1:
100                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
101                                 || (curr == JVMTI_EVENT_BREAKPOINT));
102                 break;
103 
104             case 2:
105                 isExpected = (curr == JVMTI_EVENT_BREAKPOINT);
106                 break;
107 
108             case 3:
109                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
110                 break;
111         }
112 
113         if (isExpected) {
114             if (curr != JVMTI_EVENT_BREAKPOINT) {
115                 if (currentCounts[i] &lt; 1) {
116                         NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
117                                             currentCounts[i],
118                                             TranslateEvent(curr));
119                     result = false;
120                 }
121             } else {
122                 if (currentCounts[i] != NUMBER_OF_INVOCATIONS) {
123                     NSK_COMPLAIN3(&quot;Unexpected number of %s events %d, expected value is %d\n&quot;,
124                                         TranslateEvent(curr),
125                                         currentCounts[i],
126                                         NUMBER_OF_INVOCATIONS);
127                     result = false;
128                 }
129             }
130 
131         } else {
132 
133             if (currentCounts[i] &gt; 0) {
134                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
135                                     TranslateEvent(curr),
136                                     currentCounts[i]);
137                 result = false;
138             }
139         }
140     }
141 
142     return result;
143 }
144 
145 static void
146 changeCount(jvmtiEvent event, int *currentCounts) {
147 
148     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
149         nsk_jvmti_setFailStatus();
150 
151     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
152 
153     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
154         nsk_jvmti_setFailStatus();
155 
156 }
157 
158 /* ============================================================================= */
159 
160 /* callbacks */
161 JNIEXPORT void JNICALL
162 cbVMInit(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread) {
163     changeCount(JVMTI_EVENT_VM_INIT, &amp;eventCount[0]);
164 }
165 
166 JNIEXPORT void JNICALL
167 cbVMDeath(jvmtiEnv* jvmti, JNIEnv* jni_env) {
168     changeCount(JVMTI_EVENT_VM_DEATH, &amp;newEventCount[0]);
169     showEventStatistics(STEP_NUMBER);
170     if (!checkEvents(STEP_NUMBER))
171         nsk_jvmti_setFailStatus();
172 
173     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock)))
174         nsk_jvmti_setFailStatus();
175 
176 }
177 
178 void JNICALL
179 cbException(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
180                 jmethodID method, jlocation location, jobject exception,
181                 jmethodID catch_method, jlocation catch_location) {
182 
183     changeCount(JVMTI_EVENT_EXCEPTION, &amp;eventCount[0]);
184 }
185 
186 void JNICALL
187 cbExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
188                 jmethodID method, jlocation location, jobject exception) {
189 
190     changeCount(JVMTI_EVENT_EXCEPTION_CATCH, &amp;eventCount[0]);
191 }
192 
193 void JNICALL
194 cbSingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
195                 jmethodID method, jlocation location) {
196 
197     changeCount(JVMTI_EVENT_SINGLE_STEP, &amp;eventCount[0]);
198 }
199 
200 void JNICALL
201 cbFramePop(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
202                 jmethodID method, jboolean was_popped_by_exception) {
203     changeCount(JVMTI_EVENT_FRAME_POP, &amp;eventCount[0]);
204 }
205 
206 void JNICALL
207 cbBreakpoint(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
208                 jmethodID method, jlocation location) {
209 
210     changeCount(JVMTI_EVENT_BREAKPOINT, &amp;eventCount[0]);
211 }
212 
213 void JNICALL
214 cbNewBreakpoint(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
215                 jmethodID method, jlocation location) {
216 
217     changeCount(JVMTI_EVENT_BREAKPOINT, &amp;newEventCount[0]);
218 }
219 
220 void JNICALL
221 cbFieldAccess(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
222                 jmethodID method, jlocation location, jclass field_klass,
223                 jobject object, jfieldID field) {
224 
225     changeCount(JVMTI_EVENT_FIELD_ACCESS, &amp;eventCount[0]);
226 }
227 
228 void JNICALL
229 cbFieldModification(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
230                 jmethodID method, jlocation location, jclass field_klass,
231                 jobject object, jfieldID field, char signature_type,
232                 jvalue new_value) {
233 
234     changeCount(JVMTI_EVENT_FIELD_MODIFICATION, &amp;eventCount[0]);
235 }
236 
237 void JNICALL
238 cbMethodEntry(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
239                 jmethodID method) {
240 
241     changeCount(JVMTI_EVENT_METHOD_ENTRY, &amp;eventCount[0]);
242 }
243 
244 void JNICALL
245 cbMethodExit(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
246                 jmethodID method, jboolean was_popped_by_exception,
247                 jvalue return_value) {
248 
249     changeCount(JVMTI_EVENT_METHOD_EXIT, &amp;eventCount[0]);
250 }
251 
252 void JNICALL
253 cbNativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env,jthread thread,
254                 jmethodID method, void* address, void** new_address_ptr) {
255     changeCount(JVMTI_EVENT_NATIVE_METHOD_BIND, &amp;eventCount[0]);
256 }
257 
258 void JNICALL
259 cbMonitorWait(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
260                     jobject object, jlong tout) {
261 
262     changeCount(JVMTI_EVENT_MONITOR_WAIT, &amp;eventCount[0]);
263 }
264 
265 void JNICALL
266 cbMonitorWaited(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
267                     jobject object, jboolean timed_out) {
268 
269     changeCount(JVMTI_EVENT_MONITOR_WAITED, &amp;eventCount[0]);
270 }
271 
272 JNIEXPORT void JNICALL
273 cbMonitorContendedEnter(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread,
274                             jobject object) {
275 
276     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTER, &amp;eventCount[0]);
277 }
278 
279 void JNICALL
280 cbMonitorContendedEntered(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
281                             jobject object) {
282 
283     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, &amp;eventCount[0]);
284 }
285 
286 void JNICALL
287 cbCompiledMethodLoad(jvmtiEnv *jvmti_env, jmethodID method, jint code_size,
288                 const void* code_addr, jint map_length,
289                 const jvmtiAddrLocationMap* map, const void* compile_info) {
290     changeCount(JVMTI_EVENT_COMPILED_METHOD_LOAD, &amp;eventCount[0]);
291 }
292 
293 void JNICALL
294 cbCompiledMethodUnload(jvmtiEnv *jvmti_env, jmethodID method,
295                 const void* code_addr) {
296     changeCount(JVMTI_EVENT_COMPILED_METHOD_UNLOAD, &amp;eventCount[0]);
297 }
298 
299 void JNICALL
300 cbGarbageCollectionStart(jvmtiEnv *jvmti_env) {
301     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_START, &amp;eventCount[0]);
302 }
303 
304 void JNICALL
305 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
306     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
307 }
308 
309 void JNICALL
310 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
311 
312     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
313 }
314 
315 void JNICALL
316 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
317                     jobject object, jclass object_klass, jlong size) {
318 
319     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
320 }
321 
322 /* ============================================================================= */
323 
324 static bool enableEvent(jvmtiEvent event) {
325 
326     if (nsk_jvmti_isOptionalEvent(event)
327             &amp;&amp; (event != JVMTI_EVENT_BREAKPOINT)) {
328         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
329                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
330             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
331                 TranslateEvent(event));
332             return false;
333         }
334     } else {
335         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
336             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
337                 TranslateEvent(event));
338             return false;
339         }
340     }
341 
342     return true;
343 }
344 
345 /**
346  * Enable or disable tested events.
347  */
348 static bool enableEventList() {
349 
350     int i, result;
351 
352     result = enableEvent(JVMTI_EVENT_VM_INIT);
353 
354     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
355 
356     /* enabling optional events */
357     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
358         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
359 
360         if (nsk_jvmti_isOptionalEvent(event))
361             result = result &amp;&amp; enableEvent(event);
362     }
363 
364     if (!result) {
365         nsk_jvmti_setFailStatus();
366         return false;
367     }
368 
369     return true;
370 }
371 
372 /* ============================================================================= */
373 
374 static bool setCallBacks(int step) {
375 
376     int i;
377 
378     jvmtiEventCallbacks eventCallbacks;
379     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
380 
381     switch (step) {
382         case 1:
383             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
384                 eventCount[i] = 0;
385             }
386 
387             eventCallbacks.VMInit                    = cbVMInit;
388             eventCallbacks.Exception                 = cbException;
389             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
390             eventCallbacks.SingleStep                = cbSingleStep;
391             eventCallbacks.FramePop                  = cbFramePop;
392             eventCallbacks.Breakpoint                = cbBreakpoint;
393             eventCallbacks.FieldAccess               = cbFieldAccess;
394             eventCallbacks.FieldModification         = cbFieldModification;
395             eventCallbacks.MethodEntry               = cbMethodEntry;
396             eventCallbacks.MethodExit                = cbMethodExit;
397             eventCallbacks.NativeMethodBind          = cbNativeMethodBind;
398             eventCallbacks.CompiledMethodLoad        = cbCompiledMethodLoad;
399             eventCallbacks.CompiledMethodUnload      = cbCompiledMethodUnload;
400             eventCallbacks.MonitorWait               = cbMonitorWait;
401             eventCallbacks.MonitorWaited             = cbMonitorWaited;
402             eventCallbacks.MonitorContendedEnter     = cbMonitorContendedEnter;
403             eventCallbacks.MonitorContendedEntered   = cbMonitorContendedEntered;
404             eventCallbacks.GarbageCollectionStart    = cbGarbageCollectionStart;
405             eventCallbacks.GarbageCollectionFinish   = cbGarbageCollectionFinish;
406             eventCallbacks.ObjectFree                = cbObjectFree;
407             eventCallbacks.VMObjectAlloc             = cbVMObjectAlloc;
408             break;
409 
410         case 2:
411             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
412                 newEventCount[i] = 0;
413             }
414 
415             eventCallbacks.Breakpoint                = cbNewBreakpoint;
416             break;
417 
418         case 3:
419             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
420                 newEventCount[i] = 0;
421             }
422 
423             eventCallbacks.VMDeath                   = cbVMDeath;
424             break;
425 
426     }
427     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
428         return false;
429 
430     return true;
431 }
432 
433 /* ============================================================================= */
434 
435 /** Agent algorithm. */
436 static void JNICALL
437 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
438 
439     ExceptionCheckingJniEnvPtr ec_jni(agentJNI);
440     int i;
441     jmethodID methodID;
442     jclass cls;
443 
444 
445     if (!nsk_jvmti_waitForSync(timeout))
446         return;
447 
448     cls = ec_jni-&gt;FindClass(CLASS_NAME, TRACE_JNI_CALL);
449     methodID = ec_jni-&gt;GetStaticMethodID(cls, METHOD_NAME, &quot;()I&quot;, TRACE_JNI_CALL);
450 
451     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetBreakpoint(methodID, 0)))
452         return;
453 
454     if (!nsk_jvmti_resumeSync())
455         return;
456 
457     for (i = 1; i &lt;= STEP_NUMBER; i++) {
458 
459         if (!nsk_jvmti_waitForSync(timeout))
460             return;
461 
462         if (i &lt; STEP_NUMBER) {
463             showEventStatistics(i);
464             if (!checkEvents(i))
465                 nsk_jvmti_setFailStatus();
466 
467             if (!setCallBacks(i + 1)) {
468                 return;
469             }
470         }
471 
472         if (!nsk_jvmti_resumeSync())
473             return;
474     }
475 
476 }
477 
478 /* ============================================================================= */
479 
480 /** Agent library initialization. */
481 #ifdef STATIC_BUILD
482 JNIEXPORT jint JNICALL Agent_OnLoad_em02t011(JavaVM *jvm, char *options, void *reserved) {
483     return Agent_Initialize(jvm, options, reserved);
484 }
485 JNIEXPORT jint JNICALL Agent_OnAttach_em02t011(JavaVM *jvm, char *options, void *reserved) {
486     return Agent_Initialize(jvm, options, reserved);
487 }
488 JNIEXPORT jint JNI_OnLoad_em02t011(JavaVM *jvm, char *options, void *reserved) {
489     return JNI_VERSION_1_8;
490 }
491 #endif
492 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
493 
494     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
495         return JNI_ERR;
496 
497     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
498 
499     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
500     if (!NSK_VERIFY(jvmti != NULL))
501         return JNI_ERR;
502 
503     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock))) {
504         nsk_jvmti_setFailStatus();
505         return JNI_ERR;
506     }
507 
508     {
509         jvmtiCapabilities caps;
510         memset(&amp;caps, 0, sizeof(caps));
511 
512         caps.can_generate_breakpoint_events = 1;
513         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
514             return JNI_ERR;
515     }
516 
517     if (!setCallBacks(1)) {
518         return JNI_ERR;
519     }
520 
521     if (!enableEventList()) {
522         return JNI_ERR;
523     }
524 
525     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
526         return JNI_ERR;
527 
528     return JNI_OK;
529 }
530 
531 /* ============================================================================= */
532 
533 
534 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/contention/TC04/tc04t001.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jvmti.scenarios.contention.TC04;
 25 
 26 import java.io.PrintStream;
 27 import java.util.concurrent.*;
 28 
 29 import nsk.share.*;
 30 import nsk.share.jvmti.*;
 31 
 32 public class tc04t001 extends DebugeeClass {
 33 
 34     final static int THREADS_LIMIT = 2;
 35     final static CountDownLatch threadsDoneSignal = new CountDownLatch(THREADS_LIMIT);
 36 
 37     // run test from command line
 38     public static void main(String argv[]) {
 39         argv = nsk.share.jvmti.JVMTITest.commonInit(argv);
 40 
 41         // JCK-compatible exit
 42         System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);
 43     }
 44 
 45     // run test from JCK-compatible environment
 46     public static int run(String argv[], PrintStream out) {
 47         return new tc04t001().runIt(argv, out);
 48     }
 49 
 50     /* =================================================================== */
 51 
 52     // scaffold objects
 53     ArgumentHandler argHandler = null;
 54     Log log = null;
 55     int status = Consts.TEST_PASSED;
 56     long timeout = 0;
 57 
 58     // run debuggee
 59     public int runIt(String argv[], PrintStream out) {
 60         argHandler = new ArgumentHandler(argv);
 61         log = new Log(out, argHandler);
 62         timeout = argHandler.getWaitTime() * 60 * 1000;
 63         log.display(&quot;Timeout = &quot; + timeout + &quot; msc.&quot;);
 64 
 65         tc04t001Thread threads[] = new tc04t001Thread[THREADS_LIMIT];
 66         status = checkStatus(status);
 67         for (int i = 0; i &lt; THREADS_LIMIT; i++) {
 68             threads[i] = new tc04t001Thread(i);
 69             threads[i].start();
 70         }
 71 
 72         try {
 73             if (!threadsDoneSignal.await(timeout, TimeUnit.MILLISECONDS)) {
 74                 throw new RuntimeException(&quot;Threads timeout&quot;);
 75             }
 76         } catch (InterruptedException e) {
 77             throw new Failure(e);
 78         }
 79 
 80         status = checkStatus(status);
 81 
 82         log.display(&quot;Debugee finished, value: &quot; + tc04t001Thread.value);
 83         if (tc04t001Thread.value !=
 84                 THREADS_LIMIT*tc04t001Thread.INCREMENT_LIMIT) {
 85             log.complain(&quot;Wrong value: &quot; + tc04t001Thread.value +
 86                 &quot;, expected: &quot; + THREADS_LIMIT*tc04t001Thread.INCREMENT_LIMIT);
 87             status = Consts.TEST_FAILED;
 88         }
 89         return status;
 90     }
 91 }
 92 
 93 /* =================================================================== */
 94 
 95 class tc04t001Thread extends Thread {
 96 
 97     final static int INCREMENT_LIMIT = 100;
 98     final static int DELAY = 1000;
 99 
100     static volatile int value = 0;
101 
102     static Flicker flicker = new Flicker();
103 
104     private int id;
105     private static volatile int lastEnterEventsCount;
106     private static native   int enterEventsCount();
107 
108     public tc04t001Thread(int i) {
109         super(&quot;Debuggee Thread &quot; + i);
110         id = i;
111     }
112 
113     public synchronized void run() {
114         for (int i = 0; i &lt; INCREMENT_LIMIT; i++) {
115             flicker.waitFor(id);
116             increment(id);
117             try {
118                 wait(1);
119             } catch (InterruptedException e) {}
120         }
121         tc04t001.threadsDoneSignal.countDown();
122     }
123 
124     static synchronized void increment(int i) {
125         flicker.unlock(i);
126         int temp = value;
127         boolean done = false;
128 
129         // Wait in a loop for a MonitorContendedEnter event.
130         // Timeout is: 20ms * DELAY.
131         for (int j = 0; j &lt; DELAY; j++) {
132             try {
133                 sleep(20);
134             } catch (InterruptedException e) {}
135 
136             done = (tc04t001.threadsDoneSignal.getCount() == 1);
137             if (done) {
138                 break; // This thread is the only remaining thread, no more contention
139             }
140             if (enterEventsCount() &gt; lastEnterEventsCount) {
141                 System.out.println(&quot;Thread-&quot; + i + &quot;: increment event: &quot; + enterEventsCount());
142                 break; // Got an expected MonitorContendedEnter event
143             }
144         }
145 
146         if (!done &amp;&amp; enterEventsCount() == lastEnterEventsCount) {
147             String msg = &quot;Timeout in waiting for a MonitorContendedEnter event&quot;;
148             throw new RuntimeException(msg);
149         }
150         value = temp + 1;
151         lastEnterEventsCount = enterEventsCount();
152     }
153 }
154 
155 class Flicker {
156 
157     private int owner = -1;
158 
159     public synchronized void waitFor(int owner) {
160         while (this.owner == owner) {
161             try {
162                 wait();
163             } catch (InterruptedException e) {}
164         }
165     }
166 
167     public synchronized void unlock(int owner) {
168         if (this.owner == owner)
169             throw new IllegalStateException(&quot;the same owner: &quot; + owner);
170 
171         this.owner = owner;
172         notifyAll();
173     }
174 }
    </pre>
  </body>
</html>
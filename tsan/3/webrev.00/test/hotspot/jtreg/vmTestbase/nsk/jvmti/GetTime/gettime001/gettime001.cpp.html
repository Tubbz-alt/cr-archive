<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/GetTime/gettime001/gettime001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdlib.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &quot;jvmti.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* ============================================================================= */
 34 
 35 static jlong timeout = 0;
 36 
 37 #define STATUS_FAIL     97
 38 
 39 #define EVENTS_COUNT    2
 40 
 41 static jvmtiEvent events[EVENTS_COUNT] = {
 42     JVMTI_EVENT_VM_INIT,
 43     JVMTI_EVENT_VM_DEATH
 44 };
 45 
 46 static julong prevTime;
 47 
 48 /* ============================================================================= */
 49 
 50 /**
 51  * Get time and optionally compare it with previous one.
 52  * @returns false if any error occured.
 53  */
 54 static bool checkTime(jvmtiEnv* jvmti, julong* time,
 55                       julong* prevTime, const char where[]) {
 56 
 57     char buf[32], buf2[32], buf3[32];
 58     bool success = true;
 59 
 60     NSK_DISPLAY0(&quot;GetTime() for current JVMTI env\n&quot;);
 61     if (!NSK_JVMTI_VERIFY(
 62             jvmti-&gt;GetTime((jlong *)time))) {
 63         return false;
 64     }
 65     NSK_DISPLAY1(&quot;  ... got time: %s\n&quot;, julong_to_string(*time, buf));
 66 
 67     if (prevTime != NULL) {
 68         julong diff = *time - *prevTime;
 69 
 70         NSK_DISPLAY1(&quot;Compare with previous time: %s\n&quot;,
 71                             julong_to_string(*prevTime, buf));
 72         NSK_DISPLAY1(&quot;  ... difference: %s\n&quot;,
 73                             julong_to_string(diff, buf));
 74 
 75         if (*time &lt; *prevTime) {
 76             NSK_COMPLAIN4(&quot;In %s GetTime() returned value less than previous:\n&quot;
 77                           &quot;#   got value:  %s\n&quot;
 78                           &quot;#   previous:   %s\n&quot;
 79                           &quot;#   difference: %s\n&quot;,
 80                             where,
 81                             julong_to_string(*time, buf),
 82                             julong_to_string(*prevTime, buf2),
 83                             julong_to_string(diff, buf3));
 84             success = false;
 85         }
 86         *prevTime = *time;
 87     }
 88 
 89     return success;
 90 }
 91 /* ============================================================================= */
 92 
 93 /** Agent algorithm. */
 94 static void JNICALL
 95 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
 96     NSK_DISPLAY0(&quot;Wait for debugee to become ready\n&quot;);
 97     if (!nsk_jvmti_waitForSync(timeout))
 98         return;
 99 
100     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #3: Check time in agent thread\n&quot;);
101     {
102         julong time;
103         if (!checkTime(jvmti, &amp;time, &amp;prevTime, &quot;agent thread&quot;)) {
104             nsk_jvmti_setFailStatus();
105         }
106     }
107 
108     NSK_DISPLAY0(&quot;Let debugee to finish\n&quot;);
109     if (!nsk_jvmti_resumeSync())
110         return;
111 }
112 
113 /* ============================================================================= */
114 
115 /**
116  * Callback for VM_INIT event.
117  */
118 JNIEXPORT void JNICALL
119 callbackVMInit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread) {
120 
121     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #2: Check time in VM_INIT callback\n&quot;);
122     {
123         julong time;
124         if (!checkTime(jvmti, &amp;time, &amp;prevTime, &quot;VM_INIT callback&quot;)) {
125             nsk_jvmti_setFailStatus();
126         }
127     }
128 }
129 
130 /**
131  * Callback for VM_DEATH event.
132  */
133 JNIEXPORT void JNICALL
134 callbackVMDeath(jvmtiEnv* jvmti, JNIEnv* jni) {
135     bool success = true;
136 
137     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #4: Check time in VM_DEATH callback\n&quot;);
138     {
139         julong time;
140         success = checkTime(jvmti, &amp;time, &amp;prevTime, &quot;VM_DEATH callback&quot;);
141     }
142 
143     NSK_DISPLAY1(&quot;Disable events: %d events\n&quot;, EVENTS_COUNT);
144     if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {
145         success = false;
146     } else {
147         NSK_DISPLAY0(&quot;  ... disabled\n&quot;);
148     }
149 
150     if (!success) {
151         NSK_DISPLAY1(&quot;Exit with FAIL exit status: %d\n&quot;, STATUS_FAIL);
152         NSK_BEFORE_TRACE(exit(STATUS_FAIL));
153     }
154 }
155 
156 /* ============================================================================= */
157 
158 /** Agent library initialization. */
159 #ifdef STATIC_BUILD
160 JNIEXPORT jint JNICALL Agent_OnLoad_gettime001(JavaVM *jvm, char *options, void *reserved) {
161     return Agent_Initialize(jvm, options, reserved);
162 }
163 JNIEXPORT jint JNICALL Agent_OnAttach_gettime001(JavaVM *jvm, char *options, void *reserved) {
164     return Agent_Initialize(jvm, options, reserved);
165 }
166 JNIEXPORT jint JNI_OnLoad_gettime001(JavaVM *jvm, char *options, void *reserved) {
167     return JNI_VERSION_1_8;
168 }
169 #endif
170 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
171     jvmtiEnv* jvmti = NULL;
172 
173     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
174         return JNI_ERR;
175 
176     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
177 
178     if (!NSK_VERIFY((jvmti =
179             nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))
180         return JNI_ERR;
181 
182     {
183         jvmtiEventCallbacks eventCallbacks;
184 
185         memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
186         eventCallbacks.VMInit = callbackVMInit;
187         eventCallbacks.VMDeath = callbackVMDeath;
188         if (!NSK_JVMTI_VERIFY(
189                 jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks)))) {
190             return JNI_ERR;
191         }
192 
193     }
194 
195     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
196         return JNI_ERR;
197 
198     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #1: Check initial time in Agent_OnLoad()\n&quot;);
199     {
200         if (!checkTime(jvmti, &amp;prevTime, NULL, &quot;Agent_OnLoad()&quot;)) {
201             nsk_jvmti_setFailStatus();
202         }
203     }
204 
205     NSK_DISPLAY1(&quot;Enable events: %d events\n&quot;, EVENTS_COUNT);
206     if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {
207         NSK_DISPLAY0(&quot;  ... enabled\n&quot;);
208     }
209 
210     return JNI_OK;
211 }
212 
213 /* ============================================================================= */
214 
215 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t008/em02t008.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../em02t007/em02t007.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../em02t009/em02t009.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t008/em02t008.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 51     int i;
 52     const char* str;
 53     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 54 
 55     NSK_DISPLAY0(&quot;\n&quot;);
 56     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 57     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 58     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 59         if (currentCounts[i] &gt; 0) {
 60             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 61             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 62         }
 63     }
 64 }
 65 
 66 /* ========================================================================== */
 67 
 68 int checkEvents(int step) {
 69     int i;
 70     jvmtiEvent curr;
<span class="line-modified"> 71     int result = NSK_TRUE;</span>
 72     int *currentCounts;
 73     int isExpected = 0;
 74 
 75     switch (step) {
 76         case 1:
 77             currentCounts = &amp;eventCount[0];
 78             break;
 79 
 80         case 2:
 81         case 3:
 82             currentCounts = &amp;newEventCount[0];
 83             break;
 84 
 85         default:
 86             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified"> 87             return NSK_FALSE;</span>
 88     }
 89 
 90     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 91 
 92         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 93 
 94         switch (step) {
 95             case 1:
 96                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
 97                                 || (curr == JVMTI_EVENT_EXCEPTION)
 98                                 || (curr == JVMTI_EVENT_EXCEPTION_CATCH));
 99                 break;
100 
101             case 2:
102                 isExpected = ((curr == JVMTI_EVENT_EXCEPTION)
103                                 || (curr == JVMTI_EVENT_EXCEPTION_CATCH));
104                 break;
105 
106             case 3:
107                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
108                 break;
109         }
110 
111         if (isExpected) {
112             if (currentCounts[i] &lt; 1) {
113                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
114                                         currentCounts[i],
115                                         TranslateEvent(curr));
<span class="line-modified">116                 result = NSK_FALSE;</span>
117             }
118         } else {
119 
120             if (currentCounts[i] &gt; 0) {
121                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
122                                     TranslateEvent(curr),
123                                     currentCounts[i]);
<span class="line-modified">124                 result = NSK_FALSE;</span>
125             }
126         }
127     }
128 
129     return result;
130 }
131 
132 static void
133 changeCount(jvmtiEvent event, int *currentCounts) {
134 
135     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
136         nsk_jvmti_setFailStatus();
137 
138     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
139 
140     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
141         nsk_jvmti_setFailStatus();
142 
143 }
144 
</pre>
<hr />
<pre>
354 void JNICALL
355 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
356     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
357 }
358 
359 void JNICALL
360 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
361 
362     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
363 }
364 
365 void JNICALL
366 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
367                     jobject object, jclass object_klass, jlong size) {
368 
369     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
370 }
371 
372 /* ============================================================================= */
373 
<span class="line-modified">374 static int enableEvent(jvmtiEvent event) {</span>
375 
376     if (nsk_jvmti_isOptionalEvent(event)
377             &amp;&amp; (event != JVMTI_EVENT_EXCEPTION)
378             &amp;&amp; (event != JVMTI_EVENT_EXCEPTION_CATCH)) {
379         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
380                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
381             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
382                 TranslateEvent(event));
<span class="line-modified">383             return NSK_FALSE;</span>
384         }
385     } else {
386         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
387             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
388                 TranslateEvent(event));
<span class="line-modified">389             return NSK_FALSE;</span>
390         }
391     }
392 
<span class="line-modified">393     return NSK_TRUE;</span>
394 }
395 
396 /**
397  * Enable or disable tested events.
398  */
<span class="line-modified">399 static int enableEventList() {</span>
400 
401     int i, result;
402 
403     result = enableEvent(JVMTI_EVENT_VM_INIT);
404 
405     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
406 
407     /* enabling optional events */
408     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
409         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
410 
411         if (nsk_jvmti_isOptionalEvent(event))
412             result = result &amp;&amp; enableEvent(event);
413     }
414 
<span class="line-modified">415     if (result == NSK_FALSE) {</span>
416         nsk_jvmti_setFailStatus();
<span class="line-modified">417         return NSK_FALSE;</span>
418     }
419 
<span class="line-modified">420     return NSK_TRUE;</span>
421 }
422 
423 /* ============================================================================= */
424 
<span class="line-modified">425 static int</span>
<span class="line-removed">426 setCallBacks(int step) {</span>
427 
428     int i;
429 
430     jvmtiEventCallbacks eventCallbacks;
431     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
432 
433     switch (step) {
434         case 1:
435             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
436                 eventCount[i] = 0;
437             }
438 
439             eventCallbacks.VMInit                    = cbVMInit;
440             eventCallbacks.Exception                 = cbException;
441             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
442             eventCallbacks.SingleStep                = cbSingleStep;
443             eventCallbacks.FramePop                  = cbFramePop;
444             eventCallbacks.Breakpoint                = cbBreakpoint;
445             eventCallbacks.FieldAccess               = cbFieldAccess;
446             eventCallbacks.FieldModification         = cbFieldModification;
</pre>
<hr />
<pre>
461 
462         case 2:
463             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
464                 newEventCount[i] = 0;
465             }
466 
467             eventCallbacks.Exception                 = cbNewException;
468             eventCallbacks.ExceptionCatch            = cbNewExceptionCatch;
469             break;
470 
471         case 3:
472             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
473                 newEventCount[i] = 0;
474             }
475 
476             eventCallbacks.VMDeath                   = cbVMDeath;
477             break;
478 
479     }
480     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">481         return NSK_FALSE;</span>
482 
<span class="line-modified">483     return NSK_TRUE;</span>
484 }
485 
486 /* ============================================================================= */
487 
488 /** Agent algorithm. */
489 static void JNICALL
490 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
491 
492     int i;
493 
494     for (i = 1; i &lt;= STEP_NUMBER; i++) {
495 
496         if (!nsk_jvmti_waitForSync(timeout))
497             return;
498 
499         if (i &lt; STEP_NUMBER) {
500             showEventStatistics(i);
501             if (!checkEvents(i))
502                 nsk_jvmti_setFailStatus();
503 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 51     int i;
 52     const char* str;
 53     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 54 
 55     NSK_DISPLAY0(&quot;\n&quot;);
 56     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 57     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 58     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 59         if (currentCounts[i] &gt; 0) {
 60             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 61             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 62         }
 63     }
 64 }
 65 
 66 /* ========================================================================== */
 67 
 68 int checkEvents(int step) {
 69     int i;
 70     jvmtiEvent curr;
<span class="line-modified"> 71     bool result = true;</span>
 72     int *currentCounts;
 73     int isExpected = 0;
 74 
 75     switch (step) {
 76         case 1:
 77             currentCounts = &amp;eventCount[0];
 78             break;
 79 
 80         case 2:
 81         case 3:
 82             currentCounts = &amp;newEventCount[0];
 83             break;
 84 
 85         default:
 86             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified"> 87             return false;</span>
 88     }
 89 
 90     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 91 
 92         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 93 
 94         switch (step) {
 95             case 1:
 96                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
 97                                 || (curr == JVMTI_EVENT_EXCEPTION)
 98                                 || (curr == JVMTI_EVENT_EXCEPTION_CATCH));
 99                 break;
100 
101             case 2:
102                 isExpected = ((curr == JVMTI_EVENT_EXCEPTION)
103                                 || (curr == JVMTI_EVENT_EXCEPTION_CATCH));
104                 break;
105 
106             case 3:
107                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
108                 break;
109         }
110 
111         if (isExpected) {
112             if (currentCounts[i] &lt; 1) {
113                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
114                                         currentCounts[i],
115                                         TranslateEvent(curr));
<span class="line-modified">116                 result = false;</span>
117             }
118         } else {
119 
120             if (currentCounts[i] &gt; 0) {
121                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
122                                     TranslateEvent(curr),
123                                     currentCounts[i]);
<span class="line-modified">124                 result = false;</span>
125             }
126         }
127     }
128 
129     return result;
130 }
131 
132 static void
133 changeCount(jvmtiEvent event, int *currentCounts) {
134 
135     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
136         nsk_jvmti_setFailStatus();
137 
138     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
139 
140     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
141         nsk_jvmti_setFailStatus();
142 
143 }
144 
</pre>
<hr />
<pre>
354 void JNICALL
355 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
356     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
357 }
358 
359 void JNICALL
360 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
361 
362     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
363 }
364 
365 void JNICALL
366 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
367                     jobject object, jclass object_klass, jlong size) {
368 
369     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
370 }
371 
372 /* ============================================================================= */
373 
<span class="line-modified">374 static bool enableEvent(jvmtiEvent event) {</span>
375 
376     if (nsk_jvmti_isOptionalEvent(event)
377             &amp;&amp; (event != JVMTI_EVENT_EXCEPTION)
378             &amp;&amp; (event != JVMTI_EVENT_EXCEPTION_CATCH)) {
379         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
380                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
381             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
382                 TranslateEvent(event));
<span class="line-modified">383             return false;</span>
384         }
385     } else {
386         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
387             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
388                 TranslateEvent(event));
<span class="line-modified">389             return false;</span>
390         }
391     }
392 
<span class="line-modified">393     return true;</span>
394 }
395 
396 /**
397  * Enable or disable tested events.
398  */
<span class="line-modified">399 static bool enableEventList() {</span>
400 
401     int i, result;
402 
403     result = enableEvent(JVMTI_EVENT_VM_INIT);
404 
405     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
406 
407     /* enabling optional events */
408     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
409         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
410 
411         if (nsk_jvmti_isOptionalEvent(event))
412             result = result &amp;&amp; enableEvent(event);
413     }
414 
<span class="line-modified">415     if (!result) {</span>
416         nsk_jvmti_setFailStatus();
<span class="line-modified">417         return false;</span>
418     }
419 
<span class="line-modified">420     return true;</span>
421 }
422 
423 /* ============================================================================= */
424 
<span class="line-modified">425 static bool setCallBacks(int step) {</span>

426 
427     int i;
428 
429     jvmtiEventCallbacks eventCallbacks;
430     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
431 
432     switch (step) {
433         case 1:
434             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
435                 eventCount[i] = 0;
436             }
437 
438             eventCallbacks.VMInit                    = cbVMInit;
439             eventCallbacks.Exception                 = cbException;
440             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
441             eventCallbacks.SingleStep                = cbSingleStep;
442             eventCallbacks.FramePop                  = cbFramePop;
443             eventCallbacks.Breakpoint                = cbBreakpoint;
444             eventCallbacks.FieldAccess               = cbFieldAccess;
445             eventCallbacks.FieldModification         = cbFieldModification;
</pre>
<hr />
<pre>
460 
461         case 2:
462             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
463                 newEventCount[i] = 0;
464             }
465 
466             eventCallbacks.Exception                 = cbNewException;
467             eventCallbacks.ExceptionCatch            = cbNewExceptionCatch;
468             break;
469 
470         case 3:
471             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
472                 newEventCount[i] = 0;
473             }
474 
475             eventCallbacks.VMDeath                   = cbVMDeath;
476             break;
477 
478     }
479     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">480         return false;</span>
481 
<span class="line-modified">482     return true;</span>
483 }
484 
485 /* ============================================================================= */
486 
487 /** Agent algorithm. */
488 static void JNICALL
489 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
490 
491     int i;
492 
493     for (i = 1; i &lt;= STEP_NUMBER; i++) {
494 
495         if (!nsk_jvmti_waitForSync(timeout))
496             return;
497 
498         if (i &lt; STEP_NUMBER) {
499             showEventStatistics(i);
500             if (!checkEvents(i))
501                 nsk_jvmti_setFailStatus();
502 
</pre>
</td>
</tr>
</table>
<center><a href="../em02t007/em02t007.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../em02t009/em02t009.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/jdi/ClassType/invokeMethod/invokemethod015.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package nsk.jdi.ClassType.invokeMethod;
 24 
 25 import nsk.share.*;
 26 import nsk.share.jpda.*;
 27 import nsk.share.jdi.*;
 28 
 29 import com.sun.jdi.*;
 30 import com.sun.jdi.connect.*;
 31 import com.sun.jdi.request.*;
 32 import com.sun.jdi.event.*;
 33 
 34 import java.io.*;
 35 import java.util.*;
 36 
 37 /**
 38  */
 39 public class invokemethod015 {
 40 
 41     //----------------------------------------------------- immutable common fields
 42 
 43     private int waitTime;
 44     private static int exitStatus = Consts.TEST_PASSED;
 45 
 46     private ArgumentHandler     argHandler;
 47     private Log                 log;
 48     private Debugee             debuggee;
 49     private VirtualMachine      vm;
 50     private ReferenceType       debuggeeClass;
 51 
 52     private EventRequestManager eventRManager;
 53     private EventSet            eventSet;
 54     private EventIterator       eventIterator;
 55 
 56     //------------------------------------------------------ mutable common fields
 57 
 58     private final static String prefix = &quot;nsk.jdi.ClassType.invokeMethod&quot;;
 59     private final static String className = &quot;.invokemethod015&quot;;
 60     private final static String debuggerName = prefix + className;
 61     private final static String debuggeeName = debuggerName + &quot;a&quot;;
 62     static final int lineForBreak = 54;
 63 
 64     //------------------------------------------------------ immutable common methods
 65 
 66     public static void main (String argv[]) {
 67         System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);
 68     }
 69 
 70     //------------------------------------------------------ test specific fields
 71 
 72     private static final String fieldName = &quot;f1&quot;;
 73     private static final String methodName = &quot;values&quot;;
 74 //    private static final String methodSignature = &quot;()[Lnsk/jdi/ClassType/invokeMethod/invokemethod015aEnum&quot;;
 75     private static final String[] expectedEnumFieldsNames = { &quot;e1&quot;, &quot;e2&quot; };
 76 
 77     //------------------------------------------------------ mutable common methods
 78 
 79     public static int run (String argv[], PrintStream out) {
 80 
 81         int exitStatus = new invokemethod015().runThis(argv, out);
 82         return exitStatus;
 83     }
 84 
 85     private int runThis(String argv[], PrintStream out) {
 86 
 87         argHandler = new ArgumentHandler(argv);
 88         log = new Log(out, argHandler);
 89         waitTime = argHandler.getWaitTime() * 60000;
 90 
 91         try {
 92 
 93             Binder binder = new Binder(argHandler, log);
 94             debuggee = binder.bindToDebugee(debuggeeName);
 95             debuggee.redirectStderr(log, &quot;&quot;);
 96             eventRManager = debuggee.getEventRequestManager();
 97 
 98             vm = debuggee.VM();
 99             eventRManager = vm.eventRequestManager();
100 
101             debuggeeClass = waitForDebuggeeClassPrepared();
102 
103             execTest();
104 
105             debuggee.resume();
106             getEventSet();
107             if (eventIterator.nextEvent() instanceof VMDeathEvent) {
108                 display(&quot;Waiting for the debuggee&#39;s finish...&quot;);
109                 debuggee.waitFor();
110 
111                 display(&quot;Getting the debuggee&#39;s exit status.&quot;);
112                 int status = debuggee.getStatus();
113                 if (status != (Consts.TEST_PASSED + Consts.JCK_STATUS_BASE)) {
114                     complain(&quot;Debuggee returned UNEXPECTED exit status: &quot; + status);
115                     exitStatus = Consts.TEST_FAILED;
116                 }
117             } else {
118                 throw new TestBug(&quot;Last event is not the VMDeathEvent&quot;);
119             }
120 
121         } catch (VMDisconnectedException e) {
122             exitStatus = Consts.TEST_FAILED;
123             complain(&quot;The test cancelled due to VMDisconnectedException.&quot;);
124             e.printStackTrace(out);
125             display(&quot;Trying: vm.process().destroy();&quot;);
126             if (vm != null) {
127                 Process vmProcess = vm.process();
128                 if (vmProcess != null) {
129                     vmProcess.destroy();
130                 }
131             }
132 
133         } catch (Exception e) {
134             exitStatus = Consts.TEST_FAILED;
135             complain(&quot;Unexpected Exception: &quot; + e.getMessage());
136             e.printStackTrace(out);
137             complain(&quot;The test has not finished normally. Forcing: vm.exit().&quot;);
138             if (vm != null) {
139                 vm.exit(Consts.TEST_PASSED + Consts.JCK_STATUS_BASE);
140             }
141             debuggee.resume();
142             getEventSet();
143         }
144 
145         return exitStatus;
146     }
147 
148     //--------------------------------------------------------- mutable common methods
149 
150     private void execTest() {
151         BreakpointRequest bpRequest = setBreakpoint( null,
152                                                      debuggeeClass,
153                                                      &quot;methodForCommunication&quot;,
154                                                      lineForBreak,
155                                                      &quot;breakForCommunication&quot;);
156         bpRequest.enable();
157 
158         display(&quot;Wait for initial brakepoint event...&quot;);
159         BreakpointEvent bpEvent = (BreakpointEvent)waitForEvent(bpRequest);
160         ThreadReference thread = bpEvent.thread();
161 
162         display(&quot;TESTING BEGINS&quot;);
163         try {
164             ClassType checkedClass = (ClassType)debuggeeClass.fieldByName(fieldName).type();
165             String className = checkedClass.name();
166 
167             List&lt;Method&gt; l = checkedClass.methods();
168             Method checkedMethod = null;
169             if (l.isEmpty()) {
170                 complain(&quot;\t ReferenceType.methods() returned empty list for type: &quot; + className);
171                 exitStatus = Consts.TEST_FAILED;
172             } else {
173                 Iterator&lt;Method&gt; it = l.iterator();
174                 while (it.hasNext()) {
175                     Method m = it.next();
176                     if (methodName.equals(m.name()))
177                         checkedMethod = m;
178                 }
179                 if (checkedMethod != null) {
180                     ArrayReference values = (ArrayReference)checkedClass.invokeMethod(thread, checkedMethod , Collections.&lt;Value&gt;emptyList(), 0);
181                     if (values.length() == 2) {
182                         List constants = values.getValues();
183                         Iterator it1 = constants.iterator();
184                         while (it1.hasNext()) {
185                             ObjectReference checkedField = (ObjectReference)it1.next();
186                             if (checkedField.type().equals(checkedClass)) {
187                                 display(&quot;Invoked method &quot; + methodName + &quot; returned expected object &quot; + checkedField.toString());
188                             } else {
189                                 display(&quot;Invoked method &quot; + methodName + &quot; returned unexpected object &quot; + checkedField.toString());
190                                 exitStatus = Consts.TEST_FAILED;
191                             }
192                         }
193                     } else {
194                         complain(&quot;Invoked method &quot; + methodName + &quot; returned list of unexpected size: &quot; + values.length());
195                         exitStatus = Consts.TEST_FAILED;
196                     }
197                 } else {
198                     complain(&quot;Cannot find in &quot; + className + &quot; the checked method &quot; + methodName);
199                     exitStatus = Consts.TEST_FAILED;
200                 }
201             }
202 
203         } catch (Exception e) {
204             complain(&quot;Unexpected exception while checking of &quot; + className + &quot;: &quot; + e);
205             e.printStackTrace(System.out);
206             exitStatus = Consts.TEST_FAILED;
207         }
208         display(&quot;TESTING ENDS&quot;);
209     }
210 
211     //--------------------------------------------------------- test specific methods
212 
213     //--------------------------------------------------------- immutable common methods
214 
215     void display(String msg) {
216         log.display(&quot;debugger &gt; &quot; + msg);
217     }
218 
219     void complain(String msg) {
220         log.complain(&quot;debugger FAILURE &gt; &quot; + msg);
221     }
222 
223    /**
224     * Sets up a breakpoint at given line number within a given method in a given class
225     * for a given thread.
226     *
227     * Returns a BreakpointRequest object in case of success, otherwise throws Failure.
228     */
229     private BreakpointRequest setBreakpoint ( ThreadReference thread,
230                                               ReferenceType testedClass,
231                                               String methodName,
232                                               int bpLine,
233                                               String property) {
234 
235         display(&quot;Setting a breakpoint in :&quot;);
236         display(&quot;  thread: &quot; + thread + &quot;; class: &quot; + testedClass +
237                 &quot;; method: &quot; + methodName + &quot;; line: &quot; + bpLine + &quot;; property: &quot; + property);
238 
239         List allLineLocations = null;
240         Location lineLocation = null;
241         BreakpointRequest breakpRequest = null;
242 
243         try {
244             Method  method  = (Method) testedClass.methodsByName(methodName).get(0);
245 
246             allLineLocations = method.allLineLocations();
247 
248             display(&quot;Getting location for breakpoint...&quot;);
249             Iterator locIterator = allLineLocations.iterator();
250             while (locIterator.hasNext()) {
251                 Location curLocation = (Location)locIterator.next();
252                 int curNumber = curLocation.lineNumber();
253                 if (curLocation.lineNumber() == bpLine) {
254                     lineLocation = curLocation;
255                     break;
256                 }
257             }
258             if (lineLocation == null) {
259                 throw new TestBug(&quot;Incorrect line number of methods&#39; location&quot;);
260             }
261 
262             try {
263                 breakpRequest = eventRManager.createBreakpointRequest(lineLocation);
264                 if (thread != null) {
265                     breakpRequest.addThreadFilter(thread);
266                 }
267                 breakpRequest.putProperty(&quot;number&quot;, property);
268             } catch ( Exception e1 ) {
269                 complain(&quot;setBreakpoint(): unexpected Exception while creating BreakpointRequest: &quot; + e1);
270                 breakpRequest = null;
271             }
272         } catch ( Exception e2 ) {
273             complain(&quot;setBreakpoint(): unexpected Exception while getting locations: &quot; + e2);
274             breakpRequest = null;
275         }
276 
277         if (breakpRequest == null) {
278             throw new Failure(&quot;setBreakpoint(): A breakpoint has not been set up.&quot;);
279         }
280 
281         display(&quot;setBreakpoint(): A breakpoint has been set up.&quot;);
282         return breakpRequest;
283     }
284 
285     private Event waitForEvent (EventRequest eventRequest) {
286         vm.resume();
287         Event resultEvent = null;
288         try {
289             eventSet = null;
290             eventIterator = null;
291             eventSet = vm.eventQueue().remove(waitTime);
292             if (eventSet == null) {
293                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
294             }
295             eventIterator = eventSet.eventIterator();
296             while (eventIterator.hasNext()) {
297                 Event curEvent = eventIterator.nextEvent();
298                 if (curEvent instanceof VMDisconnectEvent) {
299                     throw new Failure(&quot;Unexpected VMDisconnectEvent received.&quot;);
300                 } else {
301                     EventRequest evRequest = curEvent.request();
302                     if (evRequest != null &amp;&amp; evRequest.equals(eventRequest)) {
303                         display(&quot;Requested event received: &quot; + curEvent.toString() +
304                             &quot;; request property: &quot; + (String) curEvent.request().getProperty(&quot;number&quot;));
305                         resultEvent = curEvent;
306                         break;
307                     } else {
308                         throw new Failure(&quot;Unexpected event received: &quot; + curEvent.toString());
309                     }
310                 }
311             }
312         } catch (Exception e) {
313             throw new Failure(&quot;Unexpected exception while waiting for an event: &quot; + e);
314         }
315         return resultEvent;
316     }
317 
318     private Event waitForEvent () {
319         vm.resume();
320         Event resultEvent = null;
321         try {
322             eventSet = null;
323             eventIterator = null;
324             eventSet = vm.eventQueue().remove(waitTime);
325             if (eventSet == null) {
326                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
327             }
328             eventIterator = eventSet.eventIterator();
329             while (eventIterator.hasNext()) {
330                 resultEvent = eventIterator.nextEvent();
331                 if (resultEvent instanceof VMDisconnectEvent) {
332                     throw new Failure(&quot;Unexpected VMDisconnectEvent received.&quot;);
333                 }
334             }
335         } catch (Exception e) {
336             throw new Failure(&quot;Unexpected exception while waiting for an event: &quot; + e);
337         }
338         return resultEvent;
339     }
340 
341     private void getEventSet() {
342         try {
343             eventSet = vm.eventQueue().remove(waitTime);
344             if (eventSet == null) {
345                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
346             }
347             eventIterator = eventSet.eventIterator();
348         } catch (Exception e) {
349             throw new Failure(&quot;getEventSet(): Unexpected exception while waiting for an event: &quot; + e);
350         }
351     }
352 
353 
354     private ThreadReference threadByName(String name) throws Failure{
355         List all = vm.allThreads();
356         ListIterator li = all.listIterator();
357 
358         while (li.hasNext()) {
359             ThreadReference thread = (ThreadReference) li.next();
360             if (thread.name().equals(name))
361                 return thread;
362         }
363         throw new Failure(&quot;Thread with searching for name is not found: &quot; + name);
364     }
365 
366     private ReferenceType waitForDebuggeeClassPrepared () {
367         display(&quot;Creating request for ClassPrepareEvent for debuggee.&quot;);
368         ClassPrepareRequest cpRequest = eventRManager.createClassPrepareRequest();
369         cpRequest.addClassFilter(debuggeeName);
370         cpRequest.addCountFilter(1);
371         cpRequest.enable();
372 
373         ClassPrepareEvent event = (ClassPrepareEvent) waitForEvent(cpRequest);
374         cpRequest.disable();
375 
376         if (!event.referenceType().name().equals(debuggeeName)) {
377            throw new Failure(&quot;Unexpected class name for ClassPrepareEvent : &quot; + debuggeeClass.name());
378         }
379         return event.referenceType();
380     }
381 }
    </pre>
  </body>
</html>
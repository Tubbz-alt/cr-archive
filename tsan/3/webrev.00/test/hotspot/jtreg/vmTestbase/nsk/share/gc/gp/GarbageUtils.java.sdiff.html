<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/share/gc/gp/GarbageUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../README.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../lock/jni/BooleanArrayCriticalLocker.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/share/gc/gp/GarbageUtils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.share.gc.gp;
 25 
 26 import java.io.IOException;
 27 import java.io.PrintWriter;
 28 import java.io.StringWriter;

 29 import java.util.*;
 30 import nsk.share.gc.gp.array.*;
 31 import nsk.share.gc.gp.string.*;
 32 import nsk.share.gc.gp.list.*;
 33 import nsk.share.gc.gp.tree.*;
 34 import nsk.share.gc.gp.misc.*;
 35 import nsk.share.gc.gp.classload.*;
 36 import nsk.share.gc.Memory;
 37 import nsk.share.TestBug;
 38 import nsk.share.test.*;
 39 
 40 /**
 41  * Utility methods for garbage producers.
 42  */
 43 public final class GarbageUtils {
 44         private static final int ALLOCATION_LIMIT = 50000000; //50 Mb
 45         private static GarbageProducers garbageProducers;
 46         private static List&lt;GarbageProducer&gt; primitiveArrayProducers;
 47         private static List&lt;GarbageProducer&gt; arrayProducers;
 48         private static final GarbageProducer  byteArrayProducer = new ByteArrayProducer();
 49         public static enum OOM_TYPE {
 50             ANY (),
 51             HEAP(&quot;Java heap space&quot;),
 52             METASPACE(&quot;Metaspace&quot;, &quot;Compressed class space&quot;);
 53 
 54             private final String[] expectedStrings;
 55             OOM_TYPE(String... expectedStrings) {
 56                 this.expectedStrings = expectedStrings;
 57             }
 58 
 59             /**
<span class="line-modified"> 60                          * Returns true if the given error message matches</span>
<span class="line-modified"> 61                          * one of expected strings.</span>
<span class="line-modified"> 62                          */</span>
<span class="line-modified"> 63                         public boolean accept(String errorMessage) {</span>
 64                 if (expectedStrings == null || expectedStrings.length == 0 || errorMessage == null) {
 65                     return true;
 66                 }
 67                 for (String s: expectedStrings) {
 68                     if (errorMessage.indexOf(s) != -1) {
 69                         return true;
 70                     }
 71                 }
 72                 return false;
 73             }
 74         };
 75 
<span class="line-modified"> 76         // Force loading of OOM_TYPE and calling of enum contrusctors when loading GarbageUtils class.</span>
 77         public static final Object[] thisIsGarbageArray_theOnlyPurposeForCreatingItAndDeclaringItPublicIsToInitializeIntancesOfOOMEnumberation = new Object[] { OOM_TYPE.ANY, OOM_TYPE.HEAP, OOM_TYPE.METASPACE };
 78 
 79         // Force early loading of classes that might otherwise unexpectedly fail
 80         // class loading during testing due to high memory pressure.
 81         public static final StringWriter preloadStringWriter = new StringWriter(1);
 82         public static final PrintWriter preloadPrintWriter = new PrintWriter(preloadStringWriter);

 83 
 84         private GarbageUtils() {
 85         }
 86 
 87         /**
 88          * Eat memory using execution controller that waits for 2 minutes.
 89          * @return number of OOME occured
 90          */
 91         public static int eatMemory() {
 92                 return eatMemory(2 * 60 * 1000);
 93         }
 94 
 95         /**
 96          * Eat memory using execution controller that waits for timeout.
 97          * @return number of OOME occured
 98          */
 99         public static int eatMemory(final long timeout) {
100                 return eatMemory(new ExecutionController() {
101                         final long initialTime = System.currentTimeMillis();
102 
</pre>
<hr />
<pre>
176          * Eat memory using given garbage producer.
177          *
178          * Note that this method can throw Failure if any exception
179          * is thrown while eating memory. To avoid OOM while allocating
180          * exception we preallocate it before the lunch starts. It means
181          * that exception stack trace does not correspond to the place
182          * where exception is thrown, but points at start of the method.
183          *
184          * @param stresser stresser to use
185          * @param gp garbage producer
186          * @param initialFactor determines which portion of initial memory initial chunk will be
187          * @param minMemoryChunk determines when to stop
188          * @param factor factor to divide the array size by. A value of 0 means that method returns after first  OOME
189          * @param type of OutOfMemory Exception: Java heap space or Metadata space
190          * @return number of OOME occured
191          */
192         public static int eatMemory(ExecutionController stresser, GarbageProducer gp, long initialFactor, long minMemoryChunk, long factor) {
193             return eatMemory(stresser, gp, initialFactor, minMemoryChunk, factor, OOM_TYPE.ANY);
194         }
195 






























196         /**
197          * Eat memory using given garbage producer.
198          *
199          * Note that this method can throw Failure if any exception
200          * is thrown while eating memory. To avoid OOM while allocating
201          * exception we preallocate it before the lunch starts. It means
202          * that exception stack trace does not correspond to the place
203          * where exception is thrown, but points at start of the method.
204          *
205          * @param stresser stresser to use
206          * @param gp garbage producer
207          * @param initialFactor determines which portion of initial memory initial chunk will be
208          * @param minMemoryChunk determines when to stop
209          * @param factor factor to divide the array size by. A value of 0 means that method returns after first  OOME
210          * @param type of OutOfMemory Exception: Java heap space or Metadata space
211          * @return number of OOME occured
212          */
<span class="line-modified">213         public static int eatMemory(ExecutionController stresser, GarbageProducer gp, long initialFactor, long minMemoryChunk, long factor, OOM_TYPE type) {</span>
<span class="line-modified">214                 int numberOfOOMEs = 0;</span>

215                 try {
<span class="line-removed">216                         StringWriter sw = new StringWriter(10000);</span>
<span class="line-removed">217                         PrintWriter pw = new PrintWriter(sw);</span>
218                         byte[] someMemory = new byte[200000]; //200 Kb
219                         try {
220                                 Runtime runtime = Runtime.getRuntime();
221                                 long maxMemory = runtime.maxMemory();
222                                 long maxMemoryChunk = maxMemory / initialFactor;
223                                 long chunk = maxMemoryChunk;
224                                 chunk = chunk &gt; ALLOCATION_LIMIT ? ALLOCATION_LIMIT : chunk;
225                                 int allocations = 0;
226                                 List&lt;Object&gt; storage = new ArrayList&lt;Object&gt;();
227 
228                                 while (chunk &gt; minMemoryChunk &amp;&amp; stresser.continueExecution()) {
229                                         try {
230                                                 storage.add(gp.create(chunk));
231                                                 if (Thread.currentThread().isInterrupted()) {
232                                                         return numberOfOOMEs;
233                                                 }
234                                                 // if we are able to eat chunk*factor let
235                                                 // try to increase size of chunk
236                                                 if (chunk * factor &lt; maxMemoryChunk
237                                                         &amp;&amp; factor != 0 &amp;&amp; allocations++ == factor + 1) {
238                                                     chunk = chunk * factor;
239                                                     allocations = 0;
240                                                 }
241                                         } catch (OutOfMemoryError e) {
242                                             someMemory = null;
243                                             if (type != OOM_TYPE.ANY) {
<span class="line-modified">244                                                 e.printStackTrace(pw);</span>
<span class="line-removed">245                                                 pw.close();</span>
<span class="line-removed">246                                                 if (type.accept(sw.toString())) {</span>
247                                                     numberOfOOMEs++;
248                                                 } else {
249                                                     // Trying to catch situation when Java generates OOM different type that test trying to catch
<span class="line-modified">250                                                     throw new TestBug(&quot;Test throw OOM of unexpected type.&quot; + sw.toString());</span>
251                                                 }
252                                             } else {
253                                                numberOfOOMEs++;
254                                             }
255                                             allocations = 0;
256                                             if (factor == 0) {
257                                                 return numberOfOOMEs;
258                                             } else {
259                                                 chunk = chunk / factor;
260                                             }
261                                         }
262                                 }
263                         } catch (OutOfMemoryError e) {
264                             someMemory = null;
265                             if (type != OOM_TYPE.ANY) {
<span class="line-modified">266                                 e.printStackTrace(pw);</span>
<span class="line-removed">267                                 pw.close();</span>
<span class="line-removed">268                                 if (type.accept(sw.toString())) {</span>
269                                     numberOfOOMEs++;
270                                 } else {
271                                     // Trying to catch situation when Java generates OOM different type that test trying to catch
<span class="line-modified">272                                     throw new TestBug(&quot;Test throw OOM of unexpected type.&quot; + sw.toString());</span>
273                                 }
274                             } else {
275                                 numberOfOOMEs++;
276                             }
277                          // all memory is eaten now even before we start, just return
278                         }
279                 } catch (OutOfMemoryError e) {
280                         numberOfOOMEs++;
281                 }
282                 return numberOfOOMEs;
283         }
284 
285         /**
286          * Get all primitive array producers.
287          */
288         public static List&lt;GarbageProducer&gt; getPrimitiveArrayProducers() {
289                 return getGarbageProducers().getPrimitiveArrayProducers();
290         }
291 
292         /**
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.share.gc.gp;
 25 
 26 import java.io.IOException;
 27 import java.io.PrintWriter;
 28 import java.io.StringWriter;
<span class="line-added"> 29 import java.lang.invoke.*;</span>
 30 import java.util.*;
 31 import nsk.share.gc.gp.array.*;
 32 import nsk.share.gc.gp.string.*;
 33 import nsk.share.gc.gp.list.*;
 34 import nsk.share.gc.gp.tree.*;
 35 import nsk.share.gc.gp.misc.*;
 36 import nsk.share.gc.gp.classload.*;
 37 import nsk.share.gc.Memory;
 38 import nsk.share.TestBug;
 39 import nsk.share.test.*;
 40 
 41 /**
 42  * Utility methods for garbage producers.
 43  */
 44 public final class GarbageUtils {
 45         private static final int ALLOCATION_LIMIT = 50000000; //50 Mb
 46         private static GarbageProducers garbageProducers;
 47         private static List&lt;GarbageProducer&gt; primitiveArrayProducers;
 48         private static List&lt;GarbageProducer&gt; arrayProducers;
 49         private static final GarbageProducer  byteArrayProducer = new ByteArrayProducer();
 50         public static enum OOM_TYPE {
 51             ANY (),
 52             HEAP(&quot;Java heap space&quot;),
 53             METASPACE(&quot;Metaspace&quot;, &quot;Compressed class space&quot;);
 54 
 55             private final String[] expectedStrings;
 56             OOM_TYPE(String... expectedStrings) {
 57                 this.expectedStrings = expectedStrings;
 58             }
 59 
 60             /**
<span class="line-modified"> 61              * Returns true if the given error message matches</span>
<span class="line-modified"> 62              * one of expected strings.</span>
<span class="line-modified"> 63              */</span>
<span class="line-modified"> 64             public boolean accept(String errorMessage) {</span>
 65                 if (expectedStrings == null || expectedStrings.length == 0 || errorMessage == null) {
 66                     return true;
 67                 }
 68                 for (String s: expectedStrings) {
 69                     if (errorMessage.indexOf(s) != -1) {
 70                         return true;
 71                     }
 72                 }
 73                 return false;
 74             }
 75         };
 76 
<span class="line-modified"> 77         // Force loading of OOM_TYPE and calling of enum constructors when loading GarbageUtils class.</span>
 78         public static final Object[] thisIsGarbageArray_theOnlyPurposeForCreatingItAndDeclaringItPublicIsToInitializeIntancesOfOOMEnumberation = new Object[] { OOM_TYPE.ANY, OOM_TYPE.HEAP, OOM_TYPE.METASPACE };
 79 
 80         // Force early loading of classes that might otherwise unexpectedly fail
 81         // class loading during testing due to high memory pressure.
 82         public static final StringWriter preloadStringWriter = new StringWriter(1);
 83         public static final PrintWriter preloadPrintWriter = new PrintWriter(preloadStringWriter);
<span class="line-added"> 84         public static final Throwable preloadThrowable = new Throwable(&quot;preload&quot;);</span>
 85 
 86         private GarbageUtils() {
 87         }
 88 
 89         /**
 90          * Eat memory using execution controller that waits for 2 minutes.
 91          * @return number of OOME occured
 92          */
 93         public static int eatMemory() {
 94                 return eatMemory(2 * 60 * 1000);
 95         }
 96 
 97         /**
 98          * Eat memory using execution controller that waits for timeout.
 99          * @return number of OOME occured
100          */
101         public static int eatMemory(final long timeout) {
102                 return eatMemory(new ExecutionController() {
103                         final long initialTime = System.currentTimeMillis();
104 
</pre>
<hr />
<pre>
178          * Eat memory using given garbage producer.
179          *
180          * Note that this method can throw Failure if any exception
181          * is thrown while eating memory. To avoid OOM while allocating
182          * exception we preallocate it before the lunch starts. It means
183          * that exception stack trace does not correspond to the place
184          * where exception is thrown, but points at start of the method.
185          *
186          * @param stresser stresser to use
187          * @param gp garbage producer
188          * @param initialFactor determines which portion of initial memory initial chunk will be
189          * @param minMemoryChunk determines when to stop
190          * @param factor factor to divide the array size by. A value of 0 means that method returns after first  OOME
191          * @param type of OutOfMemory Exception: Java heap space or Metadata space
192          * @return number of OOME occured
193          */
194         public static int eatMemory(ExecutionController stresser, GarbageProducer gp, long initialFactor, long minMemoryChunk, long factor) {
195             return eatMemory(stresser, gp, initialFactor, minMemoryChunk, factor, OOM_TYPE.ANY);
196         }
197 
<span class="line-added">198          static int numberOfOOMEs = 0;</span>
<span class="line-added">199 </span>
<span class="line-added">200          /**</span>
<span class="line-added">201           * Minimal wrapper of the main implementation. Catches any OOM</span>
<span class="line-added">202           * that might be thrown when rematerializing Objects when deoptimizing.</span>
<span class="line-added">203           *</span>
<span class="line-added">204           * It is Important that the impl is not inlined.</span>
<span class="line-added">205           */</span>
<span class="line-added">206 </span>
<span class="line-added">207          public static int eatMemory(ExecutionController stresser, GarbageProducer gp, long initialFactor, long minMemoryChunk, long factor, OOM_TYPE type) {</span>
<span class="line-added">208             try {</span>
<span class="line-added">209                // Using a methodhandle invoke of eatMemoryImpl to prevent inlining of it</span>
<span class="line-added">210                MethodHandles.Lookup lookup = MethodHandles.lookup();</span>
<span class="line-added">211                MethodType mt = MethodType.methodType(</span>
<span class="line-added">212                      int.class,</span>
<span class="line-added">213                      ExecutionController.class,</span>
<span class="line-added">214                      GarbageProducer.class,</span>
<span class="line-added">215                      long.class,</span>
<span class="line-added">216                      long.class,</span>
<span class="line-added">217                      long.class,</span>
<span class="line-added">218                      OOM_TYPE.class);</span>
<span class="line-added">219                MethodHandle eat = lookup.findStatic(GarbageUtils.class, &quot;eatMemoryImpl&quot;, mt);</span>
<span class="line-added">220                return (int) eat.invoke(stresser, gp, initialFactor, minMemoryChunk, factor, type);</span>
<span class="line-added">221             } catch (OutOfMemoryError e) {</span>
<span class="line-added">222                return numberOfOOMEs++;</span>
<span class="line-added">223             } catch (Throwable t) {</span>
<span class="line-added">224                throw new RuntimeException(t);</span>
<span class="line-added">225             }</span>
<span class="line-added">226          }</span>
<span class="line-added">227 </span>
228         /**
229          * Eat memory using given garbage producer.
230          *
231          * Note that this method can throw Failure if any exception
232          * is thrown while eating memory. To avoid OOM while allocating
233          * exception we preallocate it before the lunch starts. It means
234          * that exception stack trace does not correspond to the place
235          * where exception is thrown, but points at start of the method.
236          *
237          * @param stresser stresser to use
238          * @param gp garbage producer
239          * @param initialFactor determines which portion of initial memory initial chunk will be
240          * @param minMemoryChunk determines when to stop
241          * @param factor factor to divide the array size by. A value of 0 means that method returns after first  OOME
242          * @param type of OutOfMemory Exception: Java heap space or Metadata space
243          * @return number of OOME occured
244          */
<span class="line-modified">245 </span>
<span class="line-modified">246          public static int eatMemoryImpl(ExecutionController stresser, GarbageProducer gp, long initialFactor, long minMemoryChunk, long factor, OOM_TYPE type) {</span>
<span class="line-added">247                 numberOfOOMEs = 0;</span>
248                 try {


249                         byte[] someMemory = new byte[200000]; //200 Kb
250                         try {
251                                 Runtime runtime = Runtime.getRuntime();
252                                 long maxMemory = runtime.maxMemory();
253                                 long maxMemoryChunk = maxMemory / initialFactor;
254                                 long chunk = maxMemoryChunk;
255                                 chunk = chunk &gt; ALLOCATION_LIMIT ? ALLOCATION_LIMIT : chunk;
256                                 int allocations = 0;
257                                 List&lt;Object&gt; storage = new ArrayList&lt;Object&gt;();
258 
259                                 while (chunk &gt; minMemoryChunk &amp;&amp; stresser.continueExecution()) {
260                                         try {
261                                                 storage.add(gp.create(chunk));
262                                                 if (Thread.currentThread().isInterrupted()) {
263                                                         return numberOfOOMEs;
264                                                 }
265                                                 // if we are able to eat chunk*factor let
266                                                 // try to increase size of chunk
267                                                 if (chunk * factor &lt; maxMemoryChunk
268                                                         &amp;&amp; factor != 0 &amp;&amp; allocations++ == factor + 1) {
269                                                     chunk = chunk * factor;
270                                                     allocations = 0;
271                                                 }
272                                         } catch (OutOfMemoryError e) {
273                                             someMemory = null;
274                                             if (type != OOM_TYPE.ANY) {
<span class="line-modified">275                                                 if (type.accept(e.toString())) {</span>


276                                                     numberOfOOMEs++;
277                                                 } else {
278                                                     // Trying to catch situation when Java generates OOM different type that test trying to catch
<span class="line-modified">279                                                     throw new TestBug(&quot;Test throw OOM of unexpected type.&quot; + e.toString());</span>
280                                                 }
281                                             } else {
282                                                numberOfOOMEs++;
283                                             }
284                                             allocations = 0;
285                                             if (factor == 0) {
286                                                 return numberOfOOMEs;
287                                             } else {
288                                                 chunk = chunk / factor;
289                                             }
290                                         }
291                                 }
292                         } catch (OutOfMemoryError e) {
293                             someMemory = null;
294                             if (type != OOM_TYPE.ANY) {
<span class="line-modified">295                                 if (type.accept(e.toString())) {</span>


296                                     numberOfOOMEs++;
297                                 } else {
298                                     // Trying to catch situation when Java generates OOM different type that test trying to catch
<span class="line-modified">299                                     throw new TestBug(&quot;Test throw OOM of unexpected type.&quot; + e.toString());</span>
300                                 }
301                             } else {
302                                 numberOfOOMEs++;
303                             }
304                          // all memory is eaten now even before we start, just return
305                         }
306                 } catch (OutOfMemoryError e) {
307                         numberOfOOMEs++;
308                 }
309                 return numberOfOOMEs;
310         }
311 
312         /**
313          * Get all primitive array producers.
314          */
315         public static List&lt;GarbageProducer&gt; getPrimitiveArrayProducers() {
316                 return getGarbageProducers().getPrimitiveArrayProducers();
317         }
318 
319         /**
</pre>
</td>
</tr>
</table>
<center><a href="../../README.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../lock/jni/BooleanArrayCriticalLocker.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
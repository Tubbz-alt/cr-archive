<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t001/em02t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
<a name="2" id="anc2"></a>
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* ============================================================================= */
 34 
 35 /* scaffold objects */
 36 static JNIEnv* jni = NULL;
 37 static jvmtiEnv *jvmti = NULL;
 38 static jlong timeout = 0;
 39 static jrawMonitorID syncLock = NULL;
 40 
 41 /* constant names */
 42 #define DEBUGEE_CLASS_NAME      &quot;nsk/jvmti/scenarios/events/EM02/em02t001&quot;
 43 #define START_FIELD_NAME        &quot;startingMonitor&quot;
 44 #define END_FIELD_NAME          &quot;endingMonitor&quot;
 45 #define MAIN_THREAD_NAME        &quot;main&quot;
 46 #define THREAD_FIELD_NAME       &quot;debuggeeThread&quot;
 47 #define OBJECT_FIELD_SIG        &quot;Ljava/lang/Object;&quot;
 48 #define THREAD_FIELD_SIG        &quot;Ljava/lang/Thread;&quot;
 49 
 50 static jthread mainThread = NULL;
 51 static jthread debuggeeThread = NULL;
 52 static jobject startObject = NULL;
 53 static jobject endObject = NULL;
 54 
 55 #define STEP_AMOUNT 3
 56 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 57 static int eventCount[JVMTI_EVENT_COUNT];
 58 static int newEventCount[JVMTI_EVENT_COUNT];
 59 
 60 /* ============================================================================= */
 61 
 62 static jthread
 63 findThread(const char *threadName) {
 64     jvmtiThreadInfo info;
 65     jthread *threads = NULL;
 66     jint threads_count = 0;
 67     jthread returnValue = NULL;
 68     int i;
 69 
 70     /* get all live threads */
 71     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetAllThreads(&amp;threads_count, &amp;threads)))
 72         return NULL;
 73 
 74     if (!NSK_VERIFY(threads != NULL))
 75         return NULL;
 76 
 77     /* find tested thread */
 78     for (i = 0; i &lt; threads_count; i++) {
 79         if (!NSK_VERIFY(threads[i] != NULL))
 80             break;
 81 
 82         /* get thread information */
 83         if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetThreadInfo(threads[i], &amp;info)))
 84             break;
 85 
 86         /* find by name */
 87         if (info.name != NULL &amp;&amp; (strcmp(info.name, threadName) == 0)) {
 88             returnValue = threads[i];
 89         }
 90     }
 91 
 92     /* deallocate threads list */
 93     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)threads)))
 94         return NULL;
 95 
 96     return returnValue;
 97 }
 98 
 99 /* ============================================================================= */
100 
101 static jobject
102 getStaticObjField(const char* className, const char* objFieldName,
103                     const char* signature) {
104 
<a name="3" id="anc3"></a>
105     jfieldID fieldID;
106     jclass klass = NULL;
107 
<a name="4" id="anc4"></a><span class="line-modified">108     klass = jni-&gt;FindClass(className);</span>
<span class="line-modified">109     if (!NSK_JNI_VERIFY(jni, klass != NULL))</span>
<span class="line-modified">110         return NULL;</span>
<span class="line-removed">111 </span>
<span class="line-removed">112     fieldID = jni-&gt;GetStaticFieldID(klass, objFieldName, signature);</span>
<span class="line-removed">113     if (!NSK_JNI_VERIFY(jni, fieldID != NULL))</span>
<span class="line-removed">114         return NULL;</span>
<span class="line-removed">115 </span>
<span class="line-removed">116     return jni-&gt;GetStaticObjectField(klass, fieldID);</span>
117 }
118 
119 /* ============================================================================= */
120 
<a name="5" id="anc5"></a><span class="line-modified">121 static int prepare() {</span>
122 
<a name="6" id="anc6"></a>
123     mainThread = findThread(MAIN_THREAD_NAME);
124     if (!NSK_VERIFY(mainThread != NULL)) {
125         NSK_COMPLAIN1(&quot;&lt;%s&gt; thread not found\n&quot;, MAIN_THREAD_NAME);
<a name="7" id="anc7"></a><span class="line-modified">126         return NSK_FALSE;</span>
127     }
128 
129     /* make thread accessable for a long time */
<a name="8" id="anc8"></a><span class="line-modified">130     mainThread = jni-&gt;NewGlobalRef(mainThread);</span>
<span class="line-removed">131     if (!NSK_JNI_VERIFY(jni, mainThread != NULL))</span>
<span class="line-removed">132         return NSK_FALSE;</span>
<span class="line-removed">133 </span>
134     startObject = getStaticObjField(DEBUGEE_CLASS_NAME, START_FIELD_NAME, OBJECT_FIELD_SIG);
135     if (!NSK_VERIFY(startObject != NULL))
<a name="9" id="anc9"></a><span class="line-modified">136         return NSK_FALSE;</span>
137 
138     /*make object accessable for a long time*/
<a name="10" id="anc10"></a><span class="line-modified">139     startObject = jni-&gt;NewGlobalRef(startObject);</span>
<span class="line-removed">140     if (!NSK_JNI_VERIFY(jni, startObject != NULL))</span>
<span class="line-removed">141         return NSK_FALSE;</span>
<span class="line-removed">142 </span>
143 
144     endObject = getStaticObjField(DEBUGEE_CLASS_NAME, END_FIELD_NAME, OBJECT_FIELD_SIG);
145     if (!NSK_VERIFY(endObject != NULL))
<a name="11" id="anc11"></a><span class="line-modified">146         return NSK_FALSE;</span>
147 
148     /*make object accessable for a long time*/
<a name="12" id="anc12"></a><span class="line-modified">149     endObject = jni-&gt;NewGlobalRef(endObject);</span>
<span class="line-removed">150     if (!NSK_JNI_VERIFY(jni, endObject != NULL))</span>
<span class="line-removed">151         return NSK_FALSE;</span>
<span class="line-removed">152 </span>
153 
154     debuggeeThread = (jthread) getStaticObjField(DEBUGEE_CLASS_NAME,
155                                                  THREAD_FIELD_NAME,
156                                                  THREAD_FIELD_SIG);
157     if (!NSK_VERIFY(debuggeeThread != NULL))
<a name="13" id="anc13"></a><span class="line-modified">158         return NSK_FALSE;</span>
159 
160     /* make thread accessable for a long time */
<a name="14" id="anc14"></a><span class="line-modified">161     debuggeeThread = jni-&gt;NewGlobalRef(debuggeeThread);</span>
<span class="line-modified">162     if (!NSK_JNI_VERIFY(jni, debuggeeThread != NULL))</span>
<span class="line-removed">163         return NSK_FALSE;</span>
<span class="line-removed">164 </span>
<span class="line-removed">165     return NSK_TRUE;</span>
166 }
167 
168 /* ============================================================================= */
169 
<a name="15" id="anc15"></a><span class="line-modified">170 static int</span>
<span class="line-removed">171 clean() {</span>
172 
<a name="16" id="anc16"></a>
173     /* disable MonitorContendedEnter event */
174     if (!NSK_JVMTI_VERIFY(
175             jvmti-&gt;SetEventNotificationMode(
176                 JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)))
177         nsk_jvmti_setFailStatus();
178 
179     /* dispose global references */
<a name="17" id="anc17"></a><span class="line-modified">180     jni-&gt;DeleteGlobalRef(startObject);</span>
<span class="line-modified">181     jni-&gt;DeleteGlobalRef(endObject);</span>
<span class="line-modified">182     jni-&gt;DeleteGlobalRef(debuggeeThread);</span>
<span class="line-modified">183     jni-&gt;DeleteGlobalRef(mainThread);</span>
184 
185     startObject = NULL;
186     endObject = NULL;
187     debuggeeThread = NULL;
188     mainThread = NULL;
189 
<a name="18" id="anc18"></a><span class="line-modified">190     return NSK_TRUE;</span>
191 }
192 
193 /* ========================================================================== */
194 
195 static void
196 showEventStatistics(int step /*int *currentCounts*/) {
197     int i;
198     const char* str;
199     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
200 
201     NSK_DISPLAY0(&quot;\n&quot;);
202     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
203     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
204     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
205         if (currentCounts[i] &gt; 0) {
206             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
207             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
208         }
209     }
210 }
211 
212 /* ========================================================================== */
213 
214 /* get thread information */
215 static void
216 showThreadInfo(jthread thread) {
217     jvmtiThreadInfo info;
218     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetThreadInfo(thread, &amp;info)))
219         return;
220 
221     NSK_DISPLAY2(&quot;\tthread (%s): %p\n&quot;, info.name, thread);
222 }
223 
224 /* ============================================================================= */
225 
226 static void
227 changeCount(jvmtiEvent event, int *currentCounts) {
228 
229     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
230         nsk_jvmti_setFailStatus();
231 
232     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
233 
234     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
235         nsk_jvmti_setFailStatus();
236 
237 }
238 
239 /* ============================================================================= */
240 
<a name="19" id="anc19"></a><span class="line-modified">241 int checkEvents(int step) {</span>
242     int i;
243     jvmtiEvent curr;
<a name="20" id="anc20"></a><span class="line-modified">244     int result = NSK_TRUE;</span>
245     int *currentCounts;
246     int isExpected = 0;
247 
248     switch (step) {
249         case 1:
250             currentCounts = &amp;eventCount[0];
251             break;
252 
253         case 2:
254         case 3:
255             currentCounts = &amp;newEventCount[0];
256             break;
257 
258         default:
259             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<a name="21" id="anc21"></a><span class="line-modified">260             return NSK_FALSE;</span>
261     }
262 
263     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
264 
265         curr = (jvmtiEvent)(i + JVMTI_MIN_EVENT_TYPE_VAL);
266 
267         switch (step) {
268             case 1:
269                 isExpected = ((curr == JVMTI_EVENT_MONITOR_CONTENDED_ENTER)
270                                 || (curr == JVMTI_EVENT_MONITOR_CONTENDED_ENTERED)
271                                 || (curr == JVMTI_EVENT_MONITOR_WAIT)
272                                 || (curr == JVMTI_EVENT_MONITOR_WAITED)
273                                 || (curr == JVMTI_EVENT_VM_INIT));
274                 break;
275 
276             case 2:
277                 isExpected = ((curr == JVMTI_EVENT_MONITOR_CONTENDED_ENTER)
278                                 || (curr == JVMTI_EVENT_MONITOR_CONTENDED_ENTERED)
279                                 || (curr == JVMTI_EVENT_MONITOR_WAIT)
280                                 || (curr == JVMTI_EVENT_MONITOR_WAITED));
281                 break;
282 
283             case 3:
284                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
285                 break;
286         }
287 
288         if (isExpected) {
289             if (currentCounts[i] != 1) {
290                     nsk_jvmti_setFailStatus();
291                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value is 1\n&quot;,
292                                         currentCounts[i],
293                                         TranslateEvent(curr));
<a name="22" id="anc22"></a><span class="line-modified">294                 result = NSK_FALSE;</span>
295             }
296         } else {
297             if (currentCounts[i] &gt; 0) {
298                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
299                                     TranslateEvent(curr),
300                                     currentCounts[i]);
<a name="23" id="anc23"></a><span class="line-modified">301                 result = NSK_FALSE;</span>
302             }
303         }
304     }
305 
306     return result;
307 }
308 
309 /* ============================================================================= */
310 
311 /* callbacks */
312 JNIEXPORT void JNICALL
313 cbVMInit(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread) {
314     changeCount(JVMTI_EVENT_VM_INIT, &amp;eventCount[0]);
315 }
316 
317 JNIEXPORT void JNICALL
318 cbVMDeath(jvmtiEnv* jvmti, JNIEnv* jni_env) {
319     changeCount(JVMTI_EVENT_VM_DEATH, &amp;newEventCount[0]);
320     showEventStatistics(STEP_AMOUNT);
321     if (!checkEvents(STEP_AMOUNT)) {
322         nsk_jvmti_setFailStatus();
323     }
324 
325     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock)))
326         nsk_jvmti_setFailStatus();
327 
328 }
329 
330 void JNICALL
331 cbException(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
332                 jmethodID method, jlocation location, jobject exception,
333                 jmethodID catch_method, jlocation catch_location) {
334     changeCount(JVMTI_EVENT_EXCEPTION, &amp;eventCount[0]);
335 }
336 
337 void JNICALL
338 cbExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
339                 jmethodID method, jlocation location, jobject exception) {
340     changeCount(JVMTI_EVENT_EXCEPTION_CATCH, &amp;eventCount[0]);
341 }
342 
343 void JNICALL
344 cbSingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
345                 jmethodID method, jlocation location) {
346     changeCount(JVMTI_EVENT_SINGLE_STEP, &amp;eventCount[0]);
347 }
348 
349 void JNICALL
350 cbFramePop(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
351                 jmethodID method, jboolean was_popped_by_exception) {
352     changeCount(JVMTI_EVENT_FRAME_POP, &amp;eventCount[0]);
353 }
354 
355 void JNICALL
356 cbBreakpoint(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
357                 jmethodID method, jlocation location) {
358     changeCount(JVMTI_EVENT_BREAKPOINT, &amp;eventCount[0]);
359 }
360 
361 void JNICALL
362 cbFieldAccess(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
363                 jmethodID method, jlocation location, jclass field_klass,
364                 jobject object, jfieldID field) {
365     changeCount(JVMTI_EVENT_FIELD_ACCESS, &amp;eventCount[0]);
366 }
367 
368 void JNICALL
369 cbFieldModification(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
370                 jmethodID method, jlocation location, jclass field_klass,
371                 jobject object, jfieldID field, char signature_type,
372                 jvalue new_value) {
373     changeCount(JVMTI_EVENT_FIELD_MODIFICATION, &amp;eventCount[0]);
374 }
375 
376 void JNICALL
377 cbMethodEntry(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
378                 jmethodID method) {
379     changeCount(JVMTI_EVENT_METHOD_ENTRY, &amp;eventCount[0]);
380 }
381 
382 void JNICALL
383 cbMethodExit(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
384                 jmethodID method, jboolean was_popped_by_exception,
385                 jvalue return_value) {
386     changeCount(JVMTI_EVENT_METHOD_EXIT, &amp;eventCount[0]);
387 }
388 
389 void JNICALL
390 cbNativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env,jthread thread,
391                 jmethodID method, void* address, void** new_address_ptr) {
392     changeCount(JVMTI_EVENT_NATIVE_METHOD_BIND, &amp;eventCount[0]);
393 }
394 
395 void JNICALL
396 cbCompiledMethodLoad(jvmtiEnv *jvmti_env, jmethodID method, jint code_size,
397                 const void* code_addr, jint map_length,
398                 const jvmtiAddrLocationMap* map, const void* compile_info) {
399     changeCount(JVMTI_EVENT_COMPILED_METHOD_LOAD, &amp;eventCount[0]);
400 }
401 
402 void JNICALL
403 cbCompiledMethodUnload(jvmtiEnv *jvmti_env, jmethodID method,
404                 const void* code_addr) {
405     changeCount(JVMTI_EVENT_COMPILED_METHOD_UNLOAD, &amp;eventCount[0]);
406 }
407 
408 void
409 handlerMC1(jvmtiEvent event, jvmtiEnv* jvmti, JNIEnv* jni_env,
410                             jthread thread, jobject object,
411                             jthread expectedThread, jobject expectedObject) {
<a name="24" id="anc24"></a>
412 
413     if (expectedThread == NULL || expectedObject == NULL)
414         return;
415 
416     /* check if event is for tested thread and for tested object */
<a name="25" id="anc25"></a><span class="line-modified">417     if (jni_env-&gt;IsSameObject(expectedThread, thread) &amp;&amp;</span>
<span class="line-modified">418             jni_env-&gt;IsSameObject(expectedObject, object)) {</span>
419 
420         NSK_DISPLAY1(&quot;---&gt;%-40s is received\n&quot;, TranslateEvent(event));
421 
422         showThreadInfo(thread);
<a name="26" id="anc26"></a><span class="line-modified">423         if (jni_env-&gt;IsSameObject(expectedObject, endObject))</span>
424             NSK_DISPLAY0(&quot;\tobject: &#39;endingMonitor&#39;\n&quot;);
425         else
426             NSK_DISPLAY0(&quot;\tobject: &#39;startingMonitor&#39;\n&quot;);
427 
428         changeCount(event, &amp;eventCount[0]);
429     }
430 }
431 
432 void JNICALL
433 cbMonitorWait(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
434                     jobject object, jlong tout) {
435 
436     handlerMC1(JVMTI_EVENT_MONITOR_WAIT,
437                                 jvmti, jni_env,
438                                 thread, object,
439                                 mainThread, startObject);
440 }
441 
442 void JNICALL
443 cbMonitorWaited(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
444                     jobject object, jboolean timed_out) {
445 
446     handlerMC1(JVMTI_EVENT_MONITOR_WAITED,
447                                 jvmti, jni_env,
448                                 thread, object,
449                                 mainThread, startObject);
450 }
451 
452 JNIEXPORT void JNICALL
453 cbMonitorContendedEnter(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread,
454                             jobject object) {
455 
456     handlerMC1(JVMTI_EVENT_MONITOR_CONTENDED_ENTER,
457                                 jvmti, jni_env,
458                                 thread, object,
459                                 debuggeeThread, endObject);
460 }
461 
462 void JNICALL
463 cbMonitorContendedEntered(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
464                             jobject object) {
465 
466     handlerMC1(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED,
467                                 jvmti_env, jni_env,
468                                 thread, object,
469                                 debuggeeThread, endObject);
470 }
471 
472 void JNICALL
473 cbGarbageCollectionStart(jvmtiEnv *jvmti_env) {
474     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_START, &amp;eventCount[0]);
475 }
476 
477 void JNICALL
478 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
479     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
480 }
481 
482 void JNICALL
483 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
484     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
485 }
486 
487 void JNICALL
488 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
489                     jobject object, jclass object_klass, jlong size) {
490 
491     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
492 }
493 
494 void
495 handlerMC2(jvmtiEvent event, jvmtiEnv* jvmti, JNIEnv* jni_env,
496                             jthread thread, jobject object,
497                             jthread expectedThread, jobject expectedObject) {
<a name="27" id="anc27"></a>
498 
499     if (expectedThread == NULL || expectedObject == NULL)
500         return;
501 
502     /* check if event is for tested thread and for tested object */
<a name="28" id="anc28"></a><span class="line-modified">503     if (jni_env-&gt;IsSameObject(expectedThread, thread) &amp;&amp;</span>
<span class="line-modified">504             jni_env-&gt;IsSameObject(expectedObject, object)) {</span>
505 
506         NSK_DISPLAY1(&quot;---&gt;%-40s is received (new callbacks)\n&quot;, TranslateEvent(event));
507 
508         showThreadInfo(thread);
<a name="29" id="anc29"></a><span class="line-modified">509         if (jni_env-&gt;IsSameObject(expectedObject, endObject))</span>
510             NSK_DISPLAY0(&quot;\tobject: &#39;endingMonitor&#39;\n&quot;);
511         else
512             NSK_DISPLAY0(&quot;\tobject: &#39;startingMonitor&#39;\n&quot;);
513 
514 
515         changeCount(event, &amp;newEventCount[0]);
516     }
517 }
518 
519 void JNICALL
520 cbNewMonitorWait(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
521                     jobject object, jlong tout) {
522 
523     handlerMC2(JVMTI_EVENT_MONITOR_WAIT,
524                                 jvmti_env, jni_env,
525                                 thread, object,
526                                 mainThread, startObject);
527 }
528 
529 void JNICALL
530 cbNewMonitorWaited(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
531                     jobject object, jboolean timed_out) {
532 
533     handlerMC2(JVMTI_EVENT_MONITOR_WAITED,
534                                 jvmti, jni_env,
535                                 thread, object,
536                                 mainThread, startObject);
537 }
538 
539 void JNICALL
540 cbNewMonitorContendedEntered(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
541                             jobject object) {
542 
543     handlerMC2(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED,
544                                 jvmti, jni_env,
545                                 thread, object,
546                                 debuggeeThread, endObject);
547 }
548 
549 JNIEXPORT void JNICALL
550 cbNewMonitorContendedEnter(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread,
551                             jobject object) {
552 
553     handlerMC2(JVMTI_EVENT_MONITOR_CONTENDED_ENTER,
554                                 jvmti, jni_env,
555                                 thread, object,
556                                 debuggeeThread, endObject);
557 }
558 
559 /* ============================================================================= */
560 
<a name="30" id="anc30"></a><span class="line-modified">561 static int enableEvent(jvmtiEvent event) {</span>
562 
563     if (nsk_jvmti_isOptionalEvent(event)
564             &amp;&amp; (event != JVMTI_EVENT_MONITOR_CONTENDED_ENTER)
565             &amp;&amp; (event != JVMTI_EVENT_MONITOR_CONTENDED_ENTERED)
566             &amp;&amp; (event != JVMTI_EVENT_MONITOR_WAIT)
567             &amp;&amp; (event != JVMTI_EVENT_MONITOR_WAITED)) {
568         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
569                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
570             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
571                 TranslateEvent(event));
<a name="31" id="anc31"></a><span class="line-modified">572             return NSK_FALSE;</span>
573         }
574     } else {
575         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
576             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
577                 TranslateEvent(event));
<a name="32" id="anc32"></a><span class="line-modified">578             return NSK_FALSE;</span>
579         }
580     }
581 
<a name="33" id="anc33"></a><span class="line-modified">582     return NSK_TRUE;</span>
583 }
584 
<a name="34" id="anc34"></a><span class="line-modified">585 static int enableEventList() {</span>
586     int i;
<a name="35" id="anc35"></a><span class="line-modified">587     int result = NSK_TRUE;</span>
588 
589     NSK_DISPLAY0(&quot;Enable events\n&quot;);
590 
591     result = enableEvent(JVMTI_EVENT_VM_INIT);
592 
593     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
594 
595     /* enabling optional events */
596     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
597         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
598 
599         if (nsk_jvmti_isOptionalEvent(event))
600             result = result &amp;&amp; enableEvent(event);
601     }
602 
<a name="36" id="anc36"></a><span class="line-modified">603     if (result == NSK_FALSE) {</span>
604         nsk_jvmti_setFailStatus();
<a name="37" id="anc37"></a><span class="line-modified">605         return NSK_FALSE;</span>
606     }
607 
<a name="38" id="anc38"></a><span class="line-modified">608     return NSK_TRUE;</span>
609 }
610 
611 /* ============================================================================= */
612 
<a name="39" id="anc39"></a><span class="line-modified">613 static int</span>
<span class="line-removed">614 setCallBacks(int step) {</span>
615 
616     int i;
617 
618     jvmtiEventCallbacks eventCallbacks;
619     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
620 
621     NSK_DISPLAY0(&quot;\n&quot;);
622     NSK_DISPLAY1(&quot;===============step %d===============\n&quot;, step);
623     NSK_DISPLAY0(&quot;\n&quot;);
624     switch (step) {
625         case 1:
626             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
627                 eventCount[i] = 0;
628             }
629 
630             eventCallbacks.VMInit                    = cbVMInit;
631             eventCallbacks.Exception                 = cbException;
632             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
633             eventCallbacks.SingleStep                = cbSingleStep;
634             eventCallbacks.FramePop                  = cbFramePop;
635             eventCallbacks.Breakpoint                = cbBreakpoint;
636             eventCallbacks.FieldAccess               = cbFieldAccess;
637             eventCallbacks.FieldModification         = cbFieldModification;
638             eventCallbacks.MethodEntry               = cbMethodEntry;
639             eventCallbacks.MethodExit                = cbMethodExit;
640             eventCallbacks.NativeMethodBind          = cbNativeMethodBind;
641             eventCallbacks.CompiledMethodLoad        = cbCompiledMethodLoad;
642             eventCallbacks.CompiledMethodUnload      = cbCompiledMethodUnload;
643             eventCallbacks.MonitorWait               = cbMonitorWait;
644             eventCallbacks.MonitorWaited             = cbMonitorWaited;
645             eventCallbacks.MonitorContendedEnter     = cbMonitorContendedEnter;
646             eventCallbacks.MonitorContendedEntered   = cbMonitorContendedEntered;
647             eventCallbacks.GarbageCollectionStart    = cbGarbageCollectionStart;
648             eventCallbacks.GarbageCollectionFinish   = cbGarbageCollectionFinish;
649             eventCallbacks.ObjectFree                = cbObjectFree;
650             eventCallbacks.VMObjectAlloc             = cbVMObjectAlloc;
651             break;
652 
653         case 2:
654             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
655                 newEventCount[i] = 0;
656             }
657 
658             eventCallbacks.MonitorWait               = cbNewMonitorWait;
659             eventCallbacks.MonitorWaited             = cbNewMonitorWaited;
660             eventCallbacks.MonitorContendedEnter     = cbNewMonitorContendedEnter;
661             eventCallbacks.MonitorContendedEntered   = cbNewMonitorContendedEntered;
662             break;
663 
664         case 3:
665             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
666                 newEventCount[i] = 0;
667             }
668 
669             eventCallbacks.VMDeath                   = cbVMDeath;
670             break;
671 
672     }
673     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<a name="40" id="anc40"></a><span class="line-modified">674         return NSK_FALSE;</span>
675 
<a name="41" id="anc41"></a><span class="line-modified">676     return NSK_TRUE;</span>
677 }
678 
679 /* ============================================================================= */
680 
681 /** Agent algorithm. */
682 static void JNICALL
683 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
684 
685     int i;
686     jni = agentJNI;
687 
688     for (i = 1; i &lt;= STEP_AMOUNT; i++) {
689         if (i &gt; 1) {
690             NSK_DISPLAY0(&quot;Check received events\n&quot;);
691 
692             showEventStatistics(i-1);
693             if (!checkEvents(i-1)) {
694                 nsk_jvmti_setFailStatus();
695             }
696 
697             if (!setCallBacks(i)) {
698                 return;
699             }
700 
701             if (!nsk_jvmti_resumeSync())
702                 return;
703         }
704 
705         NSK_DISPLAY0(&quot;Wait for debuggee to become ready\n&quot;);
706         if (!nsk_jvmti_waitForSync(timeout))
707             return;
708 
709         prepare();
710 
711         if (!nsk_jvmti_resumeSync())
712             return;
713 
714 
715         NSK_DISPLAY0(&quot;Waiting events\n&quot;); /* thread started */
716         if (!nsk_jvmti_waitForSync(timeout))
717             return;
718 
719         if (!nsk_jvmti_resumeSync())
720             return;
721 
722         if (!nsk_jvmti_waitForSync(timeout))
723             return;
724 
725     }
726 
727     if (!clean()) {
728         nsk_jvmti_setFailStatus();
729         return;
730     }
731 
732     NSK_DISPLAY0(&quot;Let debuggee to finish\n&quot;);
733     if (!nsk_jvmti_resumeSync())
734         return;
735 
736 }
737 
738 /* ============================================================================= */
739 
740 /** Agent library initialization. */
741 #ifdef STATIC_BUILD
742 JNIEXPORT jint JNICALL Agent_OnLoad_em02t001(JavaVM *jvm, char *options, void *reserved) {
743     return Agent_Initialize(jvm, options, reserved);
744 }
745 JNIEXPORT jint JNICALL Agent_OnAttach_em02t001(JavaVM *jvm, char *options, void *reserved) {
746     return Agent_Initialize(jvm, options, reserved);
747 }
748 JNIEXPORT jint JNI_OnLoad_em02t001(JavaVM *jvm, char *options, void *reserved) {
749     return JNI_VERSION_1_8;
750 }
751 #endif
752 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
753 
754     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
755         return JNI_ERR;
756 
757     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
758 
759     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
760     if (!NSK_VERIFY(jvmti != NULL))
761         return JNI_ERR;
762 
763     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock))) {
764         nsk_jvmti_setFailStatus();
765         return JNI_ERR;
766     }
767 
768     {
769         jvmtiCapabilities caps;
770         memset(&amp;caps, 0, sizeof(caps));
771 
772         caps.can_generate_monitor_events = 1;
773         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
774             return JNI_ERR;
775     }
776 
777     if (!setCallBacks(1)) {
778         return JNI_ERR;
779     }
780 
781     nsk_jvmti_showPossessedCapabilities(jvmti);
782 
783     if (!enableEventList()) {
784         return JNI_ERR;
785     }
786 
787     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
788         return JNI_ERR;
789 
790     return JNI_OK;
791 }
792 
793 /* ============================================================================= */
794 
795 
796 }
<a name="42" id="anc42"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="42" type="hidden" />
</body>
</html>
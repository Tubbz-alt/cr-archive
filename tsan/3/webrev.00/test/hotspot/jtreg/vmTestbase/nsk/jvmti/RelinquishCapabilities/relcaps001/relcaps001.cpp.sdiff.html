<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/RelinquishCapabilities/relcaps001/relcaps001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../RawMonitorWait/rawmnwait005/rawmnwait005.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../relcaps002/relcaps002.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/RelinquishCapabilities/relcaps001/relcaps001.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
107     PRINT_CAP(caps, can_get_thread_cpu_time);
108     PRINT_CAP(caps, can_generate_method_entry_events);
109     PRINT_CAP(caps, can_generate_method_exit_events);
110     PRINT_CAP(caps, can_generate_all_class_hook_events);
111     PRINT_CAP(caps, can_generate_compiled_method_load_events);
112     PRINT_CAP(caps, can_generate_monitor_events);
113     PRINT_CAP(caps, can_generate_vm_object_alloc_events);
114     PRINT_CAP(caps, can_generate_native_method_bind_events);
115     PRINT_CAP(caps, can_generate_garbage_collection_events);
116     PRINT_CAP(caps, can_generate_object_free_events);
117     /* :15 */
118     /* :16 */
119     /* :16 */
120     /* :16 */
121     /* :16 */
122     /* :16 */
123 }
124 
125 #define CHECK_CAP(initCaps, caps, name)                                         \
126     if (caps-&gt;name != 0) {                                                      \
<span class="line-modified">127         success = NSK_FALSE;                                                    \</span>
128         NSK_COMPLAIN4(&quot;GetCapabilities() in %s returned capability after add and relinguish all potential capabilities:\n&quot;  \
129                       &quot;#   capability: %s\n&quot;                                    \
130                       &quot;#   got value:  %d\n&quot;                                    \
131                       &quot;#   expected:   %d\n&quot;,                                   \
132                         where, #name, (int)caps-&gt;name, 0)       ;               \
133     }
134 
135 /**
136  * Check value of known capabilities.
<span class="line-modified">137  * @returns NSK_FALSE if any error occured.</span>
138  */
<span class="line-modified">139 static int checkCapabilitiesValue(jvmtiCapabilities* caps, jvmtiCapabilities* initCaps, const char where[]) {</span>
<span class="line-modified">140     int success = NSK_TRUE;</span>
141 
142     CHECK_CAP(initCaps, caps, can_tag_objects);
143     CHECK_CAP(initCaps, caps, can_generate_field_modification_events);
144     CHECK_CAP(initCaps, caps, can_generate_field_access_events);
145     CHECK_CAP(initCaps, caps, can_get_bytecodes);
146     CHECK_CAP(initCaps, caps, can_get_synthetic_attribute);
147     CHECK_CAP(initCaps, caps, can_get_owned_monitor_info);
148     CHECK_CAP(initCaps, caps, can_get_current_contended_monitor);
149     CHECK_CAP(initCaps, caps, can_get_monitor_info);
150     CHECK_CAP(initCaps, caps, can_pop_frame);
151     CHECK_CAP(initCaps, caps, can_redefine_classes);
152     CHECK_CAP(initCaps, caps, can_signal_thread);
153     CHECK_CAP(initCaps, caps, can_get_source_file_name);
154     CHECK_CAP(initCaps, caps, can_get_line_numbers);
155     CHECK_CAP(initCaps, caps, can_get_source_debug_extension);
156     CHECK_CAP(initCaps, caps, can_access_local_variables);
157     CHECK_CAP(initCaps, caps, can_maintain_original_method_order);
158     CHECK_CAP(initCaps, caps, can_generate_single_step_events);
159     CHECK_CAP(initCaps, caps, can_generate_exception_events);
160     CHECK_CAP(initCaps, caps, can_generate_frame_pop_events);
</pre>
<hr />
<pre>
167     CHECK_CAP(initCaps, caps, can_generate_method_exit_events);
168     CHECK_CAP(initCaps, caps, can_generate_all_class_hook_events);
169     CHECK_CAP(initCaps, caps, can_generate_compiled_method_load_events);
170     CHECK_CAP(initCaps, caps, can_generate_monitor_events);
171     CHECK_CAP(initCaps, caps, can_generate_vm_object_alloc_events);
172     CHECK_CAP(initCaps, caps, can_generate_native_method_bind_events);
173     CHECK_CAP(initCaps, caps, can_generate_garbage_collection_events);
174     CHECK_CAP(initCaps, caps, can_generate_object_free_events);
175     /* :15 */
176     /* :16 */
177     /* :16 */
178     /* :16 */
179     /* :16 */
180     /* :16 */
181 
182     return success;
183 }
184 
185 /**
186  * Get and check current capabilities.
<span class="line-modified">187  * @returns NSK_FALSE if any error occured.</span>
188  */
<span class="line-modified">189 static int checkCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* initCaps, const char where[]) {</span>
<span class="line-modified">190     int success = NSK_TRUE;</span>
191     jvmtiCapabilities caps;
192 
193     memset(&amp;caps, 0, sizeof(jvmtiCapabilities));
194 
195     NSK_DISPLAY0(&quot;GetCapabilities() for current JVMTI env\n&quot;);
196     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetCapabilities(&amp;caps))) {
<span class="line-modified">197         return NSK_FALSE;</span>
198     }
199 
200     NSK_DISPLAY0(&quot;Got raw capabilities:\n&quot;);
201     printRawCapabilities(&amp;caps);
202 
203     NSK_DISPLAY0(&quot;Known capabilities:\n&quot;);
204     printKnownCapabilities(&amp;caps);
205 
206     NSK_DISPLAY0(&quot;Checking capabilities value:\n&quot;);
207     success = checkCapabilitiesValue(&amp;caps, initCaps, where);
208     NSK_DISPLAY0(&quot;  ... checked\n&quot;);
209 
210     return success;
211 }
212 
213 /**
214  * Add given capabilities list.
<span class="line-modified">215  * @returns NSK_FALSE if any error occured.</span>
216  */
<span class="line-modified">217 static int addCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* caps) {</span>
218     NSK_DISPLAY0(&quot;AddCapabilities() for current JVMTI env\n&quot;);
219     if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(caps))) {
<span class="line-modified">220         return NSK_FALSE;</span>
221     }
222     NSK_DISPLAY0(&quot;  ... set\n&quot;);
223 
<span class="line-modified">224     return NSK_TRUE;</span>
225 }
226 
227 /**
228  * Remove given capabilities list.
<span class="line-modified">229  * @returns NSK_FALSE if any error occured.</span>
230  */
<span class="line-modified">231 static int removeCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* caps, const char where[]) {</span>
232     NSK_DISPLAY0(&quot;RelinquishCapabilities() for current JVMTI env\n&quot;);
233     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RelinquishCapabilities(caps))) {
<span class="line-modified">234         return NSK_FALSE;</span>
235     }
236     NSK_DISPLAY0(&quot;  ... relinguished\n&quot;);
237 
<span class="line-modified">238     return NSK_TRUE;</span>
239 }
240 
241 /**
242  * Get potential capabilities to the given list.
<span class="line-modified">243  * @returns NSK_FALSE if any error occured.</span>
244  */
<span class="line-modified">245 static int getPotentialCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* caps) {</span>
246     NSK_DISPLAY0(&quot;GetPotentialCapabilities() for current JVMTI env\n&quot;);
247     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetPotentialCapabilities(caps))) {
<span class="line-modified">248         return NSK_FALSE;</span>
249     }
250 
251     NSK_DISPLAY0(&quot;Got raw capabilities:\n&quot;);
252     printRawCapabilities(caps);
253 
254     NSK_DISPLAY0(&quot;Known capabilities:\n&quot;);
255     printKnownCapabilities(caps);
256 
<span class="line-modified">257     return NSK_TRUE;</span>
258 }
259 
260 /* ============================================================================= */
261 
262 /** Agent algorithm. */
263 static void JNICALL
264 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
265     NSK_DISPLAY0(&quot;Wait for debugee to become ready\n&quot;);
266     if (!nsk_jvmti_waitForSync(timeout))
267         return;
268 
269     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #3: Check capabilities in agent thread\n&quot;);
270     if (!checkCapabilities(jvmti, &amp;initCaps, &quot;agent thread&quot;)) {
271         nsk_jvmti_setFailStatus();
272     }
273 
274     NSK_DISPLAY0(&quot;Let debugee to finish\n&quot;);
275     if (!nsk_jvmti_resumeSync())
276         return;
277 }
</pre>
<hr />
<pre>
279 /* ============================================================================= */
280 
281 /**
282  * Callback for VM_INIT event.
283  */
284 JNIEXPORT void JNICALL
285 callbackVMInit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread) {
286 
287     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #2: Check capabilities in VM_INIT callback\n&quot;);
288     if (!checkCapabilities(jvmti, &amp;initCaps, &quot;VM_INIT callback&quot;)) {
289         nsk_jvmti_setFailStatus();
290     }
291 
292 }
293 
294 /**
295  * Callback for VM_DEATH event.
296  */
297 JNIEXPORT void JNICALL
298 callbackVMDeath(jvmtiEnv* jvmti, JNIEnv* jni) {
<span class="line-modified">299     int success = NSK_TRUE;</span>
300 
301     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #4: Check capabilities in VM_DEATH callback\n&quot;);
302     success = checkCapabilities(jvmti, &amp;initCaps, &quot;VM_DEATH callback&quot;);
303 
304     NSK_DISPLAY1(&quot;Disable events: %d events\n&quot;, EVENTS_COUNT);
305     if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {
<span class="line-modified">306         success = NSK_FALSE;</span>
307     } else {
308         NSK_DISPLAY0(&quot;  ... disabled\n&quot;);
309     }
310 
<span class="line-modified">311     if (success != NSK_TRUE) {</span>
312         NSK_DISPLAY1(&quot;Exit with FAIL exit status: %d\n&quot;, STATUS_FAIL);
313         NSK_BEFORE_TRACE(exit(STATUS_FAIL));
314     }
315 }
316 
317 /* ============================================================================= */
318 
319 /** Agent library initialization. */
320 #ifdef STATIC_BUILD
321 JNIEXPORT jint JNICALL Agent_OnLoad_relcaps001(JavaVM *jvm, char *options, void *reserved) {
322     return Agent_Initialize(jvm, options, reserved);
323 }
324 JNIEXPORT jint JNICALL Agent_OnAttach_relcaps001(JavaVM *jvm, char *options, void *reserved) {
325     return Agent_Initialize(jvm, options, reserved);
326 }
327 JNIEXPORT jint JNI_OnLoad_relcaps001(JavaVM *jvm, char *options, void *reserved) {
328     return JNI_VERSION_1_8;
329 }
330 #endif
331 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
</pre>
</td>
<td>
<hr />
<pre>
107     PRINT_CAP(caps, can_get_thread_cpu_time);
108     PRINT_CAP(caps, can_generate_method_entry_events);
109     PRINT_CAP(caps, can_generate_method_exit_events);
110     PRINT_CAP(caps, can_generate_all_class_hook_events);
111     PRINT_CAP(caps, can_generate_compiled_method_load_events);
112     PRINT_CAP(caps, can_generate_monitor_events);
113     PRINT_CAP(caps, can_generate_vm_object_alloc_events);
114     PRINT_CAP(caps, can_generate_native_method_bind_events);
115     PRINT_CAP(caps, can_generate_garbage_collection_events);
116     PRINT_CAP(caps, can_generate_object_free_events);
117     /* :15 */
118     /* :16 */
119     /* :16 */
120     /* :16 */
121     /* :16 */
122     /* :16 */
123 }
124 
125 #define CHECK_CAP(initCaps, caps, name)                                         \
126     if (caps-&gt;name != 0) {                                                      \
<span class="line-modified">127         success = false;                                                        \</span>
128         NSK_COMPLAIN4(&quot;GetCapabilities() in %s returned capability after add and relinguish all potential capabilities:\n&quot;  \
129                       &quot;#   capability: %s\n&quot;                                    \
130                       &quot;#   got value:  %d\n&quot;                                    \
131                       &quot;#   expected:   %d\n&quot;,                                   \
132                         where, #name, (int)caps-&gt;name, 0)       ;               \
133     }
134 
135 /**
136  * Check value of known capabilities.
<span class="line-modified">137  * @returns false if any error occured.</span>
138  */
<span class="line-modified">139 static bool checkCapabilitiesValue(jvmtiCapabilities* caps, jvmtiCapabilities* initCaps, const char where[]) {</span>
<span class="line-modified">140     bool success = true;</span>
141 
142     CHECK_CAP(initCaps, caps, can_tag_objects);
143     CHECK_CAP(initCaps, caps, can_generate_field_modification_events);
144     CHECK_CAP(initCaps, caps, can_generate_field_access_events);
145     CHECK_CAP(initCaps, caps, can_get_bytecodes);
146     CHECK_CAP(initCaps, caps, can_get_synthetic_attribute);
147     CHECK_CAP(initCaps, caps, can_get_owned_monitor_info);
148     CHECK_CAP(initCaps, caps, can_get_current_contended_monitor);
149     CHECK_CAP(initCaps, caps, can_get_monitor_info);
150     CHECK_CAP(initCaps, caps, can_pop_frame);
151     CHECK_CAP(initCaps, caps, can_redefine_classes);
152     CHECK_CAP(initCaps, caps, can_signal_thread);
153     CHECK_CAP(initCaps, caps, can_get_source_file_name);
154     CHECK_CAP(initCaps, caps, can_get_line_numbers);
155     CHECK_CAP(initCaps, caps, can_get_source_debug_extension);
156     CHECK_CAP(initCaps, caps, can_access_local_variables);
157     CHECK_CAP(initCaps, caps, can_maintain_original_method_order);
158     CHECK_CAP(initCaps, caps, can_generate_single_step_events);
159     CHECK_CAP(initCaps, caps, can_generate_exception_events);
160     CHECK_CAP(initCaps, caps, can_generate_frame_pop_events);
</pre>
<hr />
<pre>
167     CHECK_CAP(initCaps, caps, can_generate_method_exit_events);
168     CHECK_CAP(initCaps, caps, can_generate_all_class_hook_events);
169     CHECK_CAP(initCaps, caps, can_generate_compiled_method_load_events);
170     CHECK_CAP(initCaps, caps, can_generate_monitor_events);
171     CHECK_CAP(initCaps, caps, can_generate_vm_object_alloc_events);
172     CHECK_CAP(initCaps, caps, can_generate_native_method_bind_events);
173     CHECK_CAP(initCaps, caps, can_generate_garbage_collection_events);
174     CHECK_CAP(initCaps, caps, can_generate_object_free_events);
175     /* :15 */
176     /* :16 */
177     /* :16 */
178     /* :16 */
179     /* :16 */
180     /* :16 */
181 
182     return success;
183 }
184 
185 /**
186  * Get and check current capabilities.
<span class="line-modified">187  * @returns false if any error occured.</span>
188  */
<span class="line-modified">189 static bool checkCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* initCaps, const char where[]) {</span>
<span class="line-modified">190     bool success = true;</span>
191     jvmtiCapabilities caps;
192 
193     memset(&amp;caps, 0, sizeof(jvmtiCapabilities));
194 
195     NSK_DISPLAY0(&quot;GetCapabilities() for current JVMTI env\n&quot;);
196     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetCapabilities(&amp;caps))) {
<span class="line-modified">197         return false;</span>
198     }
199 
200     NSK_DISPLAY0(&quot;Got raw capabilities:\n&quot;);
201     printRawCapabilities(&amp;caps);
202 
203     NSK_DISPLAY0(&quot;Known capabilities:\n&quot;);
204     printKnownCapabilities(&amp;caps);
205 
206     NSK_DISPLAY0(&quot;Checking capabilities value:\n&quot;);
207     success = checkCapabilitiesValue(&amp;caps, initCaps, where);
208     NSK_DISPLAY0(&quot;  ... checked\n&quot;);
209 
210     return success;
211 }
212 
213 /**
214  * Add given capabilities list.
<span class="line-modified">215  * @returns false if any error occured.</span>
216  */
<span class="line-modified">217 static bool addCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* caps) {</span>
218     NSK_DISPLAY0(&quot;AddCapabilities() for current JVMTI env\n&quot;);
219     if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(caps))) {
<span class="line-modified">220         return false;</span>
221     }
222     NSK_DISPLAY0(&quot;  ... set\n&quot;);
223 
<span class="line-modified">224     return true;</span>
225 }
226 
227 /**
228  * Remove given capabilities list.
<span class="line-modified">229  * @returns false if any error occured.</span>
230  */
<span class="line-modified">231 static bool removeCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* caps, const char where[]) {</span>
232     NSK_DISPLAY0(&quot;RelinquishCapabilities() for current JVMTI env\n&quot;);
233     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RelinquishCapabilities(caps))) {
<span class="line-modified">234         return false;</span>
235     }
236     NSK_DISPLAY0(&quot;  ... relinguished\n&quot;);
237 
<span class="line-modified">238     return true;</span>
239 }
240 
241 /**
242  * Get potential capabilities to the given list.
<span class="line-modified">243  * @returns false if any error occured.</span>
244  */
<span class="line-modified">245 static bool getPotentialCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* caps) {</span>
246     NSK_DISPLAY0(&quot;GetPotentialCapabilities() for current JVMTI env\n&quot;);
247     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetPotentialCapabilities(caps))) {
<span class="line-modified">248         return false;</span>
249     }
250 
251     NSK_DISPLAY0(&quot;Got raw capabilities:\n&quot;);
252     printRawCapabilities(caps);
253 
254     NSK_DISPLAY0(&quot;Known capabilities:\n&quot;);
255     printKnownCapabilities(caps);
256 
<span class="line-modified">257     return true;</span>
258 }
259 
260 /* ============================================================================= */
261 
262 /** Agent algorithm. */
263 static void JNICALL
264 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
265     NSK_DISPLAY0(&quot;Wait for debugee to become ready\n&quot;);
266     if (!nsk_jvmti_waitForSync(timeout))
267         return;
268 
269     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #3: Check capabilities in agent thread\n&quot;);
270     if (!checkCapabilities(jvmti, &amp;initCaps, &quot;agent thread&quot;)) {
271         nsk_jvmti_setFailStatus();
272     }
273 
274     NSK_DISPLAY0(&quot;Let debugee to finish\n&quot;);
275     if (!nsk_jvmti_resumeSync())
276         return;
277 }
</pre>
<hr />
<pre>
279 /* ============================================================================= */
280 
281 /**
282  * Callback for VM_INIT event.
283  */
284 JNIEXPORT void JNICALL
285 callbackVMInit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread) {
286 
287     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #2: Check capabilities in VM_INIT callback\n&quot;);
288     if (!checkCapabilities(jvmti, &amp;initCaps, &quot;VM_INIT callback&quot;)) {
289         nsk_jvmti_setFailStatus();
290     }
291 
292 }
293 
294 /**
295  * Callback for VM_DEATH event.
296  */
297 JNIEXPORT void JNICALL
298 callbackVMDeath(jvmtiEnv* jvmti, JNIEnv* jni) {
<span class="line-modified">299     bool success = true;</span>
300 
301     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #4: Check capabilities in VM_DEATH callback\n&quot;);
302     success = checkCapabilities(jvmti, &amp;initCaps, &quot;VM_DEATH callback&quot;);
303 
304     NSK_DISPLAY1(&quot;Disable events: %d events\n&quot;, EVENTS_COUNT);
305     if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {
<span class="line-modified">306         success = false;</span>
307     } else {
308         NSK_DISPLAY0(&quot;  ... disabled\n&quot;);
309     }
310 
<span class="line-modified">311     if (!success) {</span>
312         NSK_DISPLAY1(&quot;Exit with FAIL exit status: %d\n&quot;, STATUS_FAIL);
313         NSK_BEFORE_TRACE(exit(STATUS_FAIL));
314     }
315 }
316 
317 /* ============================================================================= */
318 
319 /** Agent library initialization. */
320 #ifdef STATIC_BUILD
321 JNIEXPORT jint JNICALL Agent_OnLoad_relcaps001(JavaVM *jvm, char *options, void *reserved) {
322     return Agent_Initialize(jvm, options, reserved);
323 }
324 JNIEXPORT jint JNICALL Agent_OnAttach_relcaps001(JavaVM *jvm, char *options, void *reserved) {
325     return Agent_Initialize(jvm, options, reserved);
326 }
327 JNIEXPORT jint JNI_OnLoad_relcaps001(JavaVM *jvm, char *options, void *reserved) {
328     return JNI_VERSION_1_8;
329 }
330 #endif
331 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
</pre>
</td>
</tr>
</table>
<center><a href="../../RawMonitorWait/rawmnwait005/rawmnwait005.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../relcaps002/relcaps002.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
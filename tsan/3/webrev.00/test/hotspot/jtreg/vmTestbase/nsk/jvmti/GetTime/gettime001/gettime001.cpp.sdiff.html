<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/GetTime/gettime001/gettime001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../GetThreadState/thrstat001/thrstat001.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../GetTimerInfo/timerinfo001/timerinfo001.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/GetTime/gettime001/gettime001.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32 
 33 /* ============================================================================= */
 34 
 35 static jlong timeout = 0;
 36 
 37 #define STATUS_FAIL     97
 38 
 39 #define EVENTS_COUNT    2
 40 
 41 static jvmtiEvent events[EVENTS_COUNT] = {
 42     JVMTI_EVENT_VM_INIT,
 43     JVMTI_EVENT_VM_DEATH
 44 };
 45 
 46 static julong prevTime;
 47 
 48 /* ============================================================================= */
 49 
 50 /**
 51  * Get time and optionally compare it with previous one.
<span class="line-modified"> 52  * @returns NSK_FALSE if any error occured.</span>
 53  */
<span class="line-modified"> 54 static int checkTime(jvmtiEnv* jvmti, julong* time,</span>
<span class="line-modified"> 55                                 julong* prevTime, const char where[]) {</span>
 56 
 57     char buf[32], buf2[32], buf3[32];
<span class="line-modified"> 58     int success = NSK_TRUE;</span>
 59 
 60     NSK_DISPLAY0(&quot;GetTime() for current JVMTI env\n&quot;);
 61     if (!NSK_JVMTI_VERIFY(
 62             jvmti-&gt;GetTime((jlong *)time))) {
<span class="line-modified"> 63         return NSK_FALSE;</span>
 64     }
 65     NSK_DISPLAY1(&quot;  ... got time: %s\n&quot;, julong_to_string(*time, buf));
 66 
 67     if (prevTime != NULL) {
 68         julong diff = *time - *prevTime;
 69 
 70         NSK_DISPLAY1(&quot;Compare with previous time: %s\n&quot;,
 71                             julong_to_string(*prevTime, buf));
 72         NSK_DISPLAY1(&quot;  ... difference: %s\n&quot;,
 73                             julong_to_string(diff, buf));
 74 
 75         if (*time &lt; *prevTime) {
 76             NSK_COMPLAIN4(&quot;In %s GetTime() returned value less than previous:\n&quot;
 77                           &quot;#   got value:  %s\n&quot;
 78                           &quot;#   previous:   %s\n&quot;
 79                           &quot;#   difference: %s\n&quot;,
 80                             where,
 81                             julong_to_string(*time, buf),
 82                             julong_to_string(*prevTime, buf2),
 83                             julong_to_string(diff, buf3));
<span class="line-modified"> 84             success = NSK_FALSE;</span>
 85         }
 86         *prevTime = *time;
 87     }
 88 
 89     return success;
 90 }
 91 /* ============================================================================= */
 92 
 93 /** Agent algorithm. */
 94 static void JNICALL
 95 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
 96     NSK_DISPLAY0(&quot;Wait for debugee to become ready\n&quot;);
 97     if (!nsk_jvmti_waitForSync(timeout))
 98         return;
 99 
100     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #3: Check time in agent thread\n&quot;);
101     {
102         julong time;
103         if (!checkTime(jvmti, &amp;time, &amp;prevTime, &quot;agent thread&quot;)) {
104             nsk_jvmti_setFailStatus();
</pre>
<hr />
<pre>
115 /**
116  * Callback for VM_INIT event.
117  */
118 JNIEXPORT void JNICALL
119 callbackVMInit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread) {
120 
121     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #2: Check time in VM_INIT callback\n&quot;);
122     {
123         julong time;
124         if (!checkTime(jvmti, &amp;time, &amp;prevTime, &quot;VM_INIT callback&quot;)) {
125             nsk_jvmti_setFailStatus();
126         }
127     }
128 }
129 
130 /**
131  * Callback for VM_DEATH event.
132  */
133 JNIEXPORT void JNICALL
134 callbackVMDeath(jvmtiEnv* jvmti, JNIEnv* jni) {
<span class="line-modified">135     int success = NSK_TRUE;</span>
136 
137     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #4: Check time in VM_DEATH callback\n&quot;);
138     {
139         julong time;
140         success = checkTime(jvmti, &amp;time, &amp;prevTime, &quot;VM_DEATH callback&quot;);
141     }
142 
143     NSK_DISPLAY1(&quot;Disable events: %d events\n&quot;, EVENTS_COUNT);
144     if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {
<span class="line-modified">145         success = NSK_FALSE;</span>
146     } else {
147         NSK_DISPLAY0(&quot;  ... disabled\n&quot;);
148     }
149 
<span class="line-modified">150     if (success != NSK_TRUE) {</span>
151         NSK_DISPLAY1(&quot;Exit with FAIL exit status: %d\n&quot;, STATUS_FAIL);
152         NSK_BEFORE_TRACE(exit(STATUS_FAIL));
153     }
154 }
155 
156 /* ============================================================================= */
157 
158 /** Agent library initialization. */
159 #ifdef STATIC_BUILD
160 JNIEXPORT jint JNICALL Agent_OnLoad_gettime001(JavaVM *jvm, char *options, void *reserved) {
161     return Agent_Initialize(jvm, options, reserved);
162 }
163 JNIEXPORT jint JNICALL Agent_OnAttach_gettime001(JavaVM *jvm, char *options, void *reserved) {
164     return Agent_Initialize(jvm, options, reserved);
165 }
166 JNIEXPORT jint JNI_OnLoad_gettime001(JavaVM *jvm, char *options, void *reserved) {
167     return JNI_VERSION_1_8;
168 }
169 #endif
170 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
</pre>
</td>
<td>
<hr />
<pre>
 32 
 33 /* ============================================================================= */
 34 
 35 static jlong timeout = 0;
 36 
 37 #define STATUS_FAIL     97
 38 
 39 #define EVENTS_COUNT    2
 40 
 41 static jvmtiEvent events[EVENTS_COUNT] = {
 42     JVMTI_EVENT_VM_INIT,
 43     JVMTI_EVENT_VM_DEATH
 44 };
 45 
 46 static julong prevTime;
 47 
 48 /* ============================================================================= */
 49 
 50 /**
 51  * Get time and optionally compare it with previous one.
<span class="line-modified"> 52  * @returns false if any error occured.</span>
 53  */
<span class="line-modified"> 54 static bool checkTime(jvmtiEnv* jvmti, julong* time,</span>
<span class="line-modified"> 55                       julong* prevTime, const char where[]) {</span>
 56 
 57     char buf[32], buf2[32], buf3[32];
<span class="line-modified"> 58     bool success = true;</span>
 59 
 60     NSK_DISPLAY0(&quot;GetTime() for current JVMTI env\n&quot;);
 61     if (!NSK_JVMTI_VERIFY(
 62             jvmti-&gt;GetTime((jlong *)time))) {
<span class="line-modified"> 63         return false;</span>
 64     }
 65     NSK_DISPLAY1(&quot;  ... got time: %s\n&quot;, julong_to_string(*time, buf));
 66 
 67     if (prevTime != NULL) {
 68         julong diff = *time - *prevTime;
 69 
 70         NSK_DISPLAY1(&quot;Compare with previous time: %s\n&quot;,
 71                             julong_to_string(*prevTime, buf));
 72         NSK_DISPLAY1(&quot;  ... difference: %s\n&quot;,
 73                             julong_to_string(diff, buf));
 74 
 75         if (*time &lt; *prevTime) {
 76             NSK_COMPLAIN4(&quot;In %s GetTime() returned value less than previous:\n&quot;
 77                           &quot;#   got value:  %s\n&quot;
 78                           &quot;#   previous:   %s\n&quot;
 79                           &quot;#   difference: %s\n&quot;,
 80                             where,
 81                             julong_to_string(*time, buf),
 82                             julong_to_string(*prevTime, buf2),
 83                             julong_to_string(diff, buf3));
<span class="line-modified"> 84             success = false;</span>
 85         }
 86         *prevTime = *time;
 87     }
 88 
 89     return success;
 90 }
 91 /* ============================================================================= */
 92 
 93 /** Agent algorithm. */
 94 static void JNICALL
 95 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
 96     NSK_DISPLAY0(&quot;Wait for debugee to become ready\n&quot;);
 97     if (!nsk_jvmti_waitForSync(timeout))
 98         return;
 99 
100     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #3: Check time in agent thread\n&quot;);
101     {
102         julong time;
103         if (!checkTime(jvmti, &amp;time, &amp;prevTime, &quot;agent thread&quot;)) {
104             nsk_jvmti_setFailStatus();
</pre>
<hr />
<pre>
115 /**
116  * Callback for VM_INIT event.
117  */
118 JNIEXPORT void JNICALL
119 callbackVMInit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread) {
120 
121     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #2: Check time in VM_INIT callback\n&quot;);
122     {
123         julong time;
124         if (!checkTime(jvmti, &amp;time, &amp;prevTime, &quot;VM_INIT callback&quot;)) {
125             nsk_jvmti_setFailStatus();
126         }
127     }
128 }
129 
130 /**
131  * Callback for VM_DEATH event.
132  */
133 JNIEXPORT void JNICALL
134 callbackVMDeath(jvmtiEnv* jvmti, JNIEnv* jni) {
<span class="line-modified">135     bool success = true;</span>
136 
137     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #4: Check time in VM_DEATH callback\n&quot;);
138     {
139         julong time;
140         success = checkTime(jvmti, &amp;time, &amp;prevTime, &quot;VM_DEATH callback&quot;);
141     }
142 
143     NSK_DISPLAY1(&quot;Disable events: %d events\n&quot;, EVENTS_COUNT);
144     if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {
<span class="line-modified">145         success = false;</span>
146     } else {
147         NSK_DISPLAY0(&quot;  ... disabled\n&quot;);
148     }
149 
<span class="line-modified">150     if (!success) {</span>
151         NSK_DISPLAY1(&quot;Exit with FAIL exit status: %d\n&quot;, STATUS_FAIL);
152         NSK_BEFORE_TRACE(exit(STATUS_FAIL));
153     }
154 }
155 
156 /* ============================================================================= */
157 
158 /** Agent library initialization. */
159 #ifdef STATIC_BUILD
160 JNIEXPORT jint JNICALL Agent_OnLoad_gettime001(JavaVM *jvm, char *options, void *reserved) {
161     return Agent_Initialize(jvm, options, reserved);
162 }
163 JNIEXPORT jint JNICALL Agent_OnAttach_gettime001(JavaVM *jvm, char *options, void *reserved) {
164     return Agent_Initialize(jvm, options, reserved);
165 }
166 JNIEXPORT jint JNI_OnLoad_gettime001(JavaVM *jvm, char *options, void *reserved) {
167     return JNI_VERSION_1_8;
168 }
169 #endif
170 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
</pre>
</td>
</tr>
</table>
<center><a href="../../GetThreadState/thrstat001/thrstat001.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../GetTimerInfo/timerinfo001/timerinfo001.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
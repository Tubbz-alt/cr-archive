<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jdi/ThreadStartRequest/addThreadFilter/addthreadfilter002.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="addthreadfilter001.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="addthreadfilter003.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jdi/ThreadStartRequest/addThreadFilter/addthreadfilter002.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
128 
129     //====================================================== test program
130     //------------------------------------------------------ common section
131 
132     static Debugee          debuggee;
133     static ArgumentHandler  argsHandler;
134 
135     static int waitTime;
136 
137     static VirtualMachine      vm            = null;
138     static EventRequestManager eventRManager = null;
139     static EventQueue          eventQueue    = null;
140     static EventSet            eventSet      = null;
141     static EventIterator       eventIterator = null;
142 
143     static ReferenceType       debuggeeClass = null;
144 
145     static int  testExitCode = PASSED;
146 
147 
<span class="line-removed">148     class JDITestRuntimeException extends RuntimeException {</span>
<span class="line-removed">149         JDITestRuntimeException(String str) {</span>
<span class="line-removed">150             super(&quot;JDITestRuntimeException : &quot; + str);</span>
<span class="line-removed">151         }</span>
<span class="line-removed">152     }</span>
<span class="line-removed">153 </span>
154     //------------------------------------------------------ methods
155 
156     private int runThis (String argv[], PrintStream out) {
157 
158         argsHandler     = new ArgumentHandler(argv);
159         logHandler      = new Log(out, argsHandler);
160         Binder binder   = new Binder(argsHandler, logHandler);
161 
162         waitTime        = argsHandler.getWaitTime() * 60000;
163 
164         try {
165             log2(&quot;launching a debuggee :&quot;);
166             log2(&quot;       &quot; + debuggeeName);
167             if (argsHandler.verbose()) {
168                 debuggee = binder.bindToDebugee(debuggeeName + &quot; -vbs&quot;);
169             } else {
170                 debuggee = binder.bindToDebugee(debuggeeName);
171             }
172             if (debuggee == null) {
173                 log3(&quot;ERROR: no debuggee launched&quot;);
</pre>
<hr />
<pre>
278         cpRequest.setSuspendPolicy( EventRequest.SUSPEND_EVENT_THREAD);
279         cpRequest.addClassFilter(debuggeeName);
280 
281         cpRequest.enable();
282         vm.resume();
283         getEventSet();
284         cpRequest.disable();
285 
286         ClassPrepareEvent event = (ClassPrepareEvent) eventIterator.next();
287         debuggeeClass = event.referenceType();
288 
289         if (!debuggeeClass.name().equals(debuggeeName))
290            throw new JDITestRuntimeException(&quot;** Unexpected ClassName for ClassPrepareEvent **&quot;);
291 
292         log2(&quot;      received: ClassPrepareEvent for debuggeeClass&quot;);
293 
294         String bPointMethod = &quot;methodForCommunication&quot;;
295         String lineForComm  = &quot;lineForComm&quot;;
296         BreakpointRequest bpRequest;
297 
<span class="line-modified">298         ThreadReference mainThread = threadByName(&quot;main&quot;);</span>
299 
300         bpRequest = settingBreakpoint(mainThread,
301                                       debuggeeClass,
302                                       bPointMethod, lineForComm, &quot;zero&quot;);
303         bpRequest.enable();
304 
305     //------------------------------------------------------  testing section
306 
307         log1(&quot;     TESTING BEGINS&quot;);
308 
309 
310         for (int i = 0; ; i++) {
311 
312             vm.resume();
313             breakpointForCommunication();
314 
315             int instruction = ((IntegerValue)
316                                (debuggeeClass.getValue(debuggeeClass.fieldByName(&quot;instruction&quot;)))).value();
317 
318             if (instruction == 0) {
</pre>
<hr />
<pre>
365             tsr1.disable();
366 
367             try {
368                 log2(&quot;...... tsr1.addThreadFilter(null);&quot;);
369                 log2(&quot;         NullPointerException is expected&quot;);
370                 tsr1.addThreadFilter(null);
371                 log3(&quot;ERROR: no NullPointerException &quot;);
372                 testExitCode = FAILED;
373             } catch ( NullPointerException e ) {
374                 log2(&quot;          NullPointerException&quot;);
375             } catch ( Exception e ) {
376                 log3(&quot;ERROR: unexpected Exception : &quot; + e);
377                 testExitCode = FAILED;
378             }
379             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
380         }
381         log1(&quot;    TESTING ENDS&quot;);
382         return;
383     }
384 
<span class="line-removed">385     private ThreadReference threadByName(String name)</span>
<span class="line-removed">386                  throws JDITestRuntimeException {</span>
<span class="line-removed">387 </span>
<span class="line-removed">388         List         all = vm.allThreads();</span>
<span class="line-removed">389         ListIterator li  = all.listIterator();</span>
<span class="line-removed">390 </span>
<span class="line-removed">391         for (; li.hasNext(); ) {</span>
<span class="line-removed">392             ThreadReference thread = (ThreadReference) li.next();</span>
<span class="line-removed">393             if (thread.name().equals(name))</span>
<span class="line-removed">394                 return thread;</span>
<span class="line-removed">395         }</span>
<span class="line-removed">396         throw new JDITestRuntimeException(&quot;** Thread IS NOT found ** : &quot; + name);</span>
<span class="line-removed">397     }</span>
<span class="line-removed">398 </span>
399    /*
400     * private BreakpointRequest settingBreakpoint(ThreadReference, ReferenceType,
401     *                                             String, String, String)
402     *
403     * It sets up a breakpoint at given line number within a given method in a given class
404     * for a given thread.
405     *
406     * Return value: BreakpointRequest object  in case of success
407     *
408     * JDITestRuntimeException   in case of an Exception thrown within the method
409     */
410 
411     private BreakpointRequest settingBreakpoint ( ThreadReference thread,
412                                                   ReferenceType testedClass,
413                                                   String methodName,
414                                                   String bpLine,
415                                                   String property)
416             throws JDITestRuntimeException {
417 
418         log2(&quot;......setting up a breakpoint:&quot;);
</pre>
<hr />
<pre>
462     private void getEventSet()
463                  throws JDITestRuntimeException {
464         try {
465 //            log2(&quot;       eventSet = eventQueue.remove(waitTime);&quot;);
466             eventSet = eventQueue.remove(waitTime);
467             if (eventSet == null) {
468                 throw new JDITestRuntimeException(&quot;** TIMEOUT while waiting for event **&quot;);
469             }
470 //            log2(&quot;       eventIterator = eventSet.eventIterator;&quot;);
471             eventIterator = eventSet.eventIterator();
472         } catch ( Exception e ) {
473             throw new JDITestRuntimeException(&quot;** EXCEPTION while waiting for event ** : &quot; + e);
474         }
475     }
476 
477 
478     private void breakpointForCommunication()
479                  throws JDITestRuntimeException {
480 
481         log2(&quot;breakpointForCommunication&quot;);
<span class="line-modified">482         getEventSet();</span>
<span class="line-modified">483 </span>
<span class="line-modified">484         if (eventIterator.nextEvent() instanceof BreakpointEvent)</span>
<span class="line-modified">485             return;</span>
<span class="line-modified">486 </span>
<span class="line-modified">487         throw new JDITestRuntimeException(&quot;** event IS NOT a breakpoint **&quot;);</span>













488     }
489 
490 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
128 
129     //====================================================== test program
130     //------------------------------------------------------ common section
131 
132     static Debugee          debuggee;
133     static ArgumentHandler  argsHandler;
134 
135     static int waitTime;
136 
137     static VirtualMachine      vm            = null;
138     static EventRequestManager eventRManager = null;
139     static EventQueue          eventQueue    = null;
140     static EventSet            eventSet      = null;
141     static EventIterator       eventIterator = null;
142 
143     static ReferenceType       debuggeeClass = null;
144 
145     static int  testExitCode = PASSED;
146 
147 






148     //------------------------------------------------------ methods
149 
150     private int runThis (String argv[], PrintStream out) {
151 
152         argsHandler     = new ArgumentHandler(argv);
153         logHandler      = new Log(out, argsHandler);
154         Binder binder   = new Binder(argsHandler, logHandler);
155 
156         waitTime        = argsHandler.getWaitTime() * 60000;
157 
158         try {
159             log2(&quot;launching a debuggee :&quot;);
160             log2(&quot;       &quot; + debuggeeName);
161             if (argsHandler.verbose()) {
162                 debuggee = binder.bindToDebugee(debuggeeName + &quot; -vbs&quot;);
163             } else {
164                 debuggee = binder.bindToDebugee(debuggeeName);
165             }
166             if (debuggee == null) {
167                 log3(&quot;ERROR: no debuggee launched&quot;);
</pre>
<hr />
<pre>
272         cpRequest.setSuspendPolicy( EventRequest.SUSPEND_EVENT_THREAD);
273         cpRequest.addClassFilter(debuggeeName);
274 
275         cpRequest.enable();
276         vm.resume();
277         getEventSet();
278         cpRequest.disable();
279 
280         ClassPrepareEvent event = (ClassPrepareEvent) eventIterator.next();
281         debuggeeClass = event.referenceType();
282 
283         if (!debuggeeClass.name().equals(debuggeeName))
284            throw new JDITestRuntimeException(&quot;** Unexpected ClassName for ClassPrepareEvent **&quot;);
285 
286         log2(&quot;      received: ClassPrepareEvent for debuggeeClass&quot;);
287 
288         String bPointMethod = &quot;methodForCommunication&quot;;
289         String lineForComm  = &quot;lineForComm&quot;;
290         BreakpointRequest bpRequest;
291 
<span class="line-modified">292         ThreadReference mainThread = debuggee.threadByNameOrThrow(&quot;main&quot;);</span>
293 
294         bpRequest = settingBreakpoint(mainThread,
295                                       debuggeeClass,
296                                       bPointMethod, lineForComm, &quot;zero&quot;);
297         bpRequest.enable();
298 
299     //------------------------------------------------------  testing section
300 
301         log1(&quot;     TESTING BEGINS&quot;);
302 
303 
304         for (int i = 0; ; i++) {
305 
306             vm.resume();
307             breakpointForCommunication();
308 
309             int instruction = ((IntegerValue)
310                                (debuggeeClass.getValue(debuggeeClass.fieldByName(&quot;instruction&quot;)))).value();
311 
312             if (instruction == 0) {
</pre>
<hr />
<pre>
359             tsr1.disable();
360 
361             try {
362                 log2(&quot;...... tsr1.addThreadFilter(null);&quot;);
363                 log2(&quot;         NullPointerException is expected&quot;);
364                 tsr1.addThreadFilter(null);
365                 log3(&quot;ERROR: no NullPointerException &quot;);
366                 testExitCode = FAILED;
367             } catch ( NullPointerException e ) {
368                 log2(&quot;          NullPointerException&quot;);
369             } catch ( Exception e ) {
370                 log3(&quot;ERROR: unexpected Exception : &quot; + e);
371                 testExitCode = FAILED;
372             }
373             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
374         }
375         log1(&quot;    TESTING ENDS&quot;);
376         return;
377     }
378 














379    /*
380     * private BreakpointRequest settingBreakpoint(ThreadReference, ReferenceType,
381     *                                             String, String, String)
382     *
383     * It sets up a breakpoint at given line number within a given method in a given class
384     * for a given thread.
385     *
386     * Return value: BreakpointRequest object  in case of success
387     *
388     * JDITestRuntimeException   in case of an Exception thrown within the method
389     */
390 
391     private BreakpointRequest settingBreakpoint ( ThreadReference thread,
392                                                   ReferenceType testedClass,
393                                                   String methodName,
394                                                   String bpLine,
395                                                   String property)
396             throws JDITestRuntimeException {
397 
398         log2(&quot;......setting up a breakpoint:&quot;);
</pre>
<hr />
<pre>
442     private void getEventSet()
443                  throws JDITestRuntimeException {
444         try {
445 //            log2(&quot;       eventSet = eventQueue.remove(waitTime);&quot;);
446             eventSet = eventQueue.remove(waitTime);
447             if (eventSet == null) {
448                 throw new JDITestRuntimeException(&quot;** TIMEOUT while waiting for event **&quot;);
449             }
450 //            log2(&quot;       eventIterator = eventSet.eventIterator;&quot;);
451             eventIterator = eventSet.eventIterator();
452         } catch ( Exception e ) {
453             throw new JDITestRuntimeException(&quot;** EXCEPTION while waiting for event ** : &quot; + e);
454         }
455     }
456 
457 
458     private void breakpointForCommunication()
459                  throws JDITestRuntimeException {
460 
461         log2(&quot;breakpointForCommunication&quot;);
<span class="line-modified">462         while (true) {</span>
<span class="line-modified">463             getEventSet();</span>
<span class="line-modified">464             while (eventIterator.hasNext()) {</span>
<span class="line-modified">465                 Event event = eventIterator.nextEvent();</span>
<span class="line-modified">466                 if (event instanceof BreakpointEvent) {</span>
<span class="line-modified">467                     return;</span>
<span class="line-added">468                 } else if (event instanceof ThreadStartEvent) {</span>
<span class="line-added">469                     // It might be the case that while the thread start request was enabled</span>
<span class="line-added">470                     // some threads not related to the test ( e.g. JVMCI threads) were started</span>
<span class="line-added">471                     // and generated thread start events. We ignore these thread start events</span>
<span class="line-added">472                     // and keep waiting for a breakpoint event.</span>
<span class="line-added">473                     ThreadStartEvent tse = (ThreadStartEvent) event;</span>
<span class="line-added">474                     log2(&quot;ThreadStartEvent is received while waiting for a breakpoint&quot; +</span>
<span class="line-added">475                             &quot; event, thread: : &quot; + tse.thread().name());</span>
<span class="line-added">476                     continue;</span>
<span class="line-added">477                 }</span>
<span class="line-added">478                 throw new JDITestRuntimeException(&quot;** event IS NOT a breakpoint or a thread start **&quot;);</span>
<span class="line-added">479             }</span>
<span class="line-added">480         }</span>
481     }
482 
483 }
</pre>
</td>
</tr>
</table>
<center><a href="addthreadfilter001.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="addthreadfilter003.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
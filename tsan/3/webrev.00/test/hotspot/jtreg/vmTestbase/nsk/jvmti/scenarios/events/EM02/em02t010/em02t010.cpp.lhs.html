<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t010/em02t010.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
<a name="2" id="anc2"></a>
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* ============================================================================= */
 34 
 35 /* scaffold objects */
 36 static jvmtiEnv *jvmti = NULL;
 37 static jlong timeout = 0;
 38 static jrawMonitorID syncLock = NULL;
 39 
 40 /* constant names */
 41 #define STEP_NUMBER 3
 42 #define CLASS_NAME &quot;nsk/jvmti/scenarios/events/EM02/em02t010&quot;
 43 #define FIELD_ACC_NAME &quot;testedField_acc&quot;
 44 #define FIELD_MOD_NAME &quot;testedField_mod&quot;
 45 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 46 #define NUMBER_OF_INVOCATIONS 1000
 47 
 48 static int eventCount[JVMTI_EVENT_COUNT];
 49 static int newEventCount[JVMTI_EVENT_COUNT];
 50 
 51 /* ============================================================================= */
 52 
 53 static void
 54 showEventStatistics(int step) {
 55     int i;
 56     const char* str;
 57     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 58 
 59     NSK_DISPLAY0(&quot;\n&quot;);
 60     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 61     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 62     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 63         if (currentCounts[i] &gt; 0) {
 64             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 65             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 66         }
 67     }
 68 }
 69 
 70 /* ========================================================================== */
 71 
 72 int checkEvents(int step) {
 73     int i;
 74     jvmtiEvent curr;
<a name="3" id="anc3"></a><span class="line-modified"> 75     int result = NSK_TRUE;</span>
 76     int *currentCounts;
 77     int isExpected = 0;
 78 
 79     switch (step) {
 80         case 1:
 81             currentCounts = &amp;eventCount[0];
 82             break;
 83 
 84         case 2:
 85         case 3:
 86             currentCounts = &amp;newEventCount[0];
 87             break;
 88 
 89         default:
 90             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<a name="4" id="anc4"></a><span class="line-modified"> 91             return NSK_FALSE;</span>
 92     }
 93 
 94     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 95 
 96         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 97 
 98         switch (step) {
 99             case 1:
100                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
101                                 || (curr == JVMTI_EVENT_FIELD_MODIFICATION)
102                                 || (curr == JVMTI_EVENT_FIELD_ACCESS));
103                 break;
104 
105             case 2:
106                 isExpected = ((curr == JVMTI_EVENT_FIELD_MODIFICATION)
107                                 || (curr == JVMTI_EVENT_FIELD_ACCESS));
108                 break;
109 
110             case 3:
111                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
112                 break;
113         }
114 
115         if (isExpected) {
116             if (curr == JVMTI_EVENT_FIELD_MODIFICATION ||
117                                 curr == JVMTI_EVENT_FIELD_ACCESS) {
118                 if (currentCounts[i] != NUMBER_OF_INVOCATIONS) {
119                     NSK_COMPLAIN3(&quot;Unexpected number of %s events %d, expected value is %d\n&quot;,
120                                         TranslateEvent(curr),
121                                         currentCounts[i],
122                                         NUMBER_OF_INVOCATIONS);
<a name="5" id="anc5"></a><span class="line-modified">123                     result = NSK_FALSE;</span>
124                 }
125             } else {
126                 if (currentCounts[i] &lt; 1) {
127                         NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
128                                             currentCounts[i],
129                                             TranslateEvent(curr));
<a name="6" id="anc6"></a><span class="line-modified">130                     result = NSK_FALSE;</span>
131                 }
132             }
133 
134         } else {
135 
136             if (currentCounts[i] &gt; 0) {
137                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
138                                     TranslateEvent(curr),
139                                     currentCounts[i]);
<a name="7" id="anc7"></a><span class="line-modified">140                 result = NSK_FALSE;</span>
141             }
142         }
143     }
144 
145     return result;
146 }
147 
148 static void
149 changeCount(jvmtiEvent event, int *currentCounts) {
150 
151     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
152         nsk_jvmti_setFailStatus();
153 
154     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
155 
156     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
157         nsk_jvmti_setFailStatus();
158 
159 }
160 
161 /* ============================================================================= */
162 
163 /* callbacks */
164 JNIEXPORT void JNICALL
165 cbVMInit(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread) {
166     changeCount(JVMTI_EVENT_VM_INIT, &amp;eventCount[0]);
167 }
168 
169 JNIEXPORT void JNICALL
170 cbVMDeath(jvmtiEnv* jvmti, JNIEnv* jni_env) {
171     changeCount(JVMTI_EVENT_VM_DEATH, &amp;newEventCount[0]);
172     showEventStatistics(STEP_NUMBER);
173     if (!checkEvents(STEP_NUMBER))
174         nsk_jvmti_setFailStatus();
175 
176     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock)))
177         nsk_jvmti_setFailStatus();
178 
179 }
180 
181 void JNICALL
182 cbException(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
183                 jmethodID method, jlocation location, jobject exception,
184                 jmethodID catch_method, jlocation catch_location) {
185 
186     changeCount(JVMTI_EVENT_EXCEPTION, &amp;eventCount[0]);
187 }
188 
189 void JNICALL
190 cbExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
191                 jmethodID method, jlocation location, jobject exception) {
192 
193     changeCount(JVMTI_EVENT_EXCEPTION_CATCH, &amp;eventCount[0]);
194 }
195 
196 void JNICALL
197 cbSingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
198                 jmethodID method, jlocation location) {
199 
200     changeCount(JVMTI_EVENT_SINGLE_STEP, &amp;eventCount[0]);
201 }
202 
203 void JNICALL
204 cbFramePop(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
205                 jmethodID method, jboolean was_popped_by_exception) {
206     changeCount(JVMTI_EVENT_FRAME_POP, &amp;eventCount[0]);
207 }
208 
209 void JNICALL
210 cbBreakpoint(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
211                 jmethodID method, jlocation location) {
212     changeCount(JVMTI_EVENT_BREAKPOINT, &amp;eventCount[0]);
213 }
214 
215 void JNICALL
216 cbFieldAccess(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
217                 jmethodID method, jlocation location, jclass field_klass,
218                 jobject object, jfieldID field) {
219 
220     changeCount(JVMTI_EVENT_FIELD_ACCESS, &amp;eventCount[0]);
221 }
222 
223 void JNICALL
224 cbFieldModification(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
225                 jmethodID method, jlocation location, jclass field_klass,
226                 jobject object, jfieldID field, char signature_type,
227                 jvalue new_value) {
228 
229     changeCount(JVMTI_EVENT_FIELD_MODIFICATION, &amp;eventCount[0]);
230 }
231 
232 void JNICALL
233 cbNewFieldAccess(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
234                 jmethodID method, jlocation location, jclass field_klass,
235                 jobject object, jfieldID field) {
236 
237     changeCount(JVMTI_EVENT_FIELD_ACCESS, &amp;newEventCount[0]);
238 }
239 
240 void JNICALL
241 cbNewFieldModification(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
242                 jmethodID method, jlocation location, jclass field_klass,
243                 jobject object, jfieldID field, char signature_type,
244                 jvalue new_value) {
245 
246     changeCount(JVMTI_EVENT_FIELD_MODIFICATION, &amp;newEventCount[0]);
247 }
248 
249 void JNICALL
250 cbMethodEntry(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
251                 jmethodID method) {
252 
253     changeCount(JVMTI_EVENT_METHOD_ENTRY, &amp;eventCount[0]);
254 }
255 
256 void JNICALL
257 cbMethodExit(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
258                 jmethodID method, jboolean was_popped_by_exception,
259                 jvalue return_value) {
260 
261     changeCount(JVMTI_EVENT_METHOD_EXIT, &amp;eventCount[0]);
262 }
263 
264 void JNICALL
265 cbNativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env,jthread thread,
266                 jmethodID method, void* address, void** new_address_ptr) {
267     changeCount(JVMTI_EVENT_NATIVE_METHOD_BIND, &amp;eventCount[0]);
268 }
269 
270 void JNICALL
271 cbMonitorWait(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
272                     jobject object, jlong tout) {
273 
274     changeCount(JVMTI_EVENT_MONITOR_WAIT, &amp;eventCount[0]);
275 }
276 
277 void JNICALL
278 cbMonitorWaited(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
279                     jobject object, jboolean timed_out) {
280 
281     changeCount(JVMTI_EVENT_MONITOR_WAITED, &amp;eventCount[0]);
282 }
283 
284 JNIEXPORT void JNICALL
285 cbMonitorContendedEnter(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread,
286                             jobject object) {
287 
288     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTER, &amp;eventCount[0]);
289 }
290 
291 void JNICALL
292 cbMonitorContendedEntered(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
293                             jobject object) {
294 
295     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, &amp;eventCount[0]);
296 }
297 
298 void JNICALL
299 cbCompiledMethodLoad(jvmtiEnv *jvmti_env, jmethodID method, jint code_size,
300                 const void* code_addr, jint map_length,
301                 const jvmtiAddrLocationMap* map, const void* compile_info) {
302     changeCount(JVMTI_EVENT_COMPILED_METHOD_LOAD, &amp;eventCount[0]);
303 }
304 
305 void JNICALL
306 cbCompiledMethodUnload(jvmtiEnv *jvmti_env, jmethodID method,
307                 const void* code_addr) {
308     changeCount(JVMTI_EVENT_COMPILED_METHOD_UNLOAD, &amp;eventCount[0]);
309 }
310 
311 void JNICALL
312 cbGarbageCollectionStart(jvmtiEnv *jvmti_env) {
313     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_START, &amp;eventCount[0]);
314 }
315 
316 void JNICALL
317 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
318     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
319 }
320 
321 void JNICALL
322 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
323 
324     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
325 }
326 
327 void JNICALL
328 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
329                     jobject object, jclass object_klass, jlong size) {
330 
331     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
332 }
333 
334 /* ============================================================================= */
335 
<a name="8" id="anc8"></a><span class="line-modified">336 static int enableEvent(jvmtiEvent event) {</span>
337 
338     if (nsk_jvmti_isOptionalEvent(event)
339             &amp;&amp; (event != JVMTI_EVENT_FIELD_MODIFICATION)
340             &amp;&amp; (event != JVMTI_EVENT_FIELD_ACCESS)) {
341         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
342                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
343             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
344                 TranslateEvent(event));
<a name="9" id="anc9"></a><span class="line-modified">345             return NSK_FALSE;</span>
346         }
347     } else {
348         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
349             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
350                 TranslateEvent(event));
<a name="10" id="anc10"></a><span class="line-modified">351             return NSK_FALSE;</span>
352         }
353     }
354 
<a name="11" id="anc11"></a><span class="line-modified">355     return NSK_TRUE;</span>
356 }
357 
358 /**
359  * Enable or disable tested events.
360  */
<a name="12" id="anc12"></a><span class="line-modified">361 static int enableEventList() {</span>
362 
363     int i, result;
364 
365     result = enableEvent(JVMTI_EVENT_VM_INIT);
366 
367     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
368 
369     /* enabling optional events */
370     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
371         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
372 
373         if (nsk_jvmti_isOptionalEvent(event))
374             result = result &amp;&amp; enableEvent(event);
375     }
376 
<a name="13" id="anc13"></a><span class="line-modified">377     if (result == NSK_FALSE) {</span>
378         nsk_jvmti_setFailStatus();
<a name="14" id="anc14"></a><span class="line-modified">379         return NSK_FALSE;</span>
380     }
381 
<a name="15" id="anc15"></a><span class="line-modified">382     return NSK_TRUE;</span>
383 }
384 
385 /* ============================================================================= */
386 
<a name="16" id="anc16"></a><span class="line-modified">387 static int</span>
<span class="line-removed">388 setCallBacks(int step) {</span>
389 
390     int i;
391 
392     jvmtiEventCallbacks eventCallbacks;
393     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
394 
395     switch (step) {
396         case 1:
397             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
398                 eventCount[i] = 0;
399             }
400 
401             eventCallbacks.VMInit                    = cbVMInit;
402             eventCallbacks.Exception                 = cbException;
403             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
404             eventCallbacks.SingleStep                = cbSingleStep;
405             eventCallbacks.FramePop                  = cbFramePop;
406             eventCallbacks.Breakpoint                = cbBreakpoint;
407             eventCallbacks.FieldAccess               = cbFieldAccess;
408             eventCallbacks.FieldModification         = cbFieldModification;
409             eventCallbacks.MethodEntry               = cbMethodEntry;
410             eventCallbacks.MethodExit                = cbMethodExit;
411             eventCallbacks.NativeMethodBind          = cbNativeMethodBind;
412             eventCallbacks.CompiledMethodLoad        = cbCompiledMethodLoad;
413             eventCallbacks.CompiledMethodUnload      = cbCompiledMethodUnload;
414             eventCallbacks.MonitorWait               = cbMonitorWait;
415             eventCallbacks.MonitorWaited             = cbMonitorWaited;
416             eventCallbacks.MonitorContendedEnter     = cbMonitorContendedEnter;
417             eventCallbacks.MonitorContendedEntered   = cbMonitorContendedEntered;
418             eventCallbacks.GarbageCollectionStart    = cbGarbageCollectionStart;
419             eventCallbacks.GarbageCollectionFinish   = cbGarbageCollectionFinish;
420             eventCallbacks.ObjectFree                = cbObjectFree;
421             eventCallbacks.VMObjectAlloc             = cbVMObjectAlloc;
422             break;
423 
424         case 2:
425             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
426                 newEventCount[i] = 0;
427             }
428 
429             eventCallbacks.FieldAccess               = cbNewFieldAccess;
430             eventCallbacks.FieldModification         = cbNewFieldModification;
431             break;
432 
433         case 3:
434             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
435                 newEventCount[i] = 0;
436             }
437 
438             eventCallbacks.VMDeath                   = cbVMDeath;
439             break;
440 
441     }
442     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<a name="17" id="anc17"></a><span class="line-modified">443         return NSK_FALSE;</span>
444 
<a name="18" id="anc18"></a><span class="line-modified">445     return NSK_TRUE;</span>
446 }
447 
448 /* ============================================================================= */
449 
450 /** Agent algorithm. */
451 static void JNICALL
452 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
453 
<a name="19" id="anc19"></a>
454     int i;
455     jfieldID field_accID, field_modID;
456     jclass cls;
457 
458 
459     if (!nsk_jvmti_waitForSync(timeout))
460         return;
461 
<a name="20" id="anc20"></a><span class="line-modified">462     cls = agentJNI-&gt;FindClass(CLASS_NAME);</span>
<span class="line-modified">463     if (!NSK_JNI_VERIFY(agentJNI, cls != NULL))</span>
<span class="line-modified">464         return;</span>
<span class="line-removed">465 </span>
<span class="line-removed">466     field_accID = agentJNI-&gt;GetStaticFieldID(cls, FIELD_ACC_NAME, &quot;I&quot;);</span>
<span class="line-removed">467     if (!NSK_JNI_VERIFY(agentJNI, field_accID != NULL))</span>
<span class="line-removed">468         return;</span>
<span class="line-removed">469 </span>
<span class="line-removed">470     field_modID = agentJNI-&gt;GetStaticFieldID(cls, FIELD_MOD_NAME, &quot;I&quot;);</span>
<span class="line-removed">471     if (!NSK_JNI_VERIFY(agentJNI, field_modID != NULL))</span>
<span class="line-removed">472         return;</span>
473 
474     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetFieldModificationWatch(cls, field_modID)))
475         return;
476 
477     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetFieldAccessWatch(cls, field_accID)))
478         return;
479 
480     if (!nsk_jvmti_resumeSync())
481         return;
482 
483     for (i = 1; i &lt;= STEP_NUMBER; i++) {
484 
485         if (!nsk_jvmti_waitForSync(timeout))
486             return;
487 
488         if (i &lt; STEP_NUMBER) {
489             showEventStatistics(i);
490             if (!checkEvents(i))
491                 nsk_jvmti_setFailStatus();
492 
493             if (!setCallBacks(i + 1)) {
494                 return;
495             }
496         }
497 
498         if (!nsk_jvmti_resumeSync())
499             return;
500     }
501 
502 }
503 
504 /* ============================================================================= */
505 
506 /** Agent library initialization. */
507 #ifdef STATIC_BUILD
508 JNIEXPORT jint JNICALL Agent_OnLoad_em02t010(JavaVM *jvm, char *options, void *reserved) {
509     return Agent_Initialize(jvm, options, reserved);
510 }
511 JNIEXPORT jint JNICALL Agent_OnAttach_em02t010(JavaVM *jvm, char *options, void *reserved) {
512     return Agent_Initialize(jvm, options, reserved);
513 }
514 JNIEXPORT jint JNI_OnLoad_em02t010(JavaVM *jvm, char *options, void *reserved) {
515     return JNI_VERSION_1_8;
516 }
517 #endif
518 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
519 
520     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
521         return JNI_ERR;
522 
523     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
524 
525     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
526     if (!NSK_VERIFY(jvmti != NULL))
527         return JNI_ERR;
528 
529     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock))) {
530         nsk_jvmti_setFailStatus();
531         return JNI_ERR;
532     }
533 
534     {
535         jvmtiCapabilities caps;
536         memset(&amp;caps, 0, sizeof(caps));
537 
538         caps.can_generate_field_modification_events = 1;
539         caps.can_generate_field_access_events = 1;
540         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
541             return JNI_ERR;
542     }
543 
544     if (!setCallBacks(1)) {
545         return JNI_ERR;
546     }
547 
548     if (!enableEventList()) {
549         return JNI_ERR;
550     }
551 
552     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
553         return JNI_ERR;
554 
555     return JNI_OK;
556 }
557 
558 /* ============================================================================= */
559 
560 
561 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
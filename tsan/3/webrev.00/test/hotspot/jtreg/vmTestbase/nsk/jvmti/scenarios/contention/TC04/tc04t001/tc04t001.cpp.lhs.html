<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/contention/TC04/tc04t001/tc04t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdlib.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &quot;jni_tools.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 /* ========================================================================== */
 33 
 34 /* scaffold objects */
 35 static jlong timeout = 0;
 36 
 37 /* test objects */
 38 static jclass object_M = NULL;
 39 static volatile int waitEventsCount = 0;
 40 static volatile int waitedEventsCount = 0;
 41 static volatile int enterEventsCount = 0;
 42 static volatile int enteredEventsCount = 0;
 43 static jrawMonitorID syncLock = NULL;
 44 
 45 
 46 static jboolean lockSyncLock(jvmtiEnv* jvmti) {
 47     jboolean status = NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock));
 48     if (!status)
 49         nsk_jvmti_setFailStatus();
 50     return status;
 51 }
 52 
 53 static void unlockSyncLock(jvmtiEnv* jvmti) {
 54     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
 55         nsk_jvmti_setFailStatus();
 56 }
 57 
 58 
 59 /* ========================================================================== */
 60 
 61 void JNICALL
 62 MonitorWait(jvmtiEnv *jvmti, JNIEnv* jni,
 63         jthread thr, jobject obj, jlong tout) {
 64 
 65     if (!NSK_VERIFY(thr != NULL)) {
 66         nsk_jvmti_setFailStatus();
 67         return;
 68     }
 69 
 70     if (!NSK_VERIFY(obj != NULL)) {
 71         nsk_jvmti_setFailStatus();
 72         return;
 73     }
 74 
 75     /* check if event is for tested object */
 76     if (jni-&gt;IsInstanceOf(obj, object_M)) {
 77         if (lockSyncLock(jvmti)) {
 78             waitEventsCount++;
 79             unlockSyncLock(jvmti);
 80         }
 81     }
 82 }
 83 
 84 void JNICALL
 85 MonitorWaited(jvmtiEnv *jvmti, JNIEnv* jni,
 86         jthread thr, jobject obj, jboolean timed_out) {
 87 
 88     if (!NSK_VERIFY(thr != NULL)) {
 89         nsk_jvmti_setFailStatus();
 90         return;
 91     }
 92 
 93     if (!NSK_VERIFY(obj != NULL)) {
 94         nsk_jvmti_setFailStatus();
 95         return;
 96     }
 97 
 98     /* check if event is for tested object */
 99     if (jni-&gt;IsInstanceOf(obj, object_M)) {
100         if (lockSyncLock(jvmti)) {
101             waitedEventsCount++;
102             unlockSyncLock(jvmti);
103         }
104     }
105 }
106 
107 void JNICALL
108 MonitorContendedEnter(jvmtiEnv *jvmti, JNIEnv* jni, jthread thr, jobject obj) {
109 
110     if (!NSK_VERIFY(thr != NULL)) {
111         nsk_jvmti_setFailStatus();
112         return;
113     }
114 
115     if (!NSK_VERIFY(obj != NULL)) {
116         nsk_jvmti_setFailStatus();
117         return;
118     }
119 
120     /* check if event is for tested object */
121     if (jni-&gt;IsSameObject(object_M, obj)) {
<a name="2" id="anc2"></a><span class="line-removed">122         jvmtiMonitorUsage usageInfo;</span>
<span class="line-removed">123 </span>
124         if (lockSyncLock(jvmti)) {
125             enterEventsCount++;
126             unlockSyncLock(jvmti);
127         }
<a name="3" id="anc3"></a><span class="line-removed">128 </span>
<span class="line-removed">129         if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetObjectMonitorUsage(obj, &amp;usageInfo))) {</span>
<span class="line-removed">130             nsk_jvmti_setFailStatus();</span>
<span class="line-removed">131         } else if (usageInfo.owner != NULL) {</span>
<span class="line-removed">132             if (!NSK_JVMTI_VERIFY(jvmti-&gt;InterruptThread(usageInfo.owner)))</span>
<span class="line-removed">133                 nsk_jvmti_setFailStatus();</span>
<span class="line-removed">134         }</span>
135     }
136 }
137 
138 void JNICALL
139 MonitorContendedEntered(jvmtiEnv *jvmti, JNIEnv* jni, jthread thr, jobject obj) {
140 
141     if (!NSK_VERIFY(thr != NULL)) {
142         nsk_jvmti_setFailStatus();
143         return;
144     }
145 
146     if (!NSK_VERIFY(obj != NULL)) {
147         nsk_jvmti_setFailStatus();
148         return;
149     }
150 
151     /* check if event is for tested object */
152     if (jni-&gt;IsSameObject(object_M, obj)) {
153         if (lockSyncLock(jvmti)) {
154             enteredEventsCount++;
155             unlockSyncLock(jvmti);
156         }
157     }
158 }
159 
160 /* ========================================================================== */
161 
162 static int prepare(jvmtiEnv* jvmti, JNIEnv* jni) {
163     const char* CLASS_NAME = &quot;nsk/jvmti/scenarios/contention/TC04/tc04t001Thread&quot;;
164 
165     NSK_DISPLAY0(&quot;Obtain tested object from debugee thread class\n&quot;);
166 
167     if (!NSK_JNI_VERIFY(jni, (object_M = jni-&gt;FindClass(CLASS_NAME)) != NULL))
168         return NSK_FALSE;
169 
170     if (!NSK_JNI_VERIFY(jni, (object_M = (jclass)jni-&gt;NewGlobalRef(object_M)) != NULL))
171         return NSK_FALSE;
172 
173     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock)))
174         return NSK_FALSE;
175 
176     /* enable MonitorWait event */
177     if (!NSK_JVMTI_VERIFY(
178             jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))
179         nsk_jvmti_setFailStatus();
180 
181     /* enable MonitorWaited event */
182     if (!NSK_JVMTI_VERIFY(
183             jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))
184         nsk_jvmti_setFailStatus();
185 
186     /* enable MonitorContendedEnter event */
187     if (!NSK_JVMTI_VERIFY(
188             jvmti-&gt;SetEventNotificationMode(
189                 JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)))
190         nsk_jvmti_setFailStatus();
191 
192     /* enable MonitorContendedEntered event */
193     if (!NSK_JVMTI_VERIFY(
194             jvmti-&gt;SetEventNotificationMode(
195                 JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL)))
196         nsk_jvmti_setFailStatus();
197 
198     return NSK_TRUE;
199 }
200 
201 static int clean(jvmtiEnv* jvmti, JNIEnv* jni) {
202 
203     /* disable MonitorWait event */
204     if (!NSK_JVMTI_VERIFY(
205             jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))
206         nsk_jvmti_setFailStatus();
207 
208     /* disable MonitorWaited event */
209     if (!NSK_JVMTI_VERIFY(
210             jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))
211         nsk_jvmti_setFailStatus();
212 
213     /* disable MonitorContendedEnter event */
214     if (!NSK_JVMTI_VERIFY(
215             jvmti-&gt;SetEventNotificationMode(
216                 JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)))
217         nsk_jvmti_setFailStatus();
218 
219     /* disable MonitorContendedEntered event */
220     if (!NSK_JVMTI_VERIFY(
221             jvmti-&gt;SetEventNotificationMode(
222                 JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL)))
223         nsk_jvmti_setFailStatus();
224 
225     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock)))
226         nsk_jvmti_setFailStatus();
227 
228     return NSK_TRUE;
229 }
230 
231 /* ========================================================================== */
232 
233 /* agent algorithm */
234 static void JNICALL
235 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
236 
237     /* wait for initial sync */
238     if (!nsk_jvmti_waitForSync(timeout))
239         return;
240 
241     if (!prepare(jvmti, jni)) {
242         nsk_jvmti_setFailStatus();
243         return;
244     }
245 
246     /* resume debugee */
247     if (!(NSK_VERIFY(nsk_jvmti_resumeSync()) &amp;&amp;
248           NSK_VERIFY(nsk_jvmti_waitForSync(timeout))))
249         return;
250 
251     // lock
252     if (lockSyncLock(jvmti)) {
253         NSK_DISPLAY1(&quot;Number of MonitorWait events: %d\n&quot;, waitEventsCount);
254         if (!NSK_VERIFY(waitEventsCount &gt;= 200)) {
255             nsk_jvmti_setFailStatus();
256             NSK_COMPLAIN1(&quot;Number of MonitorWait events: %d\n&quot;, waitEventsCount);
257         }
258 
259         NSK_DISPLAY1(&quot;Number of MonitorWaited events: %d\n&quot;, waitedEventsCount);
260         if (!NSK_VERIFY(waitedEventsCount &gt;= 200)) {
261             nsk_jvmti_setFailStatus();
262             NSK_COMPLAIN1(&quot;Number of MonitorWaited events: %d\n&quot;, waitedEventsCount);
263         }
264 
265         NSK_DISPLAY1(&quot;Number of MonitorContendedEnter events: %d\n&quot;,
266             enterEventsCount);
267         if (!NSK_VERIFY(enterEventsCount == 199)) {
268             nsk_jvmti_setFailStatus();
269             NSK_COMPLAIN1(&quot;Number of MonitorContendedEnter events: %d\n&quot;,
270                 enterEventsCount);
271         }
272 
273         NSK_DISPLAY1(&quot;Number of MonitorContendedEntered events: %d\n&quot;,
274             enteredEventsCount);
275         if (!NSK_VERIFY(enteredEventsCount == 199)) {
276             nsk_jvmti_setFailStatus();
277             NSK_COMPLAIN1(&quot;Number of MonitorContendedEntered events: %d\n&quot;,
278                 enteredEventsCount);
279         }
280         unlockSyncLock(jvmti);
281     }
282 
283     if (!clean(jvmti, jni)) {
284         nsk_jvmti_setFailStatus();
285         return;
286     }
287 
288     /* resume debugee after last sync */
289     if (!nsk_jvmti_resumeSync())
290         return;
291 }
292 
293 /* ========================================================================== */
294 
295 /* agent library initialization */
296 #ifdef STATIC_BUILD
297 JNIEXPORT jint JNICALL Agent_OnLoad_tc04t001(JavaVM *jvm, char *options, void *reserved) {
298     return Agent_Initialize(jvm, options, reserved);
299 }
300 JNIEXPORT jint JNICALL Agent_OnAttach_tc04t001(JavaVM *jvm, char *options, void *reserved) {
301     return Agent_Initialize(jvm, options, reserved);
302 }
303 JNIEXPORT jint JNI_OnLoad_tc04t001(JavaVM *jvm, char *options, void *reserved) {
304     return JNI_VERSION_1_8;
305 }
306 #endif
307 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
308     jvmtiEnv* jvmti = NULL;
309     jvmtiCapabilities caps;
310     jvmtiEventCallbacks callbacks;
311 
312     /* init framework and parse options */
313     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
314         return JNI_ERR;
315 
316     timeout = nsk_jvmti_getWaitTime() * 60000;
317     NSK_DISPLAY1(&quot;Timeout: %d msc\n&quot;, (int)timeout);
318 
319     /* create JVMTI environment */
320     if (!NSK_VERIFY((jvmti =
321             nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))
322         return JNI_ERR;
323 
324     /* add capabilities */
325     memset(&amp;caps, 0, sizeof(caps));
326     caps.can_generate_monitor_events = 1;
327     caps.can_get_monitor_info = 1;
328     caps.can_signal_thread = 1;
329     if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
330         return JNI_ERR;
331 
332     memset(&amp;callbacks, 0, sizeof(callbacks));
333     callbacks.MonitorWait = &amp;MonitorWait;
334     callbacks.MonitorWaited = &amp;MonitorWaited;
335     callbacks.MonitorContendedEnter = &amp;MonitorContendedEnter;
336     callbacks.MonitorContendedEntered = &amp;MonitorContendedEntered;
337     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks))))
338         return JNI_ERR;
339 
340     /* register agent proc and arg */
341     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
342         return JNI_ERR;
343 
344     return JNI_OK;
345 }
346 
<a name="4" id="anc4"></a>




347 /* ========================================================================== */
348 
349 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
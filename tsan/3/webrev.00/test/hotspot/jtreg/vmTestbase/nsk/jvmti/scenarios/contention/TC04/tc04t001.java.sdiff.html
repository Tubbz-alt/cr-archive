<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/contention/TC04/tc04t001.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../TC02/tc02t001/tc02t001.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="tc04t001/tc04t001.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/contention/TC04/tc04t001.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jvmti.scenarios.contention.TC04;
 25 
 26 import java.io.PrintStream;

 27 
 28 import nsk.share.*;
 29 import nsk.share.jvmti.*;
 30 
 31 public class tc04t001 extends DebugeeClass {
 32 
 33     final static int THREADS_LIMIT = 2;

 34 
 35     // run test from command line
 36     public static void main(String argv[]) {
 37         argv = nsk.share.jvmti.JVMTITest.commonInit(argv);
 38 
 39         // JCK-compatible exit
 40         System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);
 41     }
 42 
 43     // run test from JCK-compatible environment
 44     public static int run(String argv[], PrintStream out) {
 45         return new tc04t001().runIt(argv, out);
 46     }
 47 
 48     /* =================================================================== */
 49 
 50     // scaffold objects
 51     ArgumentHandler argHandler = null;
 52     Log log = null;
 53     int status = Consts.TEST_PASSED;
 54     long timeout = 0;
 55 
 56     // run debuggee
 57     public int runIt(String argv[], PrintStream out) {
 58         argHandler = new ArgumentHandler(argv);
 59         log = new Log(out, argHandler);
 60         timeout = argHandler.getWaitTime() * 60 * 1000;
 61         log.display(&quot;Timeout = &quot; + timeout + &quot; msc.&quot;);
 62 
 63         tc04t001Thread threads[] = new tc04t001Thread[THREADS_LIMIT];
 64         status = checkStatus(status);
 65         for (int i = 0; i &lt; THREADS_LIMIT; i++) {
 66             threads[i] = new tc04t001Thread(i);
 67             threads[i].start();
 68         }
 69 
 70         try {
<span class="line-modified"> 71             for (int i = 0; i &lt; THREADS_LIMIT; i++) {</span>
<span class="line-modified"> 72                 threads[i].join(timeout/THREADS_LIMIT);</span>
 73             }
 74         } catch (InterruptedException e) {
 75             throw new Failure(e);
 76         }
 77 
 78         status = checkStatus(status);
 79 
 80         log.display(&quot;Debugee finished, value: &quot; + tc04t001Thread.value);
 81         if (tc04t001Thread.value !=
 82                 THREADS_LIMIT*tc04t001Thread.INCREMENT_LIMIT) {
 83             log.complain(&quot;Wrong value: &quot; + tc04t001Thread.value +
 84                 &quot;, expected: &quot; + THREADS_LIMIT*tc04t001Thread.INCREMENT_LIMIT);
 85             status = Consts.TEST_FAILED;
 86         }
<span class="line-removed"> 87 </span>
<span class="line-removed"> 88 /* DEBUG -- to check if the threads taking turns in right order</span>
<span class="line-removed"> 89         boolean race = false;</span>
<span class="line-removed"> 90         for (int i = 1; i &lt; 2*tc04t001Thread.INCREMENT_LIMIT; i++) {</span>
<span class="line-removed"> 91              if (tc04t001Thread.passOrder[i] == tc04t001Thread.passOrder[i-1]) {</span>
<span class="line-removed"> 92                 race = true;</span>
<span class="line-removed"> 93                 System.out.println(&quot;Race condition in the test:&quot;);</span>
<span class="line-removed"> 94                 System.out.println(&quot;passOrder[&quot; + (i-1) + &quot;]:&quot;</span>
<span class="line-removed"> 95                     + tc04t001Thread.passOrder[i-1]);</span>
<span class="line-removed"> 96                 System.out.println(&quot;passOrder[&quot; + (i) + &quot;]:&quot;</span>
<span class="line-removed"> 97                     + tc04t001Thread.passOrder[i]);</span>
<span class="line-removed"> 98              }</span>
<span class="line-removed"> 99         }</span>
<span class="line-removed">100         if (race)</span>
<span class="line-removed">101             System.out.println(&quot;There was a race condition in the test.&quot;);</span>
<span class="line-removed">102 */</span>
<span class="line-removed">103 </span>
104         return status;
105     }
106 }
107 
108 /* =================================================================== */
109 
110 class tc04t001Thread extends Thread {
111 
112     final static int INCREMENT_LIMIT = 100;
113     final static int DELAY = 1000;
114 
115     static volatile int value = 0;
116 
117     static Flicker flicker = new Flicker();
<span class="line-removed">118 /* DEBUG -- to check if the threads taking turns in right order</span>
<span class="line-removed">119     static volatile int iter = 0;</span>
<span class="line-removed">120     static volatile int passOrder[] =</span>
<span class="line-removed">121         new int[INCREMENT_LIMIT*tc04t001.THREADS_LIMIT];</span>
<span class="line-removed">122 */</span>
123 
124     private int id;


125 
126     public tc04t001Thread(int i) {
127         super(&quot;Debuggee Thread &quot; + i);
128         id = i;
129     }
130 
131     public synchronized void run() {
132         for (int i = 0; i &lt; INCREMENT_LIMIT; i++) {
133             flicker.waitFor(id);
134             increment(id);
135             try {
136                 wait(1);
137             } catch (InterruptedException e) {}
138         }

139     }
140 
141     static synchronized void increment(int i) {
<span class="line-removed">142 /* DEBUG -- to check if the threads taking turns in right order</span>
<span class="line-removed">143         passOrder[iter++] = i;</span>
<span class="line-removed">144 */</span>
145         flicker.unlock(i);
146         int temp = value;
<span class="line-modified">147         for (int j = 0; j &lt; DELAY; j++) ;</span>
<span class="line-modified">148         try {</span>
<span class="line-modified">149             sleep(500);</span>
<span class="line-modified">150         } catch (InterruptedException e) {}</span>



















151         value = temp + 1;

152     }
153 }
154 
155 class Flicker {
156 
157     private int owner = -1;
158 
159     public synchronized void waitFor(int owner) {
160         while (this.owner == owner) {
161             try {
162                 wait();
163             } catch (InterruptedException e) {}
164         }
165     }
166 
167     public synchronized void unlock(int owner) {
168         if (this.owner == owner)
169             throw new IllegalStateException(&quot;the same owner: &quot; + owner);
170 
171         this.owner = owner;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jvmti.scenarios.contention.TC04;
 25 
 26 import java.io.PrintStream;
<span class="line-added"> 27 import java.util.concurrent.*;</span>
 28 
 29 import nsk.share.*;
 30 import nsk.share.jvmti.*;
 31 
 32 public class tc04t001 extends DebugeeClass {
 33 
 34     final static int THREADS_LIMIT = 2;
<span class="line-added"> 35     final static CountDownLatch threadsDoneSignal = new CountDownLatch(THREADS_LIMIT);</span>
 36 
 37     // run test from command line
 38     public static void main(String argv[]) {
 39         argv = nsk.share.jvmti.JVMTITest.commonInit(argv);
 40 
 41         // JCK-compatible exit
 42         System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);
 43     }
 44 
 45     // run test from JCK-compatible environment
 46     public static int run(String argv[], PrintStream out) {
 47         return new tc04t001().runIt(argv, out);
 48     }
 49 
 50     /* =================================================================== */
 51 
 52     // scaffold objects
 53     ArgumentHandler argHandler = null;
 54     Log log = null;
 55     int status = Consts.TEST_PASSED;
 56     long timeout = 0;
 57 
 58     // run debuggee
 59     public int runIt(String argv[], PrintStream out) {
 60         argHandler = new ArgumentHandler(argv);
 61         log = new Log(out, argHandler);
 62         timeout = argHandler.getWaitTime() * 60 * 1000;
 63         log.display(&quot;Timeout = &quot; + timeout + &quot; msc.&quot;);
 64 
 65         tc04t001Thread threads[] = new tc04t001Thread[THREADS_LIMIT];
 66         status = checkStatus(status);
 67         for (int i = 0; i &lt; THREADS_LIMIT; i++) {
 68             threads[i] = new tc04t001Thread(i);
 69             threads[i].start();
 70         }
 71 
 72         try {
<span class="line-modified"> 73             if (!threadsDoneSignal.await(timeout, TimeUnit.MILLISECONDS)) {</span>
<span class="line-modified"> 74                 throw new RuntimeException(&quot;Threads timeout&quot;);</span>
 75             }
 76         } catch (InterruptedException e) {
 77             throw new Failure(e);
 78         }
 79 
 80         status = checkStatus(status);
 81 
 82         log.display(&quot;Debugee finished, value: &quot; + tc04t001Thread.value);
 83         if (tc04t001Thread.value !=
 84                 THREADS_LIMIT*tc04t001Thread.INCREMENT_LIMIT) {
 85             log.complain(&quot;Wrong value: &quot; + tc04t001Thread.value +
 86                 &quot;, expected: &quot; + THREADS_LIMIT*tc04t001Thread.INCREMENT_LIMIT);
 87             status = Consts.TEST_FAILED;
 88         }

















 89         return status;
 90     }
 91 }
 92 
 93 /* =================================================================== */
 94 
 95 class tc04t001Thread extends Thread {
 96 
 97     final static int INCREMENT_LIMIT = 100;
 98     final static int DELAY = 1000;
 99 
100     static volatile int value = 0;
101 
102     static Flicker flicker = new Flicker();





103 
104     private int id;
<span class="line-added">105     private static volatile int lastEnterEventsCount;</span>
<span class="line-added">106     private static native   int enterEventsCount();</span>
107 
108     public tc04t001Thread(int i) {
109         super(&quot;Debuggee Thread &quot; + i);
110         id = i;
111     }
112 
113     public synchronized void run() {
114         for (int i = 0; i &lt; INCREMENT_LIMIT; i++) {
115             flicker.waitFor(id);
116             increment(id);
117             try {
118                 wait(1);
119             } catch (InterruptedException e) {}
120         }
<span class="line-added">121         tc04t001.threadsDoneSignal.countDown();</span>
122     }
123 
124     static synchronized void increment(int i) {



125         flicker.unlock(i);
126         int temp = value;
<span class="line-modified">127         boolean done = false;</span>
<span class="line-modified">128 </span>
<span class="line-modified">129         // Wait in a loop for a MonitorContendedEnter event.</span>
<span class="line-modified">130         // Timeout is: 20ms * DELAY.</span>
<span class="line-added">131         for (int j = 0; j &lt; DELAY; j++) {</span>
<span class="line-added">132             try {</span>
<span class="line-added">133                 sleep(20);</span>
<span class="line-added">134             } catch (InterruptedException e) {}</span>
<span class="line-added">135 </span>
<span class="line-added">136             done = (tc04t001.threadsDoneSignal.getCount() == 1);</span>
<span class="line-added">137             if (done) {</span>
<span class="line-added">138                 break; // This thread is the only remaining thread, no more contention</span>
<span class="line-added">139             }</span>
<span class="line-added">140             if (enterEventsCount() &gt; lastEnterEventsCount) {</span>
<span class="line-added">141                 System.out.println(&quot;Thread-&quot; + i + &quot;: increment event: &quot; + enterEventsCount());</span>
<span class="line-added">142                 break; // Got an expected MonitorContendedEnter event</span>
<span class="line-added">143             }</span>
<span class="line-added">144         }</span>
<span class="line-added">145 </span>
<span class="line-added">146         if (!done &amp;&amp; enterEventsCount() == lastEnterEventsCount) {</span>
<span class="line-added">147             String msg = &quot;Timeout in waiting for a MonitorContendedEnter event&quot;;</span>
<span class="line-added">148             throw new RuntimeException(msg);</span>
<span class="line-added">149         }</span>
150         value = temp + 1;
<span class="line-added">151         lastEnterEventsCount = enterEventsCount();</span>
152     }
153 }
154 
155 class Flicker {
156 
157     private int owner = -1;
158 
159     public synchronized void waitFor(int owner) {
160         while (this.owner == owner) {
161             try {
162                 wait();
163             } catch (InterruptedException e) {}
164         }
165     }
166 
167     public synchronized void unlock(int owner) {
168         if (this.owner == owner)
169             throw new IllegalStateException(&quot;the same owner: &quot; + owner);
170 
171         this.owner = owner;
</pre>
</td>
</tr>
</table>
<center><a href="../TC02/tc02t001/tc02t001.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="tc04t001/tc04t001.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/test/hotspot/jtreg/vmTestbase/nsk/jvmti/FramePop/framepop002/framepop002.cpp b/test/hotspot/jtreg/vmTestbase/nsk/jvmti/FramePop/framepop002/framepop002.cpp
--- a/test/hotspot/jtreg/vmTestbase/nsk/jvmti/FramePop/framepop002/framepop002.cpp
+++ b/test/hotspot/jtreg/vmTestbase/nsk/jvmti/FramePop/framepop002/framepop002.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -60,10 +60,13 @@
 static int push_count = 0;
 static int thr_count = 0;
 static int max_depth = 0;
 static thr threads[MAX_THREADS];
 
+static volatile int callbacksEnabled = NSK_FALSE;
+static jrawMonitorID agent_lock;
+
 static
 int isTestThread(jvmtiEnv *jvmti_env, jthread thr) {
     jvmtiError err;
     jvmtiThreadInfo inf;
     const char* TEST_THREAD_NAME_BASE = "Test Thread";
@@ -209,16 +212,24 @@
     jboolean isNative;
     jint frameCount;
 
     if (watch_events == JNI_FALSE) return;
 
+    jvmti->RawMonitorEnter(agent_lock);
+
+    if (!callbacksEnabled) {
+        jvmti->RawMonitorExit(agent_lock);
+        return;
+    }
+
     err = jvmti_env->GetFrameCount(thr, &frameCount);
     if (err != JVMTI_ERROR_NONE) {
         printf("(GetFrameCount#entry) unexpected error: %s (%d)\n",
                TranslateError(err), err);
         printInfo(jvmti_env, thr, method, frameCount);
         result = STATUS_FAILED;
+        jvmti->RawMonitorExit(agent_lock);
         return;
     }
 
     err = jvmti_env->IsMethodNative(method, &isNative);
     if (err != JVMTI_ERROR_NONE) {
@@ -257,23 +268,49 @@
                 printInfo(jvmti_env, thr, method, frameCount);
                 result = STATUS_FAILED;
             }
         }
     }
+
+    jvmti->RawMonitorExit(agent_lock);
+}
+
+void JNICALL VMStart(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {
+    jvmti->RawMonitorEnter(agent_lock);
+
+    callbacksEnabled = NSK_TRUE;
+
+    jvmti->RawMonitorExit(agent_lock);
+}
+
+
+void JNICALL VMDeath(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {
+    jvmti->RawMonitorEnter(agent_lock);
+
+    callbacksEnabled = NSK_FALSE;
+
+    jvmti->RawMonitorExit(agent_lock);
 }
 
 void JNICALL FramePop(jvmtiEnv *jvmti_env, JNIEnv *env,
         jthread thr, jmethodID method, jboolean wasPopedByException) {
     jvmtiError err;
     jint frameCount;
 
+    jvmti->RawMonitorEnter(agent_lock);
+
+    if (!callbacksEnabled) {
+        jvmti->RawMonitorExit(agent_lock);
+        return;
+    }
     err = jvmti_env->GetFrameCount(thr, &frameCount);
     if (err != JVMTI_ERROR_NONE) {
         printf("(GetFrameCount#entry) unexpected error: %s (%d)\n",
                TranslateError(err), err);
         printInfo(jvmti_env, thr, method, frameCount);
         result = STATUS_FAILED;
+        jvmti->RawMonitorExit(agent_lock);
         return;
     }
 
     if (isTestThread(jvmti_env, thr)) {
         if (printdump == JNI_TRUE) {
@@ -294,10 +331,12 @@
                    TranslateError(err), err);
             printInfo(jvmti_env, thr, method, frameCount);
             result = STATUS_FAILED;
         }
     }
+
+    jvmti->RawMonitorExit(agent_lock);
 }
 
 #ifdef STATIC_BUILD
 JNIEXPORT jint JNICALL Agent_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {
     return Agent_Initialize(jvm, options, reserved);
@@ -353,16 +392,28 @@
 
     if (caps.can_generate_frame_pop_events &&
             caps.can_generate_method_entry_events) {
         callbacks.MethodEntry = &MethodEntry;
         callbacks.FramePop = &FramePop;
+        callbacks.VMStart = &VMStart;
+        callbacks.VMDeath = &VMDeath;
+
         err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));
         if (err != JVMTI_ERROR_NONE) {
             printf("(SetEventCallbacks) unexpected error: %s (%d)\n",
                    TranslateError(err), err);
             return JNI_ERR;
         }
+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL)))
+            return JNI_ERR;
+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))
+            return JNI_ERR;
+
+        if (jvmti->CreateRawMonitor("agent_lock", &agent_lock) != JVMTI_ERROR_NONE) {
+            return JNI_ERR;
+        }
+
     } else {
         printf("Warning: FramePop or MethodEntry event is not implemented\n");
     }
 
     return JNI_OK;

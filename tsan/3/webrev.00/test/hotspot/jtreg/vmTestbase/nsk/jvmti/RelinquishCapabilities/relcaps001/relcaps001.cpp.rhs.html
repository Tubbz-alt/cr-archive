<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/RelinquishCapabilities/relcaps001/relcaps001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdlib.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &quot;jvmti.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* ============================================================================= */
 34 
 35 static jlong timeout = 0;
 36 
 37 #define STATUS_FAIL     97
 38 
 39 #define EVENTS_COUNT    2
 40 
 41 static jvmtiEvent events[EVENTS_COUNT] = {
 42     JVMTI_EVENT_VM_INIT,
 43     JVMTI_EVENT_VM_DEATH
 44 };
 45 
 46 static jvmtiCapabilities initCaps;
 47 
 48 /* ============================================================================= */
 49 
 50 /** Prints capabilities structure as raw bits. */
 51 static void printRawCapabilities(const jvmtiCapabilities* caps) {
 52     const unsigned char* p = (const unsigned char*)caps;
 53     size_t size = sizeof(jvmtiCapabilities);
 54     size_t i;
 55     int j, k;
 56 
 57     nsk_printf(&quot;            &quot;);
 58     for (j = 0; j &lt; 16; j++) {
 59         nsk_printf(&quot; %1X&quot;, j);
 60     }
 61     nsk_printf(&quot;\n&quot;);
 62 
 63     for (i = 0; i &lt; size; i += 2) {
 64         int prefix = (int) i / 2;
 65 
 66         nsk_printf(&quot;    0x%03X.: &quot;, prefix);
 67         for (k = 0; k &lt; 2; k++) {
 68             unsigned char b = *(p++);
 69 
 70             for (j = 0; j &lt; 8; j++) {
 71                 int bit = b % 2;
 72                 b /= 2;
 73                 nsk_printf(&quot; %1d&quot;, bit);
 74             }
 75         }
 76         nsk_printf(&quot;\n&quot;);
 77     }
 78 }
 79 
 80 #define PRINT_CAP(caps, name)  nsk_printf(&quot;    %-40s: %d\n&quot;, #name, (int)caps-&gt;name)
 81 
 82 /** Print values of known capabilities. */
 83 static void printKnownCapabilities(const jvmtiCapabilities* caps) {
 84     PRINT_CAP(caps, can_tag_objects);
 85     PRINT_CAP(caps, can_generate_field_modification_events);
 86     PRINT_CAP(caps, can_generate_field_access_events);
 87     PRINT_CAP(caps, can_get_bytecodes);
 88     PRINT_CAP(caps, can_get_synthetic_attribute);
 89     PRINT_CAP(caps, can_get_owned_monitor_info);
 90     PRINT_CAP(caps, can_get_current_contended_monitor);
 91     PRINT_CAP(caps, can_get_monitor_info);
 92     PRINT_CAP(caps, can_pop_frame);
 93     PRINT_CAP(caps, can_redefine_classes);
 94     PRINT_CAP(caps, can_signal_thread);
 95     PRINT_CAP(caps, can_get_source_file_name);
 96     PRINT_CAP(caps, can_get_line_numbers);
 97     PRINT_CAP(caps, can_get_source_debug_extension);
 98     PRINT_CAP(caps, can_access_local_variables);
 99     PRINT_CAP(caps, can_maintain_original_method_order);
100     PRINT_CAP(caps, can_generate_single_step_events);
101     PRINT_CAP(caps, can_generate_exception_events);
102     PRINT_CAP(caps, can_generate_frame_pop_events);
103     PRINT_CAP(caps, can_generate_breakpoint_events);
104     PRINT_CAP(caps, can_suspend);
105     /* :1 */
106     PRINT_CAP(caps, can_get_current_thread_cpu_time);
107     PRINT_CAP(caps, can_get_thread_cpu_time);
108     PRINT_CAP(caps, can_generate_method_entry_events);
109     PRINT_CAP(caps, can_generate_method_exit_events);
110     PRINT_CAP(caps, can_generate_all_class_hook_events);
111     PRINT_CAP(caps, can_generate_compiled_method_load_events);
112     PRINT_CAP(caps, can_generate_monitor_events);
113     PRINT_CAP(caps, can_generate_vm_object_alloc_events);
114     PRINT_CAP(caps, can_generate_native_method_bind_events);
115     PRINT_CAP(caps, can_generate_garbage_collection_events);
116     PRINT_CAP(caps, can_generate_object_free_events);
117     /* :15 */
118     /* :16 */
119     /* :16 */
120     /* :16 */
121     /* :16 */
122     /* :16 */
123 }
124 
125 #define CHECK_CAP(initCaps, caps, name)                                         \
126     if (caps-&gt;name != 0) {                                                      \
<a name="1" id="anc1"></a><span class="line-modified">127         success = false;                                                        \</span>
128         NSK_COMPLAIN4(&quot;GetCapabilities() in %s returned capability after add and relinguish all potential capabilities:\n&quot;  \
129                       &quot;#   capability: %s\n&quot;                                    \
130                       &quot;#   got value:  %d\n&quot;                                    \
131                       &quot;#   expected:   %d\n&quot;,                                   \
132                         where, #name, (int)caps-&gt;name, 0)       ;               \
133     }
134 
135 /**
136  * Check value of known capabilities.
<a name="2" id="anc2"></a><span class="line-modified">137  * @returns false if any error occured.</span>
138  */
<a name="3" id="anc3"></a><span class="line-modified">139 static bool checkCapabilitiesValue(jvmtiCapabilities* caps, jvmtiCapabilities* initCaps, const char where[]) {</span>
<span class="line-modified">140     bool success = true;</span>
141 
142     CHECK_CAP(initCaps, caps, can_tag_objects);
143     CHECK_CAP(initCaps, caps, can_generate_field_modification_events);
144     CHECK_CAP(initCaps, caps, can_generate_field_access_events);
145     CHECK_CAP(initCaps, caps, can_get_bytecodes);
146     CHECK_CAP(initCaps, caps, can_get_synthetic_attribute);
147     CHECK_CAP(initCaps, caps, can_get_owned_monitor_info);
148     CHECK_CAP(initCaps, caps, can_get_current_contended_monitor);
149     CHECK_CAP(initCaps, caps, can_get_monitor_info);
150     CHECK_CAP(initCaps, caps, can_pop_frame);
151     CHECK_CAP(initCaps, caps, can_redefine_classes);
152     CHECK_CAP(initCaps, caps, can_signal_thread);
153     CHECK_CAP(initCaps, caps, can_get_source_file_name);
154     CHECK_CAP(initCaps, caps, can_get_line_numbers);
155     CHECK_CAP(initCaps, caps, can_get_source_debug_extension);
156     CHECK_CAP(initCaps, caps, can_access_local_variables);
157     CHECK_CAP(initCaps, caps, can_maintain_original_method_order);
158     CHECK_CAP(initCaps, caps, can_generate_single_step_events);
159     CHECK_CAP(initCaps, caps, can_generate_exception_events);
160     CHECK_CAP(initCaps, caps, can_generate_frame_pop_events);
161     CHECK_CAP(initCaps, caps, can_generate_breakpoint_events);
162     CHECK_CAP(initCaps, caps, can_suspend);
163     /* :1 */
164     CHECK_CAP(initCaps, caps, can_get_current_thread_cpu_time);
165     CHECK_CAP(initCaps, caps, can_get_thread_cpu_time);
166     CHECK_CAP(initCaps, caps, can_generate_method_entry_events);
167     CHECK_CAP(initCaps, caps, can_generate_method_exit_events);
168     CHECK_CAP(initCaps, caps, can_generate_all_class_hook_events);
169     CHECK_CAP(initCaps, caps, can_generate_compiled_method_load_events);
170     CHECK_CAP(initCaps, caps, can_generate_monitor_events);
171     CHECK_CAP(initCaps, caps, can_generate_vm_object_alloc_events);
172     CHECK_CAP(initCaps, caps, can_generate_native_method_bind_events);
173     CHECK_CAP(initCaps, caps, can_generate_garbage_collection_events);
174     CHECK_CAP(initCaps, caps, can_generate_object_free_events);
175     /* :15 */
176     /* :16 */
177     /* :16 */
178     /* :16 */
179     /* :16 */
180     /* :16 */
181 
182     return success;
183 }
184 
185 /**
186  * Get and check current capabilities.
<a name="4" id="anc4"></a><span class="line-modified">187  * @returns false if any error occured.</span>
188  */
<a name="5" id="anc5"></a><span class="line-modified">189 static bool checkCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* initCaps, const char where[]) {</span>
<span class="line-modified">190     bool success = true;</span>
191     jvmtiCapabilities caps;
192 
193     memset(&amp;caps, 0, sizeof(jvmtiCapabilities));
194 
195     NSK_DISPLAY0(&quot;GetCapabilities() for current JVMTI env\n&quot;);
196     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetCapabilities(&amp;caps))) {
<a name="6" id="anc6"></a><span class="line-modified">197         return false;</span>
198     }
199 
200     NSK_DISPLAY0(&quot;Got raw capabilities:\n&quot;);
201     printRawCapabilities(&amp;caps);
202 
203     NSK_DISPLAY0(&quot;Known capabilities:\n&quot;);
204     printKnownCapabilities(&amp;caps);
205 
206     NSK_DISPLAY0(&quot;Checking capabilities value:\n&quot;);
207     success = checkCapabilitiesValue(&amp;caps, initCaps, where);
208     NSK_DISPLAY0(&quot;  ... checked\n&quot;);
209 
210     return success;
211 }
212 
213 /**
214  * Add given capabilities list.
<a name="7" id="anc7"></a><span class="line-modified">215  * @returns false if any error occured.</span>
216  */
<a name="8" id="anc8"></a><span class="line-modified">217 static bool addCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* caps) {</span>
218     NSK_DISPLAY0(&quot;AddCapabilities() for current JVMTI env\n&quot;);
219     if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(caps))) {
<a name="9" id="anc9"></a><span class="line-modified">220         return false;</span>
221     }
222     NSK_DISPLAY0(&quot;  ... set\n&quot;);
223 
<a name="10" id="anc10"></a><span class="line-modified">224     return true;</span>
225 }
226 
227 /**
228  * Remove given capabilities list.
<a name="11" id="anc11"></a><span class="line-modified">229  * @returns false if any error occured.</span>
230  */
<a name="12" id="anc12"></a><span class="line-modified">231 static bool removeCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* caps, const char where[]) {</span>
232     NSK_DISPLAY0(&quot;RelinquishCapabilities() for current JVMTI env\n&quot;);
233     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RelinquishCapabilities(caps))) {
<a name="13" id="anc13"></a><span class="line-modified">234         return false;</span>
235     }
236     NSK_DISPLAY0(&quot;  ... relinguished\n&quot;);
237 
<a name="14" id="anc14"></a><span class="line-modified">238     return true;</span>
239 }
240 
241 /**
242  * Get potential capabilities to the given list.
<a name="15" id="anc15"></a><span class="line-modified">243  * @returns false if any error occured.</span>
244  */
<a name="16" id="anc16"></a><span class="line-modified">245 static bool getPotentialCapabilities(jvmtiEnv* jvmti, jvmtiCapabilities* caps) {</span>
246     NSK_DISPLAY0(&quot;GetPotentialCapabilities() for current JVMTI env\n&quot;);
247     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetPotentialCapabilities(caps))) {
<a name="17" id="anc17"></a><span class="line-modified">248         return false;</span>
249     }
250 
251     NSK_DISPLAY0(&quot;Got raw capabilities:\n&quot;);
252     printRawCapabilities(caps);
253 
254     NSK_DISPLAY0(&quot;Known capabilities:\n&quot;);
255     printKnownCapabilities(caps);
256 
<a name="18" id="anc18"></a><span class="line-modified">257     return true;</span>
258 }
259 
260 /* ============================================================================= */
261 
262 /** Agent algorithm. */
263 static void JNICALL
264 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
265     NSK_DISPLAY0(&quot;Wait for debugee to become ready\n&quot;);
266     if (!nsk_jvmti_waitForSync(timeout))
267         return;
268 
269     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #3: Check capabilities in agent thread\n&quot;);
270     if (!checkCapabilities(jvmti, &amp;initCaps, &quot;agent thread&quot;)) {
271         nsk_jvmti_setFailStatus();
272     }
273 
274     NSK_DISPLAY0(&quot;Let debugee to finish\n&quot;);
275     if (!nsk_jvmti_resumeSync())
276         return;
277 }
278 
279 /* ============================================================================= */
280 
281 /**
282  * Callback for VM_INIT event.
283  */
284 JNIEXPORT void JNICALL
285 callbackVMInit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread) {
286 
287     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #2: Check capabilities in VM_INIT callback\n&quot;);
288     if (!checkCapabilities(jvmti, &amp;initCaps, &quot;VM_INIT callback&quot;)) {
289         nsk_jvmti_setFailStatus();
290     }
291 
292 }
293 
294 /**
295  * Callback for VM_DEATH event.
296  */
297 JNIEXPORT void JNICALL
298 callbackVMDeath(jvmtiEnv* jvmti, JNIEnv* jni) {
<a name="19" id="anc19"></a><span class="line-modified">299     bool success = true;</span>
300 
301     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #4: Check capabilities in VM_DEATH callback\n&quot;);
302     success = checkCapabilities(jvmti, &amp;initCaps, &quot;VM_DEATH callback&quot;);
303 
304     NSK_DISPLAY1(&quot;Disable events: %d events\n&quot;, EVENTS_COUNT);
305     if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {
<a name="20" id="anc20"></a><span class="line-modified">306         success = false;</span>
307     } else {
308         NSK_DISPLAY0(&quot;  ... disabled\n&quot;);
309     }
310 
<a name="21" id="anc21"></a><span class="line-modified">311     if (!success) {</span>
312         NSK_DISPLAY1(&quot;Exit with FAIL exit status: %d\n&quot;, STATUS_FAIL);
313         NSK_BEFORE_TRACE(exit(STATUS_FAIL));
314     }
315 }
316 
317 /* ============================================================================= */
318 
319 /** Agent library initialization. */
320 #ifdef STATIC_BUILD
321 JNIEXPORT jint JNICALL Agent_OnLoad_relcaps001(JavaVM *jvm, char *options, void *reserved) {
322     return Agent_Initialize(jvm, options, reserved);
323 }
324 JNIEXPORT jint JNICALL Agent_OnAttach_relcaps001(JavaVM *jvm, char *options, void *reserved) {
325     return Agent_Initialize(jvm, options, reserved);
326 }
327 JNIEXPORT jint JNI_OnLoad_relcaps001(JavaVM *jvm, char *options, void *reserved) {
328     return JNI_VERSION_1_8;
329 }
330 #endif
331 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
332     jvmtiEnv* jvmti = NULL;
333 
334     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
335         return JNI_ERR;
336 
337     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
338 
339     if (!NSK_VERIFY((jvmti =
340             nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))
341         return JNI_ERR;
342 
343     {
344         jvmtiEventCallbacks eventCallbacks;
345 
346         memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
347         eventCallbacks.VMInit = callbackVMInit;
348         eventCallbacks.VMDeath = callbackVMDeath;
349         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks)))) {
350             return JNI_ERR;
351         }
352 
353     }
354 
355     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
356         return JNI_ERR;
357 
358     memset(&amp;initCaps, 0, sizeof(jvmtiCapabilities));
359     if (!getPotentialCapabilities(jvmti, &amp;initCaps)) {
360         return JNI_ERR;
361     }
362 
363     if (!addCapabilities(jvmti, &amp;initCaps)) {
364         return JNI_ERR;
365     }
366 
367     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #0: Remove all potential capabilities in Agent_OnLoad()\n&quot;);
368     if (!removeCapabilities(jvmti, &amp;initCaps, &quot;Agent_OnLoad()&quot;)) {
369         nsk_jvmti_setFailStatus();
370     }
371 
372     NSK_DISPLAY0(&quot;&gt;&gt;&gt; Testcase #1: Check capabilities in Agent_OnLoad()\n&quot;);
373     if (!checkCapabilities(jvmti, &amp;initCaps, &quot;Agent_OnLoad()&quot;)) {
374         nsk_jvmti_setFailStatus();
375     }
376 
377     NSK_DISPLAY1(&quot;Enable events: %d events\n&quot;, EVENTS_COUNT);
378     if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {
379         NSK_DISPLAY0(&quot;  ... enabled\n&quot;);
380     }
381 
382     return JNI_OK;
383 }
384 
385 /* ============================================================================= */
386 
387 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
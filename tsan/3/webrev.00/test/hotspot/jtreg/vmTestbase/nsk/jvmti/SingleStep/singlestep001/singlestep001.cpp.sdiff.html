<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/SingleStep/singlestep001/singlestep001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../ResourceExhausted/resexhausted004/TestDescription.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../singlestep003/singlestep003.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/SingleStep/singlestep001/singlestep001.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 40 
 41 static const char *METHODS[] = {
 42     &quot;bpMethod&quot;,
 43     &quot;runThis&quot;
 44 };
 45 
 46 static const char *METHOD_SIGS[] = {
 47     &quot;()V&quot;,
 48     &quot;([Ljava/lang/String;Ljava/io/PrintStream;)I&quot;
 49 };
 50 
 51 static volatile long stepEv[] = { 0, 0 };
 52 
 53 static const char *CLASS_SIG =
 54     &quot;Lnsk/jvmti/SingleStep/singlestep001;&quot;;
 55 
 56 static volatile jint result = PASSED;
 57 static jvmtiEnv *jvmti = NULL;
 58 static jvmtiEventCallbacks callbacks;
 59 
<span class="line-modified"> 60 static int vm_started = 0;</span>
 61 static jrawMonitorID agent_lock;
 62 
 63 static void setBP(jvmtiEnv *jvmti_env, JNIEnv *env, jclass klass) {
 64     jmethodID mid;
 65 
 66     if (!NSK_JNI_VERIFY(env, (mid = env-&gt;GetMethodID(klass, METHODS[0], METHOD_SIGS[0])) != NULL))
 67         env-&gt;FatalError(&quot;failed to get ID for the java method\n&quot;);
 68 
 69     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;SetBreakpoint(mid, 0)))
 70         env-&gt;FatalError(&quot;failed to set breakpoint\n&quot;);
 71 }
 72 
 73 /** callback functions **/
 74 void JNICALL
 75 ClassLoad(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread, jclass klass) {
 76     char *sig, *generic;
 77 
 78     jvmti-&gt;RawMonitorEnter(agent_lock);
 79 
<span class="line-modified"> 80     if (vm_started) {</span>
 81         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetClassSignature(klass, &amp;sig, &amp;generic)))
 82             env-&gt;FatalError(&quot;failed to obtain a class signature\n&quot;);
 83 
 84         if (sig != NULL &amp;&amp; (strcmp(sig, CLASS_SIG) == 0)) {
 85             NSK_DISPLAY1(
 86                 &quot;ClassLoad event received for the class \&quot;%s\&quot;\n&quot;
 87                 &quot;\tsetting breakpoint ...\n&quot;,
 88                 sig);
 89             setBP(jvmti_env, env, klass);
 90         }
 91     }
 92 
 93     jvmti-&gt;RawMonitorExit(agent_lock);
 94 }
 95 
 96 void JNICALL
 97 Breakpoint(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr, jmethodID method,
 98         jlocation loc) {
 99     jclass klass;
100     char *sig, *generic;
101 







102     NSK_DISPLAY0(&quot;Breakpoint event received\n&quot;);
103     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodDeclaringClass(method, &amp;klass)))
104         NSK_COMPLAIN0(&quot;TEST FAILURE: unable to get method declaring class\n\n&quot;);
105 
106     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetClassSignature(klass, &amp;sig, &amp;generic)))
107         env-&gt;FatalError(&quot;Breakpoint: failed to obtain a class signature\n&quot;);
108 
109     if (sig != NULL &amp;&amp; (strcmp(sig, CLASS_SIG) == 0)) {
110         NSK_DISPLAY1(&quot;method declaring class \&quot;%s\&quot;\n\tenabling SingleStep events ...\n&quot;,
111             sig);
112         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, thr))) {
113             result = STATUS_FAILED;
114             NSK_COMPLAIN0(&quot;TEST FAILURE: cannot enable SingleStep events\n\n&quot;);
115         }
116     } else {
117         result = STATUS_FAILED;
118         NSK_COMPLAIN1(&quot;TEST FAILURE: unexpected breakpoint event in method of class \&quot;%s\&quot;\n\n&quot;,
119             sig);
120     }

121 }
122 
123 void JNICALL
124 SingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
125         jmethodID method, jlocation location) {
126     jclass klass;
127     char *sig, *generic, *methNam, *methSig;
128 
129     if (result == STATUS_FAILED) {
130         return;
131     }
132 
133     NSK_DISPLAY0(&quot;&gt;&gt;&gt;&gt; SingleStep event received\n&quot;);
134 
135     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodName(method, &amp;methNam, &amp;methSig, NULL))) {
136         result = STATUS_FAILED;
137         NSK_COMPLAIN0(&quot;TEST FAILED: unable to get method name during SingleStep callback\n\n&quot;);
138         return;
139     }
140     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodDeclaringClass(method, &amp;klass))) {
</pre>
<hr />
<pre>
180             }
181         }
182     }
183 
184     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*) methNam))) {
185         result = STATUS_FAILED;
186         NSK_COMPLAIN0(&quot;TEST FAILED: unable to deallocate memory pointed to method name\n\n&quot;);
187     }
188     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*) methSig))) {
189         result = STATUS_FAILED;
190         NSK_COMPLAIN0(&quot;TEST FAILED: unable to deallocate memory pointed to method signature\n\n&quot;);
191     }
192 
193     NSK_DISPLAY0(&quot;&lt;&lt;&lt;&lt;\n\n&quot;);
194 }
195 
196 void JNICALL
197 VMStart(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {
198     jvmti-&gt;RawMonitorEnter(agent_lock);
199 
<span class="line-modified">200     vm_started = 1;</span>









201 
202     jvmti-&gt;RawMonitorExit(agent_lock);
203 }
204 /************************/
205 
206 JNIEXPORT jint JNICALL
207 Java_nsk_jvmti_SingleStep_singlestep001_check(
208         JNIEnv *env, jobject obj) {
209     int i;
210 
211     for (i=0; i&lt;METH_NUM; i++)
212         if (stepEv[i] == 0) {
213             result = STATUS_FAILED;
214             NSK_COMPLAIN1(&quot;TEST FAILED: no SingleStep events for the method \&quot;%s\&quot;\n\n&quot;,
215                 METHODS[i]);
216         }
217 
218     return result;
219 }
220 
</pre>
<hr />
<pre>
244     /* add capability to generate compiled method events */
245     memset(&amp;caps, 0, sizeof(jvmtiCapabilities));
246     caps.can_generate_breakpoint_events = 1;
247     caps.can_generate_single_step_events = 1;
248     if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
249         return JNI_ERR;
250 
251     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetCapabilities(&amp;caps)))
252         return JNI_ERR;
253 
254     if (!caps.can_generate_single_step_events)
255         NSK_DISPLAY0(&quot;Warning: generation of single step events is not implemented\n&quot;);
256 
257     /* set event callback */
258     NSK_DISPLAY0(&quot;setting event callbacks ...\n&quot;);
259     (void) memset(&amp;callbacks, 0, sizeof(callbacks));
260     callbacks.ClassLoad = &amp;ClassLoad;
261     callbacks.Breakpoint = &amp;Breakpoint;
262     callbacks.SingleStep = &amp;SingleStep;
263     callbacks.VMStart = &amp;VMStart;

264     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks))))
265         return JNI_ERR;
266 
267     NSK_DISPLAY0(&quot;setting event callbacks done\nenabling JVMTI events ...\n&quot;);
268     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL)))
269         return JNI_ERR;


270     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL)))
271         return JNI_ERR;
272     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL)))
273         return JNI_ERR;
274     NSK_DISPLAY0(&quot;enabling the events done\n\n&quot;);
275 
276     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;agent lock&quot;, &amp;agent_lock)))
277         return JNI_ERR;
278 
279     return JNI_OK;
280 }
281 
282 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 40 
 41 static const char *METHODS[] = {
 42     &quot;bpMethod&quot;,
 43     &quot;runThis&quot;
 44 };
 45 
 46 static const char *METHOD_SIGS[] = {
 47     &quot;()V&quot;,
 48     &quot;([Ljava/lang/String;Ljava/io/PrintStream;)I&quot;
 49 };
 50 
 51 static volatile long stepEv[] = { 0, 0 };
 52 
 53 static const char *CLASS_SIG =
 54     &quot;Lnsk/jvmti/SingleStep/singlestep001;&quot;;
 55 
 56 static volatile jint result = PASSED;
 57 static jvmtiEnv *jvmti = NULL;
 58 static jvmtiEventCallbacks callbacks;
 59 
<span class="line-modified"> 60 static volatile int callbacksEnabled = NSK_FALSE;</span>
 61 static jrawMonitorID agent_lock;
 62 
 63 static void setBP(jvmtiEnv *jvmti_env, JNIEnv *env, jclass klass) {
 64     jmethodID mid;
 65 
 66     if (!NSK_JNI_VERIFY(env, (mid = env-&gt;GetMethodID(klass, METHODS[0], METHOD_SIGS[0])) != NULL))
 67         env-&gt;FatalError(&quot;failed to get ID for the java method\n&quot;);
 68 
 69     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;SetBreakpoint(mid, 0)))
 70         env-&gt;FatalError(&quot;failed to set breakpoint\n&quot;);
 71 }
 72 
 73 /** callback functions **/
 74 void JNICALL
 75 ClassLoad(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread, jclass klass) {
 76     char *sig, *generic;
 77 
 78     jvmti-&gt;RawMonitorEnter(agent_lock);
 79 
<span class="line-modified"> 80     if (callbacksEnabled) {</span>
 81         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetClassSignature(klass, &amp;sig, &amp;generic)))
 82             env-&gt;FatalError(&quot;failed to obtain a class signature\n&quot;);
 83 
 84         if (sig != NULL &amp;&amp; (strcmp(sig, CLASS_SIG) == 0)) {
 85             NSK_DISPLAY1(
 86                 &quot;ClassLoad event received for the class \&quot;%s\&quot;\n&quot;
 87                 &quot;\tsetting breakpoint ...\n&quot;,
 88                 sig);
 89             setBP(jvmti_env, env, klass);
 90         }
 91     }
 92 
 93     jvmti-&gt;RawMonitorExit(agent_lock);
 94 }
 95 
 96 void JNICALL
 97 Breakpoint(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr, jmethodID method,
 98         jlocation loc) {
 99     jclass klass;
100     char *sig, *generic;
101 
<span class="line-added">102     jvmti-&gt;RawMonitorEnter(agent_lock);</span>
<span class="line-added">103 </span>
<span class="line-added">104     if (!callbacksEnabled) {</span>
<span class="line-added">105         jvmti-&gt;RawMonitorExit(agent_lock);</span>
<span class="line-added">106         return;</span>
<span class="line-added">107     }</span>
<span class="line-added">108 </span>
109     NSK_DISPLAY0(&quot;Breakpoint event received\n&quot;);
110     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodDeclaringClass(method, &amp;klass)))
111         NSK_COMPLAIN0(&quot;TEST FAILURE: unable to get method declaring class\n\n&quot;);
112 
113     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetClassSignature(klass, &amp;sig, &amp;generic)))
114         env-&gt;FatalError(&quot;Breakpoint: failed to obtain a class signature\n&quot;);
115 
116     if (sig != NULL &amp;&amp; (strcmp(sig, CLASS_SIG) == 0)) {
117         NSK_DISPLAY1(&quot;method declaring class \&quot;%s\&quot;\n\tenabling SingleStep events ...\n&quot;,
118             sig);
119         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, thr))) {
120             result = STATUS_FAILED;
121             NSK_COMPLAIN0(&quot;TEST FAILURE: cannot enable SingleStep events\n\n&quot;);
122         }
123     } else {
124         result = STATUS_FAILED;
125         NSK_COMPLAIN1(&quot;TEST FAILURE: unexpected breakpoint event in method of class \&quot;%s\&quot;\n\n&quot;,
126             sig);
127     }
<span class="line-added">128     jvmti-&gt;RawMonitorExit(agent_lock);</span>
129 }
130 
131 void JNICALL
132 SingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
133         jmethodID method, jlocation location) {
134     jclass klass;
135     char *sig, *generic, *methNam, *methSig;
136 
137     if (result == STATUS_FAILED) {
138         return;
139     }
140 
141     NSK_DISPLAY0(&quot;&gt;&gt;&gt;&gt; SingleStep event received\n&quot;);
142 
143     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodName(method, &amp;methNam, &amp;methSig, NULL))) {
144         result = STATUS_FAILED;
145         NSK_COMPLAIN0(&quot;TEST FAILED: unable to get method name during SingleStep callback\n\n&quot;);
146         return;
147     }
148     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodDeclaringClass(method, &amp;klass))) {
</pre>
<hr />
<pre>
188             }
189         }
190     }
191 
192     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*) methNam))) {
193         result = STATUS_FAILED;
194         NSK_COMPLAIN0(&quot;TEST FAILED: unable to deallocate memory pointed to method name\n\n&quot;);
195     }
196     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*) methSig))) {
197         result = STATUS_FAILED;
198         NSK_COMPLAIN0(&quot;TEST FAILED: unable to deallocate memory pointed to method signature\n\n&quot;);
199     }
200 
201     NSK_DISPLAY0(&quot;&lt;&lt;&lt;&lt;\n\n&quot;);
202 }
203 
204 void JNICALL
205 VMStart(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {
206     jvmti-&gt;RawMonitorEnter(agent_lock);
207 
<span class="line-modified">208     callbacksEnabled = NSK_TRUE;</span>
<span class="line-added">209 </span>
<span class="line-added">210     jvmti-&gt;RawMonitorExit(agent_lock);</span>
<span class="line-added">211 }</span>
<span class="line-added">212 </span>
<span class="line-added">213 void JNICALL</span>
<span class="line-added">214 VMDeath(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {</span>
<span class="line-added">215     jvmti-&gt;RawMonitorEnter(agent_lock);</span>
<span class="line-added">216 </span>
<span class="line-added">217     callbacksEnabled = NSK_FALSE;</span>
218 
219     jvmti-&gt;RawMonitorExit(agent_lock);
220 }
221 /************************/
222 
223 JNIEXPORT jint JNICALL
224 Java_nsk_jvmti_SingleStep_singlestep001_check(
225         JNIEnv *env, jobject obj) {
226     int i;
227 
228     for (i=0; i&lt;METH_NUM; i++)
229         if (stepEv[i] == 0) {
230             result = STATUS_FAILED;
231             NSK_COMPLAIN1(&quot;TEST FAILED: no SingleStep events for the method \&quot;%s\&quot;\n\n&quot;,
232                 METHODS[i]);
233         }
234 
235     return result;
236 }
237 
</pre>
<hr />
<pre>
261     /* add capability to generate compiled method events */
262     memset(&amp;caps, 0, sizeof(jvmtiCapabilities));
263     caps.can_generate_breakpoint_events = 1;
264     caps.can_generate_single_step_events = 1;
265     if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
266         return JNI_ERR;
267 
268     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetCapabilities(&amp;caps)))
269         return JNI_ERR;
270 
271     if (!caps.can_generate_single_step_events)
272         NSK_DISPLAY0(&quot;Warning: generation of single step events is not implemented\n&quot;);
273 
274     /* set event callback */
275     NSK_DISPLAY0(&quot;setting event callbacks ...\n&quot;);
276     (void) memset(&amp;callbacks, 0, sizeof(callbacks));
277     callbacks.ClassLoad = &amp;ClassLoad;
278     callbacks.Breakpoint = &amp;Breakpoint;
279     callbacks.SingleStep = &amp;SingleStep;
280     callbacks.VMStart = &amp;VMStart;
<span class="line-added">281     callbacks.VMDeath = &amp;VMDeath;</span>
282     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks))))
283         return JNI_ERR;
284 
285     NSK_DISPLAY0(&quot;setting event callbacks done\nenabling JVMTI events ...\n&quot;);
286     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL)))
287         return JNI_ERR;
<span class="line-added">288     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))</span>
<span class="line-added">289         return JNI_ERR;</span>
290     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL)))
291         return JNI_ERR;
292     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL)))
293         return JNI_ERR;
294     NSK_DISPLAY0(&quot;enabling the events done\n\n&quot;);
295 
296     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;agent lock&quot;, &amp;agent_lock)))
297         return JNI_ERR;
298 
299     return JNI_OK;
300 }
301 
302 }
</pre>
</td>
</tr>
</table>
<center><a href="../../ResourceExhausted/resexhausted004/TestDescription.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../singlestep003/singlestep003.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
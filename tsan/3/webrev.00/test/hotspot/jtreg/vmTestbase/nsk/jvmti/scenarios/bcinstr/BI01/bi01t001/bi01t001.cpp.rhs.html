<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/bcinstr/BI01/bi01t001/bi01t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 27 #include &quot;ExceptionCheckingJniEnv.hpp&quot;</span>
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* scaffold objects */
 34 static jvmtiEnv *jvmti = NULL;
 35 static jlong timeout = 0;
 36 
 37 #define TESTED_CLASS_NAME   &quot;nsk/jvmti/scenarios/bcinstr/BI01/bi01t001a&quot;
 38 
 39 static jint newClassSize;
 40 static unsigned char* newClassBytes;
 41 static jvmtiClassDefinition oldClassDef;
 42 
 43 /* ============================================================================= */
 44 /*
 45  * Class:     nsk_jvmti_scenarios_bcinstr_BI01_bi01t001
 46  * Method:    setNewByteCode
 47  * Signature: ([B)Z
 48  */
 49 JNIEXPORT jboolean JNICALL
 50 Java_nsk_jvmti_scenarios_bcinstr_BI01_bi01t001_setNewByteCode(JNIEnv *jni_env,
<a name="3" id="anc3"></a><span class="line-modified"> 51                                                               jobject o,</span>
<span class="line-modified"> 52                                                               jbyteArray byteCode) {</span>
<span class="line-added"> 53     ExceptionCheckingJniEnvPtr ec_jni(jni_env);</span>
 54     jbyte* elements;
 55     jboolean isCopy;
 56 
<a name="4" id="anc4"></a><span class="line-modified"> 57     newClassSize = ec_jni-&gt;GetArrayLength(byteCode, TRACE_JNI_CALL);</span>
<span class="line-modified"> 58     if (newClassSize &lt;= 0) {</span>
 59         nsk_jvmti_setFailStatus();
 60         return NSK_FALSE;
 61     }
 62     NSK_DISPLAY1(&quot;\t... got array size: %d\n&quot;, newClassSize);
 63 
<a name="5" id="anc5"></a><span class="line-modified"> 64     elements = ec_jni-&gt;GetByteArrayElements(byteCode, &amp;isCopy, TRACE_JNI_CALL);</span>




 65     NSK_DISPLAY1(&quot;\t... got elements list: 0x%p\n&quot;, (void*)elements);
 66 
 67     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Allocate(newClassSize, &amp;newClassBytes))) {
 68         nsk_jvmti_setFailStatus();
 69         return NSK_FALSE;
 70     }
 71     NSK_DISPLAY1(&quot;\t... created bytes array: 0x%p\n&quot;, (void*)newClassBytes);
 72 
 73     {
 74         int j;
 75         for (j = 0; j &lt; newClassSize; j++)
 76             newClassBytes[j] = (unsigned char)elements[j];
 77     }
 78     NSK_DISPLAY1(&quot;\t... copied bytecode: %d bytes\n&quot;, (int)newClassSize);
 79 
 80     NSK_DISPLAY1(&quot;\t... release elements list: 0x%p\n&quot;, (void*)elements);
<a name="6" id="anc6"></a><span class="line-modified"> 81     ec_jni-&gt;ReleaseByteArrayElements(byteCode, elements, JNI_ABORT, TRACE_JNI_CALL);</span>
 82     NSK_DISPLAY0(&quot;\t... released\n&quot;);
 83     return NSK_TRUE;
 84 }
 85 
 86 /* ============================================================================= */
 87 /*
 88  * Class:     nsk_jvmti_scenarios_bcinstr_BI01_bi01t001
 89  * Method:    setClass
 90  * Signature: (Ljava/lang/Class;)V
 91  */
 92 JNIEXPORT void JNICALL
 93 Java_nsk_jvmti_scenarios_bcinstr_BI01_bi01t001_setClass(JNIEnv *jni_env,
 94                         jobject o, jclass cls) {
<a name="7" id="anc7"></a><span class="line-modified"> 95     ExceptionCheckingJniEnvPtr ec_jni(jni_env);</span>
<span class="line-modified"> 96     oldClassDef.klass = (jclass) ec_jni-&gt;NewGlobalRef(cls, TRACE_JNI_CALL);</span>



 97 }
 98 
 99 /* ============================================================================= */
100 
101 /** Callback function for ClassFileLoadHook event. */
102 JNIEXPORT void JNICALL
103 cbClassFileLoadHook(jvmtiEnv *jvmti_env, JNIEnv* jni_env,
104             jclass class_being_redefined, jobject loader, const char* name,
105             jobject protection_domain, jint class_data_len,
106             const unsigned char* class_data, jint* new_class_data_len,
107             unsigned char** new_class_data) {
108 
109     if (name == NULL || strcmp(name, TESTED_CLASS_NAME)) {
110         return;
111     }
112 
113     NSK_DISPLAY3(&quot;CLASS_FILE_LOAD_HOOK event: %s\n\treceived bytecode: 0x%p:%d\n&quot;,
114                         name, (void *)class_data, class_data_len);
115     if (nsk_getVerboseMode()) {
116         nsk_printHexBytes(&quot;   &quot;, 16, class_data_len, class_data);
117     }
118 
119     {
120         /*store original byte code, it will be used to do final redefinition*/
121         int j;
122         unsigned char *arr;
123 
124         oldClassDef.class_byte_count = class_data_len;
125         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Allocate(class_data_len, &amp;arr))) {
126             nsk_jvmti_setFailStatus();
127             return;
128         }
129         for (j = 0; j &lt; class_data_len; j++) {
130             arr[j] = class_data[j];
131         }
132         oldClassDef.class_bytes = arr;
133     }
134 
135     *new_class_data_len = newClassSize;
136     *new_class_data = newClassBytes;
137 
138     NSK_DISPLAY2(&quot;Replace with new bytecode: 0x%p:%d\n&quot;,
139                                 (void*)newClassBytes,
140                                 (int)newClassSize);
141     if (nsk_getVerboseMode()) {
142         nsk_printHexBytes(&quot;   &quot;, 16, newClassSize,
143                                 newClassBytes);
144     }
145 }
146 
147 /* ============================================================================= */
148 
149 /** Agent algorithm. */
150 static void JNICALL
151 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
<a name="8" id="anc8"></a><span class="line-added">152     ExceptionCheckingJniEnvPtr ec_jni(agentJNI);</span>
153 
154     /*Wait for debuggee to read new byte codes nsk_jvmti_waitForSync#1*/
155     NSK_DISPLAY0(&quot;Wait for debuggee to read new byte codes nsk_jvmti_waitForSync#1\n&quot;);
156     if (!nsk_jvmti_waitForSync(timeout))
157         return;
158 
159     if (!nsk_jvmti_resumeSync())
160         return;
161 
162     NSK_DISPLAY0(&quot;Wait for debuggee to load tested class by classLoader\n&quot;);
163     /*Wait for debuggee to load next class nsk_jvmti_waitForSync#2*/
164     if (!nsk_jvmti_waitForSync(timeout))
165         return;
166 
167     if (!nsk_jvmti_resumeSync())
168         return;
169 
170     /*Wait for debuggee to check instrumentation code works nsk_jvmti_waitForSync#3*/
171     NSK_DISPLAY0(&quot;Wait for debuggee to check instrumentation code works nsk_jvmti_waitForSync#3\n&quot;);
172     if (!nsk_jvmti_waitForSync(timeout))
173         return;
174 
175     NSK_DISPLAY0(&quot;Notification disabled for CLASS_FILE_LOAD_HOOK event\n&quot;);
176     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE,
177                                                           JVMTI_EVENT_CLASS_FILE_LOAD_HOOK,
178                                                           NULL))) {
179         nsk_jvmti_setFailStatus();
180         return;
181     }
182 
183     if (!nsk_jvmti_resumeSync())
184         return;
185 
186     /*Wait for debuggee to set classes to be redefined nsk_jvmti_waitForSync#4*/
187     NSK_DISPLAY0(&quot;Wait for debuggee to set classes to be redefined nsk_jvmti_waitForSync#4\n&quot;);
188     if (!nsk_jvmti_waitForSync(timeout))
189         return;
190 
191     NSK_DISPLAY0(&quot;Redfine class with old byte code\n&quot;);
192     NSK_DISPLAY3(&quot;class definition:\n\t0x%p, 0x%p:%d\n&quot;,
193                     oldClassDef.klass,
194                     oldClassDef.class_bytes,
195                     oldClassDef.class_byte_count);
196     if (nsk_getVerboseMode()) {
197         nsk_printHexBytes(&quot;   &quot;, 16, oldClassDef.class_byte_count,
198                                 oldClassDef.class_bytes);
199     }
200     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RedefineClasses(1, &amp;oldClassDef))) {
201         nsk_jvmti_setFailStatus();
202         return;
203     }
204 
205     if (!nsk_jvmti_resumeSync())
206         return;
207 
208     /*Wait for debuggee to check old byte code works nsk_jvmti_waitForSync#5*/
209     NSK_DISPLAY0(&quot;Wait for debuggee to check old byte code works nsk_jvmti_waitForSync#5\n&quot;);
210     if (!nsk_jvmti_waitForSync(timeout))
211         return;
212 
<a name="9" id="anc9"></a><span class="line-modified">213     ec_jni-&gt;DeleteGlobalRef(oldClassDef.klass, TRACE_JNI_CALL);</span>
214 
215     NSK_DISPLAY0(&quot;Let debuggee to finish\n&quot;);
216     if (!nsk_jvmti_resumeSync())
217         return;
218 
219 }
220 
221 /* ============================================================================= */
222 
223 /** Agent library initialization. */
224 #ifdef STATIC_BUILD
225 JNIEXPORT jint JNICALL Agent_OnLoad_bi01t001(JavaVM *jvm, char *options, void *reserved) {
226     return Agent_Initialize(jvm, options, reserved);
227 }
228 JNIEXPORT jint JNICALL Agent_OnAttach_bi01t001(JavaVM *jvm, char *options, void *reserved) {
229     return Agent_Initialize(jvm, options, reserved);
230 }
231 JNIEXPORT jint JNI_OnLoad_bi01t001(JavaVM *jvm, char *options, void *reserved) {
232     return JNI_VERSION_1_8;
233 }
234 #endif
235 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
236 
237     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
238         return JNI_ERR;
239 
240     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
241 
242     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
243     if (!NSK_VERIFY(jvmti != NULL))
244         return JNI_ERR;
245 
246     {
247         jvmtiCapabilities caps;
248         memset(&amp;caps, 0, sizeof(caps));
249 
250         caps.can_redefine_classes = 1;
251         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
252             return JNI_ERR;
253     }
254 
255     NSK_DISPLAY0(&quot;Set callback for CLASS_FILE_LOAD_HOOK event\n&quot;);
256     {
257         jvmtiEventCallbacks callbacks;
258         jint size = (jint)sizeof(callbacks);
259 
260         memset(&amp;callbacks, 0, size);
261         callbacks.ClassFileLoadHook = cbClassFileLoadHook;
262         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;callbacks, size))) {
263             return JNI_ERR;
264         }
265     }
266 
267     NSK_DISPLAY0(&quot;Set notification enabled for CLASS_FILE_LOAD_HOOK event\n&quot;);
268     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE,
269                                                           JVMTI_EVENT_CLASS_FILE_LOAD_HOOK,
270                                                           NULL))) {
271         nsk_jvmti_setFailStatus();
272         return NSK_FALSE;
273     }
274 
275     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
276         return JNI_ERR;
277 
278     return JNI_OK;
279 }
280 
281 /* ============================================================================= */
282 
283 
284 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
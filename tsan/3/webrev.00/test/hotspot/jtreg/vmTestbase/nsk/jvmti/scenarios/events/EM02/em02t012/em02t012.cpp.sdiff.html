<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t012/em02t012.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../em02t011/libem02t011.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="libem02t012.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t012/em02t012.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;

 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* ============================================================================= */
 34 
 35 /* scaffold objects */
 36 static jvmtiEnv *jvmti = NULL;
 37 static jthread testedThread;
 38 static jlong timeout = 0;
 39 static jrawMonitorID syncLock = NULL;
 40 
 41 /* constant names */
 42 #define STEP_NUMBER 3
 43 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 44 #define NUMBER_OF_INVOCATIONS 1000
 45 
 46 static int eventCount[JVMTI_EVENT_COUNT];
 47 static int newEventCount[JVMTI_EVENT_COUNT];
 48 
 49 /* ============================================================================= */
 50 JNIEXPORT void JNICALL
<span class="line-modified"> 51 Java_nsk_jvmti_scenarios_events_EM02_em02t012_setThread(JNIEnv *jni_env,</span>
 52                         jobject o, jthread thrd) {
<span class="line-modified"> 53 </span>
 54     /* make thread accessable for a long time */
<span class="line-modified"> 55     testedThread = jni_env-&gt;NewGlobalRef(thrd);</span>
<span class="line-removed"> 56     NSK_JNI_VERIFY(jni_env, testedThread != NULL);</span>
 57 }
 58 
 59 static void
 60 showEventStatistics(int step) {
 61     int i;
 62     const char* str;
 63     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 64 
 65     NSK_DISPLAY0(&quot;\n&quot;);
 66     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 67     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 68     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 69         if (currentCounts[i] &gt; 0) {
 70             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 71             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 72         }
 73     }
 74 }
 75 
 76 /* ========================================================================== */
 77 
<span class="line-modified"> 78 int checkEvents(int step) {</span>
 79     int i;
 80     jvmtiEvent curr;
<span class="line-modified"> 81     int result = NSK_TRUE;</span>
 82     int *currentCounts;
 83     int isExpected = 0;
 84 
 85     switch (step) {
 86         case 1:
 87             currentCounts = &amp;eventCount[0];
 88             break;
 89 
 90         case 2:
 91         case 3:
 92             currentCounts = &amp;newEventCount[0];
 93             break;
 94 
 95         default:
 96             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified"> 97             return NSK_FALSE;</span>
 98     }
 99 
100     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
101 
102         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
103 
104         switch (step) {
105             case 1:
106                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
107                                 || (curr == JVMTI_EVENT_FRAME_POP));
108                 break;
109 
110             case 2:
111                 isExpected = (curr == JVMTI_EVENT_FRAME_POP);
112                 break;
113 
114             case 3:
115                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
116                 break;
117         }
118 
119         if (isExpected) {
120             if (curr == JVMTI_EVENT_FRAME_POP) {
121                 if (currentCounts[i] != NUMBER_OF_INVOCATIONS) {
122                     NSK_COMPLAIN3(&quot;Unexpected number of %s events %d, expected value is %d\n&quot;,
123                                         TranslateEvent(curr),
124                                         currentCounts[i],
125                                         NUMBER_OF_INVOCATIONS);
<span class="line-modified">126                     result = NSK_FALSE;</span>
127                 }
128             } else {
129                 if (currentCounts[i] &lt; 1) {
130                         NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
131                                             currentCounts[i],
132                                             TranslateEvent(curr));
<span class="line-modified">133                     result = NSK_FALSE;</span>
134                 }
135             }
136 
137         } else {
138 
139             if (currentCounts[i] &gt; 0) {
140                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
141                                     TranslateEvent(curr),
142                                     currentCounts[i]);
<span class="line-modified">143                 result = NSK_FALSE;</span>
144             }
145         }
146     }
147 
148     return result;
149 }
150 
151 static void
152 changeCount(jvmtiEvent event, int *currentCounts) {
153 
154     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
155         nsk_jvmti_setFailStatus();
156 
157     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
158 
159     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
160         nsk_jvmti_setFailStatus();
161 
162 }
163 
</pre>
<hr />
<pre>
308 void JNICALL
309 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
310     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
311 }
312 
313 void JNICALL
314 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
315 
316     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
317 }
318 
319 void JNICALL
320 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
321                     jobject object, jclass object_klass, jlong size) {
322 
323     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
324 }
325 
326 /* ============================================================================= */
327 
<span class="line-modified">328 static int enableEvent(jvmtiEvent event) {</span>
329 
330     if (nsk_jvmti_isOptionalEvent(event)
331             &amp;&amp; (event != JVMTI_EVENT_FRAME_POP)) {
332         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
333                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
334             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
335                 TranslateEvent(event));
<span class="line-modified">336             return NSK_FALSE;</span>
337         }
338     } else {
339         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
340             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
341                 TranslateEvent(event));
<span class="line-modified">342             return NSK_FALSE;</span>
343         }
344     }
345 
<span class="line-modified">346     return NSK_TRUE;</span>
347 }
348 
349 /**
350  * Enable or disable tested events.
351  */
<span class="line-modified">352 static int enableEventList() {</span>
353 
354     int i, result;
355 
356     result = enableEvent(JVMTI_EVENT_VM_INIT);
357 
358     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
359 
360     /* enabling optional events */
361     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
362         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
363 
364         if (nsk_jvmti_isOptionalEvent(event))
365             result = result &amp;&amp; enableEvent(event);
366     }
367 
<span class="line-modified">368     if (result == NSK_FALSE) {</span>
369         nsk_jvmti_setFailStatus();
<span class="line-modified">370         return NSK_FALSE;</span>
371     }
372 
<span class="line-modified">373     return NSK_TRUE;</span>
374 }
375 
376 /* ============================================================================= */
377 
<span class="line-modified">378 static int</span>
<span class="line-removed">379 setCallBacks(int step) {</span>
380 
381     int i;
382 
383     jvmtiEventCallbacks eventCallbacks;
384     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
385 
386     switch (step) {
387         case 1:
388             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
389                 eventCount[i] = 0;
390             }
391 
392             eventCallbacks.VMInit                    = cbVMInit;
393             eventCallbacks.Exception                 = cbException;
394             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
395             eventCallbacks.SingleStep                = cbSingleStep;
396             eventCallbacks.FramePop                  = cbFramePop;
397             eventCallbacks.Breakpoint                = cbBreakpoint;
398             eventCallbacks.FieldAccess               = cbFieldAccess;
399             eventCallbacks.FieldModification         = cbFieldModification;
</pre>
<hr />
<pre>
413             break;
414 
415         case 2:
416             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
417                 newEventCount[i] = 0;
418             }
419 
420             eventCallbacks.FramePop                  = cbNewFramePop;
421             break;
422 
423         case 3:
424             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
425                 newEventCount[i] = 0;
426             }
427 
428             eventCallbacks.VMDeath                   = cbVMDeath;
429             break;
430 
431     }
432     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">433         return NSK_FALSE;</span>
434 
<span class="line-modified">435     return NSK_TRUE;</span>
436 }
437 
438 /* ============================================================================= */
439 
440 /** Agent algorithm. */
441 static void JNICALL
442 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
443 
444     int i, j;
445 
446     for (i = 1; i &lt;= STEP_NUMBER; i++) {
447 
448         if (!nsk_jvmti_waitForSync(timeout))
449             return;
450 
451         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SuspendThread(testedThread)))
452             return;
453 
454         for (j = 2; j &lt; 1002; j++) {
455             if (!NSK_JVMTI_VERIFY(jvmti-&gt;NotifyFramePop(testedThread, j)))
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
<span class="line-added"> 27 #include &quot;ExceptionCheckingJniEnv.hpp&quot;</span>
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 #include &quot;JVMTITools.h&quot;
 31 
 32 extern &quot;C&quot; {
 33 
 34 /* ============================================================================= */
 35 
 36 /* scaffold objects */
 37 static jvmtiEnv *jvmti = NULL;
 38 static jthread testedThread;
 39 static jlong timeout = 0;
 40 static jrawMonitorID syncLock = NULL;
 41 
 42 /* constant names */
 43 #define STEP_NUMBER 3
 44 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 45 #define NUMBER_OF_INVOCATIONS 1000
 46 
 47 static int eventCount[JVMTI_EVENT_COUNT];
 48 static int newEventCount[JVMTI_EVENT_COUNT];
 49 
 50 /* ============================================================================= */
 51 JNIEXPORT void JNICALL
<span class="line-modified"> 52 Java_nsk_jvmti_scenarios_events_EM02_em02t012_setThread(JNIEnv *jni,</span>
 53                         jobject o, jthread thrd) {
<span class="line-modified"> 54     ExceptionCheckingJniEnvPtr ec_jni(jni);</span>
 55     /* make thread accessable for a long time */
<span class="line-modified"> 56     testedThread = ec_jni-&gt;NewGlobalRef(thrd, TRACE_JNI_CALL);</span>

 57 }
 58 
 59 static void
 60 showEventStatistics(int step) {
 61     int i;
 62     const char* str;
 63     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 64 
 65     NSK_DISPLAY0(&quot;\n&quot;);
 66     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 67     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 68     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 69         if (currentCounts[i] &gt; 0) {
 70             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 71             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 72         }
 73     }
 74 }
 75 
 76 /* ========================================================================== */
 77 
<span class="line-modified"> 78 bool checkEvents(int step) {</span>
 79     int i;
 80     jvmtiEvent curr;
<span class="line-modified"> 81     bool result = true;</span>
 82     int *currentCounts;
 83     int isExpected = 0;
 84 
 85     switch (step) {
 86         case 1:
 87             currentCounts = &amp;eventCount[0];
 88             break;
 89 
 90         case 2:
 91         case 3:
 92             currentCounts = &amp;newEventCount[0];
 93             break;
 94 
 95         default:
 96             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified"> 97             return false;</span>
 98     }
 99 
100     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
101 
102         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
103 
104         switch (step) {
105             case 1:
106                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
107                                 || (curr == JVMTI_EVENT_FRAME_POP));
108                 break;
109 
110             case 2:
111                 isExpected = (curr == JVMTI_EVENT_FRAME_POP);
112                 break;
113 
114             case 3:
115                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
116                 break;
117         }
118 
119         if (isExpected) {
120             if (curr == JVMTI_EVENT_FRAME_POP) {
121                 if (currentCounts[i] != NUMBER_OF_INVOCATIONS) {
122                     NSK_COMPLAIN3(&quot;Unexpected number of %s events %d, expected value is %d\n&quot;,
123                                         TranslateEvent(curr),
124                                         currentCounts[i],
125                                         NUMBER_OF_INVOCATIONS);
<span class="line-modified">126                     result = false;</span>
127                 }
128             } else {
129                 if (currentCounts[i] &lt; 1) {
130                         NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
131                                             currentCounts[i],
132                                             TranslateEvent(curr));
<span class="line-modified">133                     result = false;</span>
134                 }
135             }
136 
137         } else {
138 
139             if (currentCounts[i] &gt; 0) {
140                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
141                                     TranslateEvent(curr),
142                                     currentCounts[i]);
<span class="line-modified">143                 result = false;</span>
144             }
145         }
146     }
147 
148     return result;
149 }
150 
151 static void
152 changeCount(jvmtiEvent event, int *currentCounts) {
153 
154     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
155         nsk_jvmti_setFailStatus();
156 
157     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
158 
159     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
160         nsk_jvmti_setFailStatus();
161 
162 }
163 
</pre>
<hr />
<pre>
308 void JNICALL
309 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
310     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
311 }
312 
313 void JNICALL
314 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
315 
316     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
317 }
318 
319 void JNICALL
320 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
321                     jobject object, jclass object_klass, jlong size) {
322 
323     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
324 }
325 
326 /* ============================================================================= */
327 
<span class="line-modified">328 static bool enableEvent(jvmtiEvent event) {</span>
329 
330     if (nsk_jvmti_isOptionalEvent(event)
331             &amp;&amp; (event != JVMTI_EVENT_FRAME_POP)) {
332         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
333                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
334             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
335                 TranslateEvent(event));
<span class="line-modified">336             return false;</span>
337         }
338     } else {
339         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
340             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
341                 TranslateEvent(event));
<span class="line-modified">342             return false;</span>
343         }
344     }
345 
<span class="line-modified">346     return true;</span>
347 }
348 
349 /**
350  * Enable or disable tested events.
351  */
<span class="line-modified">352 static bool enableEventList() {</span>
353 
354     int i, result;
355 
356     result = enableEvent(JVMTI_EVENT_VM_INIT);
357 
358     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
359 
360     /* enabling optional events */
361     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
362         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
363 
364         if (nsk_jvmti_isOptionalEvent(event))
365             result = result &amp;&amp; enableEvent(event);
366     }
367 
<span class="line-modified">368     if (!result) {</span>
369         nsk_jvmti_setFailStatus();
<span class="line-modified">370         return false;</span>
371     }
372 
<span class="line-modified">373     return true;</span>
374 }
375 
376 /* ============================================================================= */
377 
<span class="line-modified">378 static bool setCallBacks(int step) {</span>

379 
380     int i;
381 
382     jvmtiEventCallbacks eventCallbacks;
383     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
384 
385     switch (step) {
386         case 1:
387             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
388                 eventCount[i] = 0;
389             }
390 
391             eventCallbacks.VMInit                    = cbVMInit;
392             eventCallbacks.Exception                 = cbException;
393             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
394             eventCallbacks.SingleStep                = cbSingleStep;
395             eventCallbacks.FramePop                  = cbFramePop;
396             eventCallbacks.Breakpoint                = cbBreakpoint;
397             eventCallbacks.FieldAccess               = cbFieldAccess;
398             eventCallbacks.FieldModification         = cbFieldModification;
</pre>
<hr />
<pre>
412             break;
413 
414         case 2:
415             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
416                 newEventCount[i] = 0;
417             }
418 
419             eventCallbacks.FramePop                  = cbNewFramePop;
420             break;
421 
422         case 3:
423             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
424                 newEventCount[i] = 0;
425             }
426 
427             eventCallbacks.VMDeath                   = cbVMDeath;
428             break;
429 
430     }
431     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">432         return false;</span>
433 
<span class="line-modified">434     return true;</span>
435 }
436 
437 /* ============================================================================= */
438 
439 /** Agent algorithm. */
440 static void JNICALL
441 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
442 
443     int i, j;
444 
445     for (i = 1; i &lt;= STEP_NUMBER; i++) {
446 
447         if (!nsk_jvmti_waitForSync(timeout))
448             return;
449 
450         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SuspendThread(testedThread)))
451             return;
452 
453         for (j = 2; j &lt; 1002; j++) {
454             if (!NSK_JVMTI_VERIFY(jvmti-&gt;NotifyFramePop(testedThread, j)))
</pre>
</td>
</tr>
</table>
<center><a href="../em02t011/libem02t011.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="libem02t012.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/share/jdi/Debugee.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.share.jdi;
 25 
 26 import nsk.share.*;
 27 import nsk.share.jpda.*;
 28 
 29 import com.sun.jdi.*;
 30 import com.sun.jdi.request.*;
 31 import com.sun.jdi.event.*;
 32 
 33 import java.util.*;
 34 
 35 /**
 36  * This class is used to interact with debugee VM using JDI features.
 37  * &lt;p&gt;
 38  * This class is wrapper for debugee VM constructed by &lt;code&gt;Binder&lt;/code&gt;
 39  * and it uses &lt;code&gt;com.sun.jdi.VirtualMachine&lt;/code&gt; to interact with debugee VM.
 40  * &lt;p&gt;
 41  * In addition to the general abities to control of debugee VM process,
 42  * provided by the base class &lt;code&gt;DebugeeProcess&lt;/code&gt;, this class
 43  * adds also several service methods over the JDI features to simplify interaction
 44  * with debugee VM (such as finding classes, setting breakpoints,
 45  * handling events, and so on.).
 46  *
 47  * @see Binder
 48  * @see DebugeeProcess
 49  */
 50 abstract public class Debugee extends DebugeeProcess {
 51     /**
 52      * Mirror of the debugee VM. This must be initialized by every
 53      * particular non-abstract class extending Debugee class.
 54      */
 55     protected VirtualMachine vm = null;
 56 
 57     /** Binder that created this debugee. */
 58     protected Binder binder = null;
 59 
 60     /** Argument handler. */
 61     protected ArgumentHandler argumentHandler = null;
 62 
 63     /** Create new &lt;code&gt;Debugee&lt;/code&gt; object for a given binder. */
 64     protected Debugee (Binder binder) {
 65         super(binder);
 66         this.binder = binder;
 67         this.argumentHandler = (ArgumentHandler)binder.getArgumentHandler();
 68     }
 69 
 70     /** Setup &lt;code&gt;Debugee&lt;/code&gt; object with given VM mirror. */
 71     public void setupVM(VirtualMachine vm) {
 72         if (this.vm != null) {
 73             throw new TestBug(&quot;Setting duplicated VM mirror for Debugee object&quot;);
 74         }
 75         this.vm = vm;
 76         int traceMode = argumentHandler.getTraceMode();
 77         if (traceMode != VirtualMachine.TRACE_NONE) {
 78             display(&quot;Setting JDI trace mode to: &quot; + argumentHandler.getTraceModeString());
 79             setDebugTraceMode(traceMode);
 80         }
 81     }
 82 
 83     /** Return &lt;code&gt;Binder&lt;/code&gt; of the debugee object. */
 84     public Binder getBinder() {
 85         return binder;
 86     }
 87 
 88     /** Return JDI mirror of the debugee VM. */
 89     public VirtualMachine VM() {
 90         return vm;
 91     }
 92 
 93     /** Return &lt;code&gt;EventRequestManager&lt;/code&gt; of the debugee object. */
 94     public EventRequestManager getEventRequestManager() {
 95         return vm.eventRequestManager();
 96     }
 97 
 98     // --------------------------------------------------- //
 99 
100     /** List of the currently running threads. */
101     public ThreadReference[] threads () {
102         List list = vm.allThreads();
103         int size = list.size();
104         ThreadReference array[] = new ThreadReference[size];
105         Iterator iterator = list.iterator();
106         for (int i = 0; i &lt; size; i++)
107             array[i] = (ThreadReference) iterator.next();
108         if (iterator.hasNext())
109             throw new Oddity(&quot;extra element in a list?&quot;);
110         return array;
111     }
112 
113     /** List of all types loaded by the debugee VM. */
114     public ReferenceType[] classes() {
115         return classes(null);
116     }
117 
118     /**
119      * List of all classes of the given &lt;code&gt;name&lt;/code&gt; loaded by
120      * the debugee VM; or list of all classes, if &lt;code&gt;name&lt;/code&gt;
121      * is &lt;code&gt;null&lt;/code&gt;.
122      */
123     private ReferenceType[] classes (String name) {
124         List list = (name==null)? vm.allClasses(): vm.classesByName(name);
125         int size = list.size();
126         ReferenceType array[] = new ReferenceType [ size ];
127         Iterator iterator = list.iterator();
128         for (int i=0; i&lt;size; i++)
129             array[i] = (ReferenceType) iterator.next();
130         if (iterator.hasNext())
131             throw new Oddity(&quot;extra element in a list?&quot;);
132         return array;
133     }
134 
135     // --------------------------------------------------- //
136 
137     /**
138      * Return mirror for the only class of the given &lt;code&gt;name&lt;/code&gt;
139      * loaded by the debugee VM; or throw TestBug exception if there
140      * are more than one such class found. TestFailure exception
141      * will be thrown in case when mirrors for classes with different
142      * names or duplicated mirrors were returned.
143      * Return &lt;code&gt;null&lt;/code&gt; if there is no such class loaded.
144      */
145     public ReferenceType classByName (String name) {
146         ReferenceType classes[] = this.classes(name);
147 
148         // if on first call debuggee doesn&#39;t return needed class try get this class one more time after delay to avoid 6446633
149         if (classes == null || classes.length == 0) {
150             try {
151                 Thread.sleep(1000);
152             }
153             catch(InterruptedException e) {
154                 throw new TestBug(&quot;Unexpected InterruptedException&quot;);
155             }
156 
157             classes = this.classes(name);
158         }
159 
160         if (classes == null || classes.length == 0)
161             return null;
162 
163         // analyze returned mirrors and throw appropriate exception
164         if (classes.length &gt; 1) {
165             boolean duplicatesFound = false;
166             boolean differentNamesFound = false;
167             boolean visited[] = new boolean[classes.length];
168             complain(&quot;Classes that were found for name \&quot;&quot; + name + &quot;\&quot;:&quot;);
169             for(ReferenceType klass : classes) {
170                 complain(&quot;\t&quot; + klass);
171             }
172             for(int c = 0; c &lt; classes.length; c++) {
173                 if(visited[c]) {
174                     continue;
175                 }
176                 if(!classes[c].name().equals(name)) {
177                     differentNamesFound = true;
178                     continue;
179                 }
180                 for(int i = c + 1; i &lt; classes.length; i++) {
181                     if(visited[i]) {
182                         continue;
183                     } else {
184                         visited[i] = true;
185                     }
186                     if(classes[c].classLoader() == classes[i].classLoader()) {
187                         duplicatesFound = true;
188                     }
189                 }
190             }
191             if(duplicatesFound) {
192                 throw new TestFailure(&quot;classes with the same name and &quot; +
193                                       &quot;loaded with the same class loader &quot; +
194                                       &quot;were found.&quot;);
195             } else if(differentNamesFound) {
196                 throw new TestFailure(&quot;class with name different from &#39;&quot; + name +
197                                       &quot;&#39; was returned by VirutualMachine.classesByName.&quot;);
198             } else {
199                 throw new TestBug(&quot;found &quot; + classes.length + &quot; such classes: &quot; + name);
200             }
201         }
202         return classes[0];
203     }
204 
205     /**
206      * Return mirror for the only method of the given &lt;code&gt;refType&lt;/code&gt;
207      * class in the debugee VM; or throw TestBug exception if there
208      * are more than one such method found. Return &lt;code&gt;null&lt;/code&gt; if
209      * there is no such method found.
210      */
211     public Method methodByName(ReferenceType refType, String name) {
212         List methods = refType.methodsByName(name);
213         if (methods == null || methods.isEmpty()) return null;
214         if (methods.size() &gt; 1)
215             throw new TestBug(
216                 &quot;found &quot; + methods.size() + &quot; such methods: &quot; + name);
217         Method method = (Method)methods.get(0);
218         return method;
219     }
220 
221     /**
222      * Return a currently running thread of the given &lt;code&gt;name&lt;/code&gt;; or
223      * throw TestBug exception if there are more than one such thread found.
224      * Return &lt;code&gt;null&lt;/code&gt; if there is no such thread.
225      */
226     public ThreadReference threadByName (String name) {
227         ThreadReference threads[] = this.threads();
228         int count = 0, index = -1;
229         for (int i = 0; i &lt; threads.length; i++) {
230             if (threads[i].name().compareTo(name)==0) {
231                 count++;
232                 index = i;
233             }
234         }
235         if (count == 0)
236             return null;
237         if (count &gt; 1)
238             throw new TestBug(
239                 &quot;found &quot; + count + &quot; such threads: &quot; + name);
240         return threads[index];
241     }
242 
243     // --------------------------------------------------- //
244 
245     /**
246      * Returns Location object for given line number in specified method or null
247      * if no location for this line is found.
248      *
249      * @param method method mirror containing given line number
250      * @param line line number to find location
251      */
252     public Location getLineLocation(Method method, int line) {
253         List locs = null;
254         try {
255             locs = method.allLineLocations();
256         } catch(AbsentInformationException e) {
257             throw new TestBug(&quot;Unable to find location for line &quot; + line + &quot;: &quot; + e);
258         }
259         Iterator iter = locs.iterator();
260         while (iter.hasNext()) {
261             Location location = (Location)iter.next();
262             if (location.lineNumber() == line) {
263                 return location;
264             }
265         }
266         return null;
267     }
268 
269     /**
270      * Returns Location object for given line number in specified reference type or null
271      * if no location for this line is found.
272      *
273      * @param refType reference type mirror containing given line number
274      * @param line line number to find location
275      */
276     public Location getLineLocation(ReferenceType refType, int line) {
277         List locs = null;
278         try {
279             locs = refType.allLineLocations();
280         } catch(AbsentInformationException e) {
281             throw new TestBug(&quot;Unable to find location for line &quot; + line + &quot;: &quot; + e);
282         }
283         Iterator iter = locs.iterator();
284         while (iter.hasNext()) {
285             Location location = (Location)iter.next();
286             if (location.lineNumber() == line) {
287                 return location;
288             }
289         }
290         return null;
291     }
292 
293     // --------------------------------------------------- //
294 
295     /**
296      * Make disabled breakpoint to given location and return BreakpointRequest.
297      *
298      * @param location location to set breakpoint
299      *
300      * @see #setBreakpoint(Method, int)
301      * @see #setBreakpoint(ReferenceType, String, int)
302      */
303     public BreakpointRequest makeBreakpoint(Location location) {
304         EventRequestManager evm = getEventRequestManager();
305         BreakpointRequest request = evm.createBreakpointRequest(location);
306         display(&quot;Breakpoint set:\n\t&quot; + request);
307         return request;
308     }
309 
310     /**
311      * Make disabled breakpoint to given line number in specified method
312      * and return BreakpointRequest.
313      *
314      * @param method method mirror to set breakpoint
315      * @param lineNumber line number inside the method
316      *
317      * @throws Failure if no location found for specified line number
318      *
319      * @see #makeBreakpoint(Location)
320      * @see #makeBreakpoint(ReferenceType, String, int)
321      */
322     public BreakpointRequest makeBreakpoint(Method method, int lineNumber) {
323         Location location = getLineLocation(method, lineNumber);
324         if (location == null) {
325             throw new Failure(&quot;No location found for setting breakpoint to line &quot; + lineNumber);
326         }
327         return makeBreakpoint(location);
328     }
329 
330     /**
331      * Make disabled breakpoint to given line number for specified method name
332      * of the given reference type and return BreakpointRequest.
333      *
334      * @param refType reference type for specified method
335      * @param methodName method name to set breakpoint
336      * @param lineNumber line number inside the method
337      *
338      * @throws Failure if no location found for specified line number
339      *
340      * @see #makeBreakpoint(Method, int)
341      */
342     public BreakpointRequest makeBreakpoint(ReferenceType refType,
343                                             String methodName, int lineNumber) {
344         Method method = methodByName(refType, methodName);
345         if (method == null) {
346             throw new Failure(&quot;No method found for setting breakpoint: &quot; + methodName);
347         }
348         return makeBreakpoint(method, lineNumber);
349     }
350 
351     /**
352      * Set and enable breakpoint to given line number for specified method
353      * and return BreakpointRequest.
354      *
355      * @param method method mirror to set breakpoint
356      * @param lineNumber line number inside the method
357      *
358      * @throws Failure if no location found for specified line number
359      *
360      * @see #setBreakpoint(ReferenceType, String, int)
361      */
362     public BreakpointRequest setBreakpoint(Method method, int lineNumber) {
363         BreakpointRequest request = makeBreakpoint(method, lineNumber);
364         request.enable();
365         return request;
366     }
367 
368     /**
369      * Set and enable breakpoint to given line number for specified method name
370      * of the given reference type and return BreakpointRequest.
371      *
372      * @param refType reference type for specified method
373      * @param methodName method name to set breakpoint
374      * @param lineNumber line number inside the method
375      *
376      * @throws Failure if no location found for specified line number
377      *
378      * @see #setBreakpoint(Method, int)
379      */
380     public BreakpointRequest setBreakpoint(ReferenceType refType,
381                                             String methodName, int lineNumber) {
382         BreakpointRequest request = makeBreakpoint(refType, methodName, lineNumber);
383         request.enable();
384         return request;
385     }
386 
387     // --------------------------------------------------- //
388 
389     /** Suspend the debugee VM. */
390     public void suspend() {
391         vm.suspend();
392     }
393 
394     /** Resume the debugee VM. */
395     public void resume() {
396         vm.resume();
397     }
398 
399     /** Dispose the debugee VM. */
400     public void dispose() {
401         vm.dispose();
402     }
403 
404     /*
405      * Set internal JDI tracing mode.
406      */
407     public void setDebugTraceMode(int traceMode) {
408         vm.setDebugTraceMode(traceMode);
409     }
410 
411     // --------------------------------------------------- //
412 
413     /**
414      * Wait for the requested event and skip other events.
415      *
416      * @param request non-null value for events generated by this
417      * event request; null value for &lt;code&gt;VMStartEvent&lt;/code&gt;.
418      * @param timeout timeout in milliseconds to wait for the requested event.
419      *
420      * @throws InterruptedException if another thread has interrupted this thread
421      */
422     public Event waitingEvent(EventRequest request, long timeout)
423                                                 throws InterruptedException {
424 
425         if (request == null) {
426             throw new Failure(&quot;Null request specified for waiting events: &quot; + request);
427         }
428 
429         long timeToFinish = System.currentTimeMillis() + timeout;
430         long timeLeft = timeout;
431         boolean exit = false;
432 
433         display(&quot;Waiting for event by request:\n\t&quot; + request);
434 
435         EventQueue eventQueue = vm.eventQueue();
436         while (timeLeft &gt; 0 &amp;&amp; !exit) {
437 
438             EventSet eventSet = eventQueue.remove(timeLeft);
439             if (eventSet == null) {
440                 continue;
441             }
442 
443             EventIterator eventIterator = eventSet.eventIterator();
444             while (eventIterator.hasNext()) {
445 
446                 Event event = eventIterator.nextEvent();
447                 EventRequest eventRequest = event.request();
448 
449                 if (request == eventRequest || request.equals(eventRequest)) {
450                     display(&quot;Got requested event:\n\t&quot; + event);
451                     return event;
452                 } else if (event instanceof VMDeathEvent) {
453                     display(&quot;Ignore unexpected VMDeathEvent&quot;);
454                 } else if (event instanceof VMDisconnectEvent) {
455                     display(&quot;Got unexpected VMDisconnectEvent&quot;);
456                     exit = true;
457                     break;
458                 } else {
459                     display(&quot;Ignore unexpected event:\n\t&quot; + event);
460                 } // if
461 
462             } // while
463 
464             timeLeft = timeToFinish - System.currentTimeMillis();
465 
466         } // while
467 
468         return null;
469     }
470 
471     /*
472      * Wait for VM to initialize by receiving initial VM_START event for specified timeout.
473      */
474     public void waitForVMInit(long timeout) {
475         waitForVMInit(vm ,log, timeout);
476     }
477 
478     /*
479      * This static method is also used by nsk.share.jdi.ConnectorTest
480      */
481     static public void waitForVMInit(VirtualMachine vm, Log log, long timeout) {
482         try {
483             EventSet eventSet = vm.eventQueue().remove(timeout);
484             if (eventSet == null) {
485                 throw new Failure(&quot;No VMStartEvent received for timeout: &quot; + timeout + &quot; ms&quot;);
486             }
487             EventIterator iterator = eventSet.eventIterator();
488             while (iterator.hasNext()) {
489                 Event event = iterator.nextEvent();
490                 if (event == null) {
491                     throw new Failure(&quot;Null event received instead of VMStartEvent&quot;);
492                 }
493                 if (event instanceof VMStartEvent) {
494                     log.display(&quot;Initial VMStartEvent received: &quot; + event);
495                 } else {
496                     throw new Failure(&quot;Unexpected event received instead of VMStartEvent: &quot; + event);
497                 }
498             }
499             int suspendPolicy = eventSet.suspendPolicy();
500             if (suspendPolicy != EventRequest.SUSPEND_ALL) {
501                 throw new Failure(&quot;Suspend policy of VMStartEvent is not SUSPEND_ALL: &quot; + suspendPolicy);
502             }
503         } catch (InterruptedException e) {
504             e.printStackTrace(log.getOutStream());
505             throw new Failure(&quot;Thread interrupted while waiting for VMStartEvent:\n\t&quot; + e);
506         }
507     }
508 
509     // --------------------------------------------------- //
510 
511     /**
512      * Bind to debuggee VM using &lt;code&gt;Binder&lt;/code&gt; and make initial
513      * synchronization via IOPipe.
514      *
515      * @param argHandler command line arguments handler to make &lt;code&gt;Binder&lt;/code&gt; object
516      * @param log &lt;code&gt;Log&lt;/code&gt; object to log messages
517      * @param mainClassName main class of debugee
518      *
519      * @throws Failure if there were problems with binding to debuggee VM
520      *
521      * @see Binder#bindToDebugee(String)
522      */
523     public static Debugee prepareDebugee(ArgumentHandler argHandler, Log log,
524                                                 String mainClassName) {
525         Binder binder = new Binder(argHandler, log);
526         Debugee debugee = binder.bindToDebugee(mainClassName);
527 
528         debugee.createIOPipe();
529 
530         debugee.redirectStderr(log, DEBUGEE_STDERR_LOG_PREFIX);
531         debugee.resume();
532 
533         debugee.receiveExpectedSignal(&quot;ready&quot;);
534 
535         return debugee;
536     }
537 
538     /**
539      * Send &lt;code&gt;&quot;quit&quot;&lt;/code&gt; signal, wait for debugee VM exit and check exit.
540      *
541      * @throws Failure if exit status is not &lt;code&gt;Consts.JCK_STATUS_BASE&lt;/code&gt;
542      *
543      * @see #endDebugee()
544      */
545     public void quit() {
546         sendSignal(&quot;quit&quot;);
547         int status = endDebugee();
548         if ( status != Consts.JCK_STATUS_BASE ) {
549             throw new Failure(&quot;Got unexpected debugee VM exit status: &quot; + status
550                                 + &quot; (not &quot; + Consts.JCK_STATUS_BASE + &quot;)&quot;);
551         }
552         display(&quot;Got expected debugee VM exit status: &quot; + status);
553     }
554 
555     /*
556      * Dispose debuggee VM, wait for it to exit, close all resources and return
557      * exit status code.
558      */
559     public int endDebugee() {
560         int status = waitFor();
561         if (vm != null) {
562             try {
563                 vm.dispose();
564             } catch (VMDisconnectedException ignore) {
565             }
566             vm = null;
567         }
568         return status;
569     }
570 
571     /*
572      * Print information about all threads in debuggee VM
573      */
574     protected void printThreadsInfo(VirtualMachine vm)  {
575         try {
576             log.display(&quot;------------ Try to print debuggee threads before killing process ------------&quot;);
577             if (vm == null) {
578                 log.display(&quot;Can&#39;t print threads info because &#39;vm&#39; is null&quot;);
579                 return;
580             }
581             List&lt;ThreadReference&gt; threads = vm.allThreads();
582             log.display(&quot;Threads: &quot; + threads);
583             log.display(&quot;Total threads: &quot; + threads.size());
584             for (ThreadReference thread : threads) {
585                 log.display(&quot;\nThread: &quot; + thread.name());
586                 log.display(&quot;Is suspended: &quot; + thread.isSuspended());
587                 log.display(&quot;Is at breakpoint: &quot; + thread.isAtBreakpoint());
588                 boolean wasSuspended = false;
589                 try {
590                     if (!thread.isSuspended()) {
591                         log.display(&quot;\n suspend thread to get its stack \n&quot;);
592                         thread.suspend();
593                         wasSuspended = true;
594                     }
595                     log.display(&quot;Stack frame count: &quot; + thread.frameCount());
596                     if (thread.frameCount() &gt; 0) {
597                         log.display(&quot;Frames:&quot;);
598                         for (StackFrame frame : thread.frames()) {
599                             Location location = frame.location();
600                             log.display(location.declaringType().name() + &quot;.&quot; + location.method().name() + &quot;, line: &quot; + location.lineNumber());
601                         }
602                     }
603                 } finally {
604                     if (wasSuspended) {
605                         log.display(&quot;\n resume thread \n&quot;);
606                         thread.resume();
607                     }
608                 }
609             }
610             log.display(&quot;----------------------------------------------------------------------&quot;);
611         } catch (Throwable t) {
612             log.complain(&quot;&quot;);
613             t.printStackTrace(log.getOutStream());
614         }
615     }
616 
617     /**
618      * Force debugge VM to exit using JDI interface if possible.
619      */
620     protected void killDebugee() {
621         try {
622             // print information about debuggee threads to simplify failure analysis
623             printThreadsInfo(vm);
624         } finally {
625             if (vm != null) {
626                 try {
627                     display(&quot;Killing debuggee by forcing target VM to exit&quot;);
628                     vm.exit(97);
629                     display(&quot;Debugee VM successfully forced to exit&quot;);
630                     vm = null;
631                 } catch (VMDisconnectedException e) {
632                     display(&quot;Ignore VMDisconnectedException while forcing debuggee VM to exit:\n\t&quot;
633                             + e);
634                 }
635             }
636         }
637     }
638 
639     public boolean isJFR_active() {
640         String opts = argumentHandler.getLaunchOptions();
641         int jfrPos = opts.indexOf(&quot;-XX:+FlightRecorder&quot;);
642 
643         if (jfrPos &gt;= 0)
644             return true;
645         else
646             return false;
647     }
648 }
    </pre>
  </body>
</html>
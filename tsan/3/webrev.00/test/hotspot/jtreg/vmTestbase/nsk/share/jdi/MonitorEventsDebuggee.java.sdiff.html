<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/share/jdi/MonitorEventsDebuggee.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="JDIEventsDebuggee.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../jni/ExceptionCheckingJniEnv.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/share/jdi/MonitorEventsDebuggee.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 36         EXIT_WITH_TIMEOUT,
 37         INTERRUPT,
 38         NOTIFY,
 39         NOTIFY_ALL
 40     }
 41 
 42     // this thread forces MonitorWaitExecutor to exit from wait()
 43     class AuxiliaryThread extends Thread {
 44         private Thread threadToInterrupt;
 45 
 46         private Object monitor;
 47 
 48         public AuxiliaryThread(Thread threadToInterrupt, Object monitor) {
 49             this.threadToInterrupt = threadToInterrupt;
 50             this.monitor = monitor;
 51         }
 52 
 53         public void run() {
 54             // wait when interrupted thread switches state to &#39;TIMED_WAITING&#39;
 55             while ((threadToInterrupt.getState() != Thread.State.WAITING) &amp;&amp; !exitedFromWait) {
<span class="line-modified"> 56                 yield();</span>
 57             }
 58 
 59             // threadToInterrupt &#39;spuriously&#39; exited from wait()
 60             if(exitedFromWait)
 61                 return;
 62 
 63             if (exitFromWaitType == ExitFromWaitType.INTERRUPT) {
 64                 threadToInterrupt.interrupt();
 65             } else if ((exitFromWaitType == ExitFromWaitType.NOTIFY)
 66                     || (exitFromWaitType == ExitFromWaitType.NOTIFY_ALL)) {
 67                 /*
 68                  * NOTE: thread&#39;s state WAITING doesn&#39;t guarantee that thread released
 69                  * monitor, and entering to the next synchronized block may cause MonitorContentedEnterEvent
 70                  * (if corresponding request was created).
 71                  *
 72                  * Debugger should take in account this issue.
 73                  */
 74                 synchronized (monitor) {
 75                     if (exitFromWaitType == ExitFromWaitType.NOTIFY)
 76                         monitor.notify();
</pre>
<hr />
<pre>
219 
220     static {
221         System.loadLibrary(nativeLibararyName);
222     }
223 
224     // this thread forces MonitorLockingThread to release holding lock
225     static class LockFreeThread extends Thread {
226         private Thread blockedThread;
227 
228         private MonitorLockingThread lockingThread;
229 
230         public LockFreeThread(Thread blockedThread,
231                 MonitorLockingThread lockingThread) {
232             this.blockedThread = blockedThread;
233             this.lockingThread = lockingThread;
234         }
235 
236         public void run() {
237             // wait when blocked thread switches state to &#39;BLOCKED&#39;
238             while (blockedThread.getState() != Thread.State.BLOCKED)
<span class="line-modified">239                 yield();</span>
240 
241             lockingThread.releaseLock();
242         }
243     }
244 
245     private boolean monitorEnter;
246 
247     private boolean monitorEntered;
248 
249     public MonitorEnterExecutor(boolean monitorEnter, boolean monitorEntered) {
250         this.monitorEnter = monitorEnter;
251         this.monitorEntered = monitorEntered;
252     }
253 
254     protected void monitorEnter() {
255         // locking thread acquires &#39;this&#39; lock
256         MonitorLockingThread lockingThread = new MonitorLockingThread(this);
257         lockingThread.acquireLock();
258 
259         if (monitorEnter) {
</pre>
</td>
<td>
<hr />
<pre>
 36         EXIT_WITH_TIMEOUT,
 37         INTERRUPT,
 38         NOTIFY,
 39         NOTIFY_ALL
 40     }
 41 
 42     // this thread forces MonitorWaitExecutor to exit from wait()
 43     class AuxiliaryThread extends Thread {
 44         private Thread threadToInterrupt;
 45 
 46         private Object monitor;
 47 
 48         public AuxiliaryThread(Thread threadToInterrupt, Object monitor) {
 49             this.threadToInterrupt = threadToInterrupt;
 50             this.monitor = monitor;
 51         }
 52 
 53         public void run() {
 54             // wait when interrupted thread switches state to &#39;TIMED_WAITING&#39;
 55             while ((threadToInterrupt.getState() != Thread.State.WAITING) &amp;&amp; !exitedFromWait) {
<span class="line-modified"> 56                 Thread.yield();</span>
 57             }
 58 
 59             // threadToInterrupt &#39;spuriously&#39; exited from wait()
 60             if(exitedFromWait)
 61                 return;
 62 
 63             if (exitFromWaitType == ExitFromWaitType.INTERRUPT) {
 64                 threadToInterrupt.interrupt();
 65             } else if ((exitFromWaitType == ExitFromWaitType.NOTIFY)
 66                     || (exitFromWaitType == ExitFromWaitType.NOTIFY_ALL)) {
 67                 /*
 68                  * NOTE: thread&#39;s state WAITING doesn&#39;t guarantee that thread released
 69                  * monitor, and entering to the next synchronized block may cause MonitorContentedEnterEvent
 70                  * (if corresponding request was created).
 71                  *
 72                  * Debugger should take in account this issue.
 73                  */
 74                 synchronized (monitor) {
 75                     if (exitFromWaitType == ExitFromWaitType.NOTIFY)
 76                         monitor.notify();
</pre>
<hr />
<pre>
219 
220     static {
221         System.loadLibrary(nativeLibararyName);
222     }
223 
224     // this thread forces MonitorLockingThread to release holding lock
225     static class LockFreeThread extends Thread {
226         private Thread blockedThread;
227 
228         private MonitorLockingThread lockingThread;
229 
230         public LockFreeThread(Thread blockedThread,
231                 MonitorLockingThread lockingThread) {
232             this.blockedThread = blockedThread;
233             this.lockingThread = lockingThread;
234         }
235 
236         public void run() {
237             // wait when blocked thread switches state to &#39;BLOCKED&#39;
238             while (blockedThread.getState() != Thread.State.BLOCKED)
<span class="line-modified">239                 Thread.yield();</span>
240 
241             lockingThread.releaseLock();
242         }
243     }
244 
245     private boolean monitorEnter;
246 
247     private boolean monitorEntered;
248 
249     public MonitorEnterExecutor(boolean monitorEnter, boolean monitorEntered) {
250         this.monitorEnter = monitorEnter;
251         this.monitorEntered = monitorEntered;
252     }
253 
254     protected void monitorEnter() {
255         // locking thread acquires &#39;this&#39; lock
256         MonitorLockingThread lockingThread = new MonitorLockingThread(this);
257         lockingThread.acquireLock();
258 
259         if (monitorEnter) {
</pre>
</td>
</tr>
</table>
<center><a href="JDIEventsDebuggee.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../jni/ExceptionCheckingJniEnv.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
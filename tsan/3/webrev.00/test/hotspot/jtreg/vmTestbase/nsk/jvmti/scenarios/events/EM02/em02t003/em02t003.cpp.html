<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t003/em02t003.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* ============================================================================= */
 34 
 35 /* scaffold objects */
 36 static jvmtiEnv *jvmti = NULL;
 37 static jlong timeout = 0;
 38 static jrawMonitorID syncLock = NULL;
 39 
 40 /* constant names */
 41 #define STEP_AMOUNT 3
 42 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 43 
 44 static int eventCount[JVMTI_EVENT_COUNT];
 45 static int newEventCount[JVMTI_EVENT_COUNT];
 46 static int loadEvents = 0;
 47 static int unloadEvents = 0;
 48 
 49 /* ============================================================================= */
 50 
 51 static void
 52 showEventStatistics(int step) {
 53     int i;
 54     const char* str;
 55     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 56 
 57     NSK_DISPLAY0(&quot;\n&quot;);
 58     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 59     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 60     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 61         if (currentCounts[i] &gt; 0) {
 62             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 63             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 64         }
 65     }
 66 }
 67 
 68 /* ========================================================================== */
 69 
 70 bool checkEvents(int step) {
 71     int i;
 72     jvmtiEvent curr;
 73     bool result = true;
 74     int *currentCounts;
 75     int isExpected = 0;
 76 
 77     switch (step) {
 78         case 1:
 79             currentCounts = &amp;eventCount[0];
 80             break;
 81 
 82         case 2:
 83         case 3:
 84             currentCounts = &amp;newEventCount[0];
 85             break;
 86 
 87         default:
 88             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
 89             return false;
 90     }
 91 
 92     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 93 
 94         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 95 
 96         switch (step) {
 97             case 1:
 98                 isExpected = ((curr == JVMTI_EVENT_COMPILED_METHOD_LOAD)
 99                                 || (curr == JVMTI_EVENT_VM_INIT));
100                 break;
101 
102             case 2:
103                 isExpected = (curr == JVMTI_EVENT_COMPILED_METHOD_LOAD);
104                 break;
105 
106             case 3:
107                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
108                 break;
109         }
110 
111         if (isExpected) {
112             if (currentCounts[i] &lt; 0) {
113                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
114                                         currentCounts[i],
115                                         TranslateEvent(curr));
116                 result = false;
117             }
118         } else {
119 
120             if (curr != JVMTI_EVENT_COMPILED_METHOD_UNLOAD) {
121                 if (currentCounts[i] &gt; 0) {
122                     NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
123                                         TranslateEvent(curr),
124                                         currentCounts[i]);
125                     result = false;
126                 }
127             }
128         }
129     }
130 
131     return result;
132 }
133 
134 static void
135 changeCount(jvmtiEvent event, int *currentCounts) {
136 
137     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
138         nsk_jvmti_setFailStatus();
139 
140     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
141 
142     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
143         nsk_jvmti_setFailStatus();
144 
145 }
146 
147 /* ============================================================================= */
148 
149 /* callbacks */
150 JNIEXPORT void JNICALL
151 cbVMInit(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread) {
152     changeCount(JVMTI_EVENT_VM_INIT, &amp;eventCount[0]);
153 }
154 
155 JNIEXPORT void JNICALL
156 cbVMDeath(jvmtiEnv* jvmti, JNIEnv* jni_env) {
157     changeCount(JVMTI_EVENT_VM_DEATH, &amp;newEventCount[0]);
158     showEventStatistics(STEP_AMOUNT);
159     if (!checkEvents(STEP_AMOUNT))
160         nsk_jvmti_setFailStatus();
161 
162     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock)))
163         nsk_jvmti_setFailStatus();
164 
165 }
166 
167 void JNICALL
168 cbException(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
169                 jmethodID method, jlocation location, jobject exception,
170                 jmethodID catch_method, jlocation catch_location) {
171     changeCount(JVMTI_EVENT_EXCEPTION, &amp;eventCount[0]);
172 }
173 
174 void JNICALL
175 cbExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
176                 jmethodID method, jlocation location, jobject exception) {
177     changeCount(JVMTI_EVENT_EXCEPTION_CATCH, &amp;eventCount[0]);
178 }
179 
180 void JNICALL
181 cbSingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
182                 jmethodID method, jlocation location) {
183     changeCount(JVMTI_EVENT_SINGLE_STEP, &amp;eventCount[0]);
184 }
185 
186 void JNICALL
187 cbFramePop(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
188                 jmethodID method, jboolean was_popped_by_exception) {
189     changeCount(JVMTI_EVENT_FRAME_POP, &amp;eventCount[0]);
190 }
191 
192 void JNICALL
193 cbBreakpoint(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
194                 jmethodID method, jlocation location) {
195     changeCount(JVMTI_EVENT_BREAKPOINT, &amp;eventCount[0]);
196 }
197 
198 void JNICALL
199 cbFieldAccess(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
200                 jmethodID method, jlocation location, jclass field_klass,
201                 jobject object, jfieldID field) {
202     changeCount(JVMTI_EVENT_FIELD_ACCESS, &amp;eventCount[0]);
203 }
204 
205 void JNICALL
206 cbFieldModification(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
207                 jmethodID method, jlocation location, jclass field_klass,
208                 jobject object, jfieldID field, char signature_type,
209                 jvalue new_value) {
210     changeCount(JVMTI_EVENT_FIELD_MODIFICATION, &amp;eventCount[0]);
211 }
212 
213 void JNICALL
214 cbMethodEntry(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
215                 jmethodID method) {
216     changeCount(JVMTI_EVENT_METHOD_ENTRY, &amp;eventCount[0]);
217 }
218 
219 void JNICALL
220 cbMethodExit(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
221                 jmethodID method, jboolean was_popped_by_exception,
222                 jvalue return_value) {
223     changeCount(JVMTI_EVENT_METHOD_EXIT, &amp;eventCount[0]);
224 }
225 
226 void JNICALL
227 cbNativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env,jthread thread,
228                 jmethodID method, void* address, void** new_address_ptr) {
229     changeCount(JVMTI_EVENT_NATIVE_METHOD_BIND, &amp;eventCount[0]);
230 }
231 
232 void JNICALL
233 cbMonitorWait(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
234                     jobject object, jlong tout) {
235 
236     changeCount(JVMTI_EVENT_MONITOR_WAIT, &amp;eventCount[0]);
237 }
238 
239 void JNICALL
240 cbMonitorWaited(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
241                     jobject object, jboolean timed_out) {
242 
243     changeCount(JVMTI_EVENT_MONITOR_WAITED, &amp;eventCount[0]);
244 }
245 
246 JNIEXPORT void JNICALL
247 cbMonitorContendedEnter(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread,
248                             jobject object) {
249 
250     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTER, &amp;eventCount[0]);
251 }
252 
253 void JNICALL
254 cbMonitorContendedEntered(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
255                             jobject object) {
256 
257     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, &amp;eventCount[0]);
258 }
259 
260 void
261 handlerMC1(jvmtiEvent event, jvmtiEnv* jvmti, jmethodID method) {
262 
263     char *name;
264     char *sign;
265     char *genc;
266 
267     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetMethodName(method, &amp;name, &amp;sign, &amp;genc))) {
268         nsk_jvmti_setFailStatus();
269         return;
270     }
271 
272     if (!strncmp(name,&quot;javaMethod&quot;, 8)) {
273         NSK_DISPLAY2(&quot;\tMethod: %s, signature: %s\n&quot;, name, sign);
274         changeCount(event, &amp;eventCount[0]);
275     }
276 
277     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)name))) {
278         nsk_jvmti_setFailStatus();
279     }
280     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)sign))) {
281         nsk_jvmti_setFailStatus();
282     }
283     if (genc != NULL)
284         if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)genc))) {
285             nsk_jvmti_setFailStatus();
286         }
287 }
288 
289 void JNICALL
290 cbCompiledMethodLoad(jvmtiEnv *jvmti_env, jmethodID method, jint code_size,
291                 const void* code_addr, jint map_length,
292                 const jvmtiAddrLocationMap* map, const void* compile_info) {
293 
294     loadEvents++;
295     handlerMC1(JVMTI_EVENT_COMPILED_METHOD_LOAD, jvmti_env, method);
296 }
297 
298 void JNICALL
299 cbCompiledMethodUnload(jvmtiEnv *jvmti_env, jmethodID method,
300                 const void* code_addr) {
301     unloadEvents++;
302     NSK_DISPLAY0(&quot;&gt;&gt;&gt;JVMTI_EVENT_COMPILED_METHOD_UNLOAD received for\n&quot;);
303     changeCount(JVMTI_EVENT_COMPILED_METHOD_UNLOAD, &amp;eventCount[0]);
304 }
305 
306 void JNICALL
307 cbGarbageCollectionStart(jvmtiEnv *jvmti_env) {
308     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_START, &amp;eventCount[0]);
309 }
310 
311 void JNICALL
312 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
313     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
314 }
315 
316 void JNICALL
317 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
318     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
319 }
320 
321 void JNICALL
322 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
323                     jobject object, jclass object_klass, jlong size) {
324 
325     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
326 }
327 
328 void
329 handlerMC2(jvmtiEvent event, jvmtiEnv* jvmti, jmethodID method) {
330 
331     char *name;
332     char *sign;
333     char *genc;
334 
335     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetMethodName(method, &amp;name, &amp;sign, &amp;genc))) {
336         nsk_jvmti_setFailStatus();
337         return;
338     }
339 
340     NSK_DISPLAY2(&quot;\tMethod: %s, signature: %s\n&quot;, name, sign);
341     changeCount(event, &amp;newEventCount[0]);
342 
343     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)name))) {
344         nsk_jvmti_setFailStatus();
345     }
346     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)sign))) {
347         nsk_jvmti_setFailStatus();
348     }
349     if (genc != NULL)
350         if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)genc))) {
351             nsk_jvmti_setFailStatus();
352         }
353 }
354 
355 void JNICALL
356 cbNewCompiledMethodLoad(jvmtiEnv *jvmti_env, jmethodID method, jint code_size,
357                 const void* code_addr, jint map_length,
358                 const jvmtiAddrLocationMap* map, const void* compile_info) {
359 
360     loadEvents++;
361     handlerMC2(JVMTI_EVENT_COMPILED_METHOD_LOAD, jvmti_env, method);
362 }
363 
364 void JNICALL
365 cbNewCompiledMethodUnload(jvmtiEnv *jvmti_env, jmethodID method,
366                 const void* code_addr) {
367 
368     unloadEvents++;
369     NSK_DISPLAY0(&quot;&gt;&gt;&gt;JVMTI_EVENT_COMPILED_METHOD_UNLOAD received for\n&quot;);
370     changeCount(JVMTI_EVENT_COMPILED_METHOD_UNLOAD, &amp;newEventCount[0]);
371 }
372 
373 /* ============================================================================= */
374 
375 static bool enableEvent(jvmtiEvent event) {
376 
377     if (nsk_jvmti_isOptionalEvent(event)
378             &amp;&amp; (event != JVMTI_EVENT_COMPILED_METHOD_LOAD)
379             &amp;&amp; (event != JVMTI_EVENT_COMPILED_METHOD_UNLOAD)) {
380         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
381                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
382             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
383                 TranslateEvent(event));
384             return false;
385         }
386     } else {
387         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
388             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
389                 TranslateEvent(event));
390             return false;
391         }
392     }
393 
394     return true;
395 }
396 
397 /**
398  * Enable or disable tested events.
399  */
400 static bool enableEventList() {
401     int i;
402     bool result = true;
403 
404     NSK_DISPLAY0(&quot;Enable events\n&quot;);
405 
406     result = enableEvent(JVMTI_EVENT_VM_INIT);
407 
408     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
409 
410     /* enabling optional events */
411     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
412         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
413 
414         if (nsk_jvmti_isOptionalEvent(event))
415             result = result &amp;&amp; enableEvent(event);
416     }
417 
418     if (!result) {
419         nsk_jvmti_setFailStatus();
420         return false;
421     }
422 
423     return true;
424 }
425 
426 /* ============================================================================= */
427 
428 static bool setCallBacks(int step) {
429 
430     int i;
431 
432     jvmtiEventCallbacks eventCallbacks;
433     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
434 
435     NSK_DISPLAY0(&quot;\n&quot;);
436     NSK_DISPLAY1(&quot;===============step %d===============\n&quot;, step);
437     NSK_DISPLAY0(&quot;\n&quot;);
438     switch (step) {
439         case 1:
440             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
441                 eventCount[i] = 0;
442             }
443 
444             eventCallbacks.VMInit                    = cbVMInit;
445             eventCallbacks.Exception                 = cbException;
446             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
447             eventCallbacks.SingleStep                = cbSingleStep;
448             eventCallbacks.FramePop                  = cbFramePop;
449             eventCallbacks.Breakpoint                = cbBreakpoint;
450             eventCallbacks.FieldAccess               = cbFieldAccess;
451             eventCallbacks.FieldModification         = cbFieldModification;
452             eventCallbacks.MethodEntry               = cbMethodEntry;
453             eventCallbacks.MethodExit                = cbMethodExit;
454             eventCallbacks.NativeMethodBind          = cbNativeMethodBind;
455             eventCallbacks.CompiledMethodLoad        = cbCompiledMethodLoad;
456             eventCallbacks.CompiledMethodUnload      = cbCompiledMethodUnload;
457             eventCallbacks.MonitorWait               = cbMonitorWait;
458             eventCallbacks.MonitorWaited             = cbMonitorWaited;
459             eventCallbacks.MonitorContendedEnter     = cbMonitorContendedEnter;
460             eventCallbacks.MonitorContendedEntered   = cbMonitorContendedEntered;
461             eventCallbacks.GarbageCollectionStart    = cbGarbageCollectionStart;
462             eventCallbacks.GarbageCollectionFinish   = cbGarbageCollectionFinish;
463             eventCallbacks.ObjectFree                = cbObjectFree;
464             eventCallbacks.VMObjectAlloc             = cbVMObjectAlloc;
465             break;
466 
467         case 2:
468             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
469                 newEventCount[i] = 0;
470             }
471 
472             eventCallbacks.CompiledMethodLoad   = cbNewCompiledMethodLoad;
473             eventCallbacks.CompiledMethodUnload = cbNewCompiledMethodUnload;
474             break;
475 
476         case 3:
477 
478             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
479                 newEventCount[i] = 0;
480             }
481 
482             eventCallbacks.VMDeath                   = cbVMDeath;
483             break;
484 
485     }
486     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
487         return false;
488 
489     return true;
490 }
491 
492 /* ============================================================================= */
493 
494 /** Agent algorithm. */
495 static void JNICALL
496 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
497 
498     int i;
499 
500     for (i = 1; i &lt;= STEP_AMOUNT; i++) {
501 
502         if (!nsk_jvmti_waitForSync(timeout))
503             return;
504 
505         NSK_DISPLAY0(&quot;Check received events\n&quot;);
506 
507         if (i &lt; STEP_AMOUNT) {
508             showEventStatistics(i);
509             if (!checkEvents(i))
510                 nsk_jvmti_setFailStatus();
511 
512             if (!setCallBacks(i + 1)) {
513                 return;
514             }
515         }
516 
517         if (!nsk_jvmti_resumeSync())
518             return;
519     }
520 
521     /* checking amounts of COMPILED_METHOD_LOAD and COMPILED_METHOD_UNLOAD events */
522     if (loadEvents &lt; unloadEvents) {
523         NSK_COMPLAIN2(&quot;Number of JVMTI_EVENT_COMPILED_METHOD_LOAD events %d is less than number of JVMTI_EVENT_COMPILED_METHOD_UNLOAD %d&quot;,
524                             loadEvents,
525                             unloadEvents);
526     }
527 }
528 
529 /* ============================================================================= */
530 
531 /** Agent library initialization. */
532 #ifdef STATIC_BUILD
533 JNIEXPORT jint JNICALL Agent_OnLoad_em02t003(JavaVM *jvm, char *options, void *reserved) {
534     return Agent_Initialize(jvm, options, reserved);
535 }
536 JNIEXPORT jint JNICALL Agent_OnAttach_em02t003(JavaVM *jvm, char *options, void *reserved) {
537     return Agent_Initialize(jvm, options, reserved);
538 }
539 JNIEXPORT jint JNI_OnLoad_em02t003(JavaVM *jvm, char *options, void *reserved) {
540     return JNI_VERSION_1_8;
541 }
542 #endif
543 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
544 
545     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
546         return JNI_ERR;
547 
548     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
549 
550     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
551     if (!NSK_VERIFY(jvmti != NULL))
552         return JNI_ERR;
553 
554     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock))) {
555         nsk_jvmti_setFailStatus();
556         return JNI_ERR;
557     }
558 
559     {
560         jvmtiCapabilities caps;
561         memset(&amp;caps, 0, sizeof(caps));
562 
563         caps.can_generate_compiled_method_load_events = 1;
564         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
565             return JNI_ERR;
566     }
567 
568     if (!setCallBacks(1)) {
569         return JNI_ERR;
570     }
571 
572     nsk_jvmti_showPossessedCapabilities(jvmti);
573 
574     if (!enableEventList()) {
575         return JNI_ERR;
576     }
577 
578     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
579         return JNI_ERR;
580 
581     return JNI_OK;
582 }
583 
584 /* ============================================================================= */
585 
586 
587 }
    </pre>
  </body>
</html>
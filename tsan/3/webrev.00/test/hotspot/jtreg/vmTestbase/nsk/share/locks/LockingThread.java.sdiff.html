<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/share/locks/LockingThread.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../jvmti/jvmti_tools.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MonitorLockingThread.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/share/locks/LockingThread.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
308         // try wait with timeout to avoid possible hanging (if LockingThread have finished execution because of uncaught exception)
309         int result = waitStateWicket.waitFor(60000);
310 
311         if (result != 0) {
312             throw new TestBug(&quot;Locking thread can&#39;t reach required state (waitStateWicket wasn&#39;t unlocked)&quot;);
313         }
314 
315         if (requiredState == null)
316             throw new TestBug(&quot;Required state not specified&quot;);
317 
318         long startTime = System.currentTimeMillis();
319 
320         // additional check to be sure that LockingThread acquired state
321         while (this.getState() != requiredState) {
322 
323             // try wait with timeout to avoid possible hanging if something will go wrong
324             if ((System.currentTimeMillis() - startTime) &gt; 60000) {
325                 throw new TestBug(&quot;Locking thread can&#39;t reach required state (state: &quot; + requiredState + &quot; wasn&#39;t reached) in 1 minute&quot;);
326             }
327 
<span class="line-modified">328             yield();</span>
329         }
330 
331         requiredState = null;
332 
333         Object relinquishedMonitor = getRelinquishedMonitor();
334         /*
335          * Changing thread state and release of lock is not single/atomic operation.
336          * As result there is a potential race when thread state (LockingThread) has
337          * been changed but the lock has not been released yet. To avoid this current
338          * thread is trying to acquire the same monitor, so current thread proceeds
339          * execution only when monitor has been really relinquished by LockingThread.
340          */
341         if (relinquishedMonitor != null) {
342             synchronized (relinquishedMonitor) {
343             }
344         }
345     }
346 
347     // LockingThread acquired required state
348     private void ready() {
</pre>
</td>
<td>
<hr />
<pre>
308         // try wait with timeout to avoid possible hanging (if LockingThread have finished execution because of uncaught exception)
309         int result = waitStateWicket.waitFor(60000);
310 
311         if (result != 0) {
312             throw new TestBug(&quot;Locking thread can&#39;t reach required state (waitStateWicket wasn&#39;t unlocked)&quot;);
313         }
314 
315         if (requiredState == null)
316             throw new TestBug(&quot;Required state not specified&quot;);
317 
318         long startTime = System.currentTimeMillis();
319 
320         // additional check to be sure that LockingThread acquired state
321         while (this.getState() != requiredState) {
322 
323             // try wait with timeout to avoid possible hanging if something will go wrong
324             if ((System.currentTimeMillis() - startTime) &gt; 60000) {
325                 throw new TestBug(&quot;Locking thread can&#39;t reach required state (state: &quot; + requiredState + &quot; wasn&#39;t reached) in 1 minute&quot;);
326             }
327 
<span class="line-modified">328             Thread.yield();</span>
329         }
330 
331         requiredState = null;
332 
333         Object relinquishedMonitor = getRelinquishedMonitor();
334         /*
335          * Changing thread state and release of lock is not single/atomic operation.
336          * As result there is a potential race when thread state (LockingThread) has
337          * been changed but the lock has not been released yet. To avoid this current
338          * thread is trying to acquire the same monitor, so current thread proceeds
339          * execution only when monitor has been really relinquished by LockingThread.
340          */
341         if (relinquishedMonitor != null) {
342             synchronized (relinquishedMonitor) {
343             }
344         }
345     }
346 
347     // LockingThread acquired required state
348     private void ready() {
</pre>
</td>
</tr>
</table>
<center><a href="../jvmti/jvmti_tools.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MonitorLockingThread.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
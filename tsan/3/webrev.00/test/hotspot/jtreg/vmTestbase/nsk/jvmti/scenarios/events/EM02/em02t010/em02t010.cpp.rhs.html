<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t010/em02t010.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 27 #include &quot;ExceptionCheckingJniEnv.hpp&quot;</span>
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 #include &quot;JVMTITools.h&quot;
 31 
 32 extern &quot;C&quot; {
 33 
 34 /* ============================================================================= */
 35 
 36 /* scaffold objects */
 37 static jvmtiEnv *jvmti = NULL;
 38 static jlong timeout = 0;
 39 static jrawMonitorID syncLock = NULL;
 40 
 41 /* constant names */
 42 #define STEP_NUMBER 3
 43 #define CLASS_NAME &quot;nsk/jvmti/scenarios/events/EM02/em02t010&quot;
 44 #define FIELD_ACC_NAME &quot;testedField_acc&quot;
 45 #define FIELD_MOD_NAME &quot;testedField_mod&quot;
 46 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 47 #define NUMBER_OF_INVOCATIONS 1000
 48 
 49 static int eventCount[JVMTI_EVENT_COUNT];
 50 static int newEventCount[JVMTI_EVENT_COUNT];
 51 
 52 /* ============================================================================= */
 53 
 54 static void
 55 showEventStatistics(int step) {
 56     int i;
 57     const char* str;
 58     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 59 
 60     NSK_DISPLAY0(&quot;\n&quot;);
 61     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 62     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 63     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 64         if (currentCounts[i] &gt; 0) {
 65             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 66             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 67         }
 68     }
 69 }
 70 
 71 /* ========================================================================== */
 72 
 73 int checkEvents(int step) {
 74     int i;
 75     jvmtiEvent curr;
<a name="3" id="anc3"></a><span class="line-modified"> 76     bool result = true;</span>
 77     int *currentCounts;
 78     int isExpected = 0;
 79 
 80     switch (step) {
 81         case 1:
 82             currentCounts = &amp;eventCount[0];
 83             break;
 84 
 85         case 2:
 86         case 3:
 87             currentCounts = &amp;newEventCount[0];
 88             break;
 89 
 90         default:
 91             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<a name="4" id="anc4"></a><span class="line-modified"> 92             return false;</span>
 93     }
 94 
 95     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 96 
 97         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 98 
 99         switch (step) {
100             case 1:
101                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
102                                 || (curr == JVMTI_EVENT_FIELD_MODIFICATION)
103                                 || (curr == JVMTI_EVENT_FIELD_ACCESS));
104                 break;
105 
106             case 2:
107                 isExpected = ((curr == JVMTI_EVENT_FIELD_MODIFICATION)
108                                 || (curr == JVMTI_EVENT_FIELD_ACCESS));
109                 break;
110 
111             case 3:
112                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
113                 break;
114         }
115 
116         if (isExpected) {
117             if (curr == JVMTI_EVENT_FIELD_MODIFICATION ||
118                                 curr == JVMTI_EVENT_FIELD_ACCESS) {
119                 if (currentCounts[i] != NUMBER_OF_INVOCATIONS) {
120                     NSK_COMPLAIN3(&quot;Unexpected number of %s events %d, expected value is %d\n&quot;,
121                                         TranslateEvent(curr),
122                                         currentCounts[i],
123                                         NUMBER_OF_INVOCATIONS);
<a name="5" id="anc5"></a><span class="line-modified">124                     result = false;</span>
125                 }
126             } else {
127                 if (currentCounts[i] &lt; 1) {
128                         NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
129                                             currentCounts[i],
130                                             TranslateEvent(curr));
<a name="6" id="anc6"></a><span class="line-modified">131                     result = false;</span>
132                 }
133             }
134 
135         } else {
136 
137             if (currentCounts[i] &gt; 0) {
138                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
139                                     TranslateEvent(curr),
140                                     currentCounts[i]);
<a name="7" id="anc7"></a><span class="line-modified">141                 result = false;</span>
142             }
143         }
144     }
145 
146     return result;
147 }
148 
149 static void
150 changeCount(jvmtiEvent event, int *currentCounts) {
151 
152     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
153         nsk_jvmti_setFailStatus();
154 
155     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
156 
157     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
158         nsk_jvmti_setFailStatus();
159 
160 }
161 
162 /* ============================================================================= */
163 
164 /* callbacks */
165 JNIEXPORT void JNICALL
166 cbVMInit(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread) {
167     changeCount(JVMTI_EVENT_VM_INIT, &amp;eventCount[0]);
168 }
169 
170 JNIEXPORT void JNICALL
171 cbVMDeath(jvmtiEnv* jvmti, JNIEnv* jni_env) {
172     changeCount(JVMTI_EVENT_VM_DEATH, &amp;newEventCount[0]);
173     showEventStatistics(STEP_NUMBER);
174     if (!checkEvents(STEP_NUMBER))
175         nsk_jvmti_setFailStatus();
176 
177     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock)))
178         nsk_jvmti_setFailStatus();
179 
180 }
181 
182 void JNICALL
183 cbException(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
184                 jmethodID method, jlocation location, jobject exception,
185                 jmethodID catch_method, jlocation catch_location) {
186 
187     changeCount(JVMTI_EVENT_EXCEPTION, &amp;eventCount[0]);
188 }
189 
190 void JNICALL
191 cbExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
192                 jmethodID method, jlocation location, jobject exception) {
193 
194     changeCount(JVMTI_EVENT_EXCEPTION_CATCH, &amp;eventCount[0]);
195 }
196 
197 void JNICALL
198 cbSingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
199                 jmethodID method, jlocation location) {
200 
201     changeCount(JVMTI_EVENT_SINGLE_STEP, &amp;eventCount[0]);
202 }
203 
204 void JNICALL
205 cbFramePop(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
206                 jmethodID method, jboolean was_popped_by_exception) {
207     changeCount(JVMTI_EVENT_FRAME_POP, &amp;eventCount[0]);
208 }
209 
210 void JNICALL
211 cbBreakpoint(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
212                 jmethodID method, jlocation location) {
213     changeCount(JVMTI_EVENT_BREAKPOINT, &amp;eventCount[0]);
214 }
215 
216 void JNICALL
217 cbFieldAccess(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
218                 jmethodID method, jlocation location, jclass field_klass,
219                 jobject object, jfieldID field) {
220 
221     changeCount(JVMTI_EVENT_FIELD_ACCESS, &amp;eventCount[0]);
222 }
223 
224 void JNICALL
225 cbFieldModification(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
226                 jmethodID method, jlocation location, jclass field_klass,
227                 jobject object, jfieldID field, char signature_type,
228                 jvalue new_value) {
229 
230     changeCount(JVMTI_EVENT_FIELD_MODIFICATION, &amp;eventCount[0]);
231 }
232 
233 void JNICALL
234 cbNewFieldAccess(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
235                 jmethodID method, jlocation location, jclass field_klass,
236                 jobject object, jfieldID field) {
237 
238     changeCount(JVMTI_EVENT_FIELD_ACCESS, &amp;newEventCount[0]);
239 }
240 
241 void JNICALL
242 cbNewFieldModification(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
243                 jmethodID method, jlocation location, jclass field_klass,
244                 jobject object, jfieldID field, char signature_type,
245                 jvalue new_value) {
246 
247     changeCount(JVMTI_EVENT_FIELD_MODIFICATION, &amp;newEventCount[0]);
248 }
249 
250 void JNICALL
251 cbMethodEntry(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
252                 jmethodID method) {
253 
254     changeCount(JVMTI_EVENT_METHOD_ENTRY, &amp;eventCount[0]);
255 }
256 
257 void JNICALL
258 cbMethodExit(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
259                 jmethodID method, jboolean was_popped_by_exception,
260                 jvalue return_value) {
261 
262     changeCount(JVMTI_EVENT_METHOD_EXIT, &amp;eventCount[0]);
263 }
264 
265 void JNICALL
266 cbNativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env,jthread thread,
267                 jmethodID method, void* address, void** new_address_ptr) {
268     changeCount(JVMTI_EVENT_NATIVE_METHOD_BIND, &amp;eventCount[0]);
269 }
270 
271 void JNICALL
272 cbMonitorWait(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
273                     jobject object, jlong tout) {
274 
275     changeCount(JVMTI_EVENT_MONITOR_WAIT, &amp;eventCount[0]);
276 }
277 
278 void JNICALL
279 cbMonitorWaited(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
280                     jobject object, jboolean timed_out) {
281 
282     changeCount(JVMTI_EVENT_MONITOR_WAITED, &amp;eventCount[0]);
283 }
284 
285 JNIEXPORT void JNICALL
286 cbMonitorContendedEnter(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread,
287                             jobject object) {
288 
289     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTER, &amp;eventCount[0]);
290 }
291 
292 void JNICALL
293 cbMonitorContendedEntered(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
294                             jobject object) {
295 
296     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, &amp;eventCount[0]);
297 }
298 
299 void JNICALL
300 cbCompiledMethodLoad(jvmtiEnv *jvmti_env, jmethodID method, jint code_size,
301                 const void* code_addr, jint map_length,
302                 const jvmtiAddrLocationMap* map, const void* compile_info) {
303     changeCount(JVMTI_EVENT_COMPILED_METHOD_LOAD, &amp;eventCount[0]);
304 }
305 
306 void JNICALL
307 cbCompiledMethodUnload(jvmtiEnv *jvmti_env, jmethodID method,
308                 const void* code_addr) {
309     changeCount(JVMTI_EVENT_COMPILED_METHOD_UNLOAD, &amp;eventCount[0]);
310 }
311 
312 void JNICALL
313 cbGarbageCollectionStart(jvmtiEnv *jvmti_env) {
314     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_START, &amp;eventCount[0]);
315 }
316 
317 void JNICALL
318 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
319     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
320 }
321 
322 void JNICALL
323 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
324 
325     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
326 }
327 
328 void JNICALL
329 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
330                     jobject object, jclass object_klass, jlong size) {
331 
332     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
333 }
334 
335 /* ============================================================================= */
336 
<a name="8" id="anc8"></a><span class="line-modified">337 static bool enableEvent(jvmtiEvent event) {</span>
338 
339     if (nsk_jvmti_isOptionalEvent(event)
340             &amp;&amp; (event != JVMTI_EVENT_FIELD_MODIFICATION)
341             &amp;&amp; (event != JVMTI_EVENT_FIELD_ACCESS)) {
342         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
343                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
344             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
345                 TranslateEvent(event));
<a name="9" id="anc9"></a><span class="line-modified">346             return false;</span>
347         }
348     } else {
349         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
350             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
351                 TranslateEvent(event));
<a name="10" id="anc10"></a><span class="line-modified">352             return false;</span>
353         }
354     }
355 
<a name="11" id="anc11"></a><span class="line-modified">356     return true;</span>
357 }
358 
359 /**
360  * Enable or disable tested events.
361  */
<a name="12" id="anc12"></a><span class="line-modified">362 static bool enableEventList() {</span>
363 
364     int i, result;
365 
366     result = enableEvent(JVMTI_EVENT_VM_INIT);
367 
368     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
369 
370     /* enabling optional events */
371     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
372         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
373 
374         if (nsk_jvmti_isOptionalEvent(event))
375             result = result &amp;&amp; enableEvent(event);
376     }
377 
<a name="13" id="anc13"></a><span class="line-modified">378     if (!result) {</span>
379         nsk_jvmti_setFailStatus();
<a name="14" id="anc14"></a><span class="line-modified">380         return false;</span>
381     }
382 
<a name="15" id="anc15"></a><span class="line-modified">383     return true;</span>
384 }
385 
386 /* ============================================================================= */
387 
<a name="16" id="anc16"></a><span class="line-modified">388 static bool setCallBacks(int step) {</span>

389 
390     int i;
391 
392     jvmtiEventCallbacks eventCallbacks;
393     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
394 
395     switch (step) {
396         case 1:
397             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
398                 eventCount[i] = 0;
399             }
400 
401             eventCallbacks.VMInit                    = cbVMInit;
402             eventCallbacks.Exception                 = cbException;
403             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
404             eventCallbacks.SingleStep                = cbSingleStep;
405             eventCallbacks.FramePop                  = cbFramePop;
406             eventCallbacks.Breakpoint                = cbBreakpoint;
407             eventCallbacks.FieldAccess               = cbFieldAccess;
408             eventCallbacks.FieldModification         = cbFieldModification;
409             eventCallbacks.MethodEntry               = cbMethodEntry;
410             eventCallbacks.MethodExit                = cbMethodExit;
411             eventCallbacks.NativeMethodBind          = cbNativeMethodBind;
412             eventCallbacks.CompiledMethodLoad        = cbCompiledMethodLoad;
413             eventCallbacks.CompiledMethodUnload      = cbCompiledMethodUnload;
414             eventCallbacks.MonitorWait               = cbMonitorWait;
415             eventCallbacks.MonitorWaited             = cbMonitorWaited;
416             eventCallbacks.MonitorContendedEnter     = cbMonitorContendedEnter;
417             eventCallbacks.MonitorContendedEntered   = cbMonitorContendedEntered;
418             eventCallbacks.GarbageCollectionStart    = cbGarbageCollectionStart;
419             eventCallbacks.GarbageCollectionFinish   = cbGarbageCollectionFinish;
420             eventCallbacks.ObjectFree                = cbObjectFree;
421             eventCallbacks.VMObjectAlloc             = cbVMObjectAlloc;
422             break;
423 
424         case 2:
425             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
426                 newEventCount[i] = 0;
427             }
428 
429             eventCallbacks.FieldAccess               = cbNewFieldAccess;
430             eventCallbacks.FieldModification         = cbNewFieldModification;
431             break;
432 
433         case 3:
434             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
435                 newEventCount[i] = 0;
436             }
437 
438             eventCallbacks.VMDeath                   = cbVMDeath;
439             break;
440 
441     }
442     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<a name="17" id="anc17"></a><span class="line-modified">443         return false;</span>
444 
<a name="18" id="anc18"></a><span class="line-modified">445     return true;</span>
446 }
447 
448 /* ============================================================================= */
449 
450 /** Agent algorithm. */
451 static void JNICALL
452 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
453 
<a name="19" id="anc19"></a><span class="line-added">454     ExceptionCheckingJniEnvPtr ec_jni(agentJNI);</span>
455     int i;
456     jfieldID field_accID, field_modID;
457     jclass cls;
458 
459 
460     if (!nsk_jvmti_waitForSync(timeout))
461         return;
462 
<a name="20" id="anc20"></a><span class="line-modified">463     cls = ec_jni-&gt;FindClass(CLASS_NAME, TRACE_JNI_CALL);</span>
<span class="line-modified">464     field_accID = ec_jni-&gt;GetStaticFieldID(cls, FIELD_ACC_NAME, &quot;I&quot;, TRACE_JNI_CALL);</span>
<span class="line-modified">465     field_modID = ec_jni-&gt;GetStaticFieldID(cls, FIELD_MOD_NAME, &quot;I&quot;, TRACE_JNI_CALL);</span>








466 
467     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetFieldModificationWatch(cls, field_modID)))
468         return;
469 
470     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetFieldAccessWatch(cls, field_accID)))
471         return;
472 
473     if (!nsk_jvmti_resumeSync())
474         return;
475 
476     for (i = 1; i &lt;= STEP_NUMBER; i++) {
477 
478         if (!nsk_jvmti_waitForSync(timeout))
479             return;
480 
481         if (i &lt; STEP_NUMBER) {
482             showEventStatistics(i);
483             if (!checkEvents(i))
484                 nsk_jvmti_setFailStatus();
485 
486             if (!setCallBacks(i + 1)) {
487                 return;
488             }
489         }
490 
491         if (!nsk_jvmti_resumeSync())
492             return;
493     }
494 
495 }
496 
497 /* ============================================================================= */
498 
499 /** Agent library initialization. */
500 #ifdef STATIC_BUILD
501 JNIEXPORT jint JNICALL Agent_OnLoad_em02t010(JavaVM *jvm, char *options, void *reserved) {
502     return Agent_Initialize(jvm, options, reserved);
503 }
504 JNIEXPORT jint JNICALL Agent_OnAttach_em02t010(JavaVM *jvm, char *options, void *reserved) {
505     return Agent_Initialize(jvm, options, reserved);
506 }
507 JNIEXPORT jint JNI_OnLoad_em02t010(JavaVM *jvm, char *options, void *reserved) {
508     return JNI_VERSION_1_8;
509 }
510 #endif
511 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
512 
513     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
514         return JNI_ERR;
515 
516     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
517 
518     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
519     if (!NSK_VERIFY(jvmti != NULL))
520         return JNI_ERR;
521 
522     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock))) {
523         nsk_jvmti_setFailStatus();
524         return JNI_ERR;
525     }
526 
527     {
528         jvmtiCapabilities caps;
529         memset(&amp;caps, 0, sizeof(caps));
530 
531         caps.can_generate_field_modification_events = 1;
532         caps.can_generate_field_access_events = 1;
533         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
534             return JNI_ERR;
535     }
536 
537     if (!setCallBacks(1)) {
538         return JNI_ERR;
539     }
540 
541     if (!enableEventList()) {
542         return JNI_ERR;
543     }
544 
545     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
546         return JNI_ERR;
547 
548     return JNI_OK;
549 }
550 
551 /* ============================================================================= */
552 
553 
554 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/hotswap/HS203/hs203t001/hs203t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../HS202/hs202t002/hs202t002.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../hs203t002/hs203t002.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/hotswap/HS203/hs203t001/hs203t001.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 80                 } else {
 81                     nsk_printf(&quot;Agent:: ***ERROR OCCURED .. in METHOD LOCATION FINDER \n&quot;);
 82                 }
 83             } else {
 84                 nsk_printf(&quot;Agent:: ***ERROR OCCURED .. COUND NOT FIND THE METHOD AND SIGNATURE SPECIFIED \n&quot;);
 85             }
 86         }
 87     }
 88 
 89 void JNICALL callbackSingleStep(jvmtiEnv *jvmti, JNIEnv* jni,
 90         jthread thread,
 91         jmethodID method,
 92         jlocation location) {
 93     jclass threadClass;
 94     jvmtiError err;
 95     char fileName[512];
 96     threadClass = jni-&gt;FindClass(SEARCH_NAME);
 97     nsk_jvmti_getFileName(redefineNumber, FILE_NAME, fileName,
 98                     sizeof(fileName)/sizeof(char));
 99     nsk_printf(&quot; %d..&quot;,redefineNumber);
<span class="line-modified">100     if (nsk_jvmti_redefineClass(jvmti, threadClass, fileName) == NSK_TRUE) {</span>
101         nsk_printf(&quot;\nMyClass :: Successfully redefined..\n&quot;);
102     } else {
103         nsk_printf(&quot;\nMyClass :: Failed to redefine ..\n&quot;);
104     }
105     nsk_printf(&quot; End of REDEFINE CLASS LOADER \n&quot;);
106     err=jvmti-&gt;SuspendThread(thread);
107     if (err == JVMTI_ERROR_NONE) {
108         nsk_printf(&quot;Agent:: Succeded in suspending..\n&quot;);
109     } else {
110         nsk_printf(&quot; ## Error occured %s \n&quot;,TranslateError(err));
111     }
112 }
113 
114 void JNICALL
115 callbackBreakpoint(jvmtiEnv *jvmti,
116         JNIEnv* jni,
117         jthread thread,
118         jmethodID method,
119         jlocation location) {
120     nsk_printf(&quot;Agent::... BreakPoint Reached..\n&quot;);
<span class="line-modified">121     if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_SINGLE_STEP,thread) == NSK_TRUE) {</span>
122         nsk_printf(&quot; ....   Enabled..\n&quot;);
123     }
124     return;
125 }
126 
127 #ifdef STATIC_BUILD
128 JNIEXPORT jint JNICALL Agent_OnLoad_hs203t001(JavaVM *jvm, char *options, void *reserved) {
129     return Agent_Initialize(jvm, options, reserved);
130 }
131 JNIEXPORT jint JNICALL Agent_OnAttach_hs203t001(JavaVM *jvm, char *options, void *reserved) {
132     return Agent_Initialize(jvm, options, reserved);
133 }
134 JNIEXPORT jint JNI_OnLoad_hs203t001(JavaVM *jvm, char *options, void *reserved) {
135     return JNI_VERSION_1_8;
136 }
137 #endif
138 jint  Agent_Initialize(JavaVM *vm, char *options, void *reserved) {
139     jint rc ;
140     nsk_printf(&quot;Agent:: VM.. Started..\n&quot;);
141     rc=vm-&gt;GetEnv((void **)&amp;jvmti, JVMTI_VERSION_1_1);
142     if (rc != JNI_OK) {
143         nsk_printf(&quot;Agent:: Could not load JVMTI interface \n&quot;);
144         return JNI_ERR;
145     } else {
146         jvmtiCapabilities caps;
147         jvmtiEventCallbacks eventCallbacks;
<span class="line-modified">148         if (nsk_jvmti_parseOptions(options) == NSK_FALSE) {</span>
149             nsk_printf(&quot;# error agent Failed to parse options \n&quot;);
150             return JNI_ERR;
151         }
152         memset(&amp;caps, 0, sizeof(caps));
153         caps.can_redefine_classes = 1;
154         caps.can_suspend=1;
155         caps.can_pop_frame=1;
156         caps.can_generate_breakpoint_events=1;
157         caps.can_generate_all_class_hook_events=1;
158         caps.can_generate_single_step_events=1;
159         jvmti-&gt;AddCapabilities(&amp;caps);
160         memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
161         eventCallbacks.ClassLoad =callbackClassLoad;
162         eventCallbacks.Breakpoint = callbackBreakpoint;
163         eventCallbacks.SingleStep =callbackSingleStep;
164         rc=jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks));
165         if (rc != JVMTI_ERROR_NONE) {
166             nsk_printf(&quot; Agent:: Error occured while setting event call back \n&quot;);
167             return JNI_ERR;
168         }
<span class="line-modified">169         if ((nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_LOAD, NULL) == NSK_TRUE) &amp;&amp;</span>
<span class="line-modified">170                 (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT,NULL) == NSK_TRUE)) {</span>
171             nsk_printf(&quot;Agent :: NOTIFICATIONS ARE ENABLED \n&quot;);
172         } else {
173             nsk_printf(&quot; Error in Eanableing Notifications..&quot;);
174         }
175     }
176     return JNI_OK;
177 }
178 
179 
180 JNIEXPORT jboolean JNICALL
181 Java_nsk_jvmti_scenarios_hotswap_HS203_hs203t001_hs203t001_popThreadFrame(JNIEnv * jni,
182         jclass clas,
183         jthread thread) {
184     jvmtiError err ;
185     jboolean retvalue;
186     jint state;
187     nsk_printf(&quot;Agent:: POPING THE FRAME....\n&quot;);
188     retvalue = JNI_FALSE;
189     nsk_printf(&quot; Here &quot;);
190     jvmti-&gt;GetThreadState(thread, &amp;state);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 80                 } else {
 81                     nsk_printf(&quot;Agent:: ***ERROR OCCURED .. in METHOD LOCATION FINDER \n&quot;);
 82                 }
 83             } else {
 84                 nsk_printf(&quot;Agent:: ***ERROR OCCURED .. COUND NOT FIND THE METHOD AND SIGNATURE SPECIFIED \n&quot;);
 85             }
 86         }
 87     }
 88 
 89 void JNICALL callbackSingleStep(jvmtiEnv *jvmti, JNIEnv* jni,
 90         jthread thread,
 91         jmethodID method,
 92         jlocation location) {
 93     jclass threadClass;
 94     jvmtiError err;
 95     char fileName[512];
 96     threadClass = jni-&gt;FindClass(SEARCH_NAME);
 97     nsk_jvmti_getFileName(redefineNumber, FILE_NAME, fileName,
 98                     sizeof(fileName)/sizeof(char));
 99     nsk_printf(&quot; %d..&quot;,redefineNumber);
<span class="line-modified">100     if (nsk_jvmti_redefineClass(jvmti, threadClass, fileName)) {</span>
101         nsk_printf(&quot;\nMyClass :: Successfully redefined..\n&quot;);
102     } else {
103         nsk_printf(&quot;\nMyClass :: Failed to redefine ..\n&quot;);
104     }
105     nsk_printf(&quot; End of REDEFINE CLASS LOADER \n&quot;);
106     err=jvmti-&gt;SuspendThread(thread);
107     if (err == JVMTI_ERROR_NONE) {
108         nsk_printf(&quot;Agent:: Succeded in suspending..\n&quot;);
109     } else {
110         nsk_printf(&quot; ## Error occured %s \n&quot;,TranslateError(err));
111     }
112 }
113 
114 void JNICALL
115 callbackBreakpoint(jvmtiEnv *jvmti,
116         JNIEnv* jni,
117         jthread thread,
118         jmethodID method,
119         jlocation location) {
120     nsk_printf(&quot;Agent::... BreakPoint Reached..\n&quot;);
<span class="line-modified">121     if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_SINGLE_STEP,thread)) {</span>
122         nsk_printf(&quot; ....   Enabled..\n&quot;);
123     }
124     return;
125 }
126 
127 #ifdef STATIC_BUILD
128 JNIEXPORT jint JNICALL Agent_OnLoad_hs203t001(JavaVM *jvm, char *options, void *reserved) {
129     return Agent_Initialize(jvm, options, reserved);
130 }
131 JNIEXPORT jint JNICALL Agent_OnAttach_hs203t001(JavaVM *jvm, char *options, void *reserved) {
132     return Agent_Initialize(jvm, options, reserved);
133 }
134 JNIEXPORT jint JNI_OnLoad_hs203t001(JavaVM *jvm, char *options, void *reserved) {
135     return JNI_VERSION_1_8;
136 }
137 #endif
138 jint  Agent_Initialize(JavaVM *vm, char *options, void *reserved) {
139     jint rc ;
140     nsk_printf(&quot;Agent:: VM.. Started..\n&quot;);
141     rc=vm-&gt;GetEnv((void **)&amp;jvmti, JVMTI_VERSION_1_1);
142     if (rc != JNI_OK) {
143         nsk_printf(&quot;Agent:: Could not load JVMTI interface \n&quot;);
144         return JNI_ERR;
145     } else {
146         jvmtiCapabilities caps;
147         jvmtiEventCallbacks eventCallbacks;
<span class="line-modified">148         if (!nsk_jvmti_parseOptions(options)) {</span>
149             nsk_printf(&quot;# error agent Failed to parse options \n&quot;);
150             return JNI_ERR;
151         }
152         memset(&amp;caps, 0, sizeof(caps));
153         caps.can_redefine_classes = 1;
154         caps.can_suspend=1;
155         caps.can_pop_frame=1;
156         caps.can_generate_breakpoint_events=1;
157         caps.can_generate_all_class_hook_events=1;
158         caps.can_generate_single_step_events=1;
159         jvmti-&gt;AddCapabilities(&amp;caps);
160         memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
161         eventCallbacks.ClassLoad =callbackClassLoad;
162         eventCallbacks.Breakpoint = callbackBreakpoint;
163         eventCallbacks.SingleStep =callbackSingleStep;
164         rc=jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks));
165         if (rc != JVMTI_ERROR_NONE) {
166             nsk_printf(&quot; Agent:: Error occured while setting event call back \n&quot;);
167             return JNI_ERR;
168         }
<span class="line-modified">169         if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_LOAD, NULL) &amp;&amp;</span>
<span class="line-modified">170                 nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT,NULL)) {</span>
171             nsk_printf(&quot;Agent :: NOTIFICATIONS ARE ENABLED \n&quot;);
172         } else {
173             nsk_printf(&quot; Error in Eanableing Notifications..&quot;);
174         }
175     }
176     return JNI_OK;
177 }
178 
179 
180 JNIEXPORT jboolean JNICALL
181 Java_nsk_jvmti_scenarios_hotswap_HS203_hs203t001_hs203t001_popThreadFrame(JNIEnv * jni,
182         jclass clas,
183         jthread thread) {
184     jvmtiError err ;
185     jboolean retvalue;
186     jint state;
187     nsk_printf(&quot;Agent:: POPING THE FRAME....\n&quot;);
188     retvalue = JNI_FALSE;
189     nsk_printf(&quot; Here &quot;);
190     jvmti-&gt;GetThreadState(thread, &amp;state);
</pre>
</td>
</tr>
</table>
<center><a href="../../HS202/hs202t002/hs202t002.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../hs203t002/hs203t002.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/contention/TC04/tc04t001/tc04t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdlib.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &quot;jni_tools.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 /* ========================================================================== */
 33 
 34 /* scaffold objects */
 35 static jlong timeout = 0;
 36 
 37 /* test objects */
 38 static jclass object_M = NULL;
 39 static volatile int waitEventsCount = 0;
 40 static volatile int waitedEventsCount = 0;
 41 static volatile int enterEventsCount = 0;
 42 static volatile int enteredEventsCount = 0;
 43 static jrawMonitorID syncLock = NULL;
 44 
 45 
 46 static jboolean lockSyncLock(jvmtiEnv* jvmti) {
 47     jboolean status = NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock));
 48     if (!status)
 49         nsk_jvmti_setFailStatus();
 50     return status;
 51 }
 52 
 53 static void unlockSyncLock(jvmtiEnv* jvmti) {
 54     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
 55         nsk_jvmti_setFailStatus();
 56 }
 57 
 58 
 59 /* ========================================================================== */
 60 
 61 void JNICALL
 62 MonitorWait(jvmtiEnv *jvmti, JNIEnv* jni,
 63         jthread thr, jobject obj, jlong tout) {
 64 
 65     if (!NSK_VERIFY(thr != NULL)) {
 66         nsk_jvmti_setFailStatus();
 67         return;
 68     }
 69 
 70     if (!NSK_VERIFY(obj != NULL)) {
 71         nsk_jvmti_setFailStatus();
 72         return;
 73     }
 74 
 75     /* check if event is for tested object */
 76     if (jni-&gt;IsInstanceOf(obj, object_M)) {
 77         if (lockSyncLock(jvmti)) {
 78             waitEventsCount++;
 79             unlockSyncLock(jvmti);
 80         }
 81     }
 82 }
 83 
 84 void JNICALL
 85 MonitorWaited(jvmtiEnv *jvmti, JNIEnv* jni,
 86         jthread thr, jobject obj, jboolean timed_out) {
 87 
 88     if (!NSK_VERIFY(thr != NULL)) {
 89         nsk_jvmti_setFailStatus();
 90         return;
 91     }
 92 
 93     if (!NSK_VERIFY(obj != NULL)) {
 94         nsk_jvmti_setFailStatus();
 95         return;
 96     }
 97 
 98     /* check if event is for tested object */
 99     if (jni-&gt;IsInstanceOf(obj, object_M)) {
100         if (lockSyncLock(jvmti)) {
101             waitedEventsCount++;
102             unlockSyncLock(jvmti);
103         }
104     }
105 }
106 
107 void JNICALL
108 MonitorContendedEnter(jvmtiEnv *jvmti, JNIEnv* jni, jthread thr, jobject obj) {
109 
110     if (!NSK_VERIFY(thr != NULL)) {
111         nsk_jvmti_setFailStatus();
112         return;
113     }
114 
115     if (!NSK_VERIFY(obj != NULL)) {
116         nsk_jvmti_setFailStatus();
117         return;
118     }
119 
120     /* check if event is for tested object */
121     if (jni-&gt;IsSameObject(object_M, obj)) {
122         if (lockSyncLock(jvmti)) {
123             enterEventsCount++;
124             unlockSyncLock(jvmti);
125         }
126     }
127 }
128 
129 void JNICALL
130 MonitorContendedEntered(jvmtiEnv *jvmti, JNIEnv* jni, jthread thr, jobject obj) {
131 
132     if (!NSK_VERIFY(thr != NULL)) {
133         nsk_jvmti_setFailStatus();
134         return;
135     }
136 
137     if (!NSK_VERIFY(obj != NULL)) {
138         nsk_jvmti_setFailStatus();
139         return;
140     }
141 
142     /* check if event is for tested object */
143     if (jni-&gt;IsSameObject(object_M, obj)) {
144         if (lockSyncLock(jvmti)) {
145             enteredEventsCount++;
146             unlockSyncLock(jvmti);
147         }
148     }
149 }
150 
151 /* ========================================================================== */
152 
153 static int prepare(jvmtiEnv* jvmti, JNIEnv* jni) {
154     const char* CLASS_NAME = &quot;nsk/jvmti/scenarios/contention/TC04/tc04t001Thread&quot;;
155 
156     NSK_DISPLAY0(&quot;Obtain tested object from debugee thread class\n&quot;);
157 
158     if (!NSK_JNI_VERIFY(jni, (object_M = jni-&gt;FindClass(CLASS_NAME)) != NULL))
159         return NSK_FALSE;
160 
161     if (!NSK_JNI_VERIFY(jni, (object_M = (jclass)jni-&gt;NewGlobalRef(object_M)) != NULL))
162         return NSK_FALSE;
163 
164     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock)))
165         return NSK_FALSE;
166 
167     /* enable MonitorWait event */
168     if (!NSK_JVMTI_VERIFY(
169             jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))
170         nsk_jvmti_setFailStatus();
171 
172     /* enable MonitorWaited event */
173     if (!NSK_JVMTI_VERIFY(
174             jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))
175         nsk_jvmti_setFailStatus();
176 
177     /* enable MonitorContendedEnter event */
178     if (!NSK_JVMTI_VERIFY(
179             jvmti-&gt;SetEventNotificationMode(
180                 JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)))
181         nsk_jvmti_setFailStatus();
182 
183     /* enable MonitorContendedEntered event */
184     if (!NSK_JVMTI_VERIFY(
185             jvmti-&gt;SetEventNotificationMode(
186                 JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL)))
187         nsk_jvmti_setFailStatus();
188 
189     return NSK_TRUE;
190 }
191 
192 static int clean(jvmtiEnv* jvmti, JNIEnv* jni) {
193 
194     /* disable MonitorWait event */
195     if (!NSK_JVMTI_VERIFY(
196             jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))
197         nsk_jvmti_setFailStatus();
198 
199     /* disable MonitorWaited event */
200     if (!NSK_JVMTI_VERIFY(
201             jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))
202         nsk_jvmti_setFailStatus();
203 
204     /* disable MonitorContendedEnter event */
205     if (!NSK_JVMTI_VERIFY(
206             jvmti-&gt;SetEventNotificationMode(
207                 JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)))
208         nsk_jvmti_setFailStatus();
209 
210     /* disable MonitorContendedEntered event */
211     if (!NSK_JVMTI_VERIFY(
212             jvmti-&gt;SetEventNotificationMode(
213                 JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL)))
214         nsk_jvmti_setFailStatus();
215 
216     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock)))
217         nsk_jvmti_setFailStatus();
218 
219     return NSK_TRUE;
220 }
221 
222 /* ========================================================================== */
223 
224 /* agent algorithm */
225 static void JNICALL
226 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
227 
228     /* wait for initial sync */
229     if (!nsk_jvmti_waitForSync(timeout))
230         return;
231 
232     if (!prepare(jvmti, jni)) {
233         nsk_jvmti_setFailStatus();
234         return;
235     }
236 
237     /* resume debugee */
238     if (!(NSK_VERIFY(nsk_jvmti_resumeSync()) &amp;&amp;
239           NSK_VERIFY(nsk_jvmti_waitForSync(timeout))))
240         return;
241 
242     // lock
243     if (lockSyncLock(jvmti)) {
244         NSK_DISPLAY1(&quot;Number of MonitorWait events: %d\n&quot;, waitEventsCount);
245         if (!NSK_VERIFY(waitEventsCount &gt;= 200)) {
246             nsk_jvmti_setFailStatus();
247             NSK_COMPLAIN1(&quot;Number of MonitorWait events: %d\n&quot;, waitEventsCount);
248         }
249 
250         NSK_DISPLAY1(&quot;Number of MonitorWaited events: %d\n&quot;, waitedEventsCount);
251         if (!NSK_VERIFY(waitedEventsCount &gt;= 200)) {
252             nsk_jvmti_setFailStatus();
253             NSK_COMPLAIN1(&quot;Number of MonitorWaited events: %d\n&quot;, waitedEventsCount);
254         }
255 
256         NSK_DISPLAY1(&quot;Number of MonitorContendedEnter events: %d\n&quot;,
257             enterEventsCount);
258         if (!NSK_VERIFY(enterEventsCount == 199)) {
259             nsk_jvmti_setFailStatus();
260             NSK_COMPLAIN1(&quot;Number of MonitorContendedEnter events: %d\n&quot;,
261                 enterEventsCount);
262         }
263 
264         NSK_DISPLAY1(&quot;Number of MonitorContendedEntered events: %d\n&quot;,
265             enteredEventsCount);
266         if (!NSK_VERIFY(enteredEventsCount == 199)) {
267             nsk_jvmti_setFailStatus();
268             NSK_COMPLAIN1(&quot;Number of MonitorContendedEntered events: %d\n&quot;,
269                 enteredEventsCount);
270         }
271         unlockSyncLock(jvmti);
272     }
273 
274     if (!clean(jvmti, jni)) {
275         nsk_jvmti_setFailStatus();
276         return;
277     }
278 
279     /* resume debugee after last sync */
280     if (!nsk_jvmti_resumeSync())
281         return;
282 }
283 
284 /* ========================================================================== */
285 
286 /* agent library initialization */
287 #ifdef STATIC_BUILD
288 JNIEXPORT jint JNICALL Agent_OnLoad_tc04t001(JavaVM *jvm, char *options, void *reserved) {
289     return Agent_Initialize(jvm, options, reserved);
290 }
291 JNIEXPORT jint JNICALL Agent_OnAttach_tc04t001(JavaVM *jvm, char *options, void *reserved) {
292     return Agent_Initialize(jvm, options, reserved);
293 }
294 JNIEXPORT jint JNI_OnLoad_tc04t001(JavaVM *jvm, char *options, void *reserved) {
295     return JNI_VERSION_1_8;
296 }
297 #endif
298 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
299     jvmtiEnv* jvmti = NULL;
300     jvmtiCapabilities caps;
301     jvmtiEventCallbacks callbacks;
302 
303     /* init framework and parse options */
304     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
305         return JNI_ERR;
306 
307     timeout = nsk_jvmti_getWaitTime() * 60000;
308     NSK_DISPLAY1(&quot;Timeout: %d msc\n&quot;, (int)timeout);
309 
310     /* create JVMTI environment */
311     if (!NSK_VERIFY((jvmti =
312             nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))
313         return JNI_ERR;
314 
315     /* add capabilities */
316     memset(&amp;caps, 0, sizeof(caps));
317     caps.can_generate_monitor_events = 1;
318     caps.can_get_monitor_info = 1;
319     caps.can_signal_thread = 1;
320     if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
321         return JNI_ERR;
322 
323     memset(&amp;callbacks, 0, sizeof(callbacks));
324     callbacks.MonitorWait = &amp;MonitorWait;
325     callbacks.MonitorWaited = &amp;MonitorWaited;
326     callbacks.MonitorContendedEnter = &amp;MonitorContendedEnter;
327     callbacks.MonitorContendedEntered = &amp;MonitorContendedEntered;
328     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks))))
329         return JNI_ERR;
330 
331     /* register agent proc and arg */
332     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
333         return JNI_ERR;
334 
335     return JNI_OK;
336 }
337 
338 JNIEXPORT jint JNICALL
339 Java_nsk_jvmti_scenarios_contention_TC04_tc04t001Thread_enterEventsCount(JNIEnv* jni, jclass klass) {
340     return enterEventsCount;
341 }
342 
343 /* ========================================================================== */
344 
345 }
    </pre>
  </body>
</html>
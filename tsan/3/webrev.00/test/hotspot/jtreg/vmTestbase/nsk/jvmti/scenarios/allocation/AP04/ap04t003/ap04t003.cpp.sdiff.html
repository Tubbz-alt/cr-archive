<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/allocation/AP04/ap04t003/ap04t003.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../SingleStep/singlestep003/singlestep003.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="libap04t003.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/allocation/AP04/ap04t003/ap04t003.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdio.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &lt;jvmti.h&gt;
 27 #include &quot;agent_common.h&quot;
<span class="line-modified"> 28 </span>
 29 #include &quot;nsk_tools.h&quot;
 30 #include &quot;jni_tools.h&quot;
 31 #include &quot;JVMTITools.h&quot;
 32 #include &quot;jvmti_tools.h&quot;
 33 
 34 extern &quot;C&quot; {
 35 
 36 #define OBJ_MAX_COUNT 100000
 37 
 38 static JNIEnv *jni = NULL;
 39 static jvmtiEnv *jvmti = NULL;
 40 static jvmtiEventCallbacks callbacks;
 41 static jvmtiCapabilities caps;
 42 
 43 static jlong timeout = 0;
 44 
 45 static const char* DEBUGEE_SIGNATURE = &quot;Lnsk/jvmti/scenarios/allocation/AP04/ap04t003;&quot;;
 46 static const char* ROOT_SIGNATURE    = &quot;[Lnsk/jvmti/scenarios/allocation/AP04/ap04t003;&quot;;
 47 
 48 static jclass debugeeClass = NULL;
</pre>
<hr />
<pre>
288     }
289 
290     /* enter and notify endLock */
291     {
292         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(endLock))) {
293             nsk_jvmti_setFailStatus();
294         }
295         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorNotify(endLock))) {
296             nsk_jvmti_setFailStatus();
297         }
298         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(endLock))) {
299             nsk_jvmti_setFailStatus();
300         }
301     }
302 
303     NSK_DISPLAY0(&quot;Agent thread: finished.\n&quot;);
304 }
305 
306 /***********************************************************************/
307 
<span class="line-modified">308 static int startThread(JNIEnv* jni, jthread threadObj) {</span>
309     int success = NSK_TRUE;
310 
311     /* enter startLock */
312     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(startLock))) {
313         nsk_jvmti_setFailStatus();
314     }
315 
316     /* start thread */
317     if (!NSK_JVMTI_VERIFY(
318             jvmti-&gt;RunAgentThread(threadObj, agent_start, NULL, JVMTI_THREAD_NORM_PRIORITY))) {
319         success = NSK_FALSE;
320         nsk_jvmti_setFailStatus();
321     } else {
322         /* wait on startLock */
323         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorWait(startLock, timeout))) {
324             nsk_jvmti_setFailStatus();
325         }
326     }
327 
328     /* exit starLock */
329     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(startLock))) {
330         nsk_jvmti_setFailStatus();
331     }
332 
333     return success;
334 }
335 
336 /** Create thread object for new agent thread. */
<span class="line-modified">337 static jthread newThreadObj(JNIEnv* jni) {</span>

338     jclass thrClass;
339     jmethodID cid;
<span class="line-removed">340     jthread result = NULL;</span>
<span class="line-removed">341 </span>
<span class="line-removed">342     thrClass = jni-&gt;FindClass(&quot;java/lang/Thread&quot;);</span>
<span class="line-removed">343     if (!NSK_JNI_VERIFY(jni, thrClass != NULL)) {</span>
<span class="line-removed">344         nsk_jvmti_setFailStatus();</span>
<span class="line-removed">345         return result;</span>
<span class="line-removed">346     }</span>
347 
<span class="line-modified">348     cid = jni-&gt;GetMethodID(thrClass, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</span>
<span class="line-modified">349     if (!NSK_JNI_VERIFY(jni, cid != NULL)) {</span>
<span class="line-modified">350         nsk_jvmti_setFailStatus();</span>
<span class="line-removed">351         return result;</span>
<span class="line-removed">352     }</span>
<span class="line-removed">353 </span>
<span class="line-removed">354     result = jni-&gt;NewObject(thrClass, cid);</span>
<span class="line-removed">355     if (!NSK_JNI_VERIFY(jni, result != NULL)) {</span>
<span class="line-removed">356         nsk_jvmti_setFailStatus();</span>
<span class="line-removed">357         return result;</span>
<span class="line-removed">358     }</span>
<span class="line-removed">359 </span>
<span class="line-removed">360     return result;</span>
361 }
362 
363 /***********************************************************************/
364 
365 /** Clean counters and start new agent thread with agent_start() body. */
<span class="line-modified">366 static int prepareToIteration (JNIEnv* jni) {</span>
367     jthread threadObj = NULL;
368 
369     setCounter(&amp;iterationCount, 0);
370     setCounter(&amp;objectCount, 0);
371 
372     threadObj = newThreadObj(jni);
<span class="line-removed">373     if (!NSK_VERIFY(threadObj != NULL)) {</span>
<span class="line-removed">374         nsk_jvmti_setFailStatus();</span>
<span class="line-removed">375         return NSK_FALSE;</span>
<span class="line-removed">376     }</span>
377 
378     /* enter endLock */
379     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(endLock))) {
380         nsk_jvmti_setFailStatus();
381     }
382 
383     NSK_DISPLAY0(&quot;Starting new agent thread...\n&quot;);
<span class="line-modified">384     return startThread(jni, threadObj);</span>
385 }
386 
387 /** Wait for new agent thread to complete. */
<span class="line-modified">388 static void afterIteration (JNIEnv* jni) {</span>
389 
390     /* notify new agent thread (in case if not yet notified) */
391     notifyThread();
392 
393     NSK_DISPLAY0(&quot;Wait for new agent thread to complete\n&quot;);
394 
395     /* wait on endLock */
396     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorWait(endLock, timeout))) {
397         nsk_jvmti_setFailStatus();
398     }
399 
400     /* exit endLock */
401     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(endLock))) {
402         nsk_jvmti_setFailStatus();
403     }
404 }
405 
406 /***********************************************************************/
407 
408 JNIEXPORT void JNICALL
</pre>
<hr />
<pre>
416     }
417 }
418 
419 JNIEXPORT void JNICALL
420 Java_nsk_jvmti_scenarios_allocation_AP04_ap04t003_runIterateOverHeap(JNIEnv* jni,
421                                                                      jclass  klass) {
422     int modified = 0;
423     int found = 0;
424 
425     if (!prepareToIteration(jni))
426         return;
427 
428     NSK_DISPLAY0(&quot;Calling IterateOverHeap...\n&quot;);
429     if (!NSK_JVMTI_VERIFY(jvmti-&gt;IterateOverHeap(JVMTI_HEAP_OBJECT_TAGGED,
430                                                  heapObjectCallback,
431                                                  NULL /*user_data*/))) {
432         nsk_jvmti_setFailStatus();
433     }
434     NSK_DISPLAY0(&quot;IterateOverHeap finished.\n&quot;);
435 
<span class="line-modified">436     afterIteration(jni);</span>
437 
438     found = getCounter(&amp;objectCount);
439     NSK_DISPLAY1(&quot;Found tagged objects: %d\n&quot;, found);
440 
441     modified = OBJ_MAX_COUNT - found;
442     if (modified &gt; 0) {
443         NSK_COMPLAIN2(&quot;Tags were modified by other thread during heap iteration: %d of %d\n&quot;,
444                                                         modified, OBJ_MAX_COUNT);
445         nsk_jvmti_setFailStatus();
446     }
447 }
448 
449 JNIEXPORT void JNICALL
450 Java_nsk_jvmti_scenarios_allocation_AP04_ap04t003_runIterateOverReachableObjects(JNIEnv* jni,
451                                                                                  jclass  klass) {
452     int modified = 0;
453     int found = 0;
454 
455     if (!prepareToIteration(jni))
456         return;
457 
458     NSK_DISPLAY0(&quot;Calling IterateOverReachableObjects...\n&quot;);
459     if (!NSK_JVMTI_VERIFY(jvmti-&gt;IterateOverReachableObjects(heapRootCallback,
460                                                              stackReferenceCallback,
461                                                              objectReferenceCallback,
462                                                              NULL /*user_data*/))) {
463         nsk_jvmti_setFailStatus();
464     }
465     NSK_DISPLAY0(&quot;IterateOverReachableObjects finished.\n&quot;);
466 
<span class="line-modified">467     afterIteration(jni);</span>
468 
469     found = getCounter(&amp;objectCount);
470     NSK_DISPLAY1(&quot;Found tagged objects: %d\n&quot;, found);
471 
472     modified = OBJ_MAX_COUNT - found;
473     if (modified &gt; 0) {
474         NSK_COMPLAIN2(&quot;Tags were modified by other thread during heap iteration: %d of %d\n&quot;,
475                                                         modified, OBJ_MAX_COUNT);
476         nsk_jvmti_setFailStatus();
477     }
478 }
479 
480 JNIEXPORT void JNICALL
481 Java_nsk_jvmti_scenarios_allocation_AP04_ap04t003_runIterateOverInstancesOfClass(JNIEnv* jni,
482                                                                                  jclass  klass) {
483     int modified = 0;
484     int found = 0;
485 
486     if (!prepareToIteration(jni))
487         return;
488 
489     NSK_DISPLAY0(&quot;Calling IterateOverInstancesOfClass...\n&quot;);
490     if (!NSK_JVMTI_VERIFY(jvmti-&gt;IterateOverInstancesOfClass(debugeeClass,
491                                                              JVMTI_HEAP_OBJECT_TAGGED,
492                                                              heapObjectCallback,
493                                                              NULL /*user_data*/))) {
494         nsk_jvmti_setFailStatus();
495     }
496     NSK_DISPLAY0(&quot;IterateOverInstancesOfClass finished.\n&quot;);
497 
<span class="line-modified">498     afterIteration(jni);</span>
499 
500     found = getCounter(&amp;objectCount);
501     NSK_DISPLAY1(&quot;Found tagged objects: %d\n&quot;, found);
502 
503     modified = OBJ_MAX_COUNT - found;
504     if (modified &gt; 0) {
505         NSK_COMPLAIN2(&quot;Tags were modified by other thread during heap iteration: %d of %d\n&quot;,
506                                                         modified, OBJ_MAX_COUNT);
507         nsk_jvmti_setFailStatus();
508     }
509 }
510 
511 JNIEXPORT void JNICALL
<span class="line-modified">512 Java_nsk_jvmti_scenarios_allocation_AP04_ap04t003_runIterateOverObjectsReachableFromObject(JNIEnv* jni,</span>
513                                                                                            jclass  klass) {

514     jobject root = NULL;
515     int modified = 0;
516     int found = 0;
517 
<span class="line-modified">518     root = jni-&gt;GetStaticObjectField(debugeeClass, rootFieldID);</span>
<span class="line-removed">519     if (!NSK_JNI_VERIFY(jni, root != NULL)) {</span>
<span class="line-removed">520         NSK_COMPLAIN0(&quot;GetStaticObjectField returned NULL for &#39;root&#39; field value\n\n&quot;);</span>
<span class="line-removed">521         nsk_jvmti_setFailStatus();</span>
<span class="line-removed">522         return;</span>
<span class="line-removed">523     }</span>
524 
<span class="line-modified">525     if (!prepareToIteration(jni))</span>
526         return;
527 
528     NSK_DISPLAY0(&quot;Calling IterateOverObjectsReachableFromObject...\n&quot;);
529     if (!NSK_JVMTI_VERIFY(jvmti-&gt;IterateOverObjectsReachableFromObject(root,
530                                                                        objectReferenceCallback,
531                                                                        NULL /*user_data*/))) {
532         nsk_jvmti_setFailStatus();
533     }
534     NSK_DISPLAY0(&quot;IterateOverObjectsReachableFromObject finished.\n&quot;);
535 
<span class="line-modified">536     afterIteration(jni);</span>
537 
538     found = getCounter(&amp;objectCount);
539     NSK_DISPLAY1(&quot;Found tagged objects: %d\n&quot;, found);
540 
541     modified = OBJ_MAX_COUNT - found;
542     if (modified &gt; 0) {
543         NSK_COMPLAIN2(&quot;Tags were modified by other thread during heap iteration: %d of %d\n&quot;,
544                                                         modified, OBJ_MAX_COUNT);
545         nsk_jvmti_setFailStatus();
546     }
547 }
548 
549 static void JNICALL
<span class="line-modified">550 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {</span>
<span class="line-modified">551 </span>
552     NSK_DISPLAY0(&quot;Wait for debugee start\n\n&quot;);
553     if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout)))
554         return;
555 
556     NSK_DISPLAY1(&quot;Find debugee class: %s\n&quot;, DEBUGEE_SIGNATURE);
557     debugeeClass = nsk_jvmti_classBySignature(DEBUGEE_SIGNATURE);
558     if (debugeeClass == NULL) {
559         nsk_jvmti_setFailStatus();
560         return;
561     }
562 
<span class="line-modified">563     debugeeClass = (jclass) jni-&gt;NewGlobalRef(debugeeClass);</span>
<span class="line-removed">564     if (!NSK_JNI_VERIFY(jni, debugeeClass != NULL))</span>
<span class="line-removed">565         return;</span>
566 
567     NSK_DISPLAY1(&quot;Find ID of &#39;root&#39; field: %s\n&quot;, ROOT_SIGNATURE);
<span class="line-modified">568     rootFieldID = jni-&gt;GetStaticFieldID(debugeeClass, &quot;root&quot;, ROOT_SIGNATURE);</span>
<span class="line-modified">569     if (!NSK_JNI_VERIFY(jni, rootFieldID != NULL)) {</span>
<span class="line-removed">570         nsk_jvmti_setFailStatus();</span>
<span class="line-removed">571         return;</span>
<span class="line-removed">572     }</span>
573 
574     NSK_DISPLAY0(&quot;Let debugee to run test cases\n&quot;);
575     if (!NSK_VERIFY(nsk_jvmti_resumeSync()))
576         return;
577 
578     NSK_DISPLAY0(&quot;Wait for completion of test cases\n\n&quot;);
579     if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout)))
580         return;
581 
<span class="line-modified">582     NSK_TRACE(jni-&gt;DeleteGlobalRef(debugeeClass));</span>
583     NSK_TRACE(jvmti-&gt;DestroyRawMonitor(counterMonitor_ptr));
584     NSK_TRACE(jvmti-&gt;DestroyRawMonitor(startLock));
585     NSK_TRACE(jvmti-&gt;DestroyRawMonitor(runLock));
586     NSK_TRACE(jvmti-&gt;DestroyRawMonitor(endLock));
587 
588     NSK_DISPLAY0(&quot;Let debugee to finish\n&quot;);
589     if (!NSK_VERIFY(nsk_jvmti_resumeSync()))
590         return;
591 }
592 
593 #ifdef STATIC_BUILD
594 JNIEXPORT jint JNICALL Agent_OnLoad_ap04t003(JavaVM *jvm, char *options, void *reserved) {
595     return Agent_Initialize(jvm, options, reserved);
596 }
597 JNIEXPORT jint JNICALL Agent_OnAttach_ap04t003(JavaVM *jvm, char *options, void *reserved) {
598     return Agent_Initialize(jvm, options, reserved);
599 }
600 JNIEXPORT jint JNI_OnLoad_ap04t003(JavaVM *jvm, char *options, void *reserved) {
601     return JNI_VERSION_1_8;
602 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdio.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &lt;jvmti.h&gt;
 27 #include &quot;agent_common.h&quot;
<span class="line-modified"> 28 #include &quot;ExceptionCheckingJniEnv.hpp&quot;</span>
 29 #include &quot;nsk_tools.h&quot;
 30 #include &quot;jni_tools.h&quot;
 31 #include &quot;JVMTITools.h&quot;
 32 #include &quot;jvmti_tools.h&quot;
 33 
 34 extern &quot;C&quot; {
 35 
 36 #define OBJ_MAX_COUNT 100000
 37 
 38 static JNIEnv *jni = NULL;
 39 static jvmtiEnv *jvmti = NULL;
 40 static jvmtiEventCallbacks callbacks;
 41 static jvmtiCapabilities caps;
 42 
 43 static jlong timeout = 0;
 44 
 45 static const char* DEBUGEE_SIGNATURE = &quot;Lnsk/jvmti/scenarios/allocation/AP04/ap04t003;&quot;;
 46 static const char* ROOT_SIGNATURE    = &quot;[Lnsk/jvmti/scenarios/allocation/AP04/ap04t003;&quot;;
 47 
 48 static jclass debugeeClass = NULL;
</pre>
<hr />
<pre>
288     }
289 
290     /* enter and notify endLock */
291     {
292         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(endLock))) {
293             nsk_jvmti_setFailStatus();
294         }
295         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorNotify(endLock))) {
296             nsk_jvmti_setFailStatus();
297         }
298         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(endLock))) {
299             nsk_jvmti_setFailStatus();
300         }
301     }
302 
303     NSK_DISPLAY0(&quot;Agent thread: finished.\n&quot;);
304 }
305 
306 /***********************************************************************/
307 
<span class="line-modified">308 static int startThread(jthread threadObj) {</span>
309     int success = NSK_TRUE;
310 
311     /* enter startLock */
312     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(startLock))) {
313         nsk_jvmti_setFailStatus();
314     }
315 
316     /* start thread */
317     if (!NSK_JVMTI_VERIFY(
318             jvmti-&gt;RunAgentThread(threadObj, agent_start, NULL, JVMTI_THREAD_NORM_PRIORITY))) {
319         success = NSK_FALSE;
320         nsk_jvmti_setFailStatus();
321     } else {
322         /* wait on startLock */
323         if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorWait(startLock, timeout))) {
324             nsk_jvmti_setFailStatus();
325         }
326     }
327 
328     /* exit starLock */
329     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(startLock))) {
330         nsk_jvmti_setFailStatus();
331     }
332 
333     return success;
334 }
335 
336 /** Create thread object for new agent thread. */
<span class="line-modified">337 static jthread newThreadObj(JNIEnv* jni_env) {</span>
<span class="line-added">338     ExceptionCheckingJniEnvPtr ec_jni(jni_env);</span>
339     jclass thrClass;
340     jmethodID cid;







341 
<span class="line-modified">342     thrClass = ec_jni-&gt;FindClass(&quot;java/lang/Thread&quot;, TRACE_JNI_CALL);</span>
<span class="line-modified">343     cid = ec_jni-&gt;GetMethodID(thrClass, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, TRACE_JNI_CALL);</span>
<span class="line-modified">344     return ec_jni-&gt;NewObject(thrClass, cid, TRACE_JNI_CALL);</span>










345 }
346 
347 /***********************************************************************/
348 
349 /** Clean counters and start new agent thread with agent_start() body. */
<span class="line-modified">350 static int prepareToIteration(JNIEnv* jni) {</span>
351     jthread threadObj = NULL;
352 
353     setCounter(&amp;iterationCount, 0);
354     setCounter(&amp;objectCount, 0);
355 
356     threadObj = newThreadObj(jni);




357 
358     /* enter endLock */
359     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(endLock))) {
360         nsk_jvmti_setFailStatus();
361     }
362 
363     NSK_DISPLAY0(&quot;Starting new agent thread...\n&quot;);
<span class="line-modified">364     return startThread(threadObj);</span>
365 }
366 
367 /** Wait for new agent thread to complete. */
<span class="line-modified">368 static void afterIteration() {</span>
369 
370     /* notify new agent thread (in case if not yet notified) */
371     notifyThread();
372 
373     NSK_DISPLAY0(&quot;Wait for new agent thread to complete\n&quot;);
374 
375     /* wait on endLock */
376     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorWait(endLock, timeout))) {
377         nsk_jvmti_setFailStatus();
378     }
379 
380     /* exit endLock */
381     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(endLock))) {
382         nsk_jvmti_setFailStatus();
383     }
384 }
385 
386 /***********************************************************************/
387 
388 JNIEXPORT void JNICALL
</pre>
<hr />
<pre>
396     }
397 }
398 
399 JNIEXPORT void JNICALL
400 Java_nsk_jvmti_scenarios_allocation_AP04_ap04t003_runIterateOverHeap(JNIEnv* jni,
401                                                                      jclass  klass) {
402     int modified = 0;
403     int found = 0;
404 
405     if (!prepareToIteration(jni))
406         return;
407 
408     NSK_DISPLAY0(&quot;Calling IterateOverHeap...\n&quot;);
409     if (!NSK_JVMTI_VERIFY(jvmti-&gt;IterateOverHeap(JVMTI_HEAP_OBJECT_TAGGED,
410                                                  heapObjectCallback,
411                                                  NULL /*user_data*/))) {
412         nsk_jvmti_setFailStatus();
413     }
414     NSK_DISPLAY0(&quot;IterateOverHeap finished.\n&quot;);
415 
<span class="line-modified">416     afterIteration();</span>
417 
418     found = getCounter(&amp;objectCount);
419     NSK_DISPLAY1(&quot;Found tagged objects: %d\n&quot;, found);
420 
421     modified = OBJ_MAX_COUNT - found;
422     if (modified &gt; 0) {
423         NSK_COMPLAIN2(&quot;Tags were modified by other thread during heap iteration: %d of %d\n&quot;,
424                                                         modified, OBJ_MAX_COUNT);
425         nsk_jvmti_setFailStatus();
426     }
427 }
428 
429 JNIEXPORT void JNICALL
430 Java_nsk_jvmti_scenarios_allocation_AP04_ap04t003_runIterateOverReachableObjects(JNIEnv* jni,
431                                                                                  jclass  klass) {
432     int modified = 0;
433     int found = 0;
434 
435     if (!prepareToIteration(jni))
436         return;
437 
438     NSK_DISPLAY0(&quot;Calling IterateOverReachableObjects...\n&quot;);
439     if (!NSK_JVMTI_VERIFY(jvmti-&gt;IterateOverReachableObjects(heapRootCallback,
440                                                              stackReferenceCallback,
441                                                              objectReferenceCallback,
442                                                              NULL /*user_data*/))) {
443         nsk_jvmti_setFailStatus();
444     }
445     NSK_DISPLAY0(&quot;IterateOverReachableObjects finished.\n&quot;);
446 
<span class="line-modified">447     afterIteration();</span>
448 
449     found = getCounter(&amp;objectCount);
450     NSK_DISPLAY1(&quot;Found tagged objects: %d\n&quot;, found);
451 
452     modified = OBJ_MAX_COUNT - found;
453     if (modified &gt; 0) {
454         NSK_COMPLAIN2(&quot;Tags were modified by other thread during heap iteration: %d of %d\n&quot;,
455                                                         modified, OBJ_MAX_COUNT);
456         nsk_jvmti_setFailStatus();
457     }
458 }
459 
460 JNIEXPORT void JNICALL
461 Java_nsk_jvmti_scenarios_allocation_AP04_ap04t003_runIterateOverInstancesOfClass(JNIEnv* jni,
462                                                                                  jclass  klass) {
463     int modified = 0;
464     int found = 0;
465 
466     if (!prepareToIteration(jni))
467         return;
468 
469     NSK_DISPLAY0(&quot;Calling IterateOverInstancesOfClass...\n&quot;);
470     if (!NSK_JVMTI_VERIFY(jvmti-&gt;IterateOverInstancesOfClass(debugeeClass,
471                                                              JVMTI_HEAP_OBJECT_TAGGED,
472                                                              heapObjectCallback,
473                                                              NULL /*user_data*/))) {
474         nsk_jvmti_setFailStatus();
475     }
476     NSK_DISPLAY0(&quot;IterateOverInstancesOfClass finished.\n&quot;);
477 
<span class="line-modified">478     afterIteration();</span>
479 
480     found = getCounter(&amp;objectCount);
481     NSK_DISPLAY1(&quot;Found tagged objects: %d\n&quot;, found);
482 
483     modified = OBJ_MAX_COUNT - found;
484     if (modified &gt; 0) {
485         NSK_COMPLAIN2(&quot;Tags were modified by other thread during heap iteration: %d of %d\n&quot;,
486                                                         modified, OBJ_MAX_COUNT);
487         nsk_jvmti_setFailStatus();
488     }
489 }
490 
491 JNIEXPORT void JNICALL
<span class="line-modified">492 Java_nsk_jvmti_scenarios_allocation_AP04_ap04t003_runIterateOverObjectsReachableFromObject(JNIEnv* jni_env,</span>
493                                                                                            jclass  klass) {
<span class="line-added">494     ExceptionCheckingJniEnvPtr ec_jni(jni_env);</span>
495     jobject root = NULL;
496     int modified = 0;
497     int found = 0;
498 
<span class="line-modified">499     root = ec_jni-&gt;GetStaticObjectField(debugeeClass, rootFieldID, TRACE_JNI_CALL);</span>





500 
<span class="line-modified">501     if (!prepareToIteration(jni_env))</span>
502         return;
503 
504     NSK_DISPLAY0(&quot;Calling IterateOverObjectsReachableFromObject...\n&quot;);
505     if (!NSK_JVMTI_VERIFY(jvmti-&gt;IterateOverObjectsReachableFromObject(root,
506                                                                        objectReferenceCallback,
507                                                                        NULL /*user_data*/))) {
508         nsk_jvmti_setFailStatus();
509     }
510     NSK_DISPLAY0(&quot;IterateOverObjectsReachableFromObject finished.\n&quot;);
511 
<span class="line-modified">512     afterIteration();</span>
513 
514     found = getCounter(&amp;objectCount);
515     NSK_DISPLAY1(&quot;Found tagged objects: %d\n&quot;, found);
516 
517     modified = OBJ_MAX_COUNT - found;
518     if (modified &gt; 0) {
519         NSK_COMPLAIN2(&quot;Tags were modified by other thread during heap iteration: %d of %d\n&quot;,
520                                                         modified, OBJ_MAX_COUNT);
521         nsk_jvmti_setFailStatus();
522     }
523 }
524 
525 static void JNICALL
<span class="line-modified">526 agentProc(jvmtiEnv* jvmti, JNIEnv* jni_env, void* arg) {</span>
<span class="line-modified">527     ExceptionCheckingJniEnvPtr ec_jni(jni_env);</span>
528     NSK_DISPLAY0(&quot;Wait for debugee start\n\n&quot;);
529     if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout)))
530         return;
531 
532     NSK_DISPLAY1(&quot;Find debugee class: %s\n&quot;, DEBUGEE_SIGNATURE);
533     debugeeClass = nsk_jvmti_classBySignature(DEBUGEE_SIGNATURE);
534     if (debugeeClass == NULL) {
535         nsk_jvmti_setFailStatus();
536         return;
537     }
538 
<span class="line-modified">539     debugeeClass = (jclass) ec_jni-&gt;NewGlobalRef(debugeeClass, TRACE_JNI_CALL);</span>


540 
541     NSK_DISPLAY1(&quot;Find ID of &#39;root&#39; field: %s\n&quot;, ROOT_SIGNATURE);
<span class="line-modified">542     rootFieldID = ec_jni-&gt;GetStaticFieldID(debugeeClass, &quot;root&quot;,</span>
<span class="line-modified">543                                         ROOT_SIGNATURE, TRACE_JNI_CALL);</span>



544 
545     NSK_DISPLAY0(&quot;Let debugee to run test cases\n&quot;);
546     if (!NSK_VERIFY(nsk_jvmti_resumeSync()))
547         return;
548 
549     NSK_DISPLAY0(&quot;Wait for completion of test cases\n\n&quot;);
550     if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout)))
551         return;
552 
<span class="line-modified">553     ec_jni-&gt;DeleteGlobalRef(debugeeClass, TRACE_JNI_CALL);</span>
554     NSK_TRACE(jvmti-&gt;DestroyRawMonitor(counterMonitor_ptr));
555     NSK_TRACE(jvmti-&gt;DestroyRawMonitor(startLock));
556     NSK_TRACE(jvmti-&gt;DestroyRawMonitor(runLock));
557     NSK_TRACE(jvmti-&gt;DestroyRawMonitor(endLock));
558 
559     NSK_DISPLAY0(&quot;Let debugee to finish\n&quot;);
560     if (!NSK_VERIFY(nsk_jvmti_resumeSync()))
561         return;
562 }
563 
564 #ifdef STATIC_BUILD
565 JNIEXPORT jint JNICALL Agent_OnLoad_ap04t003(JavaVM *jvm, char *options, void *reserved) {
566     return Agent_Initialize(jvm, options, reserved);
567 }
568 JNIEXPORT jint JNICALL Agent_OnAttach_ap04t003(JavaVM *jvm, char *options, void *reserved) {
569     return Agent_Initialize(jvm, options, reserved);
570 }
571 JNIEXPORT jint JNI_OnLoad_ap04t003(JavaVM *jvm, char *options, void *reserved) {
572     return JNI_VERSION_1_8;
573 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../SingleStep/singlestep003/singlestep003.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="libap04t003.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jdi/EventRequestManager/createStepRequest/crstepreq004.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="crstepreq003.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="crstepreq005.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jdi/EventRequestManager/createStepRequest/crstepreq004.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
138             }
139 
140         } catch (Exception e) {
141             exitCode = Consts.TEST_FAILED;
142             complain(&quot;Unexpected Exception: &quot; + e.getMessage());
143             e.printStackTrace(out);
144             complain(&quot;The test has not finished normally. Forcing: vm.exit().&quot;);
145             if (vm != null) {
146                 vm.exit(PASSED + PASS_BASE);
147             }
148             debuggee.resume();
149             getEventSet();
150         }
151 
152         return exitCode;
153     }
154 
155     //--------------------------------------------------------- mutable common methods
156 
157     private void execTest() {
<span class="line-modified">158         ThreadReference mainThread = threadByName(&quot;main&quot;);</span>
159 
160         BreakpointRequest bpRequest = setBreakpoint( mainThread,
161                                                      debuggeeClass,
162                                                      &quot;methodForCommunication&quot;,
163                                                      lineForBreakInThread,
164                                                      &quot;breakpointForCommunication&quot;);
165         bpRequest.enable();
166 
167         display(&quot;TESTING BEGINS&quot;);
168 
169         label0:
170         for (int testCase = 0; instruction != quit; testCase++) {
171 
172 //            waitForEvent(bpRequest);
173             instruction = getInstruction();
174             if (instruction == quit) {
175                 vm.resume();
176                 break;
177             }
178 
</pre>
<hr />
<pre>
230         display(&quot;setStepRequest(): A StepRequest has been set up.&quot;);
231         return stepRequest;
232     }
233 
234     private void setAndCheckStepEvent ( BreakpointRequest bpRequest,
235                                         String caseProperty,
236                                         String threadName,
237                                         int testCaseIndex,
238                                         int stepDepth) {
239         display(&quot;Wait for brakepoint event in &quot; + threadName);
240         BreakpointEvent bpEvent = (BreakpointEvent)waitForEvent(bpRequest);
241 
242         // check location of breakpoint event
243         int lineOfEvent = ((LocatableEvent)bpEvent).location().lineNumber();
244         if (lineOfEvent != lineForBreakInThread) {
245             complain(&quot;Wrong line number of BreakpointEvent for &quot; + threadName);
246             complain(&quot;\texpected value : &quot; + lineForBreakInThread + &quot;; got one : &quot; + lineOfEvent);
247             exitCode = FAILED;
248         }
249 
<span class="line-modified">250         ThreadReference thread = threadByName(threadName);</span>
251         StepRequest stepRequest = setStepRequest( thread,
252                                                   StepRequest.STEP_LINE,
253                                                   stepDepth,
254                                                   caseProperty);
255         stepRequest.enable();
256 
257         display(&quot;waiting for StepEvent in &quot; + threadName);
258         Event newEvent = waitForEvent(stepRequest);
259         if (newEvent instanceof StepEvent) {
260             String property = (String) newEvent.request().getProperty(&quot;number&quot;);
261             display(&quot;got new StepEvent with property &#39;number&#39; == &quot; + property);
262 
263             if ( !property.equals(caseProperty) ) {
264                 complain(&quot;property is not : &quot; + caseProperty);
265                 exitCode = FAILED;
266             }
267             // check location of step event
268             lineOfEvent = ((LocatableEvent)newEvent).location().lineNumber();
269             boolean isCorrectLine = lineOfEvent == checkedLines[testCaseIndex] || lineOfEvent == checkedLinesAlt[testCaseIndex];
270             if (!isCorrectLine) {
</pre>
<hr />
<pre>
401             }
402         } catch (Exception e) {
403             throw new Failure(&quot;Unexpected exception while waiting for an event: &quot; + e);
404         }
405         return resultEvent;
406     }
407 
408 
409     private void getEventSet() {
410         try {
411             eventSet = vm.eventQueue().remove(waitTime);
412             if (eventSet == null) {
413                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
414             }
415             eventIterator = eventSet.eventIterator();
416         } catch (Exception e) {
417             throw new Failure(&quot;getEventSet(): Unexpected exception while waiting for an event: &quot; + e);
418         }
419     }
420 
<span class="line-removed">421 </span>
<span class="line-removed">422     private ThreadReference threadByName(String name) throws Failure{</span>
<span class="line-removed">423         List all = vm.allThreads();</span>
<span class="line-removed">424         ListIterator li = all.listIterator();</span>
<span class="line-removed">425 </span>
<span class="line-removed">426         while (li.hasNext()) {</span>
<span class="line-removed">427             ThreadReference thread = (ThreadReference) li.next();</span>
<span class="line-removed">428             if (thread.name().equals(name))</span>
<span class="line-removed">429                 return thread;</span>
<span class="line-removed">430         }</span>
<span class="line-removed">431         throw new Failure(&quot;Thread with searching for name is not found: &quot; + name);</span>
<span class="line-removed">432     }</span>
<span class="line-removed">433 </span>
434     private ReferenceType waitForDebuggeeClassPrepared () {
435         display(&quot;Creating request for ClassPrepareEvent for debuggee.&quot;);
436         ClassPrepareRequest cpRequest = eventRManager.createClassPrepareRequest();
437         cpRequest.addClassFilter(debuggeeName);
438         cpRequest.addCountFilter(1);
439         cpRequest.enable();
440 
441         ClassPrepareEvent event = (ClassPrepareEvent) waitForEvent(cpRequest);
442         cpRequest.disable();
443 
444         if (!event.referenceType().name().equals(debuggeeName)) {
445            throw new Failure(&quot;Unexpected class name for ClassPrepareEvent : &quot; + debuggeeClass.name());
446         }
447         return event.referenceType();
448     }
449 
450     private int getInstruction () {
451         if (debuggeeClass == null) {
452             throw new Failure(&quot;getInstruction() :: debuggeeClass reference is null&quot;);
453         }
</pre>
</td>
<td>
<hr />
<pre>
138             }
139 
140         } catch (Exception e) {
141             exitCode = Consts.TEST_FAILED;
142             complain(&quot;Unexpected Exception: &quot; + e.getMessage());
143             e.printStackTrace(out);
144             complain(&quot;The test has not finished normally. Forcing: vm.exit().&quot;);
145             if (vm != null) {
146                 vm.exit(PASSED + PASS_BASE);
147             }
148             debuggee.resume();
149             getEventSet();
150         }
151 
152         return exitCode;
153     }
154 
155     //--------------------------------------------------------- mutable common methods
156 
157     private void execTest() {
<span class="line-modified">158         ThreadReference mainThread = debuggee.threadByNameOrThrow(&quot;main&quot;);</span>
159 
160         BreakpointRequest bpRequest = setBreakpoint( mainThread,
161                                                      debuggeeClass,
162                                                      &quot;methodForCommunication&quot;,
163                                                      lineForBreakInThread,
164                                                      &quot;breakpointForCommunication&quot;);
165         bpRequest.enable();
166 
167         display(&quot;TESTING BEGINS&quot;);
168 
169         label0:
170         for (int testCase = 0; instruction != quit; testCase++) {
171 
172 //            waitForEvent(bpRequest);
173             instruction = getInstruction();
174             if (instruction == quit) {
175                 vm.resume();
176                 break;
177             }
178 
</pre>
<hr />
<pre>
230         display(&quot;setStepRequest(): A StepRequest has been set up.&quot;);
231         return stepRequest;
232     }
233 
234     private void setAndCheckStepEvent ( BreakpointRequest bpRequest,
235                                         String caseProperty,
236                                         String threadName,
237                                         int testCaseIndex,
238                                         int stepDepth) {
239         display(&quot;Wait for brakepoint event in &quot; + threadName);
240         BreakpointEvent bpEvent = (BreakpointEvent)waitForEvent(bpRequest);
241 
242         // check location of breakpoint event
243         int lineOfEvent = ((LocatableEvent)bpEvent).location().lineNumber();
244         if (lineOfEvent != lineForBreakInThread) {
245             complain(&quot;Wrong line number of BreakpointEvent for &quot; + threadName);
246             complain(&quot;\texpected value : &quot; + lineForBreakInThread + &quot;; got one : &quot; + lineOfEvent);
247             exitCode = FAILED;
248         }
249 
<span class="line-modified">250         ThreadReference thread = debuggee.threadByNameOrThrow(threadName);</span>
251         StepRequest stepRequest = setStepRequest( thread,
252                                                   StepRequest.STEP_LINE,
253                                                   stepDepth,
254                                                   caseProperty);
255         stepRequest.enable();
256 
257         display(&quot;waiting for StepEvent in &quot; + threadName);
258         Event newEvent = waitForEvent(stepRequest);
259         if (newEvent instanceof StepEvent) {
260             String property = (String) newEvent.request().getProperty(&quot;number&quot;);
261             display(&quot;got new StepEvent with property &#39;number&#39; == &quot; + property);
262 
263             if ( !property.equals(caseProperty) ) {
264                 complain(&quot;property is not : &quot; + caseProperty);
265                 exitCode = FAILED;
266             }
267             // check location of step event
268             lineOfEvent = ((LocatableEvent)newEvent).location().lineNumber();
269             boolean isCorrectLine = lineOfEvent == checkedLines[testCaseIndex] || lineOfEvent == checkedLinesAlt[testCaseIndex];
270             if (!isCorrectLine) {
</pre>
<hr />
<pre>
401             }
402         } catch (Exception e) {
403             throw new Failure(&quot;Unexpected exception while waiting for an event: &quot; + e);
404         }
405         return resultEvent;
406     }
407 
408 
409     private void getEventSet() {
410         try {
411             eventSet = vm.eventQueue().remove(waitTime);
412             if (eventSet == null) {
413                 throw new Failure(&quot;TIMEOUT while waiting for an event&quot;);
414             }
415             eventIterator = eventSet.eventIterator();
416         } catch (Exception e) {
417             throw new Failure(&quot;getEventSet(): Unexpected exception while waiting for an event: &quot; + e);
418         }
419     }
420 













421     private ReferenceType waitForDebuggeeClassPrepared () {
422         display(&quot;Creating request for ClassPrepareEvent for debuggee.&quot;);
423         ClassPrepareRequest cpRequest = eventRManager.createClassPrepareRequest();
424         cpRequest.addClassFilter(debuggeeName);
425         cpRequest.addCountFilter(1);
426         cpRequest.enable();
427 
428         ClassPrepareEvent event = (ClassPrepareEvent) waitForEvent(cpRequest);
429         cpRequest.disable();
430 
431         if (!event.referenceType().name().equals(debuggeeName)) {
432            throw new Failure(&quot;Unexpected class name for ClassPrepareEvent : &quot; + debuggeeClass.name());
433         }
434         return event.referenceType();
435     }
436 
437     private int getInstruction () {
438         if (debuggeeClass == null) {
439             throw new Failure(&quot;getInstruction() :: debuggeeClass reference is null&quot;);
440         }
</pre>
</td>
</tr>
</table>
<center><a href="crstepreq003.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="crstepreq005.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
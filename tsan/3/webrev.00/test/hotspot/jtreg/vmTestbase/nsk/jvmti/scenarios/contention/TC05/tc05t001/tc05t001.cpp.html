<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/contention/TC05/tc05t001/tc05t001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdlib.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &quot;jni_tools.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 /* ========================================================================== */
 33 
 34 static const jlong EXPECTED_TIMEOUT = 1;
 35 /*
 36  * The expected timeout accuracy was already increased from 100000 to 300000.
 37  * Please, do not increase it anymore if the test still fails with the message:
 38  *  &quot;(waitedTime - waitTime) &gt;= (EXPECTED_TIMEOUT * 1000000) - EXPECTED_TIMEOUT_ACCURACY_NS&quot;
 39  */
 40 static const jlong EXPECTED_TIMEOUT_ACCURACY_NS = 300000;
 41 
 42 #if (defined(WIN32) || defined(_WIN32))
 43 static const jlong EXPECTED_ACCURACY = 16; // 16ms is longest clock update interval
 44 #else
 45 static const jlong EXPECTED_ACCURACY = 10; // high frequency clock updates expected
 46 #endif
 47 
 48 /* scaffold objects */
 49 static jlong timeout = 0;
 50 
 51 /* test objects */
 52 static jthread thread = NULL;
 53 static jobject object_M = NULL;
 54 static volatile int waitEventsCount = 0;
 55 static volatile int waitedEventsCount = 0;
 56 static jlong waitTime = 0;
 57 static jlong waitThreadCpuTime = 0;
 58 static jlong waitedTime = 0;
 59 static jlong waitedThreadCpuTime = 0;
 60 
 61 /* ========================================================================== */
 62 
 63 void JNICALL
 64 MonitorWait(jvmtiEnv *jvmti, JNIEnv* jni,
 65         jthread thr, jobject obj, jlong tout) {
 66     char buffer[32];
 67 
 68     if (!NSK_VERIFY(thr != NULL)) {
 69         nsk_jvmti_setFailStatus();
 70         return;
 71     }
 72 
 73     if (!NSK_VERIFY(obj != NULL)) {
 74         nsk_jvmti_setFailStatus();
 75         return;
 76     }
 77 
 78     /* check if event is for tested thread and object */
 79     if (jni-&gt;IsSameObject(thread, thr) &amp;&amp;
 80             jni-&gt;IsSameObject(object_M, obj)) {
 81         if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetThreadCpuTime(thr, &amp;waitThreadCpuTime))) {
 82             nsk_jvmti_setFailStatus();
 83         }
 84         if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetTime(&amp;waitTime))) {
 85             nsk_jvmti_setFailStatus();
 86         }
 87         waitEventsCount++;
 88         NSK_DISPLAY0(&quot;MonitorWait event:\n&quot;);
 89         NSK_DISPLAY3(&quot;\tthread: %p, object: %p, timeout: %s\n&quot;,
 90             thr, obj, jlong_to_string(tout, buffer));
 91         NSK_DISPLAY1(&quot;\ttime: %s\n&quot;,
 92             jlong_to_string(waitTime, buffer));
 93         NSK_DISPLAY1(&quot;\tthread CPU time: %s\n&quot;,
 94             jlong_to_string(waitThreadCpuTime, buffer));
 95 
 96         if (!NSK_VERIFY(tout == EXPECTED_TIMEOUT)) {
 97             nsk_jvmti_setFailStatus();
 98         }
 99     }
100 }
101 
102 void JNICALL
103 MonitorWaited(jvmtiEnv *jvmti, JNIEnv* jni,
104         jthread thr, jobject obj, jboolean timed_out) {
105     char buffer[32];
106 
107     if (!NSK_VERIFY(thr != NULL)) {
108         nsk_jvmti_setFailStatus();
109         return;
110     }
111 
112     if (!NSK_VERIFY(obj != NULL)) {
113         nsk_jvmti_setFailStatus();
114         return;
115     }
116 
117     /* check if event is for tested thread and object */
118     if (jni-&gt;IsSameObject(thread, thr) &amp;&amp;
119             jni-&gt;IsSameObject(object_M, obj)) {
120         if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetThreadCpuTime(thr, &amp;waitedThreadCpuTime))) {
121             nsk_jvmti_setFailStatus();
122         }
123         if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetTime(&amp;waitedTime))) {
124             nsk_jvmti_setFailStatus();
125         }
126         waitedEventsCount++;
127         NSK_DISPLAY0(&quot;MonitorWaited event:\n&quot;);
128         NSK_DISPLAY3(&quot;\tthread: %p, object: %p, timed_out: %s\n&quot;,
129             thr, obj, (timed_out == JNI_TRUE) ? &quot;true&quot; : &quot;false&quot;);
130         NSK_DISPLAY1(&quot;\tGetTime: %s\n&quot;,
131             jlong_to_string(waitedTime, buffer));
132         NSK_DISPLAY1(&quot;\tthread CPU time: %s\n&quot;,
133             jlong_to_string(waitedThreadCpuTime, buffer));
134     }
135 }
136 
137 /* ========================================================================== */
138 
139 static int prepare(jvmtiEnv* jvmti, JNIEnv* jni) {
140     const char* THREAD_NAME = &quot;Debuggee Thread&quot;;
141     const char* FIELD_SIG = &quot;Ljava/lang/Object;&quot;;
142     jvmtiThreadInfo info;
143     jthread *threads = NULL;
144     jint threads_count = 0;
145     jfieldID field = NULL;
146     jclass klass = NULL;
147     int i;
148 
149     NSK_DISPLAY0(&quot;Prepare: find tested thread\n&quot;);
150 
151     /* get all live threads */
152     if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetAllThreads(&amp;threads_count, &amp;threads)))
153         return NSK_FALSE;
154 
155     if (!NSK_VERIFY(threads_count &gt; 0 &amp;&amp; threads != NULL))
156         return NSK_FALSE;
157 
158     /* find tested thread */
159     for (i = 0; i &lt; threads_count; i++) {
160         if (!NSK_VERIFY(threads[i] != NULL))
161             return NSK_FALSE;
162 
163         /* get thread information */
164         if (!NSK_JVMTI_VERIFY(jvmti-&gt;GetThreadInfo(threads[i], &amp;info)))
165             return NSK_FALSE;
166 
167         NSK_DISPLAY3(&quot;    thread #%d (%s): %p\n&quot;, i, info.name, threads[i]);
168 
169         /* find by name */
170         if (info.name != NULL &amp;&amp; (strcmp(info.name, THREAD_NAME) == 0)) {
171             thread = threads[i];
172         }
173 
174         if (info.name != NULL) {
175             if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)info.name)))
176                 return NSK_FALSE;
177         }
178     }
179 
180     /* deallocate threads list */
181     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)threads)))
182         return NSK_FALSE;
183 
184     if (thread == NULL) {
185         NSK_COMPLAIN0(&quot;Debuggee thread not found&quot;);
186         return NSK_FALSE;
187     }
188 
189     /* make thread accessable for a long time */
190     if (!NSK_JNI_VERIFY(jni, (thread = jni-&gt;NewGlobalRef(thread)) != NULL))
191         return NSK_FALSE;
192 
193     /* get tested thread class */
194     if (!NSK_JNI_VERIFY(jni, (klass = jni-&gt;GetObjectClass(thread)) != NULL))
195         return NSK_FALSE;
196 
197     /* get tested thread field &#39;M&#39; */
198     if (!NSK_JNI_VERIFY(jni, (field = jni-&gt;GetFieldID(klass, &quot;M&quot;, FIELD_SIG)) != NULL))
199         return NSK_FALSE;
200 
201     if (!NSK_JNI_VERIFY(jni, (object_M = jni-&gt;GetObjectField(thread, field)) != NULL))
202         return NSK_FALSE;
203 
204     /* make object accessable for a long time */
205     if (!NSK_JNI_VERIFY(jni, (object_M = jni-&gt;NewGlobalRef(object_M)) != NULL))
206         return NSK_FALSE;
207 
208     /* enable MonitorWait event */
209     if (!NSK_JVMTI_VERIFY(
210             jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))
211         return NSK_FALSE;
212 
213     /* enable MonitorWaited event */
214     if (!NSK_JVMTI_VERIFY(
215             jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))
216         return NSK_FALSE;
217 
218     return NSK_TRUE;
219 }
220 
221 static int clean(jvmtiEnv* jvmti, JNIEnv* jni) {
222 
223     /* disable MonitorWait event */
224     if (!NSK_JVMTI_VERIFY(
225             jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))
226         nsk_jvmti_setFailStatus();
227 
228     /* disable MonitorWaited event */
229     if (!NSK_JVMTI_VERIFY(
230             jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))
231         nsk_jvmti_setFailStatus();
232 
233     return NSK_TRUE;
234 }
235 
236 /* ========================================================================== */
237 
238 /* agent algorithm */
239 static void JNICALL
240 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
241     char buffer[32];
242 
243     /* wait for initial sync */
244     if (!nsk_jvmti_waitForSync(timeout))
245         return;
246 
247     if (!prepare(jvmti, jni)) {
248         nsk_jvmti_setFailStatus();
249         return;
250     }
251 
252     /* resume debugee to catch MonitorContendedEntered events */
253     if (!(NSK_VERIFY(nsk_jvmti_resumeSync()) &amp;&amp;
254           NSK_VERIFY(nsk_jvmti_waitForSync(timeout))))
255         return;
256 
257     NSK_DISPLAY1(&quot;Number of MonitorWait events: %d\n&quot;, waitEventsCount);
258     if (!(NSK_VERIFY(waitEventsCount == 1))) {
259         nsk_jvmti_setFailStatus();
260     }
261 
262     NSK_DISPLAY1(&quot;Number of MonitorWaited events: %d\n&quot;, waitedEventsCount);
263     if (!(NSK_VERIFY(waitedEventsCount == 1))) {
264         nsk_jvmti_setFailStatus();
265     }
266 
267     NSK_DISPLAY1(&quot;Time frame between the events: %s ns\n&quot;,
268         jlong_to_string(waitedTime - waitTime, buffer));
269     if (!(NSK_VERIFY((waitedTime - waitTime) &gt;= (EXPECTED_TIMEOUT * 1000000) - EXPECTED_TIMEOUT_ACCURACY_NS))) {
270 #if (defined(WIN32) || defined(_WIN32))
271         /* Do not fail on Windows as early returns are expected and wait() treats them as spurious wakeups. */
272 #else
273         nsk_jvmti_setFailStatus();
274 #endif
275         printf(&quot;waitedTime: %&quot; LL &quot;d,  waitTime: %&quot; LL &quot;d, waitedTime - waitTime: %&quot; LL &quot;d\n&quot;,
276                 waitedTime, waitTime, waitedTime - waitTime);
277     }
278 
279     NSK_DISPLAY1(&quot;Thread CPU time between the events: %s ns\n&quot;,
280         jlong_to_string(waitedThreadCpuTime - waitThreadCpuTime, buffer));
281     if (!(NSK_VERIFY((waitedThreadCpuTime - waitThreadCpuTime)
282             &lt; (EXPECTED_ACCURACY * 1000000)))) {
283         nsk_jvmti_setFailStatus();
284         printf(&quot;waitedThreadCpuTime: %&quot; LL &quot;d, waitThreadCpuTime: %&quot; LL &quot;d, waitedThreadCpuTime - waitThreadCpuTime: %&quot; LL &quot;d\n&quot;,
285                 waitedThreadCpuTime, waitThreadCpuTime, waitedThreadCpuTime - waitThreadCpuTime);
286     }
287 
288     if (!clean(jvmti, jni)) {
289         nsk_jvmti_setFailStatus();
290         return;
291     }
292 
293     /* resume debugee after last sync */
294     if (!nsk_jvmti_resumeSync())
295         return;
296 }
297 
298 /* ========================================================================== */
299 
300 /* agent library initialization */
301 #ifdef STATIC_BUILD
302 JNIEXPORT jint JNICALL Agent_OnLoad_tc05t001(JavaVM *jvm, char *options, void *reserved) {
303     return Agent_Initialize(jvm, options, reserved);
304 }
305 JNIEXPORT jint JNICALL Agent_OnAttach_tc05t001(JavaVM *jvm, char *options, void *reserved) {
306     return Agent_Initialize(jvm, options, reserved);
307 }
308 JNIEXPORT jint JNI_OnLoad_tc05t001(JavaVM *jvm, char *options, void *reserved) {
309     return JNI_VERSION_1_8;
310 }
311 #endif
312 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
313     jvmtiEnv* jvmti = NULL;
314     jvmtiCapabilities caps;
315     jvmtiEventCallbacks callbacks;
316 
317     /* init framework and parse options */
318     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
319         return JNI_ERR;
320 
321     timeout = nsk_jvmti_getWaitTime() * 60000;
322     NSK_DISPLAY1(&quot;Timeout: %d msc\n&quot;, (int)timeout);
323 
324     /* create JVMTI environment */
325     if (!NSK_VERIFY((jvmti =
326             nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))
327         return JNI_ERR;
328 
329     /* add capabilities */
330     memset(&amp;caps, 0, sizeof(caps));
331     caps.can_generate_monitor_events = 1;
332     caps.can_get_thread_cpu_time = 1;
333     if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
334         return JNI_ERR;
335 
336     memset(&amp;callbacks, 0, sizeof(callbacks));
337     callbacks.MonitorWait = &amp;MonitorWait;
338     callbacks.MonitorWaited = &amp;MonitorWaited;
339     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks))))
340         return JNI_ERR;
341 
342     /* register agent proc and arg */
343     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
344         return JNI_ERR;
345 
346     return JNI_OK;
347 }
348 
349 /* ========================================================================== */
350 
351 }
    </pre>
  </body>
</html>
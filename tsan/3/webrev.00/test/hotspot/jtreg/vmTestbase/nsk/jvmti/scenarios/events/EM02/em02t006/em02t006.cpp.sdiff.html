<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t006/em02t006.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../em02t005/em02t005.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../em02t007/em02t007.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t006/em02t006.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 42 #define OBJECT_NUMBER 100
 43 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 44 
 45 static int eventCount[JVMTI_EVENT_COUNT];
 46 static int newEventCount[JVMTI_EVENT_COUNT];
 47 
 48 /* ============================================================================= */
 49 
 50 
 51 /*
 52  * Class:     nsk_jvmti_scenarios_events_EM02_em02t006
 53  * Method:    setTag
 54  * Signature: (Ljava/lang/Object;J)Z
 55  */
 56 JNIEXPORT jboolean JNICALL
 57 Java_nsk_jvmti_scenarios_events_EM02_em02t006_setTag(JNIEnv *env,
 58                         jobject o, jobject object, jlong tag) {
 59 
 60     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(object, tag))) {
 61         NSK_COMPLAIN0(&quot;TEST FAILED: unable to set tag for a tested object\n&quot;);
<span class="line-modified"> 62         return NSK_FALSE;</span>
 63     }
<span class="line-modified"> 64     return NSK_TRUE;</span>
 65 }
 66 
 67 static void
 68 showEventStatistics(int step) {
 69     int i;
 70     const char* str;
 71     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 72 
 73     NSK_DISPLAY0(&quot;\n&quot;);
 74     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 75     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 76     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 77         if (currentCounts[i] &gt; 0) {
 78             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 79             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 80         }
 81     }
 82 }
 83 
 84 /* ========================================================================== */
 85 
 86 int checkEvents(int step) {
 87     int i;
 88     jvmtiEvent curr;
<span class="line-modified"> 89     int result = NSK_TRUE;</span>
 90     int *currentCounts;
 91     int isExpected = 0;
 92 
 93     switch (step) {
 94         case 1:
 95             currentCounts = &amp;eventCount[0];
 96             break;
 97 
 98         case 2:
 99         case 3:
100             currentCounts = &amp;newEventCount[0];
101             break;
102 
103         default:
104             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified">105             return NSK_FALSE;</span>
106     }
107 
108     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
109 
110         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
111 
112         switch (step) {
113             case 1:
114                 isExpected = ((curr == JVMTI_EVENT_OBJECT_FREE)
115                                 || (curr == JVMTI_EVENT_VM_INIT));
116                 break;
117 
118             case 2:
119                 isExpected = (curr == JVMTI_EVENT_OBJECT_FREE);
120                 break;
121 
122             case 3:
123                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
124                 break;
125         }
126 
127         if (isExpected) {
128             if (currentCounts[i] &lt; 0 || currentCounts[i] &gt; OBJECT_NUMBER) {
129                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
130                                         currentCounts[i],
131                                         TranslateEvent(curr));
<span class="line-modified">132                 result = NSK_FALSE;</span>
133             }
134         } else {
135 
136             if (currentCounts[i] &gt; 0) {
137                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
138                                     TranslateEvent(curr),
139                                     currentCounts[i]);
<span class="line-modified">140                 result = NSK_FALSE;</span>
141             }
142         }
143     }
144 
145     return result;
146 }
147 
148 static void
149 changeCount(jvmtiEvent event, int *currentCounts) {
150 
151     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
152         nsk_jvmti_setFailStatus();
153 
154     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
155 
156     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
157         nsk_jvmti_setFailStatus();
158 
159 }
160 
</pre>
<hr />
<pre>
306 
307 void JNICALL
308 cbNewObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
309 
310     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;newEventCount[0]);
311     if (tag &lt; 1 || tag &gt; OBJECT_NUMBER) {
312         NSK_COMPLAIN1(&quot;Unexpected tag value %lld\n&quot;, tag);
313         nsk_jvmti_setFailStatus();
314     }
315 }
316 
317 void JNICALL
318 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
319                     jobject object, jclass object_klass, jlong size) {
320 
321     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
322 }
323 
324 /* ============================================================================= */
325 
<span class="line-modified">326 static int enableEvent(jvmtiEvent event) {</span>
327 
328     if (nsk_jvmti_isOptionalEvent(event)
329             &amp;&amp; (event != JVMTI_EVENT_OBJECT_FREE)) {
330         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
331                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
332             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
333                 TranslateEvent(event));
<span class="line-modified">334             return NSK_FALSE;</span>
335         }
336     } else {
337         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
338             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
339                 TranslateEvent(event));
<span class="line-modified">340             return NSK_FALSE;</span>
341         }
342     }
343 
<span class="line-modified">344     return NSK_TRUE;</span>
345 }
346 
347 /**
348  * Enable or disable tested events.
349  */
<span class="line-modified">350 static int enableEventList() {</span>
351 
352     int i, result;
353 
354     result = enableEvent(JVMTI_EVENT_VM_INIT);
355 
356     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
357 
358     /* enabling optional events */
359     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
360         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
361 
362         if (nsk_jvmti_isOptionalEvent(event))
363             result = result &amp;&amp; enableEvent(event);
364     }
365 
<span class="line-modified">366     if (result == NSK_FALSE) {</span>
367         nsk_jvmti_setFailStatus();
<span class="line-modified">368         return NSK_FALSE;</span>
369     }
370 
<span class="line-modified">371     return NSK_TRUE;</span>
372 }
373 
374 /* ============================================================================= */
375 
<span class="line-modified">376 static int</span>
<span class="line-removed">377 setCallBacks(int step) {</span>
378 
379     int i;
380 
381     jvmtiEventCallbacks eventCallbacks;
382     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
383 
384     switch (step) {
385         case 1:
386             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
387                 eventCount[i] = 0;
388             }
389 
390             eventCallbacks.VMInit                    = cbVMInit;
391             eventCallbacks.Exception                 = cbException;
392             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
393             eventCallbacks.SingleStep                = cbSingleStep;
394             eventCallbacks.FramePop                  = cbFramePop;
395             eventCallbacks.Breakpoint                = cbBreakpoint;
396             eventCallbacks.FieldAccess               = cbFieldAccess;
397             eventCallbacks.FieldModification         = cbFieldModification;
</pre>
<hr />
<pre>
411             break;
412 
413         case 2:
414             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
415                 newEventCount[i] = 0;
416             }
417 
418             eventCallbacks.ObjectFree                = cbNewObjectFree;
419             break;
420 
421         case 3:
422             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
423                 newEventCount[i] = 0;
424             }
425 
426             eventCallbacks.VMDeath                   = cbVMDeath;
427             break;
428 
429     }
430     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">431         return NSK_FALSE;</span>
432 
<span class="line-modified">433     return NSK_TRUE;</span>
434 }
435 
436 /* ============================================================================= */
437 
438 /** Agent algorithm. */
439 static void JNICALL
440 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
441 
442     int i;
443 
444     for (i = 1; i &lt;= STEP_NUMBER; i++) {
445 
446         if (!nsk_jvmti_waitForSync(timeout))
447             return;
448 
449         NSK_DISPLAY0(&quot;Check received events\n&quot;);
450 
451         if (i &lt; STEP_NUMBER) {
452             showEventStatistics(i);
453             if (!checkEvents(i))
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 42 #define OBJECT_NUMBER 100
 43 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 44 
 45 static int eventCount[JVMTI_EVENT_COUNT];
 46 static int newEventCount[JVMTI_EVENT_COUNT];
 47 
 48 /* ============================================================================= */
 49 
 50 
 51 /*
 52  * Class:     nsk_jvmti_scenarios_events_EM02_em02t006
 53  * Method:    setTag
 54  * Signature: (Ljava/lang/Object;J)Z
 55  */
 56 JNIEXPORT jboolean JNICALL
 57 Java_nsk_jvmti_scenarios_events_EM02_em02t006_setTag(JNIEnv *env,
 58                         jobject o, jobject object, jlong tag) {
 59 
 60     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(object, tag))) {
 61         NSK_COMPLAIN0(&quot;TEST FAILED: unable to set tag for a tested object\n&quot;);
<span class="line-modified"> 62         return false;</span>
 63     }
<span class="line-modified"> 64     return true;</span>
 65 }
 66 
 67 static void
 68 showEventStatistics(int step) {
 69     int i;
 70     const char* str;
 71     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 72 
 73     NSK_DISPLAY0(&quot;\n&quot;);
 74     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 75     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 76     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 77         if (currentCounts[i] &gt; 0) {
 78             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 79             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 80         }
 81     }
 82 }
 83 
 84 /* ========================================================================== */
 85 
 86 int checkEvents(int step) {
 87     int i;
 88     jvmtiEvent curr;
<span class="line-modified"> 89     bool result = true;</span>
 90     int *currentCounts;
 91     int isExpected = 0;
 92 
 93     switch (step) {
 94         case 1:
 95             currentCounts = &amp;eventCount[0];
 96             break;
 97 
 98         case 2:
 99         case 3:
100             currentCounts = &amp;newEventCount[0];
101             break;
102 
103         default:
104             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified">105             return false;</span>
106     }
107 
108     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
109 
110         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
111 
112         switch (step) {
113             case 1:
114                 isExpected = ((curr == JVMTI_EVENT_OBJECT_FREE)
115                                 || (curr == JVMTI_EVENT_VM_INIT));
116                 break;
117 
118             case 2:
119                 isExpected = (curr == JVMTI_EVENT_OBJECT_FREE);
120                 break;
121 
122             case 3:
123                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
124                 break;
125         }
126 
127         if (isExpected) {
128             if (currentCounts[i] &lt; 0 || currentCounts[i] &gt; OBJECT_NUMBER) {
129                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
130                                         currentCounts[i],
131                                         TranslateEvent(curr));
<span class="line-modified">132                 result = false;</span>
133             }
134         } else {
135 
136             if (currentCounts[i] &gt; 0) {
137                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
138                                     TranslateEvent(curr),
139                                     currentCounts[i]);
<span class="line-modified">140                 result = false;</span>
141             }
142         }
143     }
144 
145     return result;
146 }
147 
148 static void
149 changeCount(jvmtiEvent event, int *currentCounts) {
150 
151     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
152         nsk_jvmti_setFailStatus();
153 
154     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
155 
156     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
157         nsk_jvmti_setFailStatus();
158 
159 }
160 
</pre>
<hr />
<pre>
306 
307 void JNICALL
308 cbNewObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
309 
310     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;newEventCount[0]);
311     if (tag &lt; 1 || tag &gt; OBJECT_NUMBER) {
312         NSK_COMPLAIN1(&quot;Unexpected tag value %lld\n&quot;, tag);
313         nsk_jvmti_setFailStatus();
314     }
315 }
316 
317 void JNICALL
318 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
319                     jobject object, jclass object_klass, jlong size) {
320 
321     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
322 }
323 
324 /* ============================================================================= */
325 
<span class="line-modified">326 static bool enableEvent(jvmtiEvent event) {</span>
327 
328     if (nsk_jvmti_isOptionalEvent(event)
329             &amp;&amp; (event != JVMTI_EVENT_OBJECT_FREE)) {
330         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
331                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
332             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
333                 TranslateEvent(event));
<span class="line-modified">334             return false;</span>
335         }
336     } else {
337         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
338             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
339                 TranslateEvent(event));
<span class="line-modified">340             return false;</span>
341         }
342     }
343 
<span class="line-modified">344     return true;</span>
345 }
346 
347 /**
348  * Enable or disable tested events.
349  */
<span class="line-modified">350 static bool enableEventList() {</span>
351 
352     int i, result;
353 
354     result = enableEvent(JVMTI_EVENT_VM_INIT);
355 
356     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
357 
358     /* enabling optional events */
359     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
360         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
361 
362         if (nsk_jvmti_isOptionalEvent(event))
363             result = result &amp;&amp; enableEvent(event);
364     }
365 
<span class="line-modified">366     if (!result) {</span>
367         nsk_jvmti_setFailStatus();
<span class="line-modified">368         return false;</span>
369     }
370 
<span class="line-modified">371     return true;</span>
372 }
373 
374 /* ============================================================================= */
375 
<span class="line-modified">376 static bool setCallBacks(int step) {</span>

377 
378     int i;
379 
380     jvmtiEventCallbacks eventCallbacks;
381     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
382 
383     switch (step) {
384         case 1:
385             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
386                 eventCount[i] = 0;
387             }
388 
389             eventCallbacks.VMInit                    = cbVMInit;
390             eventCallbacks.Exception                 = cbException;
391             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
392             eventCallbacks.SingleStep                = cbSingleStep;
393             eventCallbacks.FramePop                  = cbFramePop;
394             eventCallbacks.Breakpoint                = cbBreakpoint;
395             eventCallbacks.FieldAccess               = cbFieldAccess;
396             eventCallbacks.FieldModification         = cbFieldModification;
</pre>
<hr />
<pre>
410             break;
411 
412         case 2:
413             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
414                 newEventCount[i] = 0;
415             }
416 
417             eventCallbacks.ObjectFree                = cbNewObjectFree;
418             break;
419 
420         case 3:
421             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
422                 newEventCount[i] = 0;
423             }
424 
425             eventCallbacks.VMDeath                   = cbVMDeath;
426             break;
427 
428     }
429     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">430         return false;</span>
431 
<span class="line-modified">432     return true;</span>
433 }
434 
435 /* ============================================================================= */
436 
437 /** Agent algorithm. */
438 static void JNICALL
439 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
440 
441     int i;
442 
443     for (i = 1; i &lt;= STEP_NUMBER; i++) {
444 
445         if (!nsk_jvmti_waitForSync(timeout))
446             return;
447 
448         NSK_DISPLAY0(&quot;Check received events\n&quot;);
449 
450         if (i &lt; STEP_NUMBER) {
451             showEventStatistics(i);
452             if (!checkEvents(i))
</pre>
</td>
</tr>
</table>
<center><a href="../em02t005/em02t005.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../em02t007/em02t007.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
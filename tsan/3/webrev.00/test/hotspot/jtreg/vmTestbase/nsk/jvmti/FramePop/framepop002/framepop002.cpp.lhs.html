<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/FramePop/framepop002/framepop002.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdio.h&gt;
 25 #include &lt;stdlib.h&gt;
 26 #include &lt;string.h&gt;
 27 #include &quot;jvmti.h&quot;
 28 #include &quot;agent_common.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 #include &quot;jvmti_tools.h&quot;
 31 
 32 extern &quot;C&quot; {
 33 
 34 
 35 #define PASSED 0
 36 #define STATUS_FAILED 2
 37 #define MAX_THREADS 32
 38 
 39 typedef struct item *item_t;
 40 struct item {
 41     item_t next;
 42     jmethodID method;
 43     int depth;
 44 } item;
 45 
 46 typedef struct thr {
 47     jthread thread;
 48     item_t tos;
 49 } thr;
 50 
 51 static jvmtiEnv *jvmti = NULL;
 52 static jvmtiCapabilities caps;
 53 static jvmtiEventCallbacks callbacks;
 54 static jrawMonitorID event_lock;
 55 static jint result = PASSED;
 56 static jboolean printdump = JNI_FALSE;
 57 static jboolean watch_events = JNI_FALSE;
 58 
 59 static int pop_count = 0;
 60 static int push_count = 0;
 61 static int thr_count = 0;
 62 static int max_depth = 0;
 63 static thr threads[MAX_THREADS];
 64 
<a name="2" id="anc2"></a>


 65 static
 66 int isTestThread(jvmtiEnv *jvmti_env, jthread thr) {
 67     jvmtiError err;
 68     jvmtiThreadInfo inf;
 69     const char* TEST_THREAD_NAME_BASE = &quot;Test Thread&quot;;
 70 
 71     err = jvmti_env-&gt;GetThreadInfo(thr, &amp;inf);
 72     if (err != JVMTI_ERROR_NONE) {
 73          printf(&quot;(GetThreadInfo) unexpected error: %s (%d)\n&quot;, TranslateError(err), err);
 74          result = STATUS_FAILED;
 75          return 0;
 76     }
 77     return strncmp(inf.name, TEST_THREAD_NAME_BASE, strlen(TEST_THREAD_NAME_BASE)) == 0;
 78 }
 79 
 80 static
 81 void printInfo(jvmtiEnv *jvmti_env, jthread thr, jmethodID method, int depth) {
 82     jvmtiError err;
 83     jvmtiThreadInfo inf;
 84     char *clsig, *name, *sig, *generic;
 85     jclass cls;
 86 
 87     err = jvmti_env-&gt;GetThreadInfo(thr, &amp;inf);
 88     if (err != JVMTI_ERROR_NONE) {
 89         printf(&quot;(GetThreadInfo) unexpected error: %s (%d)\n&quot;,
 90                TranslateError(err), err);
 91         result = STATUS_FAILED;
 92     }
 93 
 94     err = jvmti_env-&gt;GetMethodDeclaringClass(method, &amp;cls);
 95     if (err != JVMTI_ERROR_NONE) {
 96         printf(&quot;(GetMethodDeclaringClass) unexpected error: %s (%d)\n&quot;,
 97                TranslateError(err), err);
 98         result = STATUS_FAILED;
 99     }
100 
101     err = jvmti_env-&gt;GetClassSignature(cls, &amp;clsig, &amp;generic);
102     if (err != JVMTI_ERROR_NONE) {
103         printf(&quot;(GetClassSignature) unexpected error: %s (%d)\n&quot;,
104                TranslateError(err), err);
105         result = STATUS_FAILED;
106     }
107 
108     err = jvmti_env-&gt;GetMethodName(method, &amp;name, &amp;sig, &amp;generic);
109     if (err != JVMTI_ERROR_NONE) {
110         printf(&quot;(GetMethodName) unexpected error: %s (%d)\n&quot;,
111                TranslateError(err), err);
112         result = STATUS_FAILED;
113     }
114 
115     printf(&quot;  %s: %s.%s%s, depth = %d\n&quot;, inf.name, clsig, name, sig, depth);
116 
117     jvmti_env-&gt;Deallocate((unsigned char *)sig);
118     jvmti_env-&gt;Deallocate((unsigned char *)name);
119     jvmti_env-&gt;Deallocate((unsigned char *)clsig);
120     jvmti_env-&gt;Deallocate((unsigned char *)inf.name);
121 }
122 
123 static
124 void pop(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr, jmethodID method, int depth) {
125     item_t old;
126     int i, count = 0;
127 
128     for (i = 0; i &lt; thr_count; i++) {
129         if (env-&gt;IsSameObject(threads[i].thread, thr)) {
130             break;
131         }
132     }
133 
134     if (i == thr_count) {
135         watch_events = JNI_FALSE;
136         printf(&quot;Unknown thread:\n&quot;);
137         printInfo(jvmti_env, thr, method, depth);
138         result = STATUS_FAILED;
139         return;
140     }
141 
142     if (threads[i].tos == NULL) {
143         watch_events = JNI_FALSE;
144         printf(&quot;Stack underflow:\n&quot;);
145         printInfo(jvmti_env, thr, method, depth);
146         result = STATUS_FAILED;
147         return;
148     }
149 
150     do {
151         pop_count++;
152         old = threads[i].tos;
153         threads[i].tos = threads[i].tos-&gt;next;
154         if (old-&gt;method == method &amp;&amp; old-&gt;depth == depth) {
155             free(old);
156             return;
157         }
158         free(old);
159     } while (threads[i].tos != NULL);
160 
161     watch_events = JNI_FALSE;
162     printf(&quot;Frame pop does not match any entry:\n&quot;);
163     printInfo(jvmti_env, thr, method, depth);
164     result = STATUS_FAILED;
165 }
166 
167 static
168 void push(JNIEnv *env, jthread thr, jmethodID method, int depth) {
169     item_t new_item;
170     int i;
171 
172     for (i = 0; i &lt; thr_count; i++) {
173         if (env-&gt;IsSameObject(threads[i].thread, thr)) {
174             break;
175         }
176     }
177 
178     if (i == thr_count) {
179         thr_count++;
180         if (thr_count == MAX_THREADS) {
181             watch_events = JNI_FALSE;
182             printf(&quot;Out of threads\n&quot;);
183             result = STATUS_FAILED;
184             return;
185         }
186         threads[i].thread = env-&gt;NewGlobalRef(thr);
187         threads[i].tos = NULL;
188     }
189 
190     new_item = (item_t)malloc(sizeof(item));
191     if (new_item == NULL) {
192         watch_events = JNI_FALSE;
193         printf(&quot;Out of memory\n&quot;);
194         result = STATUS_FAILED;
195         return;
196     }
197 
198     new_item-&gt;next = threads[i].tos;
199     new_item-&gt;method = method;
200     new_item-&gt;depth = depth;
201     threads[i].tos = new_item;
202     push_count++;
203     max_depth = (max_depth &lt; depth) ? depth : max_depth;
204 }
205 
206 void JNICALL MethodEntry(jvmtiEnv *jvmti_env, JNIEnv *env,
207         jthread thr, jmethodID method) {
208     jvmtiError err;
209     jboolean isNative;
210     jint frameCount;
211 
212     if (watch_events == JNI_FALSE) return;
213 
<a name="3" id="anc3"></a>






214     err = jvmti_env-&gt;GetFrameCount(thr, &amp;frameCount);
215     if (err != JVMTI_ERROR_NONE) {
216         printf(&quot;(GetFrameCount#entry) unexpected error: %s (%d)\n&quot;,
217                TranslateError(err), err);
218         printInfo(jvmti_env, thr, method, frameCount);
219         result = STATUS_FAILED;
<a name="4" id="anc4"></a>
220         return;
221     }
222 
223     err = jvmti_env-&gt;IsMethodNative(method, &amp;isNative);
224     if (err != JVMTI_ERROR_NONE) {
225         printf(&quot;(IsMethodNative) unexpected error: %s (%d)\n&quot;,
226                TranslateError(err), err);
227         printInfo(jvmti_env, thr, method, frameCount);
228         result = STATUS_FAILED;
229     }
230 
231     if (isTestThread(jvmti_env, thr)) {
232         if (printdump == JNI_TRUE) {
233             printf(&quot;&gt;&gt;&gt; %sMethod entry\n&gt;&gt;&gt;&quot;,
234                    (isNative == JNI_TRUE) ? &quot;Native &quot; : &quot;&quot;);
235             printInfo(jvmti_env, thr, method, frameCount);
236         }
237         if (isNative == JNI_FALSE) {
238             err = jvmti_env-&gt;RawMonitorEnter(event_lock);
239             if (err != JVMTI_ERROR_NONE) {
240                 printf(&quot;(RawMonitorEnter) unexpected error: %s (%d)\n&quot;,
241                        TranslateError(err), err);
242                 printInfo(jvmti_env, thr, method, frameCount);
243                 result = STATUS_FAILED;
244             }
245             push((JNIEnv *)env, thr, method, frameCount);
246             err = jvmti_env-&gt;RawMonitorExit(event_lock);
247             if (err != JVMTI_ERROR_NONE) {
248                 printf(&quot;(RawMonitorExit) unexpected error: %s (%d)\n&quot;,
249                        TranslateError(err), err);
250                 printInfo(jvmti_env, thr, method, frameCount);
251                 result = STATUS_FAILED;
252             }
253             err = jvmti_env-&gt;NotifyFramePop(thr, 0);
254             if (err != JVMTI_ERROR_NONE) {
255                 printf(&quot;(NotifyFramePop) unexpected error: %s (%d)\n&quot;,
256                        TranslateError(err), err);
257                 printInfo(jvmti_env, thr, method, frameCount);
258                 result = STATUS_FAILED;
259             }
260         }
261     }
<a name="5" id="anc5"></a>


















262 }
263 
264 void JNICALL FramePop(jvmtiEnv *jvmti_env, JNIEnv *env,
265         jthread thr, jmethodID method, jboolean wasPopedByException) {
266     jvmtiError err;
267     jint frameCount;
268 
<a name="6" id="anc6"></a>





269     err = jvmti_env-&gt;GetFrameCount(thr, &amp;frameCount);
270     if (err != JVMTI_ERROR_NONE) {
271         printf(&quot;(GetFrameCount#entry) unexpected error: %s (%d)\n&quot;,
272                TranslateError(err), err);
273         printInfo(jvmti_env, thr, method, frameCount);
274         result = STATUS_FAILED;
<a name="7" id="anc7"></a>
275         return;
276     }
277 
278     if (isTestThread(jvmti_env, thr)) {
279         if (printdump == JNI_TRUE) {
280             printf(&quot;&gt;&gt;&gt; Frame Pop\n&gt;&gt;&gt;&quot;);
281             printInfo(jvmti_env, thr, method, frameCount);
282         }
283         err = jvmti_env-&gt;RawMonitorEnter(event_lock);
284         if (err != JVMTI_ERROR_NONE) {
285             printf(&quot;(RawMonitorEnter) unexpected error: %s (%d)\n&quot;,
286                    TranslateError(err), err);
287             printInfo(jvmti_env, thr, method, frameCount);
288             result = STATUS_FAILED;
289         }
290         pop(jvmti_env, (JNIEnv *)env, thr, method, frameCount);
291         err = jvmti_env-&gt;RawMonitorExit(event_lock);
292         if (err != JVMTI_ERROR_NONE) {
293             printf(&quot;(RawMonitorExit) unexpected error: %s (%d)\n&quot;,
294                    TranslateError(err), err);
295             printInfo(jvmti_env, thr, method, frameCount);
296             result = STATUS_FAILED;
297         }
298     }
<a name="8" id="anc8"></a>

299 }
300 
301 #ifdef STATIC_BUILD
302 JNIEXPORT jint JNICALL Agent_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {
303     return Agent_Initialize(jvm, options, reserved);
304 }
305 JNIEXPORT jint JNICALL Agent_OnAttach_framepop002(JavaVM *jvm, char *options, void *reserved) {
306     return Agent_Initialize(jvm, options, reserved);
307 }
308 JNIEXPORT jint JNI_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {
309     return JNI_VERSION_1_8;
310 }
311 #endif
312 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
313     jvmtiError err;
314     jint res;
315 
316     if (options != NULL &amp;&amp; strcmp(options, &quot;printdump&quot;) == 0) {
317         printdump = JNI_TRUE;
318     }
319 
320     res = jvm-&gt;GetEnv((void **) &amp;jvmti, JVMTI_VERSION_1_1);
321     if (res != JNI_OK || jvmti == NULL) {
322         printf(&quot;Wrong result of a valid call to GetEnv!\n&quot;);
323         return JNI_ERR;
324     }
325 
326     err = jvmti-&gt;CreateRawMonitor(&quot;_event_lock&quot;, &amp;event_lock);
327     if (err != JVMTI_ERROR_NONE) {
328         printf(&quot;(CreateRawMonitor) unexpected error: %s (%d)\n&quot;,
329                TranslateError(err), err);
330         return JNI_ERR;
331     }
332 
333     err = jvmti-&gt;GetPotentialCapabilities(&amp;caps);
334     if (err != JVMTI_ERROR_NONE) {
335         printf(&quot;(GetPotentialCapabilities) unexpected error: %s (%d)\n&quot;,
336                TranslateError(err), err);
337         return JNI_ERR;
338     }
339 
340     err = jvmti-&gt;AddCapabilities(&amp;caps);
341     if (err != JVMTI_ERROR_NONE) {
342         printf(&quot;(AddCapabilities) unexpected error: %s (%d)\n&quot;,
343                TranslateError(err), err);
344         return JNI_ERR;
345     }
346 
347     err = jvmti-&gt;GetCapabilities(&amp;caps);
348     if (err != JVMTI_ERROR_NONE) {
349         printf(&quot;(GetCapabilities) unexpected error: %s (%d)\n&quot;,
350                TranslateError(err), err);
351         return JNI_ERR;
352     }
353 
354     if (caps.can_generate_frame_pop_events &amp;&amp;
355             caps.can_generate_method_entry_events) {
356         callbacks.MethodEntry = &amp;MethodEntry;
357         callbacks.FramePop = &amp;FramePop;
<a name="9" id="anc9"></a>


358         err = jvmti-&gt;SetEventCallbacks(&amp;callbacks, sizeof(callbacks));
359         if (err != JVMTI_ERROR_NONE) {
360             printf(&quot;(SetEventCallbacks) unexpected error: %s (%d)\n&quot;,
361                    TranslateError(err), err);
362             return JNI_ERR;
363         }
<a name="10" id="anc10"></a>








364     } else {
365         printf(&quot;Warning: FramePop or MethodEntry event is not implemented\n&quot;);
366     }
367 
368     return JNI_OK;
369 }
370 
371 JNIEXPORT void JNICALL Java_nsk_jvmti_FramePop_framepop002_getReady(JNIEnv *env, jclass cls) {
372     jvmtiError err;
373 
374     if (!caps.can_generate_frame_pop_events ||
375             !caps.can_generate_method_entry_events) {
376         return ;
377     }
378 
379     err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE,
380          JVMTI_EVENT_METHOD_ENTRY, NULL);
381     if (err != JVMTI_ERROR_NONE) {
382         printf(&quot;Failed to enable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\n&quot;,
383                TranslateError(err), err);
384         result = STATUS_FAILED;
385     }
386     err = jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE,
387          JVMTI_EVENT_FRAME_POP, NULL);
388     if (err != JVMTI_ERROR_NONE) {
389         printf(&quot;Failed to enable JVMTI_EVENT_FRAME_POP event: %s (%d)\n&quot;,
390                TranslateError(err), err);
391         result = STATUS_FAILED;
392     }
393     watch_events = JNI_TRUE;
394 }
395 
396 JNIEXPORT jint JNICALL Java_nsk_jvmti_FramePop_framepop002_check(JNIEnv *env, jclass cls) {
397     jvmtiError err;
398 
399     watch_events = JNI_FALSE;
400     err = jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE,
401          JVMTI_EVENT_FRAME_POP, NULL);
402     if (err != JVMTI_ERROR_NONE) {
403         printf(&quot;Failed to disable JVMTI_EVENT_FRAME_POP event: %s (%d)\n&quot;,
404                TranslateError(err), err);
405         result = STATUS_FAILED;
406     }
407     err = jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE,
408          JVMTI_EVENT_METHOD_ENTRY, NULL);
409     if (err != JVMTI_ERROR_NONE) {
410         printf(&quot;Failed to disable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\n&quot;,
411                TranslateError(err), err);
412         result = STATUS_FAILED;
413     }
414 
415     if (printdump == JNI_TRUE) {
416         printf(&quot;%d threads, %d method entrys, %d frame pops, max depth = %d\n&quot;,
417                thr_count, push_count, pop_count, max_depth);
418     }
419 
420     return result;
421 }
422 
423 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
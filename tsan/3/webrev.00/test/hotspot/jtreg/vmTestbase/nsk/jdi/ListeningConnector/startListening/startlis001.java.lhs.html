<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jdi/ListeningConnector/startListening/startlis001.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.ListeningConnector.startListening;
 25 
 26 import com.sun.jdi.Bootstrap;
 27 import com.sun.jdi.connect.*;
 28 import com.sun.jdi.VirtualMachine;
 29 
 30 import java.io.*;
 31 
 32 import java.net.InetAddress;
 33 import java.net.UnknownHostException;
 34 
<a name="2" id="anc2"></a>
 35 import java.util.Iterator;
<a name="3" id="anc3"></a>
 36 import java.util.List;
 37 import java.util.Map;
<a name="4" id="anc4"></a>
 38 
 39 import nsk.share.*;
 40 import nsk.share.jpda.*;
 41 import nsk.share.jdi.*;
 42 
 43 
 44 /**
 45  * The test exercises JDI function &lt;code&gt;ListeningConnector.startListening&lt;/code&gt;.
 46  * The &lt;b&gt;Socket Listening Connector&lt;/b&gt; is using as listening
 47  * connector.&lt;br&gt;
 48  * The test cases include:
 49  * &lt;li&gt; checking that listening address returned by
 50  * &lt;code&gt;ListeningConnector.startListening()&lt;/code&gt; matches the address
 51  * which was set via connector&#39;s arguments;
 52  * &lt;li&gt; checking that address generated by
 53  * &lt;code&gt;ListeningConnector.startListening()&lt;/code&gt; is valid i.e.
 54  * debugee VM is accessible via this address.
 55  */
 56 public class startlis001 {
 57     static final int PASSED = 0;
 58     static final int FAILED = 2;
 59     static final int JCK_STATUS_BASE = 95;
 60     static final String CONNECTOR_NAME =
 61         &quot;com.sun.jdi.SocketListen&quot;;
 62     static final String DEBUGEE_CLASS =
 63         &quot;nsk.jdi.ListeningConnector.startListening.startlis001t&quot;;
 64 
 65     private Log log;
 66 
 67     private VirtualMachine vm;
 68     private ListeningConnector connector;
 69     private Map&lt;java.lang.String,? extends com.sun.jdi.connect.Connector.Argument&gt; connArgs;
 70     private PrintStream out;
 71 
 72     IORedirector outRedirector;
 73     IORedirector errRedirector;
 74 
 75     boolean totalRes = true;
 76 
 77     public static void main (String argv[]) {
 78         System.exit(run(argv,System.out) + JCK_STATUS_BASE);
 79     }
 80 
 81     public static int run(String argv[], PrintStream out) {
 82         return new startlis001().runIt(argv, out);
 83     }
 84 
 85     private int runIt(String argv[], PrintStream out) {
 86         String port;
 87         String addr;
<a name="5" id="anc5"></a><span class="line-removed"> 88         InetAddress inetAddr = null;</span>
 89         ArgumentHandler argHandler = new ArgumentHandler(argv);
 90 
 91 // pass if CONNECTOR_NAME is not implemented
 92 // on this platform
 93         if (argHandler.shouldPass(CONNECTOR_NAME))
 94             return PASSED;
 95         this.out = out;
 96         log = new Log(out, argHandler);
 97 
 98         long timeout = argHandler.getWaitTime() * 60 * 1000;
 99 
<a name="6" id="anc6"></a><span class="line-modified">100 /* Check that listening address returned by ListeningConnector.startListening()</span>
<span class="line-modified">101    matches the address which was set via connector&#39;s arguments */</span>





102         try {
<a name="7" id="anc7"></a><span class="line-modified">103             inetAddr = InetAddress.getLocalHost();</span>

104         } catch (UnknownHostException e) {
105             log.complain(&quot;FAILURE: caught UnknownHostException &quot; +
<a name="8" id="anc8"></a><span class="line-modified">106                 e.getMessage());</span>
107             totalRes = false;
108         }
<a name="9" id="anc9"></a><span class="line-modified">109         String hostname = inetAddr.getHostName();</span>
<span class="line-removed">110         String ip = inetAddr.getHostAddress();</span>
111         port = argHandler.getTransportPortIfNotDynamic();
112 
113         initConnector(port);
114         if ((addr = startListen()) == null) {
115             log.complain(&quot;Test case #1 FAILED: unable to start listening&quot;);
116             totalRes = false;
<a name="10" id="anc10"></a><span class="line-modified">117         }</span>
<span class="line-modified">118         else {</span>


119             log.display(&quot;Test case #1: start listening the address &quot; + addr);
<a name="11" id="anc11"></a><span class="line-modified">120             log.display(&quot;Expected address: &quot;+ hostname + &quot;:&quot; + port +</span>
<span class="line-modified">121                 &quot;\n\tor &quot;+ ip + &quot;:&quot; + port);</span>
<span class="line-modified">122             if ( (!addr.startsWith(hostname) &amp;&amp; !addr.startsWith(ip)) ||</span>
<span class="line-modified">123                  (port != null &amp;&amp; !addr.endsWith(port)) ) {</span>

124                 log.complain(&quot;Test case #1 FAILED: listening address &quot; + addr +
<a name="12" id="anc12"></a><span class="line-modified">125                     &quot;\ndoes not match expected address:\n&quot; +</span>
<span class="line-removed">126                     hostname + &quot;:&quot; + port + &quot; or &quot; +</span>
<span class="line-removed">127                     ip + &quot;:&quot; + port);</span>
128                 totalRes = false;
129             }
130             if (!stopListen()) {
131                 log.complain(&quot;TEST: unable to stop listening #1&quot;);
132                 totalRes = false;
133             }
134             else
135                log.display(&quot;Test case #1 PASSED: listening address matches expected address&quot;);
136         }
137 
<a name="13" id="anc13"></a><span class="line-modified">138 /* Check that an address generated by ListeningConnector.startListening()</span>
<span class="line-modified">139    is valid i.e. debugee VM is accessible via this address */</span>
140         initConnector(null);
141         if ((addr = startListen()) == null) {
142             log.complain(&quot;Test case #2 FAILED: unable to start listening&quot;);
143             return FAILED;
144         }
145         else
146             log.display(&quot;Test case #2: start listening the address &quot; + addr);
147 
148         String java = argHandler.getLaunchExecPath()
149                           + &quot; &quot; + argHandler.getLaunchOptions();
150 
151         String cmd = java +
152             &quot; -Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=n,address=&quot; +
153             addr + &quot; &quot; + DEBUGEE_CLASS;
154 
155         Binder binder = new Binder(argHandler, log);
156         Debugee debugee = null;
157 
158         log.display(&quot;command: &quot; + cmd);
159         try {
160             debugee = binder.startLocalDebugee(cmd);
161             debugee.redirectOutput(log);
162         } catch (Exception e) {
163             stopListen();
164             throw new Failure(e);
165         }
166 
167         if ((vm = attachTarget()) == null) {
168             log.complain(&quot;Test case #2 FAILED: unable to attach the debugee VM&quot;);
169             debugee.close();
170             stopListen();
171             return FAILED;
172         }
173         else
174             log.display(&quot;Test case #2 PASSED: successfully attach the debugee VM&quot;);
175 
176         if (!stopListen()) {
177             log.complain(&quot;TEST: unable to stop listening #2&quot;);
178             debugee.close();
179             return FAILED;
180         }
181 
182         debugee.setupVM(vm);
183         debugee.waitForVMInit(timeout);
184 
185         log.display(&quot;\nResuming debugee VM&quot;);
186         debugee.resume();
187 
188         log.display(&quot;\nWaiting for debugee VM exit&quot;);
189         int code = debugee.waitFor();
190         if (code != (JCK_STATUS_BASE+PASSED)) {
191             log.complain(&quot;Debugee VM has crashed: exit code=&quot; +
192                 code);
193             return FAILED;
194         }
195         log.display(&quot;Debugee VM: exit code=&quot; + code);
196 
197         if (totalRes) return PASSED;
198         else return FAILED;
199     }
200 
201     private VirtualMachine attachTarget() {
202         try {
203             return connector.accept(connArgs);
204         } catch (IOException e) {
205             log.complain(&quot;FAILURE: caught IOException: &quot; +
206                 e.getMessage());
207             e.printStackTrace(out);
208             return null;
209         } catch (IllegalConnectorArgumentsException e) {
210             log.complain(&quot;FAILURE: Illegal connector arguments: &quot; +
211                 e.getMessage());
212             e.printStackTrace(out);
213             return null;
214         } catch (Exception e) {
215             log.complain(&quot;FAILURE: Exception: &quot; +
216                 e.getMessage());
217             e.printStackTrace(out);
218             return null;
219         }
220     }
221 
222     private void initConnector(String port) {
223         Connector.Argument arg;
224 
225         connector = (ListeningConnector)
226             findConnector(CONNECTOR_NAME);
227 
228         connArgs = connector.defaultArguments();
229         Iterator cArgsValIter = connArgs.keySet().iterator();
230         while (cArgsValIter.hasNext()) {
231             String argKey = (String) cArgsValIter.next();
232             String argVal = null;
233 
234             if ((arg = (Connector.Argument) connArgs.get(argKey)) == null) {
235                 log.complain(&quot;Argument &quot; + argKey.toString() +
236                     &quot;is not defined for the connector: &quot; +
237                     connector.name());
238             }
239             if (arg.name().equals(&quot;port&quot;) &amp;&amp; port != null)
240                 arg.setValue(port);
241 
242             log.display(&quot;\targument name=&quot; + arg.name());
243             if ((argVal = arg.value()) != null)
244                 log.display(&quot;\t\tvalue=&quot; + argVal);
245             else log.display(&quot;\t\tvalue=NULL&quot;);
246         }
247     }
248 
249     private String startListen() {
250         try {
251             return connector.startListening(connArgs);
252         } catch (IOException e) {
253             log.complain(&quot;FAILURE: caught IOException: &quot; +
254                 e.getMessage());
255             e.printStackTrace(out);
256             return null;
257         } catch (IllegalConnectorArgumentsException e) {
258             log.complain(&quot;FAILURE: Illegal connector arguments: &quot; +
259                 e.getMessage());
260             e.printStackTrace(out);
261             return null;
262         } catch (Exception e) {
263             log.complain(&quot;FAILURE: Exception: &quot; + e.getMessage());
264             e.printStackTrace(out);
265             return null;
266         }
267     }
268 
269     private boolean stopListen() {
270         try {
271             connector.stopListening(connArgs);
272         } catch (IOException e) {
273             log.complain(&quot;FAILURE: caught IOException: &quot; +
274                 e.getMessage());
275             e.printStackTrace(out);
276             return false;
277         } catch (IllegalConnectorArgumentsException e) {
278             log.complain(&quot;FAILURE: Illegal connector arguments: &quot; +
279                 e.getMessage());
280             e.printStackTrace(out);
281             return false;
282         } catch (Exception e) {
283             log.complain(&quot;FAILURE: Exception: &quot; + e.getMessage());
284             e.printStackTrace(out);
285             return false;
286         }
287 
288         return true;
289     }
290 
291     private Connector findConnector(String connectorName) {
292         List connectors = Bootstrap.virtualMachineManager().allConnectors();
293         Iterator iter = connectors.iterator();
294 
295         while (iter.hasNext()) {
296             Connector connector = (Connector) iter.next();
297             if (connector.name().equals(connectorName)) {
298                 log.display(&quot;Connector name=&quot; + connector.name() +
299                     &quot;\n\tdescription=&quot; + connector.description() +
300                     &quot;\n\ttransport=&quot; + connector.transport().name());
301                 return connector;
302             }
303         }
304         throw new Error(&quot;No appropriate connector&quot;);
305     }
306 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
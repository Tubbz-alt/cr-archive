<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/vmTestbase/nsk/jdi/EventIterator/nextEvent/nextevent001.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package nsk.jdi.EventIterator.nextEvent;
 25 
 26 import nsk.share.*;
 27 import nsk.share.jdi.*;
 28 
 29 import com.sun.jdi.*;
 30 import com.sun.jdi.event.*;
 31 import com.sun.jdi.request.*;
 32 
 33 import java.util.*;
 34 import java.io.*;
 35 
 36 /**
 37  * The test for the implementation of an object of the type     &lt;BR&gt;
 38  * EventIterator.                                               &lt;BR&gt;
 39  *                                                              &lt;BR&gt;
 40  * The test checks that results of the method                   &lt;BR&gt;
 41  * &lt;code&gt;com.sun.jdi.EventIterator.nextEvent()&lt;/code&gt;           &lt;BR&gt;
 42  * complies with its spec.                                      &lt;BR&gt;
 43  * &lt;BR&gt;
 44  * For each type of Events except for ClassUnloadEvent,                 &lt;BR&gt;
 45  * the cases to check are as follows:                                   &lt;BR&gt;
 46  * - the method returns Event object if there is an Event to return;    &lt;BR&gt;
 47  * - NoSuchElementException is thrown if no more events to return;      &lt;BR&gt;
 48  * - doesn&#39;t throw other Exceptions.                                    &lt;BR&gt;
 49  * &lt;BR&gt;
 50  * The test has three phases and works as follows.              &lt;BR&gt;
 51  * &lt;BR&gt;
 52  * In first phase,                                                      &lt;BR&gt;
 53  * upon launching debuggee&#39;s VM which will be suspended,                &lt;BR&gt;
 54  * a debugger waits for the VMStartEvent within a predefined            &lt;BR&gt;
 55  * time interval. If no the VMStartEvent received, the test is FAILED.  &lt;BR&gt;
 56  * Upon getting the VMStartEvent, it saves its EventSet into            &lt;BR&gt;
 57  * a special array and makes the request for debuggee&#39;s                 &lt;BR&gt;
 58  * ClassPrepareEvent with SUSPEND_EVENT_THREAD, resumes the VM,         &lt;BR&gt;
 59  * and waits for the event within the predefined time interval.         &lt;BR&gt;
 60  * If no the ClassPrepareEvent received, the test is FAILED.            &lt;BR&gt;
 61  * Upon getting the ClassPrepareEvent,                                  &lt;BR&gt;
 62  * the debugger saves its EventSet into the array and                   &lt;BR&gt;
 63  * sets up the breakpoint with SUSPEND_EVENT_THREAD                     &lt;BR&gt;
 64  * within debuggee&#39;s special methodForCommunication().                  &lt;BR&gt;
 65  * &lt;BR&gt;
 66  * In second phase the debugger and the debuggee perform the following. &lt;BR&gt;
 67  * - The debugger creates ThreadStartRequest and ThreadDeathRequest,    &lt;BR&gt;
 68  *   resumes the debuggee, and                                          &lt;BR&gt;
 69  *   waits for corresponding ThreadStartEvent and ThreadDeathEvent.     &lt;BR&gt;
 70  * - The debuggee creates new thread,  named &quot;thread2&quot;,                 &lt;BR&gt;
 71  *   whose running creates the above events.                            &lt;BR&gt;
 72  * - Upon getting the events, the debugger saves their sets in the array,&lt;BR&gt;
 73  *   resumes the debuggee and waits for the BreakpointEvent.            &lt;BR&gt;
 74  * - The debuggee creates a number of threads, one for each             &lt;BR&gt;
 75  *   following event: AccessWatchpoint, ModificationWatchpoint,         &lt;BR&gt;
 76  *   MethodEntry, MethodExit, Step, Exception, and Breakpoint,          &lt;BR&gt;
 77  *   and invokes the methodForCommunication to be suspended and         &lt;BR&gt;
 78  *   to inform the debugger with the event.                             &lt;BR&gt;
 79  * - Upon getting the BreakpointForCommunication, the debugger          &lt;BR&gt;
 80  *   gets ThreadReferences mirroring all tested threads in the debuggee,&lt;BR&gt;
 81  *   sets up Requests within them to get EventSets to check up on,      &lt;BR&gt;
 82  *   resumes the debuggee, waits for events, and upon getting them,     &lt;BR&gt;
 83  *   saves its EventSets into the array.                                &lt;BR&gt;
 84  * &lt;BR&gt;
 85  * In third phase,at the end                                            &lt;BR&gt;
 86  * the debuggee changes the value of the &quot;instruction&quot;                  &lt;BR&gt;
 87  * to inform the debugger of checks finished, and ends.                 &lt;BR&gt;
 88  * The debugger waits for VMDeathEvent and VMDisconnectEvent, and       &lt;BR&gt;
 89  * upon getting them, saves their EventSets into the array.             &lt;BR&gt;
 90  * Finally, the debugger, using the array of EventSets,                 &lt;BR&gt;
 91  * checks up on their EventIterators.                                   &lt;BR&gt;
 92  * &lt;BR&gt;
 93  * Note. To inform each other of needed actions, the debugger and       &lt;BR&gt;
 94  *       and the debuggee use debuggee&#39;s variable &quot;instruction&quot;.        &lt;BR&gt;
 95  * &lt;BR&gt;
 96  */
 97 
 98 public class nextevent001 {
 99 
100     //----------------------------------------------------- templete section
101     static final int PASSED = 0;
102     static final int FAILED = 2;
103     static final int PASS_BASE = 95;
104 
105     //----------------------------------------------------- templete parameters
106     static final String
107     sHeader1 = &quot;\n==&gt; nsk/jdi/EventIterator/nextEvent/nextevent001 &quot;,
108     sHeader2 = &quot;--&gt; debugger: &quot;,
109     sHeader3 = &quot;##&gt; debugger: &quot;;
110 
111     //----------------------------------------------------- main method
112 
113     public static void main (String argv[]) {
114 
115         int result = run(argv, System.out);
116 
117         System.exit(result + PASS_BASE);
118     }
119 
120     public static int run (String argv[], PrintStream out) {
121 
122         int exitCode = new nextevent001().runThis(argv, out);
123 
124         if (exitCode != PASSED) {
125             System.out.println(&quot;TEST FAILED&quot;);
126         }
127         return testExitCode;
128     }
129 
130     //--------------------------------------------------   log procedures
131 
132     private static Log  logHandler;
133 
134     private static void log1(String message) {
135         logHandler.display(sHeader1 + message);
136     }
137     private static void log2(String message) {
138         logHandler.display(sHeader2 + message);
139     }
140     private static void log3(String message) {
141         logHandler.complain(sHeader3 + message);
142     }
143 
144     //  ************************************************    test parameters
145 
146     private String debuggeeName =
147         &quot;nsk.jdi.EventIterator.nextEvent.nextevent001a&quot;;
148 
149     private String testedClassName =
150       &quot;nsk.jdi.EventIterator.nextEvent.TestClass&quot;;
151 
152     //====================================================== test program
153     //------------------------------------------------------ common section
154 
155     static Debugee          debuggee;
156     static ArgumentHandler  argsHandler;
157 
158     static int waitTime;
159 
160     static VirtualMachine      vm            = null;
161     static EventRequestManager eventRManager = null;
162     static EventQueue          eventQueue    = null;
163     static EventSet            eventSet      = null;
164     static EventIterator       eventIterator = null;
165 
166     static ReferenceType       debuggeeClass = null;
167 
168     static int  testExitCode = PASSED;
169 
170 
171     class JDITestRuntimeException extends RuntimeException {
172         JDITestRuntimeException(String str) {
173             super(&quot;JDITestRuntimeException : &quot; + str);
174         }
175     }
176 
177     //  Event #:
178     //  0-6  : AccessWatchpoint, ModificationWatchpoint, Breakpoint, Exception,
179     //         MethodEntry, MethodExit, Step
180     //  7-8  : ClassPrepare, ClassUnload
181     //  9-10 : ThreadDeath, ThreadStart
182     // 11-13 : VMDeath, VMDisconnect, VMStart
183 
184     EventSet     eventSets[] = new EventSet [14];
185     EventRequest eRequests[] = new EventRequest[14];
186 
187     int eventFlags[] = { 0,0,0,0, 0,0,0,0, 3,0,0,0, 1,1 };
188 
189     //------------------------------------------------------ methods
190 
191     private int runThis (String argv[], PrintStream out) {
192 
193         argsHandler     = new ArgumentHandler(argv);
194         logHandler      = new Log(out, argsHandler);
195         Binder binder   = new Binder(argsHandler, logHandler);
196 
197         waitTime        = argsHandler.getWaitTime() * 60000;
198 
199         try {
200             log2(&quot;launching a debuggee :&quot;);
201             log2(&quot;       &quot; + debuggeeName);
202             if (argsHandler.verbose()) {
203                 debuggee = binder.bindToDebugeeNoWait(debuggeeName + &quot; -vbs&quot;);
204             } else {
205                 debuggee = binder.bindToDebugeeNoWait(debuggeeName);
206             }
207             if (debuggee == null) {
208                 log3(&quot;ERROR: no debuggee launched&quot;);
209                 return FAILED;
210             }
211             log2(&quot;debuggee launched&quot;);
212         } catch ( Exception e ) {
213             log3(&quot;ERROR: Exception : &quot; + e);
214             log2(&quot;       test cancelled&quot;);
215             return FAILED;
216         }
217 
218         debuggee.redirectOutput(logHandler);
219 
220         vm = debuggee.VM();
221 
222         eventQueue = vm.eventQueue();
223         if (eventQueue == null) {
224             log3(&quot;ERROR: eventQueue == null : TEST ABORTED&quot;);
225             vm.exit(PASS_BASE);
226             return FAILED;
227         }
228 
229         log2(&quot;invocation of the method runTest()&quot;);
230         switch (runTest()) {
231 
232             case 0 :  log2(&quot;test phase has finished normally&quot;);
233                       log2(&quot;   waiting for the debuggee to finish ...&quot;);
234                       debuggee.waitFor();
235 
236                       log2(&quot;......getting the debuggee&#39;s exit status&quot;);
237                       int status = debuggee.getStatus();
238                       if (status != PASS_BASE) {
239                           log3(&quot;ERROR: debuggee returned UNEXPECTED exit status: &quot; +
240                               status + &quot; != PASS_BASE&quot;);
241                           testExitCode = FAILED;
242                       } else {
243                           log2(&quot;......debuggee returned expected exit status: &quot; +
244                               status + &quot; == PASS_BASE&quot;);
245                       }
246                       break;
247 
248             default : log3(&quot;ERROR: runTest() returned unexpected value&quot;);
249 
250             case 1 :  log3(&quot;test phase has not finished normally: debuggee is still alive&quot;);
251                       log2(&quot;......forcing: vm.exit();&quot;);
252                       testExitCode = FAILED;
253                       try {
254                           vm.exit(PASS_BASE);
255                       } catch ( Exception e ) {
256                           log3(&quot;ERROR: Exception : e&quot;);
257                       }
258                       break;
259 
260             case 2 :  log3(&quot;test cancelled due to VMDisconnectedException&quot;);
261                       log2(&quot;......trying: vm.process().destroy();&quot;);
262                       testExitCode = FAILED;
263                       try {
264                           Process vmProcess = vm.process();
265                           if (vmProcess != null) {
266                               vmProcess.destroy();
267                           }
268                       } catch ( Exception e ) {
269                           log3(&quot;ERROR: Exception : e&quot;);
270                       }
271                       break;
272             }
273 
274         return testExitCode;
275     }
276 
277 
278    /*
279     * Return value: 0 - normal end of the test
280     *               1 - ubnormal end of the test
281     *               2 - VMDisconnectedException while test phase
282     */
283 
284     private int runTest() {
285 
286         try {
287             log2(&quot;waiting for VMStartEvent&quot;);
288             getEventSet();
289 //
290             eventSets[13] = eventSet;
291             if (eventIterator.nextEvent() instanceof VMStartEvent) {
292                 log2(&quot;VMStartEvent received; test begins&quot;);
293 
294                 testRun();
295 
296                 log2(&quot;waiting for VMDeathEvent&quot;);
297                 getEventSet();
298                 eventSets[11] = eventSet;
299                 if ( !(eventIterator.nextEvent() instanceof VMDeathEvent) ) {
300                     log3(&quot;ERROR: last event is not the VMDeathEvent&quot;);
301                     return 1;
302                 }
303 
304                 log2(&quot;waiting for VMDisconnectEvent&quot;);
305                 getEventSet();
306 //
307                 eventSets[12] = eventSet;
308                 if ( !(eventIterator.nextEvent() instanceof VMDisconnectEvent) ) {
309                     log3(&quot;ERROR: last event is not the VMDisconnectEvent&quot;);
310                     return 1;
311                 }
312 
313                 check();
314                 return 0;
315             } else {
316                 log3(&quot;ERROR: first event is not the VMStartEvent&quot;);
317                 return 1;
318             }
319         } catch ( VMDisconnectedException e ) {
320             log3(&quot;ERROR: VMDisconnectedException : &quot; + e);
321             return 2;
322         } catch ( Exception e ) {
323             log3(&quot;ERROR: Exception : &quot; + e);
324             return 1;
325         }
326 
327     }
328 
329     private void testRun()
330                  throws JDITestRuntimeException, Exception {
331 
332         eventRManager = vm.eventRequestManager();
333 
334         ClassPrepareRequest cpRequest = eventRManager.createClassPrepareRequest();
335         cpRequest.setSuspendPolicy( EventRequest.SUSPEND_EVENT_THREAD);
336         cpRequest.addClassFilter(debuggeeName);
337 
338         log2(&quot;......setting up ClassPrepareRequest&quot;);
339         eRequests[7] = cpRequest;
340 
341         cpRequest.enable();
342         vm.resume();
343 
344         getEventSet();
345         eventSets[7] = eventSet;
346 
347         cpRequest.disable();
348 
349         ClassPrepareEvent event = (ClassPrepareEvent) eventIterator.next();
350         debuggeeClass = event.referenceType();
351 
352         if (!debuggeeClass.name().equals(debuggeeName))
353            throw new JDITestRuntimeException(&quot;** Unexpected ClassName for ClassPrepareEvent **&quot;);
354 
355         log2(&quot;      received: ClassPrepareEvent for debuggeeClass&quot;);
356 
357         log2(&quot;......setting up ClassPrepareEvent&quot;);
358 
359         String bPointMethod = &quot;methodForCommunication&quot;;
360         String lineForComm  = &quot;lineForComm&quot;;
361         BreakpointRequest bpRequest;
362 
363         ThreadReference mainThread = threadByName(&quot;main&quot;);
364 
365         bpRequest = settingBreakpoint(mainThread,
366                                       debuggeeClass,
367                                       bPointMethod, lineForComm, &quot;zero&quot;);
368         bpRequest.enable();
369 
370     //------------------------------------------------------  testing section
371 
372         log1(&quot;     TESTING BEGINS&quot;);
373 
374         {
375             log2(&quot;......setting up ThreadStartRequest&quot;);
376             ThreadStartRequest tsr = eventRManager.createThreadStartRequest();
377             tsr.addCountFilter(1);
378             tsr.setSuspendPolicy(EventRequest.SUSPEND_ALL);
379             tsr.putProperty(&quot;number&quot;, &quot;ThreadStartRequest&quot;);
380             tsr.enable();
381 
382             eRequests[10] = tsr;
383 
384             log2(&quot;......setting up ThreadDeathRequest&quot;);
385             ThreadDeathRequest tdr = eventRManager.createThreadDeathRequest();
386             tdr.addCountFilter(1);
387             tdr.setSuspendPolicy(EventRequest.SUSPEND_ALL);
388             tsr.putProperty(&quot;number&quot;, &quot;ThreadDeathRequest&quot;);
389             tdr.enable();
390 
391             eRequests[9] = tdr;
392 
393             log2(&quot;......vm.resume();&quot;);
394             vm.resume();
395 
396             log2(&quot;......waiting for ThreadStartEvent&quot;);
397             getEventSet();
398             eventSets[10] = eventSet;
399 
400             Event receivedEvent = eventIterator.nextEvent();
401             if ( !(receivedEvent instanceof ThreadStartEvent) ) {
402                 testExitCode = FAILED;
403                 log3(&quot;ERROR: new event is not ThreadStartEvent: &quot; + receivedEvent);
404                 return;
405             }
406             tsr.disable();
407 
408             log2(&quot;......vm.resume();&quot;);
409             vm.resume();
410 
411             log2(&quot;......waiting for ThreadDeathEvent&quot;);
412             getEventSet();
413             eventSets[9] = eventSet;
414             receivedEvent = eventIterator.nextEvent();
415             if ( !(receivedEvent instanceof ThreadDeathEvent) ) {
416                 testExitCode = FAILED;
417                 log3(&quot;ERROR: new event is not ThreadDeathEvent: &quot; + receivedEvent);
418                 return;
419             }
420             tdr.disable();
421         }
422 
423         for (int i = 0; ; i++) {
424 
425             vm.resume();
426             breakpointForCommunication();
427 
428             int instruction = ((IntegerValue)
429                                (debuggeeClass.getValue(debuggeeClass.fieldByName(&quot;instruction&quot;)))).value();
430 
431             if (instruction == 0) {
432                 vm.resume();
433                 break;
434             }
435 
436             log1(&quot;:::::: case: # &quot; + i);
437 
438             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ variable part
439 
440             String bpLineName        = &quot;breakpointLine&quot;;
441             String bpMethodName      = &quot;method&quot;;
442             String awFieldName       = &quot;awFieldName&quot;;
443             String mwFieldName       = &quot;mwFieldName&quot;;
444 
445             String namesArray = &quot;threadNames&quot;;
446 
447             String threadNames[] = {
448                     &quot;awThread&quot;  ,
449                     &quot;mwThread&quot;  ,
450                     &quot;bpThread&quot;  ,
451                     &quot;excThread&quot; ,
452                     &quot;menThread&quot; ,
453                     &quot;mexThread&quot; ,
454                     &quot;stThread&quot;
455                };
456 
457             int flags = 0;
458 
459             ThreadReference eventThreads[] = new ThreadReference[threadNames.length];
460 
461 
462             List allThreads = vm.allThreads();
463 
464             log2(&quot;......getting: ArrayReference namesRef = (ArrayReference) debuggeeClass.getValue(debuggeeClass.fieldByName(namesArray));&quot;);
465             ArrayReference namesRef = (ArrayReference)
466                          debuggeeClass.getValue(debuggeeClass.fieldByName(namesArray));
467             log2(&quot;       namesRef.length() == &quot; + namesRef.length());
468 
469             log2(&quot;......getting and chcking up on debuggee threads&#39; names&quot;);
470             for (int n1 = 0; n1 &lt; namesRef.length(); n1++) {
471 
472                 log2(&quot;      String name = ((StringReference) namesRef.getValue(n1)).value();&quot;);
473                 String name = ((StringReference) namesRef.getValue(n1)).value();
474 
475                 label0: {
476                     for (int n2 = 0; n2 &lt; threadNames.length; n2++) {
477 
478                         if (name.equals(threadNames[n2])) {
479                             ListIterator li  = allThreads.listIterator();
480                             for (; li.hasNext(); ) {
481                                 ThreadReference thread = (ThreadReference) li.next();
482                                 if (thread.name().equals(name)) {
483                                     eventThreads[n1] =  thread;
484                                     break;
485                                 }
486                             }
487                             break label0;
488                         }
489                     }
490                     testExitCode = FAILED;
491                     log3(&quot;ERROR: no thread found in the debuggee : &quot; + name);
492                 }
493             }
494             if (testExitCode == FAILED)
495                 break;
496 
497 
498             log2(&quot;......ReferenceType testClass = (ReferenceType) (vm.classesByName(testedClassName)).get(0);&quot;);
499             ReferenceType testClass = (ReferenceType) (vm.classesByName(testedClassName)).get(0);
500 
501             log2(&quot;......setting up Requests&quot;);
502             for ( int n3 = 0; n3 &lt; namesRef.length(); n3++) {
503                  switch (n3) {
504                       case 0:
505                              if (vm.canWatchFieldAccess()) {
506                                  String awName = ( (StringReference) testClass.getValue(
507                                              testClass.fieldByName(awFieldName))).value();
508                                  eRequests[n3] = settingAccessWatchpoint(eventThreads[n3],
509                                               testClass, awName, threadNames[n3]);
510                                  eRequests[n3].enable();
511                                  flags |= 1;
512                              }
513                              break;
514 
515                       case 1:
516                              if (vm.canWatchFieldModification() ) {
517                                  String mwName = ( (StringReference) testClass.getValue(
518                                              testClass.fieldByName(mwFieldName))).value();
519                                  eRequests[n3] = settingModificationWatchpoint(eventThreads[n3],
520                                               testClass, mwName, threadNames[n3]);
521                                  eRequests[n3].enable();
522                                  flags |= 1&lt;&lt;1;
523                              }
524                              break;
525 
526                       case 2:
527                              eRequests[n3] = settingBreakpoint(eventThreads[n3], testClass,
528                                                bpMethodName, bpLineName, threadNames[n3]);
529                              eRequests[n3].setSuspendPolicy( EventRequest.SUSPEND_NONE);
530                              eRequests[n3].enable();
531                              flags |= 1&lt;&lt;2;
532                              break;
533 
534                       case 3:
535                              eRequests[n3] = settingException(eventThreads[n3], debuggeeClass, //testClass,
536                                                                 threadNames[n3]);
537                              eRequests[n3].enable();
538                              flags |= 1&lt;&lt;3;
539                              break;
540 
541                       case 4:
542                              eRequests[n3] = settingMethodEntry(eventThreads[n3], testClass,
543                                                                 threadNames[n3]);
544                              eRequests[n3].enable();
545                              flags |= 1&lt;&lt;4;
546                              break;
547 
548                       case 5:
549                              eRequests[n3] = settingMethodExit(eventThreads[n3], testClass,
550                                                                 threadNames[n3]);
551                              eRequests[n3].enable();
552                              flags |= 1&lt;&lt;5;
553                              break;
554 
555                       case 6:
556                              eRequests[n3] = settingStep(eventThreads[n3], threadNames[n3]);
557                              eRequests[n3].enable();
558                              flags |= 1&lt;&lt;6;
559                              break;
560 
561                       default:
562                              throw new JDITestRuntimeException(&quot;** default case while prepareing requests**&quot;);
563                 }
564             }
565 
566             log2(&quot;:::::::::vm.resume();&quot;);
567             vm.resume();
568 
569             Event  event1     = null;
570             int    flagsCopy  = flags;
571             String eName      = null;
572             int    index      = 0;
573 
574             log2(&quot;......getting and checking up on Events&quot;);
575             for (int n4 = 0; n4 &lt; namesRef.length(); n4++) {
576                 int flag;
577 
578                 getEventSet();
579                 event1 = eventIterator.nextEvent();
580 
581                 if (event1 instanceof AccessWatchpointEvent) {
582                     index = 0;
583                 } else if (event1 instanceof ModificationWatchpointEvent ) {
584                     index = 1;
585                 } else if (event1 instanceof BreakpointEvent ) {
586                     index = 2;
587                 } else if (event1 instanceof ExceptionEvent ) {
588                     index = 3;
589                 } else if (event1 instanceof MethodEntryEvent ) {
590                     index = 4;
591                 } else if (event1 instanceof MethodExitEvent ) {
592                     index = 5;
593                 } else if (event1 instanceof StepEvent ) {
594                     index = 6;
595                 } else {
596                     log3(&quot;ERROR: else clause in detecting type of event1&quot;);
597                     testExitCode = FAILED;
598                 }
599 
600                 flag = 1 &lt;&lt; index;
601                 if ((flagsCopy &amp; flag) == 0) {
602                     log3(&quot;ERROR: event duplication: &quot; + eName);
603                     testExitCode = FAILED;
604                 } else {
605                     flagsCopy ^= flag;
606                     flags |= flag;
607                 }
608 
609                 eventSets[index] = eventSet;
610             }
611 
612             if (testExitCode == FAILED)
613                 break;
614 
615             breakpointForCommunication();
616 
617             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
618         }
619         log1(&quot;    TESTING ENDS&quot;);
620         return;
621     }
622 
623     private ThreadReference threadByName(String name)
624                  throws JDITestRuntimeException {
625 
626         List         all = vm.allThreads();
627         ListIterator li  = all.listIterator();
628 
629         for (; li.hasNext(); ) {
630             ThreadReference thread = (ThreadReference) li.next();
631             if (thread.name().equals(name))
632                 return thread;
633         }
634         throw new JDITestRuntimeException(&quot;** Thread IS NOT found ** : &quot; + name);
635     }
636 
637    /*
638     * private BreakpointRequest settingBreakpoint(ThreadReference, ReferenceType,
639     *                                             String, String, String)
640     *
641     * It sets up a breakpoint at given line number within a given method in a given class
642     * for a given thread.
643     *
644     * Return value: BreakpointRequest object  in case of success
645     *
646     * JDITestRuntimeException   in case of an Exception thrown within the method
647     */
648 
649     private BreakpointRequest settingBreakpoint ( ThreadReference thread,
650                                                   ReferenceType testedClass,
651                                                   String methodName,
652                                                   String bpLine,
653                                                   String property)
654             throws JDITestRuntimeException {
655 
656         log2(&quot;......setting up a breakpoint:&quot;);
657         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
658                         &quot;; method: &quot; + methodName + &quot;; line: &quot; + bpLine);
659 
660         List              alllineLocations = null;
661         Location          lineLocation     = null;
662         BreakpointRequest breakpRequest    = null;
663 
664         try {
665             Method  method  = (Method) testedClass.methodsByName(methodName).get(0);
666 
667             alllineLocations = method.allLineLocations();
668 
669             int n =
670                 ( (IntegerValue) testedClass.getValue(testedClass.fieldByName(bpLine) ) ).value();
671             if (n &gt; alllineLocations.size()) {
672                 log3(&quot;ERROR:  TEST_ERROR_IN_settingBreakpoint(): number is out of bound of method&#39;s lines&quot;);
673             } else {
674                 lineLocation = (Location) alllineLocations.get(n);
675                 try {
676                     breakpRequest = eventRManager.createBreakpointRequest(lineLocation);
677                     breakpRequest.putProperty(&quot;number&quot;, property);
678                     breakpRequest.addThreadFilter(thread);
679                     breakpRequest.setSuspendPolicy( EventRequest.SUSPEND_EVENT_THREAD);
680                 } catch ( Exception e1 ) {
681                     log3(&quot;ERROR: inner Exception within settingBreakpoint() : &quot; + e1);
682                     breakpRequest    = null;
683                 }
684             }
685         } catch ( Exception e2 ) {
686             log3(&quot;ERROR: ATTENTION:  outer Exception within settingBreakpoint() : &quot; + e2);
687             breakpRequest    = null;
688         }
689 
690         if (breakpRequest == null) {
691             log2(&quot;      A BREAKPOINT HAS NOT BEEN SET UP&quot;);
692             throw new JDITestRuntimeException(&quot;**FAILURE to set up a breakpoint**&quot;);
693         }
694 
695         log2(&quot;      a breakpoint has been set up&quot;);
696         return breakpRequest;
697     }
698 
699 
700     private void getEventSet()
701                  throws JDITestRuntimeException {
702         try {
703 //            log2(&quot;       eventSet = eventQueue.remove(waitTime);&quot;);
704             eventSet = eventQueue.remove(waitTime);
705             if (eventSet == null) {
706                 throw new JDITestRuntimeException(&quot;** TIMEOUT while waiting for event **&quot;);
707             }
708 //            log2(&quot;       eventIterator = eventSet.eventIterator;&quot;);
709             eventIterator = eventSet.eventIterator();
710         } catch ( Exception e ) {
711             throw new JDITestRuntimeException(&quot;** EXCEPTION while waiting for event ** : &quot; + e);
712         }
713     }
714 
715 
716     private void breakpointForCommunication()
717                  throws JDITestRuntimeException {
718 
719         log2(&quot;breakpointForCommunication&quot;);
720         getEventSet();
721 
722         if (eventIterator.nextEvent() instanceof BreakpointEvent)
723             return;
724 
725         throw new JDITestRuntimeException(&quot;** event IS NOT a breakpoint **&quot;);
726     }
727 
728     // ============================== test&#39;s additional methods
729 
730     private AccessWatchpointRequest settingAccessWatchpoint (
731                                                   ThreadReference thread,
732                                                   ReferenceType testedClass,
733                                                   String fieldName,
734                                                   String property)
735             throws JDITestRuntimeException {
736 
737         log2(&quot;......setting up AccessWatchpoint:&quot;);
738         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
739                              &quot;; fieldName: &quot; + fieldName);
740 
741         AccessWatchpointRequest awRequest = null;
742         try {
743             Field field = testedClass.fieldByName(fieldName);
744             awRequest = eventRManager.createAccessWatchpointRequest(field);
745             awRequest.putProperty(&quot;number&quot;, property);
746             awRequest.addThreadFilter(thread);
747             awRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
748         } catch ( Exception e ) {
749             log3(&quot;ERROR: ATTENTION: Exception within settingAccessWatchpoint() : &quot; + e);
750             log3(&quot;       AN ACCESSWATCHPOINT HAS NOT BEEN SET UP&quot;);
751             throw new JDITestRuntimeException(&quot;** FAILURE to set up an AccessWatchpoint **&quot;);
752         }
753 
754         log2(&quot;      an AccessWatchpoint has been set up&quot;);
755         return awRequest;
756     }
757 
758     private ModificationWatchpointRequest settingModificationWatchpoint (
759                                                   ThreadReference thread,
760                                                   ReferenceType testedClass,
761                                                   String fieldName,
762                                                   String property)
763             throws JDITestRuntimeException {
764 
765         log2(&quot;......setting up ModificationWatchpoint:&quot;);
766         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
767                              &quot;; fieldName: &quot; + fieldName);
768 
769         ModificationWatchpointRequest mwRequest = null;
770         try {
771             Field field = testedClass.fieldByName(fieldName);
772             mwRequest = eventRManager.createModificationWatchpointRequest(field);
773             mwRequest.putProperty(&quot;number&quot;, property);
774             mwRequest.addThreadFilter(thread);
775             mwRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
776         } catch ( Exception e ) {
777             log3(&quot;ERROR: ATTENTION: Exception within settingModificationWatchpoint() : &quot; + e);
778             log3(&quot;       AN ModificationWATCHPOINT HAS NOT BEEN SET UP&quot;);
779             throw new JDITestRuntimeException(&quot;** FAILURE to set up an AccessWatchpoint **&quot;);
780         }
781 
782         log2(&quot;      a ModificationWatchpoint has been set up&quot;);
783         return mwRequest;
784     }
785 
786     private MethodEntryRequest settingMethodEntry ( ThreadReference thread,
787                                                     ReferenceType testedClass,
788                                                     String property)
789             throws JDITestRuntimeException {
790 
791         log2(&quot;......setting up MethodEntry:&quot;);
792         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
793                              &quot;; property: &quot; + property);
794 
795         MethodEntryRequest menRequest = null;
796         try {
797             menRequest = eventRManager.createMethodEntryRequest();
798             menRequest.putProperty(&quot;number&quot;, property);
799             menRequest.addThreadFilter(thread);
800             menRequest.addClassFilter(testedClass);
801             menRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
802         } catch ( Exception e ) {
803             log3(&quot;ERROR: ATTENTION: Exception within settingMethodEntry() : &quot; + e);
804             log3(&quot;       A MethodEntry HAS NOT BEEN SET UP&quot;);
805             throw new JDITestRuntimeException(&quot;** FAILURE to set up a MethodEntry **&quot;);
806         }
807 
808         log2(&quot;      a MethodEntry has been set up&quot;);
809         return menRequest;
810     }
811 
812     private MethodExitRequest settingMethodExit ( ThreadReference thread,
813                                                   ReferenceType testedClass,
814                                                   String property)
815             throws JDITestRuntimeException {
816 
817         log2(&quot;......setting up MethodExit:&quot;);
818         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
819                              &quot;; property: &quot; + property);
820 
821         MethodExitRequest mexRequest = null;
822         try {
823             mexRequest = eventRManager.createMethodExitRequest();
824             mexRequest.putProperty(&quot;number&quot;, property);
825             mexRequest.addThreadFilter(thread);
826             mexRequest.addClassFilter(testedClass);
827             mexRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
828         } catch ( Exception e ) {
829             log3(&quot;ERROR: ATTENTION: Exception within settingMethodExit() : &quot; + e);
830             log3(&quot;       A MethodExit HAS NOT BEEN SET UP&quot;);
831             throw new JDITestRuntimeException(&quot;** FAILURE to set up a MethodExit **&quot;);
832         }
833 
834         log2(&quot;      a MethodExit has been set up&quot;);
835         return mexRequest;
836     }
837 
838     private StepRequest settingStep ( ThreadReference thread, String property)
839             throws JDITestRuntimeException {
840 
841         log2(&quot;......setting up Step:&quot;);
842         log2(&quot;       thread: &quot; + thread + &quot;; property: &quot; + property);
843 
844         StepRequest stRequest = null;
845         try {
846             stRequest = eventRManager.createStepRequest(thread, StepRequest.STEP_LINE, StepRequest.STEP_OVER);
847             stRequest.putProperty(&quot;number&quot;, property);
848             stRequest.addCountFilter(1);
849             stRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
850         } catch ( Exception e ) {
851             log3(&quot;ERROR: ATTENTION: Exception within settingStep() : &quot; + e);
852             log3(&quot;       A Step HAS NOT BEEN SET UP&quot;);
853             throw new JDITestRuntimeException(&quot;** FAILURE to set up a Step **&quot;);
854         }
855 
856         log2(&quot;      a Step has been set up&quot;);
857         return stRequest;
858     }
859 
860 
861     private ExceptionRequest settingException ( ThreadReference thread,
862                                                 ReferenceType testedClass,
863                                                 String property)
864             throws JDITestRuntimeException {
865 
866         log2(&quot;......setting up Exception:&quot;);
867         log2(&quot;       thread: &quot; + thread + &quot;; class: &quot; + testedClass +
868                              &quot;; property: &quot; + property);
869 
870         ExceptionRequest excRequest = null;
871         try {
872             excRequest = eventRManager.createExceptionRequest(null, true, true);
873             excRequest.putProperty(&quot;number&quot;, property);
874             excRequest.addThreadFilter(thread);
875             excRequest.addClassFilter(testedClass);
876             excRequest.setSuspendPolicy( EventRequest.SUSPEND_NONE);
877         } catch ( Exception e ) {
878             log3(&quot;ERROR: ATTENTION: Exception within settingException() : &quot; + e);
879             log3(&quot;       A Exception HAS NOT BEEN SET UP&quot;);
880             throw new JDITestRuntimeException(&quot;** FAILURE to set up a Exception **&quot;);
881         }
882 
883         log2(&quot;      a Exception has been set up&quot;);
884         return excRequest;
885     }
886 
887     private void checkingEventIterator(EventIterator eIterator) {
888 
889         log2(&quot;......checking up on eIterator.nextEvent()&quot;);
890 
891         try {
892             log2(&quot;......first time: Event testedEvent = eIterator.nextEvent();&quot;);
893             log2(&quot;        no Exception to be thrown is expected&quot;);
894             Event testedEvent = eIterator.nextEvent();
895         } catch (Exception e) {
896                 log3(&quot;ERROR: Exception while: testedEvent = eIterator.nextEvent(); :: &quot; + e);
897                 testExitCode = FAILED;
898         }
899         try {
900             log2(&quot;......second time: Event testedEvent = eIterator.nextEvent();&quot;);
901             log2(&quot;        NoSuchElementException is expected&quot;);
902             Event testedEvent = eIterator.nextEvent();
903             log3(&quot;ERROR: no NoSuchElementException while: testedEvent = eIterator.nextEvent();&quot;);
904             testExitCode = FAILED;
905         } catch (NoSuchElementException e) {
906             log2(&quot;        NoSuchElementException&quot;);
907         } catch (Exception e) {
908             log3(&quot;ERROR: unexpected Exception :: &quot; + e);
909             testExitCode = FAILED;
910         }
911     }
912 
913     private void check() {
914 
915         log2(&quot;......performing the check;&quot;);
916         for (int k = 0; k &lt; eventFlags.length; k++) {
917 
918             log2(&quot;......new check case ::  k == &quot; + k);
919             switch (eventFlags[k]) {
920 
921             case 0:
922             case 1:
923             case 2:
924                    checkingEventIterator(eventSets[k].eventIterator());
925                    break;
926 
927             case 3:
928                    break;
929 
930             default:
931                     log3(&quot;ERROR: unexpected default case&quot;);
932                     testExitCode = FAILED;
933                     throw new JDITestRuntimeException(&quot;** FAILURE within check() **&quot;);
934             }
935         }
936     }
937 
938 }
    </pre>
  </body>
</html>
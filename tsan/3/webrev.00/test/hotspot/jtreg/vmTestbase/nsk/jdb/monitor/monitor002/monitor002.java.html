<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jdb/monitor/monitor002/monitor002.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 /*
 26  * @test
 27  *
 28  * @summary JDB problem running monitor command
 29  * VM Testbase keywords: [jpda, jdb]
 30  * VM Testbase readme:
 31  * DESCRIPTION
 32  * Make sure &#39;monitor unmonitor 1&#39; does not cause ConcurrentModificationException
 33  * in the debugger.
 34  * The jdb sets up line breakpoint at the debugged application. Then one command
 35  * &#39;monitor unmonitor 1&#39; is set. After resuming the debuggee stops at the breakpoint.
 36  * The test passes if correct reply for &quot;unmonitor 1&quot; commanda is found in jdb stdout
 37  * stream.
 38  * The test consists of two program:
 39  *   monitor002.java - launches jdb and debuggee, writes commands to jdb, reads the jdb output,
 40  *   monitor002a.java - the debugged application.
 41  *
 42  * @library /vmTestbase
 43  *          /test/lib
 44  * @run driver jdk.test.lib.FileInstaller . .
 45  * @build nsk.jdb.monitor.monitor002.monitor002
 46  *        nsk.jdb.monitor.monitor002.monitor002a
 47  * @run main/othervm PropertyResolvingWrapper nsk.jdb.monitor.monitor002.monitor002
 48  *      -arch=${os.family}-${os.simpleArch}
 49  *      -waittime=5
 50  *      -debugee.vmkind=java
 51  *      -transport.address=dynamic
 52  *      -jdb=${test.jdk}/bin/jdb
 53  *      -java.options=&quot;${test.vm.opts} ${test.java.opts}&quot;
 54  *      -workdir=.
 55  *      -debugee.vmkeys=&quot;${test.vm.opts} ${test.java.opts}&quot;
 56  */
 57 
 58 package nsk.jdb.monitor.monitor002;
 59 
 60 import nsk.share.*;
 61 import nsk.share.jdb.*;
 62 
 63 import java.io.*;
 64 import java.util.*;
 65 
 66 public class monitor002 extends JdbTest {
 67 
 68     public static void main (String argv[]) {
 69         System.exit(run(argv, System.out) + JCK_STATUS_BASE);
 70     }
 71 
 72     public static int run(String argv[], PrintStream out) {
 73         debuggeeClass =  DEBUGGEE_CLASS;
 74         firstBreak = FIRST_BREAK;
 75         lastBreak = LAST_BREAK;
 76         return new monitor002().runTest(argv, out);
 77     }
 78 
 79     static final String PACKAGE_NAME = &quot;nsk.jdb.monitor.monitor002&quot;;
 80     static final String TEST_CLASS = PACKAGE_NAME + &quot;.monitor002&quot;;
 81     static final String DEBUGGEE_CLASS = TEST_CLASS + &quot;a&quot;;
 82     static final String FIRST_BREAK        = DEBUGGEE_CLASS + &quot;.main&quot;;
 83     static final String LAST_BREAK         = DEBUGGEE_CLASS + &quot;.lastBreak&quot;;
 84     static final int    LINE_NUMBER        = 47;
 85 
 86     static final String[] CHECKED_COMMANDS = {
 87         JdbCommand.unmonitor + &quot;1&quot;
 88                                              };
 89 
 90     protected void runCases() {
 91         String[] reply;
 92         Paragrep grep;
 93         int count;
 94         Vector v;
 95         String found;
 96 
 97         reply = jdb.receiveReplyFor(JdbCommand.stop_at + DEBUGGEE_CLASS + &quot;:&quot; + LINE_NUMBER);
 98 
 99         for (int i = 0; i &lt; CHECKED_COMMANDS.length; i++) {
100             reply = jdb.receiveReplyFor(JdbCommand.monitor + CHECKED_COMMANDS[i]);
101         }
102 
103         int repliesCount = CHECKED_COMMANDS.length + 1;
104         reply = jdb.receiveReplyFor(JdbCommand.cont, true, repliesCount);
105 
106         reply = jdb.receiveReplyFor(JdbCommand.monitor);
107         if (reply.length != 1) {
108             log.complain(&quot;Expected no active monitors after exectuting monitored command: &quot; + CHECKED_COMMANDS[0]);
109             success = false;
110         }
111 
112         jdb.contToExit(1);
113 
114         reply = jdb.getTotalReply();
115 
116         if (!checkCommands(reply)) {
117             success = false;
118         }
119     }
120 
121     private boolean checkCommands(String[] reply) {
122         Paragrep grep;
123         boolean result = true;
124         int count;
125 
126         grep = new Paragrep(reply);
127 
128         if ((count = grep.find(&quot;Unmonitoring 1:  unmonitor 1&quot;)) != 1) {
129             log.complain(&quot;Wrong number of execution of monitored command: &quot; + CHECKED_COMMANDS[0]);
130             log.complain(&quot;    Expected: 1; found: &quot; + count);
131             result = false;
132         }
133 
134         return result;
135     }
136 }
    </pre>
  </body>
</html>
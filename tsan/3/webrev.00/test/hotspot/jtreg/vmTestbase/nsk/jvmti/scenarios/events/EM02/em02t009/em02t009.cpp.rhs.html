<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t009/em02t009.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* ============================================================================= */
 34 
 35 /* scaffold objects */
 36 static jvmtiEnv *jvmti = NULL;
 37 static jlong timeout = 0;
 38 static jrawMonitorID syncLock = NULL;
 39 
 40 /* constant names */
 41 #define STEP_NUMBER 3
 42 #define NUMBER_OF_INVOCATIONS 1000
 43 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 44 
 45 static int eventCount[JVMTI_EVENT_COUNT];
 46 static int newEventCount[JVMTI_EVENT_COUNT];
 47 
 48 /* ============================================================================= */
 49 
 50 static void
 51 showEventStatistics(int step) {
 52     int i;
 53     const char* str;
 54     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 55 
 56     NSK_DISPLAY0(&quot;\n&quot;);
 57     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 58     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 59     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 60         if (currentCounts[i] &gt; 0) {
 61             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 62             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 63         }
 64     }
 65 }
 66 
 67 /* ========================================================================== */
 68 
 69 int checkEvents(int step) {
 70     int i;
 71     jvmtiEvent curr;
<a name="2" id="anc2"></a><span class="line-modified"> 72     bool result = true;</span>
 73     int *currentCounts;
 74     int isExpected = 0;
 75 
 76     switch (step) {
 77         case 1:
 78             currentCounts = &amp;eventCount[0];
 79             break;
 80 
 81         case 2:
 82         case 3:
 83             currentCounts = &amp;newEventCount[0];
 84             break;
 85 
 86         default:
 87             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<a name="3" id="anc3"></a><span class="line-modified"> 88             return false;</span>
 89     }
 90 
 91     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 92 
 93         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
 94 
 95         switch (step) {
 96             case 1:
 97                 isExpected = ((curr == JVMTI_EVENT_VM_INIT)
 98                                 || (curr == JVMTI_EVENT_METHOD_ENTRY)
 99                                 || (curr == JVMTI_EVENT_METHOD_EXIT));
100                 break;
101 
102             case 2:
103                 isExpected = ((curr == JVMTI_EVENT_METHOD_ENTRY)
104                                 || (curr == JVMTI_EVENT_METHOD_EXIT));
105                 break;
106 
107             case 3:
108                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
109                 break;
110         }
111 
112         if (isExpected) {
113             if (curr == JVMTI_EVENT_VM_INIT || curr == JVMTI_EVENT_VM_DEATH) {
114                 if (currentCounts[i] &lt; 1) {
115                         NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
116                                             currentCounts[i],
117                                             TranslateEvent(curr));
<a name="4" id="anc4"></a><span class="line-modified">118                     result = false;</span>
119                 }
120             } else {
121                 if (currentCounts[i] != NUMBER_OF_INVOCATIONS) {
122                     NSK_COMPLAIN3(&quot;Unexpected number of %s events %d, expected value is %d\n&quot;,
123                                         TranslateEvent(curr),
124                                         currentCounts[i],
125                                         NUMBER_OF_INVOCATIONS);
<a name="5" id="anc5"></a><span class="line-modified">126                     result = false;</span>
127                 }
128             }
129         } else {
130 
131             if (currentCounts[i] &gt; 0) {
132                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
133                                     TranslateEvent(curr),
134                                     currentCounts[i]);
<a name="6" id="anc6"></a><span class="line-modified">135                 result = false;</span>
136             }
137         }
138     }
139 
140     return result;
141 }
142 
143 static void
144 changeCount(jvmtiEvent event, int *currentCounts) {
145 
146     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
147         nsk_jvmti_setFailStatus();
148 
149     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
150 
151     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
152         nsk_jvmti_setFailStatus();
153 
154 }
155 
156 /* ============================================================================= */
157 
158 /* callbacks */
159 JNIEXPORT void JNICALL
160 cbVMInit(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread) {
161     changeCount(JVMTI_EVENT_VM_INIT, &amp;eventCount[0]);
162 }
163 
164 JNIEXPORT void JNICALL
165 cbVMDeath(jvmtiEnv* jvmti, JNIEnv* jni_env) {
166     changeCount(JVMTI_EVENT_VM_DEATH, &amp;newEventCount[0]);
167     showEventStatistics(STEP_NUMBER);
168     if (!checkEvents(STEP_NUMBER))
169         nsk_jvmti_setFailStatus();
170 
171     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock)))
172         nsk_jvmti_setFailStatus();
173 
174 }
175 
176 void JNICALL
177 cbException(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
178                 jmethodID method, jlocation location, jobject exception,
179                 jmethodID catch_method, jlocation catch_location) {
180 
181     changeCount(JVMTI_EVENT_EXCEPTION, &amp;eventCount[0]);
182 }
183 
184 void JNICALL
185 cbExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
186                 jmethodID method, jlocation location, jobject exception) {
187 
188     changeCount(JVMTI_EVENT_EXCEPTION_CATCH, &amp;eventCount[0]);
189 }
190 
191 void JNICALL
192 cbSingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
193                 jmethodID method, jlocation location) {
194 
195     changeCount(JVMTI_EVENT_SINGLE_STEP, &amp;eventCount[0]);
196 }
197 
198 void JNICALL
199 cbFramePop(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
200                 jmethodID method, jboolean was_popped_by_exception) {
201     changeCount(JVMTI_EVENT_FRAME_POP, &amp;eventCount[0]);
202 }
203 
204 void JNICALL
205 cbBreakpoint(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
206                 jmethodID method, jlocation location) {
207     changeCount(JVMTI_EVENT_BREAKPOINT, &amp;eventCount[0]);
208 }
209 
210 void JNICALL
211 cbFieldAccess(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
212                 jmethodID method, jlocation location, jclass field_klass,
213                 jobject object, jfieldID field) {
214     changeCount(JVMTI_EVENT_FIELD_ACCESS, &amp;eventCount[0]);
215 }
216 
217 void JNICALL
218 cbFieldModification(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
219                 jmethodID method, jlocation location, jclass field_klass,
220                 jobject object, jfieldID field, char signature_type,
221                 jvalue new_value) {
222     changeCount(JVMTI_EVENT_FIELD_MODIFICATION, &amp;eventCount[0]);
223 }
224 
225 void handler1(jvmtiEnv *jvmti_env, jvmtiEvent event, jmethodID method) {
226 
227     char *name;
228     char *sign;
229     char *genc;
230 
231     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodName(method, &amp;name, &amp;sign, &amp;genc))) {
232         nsk_jvmti_setFailStatus();
233         return;
234     }
235 
236     if (!strncmp(name,&quot;javaMethod&quot;, 8)) {
237         changeCount(event, &amp;eventCount[0]);
238     }
239 
240     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)name))) {
241         nsk_jvmti_setFailStatus();
242     }
243     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)sign))) {
244         nsk_jvmti_setFailStatus();
245     }
246     if (genc != NULL)
247         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)genc))) {
248             nsk_jvmti_setFailStatus();
249         }
250 }
251 
252 void JNICALL
253 cbMethodEntry(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
254                 jmethodID method) {
255 
256     handler1(jvmti_env, JVMTI_EVENT_METHOD_ENTRY, method);
257 }
258 
259 void JNICALL
260 cbMethodExit(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
261                 jmethodID method, jboolean was_popped_by_exception,
262                 jvalue return_value) {
263 
264     handler1(jvmti_env, JVMTI_EVENT_METHOD_EXIT, method);
265 }
266 
267 void handler2(jvmtiEnv *jvmti_env, jvmtiEvent event, jmethodID method) {
268 
269     char *name;
270     char *sign;
271     char *genc;
272 
273     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodName(method, &amp;name, &amp;sign, &amp;genc))) {
274         nsk_jvmti_setFailStatus();
275         return;
276     }
277 
278     if (!strncmp(name,&quot;javaMethod&quot;, 8)) {
279         changeCount(event, &amp;newEventCount[0]);
280     }
281 
282     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)name))) {
283         nsk_jvmti_setFailStatus();
284     }
285     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)sign))) {
286         nsk_jvmti_setFailStatus();
287     }
288     if (genc != NULL)
289         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)genc))) {
290             nsk_jvmti_setFailStatus();
291         }
292 }
293 
294 void JNICALL
295 cbNewMethodEntry(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
296                 jmethodID method) {
297 
298     handler2(jvmti_env, JVMTI_EVENT_METHOD_ENTRY, method);
299 }
300 
301 void JNICALL
302 cbNewMethodExit(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
303                 jmethodID method, jboolean was_popped_by_exception,
304                 jvalue return_value) {
305 
306     handler2(jvmti_env, JVMTI_EVENT_METHOD_EXIT, method);
307 }
308 
309 void JNICALL
310 cbNativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env,jthread thread,
311                 jmethodID method, void* address, void** new_address_ptr) {
312     changeCount(JVMTI_EVENT_NATIVE_METHOD_BIND, &amp;eventCount[0]);
313 }
314 
315 void JNICALL
316 cbMonitorWait(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
317                     jobject object, jlong tout) {
318 
319     changeCount(JVMTI_EVENT_MONITOR_WAIT, &amp;eventCount[0]);
320 }
321 
322 void JNICALL
323 cbMonitorWaited(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
324                     jobject object, jboolean timed_out) {
325 
326     changeCount(JVMTI_EVENT_MONITOR_WAITED, &amp;eventCount[0]);
327 }
328 
329 JNIEXPORT void JNICALL
330 cbMonitorContendedEnter(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread,
331                             jobject object) {
332 
333     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTER, &amp;eventCount[0]);
334 }
335 
336 void JNICALL
337 cbMonitorContendedEntered(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
338                             jobject object) {
339 
340     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, &amp;eventCount[0]);
341 }
342 
343 void JNICALL
344 cbCompiledMethodLoad(jvmtiEnv *jvmti_env, jmethodID method, jint code_size,
345                 const void* code_addr, jint map_length,
346                 const jvmtiAddrLocationMap* map, const void* compile_info) {
347     changeCount(JVMTI_EVENT_COMPILED_METHOD_LOAD, &amp;eventCount[0]);
348 }
349 
350 void JNICALL
351 cbCompiledMethodUnload(jvmtiEnv *jvmti_env, jmethodID method,
352                 const void* code_addr) {
353     changeCount(JVMTI_EVENT_COMPILED_METHOD_UNLOAD, &amp;eventCount[0]);
354 }
355 
356 void JNICALL
357 cbGarbageCollectionStart(jvmtiEnv *jvmti_env) {
358     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_START, &amp;eventCount[0]);
359 }
360 
361 void JNICALL
362 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
363     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
364 }
365 
366 void JNICALL
367 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
368 
369     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
370 }
371 
372 void JNICALL
373 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
374                     jobject object, jclass object_klass, jlong size) {
375 
376     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
377 }
378 
379 /* ============================================================================= */
380 
<a name="7" id="anc7"></a><span class="line-modified">381 static bool enableEvent(jvmtiEvent event) {</span>
382 
383     if (nsk_jvmti_isOptionalEvent(event)
384             &amp;&amp; (event != JVMTI_EVENT_METHOD_ENTRY)
385             &amp;&amp; (event != JVMTI_EVENT_METHOD_EXIT)) {
386         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
387                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
388             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
389                 TranslateEvent(event));
<a name="8" id="anc8"></a><span class="line-modified">390             return false;</span>
391         }
392     } else {
393         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
394             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
395                 TranslateEvent(event));
<a name="9" id="anc9"></a><span class="line-modified">396             return false;</span>
397         }
398     }
399 
<a name="10" id="anc10"></a><span class="line-modified">400     return true;</span>
401 }
402 
403 /**
404  * Enable or disable tested events.
405  */
<a name="11" id="anc11"></a><span class="line-modified">406 static bool enableEventList() {</span>
407 
408     int i, result;
409 
410     result = enableEvent(JVMTI_EVENT_VM_INIT);
411 
412     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
413 
414     /* enabling optional events */
415     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
416         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
417 
418         if (nsk_jvmti_isOptionalEvent(event))
419             result = result &amp;&amp; enableEvent(event);
420     }
421 
<a name="12" id="anc12"></a><span class="line-modified">422     if (!result) {</span>
423         nsk_jvmti_setFailStatus();
<a name="13" id="anc13"></a><span class="line-modified">424         return false;</span>
425     }
426 
<a name="14" id="anc14"></a><span class="line-modified">427     return true;</span>
428 }
429 
430 /* ============================================================================= */
431 
<a name="15" id="anc15"></a><span class="line-modified">432 static bool setCallBacks(int step) {</span>

433 
434     int i;
435 
436     jvmtiEventCallbacks eventCallbacks;
437     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
438 
439     switch (step) {
440         case 1:
441             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
442                 eventCount[i] = 0;
443             }
444 
445             eventCallbacks.VMInit                    = cbVMInit;
446             eventCallbacks.Exception                 = cbException;
447             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
448             eventCallbacks.SingleStep                = cbSingleStep;
449             eventCallbacks.FramePop                  = cbFramePop;
450             eventCallbacks.Breakpoint                = cbBreakpoint;
451             eventCallbacks.FieldAccess               = cbFieldAccess;
452             eventCallbacks.FieldModification         = cbFieldModification;
453             eventCallbacks.MethodEntry               = cbMethodEntry;
454             eventCallbacks.MethodExit                = cbMethodExit;
455             eventCallbacks.NativeMethodBind          = cbNativeMethodBind;
456             eventCallbacks.CompiledMethodLoad        = cbCompiledMethodLoad;
457             eventCallbacks.CompiledMethodUnload      = cbCompiledMethodUnload;
458             eventCallbacks.MonitorWait               = cbMonitorWait;
459             eventCallbacks.MonitorWaited             = cbMonitorWaited;
460             eventCallbacks.MonitorContendedEnter     = cbMonitorContendedEnter;
461             eventCallbacks.MonitorContendedEntered   = cbMonitorContendedEntered;
462             eventCallbacks.GarbageCollectionStart    = cbGarbageCollectionStart;
463             eventCallbacks.GarbageCollectionFinish   = cbGarbageCollectionFinish;
464             eventCallbacks.ObjectFree                = cbObjectFree;
465             eventCallbacks.VMObjectAlloc             = cbVMObjectAlloc;
466             break;
467 
468         case 2:
469             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
470                 newEventCount[i] = 0;
471             }
472 
473             eventCallbacks.MethodEntry               = cbNewMethodEntry;
474             eventCallbacks.MethodExit                = cbNewMethodExit;
475             break;
476 
477         case 3:
478             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
479                 newEventCount[i] = 0;
480             }
481 
482             eventCallbacks.VMDeath                   = cbVMDeath;
483             break;
484 
485     }
486     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<a name="16" id="anc16"></a><span class="line-modified">487         return false;</span>
488 
<a name="17" id="anc17"></a><span class="line-modified">489     return true;</span>
490 }
491 
492 /* ============================================================================= */
493 
494 /** Agent algorithm. */
495 static void JNICALL
496 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
497 
498     int i;
499 
500     for (i = 1; i &lt;= STEP_NUMBER; i++) {
501 
502         if (!nsk_jvmti_waitForSync(timeout))
503             return;
504 
505         if (i &lt; STEP_NUMBER) {
506             showEventStatistics(i);
507             if (!checkEvents(i))
508                 nsk_jvmti_setFailStatus();
509 
510             if (!setCallBacks(i + 1)) {
511                 return;
512             }
513         }
514 
515         if (!nsk_jvmti_resumeSync())
516             return;
517     }
518 
519 }
520 
521 /* ============================================================================= */
522 
523 /** Agent library initialization. */
524 #ifdef STATIC_BUILD
525 JNIEXPORT jint JNICALL Agent_OnLoad_em02t009(JavaVM *jvm, char *options, void *reserved) {
526     return Agent_Initialize(jvm, options, reserved);
527 }
528 JNIEXPORT jint JNICALL Agent_OnAttach_em02t009(JavaVM *jvm, char *options, void *reserved) {
529     return Agent_Initialize(jvm, options, reserved);
530 }
531 JNIEXPORT jint JNI_OnLoad_em02t009(JavaVM *jvm, char *options, void *reserved) {
532     return JNI_VERSION_1_8;
533 }
534 #endif
535 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
536 
537     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
538         return JNI_ERR;
539 
540     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
541 
542     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
543     if (!NSK_VERIFY(jvmti != NULL))
544         return JNI_ERR;
545 
546     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock))) {
547         nsk_jvmti_setFailStatus();
548         return JNI_ERR;
549     }
550 
551     {
552         jvmtiCapabilities caps;
553         memset(&amp;caps, 0, sizeof(caps));
554 
555         caps.can_generate_method_entry_events = 1;
556         caps.can_generate_method_exit_events = 1;
557         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
558             return JNI_ERR;
559     }
560 
561     if (!setCallBacks(1)) {
562         return JNI_ERR;
563     }
564 
565     if (!enableEventList()) {
566         return JNI_ERR;
567     }
568 
569     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
570         return JNI_ERR;
571 
572     return JNI_OK;
573 }
574 
575 /* ============================================================================= */
576 
577 
578 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
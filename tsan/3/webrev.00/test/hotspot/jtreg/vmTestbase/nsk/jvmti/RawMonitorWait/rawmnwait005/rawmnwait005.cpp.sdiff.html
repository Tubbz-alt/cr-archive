<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/RawMonitorWait/rawmnwait005/rawmnwait005.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../GetTimerInfo/timerinfo001/timerinfo001.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../RelinquishCapabilities/relcaps001/relcaps001.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/RawMonitorWait/rawmnwait005/rawmnwait005.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdio.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &quot;jvmti.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;JVMTITools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 
 33 #define PASSED 0
 34 #define STATUS_FAILED 2
 35 #define MILLIS_PER_MINUTE (60 * 1000)
 36 
 37 static jvmtiEnv *jvmti = NULL;
 38 static jvmtiCapabilities caps;
 39 static jint result = PASSED;
<span class="line-modified"> 40 static jboolean printdump = JNI_FALSE;</span>
 41 static jrawMonitorID monitor;
 42 static jrawMonitorID wait_lock;
 43 static jlong wait_time;
 44 
 45 #ifdef STATIC_BUILD
 46 JNIEXPORT jint JNICALL Agent_OnLoad_rawmnwait005(JavaVM *jvm, char *options, void *reserved) {
 47     return Agent_Initialize(jvm, options, reserved);
 48 }
 49 JNIEXPORT jint JNICALL Agent_OnAttach_rawmnwait005(JavaVM *jvm, char *options, void *reserved) {
 50     return Agent_Initialize(jvm, options, reserved);
 51 }
 52 JNIEXPORT jint JNI_OnLoad_rawmnwait005(JavaVM *jvm, char *options, void *reserved) {
 53     return JNI_VERSION_1_8;
 54 }
 55 #endif
 56 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
 57     jint res;
 58     jvmtiError err;
 59 
 60     if (options != NULL &amp;&amp; strcmp(options, &quot;printdump&quot;) == 0) {
</pre>
<hr />
<pre>
 83 
 84     err = jvmti-&gt;GetCapabilities(&amp;caps);
 85     if (err != JVMTI_ERROR_NONE) {
 86         printf(&quot;(GetCapabilities) unexpected error: %s (%d)\n&quot;,
 87                TranslateError(err), err);
 88         return JNI_ERR;
 89     }
 90 
 91     if (!caps.can_signal_thread) {
 92         printf(&quot;Warning: InterruptThread is not implemented\n&quot;);
 93     }
 94 
 95     return JNI_OK;
 96 }
 97 
 98 static void JNICALL
 99 test_thread(jvmtiEnv* jvmti, JNIEnv* jni, void *unused) {
100     jvmtiError err;
101     const char* const thread_name = &quot;test thread&quot;;
102 


103     err = jvmti-&gt;RawMonitorEnter(monitor);
104     if (err != JVMTI_ERROR_NONE) {
105         printf(&quot;(RawMonitorEnter#test) unexpected error: %s (%d)\n&quot;,
106                TranslateError(err), err);
107         result = STATUS_FAILED;
108     }
109     if (printdump == JNI_TRUE) {
110         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;monitor&#39; ...\n&quot;, thread_name);
111     }
112 

113     err = jvmti-&gt;RawMonitorEnter(wait_lock);
114     if (err != JVMTI_ERROR_NONE) {
115         printf(&quot;(RawMonitorEnter#wait) unexpected error: %s (%d)\n&quot;,
116                TranslateError(err), err);
117         result = STATUS_FAILED;
118         return;
119     }
120 
121     if (printdump == JNI_TRUE) {
122         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;wait_lock&#39; ...\n&quot;, thread_name);
123         printf(&quot;&gt;&gt;&gt; [%s] notifying main thread (wait_lock.notify) ...\n&quot;, thread_name);
124     }
125 
126     err = jvmti-&gt;RawMonitorNotify(wait_lock);
127     if (err != JVMTI_ERROR_NONE) {
128         printf(&quot;(RawMonitorWait#wait) unexpected error: %s (%d)\n&quot;,
129                TranslateError(err), err);
130         result = STATUS_FAILED;
131         return;
132     }
</pre>
<hr />
<pre>
139     }
140 
141     if (printdump == JNI_TRUE) {
142         printf(&quot;&gt;&gt;&gt; [%s] waiting for interrupt ...\n&quot;, thread_name);
143     }
144 
145     err = jvmti-&gt;RawMonitorWait(monitor, wait_time);
146     if (err != JVMTI_ERROR_INTERRUPT) {
147         printf(&quot;Error expected: JVMTI_ERROR_INTERRUPT,\n&quot;);
148         printf(&quot;\tactual: %s (%d)\n&quot;, TranslateError(err), err);
149         result = STATUS_FAILED;
150     }
151 
152     err = jvmti-&gt;RawMonitorExit(monitor);
153     if (err != JVMTI_ERROR_NONE) {
154         printf(&quot;(RawMonitorExit#test) unexpected error: %s (%d)\n&quot;,
155                TranslateError(err), err);
156         result = STATUS_FAILED;
157     }
158 






























159     if (printdump == JNI_TRUE) {
160         printf(&quot;&gt;&gt;&gt; [%s] all done\n&quot;, thread_name);
161     }
162 }
163 
164 JNIEXPORT jint JNICALL
165 Java_nsk_jvmti_RawMonitorWait_rawmnwait005_check(JNIEnv *env,
166         jclass cls, jthread thr, jint wtime) {
167     jvmtiError err;
168     const char* const thread_name = &quot;main thread&quot;;
169 
170     if (!caps.can_signal_thread) {
171         return result;
172     }
173 
174     wait_time = wtime * MILLIS_PER_MINUTE;
175 
176     if (jvmti == NULL) {
177         printf(&quot;JVMTI client was not properly loaded!\n&quot;);
178         return STATUS_FAILED;
</pre>
<hr />
<pre>
206     //                     | wait_lock.enter
207     //                     | wait_lock.wait(0)
208     //    ...              |
209     //                     |  ... will wait forever ...
210     //
211     // See also 6399368 test bug.
212     //
213     err = jvmti-&gt;RawMonitorEnter(wait_lock);
214     if (err != JVMTI_ERROR_NONE) {
215         printf(&quot;(RawMonitorEnter#wait) unexpected error: %s (%d)\n&quot;,
216                TranslateError(err), err);
217         return STATUS_FAILED;
218     }
219     if (printdump == JNI_TRUE) {
220         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;wait_lock&#39; ... \n&quot;, thread_name);
221     }
222 
223     if (printdump == JNI_TRUE) {
224         printf(&quot;&gt;&gt;&gt; [%s] starting test thread ...\n&quot;, thread_name);
225     }





226     err = jvmti-&gt;RunAgentThread(thr, test_thread, NULL,
227                                 JVMTI_THREAD_NORM_PRIORITY);
228     if (err != JVMTI_ERROR_NONE) {
229         printf(&quot;(RunDebugThread) unexpected error: %s (%d)\n&quot;,
230                TranslateError(err), err);
231         return STATUS_FAILED;
232     }
233 
234     if (printdump == JNI_TRUE) {
235         printf(&quot;&gt;&gt;&gt; [%s] waiting for test thread to run (do wait_lock.wait)...\n&quot;, thread_name);
236     }
237     err = jvmti-&gt;RawMonitorWait(wait_lock, (jlong)0);
238     if (err != JVMTI_ERROR_NONE) {
239         printf(&quot;(RawMonitorWait#wait) unexpected error: %s (%d)\n&quot;,
240                TranslateError(err), err);
241         return STATUS_FAILED;
242     }
243     if (printdump == JNI_TRUE) {
244         printf(&quot;&gt;&gt;&gt; [%s] got notification from test thread ...\n&quot;, thread_name);
245     }
246 
<span class="line-modified">247     err = jvmti-&gt;RawMonitorExit(wait_lock);</span>
<span class="line-removed">248     if (err != JVMTI_ERROR_NONE) {</span>
<span class="line-removed">249         printf(&quot;(RawMonitorExit#wait) unexpected error: %s (%d)\n&quot;,</span>
<span class="line-removed">250                TranslateError(err), err);</span>
<span class="line-removed">251         return STATUS_FAILED;</span>
<span class="line-removed">252     }</span>
253 
254     err = jvmti-&gt;RawMonitorEnter(monitor);
255     if (err != JVMTI_ERROR_NONE) {
256         printf(&quot;(RawMonitorEnter#test) unexpected error: %s (%d)\n&quot;,
257                TranslateError(err), err);
258         return STATUS_FAILED;
259     }
260     if (printdump == JNI_TRUE) {
261         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;monitor&#39; ... \n&quot;, thread_name);
262     }
263 
264     if (printdump == JNI_TRUE) {
265         printf(&quot;&gt;&gt;&gt; [%s] interrupting test thread ...\n&quot;, thread_name);
266     }
267 
268     err = jvmti-&gt;InterruptThread(thr);
269     if (err != JVMTI_ERROR_NONE) {
270         printf(&quot;(InterruptThread) unexpected error: %s (%d)\n&quot;,
271                TranslateError(err), err);
272         result = STATUS_FAILED;
273     }
274 
275     err = jvmti-&gt;RawMonitorExit(monitor);
276     if (err != JVMTI_ERROR_NONE) {
277         printf(&quot;(RawMonitorExit#test) unexpected error: %s (%d)\n&quot;,
278                TranslateError(err), err);
279         result = STATUS_FAILED;
280     }
281 




















282     if (printdump == JNI_TRUE) {
283         printf(&quot;&gt;&gt;&gt; [%s] all done\n&quot;, thread_name);
284     }
285 
286     return result;
287 }
288 
289 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;stdio.h&gt;
 25 #include &lt;string.h&gt;
 26 #include &quot;jvmti.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;JVMTITools.h&quot;
 29 
 30 extern &quot;C&quot; {
 31 
 32 
 33 #define PASSED 0
 34 #define STATUS_FAILED 2
 35 #define MILLIS_PER_MINUTE (60 * 1000)
 36 
 37 static jvmtiEnv *jvmti = NULL;
 38 static jvmtiCapabilities caps;
 39 static jint result = PASSED;
<span class="line-modified"> 40 static jboolean printdump = JNI_TRUE;</span>
 41 static jrawMonitorID monitor;
 42 static jrawMonitorID wait_lock;
 43 static jlong wait_time;
 44 
 45 #ifdef STATIC_BUILD
 46 JNIEXPORT jint JNICALL Agent_OnLoad_rawmnwait005(JavaVM *jvm, char *options, void *reserved) {
 47     return Agent_Initialize(jvm, options, reserved);
 48 }
 49 JNIEXPORT jint JNICALL Agent_OnAttach_rawmnwait005(JavaVM *jvm, char *options, void *reserved) {
 50     return Agent_Initialize(jvm, options, reserved);
 51 }
 52 JNIEXPORT jint JNI_OnLoad_rawmnwait005(JavaVM *jvm, char *options, void *reserved) {
 53     return JNI_VERSION_1_8;
 54 }
 55 #endif
 56 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
 57     jint res;
 58     jvmtiError err;
 59 
 60     if (options != NULL &amp;&amp; strcmp(options, &quot;printdump&quot;) == 0) {
</pre>
<hr />
<pre>
 83 
 84     err = jvmti-&gt;GetCapabilities(&amp;caps);
 85     if (err != JVMTI_ERROR_NONE) {
 86         printf(&quot;(GetCapabilities) unexpected error: %s (%d)\n&quot;,
 87                TranslateError(err), err);
 88         return JNI_ERR;
 89     }
 90 
 91     if (!caps.can_signal_thread) {
 92         printf(&quot;Warning: InterruptThread is not implemented\n&quot;);
 93     }
 94 
 95     return JNI_OK;
 96 }
 97 
 98 static void JNICALL
 99 test_thread(jvmtiEnv* jvmti, JNIEnv* jni, void *unused) {
100     jvmtiError err;
101     const char* const thread_name = &quot;test thread&quot;;
102 
<span class="line-added">103     // Once we hold this monitor we know we can&#39;t get interrupted</span>
<span class="line-added">104     // until we have called wait().</span>
105     err = jvmti-&gt;RawMonitorEnter(monitor);
106     if (err != JVMTI_ERROR_NONE) {
107         printf(&quot;(RawMonitorEnter#test) unexpected error: %s (%d)\n&quot;,
108                TranslateError(err), err);
109         result = STATUS_FAILED;
110     }
111     if (printdump == JNI_TRUE) {
112         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;monitor&#39; ...\n&quot;, thread_name);
113     }
114 
<span class="line-added">115     // We can&#39;t get this monitor until the main thread has called wait() on it.</span>
116     err = jvmti-&gt;RawMonitorEnter(wait_lock);
117     if (err != JVMTI_ERROR_NONE) {
118         printf(&quot;(RawMonitorEnter#wait) unexpected error: %s (%d)\n&quot;,
119                TranslateError(err), err);
120         result = STATUS_FAILED;
121         return;
122     }
123 
124     if (printdump == JNI_TRUE) {
125         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;wait_lock&#39; ...\n&quot;, thread_name);
126         printf(&quot;&gt;&gt;&gt; [%s] notifying main thread (wait_lock.notify) ...\n&quot;, thread_name);
127     }
128 
129     err = jvmti-&gt;RawMonitorNotify(wait_lock);
130     if (err != JVMTI_ERROR_NONE) {
131         printf(&quot;(RawMonitorWait#wait) unexpected error: %s (%d)\n&quot;,
132                TranslateError(err), err);
133         result = STATUS_FAILED;
134         return;
135     }
</pre>
<hr />
<pre>
142     }
143 
144     if (printdump == JNI_TRUE) {
145         printf(&quot;&gt;&gt;&gt; [%s] waiting for interrupt ...\n&quot;, thread_name);
146     }
147 
148     err = jvmti-&gt;RawMonitorWait(monitor, wait_time);
149     if (err != JVMTI_ERROR_INTERRUPT) {
150         printf(&quot;Error expected: JVMTI_ERROR_INTERRUPT,\n&quot;);
151         printf(&quot;\tactual: %s (%d)\n&quot;, TranslateError(err), err);
152         result = STATUS_FAILED;
153     }
154 
155     err = jvmti-&gt;RawMonitorExit(monitor);
156     if (err != JVMTI_ERROR_NONE) {
157         printf(&quot;(RawMonitorExit#test) unexpected error: %s (%d)\n&quot;,
158                TranslateError(err), err);
159         result = STATUS_FAILED;
160     }
161 
<span class="line-added">162     // We can&#39;t reacquire this monitor until the main thread is waiting for us to</span>
<span class="line-added">163     // complete.</span>
<span class="line-added">164     err = jvmti-&gt;RawMonitorEnter(wait_lock);</span>
<span class="line-added">165     if (err != JVMTI_ERROR_NONE) {</span>
<span class="line-added">166         printf(&quot;(RawMonitorEnter#wait) unexpected error: %s (%d)\n&quot;,</span>
<span class="line-added">167                TranslateError(err), err);</span>
<span class="line-added">168         result = STATUS_FAILED;</span>
<span class="line-added">169         return;</span>
<span class="line-added">170     }</span>
<span class="line-added">171 </span>
<span class="line-added">172     if (printdump == JNI_TRUE) {</span>
<span class="line-added">173         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;wait_lock&#39; ...\n&quot;, thread_name);</span>
<span class="line-added">174         printf(&quot;&gt;&gt;&gt; [%s] notifying main thread we are done ...\n&quot;, thread_name);</span>
<span class="line-added">175     }</span>
<span class="line-added">176 </span>
<span class="line-added">177     err = jvmti-&gt;RawMonitorNotify(wait_lock);</span>
<span class="line-added">178     if (err != JVMTI_ERROR_NONE) {</span>
<span class="line-added">179         printf(&quot;(RawMonitorWait#wait) unexpected error: %s (%d)\n&quot;,</span>
<span class="line-added">180                TranslateError(err), err);</span>
<span class="line-added">181         result = STATUS_FAILED;</span>
<span class="line-added">182         return;</span>
<span class="line-added">183     }</span>
<span class="line-added">184     err = jvmti-&gt;RawMonitorExit(wait_lock);</span>
<span class="line-added">185     if (err != JVMTI_ERROR_NONE) {</span>
<span class="line-added">186         printf(&quot;(RawMonitorExit#wait) unexpected error: %s (%d)\n&quot;,</span>
<span class="line-added">187                TranslateError(err), err);</span>
<span class="line-added">188         result = STATUS_FAILED;</span>
<span class="line-added">189         return;</span>
<span class="line-added">190     }</span>
<span class="line-added">191 </span>
192     if (printdump == JNI_TRUE) {
193         printf(&quot;&gt;&gt;&gt; [%s] all done\n&quot;, thread_name);
194     }
195 }
196 
197 JNIEXPORT jint JNICALL
198 Java_nsk_jvmti_RawMonitorWait_rawmnwait005_check(JNIEnv *env,
199         jclass cls, jthread thr, jint wtime) {
200     jvmtiError err;
201     const char* const thread_name = &quot;main thread&quot;;
202 
203     if (!caps.can_signal_thread) {
204         return result;
205     }
206 
207     wait_time = wtime * MILLIS_PER_MINUTE;
208 
209     if (jvmti == NULL) {
210         printf(&quot;JVMTI client was not properly loaded!\n&quot;);
211         return STATUS_FAILED;
</pre>
<hr />
<pre>
239     //                     | wait_lock.enter
240     //                     | wait_lock.wait(0)
241     //    ...              |
242     //                     |  ... will wait forever ...
243     //
244     // See also 6399368 test bug.
245     //
246     err = jvmti-&gt;RawMonitorEnter(wait_lock);
247     if (err != JVMTI_ERROR_NONE) {
248         printf(&quot;(RawMonitorEnter#wait) unexpected error: %s (%d)\n&quot;,
249                TranslateError(err), err);
250         return STATUS_FAILED;
251     }
252     if (printdump == JNI_TRUE) {
253         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;wait_lock&#39; ... \n&quot;, thread_name);
254     }
255 
256     if (printdump == JNI_TRUE) {
257         printf(&quot;&gt;&gt;&gt; [%s] starting test thread ...\n&quot;, thread_name);
258     }
<span class="line-added">259 </span>
<span class="line-added">260     // This starts a daemon thread, so we need to synchronize with it</span>
<span class="line-added">261     // before we terminate - else the test will end before it checks</span>
<span class="line-added">262     // it was interrupted!</span>
<span class="line-added">263 </span>
264     err = jvmti-&gt;RunAgentThread(thr, test_thread, NULL,
265                                 JVMTI_THREAD_NORM_PRIORITY);
266     if (err != JVMTI_ERROR_NONE) {
267         printf(&quot;(RunDebugThread) unexpected error: %s (%d)\n&quot;,
268                TranslateError(err), err);
269         return STATUS_FAILED;
270     }
271 
272     if (printdump == JNI_TRUE) {
273         printf(&quot;&gt;&gt;&gt; [%s] waiting for test thread to run (do wait_lock.wait)...\n&quot;, thread_name);
274     }
275     err = jvmti-&gt;RawMonitorWait(wait_lock, (jlong)0);
276     if (err != JVMTI_ERROR_NONE) {
277         printf(&quot;(RawMonitorWait#wait) unexpected error: %s (%d)\n&quot;,
278                TranslateError(err), err);
279         return STATUS_FAILED;
280     }
281     if (printdump == JNI_TRUE) {
282         printf(&quot;&gt;&gt;&gt; [%s] got notification from test thread ...\n&quot;, thread_name);
283     }
284 
<span class="line-modified">285     // Keep the wait_lock so we can wait again at the end.</span>





286 
287     err = jvmti-&gt;RawMonitorEnter(monitor);
288     if (err != JVMTI_ERROR_NONE) {
289         printf(&quot;(RawMonitorEnter#test) unexpected error: %s (%d)\n&quot;,
290                TranslateError(err), err);
291         return STATUS_FAILED;
292     }
293     if (printdump == JNI_TRUE) {
294         printf(&quot;&gt;&gt;&gt; [%s] acquired lock for &#39;monitor&#39; ... \n&quot;, thread_name);
295     }
296 
297     if (printdump == JNI_TRUE) {
298         printf(&quot;&gt;&gt;&gt; [%s] interrupting test thread ...\n&quot;, thread_name);
299     }
300 
301     err = jvmti-&gt;InterruptThread(thr);
302     if (err != JVMTI_ERROR_NONE) {
303         printf(&quot;(InterruptThread) unexpected error: %s (%d)\n&quot;,
304                TranslateError(err), err);
305         result = STATUS_FAILED;
306     }
307 
308     err = jvmti-&gt;RawMonitorExit(monitor);
309     if (err != JVMTI_ERROR_NONE) {
310         printf(&quot;(RawMonitorExit#test) unexpected error: %s (%d)\n&quot;,
311                TranslateError(err), err);
312         result = STATUS_FAILED;
313     }
314 
<span class="line-added">315     if (printdump == JNI_TRUE) {</span>
<span class="line-added">316         printf(&quot;&gt;&gt;&gt; [%s] waiting for test thread to complete its wait and notify us ...\n&quot;, thread_name);</span>
<span class="line-added">317     }</span>
<span class="line-added">318     err = jvmti-&gt;RawMonitorWait(wait_lock, (jlong)0);</span>
<span class="line-added">319     if (err != JVMTI_ERROR_NONE) {</span>
<span class="line-added">320         printf(&quot;(RawMonitorWait#wait) unexpected error: %s (%d)\n&quot;,</span>
<span class="line-added">321                TranslateError(err), err);</span>
<span class="line-added">322         return STATUS_FAILED;</span>
<span class="line-added">323     }</span>
<span class="line-added">324     if (printdump == JNI_TRUE) {</span>
<span class="line-added">325         printf(&quot;&gt;&gt;&gt; [%s] got final notification from test thread ...\n&quot;, thread_name);</span>
<span class="line-added">326     }</span>
<span class="line-added">327 </span>
<span class="line-added">328     err = jvmti-&gt;RawMonitorExit(wait_lock);</span>
<span class="line-added">329     if (err != JVMTI_ERROR_NONE) {</span>
<span class="line-added">330         printf(&quot;(RawMonitorExit#wait) unexpected error: %s (%d)\n&quot;,</span>
<span class="line-added">331                TranslateError(err), err);</span>
<span class="line-added">332         return STATUS_FAILED;</span>
<span class="line-added">333     }</span>
<span class="line-added">334 </span>
335     if (printdump == JNI_TRUE) {
336         printf(&quot;&gt;&gt;&gt; [%s] all done\n&quot;, thread_name);
337     }
338 
339     return result;
340 }
341 
342 }
</pre>
</td>
</tr>
</table>
<center><a href="../../GetTimerInfo/timerinfo001/timerinfo001.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../RelinquishCapabilities/relcaps001/relcaps001.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
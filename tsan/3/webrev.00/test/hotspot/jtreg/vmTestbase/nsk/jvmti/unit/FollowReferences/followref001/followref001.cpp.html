<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/unit/FollowReferences/followref001/followref001.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &lt;stdint.h&gt;
 26 #include &quot;jvmti.h&quot;
 27 #include &quot;agent_common.h&quot;
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* ============================================================================= */
 34 
 35 static jlong timeout = 0;
 36 
 37 #define DEBUGEE_CLASS_NAME      &quot;nsk/jvmti/unit/FollowReferences/followref001&quot;
 38 #define ROOT_OBJECT_CLASS_NAME  &quot;nsk/jvmti/unit/FollowReferences/followref001RootTestedClass&quot;
 39 #define ROOT_OBJECT_CLASS_SIG   &quot;L&quot; ROOT_OBJECT_CLASS_NAME &quot;;&quot;
 40 #define CHAIN_OBJECT_CLASS_NAME &quot;nsk/jvmti/unit/FollowReferences/followref001TestedClass&quot;
 41 #define CHAIN_OBJECT_CLASS_SIG  &quot;L&quot; CHAIN_OBJECT_CLASS_NAME &quot;;&quot;
 42 
 43 #define OBJECT_FIELD_NAME               &quot;rootObject&quot;
 44 #define REACHABLE_CHAIN_FIELD_NAME      &quot;reachableChain&quot;
 45 #define UNREACHABLE_CHAIN_FIELD_NAME    &quot;unreachableChain&quot;
 46 #define NEXT_FIELD_NAME                 &quot;next&quot;
 47 
 48 
 49 #define DEFAULT_CHAIN_LENGTH 3
 50 #define FULL_32_BIT_MASK     0xFFFFFFFF
 51 
 52 typedef struct ObjectDescStruct {
 53     jlong tag;           /* Tag of the object */
 54     jlong exp_class_tag; /* Expected tag of the object class */
 55     jlong class_tag;     /* Reported tag of the object class */
 56     jint  exp_found;     /* Expected number of iterations through the object */
 57     jint  found;         /* Reported number of iterations through the object */
 58 } ObjectDesc;
 59 
 60 static int chainLength   = 0;
 61 static int objectsCount  = 0;
 62 static int fakeUserData  = 0;
 63 static int userDataError = 0;
 64 
 65 static ObjectDesc* objectDescList = NULL;
 66 
 67 static const jlong ROOT_CLASS_TAG   = 9;
 68 static const jlong CHAIN_CLASS_TAG  = 99;
 69 static const jlong ROOT_OBJECT_TAG  = 10;
 70 static const jlong CHAIN_OBJECT_TAG = 100;
 71 
 72 static jvmtiHeapCallbacks heapCallbacks;
 73 
 74 /* This array has to be up-to-date with the jvmtiHeapReferenceKind enum */
 75 static const char* ref_kind_str[28] = {
 76    &quot;unknown_0&quot;,
 77    &quot;JVMTI_HEAP_REFERENCE_CLASS&quot;,
 78    &quot;JVMTI_HEAP_REFERENCE_FIELD&quot;,
 79    &quot;JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT&quot;,
 80    &quot;JVMTI_HEAP_REFERENCE_CLASS_LOADER&quot;,
 81    &quot;JVMTI_HEAP_REFERENCE_SIGNERS&quot;,
 82    &quot;JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN&quot;,
 83    &quot;JVMTI_HEAP_REFERENCE_INTERFACE&quot;,
 84    &quot;JVMTI_HEAP_REFERENCE_STATIC_FIELD&quot;,
 85    &quot;JVMTI_HEAP_REFERENCE_CONSTANT_POOL&quot;,
 86    &quot;JVMTI_HEAP_REFERENCE_SUPERCLASS&quot;,
 87    &quot;unknown_11&quot;, &quot;unknown_12&quot;, &quot;unknown_13&quot;, &quot;unknown_14&quot;, &quot;unknown_15&quot;,
 88    &quot;unknown_16&quot;, &quot;unknown_17&quot;, &quot;unknown_18&quot;, &quot;unknown_19&quot;, &quot;unknown_20&quot;,
 89    &quot;JVMTI_HEAP_REFERENCE_JNI_GLOBAL&quot;,
 90    &quot;JVMTI_HEAP_REFERENCE_SYSTEM_CLASS&quot;,
 91    &quot;JVMTI_HEAP_REFERENCE_MONITOR&quot;,
 92    &quot;JVMTI_HEAP_REFERENCE_STACK_LOCAL&quot;,
 93    &quot;JVMTI_HEAP_REFERENCE_JNI_LOCAL&quot;,
 94    &quot;JVMTI_HEAP_REFERENCE_THREAD&quot;,
 95    &quot;JVMTI_HEAP_REFERENCE_OTHER&quot;
 96 };
 97 
 98 #define DEREF(ptr) (((ptr) == NULL ? 0 : *(ptr)))
 99 
100 
101 /* ============================================================================= */
102 
103 static int get_reference_index(jvmtiHeapReferenceKind   reference_kind,
104                                const jvmtiHeapReferenceInfo* reference_info) {
105     int referrer_index = 0;
106 
107     switch (reference_kind) {
108         case JVMTI_HEAP_REFERENCE_CONSTANT_POOL:
109             referrer_index = reference_info-&gt;constant_pool.index;
110             break;
111         case JVMTI_HEAP_REFERENCE_FIELD:
112         case JVMTI_HEAP_REFERENCE_STATIC_FIELD:
113             referrer_index = reference_info-&gt;field.index;
114             break;
115         case JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT:
116             referrer_index = reference_info-&gt;array.index;
117             break;
118         case JVMTI_HEAP_REFERENCE_STACK_LOCAL:
119             referrer_index = reference_info-&gt;stack_local.slot;
120             /* Fall through */
121         case JVMTI_HEAP_REFERENCE_JNI_LOCAL:
122             referrer_index |= reference_info-&gt;stack_local.depth &lt;&lt; 16;
123             break;
124         default:
125             // TODO: check that realy should be done w/ other jvmtiHeapReferenceKind
126             break;
127     }
128 
129     return referrer_index;
130 } /* get_reference_index */
131 
132 
133 /** Initialize objectDescList. */
134 static bool initObjectDescList(jvmtiEnv*    jvmti,
135                                int          chainLength,
136                                int*         objectsCount,
137                                ObjectDesc** objectDescList) {
138     /* root object + reachable and unreachable object chains */
139     *objectsCount = 1 + 2 * chainLength;
140 
141     printf(&quot;Allocate memory for objects list: %d objects\n&quot;, *objectsCount);
142     fflush(0);
143     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Allocate((*objectsCount * sizeof(ObjectDesc)),
144                                           (unsigned char**) objectDescList))) {
145         nsk_jvmti_setFailStatus();
146         return false;
147     }
148     printf(&quot;  ... allocated array: 0x%p\n&quot;, (void*)objectDescList);
149     fflush(0);
150 
151     {
152         int k;
153         for (k = 0; k &lt; *objectsCount; k++) {
154             (*objectDescList)[k].tag = 0;
155             (*objectDescList)[k].exp_class_tag = CHAIN_CLASS_TAG;
156             (*objectDescList)[k].exp_found = 0;
157             (*objectDescList)[k].found = 0;
158         }
159     }
160     (*objectDescList)[0].exp_class_tag = ROOT_CLASS_TAG;
161     (*objectDescList)[0].tag           = ROOT_OBJECT_TAG;
162 
163     /* Object with tag=100 must be referenced 2 times */
164     (*objectDescList)[chainLength].exp_found = 1;
165 
166 
167      return true;
168 } /* initObjectDescList */
169 
170 
171 /** Find and tag classes. */
172 static bool getAndTagClasses(jvmtiEnv*    jvmti,
173                              JNIEnv*      jni,
174                              jclass*      debugeeClass,
175                              jclass*      rootObjectClass,
176                              jclass*      chainObjectClass) {
177 
178     if (!NSK_JNI_VERIFY(jni, (*debugeeClass = jni-&gt;FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {
179         nsk_jvmti_setFailStatus();
180         return false;
181     }
182     printf(&quot;\nFound debugee class: 0x%p\n  %s\n&quot;,
183            (void*) *debugeeClass, DEBUGEE_CLASS_NAME);
184     fflush(0);
185 
186     if (!NSK_JNI_VERIFY(jni, (*rootObjectClass =
187             jni-&gt;FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {
188         nsk_jvmti_setFailStatus();
189         return false;
190     }
191 
192     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(*rootObjectClass, ROOT_CLASS_TAG))) {
193         nsk_jvmti_setFailStatus();
194     }
195 
196     printf(&quot;\nFound root object class: 0x%p, tag=%ld\n  %s\n&quot;,
197            (void*) *rootObjectClass,(long) ROOT_CLASS_TAG,
198            ROOT_OBJECT_CLASS_NAME);
199     fflush(0);
200 
201 
202     if (!NSK_JNI_VERIFY(jni, (*chainObjectClass =
203             jni-&gt;FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {
204         nsk_jvmti_setFailStatus();
205         return false;
206     }
207 
208     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(*chainObjectClass, CHAIN_CLASS_TAG))) {
209         nsk_jvmti_setFailStatus();
210     }
211     printf(&quot;\nFound chain object class: 0x%p, tag=%ld\n  %s\n&quot;,
212            (void*) *chainObjectClass, (long) CHAIN_CLASS_TAG,
213            CHAIN_OBJECT_CLASS_NAME);
214     fflush(0);
215 
216      return true;
217 } /* getAndTagClasses */
218 
219 
220 /** Obtain chain of tested objects and tag them recursively. */
221 static bool getFieldsAndObjects(jvmtiEnv*  jvmti,
222                                 JNIEnv*    jni,
223                                 jclass     debugeeClass,
224                                 jclass     rootObjectClass,
225                                 jclass     chainObjectClass,
226                                 jobject*   rootObjectPtr,
227                                 jfieldID*  reachableChainField,
228                                 jfieldID*  unreachableChainField,
229                                 jfieldID*  nextField) {
230     jfieldID rootObjectField = NULL;
231 
232     if (!NSK_JNI_VERIFY(jni, (rootObjectField =
233             jni-&gt;GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {
234         nsk_jvmti_setFailStatus();
235         return false;
236     }
237     printf(&quot;\nFound fieldID: 0x%p - \&#39;%s\&#39; static field in debugee class\n&quot;,
238            (void*) rootObjectField, OBJECT_FIELD_NAME);
239     fflush(0);
240 
241     if (!NSK_JNI_VERIFY(jni, (*reachableChainField =
242             jni-&gt;GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {
243         nsk_jvmti_setFailStatus();
244         return false;
245     }
246     printf(&quot;\nFound fieldID: 0x%p - \&#39;%s\&#39; field in root object class\n&quot;,
247            (void*) reachableChainField, REACHABLE_CHAIN_FIELD_NAME);
248     fflush(0);
249 
250     if (!NSK_JNI_VERIFY(jni, (*unreachableChainField =
251             jni-&gt;GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {
252         nsk_jvmti_setFailStatus();
253         return false;
254     }
255 
256     printf(&quot;\nFound fieldID: 0x%p - \&#39;%s\&#39; field in root object class\n&quot;,
257            (void*) unreachableChainField, UNREACHABLE_CHAIN_FIELD_NAME);
258     fflush(0);
259 
260     if (!NSK_JNI_VERIFY(jni, (*nextField =
261             jni-&gt;GetFieldID(chainObjectClass, NEXT_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {
262         nsk_jvmti_setFailStatus();
263         return false;
264     }
265     printf(&quot;\nFound fieldID: 0x%p - \&#39;%s\&#39; field in chain object class\n&quot;,
266            (void*) nextField, NEXT_FIELD_NAME);
267     fflush(0);
268 
269     if (!NSK_JNI_VERIFY(jni, (*rootObjectPtr =
270             jni-&gt;GetStaticObjectField(debugeeClass, rootObjectField)) != NULL)) {
271         nsk_jvmti_setFailStatus();
272         return false;
273     }
274     printf(&quot;\nFound root object: 0x%p\n&quot;, (void*) *rootObjectPtr);
275     fflush(0);
276 
277     if (!NSK_JNI_VERIFY(jni, (*rootObjectPtr = jni-&gt;NewGlobalRef(*rootObjectPtr)) != NULL)) {
278         nsk_jvmti_setFailStatus();
279         return false;
280     }
281     printf(&quot;Created root object global ref: 0x%p\n&quot;, (void*)*rootObjectPtr);
282     fflush(0);
283 
284      return true;
285 } /* getFieldsAndObjects */
286 
287 
288 /** Obtain chain of tested objects and tag them recursively. */
289 static bool getAndTagChainObjects(
290     jvmtiEnv*  jvmti,
291     JNIEnv*    jni,
292     jobject    currObj,
293     jfieldID   refField,
294     jfieldID   nextField,
295     int        count,
296     ObjectDesc objectDescList[],
297     jlong      tag,
298     bool       reachable) {
299     jobject nextObj = NULL;
300     jlong objTag = (reachable ? tag : -tag);
301 
302     if (count &lt;= 0) {
303         return true;
304     }
305 
306     count--;
307     tag++;
308 
309     if (!NSK_JNI_VERIFY(jni, (nextObj = jni-&gt;GetObjectField(currObj, refField)) != NULL)) {
310         nsk_jvmti_setFailStatus();
311         return false;
312     }
313 
314     objectDescList[count].tag = objTag;
315     if (reachable) {
316         objectDescList[count].exp_found++;
317     }
318 
319     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(nextObj, objTag))) {
320         nsk_jvmti_setFailStatus();
321     }
322     printf(&quot;        tag=%-5ld object=0x%p\n&quot;, (long)objTag, (void*)nextObj);
323     fflush(0);
324 
325     /* To continue traversing objects in the chain */
326     if (!getAndTagChainObjects(jvmti,
327                                jni,
328                                nextObj,
329                                nextField,
330                                nextField,
331                                count,
332                                objectDescList,
333                                tag,
334                                reachable)
335     ) {
336         return false;
337     }
338 
339     NSK_TRACE(jni-&gt;DeleteLocalRef(nextObj));
340 
341     return true;
342 } /* getAndTagChainObjects */
343 
344 /** Obtain all tested objects from debugee class and tag them recursively. */
345 static int getAndTagTestedObjects(
346     jvmtiEnv*    jvmti,
347     JNIEnv*      jni,
348     int          chainLength,
349     int*         objectsCount,
350     ObjectDesc** objectDescList,
351     jobject*     rootObjectPtr)
352 {
353     jclass   debugeeClass          = NULL;
354     jclass   rootObjectClass       = NULL;
355     jclass   chainObjectClass      = NULL;
356 
357     jfieldID reachableChainField   = NULL;
358     jfieldID unreachableChainField = NULL;
359     jfieldID nextField             = NULL;
360 
361     if (!initObjectDescList(jvmti,
362                             chainLength,
363                             objectsCount,
364                             objectDescList)) {
365         return false;
366     }
367 
368     if (!getAndTagClasses(jvmti,
369                           jni,
370                           &amp;debugeeClass,
371                           &amp;rootObjectClass,
372                           &amp;chainObjectClass)) {
373         return false;
374     }
375 
376     if (!getFieldsAndObjects(jvmti,
377                              jni,
378                              debugeeClass,
379                              rootObjectClass,
380                              chainObjectClass,
381                              rootObjectPtr,
382                              &amp;reachableChainField,
383                              &amp;unreachableChainField,
384                              &amp;nextField)) {
385         return false;
386     }
387 
388     printf(&quot;\nObtain and tag chain objects:\n&quot;);
389     printf(&quot;    root tested object:\n&quot;);
390 
391     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetTag(*rootObjectPtr, ROOT_OBJECT_TAG))
392     ) {
393         nsk_jvmti_setFailStatus();
394     }
395     printf(&quot;        tag=%-5ld  object = 0x%p\n&quot;,
396            (long) ROOT_OBJECT_TAG, (void*) *rootObjectPtr);
397 
398     printf(&quot;    reachable objects chain: %d objects\n&quot;, chainLength);
399     fflush(0);
400 
401     if (!getAndTagChainObjects(jvmti,
402                                jni,
403                                *rootObjectPtr,
404                                reachableChainField,
405                                nextField,
406                                chainLength,
407                                (*objectDescList) + 1,
408                                CHAIN_OBJECT_TAG,
409                                true)  /* reachable objects */
410     ) {
411         nsk_jvmti_setFailStatus();
412         return false;
413     }
414 
415     printf(&quot;    unreachable objects chain: %d objects\n&quot;, chainLength);
416     if (!getAndTagChainObjects(jvmti,
417                                jni,
418                                *rootObjectPtr,
419                                unreachableChainField,
420                                nextField,
421                                chainLength,
422                                (*objectDescList) + 1 + chainLength,
423                                CHAIN_OBJECT_TAG,
424                                false) /* unreachable objects */
425     ) {
426         nsk_jvmti_setFailStatus();
427         return false;
428     }
429 
430     return true;
431 } /* getAndTagTestedObjects */
432 
433 /** Check if tagged objects were iterated. */
434 static bool checkTestedObjects(jvmtiEnv*  jvmti,
435                                JNIEnv*    jni,
436                                int        chainLength,
437                                ObjectDesc objectDescList[])
438 {
439     bool success = true;
440     int i, idx;
441 
442     printf(&quot;Following tagged objects were iterated:\n&quot;);
443 
444     printf(&quot;Root tested object:\n&quot;);
445     printf(&quot;   tag:                 %ld\n&quot;
446            &quot;   expected to iterate: %d times\n&quot;
447            &quot;   iterated:            %d times\n&quot;,
448            (long) objectDescList[0].tag,
449                   objectDescList[0].exp_found,
450                   objectDescList[0].found);
451     if (objectDescList[0].found != objectDescList[0].exp_found) {
452         NSK_COMPLAIN1(&quot;Root tested object unexpectedly iterated %d times\n&quot;,
453                       objectDescList[0].found);
454         nsk_jvmti_setFailStatus();
455     }
456 
457     printf(&quot;\nReachable objects:\n&quot;);
458     fflush(0);
459     for (i = 0; i &lt; chainLength; i++) {
460         idx = i + 1;
461         printf(&quot;Reachable object:\n&quot;
462                &quot;   tag:                 %-3ld\n&quot;
463                &quot;   expected to iterate: %d times\n&quot;
464                &quot;   iterated:            %d times\n&quot;,
465                 (long) objectDescList[idx].tag,
466                        objectDescList[idx].exp_found,
467                        objectDescList[idx].found);
468         if (objectDescList[i + 1].found &lt;= 0) {
469             NSK_COMPLAIN0(&quot;Reachable object was not iterated\n&quot;);
470             nsk_jvmti_setFailStatus();
471         }
472         if (objectDescList[idx].found != objectDescList[idx].exp_found) {
473             NSK_COMPLAIN0(&quot;Reachable object was iterated unexpected number of times\n&quot;);
474             nsk_jvmti_setFailStatus();
475         }
476     }
477 
478     printf(&quot;\nUnreachable objects:\n&quot;);
479     for (i = 0; i &lt; chainLength; i++) {
480         idx = i + 1 + chainLength;
481 
482         printf(&quot;Unreachable object:\n&quot;
483                &quot;   tag:                 %ld\n&quot;
484                &quot;   expected to iterate: %d times\n&quot;
485                &quot;   iterated:            %d times\n&quot;,
486                 (long) objectDescList[idx].tag,
487                        objectDescList[idx].exp_found,
488                        objectDescList[idx].found);
489         if (objectDescList[idx].found &gt; 0) {
490             NSK_COMPLAIN0(&quot;Unreachable object was iterated\n&quot;);
491             nsk_jvmti_setFailStatus();
492         }
493         fflush(0);
494     }
495 
496     return true;
497 } /* checkTestedObjects */
498 
499 
500 /** Release references to the tested objects and free allocated memory. */
501 static void releaseTestedObjects(jvmtiEnv*   jvmti,
502                                  JNIEnv*     jni,
503                                  int         chainLength,
504                                  ObjectDesc* objectDescList,
505                                  jobject     rootObject)
506 {
507     if (rootObject != NULL) {
508         printf(&quot;Release object reference to root tested object: 0x%p\n&quot;, rootObject);
509         NSK_TRACE(jni-&gt;DeleteGlobalRef(rootObject));
510     }
511 
512     if (objectDescList != NULL) {
513         printf(&quot;Deallocate objects list: 0x%p\n&quot;, (void*)objectDescList);
514         if (!NSK_JVMTI_VERIFY(jvmti-&gt;Deallocate((unsigned char*)objectDescList))) {
515             nsk_jvmti_setFailStatus();
516         }
517     }
518 
519     fflush(0);
520 } /* releaseTestedObjects */
521 
522 
523 /* ============================================================================= */
524 
525 /** heapReferenceCallback for heap iterator. */
526 jint JNICALL heapReferenceCallback(
527      jvmtiHeapReferenceKind        reference_kind,
528      const jvmtiHeapReferenceInfo* reference_info,
529      jlong                         class_tag,
530      jlong                         referrer_class_tag,
531      jlong                         size,
532      jlong*                        tag_ptr,
533      jlong*                        referrer_tag_ptr,
534      jint                          length,
535      void*                         user_data)
536 {
537     jint referrer_index = 0;
538     jlong tag;
539     jlong ref_tag;
540 
541     printf(&quot; heapReferenceCallback: %s\n&quot;, ref_kind_str[reference_kind]);
542     printf(&quot;   reference_info: 0x%p, class_tag: 0x%&quot; LL &quot;d, referrer_class_tag: 0x%&quot; LL &quot;d\n&quot;,
543                reference_info,       class_tag,           referrer_class_tag);
544                           /* ss45998: class_tag=&gt;referrence_class_tag */
545     printf(&quot;   size: %&quot; LL &quot;d, tag_ptr: 0x%p, referrer_tag_ptr: 0x%p, length: %-d\n&quot;,
546                size,         tag_ptr,       referrer_tag_ptr,       length);
547     fflush(0);
548 
549     if (((uintptr_t) tag_ptr &amp; FULL_32_BIT_MASK) == FULL_32_BIT_MASK) {
550         NSK_COMPLAIN1(&quot;wrong tag_ptr passed to &quot;
551                       &quot;heapReferenceCallback: %#lx\n&quot;, tag_ptr);
552         nsk_jvmti_setFailStatus();
553         tag = 0;
554     } else {
555         tag = DEREF(tag_ptr);
556     }
557 
558     if (((uintptr_t) referrer_tag_ptr &amp; FULL_32_BIT_MASK) == FULL_32_BIT_MASK) {
559         NSK_COMPLAIN1(&quot;wrong referrer_tag_ptr passed to &quot;
560                       &quot;heapReferenceCallback: %#lx\n&quot;, referrer_tag_ptr);
561         nsk_jvmti_setFailStatus();
562         ref_tag = 0;
563     } else {
564         ref_tag = DEREF(referrer_tag_ptr);
565     }
566 
567     referrer_index = get_reference_index(reference_kind, reference_info);
568 
569     printf(&quot;   class_tag=%&quot; LL &quot;d, tag=%&quot; LL &quot;d, size=%&quot; LL &quot;d,&quot;
570            &quot; ref_tag=%&quot; LL &quot;d, referrer_index=%d\n\n&quot;,
571                class_tag, tag, size, ref_tag, referrer_index);
572     fflush(0);
573 
574     if (length != -1) {
575         NSK_COMPLAIN1(&quot;wrong length passed to heapReferenceCallback: &quot;
576                       &quot;%d; must be: -1\n&quot;, length);
577         nsk_jvmti_setFailStatus();
578     }
579 
580     if (tag_ptr != NULL &amp;&amp; *tag_ptr != 0) {
581         int found = 0;
582         int i;
583 
584         for (i = 0; i &lt; objectsCount; i++) {
585             if (*tag_ptr == objectDescList[i].tag) {
586                 found++;
587                 objectDescList[i].found++;
588 
589                 if (*tag_ptr &lt; 0) {
590                     NSK_COMPLAIN0(&quot;Unreachable tagged object is passed&quot;
591                                   &quot; to heapReferenceCallback\n&quot;);
592                     nsk_jvmti_setFailStatus();
593                 }
594                 break;
595             }
596         }
597 
598         if (reference_kind != JVMTI_HEAP_REFERENCE_CLASS &amp;&amp; found &lt;= 0) {
599             NSK_COMPLAIN0(&quot;Unknown tagged object is passed&quot;
600                           &quot; to heapReferenceCallback\n&quot;);
601             nsk_jvmti_setFailStatus();
602         }
603     }
604 
605     if (user_data != &amp;fakeUserData &amp;&amp; !userDataError) {
606        NSK_COMPLAIN2(&quot;Unexpected user_data is passed&quot;
607                      &quot; to heapReferenceCallback:\n&quot;
608                       &quot;   expected:       0x%p\n&quot;
609                       &quot;   actual:         0x%p\n&quot;,
610                       user_data,
611                       &amp;fakeUserData);
612         nsk_jvmti_setFailStatus();
613         userDataError++;
614     }
615 
616     switch (reference_kind) {
617         int i;
618         case JVMTI_HEAP_REFERENCE_CLASS: {
619             if (tag == 0) {
620                 return 0;
621             }
622             if (tag != ROOT_CLASS_TAG &amp;&amp; tag != CHAIN_CLASS_TAG) {
623                 NSK_COMPLAIN0(&quot;Unknown tagged class is passed&quot;
624                               &quot; to heapReferenceCallback\n&quot;);
625                 nsk_jvmti_setFailStatus();
626             }
627             for (i = 0; i &lt; objectsCount; i++) {
628                if (ref_tag == objectDescList[i].tag) {
629                    if (objectDescList[i].exp_class_tag != tag) {
630                        NSK_COMPLAIN2(&quot;Wrong tag in heapReferenceCallback&quot;
631                                      &quot;/JVMTI_HEAP_REFERENCE_CLASS:\n&quot;
632                                      &quot;Expected: %-3ld\n&quot;
633                                      &quot;Passed:   %-3ld\n&quot;,
634                                       objectDescList[i].exp_class_tag,
635                                       tag);
636                        nsk_jvmti_setFailStatus();
637                    }
638                    break;
639                }
640             }
641             return 0;
642         }
643         case JVMTI_HEAP_REFERENCE_JNI_GLOBAL:
644         case JVMTI_HEAP_REFERENCE_SYSTEM_CLASS:
645         case JVMTI_HEAP_REFERENCE_MONITOR:
646         case JVMTI_HEAP_REFERENCE_STACK_LOCAL:
647         case JVMTI_HEAP_REFERENCE_JNI_LOCAL:
648         case JVMTI_HEAP_REFERENCE_THREAD:
649         case JVMTI_HEAP_REFERENCE_OTHER: {
650             NSK_COMPLAIN1(&quot;This reference kind was not expected: %s\n&quot;,
651                            ref_kind_str[reference_kind]);
652             fflush(0);
653             nsk_jvmti_setFailStatus();
654             return 0;
655         }
656         default:
657             // TODO: check that realy should be done w/ other jvmtiHeapReferenceKind
658             break;
659     }
660     return JVMTI_VISIT_OBJECTS;
661 } /* heapReferenceCallback */
662 
663 
664 jint JNICALL primitiveFieldCallback(
665      jvmtiHeapReferenceKind        reference_kind,
666      const jvmtiHeapReferenceInfo* reference_info,
667      jlong                         class_tag,
668      jlong*                        tag_ptr,
669      jvalue                        value,
670      jvmtiPrimitiveType            value_type,
671      void*                         user_data)
672 {
673     printf(&quot; primitiveFieldCallback: ref=%s,&quot;
674                &quot; class_tag=%-3ld, tag=%-3ld, type=%c\n&quot;,
675                ref_kind_str[reference_kind],
676                (long) class_tag,
677                (long) DEREF(tag_ptr),
678                (int) value_type);
679     fflush(0);
680     return 0;
681 } /* primitiveFieldCallback */
682 
683 
684 jint JNICALL arrayPrimitiveValueCallback(
685      jlong              class_tag,
686      jlong              size,
687      jlong*             tag_ptr,
688      jint               element_count,
689      jvmtiPrimitiveType element_type,
690      const void*        elements,
691      void*              user_data)
692 {
693     printf(&quot; arrayPrimitiveValueCallback: class_tag=%-3ld,&quot;
694            &quot; tag=%-3ld, len=%d, type=%c\n&quot;,
695            (long) class_tag,
696            (long) DEREF(tag_ptr),
697            (int) element_count,
698            (int) element_type);
699     fflush(0);
700     return 0;
701 } /* arrayPrimitiveValueCallback */
702 
703 
704 jint JNICALL stringPrimitiveValueCallback(
705      jlong        class_tag,
706      jlong        size,
707      jlong*       tag_ptr,
708      const jchar* value,
709      jint         value_length,
710      void*        user_data)
711 {
712     printf(&quot;stringPrimitiveValueCallback: class_tag=%-3ld, tag=%-3ld, len=%d\n&quot;,
713            (long) class_tag,
714            (long) DEREF(tag_ptr),
715            (int) value_length);
716     fflush(0);
717     return 0;
718 } /* stringPrimitiveValueCallback */
719 
720 
721 
722 /* ============================================================================= */
723 
724 /** Agent algorithm. */
725 static void JNICALL
726 agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {
727     jobject rootObject = NULL;
728 
729     printf(&quot;Wait for tested objects created\n&quot;);
730     fflush(0);
731     if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout))) {
732         return;
733     }
734 
735 
736     printf(&quot;&gt;&gt;&gt; Obtain and tag tested objects from debugee class\n&quot;);
737     fflush(0);
738 
739     if (!NSK_VERIFY(getAndTagTestedObjects(jvmti,
740                                            jni,
741                                            chainLength,
742                                            &amp;objectsCount,
743                                            &amp;objectDescList,
744                                            &amp;rootObject))
745     ) {
746         return;
747     }
748 
749     printf(&quot;&gt;&gt;&gt; Let debugee to clean links to unreachable objects\n&quot;);
750     fflush(0);
751 
752     if (!NSK_VERIFY(nsk_jvmti_resumeSync())) {
753         return;
754     }
755     if (!NSK_VERIFY(nsk_jvmti_waitForSync(timeout))) {
756         return;
757     }
758 
759     printf(&quot;&gt;&gt;&gt; Start iteration from root tested object: 0x%p\n\n&quot;, rootObject);
760     fflush(0);
761 
762     if (!NSK_JVMTI_VERIFY(jvmti-&gt;FollowReferences((jint)   0,    /* heap_filter    */
763                                                   (jclass) NULL, /* class          */
764                                                   rootObject,    /* initial_object */
765                                                   &amp;heapCallbacks,
766                                                   (const void *) &amp;fakeUserData))) {
767          nsk_jvmti_setFailStatus();
768          return;
769     }
770 
771     printf(&quot;&gt;&gt;&gt; Check if reachable objects were iterated:\n&quot;);
772     fflush(0);
773 
774     if (!checkTestedObjects(jvmti, jni, chainLength, objectDescList)) {
775         nsk_jvmti_setFailStatus();
776     }
777 
778     printf(&quot;&gt;&gt;&gt; Clean used data\n&quot;);
779     fflush(0);
780 
781     releaseTestedObjects(jvmti, jni, chainLength, objectDescList, rootObject);
782 
783     printf(&quot;&gt;&gt;&gt; Let debugee to finish\n&quot;);
784     fflush(0);
785     if (!NSK_VERIFY(nsk_jvmti_resumeSync())) {
786         return;
787     }
788 } /* agentProc */
789 
790 
791 /* ============================================================================= */
792 
793 /** Agent library initialization. */
794 #ifdef STATIC_BUILD
795 JNIEXPORT jint JNICALL Agent_OnLoad_followref001(JavaVM *jvm, char *options, void *reserved) {
796     return Agent_Initialize(jvm, options, reserved);
797 }
798 JNIEXPORT jint JNICALL Agent_OnAttach_followref001(JavaVM *jvm, char *options, void *reserved) {
799     return Agent_Initialize(jvm, options, reserved);
800 }
801 JNIEXPORT jint JNI_OnLoad_followref001(JavaVM *jvm, char *options, void *reserved) {
802     return JNI_VERSION_1_8;
803 }
804 #endif
805 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
806     jvmtiEnv* jvmti = NULL;
807 
808     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options))) {
809         return JNI_ERR;
810     }
811     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
812 
813     chainLength = nsk_jvmti_findOptionIntValue(&quot;objects&quot;, DEFAULT_CHAIN_LENGTH);
814     if (!NSK_VERIFY(chainLength &gt; 0))
815         return JNI_ERR;
816 
817     if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL)) {
818         return JNI_ERR;
819     }
820 
821     {
822         jvmtiCapabilities caps;
823 
824         memset(&amp;caps, 0, sizeof(caps));
825         caps.can_tag_objects = 1;
826         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps))) {
827             return JNI_ERR;
828         }
829     }
830 
831     /* Setting Heap Callbacks */
832     heapCallbacks.heap_iteration_callback         = NULL;
833     heapCallbacks.heap_reference_callback         = heapReferenceCallback;
834     heapCallbacks.primitive_field_callback        = primitiveFieldCallback;
835     heapCallbacks.array_primitive_value_callback  = arrayPrimitiveValueCallback;
836     heapCallbacks.string_primitive_value_callback = stringPrimitiveValueCallback;
837 
838     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL))) {
839         return JNI_ERR;
840     }
841 
842     return JNI_OK;
843 } /* Agent_OnLoad */
844 
845 
846 /* ============================================================================= */
847 
848 }
    </pre>
  </body>
</html>
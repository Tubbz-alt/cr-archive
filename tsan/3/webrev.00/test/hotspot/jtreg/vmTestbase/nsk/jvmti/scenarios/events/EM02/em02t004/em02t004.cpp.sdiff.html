<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t004/em02t004.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../em02t003/em02t003.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../em02t005/em02t005.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t004/em02t004.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 65 
 66 static void
 67 showEventStatistics(int step) {
 68     int i;
 69     const char* str;
 70     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 71 
 72     NSK_DISPLAY0(&quot;\n&quot;);
 73     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 74     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 75     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 76         if (currentCounts[i] &gt; 0) {
 77             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 78             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 79         }
 80     }
 81 }
 82 
 83 /* ========================================================================== */
 84 
<span class="line-modified"> 85 int checkEvents(int step) {</span>
 86     int i;
 87     jvmtiEvent curr;
<span class="line-modified"> 88     int result = NSK_TRUE;</span>
 89     int *currentCounts;
 90     int isExpected = 0;
 91 
 92     switch (step) {
 93         case 1:
 94             currentCounts = &amp;eventCount[0];
 95             break;
 96 
 97         case 2:
 98         case 3:
 99             currentCounts = &amp;newEventCount[0];
100             break;
101 
102         default:
103             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified">104             return NSK_FALSE;</span>
105     }
106 
107     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
108 
109         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
110 
111         switch (step) {
112             case 1:
113                 isExpected = ((curr == JVMTI_EVENT_NATIVE_METHOD_BIND)
114                                 || (curr == JVMTI_EVENT_VM_INIT));
115                 break;
116 
117             case 2:
118                 isExpected = ((curr == JVMTI_EVENT_NATIVE_METHOD_BIND));
119                 break;
120 
121             case 3:
122                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
123                 break;
124         }
125 
126         if (isExpected) {
127             if (currentCounts[i] &lt; 1) {
128                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
129                                         currentCounts[i],
130                                         TranslateEvent(curr));
<span class="line-modified">131                 result = NSK_FALSE;</span>
132             }
133         } else {
134             if (currentCounts[i] &gt; 0) {
135                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
136                                     TranslateEvent(curr),
137                                     currentCounts[i]);
<span class="line-modified">138                 result = NSK_FALSE;</span>
139             }
140         }
141     }
142 
143     return result;
144 }
145 
146 static void
147 changeCount(jvmtiEvent event, int *currentCounts) {
148 
149     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
150         nsk_jvmti_setFailStatus();
151 
152     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
153 
154     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
155         nsk_jvmti_setFailStatus();
156 
157 }
158 
</pre>
<hr />
<pre>
365         NSK_DISPLAY0(&quot;NATIVE_METHOD_BIND recieved for\n&quot;);
366         NSK_DISPLAY4(&quot;\tmethod: %s, signature: %s address: %p new_address: %p\n&quot;,
367                             name, sign, address, new_address_ptr);
368         changeCount(JVMTI_EVENT_NATIVE_METHOD_BIND, &amp;newEventCount[0]);
369     }
370 
371     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)name))) {
372         nsk_jvmti_setFailStatus();
373     }
374     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)sign))) {
375         nsk_jvmti_setFailStatus();
376     }
377     if (genc != NULL)
378         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)genc))) {
379             nsk_jvmti_setFailStatus();
380         }
381 }
382 
383 /* ============================================================================= */
384 
<span class="line-modified">385 static int enableEvent(jvmtiEvent event) {</span>
386 
387     if (nsk_jvmti_isOptionalEvent(event)
388             &amp;&amp; (event != JVMTI_EVENT_NATIVE_METHOD_BIND)) {
389         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
390                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
391             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
392                 TranslateEvent(event));
<span class="line-modified">393             return NSK_FALSE;</span>
394         }
395     } else {
396         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
397             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
398                 TranslateEvent(event));
<span class="line-modified">399             return NSK_FALSE;</span>
400         }
401     }
402 
<span class="line-modified">403     return NSK_TRUE;</span>
404 }
405 
406 /**
407  * Enable or disable tested events.
408  */
<span class="line-modified">409 static int enableEventList() {</span>
410     int i;
<span class="line-modified">411     int result = NSK_TRUE;</span>
412 
413     NSK_DISPLAY0(&quot;Enable events\n&quot;);
414 
415     result = enableEvent(JVMTI_EVENT_VM_INIT);
416 
417     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
418 
419     /* enabling optional events */
420     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
421         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
422 
423         if (nsk_jvmti_isOptionalEvent(event))
424             result = result &amp;&amp; enableEvent(event);
425     }
426 
<span class="line-modified">427     if (result == NSK_FALSE) {</span>
428         nsk_jvmti_setFailStatus();
<span class="line-modified">429         return NSK_FALSE;</span>
430     }
431 
<span class="line-modified">432     return NSK_TRUE;</span>
433 }
434 
435 /* ============================================================================= */
436 
<span class="line-modified">437 static int</span>
<span class="line-removed">438 setCallBacks(int step) {</span>
439 
440     int i;
441 
442     jvmtiEventCallbacks eventCallbacks;
443     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
444 
445     NSK_DISPLAY0(&quot;\n&quot;);
446     NSK_DISPLAY1(&quot;===============step %d===============\n&quot;, step);
447     NSK_DISPLAY0(&quot;\n&quot;);
448     switch (step) {
449         case 1:
450             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
451                 eventCount[i] = 0;
452             }
453 
454             eventCallbacks.VMInit                    = cbVMInit;
455             eventCallbacks.Exception                 = cbException;
456             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
457             eventCallbacks.SingleStep                = cbSingleStep;
458             eventCallbacks.FramePop                  = cbFramePop;
</pre>
<hr />
<pre>
475             break;
476 
477         case 2:
478             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
479                 newEventCount[i] = 0;
480             }
481 
482             eventCallbacks.NativeMethodBind = cbNewNativeMethodBind;
483             break;
484 
485         case 3:
486             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
487                 newEventCount[i] = 0;
488             }
489 
490             eventCallbacks.VMDeath                   = cbVMDeath;
491             break;
492 
493     }
494     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">495         return NSK_FALSE;</span>
496 
<span class="line-modified">497     return NSK_TRUE;</span>
498 }
499 
500 /* ============================================================================= */
501 
502 /** Agent algorithm. */
503 static void JNICALL
504 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
505 
506     int i;
507 
508     for (i = 1; i &lt;= STEP_AMOUNT; i++) {
509         if (i &gt; 1) {
510             NSK_DISPLAY0(&quot;Check received events\n&quot;);
511 
512             showEventStatistics(i-1);
513             if (!checkEvents(i-1))
514                 nsk_jvmti_setFailStatus();
515 
516             if (!setCallBacks(i)) {
517                 return;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 65 
 66 static void
 67 showEventStatistics(int step) {
 68     int i;
 69     const char* str;
 70     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 71 
 72     NSK_DISPLAY0(&quot;\n&quot;);
 73     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 74     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 75     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 76         if (currentCounts[i] &gt; 0) {
 77             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 78             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 79         }
 80     }
 81 }
 82 
 83 /* ========================================================================== */
 84 
<span class="line-modified"> 85 bool checkEvents(int step) {</span>
 86     int i;
 87     jvmtiEvent curr;
<span class="line-modified"> 88     bool result = true;</span>
 89     int *currentCounts;
 90     int isExpected = 0;
 91 
 92     switch (step) {
 93         case 1:
 94             currentCounts = &amp;eventCount[0];
 95             break;
 96 
 97         case 2:
 98         case 3:
 99             currentCounts = &amp;newEventCount[0];
100             break;
101 
102         default:
103             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
<span class="line-modified">104             return false;</span>
105     }
106 
107     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
108 
109         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
110 
111         switch (step) {
112             case 1:
113                 isExpected = ((curr == JVMTI_EVENT_NATIVE_METHOD_BIND)
114                                 || (curr == JVMTI_EVENT_VM_INIT));
115                 break;
116 
117             case 2:
118                 isExpected = ((curr == JVMTI_EVENT_NATIVE_METHOD_BIND));
119                 break;
120 
121             case 3:
122                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
123                 break;
124         }
125 
126         if (isExpected) {
127             if (currentCounts[i] &lt; 1) {
128                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
129                                         currentCounts[i],
130                                         TranslateEvent(curr));
<span class="line-modified">131                 result = false;</span>
132             }
133         } else {
134             if (currentCounts[i] &gt; 0) {
135                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
136                                     TranslateEvent(curr),
137                                     currentCounts[i]);
<span class="line-modified">138                 result = false;</span>
139             }
140         }
141     }
142 
143     return result;
144 }
145 
146 static void
147 changeCount(jvmtiEvent event, int *currentCounts) {
148 
149     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
150         nsk_jvmti_setFailStatus();
151 
152     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
153 
154     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
155         nsk_jvmti_setFailStatus();
156 
157 }
158 
</pre>
<hr />
<pre>
365         NSK_DISPLAY0(&quot;NATIVE_METHOD_BIND recieved for\n&quot;);
366         NSK_DISPLAY4(&quot;\tmethod: %s, signature: %s address: %p new_address: %p\n&quot;,
367                             name, sign, address, new_address_ptr);
368         changeCount(JVMTI_EVENT_NATIVE_METHOD_BIND, &amp;newEventCount[0]);
369     }
370 
371     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)name))) {
372         nsk_jvmti_setFailStatus();
373     }
374     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)sign))) {
375         nsk_jvmti_setFailStatus();
376     }
377     if (genc != NULL)
378         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)genc))) {
379             nsk_jvmti_setFailStatus();
380         }
381 }
382 
383 /* ============================================================================= */
384 
<span class="line-modified">385 static bool enableEvent(jvmtiEvent event) {</span>
386 
387     if (nsk_jvmti_isOptionalEvent(event)
388             &amp;&amp; (event != JVMTI_EVENT_NATIVE_METHOD_BIND)) {
389         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
390                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
391             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
392                 TranslateEvent(event));
<span class="line-modified">393             return false;</span>
394         }
395     } else {
396         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
397             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
398                 TranslateEvent(event));
<span class="line-modified">399             return false;</span>
400         }
401     }
402 
<span class="line-modified">403     return true;</span>
404 }
405 
406 /**
407  * Enable or disable tested events.
408  */
<span class="line-modified">409 static bool enableEventList() {</span>
410     int i;
<span class="line-modified">411     bool result = true;</span>
412 
413     NSK_DISPLAY0(&quot;Enable events\n&quot;);
414 
415     result = enableEvent(JVMTI_EVENT_VM_INIT);
416 
417     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
418 
419     /* enabling optional events */
420     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
421         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
422 
423         if (nsk_jvmti_isOptionalEvent(event))
424             result = result &amp;&amp; enableEvent(event);
425     }
426 
<span class="line-modified">427     if (!result) {</span>
428         nsk_jvmti_setFailStatus();
<span class="line-modified">429         return false;</span>
430     }
431 
<span class="line-modified">432     return true;</span>
433 }
434 
435 /* ============================================================================= */
436 
<span class="line-modified">437 static bool setCallBacks(int step) {</span>

438 
439     int i;
440 
441     jvmtiEventCallbacks eventCallbacks;
442     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
443 
444     NSK_DISPLAY0(&quot;\n&quot;);
445     NSK_DISPLAY1(&quot;===============step %d===============\n&quot;, step);
446     NSK_DISPLAY0(&quot;\n&quot;);
447     switch (step) {
448         case 1:
449             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
450                 eventCount[i] = 0;
451             }
452 
453             eventCallbacks.VMInit                    = cbVMInit;
454             eventCallbacks.Exception                 = cbException;
455             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
456             eventCallbacks.SingleStep                = cbSingleStep;
457             eventCallbacks.FramePop                  = cbFramePop;
</pre>
<hr />
<pre>
474             break;
475 
476         case 2:
477             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
478                 newEventCount[i] = 0;
479             }
480 
481             eventCallbacks.NativeMethodBind = cbNewNativeMethodBind;
482             break;
483 
484         case 3:
485             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
486                 newEventCount[i] = 0;
487             }
488 
489             eventCallbacks.VMDeath                   = cbVMDeath;
490             break;
491 
492     }
493     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
<span class="line-modified">494         return false;</span>
495 
<span class="line-modified">496     return true;</span>
497 }
498 
499 /* ============================================================================= */
500 
501 /** Agent algorithm. */
502 static void JNICALL
503 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
504 
505     int i;
506 
507     for (i = 1; i &lt;= STEP_AMOUNT; i++) {
508         if (i &gt; 1) {
509             NSK_DISPLAY0(&quot;Check received events\n&quot;);
510 
511             showEventStatistics(i-1);
512             if (!checkEvents(i-1))
513                 nsk_jvmti_setFailStatus();
514 
515             if (!setCallBacks(i)) {
516                 return;
</pre>
</td>
</tr>
</table>
<center><a href="../em02t003/em02t003.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../em02t005/em02t005.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
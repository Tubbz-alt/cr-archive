<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/bcinstr/BI01/bi01t002/bi01t002.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
 27 #include &quot;ExceptionCheckingJniEnv.hpp&quot;
 28 #include &quot;jni_tools.h&quot;
 29 #include &quot;jvmti_tools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* scaffold objects */
 34 static jvmtiEnv *jvmti = NULL;
 35 static jlong timeout = 0;
 36 
 37 #define TESTED_CLASS_NAME   &quot;nsk/jvmti/scenarios/bcinstr/BI01/bi01t002a&quot;
 38 #define TOTAL_INSTRUMENTED_CLASSES 2
 39 
 40 static int clsLoadedIdx=0;
 41 static jint newClassSize[TOTAL_INSTRUMENTED_CLASSES];
 42 static unsigned char* newClassBytes[TOTAL_INSTRUMENTED_CLASSES];
 43 static jvmtiClassDefinition oldClassDef[TOTAL_INSTRUMENTED_CLASSES];
 44 
 45 /* ============================================================================= */
 46 /*
 47  * Class:     nsk_jvmti_scenarios_bcinstr_BI01_bi01t002
 48  * Method:    setNewByteCode
 49  * Signature: (I[B)Z
 50  */
 51 JNIEXPORT jboolean JNICALL
 52 Java_nsk_jvmti_scenarios_bcinstr_BI01_bi01t002_setNewByteCode(JNIEnv *jni_env,
 53                         jobject o, jint ind, jbyteArray byteCode) {
 54 
 55     ExceptionCheckingJniEnvPtr ec_jni(jni_env);
 56     jbyte* elements;
 57     jboolean isCopy;
 58 
 59     newClassSize[ind] = ec_jni-&gt;GetArrayLength(byteCode, TRACE_JNI_CALL);
 60     if (!NSK_VERIFY(newClassSize[ind] &gt; 0)) {
 61         nsk_jvmti_setFailStatus();
 62         return NSK_FALSE;
 63     }
 64     NSK_DISPLAY1(&quot;\t... got array size: %d\n&quot;, newClassSize[ind]);
 65 
 66     elements = ec_jni-&gt;GetByteArrayElements(byteCode, &amp;isCopy, TRACE_JNI_CALL);
 67     NSK_DISPLAY1(&quot;\t... got elements list: 0x%p\n&quot;, (void*)elements);
 68 
 69     if (!NSK_JVMTI_VERIFY(jvmti-&gt;Allocate(newClassSize[ind], &amp;newClassBytes[ind]))) {
 70         nsk_jvmti_setFailStatus();
 71         return NSK_FALSE;
 72     }
 73     NSK_DISPLAY1(&quot;\t... created bytes array: 0x%p\n&quot;, (void*)newClassBytes[ind]);
 74 
 75     {
 76         int j;
 77         for (j = 0; j &lt; newClassSize[ind]; j++)
 78             newClassBytes[ind][j] = (unsigned char)elements[j];
 79     }
 80     NSK_DISPLAY1(&quot;\t... copied bytecode: %d bytes\n&quot;, (int)newClassSize[ind]);
 81 
 82     NSK_DISPLAY1(&quot;\t... release elements list: 0x%p\n&quot;, (void*)elements);
 83     NSK_TRACE(ec_jni-&gt;ReleaseByteArrayElements(byteCode, elements, JNI_ABORT, TRACE_JNI_CALL));
 84     NSK_DISPLAY0(&quot;\t... released\n&quot;);
 85     return NSK_TRUE;
 86 }
 87 
 88 /* ============================================================================= */
 89 /*
 90  * Class:     nsk_jvmti_scenarios_bcinstr_BI01_bi01t002
 91  * Method:    setClass
 92  * Signature: (ILjava/lang/Class;)V
 93  */
 94 JNIEXPORT void JNICALL
 95 Java_nsk_jvmti_scenarios_bcinstr_BI01_bi01t002_setClass(JNIEnv *jni_env,
 96                         jobject o, jint ind, jclass cls) {
 97 
 98     ExceptionCheckingJniEnvPtr ec_jni(jni_env);
 99     oldClassDef[ind].klass = (jclass) ec_jni-&gt;NewGlobalRef(cls, TRACE_JNI_CALL);
100 }
101 
102 /* ============================================================================= */
103 
104 /** Callback function for ClassFileLoadHook event. */
105 JNIEXPORT void JNICALL
106 cbClassFileLoadHook(jvmtiEnv *jvmti_env, JNIEnv* jni_env,
107             jclass class_being_redefined, jobject loader, const char* name,
108             jobject protection_domain, jint class_data_len,
109             const unsigned char* class_data, jint* new_class_data_len,
110             unsigned char** new_class_data) {
111 
112     if (name == NULL || strcmp(name, TESTED_CLASS_NAME)) {
113         return;
114     }
115 
116     NSK_DISPLAY3(&quot;CLASS_FILE_LOAD_HOOK event: %s\n\treceived bytecode: 0x%p:%d\n&quot;,
117                         name, (void *)class_data, class_data_len);
118     if (nsk_getVerboseMode()) {
119         nsk_printHexBytes(&quot;   &quot;, 16, class_data_len, class_data);
120     }
121 
122     {
123         /*store original byte code, it will be used to do final redefinition*/
124         int j;
125         unsigned char *arr;
126 
127         oldClassDef[clsLoadedIdx].class_byte_count = class_data_len;
128         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Allocate(class_data_len, &amp;arr))) {
129             nsk_jvmti_setFailStatus();
130             return;
131         }
132         for (j = 0; j &lt; class_data_len; j++) {
133             arr[j] = class_data[j];
134         }
135         oldClassDef[clsLoadedIdx].class_bytes = arr;
136     }
137 
138     *new_class_data_len = newClassSize[clsLoadedIdx];
139     *new_class_data = newClassBytes[clsLoadedIdx];
140 
141     NSK_DISPLAY2(&quot;Replace with new bytecode: 0x%p:%d\n&quot;,
142                                 (void*)newClassBytes[clsLoadedIdx],
143                                 (int)newClassSize[clsLoadedIdx]);
144     if (nsk_getVerboseMode()) {
145         nsk_printHexBytes(&quot;   &quot;, 16, newClassSize[clsLoadedIdx],
146                                 newClassBytes[clsLoadedIdx]);
147     }
148 }
149 
150 /* ============================================================================= */
151 
152 /** Agent algorithm. */
153 static void JNICALL
154 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
155 
156     int i;
157 
158     /*Wait for debuggee to read new byte codes nsk_jvmti_waitForSync#1*/
159     NSK_DISPLAY0(&quot;Wait for debuggee to read new byte codes nsk_jvmti_waitForSync#1\n&quot;);
160     if (!nsk_jvmti_waitForSync(timeout))
161         return;
162 
163     for (clsLoadedIdx=0; clsLoadedIdx &lt; TOTAL_INSTRUMENTED_CLASSES; clsLoadedIdx++) {
164 
165         if (!nsk_jvmti_resumeSync())
166             return;
167 
168         NSK_DISPLAY1(&quot;Wait for debuggee to load tested class by classLoader[%d]\n&quot;,
169                             (clsLoadedIdx+1));
170         /*Wait for debuggee to load next class nsk_jvmti_waitForSync#2*/
171         if (!nsk_jvmti_waitForSync(timeout))
172             return;
173     }
174 
175     if (!nsk_jvmti_resumeSync())
176         return;
177 
178     /*Wait for debuggee to check instrumentation code works nsk_jvmti_waitForSync#3*/
179     NSK_DISPLAY0(&quot;Wait for debuggee to check instrumentation code works nsk_jvmti_waitForSync#3\n&quot;);
180     if (!nsk_jvmti_waitForSync(timeout))
181         return;
182 
183     NSK_DISPLAY0(&quot;Notification disabled for CLASS_FILE_LOAD_HOOK event\n&quot;);
184     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_DISABLE,
185                                                           JVMTI_EVENT_CLASS_FILE_LOAD_HOOK,
186                                                           NULL))) {
187         nsk_jvmti_setFailStatus();
188         return;
189     }
190 
191     if (!nsk_jvmti_resumeSync())
192         return;
193 
194     /*Wait for debuggee to set classes to be redefined nsk_jvmti_waitForSync#4*/
195     NSK_DISPLAY0(&quot;Wait for debuggee to set classes to be redefined nsk_jvmti_waitForSync#4\n&quot;);
196     if (!nsk_jvmti_waitForSync(timeout))
197         return;
198 
199     NSK_DISPLAY0(&quot;Redfine class with old byte code\n&quot;);
200     for (i = 0; i &lt; TOTAL_INSTRUMENTED_CLASSES; i++) {
201         NSK_DISPLAY4(&quot;class definition %d:\n\t0x%p, 0x%p:%d\n&quot;,
202                         i,
203                         oldClassDef[i].klass,
204                         oldClassDef[i].class_bytes,
205                         oldClassDef[i].class_byte_count);
206         if (nsk_getVerboseMode()) {
207             nsk_printHexBytes(&quot;   &quot;, 16, oldClassDef[i].class_byte_count,
208                                     oldClassDef[i].class_bytes);
209         }
210     }
211     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RedefineClasses(TOTAL_INSTRUMENTED_CLASSES, oldClassDef))) {
212         nsk_jvmti_setFailStatus();
213         return;
214     }
215 
216     if (!nsk_jvmti_resumeSync())
217         return;
218 
219     /*Wait for debuggee to check old byte code works nsk_jvmti_waitForSync#5*/
220     NSK_DISPLAY0(&quot;Wait for debuggee to check old byte code works nsk_jvmti_waitForSync#5\n&quot;);
221     if (!nsk_jvmti_waitForSync(timeout))
222         return;
223 
224     for (i = 0; i &lt; TOTAL_INSTRUMENTED_CLASSES; i++) {
225         agentJNI-&gt;DeleteGlobalRef(oldClassDef[i].klass);
226     }
227 
228     NSK_DISPLAY0(&quot;Let debuggee to finish\n&quot;);
229     if (!nsk_jvmti_resumeSync())
230         return;
231 
232 }
233 
234 /* ============================================================================= */
235 
236 /** Agent library initialization. */
237 #ifdef STATIC_BUILD
238 JNIEXPORT jint JNICALL Agent_OnLoad_bi01t002(JavaVM *jvm, char *options, void *reserved) {
239     return Agent_Initialize(jvm, options, reserved);
240 }
241 JNIEXPORT jint JNICALL Agent_OnAttach_bi01t002(JavaVM *jvm, char *options, void *reserved) {
242     return Agent_Initialize(jvm, options, reserved);
243 }
244 JNIEXPORT jint JNI_OnLoad_bi01t002(JavaVM *jvm, char *options, void *reserved) {
245     return JNI_VERSION_1_8;
246 }
247 #endif
248 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
249 
250     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
251         return JNI_ERR;
252 
253     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
254 
255     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
256     if (!NSK_VERIFY(jvmti != NULL))
257         return JNI_ERR;
258 
259     {
260         jvmtiCapabilities caps;
261         memset(&amp;caps, 0, sizeof(caps));
262 
263         caps.can_redefine_classes = 1;
264         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
265             return JNI_ERR;
266     }
267 
268     NSK_DISPLAY0(&quot;Set callback for CLASS_FILE_LOAD_HOOK event\n&quot;);
269     {
270         jvmtiEventCallbacks callbacks;
271         jint size = (jint)sizeof(callbacks);
272 
273         memset(&amp;callbacks, 0, size);
274         callbacks.ClassFileLoadHook = cbClassFileLoadHook;
275         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;callbacks, size))) {
276             return JNI_ERR;
277         }
278     }
279 
280     NSK_DISPLAY0(&quot;Set notification enabled for CLASS_FILE_LOAD_HOOK event\n&quot;);
281     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE,
282                                                           JVMTI_EVENT_CLASS_FILE_LOAD_HOOK,
283                                                           NULL))) {
284         nsk_jvmti_setFailStatus();
285         return NSK_FALSE;
286     }
287 
288     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
289         return JNI_ERR;
290 
291     return JNI_OK;
292 }
293 
294 /* ============================================================================= */
295 
296 
297 }
    </pre>
  </body>
</html>
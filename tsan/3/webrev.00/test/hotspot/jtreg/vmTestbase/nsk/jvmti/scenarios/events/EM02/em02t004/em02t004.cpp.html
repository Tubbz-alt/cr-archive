<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/events/EM02/em02t004/em02t004.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;string.h&gt;
 25 #include &quot;jvmti.h&quot;
 26 #include &quot;agent_common.h&quot;
 27 #include &quot;jni_tools.h&quot;
 28 #include &quot;jvmti_tools.h&quot;
 29 #include &quot;JVMTITools.h&quot;
 30 
 31 extern &quot;C&quot; {
 32 
 33 /* ============================================================================= */
 34 
 35 /* scaffold objects */
 36 static jvmtiEnv *jvmti = NULL;
 37 static jlong timeout = 0;
 38 static jrawMonitorID syncLock = NULL;
 39 
 40 /* constant names */
 41 #define STEP_AMOUNT 3
 42 #define JVMTI_EVENT_COUNT   (int)(JVMTI_MAX_EVENT_TYPE_VAL - JVMTI_MIN_EVENT_TYPE_VAL + 1)
 43 
 44 static int eventCount[JVMTI_EVENT_COUNT];
 45 static int newEventCount[JVMTI_EVENT_COUNT];
 46 
 47 /* ============================================================================= */
 48 JNIEXPORT void JNICALL
 49 Java_nsk_jvmti_scenarios_events_EM02_em02t004_nativeMethod1(JNIEnv *jni_env,
 50                         jobject o) {
 51     NSK_DISPLAY0(&quot;called nativeMethod1\n&quot;);
 52 }
 53 
 54 JNIEXPORT void JNICALL
 55 Java_nsk_jvmti_scenarios_events_EM02_em02t004_nativeMethod2(JNIEnv *jni_env,
 56                         jobject o) {
 57     NSK_DISPLAY0(&quot;called nativeMethod2\n&quot;);
 58 }
 59 
 60 JNIEXPORT void JNICALL
 61 Java_nsk_jvmti_scenarios_events_EM02_em02t004_nativeMethod3(JNIEnv *jni_env,
 62                         jobject o) {
 63     NSK_DISPLAY0(&quot;called nativeMethod3\n&quot;);
 64 }
 65 
 66 static void
 67 showEventStatistics(int step) {
 68     int i;
 69     const char* str;
 70     int *currentCounts = (step == 1) ? &amp;eventCount[0] : &amp;newEventCount[0];
 71 
 72     NSK_DISPLAY0(&quot;\n&quot;);
 73     NSK_DISPLAY1(&quot;Event statistics for %d step:\n&quot;, step);
 74     NSK_DISPLAY0(&quot;-----------------------------\n&quot;);
 75     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
 76         if (currentCounts[i] &gt; 0) {
 77             str = TranslateEvent((jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL));
 78             NSK_DISPLAY2(&quot;%-40s %7d\n&quot;, str, currentCounts[i]);
 79         }
 80     }
 81 }
 82 
 83 /* ========================================================================== */
 84 
 85 bool checkEvents(int step) {
 86     int i;
 87     jvmtiEvent curr;
 88     bool result = true;
 89     int *currentCounts;
 90     int isExpected = 0;
 91 
 92     switch (step) {
 93         case 1:
 94             currentCounts = &amp;eventCount[0];
 95             break;
 96 
 97         case 2:
 98         case 3:
 99             currentCounts = &amp;newEventCount[0];
100             break;
101 
102         default:
103             NSK_COMPLAIN1(&quot;Unexpected step no: %d\n&quot;, step);
104             return false;
105     }
106 
107     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
108 
109         curr = (jvmtiEvent) (i + JVMTI_MIN_EVENT_TYPE_VAL);
110 
111         switch (step) {
112             case 1:
113                 isExpected = ((curr == JVMTI_EVENT_NATIVE_METHOD_BIND)
114                                 || (curr == JVMTI_EVENT_VM_INIT));
115                 break;
116 
117             case 2:
118                 isExpected = ((curr == JVMTI_EVENT_NATIVE_METHOD_BIND));
119                 break;
120 
121             case 3:
122                 isExpected = (curr == JVMTI_EVENT_VM_DEATH);
123                 break;
124         }
125 
126         if (isExpected) {
127             if (currentCounts[i] &lt; 1) {
128                     NSK_COMPLAIN2(&quot;Unexpected events number %7d for %s\n\texpected value must be greater than 1\n&quot;,
129                                         currentCounts[i],
130                                         TranslateEvent(curr));
131                 result = false;
132             }
133         } else {
134             if (currentCounts[i] &gt; 0) {
135                 NSK_COMPLAIN2(&quot;Unexpected event %s was sent %d times\n&quot;,
136                                     TranslateEvent(curr),
137                                     currentCounts[i]);
138                 result = false;
139             }
140         }
141     }
142 
143     return result;
144 }
145 
146 static void
147 changeCount(jvmtiEvent event, int *currentCounts) {
148 
149     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorEnter(syncLock)))
150         nsk_jvmti_setFailStatus();
151 
152     currentCounts[event - JVMTI_MIN_EVENT_TYPE_VAL]++;
153 
154     if (!NSK_JVMTI_VERIFY(jvmti-&gt;RawMonitorExit(syncLock)))
155         nsk_jvmti_setFailStatus();
156 
157 }
158 
159 /* ============================================================================= */
160 
161 /* callbacks */
162 JNIEXPORT void JNICALL
163 cbVMInit(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread) {
164     changeCount(JVMTI_EVENT_VM_INIT, &amp;eventCount[0]);
165 }
166 
167 JNIEXPORT void JNICALL
168 cbVMDeath(jvmtiEnv* jvmti, JNIEnv* jni_env) {
169     changeCount(JVMTI_EVENT_VM_DEATH, &amp;newEventCount[0]);
170     showEventStatistics(STEP_AMOUNT);
171     if (!checkEvents(STEP_AMOUNT))
172         nsk_jvmti_setFailStatus();
173 
174     if (!NSK_JVMTI_VERIFY(jvmti-&gt;DestroyRawMonitor(syncLock)))
175         nsk_jvmti_setFailStatus();
176 
177 }
178 
179 void JNICALL
180 cbException(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
181                 jmethodID method, jlocation location, jobject exception,
182                 jmethodID catch_method, jlocation catch_location) {
183     changeCount(JVMTI_EVENT_EXCEPTION, &amp;eventCount[0]);
184 }
185 
186 void JNICALL
187 cbExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
188                 jmethodID method, jlocation location, jobject exception) {
189     changeCount(JVMTI_EVENT_EXCEPTION_CATCH, &amp;eventCount[0]);
190 }
191 
192 void JNICALL
193 cbSingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
194                 jmethodID method, jlocation location) {
195     changeCount(JVMTI_EVENT_SINGLE_STEP, &amp;eventCount[0]);
196 }
197 
198 void JNICALL
199 cbFramePop(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
200                 jmethodID method, jboolean was_popped_by_exception) {
201     changeCount(JVMTI_EVENT_FRAME_POP, &amp;eventCount[0]);
202 }
203 
204 void JNICALL
205 cbBreakpoint(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
206                 jmethodID method, jlocation location) {
207     changeCount(JVMTI_EVENT_BREAKPOINT, &amp;eventCount[0]);
208 }
209 
210 void JNICALL
211 cbFieldAccess(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
212                 jmethodID method, jlocation location, jclass field_klass,
213                 jobject object, jfieldID field) {
214     changeCount(JVMTI_EVENT_FIELD_ACCESS, &amp;eventCount[0]);
215 }
216 
217 void JNICALL
218 cbFieldModification(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
219                 jmethodID method, jlocation location, jclass field_klass,
220                 jobject object, jfieldID field, char signature_type,
221                 jvalue new_value) {
222     changeCount(JVMTI_EVENT_FIELD_MODIFICATION, &amp;eventCount[0]);
223 }
224 
225 void JNICALL
226 cbMethodEntry(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
227                 jmethodID method) {
228     changeCount(JVMTI_EVENT_METHOD_ENTRY, &amp;eventCount[0]);
229 }
230 
231 void JNICALL
232 cbMethodExit(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
233                 jmethodID method, jboolean was_popped_by_exception,
234                 jvalue return_value) {
235     changeCount(JVMTI_EVENT_METHOD_EXIT, &amp;eventCount[0]);
236 }
237 
238 void JNICALL
239 cbCompiledMethodLoad(jvmtiEnv *jvmti_env, jmethodID method, jint code_size,
240                 const void* code_addr, jint map_length,
241                 const jvmtiAddrLocationMap* map, const void* compile_info) {
242     changeCount(JVMTI_EVENT_COMPILED_METHOD_LOAD, &amp;eventCount[0]);
243 }
244 
245 void JNICALL
246 cbCompiledMethodUnload(jvmtiEnv *jvmti_env, jmethodID method,
247                 const void* code_addr) {
248     changeCount(JVMTI_EVENT_COMPILED_METHOD_UNLOAD, &amp;eventCount[0]);
249 }
250 
251 void JNICALL
252 cbMonitorWait(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
253                     jobject object, jlong tout) {
254 
255     changeCount(JVMTI_EVENT_MONITOR_WAIT, &amp;eventCount[0]);
256 }
257 
258 void JNICALL
259 cbMonitorWaited(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
260                     jobject object, jboolean timed_out) {
261 
262     changeCount(JVMTI_EVENT_MONITOR_WAITED, &amp;eventCount[0]);
263 }
264 
265 JNIEXPORT void JNICALL
266 cbMonitorContendedEnter(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread,
267                             jobject object) {
268 
269     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTER, &amp;eventCount[0]);
270 }
271 
272 void JNICALL
273 cbMonitorContendedEntered(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
274                             jobject object) {
275 
276     changeCount(JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, &amp;eventCount[0]);
277 }
278 
279 void JNICALL
280 cbGarbageCollectionStart(jvmtiEnv *jvmti_env) {
281 
282     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_START, &amp;eventCount[0]);
283 }
284 
285 void JNICALL
286 cbGarbageCollectionFinish(jvmtiEnv *jvmti_env) {
287 
288     changeCount(JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, &amp;eventCount[0]);
289 }
290 
291 void JNICALL
292 cbObjectFree(jvmtiEnv *jvmti_env, jlong tag) {
293     changeCount(JVMTI_EVENT_OBJECT_FREE, &amp;eventCount[0]);
294 }
295 
296 void JNICALL
297 cbVMObjectAlloc(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,
298                     jobject object, jclass object_klass, jlong size) {
299 
300     changeCount(JVMTI_EVENT_VM_OBJECT_ALLOC, &amp;eventCount[0]);
301 }
302 
303 void JNICALL
304 cbNativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env,jthread thread,
305                 jmethodID method, void* address, void** new_address_ptr) {
306 
307     char *name;
308     char *sign;
309     char *genc;
310     jvmtiPhase phase;
311 
312     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetPhase(&amp;phase))) {
313         nsk_jvmti_setFailStatus();
314     }
315 
316     if (phase != JVMTI_PHASE_START &amp;&amp; phase != JVMTI_PHASE_LIVE) {
317         return;
318     }
319 
320     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodName(method, &amp;name, &amp;sign, &amp;genc))) {
321         return;
322     }
323 
324     if (!strcmp(name,&quot;nativeMethod1&quot;)) {
325         NSK_DISPLAY0(&quot;NATIVE_METHOD_BIND recieved for\n&quot;);
326         NSK_DISPLAY4(&quot;\tmethod: %s, signature: %s address: %p new_address: %p\n&quot;,
327                             name, sign, address, new_address_ptr);
328         changeCount(JVMTI_EVENT_NATIVE_METHOD_BIND, &amp;eventCount[0]);
329     }
330 
331     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)name))) {
332         nsk_jvmti_setFailStatus();
333     }
334     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)sign))) {
335         nsk_jvmti_setFailStatus();
336     }
337     if (genc != NULL)
338         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)genc))) {
339             nsk_jvmti_setFailStatus();
340         }
341 }
342 
343 void JNICALL
344 cbNewNativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env,jthread thread,
345                 jmethodID method, void* address, void** new_address_ptr) {
346     char *name;
347     char *sign;
348     char *genc;
349 
350     jvmtiPhase phase;
351 
352     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetPhase(&amp;phase))) {
353         nsk_jvmti_setFailStatus();
354     }
355 
356     if (phase != JVMTI_PHASE_START &amp;&amp; phase != JVMTI_PHASE_LIVE) {
357         return;
358     }
359 
360     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;GetMethodName(method, &amp;name, &amp;sign, &amp;genc))) {
361         return;
362     }
363 
364     if (!strcmp(name,&quot;nativeMethod2&quot;)) {
365         NSK_DISPLAY0(&quot;NATIVE_METHOD_BIND recieved for\n&quot;);
366         NSK_DISPLAY4(&quot;\tmethod: %s, signature: %s address: %p new_address: %p\n&quot;,
367                             name, sign, address, new_address_ptr);
368         changeCount(JVMTI_EVENT_NATIVE_METHOD_BIND, &amp;newEventCount[0]);
369     }
370 
371     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)name))) {
372         nsk_jvmti_setFailStatus();
373     }
374     if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)sign))) {
375         nsk_jvmti_setFailStatus();
376     }
377     if (genc != NULL)
378         if (!NSK_JVMTI_VERIFY(jvmti_env-&gt;Deallocate((unsigned char*)genc))) {
379             nsk_jvmti_setFailStatus();
380         }
381 }
382 
383 /* ============================================================================= */
384 
385 static bool enableEvent(jvmtiEvent event) {
386 
387     if (nsk_jvmti_isOptionalEvent(event)
388             &amp;&amp; (event != JVMTI_EVENT_NATIVE_METHOD_BIND)) {
389         if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_MUST_POSSESS_CAPABILITY,
390                 jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
391             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
392                 TranslateEvent(event));
393             return false;
394         }
395     } else {
396         if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {
397             NSK_COMPLAIN1(&quot;Unexpected error enabling %s\n&quot;,
398                 TranslateEvent(event));
399             return false;
400         }
401     }
402 
403     return true;
404 }
405 
406 /**
407  * Enable or disable tested events.
408  */
409 static bool enableEventList() {
410     int i;
411     bool result = true;
412 
413     NSK_DISPLAY0(&quot;Enable events\n&quot;);
414 
415     result = enableEvent(JVMTI_EVENT_VM_INIT);
416 
417     result = result &amp;&amp; enableEvent(JVMTI_EVENT_VM_DEATH);
418 
419     /* enabling optional events */
420     for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
421         jvmtiEvent event = (jvmtiEvent)(i+JVMTI_MIN_EVENT_TYPE_VAL);
422 
423         if (nsk_jvmti_isOptionalEvent(event))
424             result = result &amp;&amp; enableEvent(event);
425     }
426 
427     if (!result) {
428         nsk_jvmti_setFailStatus();
429         return false;
430     }
431 
432     return true;
433 }
434 
435 /* ============================================================================= */
436 
437 static bool setCallBacks(int step) {
438 
439     int i;
440 
441     jvmtiEventCallbacks eventCallbacks;
442     memset(&amp;eventCallbacks, 0, sizeof(eventCallbacks));
443 
444     NSK_DISPLAY0(&quot;\n&quot;);
445     NSK_DISPLAY1(&quot;===============step %d===============\n&quot;, step);
446     NSK_DISPLAY0(&quot;\n&quot;);
447     switch (step) {
448         case 1:
449             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
450                 eventCount[i] = 0;
451             }
452 
453             eventCallbacks.VMInit                    = cbVMInit;
454             eventCallbacks.Exception                 = cbException;
455             eventCallbacks.ExceptionCatch            = cbExceptionCatch;
456             eventCallbacks.SingleStep                = cbSingleStep;
457             eventCallbacks.FramePop                  = cbFramePop;
458             eventCallbacks.Breakpoint                = cbBreakpoint;
459             eventCallbacks.FieldAccess               = cbFieldAccess;
460             eventCallbacks.FieldModification         = cbFieldModification;
461             eventCallbacks.MethodEntry               = cbMethodEntry;
462             eventCallbacks.MethodExit                = cbMethodExit;
463             eventCallbacks.NativeMethodBind          = cbNativeMethodBind;
464             eventCallbacks.CompiledMethodLoad        = cbCompiledMethodLoad;
465             eventCallbacks.CompiledMethodUnload      = cbCompiledMethodUnload;
466             eventCallbacks.MonitorWait               = cbMonitorWait;
467             eventCallbacks.MonitorWaited             = cbMonitorWaited;
468             eventCallbacks.MonitorContendedEnter     = cbMonitorContendedEnter;
469             eventCallbacks.MonitorContendedEntered   = cbMonitorContendedEntered;
470             eventCallbacks.GarbageCollectionStart    = cbGarbageCollectionStart;
471             eventCallbacks.GarbageCollectionFinish   = cbGarbageCollectionFinish;
472             eventCallbacks.ObjectFree                = cbObjectFree;
473             eventCallbacks.VMObjectAlloc             = cbVMObjectAlloc;
474             break;
475 
476         case 2:
477             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
478                 newEventCount[i] = 0;
479             }
480 
481             eventCallbacks.NativeMethodBind = cbNewNativeMethodBind;
482             break;
483 
484         case 3:
485             for (i = 0; i &lt; JVMTI_EVENT_COUNT; i++) {
486                 newEventCount[i] = 0;
487             }
488 
489             eventCallbacks.VMDeath                   = cbVMDeath;
490             break;
491 
492     }
493     if (!NSK_JVMTI_VERIFY(jvmti-&gt;SetEventCallbacks(&amp;eventCallbacks, sizeof(eventCallbacks))))
494         return false;
495 
496     return true;
497 }
498 
499 /* ============================================================================= */
500 
501 /** Agent algorithm. */
502 static void JNICALL
503 agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {
504 
505     int i;
506 
507     for (i = 1; i &lt;= STEP_AMOUNT; i++) {
508         if (i &gt; 1) {
509             NSK_DISPLAY0(&quot;Check received events\n&quot;);
510 
511             showEventStatistics(i-1);
512             if (!checkEvents(i-1))
513                 nsk_jvmti_setFailStatus();
514 
515             if (!setCallBacks(i)) {
516                 return;
517             }
518 
519             if (!nsk_jvmti_resumeSync())
520                 return;
521         }
522 
523         NSK_DISPLAY0(&quot;Wait for debuggee to become ready\n&quot;);
524         if (!nsk_jvmti_waitForSync(timeout))
525             return;
526 
527     }
528 
529     NSK_DISPLAY0(&quot;Let debuggee to finish\n&quot;);
530     if (!nsk_jvmti_resumeSync())
531         return;
532 
533 }
534 
535 /* ============================================================================= */
536 
537 /** Agent library initialization. */
538 #ifdef STATIC_BUILD
539 JNIEXPORT jint JNICALL Agent_OnLoad_em02t004(JavaVM *jvm, char *options, void *reserved) {
540     return Agent_Initialize(jvm, options, reserved);
541 }
542 JNIEXPORT jint JNICALL Agent_OnAttach_em02t004(JavaVM *jvm, char *options, void *reserved) {
543     return Agent_Initialize(jvm, options, reserved);
544 }
545 JNIEXPORT jint JNI_OnLoad_em02t004(JavaVM *jvm, char *options, void *reserved) {
546     return JNI_VERSION_1_8;
547 }
548 #endif
549 jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {
550 
551     if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))
552         return JNI_ERR;
553 
554     timeout = nsk_jvmti_getWaitTime() * 60 * 1000;
555 
556     jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);
557     if (!NSK_VERIFY(jvmti != NULL))
558         return JNI_ERR;
559 
560     if (!NSK_JVMTI_VERIFY(jvmti-&gt;CreateRawMonitor(&quot;_syncLock&quot;, &amp;syncLock))) {
561         nsk_jvmti_setFailStatus();
562         return JNI_ERR;
563     }
564 
565     {
566         jvmtiCapabilities caps;
567         memset(&amp;caps, 0, sizeof(caps));
568 
569         caps.can_generate_native_method_bind_events = 1;
570         if (!NSK_JVMTI_VERIFY(jvmti-&gt;AddCapabilities(&amp;caps)))
571             return JNI_ERR;
572     }
573 
574     if (!setCallBacks(1)) {
575         return JNI_ERR;
576     }
577 
578     nsk_jvmti_showPossessedCapabilities(jvmti);
579 
580     if (!enableEventList()) {
581         return JNI_ERR;
582     }
583 
584     if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))
585         return JNI_ERR;
586 
587     return JNI_OK;
588 }
589 
590 /* ============================================================================= */
591 
592 
593 }
    </pre>
  </body>
</html>
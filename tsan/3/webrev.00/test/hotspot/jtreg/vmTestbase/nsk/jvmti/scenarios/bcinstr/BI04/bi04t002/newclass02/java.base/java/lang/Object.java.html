<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/bcinstr/BI04/bi04t002/newclass02/java.base/java/lang/Object.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package java.lang;
 25 
 26 import nsk.jvmti.scenarios.bcinstr.BI04.bi04t002a;
 27 
 28 /**
 29  * Class &lt;code&gt;Object&lt;/code&gt; is the root of the class hierarchy.
 30  * Every class has &lt;code&gt;Object&lt;/code&gt; as a superclass. All objects,
 31  * including arrays, implement the methods of this class.
 32  *
 33  * @author  unascribed
 34  * @version 1.67, 02/03/04
 35  * @see     java.lang.Class
 36  * @since   JDK1.0
 37  */
 38 public class Object {
 39 
 40     /**
 41      * Returns the runtime class of an object. That &lt;tt&gt;Class&lt;/tt&gt;
 42      * object is the object that is locked by &lt;tt&gt;static synchronized&lt;/tt&gt;
 43      * methods of the represented class.
 44      *
 45      * @return The &lt;code&gt;java.lang.Class&lt;/code&gt; object that represents
 46      *         the runtime class of the object.  The result is of type
 47      *         {@code Class&lt;? extends X&gt;} where X is the
 48      *         static type of the expression on which
 49      *         &lt;code&gt;getClass&lt;/code&gt; is called.
 50      */
 51     public final native Class&lt;? extends Object&gt; getClass();
 52 
 53     /**
 54      * Returns a hash code value for the object. This method is
 55      * supported for the benefit of hashtables such as those provided by
 56      * &lt;code&gt;java.util.Hashtable&lt;/code&gt;.
 57      * &lt;p&gt;
 58      * The general contract of &lt;code&gt;hashCode&lt;/code&gt; is:
 59      * &lt;ul&gt;
 60      * &lt;li&gt;Whenever it is invoked on the same object more than once during
 61      *     an execution of a Java application, the &lt;tt&gt;hashCode&lt;/tt&gt; method
 62      *     must consistently return the same integer, provided no information
 63      *     used in &lt;tt&gt;equals&lt;/tt&gt; comparisons on the object is modified.
 64      *     This integer need not remain consistent from one execution of an
 65      *     application to another execution of the same application.
 66      * &lt;li&gt;If two objects are equal according to the &lt;tt&gt;equals(Object)&lt;/tt&gt;
 67      *     method, then calling the &lt;code&gt;hashCode&lt;/code&gt; method on each of
 68      *     the two objects must produce the same integer result.
 69      * &lt;li&gt;It is &lt;em&gt;not&lt;/em&gt; required that if two objects are unequal
 70      *     according to the {@link java.lang.Object#equals(java.lang.Object)}
 71      *     method, then calling the &lt;tt&gt;hashCode&lt;/tt&gt; method on each of the
 72      *     two objects must produce distinct integer results.  However, the
 73      *     programmer should be aware that producing distinct integer results
 74      *     for unequal objects may improve the performance of hashtables.
 75      * &lt;/ul&gt;
 76      * &lt;p&gt;
 77      * As much as is reasonably practical, the hashCode method defined by
 78      * class &lt;tt&gt;Object&lt;/tt&gt; does return distinct integers for distinct
 79      * objects. (This is typically implemented by converting the internal
 80      * address of the object into an integer, but this implementation
 81      * technique is not required by the
 82      * Java&lt;font size=&quot;-2&quot;&gt;&lt;sup&gt;TM&lt;/sup&gt;&lt;/font&gt; programming language.)
 83      *
 84      * @return  a hash code value for this object.
 85      * @see     java.lang.Object#equals(java.lang.Object)
 86      * @see     java.util.Hashtable
 87      */
 88     public native int hashCode();
 89 
 90     /**
 91      * Indicates whether some other object is &quot;equal to&quot; this one.
 92      * &lt;p&gt;
 93      * The &lt;code&gt;equals&lt;/code&gt; method implements an equivalence relation
 94      * on non-null object references:
 95      * &lt;ul&gt;
 96      * &lt;li&gt;It is &lt;i&gt;reflexive&lt;/i&gt;: for any non-null reference value
 97      *     &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.equals(x)&lt;/code&gt; should return
 98      *     &lt;code&gt;true&lt;/code&gt;.
 99      * &lt;li&gt;It is &lt;i&gt;symmetric&lt;/i&gt;: for any non-null reference values
100      *     &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;x.equals(y)&lt;/code&gt;
101      *     should return &lt;code&gt;true&lt;/code&gt; if and only if
102      *     &lt;code&gt;y.equals(x)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.
103      * &lt;li&gt;It is &lt;i&gt;transitive&lt;/i&gt;: for any non-null reference values
104      *     &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, if
105      *     &lt;code&gt;x.equals(y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; and
106      *     &lt;code&gt;y.equals(z)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, then
107      *     &lt;code&gt;x.equals(z)&lt;/code&gt; should return &lt;code&gt;true&lt;/code&gt;.
108      * &lt;li&gt;It is &lt;i&gt;consistent&lt;/i&gt;: for any non-null reference values
109      *     &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, multiple invocations of
110      *     &lt;tt&gt;x.equals(y)&lt;/tt&gt; consistently return &lt;code&gt;true&lt;/code&gt;
111      *     or consistently return &lt;code&gt;false&lt;/code&gt;, provided no
112      *     information used in &lt;code&gt;equals&lt;/code&gt; comparisons on the
113      *     objects is modified.
114      * &lt;li&gt;For any non-null reference value &lt;code&gt;x&lt;/code&gt;,
115      *     &lt;code&gt;x.equals(null)&lt;/code&gt; should return &lt;code&gt;false&lt;/code&gt;.
116      * &lt;/ul&gt;
117      * &lt;p&gt;
118      * The &lt;tt&gt;equals&lt;/tt&gt; method for class &lt;code&gt;Object&lt;/code&gt; implements
119      * the most discriminating possible equivalence relation on objects;
120      * that is, for any non-null reference values &lt;code&gt;x&lt;/code&gt; and
121      * &lt;code&gt;y&lt;/code&gt;, this method returns &lt;code&gt;true&lt;/code&gt; if and only
122      * if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; refer to the same object
123      * (&lt;code&gt;x == y&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;).
124      * &lt;p&gt;
125      * Note that it is generally necessary to override the &lt;tt&gt;hashCode&lt;/tt&gt;
126      * method whenever this method is overridden, so as to maintain the
127      * general contract for the &lt;tt&gt;hashCode&lt;/tt&gt; method, which states
128      * that equal objects must have equal hash codes.
129      *
130      * @param   obj   the reference object with which to compare.
131      * @return  &lt;code&gt;true&lt;/code&gt; if this object is the same as the obj
132      *          argument; &lt;code&gt;false&lt;/code&gt; otherwise.
133      * @see     #hashCode()
134      * @see     java.util.Hashtable
135      */
136     public boolean equals(Object obj) {
137         bi04t002a.instrInvoke(bi04t002a.INSTR_EQUALS);
138         return (this == obj);
139     }
140 
141     /**
142      * Creates and returns a copy of this object.  The precise meaning
143      * of &quot;copy&quot; may depend on the class of the object. The general
144      * intent is that, for any object &lt;tt&gt;x&lt;/tt&gt;, the expression:
145      * &lt;blockquote&gt;
146      * &lt;pre&gt;
147      * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;
148      * will be true, and that the expression:
149      * &lt;blockquote&gt;
150      * &lt;pre&gt;
151      * x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;
152      * will be &lt;tt&gt;true&lt;/tt&gt;, but these are not absolute requirements.
153      * While it is typically the case that:
154      * &lt;blockquote&gt;
155      * &lt;pre&gt;
156      * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;
157      * will be &lt;tt&gt;true&lt;/tt&gt;, this is not an absolute requirement.
158      * &lt;p&gt;
159      * By convention, the returned object should be obtained by calling
160      * &lt;tt&gt;super.clone&lt;/tt&gt;.  If a class and all of its superclasses (except
161      * &lt;tt&gt;Object&lt;/tt&gt;) obey this convention, it will be the case that
162      * &lt;tt&gt;x.clone().getClass() == x.getClass()&lt;/tt&gt;.
163      * &lt;p&gt;
164      * By convention, the object returned by this method should be independent
165      * of this object (which is being cloned).  To achieve this independence,
166      * it may be necessary to modify one or more fields of the object returned
167      * by &lt;tt&gt;super.clone&lt;/tt&gt; before returning it.  Typically, this means
168      * copying any mutable objects that comprise the internal &quot;deep structure&quot;
169      * of the object being cloned and replacing the references to these
170      * objects with references to the copies.  If a class contains only
171      * primitive fields or references to immutable objects, then it is usually
172      * the case that no fields in the object returned by &lt;tt&gt;super.clone&lt;/tt&gt;
173      * need to be modified.
174      * &lt;p&gt;
175      * The method &lt;tt&gt;clone&lt;/tt&gt; for class &lt;tt&gt;Object&lt;/tt&gt; performs a
176      * specific cloning operation. First, if the class of this object does
177      * not implement the interface &lt;tt&gt;Cloneable&lt;/tt&gt;, then a
178      * &lt;tt&gt;CloneNotSupportedException&lt;/tt&gt; is thrown. Note that all arrays
179      * are considered to implement the interface &lt;tt&gt;Cloneable&lt;/tt&gt;.
180      * Otherwise, this method creates a new instance of the class of this
181      * object and initializes all its fields with exactly the contents of
182      * the corresponding fields of this object, as if by assignment; the
183      * contents of the fields are not themselves cloned. Thus, this method
184      * performs a &quot;shallow copy&quot; of this object, not a &quot;deep copy&quot; operation.
185      * &lt;p&gt;
186      * The class &lt;tt&gt;Object&lt;/tt&gt; does not itself implement the interface
187      * &lt;tt&gt;Cloneable&lt;/tt&gt;, so calling the &lt;tt&gt;clone&lt;/tt&gt; method on an object
188      * whose class is &lt;tt&gt;Object&lt;/tt&gt; will result in throwing an
189      * exception at run time.
190      *
191      * @return     a clone of this instance.
192      * @exception  CloneNotSupportedException  if the object&#39;s class does not
193      *               support the &lt;code&gt;Cloneable&lt;/code&gt; interface. Subclasses
194      *               that override the &lt;code&gt;clone&lt;/code&gt; method can also
195      *               throw this exception to indicate that an instance cannot
196      *               be cloned.
197      * @see java.lang.Cloneable
198      */
199     protected native Object clone() throws CloneNotSupportedException;
200 
201     /**
202      * Returns a string representation of the object. In general, the
203      * &lt;code&gt;toString&lt;/code&gt; method returns a string that
204      * &quot;textually represents&quot; this object. The result should
205      * be a concise but informative representation that is easy for a
206      * person to read.
207      * It is recommended that all subclasses override this method.
208      * &lt;p&gt;
209      * The &lt;code&gt;toString&lt;/code&gt; method for class &lt;code&gt;Object&lt;/code&gt;
210      * returns a string consisting of the name of the class of which the
211      * object is an instance, the at-sign character `&lt;code&gt;@&lt;/code&gt;&#39;, and
212      * the unsigned hexadecimal representation of the hash code of the
213      * object. In other words, this method returns a string equal to the
214      * value of:
215      * &lt;blockquote&gt;
216      * &lt;pre&gt;
217      * getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode())
218      * &lt;/pre&gt;&lt;/blockquote&gt;
219      *
220      * @return  a string representation of the object.
221      */
222     public String toString() {
223         bi04t002a.instrInvoke(bi04t002a.INSTR_TOSTRING);
224         return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
225     }
226 
227     /**
228      * Wakes up a single thread that is waiting on this object&#39;s
229      * monitor. If any threads are waiting on this object, one of them
230      * is chosen to be awakened. The choice is arbitrary and occurs at
231      * the discretion of the implementation. A thread waits on an object&#39;s
232      * monitor by calling one of the &lt;code&gt;wait&lt;/code&gt; methods.
233      * &lt;p&gt;
234      * The awakened thread will not be able to proceed until the current
235      * thread relinquishes the lock on this object. The awakened thread will
236      * compete in the usual manner with any other threads that might be
237      * actively competing to synchronize on this object; for example, the
238      * awakened thread enjoys no reliable privilege or disadvantage in being
239      * the next thread to lock this object.
240      * &lt;p&gt;
241      * This method should only be called by a thread that is the owner
242      * of this object&#39;s monitor. A thread becomes the owner of the
243      * object&#39;s monitor in one of three ways:
244      * &lt;ul&gt;
245      * &lt;li&gt;By executing a synchronized instance method of that object.
246      * &lt;li&gt;By executing the body of a &lt;code&gt;synchronized&lt;/code&gt; statement
247      *     that synchronizes on the object.
248      * &lt;li&gt;For objects of type &lt;code&gt;Class,&lt;/code&gt; by executing a
249      *     synchronized static method of that class.
250      * &lt;/ul&gt;
251      * &lt;p&gt;
252      * Only one thread at a time can own an object&#39;s monitor.
253      *
254      * @exception  IllegalMonitorStateException  if the current thread is not
255      *               the owner of this object&#39;s monitor.
256      * @see        java.lang.Object#notifyAll()
257      * @see        java.lang.Object#wait()
258      */
259     public final native void notify();
260 
261     /**
262      * Wakes up all threads that are waiting on this object&#39;s monitor. A
263      * thread waits on an object&#39;s monitor by calling one of the
264      * &lt;code&gt;wait&lt;/code&gt; methods.
265      * &lt;p&gt;
266      * The awakened threads will not be able to proceed until the current
267      * thread relinquishes the lock on this object. The awakened threads
268      * will compete in the usual manner with any other threads that might
269      * be actively competing to synchronize on this object; for example,
270      * the awakened threads enjoy no reliable privilege or disadvantage in
271      * being the next thread to lock this object.
272      * &lt;p&gt;
273      * This method should only be called by a thread that is the owner
274      * of this object&#39;s monitor. See the &lt;code&gt;notify&lt;/code&gt; method for a
275      * description of the ways in which a thread can become the owner of
276      * a monitor.
277      *
278      * @exception  IllegalMonitorStateException  if the current thread is not
279      *               the owner of this object&#39;s monitor.
280      * @see        java.lang.Object#notify()
281      * @see        java.lang.Object#wait()
282      */
283     public final native void notifyAll();
284 
285     /**
286      * Causes current thread to wait until either another thread invokes the
287      * {@link java.lang.Object#notify()} method or the
288      * {@link java.lang.Object#notifyAll()} method for this object, or a
289      * specified amount of time has elapsed.
290      * &lt;p&gt;
291      * The current thread must own this object&#39;s monitor.
292      * &lt;p&gt;
293      * This method causes the current thread (call it &lt;var&gt;T&lt;/var&gt;) to
294      * place itself in the wait set for this object and then to relinquish
295      * any and all synchronization claims on this object. Thread &lt;var&gt;T&lt;/var&gt;
296      * becomes disabled for thread scheduling purposes and lies dormant
297      * until one of four things happens:
298      * &lt;ul&gt;
299      * &lt;li&gt;Some other thread invokes the &lt;tt&gt;notify&lt;/tt&gt; method for this
300      * object and thread &lt;var&gt;T&lt;/var&gt; happens to be arbitrarily chosen as
301      * the thread to be awakened.
302      * &lt;li&gt;Some other thread invokes the &lt;tt&gt;notifyAll&lt;/tt&gt; method for this
303      * object.
304      * &lt;li&gt;Some other thread {@link java.lang.Thread#interrupt() interrupts}
305      * thread &lt;var&gt;T&lt;/var&gt;.
306      * &lt;li&gt;The specified amount of real time has elapsed, more or less.  If
307      * &lt;tt&gt;timeout&lt;/tt&gt; is zero, however, then real time is not taken into
308      * consideration and the thread simply waits until notified.
309      * &lt;/ul&gt;
310      * The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this
311      * object and re-enabled for thread scheduling. It then competes in the
312      * usual manner with other threads for the right to synchronize on the
313      * object; once it has gained control of the object, all its
314      * synchronization claims on the object are restored to the status quo
315      * ante - that is, to the situation as of the time that the &lt;tt&gt;wait&lt;/tt&gt;
316      * method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the
317      * invocation of the &lt;tt&gt;wait&lt;/tt&gt; method. Thus, on return from the
318      * &lt;tt&gt;wait&lt;/tt&gt; method, the synchronization state of the object and of
319      * thread &lt;tt&gt;T&lt;/tt&gt; is exactly as it was when the &lt;tt&gt;wait&lt;/tt&gt; method
320      * was invoked.
321      * &lt;p&gt;
322      * A thread can also wake up without being notified, interrupted, or
323      * timing out, a so-called &lt;i&gt;spurious wakeup&lt;/i&gt;.  While this will rarely
324      * occur in practice, applications must guard against it by testing for
325      * the condition that should have caused the thread to be awakened, and
326      * continuing to wait if the condition is not satisfied.  In other words,
327      * waits should always occur in loops, like this one:
328      * &lt;pre&gt;
329      *     synchronized (obj) {
330      *         while (&amp;lt;condition does not hold&amp;gt;)
331      *             obj.wait(timeout);
332      *         ... // Perform action appropriate to condition
333      *     }
334      * &lt;/pre&gt;
335      * (For more information on this topic, see Section 3.2.3 in Doug Lea&#39;s
336      * &quot;Concurrent Programming in Java (Second Edition)&quot; (Addison-Wesley,
337      * 2000), or Item 50 in Joshua Bloch&#39;s &quot;Effective Java Programming
338      * Language Guide&quot; (Addison-Wesley, 2001).
339      * &lt;p&gt;
340      * If the current thread is
341      * {@link java.lang.Thread#interrupt() interrupted} by another thread
342      * while it is waiting, then an &lt;tt&gt;InterruptedException&lt;/tt&gt; is thrown.
343      * This exception is not thrown until the lock status of this object has
344      * been restored as described above.
345      * &lt;p&gt;
346      * Note that the &lt;tt&gt;wait&lt;/tt&gt; method, as it places the current thread
347      * into the wait set for this object, unlocks only this object; any
348      * other objects on which the current thread may be synchronized remain
349      * locked while the thread waits.
350      * &lt;p&gt;
351      * This method should only be called by a thread that is the owner
352      * of this object&#39;s monitor. See the &lt;code&gt;notify&lt;/code&gt; method for a
353      * description of the ways in which a thread can become the owner of
354      * a monitor.
355      *
356      * @param      timeout   the maximum time to wait in milliseconds.
357      * @exception  IllegalArgumentException      if the value of timeout is
358      *               negative.
359      * @exception  IllegalMonitorStateException  if the current thread is not
360      *               the owner of the object&#39;s monitor.
361      * @exception  InterruptedException if another thread interrupted the
362      *             current thread before or while the current thread
363      *             was waiting for a notification.  The &lt;i&gt;interrupted
364      *             status&lt;/i&gt; of the current thread is cleared when
365      *             this exception is thrown.
366      * @see        java.lang.Object#notify()
367      * @see        java.lang.Object#notifyAll()
368      */
369     public final native void wait(long timeout) throws InterruptedException;
370 
371     /**
372      * Causes current thread to wait until another thread invokes the
373      * {@link java.lang.Object#notify()} method or the
374      * {@link java.lang.Object#notifyAll()} method for this object, or
375      * some other thread interrupts the current thread, or a certain
376      * amount of real time has elapsed.
377      * &lt;p&gt;
378      * This method is similar to the &lt;code&gt;wait&lt;/code&gt; method of one
379      * argument, but it allows finer control over the amount of time to
380      * wait for a notification before giving up. The amount of real time,
381      * measured in nanoseconds, is given by:
382      * &lt;blockquote&gt;
383      * &lt;pre&gt;
384      * 1000000*timeout+nanos&lt;/pre&gt;&lt;/blockquote&gt;
385      * &lt;p&gt;
386      * In all other respects, this method does the same thing as the
387      * method {@link #wait(long)} of one argument. In particular,
388      * &lt;tt&gt;wait(0, 0)&lt;/tt&gt; means the same thing as &lt;tt&gt;wait(0)&lt;/tt&gt;.
389      * &lt;p&gt;
390      * The current thread must own this object&#39;s monitor. The thread
391      * releases ownership of this monitor and waits until either of the
392      * following two conditions has occurred:
393      * &lt;ul&gt;
394      * &lt;li&gt;Another thread notifies threads waiting on this object&#39;s monitor
395      *     to wake up either through a call to the &lt;code&gt;notify&lt;/code&gt; method
396      *     or the &lt;code&gt;notifyAll&lt;/code&gt; method.
397      * &lt;li&gt;The timeout period, specified by &lt;code&gt;timeout&lt;/code&gt;
398      *     milliseconds plus &lt;code&gt;nanos&lt;/code&gt; nanoseconds arguments, has
399      *     elapsed.
400      * &lt;/ul&gt;
401      * &lt;p&gt;
402      * The thread then waits until it can re-obtain ownership of the
403      * monitor and resumes execution.
404      * &lt;p&gt;
405      * As in the one argument version, interrupts and spurious wakeups are
406      * possible, and this method should always be used in a loop:
407      * &lt;pre&gt;
408      *     synchronized (obj) {
409      *         while (&amp;lt;condition does not hold&amp;gt;)
410      *             obj.wait(timeout, nanos);
411      *         ... // Perform action appropriate to condition
412      *     }
413      * &lt;/pre&gt;
414      * This method should only be called by a thread that is the owner
415      * of this object&#39;s monitor. See the &lt;code&gt;notify&lt;/code&gt; method for a
416      * description of the ways in which a thread can become the owner of
417      * a monitor.
418      *
419      * @param      timeout   the maximum time to wait in milliseconds.
420      * @param      nanos      additional time, in nanoseconds range
421      *                       0-999999.
422      * @exception  IllegalArgumentException      if the value of timeout is
423      *                      negative or the value of nanos is
424      *                      not in the range 0-999999.
425      * @exception  IllegalMonitorStateException  if the current thread is not
426      *               the owner of this object&#39;s monitor.
427      * @exception  InterruptedException if another thread interrupted the
428      *             current thread before or while the current thread
429      *             was waiting for a notification.  The &lt;i&gt;interrupted
430      *             status&lt;/i&gt; of the current thread is cleared when
431      *             this exception is thrown.
432      */
433     public final void wait(long timeout, int nanos) throws InterruptedException {
434 
435         bi04t002a.instrInvoke(bi04t002a.INSTR_WAIT_JI);
436 
437         if (timeout &lt; 0) {
438             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
439         }
440 
441         if (nanos &lt; 0 || nanos &gt; 999999) {
442             throw new IllegalArgumentException(
443                                 &quot;nanosecond timeout value out of range&quot;);
444         }
445 
446             if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; timeout == 0)) {
447                 timeout++;
448             }
449 
450             wait(timeout);
451     }
452 
453     /**
454      * Causes current thread to wait until another thread invokes the
455      * {@link java.lang.Object#notify()} method or the
456      * {@link java.lang.Object#notifyAll()} method for this object.
457      * In other words, this method behaves exactly as if it simply
458      * performs the call &lt;tt&gt;wait(0)&lt;/tt&gt;.
459      * &lt;p&gt;
460      * The current thread must own this object&#39;s monitor. The thread
461      * releases ownership of this monitor and waits until another thread
462      * notifies threads waiting on this object&#39;s monitor to wake up
463      * either through a call to the &lt;code&gt;notify&lt;/code&gt; method or the
464      * &lt;code&gt;notifyAll&lt;/code&gt; method. The thread then waits until it can
465      * re-obtain ownership of the monitor and resumes execution.
466      * &lt;p&gt;
467      * As in the one argument version, interrupts and spurious wakeups are
468      * possible, and this method should always be used in a loop:
469      * &lt;pre&gt;
470      *     synchronized (obj) {
471      *         while (&amp;lt;condition does not hold&amp;gt;)
472      *             obj.wait();
473      *         ... // Perform action appropriate to condition
474      *     }
475      * &lt;/pre&gt;
476      * This method should only be called by a thread that is the owner
477      * of this object&#39;s monitor. See the &lt;code&gt;notify&lt;/code&gt; method for a
478      * description of the ways in which a thread can become the owner of
479      * a monitor.
480      *
481      * @exception  IllegalMonitorStateException  if the current thread is not
482      *               the owner of the object&#39;s monitor.
483      * @exception  InterruptedException if another thread interrupted the
484      *             current thread before or while the current thread
485      *             was waiting for a notification.  The &lt;i&gt;interrupted
486      *             status&lt;/i&gt; of the current thread is cleared when
487      *             this exception is thrown.
488      * @see        java.lang.Object#notify()
489      * @see        java.lang.Object#notifyAll()
490      */
491     public final void wait() throws InterruptedException {
492         bi04t002a.instrInvoke(bi04t002a.INSTR_WAIT);
493         wait(0);
494     }
495 
496     /**
497      * Called by the garbage collector on an object when garbage collection
498      * determines that there are no more references to the object.
499      * A subclass overrides the &lt;code&gt;finalize&lt;/code&gt; method to dispose of
500      * system resources or to perform other cleanup.
501      * &lt;p&gt;
502      * The general contract of &lt;tt&gt;finalize&lt;/tt&gt; is that it is invoked
503      * if and when the Java&lt;font size=&quot;-2&quot;&gt;&lt;sup&gt;TM&lt;/sup&gt;&lt;/font&gt; virtual
504      * machine has determined that there is no longer any
505      * means by which this object can be accessed by any thread that has
506      * not yet died, except as a result of an action taken by the
507      * finalization of some other object or class which is ready to be
508      * finalized. The &lt;tt&gt;finalize&lt;/tt&gt; method may take any action, including
509      * making this object available again to other threads; the usual purpose
510      * of &lt;tt&gt;finalize&lt;/tt&gt;, however, is to perform cleanup actions before
511      * the object is irrevocably discarded. For example, the finalize method
512      * for an object that represents an input/output connection might perform
513      * explicit I/O transactions to break the connection before the object is
514      * permanently discarded.
515      * &lt;p&gt;
516      * The &lt;tt&gt;finalize&lt;/tt&gt; method of class &lt;tt&gt;Object&lt;/tt&gt; performs no
517      * special action; it simply returns normally. Subclasses of
518      * &lt;tt&gt;Object&lt;/tt&gt; may override this definition.
519      * &lt;p&gt;
520      * The Java programming language does not guarantee which thread will
521      * invoke the &lt;tt&gt;finalize&lt;/tt&gt; method for any given object. It is
522      * guaranteed, however, that the thread that invokes finalize will not
523      * be holding any user-visible synchronization locks when finalize is
524      * invoked. If an uncaught exception is thrown by the finalize method,
525      * the exception is ignored and finalization of that object terminates.
526      * &lt;p&gt;
527      * After the &lt;tt&gt;finalize&lt;/tt&gt; method has been invoked for an object, no
528      * further action is taken until the Java virtual machine has again
529      * determined that there is no longer any means by which this object can
530      * be accessed by any thread that has not yet died, including possible
531      * actions by other objects or classes which are ready to be finalized,
532      * at which point the object may be discarded.
533      * &lt;p&gt;
534      * The &lt;tt&gt;finalize&lt;/tt&gt; method is never invoked more than once by a Java
535      * virtual machine for any given object.
536      * &lt;p&gt;
537      * Any exception thrown by the &lt;code&gt;finalize&lt;/code&gt; method causes
538      * the finalization of this object to be halted, but is otherwise
539      * ignored.
540      *
541      * @throws Throwable the &lt;code&gt;Exception&lt;/code&gt; raised by this method
542      */
543     protected void finalize() throws Throwable { }
544 
545 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/runtime/appcds/SharedArchiveConsistency.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 /*
 26  * @test
 27  * @summary SharedArchiveConsistency
 28  * @requires vm.cds
 29  * @library /test/lib
 30  * @modules java.base/jdk.internal.misc
 31  *          java.compiler
 32  *          java.management
 33  *          jdk.jartool/sun.tools.jar
 34  *          jdk.internal.jvmstat/sun.jvmstat.monitor
 35  * @build sun.hotspot.WhiteBox
 36  * @compile test-classes/Hello.java
 37  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 38  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI SharedArchiveConsistency
 39  */
 40 import jdk.test.lib.process.OutputAnalyzer;
 41 import jdk.test.lib.Utils;
 42 import java.io.File;
 43 import java.io.FileInputStream;
 44 import java.io.FileOutputStream;
 45 import java.io.IOException;
 46 import java.nio.ByteBuffer;
 47 import java.nio.ByteOrder;
 48 import java.nio.channels.FileChannel;
 49 import java.nio.file.Files;
 50 import java.nio.file.Path;
 51 import java.nio.file.Paths;
 52 import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
 53 import java.nio.file.StandardOpenOption;
 54 import static java.nio.file.StandardOpenOption.READ;
 55 import static java.nio.file.StandardOpenOption.WRITE;
 56 import java.util.ArrayList;
 57 import java.util.HashSet;
 58 import java.util.List;
 59 import java.util.Random;
 60 import sun.hotspot.WhiteBox;
 61 
 62 public class SharedArchiveConsistency {
 63     public static WhiteBox wb;
 64     public static int offset_magic;    // FileMapHeader::_magic
 65     public static int sp_offset_crc;   // CDSFileMapRegion::_crc
 66     public static int file_header_size = -1;// total size of header, variant, need calculation
 67     public static int CDSFileMapRegion_size; // size of CDSFileMapRegion
 68     public static int sp_offset;       // offset of CDSFileMapRegion
 69     public static int sp_used_offset;  // offset of CDSFileMapRegion::_used
 70     public static int size_t_size;     // size of size_t
 71 
 72     public static File jsa;        // will be updated during test
 73     public static File orgJsaFile; // kept the original file not touched.
 74     public static String[] shared_region_name = {&quot;MiscCode&quot;, &quot;ReadWrite&quot;, &quot;ReadOnly&quot;, &quot;MiscData&quot;};
 75     public static int num_regions = shared_region_name.length;
 76     public static String[] matchMessages = {
 77         &quot;Unable to use shared archive&quot;,
 78         &quot;An error has occurred while processing the shared archive file.&quot;,
 79         &quot;Checksum verification failed.&quot;,
 80         &quot;The shared archive file has been truncated.&quot;
 81     };
 82 
 83     public static void getFileOffsetInfo() throws Exception {
 84         wb = WhiteBox.getWhiteBox();
 85         offset_magic = wb.getOffsetForName(&quot;FileMapHeader::_magic&quot;);
 86         sp_offset_crc = wb.getOffsetForName(&quot;CDSFileMapRegion::_crc&quot;);
 87         try {
 88             int nonExistOffset = wb.getOffsetForName(&quot;FileMapHeader::_non_exist_offset&quot;);
 89             System.exit(-1); // should fail
 90         } catch (Exception e) {
 91             // success
 92         }
 93 
 94         sp_offset = wb.getOffsetForName(&quot;FileMapHeader::_space[0]&quot;) - offset_magic;
 95         sp_used_offset = wb.getOffsetForName(&quot;CDSFileMapRegion::_used&quot;) - sp_offset_crc;
 96         size_t_size = wb.getOffsetForName(&quot;size_t_size&quot;);
 97         CDSFileMapRegion_size  = wb.getOffsetForName(&quot;CDSFileMapRegion_size&quot;);
 98     }
 99 
100     public static int getFileHeaderSize(FileChannel fc) throws Exception {
101         if (file_header_size != -1) {
102             return file_header_size;
103         }
104         // this is not real header size, it is struct size
105         file_header_size = wb.getOffsetForName(&quot;file_header_size&quot;);
106         int offset_path_misc_info = wb.getOffsetForName(&quot;FileMapHeader::_paths_misc_info_size&quot;) -
107             offset_magic;
108         int path_misc_info_size   = (int)readInt(fc, offset_path_misc_info, size_t_size);
109         file_header_size += path_misc_info_size; //readInt(fc, offset_path_misc_info, size_t_size);
110         System.out.println(&quot;offset_path_misc_info = &quot; + offset_path_misc_info);
111         System.out.println(&quot;path_misc_info_size   = &quot; + path_misc_info_size);
112         System.out.println(&quot;file_header_size      = &quot; + file_header_size);
113         file_header_size = (int)align_up_page(file_header_size);
114         System.out.println(&quot;file_header_size (aligned to page) = &quot; + file_header_size);
115         return file_header_size;
116     }
117 
118     public static long align_up_page(long l) throws Exception {
119         // wb is obtained in getFileOffsetInfo() which is called first in main() else we should call
120         // WhiteBox.getWhiteBox() here first.
121         int pageSize = wb.getVMPageSize();
122         return (l + pageSize -1) &amp; (~ (pageSize - 1));
123     }
124 
125     private static long getRandomBetween(long start, long end) throws Exception {
126         if (start &gt; end) {
127             throw new IllegalArgumentException(&quot;start must be less than end&quot;);
128         }
129         Random aRandom = Utils.getRandomInstance();
130         int d = aRandom.nextInt((int)(end - start));
131         if (d &lt; 1) {
132             d = 1;
133         }
134         return start + d;
135     }
136 
137     public static long readInt(FileChannel fc, long offset, int nbytes) throws Exception {
138         ByteBuffer bb = ByteBuffer.allocate(nbytes);
139         bb.order(ByteOrder.nativeOrder());
140         fc.position(offset);
141         fc.read(bb);
142         return  (nbytes &gt; 4 ? bb.getLong(0) : bb.getInt(0));
143     }
144 
145     public static void writeData(FileChannel fc, long offset, ByteBuffer bb) throws Exception {
146         fc.position(offset);
147         fc.write(bb);
148         fc.force(true);
149     }
150 
151     public static FileChannel getFileChannel() throws Exception {
152         List&lt;StandardOpenOption&gt; arry = new ArrayList&lt;StandardOpenOption&gt;();
153         arry.add(READ);
154         arry.add(WRITE);
155         return FileChannel.open(jsa.toPath(), new HashSet&lt;StandardOpenOption&gt;(arry));
156     }
157 
158     public static void modifyJsaContentRandomly() throws Exception {
159         FileChannel fc = getFileChannel();
160         // corrupt random area in the data areas (MiscCode, ReadWrite, ReadOnly, MiscData)
161         long[] used    = new long[num_regions];       // record used bytes
162         long start0, start, end, off;
163         int used_offset, path_info_size;
164 
165         int bufSize;
166         System.out.printf(&quot;%-12s%-12s%-12s%-12s%-12s\n&quot;, &quot;Space Name&quot;, &quot;Offset&quot;, &quot;Used bytes&quot;, &quot;Reg Start&quot;, &quot;Random Offset&quot;);
167         start0 = getFileHeaderSize(fc);
168         for (int i = 0; i &lt; num_regions; i++) {
169             used_offset = sp_offset + CDSFileMapRegion_size * i + sp_used_offset;
170             // read &#39;used&#39;
171             used[i] = readInt(fc, used_offset, size_t_size);
172             start = start0;
173             for (int j = 0; j &lt; i; j++) {
174                 start += align_up_page(used[j]);
175             }
176             end = start + used[i];
177             off = getRandomBetween(start, end);
178             System.out.printf(&quot;%-12s%-12d%-12d%-12d%-12d\n&quot;, shared_region_name[i], used_offset, used[i], start, off);
179             if (end - off &lt; 1024) {
180                 bufSize = (int)(end - off + 1);
181             } else {
182                 bufSize = 1024;
183             }
184             ByteBuffer bbuf = ByteBuffer.wrap(new byte[bufSize]);
185             writeData(fc, off, bbuf);
186         }
187         if (fc.isOpen()) {
188             fc.close();
189         }
190     }
191 
192     public static void modifyJsaContent() throws Exception {
193         FileChannel fc = getFileChannel();
194         byte[] buf = new byte[4096];
195         ByteBuffer bbuf = ByteBuffer.wrap(buf);
196 
197         long total = 0L;
198         long used_offset = 0L;
199         long[] used = new long[num_regions];
200         System.out.printf(&quot;%-12s%-12s\n&quot;, &quot;Space name&quot;, &quot;Used bytes&quot;);
201         for (int i = 0; i &lt; num_regions; i++) {
202             used_offset = sp_offset + CDSFileMapRegion_size* i + sp_used_offset;
203             // read &#39;used&#39;
204             used[i] = readInt(fc, used_offset, size_t_size);
205             System.out.printf(&quot;%-12s%-12d\n&quot;, shared_region_name[i], used[i]);
206             total += used[i];
207         }
208         System.out.printf(&quot;%-12s%-12d\n&quot;, &quot;Total: &quot;, total);
209         long corrupt_used_offset =  getFileHeaderSize(fc);
210         System.out.println(&quot;Corrupt RO section, offset = &quot; + corrupt_used_offset);
211         while (used_offset &lt; used[0]) {
212             writeData(fc, corrupt_used_offset, bbuf);
213             bbuf.clear();
214             used_offset += 4096;
215         }
216         fc.force(true);
217         if (fc.isOpen()) {
218             fc.close();
219         }
220     }
221 
222     public static void modifyJsaHeader() throws Exception {
223         FileChannel fc = getFileChannel();
224         // screw up header info
225         byte[] buf = new byte[getFileHeaderSize(fc)];
226         ByteBuffer bbuf = ByteBuffer.wrap(buf);
227         writeData(fc, 0L, bbuf);
228         if (fc.isOpen()) {
229             fc.close();
230         }
231     }
232 
233     public static void copyFile(File from, File to) throws Exception {
234         if (to.exists()) {
235             if(!to.delete()) {
236                 throw new IOException(&quot;Could not delete file &quot; + to);
237             }
238         }
239         to.createNewFile();
240         setReadWritePermission(to);
241         Files.copy(from.toPath(), to.toPath(), REPLACE_EXISTING);
242     }
243 
244     // Copy file with bytes deleted or inserted
245     // del -- true, deleted, false, inserted
246     public static void copyFile(File from, File to, boolean del) throws Exception {
247         try (
248             FileChannel inputChannel = new FileInputStream(from).getChannel();
249             FileChannel outputChannel = new FileOutputStream(to).getChannel()
250         ) {
251             long size = inputChannel.size();
252             int init_size = getFileHeaderSize(inputChannel);
253             outputChannel.transferFrom(inputChannel, 0, init_size);
254             int n = (int)getRandomBetween(0, 1024);
255             if (del) {
256                 System.out.println(&quot;Delete &quot; + n + &quot; bytes at data start section&quot;);
257                 inputChannel.position(init_size + n);
258                 outputChannel.transferFrom(inputChannel, init_size, size - init_size - n);
259             } else {
260                 System.out.println(&quot;Insert &quot; + n + &quot; bytes at data start section&quot;);
261                 outputChannel.position(init_size);
262                 outputChannel.write(ByteBuffer.wrap(new byte[n]));
263                 outputChannel.transferFrom(inputChannel, init_size + n , size - init_size);
264             }
265         }
266     }
267 
268     public static void restoreJsaFile() throws Exception {
269         Files.copy(orgJsaFile.toPath(), jsa.toPath(), REPLACE_EXISTING);
270     }
271 
272     public static void setReadWritePermission(File file) throws Exception {
273         if (!file.canRead()) {
274             if (!file.setReadable(true)) {
275                 throw new IOException(&quot;Cannot modify file &quot; + file + &quot; as readable&quot;);
276             }
277         }
278         if (!file.canWrite()) {
279             if (!file.setWritable(true)) {
280                 throw new IOException(&quot;Cannot modify file &quot; + file + &quot; as writable&quot;);
281             }
282         }
283     }
284 
285     public static void testAndCheck(String[] execArgs) throws Exception {
286         OutputAnalyzer output = TestCommon.execCommon(execArgs);
287         String stdtxt = output.getOutput();
288         System.out.println(&quot;Note: this test may fail in very rare occasions due to CRC32 checksum collision&quot;);
289         for (String message : matchMessages) {
290             if (stdtxt.contains(message)) {
291                 // match any to return
292                 return;
293             }
294         }
295         TestCommon.checkExec(output);
296     }
297 
298     // dump with hello.jsa, then
299     // read the jsa file
300     //   1) run normal
301     //   2) modify header
302     //   3) keep header correct but modify content
303     //   4) update both header and content, test
304     //   5) delete bytes in data begining
305     //   6) insert bytes in data begining
306     //   7) randomly corrupt data in four areas: RO, RW. MISC DATA, MISC CODE
307     public static void main(String... args) throws Exception {
308         // must call to get offset info first!!!
309         getFileOffsetInfo();
310         Path currentRelativePath = Paths.get(&quot;&quot;);
311         String currentDir = currentRelativePath.toAbsolutePath().toString();
312         System.out.println(&quot;Current relative path is: &quot; + currentDir);
313         // get jar file
314         String jarFile = JarBuilder.getOrCreateHelloJar();
315 
316         // dump (appcds.jsa created)
317         TestCommon.testDump(jarFile, null);
318 
319         // test, should pass
320         System.out.println(&quot;1. Normal, should pass but may fail\n&quot;);
321         String[] execArgs = {&quot;-cp&quot;, jarFile, &quot;Hello&quot;};
322 
323         OutputAnalyzer output = TestCommon.execCommon(execArgs);
324 
325         try {
326             TestCommon.checkExecReturn(output, 0, true, &quot;Hello World&quot;);
327         } catch (Exception e) {
328             TestCommon.checkExecReturn(output, 1, true, matchMessages[0]);
329         }
330 
331         // get current archive name
332         jsa = new File(TestCommon.getCurrentArchiveName());
333         if (!jsa.exists()) {
334             throw new IOException(jsa + &quot; does not exist!&quot;);
335         }
336 
337         setReadWritePermission(jsa);
338 
339         // save as original untouched
340         orgJsaFile = new File(new File(currentDir), &quot;appcds.jsa.bak&quot;);
341         copyFile(jsa, orgJsaFile);
342 
343 
344         // modify jsa header, test should fail
345         System.out.println(&quot;\n2. Corrupt header, should fail\n&quot;);
346         modifyJsaHeader();
347         output = TestCommon.execCommon(execArgs);
348         output.shouldContain(&quot;The shared archive file has the wrong version&quot;);
349         output.shouldNotContain(&quot;Checksum verification failed&quot;);
350 
351         // modify content
352         System.out.println(&quot;\n3. Corrupt Content, should fail\n&quot;);
353         copyFile(orgJsaFile, jsa);
354         modifyJsaContent();
355         testAndCheck(execArgs);
356 
357         // modify both header and content, test should fail
358         System.out.println(&quot;\n4. Corrupt Header and Content, should fail\n&quot;);
359         copyFile(orgJsaFile, jsa);
360         modifyJsaHeader();
361         modifyJsaContent();  // this will not be reached since failed on header change first
362         output = TestCommon.execCommon(execArgs);
363         output.shouldContain(&quot;The shared archive file has the wrong version&quot;);
364         output.shouldNotContain(&quot;Checksum verification failed&quot;);
365 
366         // delete bytes in data sectoin
367         System.out.println(&quot;\n5. Delete bytes at begining of data section, should fail\n&quot;);
368         copyFile(orgJsaFile, jsa, true);
369         testAndCheck(execArgs);
370 
371         // insert bytes in data sectoin forward
372         System.out.println(&quot;\n6. Insert bytes at begining of data section, should fail\n&quot;);
373         copyFile(orgJsaFile, jsa, false);
374         testAndCheck(execArgs);
375 
376         System.out.println(&quot;\n7. modify Content in random areas, should fail\n&quot;);
377         copyFile(orgJsaFile, jsa);
378         modifyJsaContentRandomly();
379         testAndCheck(execArgs);
380     }
381 }
    </pre>
  </body>
</html>
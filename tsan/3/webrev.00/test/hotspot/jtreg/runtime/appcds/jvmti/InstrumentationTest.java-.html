<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/runtime/appcds/jvmti/InstrumentationTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 /*
 26  * @test
 27  * @summary Exercise the java.lang.instrument.Instrumentation APIs on classes archived
 28  *          using CDS/AppCDSv1/AppCDSv2.
 29  * @library /test/lib /test/hotspot/jtreg/runtime/appcds /test/hotspot/jtreg/runtime/appcds/test-classes
 30  * @requires vm.cds
 31  * @requires vm.flavor != &quot;minimal&quot;
 32  * @modules java.base/jdk.internal.misc
 33  *          jdk.jartool/sun.tools.jar
 34  *          java.management
 35  * @build sun.hotspot.WhiteBox
 36  *        InstrumentationApp
 37  *        InstrumentationClassFileTransformer
 38  *        InstrumentationRegisterClassFileTransformer
 39  * @run main/othervm InstrumentationTest
 40  */
 41 
 42 // Note: TestCommon is from /test/hotspot/jtreg/runtime/appcds/TestCommon.java
 43 // Note: Util       is from /test/hotspot/jtreg/runtime/appcds/test-classes/TestCommon.java
 44 
 45 import com.sun.tools.attach.VirtualMachine;
 46 import com.sun.tools.attach.VirtualMachineDescriptor;
 47 import java.io.File;
 48 import java.io.FileOutputStream;
 49 import java.util.List;
 50 import jdk.test.lib.Asserts;
 51 import jdk.test.lib.cds.CDSOptions;
 52 import jdk.test.lib.process.OutputAnalyzer;
 53 import jdk.test.lib.process.ProcessTools;
 54 
 55 public class InstrumentationTest {
 56     public static String bootClasses[] = {
 57         &quot;InstrumentationApp$Intf&quot;,
 58         &quot;InstrumentationApp$Bar&quot;,
 59         &quot;sun.hotspot.WhiteBox&quot;,
 60     };
 61     public static String appClasses[] = {
 62         &quot;InstrumentationApp&quot;,
 63         &quot;InstrumentationApp$Foo&quot;,
 64         &quot;InstrumentationApp$MyLoader&quot;,
 65     };
 66     public static String custClasses[] = {
 67         &quot;InstrumentationApp$Coo&quot;,
 68     };
 69     public static String sharedClasses[] = TestCommon.concat(bootClasses, appClasses);
 70 
 71     public static String agentClasses[] = {
 72         &quot;InstrumentationClassFileTransformer&quot;,
 73         &quot;InstrumentationRegisterClassFileTransformer&quot;,
 74         &quot;Util&quot;,
 75     };
 76 
 77     public static void main(String[] args) throws Throwable {
 78         runTest(false);
 79         runTest(true);
 80     }
 81 
 82     public static void runTest(boolean attachAgent) throws Throwable {
 83         String bootJar =
 84             ClassFileInstaller.writeJar(&quot;InstrumentationBoot.jar&quot;, bootClasses);
 85         String appJar =
 86             ClassFileInstaller.writeJar(&quot;InstrumentationApp.jar&quot;,
 87                                         TestCommon.concat(appClasses,
 88                                                           &quot;InstrumentationApp$ArchivedIfAppCDSv2Enabled&quot;));
 89         String custJar =
 90             ClassFileInstaller.writeJar(&quot;InstrumentationCust.jar&quot;, custClasses);
 91         String agentJar =
 92             ClassFileInstaller.writeJar(&quot;InstrumentationAgent.jar&quot;,
 93                                         ClassFileInstaller.Manifest.fromSourceFile(&quot;InstrumentationAgent.mf&quot;),
 94                                         agentClasses);
 95 
 96         String bootCP = &quot;-Xbootclasspath/a:&quot; + bootJar;
 97 
 98         System.out.println(&quot;&quot;);
 99         System.out.println(&quot;============================================================&quot;);
100         System.out.println(&quot;CDS: NO, attachAgent: &quot; + (attachAgent ? &quot;YES&quot; : &quot;NO&quot;));
101         System.out.println(&quot;============================================================&quot;);
102         System.out.println(&quot;&quot;);
103 
104         String agentCmdArg, flagFile;
105         if (attachAgent) {
106             // we will attach the agent, so don&#39;t specify -javaagent in the command line. We&#39;ll use
107             // something harmless like -showversion to make it easier to construct the command line
108             agentCmdArg = &quot;-showversion&quot;;
109         } else {
110             agentCmdArg = &quot;-javaagent:&quot; + agentJar;
111         }
112 
113         // First, run the test class directly, w/o sharing, as a baseline reference
114         flagFile = getFlagFile(attachAgent);
115         AgentAttachThread t = doAttach(attachAgent, flagFile, agentJar);
116         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(
117                 bootCP,
118                 &quot;-cp&quot;, appJar,
119                 &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
120                 &quot;-XX:+WhiteBoxAPI&quot;,
121                 &quot;-Xshare:off&quot;,
122                 agentCmdArg,
123                 &quot;InstrumentationApp&quot;, flagFile, bootJar, appJar, custJar);
124         TestCommon.executeAndLog(pb, &quot;no-sharing&quot;).shouldHaveExitValue(0);
125         checkAttach(t);
126 
127         // Dump the AppCDS archive. On some platforms AppCDSv2 may not be enabled, so we
128         // first try the v2 classlist, and if that fails, revert to the v1 classlist.
129         // Note that the InstrumentationApp$ArchivedIfAppCDSv2Enabled class is archived
130         // only if V2 is enabled. This is tested by InstrumentationApp.isAppCDSV2Enabled().
131         String[] v2Classes = {
132             &quot;InstrumentationApp$ArchivedIfAppCDSv2Enabled&quot;,
133             &quot;java/lang/Object id: 0&quot;,
134             &quot;InstrumentationApp$Intf id: 1&quot;,
135             &quot;InstrumentationApp$Coo  id: 2 super: 0 interfaces: 1 source: &quot; + custJar,
136         };
137         String[] sharedClassesWithV2 = TestCommon.concat(v2Classes, sharedClasses);
138         OutputAnalyzer out = TestCommon.dump(appJar, sharedClassesWithV2, bootCP);
139         if (out.getExitValue() != 0) {
140             System.out.println(&quot;Redumping with AppCDSv2 disabled&quot;);
141                 TestCommon.testDump(appJar, sharedClasses, bootCP);
142         }
143 
144         // Run with AppCDS.
145         System.out.println(&quot;&quot;);
146         System.out.println(&quot;============================================================&quot;);
147         System.out.println(&quot;CDS: YES, attachAgent: &quot; + (attachAgent ? &quot;YES&quot; : &quot;NO&quot;));
148         System.out.println(&quot;============================================================&quot;);
149         System.out.println(&quot;&quot;);
150 
151         flagFile = getFlagFile(attachAgent);
152         t = doAttach(attachAgent, flagFile, agentJar);
153         out = TestCommon.execAuto(&quot;-cp&quot;, appJar,
154                 bootCP,
155                 &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
156                 &quot;-XX:+WhiteBoxAPI&quot;,
157                 agentCmdArg,
158                &quot;InstrumentationApp&quot;, flagFile, bootJar, appJar, custJar);
159 
160         CDSOptions opts = (new CDSOptions()).setXShareMode(&quot;auto&quot;);
161         TestCommon.checkExec(out, opts);
162         checkAttach(t);
163     }
164 
165     static int flagFileSerial = 1;
166     static private String getFlagFile(boolean attachAgent) {
167         if (attachAgent) {
168             // Do not reuse the same file name as Windows may fail to
169             // delete the file.
170             return &quot;attach.flag.&quot; + ProcessHandle.current().pid() +
171                     &quot;.&quot; + (flagFileSerial++) + &quot;.&quot; + System.currentTimeMillis();
172         } else {
173             return &quot;noattach&quot;;
174         }
175     }
176 
177     static AgentAttachThread doAttach(boolean attachAgent, String flagFile, String agentJar) throws Throwable {
178         if (!attachAgent) {
179             return null;
180         }
181 
182         // We use the flagFile to prevent the child process to make progress, until we have
183         // attached to it.
184         File f = new File(flagFile);
185         try (FileOutputStream o = new FileOutputStream(f)) {
186             o.write(1);
187         }
188         if (!f.exists()) {
189             throw new RuntimeException(&quot;Failed to create &quot; + f);
190         }
191 
192         // At this point, the child process is not yet launched. Note that
193         // TestCommon.exec() and OutputAnalyzer.OutputAnalyzer() both block
194         // until the child process has finished.
195         //
196         // So, we will launch a AgentAttachThread which will poll the system
197         // until the child process is launched, and then do the attachment.
198         // The child process is uniquely identified by having flagFile in its
199         // command-line -- see AgentAttachThread.getPid().
200         AgentAttachThread t = new AgentAttachThread(flagFile, agentJar);
201         t.start();
202         return t;
203     }
204 
205     static void checkAttach(AgentAttachThread thread) throws Throwable {
206         if (thread != null) {
207             thread.check();
208         }
209     }
210 
211     static class AgentAttachThread extends Thread {
212         String flagFile;
213         String agentJar;
214         volatile boolean succeeded;
215 
216         AgentAttachThread(String flagFile, String agentJar) {
217             this.flagFile = flagFile;
218             this.agentJar = agentJar;
219             this.succeeded = false;
220         }
221 
222         static String getPid(String flagFile) throws Throwable {
223             while (true) {
224                 // Keep polling until the child process has been launched. If for some
225                 // reason the child process fails to launch, this test will be terminated
226                 // by JTREG&#39;s time-out mechanism.
227                 Thread.sleep(100);
228                 List&lt;VirtualMachineDescriptor&gt; vmds = VirtualMachine.list();
229                 for (VirtualMachineDescriptor vmd : vmds) {
230                     if (vmd.displayName().contains(flagFile) &amp;&amp; vmd.displayName().contains(&quot;InstrumentationApp&quot;)) {
231                         // We use flagFile (which has the PID of this process) as a unique identifier
232                         // to ident the child process, which we want to attach to.
233                         System.out.println(&quot;Process found: &quot; + vmd.id() + &quot; &quot; + vmd.displayName());
234                         return vmd.id();
235                     }
236                 }
237             }
238         }
239 
240         public void run() {
241             try {
242                 String pid = getPid(flagFile);
243                 VirtualMachine vm = VirtualMachine.attach(pid);
244                 System.out.println(agentJar);
245                 vm.loadAgent(agentJar);
246             } catch (Throwable t) {
247                 t.printStackTrace();
248                 throw new RuntimeException(t);
249             }
250 
251             // Delete the flagFile to indicate to the child process that we
252             // have attached to it, so it should proceed.
253             File f = new File(flagFile);
254             for (int i=0; i&lt;5; i++) {
255                 // The detele may fail on Windows if the child JVM is checking
256                 // f.exists() at exactly the same time?? Let&#39;s do a little
257                 // dance.
258                 f.delete();
259                 try {
260                     Thread.sleep(10);
261                 } catch (Throwable t) {;}
262             }
263             if (f.exists()) {
264                 throw new RuntimeException(&quot;Failed to delete &quot; + f);
265             }
266             System.out.println(&quot;Attach succeeded (parent)&quot;);
267             succeeded = true;
268         }
269 
270         void check() throws Throwable {
271             super.join();
272             if (!succeeded) {
273                 throw new RuntimeException(&quot;Attaching agent to child VM failed&quot;);
274             }
275         }
276     }
277 }
278 
    </pre>
  </body>
</html>
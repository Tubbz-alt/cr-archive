<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/runtime/appcds/TestCommon.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 import jdk.test.lib.Utils;
 26 import jdk.test.lib.BuildHelper;
 27 import jdk.test.lib.JDKToolFinder;
 28 import jdk.test.lib.Platform;
 29 import jdk.test.lib.cds.CDSOptions;
 30 import jdk.test.lib.cds.CDSTestUtils;
 31 import jdk.test.lib.cds.CDSTestUtils.Result;
 32 import jdk.test.lib.process.ProcessTools;
 33 import jdk.test.lib.process.OutputAnalyzer;
 34 import java.io.File;
 35 import java.text.SimpleDateFormat;
 36 import java.util.Arrays;
 37 import java.util.ArrayList;
 38 import java.util.Date;
 39 
 40 /**
 41  * This is a test utility class for common AppCDS test functionality.
 42  *
 43  * Various methods use (String ...) for passing VM options. Note that the order
 44  * of the VM options are important in certain cases. Many methods take arguments like
 45  *
 46  *    (String prefix[], String suffix[], String... opts)
 47  *
 48  * Note that the order of the VM options is:
 49  *
 50  *    prefix + opts + suffix
 51  */
 52 public class TestCommon extends CDSTestUtils {
 53     private static final String JSA_FILE_PREFIX = System.getProperty(&quot;user.dir&quot;) +
 54         File.separator + &quot;appcds-&quot;;
 55 
 56     private static final SimpleDateFormat timeStampFormat =
 57         new SimpleDateFormat(&quot;HH&#39;h&#39;mm&#39;m&#39;ss&#39;s&#39;SSS&quot;);
 58 
 59     private static final String timeoutFactor =
 60         System.getProperty(&quot;test.timeout.factor&quot;, &quot;1.0&quot;);
 61 
 62     private static String currentArchiveName;
 63 
 64     // Call this method to start new archive with new unique name
 65     public static void startNewArchiveName() {
 66         deletePriorArchives();
 67         currentArchiveName = JSA_FILE_PREFIX +
 68             timeStampFormat.format(new Date()) + &quot;.jsa&quot;;
 69     }
 70 
 71     // Call this method to get current archive name
 72     public static String getCurrentArchiveName() {
 73         return currentArchiveName;
 74     }
 75 
 76     // Attempt to clean old archives to preserve space
 77     // Archives are large artifacts (20Mb or more), and much larger than
 78     // most other artifacts created in jtreg testing.
 79     // Therefore it is a good idea to clean the old archives when they are not needed.
 80     // In most cases the deletion attempt will succeed; on rare occasion the
 81     // delete operation will fail since the system or VM process still holds a handle
 82     // to the file; in such cases the File.delete() operation will silently fail, w/o
 83     // throwing an exception, thus allowing testing to continue.
 84     public static void deletePriorArchives() {
 85         File dir = new File(System.getProperty(&quot;user.dir&quot;));
 86         String files[] = dir.list();
 87         for (String name : files) {
 88             if (name.startsWith(&quot;appcds-&quot;) &amp;&amp; name.endsWith(&quot;.jsa&quot;)) {
 89                 if (!(new File(dir, name)).delete())
 90                     System.out.println(&quot;deletePriorArchives(): delete failed for file &quot; + name);
 91             }
 92         }
 93     }
 94 
 95 
 96     // Create AppCDS archive using most common args - convenience method
 97     // Legacy name preserved for compatibility
 98     public static OutputAnalyzer dump(String appJar, String classList[],
 99                                                String... suffix) throws Exception {
100         return createArchive(appJar, classList, suffix);
101     }
102 
103 
104     // Create AppCDS archive using most common args - convenience method
105     public static OutputAnalyzer createArchive(String appJar, String classList[],
106                                                String... suffix) throws Exception {
107         AppCDSOptions opts = (new AppCDSOptions()).setAppJar(appJar);
108         opts.setClassList(classList);
109         opts.addSuffix(suffix);
110         return createArchive(opts);
111     }
112 
113     // Create AppCDS archive using appcds options
114     public static OutputAnalyzer createArchive(AppCDSOptions opts)
115         throws Exception {
116 
117         ArrayList&lt;String&gt; cmd = new ArrayList&lt;String&gt;();
118         startNewArchiveName();
119 
120         for (String p : opts.prefix) cmd.add(p);
121 
122         if (opts.appJar != null) {
123             cmd.add(&quot;-cp&quot;);
124             cmd.add(opts.appJar);
125         } else {
126             cmd.add(&quot;-Djava.class.path=&quot;);
127         }
128 
129         cmd.add(&quot;-Xshare:dump&quot;);
130 
131         if (opts.archiveName == null)
132             opts.archiveName = getCurrentArchiveName();
133 
134         cmd.add(&quot;-XX:SharedArchiveFile=&quot; + opts.archiveName);
135 
136         if (opts.classList != null) {
137             File classListFile = makeClassList(opts.classList);
138             cmd.add(&quot;-XX:ExtraSharedClassListFile=&quot; + classListFile.getPath());
139         }
140 
141         for (String s : opts.suffix) cmd.add(s);
142 
143         String[] cmdLine = cmd.toArray(new String[cmd.size()]);
144         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, cmdLine);
145         return executeAndLog(pb, &quot;dump&quot;);
146     }
147 
148 
149     // Execute JVM using AppCDS archive with specified AppCDSOptions
150     public static OutputAnalyzer runWithArchive(AppCDSOptions opts)
151         throws Exception {
152 
153         ArrayList&lt;String&gt; cmd = new ArrayList&lt;String&gt;();
154 
155         for (String p : opts.prefix) cmd.add(p);
156 
157         cmd.add(&quot;-Xshare:&quot; + opts.xShareMode);
158         cmd.add(&quot;-showversion&quot;);
159         cmd.add(&quot;-XX:SharedArchiveFile=&quot; + getCurrentArchiveName());
160         cmd.add(&quot;-Dtest.timeout.factor=&quot; + timeoutFactor);
161 
162         if (opts.appJar != null) {
163             cmd.add(&quot;-cp&quot;);
164             cmd.add(opts.appJar);
165         }
166 
167         for (String s : opts.suffix) cmd.add(s);
168 
169         String[] cmdLine = cmd.toArray(new String[cmd.size()]);
170         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, cmdLine);
171         return executeAndLog(pb, &quot;exec&quot;);
172     }
173 
174 
175     public static OutputAnalyzer execCommon(String... suffix) throws Exception {
176         AppCDSOptions opts = (new AppCDSOptions());
177         opts.addSuffix(suffix);
178         return runWithArchive(opts);
179     }
180 
181     // This is the new API for running a Java process with CDS enabled.
182     // See comments in the CDSTestUtils.Result class for how to use this method.
183     public static Result run(String... suffix) throws Exception {
184         AppCDSOptions opts = (new AppCDSOptions());
185         opts.addSuffix(suffix);
186         return new Result(opts, runWithArchive(opts));
187     }
188 
189     public static OutputAnalyzer exec(String appJar, String... suffix) throws Exception {
190         AppCDSOptions opts = (new AppCDSOptions()).setAppJar(appJar);
191         opts.addSuffix(suffix);
192         return runWithArchive(opts);
193     }
194 
195     public static Result runWithModules(String prefix[], String upgrademodulepath, String modulepath,
196                                             String mid, String... testClassArgs) throws Exception {
197         AppCDSOptions opts = makeModuleOptions(prefix, upgrademodulepath, modulepath,
198                                                mid, testClassArgs);
199         return new Result(opts, runWithArchive(opts));
200     }
201 
202     public static OutputAnalyzer execAuto(String... suffix) throws Exception {
203         AppCDSOptions opts = (new AppCDSOptions());
204         opts.addSuffix(suffix).setXShareMode(&quot;auto&quot;);
205         return runWithArchive(opts);
206     }
207 
208     public static OutputAnalyzer execOff(String... suffix) throws Exception {
209         AppCDSOptions opts = (new AppCDSOptions());
210         opts.addSuffix(suffix).setXShareMode(&quot;off&quot;);
211         return runWithArchive(opts);
212     }
213 
214 
215     private static AppCDSOptions makeModuleOptions(String prefix[], String upgrademodulepath, String modulepath,
216                                             String mid, String testClassArgs[]) {
217         AppCDSOptions opts = (new AppCDSOptions());
218 
219         opts.addPrefix(prefix);
220         if (upgrademodulepath == null) {
221             opts.addSuffix(&quot;-p&quot;, modulepath, &quot;-m&quot;, mid);
222         } else {
223             opts.addSuffix(&quot;--upgrade-module-path&quot;, upgrademodulepath,
224                            &quot;-p&quot;, modulepath, &quot;-m&quot;, mid);
225         }
226         opts.addSuffix(testClassArgs);
227         return opts;
228     }
229 
230     public static OutputAnalyzer execModule(String prefix[], String upgrademodulepath, String modulepath,
231                                             String mid, String... testClassArgs)
232         throws Exception {
233         AppCDSOptions opts = makeModuleOptions(prefix, upgrademodulepath, modulepath,
234                                                mid, testClassArgs);
235         return runWithArchive(opts);
236     }
237 
238 
239     // A common operation: dump, then check results
240     public static OutputAnalyzer testDump(String appJar, String classList[],
241                                           String... suffix) throws Exception {
242         OutputAnalyzer output = dump(appJar, classList, suffix);
243         output.shouldContain(&quot;Loading classes to share&quot;);
244         output.shouldHaveExitValue(0);
245         return output;
246     }
247 
248 
249     /**
250      * Simple test -- dump and execute appJar with the given classList in classlist.
251      */
252     public static OutputAnalyzer test(String appJar, String classList[], String... args)
253         throws Exception {
254         testDump(appJar, classList);
255 
256         OutputAnalyzer output = exec(appJar, args);
257         return checkExec(output);
258     }
259 
260 
261     public static OutputAnalyzer checkExecReturn(OutputAnalyzer output, int ret,
262                            boolean checkContain, String... matches) throws Exception {
263         try {
264             for (String s : matches) {
265                 if (checkContain) {
266                     output.shouldContain(s);
267                 } else {
268                     output.shouldNotContain(s);
269                 }
270             }
271             output.shouldHaveExitValue(ret);
272         } catch (Exception e) {
273             checkCommonExecExceptions(output, e);
274         }
275 
276         return output;
277     }
278 
279 
280     // Convenience concatenation utils
281     public static String[] list(String ...args) {
282         return args;
283     }
284 
285 
286     public static String[] list(String arg, int count) {
287         ArrayList&lt;String&gt; stringList = new ArrayList&lt;String&gt;();
288         for (int i = 0; i &lt; count; i++) {
289             stringList.add(arg);
290         }
291 
292         String outputArray[] = stringList.toArray(new String[stringList.size()]);
293         return outputArray;
294     }
295 
296 
297     public static String[] concat(String... args) {
298         return list(args);
299     }
300 
301 
302     public static String[] concat(String prefix[], String... extra) {
303         ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
304         for (String s : prefix) {
305             list.add(s);
306         }
307         for (String s : extra) {
308             list.add(s);
309         }
310 
311         return list.toArray(new String[list.size()]);
312     }
313 
314 
315     // ===================== Concatenate paths
316     public static String concatPaths(String... paths) {
317         String prefix = &quot;&quot;;
318         String s = &quot;&quot;;
319         for (String p : paths) {
320             s += prefix;
321             s += p;
322             prefix = File.pathSeparator;
323         }
324         return s;
325     }
326 
327 
328     public static String getTestJar(String jar) {
329         File jarFile = CDSTestUtils.getTestArtifact(jar, true);
330         if (!jarFile.isFile()) {
331             throw new RuntimeException(&quot;Not a regular file: &quot; + jarFile.getPath());
332         }
333         return jarFile.getPath();
334     }
335 
336 
337     public static String getTestDir(String d) {
338         File dirFile = CDSTestUtils.getTestArtifact(d, true);
339         if (!dirFile.isDirectory()) {
340             throw new RuntimeException(&quot;Not a directory: &quot; + dirFile.getPath());
341         }
342         return dirFile.getPath();
343     }
344 
345     public static boolean checkOutputStrings(String outputString1,
346                                              String outputString2,
347                                              String split_regex) {
348         String[] sa1 = outputString1.split(split_regex);
349         String[] sa2 = outputString2.split(split_regex);
350         Arrays.sort(sa1);
351         Arrays.sort(sa2);
352 
353         int i = 0;
354         for (String s : sa1) {
355             if (!s.equals(sa2[i])) {
356                 throw new RuntimeException(s + &quot; is different from &quot; + sa2[i]);
357             }
358             i ++;
359         }
360         return true;
361     }
362 }
    </pre>
  </body>
</html>
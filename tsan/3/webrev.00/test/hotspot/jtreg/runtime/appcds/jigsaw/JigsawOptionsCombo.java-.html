<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/runtime/appcds/jigsaw/JigsawOptionsCombo.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 /*
 26  * @test
 27  * @summary Test combinations of jigsaw options that affect the use of AppCDS
 28  *
 29  * @requires vm.cds &amp; !vm.graal.enabled
 30  * @library /test/lib ..
 31  * @modules java.base/jdk.internal.misc
 32  *          java.management
 33  *          jdk.jartool/sun.tools.jar
 34  *          jdk.internal.jvmstat/sun.jvmstat.monitor
 35  * @compile ../test-classes/Hello.java ../test-classes/HelloMore.java
 36  * @run driver JigsawOptionsCombo
 37  */
 38 import jdk.test.lib.compiler.InMemoryJavaCompiler;
 39 import jdk.test.lib.process.OutputAnalyzer;
 40 import java.util.ArrayList;
 41 
 42 
 43 // Remaining WORK: TODO:
 44 // 1. test with -m initial-module; waiting for changes from Chris will provide
 45 //    utils to build modules
 46 // 2. Loading classes from Jmod files - waiting on utils
 47 // 3. Loading classes from exploded module dir&quot;
 48 
 49 public class JigsawOptionsCombo {
 50 
 51     public static void main(String[] args) throws Exception {
 52         String source = &quot;package javax.naming.spi; &quot;                +
 53                         &quot;public class NamingManager { &quot;             +
 54                         &quot;    static { &quot;                             +
 55                         &quot;        System.out.println(\&quot;I pass!\&quot;); &quot; +
 56                         &quot;    } &quot;                                    +
 57                         &quot;}&quot;;
 58         ClassFileInstaller.writeClassToDisk(&quot;javax/naming/spi/NamingManager&quot;,
 59             InMemoryJavaCompiler.compile(&quot;javax.naming.spi.NamingManager&quot;, source, &quot;--patch-module=java.naming&quot;),
 60             &quot;mods/java.naming&quot;);
 61 
 62         JarBuilder.build(&quot;hello&quot;, &quot;Hello&quot;);
 63         JarBuilder.build(&quot;hello_more&quot;, &quot;HelloMore&quot;);
 64 
 65         (new JigsawOptionsCombo()).runTests();
 66     }
 67 
 68 
 69     private ArrayList&lt;TestCase&gt; testCaseTable = new ArrayList&lt;TestCase&gt;();
 70 
 71     public static String infoDuringDump(String option) {
 72         return &quot;Cannot use the following option when dumping the shared archive: &quot; + option;
 73     }
 74 
 75     public void runTests() throws Exception {
 76 
 77         testCaseTable.add(new TestCase(
 78             &quot;basic: Basic dump and execute, to verify the test plumbing works&quot;,
 79             &quot;&quot;, &quot;&quot;, 0,
 80             &quot;&quot;, &quot;&quot;, 0, true) );
 81 
 82         String bcpArg = &quot;-Xbootclasspath/a:&quot; +
 83         TestCommon.getTestJar(&quot;hello_more.jar&quot;);
 84 
 85         testCaseTable.add(new TestCase(
 86             &quot;Xbootclasspath/a: is OK for both dump and run time&quot;,
 87             bcpArg, &quot;&quot;, 0,
 88             bcpArg, &quot;&quot;, 0, true) );
 89 
 90         testCaseTable.add(new TestCase(
 91             &quot;module-path-01: --module-path is ignored for dump time&quot;,
 92             &quot;--module-path mods&quot;, &quot;&quot;, 0,
 93             null, null, 0, true) );
 94 
 95         testCaseTable.add(new TestCase(
 96             &quot;module-path-02: --module-path is ok for run time&quot;,
 97             &quot;&quot;, &quot;&quot;, 0,
 98             &quot;--module-path mods&quot;, &quot;&quot;, 0, true) );
 99 
100         testCaseTable.add(new TestCase(
101             &quot;add-modules-01: --add-modules is ok at dump time&quot;,
102             &quot;--add-modules java.management&quot;,
103             &quot;&quot;, 0,
104             null, null, 0, true) );
105 
106         testCaseTable.add(new TestCase(
107             &quot;add-modules-02: --add-modules is ok at run time&quot;,
108             &quot;&quot;, &quot;&quot;, 0,
109             &quot;--add-modules java.management&quot;, &quot;&quot;, 0, true) );
110 
111         testCaseTable.add(new TestCase(
112             &quot;limit-modules-01: --limit-modules is ignored at dump time&quot;,
113             &quot;--limit-modules java.base&quot;,
114             infoDuringDump(&quot;--limit-modules&quot;), 1,
115             null, null, 0, true) );
116 
117         testCaseTable.add(new TestCase(
118             &quot;limit-modules-02: --limit-modules is ok at run time&quot;,
119             &quot;&quot;, &quot;&quot;, 0,
120             &quot;--limit-modules java.base&quot;, &quot;&quot;, 0, false) );
121 
122         testCaseTable.add(new TestCase(
123             &quot;upgrade-module-path-01: --upgrade-module-path is ignored at dump time&quot;,
124             &quot;--upgrade-module-path mods&quot;,
125             infoDuringDump(&quot;--upgrade-module-path&quot;), 1,
126             null, null, 0, true) );
127 
128         testCaseTable.add(new TestCase(
129             &quot;-upgrade-module-path-module-path-02: --upgrade-module-path is ok at run time&quot;,
130             &quot;&quot;, &quot;&quot;, 0,
131             &quot;--upgrade-module-path mods&quot;, &quot;&quot;, 0, false) );
132 
133         for (TestCase tc : testCaseTable) tc.execute();
134     }
135 
136 
137     // class representing a singe test case
138     public class TestCase {
139         String description;
140         String dumpTimeArgs;
141         String dumpTimeExpectedOutput;
142         int    dumpTimeExpectedExitValue;
143         String runTimeArgs;
144         String runTimeExpectedOutput;
145         int    runTimeExpectedExitValue;
146         boolean sharingOn;
147 
148         private String appJar = TestCommon.getTestJar(&quot;hello.jar&quot;);
149         private String appClasses[] = {&quot;Hello&quot;};
150 
151 
152         public TestCase(String description,
153             String dumpTimeArgs, String dumpTimeExpectedOutput, int dumpTimeExpectedExitValue,
154             String runTimeArgs, String runTimeExpectedOutput, int runTimeExpectedExitValue,
155             boolean sharingOn) {
156 
157             this.description = description;
158             this.dumpTimeArgs = dumpTimeArgs;
159             this.dumpTimeExpectedOutput = dumpTimeExpectedOutput;
160             this.dumpTimeExpectedExitValue = dumpTimeExpectedExitValue;
161             this.runTimeArgs = runTimeArgs;
162             this.runTimeExpectedOutput = runTimeExpectedOutput;
163             this.runTimeExpectedExitValue = runTimeExpectedExitValue;
164             this.sharingOn = sharingOn;
165         }
166 
167 
168         public void execute() throws Exception {
169             System.out.println(&quot;Description: &quot; + description);
170 
171             // ===== dump step - create the archive
172             OutputAnalyzer dumpOutput = TestCommon.dump(
173                 appJar, appClasses, getDumpOptions());
174 
175             if (dumpTimeExpectedExitValue == 0) {
176                 TestCommon.checkDump(dumpOutput, dumpTimeExpectedOutput);
177             } else {
178                 dumpOutput.shouldMatch(dumpTimeExpectedOutput);
179                 dumpOutput.shouldHaveExitValue(dumpTimeExpectedExitValue);
180             }
181 
182             // ===== exec step - use the archive
183             if (runTimeArgs != null) {
184                 OutputAnalyzer execOutput = TestCommon.exec(appJar, getRunOptions());
185 
186                 if (runTimeExpectedExitValue == 0) {
187                     if (sharingOn) {
188                         TestCommon.checkExec(execOutput, runTimeExpectedOutput, &quot;Hello World&quot;);
189                     } else {
190                         execOutput.shouldHaveExitValue(0)
191                                   .shouldContain(runTimeExpectedOutput)
192                                   .shouldContain(&quot;Hello World&quot;);
193                     }
194                 } else {
195                     execOutput.shouldMatch(dumpTimeExpectedOutput);
196                     execOutput.shouldHaveExitValue(dumpTimeExpectedExitValue);
197                 }
198             }
199         }
200 
201 
202         // dump command line options can be separated by a space
203         private String[] getDumpOptions() {
204             return dumpTimeArgs.split(&quot; &quot;);
205         }
206 
207 
208         // run command line options can be separated by a space
209         private String[] getRunOptions() {
210             ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();
211 
212             if (runTimeArgs != &quot;&quot;) {
213                 String splitArgs[] = runTimeArgs.split(&quot; &quot;);
214                 for (String arg : splitArgs)
215                     result.add(arg);
216             }
217 
218             result.add(&quot;Hello&quot;);
219             return result.toArray(new String[1]);
220         }
221     }
222 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/runtime/appcds/VerifierTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 import java.io.File;
 26 import java.io.FileOutputStream;
 27 import jdk.test.lib.process.OutputAnalyzer;
 28 import java.nio.file.Files;
 29 
 30 import java.util.*;
 31 import jdk.internal.org.objectweb.asm.*;
 32 
 33 /**
 34  * The testsets contained in this class are executed by ./VerifierTest_*.java, so that
 35  * individual testsets can be executed in parallel to shorten the total time required.
 36  */
 37 public class VerifierTest implements Opcodes {
 38     // Test verification settings for dumping &amp; runtime
 39     static final String VFY_ALL = &quot;-Xverify:all&quot;;
 40     static final String VFY_REMOTE = &quot;-Xverify:remote&quot;; // default
 41     static final String VFY_NONE = &quot;-XX:-BytecodeVerificationRemote, -XX:-BytecodeVerificationLocal&quot;;
 42 
 43     static final String ERR =
 44         &quot;ERROR: class VerifierTestC was loaded unexpectedly&quot;;
 45     static final String MAP_FAIL =
 46         &quot;shared archive file was created with less restrictive verification setting&quot;;
 47     static final String VFY_ERR = &quot;java.lang.VerifyError&quot;;
 48     static final String PASS_RESULT = &quot;Hi, how are you?&quot;;
 49     static final String VFY_INFO_MESSAGE =
 50         &quot;All non-system classes will be verified (-Xverify:remote) during CDS dump time.&quot;;
 51     static final String CDS_LOGGING = &quot;-Xlog:cds,cds+hashtables&quot;;
 52 
 53     enum Testset1Part {
 54         A, B
 55     }
 56 
 57     public static void main(String[] args) throws Exception {
 58         String subCaseId = args[0];
 59         String jarName_verifier_test_tmp = &quot;verifier_test_tmp&quot; + &quot;_&quot; + subCaseId;
 60         String jarName_verifier_test = &quot;verifier_test&quot; + &quot;_&quot; + subCaseId;
 61         String jarName_greet = &quot;greet&quot; + &quot;_&quot; + subCaseId;
 62         String jarName_hi = &quot;hi&quot; + &quot;_&quot; + subCaseId;
 63 
 64 
 65         JarBuilder.build(jarName_verifier_test_tmp, &quot;VerifierTest0&quot;, &quot;VerifierTestA&quot;,
 66                          &quot;VerifierTestB&quot;, &quot;VerifierTestC&quot;, &quot;VerifierTestD&quot;, &quot;VerifierTestE&quot;,
 67                          &quot;UnverifiableBase&quot;, &quot;UnverifiableIntf&quot;, &quot;UnverifiableIntfSub&quot;);
 68         JarBuilder.build(jarName_greet, &quot;Greet&quot;);
 69         JarBuilder.build(jarName_hi, &quot;Hi&quot;, &quot;Hi$MyClass&quot;);
 70 
 71         File dir = new File(System.getProperty(&quot;test.classes&quot;, &quot;.&quot;));
 72         File jarSrcFile = new File(dir, jarName_verifier_test_tmp + &quot;.jar&quot;);
 73         File jarFile = new File(dir, jarName_verifier_test + &quot;.jar&quot;);
 74         String jar = jarFile.getPath();
 75 
 76         if (!jarFile.exists() || jarFile.lastModified() &lt; jarSrcFile.lastModified()) {
 77             createTestJarFile(jarSrcFile, jarFile);
 78         } else {
 79             System.out.println(&quot;Already up-to-date: &quot; + jarFile);
 80         }
 81 
 82         String noAppClasses[] = TestCommon.list(&quot;&quot;);
 83         String appClasses[] = TestCommon.list(&quot;UnverifiableBase&quot;,
 84                                               &quot;UnverifiableIntf&quot;,
 85                                               &quot;UnverifiableIntfSub&quot;,
 86                                               &quot;VerifierTestA&quot;,
 87                                               &quot;VerifierTestB&quot;,
 88                                               &quot;VerifierTestC&quot;,
 89                                               &quot;VerifierTestD&quot;,
 90                                               &quot;VerifierTestE&quot;,
 91                                               &quot;VerifierTest0&quot;);
 92 
 93 
 94         switch (subCaseId) {
 95         case &quot;0&quot;:         testset_0(jar, noAppClasses, appClasses);                 return;
 96         case &quot;1A&quot;:        testset_1(jar, noAppClasses, appClasses, Testset1Part.A); return;
 97         case &quot;1B&quot;:        testset_1(jar, noAppClasses, appClasses, Testset1Part.B); return;
 98         case &quot;2&quot;:         testset_2(jarName_greet, jarName_hi);                   return;
 99         default:
100             throw new RuntimeException(&quot;Unknown option: &quot; + subCaseId);
101         }
102     }
103 
104     static void testset_0(String jar, String[] noAppClasses, String[] appClasses) throws Exception {
105         // Unverifiable classes won&#39;t be included in the CDS archive.
106         // Dumping should not fail.
107         OutputAnalyzer output = TestCommon.dump(jar, appClasses);
108         output.shouldHaveExitValue(0);
109         if (output.getStdout().contains(&quot;Loading clases to share&quot;)) {
110             // last entry in appClasses[] is a verifiable class
111             for (int i = 0; i &lt; (appClasses.length - 1); i++) {
112                 output.shouldContain(&quot;Verification failed for &quot; + appClasses[i]);
113                 output.shouldContain(&quot;Removed error class: &quot; + appClasses[i]);
114             }
115         }
116     }
117 
118     static void checkRuntimeOutput(OutputAnalyzer output, String expected) throws Exception {
119         output.shouldContain(expected);
120         if (expected.equals(PASS_RESULT) ||
121             expected.equals(VFY_ERR)) {
122             output.shouldHaveExitValue(0);
123         } else {
124             output.shouldNotHaveExitValue(0);
125         }
126     }
127 
128     static void testset_1(String jar, String[] noAppClasses, String[] appClasses, Testset1Part part)
129         throws Exception
130     {
131         String config[][] = {
132             // {dump_list, dumptime_verification_setting,
133             //  runtime_verification_setting, expected_output_str},
134 
135             // Dump app/ext with -Xverify:remote
136             {&quot;app&quot;,   VFY_REMOTE, VFY_REMOTE, VFY_ERR},
137             {&quot;app&quot;,   VFY_REMOTE, VFY_ALL,    MAP_FAIL},
138             {&quot;app&quot;,   VFY_REMOTE, VFY_NONE,   ERR },
139             // Dump app/ext with -Xverify:all
140             {&quot;app&quot;,   VFY_ALL,    VFY_REMOTE, VFY_ERR },
141             {&quot;app&quot;,   VFY_ALL,    VFY_ALL,    VFY_ERR },
142             {&quot;app&quot;,   VFY_ALL,    VFY_NONE,   ERR },
143             // Dump app/ext with verifier turned off
144             {&quot;app&quot;,   VFY_NONE,   VFY_REMOTE, VFY_ERR},
145             {&quot;app&quot;,   VFY_NONE,   VFY_ALL,    MAP_FAIL},
146             {&quot;app&quot;,   VFY_NONE,   VFY_NONE,   ERR },
147             // Dump sys only with -Xverify:remote
148             {&quot;noApp&quot;, VFY_REMOTE, VFY_REMOTE, VFY_ERR},
149             {&quot;noApp&quot;, VFY_REMOTE, VFY_ALL,    VFY_ERR},
150             {&quot;noApp&quot;, VFY_REMOTE, VFY_NONE,   ERR},
151             // Dump sys only with -Xverify:all
152             {&quot;noApp&quot;, VFY_ALL, VFY_REMOTE,    VFY_ERR},
153             {&quot;noApp&quot;, VFY_ALL, VFY_ALL,       VFY_ERR},
154             {&quot;noApp&quot;, VFY_ALL, VFY_NONE,      ERR},
155             // Dump sys only with verifier turned off
156             {&quot;noApp&quot;, VFY_NONE, VFY_REMOTE,   VFY_ERR},
157             {&quot;noApp&quot;, VFY_NONE, VFY_ALL,      VFY_ERR},
158             {&quot;noApp&quot;, VFY_NONE, VFY_NONE,     ERR},
159         };
160 
161         int loop_start, loop_stop;
162 
163         // Further break down testset_1 into two parts (to be invoked from VerifierTest_1A.java
164         // and VerifierTest_1B.java) to improve parallel test execution time.
165         switch (part) {
166         case A:
167             loop_start = 0;
168             loop_stop  = 9;
169             break;
170         case B:
171         default:
172             assert part == Testset1Part.B;
173             loop_start = 9;
174             loop_stop  = config.length;
175             break;
176         }
177 
178         String prev_dump_setting = &quot;&quot;;
179         for (int i = loop_start; i &lt; loop_stop; i ++) {
180             String dump_list[] = config[i][0].equals(&quot;app&quot;) ? appClasses :
181                 noAppClasses;
182             String dump_setting = config[i][1];
183             String runtime_setting = config[i][2];
184             String expected_output_str = config[i][3];
185             System.out.println(&quot;Test case [&quot; + i + &quot;]: dumping &quot; + config[i][0] +
186                                &quot; with &quot; + dump_setting +
187                                &quot;, run with &quot; + runtime_setting);
188             if (!dump_setting.equals(prev_dump_setting)) {
189                 String dump_arg1;
190                 String dump_arg2;
191                 // Need to break this into two separate arguments.
192                 if (dump_setting.equals(VFY_NONE)) {
193                     dump_arg1 = &quot;-XX:-BytecodeVerificationRemote&quot;;
194                     dump_arg2 = &quot;-XX:-BytecodeVerificationLocal&quot;;
195                 } else {
196                     // Redundant args should be harmless.
197                     dump_arg1 = dump_arg2 = dump_setting;
198                 }
199 
200                 OutputAnalyzer dumpOutput = TestCommon.dump(
201                                                             jar, dump_list, dump_arg1, dump_arg2,
202                                                             CDS_LOGGING,
203                                                             // FIXME: the following options are for working around a GC
204                                                             // issue - assert failure when dumping archive with the -Xverify:all
205                                                             &quot;-Xms256m&quot;,
206                                                             &quot;-Xmx256m&quot;);
207                 if (dump_setting.equals(VFY_NONE) &amp;&amp;
208                     runtime_setting.equals(VFY_REMOTE)) {
209                     dumpOutput.shouldContain(VFY_INFO_MESSAGE);
210                 }
211             }
212             String runtime_arg1;
213             String runtime_arg2;
214             if (runtime_setting.equals(VFY_NONE)) {
215                 runtime_arg1 = &quot;-XX:-BytecodeVerificationRemote&quot;;
216                 runtime_arg2 = &quot;-XX:-BytecodeVerificationLocal&quot;;
217             } else {
218                 // Redundant args should be harmless.
219                 runtime_arg1 = runtime_arg2 = runtime_setting;
220             }
221             TestCommon.run(&quot;-cp&quot;, jar,
222                            runtime_arg1, runtime_arg2,
223                            &quot;VerifierTest0&quot;)
224                 .ifNoMappingFailure(output -&gt; checkRuntimeOutput(output, expected_output_str));
225             prev_dump_setting = dump_setting;
226         }
227     }
228 
229     static void testset_2(String jarName_greet, String jarName_hi) throws Exception {
230         String appClasses[];
231         String jar;
232 
233         // The following section is for testing the scenarios where
234         // the classes are verifiable during dump time.
235         appClasses = TestCommon.list(&quot;Hi&quot;,
236                                      &quot;Greet&quot;,
237                                      &quot;Hi$MyClass&quot;);
238         jar = TestCommon.getTestJar(jarName_hi + &quot;.jar&quot;) + File.pathSeparator +
239             TestCommon.getTestJar(jarName_greet + &quot;.jar&quot;);
240         String config2[][] = {
241             // {dump_list, dumptime_verification_setting,
242             //  runtime_verification_setting, expected_output_str},
243 
244             // Dump app/ext with -Xverify:remote
245             {&quot;app&quot;,   VFY_REMOTE, VFY_REMOTE, PASS_RESULT},
246             {&quot;app&quot;,   VFY_REMOTE, VFY_ALL,    MAP_FAIL},
247             {&quot;app&quot;,   VFY_REMOTE, VFY_NONE,   PASS_RESULT },
248             // Dump app/ext with -Xverify:all
249             {&quot;app&quot;,   VFY_ALL,    VFY_REMOTE, PASS_RESULT },
250             {&quot;app&quot;,   VFY_ALL,    VFY_ALL,    PASS_RESULT },
251             {&quot;app&quot;,   VFY_ALL,    VFY_NONE,   PASS_RESULT },
252             // Dump app/ext with verifier turned off
253             {&quot;app&quot;,   VFY_NONE,   VFY_REMOTE, PASS_RESULT},
254             {&quot;app&quot;,   VFY_NONE,   VFY_ALL,    MAP_FAIL},
255             {&quot;app&quot;,   VFY_NONE,   VFY_NONE,   PASS_RESULT },
256         };
257         String prev_dump_setting = &quot;&quot;;
258         for (int i = 0; i &lt; config2.length; i ++) {
259             // config2[i][0] is always set to &quot;app&quot; in this test
260             String dump_setting = config2[i][1];
261             String runtime_setting = config2[i][2];
262             String expected_output_str = config2[i][3];
263             System.out.println(&quot;Test case [&quot; + i + &quot;]: dumping &quot; + config2[i][0] +
264                                &quot; with &quot; + dump_setting +
265                                &quot;, run with &quot; + runtime_setting);
266             if (!dump_setting.equals(prev_dump_setting)) {
267                 String dump_arg1;
268                 String dump_arg2;
269                 if (dump_setting.equals(VFY_NONE)) {
270                     dump_arg1 = &quot;-XX:-BytecodeVerificationRemote&quot;;
271                     dump_arg2 = &quot;-XX:-BytecodeVerificationLocal&quot;;
272                 } else {
273                     // Redundant args should be harmless.
274                     dump_arg1 = dump_arg2 = dump_setting;
275                 }
276                 OutputAnalyzer dumpOutput = TestCommon.dump(
277                                                             jar, appClasses, dump_arg1, dump_arg2,
278                                                             CDS_LOGGING,
279                                                             // FIXME: the following options are for working around a GC
280                                                             // issue - assert failure when dumping archive with the -Xverify:all
281                                                             &quot;-Xms256m&quot;,
282                                                             &quot;-Xmx256m&quot;);
283                 if (dump_setting.equals(VFY_NONE) &amp;&amp;
284                     runtime_setting.equals(VFY_REMOTE)) {
285                     dumpOutput.shouldContain(VFY_INFO_MESSAGE);
286                 }
287             }
288             String runtime_arg1;
289             String runtime_arg2;
290             if (runtime_setting.equals(VFY_NONE)) {
291                 runtime_arg1 = &quot;-XX:-BytecodeVerificationRemote&quot;;
292                 runtime_arg2 = &quot;-XX:-BytecodeVerificationLocal&quot;;
293             } else {
294                 // Redundant args should be harmless.
295                 runtime_arg1 = runtime_arg2 = runtime_setting;
296             }
297             TestCommon.run(&quot;-cp&quot;, jar,
298                            runtime_arg1, runtime_arg2,
299                            &quot;Hi&quot;)
300                 .ifNoMappingFailure(output -&gt; checkRuntimeOutput(output, expected_output_str));
301            prev_dump_setting = dump_setting;
302         }
303     }
304 
305     static void createTestJarFile(File jarSrcFile, File jarFile) throws Exception {
306         jarFile.delete();
307         Files.copy(jarSrcFile.toPath(), jarFile.toPath());
308 
309         File dir = new File(System.getProperty(&quot;test.classes&quot;, &quot;.&quot;));
310         File outdir = new File(dir, &quot;verifier_test_classes&quot;);
311         outdir.mkdir();
312 
313         writeClassFile(new File(outdir, &quot;UnverifiableBase.class&quot;), makeUnverifiableBase());
314         writeClassFile(new File(outdir, &quot;UnverifiableIntf.class&quot;), makeUnverifiableIntf());
315 
316         JarBuilder.update(jarFile.getPath(), outdir.getPath());
317     }
318 
319     static void writeClassFile(File file, byte bytecodes[]) throws Exception {
320         try (FileOutputStream fos = new FileOutputStream(file)) {
321             fos.write(bytecodes);
322         }
323     }
324 
325     // This was obtained using JDK8: java jdk.internal.org.objectweb.asm.util.ASMifier tmpclasses/UnverifiableBase.class
326     static byte[] makeUnverifiableBase() throws Exception {
327         ClassWriter cw = new ClassWriter(0);
328         FieldVisitor fv;
329         MethodVisitor mv;
330         AnnotationVisitor av0;
331 
332         cw.visit(V1_8, ACC_SUPER, &quot;UnverifiableBase&quot;, null, &quot;java/lang/Object&quot;, null);
333         {
334             fv = cw.visitField(ACC_FINAL + ACC_STATIC, &quot;x&quot;, &quot;LVerifierTest;&quot;, null, null);
335             fv.visitEnd();
336         }
337         {
338             mv = cw.visitMethod(0, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
339             mv.visitCode();
340             mv.visitVarInsn(ALOAD, 0);
341             mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);
342             mv.visitInsn(RETURN);
343             mv.visitMaxs(1, 1);
344             mv.visitEnd();
345         }
346         {
347             mv = cw.visitMethod(ACC_STATIC, &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, null, null);
348             mv.visitCode();
349             mv.visitTypeInsn(NEW, &quot;VerifierTest0&quot;);
350             mv.visitInsn(DUP);
351             mv.visitMethodInsn(INVOKESPECIAL, &quot;VerifierTest0&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);
352             mv.visitFieldInsn(PUTSTATIC, &quot;UnverifiableBase&quot;, &quot;x&quot;, &quot;LVerifierTest;&quot;);
353             mv.visitInsn(RETURN);
354             mv.visitMaxs(2, 0);
355             mv.visitEnd();
356         }
357         addBadMethod(cw);
358         cw.visitEnd();
359 
360         return cw.toByteArray();
361     }
362 
363     // This was obtained using JDK8: java jdk.internal.org.objectweb.asm.util.ASMifier tmpclasses/UnverifiableIntf.class
364     static byte[] makeUnverifiableIntf() throws Exception {
365         ClassWriter cw = new ClassWriter(0);
366         FieldVisitor fv;
367         MethodVisitor mv;
368         AnnotationVisitor av0;
369 
370         cw.visit(V1_8, ACC_ABSTRACT + ACC_INTERFACE, &quot;UnverifiableIntf&quot;, null, &quot;java/lang/Object&quot;, null);
371 
372         {
373             fv = cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, &quot;x&quot;, &quot;LVerifierTest0;&quot;, null, null);
374             fv.visitEnd();
375         }
376         {
377             mv = cw.visitMethod(ACC_STATIC, &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, null, null);
378             mv.visitCode();
379             mv.visitTypeInsn(NEW, &quot;VerifierTest0&quot;);
380             mv.visitInsn(DUP);
381             mv.visitMethodInsn(INVOKESPECIAL, &quot;VerifierTest0&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);
382             mv.visitFieldInsn(PUTSTATIC, &quot;UnverifiableIntf&quot;, &quot;x&quot;, &quot;LVerifierTest0;&quot;);
383             mv.visitInsn(RETURN);
384             mv.visitMaxs(2, 0);
385             mv.visitEnd();
386         }
387         addBadMethod(cw);
388         cw.visitEnd();
389 
390         return cw.toByteArray();
391     }
392 
393     // Add a bad method to make the class fail verification.
394     static void addBadMethod(ClassWriter cw) throws Exception {
395         MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, &quot;bad&quot;, &quot;()V&quot;, null, null);
396         mv.visitCode();
397         mv.visitInsn(ARETURN); //  java.lang.VerifyError: Operand stack underflow
398         mv.visitMaxs(2, 2);
399         mv.visitEnd();
400     }
401 }
    </pre>
  </body>
</html>
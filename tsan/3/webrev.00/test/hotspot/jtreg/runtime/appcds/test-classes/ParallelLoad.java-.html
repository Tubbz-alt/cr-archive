<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/runtime/appcds/test-classes/ParallelLoad.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 import java.io.*;
 26 import java.net.*;
 27 import java.lang.reflect.Field;
 28 
 29 
 30 // This test helper is parameterized by:
 31 // - class transformation mode: property &quot;appcds.parallel.transform.mode&quot;
 32 // - class loader test types
 33 //
 34 // In the case of transformMode == &quot;cflh&quot;, the transformation is performed
 35 // by AppCDS/jvmti/TransformerAgent.java. The classes to be transformed, such as
 36 // ParallelClassTr0, are defined in ./jvmti/parallelLoad/ParallelClasses.java
 37 
 38 public class ParallelLoad {
 39     public static int MAX_CLASSES = 40;
 40     public static int NUM_THREADS = 4;
 41 
 42     public final static int SYSTEM_LOADER = 0;
 43     public final static int SINGLE_CUSTOM_LOADER = 1;
 44     public final static int MULTI_CUSTOM_LOADER = 2;
 45 
 46     public static final int FINGERPRINT_MODE = 1;
 47     public static final int API_MODE         = 2;
 48 
 49     public static int loaderType = SYSTEM_LOADER;
 50     public static ClassLoader classLoaders[];
 51     public static int mode = FINGERPRINT_MODE;
 52 
 53     public static float timeoutFactor =
 54         Float.parseFloat(System.getProperty(&quot;test.timeout.factor&quot;, &quot;1.0&quot;));
 55 
 56     public static void main(String args[]) throws Throwable {
 57         run(args, null);
 58     }
 59     public static void run(String args[], ClassLoader loaders[]) throws Throwable {
 60         String customJar = null;
 61         System.out.println(&quot;ParallelLoad: timeoutFactor = &quot; + timeoutFactor);
 62 
 63         if (args.length &gt;= 1) {
 64             if (&quot;SINGLE_CUSTOM_LOADER&quot;.equals(args[0])) {
 65                 loaderType = SINGLE_CUSTOM_LOADER;
 66                 customJar = args[2];
 67             } else if (&quot;MULTI_CUSTOM_LOADER&quot;.equals(args[0])) {
 68                 loaderType = MULTI_CUSTOM_LOADER;
 69                 customJar = args[2];
 70             } else if (&quot;SYSTEM_LOADER&quot;.equals(args[0])) {
 71                 loaderType = SYSTEM_LOADER;
 72             } else {
 73                 throw new RuntimeException(&quot;Unexpected loaderType&quot; + args[0]);
 74             }
 75         }
 76 
 77         if (customJar != null) {
 78             if (&quot;FINGERPRINT_MODE&quot;.equals(args[1])) {
 79                 mode = FINGERPRINT_MODE;
 80                 classLoaders = new ClassLoader[NUM_THREADS];
 81                 for (int i=0; i&lt;NUM_THREADS; i++) {
 82                     URL url = new File(customJar).toURI().toURL();
 83                     URL[] urls = new URL[] {url};
 84                     classLoaders[i] = new URLClassLoader(urls);
 85                 }
 86             } else {
 87                 // Loaders must be supplied by caller of the run() method
 88                 mode = API_MODE;
 89                 classLoaders = loaders;
 90             }
 91         }
 92 
 93         System.out.println(&quot;Start Parallel Load ...&quot;);
 94 
 95         Thread thread[] = new Thread[NUM_THREADS];
 96         for (int i=0; i&lt;NUM_THREADS; i++) {
 97             Thread t = new ParallelLoadThread(i);
 98             t.start();
 99             thread[i] = t;
100         }
101 
102         Thread watchdog = new ParallelLoadWatchdog();
103         watchdog.setDaemon(true);
104         watchdog.start();
105 
106         for (int i=0; i&lt;NUM_THREADS; i++) {
107             thread[i].join();
108         }
109         System.out.println(&quot;Parallel Load ... done&quot;);
110         System.exit(0);
111     }
112 }
113 
114 
115 class ParallelLoadWatchdog extends Thread {
116     public void run() {
117         try {
118             long timeout = (long) (20 * 1000 * ParallelLoad.timeoutFactor);
119             Thread.sleep(timeout);
120             System.out.println(&quot;ParallelLoadWatchdog: Timeout reached: timeout(ms) = &quot; + timeout);
121             System.exit(1);
122         } catch (Throwable t) {
123             t.printStackTrace();
124             System.exit(1);
125         }
126     }
127 };
128 
129 
130 class ParallelLoadThread extends Thread {
131     static int num_ready[] = new int[ParallelLoad.MAX_CLASSES];
132     static Object lock = new Object();
133     static String transformMode =
134         System.getProperty(&quot;appcds.parallel.transform.mode&quot;, &quot;none&quot;);
135 
136     int thread_id;
137     ParallelLoadThread(int thread_id) {
138         this.thread_id = thread_id;
139     }
140 
141     public void run() {
142         try {
143             run0();
144         } catch (Throwable t) {
145             t.printStackTrace();
146             System.exit(1);
147         }
148     }
149 
150     private static void log(String msg, Object... args) {
151         String msg0 = &quot;ParallelLoadThread: &quot; + String.format(msg, args);
152         System.out.println(msg0);
153     }
154 
155     private void run0() throws Throwable {
156         for (int i=0; i&lt;ParallelLoad.MAX_CLASSES; i++) {
157             synchronized(lock) {
158                 num_ready[i] ++;
159                 while (num_ready[i] &lt; ParallelLoad.NUM_THREADS) {
160                     lock.wait();
161                 }
162                 lock.notifyAll();
163             }
164             log(&quot;this = %s %d&quot;, this, i);
165             String className = &quot;ParallelClass&quot; + i;
166             if (transformMode.equals(&quot;cflh&quot;))
167                 className = &quot;ParallelClassTr&quot; + i;
168 
169             Class clazz = null;
170 
171             switch (ParallelLoad.loaderType) {
172             case ParallelLoad.SYSTEM_LOADER:
173                 clazz = Class.forName(className);
174                 break;
175             case ParallelLoad.SINGLE_CUSTOM_LOADER:
176                 clazz = ParallelLoad.classLoaders[0].loadClass(className);
177                 break;
178             case ParallelLoad.MULTI_CUSTOM_LOADER:
179                 clazz = ParallelLoad.classLoaders[thread_id].loadClass(className);
180                 break;
181             }
182 
183             log(&quot;clazz = %s&quot;, clazz);
184             testTransformation(clazz);
185         }
186     }
187 
188     private void testTransformation(Class c) throws Exception {
189         if (transformMode.equals(&quot;none&quot;))
190             return;
191 
192         // currently only cflh transform mode is supported
193         if (!transformMode.equals(&quot;cflh&quot;)) {
194             String msg = &quot;wrong transform mode: &quot; + transformMode;
195             throw new IllegalArgumentException(msg);
196         }
197 
198         Field[] fields = c.getFields();
199         boolean fieldFound = false;
200         for (Field f : fields) {
201             if (f.getName().equals(&quot;testString&quot;)) {
202                 checkTransformationString(c, (String) f.get(null));
203                 fieldFound = true;
204             }
205         }
206 
207         if (!fieldFound)
208             throw new RuntimeException (&quot;Expected field &#39;testString&#39; not found&quot;);
209     }
210 
211     private void checkTransformationString(Class c, String actual) throws Exception {
212         String expected = &quot;class-transform-check: this-has-been--transformed&quot;;
213         if (!actual.equals(expected)) {
214             String msg1 = &quot;Transformation failed for class&quot; + c.getName();
215             String msg2 = String.format(&quot;Expected: %s, actual: %s&quot;, expected, actual);
216             throw new RuntimeException(msg1 + &quot;\n&quot; + msg2);
217         }
218     }
219 }
220 
    </pre>
  </body>
</html>
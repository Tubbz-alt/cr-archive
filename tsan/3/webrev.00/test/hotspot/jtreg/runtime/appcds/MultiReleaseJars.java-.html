<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/runtime/appcds/MultiReleaseJars.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 /*
 26  * @test MultiReleaseJars
 27  * @summary Test multi-release jar with AppCDS.
 28  * @requires vm.cds
 29  * @library /test/lib
 30  * @modules java.base/jdk.internal.misc
 31  *          jdk.jartool/sun.tools.jar
 32  * @run main/othervm/timeout=2400 MultiReleaseJars
 33  */
 34 
 35 import java.io.File;
 36 import java.io.FileOutputStream;
 37 import java.io.PrintStream;
 38 import java.io.IOException;
 39 import jdk.test.lib.process.OutputAnalyzer;
 40 
 41 public class MultiReleaseJars {
 42 
 43     static final int MAJOR_VERSION = Runtime.version().major();
 44     static final String MAJOR_VERSION_STRING = String.valueOf(MAJOR_VERSION);
 45 
 46     static String[] getMain() {
 47         String[] sts = {
 48             &quot;package version;&quot;,
 49             &quot;public class Main {&quot;,
 50             &quot;    public static void main(String[] args) {&quot;,
 51             &quot;        Version version = new Version();&quot;,
 52             &quot;        System.out.println(\&quot;I am running on version \&quot; + version.getVersion());&quot;,
 53             &quot;    }&quot;,
 54             &quot;}&quot;
 55         };
 56         return sts;
 57     }
 58 
 59     static String[] getVersion(int version) {
 60         String[] sts = {
 61             &quot;package version;&quot;,
 62             &quot;public class Version {&quot;,
 63             &quot;    public int getVersion(){ return &quot; + version + &quot;; }&quot;,
 64             &quot;}&quot;
 65         };
 66         return sts;
 67     }
 68 
 69     static void writeFile(File file, String... contents) throws Exception {
 70         if (contents == null) {
 71             throw new java.lang.RuntimeException(&quot;No input for writing to file&quot; + file);
 72         }
 73         try (
 74              FileOutputStream fos = new FileOutputStream(file);
 75              PrintStream ps = new PrintStream(fos)
 76         ) {
 77             for (String str : contents) {
 78                 ps.println(str);
 79             }
 80         }
 81     }
 82 
 83     /* version.jar entries and files:
 84      * META-INF/
 85      * META-INF/MANIFEST.MF
 86      * version/
 87      * version/Main.class
 88      * version/Version.class
 89      * META-INF/versions/
 90      * META-INF/versions/&lt;major-version&gt;/
 91      * META-INF/versions/&lt;major-version&gt;/version/
 92      * META-INF/versions/&lt;major-version&gt;/version/Version.class
 93      */
 94     static void createClassFilesAndJar() throws Exception {
 95         String tempDir = System.getProperty(&quot;test.classes&quot;);
 96         File baseDir = new File(tempDir + File.separator + &quot;base&quot;);
 97         File vDir    = new File(tempDir + File.separator + MAJOR_VERSION_STRING);
 98 
 99         baseDir.mkdirs();
100         vDir.mkdirs();
101 
102         File fileMain = TestCommon.getOutputSourceFile(&quot;Main.java&quot;);
103         writeFile(fileMain, getMain());
104 
105         File fileVersion = TestCommon.getOutputSourceFile(&quot;Version.java&quot;);
106         writeFile(fileVersion, getVersion(7));
107         JarBuilder.compile(baseDir.getAbsolutePath(), fileVersion.getAbsolutePath(), &quot;--release&quot;, &quot;7&quot;);
108         JarBuilder.compile(baseDir.getAbsolutePath(), fileMain.getAbsolutePath(),
109             &quot;-cp&quot;, baseDir.getAbsolutePath(), &quot;--release&quot;, MAJOR_VERSION_STRING);
110 
111         String[] meta = {
112             &quot;Multi-Release: true&quot;,
113             &quot;Main-Class: version.Main&quot;
114         };
115         File metainf = new File(tempDir, &quot;mf.txt&quot;);
116         writeFile(metainf, meta);
117 
118         fileVersion = TestCommon.getOutputSourceFile(&quot;Version.java&quot;);
119         writeFile(fileVersion, getVersion(MAJOR_VERSION));
120         JarBuilder.compile(vDir.getAbsolutePath(), fileVersion.getAbsolutePath(), &quot;--release&quot;, MAJOR_VERSION_STRING);
121 
122         JarBuilder.build(&quot;version&quot;, baseDir, metainf.getAbsolutePath(),
123             &quot;--release&quot;, MAJOR_VERSION_STRING, &quot;-C&quot;, vDir.getAbsolutePath(), &quot;.&quot;);
124 
125         // the following jar file is for testing case-insensitive &quot;Multi-Release&quot;
126         // attibute name
127         String[] meta2 = {
128             &quot;multi-Release: true&quot;,
129             &quot;Main-Class: version.Main&quot;
130         };
131         metainf = new File(tempDir, &quot;mf2.txt&quot;);
132         writeFile(metainf, meta2);
133         JarBuilder.build(&quot;version2&quot;, baseDir, metainf.getAbsolutePath(),
134             &quot;--release&quot;, MAJOR_VERSION_STRING, &quot;-C&quot;, vDir.getAbsolutePath(), &quot;.&quot;);
135     }
136 
137     static void checkExecOutput(OutputAnalyzer output, String expectedOutput) throws Exception {
138         try {
139             TestCommon.checkExec(output, expectedOutput);
140         } catch (java.lang.RuntimeException re) {
141             String cause = re.getMessage();
142             if (!expectedOutput.equals(cause)) {
143                 throw re;
144             }
145         }
146     }
147 
148     public static void main(String... args) throws Exception {
149         // create version.jar which contains Main.class and Version.class.
150         // Version.class has two versions: 8 and the current version.
151         createClassFilesAndJar();
152 
153         String mainClass          = &quot;version.Main&quot;;
154         String loadInfo           = &quot;[class,load] version.Version source: shared objects file&quot;;
155         String appClasses[]       = {&quot;version/Main&quot;, &quot;version/Version&quot;};
156         String appJar             = TestCommon.getTestJar(&quot;version.jar&quot;);
157         String appJar2            = TestCommon.getTestJar(&quot;version2.jar&quot;);
158         String enableMultiRelease = &quot;-Djdk.util.jar.enableMultiRelease=true&quot;;
159         String jarVersion         = null;
160         String expectedOutput     = null;
161 
162         // 1. default to highest version
163         //    if META-INF/versions exists, no other commandline options like -Djdk.util.jar.version and
164         //    -Djdk.util.jar.enableMultiRelease passed to vm
165         OutputAnalyzer output = TestCommon.dump(appJar, appClasses);
166         output.shouldContain(&quot;Loading classes to share: done.&quot;);
167         output.shouldHaveExitValue(0);
168 
169         output = TestCommon.exec(appJar, mainClass);
170         checkExecOutput(output, &quot;I am running on version &quot; + MAJOR_VERSION_STRING);
171 
172         // 2. Test versions 7 and the current major version.
173         //    -Djdk.util.jar.enableMultiRelease=true (or force), default is true.
174         //    a) -Djdk.util.jar.version=7 does not exist in jar.
175         //        It will fallback to the root version which is also 7 in this test.
176         //    b) -Djdk.util.jar.version=MAJOR_VERSION exists in the jar.
177         for (int i : new int[] {7, MAJOR_VERSION}) {
178             jarVersion = &quot;-Djdk.util.jar.version=&quot; + i;
179             expectedOutput = &quot;I am running on version &quot; + i;
180             output = TestCommon.dump(appJar, appClasses, enableMultiRelease, jarVersion);
181             output.shouldContain(&quot;Loading classes to share: done.&quot;);
182             output.shouldHaveExitValue(0);
183 
184             output = TestCommon.exec(appJar, mainClass);
185             checkExecOutput(output, expectedOutput);
186         }
187 
188         // 3. For unsupported version, 5 and current major version + 1, the multiversion
189         // will be turned off, so it will use the default (root) version.
190         for (int i : new int[] {5, MAJOR_VERSION + 1}) {
191             jarVersion = &quot;-Djdk.util.jar.version=&quot; + i;
192             output = TestCommon.dump(appJar, appClasses, enableMultiRelease, jarVersion);
193             output.shouldHaveExitValue(0);
194             // With the fix for 8172218, multi-release jar is being handled in
195             // jdk corelib which doesn&#39;t emit the following warning message.
196             //output.shouldContain(&quot;JDK&quot; + i + &quot; is not supported in multiple version jars&quot;);
197 
198             output = TestCommon.exec(appJar, mainClass);
199             if (i == 5)
200                 checkExecOutput(output, &quot;I am running on version 7&quot;);
201             else
202                 checkExecOutput(output, &quot;I am running on version &quot; + MAJOR_VERSION_STRING);
203         }
204 
205         // 4. If explicitly disabled from command line for multiversion jar, it will use default
206         //    version at root regardless multiversion versions exists.
207         //    -Djdk.util.jar.enableMultiRelease=false (not &#39;true&#39; or &#39;force&#39;)
208         for (int i = 6; i &lt; MAJOR_VERSION + 1; i++) {
209             jarVersion = &quot;-Djdk.util.jar.version=&quot; + i;
210             output = TestCommon.dump(appJar, appClasses, &quot;-Djdk.util.jar.enableMultiRelease=false&quot;, jarVersion);
211             output.shouldHaveExitValue(0);
212 
213             output = TestCommon.exec(appJar, mainClass);
214             expectedOutput = &quot;I am running on version 7&quot;;
215             checkExecOutput(output, expectedOutput);
216         }
217 
218         // 5. Sanity test with -Xbootclasspath/a
219         //    AppCDS behaves the same as the non-AppCDS case. A multi-release
220         //    jar file in the -Xbootclasspath/a will be ignored.
221         output = TestCommon.dump(appJar, appClasses, &quot;-Xbootclasspath/a:&quot; + appJar, enableMultiRelease, jarVersion);
222         output.shouldContain(&quot;Loading classes to share: done.&quot;);
223         output.shouldHaveExitValue(0);
224 
225         output = TestCommon.exec(appJar, &quot;-Xbootclasspath/a:&quot; + appJar, mainClass);
226         checkExecOutput(output, &quot;I am running on version 7&quot;);
227 
228         // 6. Sanity test case-insensitive &quot;Multi-Release&quot; attribute name
229         output = TestCommon.dump(appJar2, appClasses);
230         output.shouldContain(&quot;Loading classes to share: done.&quot;);
231         output.shouldHaveExitValue(0);
232 
233         output = TestCommon.exec(appJar2, mainClass);
234         checkExecOutput(output, &quot;I am running on version &quot; + MAJOR_VERSION_STRING);
235     }
236 }
    </pre>
  </body>
</html>
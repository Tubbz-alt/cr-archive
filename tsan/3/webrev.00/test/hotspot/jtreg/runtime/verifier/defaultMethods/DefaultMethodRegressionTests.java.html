<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/verifier/defaultMethods/DefaultMethodRegressionTests.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @bug 8003639
 27  * @summary defaultMethod resolution and verification
 28  * @run main DefaultMethodRegressionTests
 29  */
 30 
 31 import java.util.ArrayList;
 32 import java.util.Arrays;
 33 import java.util.List;
 34 
 35 /**
 36  * This set of classes/interfaces (K/I/C) is specially designed to expose a
 37  * bug in the JVM where it did not find some overloaded methods in some
 38  * specific situations. (fixed by hotspot changeset ffb9316fd9ed).
 39  */
 40 interface K {
 41     int bbb(Long l);
 42 }
 43 
 44 interface I extends K {
 45     default void aaa() {}
 46     default void aab() {}
 47     default void aac() {}
 48 
 49     default int bbb(Integer i) { return 22; }
 50     default int bbb(Float f) { return 33; }
 51     default int bbb(Long l) { return 44; }
 52     default int bbb(Double d) { return 55; }
 53     default int bbb(String s) { return 66; }
 54 
 55     default void caa() {}
 56     default void cab() {}
 57     default void cac() {}
 58 }
 59 
 60 class C implements I {}
 61 
 62 public class DefaultMethodRegressionTests {
 63     public static void main(String... args) {
 64         new DefaultMethodRegressionTests().run(args);
 65     }
 66     void run(String... args) {
 67         testLostOverloadedMethod();
 68         System.out.println(&quot;testLostOverloadedMethod: OK&quot;);
 69         testInferenceVerifier();
 70         System.out.println(&quot;testInferenceVerifier: OK&quot;);
 71     }
 72     void testLostOverloadedMethod() {
 73         C c = new C();
 74         assertEquals(c.bbb(new Integer(1)), 22);
 75         assertEquals(c.bbb(new Float(1.1)), 33);
 76         assertEquals(c.bbb(new Long(1L)), 44);
 77         assertEquals(c.bbb(new Double(0.01)), 55);
 78         assertEquals(c.bbb(new String(&quot;&quot;)), 66);
 79     }
 80     // Test to ensure that the inference verifier accepts older classfiles
 81     // with classes that implement interfaces with defaults.
 82     void testInferenceVerifier() {
 83         // interface I { int m() default { return 99; } }
 84         byte I_bytes[] = {
 85             (byte)0xca, (byte)0xfe, (byte)0xba, (byte)0xbe, 0x00, 0x00, 0x00, 0x34,
 86             0x00, 0x08, 0x07, 0x00, 0x06, 0x07, 0x00, 0x07,
 87             0x01, 0x00, 0x03, 0x66, 0x6f, 0x6f, 0x01, 0x00,
 88             0x03, 0x28, 0x29, 0x49, 0x01, 0x00, 0x04, 0x43,
 89             0x6f, 0x64, 0x65, 0x01, 0x00, 0x01, 0x49, 0x01,
 90             0x00, 0x10, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c,
 91             0x61, 0x6e, 0x67, 0x2f, 0x4f, 0x62, 0x6a, 0x65,
 92             0x63, 0x74, 0x06, 0x00, 0x00, 0x01, 0x00, 0x02,
 93             0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x01,
 94             0x00, 0x03, 0x00, 0x04, 0x00, 0x01, 0x00, 0x05,
 95             0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x00, 0x01,
 96             0x00, 0x00, 0x00, 0x03, 0x10, 0x63, (byte)0xac, 0x00,
 97             0x00, 0x00, 0x00, 0x00, 0x00
 98         };
 99         // public class C implements I {}  /* -target 1.5 */
100         byte C_bytes[] = {
101             (byte)0xca, (byte)0xfe, (byte)0xba, (byte)0xbe, 0x00, 0x00, 0x00, 0x31,
102             0x00, 0x0c, 0x0a, 0x00, 0x03, 0x00, 0x08, 0x07,
103             0x00, 0x09, 0x07, 0x00, 0x0a, 0x07, 0x00, 0x0b,
104             0x01, 0x00, 0x06, 0x3c, 0x69, 0x6e, 0x69, 0x74,
105             0x3e, 0x01, 0x00, 0x03, 0x28, 0x29, 0x56, 0x01,
106             0x00, 0x04, 0x43, 0x6f, 0x64, 0x65, 0x0c, 0x00,
107             0x05, 0x00, 0x06, 0x01, 0x00, 0x01, 0x43, 0x01,
108             0x00, 0x10, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c,
109             0x61, 0x6e, 0x67, 0x2f, 0x4f, 0x62, 0x6a, 0x65,
110             0x63, 0x74, 0x01, 0x00, 0x01, 0x49, 0x00, 0x21,
111             0x00, 0x02, 0x00, 0x03, 0x00, 0x01, 0x00, 0x04,
112             0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x05,
113             0x00, 0x06, 0x00, 0x01, 0x00, 0x07, 0x00, 0x00,
114             0x00, 0x11, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
115             0x00, 0x05, 0x2a, (byte)0xb7, 0x00, 0x01, (byte)0xb1, 0x00,
116             0x00, 0x00, 0x00, 0x00, 0x00
117         };
118 
119         ClassLoader cl = new ClassLoader() {
120             protected Class&lt;?&gt; findClass(String name) {
121                 if (name.equals(&quot;I&quot;)) {
122                     return defineClass(&quot;I&quot;, I_bytes, 0, I_bytes.length);
123                 } else if (name.equals(&quot;C&quot;)) {
124                     return defineClass(&quot;C&quot;, C_bytes, 0, C_bytes.length);
125                 } else {
126                     return null;
127                 }
128             }
129         };
130         try {
131             Class.forName(&quot;C&quot;, true, cl);
132         } catch (Exception e) {
133             // unmodified verifier will throw VerifyError
134             throw new RuntimeException(e);
135         }
136     }
137     void assertEquals(Object o1, Object o2) {
138         System.out.print(&quot;Expected: &quot; + o1);
139         System.out.println(&quot;, Obtained: &quot; + o2);
140         if (!o1.equals(o2)) {
141             throw new RuntimeException(&quot;got unexpected values&quot;);
142         }
143     }
144 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/runtime/SharedArchiveFile/serviceability/ReplaceCriticalClasses.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 /*
 26  * @test
 27  * @summary Tests how CDS works when critical library classes are replaced with JVMTI ClassFileLoadHook
 28  * @library /test/lib
 29  * @requires vm.cds
 30  * @build sun.hotspot.WhiteBox
 31  * @run driver ClassFileInstaller -jar whitebox.jar sun.hotspot.WhiteBox
 32  * @run main/othervm/native ReplaceCriticalClasses
 33  */
 34 
 35 import java.util.regex.Matcher;
 36 import java.util.regex.Pattern;
 37 import jdk.test.lib.cds.CDSTestUtils;
 38 import jdk.test.lib.cds.CDSOptions;
 39 import jdk.test.lib.process.OutputAnalyzer;
 40 import sun.hotspot.WhiteBox;
 41 
 42 public class ReplaceCriticalClasses {
 43     public static void main(String args[]) throws Throwable {
 44         ReplaceCriticalClasses rcc = new ReplaceCriticalClasses();
 45         rcc.process(args);
 46     }
 47 
 48     public void process(String args[]) throws Throwable {
 49         if (args.length == 0) {
 50             launchChildProcesses(getTests());
 51         } else if (args.length == 3 &amp;&amp; args[0].equals(&quot;child&quot;)) {
 52             Class klass = Class.forName(args[2].replace(&quot;/&quot;, &quot;.&quot;));
 53             if (args[1].equals(&quot;-shared&quot;)) {
 54                 testInChild(true, klass);
 55             } else if (args[1].equals(&quot;-notshared&quot;)) {
 56                 testInChild(false, klass);
 57             } else {
 58                 throw new RuntimeException(&quot;Unknown child exec option &quot; + args[1]);
 59             }
 60             return;
 61         } else {
 62             throw new RuntimeException(&quot;Usage: @run main/othervm/native ReplaceCriticalClasses&quot;);
 63         }
 64     }
 65 
 66     public String[] getTests() {
 67         String tests[] = {
 68             // CDS should be disabled -- these critical classes will be replaced
 69             // because JvmtiExport::early_class_hook_env() is true.
 70             &quot;-early -notshared java/lang/Object&quot;,
 71             &quot;-early -notshared java/lang/String&quot;,
 72             &quot;-early -notshared java/lang/Cloneable&quot;,
 73             &quot;-early -notshared java/io/Serializable&quot;,
 74 
 75             // CDS should not be disabled -- these critical classes cannot be replaced because
 76             // JvmtiExport::early_class_hook_env() is false.
 77             &quot;java/lang/Object&quot;,
 78             &quot;java/lang/String&quot;,
 79             &quot;java/lang/Cloneable&quot;,
 80             &quot;java/io/Serializable&quot;,
 81 
 82             /* Try to replace classes that are used by the archived subgraph graphs.
 83                The following test cases are in ReplaceCriticalClassesForSubgraphs.java.
 84             &quot;-early -notshared -subgraph java/lang/module/ResolvedModule jdk.internal.module.ArchivedModuleGraph&quot;,
 85             &quot;-early -notshared -subgraph java/lang/Long java.lang.Long$LongCache&quot;,
 86             &quot;-subgraph java/lang/Long java.lang.Long$LongCache&quot;,
 87             */
 88 
 89             // Replace classes that are loaded after JVMTI_PHASE_PRIMORDIAL. It&#39;s OK to replace
 90             // such
 91             // classes even when CDS is enabled. Nothing bad should happen.
 92             &quot;-notshared java/util/Locale&quot;,
 93             &quot;-notshared sun/util/locale/BaseLocale&quot;,
 94             &quot;-notshared java/lang/Readable&quot;,
 95         };
 96         return tests;
 97     }
 98 
 99     static void launchChildProcesses(String tests[]) throws Throwable {
100         int n = 0;
101         for (String s : tests) {
102             System.out.println(&quot;Test case[&quot; + (n++) + &quot;] = \&quot;&quot; + s + &quot;\&quot;&quot;);
103             String args[] = s.split(&quot;\\s+&quot;); // split by space character
104             launchChild(args);
105         }
106     }
107 
108     static void launchChild(String args[]) throws Throwable {
109         if (args.length &lt; 1) {
110             throw new RuntimeException(&quot;Invalid test case. Should be &lt;-early&gt; &lt;-subgraph&gt; &lt;-notshared&gt; klassName subgraphKlass&quot;);
111         }
112         String klassName = null;
113         String subgraphKlass = null;
114         String early = &quot;&quot;;
115         boolean subgraph = false;
116         String shared = &quot;-shared&quot;;
117 
118         for (int i=0; i&lt;args.length-1; i++) {
119             String opt = args[i];
120             if (opt.equals(&quot;-early&quot;)) {
121                 early = &quot;-early,&quot;;
122             } else if (opt.equals(&quot;-subgraph&quot;)) {
123                 subgraph = true;
124             } else if (opt.equals(&quot;-notshared&quot;)) {
125                 shared = opt;
126             } else {
127               if (!subgraph) {
128                 throw new RuntimeException(&quot;Unknown option: &quot; + opt);
129               }
130             }
131         }
132         if (subgraph) {
133           klassName = args[args.length-2];
134           subgraphKlass = args[args.length-1];
135         } else {
136           klassName = args[args.length-1];
137         }
138         Class.forName(klassName.replace(&quot;/&quot;, &quot;.&quot;)); // make sure it&#39;s a valid class
139         final String subgraphInit = &quot;initialize_from_archived_subgraph &quot; + subgraphKlass;
140 
141         // We will pass an option like &quot;-agentlib:SimpleClassFileLoadHook=java/util/Locale,XXX,XXX&quot;.
142         // The SimpleClassFileLoadHook agent would attempt to hook the java/util/Locale class
143         // but leave the class file bytes unchanged (it replaces all bytes &quot;XXX&quot; with &quot;XXX&quot;, i.e.,
144         // a no-op). JVMTI doesn&#39;t check the class file bytes returned by the agent, so as long
145         // as the agent returns a buffer, it will not load the class from CDS, and will instead
146         // load the class by parsing the buffer.
147         //
148         // Note that for safety we don&#39;t change the contents of the class file bytes. If in the
149         // future JVMTI starts checking the contents of the class file bytes, this test would need
150         // to be updated. (You&#39;d see the test case with java/util/Locale staring to fail).
151         String agent = &quot;-agentlib:SimpleClassFileLoadHook=&quot; + early + klassName + &quot;,XXX,XXX&quot;;
152 
153         CDSOptions opts = (new CDSOptions())
154             .setXShareMode(&quot;auto&quot;)
155             .setUseSystemArchive(true)
156             .setUseVersion(false)
157             .addSuffix(&quot;-showversion&quot;,
158                        &quot;-Xlog:cds&quot;,
159                        &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
160                        agent,
161                        &quot;-XX:+WhiteBoxAPI&quot;,
162                        &quot;-Xbootclasspath/a:&quot; + ClassFileInstaller.getJarPath(&quot;whitebox.jar&quot;));
163 
164         if (subgraph) {
165             opts.addSuffix(&quot;-Xlog:cds,cds+heap&quot;);
166         }
167 
168         opts.addSuffix(&quot;ReplaceCriticalClasses&quot;,
169                        &quot;child&quot;,
170                        shared,
171                        klassName);
172 
173         final boolean expectDisable = !early.equals(&quot;&quot;);
174         final boolean checkSubgraph = subgraph;
175         final boolean expectShared = shared.equals(&quot;-shared&quot;);
176         CDSTestUtils.run(opts).assertNormalExit(out -&gt; {
177                 if (expectDisable) {
178                     out.shouldContain(&quot;UseSharedSpaces: CDS is disabled because early JVMTI ClassFileLoadHook is in use.&quot;);
179                     System.out.println(&quot;CDS disabled as expected&quot;);
180                 }
181                 if (checkSubgraph) {
182                     if (expectShared) {
183                         if (!out.getOutput().contains(&quot;UseSharedSpaces: Unable to map at required address in java heap&quot;)) {
184                             out.shouldContain(subgraphInit);
185                         }
186                     } else {
187                       out.shouldNotContain(subgraphInit);
188                     }
189                 }
190             });
191     }
192 
193     static void testInChild(boolean shouldBeShared, Class klass) {
194         WhiteBox wb = WhiteBox.getWhiteBox();
195 
196         if (shouldBeShared &amp;&amp; !wb.isSharedClass(klass)) {
197             throw new RuntimeException(klass + &quot; should be shared but but actually is not.&quot;);
198         }
199         if (!shouldBeShared &amp;&amp; wb.isSharedClass(klass)) {
200             throw new RuntimeException(klass + &quot; should not be shared but actually is.&quot;);
201         }
202         System.out.println(&quot;wb.isSharedClass(klass): &quot; + wb.isSharedClass(klass) + &quot; == &quot; + shouldBeShared);
203 
204         String strings[] = {
205             // interned strings from j.l.Object
206             &quot;@&quot;,
207             &quot;nanosecond timeout value out of range&quot;,
208             &quot;timeoutMillis value is negative&quot;,
209 
210             // interned strings from j.l.Integer
211             &quot;0&quot;,
212             &quot;0X&quot;,
213             &quot;0x&quot;,
214             &quot;int&quot;
215         };
216 
217         // Make sure the interned string table is same
218         for (String s : strings) {
219             String i = s.intern();
220             if (s != i) {
221                 throw new RuntimeException(&quot;Interned string mismatch: \&quot;&quot; + s + &quot;\&quot; @ &quot; + System.identityHashCode(s) +
222                                            &quot; vs \&quot;&quot; + i + &quot;\&quot; @ &quot; + System.identityHashCode(i));
223             }
224         }
225         // We have tried to use ClassFileLoadHook to replace critical library classes (which may
226         // may not have succeeded, depending on whether the agent has requested
227         // can_generate_all_class_hook_events/can_generate_early_class_hook_events capabilities).
228         //
229         // In any case, the JVM should have started properly (perhaps with CDS disabled) and
230         // the above operations should succeed.
231         System.out.println(&quot;If I can come to here without crashing, things should be OK&quot;);
232     }
233 }
    </pre>
  </body>
</html>
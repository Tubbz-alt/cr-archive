<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/exceptionMsgs/NullPointerException/NullPointerExceptionTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2019 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /**
  26  * @test
  27  * @summary Test extended NullPointerException message for
  28  *   classfiles generated with debug information. In this case the name
  29  *   of the variable containing the array is printed.
  30  * @bug 8218628
  31  * @modules java.base/java.lang:open
  32  *          java.base/jdk.internal.org.objectweb.asm
  33  * @library /test/lib
  34  * @compile -g NullPointerExceptionTest.java
  35  * @run main/othervm -XX:MaxJavaStackTraceDepth=1 -XX:+ShowCodeDetailsInExceptionMessages NullPointerExceptionTest hasDebugInfo
  36  */
  37 /**
  38  * @test
  39  * @summary Test extended NullPointerException message for class
  40  *   files generated without debugging information. The message lists
  41  *   detailed information about the entity that is null.
  42  * @bug 8218628
  43  * @modules java.base/java.lang:open
  44  *          java.base/jdk.internal.org.objectweb.asm
  45  * @library /test/lib
  46  * @compile NullPointerExceptionTest.java
  47  * @run main/othervm -XX:MaxJavaStackTraceDepth=1 -XX:+ShowCodeDetailsInExceptionMessages NullPointerExceptionTest
  48  */
  49 
  50 import java.io.ByteArrayInputStream;
  51 import java.io.ByteArrayOutputStream;
  52 import java.io.ObjectInputStream;
  53 import java.io.ObjectOutputStream;
  54 import java.lang.invoke.MethodHandles.Lookup;
  55 import java.util.ArrayList;
  56 
  57 import jdk.internal.org.objectweb.asm.ClassWriter;
  58 import jdk.internal.org.objectweb.asm.Label;
  59 import jdk.internal.org.objectweb.asm.MethodVisitor;
  60 import jdk.test.lib.Asserts;
  61 
  62 import static java.lang.invoke.MethodHandles.lookup;
  63 import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;
  64 import static jdk.internal.org.objectweb.asm.Opcodes.ACC_SUPER;
  65 import static jdk.internal.org.objectweb.asm.Opcodes.ACONST_NULL;
  66 import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;
  67 import static jdk.internal.org.objectweb.asm.Opcodes.ASTORE;
  68 import static jdk.internal.org.objectweb.asm.Opcodes.GETFIELD;
  69 import static jdk.internal.org.objectweb.asm.Opcodes.GETSTATIC;
  70 import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_1;
  71 import static jdk.internal.org.objectweb.asm.Opcodes.ICONST_2;
  72 import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;
  73 import static jdk.internal.org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
  74 import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;
  75 import static jdk.internal.org.objectweb.asm.Opcodes.IRETURN;
  76 import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;
  77 
  78 /**
  79  * Tests NullPointerExceptions
  80  */
  81 public class NullPointerExceptionTest {
  82 
  83     // Some fields used in the test.
  84     static Object nullStaticField;
  85     NullPointerExceptionTest nullInstanceField;
  86     static int[][][][] staticArray;
  87     static long[][] staticLongArray = new long[1000][];
  88     DoubleArrayGen dag;
  89     ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();
  90     ArrayList&lt;String&gt; curr;
  91     static boolean hasDebugInfo = false;
  92 
  93     static {
  94         staticArray       = new int[1][][][];
  95         staticArray[0]    = new int[1][][];
  96         staticArray[0][0] = new int[1][];
  97     }
  98 
  99     public static void checkMessage(Throwable t, String expression,
 100                                     String obtainedMsg, String expectedMsg) {
 101         System.out.println(&quot;\nSource code:\n  &quot; + expression + &quot;\n\nOutput:&quot;);
 102         t.printStackTrace(System.out);
 103         if (obtainedMsg != expectedMsg &amp;&amp; // E.g. both are null.
 104             !obtainedMsg.equals(expectedMsg)) {
 105             System.out.println(&quot;expected msg: &quot; + expectedMsg);
 106             Asserts.assertEquals(expectedMsg, obtainedMsg);
 107         }
 108         System.out.println(&quot;\n----&quot;);
 109     }
 110 
 111     public static void main(String[] args) throws Exception {
 112         NullPointerExceptionTest t = new NullPointerExceptionTest();
 113         if (args.length &gt; 0) {
 114             hasDebugInfo = true;
 115         }
 116 
 117         System.out.println(&quot;Tests for the first part of the message:&quot;);
 118         System.out.println(&quot;========================================\n&quot;);
 119 
 120         // Test the message printed for the failed action.
 121         t.testFailedAction();
 122 
 123         System.out.println(&quot;Tests for the second part of the message:&quot;);
 124         System.out.println(&quot;=========================================\n&quot;);
 125         // Test the method printed for the null entity.
 126         t.testNullEntity();
 127 
 128         System.out.println(&quot;Further tests:&quot;);
 129         System.out.println(&quot;==============\n&quot;);
 130 
 131         // Test if parameters are used in the code.
 132         // This is relevant if there is no debug information.
 133         t.testParameters();
 134 
 135         // Test that no message is printed for exceptions
 136         // allocated explicitly.
 137         t.testCreation();
 138 
 139         // Test that no message is printed for exceptions
 140         // thrown in native methods.
 141         t.testNative();
 142 
 143         // Test that two calls to getMessage() return the same
 144         // message.
 145         // It is a design decision that it returns two different
 146         // String objects.
 147         t.testSameMessage();
 148 
 149         // Test serialization.
 150         // It is a design decision that after serialization the
 151         // the message is lost.
 152         t.testSerialization();
 153 
 154         // Test that messages are printed for code generated
 155         // on-the-fly.
 156         t.testGeneratedCode();
 157 
 158         // Some more interesting complex messages.
 159         t.testComplexMessages();
 160     }
 161 
 162     // Helper method to cause test case.
 163     private double callWithTypes(String[][] dummy1, int[][][] dummy2, float dummy3, long dummy4, short dummy5,
 164                                  boolean dummy6, byte dummy7, double dummy8, char dummy9) {
 165         return 0.0;
 166     }
 167 
 168     @SuppressWarnings(&quot;null&quot;)
 169     public void testFailedAction() {
 170         int[]     ia1 = null;
 171         float[]   fa1 = null;
 172         Object[]  oa1 = null;
 173         boolean[] za1 = null;
 174         byte[]    ba1 = null;
 175         char[]    ca1 = null;
 176         short[]   sa1 = null;
 177         long[]    la1 = null;
 178         double[]  da1 = null;
 179 
 180         // iaload
 181         try {
 182             int val = ia1[0];
 183             System.out.println(val);
 184             Asserts.fail();
 185         } catch (NullPointerException e) {
 186             checkMessage(e, &quot;int val = ia1[0];&quot;, e.getMessage(),
 187                          &quot;Cannot load from int array because &quot; +
 188                          (hasDebugInfo ? &quot;\&quot;ia1\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
 189         }
 190         // faload
 191         try {
 192             float val = fa1[0];
 193             System.out.println(val);
 194             Asserts.fail();
 195         } catch (NullPointerException e) {
 196             checkMessage(e, &quot;float val = fa1[0];&quot;, e.getMessage(),
 197                          &quot;Cannot load from float array because &quot; +
 198                          (hasDebugInfo ? &quot;\&quot;fa1\&quot;&quot; : &quot;\&quot;&lt;local2&gt;\&quot;&quot;) + &quot; is null&quot;);
 199         }
 200         // aaload
 201         try {
 202             Object val = oa1[0];
 203             System.out.println(val);
 204             Asserts.fail();
 205         } catch (NullPointerException e) {
 206             checkMessage(e, &quot;Object val = oa1[0];&quot;, e.getMessage(),
 207                          &quot;Cannot load from object array because &quot; +
 208                          (hasDebugInfo ? &quot;\&quot;oa1\&quot;&quot; : &quot;\&quot;&lt;local3&gt;\&quot;&quot;) + &quot; is null&quot;);
 209         }
 210         // baload (boolean)
 211         try {
 212             boolean val = za1[0];
 213             System.out.println(val);
 214             Asserts.fail();
 215         } catch (NullPointerException e) {
 216             checkMessage(e, &quot;boolean val = za1[0];&quot;, e.getMessage(),
 217                          &quot;Cannot load from byte/boolean array because &quot; +
 218                          (hasDebugInfo ? &quot;\&quot;za1\&quot;&quot; : &quot;\&quot;&lt;local4&gt;\&quot;&quot;) + &quot; is null&quot;);
 219         }
 220         // baload (byte)
 221         try {
 222             byte val = ba1[0];
 223             System.out.println(val);
 224             Asserts.fail();
 225         } catch (NullPointerException e) {
 226             checkMessage(e, &quot;byte val = ba1[0];&quot;, e.getMessage(),
 227                          &quot;Cannot load from byte/boolean array because &quot; +
 228                          (hasDebugInfo ? &quot;\&quot;ba1\&quot;&quot; : &quot;\&quot;&lt;local5&gt;\&quot;&quot;) + &quot; is null&quot;);
 229         }
 230         // caload
 231         try {
 232             char val = ca1[0];
 233             System.out.println(val);
 234             Asserts.fail();
 235         } catch (NullPointerException e) {
 236             checkMessage(e, &quot;char val = ca1[0];&quot;, e.getMessage(),
 237                          &quot;Cannot load from char array because &quot; +
 238                          (hasDebugInfo ? &quot;\&quot;ca1\&quot;&quot; : &quot;\&quot;&lt;local6&gt;\&quot;&quot;) + &quot; is null&quot;);
 239         }
 240         // saload
 241         try {
 242             short val = sa1[0];
 243             System.out.println(val);
 244             Asserts.fail();
 245         } catch (NullPointerException e) {
 246             checkMessage(e, &quot;short val = sa1[0];&quot;, e.getMessage(),
 247                          &quot;Cannot load from short array because &quot; +
 248                          (hasDebugInfo ? &quot;\&quot;sa1\&quot;&quot; : &quot;\&quot;&lt;local7&gt;\&quot;&quot;) + &quot; is null&quot;);
 249         }
 250         // laload
 251         try {
 252             long val = la1[0];
 253             System.out.println(val);
 254             Asserts.fail();
 255         } catch (NullPointerException e) {
 256             checkMessage(e, &quot;long val = la1[0];&quot;, e.getMessage(),
 257                          &quot;Cannot load from long array because &quot; +
 258                          (hasDebugInfo ? &quot;\&quot;la1\&quot;&quot; : &quot;\&quot;&lt;local8&gt;\&quot;&quot;) + &quot; is null&quot;);
 259         }
 260         // daload
 261         try {
 262             double val = da1[0];
 263             System.out.println(val);
 264             Asserts.fail();
 265         } catch (NullPointerException e) {
 266             checkMessage(e, &quot;double val = da1[0];&quot;, e.getMessage(),
 267                          &quot;Cannot load from double array because &quot; +
 268                          (hasDebugInfo ? &quot;\&quot;da1\&quot;&quot; : &quot;\&quot;&lt;local9&gt;\&quot;&quot;) + &quot; is null&quot;);
 269         }
 270 
 271         // iastore
 272         try {
 273             ia1[0] = 0;
 274             System.out.println(ia1[0]);
 275             Asserts.fail();
 276         } catch (NullPointerException e) {
 277             checkMessage(e, &quot;ia1[0] = 0;&quot;, e.getMessage(),
 278                          &quot;Cannot store to int array because &quot; +
 279                          (hasDebugInfo ? &quot;\&quot;ia1\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
 280         }
 281         // fastore
 282         try {
 283             fa1[0] = 0.7f;
 284             System.out.println(fa1[0]);
 285             Asserts.fail();
 286         } catch (NullPointerException e) {
 287             checkMessage(e, &quot;fa1[0] = 0.7f;&quot;, e.getMessage(),
 288                          &quot;Cannot store to float array because &quot; +
 289                          (hasDebugInfo ? &quot;\&quot;fa1\&quot;&quot; : &quot;\&quot;&lt;local2&gt;\&quot;&quot;) + &quot; is null&quot;);
 290         }
 291         // aastore
 292         try {
 293             oa1[0] = new Object();
 294             System.out.println(oa1[0]);
 295             Asserts.fail();
 296         } catch (NullPointerException e) {
 297             checkMessage(e, &quot;oa1[0] = new Object();&quot;, e.getMessage(),
 298                          &quot;Cannot store to object array because &quot; +
 299                          (hasDebugInfo ? &quot;\&quot;oa1\&quot;&quot; : &quot;\&quot;&lt;local3&gt;\&quot;&quot;) + &quot; is null&quot;);
 300         }
 301         // bastore (boolean)
 302         try {
 303             za1[0] = false;
 304             System.out.println(za1[0]);
 305             Asserts.fail();
 306         } catch (NullPointerException e) {
 307             checkMessage(e, &quot;za1[0] = false;&quot;, e.getMessage(),
 308                          &quot;Cannot store to byte/boolean array because &quot; +
 309                          (hasDebugInfo ? &quot;\&quot;za1\&quot;&quot; : &quot;\&quot;&lt;local4&gt;\&quot;&quot;) + &quot; is null&quot;);
 310         }
 311         // bastore (byte)
 312         try {
 313             ba1[0] = 0;
 314             System.out.println(ba1[0]);
 315             Asserts.fail();
 316         } catch (NullPointerException e) {
 317             checkMessage(e, &quot;ba1[0] = 0;&quot;, e.getMessage(),
 318                          &quot;Cannot store to byte/boolean array because &quot; +
 319                          (hasDebugInfo ? &quot;\&quot;ba1\&quot;&quot; : &quot;\&quot;&lt;local5&gt;\&quot;&quot;) + &quot; is null&quot;);
 320         }
 321         // castore
 322         try {
 323             ca1[0] = 0;
 324             System.out.println(ca1[0]);
 325             Asserts.fail();
 326         } catch (NullPointerException e) {
 327             checkMessage(e, &quot;ca1[0] = 0;&quot;, e.getMessage(),
 328                          &quot;Cannot store to char array because &quot; +
 329                          (hasDebugInfo ? &quot;\&quot;ca1\&quot;&quot; : &quot;\&quot;&lt;local6&gt;\&quot;&quot;) + &quot; is null&quot;);
 330         }
 331         // sastore
 332         try {
 333             sa1[0] = 0;
 334             System.out.println(sa1[0]);
 335             Asserts.fail();
 336         } catch (NullPointerException e) {
 337             checkMessage(e, &quot;sa1[0] = 0;&quot;, e.getMessage(),
 338                          &quot;Cannot store to short array because &quot; +
 339                          (hasDebugInfo ? &quot;\&quot;sa1\&quot;&quot; : &quot;\&quot;&lt;local7&gt;\&quot;&quot;) + &quot; is null&quot;);
 340         }
 341         // lastore
 342         try {
 343             la1[0] = 0;
 344             System.out.println(la1[0]);
 345             Asserts.fail();
 346         } catch (NullPointerException e) {
 347             checkMessage(e, &quot;la1[0] = 0;&quot;, e.getMessage(),
 348                          &quot;Cannot store to long array because &quot; +
 349                          (hasDebugInfo ? &quot;\&quot;la1\&quot;&quot; : &quot;\&quot;&lt;local8&gt;\&quot;&quot;) + &quot; is null&quot;);
 350         }
 351         // dastore
 352         try {
 353             da1[0] = 0;
 354             System.out.println(da1[0]);
 355             Asserts.fail();
 356         } catch (NullPointerException e) {
 357             checkMessage(e, &quot;da1[0] = 0;&quot;, e.getMessage(),
 358                          &quot;Cannot store to double array because &quot; +
 359                          (hasDebugInfo ? &quot;\&quot;da1\&quot;&quot; : &quot;\&quot;&lt;local9&gt;\&quot;&quot;) + &quot; is null&quot;);
 360         }
 361 
 362         // arraylength
 363         try {
 364             int val = za1.length;
 365             System.out.println(val);
 366             Asserts.fail();
 367         } catch (NullPointerException e) {
 368             checkMessage(e, &quot; int val = za1.length;&quot;, e.getMessage(),
 369                          &quot;Cannot read the array length because &quot; +
 370                          (hasDebugInfo ? &quot;\&quot;za1\&quot;&quot; : &quot;\&quot;&lt;local4&gt;\&quot;&quot;) + &quot; is null&quot;);
 371         }
 372         // athrow
 373         try {
 374             RuntimeException exc = null;
 375             throw exc;
 376         } catch (NullPointerException e) {
 377             checkMessage(e, &quot;throw exc;&quot;, e.getMessage(),
 378                          &quot;Cannot throw exception because &quot; +
 379                          (hasDebugInfo ? &quot;\&quot;exc\&quot;&quot; : &quot;\&quot;&lt;local10&gt;\&quot;&quot;) + &quot; is null&quot;);
 380         }
 381         // monitorenter
 382         try {
 383             synchronized (nullInstanceField) {
 384                 // desired
 385             }
 386         } catch (NullPointerException e) {
 387             checkMessage(e, &quot;synchronized (nullInstanceField) { ... }&quot;, e.getMessage(),
 388                          &quot;Cannot enter synchronized block because &quot; +
 389                          &quot;\&quot;this.nullInstanceField\&quot; is null&quot;);
 390         }
 391         // monitorexit
 392         // No test available
 393 
 394         // getfield
 395         try {
 396             Object val = nullInstanceField.nullInstanceField;
 397             System.out.println(val);
 398             Asserts.fail();
 399         } catch (NullPointerException e) {
 400             checkMessage(e, &quot;Object val = nullInstanceField.nullInstanceField;&quot;, e.getMessage(),
 401                          &quot;Cannot read field \&quot;nullInstanceField\&quot; because &quot; +
 402                          &quot;\&quot;this.nullInstanceField\&quot; is null&quot;);
 403         }
 404         // putfield
 405         try {
 406             nullInstanceField.nullInstanceField = new NullPointerExceptionTest();
 407             System.out.println(nullInstanceField.nullInstanceField);
 408             Asserts.fail();
 409         } catch (NullPointerException e) {
 410             checkMessage(e, &quot;nullInstanceField.nullInstanceField = new NullPointerExceptionTest();&quot;, e.getMessage(),
 411                          &quot;Cannot assign field \&quot;nullInstanceField\&quot; because &quot; +
 412                          &quot;\&quot;this.nullInstanceField\&quot; is null&quot;);
 413         }
 414         // invokevirtual
 415         try {
 416             String val = nullInstanceField.toString();
 417             System.out.println(val);
 418             Asserts.fail();
 419         } catch (NullPointerException e) {
 420             checkMessage(e, &quot;String val = nullInstanceField.toString();&quot;, e.getMessage(),
 421                          &quot;Cannot invoke \&quot;Object.toString()\&quot; because &quot; +
 422                          &quot;\&quot;this.nullInstanceField\&quot; is null&quot;);
 423         }
 424         // invokeinterface
 425         try {
 426             NullPointerExceptionTest obj = this;
 427             Object val = obj.dag.getArray();
 428             Asserts.assertNull(val);
 429             Asserts.fail();
 430         } catch (NullPointerException e) {
 431             checkMessage(e, &quot;Object val = obj.dag.getArray();&quot;, e.getMessage(),
 432                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$DoubleArrayGen.getArray()\&quot; because &quot; +
 433                          (hasDebugInfo ? &quot;\&quot;obj&quot; : &quot;\&quot;&lt;local10&gt;&quot;) + &quot;.dag\&quot; is null&quot;);
 434         }
 435         // invokespecial
 436         G g = null;
 437         try {
 438             byte[] classBytes = G.generateSub2GTestClass();
 439             Lookup lookup = lookup();
 440             Class&lt;?&gt; clazz = lookup.defineClass(classBytes);
 441             g = (G) clazz.getDeclaredConstructor().newInstance();
 442         } catch (Exception e) {
 443             e.printStackTrace();
 444             Asserts.fail(&quot;Generating class Sub2G failed.&quot;);
 445         }
 446         try {
 447             g.m2(&quot;Beginning&quot;);
 448         } catch (NullPointerException e) {
 449             checkMessage(e, &quot;return super.m2(x).substring(2); // ... where super is null by bytecode manipulation.&quot;, e.getMessage(),
 450                          &quot;Cannot invoke \&quot;G.m2(String)\&quot; because \&quot;null\&quot; is null&quot;);
 451         }
 452         // Test parameter and return types
 453         try {
 454             boolean val = (nullInstanceField.callWithTypes(null, null, 0.0f, 0L, (short)0, false, (byte)0, 0.0, &#39;x&#39;) == 0.0);
 455             Asserts.assertTrue(val);
 456             Asserts.fail();
 457         } catch (NullPointerException e) {
 458             checkMessage(e, &quot;boolean val = (nullInstanceField.callWithTypes(null, null, 0.0f, 0L, (short)0, false, (byte)0, 0.0, &#39;x&#39;) == 0.0);&quot;, e.getMessage(),
 459                          &quot;Cannot invoke \&quot;NullPointerExceptionTest.callWithTypes(String[][], int[][][], float, long, short, boolean, byte, double, char)\&quot; because &quot; +
 460                          &quot;\&quot;this.nullInstanceField\&quot; is null&quot;);
 461         }
 462     }
 463 
 464     static void test_iload() {
 465         int i0 = 0;
 466         int i1 = 1;
 467         int i2 = 2;
 468         int i3 = 3;
 469         @SuppressWarnings(&quot;unused&quot;)
 470         int i4 = 4;
 471         int i5 = 5;
 472 
 473         int[][] a = new int[6][];
 474 
 475         // iload_0
 476         try {
 477             a[i0][0] = 77;
 478             Asserts.fail();
 479         } catch (NullPointerException e) {
 480             checkMessage(e, &quot;a[i0][0] = 77;&quot;, e.getMessage(),
 481                          &quot;Cannot store to int array because &quot; +
 482                          (hasDebugInfo ? &quot;\&quot;a[i0]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[&lt;local0&gt;]\&quot;&quot;) + &quot; is null&quot;);
 483         }
 484         // iload_1
 485         try {
 486             a[i1][0] = 77;
 487             Asserts.fail();
 488         } catch (NullPointerException e) {
 489             checkMessage(e, &quot;a[i1][0] = 77;&quot;, e.getMessage(),
 490                          &quot;Cannot store to int array because &quot; +
 491                          (hasDebugInfo ? &quot;\&quot;a[i1]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[&lt;local1&gt;]\&quot;&quot;) + &quot; is null&quot;);
 492         }
 493         // iload_2
 494         try {
 495             a[i2][0] = 77;
 496             Asserts.fail();
 497         } catch (NullPointerException e) {
 498             checkMessage(e, &quot;a[i2][0] = 77;&quot;, e.getMessage(),
 499                          &quot;Cannot store to int array because &quot; +
 500                          (hasDebugInfo ? &quot;\&quot;a[i2]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[&lt;local2&gt;]\&quot;&quot;) + &quot; is null&quot;);
 501         }
 502         // iload_3
 503         try {
 504             a[i3][0] = 77;
 505             Asserts.fail();
 506         } catch (NullPointerException e) {
 507             checkMessage(e, &quot;a[i3][0] = 77;&quot;, e.getMessage(),
 508                          &quot;Cannot store to int array because &quot; +
 509                          (hasDebugInfo ? &quot;\&quot;a[i3]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[&lt;local3&gt;]\&quot;&quot;) + &quot; is null&quot;);
 510         }
 511         // iload
 512         try {
 513             a[i5][0] = 77;
 514             Asserts.fail();
 515         } catch (NullPointerException e) {
 516             checkMessage(e, &quot;a[i5][0] = 77;&quot;, e.getMessage(),
 517                          &quot;Cannot store to int array because &quot; +
 518                          (hasDebugInfo ? &quot;\&quot;a[i5]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[&lt;local5&gt;]\&quot;&quot;) + &quot; is null&quot;);
 519         }
 520     }
 521 
 522     // Other datatyes than int are not needed.
 523     // If we implement l2d and similar bytecodes, we can print
 524     // long expressions as array indexes. Then these here could
 525     // be used.
 526     static void test_lload() {
 527         long long0 = 0L;  // l0 looks like 10. Therefore long0.
 528         long long1 = 1L;
 529         long long2 = 2L;
 530         long long3 = 3L;
 531         @SuppressWarnings(&quot;unused&quot;)
 532         long long4 = 4L;
 533         long long5 = 5L;
 534 
 535         int[][] a = new int[6][];
 536 
 537         // lload_0
 538         try {
 539             a[(int)long0][0] = 77;
 540             Asserts.fail();
 541         } catch (NullPointerException e) {
 542             checkMessage(e, &quot;a[(int)long0][0] = 77;&quot;, e.getMessage(),
 543                          &quot;Cannot store to int array because &quot; +
 544                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local12&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 545         }
 546         // lload_1
 547         try {
 548             a[(int)long1][0] = 77;
 549             Asserts.fail();
 550         } catch (NullPointerException e) {
 551             checkMessage(e, &quot;a[(int)long1][0] = 77;&quot;, e.getMessage(),
 552                          &quot;Cannot store to int array because &quot; +
 553                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local12&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 554         }
 555         // lload_2
 556         try {
 557             a[(int)long2][0] = 77;
 558             Asserts.fail();
 559         } catch (NullPointerException e) {
 560             checkMessage(e, &quot;a[(int)long2][0] = 77;&quot;, e.getMessage(),
 561                          &quot;Cannot store to int array because &quot; +
 562                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local12&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 563         }
 564         // lload_3
 565         try {
 566             a[(int)long3][0] = 77;
 567             Asserts.fail();
 568         } catch (NullPointerException e) {
 569             checkMessage(e, &quot;a[(int)long3][0] = 77;&quot;, e.getMessage(),
 570                          &quot;Cannot store to int array because &quot; +
 571                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local12&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 572         }
 573         // lload
 574         try {
 575             a[(int)long5][0] = 77;
 576             Asserts.fail();
 577         } catch (NullPointerException e) {
 578             checkMessage(e, &quot;a[(int)long5][0] = 77;&quot;, e.getMessage(),
 579                          &quot;Cannot store to int array because &quot; +
 580                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local12&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 581         }
 582     }
 583 
 584     static void test_fload() {
 585         float f0 = 0.0f;
 586         float f1 = 1.0f;
 587         float f2 = 2.0f;
 588         float f3 = 3.0f;
 589         @SuppressWarnings(&quot;unused&quot;)
 590         float f4 = 4.0f;
 591         float f5 = 5.0f;
 592 
 593         int[][] a = new int[6][];
 594 
 595         // fload_0
 596         try {
 597             a[(int)f0][0] = 77;
 598             Asserts.fail();
 599         } catch (NullPointerException e) {
 600             checkMessage(e, &quot;a[(int)f0][0] = 77;&quot;, e.getMessage(),
 601                          &quot;Cannot store to int array because &quot; +
 602                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 603         }
 604         // fload_1
 605         try {
 606             a[(int)f1][0] = 77;
 607             Asserts.fail();
 608         } catch (NullPointerException e) {
 609             checkMessage(e, &quot;a[(int)f1][0] = 77;&quot;, e.getMessage(),
 610                          &quot;Cannot store to int array because &quot; +
 611                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 612         }
 613         // fload_2
 614         try {
 615             a[(int)f2][0] = 77;
 616             Asserts.fail();
 617         } catch (NullPointerException e) {
 618             checkMessage(e, &quot;a[(int)f2][0] = 77;&quot;, e.getMessage(),
 619                          &quot;Cannot store to int array because &quot; +
 620                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 621         }
 622         // fload_3
 623         try {
 624             a[(int)f3][0] = 77;
 625             Asserts.fail();
 626         } catch (NullPointerException e) {
 627             checkMessage(e, &quot;a[(int)f3][0] = 77;&quot;, e.getMessage(),
 628                          &quot;Cannot store to int array because &quot; +
 629                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 630         }
 631         // fload
 632         try {
 633             a[(int)f5][0] = 77;
 634             Asserts.fail();
 635         } catch (NullPointerException e) {
 636             checkMessage(e, &quot;a[(int)f5][0] = 77;&quot;, e.getMessage(),
 637                          &quot;Cannot store to int array because &quot; +
 638                          (hasDebugInfo ? &quot;\&quot;a[...]\&quot;&quot; : &quot;\&quot;&lt;local6&gt;[...]\&quot;&quot;) + &quot; is null&quot;);
 639         }
 640     }
 641 
 642     @SuppressWarnings(&quot;null&quot;)
 643     static void test_aload() {
 644         F f0 = null;
 645         F f1 = null;
 646         F f2 = null;
 647         F f3 = null;
 648         @SuppressWarnings(&quot;unused&quot;)
 649         F f4 = null;
 650         F f5 = null;
 651 
 652         // aload_0
 653         try {
 654             f0.i = 33;
 655             Asserts.fail();
 656         } catch (NullPointerException e) {
 657             checkMessage(e, &quot;f0.i = 33;&quot;, e.getMessage(),
 658                          &quot;Cannot assign field \&quot;i\&quot; because &quot; +
 659                          (hasDebugInfo ? &quot;\&quot;f0\&quot;&quot; : &quot;\&quot;&lt;local0&gt;\&quot;&quot;) + &quot; is null&quot;);
 660         }
 661         // aload_1
 662         try {
 663             f1.i = 33;
 664             Asserts.fail();
 665         } catch (NullPointerException e) {
 666             checkMessage(e, &quot;f1.i = 33;&quot;, e.getMessage(),
 667                          &quot;Cannot assign field \&quot;i\&quot; because &quot; +
 668                          (hasDebugInfo ? &quot;\&quot;f1\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
 669         }
 670         // aload_2
 671         try {
 672             f2.i = 33;
 673             Asserts.fail();
 674         } catch (NullPointerException e) {
 675             checkMessage(e, &quot;f2.i = 33;&quot;, e.getMessage(),
 676                          &quot;Cannot assign field \&quot;i\&quot; because &quot; +
 677                          (hasDebugInfo ? &quot;\&quot;f2\&quot;&quot; : &quot;\&quot;&lt;local2&gt;\&quot;&quot;) + &quot; is null&quot;);
 678         }
 679         // aload_3
 680         try {
 681             f3.i = 33;
 682             Asserts.fail();
 683         } catch (NullPointerException e) {
 684             checkMessage(e, &quot;f3.i = 33;&quot;, e.getMessage(),
 685                          &quot;Cannot assign field \&quot;i\&quot; because &quot; +
 686                          (hasDebugInfo ? &quot;\&quot;f3\&quot;&quot; : &quot;\&quot;&lt;local3&gt;\&quot;&quot;) + &quot; is null&quot;);
 687         }
 688         // aload
 689         try {
 690             f5.i = 33;
 691             Asserts.fail();
 692         } catch (NullPointerException e) {
 693             checkMessage(e, &quot;f5.i = 33;&quot;, e.getMessage(),
 694                          &quot;Cannot assign field \&quot;i\&quot; because &quot; +
 695                          (hasDebugInfo ? &quot;\&quot;f5\&quot;&quot; : &quot;\&quot;&lt;local5&gt;\&quot;&quot;) + &quot; is null&quot;);
 696         }
 697     }
 698 
 699     // Helper class for test cases.
 700     class A {
 701         public B to_b;
 702         public B getB() { return to_b; }
 703     }
 704 
 705     // Helper class for test cases.
 706     class B {
 707         public C to_c;
 708         public B to_b;
 709         public C getC() { return to_c; }
 710         public B getBfromB() { return to_b; }
 711     }
 712 
 713     // Helper class for test cases.
 714     class C {
 715         public D to_d;
 716         public D getD() { return to_d; }
 717     }
 718 
 719     // Helper class for test cases.
 720     class D {
 721         public int num;
 722         public int[][] ar;
 723     }
 724 
 725 
 726     @SuppressWarnings(&quot;null&quot;)
 727     public void testArrayChasing() {
 728         int[][][][][][] a = null;
 729         try {
 730             a[0][0][0][0][0][0] = 99;
 731             Asserts.fail();
 732         } catch (NullPointerException e) {
 733             checkMessage(e, &quot;a[0][0][0][0][0] = 99; // a is null&quot;, e.getMessage(),
 734                          &quot;Cannot load from object array because &quot; +
 735                          (hasDebugInfo ? &quot;\&quot;a\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
 736         }
 737         a = new int[1][][][][][];
 738         try {
 739             a[0][0][0][0][0][0] = 99;
 740             Asserts.fail();
 741         } catch (NullPointerException e) {
 742             checkMessage(e, &quot;a[0][0][0][0][0] = 99; // a[0] is null&quot;, e.getMessage(),
 743                          &quot;Cannot load from object array because &quot; +
 744                          (hasDebugInfo ? &quot;\&quot;a[0]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[0]\&quot;&quot;) + &quot; is null&quot;);
 745         }
 746         a[0] = new int[1][][][][];
 747         try {
 748             a[0][0][0][0][0][0] = 99;
 749             Asserts.fail();
 750         } catch (NullPointerException e) {
 751             checkMessage(e, &quot;a[0][0][0][0][0] = 99; // a[0][0] is null&quot;, e.getMessage(),
 752                          &quot;Cannot load from object array because &quot; +
 753                          (hasDebugInfo ? &quot;\&quot;a[0][0]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[0][0]\&quot;&quot;) + &quot; is null&quot;);
 754         }
 755         a[0][0] = new int[1][][][];
 756         try {
 757             a[0][0][0][0][0][0] = 99;
 758             Asserts.fail();
 759         } catch (NullPointerException e) {
 760             checkMessage(e, &quot;a[0][0][0][0][0] = 99; // a[0][0][0] is null&quot;, e.getMessage(),
 761                          &quot;Cannot load from object array because &quot; +
 762                          (hasDebugInfo ? &quot;\&quot;a[0][0][0]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[0][0][0]\&quot;&quot;) + &quot; is null&quot;);
 763         }
 764         try {
 765             System.out.println(a[0][0][0].length);
 766             Asserts.fail();
 767         } catch (NullPointerException e) {
 768             checkMessage(e, &quot;a[0][0][0].length; // a[0][0][0] is null&quot;, e.getMessage(),
 769                          &quot;Cannot read the array length because &quot; +
 770                          (hasDebugInfo ? &quot;\&quot;a[0][0][0]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[0][0][0]\&quot;&quot;) + &quot; is null&quot;);
 771         }
 772         a[0][0][0] = new int[1][][];
 773         try {
 774             a[0][0][0][0][0][0] = 99;
 775             Asserts.fail();
 776         } catch (NullPointerException e) {
 777             checkMessage(e, &quot;a[0][0][0][0][0] = 99; // a[0][0][0][0] is null&quot;, e.getMessage(),
 778                          &quot;Cannot load from object array because &quot; +
 779                          (hasDebugInfo ? &quot;\&quot;a[0][0][0][0]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[0][0][0][0]\&quot;&quot;) + &quot; is null&quot;);
 780         }
 781         a[0][0][0][0] = new int[1][];
 782         // Reaching max recursion depth. Prints &lt;array&gt;.
 783         try {
 784             a[0][0][0][0][0][0] = 99;
 785             Asserts.fail();
 786         } catch (NullPointerException e) {
 787             checkMessage(e, &quot;a[0][0][0][0][0] = 99; // a[0][0][0][0][0] is null&quot;, e.getMessage(),
 788                          &quot;Cannot store to int array because &quot; +
 789                          &quot;\&quot;&lt;array&gt;[0][0][0][0][0]\&quot; is null&quot;);
 790         }
 791         a[0][0][0][0][0] = new int[1];
 792         try {
 793             a[0][0][0][0][0][0] = 99;
 794         } catch (NullPointerException e) {
 795             Asserts.fail();
 796         }
 797     }
 798 
 799     @SuppressWarnings(&quot;null&quot;)
 800     public void testPointerChasing() {
 801         A a = null;
 802         try {
 803             a.to_b.to_c.to_d.num = 99;
 804             Asserts.fail();
 805         } catch (NullPointerException e) {
 806             checkMessage(e, &quot;a.to_b.to_c.to_d.num = 99; // a is null&quot;, e.getMessage(),
 807                          &quot;Cannot read field \&quot;to_b\&quot; because &quot; +
 808                          (hasDebugInfo ? &quot;\&quot;a\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
 809         }
 810         a = new A();
 811         try {
 812             a.to_b.to_c.to_d.num = 99;
 813             Asserts.fail();
 814         } catch (NullPointerException e) {
 815             checkMessage(e, &quot;a.to_b.to_c.to_d.num = 99; // a.to_b is null&quot;, e.getMessage(),
 816                          &quot;Cannot read field \&quot;to_c\&quot; because &quot; +
 817                          (hasDebugInfo ? &quot;\&quot;a.to_b\&quot;&quot; : &quot;\&quot;&lt;local1&gt;.to_b\&quot;&quot;) + &quot; is null&quot;);
 818         }
 819         a.to_b = new B();
 820         try {
 821             a.to_b.to_c.to_d.num = 99;
 822             Asserts.fail();
 823         } catch (NullPointerException e) {
 824             checkMessage(e, &quot;a.to_b.to_c.to_d.num = 99; // a.to_b.to_c is null&quot;, e.getMessage(),
 825                          &quot;Cannot read field \&quot;to_d\&quot; because &quot; +
 826                          (hasDebugInfo ? &quot;\&quot;a.to_b.to_c\&quot;&quot; : &quot;\&quot;&lt;local1&gt;.to_b.to_c\&quot;&quot;) + &quot; is null&quot;);
 827         }
 828         a.to_b.to_c = new C();
 829         try {
 830             a.to_b.to_c.to_d.num = 99;
 831             Asserts.fail();
 832         } catch (NullPointerException e) {
 833             checkMessage(e, &quot;a.to_b.to_c.to_d.num = 99; // a.to_b.to_c.to_d is null&quot;, e.getMessage(),
 834                          &quot;Cannot assign field \&quot;num\&quot; because &quot; +
 835                          (hasDebugInfo ? &quot;\&quot;a.to_b.to_c.to_d\&quot;&quot; : &quot;\&quot;&lt;local1&gt;.to_b.to_c.to_d\&quot;&quot;) + &quot; is null&quot;);
 836         }
 837     }
 838 
 839     @SuppressWarnings(&quot;null&quot;)
 840     public void testMethodChasing() {
 841         A a = null;
 842         try {
 843             a.getB().getBfromB().getC().getD().num = 99;
 844             Asserts.fail();
 845         } catch (NullPointerException e) {
 846             checkMessage(e, &quot;a.getB().getBfromB().getC().getD().num = 99; // a is null&quot;, e.getMessage(),
 847                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$A.getB()\&quot; because &quot; +
 848                          (hasDebugInfo ? &quot;\&quot;a&quot; : &quot;\&quot;&lt;local1&gt;&quot;) + &quot;\&quot; is null&quot;);
 849         }
 850         a = new A();
 851         try {
 852             a.getB().getBfromB().getC().getD().num = 99;
 853             Asserts.fail();
 854         } catch (NullPointerException e) {
 855             checkMessage(e, &quot;a.getB().getBfromB().getC().getD().num = 99; // a.getB() is null&quot;, e.getMessage(),
 856                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$B.getBfromB()\&quot; because &quot; +
 857                          &quot;the return value of \&quot;NullPointerExceptionTest$A.getB()\&quot; is null&quot;);
 858         }
 859         a.to_b = new B();
 860         try {
 861             a.getB().getBfromB().getC().getD().num = 99;
 862             Asserts.fail();
 863         } catch (NullPointerException e) {
 864             checkMessage(e, &quot;a.getB().getBfromB().getC().getD().num = 99; // a.getB().getBfromB() is null&quot;, e.getMessage(),
 865                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$B.getC()\&quot; because &quot; +
 866                          &quot;the return value of \&quot;NullPointerExceptionTest$B.getBfromB()\&quot; is null&quot;);
 867         }
 868         a.to_b.to_b = new B();
 869         try {
 870             a.getB().getBfromB().getC().getD().num = 99;
 871             Asserts.fail();
 872         } catch (NullPointerException e) {
 873             checkMessage(e, &quot;a.getB().getBfromB().getC().getD().num = 99; // a.getB().getBfromB().getC() is null&quot;, e.getMessage(),
 874                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$C.getD()\&quot; because &quot; +
 875                          &quot;the return value of \&quot;NullPointerExceptionTest$B.getC()\&quot; is null&quot;);
 876         }
 877         a.to_b.to_b.to_c = new C();
 878         try {
 879             a.getB().getBfromB().getC().getD().num = 99;
 880             Asserts.fail();
 881         } catch (NullPointerException e) {
 882             checkMessage(e, &quot;a.getB().getBfromB().getC().getD().num = 99; // a.getB().getBfromB().getC().getD() is null&quot;, e.getMessage(),
 883                          &quot;Cannot assign field \&quot;num\&quot; because &quot; +
 884                          &quot;the return value of \&quot;NullPointerExceptionTest$C.getD()\&quot; is null&quot;);
 885         }
 886     }
 887 
 888     @SuppressWarnings(&quot;null&quot;)
 889     public void testMixedChasing() {
 890         A a = null;
 891         try {
 892             a.getB().getBfromB().to_c.to_d.ar[0][0] = 99;
 893             Asserts.fail();
 894         } catch (NullPointerException e) {
 895             checkMessage(e, &quot;a.getB().getBfromB().to_c.to_d.ar[0][0] = 99; // a is null&quot;, e.getMessage(),
 896                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$A.getB()\&quot; because &quot; +
 897                          (hasDebugInfo ? &quot;\&quot;a\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
 898         }
 899         a = new A();
 900         try {
 901             a.getB().getBfromB().to_c.to_d.ar[0][0] = 99;
 902             Asserts.fail();
 903         } catch (NullPointerException e) {
 904             checkMessage(e, &quot;a.getB().getBfromB().to_c.to_d.ar[0][0] = 99; // a.getB() is null&quot;, e.getMessage(),
 905                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$B.getBfromB()\&quot; because &quot; +
 906                          &quot;the return value of \&quot;NullPointerExceptionTest$A.getB()\&quot; is null&quot;);
 907         }
 908         a.to_b = new B();
 909         try {
 910             a.getB().getBfromB().to_c.to_d.ar[0][0] = 99;
 911             Asserts.fail();
 912         } catch (NullPointerException e) {
 913             checkMessage(e, &quot;a.getB().getBfromB().to_c.to_d.ar[0][0] = 99; // a.getB().getBfromB() is null&quot;, e.getMessage(),
 914                          &quot;Cannot read field \&quot;to_c\&quot; because &quot; +
 915                          &quot;the return value of \&quot;NullPointerExceptionTest$B.getBfromB()\&quot; is null&quot;);
 916         }
 917         a.to_b.to_b = new B();
 918         try {
 919             a.getB().getBfromB().to_c.to_d.ar[0][0] = 99;
 920             Asserts.fail();
 921         } catch (NullPointerException e) {
 922             checkMessage(e, &quot;a.getB().getBfromB().to_c.to_d.ar[0][0] = 99; // a.getB().getBfromB().to_c is null&quot;, e.getMessage(),
 923                          &quot;Cannot read field \&quot;to_d\&quot; because &quot; +
 924                          &quot;\&quot;NullPointerExceptionTest$B.getBfromB().to_c\&quot; is null&quot;);
 925         }
 926         a.to_b.to_b.to_c = new C();
 927         try {
 928             a.getB().getBfromB().to_c.to_d.ar[0][0] = 99;
 929             Asserts.fail();
 930         } catch (NullPointerException e) {
 931             checkMessage(e, &quot;a.getB().getBfromB().to_c.to_d.ar[0][0] = 99; // a.getB().getBfromB().to_c.to_d is null&quot;, e.getMessage(),
 932                          &quot;Cannot read field \&quot;ar\&quot; because &quot; +
 933                          &quot;\&quot;NullPointerExceptionTest$B.getBfromB().to_c.to_d\&quot; is null&quot;);
 934         }
 935         a.to_b.to_b.to_c.to_d = new D();
 936         try {
 937             a.getB().getBfromB().to_c.to_d.ar[0][0] = 99;
 938             Asserts.fail();
 939         } catch (NullPointerException e) {
 940             checkMessage(e, &quot;a.getB().getBfromB().to_c.to_d.ar[0][0] = 99; // a.getB().getBfromB().to_c.to_d.ar is null&quot;, e.getMessage(),
 941                          &quot;Cannot load from object array because &quot; +
 942                          &quot;\&quot;NullPointerExceptionTest$B.getBfromB().to_c.to_d.ar\&quot; is null&quot;);
 943         }
 944         try {
 945             a.getB().getBfromB().getC().getD().ar[0][0] = 99;
 946             Asserts.fail();
 947         } catch (NullPointerException e) {
 948             checkMessage(e, &quot;a.getB().getBfromB().getC().getD().ar[0][0] = 99; // a.getB().getBfromB().getC().getD().ar is null&quot;, e.getMessage(),
 949                          &quot;Cannot load from object array because &quot; +
 950                          &quot;\&quot;NullPointerExceptionTest$C.getD().ar\&quot; is null&quot;);
 951         }
 952         a.to_b.to_b.to_c.to_d.ar = new int[1][];
 953         try {
 954             a.getB().getBfromB().to_c.to_d.ar[0][0] = 99;
 955             Asserts.fail();
 956         } catch (NullPointerException e) {
 957             checkMessage(e, &quot;a.getB().getBfromB().to_c.to_d.ar[0][0] = 99; // a.getB().getBfromB().to_c.to_d.ar[0] is null&quot;, e.getMessage(),
 958                          &quot;Cannot store to int array because &quot; +
 959                          &quot;\&quot;NullPointerExceptionTest$B.getBfromB().to_c.to_d.ar[0]\&quot; is null&quot;);
 960         }
 961         try {
 962             a.getB().getBfromB().getC().getD().ar[0][0] = 99;
 963             Asserts.fail();
 964         } catch (NullPointerException e) {
 965             checkMessage(e, &quot;a.getB().getBfromB().getC().getD().ar[0][0] = 99; // a.getB().getBfromB().getC().getD().ar[0] is null&quot;, e.getMessage(),
 966                          &quot;Cannot store to int array because &quot; +
 967                          &quot;\&quot;NullPointerExceptionTest$C.getD().ar[0]\&quot; is null&quot;);
 968         }
 969     }
 970 
 971     // Helper method to cause test case.
 972     private Object returnNull(String[][] dummy1, int[][][] dummy2, float dummy3) {
 973         return null;
 974     }
 975 
 976     // Helper method to cause test case.
 977     private NullPointerExceptionTest returnMeAsNull(Throwable dummy1, int dummy2, char dummy3) {
 978         return null;
 979     }
 980 
 981     // Helper interface for test cases.
 982     static interface DoubleArrayGen {
 983         public double[] getArray();
 984     }
 985 
 986     // Helper class for test cases.
 987     static class DoubleArrayGenImpl implements DoubleArrayGen {
 988         @Override
 989         public double[] getArray() {
 990             return null;
 991         }
 992     }
 993 
 994     // Helper class for test cases.
 995     static class NullPointerGenerator {
 996         public static Object nullReturner(boolean dummy1) {
 997             return null;
 998         }
 999 
1000         public Object returnMyNull(double dummy1, long dummy2, short dummy3) {
1001             return null;
1002         }
1003     }
1004 
1005     // Helper method to cause test case.
1006     public void ImplTestLoadedFromMethod(DoubleArrayGen gen) {
1007         try {
1008             (gen.getArray())[0] = 1.0;
1009             Asserts.fail();
1010         } catch (NullPointerException e) {
1011             checkMessage(e, &quot;(gen.getArray())[0] = 1.0;&quot;, e.getMessage(),
1012                          &quot;Cannot store to double array because &quot; +
1013                          &quot;the return value of \&quot;NullPointerExceptionTest$DoubleArrayGen.getArray()\&quot; is null&quot;);
1014         }
1015     }
1016 
1017     public void testNullEntity() {
1018         int[][] a = new int[820][];
1019 
1020         test_iload();
1021         test_lload();
1022         test_fload();
1023         // test_dload();
1024         test_aload();
1025         // aload_0: &#39;this&#39;
1026         try {
1027             this.nullInstanceField.nullInstanceField = new NullPointerExceptionTest();
1028             Asserts.fail();
1029         } catch (NullPointerException e) {
1030             checkMessage(e, &quot;this.nullInstanceField.nullInstanceField = new NullPointerExceptionTest();&quot;, e.getMessage(),
1031                          &quot;Cannot assign field \&quot;nullInstanceField\&quot; because \&quot;this.nullInstanceField\&quot; is null&quot;);
1032         }
1033 
1034         // aconst_null
1035         try {
1036             throw null;
1037         } catch (NullPointerException e) {
1038             checkMessage(e, &quot;throw null;&quot;, e.getMessage(),
1039                          &quot;Cannot throw exception because \&quot;null\&quot; is null&quot;);
1040         }
1041         // iconst_0
1042         try {
1043             a[0][0] = 77;
1044             Asserts.fail();
1045         } catch (NullPointerException e) {
1046             checkMessage(e, &quot;a[0][0] = 77;&quot;, e.getMessage(),
1047                          &quot;Cannot store to int array because &quot; +
1048                          (hasDebugInfo ? &quot;\&quot;a[0]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[0]\&quot;&quot;) + &quot; is null&quot;);
1049         }
1050         // iconst_1
1051         try {
1052             a[1][0] = 77;
1053             Asserts.fail();
1054         } catch (NullPointerException e) {
1055             checkMessage(e, &quot;a[1][0] = 77;&quot;, e.getMessage(),
1056                          &quot;Cannot store to int array because &quot; +
1057                          (hasDebugInfo ? &quot;\&quot;a[1]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[1]\&quot;&quot;) + &quot; is null&quot;);
1058         }
1059         // iconst_2
1060         try {
1061             a[2][0] = 77;
1062             Asserts.fail();
1063         } catch (NullPointerException e) {
1064             checkMessage(e, &quot;a[2][0] = 77;&quot;, e.getMessage(),
1065                          &quot;Cannot store to int array because &quot; +
1066                          (hasDebugInfo ? &quot;\&quot;a[2]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[2]\&quot;&quot;) + &quot; is null&quot;);
1067         }
1068         // iconst_3
1069         try {
1070             a[3][0] = 77;
1071             Asserts.fail();
1072         } catch (NullPointerException e) {
1073             checkMessage(e, &quot;a[3][0] = 77;&quot;, e.getMessage(),
1074                          &quot;Cannot store to int array because &quot; +
1075                          (hasDebugInfo ? &quot;\&quot;a[3]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[3]\&quot;&quot;) + &quot; is null&quot;);
1076         }
1077         // iconst_4
1078         try {
1079             a[4][0] = 77;
1080             Asserts.fail();
1081         } catch (NullPointerException e) {
1082             checkMessage(e, &quot;a[4][0] = 77;&quot;, e.getMessage(),
1083                          &quot;Cannot store to int array because &quot; +
1084                          (hasDebugInfo ? &quot;\&quot;a[4]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[4]\&quot;&quot;) + &quot; is null&quot;);
1085         }
1086         // iconst_5
1087         try {
1088             a[5][0] = 77;
1089             Asserts.fail();
1090         } catch (NullPointerException e) {
1091             checkMessage(e, &quot;a[5][0] = 77;&quot;, e.getMessage(),
1092                          &quot;Cannot store to int array because &quot; +
1093                          (hasDebugInfo ? &quot;\&quot;a[5]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[5]\&quot;&quot;) + &quot; is null&quot;);
1094         }
1095         // long --&gt; iconst
1096         try {
1097             a[(int)0L][0] = 77;
1098             Asserts.fail();
1099         } catch (NullPointerException e) {
1100             checkMessage(e, &quot;a[(int)0L][0] = 77;&quot;, e.getMessage(),
1101                          &quot;Cannot store to int array because &quot; +
1102                          (hasDebugInfo ? &quot;\&quot;a[0]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[0]\&quot;&quot;) + &quot; is null&quot;);
1103         }
1104         // bipush
1105         try {
1106             a[139 /*0x77*/][0] = 77;
1107             Asserts.fail();
1108         } catch (NullPointerException e) {
1109             checkMessage(e, &quot;a[139][0] = 77;&quot;, e.getMessage(),
1110                          &quot;Cannot store to int array because &quot; +
1111                          (hasDebugInfo ? &quot;\&quot;a[139]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[139]\&quot;&quot;) + &quot; is null&quot;);
1112         }
1113         // sipush
1114         try {
1115             a[819 /*0x333*/][0] = 77;
1116             Asserts.fail();
1117         } catch (NullPointerException e) {
1118             checkMessage(e, &quot;a[819][0] = 77;&quot;, e.getMessage(),
1119                          &quot;Cannot store to int array because &quot; +
1120                          (hasDebugInfo ? &quot;\&quot;a[819]\&quot;&quot; : &quot;\&quot;&lt;local1&gt;[819]\&quot;&quot;) + &quot; is null&quot;);
1121         }
1122 
1123         // aaload, with recursive descend.
1124         testArrayChasing();
1125 
1126         // getstatic
1127         try {
1128             boolean val = (((float[]) nullStaticField)[0] == 1.0f);
1129             Asserts.assertTrue(val);
1130             Asserts.fail();
1131         } catch (NullPointerException e) {
1132             checkMessage(e, &quot;boolean val = (((float[]) nullStaticField)[0] == 1.0f);&quot;, e.getMessage(),
1133                          &quot;Cannot load from float array because \&quot;NullPointerExceptionTest.nullStaticField\&quot; is null&quot;);
1134         }
1135 
1136         // getfield, with recursive descend.
1137         testPointerChasing();
1138 
1139         // invokestatic
1140         try {
1141             char val = ((char[]) NullPointerGenerator.nullReturner(false))[0];
1142             System.out.println(val);
1143             Asserts.fail();
1144         } catch (NullPointerException e) {
1145             checkMessage(e, &quot;char val = ((char[]) NullPointerGenerator.nullReturner(false))[0];&quot;, e.getMessage(),
1146                          &quot;Cannot load from char array because &quot; +
1147                          &quot;the return value of \&quot;NullPointerExceptionTest$NullPointerGenerator.nullReturner(boolean)\&quot; is null&quot;);
1148         }
1149         // invokevirtual
1150         try {
1151             char val = ((char[]) (new NullPointerGenerator().returnMyNull(1, 1, (short) 1)))[0];
1152             System.out.println(val);
1153             Asserts.fail();
1154         } catch (NullPointerException e) {
1155             checkMessage(e, &quot;char val = ((char[]) (new NullPointerGenerator().returnMyNull(1, 1, (short) 1)))[0];&quot;, e.getMessage(),
1156                          &quot;Cannot load from char array because &quot; +
1157                          &quot;the return value of \&quot;NullPointerExceptionTest$NullPointerGenerator.returnMyNull(double, long, short)\&quot; is null&quot;);
1158         }
1159         // Call with array arguments.
1160         try {
1161             double val = ((double[]) returnNull(null, null, 1f))[0];
1162             System.out.println(val);
1163             Asserts.fail();
1164         } catch (NullPointerException e) {
1165             checkMessage(e, &quot;double val = ((double[]) returnNull(null, null, 1f))[0];&quot;, e.getMessage(),
1166                          &quot;Cannot load from double array because &quot; +
1167                          &quot;the return value of \&quot;NullPointerExceptionTest.returnNull(String[][], int[][][], float)\&quot; is null&quot;);
1168         }
1169         // invokespecial
1170         try {
1171             SubG g = new SubG();
1172             g.m2(&quot;Beginning&quot;);
1173         } catch (NullPointerException e) {
1174             checkMessage(e, &quot;return super.m2(x).substring(2);&quot;, e.getMessage(),
1175                          &quot;Cannot invoke \&quot;String.substring(int)\&quot; because &quot; +
1176                          &quot;the return value of \&quot;G.m2(String)\&quot; is null&quot;);
1177         }
1178         // invokeinterface
1179         ImplTestLoadedFromMethod(new DoubleArrayGenImpl());
1180         try {
1181             returnMeAsNull(null, 1, &#39;A&#39;).dag = new DoubleArrayGenImpl();
1182             Asserts.fail();
1183         } catch (NullPointerException e) {
1184             checkMessage(e, &quot;returnMeAsNull(null, 1, &#39;A&#39;).dag = new DoubleArrayGenImpl();&quot;, e.getMessage(),
1185                          &quot;Cannot assign field \&quot;dag\&quot; because &quot; +
1186                          &quot;the return value of \&quot;NullPointerExceptionTest.returnMeAsNull(java.lang.Throwable, int, char)\&quot; is null&quot;);
1187         }
1188         testMethodChasing();
1189 
1190         // Mixed recursive descend.
1191         testMixedChasing();
1192     }
1193 
1194     // Assure 64 parameters are printed as &#39;parameteri&#39;.
1195     public String manyParameters(
1196         int  i1, int  i2, int  i3, int  i4, int  i5, int  i6, int  i7, int  i8, int  i9, int i10,
1197         int i11, int i12, int i13, int i14, int i15, int i16, int i17, int i18, int i19, int i20,
1198         int i21, int i22, int i23, int i24, int i25, int i26, int i27, int i28, int i29, int i30,
1199         int i31, int i32, int i33, int i34, int i35, int i36, int i37, int i38, int i39, int i40,
1200         int i41, int i42, int i43, int i44, int i45, int i46, int i47, int i48, int i49, int i50,
1201         int i51, int i52, int i53, int i54, int i55, int i56, int i57, int i58, int i59, int i60,
1202         int i61, int i62, int i63, int i64, int i65, int i66, int i67, int i68, int i69, int i70) {
1203         String[][][][] ar5 = new String[1][1][1][1];
1204         int[][][] idx3 = new int[1][1][1];
1205         int[][]   idx2 = new int[1][1];
1206         return ar5[i70]
1207                   [idx2[i65][i64]]
1208                   [idx3[i63][i62][i47]]
1209                   [idx3[idx2[i33][i32]][i31][i17]]
1210                   .substring(2);
1211     }
1212 
1213     // The double placeholder takes two slots on the stack.
1214     public void testParametersTestMethod(A a, double placeholder, B b, Integer i) throws Exception {
1215         try {
1216             a.to_b.to_c.to_d.num = 99;
1217             Asserts.fail();
1218         } catch (NullPointerException e) {
1219             checkMessage(e, &quot;a.to_b.to_c.to_d.num = 99; // to_c is null, a is a parameter.&quot;, e.getMessage(),
1220                          &quot;Cannot read field \&quot;to_d\&quot; because \&quot;&quot; +
1221                          (hasDebugInfo ? &quot;a&quot; : &quot;&lt;parameter1&gt;&quot;) + &quot;.to_b.to_c\&quot; is null&quot;);
1222         }
1223 
1224         try {
1225             b.to_c.to_d.num = 99;
1226             Asserts.fail();
1227         } catch (NullPointerException e) {
1228             checkMessage(e, &quot;b.to_c.to_d.num = 99; // b is null and b is a parameter.&quot;, e.getMessage(),
1229                          &quot;Cannot read field \&quot;to_c\&quot; because &quot; +
1230                          // We expect number &#39;3&#39; for the parameter.
1231                          (hasDebugInfo ? &quot;\&quot;b\&quot;&quot; : &quot;\&quot;&lt;parameter3&gt;\&quot;&quot;) + &quot; is null&quot;);
1232         }
1233 
1234 
1235         try {
1236             @SuppressWarnings(&quot;unused&quot;)
1237             int my_i = i;
1238         }  catch (NullPointerException e) {
1239             checkMessage(e, &quot;int my_i = i; // i is a parameter of type Integer.&quot;,  e.getMessage(),
1240                          &quot;Cannot invoke \&quot;java.lang.Integer.intValue()\&quot; because &quot; +
1241                          (hasDebugInfo ? &quot;\&quot;i\&quot;&quot; : &quot;\&quot;&lt;parameter4&gt;\&quot;&quot;) + &quot; is null&quot;);
1242         }
1243 
1244         // If no debug information is available, only 64 parameters (this and i1 through i63)
1245         // will be reported in the message as &#39;parameteri&#39;. Others will be reported as &#39;locali&#39;.
1246         try {
1247             manyParameters(0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1248                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1249                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1250                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1251                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1252                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1253                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
1254             } catch (NullPointerException e) {
1255                 checkMessage(e, &quot;return ar5[i70][idx2[i65][i64]][idx3[i63][i62][i47]][idx3[idx2[i33][i32]][i31][i17]].substring(2);&quot;, e.getMessage(),
1256                              &quot;Cannot invoke \&quot;String.substring(int)\&quot; because &quot; +
1257                              (hasDebugInfo ?
1258                                &quot;\&quot;ar5[i70][idx2[i65][i64]][idx3[i63][i62][i47]][idx3[idx2[i33][i32]][i31][i17]]\&quot;&quot; :
1259                                &quot;\&quot;&lt;local71&gt;[&lt;local70&gt;][&lt;local73&gt;[&lt;local65&gt;][&lt;local64&gt;]][&lt;local72&gt;[&lt;parameter63&gt;][&lt;parameter62&gt;]&quot; +
1260                                   &quot;[&lt;parameter47&gt;]][&lt;local72&gt;[&lt;local73&gt;[&lt;parameter33&gt;][&lt;parameter32&gt;]][&lt;parameter31&gt;][&lt;parameter17&gt;]]\&quot;&quot;) +
1261                              &quot; is null&quot;);
1262             }
1263     }
1264 
1265 
1266     public void testParameters() throws Exception {
1267         A a = new A();
1268         a.to_b = new B();
1269         testParametersTestMethod(a, 0.0, null, null);
1270     }
1271 
1272 
1273     public void testCreation() throws Exception {
1274         // If allocated with new, the message should not be generated.
1275         Asserts.assertNull(new NullPointerException().getMessage());
1276         String msg = new String(&quot;A pointless message&quot;);
1277         Asserts.assertTrue(new NullPointerException(msg).getMessage() == msg);
1278 
1279         // If created via reflection, the message should not be generated.
1280         Exception ex = NullPointerException.class.getDeclaredConstructor().newInstance();
1281         Asserts.assertNull(ex.getMessage());
1282     }
1283 
1284     public void testNative() throws Exception {
1285         // If NPE is thrown in a native method, the message should
1286         // not be generated.
1287         try {
1288             Class.forName(null);
1289             Asserts.fail();
1290         } catch (NullPointerException e) {
1291             Asserts.assertNull(e.getMessage());
1292         }
1293 
1294     }
1295 
1296     // Test we get the same message calling npe.getMessage() twice.
1297     @SuppressWarnings(&quot;null&quot;)
1298     public void testSameMessage() throws Exception {
1299         Object null_o = null;
1300         String expectedMsg =
1301             &quot;Cannot invoke \&quot;Object.hashCode()\&quot; because &quot; +
1302             (hasDebugInfo ? &quot;\&quot;null_o&quot; : &quot;\&quot;&lt;local1&gt;&quot;) + &quot;\&quot; is null&quot;;
1303 
1304         try {
1305             null_o.hashCode();
1306             Asserts.fail();
1307         } catch (NullPointerException e) {
1308             String msg1 = e.getMessage();
1309             checkMessage(e, &quot;null_o.hashCode()&quot;, msg1, expectedMsg);
1310             String msg2 = e.getMessage();
1311             Asserts.assertTrue(msg1.equals(msg2));
1312             // It was decided that getMessage should generate the
1313             // message anew on every call, so this does not hold.
1314             //Asserts.assertTrue(msg1 == msg2);
1315             Asserts.assertFalse(msg1 == msg2);
1316         }
1317     }
1318 
1319     @SuppressWarnings(&quot;null&quot;)
1320     public void testSerialization() throws Exception {
1321         // NPE without message.
1322         Object o1 = new NullPointerException();
1323         ByteArrayOutputStream bos1 = new ByteArrayOutputStream();
1324         ObjectOutputStream oos1 = new ObjectOutputStream(bos1);
1325         oos1.writeObject(o1);
1326         ByteArrayInputStream bis1 = new ByteArrayInputStream(bos1.toByteArray());
1327         ObjectInputStream ois1 = new ObjectInputStream(bis1);
1328         Exception ex1 = (Exception) ois1.readObject();
1329         Asserts.assertNull(ex1.getMessage());
1330 
1331         // NPE with custom message.
1332         String msg2 = &quot;A useless message&quot;;
1333         Object o2 = new NullPointerException(msg2);
1334         ByteArrayOutputStream bos2 = new ByteArrayOutputStream();
1335         ObjectOutputStream oos2 = new ObjectOutputStream(bos2);
1336         oos2.writeObject(o2);
1337         ByteArrayInputStream bis2 = new ByteArrayInputStream(bos2.toByteArray());
1338         ObjectInputStream ois2 = new ObjectInputStream(bis2);
1339         Exception ex2 = (Exception) ois2.readObject();
1340         Asserts.assertEquals(ex2.getMessage(), msg2);
1341 
1342         // NPE with generated message.
1343         Object null_o3 = null;
1344         Object o3 = null;
1345         String msg3 = null;
1346         try {
1347             int hc = null_o3.hashCode();
1348             System.out.println(hc);
1349             Asserts.fail();
1350         } catch (NullPointerException npe3) {
1351             o3 = npe3;
1352             msg3 = npe3.getMessage();
1353             checkMessage(npe3, &quot;int hc = null_o3.hashCode();&quot;, msg3,
1354                          &quot;Cannot invoke \&quot;Object.hashCode()\&quot; because &quot; +
1355                          (hasDebugInfo ? &quot;\&quot;null_o3\&quot;&quot; : &quot;\&quot;&lt;local14&gt;\&quot;&quot;) + &quot; is null&quot;);
1356         }
1357         ByteArrayOutputStream bos3 = new ByteArrayOutputStream();
1358         ObjectOutputStream oos3 = new ObjectOutputStream(bos3);
1359         oos3.writeObject(o3);
1360         ByteArrayInputStream bis3 = new ByteArrayInputStream(bos3.toByteArray());
1361         ObjectInputStream ois3 = new ObjectInputStream(bis3);
1362         Exception ex3 = (Exception) ois3.readObject();
1363         // It was decided that getMessage should not store the
1364         // message in Throwable.detailMessage or implement writeReplace(),
1365         // thus it can not be recovered by serialization.
1366         //Asserts.assertEquals(ex3.getMessage(), msg3);
1367         Asserts.assertEquals(ex3.getMessage(), null);
1368     }
1369 
1370     static int index17 = 17;
1371     int getIndex17() { return 17; };
1372 
1373     @SuppressWarnings({ &quot;unused&quot;, &quot;null&quot; })
1374     public void testComplexMessages() {
1375         try {
1376             staticLongArray[0][0] = 2L;
1377             Asserts.fail();
1378         } catch (NullPointerException e) {
1379             checkMessage(e, &quot;staticLongArray[0][0] = 2L;&quot;, e.getMessage(),
1380                          &quot;Cannot store to long array because &quot; +
1381                          &quot;\&quot;NullPointerExceptionTest.staticLongArray[0]\&quot; is null&quot;);
1382         }
1383 
1384         try {
1385             NullPointerExceptionTest obj = this;
1386             Object val = obj.dag.getArray().clone();
1387             Asserts.assertNull(val);
1388             Asserts.fail();
1389         } catch (NullPointerException e) {
1390             checkMessage(e, &quot;Object val = obj.dag.getArray().clone();&quot;, e.getMessage(),
1391                          &quot;Cannot invoke \&quot;NullPointerExceptionTest$DoubleArrayGen.getArray()\&quot; because &quot; +
1392                          (hasDebugInfo ? &quot;\&quot;obj&quot; : &quot;\&quot;&lt;local1&gt;&quot;) + &quot;.dag\&quot; is null&quot;);
1393         }
1394         try {
1395             int indexes[] = new int[1];
1396             NullPointerExceptionTest[] objs = new NullPointerExceptionTest[] {this};
1397             Object val = objs[indexes[0]].nullInstanceField.returnNull(null, null, 1f);
1398             Asserts.assertNull(val);
1399             Asserts.fail();
1400         } catch (NullPointerException e) {
1401             checkMessage(e, &quot;Object val = objs[indexes[0]].nullInstanceField.returnNull(null, null, 1f);&quot;, e.getMessage(),
1402                          &quot;Cannot invoke \&quot;NullPointerExceptionTest.returnNull(String[][], int[][][], float)\&quot; because &quot; +
1403                          (hasDebugInfo ? &quot;\&quot;objs[indexes&quot; : &quot;\&quot;&lt;local2&gt;[&lt;local1&gt;&quot;) + &quot;[0]].nullInstanceField\&quot; is null&quot;);
1404         }
1405 
1406         try {
1407             int indexes[] = new int[1];
1408             NullPointerExceptionTest[][] objs =
1409                 new NullPointerExceptionTest[][] {new NullPointerExceptionTest[] {this}};
1410             synchronized (objs[indexes[0]][0].nullInstanceField) {
1411                 Asserts.fail();
1412             }
1413         } catch (NullPointerException e) {
1414             checkMessage(e, &quot;synchronized (objs[indexes[0]][0].nullInstanceField) { ... }&quot;, e.getMessage(),
1415                          &quot;Cannot enter synchronized block because &quot; +
1416                          (hasDebugInfo ? &quot;\&quot;objs[indexes&quot; : &quot;\&quot;&lt;local2&gt;[&lt;local1&gt;&quot; ) + &quot;[0]][0].nullInstanceField\&quot; is null&quot;);
1417         }
1418 
1419         try {
1420             // If we can get the value from more than one bci, we cannot know which one
1421             // is null. Make sure we don&#39;t print the wrong value.
1422             String s = null;
1423             @SuppressWarnings(&quot;unused&quot;)
1424             byte[] val = (Math.random() &lt; 0.5 ? s : (new String[1])[0]).getBytes();
1425         } catch (NullPointerException e) {
1426             checkMessage(e, &quot;byte[] val = (Math.random() &lt; 0.5 ? s : (new String[1])[0]).getBytes();&quot;, e.getMessage(),
1427                          &quot;Cannot invoke \&quot;String.getBytes()\&quot;&quot;);
1428         }
1429 
1430         try {
1431             // If we can get the value from more than one bci, we cannot know which one
1432             // is null. Make sure we don&#39;t print the wrong value.  Also make sure if
1433             // we don&#39;t print the failed action we don&#39;t print a string at all.
1434             int[][] a = new int[1][];
1435             int[][] b = new int[2][];
1436             long index = 0;
1437             @SuppressWarnings(&quot;unused&quot;)
1438             int val = (Math.random() &lt; 0.5 ? a[(int)index] : b[(int)index])[13];
1439         } catch (NullPointerException e) {
1440             checkMessage(e, &quot;int val = (Math.random() &lt; 0.5 ? a[(int)index] : b[(int)index])[13]&quot;, e.getMessage(),
1441                          &quot;Cannot load from int array&quot;);
1442         }
1443 
1444         try {
1445             // If we can get the value from more than one bci, we cannot know which one
1446             // is null. Make sure we don&#39;t print the wrong value.  Also make sure if
1447             // we don&#39;t print the failed action we don&#39;t print a string at all.
1448             int[][] a = new int[1][];
1449             int[][] b = new int[2][];
1450             long index = 0;
1451             int val = (Math.random() &lt; 0.5 ? a : b)[(int)index][13];
1452         } catch (NullPointerException e) {
1453             checkMessage(e, &quot;int val = (Math.random() &lt; 0.5 ? a : b)[(int)index][13]&quot;, e.getMessage(),
1454                          &quot;Cannot load from int array because \&quot;&lt;array&gt;[...]\&quot; is null&quot;);
1455         }
1456 
1457         try {
1458             C c1 = new C();
1459             C c2 = new C();
1460             (Math.random() &lt; 0.5 ? c1 : c2).to_d.num = 77;
1461         } catch (NullPointerException e) {
1462             checkMessage(e, &quot;(Math.random() &lt; 0.5 ? c1 : c2).to_d.num = 77;&quot;, e.getMessage(),
1463                          &quot;Cannot assign field \&quot;num\&quot; because \&quot;to_d\&quot; is null&quot;);
1464         }
1465 
1466         // Static variable as array index.
1467         try {
1468             staticLongArray[index17][0] = 2L;
1469         }  catch (NullPointerException e) {
1470             checkMessage(e, &quot;staticLongArray[index17][0] = 2L;&quot;,  e.getMessage(),
1471                          &quot;Cannot store to long array because &quot; +
1472                          &quot;\&quot;NullPointerExceptionTest.staticLongArray[NullPointerExceptionTest.index17]\&quot; is null&quot;);
1473         }
1474 
1475         // Method call as array index.
1476         try {
1477             staticLongArray[getIndex17()][0] = 2L;
1478         }  catch (NullPointerException e) {
1479             checkMessage(e, &quot;staticLongArray[getIndex17()][0] = 2L;&quot;,  e.getMessage(),
1480                          &quot;Cannot store to long array because &quot; +
1481                          &quot;\&quot;NullPointerExceptionTest.staticLongArray[NullPointerExceptionTest.getIndex17()]\&quot; is null&quot;);
1482         }
1483 
1484         // Unboxing.
1485         Integer a = null;
1486         try {
1487             int b = a;
1488         }  catch (NullPointerException e) {
1489             checkMessage(e, &quot;Integer a = null; int b = a;&quot;,  e.getMessage(),
1490                          &quot;Cannot invoke \&quot;java.lang.Integer.intValue()\&quot; because &quot; +
1491                          (hasDebugInfo ? &quot;\&quot;a\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
1492         }
1493 
1494         // Unboxing by hand. Has the same message as above.
1495         try {
1496             int b = a.intValue();
1497         }  catch (NullPointerException e) {
1498             checkMessage(e, &quot;Integer a = null; int b = a.intValue();&quot;,  e.getMessage(),
1499                          &quot;Cannot invoke \&quot;java.lang.Integer.intValue()\&quot; because &quot; +
1500                          (hasDebugInfo ? &quot;\&quot;a\&quot;&quot; : &quot;\&quot;&lt;local1&gt;\&quot;&quot;) + &quot; is null&quot;);
1501         }
1502     }
1503 
1504     // Generates:
1505     // class E implements E0 {
1506     //     public int throwNPE(F f) {
1507     //         return f.i;
1508     //     }
1509     //     public void throwNPE_reuseStackSlot1(String s1) {
1510     //         System.out.println(s1.substring(1));
1511     //         String s1_2 = null; // Reuses slot 1.
1512     //         System.out.println(s1_2.substring(1));
1513     //     }
1514     //     public void throwNPE_reuseStackSlot4(String s1, String s2, String s3, String s4) {
1515     //         System.out.println(s4.substring(1));
1516     //         String s4_2 = null;  // Reuses slot 4.
1517     //         System.out.println(s4_2.substring(1));
1518     //     }
1519     // }
1520     //
1521     // This code was adapted from output of
1522     //   java jdk.internal.org.objectweb.asm.util.ASMifier E0.class
1523     static byte[] generateTestClass() {
1524         ClassWriter cw = new ClassWriter(0);
1525         MethodVisitor mv;
1526 
1527         cw.visit(50, ACC_SUPER, &quot;E&quot;, null, &quot;java/lang/Object&quot;, new String[] { &quot;E0&quot; });
1528 
1529         {
1530             mv = cw.visitMethod(0, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
1531             mv.visitCode();
1532             mv.visitVarInsn(ALOAD, 0);
1533             mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);
1534             mv.visitInsn(RETURN);
1535             mv.visitMaxs(1, 1);
1536             mv.visitEnd();
1537         }
1538 
1539         {
1540             mv = cw.visitMethod(ACC_PUBLIC, &quot;throwNPE&quot;, &quot;(LF;)I&quot;, null, null);
1541             mv.visitCode();
1542             Label label0 = new Label();
1543             mv.visitLabel(label0);
1544             mv.visitLineNumber(118, label0);
1545             mv.visitVarInsn(ALOAD, 1);
1546             mv.visitFieldInsn(GETFIELD, &quot;F&quot;, &quot;i&quot;, &quot;I&quot;);
1547             mv.visitInsn(IRETURN);
1548             Label label1 = new Label();
1549             mv.visitLabel(label1);
1550             mv.visitLocalVariable(&quot;this&quot;, &quot;LE;&quot;, null, label0, label1, 0);
1551             mv.visitLocalVariable(&quot;f&quot;, &quot;LE;&quot;, null, label0, label1, 1);
1552             mv.visitMaxs(1, 2);
1553             mv.visitEnd();
1554         }
1555 
1556         {
1557             mv = cw.visitMethod(ACC_PUBLIC, &quot;throwNPE_reuseStackSlot1&quot;, &quot;(Ljava/lang/String;)V&quot;, null, null);
1558             mv.visitCode();
1559             Label label0 = new Label();
1560             mv.visitLabel(label0);
1561             mv.visitLineNumber(7, label0);
1562             mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
1563             mv.visitVarInsn(ALOAD, 1);
1564             mv.visitInsn(ICONST_1);
1565             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;substring&quot;, &quot;(I)Ljava/lang/String;&quot;, false);
1566             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
1567             Label label1 = new Label();
1568             mv.visitLabel(label1);
1569             mv.visitLineNumber(8, label1);
1570             mv.visitInsn(ACONST_NULL);
1571             mv.visitVarInsn(ASTORE, 1);
1572             Label label2 = new Label();
1573             mv.visitLabel(label2);
1574             mv.visitLineNumber(9, label2);
1575             mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
1576             mv.visitVarInsn(ALOAD, 1);
1577             mv.visitInsn(ICONST_1);
1578             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;substring&quot;, &quot;(I)Ljava/lang/String;&quot;, false);
1579             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
1580             Label label3 = new Label();
1581             mv.visitLabel(label3);
1582             mv.visitLineNumber(10, label3);
1583             mv.visitInsn(RETURN);
1584             mv.visitMaxs(3, 3);
1585             mv.visitEnd();
1586         }
1587 
1588         {
1589             mv = cw.visitMethod(ACC_PUBLIC, &quot;throwNPE_reuseStackSlot4&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V&quot;, null, null);
1590             mv.visitCode();
1591             Label label0 = new Label();
1592             mv.visitLabel(label0);
1593             mv.visitLineNumber(12, label0);
1594             mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
1595             mv.visitVarInsn(ALOAD, 4);
1596             mv.visitInsn(ICONST_1);
1597             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;substring&quot;, &quot;(I)Ljava/lang/String;&quot;, false);
1598             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
1599             Label label1 = new Label();
1600             mv.visitLabel(label1);
1601             mv.visitLineNumber(13, label1);
1602             mv.visitInsn(ACONST_NULL);
1603             mv.visitVarInsn(ASTORE, 4);
1604             Label label2 = new Label();
1605             mv.visitLabel(label2);
1606             mv.visitLineNumber(14, label2);
1607             mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
1608             mv.visitVarInsn(ALOAD, 4);
1609             mv.visitInsn(ICONST_1);
1610             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;substring&quot;, &quot;(I)Ljava/lang/String;&quot;, false);
1611             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
1612             Label label3 = new Label();
1613             mv.visitLabel(label3);
1614             mv.visitLineNumber(15, label3);
1615             mv.visitInsn(RETURN);
1616             mv.visitMaxs(3, 6);
1617             mv.visitEnd();
1618         }
1619 
1620         cw.visitEnd();
1621 
1622         return cw.toByteArray();
1623     }
1624 
1625     // Assign to a parameter.
1626     // Without debug information, this will print &quot;parameter1&quot; if a NPE
1627     // is raised in the first line because null was passed to the method.
1628     // It will print &quot;local1&quot; if a NPE is raised in line three.
1629     public void assign_to_parameter(String s1) {
1630         System.out.println(s1.substring(1));
1631         s1 = null;
1632         System.out.println(s1.substring(2));
1633     }
1634 
1635     // Tests that a class generated on the fly is handled properly.
1636     public void testGeneratedCode() throws Exception {
1637         byte[] classBytes = generateTestClass();
1638         Lookup lookup = lookup();
1639         Class&lt;?&gt; clazz = lookup.defineClass(classBytes);
1640         E0 e = (E0) clazz.getDeclaredConstructor().newInstance();
1641         try {
1642             e.throwNPE(null);
1643         } catch (NullPointerException ex) {
1644             checkMessage(ex, &quot;return f.i;&quot;,
1645                          ex.getMessage(),
1646                          &quot;Cannot read field \&quot;i\&quot; because \&quot;f\&quot; is null&quot;);
1647         }
1648 
1649         // Optimized bytecode can reuse local variable slots for several
1650         // local variables.
1651         // If there is no variable name information, we print &#39;parameteri&#39;
1652         // if a parameter maps to a local slot. Once a local slot has been
1653         // written, we don&#39;t know any more whether it was written as the
1654         // corresponding parameter, or whether another local has been
1655         // mapped to the slot. So we don&#39;t want to print &#39;parameteri&#39; any
1656         // more, but &#39;locali&#39;. Similary for &#39;this&#39;.
1657 
1658         // Expect message saying &quot;parameter0&quot;.
1659         try {
1660             e.throwNPE_reuseStackSlot1(null);
1661         } catch (NullPointerException ex) {
1662             checkMessage(ex, &quot;s1.substring(1)&quot;,
1663                          ex.getMessage(),
1664                          &quot;Cannot invoke \&quot;String.substring(int)\&quot; because \&quot;&lt;parameter1&gt;\&quot; is null&quot;);
1665         }
1666         // Expect message saying &quot;local0&quot;.
1667         try {
1668             e.throwNPE_reuseStackSlot1(&quot;aa&quot;);
1669         } catch (NullPointerException ex) {
1670             checkMessage(ex, &quot;s1_2.substring(1)&quot;,
1671                          ex.getMessage(),
1672                          &quot;Cannot invoke \&quot;String.substring(int)\&quot; because \&quot;&lt;local1&gt;\&quot; is null&quot;);
1673         }
1674         // Expect message saying &quot;parameter4&quot;.
1675         try {
1676             e.throwNPE_reuseStackSlot4(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, null);
1677         } catch (NullPointerException ex) {
1678             checkMessage(ex, &quot;s4.substring(1)&quot;,
1679                          ex.getMessage(),
1680                          &quot;Cannot invoke \&quot;String.substring(int)\&quot; because \&quot;&lt;parameter4&gt;\&quot; is null&quot;);
1681         }
1682         // Expect message saying &quot;local4&quot;.
1683         try {
1684             e.throwNPE_reuseStackSlot4(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);
1685         } catch (NullPointerException ex) {
1686             checkMessage(ex, &quot;s4_2.substring(1)&quot;,
1687                          ex.getMessage(),
1688                          &quot;Cannot invoke \&quot;String.substring(int)\&quot; because \&quot;&lt;local4&gt;\&quot; is null&quot;);
1689         }
1690 
1691         // Unfortunately, with the fix for optimized code as described above
1692         // we don&#39;t write &#39;parameteri&#39; any more after the parameter variable
1693         // has been assigned.
1694 
1695         if (!hasDebugInfo) {
1696             // Expect message saying &quot;parameter1&quot;.
1697             try {
1698                 assign_to_parameter(null);
1699             } catch (NullPointerException ex) {
1700                 checkMessage(ex, &quot;s1.substring(1)&quot;,
1701                              ex.getMessage(),
1702                              &quot;Cannot invoke \&quot;String.substring(int)\&quot; because \&quot;&lt;parameter1&gt;\&quot; is null&quot;);
1703             }
1704             // The message says &quot;local1&quot; although &quot;parameter1&quot; would be correct.
1705             try {
1706                 assign_to_parameter(&quot;aaa&quot;);
1707             } catch (NullPointerException ex) {
1708                 checkMessage(ex, &quot;s1.substring(2)&quot;,
1709                              ex.getMessage(),
1710                              &quot;Cannot invoke \&quot;String.substring(int)\&quot; because \&quot;&lt;local1&gt;\&quot; is null&quot;);
1711             }
1712         }
1713     }
1714 }
1715 
1716 // Helper interface for test cases needed for generateTestClass().
1717 interface E0 {
1718     public int  throwNPE(F f);
1719     public void throwNPE_reuseStackSlot1(String s1);
1720     public void throwNPE_reuseStackSlot4(String s1, String s2, String s3, String s4);
1721 }
1722 
1723 // Helper class for test cases needed for generateTestClass().
1724 class F {
1725     int i;
1726 }
1727 
1728 // For invokespecial test cases.
1729 class G {
1730     public String m2(String x) {
1731         return null;
1732     }
1733 
1734     // This generates the following class:
1735     //
1736     // class Sub2G extends G {
1737     //   public String m2(String x) {
1738     //       super = null;  // Possible in raw bytecode.
1739     //       return super.m2(x).substring(2);  // Uses invokespecial.
1740     //   }
1741     // }
1742     //
1743     // This code was adapted from output of
1744     //   java jdk.internal.org.objectweb.asm.util.ASMifier Sub2G.class
1745     static byte[] generateSub2GTestClass() {
1746         ClassWriter cw = new ClassWriter(0);
1747         MethodVisitor mv;
1748 
1749         cw.visit(50, ACC_SUPER, &quot;Sub2G&quot;, null, &quot;G&quot;, null);
1750 
1751         {
1752             mv = cw.visitMethod(0, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
1753             mv.visitCode();
1754             mv.visitVarInsn(ALOAD, 0);
1755             mv.visitMethodInsn(INVOKESPECIAL, &quot;G&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);
1756             mv.visitInsn(RETURN);
1757             mv.visitMaxs(1, 1);
1758             mv.visitEnd();
1759         }
1760         {
1761             mv = cw.visitMethod(ACC_PUBLIC, &quot;m2&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;, null, null);
1762             mv.visitCode();
1763             mv.visitInsn(ACONST_NULL);   // Will cause NPE.
1764             mv.visitVarInsn(ALOAD, 1);
1765             mv.visitMethodInsn(INVOKESPECIAL, &quot;G&quot;, &quot;m2&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;, false);
1766             mv.visitInsn(ICONST_2);
1767             mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/String&quot;, &quot;substring&quot;, &quot;(I)Ljava/lang/String;&quot;, false);
1768             mv.visitInsn(ARETURN);
1769             mv.visitMaxs(2, 2);
1770             mv.visitEnd();
1771         }
1772 
1773         cw.visitEnd();
1774 
1775         return cw.toByteArray();
1776     }
1777 }
1778 class SubG extends G {
1779     public String m2(String x) {
1780         return super.m2(x).substring(2);
1781     }
1782 }
    </pre>
  </body>
</html>
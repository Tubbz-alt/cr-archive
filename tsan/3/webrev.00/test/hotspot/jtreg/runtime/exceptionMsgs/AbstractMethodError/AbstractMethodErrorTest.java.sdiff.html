<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/runtime/exceptionMsgs/AbstractMethodError/AbstractMethodErrorTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../clone/invokevirtual/NoLocalCloneAbstr.jasm.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../ArrayIndexOutOfBoundsException/ArrayIndexOutOfBoundsExceptionTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/runtime/exceptionMsgs/AbstractMethodError/AbstractMethodErrorTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 82         test_ame6_compiled_itable_stub();
 83         enableChecks = true;
 84 
 85         // Compile
 86         if (!compile(AbstractMethodErrorTest.class, &quot;test_ame5_compiled_vtable_stub&quot;) ||
 87             !compile(AbstractMethodErrorTest.class, &quot;test_ame6_compiled_itable_stub&quot;) ||
 88             !compile(AME5_C.class, &quot;mc&quot;) ||
 89             !compile(AME5_D.class, &quot;mc&quot;) ||
 90             !compile(AME5_E.class, &quot;mc&quot;) ||
 91             !compile(AME6_C.class, &quot;mc&quot;) ||
 92             !compile(AME6_D.class, &quot;mc&quot;) ||
 93             !compile(AME6_E.class, &quot;mc&quot;)) {
 94             return false;
 95         }
 96 
 97         System.out.println(&quot;warmup done.&quot;);
 98         return true;
 99     }
100 
101     private static String expectedErrorMessageAME1_1 =
<span class="line-modified">102         &quot;Missing implementation of resolved method abstract &quot; +</span>
<span class="line-modified">103         &quot;anAbstractMethod()Ljava/lang/String; of abstract class AME1_B.&quot;;</span>
104     private static String expectedErrorMessageAME1_2 =
105         &quot;Receiver class AME1_E does not define or inherit an implementation of the &quot; +
<span class="line-modified">106         &quot;resolved method abstract aFunctionOfMyInterface()Ljava/lang/String; of &quot; +</span>
107         &quot;interface AME1_C.&quot;;
108 
109     public static void test_ame1() {
110         AME1_B objectAbstract = new AME1_D();
111         AME1_C objectInterface = new AME1_D();
112         objectInterface.secondFunctionOfMyInterface();
113         objectAbstract.anAbstractMethod();
114         objectInterface.aFunctionOfMyInterface();
115 
116         try {
117             objectAbstract = new AME1_E();
118             // AbstractMethodError gets thrown in the interpreter at:
119             // InterpreterGenerator::generate_abstract_entry
120             objectAbstract.anAbstractMethod();
121             throw new RuntimeException(&quot;Expected AbstractRuntimeError was not thrown.&quot;);
122         } catch (AbstractMethodError e) {
123             String errorMsg = e.getMessage();
124             if (errorMsg == null) {
125                 throw new RuntimeException(&quot;Caught AbstractMethodError with empty message.&quot;);
126             } else if (!errorMsg.equals(expectedErrorMessageAME1_1)) {
</pre>
<hr />
<pre>
141             objectInterface.aFunctionOfMyInterface();
142             throw new RuntimeException(&quot;Expected AbstractRuntimeError was not thrown.&quot;);
143         } catch (AbstractMethodError e) {
144             String errorMsg = e.getMessage();
145             if (errorMsg == null) {
146                 throw new RuntimeException(&quot;Caught AbstractMethodError with empty message.&quot;);
147             } else if (!errorMsg.equals(expectedErrorMessageAME1_2)) {
148                 // Thrown via InterpreterRuntime::throw_AbstractMethodErrorVerbose().
149                 System.out.println(&quot;Expected: &quot; + expectedErrorMessageAME1_2 + &quot;\n&quot; +
150                                    &quot;but got:  &quot; + errorMsg);
151                 throw new RuntimeException(&quot;Wrong error message of AbstractMethodError.&quot;);
152             } else {
153                 System.out.println(&quot;Passed with message: &quot; + errorMsg);
154             }
155         } catch (Throwable e) {
156             throw new RuntimeException(&quot;Caught unexpected exception: &quot; + e);
157         }
158     }
159 
160     private static String expectedErrorMessageAME2_Interpreted =
<span class="line-modified">161         &quot;Missing implementation of resolved method abstract &quot; +</span>
<span class="line-modified">162         &quot;aFunctionOfMyInterface()V of interface AME2_A.&quot;;</span>
163     private static String expectedErrorMessageAME2_Compiled =
164         &quot;Receiver class AME2_C does not define or inherit an implementation of the resolved method &quot; +
<span class="line-modified">165         &quot;abstract aFunctionOfMyInterface()V of interface AME2_A.&quot;;</span>
166 
167     public AbstractMethodErrorTest() throws InstantiationException, IllegalAccessException {
168         try {
169             AME2_B myAbstract = new ImplementsAllFunctions();
170             myAbstract.fun2();
171             myAbstract.aFunctionOfMyInterface();
172 
173             // AME2_C does not implement the method
174             // aFunctionOfMyInterface(). Expected runtime behavior is
175             // throwing an AbstractMethodError.
176             // The error will be thrown via throw_AbstractMethodErrorWithMethod()
177             // if the template interpreter calls an abstract method by
178             // entering the abstract method entry.
179             myAbstract = new AME2_C();
180             myAbstract.fun2();
181             myAbstract.aFunctionOfMyInterface();
182         } catch (SecurityException e) {
183             e.printStackTrace();
184         }
185     }
</pre>
<hr />
<pre>
211                     // sparc misses the test case for LinkResolver::runtime_resolve_virtual_method().
212                     seenCompiled = true;
213                 } else {
214                     System.out.println(&quot;Expected: &quot; + expectedErrorMessageAME2_Interpreted + &quot;\n&quot; +
215                                        &quot;or:       &quot; + expectedErrorMessageAME2_Compiled + &quot;\n&quot; +
216                                        &quot;but got:  &quot; + errorMsg);
217                     throw new RuntimeException(&quot;Wrong error message of AbstractMethodError.&quot;);
218                 }
219             }
220         }
221         if (!(seenInterpreted &amp;&amp; seenCompiled)) {
222             if (seenInterpreted) { System.out.println(&quot;Saw interpreted message.&quot;); }
223             if (seenCompiled)    { System.out.println(&quot;Saw compiled message.&quot;); }
224             throw new RuntimeException(&quot;Test did not produce wrong error messages for AbstractMethodError, &quot; +
225                                        &quot;but it did not test both cases (interpreted and compiled).&quot;);
226         }
227     }
228 
229     private static String expectedErrorMessageAME3_1 =
230         &quot;Receiver class AME3_C does not define or inherit an implementation of the resolved method &quot; +
<span class="line-modified">231         &quot;ma()V of class AME3_A. Selected method is abstract AME3_B.ma()V.&quot;;</span>
232 
233     // Testing abstract class that extends a class that has an implementation.
234     // Loop so that method gets eventually compiled/osred.
235     public static void test_ame3_1() throws Exception {
236         AME3_A c = new AME3_C();
237 
238         try {
239             // Supposed to throw AME with verbose message.
240             c.ma();
241 
242             throw new RuntimeException(&quot;Expected AbstractMethodError was not thrown.&quot;);
243         } catch (AbstractMethodError e) {
244             String errorMsg = e.getMessage();
245 
246             // Check the message obtained.
247             if (errorMsg == null) {
248                 throw new RuntimeException(&quot;Caught AbstractMethodError with empty message.&quot;);
249             } else if (errorMsg.equals(expectedErrorMessageAME3_1)) {
250                 // Expected test case thrown via LinkResolver::runtime_resolve_virtual_method().
251                 System.out.println(&quot;Passed with message: &quot; + errorMsg);
252             } else {
253                 System.out.println(&quot;Expected: &quot; + expectedErrorMessageAME3_1 + &quot;\n&quot; +
254                                    &quot;but got:  &quot; + errorMsg);
255                 throw new RuntimeException(&quot;Wrong error message of AbstractMethodError.&quot;);
256             }
257         }
258     }
259 
260     private static String expectedErrorMessageAME3_2 =
261         &quot;Receiver class AME3_C does not define or inherit an implementation of &quot; +
<span class="line-modified">262         &quot;the resolved method abstract ma()V of abstract class AME3_B.&quot;;</span>
263 
264     // Testing abstract class that extends a class that has an implementation.
265     // Loop so that method gets eventually compiled/osred.
266     public static void test_ame3_2() throws Exception {
267         AME3_C c = new AME3_C();
268 
269         try {
270             // Supposed to throw AME with verbose message.
271             c.ma();
272 
273             throw new RuntimeException(&quot;Expected AbstractMethodError was not thrown.&quot;);
274         } catch (AbstractMethodError e) {
275             String errorMsg = e.getMessage();
276 
277             // Check the message obtained.
278             if (errorMsg == null) {
279                 throw new RuntimeException(&quot;Caught AbstractMethodError with empty message.&quot;);
280             } else if (errorMsg.equals(expectedErrorMessageAME3_2)) {
281                 // Expected test case thrown via LinkResolver::runtime_resolve_virtual_method().
282                 System.out.println(&quot;Passed with message: &quot; + errorMsg);
283             } else {
284                 System.out.println(&quot;Expected: &quot; + expectedErrorMessageAME3_2 + &quot;\n&quot; +
285                                    &quot;but got:  &quot; + errorMsg);
286                 throw new RuntimeException(&quot;Wrong error message of AbstractMethodError.&quot;);
287             }
288         }
289     }
290 
291     private static String expectedErrorMessageAME4 =
<span class="line-modified">292         &quot;Missing implementation of resolved method abstract ma()V of &quot; +</span>
293         &quot;abstract class AME4_B.&quot;;
294 
295     // Testing abstract class that extends a class that has an implementation.
296     public static void test_ame4() throws Exception {
297         AME4_C c = new AME4_C();
298         AME4_D d = new AME4_D();
299         AME4_E e = new AME4_E();  // Errorneous.
300 
301         AME4_A a;
302         try {
303             // Test: calls errorneous e.ma() in the last iteration.
304             final int iterations = 10;
305             for (int i = 0; i &lt; iterations; i++) {
306                 a = e;
307                 if (i % 2 == 0 &amp;&amp; i &lt; iterations - 1) {
308                     a = c;
309                 }
310                 if (i % 2 == 1 &amp;&amp; i &lt; iterations - 1) {
311                     a = d;
312                 }
</pre>
<hr />
<pre>
319             throw new RuntimeException(&quot;Expected AbstractMethodError was not thrown.&quot;);
320         } catch (AbstractMethodError exc) {
321             System.out.println();
322             String errorMsg = exc.getMessage();
323 
324                 // Check the message obtained.
325             if (enableChecks &amp;&amp; errorMsg == null) {
326                 throw new RuntimeException(&quot;Caught AbstractMethodError with empty message.&quot;);
327             } else if (errorMsg.equals(expectedErrorMessageAME4)) {
328                 // Expected test case.
329                 System.out.println(&quot;Passed with message: &quot; + errorMsg);
330             } else if (enableChecks) {
331                 System.out.println(&quot;Expected: &quot; + expectedErrorMessageAME4 + &quot;\n&quot; +
332                                    &quot;but got:  &quot; + errorMsg);
333                 throw new RuntimeException(&quot;Wrong error message of AbstractMethodError.&quot;);
334             }
335         }
336     }
337 
338     private static String expectedErrorMessageAME5_VtableStub =
<span class="line-modified">339         &quot;Receiver class AME5_B does not define or inherit an implementation of the resolved method abstract mc()V &quot; +</span>
340         &quot;of abstract class AME5_A.&quot;;
341 
342     // AbstractMethodErrors detected in vtable stubs.
343     // Note: How can we verify that we really stepped through the vtable stub?
344     // - Bimorphic inlining should not happen since we have no profiling data when
345     //   we compile the method
346     // - As a result, an inline cache call should be generated
347     // - This inline cache call is patched into a real vtable call at the first
348     //   re-resolve, which happens constantly during the first 10 iterations of the loop.
349     // =&gt; we should be fine! :-)
350     public static void test_ame5_compiled_vtable_stub() {
351         // Allocated the objects we need and call a valid method.
352         boolean caught_ame = false;
353         AME5_B b = new AME5_B();
354         AME5_C c = new AME5_C();
355         AME5_D d = new AME5_D();
356         AME5_E e = new AME5_E();
357         b.ma();
358         c.ma();
359         d.ma();
</pre>
<hr />
<pre>
392                                    &quot;but got:  &quot; + errorMsg);
393                 System.out.println(exc);
394                 throw new RuntimeException(&quot;Wrong error message of AbstractMethodError.&quot;);
395             }
396             if (enableChecks) {
397                 System.out.println(&quot;Passed with message: &quot; + errorMsg);
398             }
399         } catch (Throwable exc) {
400 
401         throw exc;
402         }
403 
404         // Check that we got the exception at some point.
405         if (enableChecks &amp;&amp; !caught_ame) {
406             throw new RuntimeException(&quot;Expected AbstractMethodError was not thrown.&quot;);
407         }
408     }
409 
410     private static String expectedErrorMessageAME6_ItableStub =
411         &quot;Receiver class AME6_B does not define or inherit an implementation of the resolved&quot; +
<span class="line-modified">412         &quot; method abstract mc()V of interface AME6_A.&quot;;</span>
413 
414     // -------------------------------------------------------------------------
415     // AbstractMethodErrors detected in itable stubs.
416     // Note: How can we verify that we really stepped through the itable stub?
417     // - Bimorphic inlining should not happen since we have no profiling data when
418     //   we compile the method
419     // - As a result, an inline cache call should be generated
420     // - This inline cache call is patched into a real vtable call at the first
421     //   re-resolve, which happens constantly during the first 10 iterations of the loop.
422     // =&gt; we should be fine! :-)
423     public static void test_ame6_compiled_itable_stub() {
424         // Allocated the objects we need and call a valid method.
425         boolean caught_ame = false;
426         AME6_B b = new AME6_B();
427         AME6_C c = new AME6_C();
428         AME6_D d = new AME6_D();
429         AME6_E e = new AME6_E();
430         b.ma();
431         c.ma();
432         d.ma();
</pre>
</td>
<td>
<hr />
<pre>
 82         test_ame6_compiled_itable_stub();
 83         enableChecks = true;
 84 
 85         // Compile
 86         if (!compile(AbstractMethodErrorTest.class, &quot;test_ame5_compiled_vtable_stub&quot;) ||
 87             !compile(AbstractMethodErrorTest.class, &quot;test_ame6_compiled_itable_stub&quot;) ||
 88             !compile(AME5_C.class, &quot;mc&quot;) ||
 89             !compile(AME5_D.class, &quot;mc&quot;) ||
 90             !compile(AME5_E.class, &quot;mc&quot;) ||
 91             !compile(AME6_C.class, &quot;mc&quot;) ||
 92             !compile(AME6_D.class, &quot;mc&quot;) ||
 93             !compile(AME6_E.class, &quot;mc&quot;)) {
 94             return false;
 95         }
 96 
 97         System.out.println(&quot;warmup done.&quot;);
 98         return true;
 99     }
100 
101     private static String expectedErrorMessageAME1_1 =
<span class="line-modified">102         &quot;Missing implementation of resolved method &#39;abstract &quot; +</span>
<span class="line-modified">103         &quot;java.lang.String anAbstractMethod()&#39; of abstract class AME1_B.&quot;;</span>
104     private static String expectedErrorMessageAME1_2 =
105         &quot;Receiver class AME1_E does not define or inherit an implementation of the &quot; +
<span class="line-modified">106         &quot;resolved method &#39;abstract java.lang.String aFunctionOfMyInterface()&#39; of &quot; +</span>
107         &quot;interface AME1_C.&quot;;
108 
109     public static void test_ame1() {
110         AME1_B objectAbstract = new AME1_D();
111         AME1_C objectInterface = new AME1_D();
112         objectInterface.secondFunctionOfMyInterface();
113         objectAbstract.anAbstractMethod();
114         objectInterface.aFunctionOfMyInterface();
115 
116         try {
117             objectAbstract = new AME1_E();
118             // AbstractMethodError gets thrown in the interpreter at:
119             // InterpreterGenerator::generate_abstract_entry
120             objectAbstract.anAbstractMethod();
121             throw new RuntimeException(&quot;Expected AbstractRuntimeError was not thrown.&quot;);
122         } catch (AbstractMethodError e) {
123             String errorMsg = e.getMessage();
124             if (errorMsg == null) {
125                 throw new RuntimeException(&quot;Caught AbstractMethodError with empty message.&quot;);
126             } else if (!errorMsg.equals(expectedErrorMessageAME1_1)) {
</pre>
<hr />
<pre>
141             objectInterface.aFunctionOfMyInterface();
142             throw new RuntimeException(&quot;Expected AbstractRuntimeError was not thrown.&quot;);
143         } catch (AbstractMethodError e) {
144             String errorMsg = e.getMessage();
145             if (errorMsg == null) {
146                 throw new RuntimeException(&quot;Caught AbstractMethodError with empty message.&quot;);
147             } else if (!errorMsg.equals(expectedErrorMessageAME1_2)) {
148                 // Thrown via InterpreterRuntime::throw_AbstractMethodErrorVerbose().
149                 System.out.println(&quot;Expected: &quot; + expectedErrorMessageAME1_2 + &quot;\n&quot; +
150                                    &quot;but got:  &quot; + errorMsg);
151                 throw new RuntimeException(&quot;Wrong error message of AbstractMethodError.&quot;);
152             } else {
153                 System.out.println(&quot;Passed with message: &quot; + errorMsg);
154             }
155         } catch (Throwable e) {
156             throw new RuntimeException(&quot;Caught unexpected exception: &quot; + e);
157         }
158     }
159 
160     private static String expectedErrorMessageAME2_Interpreted =
<span class="line-modified">161         &quot;Missing implementation of resolved method &#39;abstract &quot; +</span>
<span class="line-modified">162         &quot;void aFunctionOfMyInterface()&#39; of interface AME2_A.&quot;;</span>
163     private static String expectedErrorMessageAME2_Compiled =
164         &quot;Receiver class AME2_C does not define or inherit an implementation of the resolved method &quot; +
<span class="line-modified">165         &quot;&#39;abstract void aFunctionOfMyInterface()&#39; of interface AME2_A.&quot;;</span>
166 
167     public AbstractMethodErrorTest() throws InstantiationException, IllegalAccessException {
168         try {
169             AME2_B myAbstract = new ImplementsAllFunctions();
170             myAbstract.fun2();
171             myAbstract.aFunctionOfMyInterface();
172 
173             // AME2_C does not implement the method
174             // aFunctionOfMyInterface(). Expected runtime behavior is
175             // throwing an AbstractMethodError.
176             // The error will be thrown via throw_AbstractMethodErrorWithMethod()
177             // if the template interpreter calls an abstract method by
178             // entering the abstract method entry.
179             myAbstract = new AME2_C();
180             myAbstract.fun2();
181             myAbstract.aFunctionOfMyInterface();
182         } catch (SecurityException e) {
183             e.printStackTrace();
184         }
185     }
</pre>
<hr />
<pre>
211                     // sparc misses the test case for LinkResolver::runtime_resolve_virtual_method().
212                     seenCompiled = true;
213                 } else {
214                     System.out.println(&quot;Expected: &quot; + expectedErrorMessageAME2_Interpreted + &quot;\n&quot; +
215                                        &quot;or:       &quot; + expectedErrorMessageAME2_Compiled + &quot;\n&quot; +
216                                        &quot;but got:  &quot; + errorMsg);
217                     throw new RuntimeException(&quot;Wrong error message of AbstractMethodError.&quot;);
218                 }
219             }
220         }
221         if (!(seenInterpreted &amp;&amp; seenCompiled)) {
222             if (seenInterpreted) { System.out.println(&quot;Saw interpreted message.&quot;); }
223             if (seenCompiled)    { System.out.println(&quot;Saw compiled message.&quot;); }
224             throw new RuntimeException(&quot;Test did not produce wrong error messages for AbstractMethodError, &quot; +
225                                        &quot;but it did not test both cases (interpreted and compiled).&quot;);
226         }
227     }
228 
229     private static String expectedErrorMessageAME3_1 =
230         &quot;Receiver class AME3_C does not define or inherit an implementation of the resolved method &quot; +
<span class="line-modified">231         &quot;&#39;void ma()&#39; of class AME3_A. Selected method is &#39;abstract void AME3_B.ma()&#39;.&quot;;</span>
232 
233     // Testing abstract class that extends a class that has an implementation.
234     // Loop so that method gets eventually compiled/osred.
235     public static void test_ame3_1() throws Exception {
236         AME3_A c = new AME3_C();
237 
238         try {
239             // Supposed to throw AME with verbose message.
240             c.ma();
241 
242             throw new RuntimeException(&quot;Expected AbstractMethodError was not thrown.&quot;);
243         } catch (AbstractMethodError e) {
244             String errorMsg = e.getMessage();
245 
246             // Check the message obtained.
247             if (errorMsg == null) {
248                 throw new RuntimeException(&quot;Caught AbstractMethodError with empty message.&quot;);
249             } else if (errorMsg.equals(expectedErrorMessageAME3_1)) {
250                 // Expected test case thrown via LinkResolver::runtime_resolve_virtual_method().
251                 System.out.println(&quot;Passed with message: &quot; + errorMsg);
252             } else {
253                 System.out.println(&quot;Expected: &quot; + expectedErrorMessageAME3_1 + &quot;\n&quot; +
254                                    &quot;but got:  &quot; + errorMsg);
255                 throw new RuntimeException(&quot;Wrong error message of AbstractMethodError.&quot;);
256             }
257         }
258     }
259 
260     private static String expectedErrorMessageAME3_2 =
261         &quot;Receiver class AME3_C does not define or inherit an implementation of &quot; +
<span class="line-modified">262         &quot;the resolved method &#39;abstract void ma()&#39; of abstract class AME3_B.&quot;;</span>
263 
264     // Testing abstract class that extends a class that has an implementation.
265     // Loop so that method gets eventually compiled/osred.
266     public static void test_ame3_2() throws Exception {
267         AME3_C c = new AME3_C();
268 
269         try {
270             // Supposed to throw AME with verbose message.
271             c.ma();
272 
273             throw new RuntimeException(&quot;Expected AbstractMethodError was not thrown.&quot;);
274         } catch (AbstractMethodError e) {
275             String errorMsg = e.getMessage();
276 
277             // Check the message obtained.
278             if (errorMsg == null) {
279                 throw new RuntimeException(&quot;Caught AbstractMethodError with empty message.&quot;);
280             } else if (errorMsg.equals(expectedErrorMessageAME3_2)) {
281                 // Expected test case thrown via LinkResolver::runtime_resolve_virtual_method().
282                 System.out.println(&quot;Passed with message: &quot; + errorMsg);
283             } else {
284                 System.out.println(&quot;Expected: &quot; + expectedErrorMessageAME3_2 + &quot;\n&quot; +
285                                    &quot;but got:  &quot; + errorMsg);
286                 throw new RuntimeException(&quot;Wrong error message of AbstractMethodError.&quot;);
287             }
288         }
289     }
290 
291     private static String expectedErrorMessageAME4 =
<span class="line-modified">292         &quot;Missing implementation of resolved method &#39;abstract void ma()&#39; of &quot; +</span>
293         &quot;abstract class AME4_B.&quot;;
294 
295     // Testing abstract class that extends a class that has an implementation.
296     public static void test_ame4() throws Exception {
297         AME4_C c = new AME4_C();
298         AME4_D d = new AME4_D();
299         AME4_E e = new AME4_E();  // Errorneous.
300 
301         AME4_A a;
302         try {
303             // Test: calls errorneous e.ma() in the last iteration.
304             final int iterations = 10;
305             for (int i = 0; i &lt; iterations; i++) {
306                 a = e;
307                 if (i % 2 == 0 &amp;&amp; i &lt; iterations - 1) {
308                     a = c;
309                 }
310                 if (i % 2 == 1 &amp;&amp; i &lt; iterations - 1) {
311                     a = d;
312                 }
</pre>
<hr />
<pre>
319             throw new RuntimeException(&quot;Expected AbstractMethodError was not thrown.&quot;);
320         } catch (AbstractMethodError exc) {
321             System.out.println();
322             String errorMsg = exc.getMessage();
323 
324                 // Check the message obtained.
325             if (enableChecks &amp;&amp; errorMsg == null) {
326                 throw new RuntimeException(&quot;Caught AbstractMethodError with empty message.&quot;);
327             } else if (errorMsg.equals(expectedErrorMessageAME4)) {
328                 // Expected test case.
329                 System.out.println(&quot;Passed with message: &quot; + errorMsg);
330             } else if (enableChecks) {
331                 System.out.println(&quot;Expected: &quot; + expectedErrorMessageAME4 + &quot;\n&quot; +
332                                    &quot;but got:  &quot; + errorMsg);
333                 throw new RuntimeException(&quot;Wrong error message of AbstractMethodError.&quot;);
334             }
335         }
336     }
337 
338     private static String expectedErrorMessageAME5_VtableStub =
<span class="line-modified">339         &quot;Receiver class AME5_B does not define or inherit an implementation of the resolved method &#39;abstract void mc()&#39; &quot; +</span>
340         &quot;of abstract class AME5_A.&quot;;
341 
342     // AbstractMethodErrors detected in vtable stubs.
343     // Note: How can we verify that we really stepped through the vtable stub?
344     // - Bimorphic inlining should not happen since we have no profiling data when
345     //   we compile the method
346     // - As a result, an inline cache call should be generated
347     // - This inline cache call is patched into a real vtable call at the first
348     //   re-resolve, which happens constantly during the first 10 iterations of the loop.
349     // =&gt; we should be fine! :-)
350     public static void test_ame5_compiled_vtable_stub() {
351         // Allocated the objects we need and call a valid method.
352         boolean caught_ame = false;
353         AME5_B b = new AME5_B();
354         AME5_C c = new AME5_C();
355         AME5_D d = new AME5_D();
356         AME5_E e = new AME5_E();
357         b.ma();
358         c.ma();
359         d.ma();
</pre>
<hr />
<pre>
392                                    &quot;but got:  &quot; + errorMsg);
393                 System.out.println(exc);
394                 throw new RuntimeException(&quot;Wrong error message of AbstractMethodError.&quot;);
395             }
396             if (enableChecks) {
397                 System.out.println(&quot;Passed with message: &quot; + errorMsg);
398             }
399         } catch (Throwable exc) {
400 
401         throw exc;
402         }
403 
404         // Check that we got the exception at some point.
405         if (enableChecks &amp;&amp; !caught_ame) {
406             throw new RuntimeException(&quot;Expected AbstractMethodError was not thrown.&quot;);
407         }
408     }
409 
410     private static String expectedErrorMessageAME6_ItableStub =
411         &quot;Receiver class AME6_B does not define or inherit an implementation of the resolved&quot; +
<span class="line-modified">412         &quot; method &#39;abstract void mc()&#39; of interface AME6_A.&quot;;</span>
413 
414     // -------------------------------------------------------------------------
415     // AbstractMethodErrors detected in itable stubs.
416     // Note: How can we verify that we really stepped through the itable stub?
417     // - Bimorphic inlining should not happen since we have no profiling data when
418     //   we compile the method
419     // - As a result, an inline cache call should be generated
420     // - This inline cache call is patched into a real vtable call at the first
421     //   re-resolve, which happens constantly during the first 10 iterations of the loop.
422     // =&gt; we should be fine! :-)
423     public static void test_ame6_compiled_itable_stub() {
424         // Allocated the objects we need and call a valid method.
425         boolean caught_ame = false;
426         AME6_B b = new AME6_B();
427         AME6_C c = new AME6_C();
428         AME6_D d = new AME6_D();
429         AME6_E e = new AME6_E();
430         b.ma();
431         c.ma();
432         d.ma();
</pre>
</td>
</tr>
</table>
<center><a href="../../clone/invokevirtual/NoLocalCloneAbstr.jasm.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../ArrayIndexOutOfBoundsException/ArrayIndexOutOfBoundsExceptionTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
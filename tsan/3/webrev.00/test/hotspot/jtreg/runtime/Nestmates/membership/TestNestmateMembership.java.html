<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/Nestmates/membership/TestNestmateMembership.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * @test
  26  * @bug 8046171
  27  * @summary Test the various rules for nest members and nest-hosts by
  28  * triggering nestmate access checks on all possible paths
  29  * @compile TestNestmateMembership.java
  30  *          PackagedNestHost.java
  31  *          PackagedNestHost2.java
  32  *          InvalidNestHost.java
  33  *
  34  * @compile TargetNoHost.jcod
  35  *          CallerNoHost.jcod
  36  *          TargetSelfHost.jcod
  37  *          CallerSelfHost.jcod
  38  *          TargetMissingHost.jcod
  39  *          CallerMissingHost.jcod
  40  *          TargetNotInstanceHost.jcod
  41  *          CallerNotInstanceHost.jcod
  42  *          TargetNotOurHost.jcod
  43  *          CallerNotOurHost.jcod
  44  *          PackagedNestHost.jcod
  45  *          PackagedNestHost2Member.jcod
  46  *          PackagedNestHostMember.jcod
  47  *
  48  * @run main/othervm TestNestmateMembership method
  49  * @run main/othervm TestNestmateMembership constructor
  50  * @run main/othervm TestNestmateMembership getField
  51  * @run main/othervm TestNestmateMembership putField
  52  * @run main/othervm -Xcomp TestNestmateMembership getField
  53  */
  54 
  55 // We test all the &quot;illegal&quot; relationships between a nest member and its nest-host
  56 // except for the case where the name of the nest-member matches the name listed
  57 // in the nest-host, but resolves to a different class. There doesn&#39;t seem to
  58 // be a way to construct that scenario.
  59 // For each nested class below there is a corresponding .jcod file which breaks one
  60 // of the rules regarding nest membership. For the package related tests we have
  61 // additional PackageNestHost*.java sources.[1]
  62 //
  63 // Note that all the .java files must be compiled in the same step, while all
  64 // .jcod files must be compiled in a later step.
  65 
  66 // We test all the different nestmate access check paths: method invocation, constructor
  67 // invocations, field get and field put. The test is invoked four times with each using
  68 // a different test mode. Plus an extra Xcomp run for field access to hit ciField path.
  69 //
  70 // As access checking requires resolution and validation of the nest-host of
  71 // both the caller class and the target class, we must check that all
  72 // combinations of good/bad caller/target are checked for each of the
  73 // possible errors:
  74 // - no nest-host attribute
  75 // - nest-host refers to self
  76 // - nest-host class can not be found
  77 // - nest-host class is not an instance class (but is in same package)
  78 // - class is not a member of nest-host&#39;s nest (but is in same package)
  79 // - class and nest-host are in different packages
  80 //
  81 // To provide coverage for reflection and MethodHandle paths through
  82 // JVM_AreNestmates, we add reflection/MH accesses to a subset of the tests.
  83 // We only need to test one case (for Caller.xxx) as all cases use the same path; further
  84 // we don&#39;t need to test all failure cases, as all exceptions are equivalent in that regard,
  85 // but for good measure we test the four basic error situations (eliding the different
  86 // package test for simplicity).
  87 //
  88 // [1] In earlier versions the package-test was the final check done in nest membership
  89 //     validation, so we needed actual test classes in different packages that claimed
  90 //     membership. The final spec requires the package test to be done first, so it can
  91 //     be trivially tested by using Object as the nest-host. But we leave the explicit
  92 //     package tests as they are, and adjust the other tests so that a &quot;bad host&quot; is
  93 //     always in the same package.
  94 
  95 import java.lang.invoke.*;
  96 import static java.lang.invoke.MethodHandles.*;
  97 import static java.lang.invoke.MethodType.*;
  98 
  99 public class TestNestmateMembership {
 100 
 101    static final MethodType VOID_T = MethodType.methodType(void.class);
 102 
 103     static class Caller {
 104 
 105         private Caller() {}
 106 
 107         private static void m() {
 108             System.out.println(&quot;Caller.m()&quot;);
 109         }
 110 
 111         // direct static method invocations
 112 
 113         public static void invokeTarget() {
 114             Target.m();
 115         }
 116         public static void invokeTargetNoHost() {
 117             TargetNoHost.m();
 118         }
 119         public static void invokeTargetSelfHost() {
 120             TargetSelfHost.m();
 121         }
 122         public static void invokeTargetMissingHost() {
 123             TargetMissingHost.m();
 124         }
 125         public static void invokeTargetNotInstanceHost() {
 126             TargetNotInstanceHost.m();
 127         }
 128         public static void invokeTargetNotOurHost() {
 129             TargetNotOurHost.m();
 130         }
 131 
 132         // reflective static method invocations
 133 
 134         public static void invokeTargetNoHostReflectively() throws Throwable {
 135             TargetNoHost.class.getDeclaredMethod(&quot;m&quot;, new Class&lt;?&gt;[0]).invoke(null, new Object[0]);
 136         }
 137         public static void invokeTargetSelfHostReflectively() throws Throwable {
 138             TargetSelfHost.class.getDeclaredMethod(&quot;m&quot;, new Class&lt;?&gt;[0]).invoke(null, new Object[0]);
 139         }
 140         public static void invokeTargetMissingHostReflectively() throws Throwable {
 141             TargetMissingHost.class.getDeclaredMethod(&quot;m&quot;, new Class&lt;?&gt;[0]).invoke(null, new Object[0]);
 142         }
 143         public static void invokeTargetNotInstanceHostReflectively() throws Throwable {
 144             TargetNotInstanceHost.class.getDeclaredMethod(&quot;m&quot;, new Class&lt;?&gt;[0]).invoke(null, new Object[0]);
 145         }
 146         public static void invokeTargetNotOurHostReflectively() throws Throwable {
 147             TargetNotOurHost.class.getDeclaredMethod(&quot;m&quot;, new Class&lt;?&gt;[0]).invoke(null, new Object[0]);
 148         }
 149 
 150         // MethodHandle static method lookup (no invoke as the lookup should fail)
 151 
 152         public static void invokeTargetNoHostMH() throws Throwable {
 153             MethodHandle mh = lookup().findStatic(TargetNoHost.class, &quot;m&quot;, VOID_T);
 154         }
 155         public static void invokeTargetSelfHostMH() throws Throwable {
 156             MethodHandle mh = lookup().findStatic(TargetSelfHost.class, &quot;m&quot;, VOID_T);
 157         }
 158         public static void invokeTargetMissingHostMH() throws Throwable {
 159             MethodHandle mh = lookup().findStatic(TargetMissingHost.class, &quot;m&quot;, VOID_T);
 160         }
 161         public static void invokeTargetNotInstanceHostMH() throws Throwable {
 162             MethodHandle mh = lookup().findStatic(TargetNotInstanceHost.class, &quot;m&quot;, VOID_T);
 163         }
 164         public static void invokeTargetNotOurHostMH() throws Throwable {
 165             MethodHandle mh = lookup().findStatic(TargetNotOurHost.class, &quot;m&quot;, VOID_T);
 166         }
 167 
 168 
 169         // direct constructor invocations
 170 
 171         public static void newTarget() {
 172             Object o = new Target();
 173         }
 174         public static void newTargetNoHost() {
 175             Object o = new TargetNoHost();
 176         }
 177         public static void newTargetSelfHost() {
 178             Object o = new TargetSelfHost();
 179         }
 180         public static void newTargetMissingHost() {
 181             Object o = new TargetMissingHost();
 182         }
 183         public static void newTargetNotInstanceHost() {
 184             Object o = new TargetNotInstanceHost();
 185         }
 186         public static void newTargetNotOurHost() {
 187             Object o = new TargetNotOurHost();
 188         }
 189 
 190         // reflective constructor invocations
 191 
 192         public static void newTargetNoHostReflectively() throws Throwable {
 193             Object o = TargetNoHost.class.getDeclaredConstructor(new Class&lt;?&gt;[0]).newInstance(new Object[0]);
 194         }
 195         public static void newTargetSelfHostReflectively() throws Throwable {
 196             Object o = TargetSelfHost.class.getDeclaredConstructor(new Class&lt;?&gt;[0]).newInstance(new Object[0]);
 197         }
 198         public static void newTargetMissingHostReflectively() throws Throwable {
 199             Object o = TargetMissingHost.class.getDeclaredConstructor(new Class&lt;?&gt;[0]).newInstance(new Object[0]);
 200         }
 201         public static void newTargetNotInstanceHostReflectively() throws Throwable {
 202             Object o = TargetNotInstanceHost.class.getDeclaredConstructor(new Class&lt;?&gt;[0]).newInstance(new Object[0]);
 203         }
 204         public static void newTargetNotOurHostReflectively() throws Throwable {
 205             Object o = TargetNotOurHost.class.getDeclaredConstructor(new Class&lt;?&gt;[0]).newInstance(new Object[0]);
 206         }
 207 
 208         // MethodHandle constructor lookup (no invoke as the lookup should fail)
 209 
 210         public static void newTargetNoHostMH() throws Throwable {
 211             MethodHandle mh = lookup().findConstructor(TargetNoHost.class, VOID_T);
 212         }
 213         public static void newTargetSelfHostMH() throws Throwable {
 214             MethodHandle mh = lookup().findConstructor(TargetSelfHost.class, VOID_T);
 215         }
 216         public static void newTargetMissingHostMH() throws Throwable {
 217             MethodHandle mh = lookup().findConstructor(TargetMissingHost.class, VOID_T);
 218         }
 219         public static void newTargetNotInstanceHostMH() throws Throwable {
 220             MethodHandle mh = lookup().findConstructor(TargetNotInstanceHost.class, VOID_T);
 221         }
 222         public static void newTargetNotOurHostMH() throws Throwable {
 223             MethodHandle mh = lookup().findConstructor(TargetNotOurHost.class, VOID_T);
 224         }
 225 
 226         private static int f;
 227 
 228         // direct field accesses
 229 
 230         public static void getFieldTarget() {
 231             int x = Target.f;
 232         }
 233         public static void getFieldTargetNoHost() {
 234             int x = TargetNoHost.f;
 235         }
 236         public static void getFieldTargetSelfHost() {
 237             int x = TargetSelfHost.f;
 238         }
 239         public static void getFieldTargetMissingHost() {
 240             int x = TargetMissingHost.f;
 241         }
 242         public static void getFieldTargetNotInstanceHost() {
 243             int x = TargetNotInstanceHost.f;
 244         }
 245         public static void getFieldTargetNotOurHost() {
 246             int x = TargetNotOurHost.f;
 247         }
 248 
 249         public static void putFieldTarget() {
 250             Target.f = 42;
 251         }
 252         public static void putFieldTargetNoHost() {
 253             TargetNoHost.f = 42;
 254         }
 255         public static void putFieldTargetSelfHost() {
 256             TargetSelfHost.f = 42;
 257         }
 258         public static void putFieldTargetMissingHost() {
 259             TargetMissingHost.f = 42;
 260         }
 261         public static void putFieldTargetNotInstanceHost() {
 262             TargetNotInstanceHost.f = 42;
 263         }
 264         public static void putFieldTargetNotOurHost() {
 265             TargetNotOurHost.f = 42;
 266         }
 267 
 268         // reflective field accesses
 269 
 270         public static void getFieldTargetNoHostReflectively() throws Throwable {
 271             int x = TargetNoHost.class.getDeclaredField(&quot;f&quot;).getInt(null);
 272         }
 273         public static void getFieldTargetSelfHostReflectively() throws Throwable {
 274             int x = TargetSelfHost.class.getDeclaredField(&quot;f&quot;).getInt(null);
 275         }
 276         public static void getFieldTargetMissingHostReflectively() throws Throwable {
 277             int x = TargetMissingHost.class.getDeclaredField(&quot;f&quot;).getInt(null);
 278         }
 279         public static void getFieldTargetNotInstanceHostReflectively() throws Throwable {
 280             int x = TargetNotInstanceHost.class.getDeclaredField(&quot;f&quot;).getInt(null);
 281         }
 282         public static void getFieldTargetNotOurHostReflectively() throws Throwable {
 283             int x = TargetNotOurHost.class.getDeclaredField(&quot;f&quot;).getInt(null);
 284         }
 285 
 286         public static void putFieldTargetNoHostReflectively() throws Throwable {
 287             TargetNoHost.class.getDeclaredField(&quot;f&quot;).setInt(null, 42);
 288         }
 289         public static void putFieldTargetSelfHostReflectively() throws Throwable {
 290             TargetSelfHost.class.getDeclaredField(&quot;f&quot;).setInt(null, 42);
 291         }
 292         public static void putFieldTargetMissingHostReflectively() throws Throwable {
 293             TargetMissingHost.class.getDeclaredField(&quot;f&quot;).setInt(null, 42);
 294         }
 295         public static void putFieldTargetNotInstanceHostReflectively() throws Throwable {
 296             TargetNotInstanceHost.class.getDeclaredField(&quot;f&quot;).setInt(null, 42);
 297         }
 298         public static void putFieldTargetNotOurHostReflectively() throws Throwable {
 299             TargetNotOurHost.class.getDeclaredField(&quot;f&quot;).setInt(null, 42);
 300         }
 301 
 302         // MethodHandle field lookup (no access as the lookup will fail)
 303 
 304         public static void getFieldTargetNoHostMH() throws Throwable {
 305             MethodHandle mh = lookup().findStaticGetter(TargetNoHost.class, &quot;f&quot;, int.class);
 306         }
 307         public static void getFieldTargetSelfHostMH() throws Throwable {
 308             MethodHandle mh = lookup().findStaticGetter(TargetSelfHost.class, &quot;f&quot;, int.class);
 309         }
 310         public static void getFieldTargetMissingHostMH() throws Throwable {
 311             MethodHandle mh = lookup().findStaticGetter(TargetMissingHost.class, &quot;f&quot;, int.class);
 312         }
 313         public static void getFieldTargetNotInstanceHostMH() throws Throwable {
 314             MethodHandle mh = lookup().findStaticGetter(TargetNotInstanceHost.class, &quot;f&quot;, int.class);
 315         }
 316         public static void getFieldTargetNotOurHostMH() throws Throwable {
 317             MethodHandle mh = lookup().findStaticGetter(TargetNotOurHost.class, &quot;f&quot;, int.class);
 318         }
 319 
 320         public static void putFieldTargetNoHostMH() throws Throwable {
 321             MethodHandle mh = lookup().findStaticSetter(TargetNoHost.class, &quot;f&quot;, int.class);
 322         }
 323         public static void putFieldTargetSelfHostMH() throws Throwable {
 324             MethodHandle mh = lookup().findStaticSetter(TargetSelfHost.class, &quot;f&quot;, int.class);
 325         }
 326         public static void putFieldTargetMissingHostMH() throws Throwable {
 327             MethodHandle mh = lookup().findStaticSetter(TargetMissingHost.class, &quot;f&quot;, int.class);
 328         }
 329         public static void putFieldTargetNotInstanceHostMH() throws Throwable {
 330             MethodHandle mh = lookup().findStaticSetter(TargetNotInstanceHost.class, &quot;f&quot;, int.class);
 331         }
 332         public static void putFieldTargetNotOurHostMH() throws Throwable {
 333             MethodHandle mh = lookup().findStaticSetter(TargetNotOurHost.class, &quot;f&quot;, int.class);
 334         }
 335 
 336     }
 337 
 338     static class CallerNoHost {
 339 
 340         // method invocations
 341 
 342         private static void m() {
 343             System.out.println(&quot;CallerNoHost.m() - java version&quot;);
 344         }
 345         public static void invokeTarget() {
 346             Target.m();
 347         }
 348         public static void invokeTargetNoHost() {
 349             TargetNoHost.m();
 350         }
 351 
 352         // constructor invocations
 353 
 354         private CallerNoHost() {}
 355 
 356         public static void newTarget() {
 357             Object o = new Target();
 358         }
 359         public static void newTargetNoHost() {
 360             Object o = new TargetNoHost();
 361         }
 362 
 363         // field accesses
 364 
 365         private static int f;
 366 
 367         public static void getFieldTarget() {
 368             int x = Target.f;
 369         }
 370         public static void getFieldTargetNoHost() {
 371             int x = TargetNoHost.f;
 372         }
 373 
 374         public static void putFieldTarget() {
 375             Target.f = 42;
 376         }
 377         public static void putFieldTargetNoHost() {
 378             TargetNoHost.f = 42;
 379         }
 380 
 381     }
 382 
 383     static class CallerSelfHost {
 384 
 385         // method invocations
 386 
 387         private static void m() {
 388             System.out.println(&quot;CallerSelfHost.m() - java version&quot;);
 389         }
 390         public static void invokeTarget() {
 391             Target.m();
 392         }
 393         public static void invokeTargetSelfHost() {
 394             TargetSelfHost.m();
 395         }
 396 
 397         // constructor invocations
 398 
 399         private CallerSelfHost() {}
 400 
 401         public static void newTarget() {
 402             Object o = new Target();
 403         }
 404         public static void newTargetSelfHost() {
 405             Object o = new TargetSelfHost();
 406         }
 407 
 408         // field accesses
 409 
 410         private static int f;
 411 
 412         public static void getFieldTarget() {
 413             int x = Target.f;
 414         }
 415         public static void getFieldTargetSelfHost() {
 416             int x = TargetSelfHost.f;
 417         }
 418 
 419         public static void putFieldTarget() {
 420             Target.f = 42;
 421         }
 422         public static void putFieldTargetSelfHost() {
 423             TargetSelfHost.f = 42;
 424         }
 425 
 426     }
 427 
 428     static class CallerMissingHost {
 429         String msg = &quot;NoCallerMissingHost&quot;; // for cp entry
 430 
 431         // method invocations
 432 
 433         private static void m() {
 434             System.out.println(&quot;CallerMissingHost.m() - java version&quot;);
 435         }
 436         public static void invokeTarget() {
 437             Target.m();
 438         }
 439         public static void invokeTargetMissingHost() {
 440             TargetMissingHost.m();
 441         }
 442 
 443         // constructor invocations
 444 
 445         private CallerMissingHost() {}
 446 
 447         public static void newTarget() {
 448             Object o = new Target();
 449         }
 450         public static void newTargetMissingHost() {
 451             Object o = new TargetMissingHost();
 452         }
 453 
 454         // field accesses
 455 
 456         private static int f;
 457 
 458         public static void getFieldTarget() {
 459             int x = Target.f;
 460         }
 461         public static void getFieldTargetMissingHost() {
 462             int x = TargetMissingHost.f;
 463         }
 464         public static void putFieldTarget() {
 465             Target.f = 42;
 466         }
 467         public static void putFieldTargetMissingHost() {
 468             TargetMissingHost.f = 42;
 469         }
 470 
 471     }
 472 
 473     static class CallerNotInstanceHost {
 474         Object[] oa; // create CP entry to use in jcod change
 475 
 476         // method invocations
 477 
 478         private static void m() {
 479             System.out.println(&quot;CallerNotInstanceHost.m() - java version&quot;);
 480         }
 481         public static void invokeTarget() {
 482             Target.m();
 483         }
 484         public static void invokeTargetNotInstanceHost() {
 485             TargetNotInstanceHost.m();
 486         }
 487 
 488         // constructor invocations
 489 
 490         private CallerNotInstanceHost() {}
 491 
 492         public static void newTarget() {
 493             Object o = new Target();
 494         }
 495         public static void newTargetNotInstanceHost() {
 496             Object o = new TargetNotInstanceHost();
 497         }
 498 
 499         // field accesses
 500 
 501         private static int f;
 502 
 503         public static void getFieldTarget() {
 504             int x = Target.f;
 505         }
 506         public static void getFieldTargetNotInstanceHost() {
 507             int x = TargetNotInstanceHost.f;
 508         }
 509         public static void putFieldTarget() {
 510             Target.f = 42;
 511         }
 512         public static void putFieldTargetNotInstanceHost() {
 513             TargetNotInstanceHost.f = 42;
 514         }
 515     }
 516 
 517     static class CallerNotOurHost {
 518 
 519         // method invocations
 520 
 521         private static void m() {
 522             System.out.println(&quot;CallerNotOurHost.m() - java version&quot;);
 523         }
 524         public static void invokeTarget() {
 525             Target.m();
 526         }
 527         public static void invokeTargetNotOurHost() {
 528             TargetNotOurHost.m();
 529         }
 530 
 531         // constructor invocations
 532 
 533         private CallerNotOurHost() {}
 534 
 535         public static void newTarget() {
 536             Object o = new Target();
 537         }
 538         public static void newTargetNotOurHost() {
 539             Object o = new TargetNotOurHost();
 540         }
 541 
 542         // field accesses
 543 
 544         private static int f;
 545 
 546         public static void getFieldTarget() {
 547             int x = Target.f;
 548         }
 549         public static void getFieldTargetNotOurHost() {
 550             int x = TargetNotOurHost.f;
 551         }
 552         public static void putFieldTarget() {
 553             Target.f = 42;
 554         }
 555         public static void putFieldTargetNotOurHost() {
 556             TargetNotOurHost.f = 42;
 557         }
 558 
 559     }
 560 
 561     static class Target {
 562         private Target() {}
 563         private static int f;
 564         private static void m() {
 565             System.out.println(&quot;Target.m()&quot;);
 566         }
 567     }
 568 
 569     static class TargetNoHost {
 570         private TargetNoHost() {}
 571         private static int f;
 572         private static void m() {
 573             System.out.println(&quot;TargetNoHost.m() - java version&quot;);
 574         }
 575     }
 576 
 577     static class TargetSelfHost {
 578         private TargetSelfHost() {}
 579         private static int f;
 580         private static void m() {
 581             System.out.println(&quot;TargetSelfHost.m() - java version&quot;);
 582         }
 583     }
 584 
 585     static class TargetMissingHost {
 586         String msg = &quot;NoTargetMissingHost&quot;;  // for cp entry
 587         private TargetMissingHost() {}
 588         private static int f;
 589         private static void m() {
 590             System.out.println(&quot;TargetMissingHost.m() - java version&quot;);
 591         }
 592     }
 593 
 594     static class TargetNotInstanceHost {
 595         Object[] oa; // create CP entry to use in jcod change
 596         private TargetNotInstanceHost() {}
 597         private static int f;
 598         private static void m() {
 599             System.out.println(&quot;TargetNotInstanceHost.m() - java version&quot;);
 600         }
 601     }
 602 
 603     static class TargetNotOurHost {
 604         private TargetNotOurHost() {}
 605         private static int f;
 606         private static void m() {
 607             System.out.println(&quot;TargetNotOurHost.m() - java version&quot;);
 608         }
 609     }
 610 
 611     public static void main(String[] args) throws Throwable {
 612         if (args.length &lt; 1) {
 613             throw new Error(&quot;Test mode argument must be one of: method, constructor, getField or putField&quot;);
 614         }
 615         switch(args[0]) {
 616         case &quot;method&quot;:
 617             System.out.println(&quot;TESTING METHOD INVOCATIONS:&quot;);
 618             test_GoodInvoke();
 619             test_NoHostInvoke();
 620             test_SelfHostInvoke();
 621             test_MissingHostInvoke();
 622             test_NotInstanceHostInvoke();
 623             test_NotOurHostInvoke();
 624             test_WrongPackageHostInvoke();
 625             break;
 626         case &quot;constructor&quot;:
 627             System.out.println(&quot;TESTING CONSTRUCTOR INVOCATIONS:&quot;);
 628             test_GoodConstruct();
 629             test_NoHostConstruct();
 630             test_SelfHostConstruct();
 631             test_MissingHostConstruct();
 632             test_NotInstanceHostConstruct();
 633             test_NotOurHostConstruct();
 634             test_WrongPackageHostConstruct();
 635             break;
 636         case &quot;getField&quot;:
 637             System.out.println(&quot;TESTING GETFIELD INVOCATIONS:&quot;);
 638             test_GoodGetField();
 639             test_NoHostGetField();
 640             test_SelfHostGetField();
 641             test_MissingHostGetField();
 642             test_NotInstanceHostGetField();
 643             test_NotOurHostGetField();
 644             test_WrongPackageHostGetField();
 645             break;
 646         case &quot;putField&quot;:
 647             System.out.println(&quot;TESTING PUTFIELD INVOCATIONS:&quot;);
 648             test_GoodPutField();
 649             test_NoHostPutField();
 650             test_SelfHostPutField();
 651             test_MissingHostPutField();
 652             test_NotInstanceHostPutField();
 653             test_NotOurHostPutField();
 654             test_WrongPackageHostPutField();
 655             break;
 656         default:
 657             throw new Error(&quot;Uknown mode: &quot; + args[0] +
 658                             &quot;. Must be one of: method, constructor, getField or putField&quot;);
 659         }
 660     }
 661 
 662     static void test_GoodInvoke(){
 663         try {
 664             Caller.invokeTarget();
 665         }
 666         catch (Exception e) {
 667             throw new Error(&quot;Unexpected exception on good invocation &quot; + e);
 668         }
 669     }
 670 
 671     static void test_NoHostInvoke() throws Throwable {
 672         System.out.println(&quot;Testing for missing nest-host attribute&quot;);
 673         String msg = &quot;class TestNestmateMembership$Caller tried to access &quot; +
 674             &quot;private method &#39;void TestNestmateMembership$TargetNoHost.m()&#39;&quot;;
 675         try {
 676             Caller.invokeTargetNoHost();
 677             throw new Error(&quot;Missing IllegalAccessError: &quot; + msg);
 678         }
 679         catch (IllegalAccessError expected) {
 680             check_expected(expected, msg);
 681         }
 682         msg = &quot;TestNestmateMembership$Caller cannot access a member of class &quot; +
 683             &quot;TestNestmateMembership$TargetNoHost with modifiers \&quot;private static\&quot;&quot;;
 684         try {
 685             Caller.invokeTargetNoHostReflectively();
 686             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
 687         }
 688         catch (IllegalAccessException expected) {
 689             check_expected(expected, msg);
 690         }
 691         msg = &quot;no such method: TestNestmateMembership$TargetNoHost.m()void/invokeStatic&quot;;
 692         try {
 693             Caller.invokeTargetNoHostMH();
 694             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
 695         }
 696         catch (IllegalAccessException expected) {
 697             check_expected(expected, msg);
 698         }
 699 
 700         msg = &quot;class TestNestmateMembership$CallerNoHost tried to access &quot; +
 701             &quot;private method &#39;void TestNestmateMembership$Target.m()&#39;&quot;;
 702         try {
 703             CallerNoHost.invokeTarget();
 704             throw new Error(&quot;Missing IllegalAccessError: &quot; + msg);
 705         }
 706         catch (IllegalAccessError expected) {
 707             check_expected(expected, msg);
 708         }
 709         msg = &quot;class TestNestmateMembership$CallerNoHost tried to access private &quot; +
 710             &quot;method &#39;void TestNestmateMembership$TargetNoHost.m()&#39;&quot;;
 711         try {
 712             CallerNoHost.invokeTargetNoHost();
 713             throw new Error(&quot;Missing IllegalAccessError: &quot; + msg);
 714         }
 715         catch (IllegalAccessError expected) {
 716             check_expected(expected, msg);
 717         }
 718     }
 719 
 720     static void test_SelfHostInvoke() throws Throwable {
 721         System.out.println(&quot;Testing for class that lists itself as nest-host&quot;);
 722         String msg = &quot;Type TestNestmateMembership$TargetSelfHost (loader: &#39;app&#39;) is not a nest member&quot; +
 723             &quot; of TestNestmateMembership$TargetSelfHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
 724         try {
 725             Caller.invokeTargetSelfHost();
 726             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 727         }
 728         catch (IncompatibleClassChangeError expected) {
 729             check_expected(expected, msg);
 730         }
 731         try {
 732             Caller.invokeTargetSelfHostReflectively();
 733             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 734         }
 735         catch (IncompatibleClassChangeError expected) {
 736             check_expected(expected, msg);
 737         }
 738         msg = &quot;no such method: TestNestmateMembership$TargetSelfHost.m()void/invokeStatic&quot;;
 739         try {
 740             Caller.invokeTargetSelfHostMH();
 741             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
 742         }
 743         catch (IllegalAccessException expected) {
 744             check_expected(expected, msg);
 745         }
 746 
 747         msg = &quot;Type TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;) is not a nest member&quot; +
 748             &quot; of TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
 749         try {
 750             CallerSelfHost.invokeTarget();
 751             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 752         }
 753         catch (IncompatibleClassChangeError expected) {
 754             check_expected(expected, msg);
 755         }
 756         msg = &quot;Type TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;) is not a nest member&quot; +
 757             &quot; of TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
 758         try {
 759             CallerSelfHost.invokeTargetSelfHost();
 760             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 761         }
 762         catch (IncompatibleClassChangeError expected) {
 763             check_expected(expected, msg);
 764         }
 765     }
 766 
 767     static void test_MissingHostInvoke() throws Throwable {
 768         System.out.println(&quot;Testing for nest-host class that does not exist&quot;);
 769         String msg = &quot;Unable to load nest-host class (NoTargetMissingHost) of &quot; +
 770             &quot;TestNestmateMembership$TargetMissingHost&quot;;
 771         String cause_msg = &quot;NoTargetMissingHost&quot;;
 772         try {
 773             Caller.invokeTargetMissingHost();
 774             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
 775         }
 776         catch (NoClassDefFoundError expected) {
 777             check_expected(expected, msg, cause_msg);
 778         }
 779         try {
 780             Caller.invokeTargetMissingHostReflectively();
 781             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
 782         }
 783         catch (NoClassDefFoundError expected) {
 784             check_expected(expected, msg, cause_msg);
 785         }
 786         msg = &quot;no such method: TestNestmateMembership$TargetMissingHost.m()void/invokeStatic&quot;;
 787         try {
 788             Caller.invokeTargetMissingHostMH();
 789             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
 790         }
 791         catch (IllegalAccessException expected) {
 792             check_expected(expected, msg);
 793         }
 794         msg = &quot;no such method: TestNestmateMembership$TargetMissingHost.m()void/invokeStatic&quot;;
 795         try {
 796             Caller.invokeTargetMissingHostMH();
 797             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
 798         }
 799         catch (IllegalAccessException expected) {
 800             check_expected(expected, msg);
 801         }
 802 
 803         msg = &quot;Unable to load nest-host class (NoCallerMissingHost) of &quot; +
 804             &quot;TestNestmateMembership$CallerMissingHost&quot;;
 805         cause_msg = &quot;NoCallerMissingHost&quot;;
 806         try {
 807             CallerMissingHost.invokeTarget();
 808             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
 809         }
 810         catch (NoClassDefFoundError expected) {
 811             check_expected(expected, msg, cause_msg);
 812         }
 813         msg = &quot;Unable to load nest-host class (NoCallerMissingHost) of &quot;+
 814             &quot;TestNestmateMembership$CallerMissingHost&quot;;
 815         cause_msg = &quot;NoCallerMissingHost&quot;;
 816         try {
 817             CallerMissingHost.invokeTargetMissingHost();
 818             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
 819         }
 820         catch (NoClassDefFoundError expected) {
 821             check_expected(expected, msg, cause_msg);
 822         }
 823     }
 824 
 825     static void test_NotInstanceHostInvoke() throws Throwable {
 826         System.out.println(&quot;Testing for nest-host class that is not an instance class&quot;);
 827         String msg = &quot;Type TestNestmateMembership$TargetNotInstanceHost (loader: &#39;app&#39;) is not a &quot;+
 828             &quot;nest member of [LInvalidNestHost; (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
 829         try {
 830             Caller.invokeTargetNotInstanceHost();
 831             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 832         }
 833         catch (IncompatibleClassChangeError expected) {
 834             check_expected(expected, msg);
 835         }
 836         try {
 837             Caller.invokeTargetNotInstanceHostReflectively();
 838             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 839         }
 840         catch (IncompatibleClassChangeError expected) {
 841             check_expected(expected, msg);
 842         }
 843         msg = &quot;no such method: TestNestmateMembership$TargetNotInstanceHost.m()void/invokeStatic&quot;;
 844         try {
 845             Caller.invokeTargetNotInstanceHostMH();
 846             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
 847         }
 848         catch (IllegalAccessException expected) {
 849             check_expected(expected, msg);
 850         }
 851 
 852         msg = &quot;Type TestNestmateMembership$CallerNotInstanceHost (loader: &#39;app&#39;) is not a &quot;+
 853             &quot;nest member of [LInvalidNestHost; (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
 854         try {
 855             CallerNotInstanceHost.invokeTarget();
 856             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 857         }
 858         catch (IncompatibleClassChangeError expected) {
 859             check_expected(expected, msg);
 860         }
 861         msg = &quot;Type TestNestmateMembership$CallerNotInstanceHost (loader: &#39;app&#39;) is not a &quot;+
 862             &quot;nest member of [LInvalidNestHost; (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
 863         try {
 864             CallerNotInstanceHost.invokeTargetNotInstanceHost();
 865             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 866         }
 867         catch (IncompatibleClassChangeError expected) {
 868             check_expected(expected, msg);
 869         }
 870     }
 871 
 872     static void test_NotOurHostInvoke() throws Throwable {
 873         System.out.println(&quot;Testing for nest-host class that does not list us in its nest&quot;);
 874         String msg = &quot;Type TestNestmateMembership$TargetNotOurHost (loader: &#39;app&#39;) is not a nest member&quot; +
 875             &quot; of InvalidNestHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
 876         try {
 877             Caller.invokeTargetNotOurHost();
 878             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 879         }
 880         catch (IncompatibleClassChangeError expected) {
 881             check_expected(expected, msg);
 882         }
 883         try {
 884             Caller.invokeTargetNotOurHostReflectively();
 885             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 886         }
 887         catch (IncompatibleClassChangeError expected) {
 888             check_expected(expected, msg);
 889         }
 890         msg = &quot;no such method: TestNestmateMembership$TargetNotOurHost.m()void/invokeStatic&quot;;
 891         try {
 892             Caller.invokeTargetNotOurHostMH();
 893             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
 894         }
 895         catch (IllegalAccessException expected) {
 896             check_expected(expected, msg);
 897         }
 898 
 899         msg = &quot;Type TestNestmateMembership$CallerNotOurHost (loader: &#39;app&#39;) is not a nest member&quot; +
 900             &quot; of InvalidNestHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
 901         try {
 902             CallerNotOurHost.invokeTarget();
 903             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 904         }
 905         catch (IncompatibleClassChangeError expected) {
 906             check_expected(expected, msg);
 907         }
 908         msg = &quot;Type TestNestmateMembership$CallerNotOurHost (loader: &#39;app&#39;) is not a nest member&quot; +
 909             &quot; of InvalidNestHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
 910         try {
 911             CallerNotOurHost.invokeTargetNotOurHost();
 912             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 913         }
 914         catch (IncompatibleClassChangeError expected) {
 915             check_expected(expected, msg);
 916         }
 917     }
 918 
 919     static void test_WrongPackageHostInvoke() {
 920         System.out.println(&quot;Testing for nest-host and nest-member in different packages&quot;);
 921         String msg = &quot;Type P2.PackagedNestHost2$Member (loader: &#39;app&#39;) is not a nest member of &quot; +
 922             &quot;P1.PackagedNestHost (loader: &#39;app&#39;): types are in different packages&quot;;
 923         try {
 924             P1.PackagedNestHost.doInvoke();
 925             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 926         }
 927         catch (IncompatibleClassChangeError expected) {
 928             check_expected(expected, msg);
 929         }
 930         try {
 931             P2.PackagedNestHost2.Member.doInvoke();
 932             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 933         }
 934         catch (IncompatibleClassChangeError expected) {
 935             check_expected(expected, msg);
 936         }
 937     }
 938 
 939     // constructor tests
 940 
 941    static void test_GoodConstruct(){
 942         try {
 943             Caller.newTarget();
 944         }
 945         catch (Exception e) {
 946             throw new Error(&quot;Unexpected exception on good construction: &quot; + e);
 947         }
 948     }
 949 
 950     static void test_NoHostConstruct() throws Throwable {
 951         System.out.println(&quot;Testing for missing nest-host attribute&quot;);
 952         String msg = &quot;class TestNestmateMembership$Caller tried to access private &quot; +
 953             &quot;method &#39;void TestNestmateMembership$TargetNoHost.&lt;init&gt;()&#39;&quot;;
 954         try {
 955             Caller.newTargetNoHost();
 956             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 957         }
 958         catch (IncompatibleClassChangeError expected) {
 959             check_expected(expected, msg);
 960         }
 961         msg = &quot;class TestNestmateMembership$Caller cannot access a member of class &quot; +
 962             &quot;TestNestmateMembership$TargetNoHost with modifiers \&quot;private\&quot;&quot;;
 963         try {
 964             Caller.newTargetNoHostReflectively();
 965             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
 966         }
 967         catch (IllegalAccessException expected) {
 968             check_expected(expected, msg);
 969         }
 970         msg = &quot;no such constructor: TestNestmateMembership$TargetNoHost.&lt;init&gt;()void/newInvokeSpecial&quot;;
 971         try {
 972             Caller.newTargetNoHostMH();
 973             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
 974         }
 975         catch (IllegalAccessException expected) {
 976             check_expected(expected, msg);
 977         }
 978 
 979         msg = &quot;class TestNestmateMembership$CallerNoHost tried to access private &quot; +
 980             &quot;method &#39;void TestNestmateMembership$Target.&lt;init&gt;()&#39;&quot;;
 981         try {
 982             CallerNoHost.newTarget();
 983             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 984         }
 985         catch (IncompatibleClassChangeError expected) {
 986             check_expected(expected, msg);
 987         }
 988         msg = &quot;class TestNestmateMembership$CallerNoHost tried to access private &quot; +
 989             &quot;method &#39;void TestNestmateMembership$TargetNoHost.&lt;init&gt;()&#39;&quot;;
 990         try {
 991             CallerNoHost.newTargetNoHost();
 992             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
 993         }
 994         catch (IncompatibleClassChangeError expected) {
 995             check_expected(expected, msg);
 996         }
 997     }
 998 
 999     static void test_SelfHostConstruct() throws Throwable {
1000         System.out.println(&quot;Testing for class that lists itself as nest-host&quot;);
1001         String msg = &quot;Type TestNestmateMembership$TargetSelfHost (loader: &#39;app&#39;) is not a nest member&quot; +
1002             &quot; of TestNestmateMembership$TargetSelfHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1003         try {
1004             Caller.newTargetSelfHost();
1005             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1006         }
1007         catch (IncompatibleClassChangeError expected) {
1008             check_expected(expected, msg);
1009         }
1010         try {
1011             Caller.newTargetSelfHostReflectively();
1012             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1013         }
1014         catch (IncompatibleClassChangeError expected) {
1015             check_expected(expected, msg);
1016         }
1017         msg = &quot;no such constructor: TestNestmateMembership$TargetSelfHost.&lt;init&gt;()void/newInvokeSpecial&quot;;
1018         try {
1019             Caller.newTargetSelfHostMH();
1020             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
1021         }
1022         catch (IllegalAccessException expected) {
1023             check_expected(expected, msg);
1024         }
1025 
1026         msg = &quot;Type TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;) is not a nest member&quot; +
1027             &quot; of TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1028         try {
1029             CallerSelfHost.newTarget();
1030             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1031         }
1032         catch (IncompatibleClassChangeError expected) {
1033             check_expected(expected, msg);
1034         }
1035         msg = &quot;Type TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;) is not a nest member&quot; +
1036             &quot; of TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1037         try {
1038             CallerSelfHost.newTargetSelfHost();
1039             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1040         }
1041         catch (IncompatibleClassChangeError expected) {
1042             check_expected(expected, msg);
1043         }
1044     }
1045 
1046     static void test_MissingHostConstruct() throws Throwable {
1047         System.out.println(&quot;Testing for nest-host class that does not exist&quot;);
1048         String msg = &quot;Unable to load nest-host class (NoTargetMissingHost) of &quot; +
1049             &quot;TestNestmateMembership$TargetMissingHost&quot;;
1050         String cause_msg = &quot;NoTargetMissingHost&quot;;
1051         try {
1052             Caller.newTargetMissingHost();
1053             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
1054         }
1055         catch (NoClassDefFoundError expected) {
1056             check_expected(expected, msg, cause_msg);
1057         }
1058         try {
1059             Caller.newTargetMissingHostReflectively();
1060             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
1061         }
1062         catch (NoClassDefFoundError expected) {
1063             check_expected(expected, msg, cause_msg);
1064         }
1065         msg = &quot;no such constructor: TestNestmateMembership$TargetMissingHost.&lt;init&gt;()void/newInvokeSpecial&quot;;
1066         try {
1067             Caller.newTargetMissingHostMH();
1068             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
1069         }
1070         catch (IllegalAccessException expected) {
1071             check_expected(expected, msg);
1072         }
1073 
1074         msg = &quot;Unable to load nest-host class (NoCallerMissingHost) of &quot; +
1075             &quot;TestNestmateMembership$CallerMissingHost&quot;;
1076         cause_msg = &quot;NoCallerMissingHost&quot;;
1077         try {
1078             CallerMissingHost.newTarget();
1079             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
1080         }
1081         catch (NoClassDefFoundError expected) {
1082             check_expected(expected, msg, cause_msg);
1083         }
1084         msg = &quot;Unable to load nest-host class (NoCallerMissingHost) of &quot;+
1085             &quot;TestNestmateMembership$CallerMissingHost&quot;;
1086         cause_msg = &quot;NoCallerMissingHost&quot;;
1087         try {
1088             CallerMissingHost.newTargetMissingHost();
1089             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
1090         }
1091         catch (NoClassDefFoundError expected) {
1092             check_expected(expected, msg, cause_msg);
1093         }
1094     }
1095 
1096     static void test_NotInstanceHostConstruct() throws Throwable {
1097         System.out.println(&quot;Testing for nest-host class that is not an instance class&quot;);
1098         String msg = &quot;Type TestNestmateMembership$TargetNotInstanceHost (loader: &#39;app&#39;) is not a &quot;+
1099             &quot;nest member of [LInvalidNestHost; (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1100         try {
1101             Caller.newTargetNotInstanceHost();
1102             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1103         }
1104         catch (IncompatibleClassChangeError expected) {
1105             check_expected(expected, msg);
1106         }
1107         try {
1108             Caller.newTargetNotInstanceHostReflectively();
1109             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1110         }
1111         catch (IncompatibleClassChangeError expected) {
1112             check_expected(expected, msg);
1113         }
1114         msg = &quot;no such constructor: TestNestmateMembership$TargetNotInstanceHost.&lt;init&gt;()void/newInvokeSpecial&quot;;
1115         try {
1116             Caller.newTargetNotInstanceHostMH();
1117             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
1118         }
1119         catch (IllegalAccessException expected) {
1120             check_expected(expected, msg);
1121         }
1122 
1123         msg = &quot;Type TestNestmateMembership$CallerNotInstanceHost (loader: &#39;app&#39;) is not a &quot;+
1124             &quot;nest member of [LInvalidNestHost; (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1125         try {
1126             CallerNotInstanceHost.newTarget();
1127             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1128         }
1129         catch (IncompatibleClassChangeError expected) {
1130             check_expected(expected, msg);
1131         }
1132         msg = &quot;Type TestNestmateMembership$CallerNotInstanceHost (loader: &#39;app&#39;) is not a &quot;+
1133             &quot;nest member of [LInvalidNestHost; (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1134         try {
1135             CallerNotInstanceHost.newTargetNotInstanceHost();
1136             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1137         }
1138         catch (IncompatibleClassChangeError expected) {
1139             check_expected(expected, msg);
1140         }
1141     }
1142 
1143     static void test_NotOurHostConstruct() throws Throwable {
1144         System.out.println(&quot;Testing for nest-host class that does not list us in its nest&quot;);
1145         String msg = &quot;Type TestNestmateMembership$TargetNotOurHost (loader: &#39;app&#39;) is not a nest member&quot; +
1146             &quot; of InvalidNestHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1147         try {
1148             Caller.newTargetNotOurHost();
1149             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1150         }
1151         catch (IncompatibleClassChangeError expected) {
1152             check_expected(expected, msg);
1153         }
1154         try {
1155             Caller.newTargetNotOurHostReflectively();
1156             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1157         }
1158         catch (IncompatibleClassChangeError expected) {
1159             check_expected(expected, msg);
1160         }
1161         msg = &quot;no such constructor: TestNestmateMembership$TargetNotOurHost.&lt;init&gt;()void/newInvokeSpecial&quot;;
1162         try {
1163             Caller.newTargetNotOurHostMH();
1164             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
1165         }
1166         catch (IllegalAccessException expected) {
1167             check_expected(expected, msg);
1168         }
1169 
1170         msg = &quot;Type TestNestmateMembership$CallerNotOurHost (loader: &#39;app&#39;) is not a nest member&quot; +
1171             &quot; of InvalidNestHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1172         try {
1173             CallerNotOurHost.newTarget();
1174             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1175         }
1176         catch (IncompatibleClassChangeError expected) {
1177             check_expected(expected, msg);
1178         }
1179         msg = &quot;Type TestNestmateMembership$CallerNotOurHost (loader: &#39;app&#39;) is not a nest member&quot; +
1180             &quot; of InvalidNestHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1181         try {
1182             CallerNotOurHost.newTargetNotOurHost();
1183             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1184         }
1185         catch (IncompatibleClassChangeError expected) {
1186             check_expected(expected, msg);
1187         }
1188     }
1189 
1190     static void test_WrongPackageHostConstruct() {
1191         System.out.println(&quot;Testing for nest-host and nest-member in different packages&quot;);
1192         String msg = &quot;Type P2.PackagedNestHost2$Member (loader: &#39;app&#39;) is not a nest member of &quot; +
1193             &quot;P1.PackagedNestHost (loader: &#39;app&#39;): types are in different packages&quot;;
1194         try {
1195             P1.PackagedNestHost.doConstruct();
1196             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1197         }
1198         catch (IncompatibleClassChangeError expected) {
1199             check_expected(expected, msg);
1200         }
1201         try {
1202             P2.PackagedNestHost2.Member.doConstruct();
1203             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1204         }
1205         catch (IncompatibleClassChangeError expected) {
1206             check_expected(expected, msg);
1207         }
1208     }
1209 
1210     // field tests
1211 
1212    static void test_GoodGetField(){
1213         try {
1214             Caller.getFieldTarget();
1215         }
1216         catch (Exception e) {
1217             throw new Error(&quot;Unexpected exception on good field access: &quot; + e);
1218         }
1219     }
1220 
1221     static void test_NoHostGetField() throws Throwable {
1222         System.out.println(&quot;Testing for missing nest-host attribute&quot;);
1223         String msg = &quot;class TestNestmateMembership$Caller tried to access private &quot; +
1224             &quot;field TestNestmateMembership$TargetNoHost.f&quot;;
1225         try {
1226             Caller.getFieldTargetNoHost();
1227             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1228         }
1229         catch (IncompatibleClassChangeError expected) {
1230             check_expected(expected, msg);
1231         }
1232         msg = &quot;class TestNestmateMembership$Caller cannot access a member of class &quot; +
1233             &quot;TestNestmateMembership$TargetNoHost with modifiers \&quot;private static\&quot;&quot;;
1234         try {
1235             Caller.getFieldTargetNoHostReflectively();
1236             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
1237         }
1238         catch (IllegalAccessException expected) {
1239             check_expected(expected, msg);
1240         }
1241         msg = &quot;member is private: TestNestmateMembership$TargetNoHost.f/int/getStatic&quot;;
1242         try {
1243             Caller.getFieldTargetNoHostMH();
1244             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
1245         }
1246         catch (IllegalAccessException expected) {
1247             check_expected(expected, msg);
1248         }
1249 
1250         msg = &quot;class TestNestmateMembership$CallerNoHost tried to access private &quot; +
1251             &quot;field TestNestmateMembership$Target.f&quot;;
1252         try {
1253             CallerNoHost.getFieldTarget();
1254             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1255         }
1256         catch (IncompatibleClassChangeError expected) {
1257             check_expected(expected, msg);
1258         }
1259         msg = &quot;class TestNestmateMembership$CallerNoHost tried to access private &quot; +
1260             &quot;field TestNestmateMembership$TargetNoHost.f&quot;;
1261         try {
1262             CallerNoHost.getFieldTargetNoHost();
1263             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1264         }
1265         catch (IncompatibleClassChangeError expected) {
1266             check_expected(expected, msg);
1267         }
1268     }
1269 
1270     static void test_SelfHostGetField() throws Throwable {
1271         System.out.println(&quot;Testing for class that lists itself as nest-host&quot;);
1272         String msg = &quot;Type TestNestmateMembership$TargetSelfHost (loader: &#39;app&#39;) is not a nest member&quot; +
1273             &quot; of TestNestmateMembership$TargetSelfHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1274         try {
1275             Caller.getFieldTargetSelfHost();
1276             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1277         }
1278         catch (IncompatibleClassChangeError expected) {
1279             check_expected(expected, msg);
1280         }
1281         try {
1282             Caller.getFieldTargetSelfHostReflectively();
1283             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1284         }
1285         catch (IncompatibleClassChangeError expected) {
1286             check_expected(expected, msg);
1287         }
1288         try {
1289             Caller.getFieldTargetSelfHostMH();
1290             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1291         }
1292         catch (IncompatibleClassChangeError expected) {
1293             check_expected(expected, msg);
1294         }
1295 
1296         msg = &quot;Type TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;) is not a nest member&quot; +
1297             &quot; of TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1298         try {
1299             CallerSelfHost.getFieldTarget();
1300             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1301         }
1302         catch (IncompatibleClassChangeError expected) {
1303             check_expected(expected, msg);
1304         }
1305         msg = &quot;Type TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;) is not a nest member&quot; +
1306             &quot; of TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1307         try {
1308             CallerSelfHost.getFieldTargetSelfHost();
1309             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1310         }
1311         catch (IncompatibleClassChangeError expected) {
1312             check_expected(expected, msg);
1313         }
1314     }
1315 
1316     static void test_MissingHostGetField() throws Throwable {
1317         System.out.println(&quot;Testing for nest-host class that does not exist&quot;);
1318         String msg = &quot;Unable to load nest-host class (NoTargetMissingHost) of &quot; +
1319             &quot;TestNestmateMembership$TargetMissingHost&quot;;
1320         String cause_msg = &quot;NoTargetMissingHost&quot;;
1321         try {
1322             Caller.getFieldTargetMissingHost();
1323             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
1324         }
1325         catch (NoClassDefFoundError expected) {
1326             check_expected(expected, msg, cause_msg);
1327         }
1328         try {
1329             Caller.getFieldTargetMissingHostReflectively();
1330             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
1331         }
1332         catch (NoClassDefFoundError expected) {
1333             check_expected(expected, msg, cause_msg);
1334         }
1335         try {
1336             Caller.getFieldTargetMissingHostMH();
1337             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
1338         }
1339         catch (NoClassDefFoundError expected) {
1340             check_expected(expected, msg, cause_msg);
1341         }
1342 
1343         msg = &quot;Unable to load nest-host class (NoCallerMissingHost) of &quot; +
1344             &quot;TestNestmateMembership$CallerMissingHost&quot;;
1345         cause_msg = &quot;NoCallerMissingHost&quot;;
1346         try {
1347             CallerMissingHost.getFieldTarget();
1348             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
1349         }
1350         catch (NoClassDefFoundError expected) {
1351             check_expected(expected, msg, cause_msg);
1352         }
1353         msg = &quot;Unable to load nest-host class (NoCallerMissingHost) of &quot;+
1354             &quot;TestNestmateMembership$CallerMissingHost&quot;;
1355         cause_msg = &quot;NoCallerMissingHost&quot;;
1356         try {
1357             CallerMissingHost.getFieldTargetMissingHost();
1358             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
1359         }
1360         catch (NoClassDefFoundError expected) {
1361             check_expected(expected, msg, cause_msg);
1362         }
1363     }
1364 
1365     static void test_NotInstanceHostGetField() throws Throwable {
1366         System.out.println(&quot;Testing for nest-host class that is not an instance class&quot;);
1367         String msg = &quot;Type TestNestmateMembership$TargetNotInstanceHost (loader: &#39;app&#39;) is not a &quot;+
1368             &quot;nest member of [LInvalidNestHost; (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1369         try {
1370             Caller.getFieldTargetNotInstanceHost();
1371             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1372         }
1373         catch (IncompatibleClassChangeError expected) {
1374             check_expected(expected, msg);
1375         }
1376         try {
1377             Caller.getFieldTargetNotInstanceHostReflectively();
1378             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1379         }
1380         catch (IncompatibleClassChangeError expected) {
1381             check_expected(expected, msg);
1382         }
1383         try {
1384             Caller.getFieldTargetNotInstanceHostMH();
1385             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1386         }
1387         catch (IncompatibleClassChangeError expected) {
1388             check_expected(expected, msg);
1389         }
1390 
1391         msg = &quot;Type TestNestmateMembership$CallerNotInstanceHost (loader: &#39;app&#39;) is not a &quot;+
1392             &quot;nest member of [LInvalidNestHost; (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1393         try {
1394             CallerNotInstanceHost.getFieldTarget();
1395             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1396         }
1397         catch (IncompatibleClassChangeError expected) {
1398             check_expected(expected, msg);
1399         }
1400         msg = &quot;Type TestNestmateMembership$CallerNotInstanceHost (loader: &#39;app&#39;) is not a &quot;+
1401             &quot;nest member of [LInvalidNestHost; (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1402         try {
1403             CallerNotInstanceHost.getFieldTargetNotInstanceHost();
1404             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1405         }
1406         catch (IncompatibleClassChangeError expected) {
1407             check_expected(expected, msg);
1408         }
1409     }
1410 
1411     static void test_NotOurHostGetField() throws Throwable {
1412         System.out.println(&quot;Testing for nest-host class that does not list us in its nest&quot;);
1413         String msg = &quot;Type TestNestmateMembership$TargetNotOurHost (loader: &#39;app&#39;) is not a nest member&quot; +
1414             &quot; of InvalidNestHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1415         try {
1416             Caller.getFieldTargetNotOurHost();
1417             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1418         }
1419         catch (IncompatibleClassChangeError expected) {
1420             check_expected(expected, msg);
1421         }
1422         try {
1423             Caller.getFieldTargetNotOurHostReflectively();
1424             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1425         }
1426         catch (IncompatibleClassChangeError expected) {
1427             check_expected(expected, msg);
1428         }
1429         try {
1430             Caller.getFieldTargetNotOurHostMH();
1431             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1432         }
1433         catch (IncompatibleClassChangeError expected) {
1434             check_expected(expected, msg);
1435         }
1436 
1437         msg = &quot;Type TestNestmateMembership$CallerNotOurHost (loader: &#39;app&#39;) is not a nest member&quot; +
1438             &quot; of InvalidNestHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1439         try {
1440             CallerNotOurHost.getFieldTarget();
1441             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1442         }
1443         catch (IncompatibleClassChangeError expected) {
1444             check_expected(expected, msg);
1445         }
1446         msg = &quot;Type TestNestmateMembership$CallerNotOurHost (loader: &#39;app&#39;) is not a nest member&quot; +
1447             &quot; of InvalidNestHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1448         try {
1449             CallerNotOurHost.getFieldTargetNotOurHost();
1450             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1451         }
1452         catch (IncompatibleClassChangeError expected) {
1453             check_expected(expected, msg);
1454         }
1455     }
1456 
1457     static void test_WrongPackageHostGetField() {
1458         System.out.println(&quot;Testing for nest-host and nest-member in different packages&quot;);
1459         String msg = &quot;Type P2.PackagedNestHost2$Member (loader: &#39;app&#39;) is not a nest member of &quot; +
1460             &quot;P1.PackagedNestHost (loader: &#39;app&#39;): types are in different packages&quot;;
1461         try {
1462             P1.PackagedNestHost.doGetField();
1463             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1464         }
1465         catch (IncompatibleClassChangeError expected) {
1466             check_expected(expected, msg);
1467         }
1468         try {
1469             P2.PackagedNestHost2.Member.doGetField();
1470             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1471         }
1472         catch (IncompatibleClassChangeError expected) {
1473             check_expected(expected, msg);
1474         }
1475     }
1476 
1477    static void test_GoodPutField(){
1478         try {
1479             Caller.putFieldTarget();
1480         }
1481         catch (Exception e) {
1482             throw new Error(&quot;Unexpected exception on good field access: &quot; + e);
1483         }
1484     }
1485 
1486     static void test_NoHostPutField() throws Throwable {
1487         System.out.println(&quot;Testing for missing nest-host attribute&quot;);
1488         String msg = &quot;class TestNestmateMembership$Caller tried to access private &quot; +
1489             &quot;field TestNestmateMembership$TargetNoHost.f&quot;;
1490         try {
1491             Caller.putFieldTargetNoHost();
1492             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1493         }
1494         catch (IncompatibleClassChangeError expected) {
1495             check_expected(expected, msg);
1496         }
1497         msg = &quot;class TestNestmateMembership$Caller cannot access a member of class &quot; +
1498             &quot;TestNestmateMembership$TargetNoHost with modifiers \&quot;private static\&quot;&quot;;
1499         try {
1500             Caller.putFieldTargetNoHostReflectively();
1501             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
1502         }
1503         catch (IllegalAccessException expected) {
1504             check_expected(expected, msg);
1505         }
1506         msg = &quot;member is private: TestNestmateMembership$TargetNoHost.f/int/putStatic&quot;;
1507         try {
1508             Caller.putFieldTargetNoHostMH();
1509             throw new Error(&quot;Missing IllegalAccessException: &quot; + msg);
1510         }
1511         catch (IllegalAccessException expected) {
1512             check_expected(expected, msg);
1513         }
1514 
1515         msg = &quot;class TestNestmateMembership$CallerNoHost tried to access private &quot; +
1516             &quot;field TestNestmateMembership$Target.f&quot;;
1517         try {
1518             CallerNoHost.putFieldTarget();
1519             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1520         }
1521         catch (IncompatibleClassChangeError expected) {
1522             check_expected(expected, msg);
1523         }
1524         msg = &quot;class TestNestmateMembership$CallerNoHost tried to access private &quot; +
1525             &quot;field TestNestmateMembership$TargetNoHost.f&quot;;
1526         try {
1527             CallerNoHost.putFieldTargetNoHost();
1528             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1529         }
1530         catch (IncompatibleClassChangeError expected) {
1531             check_expected(expected, msg);
1532         }
1533     }
1534 
1535     static void test_SelfHostPutField() throws Throwable {
1536         System.out.println(&quot;Testing for class that lists itself as nest-host&quot;);
1537         String msg = &quot;Type TestNestmateMembership$TargetSelfHost (loader: &#39;app&#39;) is not a nest member&quot; +
1538             &quot; of TestNestmateMembership$TargetSelfHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1539         try {
1540             Caller.putFieldTargetSelfHost();
1541             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1542         }
1543         catch (IncompatibleClassChangeError expected) {
1544             check_expected(expected, msg);
1545         }
1546         try {
1547             Caller.putFieldTargetSelfHostReflectively();
1548             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1549         }
1550         catch (IncompatibleClassChangeError expected) {
1551             check_expected(expected, msg);
1552         }
1553         try {
1554             Caller.putFieldTargetSelfHostMH();
1555             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1556         }
1557         catch (IncompatibleClassChangeError expected) {
1558             check_expected(expected, msg);
1559         }
1560 
1561         msg = &quot;Type TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;) is not a nest member&quot; +
1562             &quot; of TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1563         try {
1564             CallerSelfHost.putFieldTarget();
1565             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1566         }
1567         catch (IncompatibleClassChangeError expected) {
1568             check_expected(expected, msg);
1569         }
1570         msg = &quot;Type TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;) is not a nest member&quot; +
1571             &quot; of TestNestmateMembership$CallerSelfHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1572         try {
1573             CallerSelfHost.putFieldTargetSelfHost();
1574             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1575         }
1576         catch (IncompatibleClassChangeError expected) {
1577             check_expected(expected, msg);
1578         }
1579     }
1580 
1581     static void test_MissingHostPutField() throws Throwable {
1582         System.out.println(&quot;Testing for nest-host class that does not exist&quot;);
1583         String msg = &quot;Unable to load nest-host class (NoTargetMissingHost) of &quot; +
1584             &quot;TestNestmateMembership$TargetMissingHost&quot;;
1585         String cause_msg = &quot;NoTargetMissingHost&quot;;
1586         try {
1587             Caller.putFieldTargetMissingHost();
1588             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
1589         }
1590         catch (NoClassDefFoundError expected) {
1591             check_expected(expected, msg, cause_msg);
1592         }
1593         try {
1594             Caller.putFieldTargetMissingHostReflectively();
1595             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
1596         }
1597         catch (NoClassDefFoundError expected) {
1598             check_expected(expected, msg, cause_msg);
1599         }
1600         try {
1601             Caller.putFieldTargetMissingHostMH();
1602             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
1603         }
1604         catch (NoClassDefFoundError expected) {
1605             check_expected(expected, msg, cause_msg);
1606         }
1607 
1608         msg = &quot;Unable to load nest-host class (NoCallerMissingHost) of &quot; +
1609             &quot;TestNestmateMembership$CallerMissingHost&quot;;
1610         cause_msg = &quot;NoCallerMissingHost&quot;;
1611         try {
1612             CallerMissingHost.putFieldTarget();
1613             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
1614         }
1615         catch (NoClassDefFoundError expected) {
1616             check_expected(expected, msg, cause_msg);
1617         }
1618         msg = &quot;Unable to load nest-host class (NoCallerMissingHost) of &quot;+
1619             &quot;TestNestmateMembership$CallerMissingHost&quot;;
1620         cause_msg = &quot;NoCallerMissingHost&quot;;
1621         try {
1622             CallerMissingHost.putFieldTargetMissingHost();
1623             throw new Error(&quot;Missing NoClassDefFoundError: &quot; + msg);
1624         }
1625         catch (NoClassDefFoundError expected) {
1626             check_expected(expected, msg, cause_msg);
1627         }
1628     }
1629 
1630     static void test_NotInstanceHostPutField() throws Throwable {
1631         System.out.println(&quot;Testing for nest-host class that is not an instance class&quot;);
1632         String msg = &quot;Type TestNestmateMembership$TargetNotInstanceHost (loader: &#39;app&#39;) is not a &quot;+
1633             &quot;nest member of [LInvalidNestHost; (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1634         try {
1635             Caller.putFieldTargetNotInstanceHost();
1636             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1637         }
1638         catch (IncompatibleClassChangeError expected) {
1639             check_expected(expected, msg);
1640         }
1641         try {
1642             Caller.putFieldTargetNotInstanceHostReflectively();
1643             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1644         }
1645         catch (IncompatibleClassChangeError expected) {
1646             check_expected(expected, msg);
1647         }
1648         try {
1649             Caller.putFieldTargetNotInstanceHostMH();
1650             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1651         }
1652         catch (IncompatibleClassChangeError expected) {
1653             check_expected(expected, msg);
1654         }
1655 
1656         msg = &quot;Type TestNestmateMembership$CallerNotInstanceHost (loader: &#39;app&#39;) is not a &quot;+
1657             &quot;nest member of [LInvalidNestHost; (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1658         try {
1659             CallerNotInstanceHost.putFieldTarget();
1660             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1661         }
1662         catch (IncompatibleClassChangeError expected) {
1663             check_expected(expected, msg);
1664         }
1665         msg = &quot;Type TestNestmateMembership$CallerNotInstanceHost (loader: &#39;app&#39;) is not a &quot;+
1666             &quot;nest member of [LInvalidNestHost; (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1667         try {
1668             CallerNotInstanceHost.putFieldTargetNotInstanceHost();
1669             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1670         }
1671         catch (IncompatibleClassChangeError expected) {
1672             check_expected(expected, msg);
1673         }
1674     }
1675 
1676     static void test_NotOurHostPutField() throws Throwable {
1677         System.out.println(&quot;Testing for nest-host class that does not list us in its nest&quot;);
1678         String msg = &quot;Type TestNestmateMembership$TargetNotOurHost (loader: &#39;app&#39;) is not a nest member&quot; +
1679             &quot; of InvalidNestHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1680         try {
1681             Caller.putFieldTargetNotOurHost();
1682             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1683         }
1684         catch (IncompatibleClassChangeError expected) {
1685             check_expected(expected, msg);
1686         }
1687         try {
1688             Caller.putFieldTargetNotOurHostReflectively();
1689             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1690         }
1691         catch (IncompatibleClassChangeError expected) {
1692             check_expected(expected, msg);
1693         }
1694         try {
1695             Caller.putFieldTargetNotOurHostMH();
1696             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1697         }
1698         catch (IncompatibleClassChangeError expected) {
1699             check_expected(expected, msg);
1700         }
1701 
1702         msg = &quot;Type TestNestmateMembership$CallerNotOurHost (loader: &#39;app&#39;) is not a nest member&quot; +
1703             &quot; of InvalidNestHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1704         try {
1705             CallerNotOurHost.putFieldTarget();
1706             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1707         }
1708         catch (IncompatibleClassChangeError expected) {
1709             check_expected(expected, msg);
1710         }
1711         msg = &quot;Type TestNestmateMembership$CallerNotOurHost (loader: &#39;app&#39;) is not a nest member&quot; +
1712             &quot; of InvalidNestHost (loader: &#39;app&#39;): current type is not listed as a nest member&quot;;
1713         try {
1714             CallerNotOurHost.putFieldTargetNotOurHost();
1715             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1716         }
1717         catch (IncompatibleClassChangeError expected) {
1718             check_expected(expected, msg);
1719         }
1720     }
1721 
1722     static void test_WrongPackageHostPutField() {
1723         System.out.println(&quot;Testing for nest-host and nest-member in different packages&quot;);
1724         String msg = &quot;Type P2.PackagedNestHost2$Member (loader: &#39;app&#39;) is not a nest member of &quot; +
1725             &quot;P1.PackagedNestHost (loader: &#39;app&#39;): types are in different packages&quot;;
1726         try {
1727             P1.PackagedNestHost.doPutField();
1728             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1729         }
1730         catch (IncompatibleClassChangeError expected) {
1731             check_expected(expected, msg);
1732         }
1733         try {
1734             P2.PackagedNestHost2.Member.doPutField();
1735             throw new Error(&quot;Missing IncompatibleClassChangeError: &quot; + msg);
1736         }
1737         catch (IncompatibleClassChangeError expected) {
1738             check_expected(expected, msg);
1739         }
1740     }
1741 
1742     // utilities
1743 
1744     static void check_expected(Throwable expected, String msg) {
1745         if (!expected.getMessage().contains(msg)) {
1746             throw new Error(&quot;Wrong &quot; + expected.getClass().getSimpleName() +&quot;: \&quot;&quot; +
1747                             expected.getMessage() + &quot;\&quot; does not contain \&quot;&quot; +
1748                             msg + &quot;\&quot;&quot;);
1749         }
1750         System.out.println(&quot;OK - got expected exception: &quot; + expected);
1751     }
1752 
1753     static void check_expected(Throwable expected, String msg, String cause_msg) {
1754         if (!expected.getMessage().contains(msg)) {
1755             throw new Error(&quot;Wrong &quot; + expected.getClass().getSimpleName() +&quot;: \&quot;&quot; +
1756                             expected.getMessage() + &quot;\&quot; does not contain \&quot;&quot; +
1757                             msg + &quot;\&quot;&quot;);
1758         }
1759         Throwable cause = expected.getCause();
1760         if (cause instanceof NoClassDefFoundError) {
1761             if (!cause.getMessage().contains(cause_msg)) {
1762                 throw new Error(expected.getClass().getSimpleName() +
1763                                 &quot; has wrong cause &quot; + cause.getClass().getSimpleName() +&quot;: \&quot;&quot; +
1764                                 cause.getMessage() + &quot;\&quot; does not contain \&quot;&quot; +
1765                                 cause_msg + &quot;\&quot;&quot;);
1766             }
1767         }
1768         else throw new Error(expected.getClass().getSimpleName() +
1769                              &quot; has wrong cause &quot; + cause.getClass().getSimpleName());
1770 
1771         System.out.println(&quot;OK - got expected exception: &quot; + expected +
1772                            &quot; with cause &quot; + cause);
1773     }
1774 
1775 }
    </pre>
  </body>
</html>
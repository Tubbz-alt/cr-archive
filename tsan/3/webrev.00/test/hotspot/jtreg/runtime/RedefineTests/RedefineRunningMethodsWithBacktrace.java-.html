<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/runtime/RedefineTests/RedefineRunningMethodsWithBacktrace.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8087315 8010319
 27  * @summary Get old method&#39;s stack trace elements after GC
 28  * @library /test/lib
 29  * @modules java.base/jdk.internal.misc
 30  * @modules java.compiler
 31  *          java.instrument
 32  *          jdk.jartool/sun.tools.jar
 33  * @run main RedefineClassHelper
 34  * @run main/othervm -javaagent:redefineagent.jar RedefineRunningMethodsWithBacktrace
 35  */
 36 
 37 import static jdk.test.lib.Asserts.*;
 38 
 39 // package access top-level class to avoid problem with RedefineClassHelper
 40 // and nested types.
 41 
 42 class RedefineRunningMethodsWithBacktrace_B {
 43     static int count1 = 0;
 44     static int count2 = 0;
 45     public static volatile boolean stop = false;
 46     static void localSleep() {
 47         try {
 48             Thread.sleep(10);//sleep for 10 ms
 49         } catch(InterruptedException ie) {
 50         }
 51     }
 52 
 53     public static void infinite() {
 54         while (!stop) { count1++; localSleep(); }
 55     }
 56     public static void throwable() {
 57         // add some stuff to the original constant pool
 58         String s1 = new String (&quot;string1&quot;);
 59         String s2 = new String (&quot;string2&quot;);
 60         String s3 = new String (&quot;string3&quot;);
 61         String s4 = new String (&quot;string4&quot;);
 62         String s5 = new String (&quot;string5&quot;);
 63         String s6 = new String (&quot;string6&quot;);
 64         String s7 = new String (&quot;string7&quot;);
 65         String s8 = new String (&quot;string8&quot;);
 66         String s9 = new String (&quot;string9&quot;);
 67         String s10 = new String (&quot;string10&quot;);
 68         String s11 = new String (&quot;string11&quot;);
 69         String s12 = new String (&quot;string12&quot;);
 70         String s13 = new String (&quot;string13&quot;);
 71         String s14 = new String (&quot;string14&quot;);
 72         String s15 = new String (&quot;string15&quot;);
 73         String s16 = new String (&quot;string16&quot;);
 74         String s17 = new String (&quot;string17&quot;);
 75         String s18 = new String (&quot;string18&quot;);
 76         String s19 = new String (&quot;string19&quot;);
 77         throw new RuntimeException(&quot;throwable called&quot;);
 78     }
 79 }
 80 
 81 public class RedefineRunningMethodsWithBacktrace {
 82 
 83     public static String newB =
 84                 &quot;class RedefineRunningMethodsWithBacktrace_B {&quot; +
 85                 &quot;   static int count1 = 0;&quot; +
 86                 &quot;   static int count2 = 0;&quot; +
 87                 &quot;   public static volatile boolean stop = false;&quot; +
 88                 &quot;  static void localSleep() { &quot; +
 89                 &quot;    try{ &quot; +
 90                 &quot;      Thread.sleep(10);&quot; +
 91                 &quot;    } catch(InterruptedException ie) { &quot; +
 92                 &quot;    } &quot; +
 93                 &quot; } &quot; +
 94                 &quot;   public static void infinite() { &quot; +
 95                 &quot;       System.out.println(\&quot;infinite called\&quot;);&quot; +
 96                 &quot;   }&quot; +
 97                 &quot;   public static void throwable() { &quot; +
 98                 &quot;       throw new RuntimeException(\&quot;throwable called\&quot;);&quot; +
 99                 &quot;   }&quot; +
100                 &quot;}&quot;;
101 
102     public static String evenNewerB =
103                 &quot;class RedefineRunningMethodsWithBacktrace_B {&quot; +
104                 &quot;   static int count1 = 0;&quot; +
105                 &quot;   static int count2 = 0;&quot; +
106                 &quot;   public static volatile boolean stop = false;&quot; +
107                 &quot;  static void localSleep() { &quot; +
108                 &quot;    try{ &quot; +
109                 &quot;      Thread.sleep(1);&quot; +
110                 &quot;    } catch(InterruptedException ie) { &quot; +
111                 &quot;    } &quot; +
112                 &quot; } &quot; +
113                 &quot;   public static void infinite() { }&quot; +
114                 &quot;   public static void throwable() { &quot; +
115                 &quot;       throw new RuntimeException(\&quot;throwable called\&quot;);&quot; +
116                 &quot;   }&quot; +
117                 &quot;}&quot;;
118 
119     private static void touchRedefinedMethodInBacktrace(Throwable throwable) {
120         System.out.println(&quot;touchRedefinedMethodInBacktrace: &quot;);
121         throwable.printStackTrace();  // this actually crashes with the bug in
122                                       // java_lang_StackTraceElement::create()
123 
124         // Make sure that we can convert the backtrace, which is referring to
125         // the redefined method, to a  StrackTraceElement[] without crashing.
126         StackTraceElement[] stackTrace = throwable.getStackTrace();
127         for (int i = 0; i &lt; stackTrace.length; i++) {
128             StackTraceElement frame = stackTrace[i];
129             assertNotNull(frame.getClassName(),
130               &quot;\nTest failed: trace[&quot; + i + &quot;].getClassName() returned null&quot;);
131             assertNotNull(frame.getMethodName(),
132               &quot;\nTest failed: trace[&quot; + i + &quot;].getMethodName() returned null&quot;);
133         }
134     }
135 
136     private static Throwable getThrowableInB() {
137         Throwable t = null;
138         try {
139             RedefineRunningMethodsWithBacktrace_B.throwable();
140         } catch (Exception e) {
141             t = e;
142             // Don&#39;t print here because Throwable will cache the constructed stacktrace
143             // e.printStackTrace();
144         }
145         return t;
146     }
147 
148 
149     public static void main(String[] args) throws Exception {
150 
151         new Thread() {
152             public void run() {
153                 RedefineRunningMethodsWithBacktrace_B.infinite();
154             }
155         }.start();
156 
157         Throwable t1 = getThrowableInB();
158 
159         RedefineClassHelper.redefineClass(RedefineRunningMethodsWithBacktrace_B.class, newB);
160 
161         System.gc();
162 
163         Throwable t2 = getThrowableInB();
164 
165         RedefineRunningMethodsWithBacktrace_B.infinite();
166 
167         for (int i = 0; i &lt; 20 ; i++) {
168             String s = new String(&quot;some garbage&quot;);
169             System.gc();
170         }
171 
172         RedefineClassHelper.redefineClass(RedefineRunningMethodsWithBacktrace_B.class, evenNewerB);
173         System.gc();
174 
175         Throwable t3 = getThrowableInB();
176 
177         for (int i = 0; i &lt; 20 ; i++) {
178             RedefineRunningMethodsWithBacktrace_B.infinite();
179             String s = new String(&quot;some garbage&quot;);
180             System.gc();
181         }
182 
183         touchRedefinedMethodInBacktrace(t1);
184         touchRedefinedMethodInBacktrace(t2);
185         touchRedefinedMethodInBacktrace(t3);
186 
187         // purge should clean everything up.
188         RedefineRunningMethodsWithBacktrace_B.stop = true;
189 
190         for (int i = 0; i &lt; 20 ; i++) {
191             RedefineRunningMethodsWithBacktrace_B.infinite();
192             String s = new String(&quot;some garbage&quot;);
193             System.gc();
194         }
195     }
196 }
    </pre>
  </body>
</html>
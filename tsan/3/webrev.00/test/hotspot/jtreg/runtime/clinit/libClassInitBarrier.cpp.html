<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/clinit/libClassInitBarrier.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &lt;jni.h&gt;
 25 
 26 static jmethodID methodId;
 27 
 28 static jclass test_class_A;
 29 static jclass test_class_B;
 30 
 31 static jmethodID test_staticM_id;
 32 static jmethodID test_staticS_id;
 33 static jmethodID test_staticN_id;
 34 static jmethodID test_A_m_id;
 35 
 36 static jfieldID test_staticF_id;
 37 static jfieldID test_A_f_id;
 38 
 39 extern &quot;C&quot; {
 40     JNIEXPORT jboolean JNICALL Java_ClassInitBarrier_init(JNIEnv* env, jclass cls) {
 41         jclass runnable = env-&gt;FindClass(&quot;java/lang/Runnable&quot;);
 42         if (runnable == NULL)  return JNI_FALSE;
 43 
 44         methodId = env-&gt;GetMethodID(runnable, &quot;run&quot;, &quot;()V&quot;);
 45         if (methodId == NULL)  return JNI_FALSE;
 46 
 47         return JNI_TRUE;
 48     }
 49 
 50     JNIEXPORT jboolean JNICALL Java_ClassInitBarrier_00024Test_00024A_init(JNIEnv* env, jclass cls, jclass arg1) {
 51         test_class_A = (jclass)env-&gt;NewGlobalRef(cls);
 52         if (test_class_A == NULL)  return JNI_FALSE;
 53 
 54         test_class_B = (jclass)env-&gt;NewGlobalRef(arg1);
 55         if (test_class_B == NULL)  return JNI_FALSE;
 56 
 57         test_staticM_id = env-&gt;GetStaticMethodID(test_class_A, &quot;staticM&quot;, &quot;(Ljava/lang/Runnable;)V&quot;);
 58         if (test_staticM_id == NULL)  return JNI_FALSE;
 59 
 60         test_staticS_id = env-&gt;GetStaticMethodID(test_class_A, &quot;staticS&quot;, &quot;(Ljava/lang/Runnable;)V&quot;);
 61         if (test_staticS_id == NULL)  return JNI_FALSE;
 62 
 63         test_staticN_id = env-&gt;GetStaticMethodID(test_class_A, &quot;staticN&quot;, &quot;(Ljava/lang/Runnable;)V&quot;);
 64         if (test_staticN_id == NULL)  return JNI_FALSE;
 65 
 66         test_A_m_id = env-&gt;GetMethodID(test_class_A, &quot;m&quot;, &quot;()V&quot;);
 67         if (test_A_m_id == NULL)  return JNI_FALSE;
 68 
 69         test_staticF_id = env-&gt;GetStaticFieldID(test_class_A, &quot;staticF&quot;, &quot;I&quot;);
 70         if (test_staticF_id == NULL)  return JNI_FALSE;
 71 
 72         test_A_f_id = env-&gt;GetFieldID(test_class_A, &quot;f&quot;, &quot;I&quot;);
 73         if (test_A_f_id == NULL)  return JNI_FALSE;
 74 
 75         return JNI_TRUE;
 76     }
 77 
 78     JNIEXPORT void JNICALL Java_ClassInitBarrier_00024Test_00024A_staticN(JNIEnv* env, jclass cls, jobject action) {
 79         env-&gt;CallVoidMethod(action, methodId);
 80     }
 81 
 82     JNIEXPORT void JNICALL Java_ClassInitBarrier_00024Test_testInvokeStaticJNI(JNIEnv* env, jclass cls, jobject action) {
 83         env-&gt;CallStaticVoidMethod(test_class_A, test_staticM_id, action);
 84     }
 85 
 86     JNIEXPORT void JNICALL Java_ClassInitBarrier_00024Test_testInvokeStaticSyncJNI(JNIEnv* env, jclass cls, jobject action) {
 87         env-&gt;CallStaticVoidMethod(test_class_A, test_staticS_id, action);
 88     }
 89 
 90     JNIEXPORT void JNICALL Java_ClassInitBarrier_00024Test_testInvokeStaticNativeJNI(JNIEnv* env, jclass cls, jobject action) {
 91         env-&gt;CallStaticVoidMethod(test_class_A, test_staticN_id, action);
 92     }
 93 
 94     JNIEXPORT jint JNICALL Java_ClassInitBarrier_00024Test_testGetStaticJNI(JNIEnv* env, jclass cls, jobject action) {
 95         jint v = env-&gt;GetStaticIntField(test_class_A, test_staticF_id); // int v = A.staticF;
 96         env-&gt;CallVoidMethod(action, methodId);                          // action.run();
 97         return v;
 98     }
 99 
100     JNIEXPORT void JNICALL Java_ClassInitBarrier_00024Test_testPutStaticJNI(JNIEnv* env, jclass cls, jobject action) {
101         env-&gt;SetStaticIntField(test_class_A, test_staticF_id, 1); // A.staticF = 1;
102         env-&gt;CallVoidMethod(action, methodId);                    // action.run();
103     }
104 
105     JNIEXPORT jobject JNICALL Java_ClassInitBarrier_00024Test_testNewInstanceAJNI(JNIEnv* env, jclass cls, jobject action) {
106         jobject obj = env-&gt;AllocObject(test_class_A); // A obj = new A();
107         if (env-&gt;ExceptionOccurred()) {
108           return NULL;
109         } else if (obj == NULL) {
110           jclass errorClass = env-&gt;FindClass(&quot;java/lang/AssertionError&quot;);
111           int ret = env-&gt;ThrowNew(errorClass, &quot;JNI: AllocObject: allocation failed, but no exception thrown&quot;);
112           return NULL;
113         }
114         env-&gt;CallVoidMethod(action, methodId);        // action.run();
115         return obj;
116     }
117 
118     JNIEXPORT jobject JNICALL Java_ClassInitBarrier_00024Test_testNewInstanceBJNI(JNIEnv* env, jclass cls, jobject action) {
119         jobject obj = env-&gt;AllocObject(test_class_B); // B obj = new B();
120         if (env-&gt;ExceptionOccurred()) {
121           return NULL;
122         } else if (obj == NULL) {
123           jclass errorClass = env-&gt;FindClass(&quot;java/lang/AssertionError&quot;);
124           int ret = env-&gt;ThrowNew(errorClass, &quot;JNI: AllocObject: allocation failed, but no exception thrown&quot;);
125           return NULL;
126         }
127         env-&gt;CallVoidMethod(action, methodId);        // action.run();
128         return obj;
129     }
130 
131     JNIEXPORT jint JNICALL Java_ClassInitBarrier_00024Test_testGetFieldJNI(JNIEnv* env, jclass cls, jobject recv, jobject action) {
132         jint v = env-&gt;GetIntField(recv, test_A_f_id); // int v = recv.f;
133         env-&gt;CallVoidMethod(action, methodId);        // action.run();
134         return v;
135     }
136 
137     JNIEXPORT void JNICALL Java_ClassInitBarrier_00024Test_testPutFieldJNI(JNIEnv* env, jclass cls, jobject recv, jobject action) {
138         env-&gt;SetIntField(recv, test_A_f_id, 1); // A.staticF = 1;
139         env-&gt;CallVoidMethod(action, methodId);  // action.run();
140     }
141 
142     JNIEXPORT void JNICALL Java_ClassInitBarrier_00024Test_testInvokeVirtualJNI(JNIEnv* env, jclass cls, jobject recv, jobject action) {
143         env-&gt;CallVoidMethod(recv, test_A_m_id); // recv.m();
144         if (env-&gt;ExceptionOccurred()) {
145             return;
146         }
147         env-&gt;CallVoidMethod(action, methodId);  // action.run();
148     }
149 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/runtime/Metaspace/DefineClass.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../MemberName/MemberNameLeak.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="PrintMetaspaceDcmd.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/runtime/Metaspace/DefineClass.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2017 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /**
 26  * @test
 27  * @bug 8173743
 28  * @requires vm.compMode != &quot;Xcomp&quot;
 29  * @summary Failures during class definition can lead to memory leaks in metaspace
 30  * @requires vm.opt.final.ClassUnloading
 31  * @library /test/lib
<span class="line-modified"> 32  * @run main/othervm test.DefineClass defineClass</span>
<span class="line-modified"> 33  * @run main/othervm test.DefineClass defineSystemClass</span>
<span class="line-modified"> 34  * @run main/othervm -XX:+AllowParallelDefineClass</span>
<span class="line-modified"> 35                      test.DefineClass defineClassParallel</span>
<span class="line-modified"> 36  * @run main/othervm -XX:-AllowParallelDefineClass</span>
<span class="line-modified"> 37                      test.DefineClass defineClassParallel</span>
<span class="line-modified"> 38  * @run main/othervm -Djdk.attach.allowAttachSelf test.DefineClass redefineClass</span>
<span class="line-modified"> 39  * @run main/othervm -Djdk.attach.allowAttachSelf test.DefineClass redefineClassWithError</span>







 40  * @author volker.simonis@gmail.com
 41  */
 42 
 43 package test;
 44 
 45 import java.io.ByteArrayOutputStream;
 46 import java.io.File;
 47 import java.io.FileOutputStream;
 48 import java.io.InputStream;
 49 import java.lang.instrument.ClassDefinition;
 50 import java.lang.instrument.Instrumentation;
<span class="line-removed"> 51 import java.lang.management.ManagementFactory;</span>
<span class="line-removed"> 52 import java.util.Scanner;</span>
 53 import java.util.concurrent.CountDownLatch;
 54 import java.util.jar.Attributes;
 55 import java.util.jar.JarEntry;
 56 import java.util.jar.JarOutputStream;
 57 import java.util.jar.Manifest;
 58 
<span class="line-removed"> 59 import javax.management.MBeanServer;</span>
<span class="line-removed"> 60 import javax.management.ObjectName;</span>
<span class="line-removed"> 61 </span>
 62 import com.sun.tools.attach.VirtualMachine;
 63 
 64 import jdk.test.lib.process.ProcessTools;

 65 
 66 public class DefineClass {
 67 
 68     private static Instrumentation instrumentation;
 69 
 70     public void getID(CountDownLatch start, CountDownLatch stop) {
 71         String id = &quot;AAAAAAAA&quot;;
 72         System.out.println(id);
 73         try {
 74             // Signal that we&#39;ve entered the activation..
 75             start.countDown();
 76             //..and wait until we can leave it.
 77             stop.await();
 78         } catch (InterruptedException e) {
 79             e.printStackTrace();
 80         }
 81         System.out.println(id);
 82         return;
 83     }
 84 
</pre>
<hr />
<pre>
188         return getStringIndex(needle, buf, 0);
189     }
190 
191     private static int getStringIndex(String needle, byte[] buf, int offset) {
192         outer:
193         for (int i = offset; i &lt; buf.length - offset - needle.length(); i++) {
194             for (int j = 0; j &lt; needle.length(); j++) {
195                 if (buf[i + j] != (byte)needle.charAt(j)) continue outer;
196             }
197             return i;
198         }
199         return 0;
200     }
201 
202     private static void replaceString(byte[] buf, String name, int index) {
203         for (int i = index; i &lt; index + name.length(); i++) {
204             buf[i] = (byte)name.charAt(i - index);
205         }
206     }
207 
<span class="line-modified">208     private static MBeanServer mbserver = ManagementFactory.getPlatformMBeanServer();</span>
<span class="line-removed">209 </span>
<span class="line-removed">210     private static int getClassStats(String pattern) {</span>
<span class="line-removed">211         try {</span>
<span class="line-removed">212             ObjectName diagCmd = new ObjectName(&quot;com.sun.management:type=DiagnosticCommand&quot;);</span>
213 
<span class="line-modified">214             String result = (String)mbserver.invoke(diagCmd , &quot;gcClassStats&quot; , new Object[] { null }, new String[] {String[].class.getName()});</span>
<span class="line-modified">215             int count = 0;</span>
<span class="line-removed">216             try (Scanner s = new Scanner(result)) {</span>
<span class="line-removed">217                 if (s.hasNextLine()) {</span>
<span class="line-removed">218                     System.out.println(s.nextLine());</span>
<span class="line-removed">219                 }</span>
<span class="line-removed">220                 while (s.hasNextLine()) {</span>
<span class="line-removed">221                     String l = s.nextLine();</span>
<span class="line-removed">222                     if (l.endsWith(pattern)) {</span>
<span class="line-removed">223                         count++;</span>
<span class="line-removed">224                         System.out.println(l);</span>
<span class="line-removed">225                     }</span>
<span class="line-removed">226                 }</span>
<span class="line-removed">227             }</span>
<span class="line-removed">228             return count;</span>
<span class="line-removed">229         }</span>
<span class="line-removed">230         catch (Exception e) {</span>
<span class="line-removed">231             throw new RuntimeException(&quot;Test failed because we can&#39;t read the class statistics!&quot;, e);</span>
<span class="line-removed">232         }</span>
<span class="line-removed">233     }</span>
<span class="line-removed">234 </span>
<span class="line-removed">235     private static void printClassStats(int expectedCount, boolean reportError) {</span>
<span class="line-removed">236         int count = getClassStats(&quot;DefineClass&quot;);</span>
237         String res = &quot;Should have &quot; + expectedCount +
238                      &quot; DefineClass instances and we have: &quot; + count;
239         System.out.println(res);
240         if (reportError &amp;&amp; count != expectedCount) {
241             throw new RuntimeException(res);
242         }
243     }
244 
245     public static final int ITERATIONS = 10;
246 















247     public static void main(String[] args) throws Exception {
248         String myName = DefineClass.class.getName();
249         byte[] buf = getBytecodes(myName.substring(myName.lastIndexOf(&quot;.&quot;) + 1));
250         int iterations = (args.length &gt; 1 ? Integer.parseInt(args[1]) : ITERATIONS);
251 
252         if (args.length == 0 || &quot;defineClass&quot;.equals(args[0])) {
253             MyClassLoader cl = new MyClassLoader();
254             for (int i = 0; i &lt; iterations; i++) {
255                 try {
256                     @SuppressWarnings(&quot;unchecked&quot;)
257                     Class&lt;DefineClass&gt; dc = (Class&lt;DefineClass&gt;) cl.myDefineClass(myName, buf, 0, buf.length);
258                     System.out.println(dc);
259                 }
260                 catch (LinkageError jle) {
261                     // Can only define once!
262                     if (i == 0) throw new Exception(&quot;Should succeed the first time.&quot;);
263                 }
264             }
265             // We expect to have two instances of DefineClass here: the initial version in which we are
266             // executing and another version which was loaded into our own classloader &#39;MyClassLoader&#39;.
267             // All the subsequent attempts to reload DefineClass into our &#39;MyClassLoader&#39; should have failed.
<span class="line-modified">268             printClassStats(2, false);</span>
<span class="line-modified">269             System.gc();</span>
<span class="line-modified">270             System.out.println(&quot;System.gc()&quot;);</span>
<span class="line-modified">271             // At least after System.gc() the failed loading attempts should leave no instances around!</span>
<span class="line-removed">272             printClassStats(2, true);</span>
273         }
274         else if (&quot;defineSystemClass&quot;.equals(args[0])) {
275             MyClassLoader cl = new MyClassLoader();
276             int index = getStringIndex(&quot;test/DefineClass&quot;, buf);
277             replaceString(buf, &quot;java/DefineClass&quot;, index);
278             while ((index = getStringIndex(&quot;Ltest/DefineClass;&quot;, buf, index + 1)) != 0) {
279                 replaceString(buf, &quot;Ljava/DefineClass;&quot;, index);
280             }
281             index = getStringIndex(&quot;test.DefineClass&quot;, buf);
282             replaceString(buf, &quot;java.DefineClass&quot;, index);
283 
284             for (int i = 0; i &lt; iterations; i++) {
285                 try {
286                     @SuppressWarnings(&quot;unchecked&quot;)
287                     Class&lt;DefineClass&gt; dc = (Class&lt;DefineClass&gt;) cl.myDefineClass(null, buf, 0, buf.length);
288                     throw new RuntimeException(&quot;Defining a class in the &#39;java&#39; package should fail!&quot;);
289                 }
290                 catch (java.lang.SecurityException jlse) {
291                     // Expected, because we&#39;re not allowed to define a class in the &#39;java&#39; package
292                 }
293             }
294             // We expect to stay with one (the initial) instances of DefineClass.
295             // All the subsequent attempts to reload DefineClass into the &#39;java&#39; package should have failed.
<span class="line-modified">296             printClassStats(1, false);</span>
<span class="line-modified">297             System.gc();</span>
<span class="line-modified">298             System.out.println(&quot;System.gc()&quot;);</span>
<span class="line-removed">299             // At least after System.gc() the failed loading attempts should leave no instances around!</span>
<span class="line-removed">300             printClassStats(1, true);</span>
301         }
302         else if (&quot;defineClassParallel&quot;.equals(args[0])) {
303             MyParallelClassLoader pcl = new MyParallelClassLoader();
304             CountDownLatch stop = new CountDownLatch(1);
305 
306             Thread[] threads = new Thread[iterations];
307             for (int i = 0; i &lt; iterations; i++) {
308                 (threads[i] = new ParallelLoadingThread(pcl, buf, stop)).start();
309             }
310             stop.countDown(); // start parallel class loading..
311             // ..and wait until all threads loaded the class
312             for (int i = 0; i &lt; iterations; i++) {
313                 threads[i].join();
314             }
315             System.out.print(&quot;Counted &quot; + pcl.getLinkageErrors() + &quot; LinkageErrors &quot;);
316             System.out.println(pcl.getLinkageErrors() == 0 ?
317                     &quot;&quot; : &quot;(use -XX:+AllowParallelDefineClass to avoid this)&quot;);
<span class="line-removed">318             System.gc();</span>
<span class="line-removed">319             System.out.println(&quot;System.gc()&quot;);</span>
320             // After System.gc() we expect to remain with two instances: one is the initial version which is
321             // kept alive by this main method and another one in the parallel class loader.
<span class="line-modified">322             printClassStats(2, true);</span>
323         }
324         else if (&quot;redefineClass&quot;.equals(args[0])) {
325             loadInstrumentationAgent(myName, buf);
326             int index = getStringIndex(&quot;AAAAAAAA&quot;, buf);
327             CountDownLatch stop = new CountDownLatch(1);
328 
329             Thread[] threads = new Thread[iterations];
330             for (int i = 0; i &lt; iterations; i++) {
331                 buf[index] = (byte) (&#39;A&#39; + i + 1); // Change string constant in getID() which is legal in redefinition
332                 instrumentation.redefineClasses(new ClassDefinition(DefineClass.class, buf));
333                 DefineClass dc = DefineClass.class.newInstance();
334                 CountDownLatch start = new CountDownLatch(1);
335                 (threads[i] = new MyThread(dc, start, stop)).start();
336                 start.await(); // Wait until the new thread entered the getID() method
337             }
338             // We expect to have one instance for each redefinition because they are all kept alive by an activation
339             // plus the initial version which is kept active by this main method.
<span class="line-modified">340             printClassStats(iterations + 1, false);</span>
341             stop.countDown(); // Let all threads leave the DefineClass.getID() activation..
342             // ..and wait until really all of them returned from DefineClass.getID()
343             for (int i = 0; i &lt; iterations; i++) {
344                 threads[i].join();
345             }
<span class="line-removed">346             System.gc();</span>
<span class="line-removed">347             System.out.println(&quot;System.gc()&quot;);</span>
348             // After System.gc() we expect to remain with two instances: one is the initial version which is
349             // kept alive by this main method and another one which is the latest redefined version.
<span class="line-modified">350             printClassStats(2, true);</span>
351         }
352         else if (&quot;redefineClassWithError&quot;.equals(args[0])) {
353             loadInstrumentationAgent(myName, buf);
354             int index = getStringIndex(&quot;getID&quot;, buf);
355 
356             for (int i = 0; i &lt; iterations; i++) {
357                 buf[index] = (byte) &#39;X&#39;; // Change getID() to XetID() which is illegal in redefinition
358                 try {
359                     instrumentation.redefineClasses(new ClassDefinition(DefineClass.class, buf));
360                     throw new RuntimeException(&quot;Class redefinition isn&#39;t allowed to change method names!&quot;);
361                 }
362                 catch (UnsupportedOperationException uoe) {
363                     // Expected because redefinition can&#39;t change the name of methods
364                 }
365             }
366             // We expect just a single DefineClass instance because failed redefinitions should
367             // leave no garbage around.
<span class="line-modified">368             printClassStats(1, false);</span>
<span class="line-modified">369             System.gc();</span>
<span class="line-removed">370             System.out.println(&quot;System.gc()&quot;);</span>
371             // At least after a System.gc() we should definitely stay with a single instance!
<span class="line-modified">372             printClassStats(1, true);</span>
373         }
374     }
375 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2017 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /**
 26  * @test
 27  * @bug 8173743
 28  * @requires vm.compMode != &quot;Xcomp&quot;
 29  * @summary Failures during class definition can lead to memory leaks in metaspace
 30  * @requires vm.opt.final.ClassUnloading
 31  * @library /test/lib
<span class="line-modified"> 32  * @build sun.hotspot.WhiteBox</span>
<span class="line-modified"> 33  * @run main ClassFileInstaller sun.hotspot.WhiteBox</span>
<span class="line-modified"> 34  *                              sun.hotspot.WhiteBox$WhiteBoxPermission</span>
<span class="line-modified"> 35  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI test.DefineClass defineClass</span>
<span class="line-modified"> 36  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI test.DefineClass defineSystemClass</span>
<span class="line-modified"> 37  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI</span>
<span class="line-modified"> 38  *                   -XX:+AllowParallelDefineClass</span>
<span class="line-modified"> 39  *                   test.DefineClass defineClassParallel</span>
<span class="line-added"> 40  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI</span>
<span class="line-added"> 41  *                   -XX:-AllowParallelDefineClass</span>
<span class="line-added"> 42  *                   test.DefineClass defineClassParallel</span>
<span class="line-added"> 43  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI</span>
<span class="line-added"> 44  *                   -Djdk.attach.allowAttachSelf test.DefineClass redefineClass</span>
<span class="line-added"> 45  * @run main/othervm -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI</span>
<span class="line-added"> 46  *                   -Djdk.attach.allowAttachSelf test.DefineClass redefineClassWithError</span>
 47  * @author volker.simonis@gmail.com
 48  */
 49 
 50 package test;
 51 
 52 import java.io.ByteArrayOutputStream;
 53 import java.io.File;
 54 import java.io.FileOutputStream;
 55 import java.io.InputStream;
 56 import java.lang.instrument.ClassDefinition;
 57 import java.lang.instrument.Instrumentation;


 58 import java.util.concurrent.CountDownLatch;
 59 import java.util.jar.Attributes;
 60 import java.util.jar.JarEntry;
 61 import java.util.jar.JarOutputStream;
 62 import java.util.jar.Manifest;
 63 



 64 import com.sun.tools.attach.VirtualMachine;
 65 
 66 import jdk.test.lib.process.ProcessTools;
<span class="line-added"> 67 import sun.hotspot.WhiteBox;</span>
 68 
 69 public class DefineClass {
 70 
 71     private static Instrumentation instrumentation;
 72 
 73     public void getID(CountDownLatch start, CountDownLatch stop) {
 74         String id = &quot;AAAAAAAA&quot;;
 75         System.out.println(id);
 76         try {
 77             // Signal that we&#39;ve entered the activation..
 78             start.countDown();
 79             //..and wait until we can leave it.
 80             stop.await();
 81         } catch (InterruptedException e) {
 82             e.printStackTrace();
 83         }
 84         System.out.println(id);
 85         return;
 86     }
 87 
</pre>
<hr />
<pre>
191         return getStringIndex(needle, buf, 0);
192     }
193 
194     private static int getStringIndex(String needle, byte[] buf, int offset) {
195         outer:
196         for (int i = offset; i &lt; buf.length - offset - needle.length(); i++) {
197             for (int j = 0; j &lt; needle.length(); j++) {
198                 if (buf[i + j] != (byte)needle.charAt(j)) continue outer;
199             }
200             return i;
201         }
202         return 0;
203     }
204 
205     private static void replaceString(byte[] buf, String name, int index) {
206         for (int i = index; i &lt; index + name.length(); i++) {
207             buf[i] = (byte)name.charAt(i - index);
208         }
209     }
210 
<span class="line-modified">211     public static WhiteBox wb = WhiteBox.getWhiteBox();</span>




212 
<span class="line-modified">213     private static void checkClasses(int expectedCount, boolean reportError) {</span>
<span class="line-modified">214         int count = wb.countAliveClasses(&quot;test.DefineClass&quot;);</span>





















215         String res = &quot;Should have &quot; + expectedCount +
216                      &quot; DefineClass instances and we have: &quot; + count;
217         System.out.println(res);
218         if (reportError &amp;&amp; count != expectedCount) {
219             throw new RuntimeException(res);
220         }
221     }
222 
223     public static final int ITERATIONS = 10;
224 
<span class="line-added">225     private static void checkClassesAfterGC(int expectedCount) {</span>
<span class="line-added">226         // The first System.gc() doesn&#39;t clean metaspaces but triggers cleaning</span>
<span class="line-added">227         // for the next safepoint.</span>
<span class="line-added">228         // In the future the ServiceThread may clean metaspaces, but this loop</span>
<span class="line-added">229         // should give it enough time to run, when that is changed.</span>
<span class="line-added">230         // We might need to revisit this test though.</span>
<span class="line-added">231         for (int i = 0; i &lt; ITERATIONS; i++) {</span>
<span class="line-added">232             System.gc();</span>
<span class="line-added">233             System.out.println(&quot;System.gc()&quot;);</span>
<span class="line-added">234             // Break if the GC has cleaned metaspace before iterations.</span>
<span class="line-added">235             if (wb.countAliveClasses(&quot;test.DefineClass&quot;) == expectedCount) break;</span>
<span class="line-added">236         }</span>
<span class="line-added">237         checkClasses(expectedCount, true);</span>
<span class="line-added">238     }</span>
<span class="line-added">239 </span>
240     public static void main(String[] args) throws Exception {
241         String myName = DefineClass.class.getName();
242         byte[] buf = getBytecodes(myName.substring(myName.lastIndexOf(&quot;.&quot;) + 1));
243         int iterations = (args.length &gt; 1 ? Integer.parseInt(args[1]) : ITERATIONS);
244 
245         if (args.length == 0 || &quot;defineClass&quot;.equals(args[0])) {
246             MyClassLoader cl = new MyClassLoader();
247             for (int i = 0; i &lt; iterations; i++) {
248                 try {
249                     @SuppressWarnings(&quot;unchecked&quot;)
250                     Class&lt;DefineClass&gt; dc = (Class&lt;DefineClass&gt;) cl.myDefineClass(myName, buf, 0, buf.length);
251                     System.out.println(dc);
252                 }
253                 catch (LinkageError jle) {
254                     // Can only define once!
255                     if (i == 0) throw new Exception(&quot;Should succeed the first time.&quot;);
256                 }
257             }
258             // We expect to have two instances of DefineClass here: the initial version in which we are
259             // executing and another version which was loaded into our own classloader &#39;MyClassLoader&#39;.
260             // All the subsequent attempts to reload DefineClass into our &#39;MyClassLoader&#39; should have failed.
<span class="line-modified">261             // The ClassLoaderDataGraph has the failed instances recorded at least until the next GC.</span>
<span class="line-modified">262             checkClasses(2, false);</span>
<span class="line-modified">263             // At least after some System.gc() the failed loading attempts should leave no instances around!</span>
<span class="line-modified">264             checkClassesAfterGC(2);</span>

265         }
266         else if (&quot;defineSystemClass&quot;.equals(args[0])) {
267             MyClassLoader cl = new MyClassLoader();
268             int index = getStringIndex(&quot;test/DefineClass&quot;, buf);
269             replaceString(buf, &quot;java/DefineClass&quot;, index);
270             while ((index = getStringIndex(&quot;Ltest/DefineClass;&quot;, buf, index + 1)) != 0) {
271                 replaceString(buf, &quot;Ljava/DefineClass;&quot;, index);
272             }
273             index = getStringIndex(&quot;test.DefineClass&quot;, buf);
274             replaceString(buf, &quot;java.DefineClass&quot;, index);
275 
276             for (int i = 0; i &lt; iterations; i++) {
277                 try {
278                     @SuppressWarnings(&quot;unchecked&quot;)
279                     Class&lt;DefineClass&gt; dc = (Class&lt;DefineClass&gt;) cl.myDefineClass(null, buf, 0, buf.length);
280                     throw new RuntimeException(&quot;Defining a class in the &#39;java&#39; package should fail!&quot;);
281                 }
282                 catch (java.lang.SecurityException jlse) {
283                     // Expected, because we&#39;re not allowed to define a class in the &#39;java&#39; package
284                 }
285             }
286             // We expect to stay with one (the initial) instances of DefineClass.
287             // All the subsequent attempts to reload DefineClass into the &#39;java&#39; package should have failed.
<span class="line-modified">288             // The ClassLoaderDataGraph has the failed instances recorded at least until the next GC.</span>
<span class="line-modified">289             checkClasses(1, false);</span>
<span class="line-modified">290             checkClassesAfterGC(1);</span>


291         }
292         else if (&quot;defineClassParallel&quot;.equals(args[0])) {
293             MyParallelClassLoader pcl = new MyParallelClassLoader();
294             CountDownLatch stop = new CountDownLatch(1);
295 
296             Thread[] threads = new Thread[iterations];
297             for (int i = 0; i &lt; iterations; i++) {
298                 (threads[i] = new ParallelLoadingThread(pcl, buf, stop)).start();
299             }
300             stop.countDown(); // start parallel class loading..
301             // ..and wait until all threads loaded the class
302             for (int i = 0; i &lt; iterations; i++) {
303                 threads[i].join();
304             }
305             System.out.print(&quot;Counted &quot; + pcl.getLinkageErrors() + &quot; LinkageErrors &quot;);
306             System.out.println(pcl.getLinkageErrors() == 0 ?
307                     &quot;&quot; : &quot;(use -XX:+AllowParallelDefineClass to avoid this)&quot;);


308             // After System.gc() we expect to remain with two instances: one is the initial version which is
309             // kept alive by this main method and another one in the parallel class loader.
<span class="line-modified">310             checkClassesAfterGC(2);</span>
311         }
312         else if (&quot;redefineClass&quot;.equals(args[0])) {
313             loadInstrumentationAgent(myName, buf);
314             int index = getStringIndex(&quot;AAAAAAAA&quot;, buf);
315             CountDownLatch stop = new CountDownLatch(1);
316 
317             Thread[] threads = new Thread[iterations];
318             for (int i = 0; i &lt; iterations; i++) {
319                 buf[index] = (byte) (&#39;A&#39; + i + 1); // Change string constant in getID() which is legal in redefinition
320                 instrumentation.redefineClasses(new ClassDefinition(DefineClass.class, buf));
321                 DefineClass dc = DefineClass.class.newInstance();
322                 CountDownLatch start = new CountDownLatch(1);
323                 (threads[i] = new MyThread(dc, start, stop)).start();
324                 start.await(); // Wait until the new thread entered the getID() method
325             }
326             // We expect to have one instance for each redefinition because they are all kept alive by an activation
327             // plus the initial version which is kept active by this main method.
<span class="line-modified">328             checkClasses(iterations + 1, true);</span>
329             stop.countDown(); // Let all threads leave the DefineClass.getID() activation..
330             // ..and wait until really all of them returned from DefineClass.getID()
331             for (int i = 0; i &lt; iterations; i++) {
332                 threads[i].join();
333             }


334             // After System.gc() we expect to remain with two instances: one is the initial version which is
335             // kept alive by this main method and another one which is the latest redefined version.
<span class="line-modified">336             checkClassesAfterGC(2);</span>
337         }
338         else if (&quot;redefineClassWithError&quot;.equals(args[0])) {
339             loadInstrumentationAgent(myName, buf);
340             int index = getStringIndex(&quot;getID&quot;, buf);
341 
342             for (int i = 0; i &lt; iterations; i++) {
343                 buf[index] = (byte) &#39;X&#39;; // Change getID() to XetID() which is illegal in redefinition
344                 try {
345                     instrumentation.redefineClasses(new ClassDefinition(DefineClass.class, buf));
346                     throw new RuntimeException(&quot;Class redefinition isn&#39;t allowed to change method names!&quot;);
347                 }
348                 catch (UnsupportedOperationException uoe) {
349                     // Expected because redefinition can&#39;t change the name of methods
350                 }
351             }
352             // We expect just a single DefineClass instance because failed redefinitions should
353             // leave no garbage around.
<span class="line-modified">354             // The ClassLoaderDataGraph has the failed instances recorded at least until the next GC.</span>
<span class="line-modified">355             checkClasses(1, false);</span>

356             // At least after a System.gc() we should definitely stay with a single instance!
<span class="line-modified">357             checkClassesAfterGC(1);</span>
358         }
359     }
360 }
</pre>
</td>
</tr>
</table>
<center><a href="../MemberName/MemberNameLeak.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="PrintMetaspaceDcmd.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
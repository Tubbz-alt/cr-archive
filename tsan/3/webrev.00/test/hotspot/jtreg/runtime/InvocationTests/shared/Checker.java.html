<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/InvocationTests/shared/Checker.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package shared;
 26 
 27 import java.lang.reflect.Method;
 28 import java.lang.reflect.Modifier;
 29 
 30 public abstract class Checker {
 31     protected Class staticTargetClass;
 32     protected Class dynamicTargetClass;
 33     protected String methodName;
 34 
 35     public abstract String check (Class callSite);
 36 
 37     public Checker(Class staticTargetClass, Class dynamicTargetClass) {
 38         if (!staticTargetClass.isAssignableFrom(dynamicTargetClass)) {
 39             throw new RuntimeException(&quot;Dynamic target class should be a subclass of the static target class.&quot;);
 40         }
 41 
 42         // **********************************************
 43         // NB!!! All classes are assumed to be PUBLIC !!!
 44         // **********************************************
 45         Class klass = dynamicTargetClass;
 46         while (klass != Object.class) {
 47             if (!Modifier.isPublic(klass.getModifiers())) {
 48                 throw new AssertionError(&quot;Class &quot;+klass.getName()+&quot; isn&#39;t public.&quot;);
 49             }
 50 
 51             klass = klass.getSuperclass();
 52         }
 53 
 54         this.methodName = Utils.TARGET_METHOD_NAME;
 55         this.staticTargetClass = staticTargetClass;
 56         this.dynamicTargetClass = dynamicTargetClass;
 57     }
 58 
 59     protected Method getMethodInHierarchy (Class klass) {
 60         return getMethodInHierarchy(klass, methodName);
 61     }
 62 
 63     protected Method getMethodInHierarchy (Class klass, String name) {
 64         while (klass != null) {
 65             Method method = getDeclaredMethod (klass, name);
 66 
 67             if ( method != null) {
 68 // TODO: why doesn&#39;t this check work in VM?
 69 //                int modifiers = method.getModifiers();
 70 //
 71 //                if (Modifier.isPrivate(modifiers)) {
 72 //                    if (klass == initialClass) {
 73 //                        return method;
 74 //                    }
 75 //                } else {
 76 //                    return method;
 77 //                }
 78                 return method;
 79             }
 80             klass = klass.getSuperclass();
 81         }
 82 
 83         return null;
 84     }
 85 
 86     protected Method getMethod (Class klass) {
 87         return getMethod (klass, methodName);
 88     }
 89 
 90     protected Method getDeclaredMethod (Class klass) {
 91         return getDeclaredMethod (klass, methodName);
 92     }
 93 
 94     static protected Method getMethod (Class klass, String name) {
 95         return findMethod (klass.getMethods(), name);
 96     }
 97 
 98     static protected Method getDeclaredMethod (Class klass, String name) {
 99         return findMethod (klass.getDeclaredMethods(), name);
100     }
101 
102     static protected Method findMethod (Method[] methods, String name) {
103         for (Method method : methods) {
104             if (name.equals(method.getName())) {
105                 return method;
106             }
107         }
108 
109         return null;
110     }
111 
112     static public String getClassPackageName(Class klass) {
113         String name = klass.getName();
114         return getClassPackageName(name);
115     }
116 
117     static public String getClassPackageName(String name) {
118         int lastDotIndex = name.lastIndexOf(&#39;.&#39;);
119         if (lastDotIndex &gt; -1) {
120             return name.substring(0, lastDotIndex);
121         } else {
122             return &quot;&quot;;
123         }
124     }
125 
126     public static String abbreviateResult(String result) {
127         // Abbreviate exception names
128         result = result.replaceAll(&quot;java.lang.NullPointerException&quot;, &quot;NPE&quot;);
129         result = result.replaceAll(&quot;java.lang.IllegalAccessError&quot;, &quot;IAE&quot;);
130         result = result.replaceAll(&quot;java.lang.IllegalAccessException&quot;, &quot;IAExc&quot;);
131         result = result.replaceAll(&quot;java.lang.NoSuchMethodError&quot;, &quot;NSME&quot;);
132         result = result.replaceAll(&quot;java.lang.AbstractMethodError&quot;, &quot;AME&quot;);
133         result = result.replaceAll(&quot;java.lang.IncompatibleClassChangeError&quot;, &quot;ICCE&quot;);
134         result = result.replaceAll(&quot;java.lang.VerifyError&quot;, &quot;VE&quot;);
135         result = result.replaceAll(&quot;java.lang.ClassFormatError&quot;, &quot;CFE&quot;);
136 
137         return result;
138     }
139 
140     // Check access possibility from particular call site
141     protected boolean checkAccess(Class klass, Class callerClass) {
142         int modifiers = klass.getModifiers();
143 
144         return checkAccess(modifiers, klass, callerClass);
145     }
146 
147     protected boolean checkAccess(Method m, Class callerClass) {
148         int modifiers = m.getModifiers();
149         Class declaringClass = m.getDeclaringClass();
150 
151         return checkAccess(modifiers, declaringClass, callerClass);
152     }
153 
154     protected boolean checkAccess(int modifiers, Class klass, Class callerClass) {
155         if ( Modifier.isPublic(modifiers) ) {
156             return true;
157         } else if ( Modifier.isProtected(modifiers) ) {
158             if (klass.isAssignableFrom(callerClass)) {
159                 return true;
160             } else if (getClassPackageName(klass).equals(getClassPackageName(callerClass))) {
161                 return true;
162             }
163         } else if ( Modifier.isPrivate(modifiers)) {
164             if (klass == callerClass) {
165                 return true;
166             }
167         } else if (getClassPackageName(klass).equals(getClassPackageName(callerClass))) {
168             return true;
169         } else {
170             // if method isn&#39;t accessible, IllegalAccessException is thrown
171             return false;
172         }
173 
174         return false;
175     }
176 }
    </pre>
  </body>
</html>
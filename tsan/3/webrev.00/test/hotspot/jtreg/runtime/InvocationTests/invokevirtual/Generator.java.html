<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/InvocationTests/invokevirtual/Generator.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package invokevirtual;
 26 
 27 import static jdk.internal.org.objectweb.asm.Opcodes.ACC_ABSTRACT;
 28 import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;
 29 import shared.AbstractGenerator;
 30 import shared.AccessType;
 31 
 32 import java.util.HashMap;
 33 import java.util.Map;
 34 
 35 public class Generator extends AbstractGenerator {
 36     public Generator(String[] args) {
 37         super(args);
 38     }
 39 
 40     public static void main (String[] args) throws Exception {
 41         new Generator(args).run();
 42     }
 43 
 44     protected Checker getChecker(Class paramClass, Class targetClass) {
 45         return new Checker(paramClass, targetClass);
 46     }
 47 
 48     private void run() throws Exception {
 49         // Specify package names
 50         String pkg1 = &quot;a.&quot;;
 51         String pkg2 = &quot;b.&quot;;
 52         String pkg3 = &quot;c.&quot;;
 53         String[] packages = new String[] { &quot;&quot;, pkg1, pkg2, pkg3 };
 54 
 55         boolean isPassed = true;
 56 
 57         // Hierarchy
 58         // The following triples will be used during further
 59         // hierarchy construction and will specify packages for A, B and C
 60         String[][] packageSets = new String[][] {
 61                 {   &quot;&quot;,   &quot;&quot;,   &quot;&quot; }
 62                 , {   &quot;&quot;, pkg1, pkg1 }
 63                 , {   &quot;&quot;, pkg1, pkg2 }
 64                 , { pkg1, pkg1, pkg1 }
 65                 , { pkg1, pkg1, pkg2 }
 66                 , { pkg1, pkg2, pkg1 }
 67                 , { pkg1, pkg2, pkg2 }
 68         };
 69 
 70         String [] header = new String[] {
 71                 String.format(&quot;%30s %45s %20s&quot;, &quot;Method access modifiers&quot;, &quot;Call site location&quot;, &quot;Status&quot;)
 72                 , String.format(&quot;%4s  %-12s %-12s %-12s   %7s %7s %7s %7s %7s %7s&quot;
 73                         , &quot;  # &quot;
 74                         , &quot;A.m()&quot;
 75                         , &quot;B.m()&quot;
 76                         , &quot;C.m()&quot;
 77                         , &quot;  A  &quot;
 78                         , &quot;pkgA &quot;
 79                         , &quot;  B  &quot;
 80                         , &quot; pkgB&quot;
 81                         , &quot;  C  &quot;
 82                         , &quot;pkgC &quot;
 83                         )
 84                 , &quot;-------------------------------------------------------------------------------------------------&quot;
 85         };
 86 
 87         for (String str : header) {
 88             System.out.println(str);
 89         }
 90 
 91         for (String[] pkgSet : packageSets) {
 92             String packageA = pkgSet[0];
 93             String packageB = pkgSet[1];
 94             String packageC = pkgSet[2];
 95 
 96             String classNameA = packageA + &quot;A&quot;;
 97             String classNameB = packageB + &quot;B&quot;;
 98             String classNameC = packageC + &quot;C&quot;;
 99 
100             String staticCallerParam = classNameA;
101 
102             // For all possible access modifier combinations
103             for (AccessType accessA : AccessType.values()) {
104                 for (AccessType accessB : AccessType.values()) {
105                     for (AccessType accessC : AccessType.values()) {
106 
107                         if (accessA == AccessType.UNDEF) {
108                             continue;
109                         }
110 
111                         for (int I = 0; I &lt; 4; I++) {
112                             boolean isAbstractA = ((I &amp; 1) != 0);
113                             boolean isAbstractB = ((I &amp; 2) != 0);
114 
115                             Map&lt;String, byte[]&gt; classes = new HashMap&lt;String, byte[]&gt;();
116 
117                             // Generate class A
118                             classes.put(
119                                     classNameA
120                                     , new ClassGenerator( classNameA
121                                                         , &quot;java.lang.Object&quot;
122                                                         , ACC_PUBLIC | (isAbstractA ? ACC_ABSTRACT : 0))
123                                         .addTargetMethod( accessA
124                                                         , (isAbstractA ? ACC_ABSTRACT : 0))
125                                         .addCaller(staticCallerParam)
126                                         .getClassFile()
127                             );
128 
129                             // Generate class B
130                             classes.put(
131                                     classNameB
132                                     , new ClassGenerator( classNameB
133                                                         , classNameA
134                                                         , ACC_PUBLIC | (isAbstractB ? ACC_ABSTRACT : 0))
135                                     .addTargetMethod( accessB
136                                                     , (isAbstractB ? ACC_ABSTRACT : 0))
137                                     .addCaller(staticCallerParam)
138                                     .getClassFile()
139                             );
140 
141                             // Generate class C
142                             classes.put(
143                                     classNameC
144                                     , new ClassGenerator(classNameC, classNameB)
145                                         .addTargetMethod(accessC)
146                                         .addCaller(staticCallerParam)
147                                         .getClassFile()
148                             );
149 
150                             // Generate package callers
151                             for (String pkg : packages) {
152                                 classes.put(
153                                         pkg+&quot;Caller&quot;
154                                         , new ClassGenerator(pkg+&quot;Caller&quot;)
155                                         .addCaller(staticCallerParam)
156                                         .getClassFile()
157                                 );
158                             }
159 
160                             String[] callSites = new String[] {
161                                     classNameA
162                                     , packageA+&quot;Caller&quot;
163                                     , classNameB
164                                     , packageB+&quot;Caller&quot;
165                                     , classNameC
166                                     , packageC+&quot;Caller&quot;
167                             };
168 
169 
170                             String caseDescription =
171                                     String.format(&quot;%-12s %-12s %-12s| &quot;
172                                         , (isAbstractA ? &quot;! &quot; : &quot;  &quot;) + classNameA + &quot; &quot; + accessA
173                                         , (isAbstractB ? &quot;! &quot; : &quot;  &quot;) + classNameB + &quot; &quot; + accessB
174                                         , classNameC + &quot; &quot; + accessC
175                                     );
176 
177                             boolean result = exec(classes, caseDescription, staticCallerParam, classNameC, callSites);
178                             isPassed = isPassed &amp;&amp; result;
179                         }
180                     }
181                 }
182             }
183         }
184 
185         // Print footer
186         for (int i = header.length-1; i &gt;= 0; i--) {
187             System.out.println(header[i]);
188         }
189 
190         if (executeTests) {
191             System.out.printf(&quot;\nEXECUTION STATUS: %s\n&quot;, (isPassed? &quot;PASSED&quot; : &quot;FAILED&quot;));
192         }
193     }
194 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/runtime/MemberName/MemberNameLeak.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../LoaderConstraints/vtableLdrConstraint/Test.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../Metaspace/DefineClass.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/runtime/MemberName/MemberNameLeak.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8174749 8213307
 27  * @summary MemberNameTable should reuse entries
<span class="line-modified"> 28  * @requires vm.gc == &quot;null&quot;</span>
<span class="line-modified"> 29  * @library /test/lib</span>

 30  * @build sun.hotspot.WhiteBox
 31  * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
 32  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MemberNameLeak
 33  */
 34 


 35 import java.lang.invoke.*;



 36 import jdk.test.lib.process.OutputAnalyzer;
 37 import jdk.test.lib.process.ProcessTools;

 38 import sun.hotspot.WhiteBox;
 39 import sun.hotspot.code.Compiler;
 40 import sun.hotspot.gc.GC;
 41 
 42 public class MemberNameLeak {







 43     static class Leak {
 44       public void callMe() {
 45       }
 46 
 47       public static void main(String[] args) throws Throwable {
 48         Leak leak = new Leak();
 49         WhiteBox wb = WhiteBox.getWhiteBox();
<span class="line-removed"> 50         int removedCountOrig =  wb.resolvedMethodRemovedCount();</span>
<span class="line-removed"> 51         int removedCount;</span>
 52 
<span class="line-modified"> 53         for (int i = 0; i &lt; 10; i++) {</span>
<span class="line-modified"> 54           MethodHandles.Lookup lookup = MethodHandles.lookup();</span>
<span class="line-modified"> 55           MethodType mt = MethodType.fromMethodDescriptorString(&quot;()V&quot;, Leak.class.getClassLoader());</span>










 56           // findSpecial leaks some native mem
<span class="line-modified"> 57           MethodHandle mh = lookup.findSpecial(Leak.class, &quot;callMe&quot;, mt, Leak.class);</span>
<span class="line-modified"> 58           mh.invokeExact(leak);</span>






 59         }
 60 










 61         // Wait until ServiceThread cleans ResolvedMethod table
 62         int cnt = 0;
 63         while (true) {
 64           if (cnt++ % 30 == 0) {
 65             System.gc();  // make mh unused
 66           }
<span class="line-modified"> 67           removedCount = wb.resolvedMethodRemovedCount();</span>
<span class="line-modified"> 68           if (removedCountOrig != removedCount) {</span>

 69             break;
 70           }

 71           Thread.sleep(100);
 72         }
 73       }
 74     }
 75 
<span class="line-modified"> 76     public static void test(String gc, boolean doConcurrent) throws Throwable {</span>










 77         // Run this Leak class with logging
 78         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(
<span class="line-modified"> 79                                       &quot;-Xlog:membername+table=trace&quot;,</span>
 80                                       &quot;-XX:+UnlockExperimentalVMOptions&quot;,
 81                                       &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
 82                                       &quot;-XX:+WhiteBoxAPI&quot;,
 83                                       &quot;-Xbootclasspath/a:.&quot;,


 84                                       doConcurrent ? &quot;-XX:+ExplicitGCInvokesConcurrent&quot; : &quot;-XX:-ExplicitGCInvokesConcurrent&quot;,
 85                                       &quot;-XX:+ClassUnloading&quot;,
 86                                       &quot;-XX:+ClassUnloadingWithConcurrentMark&quot;,
<span class="line-modified"> 87                                       gc, Leak.class.getName());</span>



 88         OutputAnalyzer output = new OutputAnalyzer(pb.start());
<span class="line-modified"> 89         output.shouldContain(&quot;ResolvedMethod entry added for MemberNameLeak$Leak.callMe()V&quot;);</span>
<span class="line-modified"> 90         output.shouldContain(&quot;ResolvedMethod entry found for MemberNameLeak$Leak.callMe()V&quot;);</span>
<span class="line-removed"> 91         output.shouldContain(&quot;ResolvedMethod entry removed&quot;);</span>
 92         output.shouldHaveExitValue(0);











 93     }
 94 
<span class="line-modified"> 95     public static void main(java.lang.String[] unused) throws Throwable {</span>
<span class="line-modified"> 96         test(&quot;-XX:+UseG1GC&quot;, false);</span>
<span class="line-modified"> 97         test(&quot;-XX:+UseG1GC&quot;, true);</span>
<span class="line-modified"> 98 </span>
<span class="line-modified"> 99         test(&quot;-XX:+UseParallelGC&quot;, false);</span>
<span class="line-modified">100         test(&quot;-XX:+UseSerialGC&quot;, false);</span>
<span class="line-modified">101         if (!Compiler.isGraalEnabled()) { // Graal does not support CMS</span>
<span class="line-modified">102             test(&quot;-XX:+UseConcMarkSweepGC&quot;, false);</span>
<span class="line-modified">103             test(&quot;-XX:+UseConcMarkSweepGC&quot;, true);</span>
<span class="line-modified">104             if (GC.Shenandoah.isSupported()) {</span>
<span class="line-modified">105                 test(&quot;-XX:+UseShenandoahGC&quot;, true);</span>
<span class="line-modified">106                 test(&quot;-XX:+UseShenandoahGC&quot;, false);</span>
<span class="line-modified">107             }</span>

108         }
109     }




110 }
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8174749 8213307
 27  * @summary MemberNameTable should reuse entries
<span class="line-modified"> 28  * @library /test/lib /runtime/testlibrary</span>
<span class="line-modified"> 29  * @modules java.base/jdk.internal.misc</span>
<span class="line-added"> 30  * @modules java.compiler</span>
 31  * @build sun.hotspot.WhiteBox
 32  * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
 33  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MemberNameLeak
 34  */
 35 
<span class="line-added"> 36 import java.io.*;</span>
<span class="line-added"> 37 import java.nio.file.*;</span>
 38 import java.lang.invoke.*;
<span class="line-added"> 39 import java.lang.reflect.*;</span>
<span class="line-added"> 40 import java.text.*;</span>
<span class="line-added"> 41 import java.util.*;</span>
 42 import jdk.test.lib.process.OutputAnalyzer;
 43 import jdk.test.lib.process.ProcessTools;
<span class="line-added"> 44 import jdk.test.lib.Utils;</span>
 45 import sun.hotspot.WhiteBox;
 46 import sun.hotspot.code.Compiler;
 47 import sun.hotspot.gc.GC;
 48 
 49 public class MemberNameLeak {
<span class="line-added"> 50     private static String className  = &quot;MemberNameLeakTestClass&quot;;</span>
<span class="line-added"> 51     private static String methodPrefix = &quot;method&quot;;</span>
<span class="line-added"> 52     // The size of the ResolvedMethodTable is 1024. 2000 entries</span>
<span class="line-added"> 53     // is enough to trigger a grow/cleaning of the table after a GC.</span>
<span class="line-added"> 54     private static int methodCount = 2000;</span>
<span class="line-added"> 55     public static ArrayList&lt;MethodHandle&gt; keepAlive;</span>
<span class="line-added"> 56 </span>
 57     static class Leak {
 58       public void callMe() {
 59       }
 60 
 61       public static void main(String[] args) throws Throwable {
 62         Leak leak = new Leak();
 63         WhiteBox wb = WhiteBox.getWhiteBox();


 64 
<span class="line-modified"> 65         keepAlive = new ArrayList&lt;&gt;(methodCount);</span>
<span class="line-modified"> 66 </span>
<span class="line-modified"> 67         ClassWithManyMethodsClassLoader classLoader = new ClassWithManyMethodsClassLoader();</span>
<span class="line-added"> 68         Class&lt;?&gt; clazz = classLoader.create(className, methodPrefix, methodCount);</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70         long before = wb.resolvedMethodItemsCount();</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72         Object o = clazz.newInstance();</span>
<span class="line-added"> 73         MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(clazz, MethodHandles.lookup());</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75         for (int i = 0; i &lt; methodCount; i++) {</span>
<span class="line-added"> 76           MethodType mt = MethodType.fromMethodDescriptorString(&quot;()V&quot;, classLoader);</span>
<span class="line-added"> 77           String methodName = methodPrefix + i;</span>
 78           // findSpecial leaks some native mem
<span class="line-modified"> 79           // Add entry to ResolvedMethodTable.</span>
<span class="line-modified"> 80           MethodHandle mh0 = lookup.findSpecial(clazz, methodName, mt, clazz);</span>
<span class="line-added"> 81           // Find entry in ResolvedMethodTable.</span>
<span class="line-added"> 82           MethodHandle mh1 = lookup.findSpecial(clazz, methodName, mt, clazz);</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84           mh1.invoke(o);</span>
<span class="line-added"> 85 </span>
<span class="line-added"> 86           keepAlive.add(mh1);</span>
 87         }
 88 
<span class="line-added"> 89         long after = wb.resolvedMethodItemsCount();</span>
<span class="line-added"> 90 </span>
<span class="line-added"> 91         System.out.println(&quot;wb.resolvedMethodItemsCount() after setup: &quot; + after);</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93         if (after == before) {</span>
<span class="line-added"> 94           throw new RuntimeException(&quot;Too few resolved methods&quot;);</span>
<span class="line-added"> 95         }</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97         keepAlive = null;</span>
<span class="line-added"> 98 </span>
 99         // Wait until ServiceThread cleans ResolvedMethod table
100         int cnt = 0;
101         while (true) {
102           if (cnt++ % 30 == 0) {
103             System.gc();  // make mh unused
104           }
<span class="line-modified">105 </span>
<span class="line-modified">106           if (after != wb.resolvedMethodItemsCount()) {</span>
<span class="line-added">107             // Entries have been removed.</span>
108             break;
109           }
<span class="line-added">110 </span>
111           Thread.sleep(100);
112         }
113       }
114     }
115 
<span class="line-modified">116     private static Path createGcLogPath(String prefix) throws IOException {</span>
<span class="line-added">117         Path gcLog = Utils.createTempFile(prefix, &quot;log&quot;);</span>
<span class="line-added">118         Files.delete(gcLog);</span>
<span class="line-added">119         return gcLog;</span>
<span class="line-added">120     }</span>
<span class="line-added">121 </span>
<span class="line-added">122     private static DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span>
<span class="line-added">123 </span>
<span class="line-added">124     public static void test(GC gc, boolean doConcurrent) throws Throwable {</span>
<span class="line-added">125         Path gcLogPath = createGcLogPath(&quot;gc.&quot; + gc + &quot;.&quot; + doConcurrent);</span>
<span class="line-added">126         System.err.println(&quot;test(&quot; + gc + &quot;, &quot; + doConcurrent + &quot;)&quot; + &quot; &quot; + dateFormat.format(new Date()));</span>
127         // Run this Leak class with logging
128         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(
<span class="line-modified">129                                       &quot;-Xlog:membername+table=trace,gc+verify=debug,gc:&quot; + gcLogPath + &quot;:time,utctime,uptime,pid,level,tags&quot;,</span>
130                                       &quot;-XX:+UnlockExperimentalVMOptions&quot;,
131                                       &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
132                                       &quot;-XX:+WhiteBoxAPI&quot;,
133                                       &quot;-Xbootclasspath/a:.&quot;,
<span class="line-added">134                                       &quot;-XX:+VerifyBeforeGC&quot;,</span>
<span class="line-added">135                                       &quot;-XX:+VerifyAfterGC&quot;,</span>
136                                       doConcurrent ? &quot;-XX:+ExplicitGCInvokesConcurrent&quot; : &quot;-XX:-ExplicitGCInvokesConcurrent&quot;,
137                                       &quot;-XX:+ClassUnloading&quot;,
138                                       &quot;-XX:+ClassUnloadingWithConcurrentMark&quot;,
<span class="line-modified">139                                       &quot;-XX:+Use&quot; + gc + &quot;GC&quot;,</span>
<span class="line-added">140                                       Leak.class.getName());</span>
<span class="line-added">141 </span>
<span class="line-added">142         // Check process</span>
143         OutputAnalyzer output = new OutputAnalyzer(pb.start());
<span class="line-modified">144         output.outputTo(System.out);</span>
<span class="line-modified">145         output.errorTo(System.err);</span>

146         output.shouldHaveExitValue(0);
<span class="line-added">147 </span>
<span class="line-added">148         // Check gc log file</span>
<span class="line-added">149         OutputAnalyzer gcLogOutput = new OutputAnalyzer(gcLogPath);</span>
<span class="line-added">150 </span>
<span class="line-added">151         // Hardcoded names for classes generated by GeneratedClassLoader</span>
<span class="line-added">152         String descriptor = className + &quot;.&quot; + methodPrefix + &quot;0()V&quot;;</span>
<span class="line-added">153         gcLogOutput.shouldContain(&quot;ResolvedMethod entry added for &quot; + descriptor);</span>
<span class="line-added">154         gcLogOutput.shouldContain(&quot;ResolvedMethod entry found for &quot; + descriptor);</span>
<span class="line-added">155         gcLogOutput.shouldContain(&quot;ResolvedMethod entry removed&quot;);</span>
<span class="line-added">156 </span>
<span class="line-added">157         System.err.println(&quot;test(&quot; + gc + &quot;, &quot; + doConcurrent + &quot;)&quot; + &quot; done &quot; + dateFormat.format(new Date()));</span>
158     }
159 
<span class="line-modified">160     private static boolean supportsSTW(GC gc) {</span>
<span class="line-modified">161         return !(gc == GC.Epsilon);</span>
<span class="line-modified">162     }</span>
<span class="line-modified">163 </span>
<span class="line-modified">164     private static boolean supportsConcurrent(GC gc) {</span>
<span class="line-modified">165         return !(gc == GC.Epsilon || gc == GC.Serial || gc == GC.Parallel);</span>
<span class="line-modified">166     }</span>
<span class="line-modified">167 </span>
<span class="line-modified">168     private static void test(GC gc) throws Throwable {</span>
<span class="line-modified">169         if (supportsSTW(gc)) {</span>
<span class="line-modified">170             test(gc, false);</span>
<span class="line-modified">171         }</span>
<span class="line-modified">172         if (supportsConcurrent(gc)) {</span>
<span class="line-added">173             test(gc, true);</span>
174         }
175     }
<span class="line-added">176 </span>
<span class="line-added">177     public static void main(java.lang.String[] unused) throws Throwable {</span>
<span class="line-added">178       test(GC.selected());</span>
<span class="line-added">179     }</span>
180 }
</pre>
</td>
</tr>
</table>
<center><a href="../LoaderConstraints/vtableLdrConstraint/Test.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../Metaspace/DefineClass.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
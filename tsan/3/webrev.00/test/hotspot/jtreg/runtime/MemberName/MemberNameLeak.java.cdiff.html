<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/hotspot/jtreg/runtime/MemberName/MemberNameLeak.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../LoaderConstraints/vtableLdrConstraint/Test.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../Metaspace/DefineClass.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/runtime/MemberName/MemberNameLeak.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,88 ***</span>
  
  /*
   * @test
   * @bug 8174749 8213307
   * @summary MemberNameTable should reuse entries
<span class="line-modified">!  * @requires vm.gc == &quot;null&quot;</span>
<span class="line-modified">!  * @library /test/lib</span>
   * @build sun.hotspot.WhiteBox
   * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
   * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MemberNameLeak
   */
  
  import java.lang.invoke.*;
  import jdk.test.lib.process.OutputAnalyzer;
  import jdk.test.lib.process.ProcessTools;
  import sun.hotspot.WhiteBox;
  import sun.hotspot.code.Compiler;
  import sun.hotspot.gc.GC;
  
  public class MemberNameLeak {
      static class Leak {
        public void callMe() {
        }
  
        public static void main(String[] args) throws Throwable {
          Leak leak = new Leak();
          WhiteBox wb = WhiteBox.getWhiteBox();
<span class="line-removed">-         int removedCountOrig =  wb.resolvedMethodRemovedCount();</span>
<span class="line-removed">-         int removedCount;</span>
  
<span class="line-modified">!         for (int i = 0; i &lt; 10; i++) {</span>
<span class="line-modified">!           MethodHandles.Lookup lookup = MethodHandles.lookup();</span>
<span class="line-modified">!           MethodType mt = MethodType.fromMethodDescriptorString(&quot;()V&quot;, Leak.class.getClassLoader());</span>
            // findSpecial leaks some native mem
<span class="line-modified">!           MethodHandle mh = lookup.findSpecial(Leak.class, &quot;callMe&quot;, mt, Leak.class);</span>
<span class="line-modified">!           mh.invokeExact(leak);</span>
          }
  
          // Wait until ServiceThread cleans ResolvedMethod table
          int cnt = 0;
          while (true) {
            if (cnt++ % 30 == 0) {
              System.gc();  // make mh unused
            }
<span class="line-modified">!           removedCount = wb.resolvedMethodRemovedCount();</span>
<span class="line-modified">!           if (removedCountOrig != removedCount) {</span>
              break;
            }
            Thread.sleep(100);
          }
        }
      }
  
<span class="line-modified">!     public static void test(String gc, boolean doConcurrent) throws Throwable {</span>
          // Run this Leak class with logging
          ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(
<span class="line-modified">!                                       &quot;-Xlog:membername+table=trace&quot;,</span>
                                        &quot;-XX:+UnlockExperimentalVMOptions&quot;,
                                        &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
                                        &quot;-XX:+WhiteBoxAPI&quot;,
                                        &quot;-Xbootclasspath/a:.&quot;,
                                        doConcurrent ? &quot;-XX:+ExplicitGCInvokesConcurrent&quot; : &quot;-XX:-ExplicitGCInvokesConcurrent&quot;,
                                        &quot;-XX:+ClassUnloading&quot;,
                                        &quot;-XX:+ClassUnloadingWithConcurrentMark&quot;,
<span class="line-modified">!                                       gc, Leak.class.getName());</span>
          OutputAnalyzer output = new OutputAnalyzer(pb.start());
<span class="line-modified">!         output.shouldContain(&quot;ResolvedMethod entry added for MemberNameLeak$Leak.callMe()V&quot;);</span>
<span class="line-modified">!         output.shouldContain(&quot;ResolvedMethod entry found for MemberNameLeak$Leak.callMe()V&quot;);</span>
<span class="line-removed">-         output.shouldContain(&quot;ResolvedMethod entry removed&quot;);</span>
          output.shouldHaveExitValue(0);
      }
  
<span class="line-modified">!     public static void main(java.lang.String[] unused) throws Throwable {</span>
<span class="line-modified">!         test(&quot;-XX:+UseG1GC&quot;, false);</span>
<span class="line-modified">!         test(&quot;-XX:+UseG1GC&quot;, true);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         test(&quot;-XX:+UseParallelGC&quot;, false);</span>
<span class="line-modified">!         test(&quot;-XX:+UseSerialGC&quot;, false);</span>
<span class="line-modified">!         if (!Compiler.isGraalEnabled()) { // Graal does not support CMS</span>
<span class="line-modified">!             test(&quot;-XX:+UseConcMarkSweepGC&quot;, false);</span>
<span class="line-modified">!             test(&quot;-XX:+UseConcMarkSweepGC&quot;, true);</span>
<span class="line-modified">!             if (GC.Shenandoah.isSupported()) {</span>
<span class="line-modified">!                 test(&quot;-XX:+UseShenandoahGC&quot;, true);</span>
<span class="line-modified">!                 test(&quot;-XX:+UseShenandoahGC&quot;, false);</span>
<span class="line-modified">!             }</span>
          }
      }
  }
<span class="line-new-header">--- 23,158 ---</span>
  
  /*
   * @test
   * @bug 8174749 8213307
   * @summary MemberNameTable should reuse entries
<span class="line-modified">!  * @library /test/lib /runtime/testlibrary</span>
<span class="line-modified">!  * @modules java.base/jdk.internal.misc</span>
<span class="line-added">+  * @modules java.compiler</span>
   * @build sun.hotspot.WhiteBox
   * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
   * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MemberNameLeak
   */
  
<span class="line-added">+ import java.io.*;</span>
<span class="line-added">+ import java.nio.file.*;</span>
  import java.lang.invoke.*;
<span class="line-added">+ import java.lang.reflect.*;</span>
<span class="line-added">+ import java.text.*;</span>
<span class="line-added">+ import java.util.*;</span>
  import jdk.test.lib.process.OutputAnalyzer;
  import jdk.test.lib.process.ProcessTools;
<span class="line-added">+ import jdk.test.lib.Utils;</span>
  import sun.hotspot.WhiteBox;
  import sun.hotspot.code.Compiler;
  import sun.hotspot.gc.GC;
  
  public class MemberNameLeak {
<span class="line-added">+     private static String className  = &quot;MemberNameLeakTestClass&quot;;</span>
<span class="line-added">+     private static String methodPrefix = &quot;method&quot;;</span>
<span class="line-added">+     // The size of the ResolvedMethodTable is 1024. 2000 entries</span>
<span class="line-added">+     // is enough to trigger a grow/cleaning of the table after a GC.</span>
<span class="line-added">+     private static int methodCount = 2000;</span>
<span class="line-added">+     public static ArrayList&lt;MethodHandle&gt; keepAlive;</span>
<span class="line-added">+ </span>
      static class Leak {
        public void callMe() {
        }
  
        public static void main(String[] args) throws Throwable {
          Leak leak = new Leak();
          WhiteBox wb = WhiteBox.getWhiteBox();
  
<span class="line-modified">!         keepAlive = new ArrayList&lt;&gt;(methodCount);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         ClassWithManyMethodsClassLoader classLoader = new ClassWithManyMethodsClassLoader();</span>
<span class="line-added">+         Class&lt;?&gt; clazz = classLoader.create(className, methodPrefix, methodCount);</span>
<span class="line-added">+ </span>
<span class="line-added">+         long before = wb.resolvedMethodItemsCount();</span>
<span class="line-added">+ </span>
<span class="line-added">+         Object o = clazz.newInstance();</span>
<span class="line-added">+         MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(clazz, MethodHandles.lookup());</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (int i = 0; i &lt; methodCount; i++) {</span>
<span class="line-added">+           MethodType mt = MethodType.fromMethodDescriptorString(&quot;()V&quot;, classLoader);</span>
<span class="line-added">+           String methodName = methodPrefix + i;</span>
            // findSpecial leaks some native mem
<span class="line-modified">!           // Add entry to ResolvedMethodTable.</span>
<span class="line-modified">!           MethodHandle mh0 = lookup.findSpecial(clazz, methodName, mt, clazz);</span>
<span class="line-added">+           // Find entry in ResolvedMethodTable.</span>
<span class="line-added">+           MethodHandle mh1 = lookup.findSpecial(clazz, methodName, mt, clazz);</span>
<span class="line-added">+ </span>
<span class="line-added">+           mh1.invoke(o);</span>
<span class="line-added">+ </span>
<span class="line-added">+           keepAlive.add(mh1);</span>
          }
  
<span class="line-added">+         long after = wb.resolvedMethodItemsCount();</span>
<span class="line-added">+ </span>
<span class="line-added">+         System.out.println(&quot;wb.resolvedMethodItemsCount() after setup: &quot; + after);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (after == before) {</span>
<span class="line-added">+           throw new RuntimeException(&quot;Too few resolved methods&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         keepAlive = null;</span>
<span class="line-added">+ </span>
          // Wait until ServiceThread cleans ResolvedMethod table
          int cnt = 0;
          while (true) {
            if (cnt++ % 30 == 0) {
              System.gc();  // make mh unused
            }
<span class="line-modified">! </span>
<span class="line-modified">!           if (after != wb.resolvedMethodItemsCount()) {</span>
<span class="line-added">+             // Entries have been removed.</span>
              break;
            }
<span class="line-added">+ </span>
            Thread.sleep(100);
          }
        }
      }
  
<span class="line-modified">!     private static Path createGcLogPath(String prefix) throws IOException {</span>
<span class="line-added">+         Path gcLog = Utils.createTempFile(prefix, &quot;log&quot;);</span>
<span class="line-added">+         Files.delete(gcLog);</span>
<span class="line-added">+         return gcLog;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     public static void test(GC gc, boolean doConcurrent) throws Throwable {</span>
<span class="line-added">+         Path gcLogPath = createGcLogPath(&quot;gc.&quot; + gc + &quot;.&quot; + doConcurrent);</span>
<span class="line-added">+         System.err.println(&quot;test(&quot; + gc + &quot;, &quot; + doConcurrent + &quot;)&quot; + &quot; &quot; + dateFormat.format(new Date()));</span>
          // Run this Leak class with logging
          ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(
<span class="line-modified">!                                       &quot;-Xlog:membername+table=trace,gc+verify=debug,gc:&quot; + gcLogPath + &quot;:time,utctime,uptime,pid,level,tags&quot;,</span>
                                        &quot;-XX:+UnlockExperimentalVMOptions&quot;,
                                        &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
                                        &quot;-XX:+WhiteBoxAPI&quot;,
                                        &quot;-Xbootclasspath/a:.&quot;,
<span class="line-added">+                                       &quot;-XX:+VerifyBeforeGC&quot;,</span>
<span class="line-added">+                                       &quot;-XX:+VerifyAfterGC&quot;,</span>
                                        doConcurrent ? &quot;-XX:+ExplicitGCInvokesConcurrent&quot; : &quot;-XX:-ExplicitGCInvokesConcurrent&quot;,
                                        &quot;-XX:+ClassUnloading&quot;,
                                        &quot;-XX:+ClassUnloadingWithConcurrentMark&quot;,
<span class="line-modified">!                                       &quot;-XX:+Use&quot; + gc + &quot;GC&quot;,</span>
<span class="line-added">+                                       Leak.class.getName());</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Check process</span>
          OutputAnalyzer output = new OutputAnalyzer(pb.start());
<span class="line-modified">!         output.outputTo(System.out);</span>
<span class="line-modified">!         output.errorTo(System.err);</span>
          output.shouldHaveExitValue(0);
<span class="line-added">+ </span>
<span class="line-added">+         // Check gc log file</span>
<span class="line-added">+         OutputAnalyzer gcLogOutput = new OutputAnalyzer(gcLogPath);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Hardcoded names for classes generated by GeneratedClassLoader</span>
<span class="line-added">+         String descriptor = className + &quot;.&quot; + methodPrefix + &quot;0()V&quot;;</span>
<span class="line-added">+         gcLogOutput.shouldContain(&quot;ResolvedMethod entry added for &quot; + descriptor);</span>
<span class="line-added">+         gcLogOutput.shouldContain(&quot;ResolvedMethod entry found for &quot; + descriptor);</span>
<span class="line-added">+         gcLogOutput.shouldContain(&quot;ResolvedMethod entry removed&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         System.err.println(&quot;test(&quot; + gc + &quot;, &quot; + doConcurrent + &quot;)&quot; + &quot; done &quot; + dateFormat.format(new Date()));</span>
      }
  
<span class="line-modified">!     private static boolean supportsSTW(GC gc) {</span>
<span class="line-modified">!         return !(gc == GC.Epsilon);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private static boolean supportsConcurrent(GC gc) {</span>
<span class="line-modified">!         return !(gc == GC.Epsilon || gc == GC.Serial || gc == GC.Parallel);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private static void test(GC gc) throws Throwable {</span>
<span class="line-modified">!         if (supportsSTW(gc)) {</span>
<span class="line-modified">!             test(gc, false);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (supportsConcurrent(gc)) {</span>
<span class="line-added">+             test(gc, true);</span>
          }
      }
<span class="line-added">+ </span>
<span class="line-added">+     public static void main(java.lang.String[] unused) throws Throwable {</span>
<span class="line-added">+       test(GC.selected());</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="../LoaderConstraints/vtableLdrConstraint/Test.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../Metaspace/DefineClass.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/test/hotspot/jtreg/runtime/MemberName/MemberNameLeak.java b/test/hotspot/jtreg/runtime/MemberName/MemberNameLeak.java
--- a/test/hotspot/jtreg/runtime/MemberName/MemberNameLeak.java
+++ b/test/hotspot/jtreg/runtime/MemberName/MemberNameLeak.java
@@ -23,88 +23,158 @@
 
 /*
  * @test
  * @bug 8174749 8213307
  * @summary MemberNameTable should reuse entries
- * @requires vm.gc == "null"
- * @library /test/lib
+ * @library /test/lib /runtime/testlibrary
+ * @modules java.base/jdk.internal.misc
+ * @modules java.compiler
  * @build sun.hotspot.WhiteBox
  * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission
  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:. MemberNameLeak
  */
 
+import java.io.*;
+import java.nio.file.*;
 import java.lang.invoke.*;
+import java.lang.reflect.*;
+import java.text.*;
+import java.util.*;
 import jdk.test.lib.process.OutputAnalyzer;
 import jdk.test.lib.process.ProcessTools;
+import jdk.test.lib.Utils;
 import sun.hotspot.WhiteBox;
 import sun.hotspot.code.Compiler;
 import sun.hotspot.gc.GC;
 
 public class MemberNameLeak {
+    private static String className  = "MemberNameLeakTestClass";
+    private static String methodPrefix = "method";
+    // The size of the ResolvedMethodTable is 1024. 2000 entries
+    // is enough to trigger a grow/cleaning of the table after a GC.
+    private static int methodCount = 2000;
+    public static ArrayList<MethodHandle> keepAlive;
+
     static class Leak {
       public void callMe() {
       }
 
       public static void main(String[] args) throws Throwable {
         Leak leak = new Leak();
         WhiteBox wb = WhiteBox.getWhiteBox();
-        int removedCountOrig =  wb.resolvedMethodRemovedCount();
-        int removedCount;
 
-        for (int i = 0; i < 10; i++) {
-          MethodHandles.Lookup lookup = MethodHandles.lookup();
-          MethodType mt = MethodType.fromMethodDescriptorString("()V", Leak.class.getClassLoader());
+        keepAlive = new ArrayList<>(methodCount);
+
+        ClassWithManyMethodsClassLoader classLoader = new ClassWithManyMethodsClassLoader();
+        Class<?> clazz = classLoader.create(className, methodPrefix, methodCount);
+
+        long before = wb.resolvedMethodItemsCount();
+
+        Object o = clazz.newInstance();
+        MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(clazz, MethodHandles.lookup());
+
+        for (int i = 0; i < methodCount; i++) {
+          MethodType mt = MethodType.fromMethodDescriptorString("()V", classLoader);
+          String methodName = methodPrefix + i;
           // findSpecial leaks some native mem
-          MethodHandle mh = lookup.findSpecial(Leak.class, "callMe", mt, Leak.class);
-          mh.invokeExact(leak);
+          // Add entry to ResolvedMethodTable.
+          MethodHandle mh0 = lookup.findSpecial(clazz, methodName, mt, clazz);
+          // Find entry in ResolvedMethodTable.
+          MethodHandle mh1 = lookup.findSpecial(clazz, methodName, mt, clazz);
+
+          mh1.invoke(o);
+
+          keepAlive.add(mh1);
         }
 
+        long after = wb.resolvedMethodItemsCount();
+
+        System.out.println("wb.resolvedMethodItemsCount() after setup: " + after);
+
+        if (after == before) {
+          throw new RuntimeException("Too few resolved methods");
+        }
+
+        keepAlive = null;
+
         // Wait until ServiceThread cleans ResolvedMethod table
         int cnt = 0;
         while (true) {
           if (cnt++ % 30 == 0) {
             System.gc();  // make mh unused
           }
-          removedCount = wb.resolvedMethodRemovedCount();
-          if (removedCountOrig != removedCount) {
+
+          if (after != wb.resolvedMethodItemsCount()) {
+            // Entries have been removed.
             break;
           }
+
           Thread.sleep(100);
         }
       }
     }
 
-    public static void test(String gc, boolean doConcurrent) throws Throwable {
+    private static Path createGcLogPath(String prefix) throws IOException {
+        Path gcLog = Utils.createTempFile(prefix, "log");
+        Files.delete(gcLog);
+        return gcLog;
+    }
+
+    private static DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
+
+    public static void test(GC gc, boolean doConcurrent) throws Throwable {
+        Path gcLogPath = createGcLogPath("gc." + gc + "." + doConcurrent);
+        System.err.println("test(" + gc + ", " + doConcurrent + ")" + " " + dateFormat.format(new Date()));
         // Run this Leak class with logging
         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(
-                                      "-Xlog:membername+table=trace",
+                                      "-Xlog:membername+table=trace,gc+verify=debug,gc:" + gcLogPath + ":time,utctime,uptime,pid,level,tags",
                                       "-XX:+UnlockExperimentalVMOptions",
                                       "-XX:+UnlockDiagnosticVMOptions",
                                       "-XX:+WhiteBoxAPI",
                                       "-Xbootclasspath/a:.",
+                                      "-XX:+VerifyBeforeGC",
+                                      "-XX:+VerifyAfterGC",
                                       doConcurrent ? "-XX:+ExplicitGCInvokesConcurrent" : "-XX:-ExplicitGCInvokesConcurrent",
                                       "-XX:+ClassUnloading",
                                       "-XX:+ClassUnloadingWithConcurrentMark",
-                                      gc, Leak.class.getName());
+                                      "-XX:+Use" + gc + "GC",
+                                      Leak.class.getName());
+
+        // Check process
         OutputAnalyzer output = new OutputAnalyzer(pb.start());
-        output.shouldContain("ResolvedMethod entry added for MemberNameLeak$Leak.callMe()V");
-        output.shouldContain("ResolvedMethod entry found for MemberNameLeak$Leak.callMe()V");
-        output.shouldContain("ResolvedMethod entry removed");
+        output.outputTo(System.out);
+        output.errorTo(System.err);
         output.shouldHaveExitValue(0);
+
+        // Check gc log file
+        OutputAnalyzer gcLogOutput = new OutputAnalyzer(gcLogPath);
+
+        // Hardcoded names for classes generated by GeneratedClassLoader
+        String descriptor = className + "." + methodPrefix + "0()V";
+        gcLogOutput.shouldContain("ResolvedMethod entry added for " + descriptor);
+        gcLogOutput.shouldContain("ResolvedMethod entry found for " + descriptor);
+        gcLogOutput.shouldContain("ResolvedMethod entry removed");
+
+        System.err.println("test(" + gc + ", " + doConcurrent + ")" + " done " + dateFormat.format(new Date()));
     }
 
-    public static void main(java.lang.String[] unused) throws Throwable {
-        test("-XX:+UseG1GC", false);
-        test("-XX:+UseG1GC", true);
-
-        test("-XX:+UseParallelGC", false);
-        test("-XX:+UseSerialGC", false);
-        if (!Compiler.isGraalEnabled()) { // Graal does not support CMS
-            test("-XX:+UseConcMarkSweepGC", false);
-            test("-XX:+UseConcMarkSweepGC", true);
-            if (GC.Shenandoah.isSupported()) {
-                test("-XX:+UseShenandoahGC", true);
-                test("-XX:+UseShenandoahGC", false);
-            }
+    private static boolean supportsSTW(GC gc) {
+        return !(gc == GC.Epsilon);
+    }
+
+    private static boolean supportsConcurrent(GC gc) {
+        return !(gc == GC.Epsilon || gc == GC.Serial || gc == GC.Parallel);
+    }
+
+    private static void test(GC gc) throws Throwable {
+        if (supportsSTW(gc)) {
+            test(gc, false);
+        }
+        if (supportsConcurrent(gc)) {
+            test(gc, true);
         }
     }
+
+    public static void main(java.lang.String[] unused) throws Throwable {
+      test(GC.selected());
+    }
 }

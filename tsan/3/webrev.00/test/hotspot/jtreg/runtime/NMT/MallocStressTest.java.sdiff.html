<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/runtime/NMT/MallocStressTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="MallocSiteTypeChange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NMTWithCDS.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/runtime/NMT/MallocStressTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 60     static volatile TestPhase phase = TestPhase.alloc;
 61 
 62     // malloc&#39;d memory
 63     static final ArrayList&lt;MallocMemory&gt;  mallocd_memory = new ArrayList&lt;MallocMemory&gt;();
 64     static long                     mallocd_total  = 0;
 65     static WhiteBox                 whiteBox;
 66     static AtomicInteger            pause_count = new AtomicInteger();
 67 
 68     static final boolean            is_64_bit_system = Platform.is64bit();
 69 
 70     private static boolean is_64_bit_system() { return is_64_bit_system; }
 71 
 72     public static void main(String args[]) throws Exception {
 73         OutputAnalyzer output;
 74         whiteBox = WhiteBox.getWhiteBox();
 75 
 76         // Grab my own PID
 77         String pid = Long.toString(ProcessTools.getProcessId());
 78         ProcessBuilder pb = new ProcessBuilder();
 79 
<span class="line-modified"> 80         AllocThread[]   alloc_threads = new AllocThread[256];</span>
<span class="line-modified"> 81         ReleaseThread[] release_threads = new ReleaseThread[64];</span>
 82 
 83         int index;
 84         // Create many allocation threads
 85         for (index = 0; index &lt; alloc_threads.length; index ++) {
 86             alloc_threads[index] = new AllocThread();
 87         }
 88 
 89         // Fewer release threads
 90         for (index = 0; index &lt; release_threads.length; index ++) {
 91             release_threads[index] = new ReleaseThread();
 92         }
 93 
<span class="line-removed"> 94         if (is_64_bit_system()) {</span>
<span class="line-removed"> 95             sleep_wait(2*60*1000);</span>
<span class="line-removed"> 96         } else {</span>
<span class="line-removed"> 97             sleep_wait(60*1000);</span>
<span class="line-removed"> 98         }</span>
 99         // pause the stress test
100         phase = TestPhase.pause;
101         while (pause_count.intValue() &lt;  alloc_threads.length + release_threads.length) {
102             sleep_wait(10);
103         }
104 
105         long mallocd_total_in_KB = (mallocd_total + K / 2) / K;
106 
107         // Now check if the result from NMT matches the total memory allocated.
108         String expected_test_summary = &quot;Test (reserved=&quot; + mallocd_total_in_KB +&quot;KB, committed=&quot; + mallocd_total_in_KB + &quot;KB)&quot;;
109         // Run &#39;jcmd &lt;pid&gt; VM.native_memory summary&#39;
110         pb.command(new String[] { JDKToolFinder.getJDKTool(&quot;jcmd&quot;), pid, &quot;VM.native_memory&quot;, &quot;summary&quot;});
111         output = new OutputAnalyzer(pb.start());
112         output.shouldContain(expected_test_summary);
113 
114         // Release all allocated memory
115         phase = TestPhase.release;
116         synchronized(mallocd_memory) {
117             mallocd_memory.notifyAll();
118         }
</pre>
<hr />
<pre>
155         private int   size;
156 
157         MallocMemory(long addr, int size) {
158             this.addr = addr;
159             this.size = size;
160         }
161 
162         long addr()  { return this.addr; }
163         int  size()  { return this.size; }
164     }
165 
166     static class AllocThread extends Thread {
167         AllocThread() {
168             this.setName(&quot;MallocThread&quot;);
169             this.start();
170         }
171 
172         // AllocThread only runs &quot;Alloc&quot; phase
173         public void run() {
174             Random random = new Random();
<span class="line-modified">175             while (MallocStressTest.phase == TestPhase.alloc) {</span>

176                 int r = random.nextInt(Integer.MAX_VALUE);
177                 // Only malloc small amount to avoid OOM
178                 int size = r % 32;
179                 if (is_64_bit_system()) {
180                     r = r % 32 * K;
181                 } else {
182                     r = r % 64;
183                 }
184                 if (size == 0) size = 1;
185                 long addr = MallocStressTest.whiteBox.NMTMallocWithPseudoStack(size, r);
186                 if (addr != 0) {
187                     try {
188                         MallocMemory mem = new MallocMemory(addr, size);
189                         synchronized(MallocStressTest.mallocd_memory) {
190                             MallocStressTest.mallocd_memory.add(mem);
191                             MallocStressTest.mallocd_total += size;
192                         }
193                     } catch (OutOfMemoryError e) {
194                         // Don&#39;t include this malloc memory because it didn&#39;t
195                         // get recorded in mallocd_memory list.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 60     static volatile TestPhase phase = TestPhase.alloc;
 61 
 62     // malloc&#39;d memory
 63     static final ArrayList&lt;MallocMemory&gt;  mallocd_memory = new ArrayList&lt;MallocMemory&gt;();
 64     static long                     mallocd_total  = 0;
 65     static WhiteBox                 whiteBox;
 66     static AtomicInteger            pause_count = new AtomicInteger();
 67 
 68     static final boolean            is_64_bit_system = Platform.is64bit();
 69 
 70     private static boolean is_64_bit_system() { return is_64_bit_system; }
 71 
 72     public static void main(String args[]) throws Exception {
 73         OutputAnalyzer output;
 74         whiteBox = WhiteBox.getWhiteBox();
 75 
 76         // Grab my own PID
 77         String pid = Long.toString(ProcessTools.getProcessId());
 78         ProcessBuilder pb = new ProcessBuilder();
 79 
<span class="line-modified"> 80         AllocThread[]   alloc_threads = new AllocThread[40];</span>
<span class="line-modified"> 81         ReleaseThread[] release_threads = new ReleaseThread[10];</span>
 82 
 83         int index;
 84         // Create many allocation threads
 85         for (index = 0; index &lt; alloc_threads.length; index ++) {
 86             alloc_threads[index] = new AllocThread();
 87         }
 88 
 89         // Fewer release threads
 90         for (index = 0; index &lt; release_threads.length; index ++) {
 91             release_threads[index] = new ReleaseThread();
 92         }
 93 





 94         // pause the stress test
 95         phase = TestPhase.pause;
 96         while (pause_count.intValue() &lt;  alloc_threads.length + release_threads.length) {
 97             sleep_wait(10);
 98         }
 99 
100         long mallocd_total_in_KB = (mallocd_total + K / 2) / K;
101 
102         // Now check if the result from NMT matches the total memory allocated.
103         String expected_test_summary = &quot;Test (reserved=&quot; + mallocd_total_in_KB +&quot;KB, committed=&quot; + mallocd_total_in_KB + &quot;KB)&quot;;
104         // Run &#39;jcmd &lt;pid&gt; VM.native_memory summary&#39;
105         pb.command(new String[] { JDKToolFinder.getJDKTool(&quot;jcmd&quot;), pid, &quot;VM.native_memory&quot;, &quot;summary&quot;});
106         output = new OutputAnalyzer(pb.start());
107         output.shouldContain(expected_test_summary);
108 
109         // Release all allocated memory
110         phase = TestPhase.release;
111         synchronized(mallocd_memory) {
112             mallocd_memory.notifyAll();
113         }
</pre>
<hr />
<pre>
150         private int   size;
151 
152         MallocMemory(long addr, int size) {
153             this.addr = addr;
154             this.size = size;
155         }
156 
157         long addr()  { return this.addr; }
158         int  size()  { return this.size; }
159     }
160 
161     static class AllocThread extends Thread {
162         AllocThread() {
163             this.setName(&quot;MallocThread&quot;);
164             this.start();
165         }
166 
167         // AllocThread only runs &quot;Alloc&quot; phase
168         public void run() {
169             Random random = new Random();
<span class="line-modified">170             // MallocStressTest.phase == TestPhase.alloc</span>
<span class="line-added">171             for (int loops = 0; loops &lt; 100; loops++) {</span>
172                 int r = random.nextInt(Integer.MAX_VALUE);
173                 // Only malloc small amount to avoid OOM
174                 int size = r % 32;
175                 if (is_64_bit_system()) {
176                     r = r % 32 * K;
177                 } else {
178                     r = r % 64;
179                 }
180                 if (size == 0) size = 1;
181                 long addr = MallocStressTest.whiteBox.NMTMallocWithPseudoStack(size, r);
182                 if (addr != 0) {
183                     try {
184                         MallocMemory mem = new MallocMemory(addr, size);
185                         synchronized(MallocStressTest.mallocd_memory) {
186                             MallocStressTest.mallocd_memory.add(mem);
187                             MallocStressTest.mallocd_total += size;
188                         }
189                     } catch (OutOfMemoryError e) {
190                         // Don&#39;t include this malloc memory because it didn&#39;t
191                         // get recorded in mallocd_memory list.
</pre>
</td>
</tr>
</table>
<center><a href="MallocSiteTypeChange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NMTWithCDS.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
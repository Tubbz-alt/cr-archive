<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/runtime/NMT/MallocStressTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @summary Stress test for malloc tracking
 27  * @key nmt jcmd stress
 28  * @library /test/lib
 29  * @modules java.base/jdk.internal.misc
 30  *          java.management
 31  * @build sun.hotspot.WhiteBox
 32  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 33  * @run main/othervm/timeout=1200 -Xbootclasspath/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail MallocStressTest
 34  */
 35 
 36 import java.util.concurrent.atomic.AtomicInteger;
 37 import java.util.ArrayList;
 38 import java.util.List;
 39 import java.util.Random;
 40 import jdk.test.lib.JDKToolFinder;
 41 import jdk.test.lib.Platform;
 42 import jdk.test.lib.process.ProcessTools;
 43 import jdk.test.lib.process.OutputAnalyzer;
 44 import sun.hotspot.WhiteBox;
 45 
 46 public class MallocStressTest {
 47     private static int K = 1024;
 48 
 49     // The stress test runs in three phases:
 50     // 1. alloc: A lot of malloc with fewer free, which simulates a burst memory allocation
 51     //    that is usually seen during startup or class loading.
 52     // 2. pause: Pause the test to check accuracy of native memory tracking
 53     // 3. release: Release all malloc&#39;d memory and check native memory tracking result.
 54     public enum TestPhase {
 55         alloc,
 56         pause,
 57         release
 58     };
 59 
 60     static volatile TestPhase phase = TestPhase.alloc;
 61 
 62     // malloc&#39;d memory
 63     static final ArrayList&lt;MallocMemory&gt;  mallocd_memory = new ArrayList&lt;MallocMemory&gt;();
 64     static long                     mallocd_total  = 0;
 65     static WhiteBox                 whiteBox;
 66     static AtomicInteger            pause_count = new AtomicInteger();
 67 
 68     static final boolean            is_64_bit_system = Platform.is64bit();
 69 
 70     private static boolean is_64_bit_system() { return is_64_bit_system; }
 71 
 72     public static void main(String args[]) throws Exception {
 73         OutputAnalyzer output;
 74         whiteBox = WhiteBox.getWhiteBox();
 75 
 76         // Grab my own PID
 77         String pid = Long.toString(ProcessTools.getProcessId());
 78         ProcessBuilder pb = new ProcessBuilder();
 79 
<a name="2" id="anc2"></a><span class="line-modified"> 80         AllocThread[]   alloc_threads = new AllocThread[256];</span>
<span class="line-modified"> 81         ReleaseThread[] release_threads = new ReleaseThread[64];</span>
 82 
 83         int index;
 84         // Create many allocation threads
 85         for (index = 0; index &lt; alloc_threads.length; index ++) {
 86             alloc_threads[index] = new AllocThread();
 87         }
 88 
 89         // Fewer release threads
 90         for (index = 0; index &lt; release_threads.length; index ++) {
 91             release_threads[index] = new ReleaseThread();
 92         }
 93 
<a name="3" id="anc3"></a><span class="line-removed"> 94         if (is_64_bit_system()) {</span>
<span class="line-removed"> 95             sleep_wait(2*60*1000);</span>
<span class="line-removed"> 96         } else {</span>
<span class="line-removed"> 97             sleep_wait(60*1000);</span>
<span class="line-removed"> 98         }</span>
 99         // pause the stress test
100         phase = TestPhase.pause;
101         while (pause_count.intValue() &lt;  alloc_threads.length + release_threads.length) {
102             sleep_wait(10);
103         }
104 
105         long mallocd_total_in_KB = (mallocd_total + K / 2) / K;
106 
107         // Now check if the result from NMT matches the total memory allocated.
108         String expected_test_summary = &quot;Test (reserved=&quot; + mallocd_total_in_KB +&quot;KB, committed=&quot; + mallocd_total_in_KB + &quot;KB)&quot;;
109         // Run &#39;jcmd &lt;pid&gt; VM.native_memory summary&#39;
110         pb.command(new String[] { JDKToolFinder.getJDKTool(&quot;jcmd&quot;), pid, &quot;VM.native_memory&quot;, &quot;summary&quot;});
111         output = new OutputAnalyzer(pb.start());
112         output.shouldContain(expected_test_summary);
113 
114         // Release all allocated memory
115         phase = TestPhase.release;
116         synchronized(mallocd_memory) {
117             mallocd_memory.notifyAll();
118         }
119 
120         // Join all threads
121         for (index = 0; index &lt; alloc_threads.length; index ++) {
122             try {
123                 alloc_threads[index].join();
124             } catch (InterruptedException e) {
125             }
126         }
127 
128         for (index = 0; index &lt; release_threads.length; index ++) {
129             try {
130                 release_threads[index].join();
131             } catch (InterruptedException e) {
132             }
133         }
134 
135         // All test memory allocated should be released
136         output = new OutputAnalyzer(pb.start());
137         output.shouldNotContain(&quot;Test (reserved=&quot;);
138 
139         // Verify that tracking level has not been downgraded
140         pb.command(new String[] { JDKToolFinder.getJDKTool(&quot;jcmd&quot;), pid, &quot;VM.native_memory&quot;, &quot;statistics&quot;});
141         output = new OutputAnalyzer(pb.start());
142         output.shouldNotContain(&quot;Tracking level has been downgraded due to lack of resources&quot;);
143     }
144 
145     private static void sleep_wait(int n) {
146         try {
147             Thread.sleep(n);
148         } catch (InterruptedException e) {
149         }
150     }
151 
152 
153     static class MallocMemory {
154         private long  addr;
155         private int   size;
156 
157         MallocMemory(long addr, int size) {
158             this.addr = addr;
159             this.size = size;
160         }
161 
162         long addr()  { return this.addr; }
163         int  size()  { return this.size; }
164     }
165 
166     static class AllocThread extends Thread {
167         AllocThread() {
168             this.setName(&quot;MallocThread&quot;);
169             this.start();
170         }
171 
172         // AllocThread only runs &quot;Alloc&quot; phase
173         public void run() {
174             Random random = new Random();
<a name="4" id="anc4"></a><span class="line-modified">175             while (MallocStressTest.phase == TestPhase.alloc) {</span>

176                 int r = random.nextInt(Integer.MAX_VALUE);
177                 // Only malloc small amount to avoid OOM
178                 int size = r % 32;
179                 if (is_64_bit_system()) {
180                     r = r % 32 * K;
181                 } else {
182                     r = r % 64;
183                 }
184                 if (size == 0) size = 1;
185                 long addr = MallocStressTest.whiteBox.NMTMallocWithPseudoStack(size, r);
186                 if (addr != 0) {
187                     try {
188                         MallocMemory mem = new MallocMemory(addr, size);
189                         synchronized(MallocStressTest.mallocd_memory) {
190                             MallocStressTest.mallocd_memory.add(mem);
191                             MallocStressTest.mallocd_total += size;
192                         }
193                     } catch (OutOfMemoryError e) {
194                         // Don&#39;t include this malloc memory because it didn&#39;t
195                         // get recorded in mallocd_memory list.
196                         MallocStressTest.whiteBox.NMTFree(addr);
197                         break;
198                     }
199                 } else {
200                     break;
201                 }
202             }
203             MallocStressTest.pause_count.incrementAndGet();
204         }
205     }
206 
207     static class ReleaseThread extends Thread {
208         private Random random = new Random();
209         ReleaseThread() {
210             this.setName(&quot;ReleaseThread&quot;);
211             this.start();
212         }
213 
214         public void run() {
215             while(true) {
216                 switch(MallocStressTest.phase) {
217                 case alloc:
218                     slow_release();
219                     break;
220                 case pause:
221                     enter_pause();
222                     break;
223                 case release:
224                     quick_release();
225                     return;
226                 }
227             }
228         }
229 
230         private void enter_pause() {
231             MallocStressTest.pause_count.incrementAndGet();
232             while (MallocStressTest.phase != MallocStressTest.TestPhase.release) {
233                 try {
234                     synchronized(MallocStressTest.mallocd_memory) {
235                         MallocStressTest.mallocd_memory.wait(10);
236                     }
237                 } catch (InterruptedException e) {
238                 }
239             }
240         }
241 
242         private void quick_release() {
243             List&lt;MallocMemory&gt; free_list;
244             while (true) {
245                 synchronized(MallocStressTest.mallocd_memory) {
246                     if (MallocStressTest.mallocd_memory.isEmpty()) return;
247                     int size =  Math.min(MallocStressTest.mallocd_memory.size(), 5000);
248                     List&lt;MallocMemory&gt; subList = MallocStressTest.mallocd_memory.subList(0, size);
249                     free_list = new ArrayList&lt;MallocMemory&gt;(subList);
250                     subList.clear();
251                 }
252                 for (int index = 0; index &lt; free_list.size(); index ++) {
253                     MallocMemory mem = free_list.get(index);
254                     MallocStressTest.whiteBox.NMTFree(mem.addr());
255                 }
256             }
257         }
258 
259         private void slow_release() {
260             try {
261                 Thread.sleep(10);
262             } catch (InterruptedException e) {
263             }
264             synchronized(MallocStressTest.mallocd_memory) {
265                 if (MallocStressTest.mallocd_memory.isEmpty()) return;
266                 int n = random.nextInt(MallocStressTest.mallocd_memory.size());
267                 MallocMemory mem = mallocd_memory.remove(n);
268                 MallocStressTest.whiteBox.NMTFree(mem.addr());
269                 MallocStressTest.mallocd_total -= mem.size();
270             }
271         }
272     }
273 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/cds/appcds/test-classes/ParallelLoad.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 import java.io.*;
 26 import java.net.*;
 27 import java.lang.reflect.Field;
 28 import java.util.concurrent.atomic.AtomicInteger;
 29 
 30 
 31 // This test helper is parameterized by:
 32 // - class transformation mode: property &quot;appcds.parallel.transform.mode&quot;
 33 // - class loader test types
 34 //
 35 // In the case of transformMode == &quot;cflh&quot;, the transformation is performed
 36 // by AppCDS/jvmti/TransformerAgent.java. The classes to be transformed, such as
 37 // ParallelClassTr0, are defined in ./jvmti/parallelLoad/ParallelClasses.java
 38 
 39 public class ParallelLoad {
 40     public static int MAX_CLASSES = 40;
 41     public static int NUM_THREADS = 4;
 42 
 43     public final static int SYSTEM_LOADER = 0;
 44     public final static int SINGLE_CUSTOM_LOADER = 1;
 45     public final static int MULTI_CUSTOM_LOADER = 2;
 46 
 47     public static final int FINGERPRINT_MODE = 1;
 48     public static final int API_MODE         = 2;
 49 
 50     public static int loaderType = SYSTEM_LOADER;
 51     public static ClassLoader classLoaders[];
 52     public static int mode = FINGERPRINT_MODE;
 53 
 54     public static float timeoutFactor =
 55         Float.parseFloat(System.getProperty(&quot;test.timeout.factor&quot;, &quot;1.0&quot;));
 56 
 57     public static void main(String args[]) throws Throwable {
 58         run(args, null);
 59     }
 60     public static void run(String args[], ClassLoader loaders[]) throws Throwable {
 61         String customJar = null;
 62         System.out.println(&quot;ParallelLoad: timeoutFactor = &quot; + timeoutFactor);
 63 
 64         if (args.length &gt;= 1) {
 65             if (&quot;SINGLE_CUSTOM_LOADER&quot;.equals(args[0])) {
 66                 loaderType = SINGLE_CUSTOM_LOADER;
 67                 customJar = args[2];
 68             } else if (&quot;MULTI_CUSTOM_LOADER&quot;.equals(args[0])) {
 69                 loaderType = MULTI_CUSTOM_LOADER;
 70                 customJar = args[2];
 71             } else if (&quot;SYSTEM_LOADER&quot;.equals(args[0])) {
 72                 loaderType = SYSTEM_LOADER;
 73             } else {
 74                 throw new RuntimeException(&quot;Unexpected loaderType&quot; + args[0]);
 75             }
 76         }
 77 
 78         if (customJar != null) {
 79             if (&quot;FINGERPRINT_MODE&quot;.equals(args[1])) {
 80                 mode = FINGERPRINT_MODE;
 81                 classLoaders = new ClassLoader[NUM_THREADS];
 82                 for (int i = 0; i &lt; NUM_THREADS; i++) {
 83                     URL url = new File(customJar).toURI().toURL();
 84                     URL[] urls = new URL[] {url};
 85                     classLoaders[i] = new URLClassLoader(urls);
 86                 }
 87             } else {
 88                 // Loaders must be supplied by caller of the run() method
 89                 mode = API_MODE;
 90                 classLoaders = loaders;
 91             }
 92         }
 93 
 94         System.out.println(&quot;Start Parallel Load ...&quot;);
 95 
 96         Thread thread[] = new Thread[NUM_THREADS];
 97         for (int i = 0; i &lt; NUM_THREADS; i++) {
 98             Thread t = new ParallelLoadThread(i);
 99             t.start();
100             thread[i] = t;
101         }
102 
103         Thread watchdog = new ParallelLoadWatchdog();
104         watchdog.setDaemon(true);
105         watchdog.start();
106 
107         for (int i = 0; i &lt; NUM_THREADS; i++) {
108             thread[i].join();
109         }
110         System.out.println(&quot;Parallel Load ... done&quot;);
111         System.exit(0);
112     }
113 }
114 
115 
116 class ParallelLoadWatchdog extends Thread {
117     public void run() {
118         try {
119             long timeout = (long) (20 * 1000 * ParallelLoad.timeoutFactor);
120             Thread.sleep(timeout);
121             System.out.println(&quot;ParallelLoadWatchdog: Timeout reached: timeout(ms) = &quot; + timeout);
122             System.exit(1);
123         } catch (Throwable t) {
124             t.printStackTrace();
125             System.exit(1);
126         }
127     }
128 };
129 
130 
131 class ParallelLoadThread extends Thread {
132     static AtomicInteger num_ready[];
133     static {
134         num_ready = new AtomicInteger[ParallelLoad.MAX_CLASSES];
135         for (int i = 0; i &lt; ParallelLoad.MAX_CLASSES; i++) {
136             num_ready[i] = new AtomicInteger();
137         }
138     }
139     static String transformMode =
140         System.getProperty(&quot;appcds.parallel.transform.mode&quot;, &quot;none&quot;);
141 
142     int thread_id;
143     ParallelLoadThread(int thread_id) {
144         this.thread_id = thread_id;
145     }
146 
147     public void run() {
148         try {
149             run0();
150         } catch (Throwable t) {
151             t.printStackTrace();
152             System.exit(1);
153         }
154     }
155 
156     private static void log(String msg, Object... args) {
157         String msg0 = &quot;ParallelLoadThread: &quot; + String.format(msg, args);
158         System.out.println(msg0);
159     }
160 
161     private void run0() throws Throwable {
162         for (int i = 0;  i &lt; ParallelLoad.MAX_CLASSES; i++) {
163             String className = &quot;ParallelClass&quot; + i;
164             if (transformMode.equals(&quot;cflh&quot;)) {
165                 className = &quot;ParallelClassTr&quot; + i;
166             }
167             Class clazz = null;
168 
169             // Spin until every thread is ready to proceed
170             num_ready[i].incrementAndGet();
171             while (num_ready[i].intValue() &lt; ParallelLoad.NUM_THREADS) {
172                 ;
173             }
174 
175             {   // Avoid logging in this block so the threads can proceed without
176                 // waiting for the stdout lock, etc.
177                 switch (ParallelLoad.loaderType) {
178                 case ParallelLoad.SYSTEM_LOADER:
179                     clazz = Class.forName(className);
180                     break;
181                 case ParallelLoad.SINGLE_CUSTOM_LOADER:
182                     clazz = ParallelLoad.classLoaders[0].loadClass(className);
183                     break;
184                 case ParallelLoad.MULTI_CUSTOM_LOADER:
185                     clazz = ParallelLoad.classLoaders[thread_id].loadClass(className);
186                     break;
187                 }
188                 testTransformation(clazz);
189             }
190 
191             log(&quot;thread[%d] t = %s, c = %s, l = %s&quot;, thread_id, this, clazz, clazz.getClassLoader());
192         }
193     }
194 
195     private void testTransformation(Class c) throws Exception {
196         if (transformMode.equals(&quot;none&quot;))
197             return;
198 
199         // currently only cflh transform mode is supported
200         if (!transformMode.equals(&quot;cflh&quot;)) {
201             String msg = &quot;wrong transform mode: &quot; + transformMode;
202             throw new IllegalArgumentException(msg);
203         }
204 
205         Field[] fields = c.getFields();
206         boolean fieldFound = false;
207         for (Field f : fields) {
208             if (f.getName().equals(&quot;testString&quot;)) {
209                 checkTransformationString(c, (String) f.get(null));
210                 fieldFound = true;
211             }
212         }
213 
214         if (!fieldFound)
215             throw new RuntimeException (&quot;Expected field &#39;testString&#39; not found&quot;);
216     }
217 
218     private void checkTransformationString(Class c, String actual) throws Exception {
219         String expected = &quot;class-transform-check: this-has-been--transformed&quot;;
220         if (!actual.equals(expected)) {
221             String msg1 = &quot;Transformation failed for class&quot; + c.getName();
222             String msg2 = String.format(&quot;Expected: %s, actual: %s&quot;, expected, actual);
223             throw new RuntimeException(msg1 + &quot;\n&quot; + msg2);
224         }
225     }
226 }
227 
    </pre>
  </body>
</html>
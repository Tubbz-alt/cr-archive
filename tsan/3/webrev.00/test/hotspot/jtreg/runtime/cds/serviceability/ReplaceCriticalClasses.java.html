<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/cds/serviceability/ReplaceCriticalClasses.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 /*
 26  * @test
 27  * @summary Tests how CDS works when critical library classes are replaced with JVMTI ClassFileLoadHook
 28  * @library /test/lib
 29  * @requires vm.cds
 30  * @build sun.hotspot.WhiteBox
 31  * @run driver ClassFileInstaller -jar whitebox.jar sun.hotspot.WhiteBox
 32  * @run main/othervm/native ReplaceCriticalClasses
 33  */
 34 
 35 import java.util.regex.Matcher;
 36 import java.util.regex.Pattern;
 37 import jdk.test.lib.cds.CDSTestUtils;
 38 import jdk.test.lib.cds.CDSOptions;
 39 import jdk.test.lib.process.OutputAnalyzer;
 40 import sun.hotspot.WhiteBox;
 41 
 42 public class ReplaceCriticalClasses {
 43     public static void main(String args[]) throws Throwable {
 44         ReplaceCriticalClasses rcc = new ReplaceCriticalClasses();
 45         rcc.process(args);
 46     }
 47 
 48     public void process(String args[]) throws Throwable {
 49         if (args.length == 0) {
 50             // Dump the shared archive in case it was not generated during the JDK build.
 51             // Put the archive at separate file to avoid clashes with concurrent tests.
 52             CDSOptions opts = new CDSOptions()
 53                 .setXShareMode(&quot;dump&quot;)
 54                 .setArchiveName(ReplaceCriticalClasses.class.getName() + &quot;.jsa&quot;)
 55                 .setUseVersion(false)
 56                 .addSuffix(&quot;-showversion&quot;);
 57             CDSTestUtils.run(opts).assertNormalExit(&quot;&quot;);
 58 
 59             launchChildProcesses(getTests());
 60         } else if (args.length == 3 &amp;&amp; args[0].equals(&quot;child&quot;)) {
 61             Class klass = Class.forName(args[2].replace(&quot;/&quot;, &quot;.&quot;));
 62             if (args[1].equals(&quot;-shared&quot;)) {
 63                 testInChild(true, klass);
 64             } else if (args[1].equals(&quot;-notshared&quot;)) {
 65                 testInChild(false, klass);
 66             } else {
 67                 throw new RuntimeException(&quot;Unknown child exec option &quot; + args[1]);
 68             }
 69             return;
 70         } else {
 71             throw new RuntimeException(&quot;Usage: @run main/othervm/native ReplaceCriticalClasses&quot;);
 72         }
 73     }
 74 
 75     public String[] getTests() {
 76         String tests[] = {
 77             // CDS should be disabled -- these critical classes will be replaced
 78             // because JvmtiExport::early_class_hook_env() is true.
 79             &quot;-early -notshared java/lang/Object&quot;,
 80             &quot;-early -notshared java/lang/String&quot;,
 81             &quot;-early -notshared java/lang/Cloneable&quot;,
 82             &quot;-early -notshared java/io/Serializable&quot;,
 83 
 84             // CDS should not be disabled -- these critical classes cannot be replaced because
 85             // JvmtiExport::early_class_hook_env() is false.
 86             &quot;java/lang/Object&quot;,
 87             &quot;java/lang/String&quot;,
 88             &quot;java/lang/Cloneable&quot;,
 89             &quot;java/io/Serializable&quot;,
 90 
 91             /* Try to replace classes that are used by the archived subgraph graphs.
 92                The following test cases are in ReplaceCriticalClassesForSubgraphs.java.
 93             &quot;-early -notshared -subgraph java/lang/module/ResolvedModule jdk.internal.module.ArchivedModuleGraph&quot;,
 94             &quot;-early -notshared -subgraph java/lang/Long java.lang.Long$LongCache&quot;,
 95             &quot;-subgraph java/lang/Long java.lang.Long$LongCache&quot;,
 96             */
 97 
 98             // Replace classes that are loaded after JVMTI_PHASE_PRIMORDIAL. It&#39;s OK to replace
 99             // such
100             // classes even when CDS is enabled. Nothing bad should happen.
101             &quot;-notshared java/util/Locale&quot;,
102             &quot;-notshared sun/util/locale/BaseLocale&quot;,
103             &quot;-notshared java/lang/Readable&quot;,
104         };
105         return tests;
106     }
107 
108     static void launchChildProcesses(String tests[]) throws Throwable {
109         int n = 0;
110         for (String s : tests) {
111             System.out.println(&quot;Test case[&quot; + (n++) + &quot;] = \&quot;&quot; + s + &quot;\&quot;&quot;);
112             String args[] = s.split(&quot;\\s+&quot;); // split by space character
113             launchChild(args);
114         }
115     }
116 
117     static void launchChild(String args[]) throws Throwable {
118         if (args.length &lt; 1) {
119             throw new RuntimeException(&quot;Invalid test case. Should be &lt;-early&gt; &lt;-subgraph&gt; &lt;-notshared&gt; klassName subgraphKlass&quot;);
120         }
121         String klassName = null;
122         String subgraphKlass = null;
123         String early = &quot;&quot;;
124         boolean subgraph = false;
125         String shared = &quot;-shared&quot;;
126 
127         for (int i=0; i&lt;args.length-1; i++) {
128             String opt = args[i];
129             if (opt.equals(&quot;-early&quot;)) {
130                 early = &quot;-early,&quot;;
131             } else if (opt.equals(&quot;-subgraph&quot;)) {
132                 subgraph = true;
133             } else if (opt.equals(&quot;-notshared&quot;)) {
134                 shared = opt;
135             } else {
136               if (!subgraph) {
137                 throw new RuntimeException(&quot;Unknown option: &quot; + opt);
138               }
139             }
140         }
141         if (subgraph) {
142           klassName = args[args.length-2];
143           subgraphKlass = args[args.length-1];
144         } else {
145           klassName = args[args.length-1];
146         }
147         Class.forName(klassName.replace(&quot;/&quot;, &quot;.&quot;)); // make sure it&#39;s a valid class
148         final String subgraphInit = &quot;initialize_from_archived_subgraph &quot; + subgraphKlass;
149 
150         // We will pass an option like &quot;-agentlib:SimpleClassFileLoadHook=java/util/Locale,XXX,XXX&quot;.
151         // The SimpleClassFileLoadHook agent would attempt to hook the java/util/Locale class
152         // but leave the class file bytes unchanged (it replaces all bytes &quot;XXX&quot; with &quot;XXX&quot;, i.e.,
153         // a no-op). JVMTI doesn&#39;t check the class file bytes returned by the agent, so as long
154         // as the agent returns a buffer, it will not load the class from CDS, and will instead
155         // load the class by parsing the buffer.
156         //
157         // Note that for safety we don&#39;t change the contents of the class file bytes. If in the
158         // future JVMTI starts checking the contents of the class file bytes, this test would need
159         // to be updated. (You&#39;d see the test case with java/util/Locale staring to fail).
160         String agent = &quot;-agentlib:SimpleClassFileLoadHook=&quot; + early + klassName + &quot;,XXX,XXX&quot;;
161 
162         CDSOptions opts = (new CDSOptions())
163             .setXShareMode(&quot;auto&quot;)
164             .setArchiveName(ReplaceCriticalClasses.class.getName() + &quot;.jsa&quot;)
165             .setUseVersion(false)
166             .addSuffix(&quot;-showversion&quot;,
167                        &quot;-Xlog:cds&quot;,
168                        &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
169                        agent,
170                        &quot;-XX:+WhiteBoxAPI&quot;,
171                        &quot;-Xbootclasspath/a:&quot; + ClassFileInstaller.getJarPath(&quot;whitebox.jar&quot;));
172 
173         if (subgraph) {
174             opts.addSuffix(&quot;-Xlog:cds,cds+heap&quot;);
175         }
176 
177         opts.addSuffix(&quot;ReplaceCriticalClasses&quot;,
178                        &quot;child&quot;,
179                        shared,
180                        klassName);
181 
182         final boolean expectDisable = !early.equals(&quot;&quot;);
183         final boolean checkSubgraph = subgraph;
184         final boolean expectShared = shared.equals(&quot;-shared&quot;);
185         CDSTestUtils.run(opts).assertNormalExit(out -&gt; {
186                 if (expectDisable) {
187                     out.shouldContain(&quot;UseSharedSpaces: CDS is disabled because early JVMTI ClassFileLoadHook is in use.&quot;);
188                     System.out.println(&quot;CDS disabled as expected&quot;);
189                 }
190                 if (checkSubgraph) {
191                     if (expectShared) {
192                         if (!out.getOutput().contains(&quot;UseSharedSpaces: Unable to map at required address in java heap&quot;)) {
193                             out.shouldContain(subgraphInit);
194                         }
195                     } else {
196                       out.shouldNotContain(subgraphInit);
197                     }
198                 }
199             });
200     }
201 
202     static void testInChild(boolean shouldBeShared, Class klass) {
203         WhiteBox wb = WhiteBox.getWhiteBox();
204 
205         if (shouldBeShared &amp;&amp; !wb.isSharedClass(klass)) {
206             throw new RuntimeException(klass + &quot; should be shared but but actually is not.&quot;);
207         }
208         if (!shouldBeShared &amp;&amp; wb.isSharedClass(klass)) {
209             throw new RuntimeException(klass + &quot; should not be shared but actually is.&quot;);
210         }
211         System.out.println(&quot;wb.isSharedClass(klass): &quot; + wb.isSharedClass(klass) + &quot; == &quot; + shouldBeShared);
212 
213         String strings[] = {
214             // interned strings from j.l.Object
215             &quot;@&quot;,
216             &quot;nanosecond timeout value out of range&quot;,
217             &quot;timeoutMillis value is negative&quot;,
218 
219             // interned strings from j.l.Integer
220             &quot;0&quot;,
221             &quot;0X&quot;,
222             &quot;0x&quot;,
223             &quot;int&quot;
224         };
225 
226         // Make sure the interned string table is same
227         for (String s : strings) {
228             String i = s.intern();
229             if (s != i) {
230                 throw new RuntimeException(&quot;Interned string mismatch: \&quot;&quot; + s + &quot;\&quot; @ &quot; + System.identityHashCode(s) +
231                                            &quot; vs \&quot;&quot; + i + &quot;\&quot; @ &quot; + System.identityHashCode(i));
232             }
233         }
234         // We have tried to use ClassFileLoadHook to replace critical library classes (which may
235         // may not have succeeded, depending on whether the agent has requested
236         // can_generate_all_class_hook_events/can_generate_early_class_hook_events capabilities).
237         //
238         // In any case, the JVM should have started properly (perhaps with CDS disabled) and
239         // the above operations should succeed.
240         System.out.println(&quot;If I can come to here without crashing, things should be OK&quot;);
241     }
242 }
    </pre>
  </body>
</html>
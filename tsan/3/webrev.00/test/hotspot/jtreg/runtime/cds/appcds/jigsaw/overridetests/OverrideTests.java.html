<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/cds/appcds/jigsaw/overridetests/OverrideTests.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 /**
 26  * @test
 27  * @requires vm.cds
 28  * @library ../..
 29  * @library /test/lib
 30  * @compile ../../test-classes/Hello.java
 31  * @run driver OverrideTests
 32  * @summary AppCDS tests for overriding archived classes with -p and --upgrade-module-path
 33  */
 34 
 35 /*
 36  * This test consists of 4 tests:
 37  *   1. Archive PLATFORM class and override with --upgrade-module-path.
 38  *   2. Archive PLATFORM class and override with -p.
 39  *   3. Archive APP class and override with --upgrade-module-path.
 40  *   4. Archive App class and override with -p.
 41  * For all 4 tests, the class is instantiatied and toString() is called
 42  * to check whether the archived version or the override version was instantiatied.
 43  * For tests 1 and 3, the overridden version should be instantiatied.
 44  * For tests 2 and 4, the archived version should be instantiated.
 45  *
 46  * This test uses the same test helper class in all 4 cases. It is located in
 47  * src/test/jdk/test/Main.java. It will be invoked once for each test cases,
 48  * with parameters to the test determining how it is run and what the
 49  * expected result is. See Main.java for a description of these 3 arguments.
 50  */
 51 
 52 import java.io.File;
 53 import java.nio.file.Files;
 54 import java.nio.file.Path;
 55 import java.nio.file.Paths;
 56 
 57 import jdk.test.lib.Asserts;
 58 import jdk.test.lib.cds.CDSOptions;
 59 import jdk.test.lib.cds.CDSTestUtils;
 60 import jdk.test.lib.process.OutputAnalyzer;
 61 import jdk.test.lib.process.ProcessTools;
 62 
 63 
 64 public class OverrideTests {
 65     private static final String TEST_SRC = System.getProperty(&quot;test.src&quot;);
 66     private static final Path SRC_DIR = Paths.get(TEST_SRC, &quot;src&quot;);
 67     private static final Path MODS_DIR = Paths.get(&quot;mods&quot;);
 68     private static String appJar;
 69     // the module that is upgraded
 70     private static final String[] UPGRADED_MODULES = {&quot;jdk.compiler&quot;, &quot;java.net.http&quot;};
 71     private static final Path[] UPGRADEDMODS_DIR = {Paths.get(&quot;upgradedmod1&quot;), Paths.get(&quot;upgradedmod2&quot;)};
 72 
 73     // the test module
 74     private static final String TEST_MODULE = &quot;test&quot;;
 75     private static final String MAIN_CLASS = &quot;jdk.test.Main&quot;;
 76 
 77     // test classes to archive. These are both in UPGRADED_MODULES
 78     private static final String APP_ARCHIVE_CLASS = &quot;com/sun/tools/javac/Main&quot;;
 79     private static final String PLATFORM_ARCHIVE_CLASS = &quot;java/net/http/HttpTimeoutException&quot;;
 80     private static final String[] ARCHIVE_CLASSES = {APP_ARCHIVE_CLASS, PLATFORM_ARCHIVE_CLASS};
 81     private static String testArchiveName;
 82 
 83 
 84     public static void main(String[] args) throws Exception {
 85         appJar = JarBuilder.getOrCreateHelloJar();
 86         OverrideTests tests = new OverrideTests();
 87         tests.compileModulesAndDumpArchive();
 88         tests.testAppClassOverriding();
 89         tests.testPlatformClassOverriding();
 90     }
 91 
 92     void compileModulesAndDumpArchive() throws Exception {
 93         boolean compiled;
 94         // javac -d upgradedmods/$upgradedMod src/$upgradedMod/**
 95         int i = 0;
 96         for (String upgradedMod : UPGRADED_MODULES) {
 97             compiled = CompilerUtils.compile(
 98                 SRC_DIR.resolve(UPGRADED_MODULES[i]),
 99                 UPGRADEDMODS_DIR[i].resolve(UPGRADED_MODULES[i])
100             );
101             Asserts.assertTrue(compiled, UPGRADED_MODULES[i] + &quot; did not compile&quot;);
102             i++;
103         }
104 
105         // javac -d mods/test --upgrade-module-path upgradedmods ...
106         compiled = CompilerUtils.compile(
107             SRC_DIR.resolve(TEST_MODULE),
108             MODS_DIR.resolve(TEST_MODULE),
109             &quot;--upgrade-module-path&quot;, UPGRADEDMODS_DIR[0].toString() +
110              System.getProperty(&quot;path.separator&quot;) + UPGRADEDMODS_DIR[1].toString()
111         );
112         Asserts.assertTrue(compiled, TEST_MODULE + &quot; did not compile&quot;);
113 
114         // dump the archive with jdk.compiler and java.net.http classes in the class list
115         OutputAnalyzer output  = TestCommon.dump(appJar, TestCommon.list(ARCHIVE_CLASSES));
116         TestCommon.checkDump(output);
117         // Make sure all the classes where successfully archived.
118         for (String archiveClass : ARCHIVE_CLASSES) {
119             output.shouldNotContain(&quot;Preload Warning: Cannot find &quot; + archiveClass);
120         }
121 
122         testArchiveName = TestCommon.getCurrentArchiveName();
123     }
124 
125     /**
126      * APP Class Overriding Tests
127      *
128      * Archive APP class com.sun.tools.javac.Main from module jdk.compiler.
129      *  -At run time, upgrade module jdk.compiler using --upgrade-module-path.
130      *   Class.forname(Main) MUST NOT load the archived Main.
131      *  -At run time, module jdk.compiler also exists in --module-path.
132      *   Class.forname(Main) MUST load the archived Main.
133      */
134     public void testAppClassOverriding() throws Exception {
135         testClassOverriding(APP_ARCHIVE_CLASS, &quot;app&quot;);
136     }
137 
138     /**
139      * PLATFORM Class Overriding Tests
140      *
141      * Archive PLATFORM class java.net.http.HttpTimeoutException from module java.net.http.
142      *  -At run time, upgrade module java.net.http using --upgrade-module-path.
143      *   Class.forname(HttpTimeoutException) MUST NOT load the archived HttpTimeoutException.
144      *  -At run time, module java.net.http also exists in --module-path.
145      *   Class.forname(HttpTimeoutException) MUST load the archived HttpTimeoutException.
146      */
147     public void testPlatformClassOverriding() throws Exception {
148         testClassOverriding(PLATFORM_ARCHIVE_CLASS, &quot;platform&quot;);
149     }
150 
151     /**
152      * Run the test twice. Once with upgrade module on --upgrade-module-path and once with it on -p.
153      * Only modules defined to the PlatformClassLoader are upgradeable.
154      * Modules defined to the AppClassLoader are not upgradeble; we expect the
155      * FindException to be thrown.
156      */
157     void testClassOverriding(String archiveClass, String loaderName) throws Exception {
158         String mid = TEST_MODULE + &quot;/&quot; + MAIN_CLASS;
159         OutputAnalyzer output;
160         boolean isAppLoader = loaderName.equals(&quot;app&quot;);
161         int upgradeModIdx = isAppLoader ? 0 : 1;
162         String expectedException = &quot;java.lang.module.FindException: Unable to compute the hash&quot;;
163         String prefix[] = new String[3];
164         prefix[0] = &quot;-Djava.class.path=&quot; + appJar;
165         prefix[1] = &quot;--add-modules&quot;;
166         prefix[2] = &quot;java.net.http&quot;;
167 
168         // Run the test with --upgrade-module-path set to alternate location of archiveClass
169         // The alternate version of archiveClass SHOULD be found.
170         TestCommon.runWithModules(prefix,
171                                   UPGRADEDMODS_DIR[upgradeModIdx].toString(),
172                                   MODS_DIR.toString(),
173                                   mid,
174                                   archiveClass, loaderName, &quot;true&quot;) // last 3 args passed to test
175             .ifNoMappingFailure(out -&gt; out.shouldContain(expectedException));
176 
177         // Now run this same test again, but this time without AppCDS. Behavior should be the same.
178         CDSOptions opts = (new CDSOptions())
179             .addPrefix(prefix)
180             .setArchiveName(testArchiveName).setUseVersion(false)
181             .addSuffix(&quot;--upgrade-module-path&quot;, UPGRADEDMODS_DIR[upgradeModIdx].toString(),
182                        &quot;-p&quot;, MODS_DIR.toString(), &quot;-m&quot;, mid)
183             .addSuffix(archiveClass, loaderName, &quot;true&quot;);
184 
185         output = CDSTestUtils.runWithArchive(opts);
186 
187         try {
188             output.shouldContain(expectedException);
189         } catch (Exception e) {
190             TestCommon.checkCommonExecExceptions(output, e);
191         }
192 
193         // Run the test with -p set to alternate location of archiveClass.
194         // The alternate version of archiveClass SHOULD NOT be found.
195         TestCommon.runWithModules(
196             prefix,
197             null,
198             UPGRADEDMODS_DIR[upgradeModIdx].toString() + java.io.File.pathSeparator + MODS_DIR.toString(),
199             mid,
200             archiveClass, loaderName, &quot;false&quot;) // last 3 args passed to test
201             .assertNormalExit();
202 
203         // Now  run this same test again, but this time without AppCDS. Behavior should be the same.
204         opts = (new CDSOptions())
205             .addPrefix(prefix)
206             .setArchiveName(testArchiveName).setUseVersion(false)
207             .addSuffix(&quot;-p&quot;, MODS_DIR.toString(), &quot;-m&quot;, mid)
208             .addSuffix(archiveClass, loaderName, &quot;false&quot;); // params to the test class
209 
210         OutputAnalyzer out = CDSTestUtils.runWithArchive(opts);
211         if (!CDSTestUtils.isUnableToMap(out))
212             out.shouldHaveExitValue(0);
213     }
214 }
    </pre>
  </body>
</html>
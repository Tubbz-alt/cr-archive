<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/cds/appcds/dynamicArchive/test-classes/MethodSortingApp.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 import java.util.concurrent.BlockingQueue;
 26 import java.util.concurrent.SynchronousQueue;
 27 
 28 public class MethodSortingApp {
 29     static class HelloA {
 30         String aaaa() { return &quot;aaaa&quot;; }
 31         String bbbb() { return &quot;bbbb&quot;; }
 32         String dddd() { return &quot;dddd&quot;; }
 33         String eeee() { return &quot;eeee&quot;; }
 34         String gggg() { return &quot;gggg&quot;; }
 35     }
 36 
 37     static class HelloA1 extends HelloA {
 38         String aaaa() { return &quot;aaa-&quot;; }
 39         String dddd() { return &quot;ddd-&quot;; }
 40         String gggg() { return &quot;ggg-&quot;; }
 41     }
 42 
 43     static class HelloB {
 44         String aaaa() { return &quot;aaaa&quot;; }
 45         String cccc() { return &quot;cccc&quot;; }
 46         String dddd() { return &quot;dddd&quot;; }
 47         String ffff() { return &quot;ffff&quot;; }
 48         String gggg() { return &quot;gggg&quot;; }
 49     }
 50 
 51     static class HelloB1 extends HelloB {
 52         String aaaa() { return &quot;aaa-&quot;; }
 53         String dddd() { return &quot;ddd-&quot;; }
 54         String gggg() { return &quot;ggg-&quot;; }
 55     }
 56 
 57     // Default methods in interfaces must be sorted
 58     static interface InterfaceA {
 59         default public String aaa() { return &quot;aaa&quot;;}
 60         default public String bbb() { return &quot;bbb&quot;;}
 61         default public String ddd() { return &quot;ddd&quot;;}
 62         default public String eee() { return &quot;eee&quot;;}
 63         default public String ggg() { return &quot;ggg&quot;;}
 64     }
 65 
 66     static class ImplementorA implements InterfaceA {
 67         public String aaa() { return &quot;aa-&quot;;}
 68     }
 69 
 70     static class ImplementorA1 extends ImplementorA {
 71         public String bbb() { return &quot;bb-&quot;;}
 72     }
 73 
 74     static interface InterfaceB {
 75         default public String aaa() { return &quot;aaa&quot;; }
 76         default public String ccc() { return &quot;ccc&quot;; }
 77         default public String ddd() { return &quot;ddd&quot;; }
 78         default public String fff() { return &quot;fff&quot;; }
 79         default public String ggg() { return &quot;ggg&quot;; }
 80     }
 81 
 82     static class ImplementorB implements InterfaceB {
 83         public String ggg() { return &quot;gg-&quot;;}
 84     }
 85 
 86     static class ImplementorB1 extends ImplementorB {
 87         public String fff() { return &quot;ff-&quot;;}
 88     }
 89 
 90 
 91     public static void main(String args[]) {
 92         testSimpleMethods();
 93         testDefaultMethods();
 94         testMixedInterfaces();
 95     }
 96 
 97     static void testSimpleMethods() {
 98         // When HelloA and HelloB are copied into the dynamic archive, the Symbols
 99         // for their method&#39;s names will have a different sorting order. This requires
100         // that the dumped InstanceKlass to re-sort their &quot;methods&quot; array and re-layout
101         // the vtables/itables.
102         HelloA1 a1 = new HelloA1();
103         HelloA a = new HelloA();
104         assertEqual(a.aaaa(), &quot;aaaa&quot;);
105         assertEqual(a.bbbb(), &quot;bbbb&quot;);
106         assertEqual(a.dddd(), &quot;dddd&quot;);
107         assertEqual(a.eeee(), &quot;eeee&quot;);
108         assertEqual(a.gggg(), &quot;gggg&quot;);
109 
110         assertEqual(a1.aaaa(), &quot;aaa-&quot;);
111         assertEqual(a1.bbbb(), &quot;bbbb&quot;);
112         assertEqual(a1.dddd(), &quot;ddd-&quot;);
113         assertEqual(a1.eeee(), &quot;eeee&quot;);
114         assertEqual(a1.gggg(), &quot;ggg-&quot;);
115 
116         HelloB b = new HelloB();
117         assertEqual(b.aaaa(), &quot;aaaa&quot;);
118         assertEqual(b.cccc(), &quot;cccc&quot;);
119         assertEqual(b.dddd(), &quot;dddd&quot;);
120         assertEqual(b.ffff(), &quot;ffff&quot;);
121         assertEqual(b.gggg(), &quot;gggg&quot;);
122 
123         HelloB b1 = new HelloB1();
124         assertEqual(b1.aaaa(), &quot;aaa-&quot;);
125         assertEqual(b1.cccc(), &quot;cccc&quot;);
126         assertEqual(b1.dddd(), &quot;ddd-&quot;);
127         assertEqual(b1.ffff(), &quot;ffff&quot;);
128         assertEqual(b1.gggg(), &quot;ggg-&quot;);
129     }
130 
131     static void testDefaultMethods() {
132         InterfaceA a1 = new ImplementorA1();
133         InterfaceA a = new ImplementorA();
134 
135         assertEqual(a.aaa(), &quot;aa-&quot;);
136         assertEqual(a.bbb(), &quot;bbb&quot;);
137         assertEqual(a.ddd(), &quot;ddd&quot;);
138         assertEqual(a.eee(), &quot;eee&quot;);
139         assertEqual(a.ggg(), &quot;ggg&quot;);
140 
141         assertEqual(a1.aaa(), &quot;aa-&quot;);
142         assertEqual(a1.bbb(), &quot;bb-&quot;);
143         assertEqual(a1.ddd(), &quot;ddd&quot;);
144         assertEqual(a1.eee(), &quot;eee&quot;);
145         assertEqual(a1.ggg(), &quot;ggg&quot;);
146 
147         InterfaceB b = new ImplementorB();
148         InterfaceB b1 = new ImplementorB1();
149 
150         assertEqual(b.aaa(), &quot;aaa&quot;);
151         assertEqual(b.ccc(), &quot;ccc&quot;);
152         assertEqual(b.ddd(), &quot;ddd&quot;);
153         assertEqual(b.fff(), &quot;fff&quot;);
154         assertEqual(b.ggg(), &quot;gg-&quot;);
155 
156         assertEqual(b1.aaa(), &quot;aaa&quot;);
157         assertEqual(b1.ccc(), &quot;ccc&quot;);
158         assertEqual(b1.ddd(), &quot;ddd&quot;);
159         assertEqual(b1.fff(), &quot;ff-&quot;);
160         assertEqual(b1.ggg(), &quot;gg-&quot;);
161     }
162 
163     // This is a regression test for an earlier bug in
164     // DynamicArchiveBuilder::relocate_buffer_to_target()
165     static void testMixedInterfaces() {
166         Object xx = new SynchronousQueue();
167         BlockingQueue yy = (BlockingQueue)xx;
168     }
169 
170     static private void assertEqual(String a, String b) {
171         if (!a.equals(b)) {
172             throw new RuntimeException(a + &quot; is not equal to &quot; + b);
173         } else {
174             System.out.println(&quot;Expected: &quot; + a + &quot;, got: &quot; + b);
175         }
176     }
177 }
    </pre>
  </body>
</html>
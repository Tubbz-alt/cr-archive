<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/cds/BootAppendTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @requires vm.cds &amp; !vm.graal.enabled
 27  * @summary Testing -Xbootclasspath/a support for CDS
 28  * @requires vm.cds
 29  * @library /test/lib
 30  * @compile javax/sound/sampled/MyClass.jasm
 31  * @compile javax/annotation/processing/FilerException.jasm
 32  * @compile nonjdk/myPackage/MyClass.java
 33  * @build LoadClass
 34  * @run main/othervm BootAppendTests
 35  */
 36 
 37 import java.io.File;
 38 import java.io.FileOutputStream;
 39 import java.io.IOException;
 40 import java.io.PrintStream;
 41 
 42 import java.nio.file.Path;
 43 import java.nio.file.Paths;
 44 
 45 import jdk.test.lib.cds.CDSOptions;
 46 import jdk.test.lib.cds.CDSTestUtils;
 47 import jdk.test.lib.process.ProcessTools;
 48 import jdk.test.lib.process.OutputAnalyzer;
 49 
 50 public class BootAppendTests {
 51     private static final String APP_CLASS = &quot;LoadClass&quot;;
 52     private static final String BOOT_APPEND_MODULE_CLASS = &quot;javax/sound/sampled/MyClass&quot;;
 53     private static final String BOOT_APPEND_DUPLICATE_MODULE_CLASS =
 54         &quot;javax/annotation/processing/FilerException&quot;;
 55     private static final String BOOT_APPEND_CLASS = &quot;nonjdk/myPackage/MyClass&quot;;
 56     private static final String BOOT_APPEND_MODULE_CLASS_NAME =
 57         BOOT_APPEND_MODULE_CLASS.replace(&#39;/&#39;, &#39;.&#39;);
 58     private static final String BOOT_APPEND_DUPLICATE_MODULE_CLASS_NAME =
 59         BOOT_APPEND_DUPLICATE_MODULE_CLASS.replace(&#39;/&#39;, &#39;.&#39;);
 60     private static final String BOOT_APPEND_CLASS_NAME =
 61         BOOT_APPEND_CLASS.replace(&#39;/&#39;, &#39;.&#39;);
 62     private static final String[] ARCHIVE_CLASSES =
 63         {BOOT_APPEND_MODULE_CLASS, BOOT_APPEND_DUPLICATE_MODULE_CLASS, BOOT_APPEND_CLASS};
 64 
 65     private static final String modes[] = {&quot;on&quot;, &quot;off&quot;};
 66 
 67     private static String appJar;
 68     private static String bootAppendJar;
 69 
 70     public static void main(String... args) throws Exception {
 71         dumpArchive();
 72 
 73         logTestCase(&quot;1&quot;);
 74         testBootAppendModuleClass();
 75 
 76         logTestCase(&quot;2&quot;);
 77         testBootAppendDuplicateModuleClass();
 78 
 79         logTestCase(&quot;3&quot;);
 80         testBootAppendExcludedModuleClass();
 81 
 82         logTestCase(&quot;4&quot;);
 83         testBootAppendDuplicateExcludedModuleClass();
 84 
 85         logTestCase(&quot;5&quot;);
 86         testBootAppendClass();
 87 
 88         logTestCase(&quot;6&quot;);
 89         testBootAppendExtraDir();
 90     }
 91 
 92     private static void logTestCase(String msg) {
 93         System.out.println();
 94         System.out.printf(&quot;TESTCASE: %s&quot;, msg);
 95         System.out.println();
 96     }
 97 
 98     static void dumpArchive() throws Exception {
 99         // create the classlist
100         File classlist = CDSTestUtils.makeClassList(ARCHIVE_CLASSES);
101 
102         // build jar files
103         appJar = ClassFileInstaller.writeJar(&quot;app.jar&quot;, APP_CLASS);
104         bootAppendJar = ClassFileInstaller.writeJar(&quot;bootAppend.jar&quot;,
105             BOOT_APPEND_MODULE_CLASS, BOOT_APPEND_DUPLICATE_MODULE_CLASS, BOOT_APPEND_CLASS);
106 
107 
108         OutputAnalyzer out = CDSTestUtils.createArchiveAndCheck(
109                                  &quot;-Xbootclasspath/a:&quot; + bootAppendJar,
110                                  &quot;-cp&quot;, appJar,
111                                  &quot;-XX:SharedClassListFile=&quot; + classlist.getPath());
112         // Make sure all the classes were successfully archived.
113         for (String archiveClass : ARCHIVE_CLASSES) {
114             String msg = &quot;Preload Warning: Cannot find &quot; + archiveClass;
115             if (archiveClass.equals(BOOT_APPEND_MODULE_CLASS)) {
116                 // We shouldn&#39;t archive a class in the appended boot class path that
117                 // are the java.desktop module. Such a class cannot be loaded
118                 // at runtime anyway.
119                 out.shouldContain(msg);
120             } else {
121                 out.shouldNotContain(msg);
122             }
123         }
124     }
125 
126     // Test #1: If a class on -Xbootclasspath/a is from a package defined in
127     //          bootmodules, the class is not loaded at runtime.
128     //          Verify the behavior is the same when the class is archived
129     //          with CDS enabled at runtime.
130     //
131     //          The javax.sound.sampled package is defined in the java.desktop module.
132     //          The archived javax.sound.sampled.MyClass from the -Xbootclasspath/a
133     //          should not be loaded at runtime.
134     public static void testBootAppendModuleClass() throws Exception {
135         for (String mode : modes) {
136             CDSOptions opts = (new CDSOptions())
137                 .setXShareMode(mode).setUseVersion(false)
138                 .addPrefix(&quot;-Xbootclasspath/a:&quot; + bootAppendJar, &quot;-cp&quot;, appJar, &quot;-showversion&quot;)
139                 .addSuffix(APP_CLASS, BOOT_APPEND_MODULE_CLASS_NAME);
140 
141             OutputAnalyzer out = CDSTestUtils.runWithArchive(opts);
142             CDSTestUtils.checkExec(out, opts, &quot;java.lang.ClassNotFoundException: javax.sound.sampled.MyClass&quot;);
143         }
144     }
145 
146     // Test #2: If a class on -Xbootclasspath/a has the same fully qualified
147     //          name as a class defined in boot modules, the class is not loaded
148     //          from -Xbootclasspath/a. Verify the behavior is the same at runtime
149     //          when CDS is enabled.
150     //
151     //          The javax/annotation/processing/FilerException is a platform module
152     //          class. The class on the -Xbootclasspath/a path that has the same
153     //          fully-qualified name should not be loaded at runtime when CDS is enabled.
154     //          The one from the platform modules should be loaded instead.
155     public static void testBootAppendDuplicateModuleClass() throws Exception {
156         for (String mode : modes) {
157             CDSOptions opts = (new CDSOptions())
158                 .setXShareMode(mode).setUseVersion(false)
159                 .addPrefix(&quot;-showversion&quot;,
160                            &quot;-Xbootclasspath/a:&quot; + bootAppendJar, &quot;-cp&quot;, appJar)
161                 .addSuffix(&quot;-Xlog:class+load=info&quot;,
162                            APP_CLASS, BOOT_APPEND_DUPLICATE_MODULE_CLASS_NAME);
163 
164             String MATCH_PATTERN = &quot;.class.load. javax.annotation.processing.FilerException source:.*bootAppend.jar*&quot;;
165             CDSTestUtils.run(opts)
166                 .assertNormalExit(out -&gt; {
167                     out.shouldNotMatch(MATCH_PATTERN);
168                 });
169         }
170     }
171 
172     // Test #3: If a class on -Xbootclasspath/a is from a package defined in boot modules,
173     //          the class can be loaded from -Xbootclasspath/a when the module is excluded
174     //          using --limit-modules. Verify the behavior is the same at runtime when CDS
175     //          is enabled.
176     //
177     //          The java.desktop module is excluded using --limit-modules at runtime
178     //          CDS will be disabled with the --limit-modules option during runtime.
179     //          javax.sound.sampled.MyClass will be loaded from the jar at runtime.
180     public static void testBootAppendExcludedModuleClass() throws Exception {
181         for (String mode : modes) {
182             CDSOptions opts = (new CDSOptions())
183                 .setXShareMode(mode).setUseVersion(false)
184                 .addPrefix(&quot;-Xbootclasspath/a:&quot; + bootAppendJar, &quot;-showversion&quot;,
185                            &quot;--limit-modules=java.base&quot;, &quot;-cp&quot;, appJar)
186                 .addSuffix(&quot;-Xlog:class+load=info&quot;,
187                            APP_CLASS, BOOT_APPEND_MODULE_CLASS_NAME);
188             CDSTestUtils.Result res = CDSTestUtils.run(opts);
189             String MATCH_PATTERN =
190                 &quot;.class.load. javax.sound.sampled.MyClass source:.*bootAppend.jar*&quot;;
191             if (mode.equals(&quot;on&quot;)) {
192                 res.assertSilentlyDisabledCDS(out -&gt; {
193                     out.shouldHaveExitValue(0)
194                        .shouldMatch(MATCH_PATTERN);
195                     });
196             } else {
197                 res.assertNormalExit(out -&gt; {
198                     out.shouldMatch(MATCH_PATTERN);
199                     });
200             }
201         }
202     }
203 
204     // Test #4: If a class on -Xbootclasspath/a has the same fully qualified
205     //          name as a class defined in boot modules, the class is loaded
206     //          from -Xbootclasspath/a when the boot module is excluded using
207     //          --limit-modules. Verify the behavior is the same at runtime
208     //          when CDS is enabled.
209     //
210     //          The javax.annotation.processing.FilerException is a platform module class.
211     //          The class on -Xbootclasspath/a that has the same fully-qualified name
212     //          as javax.annotation.processing.FilerException can be loaded at runtime when
213     //          java.compiler is excluded.
214     //          CDS is disabled during runtime if the --limit-modules option is
215     //          specified.
216     public static void testBootAppendDuplicateExcludedModuleClass() throws Exception {
217         for (String mode : modes) {
218             CDSOptions opts = (new CDSOptions())
219                 .setXShareMode(mode).setUseVersion(false)
220                 .addPrefix(&quot;-Xbootclasspath/a:&quot; + bootAppendJar, &quot;-showversion&quot;,
221                            &quot;--limit-modules=java.base&quot;, &quot;-cp&quot;, appJar)
222                 .addSuffix(&quot;-Xlog:class+load=info&quot;,
223                            APP_CLASS, BOOT_APPEND_DUPLICATE_MODULE_CLASS_NAME);
224 
225             CDSTestUtils.Result res = CDSTestUtils.run(opts);
226             String MATCH_PATTERN =
227                 &quot;.class.load. javax.annotation.processing.FilerException source:.*bootAppend.jar*&quot;;
228             if (mode.equals(&quot;on&quot;)) {
229                 res.assertSilentlyDisabledCDS(out -&gt; {
230                     out.shouldHaveExitValue(0)
231                        .shouldMatch(MATCH_PATTERN);
232                     });
233             } else {
234                 res.assertNormalExit(out -&gt; {
235                     out.shouldMatch(MATCH_PATTERN);
236                     });
237             }
238         }
239     }
240 
241     // Test #5: If a class on -Xbootclasspath/a is not from named modules,
242     //          the class can be loaded at runtime. Verify the behavior is
243     //          the same at runtime when CDS is enabled.
244     //
245     //          The nonjdk.myPackage is not defined in named modules. The
246     //          nonjdk.myPackage.MyClass will be loaded from the jar in
247     //          -Xbootclasspath/a since CDS will be disabled with the
248     //          --limit-modules option.
249     public static void testBootAppendClass() throws Exception {
250         for (String mode : modes) {
251             CDSOptions opts = (new CDSOptions())
252                 .setXShareMode(mode).setUseVersion(false)
253                 .addPrefix(&quot;-Xbootclasspath/a:&quot; + bootAppendJar, &quot;-showversion&quot;,
254                            &quot;--limit-modules=java.base&quot;, &quot;-cp&quot;, appJar)
255                 .addSuffix(&quot;-Xlog:class+load=info&quot;,
256                            APP_CLASS, BOOT_APPEND_CLASS_NAME);
257 
258             CDSTestUtils.Result res = CDSTestUtils.run(opts);
259             String MATCH_PATTERN =
260                 &quot;.class.load. nonjdk.myPackage.MyClass source:.*bootAppend.jar*&quot;;
261             if (mode.equals(&quot;on&quot;)) {
262                 res.assertSilentlyDisabledCDS(out -&gt; {
263                     out.shouldHaveExitValue(0)
264                        .shouldMatch(MATCH_PATTERN);
265                     });
266             } else {
267                 res.assertNormalExit(out -&gt; {
268                     out.shouldMatch(MATCH_PATTERN);
269                     });
270             }
271         }
272     }
273 
274     // Test #6: This is similar to Test #5. During runtime, an extra dir
275     //          is appended to the bootclasspath. It should not invalidate
276     //          the shared archive. However, CDS will be disabled with the
277     //          --limit-modules in the command line.
278     public static void testBootAppendExtraDir() throws Exception {
279         for (String mode : modes) {
280             CDSOptions opts = (new CDSOptions())
281                 .setXShareMode(mode).setUseVersion(false)
282                 .addPrefix(&quot;-Xbootclasspath/a:&quot; + bootAppendJar + File.pathSeparator + appJar,
283                            &quot;-showversion&quot;, &quot;--limit-modules=java.base&quot;, &quot;-cp&quot;, appJar)
284                 .addSuffix(&quot;-Xlog:class+load=info&quot;,
285                            APP_CLASS, BOOT_APPEND_CLASS_NAME);
286 
287             CDSTestUtils.Result res = CDSTestUtils.run(opts);
288             String MATCH_PATTERN =
289                 &quot;.class.load. nonjdk.myPackage.MyClass source:.*bootAppend.jar*&quot;;
290             if (mode.equals(&quot;on&quot;)) {
291                 res.assertSilentlyDisabledCDS(out -&gt; {
292                     out.shouldHaveExitValue(0)
293                        .shouldMatch(MATCH_PATTERN);
294                     });
295             } else {
296                 res.assertNormalExit(out -&gt; {
297                     out.shouldMatch(MATCH_PATTERN);
298                     });
299             }
300         }
301     }
302 }
    </pre>
  </body>
</html>
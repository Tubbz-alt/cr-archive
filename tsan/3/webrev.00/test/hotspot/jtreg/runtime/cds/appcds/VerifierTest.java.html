<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/cds/appcds/VerifierTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 import java.io.File;
 26 import java.io.FileOutputStream;
 27 import jdk.test.lib.process.OutputAnalyzer;
 28 import java.nio.file.Files;
 29 
 30 import java.util.*;
 31 import jdk.internal.org.objectweb.asm.*;
 32 
 33 /**
 34  * The testsets contained in this class are executed by ./VerifierTest_*.java, so that
 35  * individual testsets can be executed in parallel to shorten the total time required.
 36  */
 37 public class VerifierTest implements Opcodes {
 38     // Test verification settings for dumping &amp; runtime
 39     static final String VFY_ALL = &quot;-Xverify:all&quot;;
 40     static final String VFY_REMOTE = &quot;-Xverify:remote&quot;; // default
 41     static final String VFY_NONE = &quot;-XX:+UnlockDiagnosticVMOptions, -XX:-BytecodeVerificationRemote, -XX:-BytecodeVerificationLocal&quot;;
 42 
 43     static final String ERR =
 44         &quot;ERROR: class VerifierTestC was loaded unexpectedly&quot;;
 45     static final String MAP_FAIL =
 46         &quot;shared archive file was created with less restrictive verification setting&quot;;
 47     static final String VFY_ERR = &quot;java.lang.VerifyError&quot;;
 48     static final String PASS_RESULT = &quot;Hi, how are you?&quot;;
 49     static final String VFY_INFO_MESSAGE =
 50         &quot;All non-system classes will be verified (-Xverify:remote) during CDS dump time.&quot;;
 51     static final String CDS_LOGGING = &quot;-Xlog:cds,cds+hashtables&quot;;
 52 
 53     enum Testset1Part {
 54         A, B
 55     }
 56 
 57     public static void main(String[] args) throws Exception {
 58         String subCaseId = args[0];
 59         String jarName_verifier_test_tmp = &quot;verifier_test_tmp&quot; + &quot;_&quot; + subCaseId;
 60         String jarName_verifier_test = &quot;verifier_test&quot; + &quot;_&quot; + subCaseId;
 61         String jarName_greet = &quot;greet&quot; + &quot;_&quot; + subCaseId;
 62         String jarName_hi = &quot;hi&quot; + &quot;_&quot; + subCaseId;
 63 
 64 
 65         JarBuilder.build(jarName_verifier_test_tmp, &quot;VerifierTest0&quot;, &quot;VerifierTestA&quot;,
 66                          &quot;VerifierTestB&quot;, &quot;VerifierTestC&quot;, &quot;VerifierTestD&quot;, &quot;VerifierTestE&quot;,
 67                          &quot;UnverifiableBase&quot;, &quot;UnverifiableIntf&quot;, &quot;UnverifiableIntfSub&quot;);
 68         JarBuilder.build(jarName_greet, &quot;Greet&quot;);
 69         JarBuilder.build(jarName_hi, &quot;Hi&quot;, &quot;Hi$MyClass&quot;);
 70 
 71         File dir = new File(System.getProperty(&quot;test.classes&quot;, &quot;.&quot;));
 72         File jarSrcFile = new File(dir, jarName_verifier_test_tmp + &quot;.jar&quot;);
 73         File jarFile = new File(dir, jarName_verifier_test + &quot;.jar&quot;);
 74         String jar = jarFile.getPath();
 75 
 76         if (!jarFile.exists() || jarFile.lastModified() &lt; jarSrcFile.lastModified()) {
 77             createTestJarFile(jarSrcFile, jarFile);
 78         } else {
 79             System.out.println(&quot;Already up-to-date: &quot; + jarFile);
 80         }
 81 
 82         String noAppClasses[] = TestCommon.list(&quot;&quot;);
 83         String appClasses[] = TestCommon.list(&quot;UnverifiableBase&quot;,
 84                                               &quot;UnverifiableIntf&quot;,
 85                                               &quot;UnverifiableIntfSub&quot;,
 86                                               &quot;VerifierTestA&quot;,
 87                                               &quot;VerifierTestB&quot;,
 88                                               &quot;VerifierTestC&quot;,
 89                                               &quot;VerifierTestD&quot;,
 90                                               &quot;VerifierTestE&quot;,
 91                                               &quot;VerifierTest0&quot;);
 92 
 93 
 94         switch (subCaseId) {
 95         case &quot;0&quot;:         testset_0(jar, noAppClasses, appClasses);                 return;
 96         case &quot;1A&quot;:        testset_1(jar, noAppClasses, appClasses, Testset1Part.A); return;
 97         case &quot;1B&quot;:        testset_1(jar, noAppClasses, appClasses, Testset1Part.B); return;
 98         case &quot;2&quot;:         testset_2(jarName_greet, jarName_hi);                   return;
 99         default:
100             throw new RuntimeException(&quot;Unknown option: &quot; + subCaseId);
101         }
102     }
103 
104     static void testset_0(String jar, String[] noAppClasses, String[] appClasses) throws Exception {
105         // Unverifiable classes won&#39;t be included in the CDS archive.
106         // Dumping should not fail.
107         OutputAnalyzer output = TestCommon.dump(jar, appClasses);
108         output.shouldHaveExitValue(0);
109         if (output.getStdout().contains(&quot;Loading clases to share&quot;)) {
110             // last entry in appClasses[] is a verifiable class
111             for (int i = 0; i &lt; (appClasses.length - 1); i++) {
112                 output.shouldContain(&quot;Verification failed for &quot; + appClasses[i]);
113                 output.shouldContain(&quot;Removed error class: &quot; + appClasses[i]);
114             }
115         }
116     }
117 
118     static void checkRuntimeOutput(OutputAnalyzer output, String expected) throws Exception {
119         output.shouldContain(expected);
120         if (expected.equals(PASS_RESULT) ||
121             expected.equals(VFY_ERR)) {
122             output.shouldHaveExitValue(0);
123         } else {
124             output.shouldNotHaveExitValue(0);
125         }
126     }
127 
128     static void testset_1(String jar, String[] noAppClasses, String[] appClasses, Testset1Part part)
129         throws Exception
130     {
131         String config[][] = {
132             // {dump_list, dumptime_verification_setting,
133             //  runtime_verification_setting, expected_output_str},
134 
135             // Dump app/ext with -Xverify:remote
136             {&quot;app&quot;,   VFY_REMOTE, VFY_REMOTE, VFY_ERR},
137             {&quot;app&quot;,   VFY_REMOTE, VFY_ALL,    MAP_FAIL},
138             {&quot;app&quot;,   VFY_REMOTE, VFY_NONE,   ERR },
139             // Dump app/ext with -Xverify:all
140             {&quot;app&quot;,   VFY_ALL,    VFY_REMOTE, VFY_ERR },
141             {&quot;app&quot;,   VFY_ALL,    VFY_ALL,    VFY_ERR },
142             {&quot;app&quot;,   VFY_ALL,    VFY_NONE,   ERR },
143             // Dump app/ext with verifier turned off
144             {&quot;app&quot;,   VFY_NONE,   VFY_REMOTE, VFY_ERR},
145             {&quot;app&quot;,   VFY_NONE,   VFY_ALL,    MAP_FAIL},
146             {&quot;app&quot;,   VFY_NONE,   VFY_NONE,   ERR },
147             // Dump sys only with -Xverify:remote
148             {&quot;noApp&quot;, VFY_REMOTE, VFY_REMOTE, VFY_ERR},
149             {&quot;noApp&quot;, VFY_REMOTE, VFY_ALL,    VFY_ERR},
150             {&quot;noApp&quot;, VFY_REMOTE, VFY_NONE,   ERR},
151             // Dump sys only with -Xverify:all
152             {&quot;noApp&quot;, VFY_ALL, VFY_REMOTE,    VFY_ERR},
153             {&quot;noApp&quot;, VFY_ALL, VFY_ALL,       VFY_ERR},
154             {&quot;noApp&quot;, VFY_ALL, VFY_NONE,      ERR},
155             // Dump sys only with verifier turned off
156             {&quot;noApp&quot;, VFY_NONE, VFY_REMOTE,   VFY_ERR},
157             {&quot;noApp&quot;, VFY_NONE, VFY_ALL,      VFY_ERR},
158             {&quot;noApp&quot;, VFY_NONE, VFY_NONE,     ERR},
159         };
160 
161         int loop_start, loop_stop;
162 
163         // Further break down testset_1 into two parts (to be invoked from VerifierTest_1A.java
164         // and VerifierTest_1B.java) to improve parallel test execution time.
165         switch (part) {
166         case A:
167             loop_start = 0;
168             loop_stop  = 9;
169             break;
170         case B:
171         default:
172             assert part == Testset1Part.B;
173             loop_start = 9;
174             loop_stop  = config.length;
175             break;
176         }
177 
178         String prev_dump_setting = &quot;&quot;;
179         for (int i = loop_start; i &lt; loop_stop; i ++) {
180             String dump_list[] = config[i][0].equals(&quot;app&quot;) ? appClasses :
181                 noAppClasses;
182             String dump_setting = config[i][1];
183             String runtime_setting = config[i][2];
184             String expected_output_str = config[i][3];
185             System.out.println(&quot;Test case [&quot; + i + &quot;]: dumping &quot; + config[i][0] +
186                                &quot; with &quot; + dump_setting +
187                                &quot;, run with &quot; + runtime_setting);
188             if (!dump_setting.equals(prev_dump_setting)) {
189                 String dump_arg1;
190                 String dump_arg2;
191                 String dump_arg3;
192                 // Need to break this into two separate arguments.
193                 if (dump_setting.equals(VFY_NONE)) {
194                     dump_arg1 = &quot;-XX:+UnlockDiagnosticVMOptions&quot;;
195                     dump_arg2 = &quot;-XX:-BytecodeVerificationRemote&quot;;
196                     dump_arg3 = &quot;-XX:-BytecodeVerificationLocal&quot;;
197                 } else {
198                     // Redundant args should be harmless.
199                     dump_arg1 = dump_arg2 = dump_arg3 = dump_setting;
200                 }
201 
202                 OutputAnalyzer dumpOutput = TestCommon.dump(
203                                                             jar, dump_list, dump_arg1, dump_arg2,
204                                                             dump_arg3, CDS_LOGGING,
205                                                             // FIXME: the following options are for working around a GC
206                                                             // issue - assert failure when dumping archive with the -Xverify:all
207                                                             &quot;-Xms256m&quot;,
208                                                             &quot;-Xmx256m&quot;);
209                 if (dump_setting.equals(VFY_NONE) &amp;&amp;
210                     runtime_setting.equals(VFY_REMOTE)) {
211                     dumpOutput.shouldContain(VFY_INFO_MESSAGE);
212                 }
213             }
214             String runtime_arg1;
215             String runtime_arg2;
216             String runtime_arg3;
217             if (runtime_setting.equals(VFY_NONE)) {
218                 runtime_arg1 = &quot;-XX:+UnlockDiagnosticVMOptions&quot;;
219                 runtime_arg2 = &quot;-XX:-BytecodeVerificationRemote&quot;;
220                 runtime_arg3 = &quot;-XX:-BytecodeVerificationLocal&quot;;
221             } else {
222                 // Redundant args should be harmless.
223                 runtime_arg1 = runtime_arg2 = runtime_arg3 = runtime_setting;
224             }
225             TestCommon.run(&quot;-cp&quot;, jar,
226                            runtime_arg1, runtime_arg2, runtime_arg3,
227                            &quot;VerifierTest0&quot;)
228                 .ifNoMappingFailure(output -&gt; checkRuntimeOutput(output, expected_output_str));
229             prev_dump_setting = dump_setting;
230         }
231     }
232 
233     static void testset_2(String jarName_greet, String jarName_hi) throws Exception {
234         String appClasses[];
235         String jar;
236 
237         // The following section is for testing the scenarios where
238         // the classes are verifiable during dump time.
239         appClasses = TestCommon.list(&quot;Hi&quot;,
240                                      &quot;Greet&quot;,
241                                      &quot;Hi$MyClass&quot;);
242         jar = TestCommon.getTestJar(jarName_hi + &quot;.jar&quot;) + File.pathSeparator +
243             TestCommon.getTestJar(jarName_greet + &quot;.jar&quot;);
244         String config2[][] = {
245             // {dump_list, dumptime_verification_setting,
246             //  runtime_verification_setting, expected_output_str},
247 
248             // Dump app/ext with -Xverify:remote
249             {&quot;app&quot;,   VFY_REMOTE, VFY_REMOTE, PASS_RESULT},
250             {&quot;app&quot;,   VFY_REMOTE, VFY_ALL,    MAP_FAIL},
251             {&quot;app&quot;,   VFY_REMOTE, VFY_NONE,   PASS_RESULT },
252             // Dump app/ext with -Xverify:all
253             {&quot;app&quot;,   VFY_ALL,    VFY_REMOTE, PASS_RESULT },
254             {&quot;app&quot;,   VFY_ALL,    VFY_ALL,    PASS_RESULT },
255             {&quot;app&quot;,   VFY_ALL,    VFY_NONE,   PASS_RESULT },
256             // Dump app/ext with verifier turned off
257             {&quot;app&quot;,   VFY_NONE,   VFY_REMOTE, PASS_RESULT},
258             {&quot;app&quot;,   VFY_NONE,   VFY_ALL,    MAP_FAIL},
259             {&quot;app&quot;,   VFY_NONE,   VFY_NONE,   PASS_RESULT },
260         };
261         String prev_dump_setting = &quot;&quot;;
262         for (int i = 0; i &lt; config2.length; i ++) {
263             // config2[i][0] is always set to &quot;app&quot; in this test
264             String dump_setting = config2[i][1];
265             String runtime_setting = config2[i][2];
266             String expected_output_str = config2[i][3];
267             System.out.println(&quot;Test case [&quot; + i + &quot;]: dumping &quot; + config2[i][0] +
268                                &quot; with &quot; + dump_setting +
269                                &quot;, run with &quot; + runtime_setting);
270             if (!dump_setting.equals(prev_dump_setting)) {
271                 String dump_arg1;
272                 String dump_arg2;
273                 String dump_arg3;
274                 if (dump_setting.equals(VFY_NONE)) {
275                     dump_arg1 = &quot;-XX:+UnlockDiagnosticVMOptions&quot;;
276                     dump_arg2 = &quot;-XX:-BytecodeVerificationRemote&quot;;
277                     dump_arg3 = &quot;-XX:-BytecodeVerificationLocal&quot;;
278                 } else {
279                     // Redundant args should be harmless.
280                     dump_arg1 = dump_arg2 = dump_arg3 = dump_setting;
281                 }
282                 OutputAnalyzer dumpOutput = TestCommon.dump(
283                                                             jar, appClasses, dump_arg1, dump_arg2,
284                                                             dump_arg3, CDS_LOGGING,
285                                                             // FIXME: the following options are for working around a GC
286                                                             // issue - assert failure when dumping archive with the -Xverify:all
287                                                             &quot;-Xms256m&quot;,
288                                                             &quot;-Xmx256m&quot;);
289                 if (dump_setting.equals(VFY_NONE) &amp;&amp;
290                     runtime_setting.equals(VFY_REMOTE)) {
291                     dumpOutput.shouldContain(VFY_INFO_MESSAGE);
292                 }
293             }
294             String runtime_arg1;
295             String runtime_arg2;
296             String runtime_arg3;
297             if (runtime_setting.equals(VFY_NONE)) {
298                 runtime_arg1 = &quot;-XX:+UnlockDiagnosticVMOptions&quot;;
299                 runtime_arg2 = &quot;-XX:-BytecodeVerificationRemote&quot;;
300                 runtime_arg3 = &quot;-XX:-BytecodeVerificationLocal&quot;;
301             } else {
302                 // Redundant args should be harmless.
303                 runtime_arg1 = runtime_arg2 = runtime_arg3 = runtime_setting;
304             }
305             TestCommon.run(&quot;-cp&quot;, jar,
306                            runtime_arg1, runtime_arg2, runtime_arg3,
307                            &quot;Hi&quot;)
308                 .ifNoMappingFailure(output -&gt; checkRuntimeOutput(output, expected_output_str));
309            prev_dump_setting = dump_setting;
310         }
311     }
312 
313     static void createTestJarFile(File jarSrcFile, File jarFile) throws Exception {
314         jarFile.delete();
315         Files.copy(jarSrcFile.toPath(), jarFile.toPath());
316 
317         File dir = new File(System.getProperty(&quot;test.classes&quot;, &quot;.&quot;));
318         File outdir = new File(dir, &quot;verifier_test_classes&quot;);
319         outdir.mkdir();
320 
321         writeClassFile(new File(outdir, &quot;UnverifiableBase.class&quot;), makeUnverifiableBase());
322         writeClassFile(new File(outdir, &quot;UnverifiableIntf.class&quot;), makeUnverifiableIntf());
323 
324         JarBuilder.update(jarFile.getPath(), outdir.getPath());
325     }
326 
327     static void writeClassFile(File file, byte bytecodes[]) throws Exception {
328         try (FileOutputStream fos = new FileOutputStream(file)) {
329             fos.write(bytecodes);
330         }
331     }
332 
333     // This was obtained using JDK8: java jdk.internal.org.objectweb.asm.util.ASMifier tmpclasses/UnverifiableBase.class
334     static byte[] makeUnverifiableBase() throws Exception {
335         ClassWriter cw = new ClassWriter(0);
336         FieldVisitor fv;
337         MethodVisitor mv;
338         AnnotationVisitor av0;
339 
340         cw.visit(V1_8, ACC_SUPER, &quot;UnverifiableBase&quot;, null, &quot;java/lang/Object&quot;, null);
341         {
342             fv = cw.visitField(ACC_FINAL + ACC_STATIC, &quot;x&quot;, &quot;LVerifierTest;&quot;, null, null);
343             fv.visitEnd();
344         }
345         {
346             mv = cw.visitMethod(0, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
347             mv.visitCode();
348             mv.visitVarInsn(ALOAD, 0);
349             mv.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);
350             mv.visitInsn(RETURN);
351             mv.visitMaxs(1, 1);
352             mv.visitEnd();
353         }
354         {
355             mv = cw.visitMethod(ACC_STATIC, &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, null, null);
356             mv.visitCode();
357             mv.visitTypeInsn(NEW, &quot;VerifierTest0&quot;);
358             mv.visitInsn(DUP);
359             mv.visitMethodInsn(INVOKESPECIAL, &quot;VerifierTest0&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);
360             mv.visitFieldInsn(PUTSTATIC, &quot;UnverifiableBase&quot;, &quot;x&quot;, &quot;LVerifierTest;&quot;);
361             mv.visitInsn(RETURN);
362             mv.visitMaxs(2, 0);
363             mv.visitEnd();
364         }
365         addBadMethod(cw);
366         cw.visitEnd();
367 
368         return cw.toByteArray();
369     }
370 
371     // This was obtained using JDK8: java jdk.internal.org.objectweb.asm.util.ASMifier tmpclasses/UnverifiableIntf.class
372     static byte[] makeUnverifiableIntf() throws Exception {
373         ClassWriter cw = new ClassWriter(0);
374         FieldVisitor fv;
375         MethodVisitor mv;
376         AnnotationVisitor av0;
377 
378         cw.visit(V1_8, ACC_ABSTRACT + ACC_INTERFACE, &quot;UnverifiableIntf&quot;, null, &quot;java/lang/Object&quot;, null);
379 
380         {
381             fv = cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, &quot;x&quot;, &quot;LVerifierTest0;&quot;, null, null);
382             fv.visitEnd();
383         }
384         {
385             mv = cw.visitMethod(ACC_STATIC, &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, null, null);
386             mv.visitCode();
387             mv.visitTypeInsn(NEW, &quot;VerifierTest0&quot;);
388             mv.visitInsn(DUP);
389             mv.visitMethodInsn(INVOKESPECIAL, &quot;VerifierTest0&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);
390             mv.visitFieldInsn(PUTSTATIC, &quot;UnverifiableIntf&quot;, &quot;x&quot;, &quot;LVerifierTest0;&quot;);
391             mv.visitInsn(RETURN);
392             mv.visitMaxs(2, 0);
393             mv.visitEnd();
394         }
395         addBadMethod(cw);
396         cw.visitEnd();
397 
398         return cw.toByteArray();
399     }
400 
401     // Add a bad method to make the class fail verification.
402     static void addBadMethod(ClassWriter cw) throws Exception {
403         MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, &quot;bad&quot;, &quot;()V&quot;, null, null);
404         mv.visitCode();
405         mv.visitInsn(ARETURN); //  java.lang.VerifyError: Operand stack underflow
406         mv.visitMaxs(2, 2);
407         mv.visitEnd();
408     }
409 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/cds/appcds/RelativePath.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 /*
 26  * @test
 27  * @summary Test relative paths specified in the -cp.
 28  * @requires vm.cds
 29  * @library /test/lib
 30  * @compile test-classes/Hello.java
 31  * @compile test-classes/HelloMore.java
 32  * @run driver RelativePath
 33  */
 34 
 35 import java.io.File;
 36 import java.nio.file.Files;
 37 import java.nio.file.Path;
 38 import java.nio.file.Paths;
 39 import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;
 40 import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
 41 import java.util.Arrays;
 42 import jdk.test.lib.Platform;
 43 
 44 public class RelativePath {
 45 
 46   private static final Path USER_DIR = Paths.get(System.getProperty(&quot;user.dir&quot;));
 47 
 48   public static void main(String[] args) throws Exception {
 49     String appJar = JarBuilder.getOrCreateHelloJar();
 50     String appJar2 = JarBuilder.build(&quot;AppendClasspath_HelloMore&quot;, &quot;HelloMore&quot;);
 51 
 52     // dump an archive with only the jar name in the -cp
 53     int idx = appJar.lastIndexOf(File.separator);
 54     String jarName = appJar.substring(idx + 1);
 55     String jarDir = appJar.substring(0, idx);
 56     TestCommon.testDump(jarDir, jarName, TestCommon.list(&quot;Hello&quot;));
 57 
 58     // copy the jar file to another dir. Specify the jar file without
 59     // a directory path.
 60     Path srcPath = Paths.get(appJar);
 61     Path destDir = Files.createTempDirectory(USER_DIR, &quot;deploy&quot;);
 62     Path destPath = destDir.resolve(jarName);
 63     Files.copy(srcPath, destPath, REPLACE_EXISTING, COPY_ATTRIBUTES);
 64     TestCommon.runWithRelativePath(
 65         destDir.toString(),
 66         &quot;-Xshare:on&quot;,
 67         &quot;-XX:SharedArchiveFile=&quot; + TestCommon.getCurrentArchiveName(),
 68         &quot;-cp&quot;, jarName + File.pathSeparator + appJar2,
 69         &quot;-Xlog:class+load=trace,class+path=info&quot;,
 70         &quot;HelloMore&quot;)
 71         .assertNormalExit(output -&gt; {
 72                 output.shouldContain(&quot;Hello source: shared objects file&quot;)
 73                       .shouldHaveExitValue(0);
 74             });
 75 
 76     // Long path test
 77     // Create a long directory path and copy the appJar there.
 78     final int MAX_PATH = 260;
 79     destDir = Paths.get(jarDir);
 80     int subDirLen = MAX_PATH - jarDir.length() - 3;
 81     if (subDirLen &gt; 0) {
 82         char[] chars = new char[subDirLen];
 83         Arrays.fill(chars, &#39;x&#39;);
 84         String subPath = new String(chars);
 85         destDir = Paths.get(jarDir, subPath);
 86     }
 87     File longDir = destDir.toFile();
 88     longDir.mkdir();
 89     String destJar = longDir.getPath() + File.separator + jarName;
 90     Files.copy(Paths.get(appJar), Paths.get(destJar), REPLACE_EXISTING);
 91     // Create an archive with the appJar in the long directory path.
 92     TestCommon.testDump(destJar, TestCommon.list(&quot;Hello&quot;));
 93 
 94     // Run with -cp containing the appJar and another jar appended.
 95     TestCommon.run(
 96         &quot;-cp&quot;, destJar + File.pathSeparator + appJar2,
 97         &quot;-Xlog:class+load=trace,class+path=info&quot;,
 98         &quot;HelloMore&quot;)
 99         .assertNormalExit(output -&gt; {
100                 output.shouldContain(&quot;Hello source: shared objects file&quot;)
101                       .shouldHaveExitValue(0);
102             });
103 
104     // Dump an archive with a specified JAR file in -classpath
105     TestCommon.testDump(appJar, TestCommon.list(&quot;Hello&quot;));
106 
107     // compose a relative path to the hello.jar
108     String newHello = TestCommon.composeRelPath(appJar);
109 
110     // create a sym link to the original hello.jar
111     File linkedHello = null;
112     if (!Platform.isWindows()) {
113         linkedHello = TestCommon.createSymLink(appJar);
114     }
115 
116     // PASS:1) same appJar but referred to via a relative path
117     TestCommon.run(
118         &quot;-cp&quot;, newHello + File.pathSeparator + appJar2,
119         &quot;-Xlog:class+load=trace,class+path=info&quot;,
120         &quot;HelloMore&quot;)
121       .assertNormalExit();
122 
123     // PASS:2) relative path starting with &quot;.&quot;
124     TestCommon.runWithRelativePath(
125         jarDir,
126         &quot;-Xshare:on&quot;,
127         &quot;-XX:SharedArchiveFile=&quot; + TestCommon.getCurrentArchiveName(),
128         &quot;-cp&quot;, &quot;.&quot; + File.separator + jarName + File.pathSeparator + appJar2,
129         &quot;-Xlog:class+load=trace,class+path=info&quot;,
130         &quot;HelloMore&quot;)
131         .assertNormalExit(output -&gt; {
132                 output.shouldContain(&quot;Hello source: shared objects file&quot;)
133                       .shouldHaveExitValue(0);
134             });
135 
136     // PASS:3) relative path starting with &quot;..&quot;
137     idx = jarDir.lastIndexOf(File.separator);
138     String jarSubDir = jarDir.substring(idx + 1);
139     TestCommon.runWithRelativePath(
140         jarDir,
141         &quot;-Xshare:on&quot;,
142         &quot;-XX:SharedArchiveFile=&quot; + TestCommon.getCurrentArchiveName(),
143         &quot;-cp&quot;, &quot;..&quot; + File.separator + jarSubDir + File.separator + jarName
144                + File.pathSeparator + appJar2,
145         &quot;-Xlog:class+load=trace,class+path=info&quot;,
146         &quot;HelloMore&quot;)
147         .assertNormalExit(output -&gt; {
148                 output.shouldContain(&quot;Hello source: shared objects file&quot;)
149                       .shouldHaveExitValue(0);
150             });
151 
152     // PASS:4) a jar linked to the original hello.jar
153     if (!Platform.isWindows()) {
154         TestCommon.run(
155             &quot;-cp&quot;, linkedHello.getPath() + File.pathSeparator + appJar2,
156             &quot;HelloMore&quot;)
157           .assertNormalExit();
158     }
159 
160     final String errorMessage1 = &quot;Unable to use shared archive&quot;;
161     final String errorMessage2 = &quot;shared class paths mismatch&quot;;
162     // FAIL: 1) runtime with classpath different from the one used in dump time
163     // (runtime has an extra jar file prepended to the class path)
164     TestCommon.run(
165         &quot;-cp&quot;, appJar2 + File.pathSeparator + newHello,
166         &quot;HelloMore&quot;)
167         .assertAbnormalExit(errorMessage1, errorMessage2);
168 
169     }
170 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/cds/appcds/jigsaw/JigsawOptionsCombo.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 /*
 26  * @test
 27  * @summary Test combinations of jigsaw options that affect the use of AppCDS
 28  *
 29  * @requires vm.cds &amp; !vm.graal.enabled
 30  * @library /test/lib ..
 31  * @compile ../test-classes/Hello.java ../test-classes/HelloMore.java
 32  * @run driver JigsawOptionsCombo
 33  */
 34 import jdk.test.lib.compiler.InMemoryJavaCompiler;
 35 import jdk.test.lib.process.OutputAnalyzer;
 36 import java.util.ArrayList;
 37 
 38 
 39 // Remaining WORK: TODO:
 40 // 1. test with -m initial-module; waiting for changes from Chris will provide
 41 //    utils to build modules
 42 // 2. Loading classes from Jmod files - waiting on utils
 43 // 3. Loading classes from exploded module dir&quot;
 44 
 45 public class JigsawOptionsCombo {
 46 
 47     public static void main(String[] args) throws Exception {
 48         String source = &quot;package javax.naming.spi; &quot;                +
 49                         &quot;public class NamingManager { &quot;             +
 50                         &quot;    static { &quot;                             +
 51                         &quot;        System.out.println(\&quot;I pass!\&quot;); &quot; +
 52                         &quot;    } &quot;                                    +
 53                         &quot;}&quot;;
 54         ClassFileInstaller.writeClassToDisk(&quot;javax/naming/spi/NamingManager&quot;,
 55             InMemoryJavaCompiler.compile(&quot;javax.naming.spi.NamingManager&quot;, source, &quot;--patch-module=java.naming&quot;),
 56             &quot;mods/java.naming&quot;);
 57 
 58         JarBuilder.build(&quot;hello&quot;, &quot;Hello&quot;);
 59         JarBuilder.build(&quot;hello_more&quot;, &quot;HelloMore&quot;);
 60 
 61         (new JigsawOptionsCombo()).runTests();
 62     }
 63 
 64 
 65     private ArrayList&lt;TestCase&gt; testCaseTable = new ArrayList&lt;TestCase&gt;();
 66 
 67     public static String infoDuringDump(String option) {
 68         return &quot;Cannot use the following option when dumping the shared archive: &quot; + option;
 69     }
 70 
 71     public void runTests() throws Exception {
 72 
 73         testCaseTable.add(new TestCase(
 74             &quot;basic: Basic dump and execute, to verify the test plumbing works&quot;,
 75             &quot;&quot;, &quot;&quot;, 0,
 76             &quot;&quot;, &quot;&quot;, 0, true) );
 77 
 78         String bcpArg = &quot;-Xbootclasspath/a:&quot; +
 79         TestCommon.getTestJar(&quot;hello_more.jar&quot;);
 80 
 81         testCaseTable.add(new TestCase(
 82             &quot;Xbootclasspath/a: is OK for both dump and run time&quot;,
 83             bcpArg, &quot;&quot;, 0,
 84             bcpArg, &quot;&quot;, 0, true) );
 85 
 86         testCaseTable.add(new TestCase(
 87             &quot;module-path-01: --module-path is ignored for dump time&quot;,
 88             &quot;--module-path mods&quot;, &quot;&quot;, 0,
 89             null, null, 0, true) );
 90 
 91         testCaseTable.add(new TestCase(
 92             &quot;module-path-02: --module-path is ok for run time&quot;,
 93             &quot;&quot;, &quot;&quot;, 0,
 94             &quot;--module-path mods&quot;, &quot;&quot;, 0, true) );
 95 
 96         testCaseTable.add(new TestCase(
 97             &quot;add-modules-01: --add-modules is ok at dump time&quot;,
 98             &quot;--add-modules java.management&quot;,
 99             &quot;&quot;, 0,
100             null, null, 0, true) );
101 
102         testCaseTable.add(new TestCase(
103             &quot;add-modules-02: --add-modules is ok at run time&quot;,
104             &quot;&quot;, &quot;&quot;, 0,
105             &quot;--add-modules java.management&quot;, &quot;&quot;, 0, true) );
106 
107         testCaseTable.add(new TestCase(
108             &quot;limit-modules-01: --limit-modules is ignored at dump time&quot;,
109             &quot;--limit-modules java.base&quot;,
110             infoDuringDump(&quot;--limit-modules&quot;), 1,
111             null, null, 0, true) );
112 
113         testCaseTable.add(new TestCase(
114             &quot;limit-modules-02: --limit-modules is ok at run time&quot;,
115             &quot;&quot;, &quot;&quot;, 0,
116             &quot;--limit-modules java.base&quot;, &quot;&quot;, 0, false) );
117 
118         testCaseTable.add(new TestCase(
119             &quot;upgrade-module-path-01: --upgrade-module-path is ignored at dump time&quot;,
120             &quot;--upgrade-module-path mods&quot;,
121             infoDuringDump(&quot;--upgrade-module-path&quot;), 1,
122             null, null, 0, true) );
123 
124         testCaseTable.add(new TestCase(
125             &quot;-upgrade-module-path-module-path-02: --upgrade-module-path is ok at run time&quot;,
126             &quot;&quot;, &quot;&quot;, 0,
127             &quot;--upgrade-module-path mods&quot;, &quot;&quot;, 0, false) );
128 
129         for (TestCase tc : testCaseTable) tc.execute();
130     }
131 
132 
133     // class representing a singe test case
134     public class TestCase {
135         String description;
136         String dumpTimeArgs;
137         String dumpTimeExpectedOutput;
138         int    dumpTimeExpectedExitValue;
139         String runTimeArgs;
140         String runTimeExpectedOutput;
141         int    runTimeExpectedExitValue;
142         boolean sharingOn;
143 
144         private String appJar = TestCommon.getTestJar(&quot;hello.jar&quot;);
145         private String appClasses[] = {&quot;Hello&quot;};
146 
147 
148         public TestCase(String description,
149             String dumpTimeArgs, String dumpTimeExpectedOutput, int dumpTimeExpectedExitValue,
150             String runTimeArgs, String runTimeExpectedOutput, int runTimeExpectedExitValue,
151             boolean sharingOn) {
152 
153             this.description = description;
154             this.dumpTimeArgs = dumpTimeArgs;
155             this.dumpTimeExpectedOutput = dumpTimeExpectedOutput;
156             this.dumpTimeExpectedExitValue = dumpTimeExpectedExitValue;
157             this.runTimeArgs = runTimeArgs;
158             this.runTimeExpectedOutput = runTimeExpectedOutput;
159             this.runTimeExpectedExitValue = runTimeExpectedExitValue;
160             this.sharingOn = sharingOn;
161         }
162 
163 
164         public void execute() throws Exception {
165             System.out.println(&quot;Description: &quot; + description);
166 
167             // ===== dump step - create the archive
168             OutputAnalyzer dumpOutput = TestCommon.dump(
169                 appJar, appClasses, getDumpOptions());
170 
171             if (dumpTimeExpectedExitValue == 0) {
172                 TestCommon.checkDump(dumpOutput, dumpTimeExpectedOutput);
173             } else {
174                 dumpOutput.shouldMatch(dumpTimeExpectedOutput);
175                 dumpOutput.shouldHaveExitValue(dumpTimeExpectedExitValue);
176             }
177 
178             // ===== exec step - use the archive
179             if (runTimeArgs != null) {
180                 OutputAnalyzer execOutput = TestCommon.exec(appJar, getRunOptions());
181 
182                 if (runTimeExpectedExitValue == 0) {
183                     if (sharingOn) {
184                         TestCommon.checkExec(execOutput, runTimeExpectedOutput, &quot;Hello World&quot;);
185                     } else {
186                         execOutput.shouldHaveExitValue(0)
187                                   .shouldContain(runTimeExpectedOutput)
188                                   .shouldContain(&quot;Hello World&quot;);
189                     }
190                 } else {
191                     execOutput.shouldMatch(dumpTimeExpectedOutput);
192                     execOutput.shouldHaveExitValue(dumpTimeExpectedExitValue);
193                 }
194             }
195         }
196 
197 
198         // dump command line options can be separated by a space
199         private String[] getDumpOptions() {
200             return dumpTimeArgs.split(&quot; &quot;);
201         }
202 
203 
204         // run command line options can be separated by a space
205         private String[] getRunOptions() {
206             ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();
207 
208             if (runTimeArgs != &quot;&quot;) {
209                 String splitArgs[] = runTimeArgs.split(&quot; &quot;);
210                 for (String arg : splitArgs)
211                     result.add(arg);
212             }
213 
214             result.add(&quot;Hello&quot;);
215             return result.toArray(new String[1]);
216         }
217     }
218 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/cds/appcds/BootClassPathMismatch.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 /*
 26  * @test
 27  * @summary bootclasspath mismatch test.
 28  * @requires vm.cds
 29  * @library /test/lib
 30  * @compile test-classes/Hello.java
 31  * @run driver BootClassPathMismatch
 32  */
 33 
 34 import jdk.test.lib.Platform;
 35 import jdk.test.lib.cds.CDSOptions;
 36 import jdk.test.lib.cds.CDSTestUtils;
 37 import jdk.test.lib.process.OutputAnalyzer;
 38 import java.io.File;
 39 import java.nio.file.Files;
 40 import java.nio.file.FileAlreadyExistsException;
 41 import java.nio.file.StandardCopyOption;
 42 import java.nio.file.Path;
 43 import java.nio.file.Paths;
 44 import java.nio.file.attribute.FileTime;
 45 
 46 
 47 public class BootClassPathMismatch {
 48     private static final String mismatchMessage = &quot;shared class paths mismatch&quot;;
 49 
 50     public static void main(String[] args) throws Exception {
 51         JarBuilder.getOrCreateHelloJar();
 52         copyHelloToNewDir();
 53 
 54         BootClassPathMismatch test = new BootClassPathMismatch();
 55         test.testBootClassPathMismatch();
 56         test.testBootClassPathMismatchWithAppClass();
 57         test.testBootClassPathMismatchWithBadPath();
 58         if (!TestCommon.isDynamicArchive()) {
 59             // this test is not applicable to dynamic archive since
 60             // there is no class to be archived in the top archive
 61             test.testBootClassPathMatchWithAppend();
 62         }
 63         test.testBootClassPathMatch();
 64     }
 65 
 66     /* Archive contains boot classes only, with Hello class on -Xbootclasspath/a path.
 67      *
 68      * Error should be detected if:
 69      * dump time: -Xbootclasspath/a:${testdir}/hello.jar
 70      * run-time : -Xbootclasspath/a:${testdir}/newdir/hello.jar
 71      *
 72      * or
 73      * dump time: -Xbootclasspath/a:${testdir}/newdir/hello.jar
 74      * run-time : -Xbootclasspath/a:${testdir}/hello.jar
 75      */
 76     public void testBootClassPathMismatch() throws Exception {
 77         String appJar = JarBuilder.getOrCreateHelloJar();
 78         String appClasses[] = {&quot;Hello&quot;};
 79         String testDir = TestCommon.getTestDir(&quot;newdir&quot;);
 80         String otherJar = testDir + File.separator + &quot;hello.jar&quot;;
 81 
 82         TestCommon.dump(appJar, appClasses, &quot;-Xbootclasspath/a:&quot; + appJar);
 83         TestCommon.run(
 84                 &quot;-Xlog:cds&quot;,
 85                 &quot;-cp&quot;, appJar, &quot;-Xbootclasspath/a:&quot; + otherJar, &quot;Hello&quot;)
 86             .assertAbnormalExit(mismatchMessage);
 87 
 88         TestCommon.dump(appJar, appClasses, &quot;-Xbootclasspath/a:&quot; + otherJar);
 89         TestCommon.run(
 90                 &quot;-Xlog:cds&quot;,
 91                 &quot;-cp&quot;, appJar, &quot;-Xbootclasspath/a:&quot; + appJar, &quot;Hello&quot;)
 92             .assertAbnormalExit(mismatchMessage);
 93     }
 94 
 95     /* Archive contains boot classes only.
 96      *
 97      * Error should be detected if:
 98      * dump time: -Xbootclasspath/a:${testdir}/newdir/hello.jar
 99      * run-time : -Xbootclasspath/a:${testdir}/newdir/hello.jar1
100      */
101     public void testBootClassPathMismatchWithBadPath() throws Exception {
102         String appClasses[] = {&quot;Hello&quot;};
103         String testDir = TestCommon.getTestDir(&quot;newdir&quot;);
104         String appJar = testDir + File.separator + &quot;hello.jar&quot;;
105         String otherJar = testDir + File.separator + &quot;hello.jar1&quot;;
106 
107         TestCommon.dump(appJar, appClasses, &quot;-Xbootclasspath/a:&quot; + appJar);
108         TestCommon.run(
109                 &quot;-Xlog:cds&quot;,
110                 &quot;-cp&quot;, appJar, &quot;-Xbootclasspath/a:&quot; + otherJar, &quot;Hello&quot;)
111             .assertAbnormalExit(mismatchMessage);
112     }
113 
114     /* Archive contains boot classes only, with Hello loaded from -Xbootclasspath/a at dump time.
115      *
116      * No error if:
117      * dump time: -Xbootclasspath/a:${testdir}/hello.jar
118      * run-time : -Xbootclasspath/a:${testdir}/hello.jar
119      */
120     public void testBootClassPathMatch() throws Exception {
121         String appJar = TestCommon.getTestJar(&quot;hello.jar&quot;);
122         String appClasses[] = {&quot;Hello&quot;};
123         TestCommon.dump(
124             appJar, appClasses, &quot;-Xbootclasspath/a:&quot; + appJar);
125         TestCommon.run(
126                 &quot;-cp&quot;, appJar, &quot;-verbose:class&quot;,
127                 &quot;-Xbootclasspath/a:&quot; + appJar, &quot;Hello&quot;)
128             .assertNormalExit(&quot;[class,load] Hello source: shared objects file&quot;);
129 
130         // test relative path to appJar
131         String newJar = TestCommon.composeRelPath(appJar);
132         TestCommon.run(
133                 &quot;-cp&quot;, newJar, &quot;-verbose:class&quot;,
134                 &quot;-Xbootclasspath/a:&quot; + newJar, &quot;Hello&quot;)
135             .assertNormalExit(&quot;[class,load] Hello source: shared objects file&quot;);
136 
137         int idx = appJar.lastIndexOf(File.separator);
138         String jarName = appJar.substring(idx + 1);
139         String jarDir = appJar.substring(0, idx);
140         // relative path starting with &quot;.&quot;
141         TestCommon.runWithRelativePath(
142             jarDir,
143             &quot;-Xshare:on&quot;,
144             &quot;-XX:SharedArchiveFile=&quot; + TestCommon.getCurrentArchiveName(),
145             &quot;-cp&quot;, &quot;.&quot; + File.separator + jarName,
146             &quot;-Xbootclasspath/a:&quot; + &quot;.&quot; + File.separator + jarName,
147             &quot;-Xlog:class+load=trace,class+path=info&quot;,
148             &quot;Hello&quot;)
149             .assertNormalExit(output -&gt; {
150                 output.shouldContain(&quot;Hello source: shared objects file&quot;)
151                       .shouldHaveExitValue(0);
152                 });
153 
154         // relative path starting with &quot;..&quot;
155         idx = jarDir.lastIndexOf(File.separator);
156         String jarSubDir = jarDir.substring(idx + 1);
157         TestCommon.runWithRelativePath(
158             jarDir,
159             &quot;-Xshare:on&quot;,
160             &quot;-XX:SharedArchiveFile=&quot; + TestCommon.getCurrentArchiveName(),
161             &quot;-cp&quot;, &quot;..&quot; + File.separator + jarSubDir + File.separator + jarName,
162             &quot;-Xbootclasspath/a:&quot; + &quot;..&quot; + File.separator + jarSubDir + File.separator + jarName,
163             &quot;-Xlog:class+load=trace,class+path=info&quot;,
164             &quot;Hello&quot;)
165             .assertNormalExit(output -&gt; {
166                 output.shouldContain(&quot;Hello source: shared objects file&quot;)
167                       .shouldHaveExitValue(0);
168                 });
169 
170         // test sym link to appJar
171         if (!Platform.isWindows()) {
172             File linkedJar = TestCommon.createSymLink(appJar);
173             TestCommon.run(
174                     &quot;-cp&quot;, linkedJar.getPath(), &quot;-verbose:class&quot;,
175                     &quot;-Xbootclasspath/a:&quot; + linkedJar.getPath(), &quot;Hello&quot;)
176                 .assertNormalExit(&quot;[class,load] Hello source: shared objects file&quot;);
177         }
178     }
179 
180     /* Archive contains boot classes only, runtime add -Xbootclasspath/a path.
181      *
182      * No error:
183      * dump time: No -Xbootclasspath/a
184      * run-time : -Xbootclasspath/a:${testdir}/hello.jar
185      */
186     public void testBootClassPathMatchWithAppend() throws Exception {
187       CDSOptions opts = new CDSOptions().setUseVersion(false);
188       OutputAnalyzer out = CDSTestUtils.createArchive(opts);
189       CDSTestUtils.checkDump(out);
190 
191       String appJar = JarBuilder.getOrCreateHelloJar();
192       opts.addPrefix(&quot;-Xbootclasspath/a:&quot; + appJar, &quot;-showversion&quot;).addSuffix(&quot;Hello&quot;);
193       CDSTestUtils.runWithArchiveAndCheck(opts);
194     }
195 
196     /* Archive contains app classes, with Hello on -cp path at dump time.
197      *
198      * Error should be detected if:
199      * dump time: &lt;no bootclasspath specified&gt;
200      * run-time : -Xbootclasspath/a:${testdir}/hello.jar
201      */
202     public void testBootClassPathMismatchWithAppClass() throws Exception {
203         String appJar = JarBuilder.getOrCreateHelloJar();
204         String appClasses[] = {&quot;Hello&quot;};
205         TestCommon.dump(appJar, appClasses);
206         TestCommon.run(
207                 &quot;-Xlog:cds&quot;,
208                 &quot;-cp&quot;, appJar, &quot;-Xbootclasspath/a:&quot; + appJar, &quot;Hello&quot;)
209             .assertAbnormalExit(mismatchMessage);
210 
211         // test relative path to appJar
212         String newJar = TestCommon.composeRelPath(appJar);
213         TestCommon.run(
214                 &quot;-cp&quot;, newJar, &quot;-Xbootclasspath/a:&quot; + newJar, &quot;Hello&quot;)
215             .assertAbnormalExit(mismatchMessage);
216     }
217 
218     private static void copyHelloToNewDir() throws Exception {
219         String classDir = System.getProperty(&quot;test.classes&quot;);
220         String dstDir = classDir + File.separator + &quot;newdir&quot;;
221         try {
222             Files.createDirectory(Paths.get(dstDir));
223         } catch (FileAlreadyExistsException e) { }
224 
225         // copy as hello.jar
226         Path dstPath = Paths.get(dstDir, &quot;hello.jar&quot;);
227         Files.copy(Paths.get(classDir, &quot;hello.jar&quot;),
228             dstPath,
229             StandardCopyOption.REPLACE_EXISTING);
230 
231         File helloJar = dstPath.toFile();
232         long modTime = helloJar.lastModified();
233 
234         // copy as hello.jar1
235         Path dstPath2 = Paths.get(dstDir, &quot;hello.jar1&quot;);
236         Files.copy(Paths.get(classDir, &quot;hello.jar&quot;),
237             dstPath2,
238             StandardCopyOption.REPLACE_EXISTING);
239 
240         // On Windows, we rely on the file size, creation time, and
241         // modification time in order to differentiate between 2 files.
242         // Setting a different modification time on hello.jar1 so that this test
243         // runs more reliably on Windows.
244         modTime += 10000;
245         Files.setAttribute(dstPath2, &quot;lastModifiedTime&quot;, FileTime.fromMillis(modTime));
246     }
247 }
    </pre>
  </body>
</html>
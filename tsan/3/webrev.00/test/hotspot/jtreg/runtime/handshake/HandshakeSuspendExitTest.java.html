<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/runtime/handshake/HandshakeSuspendExitTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 /*
 26  * @test HandshakeSuspendExitTest
 27  * @summary This test tries to stress the handshakes with new and exiting threads while suspending them.
 28  * @library /testlibrary /test/lib
 29  * @build HandshakeSuspendExitTest
 30  * @run main/othervm -XX:+UnlockDiagnosticVMOptions -XX:GuaranteedSafepointInterval=1 -XX:+HandshakeALot HandshakeSuspendExitTest
 31  */
 32 
 33 public class HandshakeSuspendExitTest  implements Runnable {
 34 
 35     static Thread[] _suspend_threads = new Thread[16];
 36     static volatile boolean _exit_now = false;
 37     static java.util.concurrent.Semaphore _sem = new java.util.concurrent.Semaphore(0);
 38 
 39     @Override
 40     public void run() {
 41         _sem.release();
 42         while (!_exit_now) {
 43             // Leave last 2 threads running.
 44             for (int i = 0; i &lt; _suspend_threads.length - 2; i++) {
 45                 if (Thread.currentThread() != _suspend_threads[i]) {
 46                     _suspend_threads[i].suspend();
 47                     _suspend_threads[i].resume();
 48                 }
 49             }
 50         }
 51         _sem.release();
 52     }
 53 
 54     public static void main(String... args) throws Exception {
 55         HandshakeSuspendExitTest test = new HandshakeSuspendExitTest();
 56         // Fire-up suspend threads.
 57         for (int i = 0; i &lt; _suspend_threads.length; i++) {
 58             _suspend_threads[i] = new Thread(test);
 59         }
 60         for (int i = 0; i &lt; _suspend_threads.length; i++) {
 61             _suspend_threads[i].start();
 62         }
 63         // Wait for all suspend-threads to start looping.
 64         for (Thread thr : _suspend_threads) {
 65             _sem.acquire();
 66         }
 67 
 68         // Fire-up exiting threads.
 69         Thread[] exit_threads = new Thread[128];
 70         for (int i = 0; i &lt; exit_threads.length; i++) {
 71             exit_threads[i] = new Thread();
 72             exit_threads[i].start();
 73         }
 74 
 75         // Try to suspend them.
 76         for (Thread thr : exit_threads) {
 77             thr.suspend();
 78         }
 79         for (Thread thr : exit_threads) {
 80             thr.resume();
 81         }
 82 
 83         // Start exit and join.
 84         _exit_now = true;
 85         int waiting = _suspend_threads.length;
 86         do {
 87             // Resume any worker threads that might have suspended
 88             // each other at exactly the same time so they can see
 89             // _exit_now and check in via the semaphore.
 90             for (Thread thr : _suspend_threads) {
 91                 thr.resume();
 92             }
 93             while (_sem.tryAcquire()) {
 94                 --waiting;
 95             }
 96         } while (waiting &gt; 0);
 97         for (Thread thr : _suspend_threads) {
 98             thr.join();
 99         }
100         for (Thread thr : exit_threads) {
101             thr.join();
102         }
103     }
104 }
    </pre>
  </body>
</html>
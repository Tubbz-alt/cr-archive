<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/micro/org/openjdk/bench/java/util/ImmutableColls.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.bench.java.util;
 24 
 25 import org.openjdk.jmh.annotations.*;
 26 import org.openjdk.jmh.infra.Blackhole;
 27 
 28 import java.util.*;
 29 import java.util.concurrent.TimeUnit;
 30 
 31 /**
 32  * Micros for the various collections implemented in
 33  * java.util.ImmutableCollections
 34  */
 35 @State(Scope.Benchmark)
 36 @OutputTimeUnit(TimeUnit.MICROSECONDS)
 37 @Fork(value = 3)
 38 @Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
 39 @Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)
 40 public class ImmutableColls {
 41 
 42     public static String[] STRINGS = {&quot;hi&quot;, &quot;all&quot;, &quot;of&quot;, &quot;you&quot;};
 43 
 44     public static List&lt;String&gt; l0 = List.of();
 45     public static List&lt;String&gt; l1 = List.of(Arrays.copyOf(STRINGS, 1));
 46     public static List&lt;String&gt; l2 = List.of(Arrays.copyOf(STRINGS, 2));
 47     public static List&lt;String&gt; l3 = List.of(Arrays.copyOf(STRINGS, 3));
 48     public static List&lt;String&gt; l4 = List.of(Arrays.copyOf(STRINGS, 4));
 49 
 50     public static Set&lt;String&gt; s0 = Set.copyOf(l0);
 51     public static Set&lt;String&gt; s1 = Set.copyOf(l1);
 52     public static Set&lt;String&gt; s2 = Set.copyOf(l2);
 53     public static Set&lt;String&gt; s3 = Set.copyOf(l3);
 54     public static Set&lt;String&gt; s4 = Set.copyOf(l4);
 55 
 56     public static Map&lt;String, String&gt; m0 = Map.of();
 57     public static Map&lt;String, String&gt; m1 = Map.of(STRINGS[0], STRINGS[0]);
 58     public static Map&lt;String, String&gt; m2 = Map.of(STRINGS[0], STRINGS[0],
 59                                                   STRINGS[1], STRINGS[1]);
 60     public static Map&lt;String, String&gt; m3 = Map.of(STRINGS[0], STRINGS[0],
 61                                                   STRINGS[1], STRINGS[1],
 62                                                   STRINGS[2], STRINGS[2]);
 63     public static Map&lt;String, String&gt; m4 = Map.of(STRINGS[0], STRINGS[0],
 64                                                   STRINGS[1], STRINGS[1],
 65                                                   STRINGS[2], STRINGS[2],
 66                                                   STRINGS[3], STRINGS[3]);
 67 
 68     public static List&lt;String&gt; a0 = new ArrayList&lt;&gt;(l0);
 69     public static List&lt;String&gt; a1 = new ArrayList&lt;&gt;(l1);
 70     public static List&lt;String&gt; a2 = new ArrayList&lt;&gt;(l2);
 71     public static List&lt;String&gt; a3 = new ArrayList&lt;&gt;(l3);
 72     public static List&lt;String&gt; a4 = new ArrayList&lt;&gt;(l4);
 73 
 74     public static final List&lt;String&gt; fl0 = List.of();
 75     public static final List&lt;String&gt; fl1 = List.copyOf(l1);
 76     public static final List&lt;String&gt; fl2 = List.copyOf(l2);
 77     public static final List&lt;String&gt; fl3 = List.copyOf(l3);
 78     public static final List&lt;String&gt; fl4 = List.copyOf(l4);
 79 
 80     public static final List&lt;String&gt; fsl0 = fl0.subList(0, 0);
 81     public static final List&lt;String&gt; fsl1 = fl2.subList(1, 2);
 82     public static final List&lt;String&gt; fsl2 = fl3.subList(0, 2);
 83     public static final List&lt;String&gt; fsl3 = fl4.subList(0, 3);
 84 
 85     public static final Set&lt;String&gt; fs0 = Set.copyOf(l0);
 86     public static final Set&lt;String&gt; fs1 = Set.copyOf(l1);
 87     public static final Set&lt;String&gt; fs2 = Set.copyOf(l2);
 88     public static final Set&lt;String&gt; fs3 = Set.copyOf(l3);
 89     public static final Set&lt;String&gt; fs4 = Set.copyOf(l4);
 90 
 91     public static final Map&lt;String, String&gt; fm0 = Map.copyOf(m0);
 92     public static final Map&lt;String, String&gt; fm1 = Map.copyOf(m1);
 93     public static final Map&lt;String, String&gt; fm2 = Map.copyOf(m2);
 94     public static final Map&lt;String, String&gt; fm3 = Map.copyOf(m3);
 95     public static final Map&lt;String, String&gt; fm4 = Map.copyOf(m4);
 96 
 97     @Benchmark
 98     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
 99     public void constructLists(Blackhole bh) {
100         bh.consume(List.of(STRINGS[0]));
101         bh.consume(List.of(STRINGS[0], STRINGS[1]));
102         bh.consume(List.of(STRINGS[0], STRINGS[1], STRINGS[2]));
103     }
104 
105     @Benchmark
106     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
107     public void constructSets(Blackhole bh) {
108         bh.consume(Set.of(STRINGS[0]));
109         bh.consume(Set.of(STRINGS[0], STRINGS[1]));
110         bh.consume(Set.of(STRINGS[0], STRINGS[1], STRINGS[2]));
111     }
112 
113     @Benchmark
114     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
115     public int sumSizesList() {
116         return sizeOf(l0) +
117                 sizeOf(l1) +
118                 sizeOf(l2) +
119                 sizeOf(l3) +
120                 sizeOf(l4);
121     }
122 
123     @Benchmark
124     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
125     public int sumSizesFinalList() {
126         return sizeOf(fl0) +
127                 sizeOf(fl1) +
128                 sizeOf(fl2) +
129                 sizeOf(fl3) +
130                 sizeOf(fl4);
131     }
132 
133     @Benchmark
134     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
135     public int sumSizesSet() {
136         return sizeOf(s0) +
137                 sizeOf(s1) +
138                 sizeOf(s2) +
139                 sizeOf(s3) +
140                 sizeOf(s4);
141     }
142 
143     @Benchmark
144     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
145     public int sumSizesFinalSet() {
146         return sizeOf2(fs0) +
147                 sizeOf2(fs1) +
148                 sizeOf2(fs2) +
149                 sizeOf2(fs3) +
150                 sizeOf2(fs4);
151     }
152 
153     @Benchmark
154     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
155     public boolean emptyFinalSet() {
156         return fs0.isEmpty() &amp;
157                 fs1.isEmpty() &amp;
158                 fs2.isEmpty() &amp;
159                 fs3.isEmpty() &amp;
160                 fs4.isEmpty();
161     }
162 
163     @Benchmark
164     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
165     public boolean emptyFinalList() {
166         return fl0.isEmpty() &amp;
167                 fl1.isEmpty() &amp;
168                 fl2.isEmpty() &amp;
169                 fl3.isEmpty() &amp;
170                 fl4.isEmpty();
171     }
172 
173     @Benchmark
174     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
175     public boolean emptyFinalMap() {
176         return fm0.isEmpty() &amp;
177                 fm1.isEmpty() &amp;
178                 fm2.isEmpty() &amp;
179                 fm3.isEmpty() &amp;
180                 fm4.isEmpty();
181     }
182 
183     @Benchmark
184     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
185     public boolean containsFinalSet() {
186         return fs0.contains(&quot;hi&quot;) &amp;
187                 fs1.contains(&quot;hi&quot;) &amp;
188                 fs2.contains(&quot;hi&quot;) &amp;
189                 fs3.contains(&quot;hi&quot;) &amp;
190                 fs4.contains(&quot;hi&quot;);
191     }
192 
193     @Benchmark
194     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
195     public boolean containsFinalList() {
196         return fl0.contains(&quot;hi&quot;) &amp;
197                 fl1.contains(&quot;hi&quot;) &amp;
198                 fl2.contains(&quot;hi&quot;) &amp;
199                 fl3.contains(&quot;hi&quot;) &amp;
200                 fl4.contains(&quot;hi&quot;);
201     }
202 
203     @Benchmark
204     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
205     public boolean containsKeyFinalMap() {
206         return fm0.containsKey(&quot;hi&quot;) &amp;
207                 fm1.containsKey(&quot;hi&quot;) &amp;
208                 fm2.containsKey(&quot;hi&quot;) &amp;
209                 fm3.containsKey(&quot;hi&quot;) &amp;
210                 fm4.containsKey(&quot;hi&quot;);
211     }
212 
213     @Benchmark
214     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
215     public boolean containsValueFinalMap() {
216         return fm0.containsValue(&quot;hi&quot;) &amp;
217                 fm1.containsValue(&quot;hi&quot;) &amp;
218                 fm2.containsValue(&quot;hi&quot;) &amp;
219                 fm3.containsValue(&quot;hi&quot;) &amp;
220                 fm4.containsValue(&quot;hi&quot;);
221     }
222 
223     @Benchmark
224     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
225     public void getOrDefault(Blackhole bh) {
226         bh.consume(fm4.getOrDefault(&quot;hi&quot;, &quot;test&quot;));
227         bh.consume(fm4.getOrDefault(&quot;not_in_this_map&quot;, &quot;test&quot;));
228     }
229 
230     public int sizeOf(List&lt;String&gt; list) {
231         return list.size();
232     }
233 
234     /**
235      * Same as sizeOf(List), but duplicated to avoid any
236      * potential profile pollution with tests using
237      * sizeOf.
238      */
239     public int sizeOf2(List&lt;String&gt; list) {
240         return list.size();
241     }
242 
243     public int sizeOf(Set&lt;String&gt; set) {
244         return set.size();
245     }
246 
247     /**
248      * Same as sizeOf(Set), but duplicated to avoid any
249      * potential profile pollution with tests using
250      * sizeOf.
251      */
252     public int sizeOf2(Set&lt;String&gt; set) {
253         return set.size();
254     }
255 
256     @Benchmark
257     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
258     public int getFromList() {
259         return get(l1, 0).length() +
260                 get(l2, 1).length() +
261                 get(l3, 2).length() +
262                 get(l4, 3).length();
263     }
264 
265     @Benchmark
266     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
267     public int finalGetFromList() {
268         return get(fl1, 0).length() +
269                 get(fl2, 1).length() +
270                 get(fl3, 2).length() +
271                 get(fl4, 3).length();
272     }
273 
274     @Benchmark
275     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
276     public void toArrayFromSet(Blackhole bh) {
277         bh.consume(fs4.toArray());
278         bh.consume(s1.toArray());
279         bh.consume(s3.toArray());
280         bh.consume(fs2.toArray());
281         bh.consume(s0.toArray());
282     }
283 
284     @Benchmark
285     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
286     public void iterateOverSet(Blackhole bh) {
287         iterateSet(bh, fs4);
288         iterateSet(bh, s1);
289         iterateSet(bh, s3);
290         iterateSet(bh, fs2);
291         iterateSet(bh, s0);
292     }
293 
294     public void iterateSet(Blackhole bh, Set&lt;String&gt; coll) {
295         for (String s : coll) {
296             bh.consume(s);
297         }
298     }
299 
300     @Benchmark
301     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
302     public void toArrayFromMap(Blackhole bh) {
303         bh.consume(fm4.entrySet().toArray());
304         bh.consume(m1.entrySet().toArray());
305         bh.consume(m3.entrySet().toArray());
306         bh.consume(fm2.entrySet().toArray());
307         bh.consume(m0.entrySet().toArray());
308     }
309 
310     @Benchmark
311     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
312     public void toArrayFromList(Blackhole bh) {
313         bh.consume(fl4.toArray());
314         bh.consume(fl1.toArray());
315         bh.consume(l3.toArray());
316         bh.consume(l0.toArray());
317         bh.consume(fsl3.toArray());
318     }
319 
320     @Benchmark
321     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
322     public void toTypedArrayFromSet(Blackhole bh) {
323         bh.consume(fs4.toArray(new String[0]));
324         bh.consume(s1.toArray(new String[0]));
325         bh.consume(s3.toArray(new String[0]));
326         bh.consume(fs2.toArray(new String[0]));
327         bh.consume(s0.toArray(new String[0]));
328     }
329 
330     @Benchmark
331     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
332     public void toTypedArrayFromMap(Blackhole bh) {
333         bh.consume(fm4.entrySet().toArray(new Map.Entry[0]));
334         bh.consume(m1.entrySet().toArray(new Map.Entry[0]));
335         bh.consume(m3.entrySet().toArray(new Map.Entry[0]));
336         bh.consume(fm2.entrySet().toArray(new Map.Entry[0]));
337         bh.consume(m0.entrySet().toArray(new Map.Entry[0]));
338     }
339 
340     @Benchmark
341     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
342     public void toTypedArrayFromList(Blackhole bh) {
343         bh.consume(fl4.toArray(new String[0]));
344         bh.consume(fl1.toArray(new String[0]));
345         bh.consume(l3.toArray(new String[0]));
346         bh.consume(l0.toArray(new String[0]));
347         bh.consume(fsl3.toArray(new String[0]));
348     }
349 
350     @Benchmark
351     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
352     public void copyOfLists(Blackhole bh) {
353         bh.consume(List.copyOf(fl1));
354         bh.consume(List.copyOf(fl4));
355         bh.consume(List.copyOf(fsl2));
356         bh.consume(List.copyOf(fsl3));
357     }
358 
359     public String get2(List&lt;String&gt; list, int idx) {
360         return list.get(idx);
361     }
362 
363     public String get(List&lt;String&gt; list, int idx) {
364         return list.get(idx);
365     }
366 
367     @Benchmark
368     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
369     public Set&lt;String&gt; createSetOf() {
370         return Set.of(STRINGS);
371     }
372 }
    </pre>
  </body>
</html>
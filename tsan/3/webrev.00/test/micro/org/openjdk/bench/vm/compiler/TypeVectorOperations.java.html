<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/micro/org/openjdk/bench/vm/compiler/TypeVectorOperations.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.bench.vm.compiler;
 24 
 25 import org.openjdk.jmh.annotations.*;
 26 import org.openjdk.jmh.infra.*;
 27 
 28 import java.util.concurrent.TimeUnit;
 29 import java.util.Random;
 30 
 31 @BenchmarkMode(Mode.AverageTime)
 32 @OutputTimeUnit(TimeUnit.NANOSECONDS)
 33 @State(Scope.Thread)
 34 public abstract class TypeVectorOperations {
 35     @Param({&quot;512&quot;,&quot;1024&quot;, &quot;2048&quot;})
 36     public int COUNT;
 37 
 38     private byte[] bytesA;
 39     private byte[] bytesB;
 40     private byte[] resB;
 41     private short[] shorts;
 42     private short[] resS;
 43     private int[] ints;
 44     private int[] resI;
 45     private long[] longs;
 46     private long[] resL;
 47     private double[] doubles;
 48     private double[] resD;
 49     private float[] floats;
 50     private float[] resF;
 51 
 52     @Param(&quot;0&quot;)
 53     private int seed;
 54     private Random r = new Random(seed);
 55 
 56     @Setup
 57     public void init() {
 58         bytesA = new byte[COUNT];
 59         bytesB = new byte[COUNT];
 60         resB = new byte[COUNT];
 61         shorts = new short[COUNT];
 62         resS = new short[COUNT];
 63         ints = new int[COUNT];
 64         resI = new int[COUNT];
 65         longs = new long[COUNT];
 66         resL = new long[COUNT];
 67         doubles = new double[COUNT];
 68         resD = new double[COUNT];
 69         floats = new float[COUNT];
 70         resF = new float[COUNT];
 71 
 72         for (int i = 0; i &lt; COUNT; i++) {
 73             shorts[i] = (short) r.nextInt(Short.MAX_VALUE + 1);
 74             ints[i] = r.nextInt();
 75             longs[i] = r.nextLong();
 76             floats[i] = r.nextFloat();
 77             doubles[i] = r.nextDouble();
 78         }
 79 
 80         r.nextBytes(bytesA);
 81         r.nextBytes(bytesB);
 82 
 83     }
 84 
 85     @Benchmark
 86     public void absB() {
 87         for (int i = 0; i &lt; COUNT; i++) {
 88             byte a = bytesA[i];
 89             resB[i] = (byte) (Math.abs((byte) a));
 90         }
 91     }
 92 
 93     @Benchmark
 94     public void mulB() {
 95         for (int i = 0; i &lt; COUNT; i++) {
 96             byte a = bytesA[i];
 97             byte b = bytesB[i];
 98             resI[i] = a * b;
 99         }
100     }
101 
102     @Benchmark
103     public void lShiftB() {
104         for (int i = 0; i &lt; COUNT; i++) {
105             resB[i] = (byte) (bytesA[i] &lt;&lt; 3);
106         }
107     }
108 
109     @Benchmark
110     public void rShiftB() {
111         for (int i = 0; i &lt; COUNT; i++) {
112             resB[i] = (byte) (bytesA[i] &gt;&gt; 3);
113         }
114     }
115 
116     @Benchmark
117     public void urShiftB() {
118         for (int i = 0; i &lt; COUNT; i++) {
119             resB[i] = (byte) (bytesA[i] &gt;&gt;&gt; 3);
120         }
121     }
122 
123     @Benchmark
124     public void absS() {
125         for (int i = 0; i &lt; COUNT; i++) {
126             short a = shorts[i];
127             resS[i] = (short) (Math.abs((short) a));
128         }
129     }
130 
131     @Benchmark
132     public void absI() {
133         for (int i = 0; i &lt; COUNT; i++) {
134             int a = ints[i];
135             resI[i] = Math.abs(a);
136         }
137     }
138 
139     @Benchmark
140     public void mulI() {
141         for (int i = 0; i &lt; COUNT; i++) {
142             resI[i] = (ints[i] * ints[i]);
143         }
144     }
145 
146     @Benchmark
147     public void mulL() {
148         for (int i = 0; i &lt; COUNT; i++) {
149             resL[i] = (longs[i] * longs[i]);
150         }
151     }
152 
153     @Benchmark
154     public void absL() {
155         for (int i = 0; i &lt; COUNT; i++) {
156             long a = longs[i];
157             resL[i] = (long) (Math.abs((long) a));
158         }
159     }
160 
161     @Benchmark
162     public void rShiftL() {
163         for (int i = 0; i &lt; COUNT; i++) {
164             resL[i] = longs[i] &gt;&gt; 3;
165         }
166     }
167 
168     @Benchmark
169     public void absF() {
170         for (int i = 0; i &lt; COUNT; i++) {
171             float a = floats[i];
172             resF[i] = (float) (Math.abs(a));
173         }
174     }
175 
176     @Benchmark
177     public void negF() {
178         for (int i = 0; i &lt; COUNT; i++) {
179             resF[i] = -floats[i];
180         }
181     }
182 
183     @Benchmark
184     public void absD() {
185         for (int i = 0; i &lt; COUNT; i++) {
186             double a = doubles[i];
187             resD[i] = (double) (Math.abs(a));
188         }
189     }
190 
191     @Benchmark
192     public void negD() {
193         for (int i = 0; i &lt; COUNT; i++) {
194             resD[i] = -doubles[i];
195         }
196     }
197 
198     @Fork(value = 1, jvmArgsPrepend = {
199         &quot;-XX:+UseSuperWord&quot;
200     })
201     public static class TypeVectorOperationsSuperWord extends TypeVectorOperations {
202 
203     }
204 
205     @Fork(value = 1, jvmArgsPrepend = {
206         &quot;-XX:-UseSuperWord&quot;
207     })
208     public static class TypeVectorOperationsNonSuperWord extends TypeVectorOperations {
209     }
210 
211 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/micro/org/openjdk/bench/java/net/SocketChannelReadWrite.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014 Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.bench.java.net;
 24 
 25 import java.io.IOException;
 26 import java.net.InetAddress;
 27 import java.net.InetSocketAddress;
 28 import java.nio.ByteBuffer;
 29 import java.nio.channels.ClosedChannelException;
 30 import java.nio.channels.ServerSocketChannel;
 31 import java.nio.channels.SocketChannel;
 32 import java.util.concurrent.TimeUnit;
 33 
 34 import org.openjdk.jmh.annotations.*;
 35 
 36 /**
 37  * Tests the overheads of I/O API.
 38  * This test is known to depend heavily on network conditions and paltform.
 39  */
 40 @BenchmarkMode(Mode.Throughput)
 41 @OutputTimeUnit(TimeUnit.MILLISECONDS)
 42 @State(Scope.Thread)
 43 public class SocketChannelReadWrite {
 44 
 45     private ServerSocketChannel ssc;
 46     private SocketChannel s1, s2;
 47     private ReadThread rt;
 48     private ByteBuffer bb = ByteBuffer.allocate(1);
 49 
 50     @Setup(Level.Trial)
 51     public void beforeRun() throws IOException {
 52         InetAddress iaddr = InetAddress.getLocalHost();
 53 
 54         ssc = ServerSocketChannel.open().bind(null);
 55         s1 = SocketChannel.open(new InetSocketAddress(iaddr, ssc.socket().getLocalPort()));
 56         s2 = ssc.accept();
 57 
 58         rt = new ReadThread(s2);
 59         rt.start();
 60 
 61         bb.put((byte) 47);
 62         bb.flip();
 63     }
 64 
 65     @TearDown(Level.Trial)
 66     public void afterRun() throws IOException, InterruptedException {
 67         s1.close();
 68         s2.close();
 69         ssc.close();
 70         rt.join();
 71     }
 72 
 73     @Benchmark
 74     public void test() throws IOException {
 75         s1.write(bb);
 76         bb.flip();
 77     }
 78 
 79     static class ReadThread extends Thread {
 80         private SocketChannel sc;
 81 
 82         public ReadThread(SocketChannel s2) {
 83             this.sc = s2;
 84         }
 85 
 86         public void run() {
 87             try {
 88                 ByteBuffer bb = ByteBuffer.allocate(1);
 89                 while (sc.read(bb) &gt; 0) {
 90                     bb.flip();
 91                 }
 92             } catch (ClosedChannelException ex) {
 93                 // shutdown time
 94             } catch (IOException e) {
 95                 e.printStackTrace();
 96             }
 97         }
 98     }
 99 
100 }
    </pre>
  </body>
</html>
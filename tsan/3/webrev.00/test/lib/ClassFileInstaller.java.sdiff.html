<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/lib/ClassFileInstaller.java</title>
    <link rel="stylesheet" href="../../style.css" />
  </head>
<body>
<center><a href="../lib-test/jdk/test/lib/apps/LingeredAppTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../index.html" target="_top">index</a> <a href="RedefineClassHelper.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/lib/ClassFileInstaller.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.ByteArrayInputStream;
 25 import java.io.File;
 26 import java.io.FileInputStream;
 27 import java.io.FileOutputStream;
 28 import java.io.FileNotFoundException;
 29 import java.io.InputStream;
 30 import java.io.ByteArrayInputStream;
 31 import java.nio.file.Files;
 32 import java.nio.file.Path;
 33 import java.nio.file.Paths;
 34 import java.nio.file.StandardCopyOption;

 35 import java.util.zip.ZipEntry;
 36 import java.util.zip.ZipOutputStream;
 37 
 38 /**
 39  * Dump a class file for a class on the class path in the current directory, or
 40  * in the specified JAR file. This class is usually used when you build a class
 41  * from a test library, but want to use this class in a sub-process.
 42  *
 43  * For example, to build the following library class:
 44  * test/lib/sun/hotspot/WhiteBox.java
 45  *
 46  * You would use the following tags:
 47  *
 48  * @library /test/lib
 49  * @build sun.hotspot.WhiteBox
 50  *
 51  * JTREG would build the class file under
 52  * ${JTWork}/classes/test/lib/sun/hotspot/WhiteBox.class
 53  *
 54  * With you run your main test class using &quot;@run main MyMainClass&quot;, JTREG would setup the
</pre>
<hr />
<pre>
 67  * @run main ClassFileInstaller -jar myjar.jar sun.hotspot.WhiteBox
 68  */
 69 public class ClassFileInstaller {
 70     /**
 71      * You can enable debug tracing of ClassFileInstaller by running JTREG with
 72      * jtreg -DClassFileInstaller.debug=true ... &lt;names of tests&gt;
 73      */
 74     public static boolean DEBUG = Boolean.getBoolean(&quot;ClassFileInstaller.debug&quot;);
 75 
 76     /**
 77      * @param args The names of the classes to dump
 78      * @throws Exception
 79      */
 80     public static void main(String... args) throws Exception {
 81         if (args.length &gt; 1 &amp;&amp; args[0].equals(&quot;-jar&quot;)) {
 82             if (args.length &lt; 2) {
 83                 throw new RuntimeException(&quot;Usage: ClassFileInstaller &lt;options&gt; &lt;classes&gt;\n&quot; +
 84                                            &quot;where possible options include:\n&quot; +
 85                                            &quot;  -jar &lt;path&gt;             Write to the JAR file &lt;path&gt;&quot;);
 86             }
<span class="line-modified"> 87             writeJar(args[1], null, args, 2, args.length);</span>


 88         } else {
 89             if (DEBUG) {
 90                 System.out.println(&quot;ClassFileInstaller: Writing to &quot; + System.getProperty(&quot;user.dir&quot;));
 91             }
<span class="line-modified"> 92             for (String arg : args) {</span>
<span class="line-modified"> 93                 writeClassToDisk(arg);</span>

 94             }
 95         }
 96     }
 97 



























 98     public static class Manifest {
 99         private InputStream in;
100 
101         private Manifest(InputStream in) {
102             this.in = in;
103         }
104 
105         static Manifest fromSourceFile(String fileName) throws Exception {
106             String pathName = System.getProperty(&quot;test.src&quot;) + File.separator + fileName;
107             return new Manifest(new FileInputStream(pathName));
108         }
109 
110         // Example:
111         //  String manifest = &quot;Premain-Class: RedefineClassHelper\n&quot; +
112         //                &quot;Can-Redefine-Classes: true\n&quot;;
113         //  ClassFileInstaller.writeJar(&quot;redefineagent.jar&quot;,
114         //    ClassFileInstaller.Manifest.fromString(manifest),
115         //    &quot;RedefineClassHelper&quot;);
116         static Manifest fromString(String manifest) throws Exception {
117             return new Manifest(new ByteArrayInputStream(manifest.getBytes()));
118         }
119 
120         public InputStream getInputStream() {
121             return in;
122         }
123     }
124 
<span class="line-modified">125     private static void writeJar(String jarFile, Manifest manifest, String classes[], int from, int to) throws Exception {</span>
126         if (DEBUG) {
127             System.out.println(&quot;ClassFileInstaller: Writing to &quot; + getJarPath(jarFile));
128         }
129 
130         (new File(jarFile)).delete();
131         FileOutputStream fos = new FileOutputStream(jarFile);
132         ZipOutputStream zos = new ZipOutputStream(fos);
133 
134         // The manifest must be the first or second entry. See comments in JarInputStream
135         // constructor and JDK-5046178.
136         if (manifest != null) {
137             writeToDisk(zos, &quot;META-INF/MANIFEST.MF&quot;, manifest.getInputStream());
138         }
139 
<span class="line-modified">140         for (int i=from; i&lt;to; i++) {</span>
<span class="line-modified">141             writeClassToDisk(zos, classes[i]);</span>
142         }
143 
144         zos.close();
145         fos.close();
146     }
147 
148     /*
149      * You can call ClassFileInstaller.writeJar() from your main test class instead of
150      * using &quot;@run ClassFileInstaller -jar ...&quot;. E.g.,
151      *
152      * String jarPath = ClassFileInstaller.getJarPath(&quot;myjar.jar&quot;, &quot;sun.hotspot.WhiteBox&quot;)
153      *
154      * If you call this API, make sure you build ClassFileInstaller with the following tags:
155      *
156      * @library testlibrary
157      * @build ClassFileInstaller
158      */
159     public static String writeJar(String jarFile, String... classes) throws Exception {
<span class="line-modified">160         writeJar(jarFile, null, classes, 0, classes.length);</span>

161         return getJarPath(jarFile);
162     }
163 
164     public static String writeJar(String jarFile, Manifest manifest, String... classes) throws Exception {
<span class="line-modified">165         writeJar(jarFile, manifest, classes, 0, classes.length);</span>

166         return getJarPath(jarFile);
167     }
168 
169     /**
170      * This returns the absolute path to the file specified in &quot;@ClassFileInstaller -jar myjar.jar&quot;,
171      * In your test program, instead of using the JAR file name directly:
172      *
173      * String jarPath = &quot;myjar.jar&quot;;
174      *
175      * you should call this function, like:
176      *
177      * String jarPath = ClassFileInstaller.getJarPath(&quot;myjar.jar&quot;)
178      *
179      * The reasons are:
180      * (1) Using absolute path makes it easy to cut-and-paste from the JTR file and rerun your
181      *     test in any directory.
182      * (2) In the future, we may make the JAR file name unique to avoid clobbering
183      *     during parallel JTREG execution.
184      *
185      */
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.ByteArrayInputStream;
 25 import java.io.File;
 26 import java.io.FileInputStream;
 27 import java.io.FileOutputStream;
 28 import java.io.FileNotFoundException;
 29 import java.io.InputStream;
 30 import java.io.ByteArrayInputStream;
 31 import java.nio.file.Files;
 32 import java.nio.file.Path;
 33 import java.nio.file.Paths;
 34 import java.nio.file.StandardCopyOption;
<span class="line-added"> 35 import java.util.ArrayList;</span>
 36 import java.util.zip.ZipEntry;
 37 import java.util.zip.ZipOutputStream;
 38 
 39 /**
 40  * Dump a class file for a class on the class path in the current directory, or
 41  * in the specified JAR file. This class is usually used when you build a class
 42  * from a test library, but want to use this class in a sub-process.
 43  *
 44  * For example, to build the following library class:
 45  * test/lib/sun/hotspot/WhiteBox.java
 46  *
 47  * You would use the following tags:
 48  *
 49  * @library /test/lib
 50  * @build sun.hotspot.WhiteBox
 51  *
 52  * JTREG would build the class file under
 53  * ${JTWork}/classes/test/lib/sun/hotspot/WhiteBox.class
 54  *
 55  * With you run your main test class using &quot;@run main MyMainClass&quot;, JTREG would setup the
</pre>
<hr />
<pre>
 68  * @run main ClassFileInstaller -jar myjar.jar sun.hotspot.WhiteBox
 69  */
 70 public class ClassFileInstaller {
 71     /**
 72      * You can enable debug tracing of ClassFileInstaller by running JTREG with
 73      * jtreg -DClassFileInstaller.debug=true ... &lt;names of tests&gt;
 74      */
 75     public static boolean DEBUG = Boolean.getBoolean(&quot;ClassFileInstaller.debug&quot;);
 76 
 77     /**
 78      * @param args The names of the classes to dump
 79      * @throws Exception
 80      */
 81     public static void main(String... args) throws Exception {
 82         if (args.length &gt; 1 &amp;&amp; args[0].equals(&quot;-jar&quot;)) {
 83             if (args.length &lt; 2) {
 84                 throw new RuntimeException(&quot;Usage: ClassFileInstaller &lt;options&gt; &lt;classes&gt;\n&quot; +
 85                                            &quot;where possible options include:\n&quot; +
 86                                            &quot;  -jar &lt;path&gt;             Write to the JAR file &lt;path&gt;&quot;);
 87             }
<span class="line-modified"> 88             String jarFile = args[1];</span>
<span class="line-added"> 89             String[] classes = addInnerClasses(args, 2);</span>
<span class="line-added"> 90             writeJar_impl(jarFile, null, classes);</span>
 91         } else {
 92             if (DEBUG) {
 93                 System.out.println(&quot;ClassFileInstaller: Writing to &quot; + System.getProperty(&quot;user.dir&quot;));
 94             }
<span class="line-modified"> 95             String[] classes = addInnerClasses(args, 0);</span>
<span class="line-modified"> 96             for (String cls : classes) {</span>
<span class="line-added"> 97                 writeClassToDisk(cls);</span>
 98             }
 99         }
100     }
101 
<span class="line-added">102     // Add commonly used inner classes that are often omitted by mistake. Currently</span>
<span class="line-added">103     // we support only sun.hotspot.WhiteBox$WhiteBoxPermission. See JDK-8199290</span>
<span class="line-added">104     private static String[] addInnerClasses(String[] classes, int startIdx) {</span>
<span class="line-added">105         boolean seenWB = false;</span>
<span class="line-added">106         boolean seenWBInner = false;</span>
<span class="line-added">107         final String wb = &quot;sun.hotspot.WhiteBox&quot;;</span>
<span class="line-added">108         final String wbInner = &quot;sun.hotspot.WhiteBox$WhiteBoxPermission&quot;;</span>
<span class="line-added">109 </span>
<span class="line-added">110         ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="line-added">111 </span>
<span class="line-added">112         for (int i = startIdx; i &lt; classes.length; i++) {</span>
<span class="line-added">113             String cls = classes[i];</span>
<span class="line-added">114             list.add(cls);</span>
<span class="line-added">115             switch (cls) {</span>
<span class="line-added">116             case wb:      seenWB      = true; break;</span>
<span class="line-added">117             case wbInner: seenWBInner = true; break;</span>
<span class="line-added">118             }</span>
<span class="line-added">119         }</span>
<span class="line-added">120         if (seenWB &amp;&amp; !seenWBInner) {</span>
<span class="line-added">121             list.add(wbInner);</span>
<span class="line-added">122         }</span>
<span class="line-added">123 </span>
<span class="line-added">124         String[] array = new String[list.size()];</span>
<span class="line-added">125         list.toArray(array);</span>
<span class="line-added">126         return array;</span>
<span class="line-added">127     }</span>
<span class="line-added">128 </span>
129     public static class Manifest {
130         private InputStream in;
131 
132         private Manifest(InputStream in) {
133             this.in = in;
134         }
135 
136         static Manifest fromSourceFile(String fileName) throws Exception {
137             String pathName = System.getProperty(&quot;test.src&quot;) + File.separator + fileName;
138             return new Manifest(new FileInputStream(pathName));
139         }
140 
141         // Example:
142         //  String manifest = &quot;Premain-Class: RedefineClassHelper\n&quot; +
143         //                &quot;Can-Redefine-Classes: true\n&quot;;
144         //  ClassFileInstaller.writeJar(&quot;redefineagent.jar&quot;,
145         //    ClassFileInstaller.Manifest.fromString(manifest),
146         //    &quot;RedefineClassHelper&quot;);
147         static Manifest fromString(String manifest) throws Exception {
148             return new Manifest(new ByteArrayInputStream(manifest.getBytes()));
149         }
150 
151         public InputStream getInputStream() {
152             return in;
153         }
154     }
155 
<span class="line-modified">156     private static void writeJar_impl(String jarFile, Manifest manifest, String classes[]) throws Exception {</span>
157         if (DEBUG) {
158             System.out.println(&quot;ClassFileInstaller: Writing to &quot; + getJarPath(jarFile));
159         }
160 
161         (new File(jarFile)).delete();
162         FileOutputStream fos = new FileOutputStream(jarFile);
163         ZipOutputStream zos = new ZipOutputStream(fos);
164 
165         // The manifest must be the first or second entry. See comments in JarInputStream
166         // constructor and JDK-5046178.
167         if (manifest != null) {
168             writeToDisk(zos, &quot;META-INF/MANIFEST.MF&quot;, manifest.getInputStream());
169         }
170 
<span class="line-modified">171         for (String cls : classes) {</span>
<span class="line-modified">172             writeClassToDisk(zos, cls);</span>
173         }
174 
175         zos.close();
176         fos.close();
177     }
178 
179     /*
180      * You can call ClassFileInstaller.writeJar() from your main test class instead of
181      * using &quot;@run ClassFileInstaller -jar ...&quot;. E.g.,
182      *
183      * String jarPath = ClassFileInstaller.getJarPath(&quot;myjar.jar&quot;, &quot;sun.hotspot.WhiteBox&quot;)
184      *
185      * If you call this API, make sure you build ClassFileInstaller with the following tags:
186      *
187      * @library testlibrary
188      * @build ClassFileInstaller
189      */
190     public static String writeJar(String jarFile, String... classes) throws Exception {
<span class="line-modified">191         classes = addInnerClasses(classes, 0);</span>
<span class="line-added">192         writeJar_impl(jarFile, null, classes);</span>
193         return getJarPath(jarFile);
194     }
195 
196     public static String writeJar(String jarFile, Manifest manifest, String... classes) throws Exception {
<span class="line-modified">197         classes = addInnerClasses(classes, 0);</span>
<span class="line-added">198         writeJar_impl(jarFile, manifest, classes);</span>
199         return getJarPath(jarFile);
200     }
201 
202     /**
203      * This returns the absolute path to the file specified in &quot;@ClassFileInstaller -jar myjar.jar&quot;,
204      * In your test program, instead of using the JAR file name directly:
205      *
206      * String jarPath = &quot;myjar.jar&quot;;
207      *
208      * you should call this function, like:
209      *
210      * String jarPath = ClassFileInstaller.getJarPath(&quot;myjar.jar&quot;)
211      *
212      * The reasons are:
213      * (1) Using absolute path makes it easy to cut-and-paste from the JTR file and rerun your
214      *     test in any directory.
215      * (2) In the future, we may make the JAR file name unique to avoid clobbering
216      *     during parallel JTREG execution.
217      *
218      */
</pre>
</td>
</tr>
</table>
<center><a href="../lib-test/jdk/test/lib/apps/LingeredAppTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../index.html" target="_top">index</a> <a href="RedefineClassHelper.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/lib/sun/hotspot/WhiteBox.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package sun.hotspot;
 25 
 26 import java.lang.management.MemoryUsage;
 27 import java.lang.reflect.Executable;
 28 import java.util.Arrays;
 29 import java.util.List;
 30 import java.util.function.BiFunction;
 31 import java.util.function.Function;
 32 import java.security.BasicPermission;
 33 import java.util.Objects;
 34 
 35 import sun.hotspot.parser.DiagnosticCommand;
 36 
 37 public class WhiteBox {
 38   @SuppressWarnings(&quot;serial&quot;)
 39   public static class WhiteBoxPermission extends BasicPermission {
 40     public WhiteBoxPermission(String s) {
 41       super(s);
 42     }
 43   }
 44 
 45   private WhiteBox() {}
 46   private static final WhiteBox instance = new WhiteBox();
 47   private static native void registerNatives();
 48 
 49   /**
 50    * Returns the singleton WhiteBox instance.
 51    *
 52    * The returned WhiteBox object should be carefully guarded
 53    * by the caller, since it can be used to read and write data
 54    * at arbitrary memory addresses. It must never be passed to
 55    * untrusted code.
 56    */
 57   public synchronized static WhiteBox getWhiteBox() {
 58     SecurityManager sm = System.getSecurityManager();
 59     if (sm != null) {
 60       sm.checkPermission(new WhiteBoxPermission(&quot;getInstance&quot;));
 61     }
 62     return instance;
 63   }
 64 
 65   static {
 66     registerNatives();
 67   }
 68 
 69   // Get the maximum heap size supporting COOPs
 70   public native long getCompressedOopsMaxHeapSize();
 71   // Arguments
 72   public native void printHeapSizes();
 73 
 74   // Memory
 75   private native long getObjectAddress0(Object o);
 76   public           long getObjectAddress(Object o) {
 77     Objects.requireNonNull(o);
 78     return getObjectAddress0(o);
 79   }
 80 
 81   public native int  getHeapOopSize();
 82   public native int  getVMPageSize();
 83   public native long getVMAllocationGranularity();
 84   public native long getVMLargePageSize();
 85   public native long getHeapSpaceAlignment();
 86   public native long getHeapAlignment();
 87 
 88   private native boolean isObjectInOldGen0(Object o);
 89   public         boolean isObjectInOldGen(Object o) {
 90     Objects.requireNonNull(o);
 91     return isObjectInOldGen0(o);
 92   }
 93 
 94   private native long getObjectSize0(Object o);
 95   public         long getObjectSize(Object o) {
 96     Objects.requireNonNull(o);
 97     return getObjectSize0(o);
 98   }
 99 
100   // Runtime
101   // Make sure class name is in the correct format
102   public boolean isClassAlive(String name) {
103     return isClassAlive0(name.replace(&#39;.&#39;, &#39;/&#39;));
104   }
105   private native boolean isClassAlive0(String name);
106   public  native int getSymbolRefcount(String name);
107 
108   private native boolean isMonitorInflated0(Object obj);
109   public         boolean isMonitorInflated(Object obj) {
110     Objects.requireNonNull(obj);
111     return isMonitorInflated0(obj);
112   }
113 
114   public native void forceSafepoint();
115 
116   private native long getConstantPool0(Class&lt;?&gt; aClass);
117   public         long getConstantPool(Class&lt;?&gt; aClass) {
118     Objects.requireNonNull(aClass);
119     return getConstantPool0(aClass);
120   }
121 
122   private native int getConstantPoolCacheIndexTag0();
123   public         int getConstantPoolCacheIndexTag() {
124     return getConstantPoolCacheIndexTag0();
125   }
126 
127   private native int getConstantPoolCacheLength0(Class&lt;?&gt; aClass);
128   public         int getConstantPoolCacheLength(Class&lt;?&gt; aClass) {
129     Objects.requireNonNull(aClass);
130     return getConstantPoolCacheLength0(aClass);
131   }
132 
133   private native int remapInstructionOperandFromCPCache0(Class&lt;?&gt; aClass, int index);
134   public         int remapInstructionOperandFromCPCache(Class&lt;?&gt; aClass, int index) {
135     Objects.requireNonNull(aClass);
136     return remapInstructionOperandFromCPCache0(aClass, index);
137   }
138 
139   private native int encodeConstantPoolIndyIndex0(int index);
140   public         int encodeConstantPoolIndyIndex(int index) {
141     return encodeConstantPoolIndyIndex0(index);
142   }
143 
144   // JVMTI
145   private native void addToBootstrapClassLoaderSearch0(String segment);
146   public         void addToBootstrapClassLoaderSearch(String segment){
147     Objects.requireNonNull(segment);
148     addToBootstrapClassLoaderSearch0(segment);
149   }
150 
151   private native void addToSystemClassLoaderSearch0(String segment);
152   public         void addToSystemClassLoaderSearch(String segment) {
153     Objects.requireNonNull(segment);
154     addToSystemClassLoaderSearch0(segment);
155   }
156 
157   // G1
158   public native boolean g1InConcurrentMark();
159   private native boolean g1IsHumongous0(Object o);
160   public         boolean g1IsHumongous(Object o) {
161     Objects.requireNonNull(o);
162     return g1IsHumongous0(o);
163   }
164 
165   private native boolean g1BelongsToHumongousRegion0(long adr);
166   public         boolean g1BelongsToHumongousRegion(long adr) {
167     if (adr == 0) {
168       throw new IllegalArgumentException(&quot;adr argument should not be null&quot;);
169     }
170     return g1BelongsToHumongousRegion0(adr);
171   }
172 
173 
174   private native boolean g1BelongsToFreeRegion0(long adr);
175   public         boolean g1BelongsToFreeRegion(long adr) {
176     if (adr == 0) {
177       throw new IllegalArgumentException(&quot;adr argument should not be null&quot;);
178     }
179     return g1BelongsToFreeRegion0(adr);
180   }
181 
182   public native long    g1NumMaxRegions();
183   public native long    g1NumFreeRegions();
184   public native int     g1RegionSize();
185   public native long    dramReservedStart();
186   public native long    dramReservedEnd();
187   public native long    nvdimmReservedStart();
188   public native long    nvdimmReservedEnd();
189   public native MemoryUsage g1AuxiliaryMemoryUsage();
190   private  native Object[]    parseCommandLine0(String commandline, char delim, DiagnosticCommand[] args);
191   public          Object[]    parseCommandLine(String commandline, char delim, DiagnosticCommand[] args) {
192     Objects.requireNonNull(args);
193     return parseCommandLine0(commandline, delim, args);
194   }
195 
196   // Parallel GC
197   public native long psVirtualSpaceAlignment();
198   public native long psHeapGenerationAlignment();
199 
200   /**
201    * Enumerates old regions with liveness less than specified and produces some statistics
202    * @param liveness percent of region&#39;s liveness (live_objects / total_region_size * 100).
203    * @return long[3] array where long[0] - total count of old regions
204    *                             long[1] - total memory of old regions
205    *                             long[2] - lowest estimation of total memory of old regions to be freed (non-full
206    *                             regions are not included)
207    */
208   public native long[] g1GetMixedGCInfo(int liveness);
209 
210   // NMT
211   public native long NMTMalloc(long size);
212   public native void NMTFree(long mem);
213   public native long NMTReserveMemory(long size);
214   public native long NMTAttemptReserveMemoryAt(long addr, long size);
215   public native void NMTCommitMemory(long addr, long size);
216   public native void NMTUncommitMemory(long addr, long size);
217   public native void NMTReleaseMemory(long addr, long size);
218   public native long NMTMallocWithPseudoStack(long size, int index);
219   public native long NMTMallocWithPseudoStackAndType(long size, int index, int type);
220   public native boolean NMTChangeTrackingLevel();
221   public native int NMTGetHashSize();
222 
223   // Compiler
224   public native int     matchesMethod(Executable method, String pattern);
225   public native int     matchesInline(Executable method, String pattern);
226   public native boolean shouldPrintAssembly(Executable method, int comp_level);
227   public native int     deoptimizeFrames(boolean makeNotEntrant);
228   public native void    deoptimizeAll();
229 
230   public        boolean isMethodCompiled(Executable method) {
231     return isMethodCompiled(method, false /*not osr*/);
232   }
233   private native boolean isMethodCompiled0(Executable method, boolean isOsr);
234   public         boolean isMethodCompiled(Executable method, boolean isOsr){
235     Objects.requireNonNull(method);
236     return isMethodCompiled0(method, isOsr);
237   }
238   public        boolean isMethodCompilable(Executable method) {
239     return isMethodCompilable(method, -2 /*any*/);
240   }
241   public        boolean isMethodCompilable(Executable method, int compLevel) {
242     return isMethodCompilable(method, compLevel, false /*not osr*/);
243   }
244   private native boolean isMethodCompilable0(Executable method, int compLevel, boolean isOsr);
245   public         boolean isMethodCompilable(Executable method, int compLevel, boolean isOsr) {
246     Objects.requireNonNull(method);
247     return isMethodCompilable0(method, compLevel, isOsr);
248   }
249   private native boolean isMethodQueuedForCompilation0(Executable method);
250   public         boolean isMethodQueuedForCompilation(Executable method) {
251     Objects.requireNonNull(method);
252     return isMethodQueuedForCompilation0(method);
253   }
254   // Determine if the compiler corresponding to the compilation level &#39;compLevel&#39;
255   // and to the compilation context &#39;compilation_context&#39; provides an intrinsic
256   // for the method &#39;method&#39;. An intrinsic is available for method &#39;method&#39; if:
257   //  - the intrinsic is enabled (by using the appropriate command-line flag) and
258   //  - the platform on which the VM is running provides the instructions necessary
259   //    for the compiler to generate the intrinsic code.
260   //
261   // The compilation context is related to using the DisableIntrinsic flag on a
262   // per-method level, see hotspot/src/share/vm/compiler/abstractCompiler.hpp
263   // for more details.
264   public boolean isIntrinsicAvailable(Executable method,
265                                       Executable compilationContext,
266                                       int compLevel) {
267       Objects.requireNonNull(method);
268       return isIntrinsicAvailable0(method, compilationContext, compLevel);
269   }
270   // If usage of the DisableIntrinsic flag is not expected (or the usage can be ignored),
271   // use the below method that does not require the compilation context as argument.
272   public boolean isIntrinsicAvailable(Executable method, int compLevel) {
273       return isIntrinsicAvailable(method, null, compLevel);
274   }
275   private native boolean isIntrinsicAvailable0(Executable method,
276                                                Executable compilationContext,
277                                                int compLevel);
278   public        int     deoptimizeMethod(Executable method) {
279     return deoptimizeMethod(method, false /*not osr*/);
280   }
281   private native int     deoptimizeMethod0(Executable method, boolean isOsr);
282   public         int     deoptimizeMethod(Executable method, boolean isOsr) {
283     Objects.requireNonNull(method);
284     return deoptimizeMethod0(method, isOsr);
285   }
286   public        void    makeMethodNotCompilable(Executable method) {
287     makeMethodNotCompilable(method, -2 /*any*/);
288   }
289   public        void    makeMethodNotCompilable(Executable method, int compLevel) {
290     makeMethodNotCompilable(method, compLevel, false /*not osr*/);
291   }
292   private native void    makeMethodNotCompilable0(Executable method, int compLevel, boolean isOsr);
293   public         void    makeMethodNotCompilable(Executable method, int compLevel, boolean isOsr) {
294     Objects.requireNonNull(method);
295     makeMethodNotCompilable0(method, compLevel, isOsr);
296   }
297   public        int     getMethodCompilationLevel(Executable method) {
298     return getMethodCompilationLevel(method, false /*not ost*/);
299   }
300   private native int     getMethodCompilationLevel0(Executable method, boolean isOsr);
301   public         int     getMethodCompilationLevel(Executable method, boolean isOsr) {
302     Objects.requireNonNull(method);
303     return getMethodCompilationLevel0(method, isOsr);
304   }
305   private native boolean testSetDontInlineMethod0(Executable method, boolean value);
306   public         boolean testSetDontInlineMethod(Executable method, boolean value) {
307     Objects.requireNonNull(method);
308     return testSetDontInlineMethod0(method, value);
309   }
310   public        int     getCompileQueuesSize() {
311     return getCompileQueueSize(-2 /*any*/);
312   }
313   public native int     getCompileQueueSize(int compLevel);
314   private native boolean testSetForceInlineMethod0(Executable method, boolean value);
315   public         boolean testSetForceInlineMethod(Executable method, boolean value) {
316     Objects.requireNonNull(method);
317     return testSetForceInlineMethod0(method, value);
318   }
319   public        boolean enqueueMethodForCompilation(Executable method, int compLevel) {
320     return enqueueMethodForCompilation(method, compLevel, -1 /*InvocationEntryBci*/);
321   }
322   private native boolean enqueueMethodForCompilation0(Executable method, int compLevel, int entry_bci);
323   public  boolean enqueueMethodForCompilation(Executable method, int compLevel, int entry_bci) {
324     Objects.requireNonNull(method);
325     return enqueueMethodForCompilation0(method, compLevel, entry_bci);
326   }
327   private native boolean enqueueInitializerForCompilation0(Class&lt;?&gt; aClass, int compLevel);
328   public  boolean enqueueInitializerForCompilation(Class&lt;?&gt; aClass, int compLevel) {
329     Objects.requireNonNull(aClass);
330     return enqueueInitializerForCompilation0(aClass, compLevel);
331   }
332   private native void    clearMethodState0(Executable method);
333   public         void    clearMethodState(Executable method) {
334     Objects.requireNonNull(method);
335     clearMethodState0(method);
336   }
337   public native void    lockCompilation();
338   public native void    unlockCompilation();
339   private native int     getMethodEntryBci0(Executable method);
340   public         int     getMethodEntryBci(Executable method) {
341     Objects.requireNonNull(method);
342     return getMethodEntryBci0(method);
343   }
344   private native Object[] getNMethod0(Executable method, boolean isOsr);
345   public         Object[] getNMethod(Executable method, boolean isOsr) {
346     Objects.requireNonNull(method);
347     return getNMethod0(method, isOsr);
348   }
349   public native long    allocateCodeBlob(int size, int type);
350   public        long    allocateCodeBlob(long size, int type) {
351       int intSize = (int) size;
352       if ((long) intSize != size || size &lt; 0) {
353           throw new IllegalArgumentException(
354                 &quot;size argument has illegal value &quot; + size);
355       }
356       return allocateCodeBlob( intSize, type);
357   }
358   public native void    freeCodeBlob(long addr);
359   public native void    forceNMethodSweep();
360   public native Object[] getCodeHeapEntries(int type);
361   public native int     getCompilationActivityMode();
362   private native long getMethodData0(Executable method);
363   public         long getMethodData(Executable method) {
364     Objects.requireNonNull(method);
365     return getMethodData0(method);
366   }
367   public native Object[] getCodeBlob(long addr);
368 
369   private native void clearInlineCaches0(boolean preserve_static_stubs);
370   public void clearInlineCaches() {
371     clearInlineCaches0(false);
372   }
373   public void clearInlineCaches(boolean preserve_static_stubs) {
374     clearInlineCaches0(preserve_static_stubs);
375   }
376 
377   // Intered strings
378   public native boolean isInStringTable(String str);
379 
380   // Memory
381   public native void readReservedMemory();
382   public native long allocateMetaspace(ClassLoader classLoader, long size);
383   public native void freeMetaspace(ClassLoader classLoader, long addr, long size);
384   public native long incMetaspaceCapacityUntilGC(long increment);
385   public native long metaspaceCapacityUntilGC();
386   public native boolean metaspaceShouldConcurrentCollect();
387   public native long metaspaceReserveAlignment();
388 
389   // Don&#39;t use these methods directly
390   // Use sun.hotspot.gc.GC class instead.
391   public native boolean isGCSupported(int name);
392   public native boolean isGCSelected(int name);
393   public native boolean isGCSelectedErgonomically();
394 
395   // Force Young GC
396   public native void youngGC();
397 
398   // Force Full GC
399   public native void fullGC();
400 
401   // Returns true if the current GC supports control of its concurrent
402   // phase via requestConcurrentGCPhase().  If false, a request will
403   // always fail.
404   public native boolean supportsConcurrentGCPhaseControl();
405 
406   // Attempt to put the collector into the indicated concurrent phase,
407   // and attempt to remain in that state until a new request is made.
408   //
409   // Returns immediately if already in the requested phase.
410   // Otherwise, waits until the phase is reached.
411   //
412   // Throws IllegalStateException if unsupported by the current collector.
413   // Throws NullPointerException if phase is null.
414   // Throws IllegalArgumentException if phase is not valid for the current collector.
415   public void requestConcurrentGCPhase(String phase) {
416     if (!supportsConcurrentGCPhaseControl()) {
417       throw new IllegalStateException(&quot;Concurrent GC phase control not supported&quot;);
418     } else if (phase == null) {
419       throw new NullPointerException(&quot;null phase&quot;);
420     } else if (!requestConcurrentGCPhase0(phase)) {
421       throw new IllegalArgumentException(&quot;Unknown concurrent GC phase: &quot; + phase);
422     }
423   }
424 
425   // Helper for requestConcurrentGCPhase().  Returns true if request
426   // succeeded, false if the phase is invalid.
427   private native boolean requestConcurrentGCPhase0(String phase);
428 
429   // Method tries to start concurrent mark cycle.
430   // It returns false if CM Thread is always in concurrent cycle.
431   public native boolean g1StartConcMarkCycle();
432 
433   // Tests on ReservedSpace/VirtualSpace classes
434   public native int stressVirtualSpaceResize(long reservedSpaceSize, long magnitude, long iterations);
435   public native void runMemoryUnitTests();
436   public native void readFromNoaccessArea();
437   public native long getThreadStackSize();
438   public native long getThreadRemainingStackSize();
439 
440   // CPU features
441   public native String getCPUFeatures();
442 
443   // VM flags
444   public native boolean isConstantVMFlag(String name);
445   public native boolean isLockedVMFlag(String name);
446   public native void    setBooleanVMFlag(String name, boolean value);
447   public native void    setIntVMFlag(String name, long value);
448   public native void    setUintVMFlag(String name, long value);
449   public native void    setIntxVMFlag(String name, long value);
450   public native void    setUintxVMFlag(String name, long value);
451   public native void    setUint64VMFlag(String name, long value);
452   public native void    setSizeTVMFlag(String name, long value);
453   public native void    setStringVMFlag(String name, String value);
454   public native void    setDoubleVMFlag(String name, double value);
455   public native Boolean getBooleanVMFlag(String name);
456   public native Long    getIntVMFlag(String name);
457   public native Long    getUintVMFlag(String name);
458   public native Long    getIntxVMFlag(String name);
459   public native Long    getUintxVMFlag(String name);
460   public native Long    getUint64VMFlag(String name);
461   public native Long    getSizeTVMFlag(String name);
462   public native String  getStringVMFlag(String name);
463   public native Double  getDoubleVMFlag(String name);
464   private final List&lt;Function&lt;String,Object&gt;&gt; flagsGetters = Arrays.asList(
465     this::getBooleanVMFlag, this::getIntVMFlag, this::getUintVMFlag,
466     this::getIntxVMFlag, this::getUintxVMFlag, this::getUint64VMFlag,
467     this::getSizeTVMFlag, this::getStringVMFlag, this::getDoubleVMFlag);
468 
469   public Object getVMFlag(String name) {
470     return flagsGetters.stream()
471                        .map(f -&gt; f.apply(name))
472                        .filter(x -&gt; x != null)
473                        .findAny()
474                        .orElse(null);
475   }
476 
477   // Jigsaw
478   public native void DefineModule(Object module, boolean is_open, String version,
479                                   String location, Object[] packages);
480   public native void AddModuleExports(Object from_module, String pkg, Object to_module);
481   public native void AddReadsModule(Object from_module, Object source_module);
482   public native void AddModuleExportsToAllUnnamed(Object module, String pkg);
483   public native void AddModuleExportsToAll(Object module, String pkg);
484 
485   public native int getOffsetForName0(String name);
486   public int getOffsetForName(String name) throws Exception {
487     int offset = getOffsetForName0(name);
488     if (offset == -1) {
489       throw new RuntimeException(name + &quot; not found&quot;);
490     }
491     return offset;
492   }
493   public native Boolean getMethodBooleanOption(Executable method, String name);
494   public native Long    getMethodIntxOption(Executable method, String name);
495   public native Long    getMethodUintxOption(Executable method, String name);
496   public native Double  getMethodDoubleOption(Executable method, String name);
497   public native String  getMethodStringOption(Executable method, String name);
498   private final List&lt;BiFunction&lt;Executable,String,Object&gt;&gt; methodOptionGetters
499       = Arrays.asList(this::getMethodBooleanOption, this::getMethodIntxOption,
500           this::getMethodUintxOption, this::getMethodDoubleOption,
501           this::getMethodStringOption);
502 
503   public Object getMethodOption(Executable method, String name) {
504     return methodOptionGetters.stream()
505                               .map(f -&gt; f.apply(method, name))
506                               .filter(x -&gt; x != null)
507                               .findAny()
508                               .orElse(null);
509   }
510 
511   // Safepoint Checking
512   public native void assertMatchingSafepointCalls(boolean mutexSafepointValue, boolean attemptedNoSafepointValue);
513 
514   // Sharing &amp; archiving
515   public native String  getDefaultArchivePath();
516   public native boolean isSharingEnabled();
517   public native boolean isShared(Object o);
518   public native boolean isSharedClass(Class&lt;?&gt; c);
519   public native boolean areSharedStringsIgnored();
520   public native boolean isCDSIncludedInVmBuild();
521   public native boolean isJFRIncludedInVmBuild();
522   public native boolean isJavaHeapArchiveSupported();
523   public native Object  getResolvedReferences(Class&lt;?&gt; c);
524   public native boolean areOpenArchiveHeapObjectsMapped();
525 
526   // Compiler Directive
527   public native int addCompilerDirective(String compDirect);
528   public native void removeCompilerDirective(int count);
529 
530   // Handshakes
531   public native int handshakeWalkStack(Thread t, boolean all_threads);
532 
533   // Returns true on linux if library has the noexecstack flag set.
534   public native boolean checkLibSpecifiesNoexecstack(String libfilename);
535 
536   // Container testing
537   public native boolean isContainerized();
538   public native void printOsInfo();
539 
540   // Decoder
541   public native void disableElfSectionCache();
542 
543   // Resolved Method Table
544   public native int resolvedMethodRemovedCount();
545 
546   // Protection Domain Table
547   public native int protectionDomainRemovedCount();
548 
549   // Number of loaded AOT libraries
550   public native int aotLibrariesCount();
551 }
    </pre>
  </body>
</html>
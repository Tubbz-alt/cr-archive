<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/lib/sun/hotspot/WhiteBox.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../jdk/test/lib/util/FileUtils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="code/Compiler.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/lib/sun/hotspot/WhiteBox.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 82   public native int  getVMPageSize();
 83   public native long getVMAllocationGranularity();
 84   public native long getVMLargePageSize();
 85   public native long getHeapSpaceAlignment();
 86   public native long getHeapAlignment();
 87 
 88   private native boolean isObjectInOldGen0(Object o);
 89   public         boolean isObjectInOldGen(Object o) {
 90     Objects.requireNonNull(o);
 91     return isObjectInOldGen0(o);
 92   }
 93 
 94   private native long getObjectSize0(Object o);
 95   public         long getObjectSize(Object o) {
 96     Objects.requireNonNull(o);
 97     return getObjectSize0(o);
 98   }
 99 
100   // Runtime
101   // Make sure class name is in the correct format





102   public boolean isClassAlive(String name) {
<span class="line-modified">103     return isClassAlive0(name.replace(&#39;.&#39;, &#39;/&#39;));</span>
104   }
<span class="line-modified">105   private native boolean isClassAlive0(String name);</span>
106   public  native int getSymbolRefcount(String name);
107 
108   private native boolean isMonitorInflated0(Object obj);
109   public         boolean isMonitorInflated(Object obj) {
110     Objects.requireNonNull(obj);
111     return isMonitorInflated0(obj);
112   }
113 
114   public native void forceSafepoint();
115 
116   private native long getConstantPool0(Class&lt;?&gt; aClass);
117   public         long getConstantPool(Class&lt;?&gt; aClass) {
118     Objects.requireNonNull(aClass);
119     return getConstantPool0(aClass);
120   }
121 
122   private native int getConstantPoolCacheIndexTag0();
123   public         int getConstantPoolCacheIndexTag() {
124     return getConstantPoolCacheIndexTag0();
125   }
</pre>
<hr />
<pre>
176     if (adr == 0) {
177       throw new IllegalArgumentException(&quot;adr argument should not be null&quot;);
178     }
179     return g1BelongsToFreeRegion0(adr);
180   }
181 
182   public native long    g1NumMaxRegions();
183   public native long    g1NumFreeRegions();
184   public native int     g1RegionSize();
185   public native long    dramReservedStart();
186   public native long    dramReservedEnd();
187   public native long    nvdimmReservedStart();
188   public native long    nvdimmReservedEnd();
189   public native MemoryUsage g1AuxiliaryMemoryUsage();
190   private  native Object[]    parseCommandLine0(String commandline, char delim, DiagnosticCommand[] args);
191   public          Object[]    parseCommandLine(String commandline, char delim, DiagnosticCommand[] args) {
192     Objects.requireNonNull(args);
193     return parseCommandLine0(commandline, delim, args);
194   }
195 



196   // Parallel GC
197   public native long psVirtualSpaceAlignment();
198   public native long psHeapGenerationAlignment();
199 
200   /**
201    * Enumerates old regions with liveness less than specified and produces some statistics
202    * @param liveness percent of region&#39;s liveness (live_objects / total_region_size * 100).
203    * @return long[3] array where long[0] - total count of old regions
204    *                             long[1] - total memory of old regions
205    *                             long[2] - lowest estimation of total memory of old regions to be freed (non-full
206    *                             regions are not included)
207    */
208   public native long[] g1GetMixedGCInfo(int liveness);
209 
210   // NMT
211   public native long NMTMalloc(long size);
212   public native void NMTFree(long mem);
213   public native long NMTReserveMemory(long size);
214   public native long NMTAttemptReserveMemoryAt(long addr, long size);
215   public native void NMTCommitMemory(long addr, long size);
216   public native void NMTUncommitMemory(long addr, long size);
217   public native void NMTReleaseMemory(long addr, long size);
218   public native long NMTMallocWithPseudoStack(long size, int index);
219   public native long NMTMallocWithPseudoStackAndType(long size, int index, int type);
220   public native boolean NMTChangeTrackingLevel();
221   public native int NMTGetHashSize();



222 
223   // Compiler


224   public native int     matchesMethod(Executable method, String pattern);
225   public native int     matchesInline(Executable method, String pattern);
226   public native boolean shouldPrintAssembly(Executable method, int comp_level);
227   public native int     deoptimizeFrames(boolean makeNotEntrant);
228   public native void    deoptimizeAll();
229 
230   public        boolean isMethodCompiled(Executable method) {
231     return isMethodCompiled(method, false /*not osr*/);
232   }
233   private native boolean isMethodCompiled0(Executable method, boolean isOsr);
234   public         boolean isMethodCompiled(Executable method, boolean isOsr){
235     Objects.requireNonNull(method);
236     return isMethodCompiled0(method, isOsr);
237   }
238   public        boolean isMethodCompilable(Executable method) {
239     return isMethodCompilable(method, -2 /*any*/);
240   }
241   public        boolean isMethodCompilable(Executable method, int compLevel) {
242     return isMethodCompilable(method, compLevel, false /*not osr*/);
243   }
</pre>
<hr />
<pre>
313   public native int     getCompileQueueSize(int compLevel);
314   private native boolean testSetForceInlineMethod0(Executable method, boolean value);
315   public         boolean testSetForceInlineMethod(Executable method, boolean value) {
316     Objects.requireNonNull(method);
317     return testSetForceInlineMethod0(method, value);
318   }
319   public        boolean enqueueMethodForCompilation(Executable method, int compLevel) {
320     return enqueueMethodForCompilation(method, compLevel, -1 /*InvocationEntryBci*/);
321   }
322   private native boolean enqueueMethodForCompilation0(Executable method, int compLevel, int entry_bci);
323   public  boolean enqueueMethodForCompilation(Executable method, int compLevel, int entry_bci) {
324     Objects.requireNonNull(method);
325     return enqueueMethodForCompilation0(method, compLevel, entry_bci);
326   }
327   private native boolean enqueueInitializerForCompilation0(Class&lt;?&gt; aClass, int compLevel);
328   public  boolean enqueueInitializerForCompilation(Class&lt;?&gt; aClass, int compLevel) {
329     Objects.requireNonNull(aClass);
330     return enqueueInitializerForCompilation0(aClass, compLevel);
331   }
332   private native void    clearMethodState0(Executable method);

333   public         void    clearMethodState(Executable method) {
334     Objects.requireNonNull(method);
335     clearMethodState0(method);
336   }
337   public native void    lockCompilation();
338   public native void    unlockCompilation();
339   private native int     getMethodEntryBci0(Executable method);
340   public         int     getMethodEntryBci(Executable method) {
341     Objects.requireNonNull(method);
342     return getMethodEntryBci0(method);
343   }
344   private native Object[] getNMethod0(Executable method, boolean isOsr);
345   public         Object[] getNMethod(Executable method, boolean isOsr) {
346     Objects.requireNonNull(method);
347     return getNMethod0(method, isOsr);
348   }
349   public native long    allocateCodeBlob(int size, int type);
350   public        long    allocateCodeBlob(long size, int type) {
351       int intSize = (int) size;
352       if ((long) intSize != size || size &lt; 0) {
</pre>
<hr />
<pre>
366   }
367   public native Object[] getCodeBlob(long addr);
368 
369   private native void clearInlineCaches0(boolean preserve_static_stubs);
370   public void clearInlineCaches() {
371     clearInlineCaches0(false);
372   }
373   public void clearInlineCaches(boolean preserve_static_stubs) {
374     clearInlineCaches0(preserve_static_stubs);
375   }
376 
377   // Intered strings
378   public native boolean isInStringTable(String str);
379 
380   // Memory
381   public native void readReservedMemory();
382   public native long allocateMetaspace(ClassLoader classLoader, long size);
383   public native void freeMetaspace(ClassLoader classLoader, long addr, long size);
384   public native long incMetaspaceCapacityUntilGC(long increment);
385   public native long metaspaceCapacityUntilGC();
<span class="line-removed">386   public native boolean metaspaceShouldConcurrentCollect();</span>
387   public native long metaspaceReserveAlignment();
388 
389   // Don&#39;t use these methods directly
390   // Use sun.hotspot.gc.GC class instead.
391   public native boolean isGCSupported(int name);
392   public native boolean isGCSelected(int name);
393   public native boolean isGCSelectedErgonomically();
394 
395   // Force Young GC
396   public native void youngGC();
397 
398   // Force Full GC
399   public native void fullGC();
400 
401   // Returns true if the current GC supports control of its concurrent
402   // phase via requestConcurrentGCPhase().  If false, a request will
403   // always fail.
404   public native boolean supportsConcurrentGCPhaseControl();
405 
406   // Attempt to put the collector into the indicated concurrent phase,
</pre>
<hr />
<pre>
493   public native Boolean getMethodBooleanOption(Executable method, String name);
494   public native Long    getMethodIntxOption(Executable method, String name);
495   public native Long    getMethodUintxOption(Executable method, String name);
496   public native Double  getMethodDoubleOption(Executable method, String name);
497   public native String  getMethodStringOption(Executable method, String name);
498   private final List&lt;BiFunction&lt;Executable,String,Object&gt;&gt; methodOptionGetters
499       = Arrays.asList(this::getMethodBooleanOption, this::getMethodIntxOption,
500           this::getMethodUintxOption, this::getMethodDoubleOption,
501           this::getMethodStringOption);
502 
503   public Object getMethodOption(Executable method, String name) {
504     return methodOptionGetters.stream()
505                               .map(f -&gt; f.apply(method, name))
506                               .filter(x -&gt; x != null)
507                               .findAny()
508                               .orElse(null);
509   }
510 
511   // Safepoint Checking
512   public native void assertMatchingSafepointCalls(boolean mutexSafepointValue, boolean attemptedNoSafepointValue);

513 
514   // Sharing &amp; archiving
515   public native String  getDefaultArchivePath();

516   public native boolean isSharingEnabled();
517   public native boolean isShared(Object o);
518   public native boolean isSharedClass(Class&lt;?&gt; c);
519   public native boolean areSharedStringsIgnored();
520   public native boolean isCDSIncludedInVmBuild();
521   public native boolean isJFRIncludedInVmBuild();
522   public native boolean isJavaHeapArchiveSupported();
523   public native Object  getResolvedReferences(Class&lt;?&gt; c);

524   public native boolean areOpenArchiveHeapObjectsMapped();
525 
526   // Compiler Directive
527   public native int addCompilerDirective(String compDirect);
528   public native void removeCompilerDirective(int count);
529 
530   // Handshakes
531   public native int handshakeWalkStack(Thread t, boolean all_threads);
532 
533   // Returns true on linux if library has the noexecstack flag set.
534   public native boolean checkLibSpecifiesNoexecstack(String libfilename);
535 
536   // Container testing
537   public native boolean isContainerized();
538   public native void printOsInfo();
539 
540   // Decoder
541   public native void disableElfSectionCache();
542 
543   // Resolved Method Table
<span class="line-modified">544   public native int resolvedMethodRemovedCount();</span>
545 
546   // Protection Domain Table
547   public native int protectionDomainRemovedCount();
548 
549   // Number of loaded AOT libraries
550   public native int aotLibrariesCount();


551 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 82   public native int  getVMPageSize();
 83   public native long getVMAllocationGranularity();
 84   public native long getVMLargePageSize();
 85   public native long getHeapSpaceAlignment();
 86   public native long getHeapAlignment();
 87 
 88   private native boolean isObjectInOldGen0(Object o);
 89   public         boolean isObjectInOldGen(Object o) {
 90     Objects.requireNonNull(o);
 91     return isObjectInOldGen0(o);
 92   }
 93 
 94   private native long getObjectSize0(Object o);
 95   public         long getObjectSize(Object o) {
 96     Objects.requireNonNull(o);
 97     return getObjectSize0(o);
 98   }
 99 
100   // Runtime
101   // Make sure class name is in the correct format
<span class="line-added">102   public int countAliveClasses(String name) {</span>
<span class="line-added">103     return countAliveClasses0(name.replace(&#39;.&#39;, &#39;/&#39;));</span>
<span class="line-added">104   }</span>
<span class="line-added">105   private native int countAliveClasses0(String name);</span>
<span class="line-added">106 </span>
107   public boolean isClassAlive(String name) {
<span class="line-modified">108     return countAliveClasses(name) != 0;</span>
109   }
<span class="line-modified">110 </span>
111   public  native int getSymbolRefcount(String name);
112 
113   private native boolean isMonitorInflated0(Object obj);
114   public         boolean isMonitorInflated(Object obj) {
115     Objects.requireNonNull(obj);
116     return isMonitorInflated0(obj);
117   }
118 
119   public native void forceSafepoint();
120 
121   private native long getConstantPool0(Class&lt;?&gt; aClass);
122   public         long getConstantPool(Class&lt;?&gt; aClass) {
123     Objects.requireNonNull(aClass);
124     return getConstantPool0(aClass);
125   }
126 
127   private native int getConstantPoolCacheIndexTag0();
128   public         int getConstantPoolCacheIndexTag() {
129     return getConstantPoolCacheIndexTag0();
130   }
</pre>
<hr />
<pre>
181     if (adr == 0) {
182       throw new IllegalArgumentException(&quot;adr argument should not be null&quot;);
183     }
184     return g1BelongsToFreeRegion0(adr);
185   }
186 
187   public native long    g1NumMaxRegions();
188   public native long    g1NumFreeRegions();
189   public native int     g1RegionSize();
190   public native long    dramReservedStart();
191   public native long    dramReservedEnd();
192   public native long    nvdimmReservedStart();
193   public native long    nvdimmReservedEnd();
194   public native MemoryUsage g1AuxiliaryMemoryUsage();
195   private  native Object[]    parseCommandLine0(String commandline, char delim, DiagnosticCommand[] args);
196   public          Object[]    parseCommandLine(String commandline, char delim, DiagnosticCommand[] args) {
197     Objects.requireNonNull(args);
198     return parseCommandLine0(commandline, delim, args);
199   }
200 
<span class="line-added">201   public native int g1ActiveMemoryNodeCount();</span>
<span class="line-added">202   public native int[] g1MemoryNodeIds();</span>
<span class="line-added">203 </span>
204   // Parallel GC
205   public native long psVirtualSpaceAlignment();
206   public native long psHeapGenerationAlignment();
207 
208   /**
209    * Enumerates old regions with liveness less than specified and produces some statistics
210    * @param liveness percent of region&#39;s liveness (live_objects / total_region_size * 100).
211    * @return long[3] array where long[0] - total count of old regions
212    *                             long[1] - total memory of old regions
213    *                             long[2] - lowest estimation of total memory of old regions to be freed (non-full
214    *                             regions are not included)
215    */
216   public native long[] g1GetMixedGCInfo(int liveness);
217 
218   // NMT
219   public native long NMTMalloc(long size);
220   public native void NMTFree(long mem);
221   public native long NMTReserveMemory(long size);
222   public native long NMTAttemptReserveMemoryAt(long addr, long size);
223   public native void NMTCommitMemory(long addr, long size);
224   public native void NMTUncommitMemory(long addr, long size);
225   public native void NMTReleaseMemory(long addr, long size);
226   public native long NMTMallocWithPseudoStack(long size, int index);
227   public native long NMTMallocWithPseudoStackAndType(long size, int index, int type);
228   public native boolean NMTChangeTrackingLevel();
229   public native int NMTGetHashSize();
<span class="line-added">230   public native long NMTNewArena(long initSize);</span>
<span class="line-added">231   public native void NMTFreeArena(long arena);</span>
<span class="line-added">232   public native void NMTArenaMalloc(long arena, long size);</span>
233 
234   // Compiler
<span class="line-added">235   public native boolean isC2OrJVMCIIncludedInVmBuild();</span>
<span class="line-added">236 </span>
237   public native int     matchesMethod(Executable method, String pattern);
238   public native int     matchesInline(Executable method, String pattern);
239   public native boolean shouldPrintAssembly(Executable method, int comp_level);
240   public native int     deoptimizeFrames(boolean makeNotEntrant);
241   public native void    deoptimizeAll();
242 
243   public        boolean isMethodCompiled(Executable method) {
244     return isMethodCompiled(method, false /*not osr*/);
245   }
246   private native boolean isMethodCompiled0(Executable method, boolean isOsr);
247   public         boolean isMethodCompiled(Executable method, boolean isOsr){
248     Objects.requireNonNull(method);
249     return isMethodCompiled0(method, isOsr);
250   }
251   public        boolean isMethodCompilable(Executable method) {
252     return isMethodCompilable(method, -2 /*any*/);
253   }
254   public        boolean isMethodCompilable(Executable method, int compLevel) {
255     return isMethodCompilable(method, compLevel, false /*not osr*/);
256   }
</pre>
<hr />
<pre>
326   public native int     getCompileQueueSize(int compLevel);
327   private native boolean testSetForceInlineMethod0(Executable method, boolean value);
328   public         boolean testSetForceInlineMethod(Executable method, boolean value) {
329     Objects.requireNonNull(method);
330     return testSetForceInlineMethod0(method, value);
331   }
332   public        boolean enqueueMethodForCompilation(Executable method, int compLevel) {
333     return enqueueMethodForCompilation(method, compLevel, -1 /*InvocationEntryBci*/);
334   }
335   private native boolean enqueueMethodForCompilation0(Executable method, int compLevel, int entry_bci);
336   public  boolean enqueueMethodForCompilation(Executable method, int compLevel, int entry_bci) {
337     Objects.requireNonNull(method);
338     return enqueueMethodForCompilation0(method, compLevel, entry_bci);
339   }
340   private native boolean enqueueInitializerForCompilation0(Class&lt;?&gt; aClass, int compLevel);
341   public  boolean enqueueInitializerForCompilation(Class&lt;?&gt; aClass, int compLevel) {
342     Objects.requireNonNull(aClass);
343     return enqueueInitializerForCompilation0(aClass, compLevel);
344   }
345   private native void    clearMethodState0(Executable method);
<span class="line-added">346   public  native void    markMethodProfiled(Executable method);</span>
347   public         void    clearMethodState(Executable method) {
348     Objects.requireNonNull(method);
349     clearMethodState0(method);
350   }
351   public native void    lockCompilation();
352   public native void    unlockCompilation();
353   private native int     getMethodEntryBci0(Executable method);
354   public         int     getMethodEntryBci(Executable method) {
355     Objects.requireNonNull(method);
356     return getMethodEntryBci0(method);
357   }
358   private native Object[] getNMethod0(Executable method, boolean isOsr);
359   public         Object[] getNMethod(Executable method, boolean isOsr) {
360     Objects.requireNonNull(method);
361     return getNMethod0(method, isOsr);
362   }
363   public native long    allocateCodeBlob(int size, int type);
364   public        long    allocateCodeBlob(long size, int type) {
365       int intSize = (int) size;
366       if ((long) intSize != size || size &lt; 0) {
</pre>
<hr />
<pre>
380   }
381   public native Object[] getCodeBlob(long addr);
382 
383   private native void clearInlineCaches0(boolean preserve_static_stubs);
384   public void clearInlineCaches() {
385     clearInlineCaches0(false);
386   }
387   public void clearInlineCaches(boolean preserve_static_stubs) {
388     clearInlineCaches0(preserve_static_stubs);
389   }
390 
391   // Intered strings
392   public native boolean isInStringTable(String str);
393 
394   // Memory
395   public native void readReservedMemory();
396   public native long allocateMetaspace(ClassLoader classLoader, long size);
397   public native void freeMetaspace(ClassLoader classLoader, long addr, long size);
398   public native long incMetaspaceCapacityUntilGC(long increment);
399   public native long metaspaceCapacityUntilGC();

400   public native long metaspaceReserveAlignment();
401 
402   // Don&#39;t use these methods directly
403   // Use sun.hotspot.gc.GC class instead.
404   public native boolean isGCSupported(int name);
405   public native boolean isGCSelected(int name);
406   public native boolean isGCSelectedErgonomically();
407 
408   // Force Young GC
409   public native void youngGC();
410 
411   // Force Full GC
412   public native void fullGC();
413 
414   // Returns true if the current GC supports control of its concurrent
415   // phase via requestConcurrentGCPhase().  If false, a request will
416   // always fail.
417   public native boolean supportsConcurrentGCPhaseControl();
418 
419   // Attempt to put the collector into the indicated concurrent phase,
</pre>
<hr />
<pre>
506   public native Boolean getMethodBooleanOption(Executable method, String name);
507   public native Long    getMethodIntxOption(Executable method, String name);
508   public native Long    getMethodUintxOption(Executable method, String name);
509   public native Double  getMethodDoubleOption(Executable method, String name);
510   public native String  getMethodStringOption(Executable method, String name);
511   private final List&lt;BiFunction&lt;Executable,String,Object&gt;&gt; methodOptionGetters
512       = Arrays.asList(this::getMethodBooleanOption, this::getMethodIntxOption,
513           this::getMethodUintxOption, this::getMethodDoubleOption,
514           this::getMethodStringOption);
515 
516   public Object getMethodOption(Executable method, String name) {
517     return methodOptionGetters.stream()
518                               .map(f -&gt; f.apply(method, name))
519                               .filter(x -&gt; x != null)
520                               .findAny()
521                               .orElse(null);
522   }
523 
524   // Safepoint Checking
525   public native void assertMatchingSafepointCalls(boolean mutexSafepointValue, boolean attemptedNoSafepointValue);
<span class="line-added">526   public native void assertSpecialLock(boolean allowVMBlock, boolean safepointCheck);</span>
527 
528   // Sharing &amp; archiving
529   public native String  getDefaultArchivePath();
<span class="line-added">530   public native boolean cdsMemoryMappingFailed();</span>
531   public native boolean isSharingEnabled();
532   public native boolean isShared(Object o);
533   public native boolean isSharedClass(Class&lt;?&gt; c);
534   public native boolean areSharedStringsIgnored();
535   public native boolean isCDSIncludedInVmBuild();
536   public native boolean isJFRIncludedInVmBuild();
537   public native boolean isJavaHeapArchiveSupported();
538   public native Object  getResolvedReferences(Class&lt;?&gt; c);
<span class="line-added">539   public native void    linkClass(Class&lt;?&gt; c);</span>
540   public native boolean areOpenArchiveHeapObjectsMapped();
541 
542   // Compiler Directive
543   public native int addCompilerDirective(String compDirect);
544   public native void removeCompilerDirective(int count);
545 
546   // Handshakes
547   public native int handshakeWalkStack(Thread t, boolean all_threads);
548 
549   // Returns true on linux if library has the noexecstack flag set.
550   public native boolean checkLibSpecifiesNoexecstack(String libfilename);
551 
552   // Container testing
553   public native boolean isContainerized();
554   public native void printOsInfo();
555 
556   // Decoder
557   public native void disableElfSectionCache();
558 
559   // Resolved Method Table
<span class="line-modified">560   public native long resolvedMethodItemsCount();</span>
561 
562   // Protection Domain Table
563   public native int protectionDomainRemovedCount();
564 
565   // Number of loaded AOT libraries
566   public native int aotLibrariesCount();
<span class="line-added">567 </span>
<span class="line-added">568   public native int getKlassMetadataSize(Class&lt;?&gt; c);</span>
569 }
</pre>
</td>
</tr>
</table>
<center><a href="../../jdk/test/lib/util/FileUtils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="code/Compiler.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
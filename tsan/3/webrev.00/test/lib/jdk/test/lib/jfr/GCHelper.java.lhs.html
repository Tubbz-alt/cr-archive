<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/lib/jdk/test/lib/jfr/GCHelper.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.test.lib.jfr;
 26 
 27 import static jdk.test.lib.Asserts.assertEquals;
 28 import static jdk.test.lib.Asserts.assertNotEquals;
 29 import static jdk.test.lib.Asserts.assertNotNull;
 30 import static jdk.test.lib.Asserts.assertNull;
 31 import static jdk.test.lib.Asserts.fail;
 32 
 33 import java.io.FileOutputStream;
 34 import java.io.IOException;
 35 import java.io.PrintStream;
 36 import java.lang.management.GarbageCollectorMXBean;
 37 import java.lang.management.ManagementFactory;
 38 import java.time.Instant;
 39 import java.util.ArrayList;
 40 import java.util.Arrays;
 41 import java.util.Collections;
 42 import java.util.HashMap;
 43 import java.util.HashSet;
 44 import java.util.List;
 45 import java.util.Map;
 46 import java.util.Set;
 47 import java.util.Stack;
 48 
 49 import jdk.jfr.ValueDescriptor;
 50 import jdk.jfr.consumer.RecordedEvent;
 51 
 52 /**
 53  * Mixed helper classes to test GC events.
 54  */
 55 public class GCHelper {
 56     public static final String event_garbage_collection = EventNames.GarbageCollection;
 57     public static final String event_young_garbage_collection = EventNames.YoungGarbageCollection;
 58     public static final String event_old_garbage_collection = EventNames.OldGarbageCollection;
 59     public static final String event_parold_garbage_collection = EventNames.ParallelOldCollection;
 60     public static final String event_g1_garbage_collection = EventNames.G1GarbageCollection;
 61     public static final String event_heap_summary = EventNames.GCHeapSummary;
 62     public static final String event_heap_ps_summary = EventNames.PSHeapSummary;
 63     public static final String event_heap_metaspace_summary = EventNames.MetaspaceSummary;
 64     public static final String event_reference_statistics = EventNames.GCReferenceStatistics;
 65     public static final String event_phases_pause = EventNames.GCPhasePause;
 66     public static final String event_phases_level_1 = EventNames.GCPhasePauseLevel1;
 67     public static final String event_phases_level_2 = EventNames.GCPhasePauseLevel2;
 68     public static final String event_phases_level_3 = EventNames.GCPhasePauseLevel3;
 69 
 70     public static final String gcG1New = &quot;G1New&quot;;
<a name="2" id="anc2"></a><span class="line-removed"> 71     public static final String gcParNew = &quot;ParNew&quot;;</span>
 72     public static final String gcDefNew = &quot;DefNew&quot;;
 73     public static final String gcParallelScavenge = &quot;ParallelScavenge&quot;;
 74     public static final String gcG1Old = &quot;G1Old&quot;;
 75     public static final String gcG1Full = &quot;G1Full&quot;;
<a name="3" id="anc3"></a><span class="line-removed"> 76     public static final String gcConcurrentMarkSweep = &quot;ConcurrentMarkSweep&quot;;</span>
 77     public static final String gcSerialOld = &quot;SerialOld&quot;;
 78     public static final String gcPSMarkSweep = &quot;PSMarkSweep&quot;;
 79     public static final String gcParallelOld = &quot;ParallelOld&quot;;
 80     public static final String pauseLevelEvent = &quot;GCPhasePauseLevel&quot;;
 81 
 82     private static final List&lt;String&gt; g1HeapRegionTypes;
<a name="4" id="anc4"></a>
 83     private static PrintStream defaultErrorLog = null;
 84 
 85     public static int getGcId(RecordedEvent event) {
 86         return Events.assertField(event, &quot;gcId&quot;).getValue();
 87     }
 88 
 89     public static boolean isGcEvent(RecordedEvent event) {
 90         for (ValueDescriptor v : event.getFields()) {
 91             if (&quot;gcId&quot;.equals(v.getName())) {
 92                 return true;
 93             }
 94         }
 95         return false;
 96     }
 97 
 98 //    public static String getEventDesc(RecordedEvent event) {
 99 //      final String path = event.getEventType().getName();
100 //        if (!isGcEvent(event)) {
101 //            return path;
102 //        }
103 //        if (event_garbage_collection.equals(path)) {
104 //            String name = Events.assertField(event, &quot;name&quot;).getValue();
105 //            String cause = Events.assertField(event, &quot;cause&quot;).getValue();
106 //            return String.format(&quot;path=%s, gcId=%d, endTime=%d, name=%s, cause=%s, startTime=%d&quot;,
107 //                    path, getGcId(event), event.getEndTime(), name, cause, event.getStartTime());
108 //        } else {
109 //            return String.format(&quot;path=%s, gcId=%d, endTime=%d&quot;, path, getGcId(event), event.getEndTime());
110 //        }
111 //    }
112 
113     public static RecordedEvent getConfigEvent(List&lt;RecordedEvent&gt; events) throws Exception {
114         for (RecordedEvent event : events) {
115             if (EventNames.GCConfiguration.equals(event.getEventType().getName())) {
116                 return event;
117             }
118         }
119         fail(&quot;Could not find event &quot; + EventNames.GCConfiguration);
120         return null;
121     }
122 
123     public static void callSystemGc(int num, boolean withGarbage) {
124         for (int i = 0; i &lt; num; i++) {
125             if (withGarbage) {
126                 makeGarbage();
127             }
128             System.gc();
129         }
130     }
131 
132     private static void makeGarbage() {
133         Object[] garbage = new Object[1024];
134         for (int i = 0; i &lt; 1024; i++) {
135             garbage[i] = new Object();
136         }
137     }
138 
139     // Removes gcEvents with lowest and highest gcID. This is used to filter out
140     // any incomplete GCs if the recording started/stopped in the middle of a GC.
141     // We also filters out events without gcId. Those events are not needed.
142     public static List&lt;RecordedEvent&gt; removeFirstAndLastGC(List&lt;RecordedEvent&gt; events) {
143         int minGcId = Integer.MAX_VALUE;
144         int maxGcId = Integer.MIN_VALUE;
145         // Find min/max gcId
146         for (RecordedEvent event : events) {
147             if (Events.hasField(event, &quot;gcId&quot;)) {
148                 int gcId = Events.assertField(event, &quot;gcId&quot;).getValue();
149                 minGcId = Math.min(gcId, minGcId);
150                 maxGcId = Math.max(gcId, maxGcId);
151             }
152         }
153 
154         // Add all events except those with gcId = min/max gcId
155         List&lt;RecordedEvent&gt; filteredEvents = new ArrayList&lt;&gt;();
156         for (RecordedEvent event : events) {
157             if (Events.hasField(event, &quot;gcId&quot;)) {
158                 int gcId = Events.assertField(event, &quot;gcId&quot;).getValue();
159                 if (gcId != minGcId &amp;&amp; gcId != maxGcId) {
160                     filteredEvents.add(event);
161                 }
162             }
163         }
164         return filteredEvents;
165     }
166 
167     public static Map&lt;String, Boolean&gt; beanCollectorTypes = new HashMap&lt;&gt;();
168     public static Set&lt;String&gt; collectorOverrides = new HashSet&lt;&gt;();
169     public static Map&lt;String, String[]&gt; requiredEvents = new HashMap&lt;&gt;();
170 
171     static {
172         // young GarbageCollectionMXBeans.
173         beanCollectorTypes.put(&quot;G1 Young Generation&quot;, true);
174         beanCollectorTypes.put(&quot;Copy&quot;, true);
175         beanCollectorTypes.put(&quot;PS Scavenge&quot;, true);
<a name="5" id="anc5"></a><span class="line-removed">176         beanCollectorTypes.put(&quot;ParNew&quot;, true);</span>
177 
178         // old GarbageCollectionMXBeans.
179         beanCollectorTypes.put(&quot;G1 Old Generation&quot;, false);
<a name="6" id="anc6"></a><span class="line-removed">180         beanCollectorTypes.put(&quot;ConcurrentMarkSweep&quot;, false);</span>
181         beanCollectorTypes.put(&quot;PS MarkSweep&quot;, false);
182         beanCollectorTypes.put(&quot;MarkSweepCompact&quot;, false);
183 
184         // List of expected collector overrides. &quot;A.B&quot; means that collector A may use collector B.
185         collectorOverrides.add(&quot;G1Old.G1Full&quot;);
<a name="7" id="anc7"></a><span class="line-removed">186         collectorOverrides.add(&quot;ConcurrentMarkSweep.SerialOld&quot;);</span>
187         collectorOverrides.add(&quot;SerialOld.PSMarkSweep&quot;);
188 
189         requiredEvents.put(gcG1New, new String[] {event_heap_summary, event_young_garbage_collection});
<a name="8" id="anc8"></a><span class="line-removed">190         requiredEvents.put(gcParNew, new String[] {event_heap_summary, event_heap_metaspace_summary, event_phases_pause, event_phases_level_1, event_young_garbage_collection});</span>
191         requiredEvents.put(gcDefNew, new String[] {event_heap_summary, event_heap_metaspace_summary, event_phases_pause, event_phases_level_1, event_young_garbage_collection});
192         requiredEvents.put(gcParallelScavenge, new String[] {event_heap_summary, event_heap_ps_summary, event_heap_metaspace_summary, event_reference_statistics, event_phases_pause, event_phases_level_1, event_young_garbage_collection});
193         requiredEvents.put(gcG1Old, new String[] {event_heap_summary, event_old_garbage_collection});
194         requiredEvents.put(gcG1Full, new String[] {event_heap_summary, event_heap_metaspace_summary, event_phases_pause, event_phases_level_1, event_old_garbage_collection});
<a name="9" id="anc9"></a><span class="line-removed">195         requiredEvents.put(gcConcurrentMarkSweep, new String[] {event_phases_pause, event_phases_level_1, event_old_garbage_collection});</span>
196         requiredEvents.put(gcSerialOld, new String[] {event_heap_summary, event_heap_metaspace_summary, event_phases_pause, event_phases_level_1, event_old_garbage_collection});
197         requiredEvents.put(gcParallelOld, new String[] {event_heap_summary, event_heap_ps_summary, event_heap_metaspace_summary, event_reference_statistics, event_phases_pause, event_phases_level_1, event_old_garbage_collection, event_parold_garbage_collection});
198 
199         String[] g1HeapRegionTypeLiterals = new String[] {
200                                                            &quot;Free&quot;,
201                                                            &quot;Eden&quot;,
202                                                            &quot;Survivor&quot;,
203                                                            &quot;Starts Humongous&quot;,
204                                                            &quot;Continues Humongous&quot;,
205                                                            &quot;Old&quot;,
206                                                            &quot;Archive&quot;
207                                                          };
208 
209         g1HeapRegionTypes = Collections.unmodifiableList(Arrays.asList(g1HeapRegionTypeLiterals));
<a name="10" id="anc10"></a>














210     }
211 
212     /**
213      * Contains all GC events belonging to the same GC (same gcId).
214      */
215     public static class GcBatch {
216         private List&lt;RecordedEvent&gt; events = new ArrayList&lt;&gt;();
217 
218         public int getGcId() {
219             if (events.isEmpty()) {
220                 return -1;
221             }
222             return GCHelper.getGcId(events.get(0));
223         }
224 
225         public String getName() {
226             RecordedEvent endEvent = getEndEvent();
227             String name = endEvent == null ? null : Events.assertField(endEvent, &quot;name&quot;).getValue();
228             return name == null ? &quot;null&quot; : name;
229         }
230 
231         public RecordedEvent getEndEvent() {
232             return getEvent(event_garbage_collection);
233         }
234 
235         public boolean addEvent(RecordedEvent event) {
236             if (!events.isEmpty()) {
237                 assertEquals(getGcId(), GCHelper.getGcId(event), &quot;Wrong gcId in event. Error in test code.&quot;);
238             }
239             boolean isEndEvent = event_garbage_collection.equals(event.getEventType().getName());
240             if (isEndEvent) {
241                 // Verify that we have not already got a garbage_collection event with this gcId.
242                 assertNull(getEndEvent(), String.format(&quot;Multiple %s for gcId %d&quot;, event_garbage_collection, getGcId()));
243             }
244             events.add(event);
245             return isEndEvent;
246         }
247 
248         public boolean isYoungCollection() {
249             boolean isYoung = containsEvent(event_young_garbage_collection);
250             boolean isOld = containsEvent(event_old_garbage_collection);
251             assertNotEquals(isYoung, isOld, &quot;isYoung and isOld was same for batch: &quot; + toString());
252             return isYoung;
253         }
254 
255         public int getEventCount() {
256             return events.size();
257         }
258 
259         public RecordedEvent getEvent(int index) {
260             return events.get(index);
261         }
262 
263         public List&lt;RecordedEvent&gt; getEvents() {
264             return events;
265         }
266 
267         public RecordedEvent getEvent(String eventPath) {
268             for (RecordedEvent event : events) {
269                 if (eventPath.equals(event.getEventType().getName())) {
270                     return event;
271                 }
272             }
273             return null;
274         }
275 
276         public boolean containsEvent(String eventPath) {
277             return getEvent(eventPath) != null;
278         }
279 
280         public String toString() {
281             RecordedEvent endEvent = getEndEvent();
282             Instant startTime = Instant.EPOCH;
283             String cause = &quot;?&quot;;
284             String name = &quot;?&quot;;
285             if (endEvent != null) {
286                 name = getName();
287                 startTime = endEvent.getStartTime();
288                 cause = Events.assertField(endEvent, &quot;cause&quot;).getValue();
289             }
290             return String.format(&quot;GcEvent: gcId=%d, method=%s, cause=%s, startTime=%s&quot;,
291                     getGcId(), name, cause, startTime);
292         }
293 
294         public String getLog() {
295             StringBuilder sb = new StringBuilder();
296             sb.append(this.toString() + System.getProperty(&quot;line.separator&quot;));
297             for (RecordedEvent event : events) {
298                 sb.append(String.format(&quot;event: %s%n&quot;, event));
299             }
300             return sb.toString();
301         }
302 
303         // Group all events info batches.
304         public static List&lt;GcBatch&gt; createFromEvents(List&lt;RecordedEvent&gt; events) throws Exception {
305             Stack&lt;Integer&gt; openGcIds = new Stack&lt;&gt;();
306             List&lt;GcBatch&gt; batches = new ArrayList&lt;&gt;();
307             GcBatch currBatch = null;
308 
309             for (RecordedEvent event : events) {
310                 if (!isGcEvent(event)) {
311                     continue;
312                 }
313                 int gcId = GCHelper.getGcId(event);
314                 if (currBatch == null || currBatch.getGcId() != gcId) {
315                     currBatch = null;
316                     // Search for existing batch
317                     for (GcBatch loopBatch : batches) {
318                         if (gcId == loopBatch.getGcId()) {
319                             currBatch = loopBatch;
320                             break;
321                         }
322                     }
323                     if (currBatch == null) {
324                         // No existing batch. Create new.
325                         currBatch = new GcBatch();
326                         batches.add(currBatch);
327                         openGcIds.push(new Integer(gcId));
328                     }
329                 }
330                 boolean isEndEvent = currBatch.addEvent(event);
331                 if (isEndEvent) {
332                     openGcIds.pop();
333                 }
334             }
335             // Verify that all start_garbage_collection events have received a corresponding &quot;garbage_collection&quot; event.
336             for (GcBatch batch : batches) {
337                 if (batch.getEndEvent() == null) {
338                     System.out.println(batch.getLog());
339                 }
340                 assertNotNull(batch.getEndEvent(), &quot;GcBatch has no end event&quot;);
341             }
342             return batches;
343         }
344     }
345 
346     /**
347      * Contains number of collections and sum pause time for young and old collections.
348      */
349     public static class CollectionSummary {
350         public long collectionCountOld;
351         public long collectionCountYoung;
352         public long collectionTimeOld;
353         public long collectionTimeYoung;
354         private Set&lt;String&gt; names = new HashSet&lt;&gt;();
355 
356         public void add(String collectorName, boolean isYoung, long count, long time) {
357             if (isYoung) {
358                 collectionCountYoung += count;
359                 collectionTimeYoung += time;
360             } else {
361                 collectionCountOld += count;
362                 collectionTimeOld += time;
363             }
364             if (!names.contains(collectorName)) {
365                 names.add(collectorName);
366             }
367         }
368 
369         public long sum() {
370             return collectionCountOld + collectionCountYoung;
371         }
372 
373         public CollectionSummary calcDelta(CollectionSummary prev) {
374             CollectionSummary delta = new CollectionSummary();
375             delta.collectionCountOld = this.collectionCountOld - prev.collectionCountOld;
376             delta.collectionTimeOld = this.collectionTimeOld - prev.collectionTimeOld;
377             delta.collectionCountYoung = this.collectionCountYoung - prev.collectionCountYoung;
378             delta.collectionTimeYoung = this.collectionTimeYoung - prev.collectionTimeYoung;
379             delta.names.addAll(this.names);
380             delta.names.addAll(prev.names);
381             return delta;
382         }
383 
384         public static CollectionSummary createFromMxBeans() {
385             CollectionSummary summary = new CollectionSummary();
386             List&lt;GarbageCollectorMXBean&gt; gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
387             for (int c=0; c&lt;gcBeans.size(); c++) {
388                 GarbageCollectorMXBean currBean = gcBeans.get(c);
389                 Boolean isYoung = beanCollectorTypes.get(currBean.getName());
390                 assertNotNull(isYoung, &quot;Unknown MXBean name: &quot; + currBean.getName());
391                 long collectionTime = currBean.getCollectionTime() * 1000; // Convert from millis to micros.
392                 summary.add(currBean.getName(), isYoung.booleanValue(), currBean.getCollectionCount(), collectionTime);
393             }
394             return summary;
395         }
396 
397         public static CollectionSummary createFromEvents(List&lt;GcBatch&gt; batches) {
398             CollectionSummary summary = new CollectionSummary();
399             for (GcBatch batch : batches) {
400                 RecordedEvent endEvent = batch.getEndEvent();
401                 assertNotNull(endEvent, &quot;No end event in batch with gcId &quot; + batch.getGcId());
402                 String name = batch.getName();
403                 summary.add(name, batch.isYoungCollection(), 1, Events.assertField(endEvent, &quot;sumOfPauses&quot;).getValue());
404             }
405             return summary;
406         }
407 
408         public String toString() {
409             StringBuilder collectorNames = new StringBuilder();
410             for (String s : names) {
411                 if (collectorNames.length() &gt; 0) {
412                     collectorNames.append(&quot;, &quot;);
413                 }
414                 collectorNames.append(s);
415             }
416             return String.format(&quot;CollectionSummary: young.collections=%d, young.time=%d, old.collections=%d, old.time=%d, collectors=(%s)&quot;,
417                     collectionCountYoung, collectionTimeYoung, collectionCountOld, collectionTimeOld, collectorNames);
418         }
419     }
420 
421     public static PrintStream getDefaultErrorLog() {
422         if (defaultErrorLog == null) {
423             try {
424                 defaultErrorLog = new PrintStream(new FileOutputStream(&quot;error.log&quot;, true));
425             } catch (IOException e) {
426                 e.printStackTrace();
427                 defaultErrorLog = System.err;
428             }
429         }
430         return defaultErrorLog;
431     }
432 
433     public static void log(Object msg) {
434         log(msg, System.err);
435         log(msg, getDefaultErrorLog());
436     }
437 
438     public static void log(Object msg, PrintStream ps) {
439         ps.println(msg);
440     }
441 
442     public static boolean isValidG1HeapRegionType(final String type) {
443         return g1HeapRegionTypes.contains(type);
444     }
445 
<a name="11" id="anc11"></a>






446     /**
447      * Helper function to align heap size up.
448      *
449      * @param value
450      * @param alignment
451      * @return aligned value
452      */
453     public static long alignUp(long value, long alignment) {
454         return (value + alignment - 1) &amp; ~(alignment - 1);
455     }
456 
457     /**
458      * Helper function to align heap size down.
459      *
460      * @param value
461      * @param alignment
462      * @return aligned value
463      */
464     public static long alignDown(long value, long alignment) {
465         return value &amp; ~(alignment - 1);
466     }
467 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
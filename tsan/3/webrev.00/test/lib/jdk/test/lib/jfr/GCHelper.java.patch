diff a/test/lib/jdk/test/lib/jfr/GCHelper.java b/test/lib/jdk/test/lib/jfr/GCHelper.java
--- a/test/lib/jdk/test/lib/jfr/GCHelper.java
+++ b/test/lib/jdk/test/lib/jfr/GCHelper.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -66,22 +66,21 @@
     public static final String event_phases_level_1 = EventNames.GCPhasePauseLevel1;
     public static final String event_phases_level_2 = EventNames.GCPhasePauseLevel2;
     public static final String event_phases_level_3 = EventNames.GCPhasePauseLevel3;
 
     public static final String gcG1New = "G1New";
-    public static final String gcParNew = "ParNew";
     public static final String gcDefNew = "DefNew";
     public static final String gcParallelScavenge = "ParallelScavenge";
     public static final String gcG1Old = "G1Old";
     public static final String gcG1Full = "G1Full";
-    public static final String gcConcurrentMarkSweep = "ConcurrentMarkSweep";
     public static final String gcSerialOld = "SerialOld";
     public static final String gcPSMarkSweep = "PSMarkSweep";
     public static final String gcParallelOld = "ParallelOld";
     public static final String pauseLevelEvent = "GCPhasePauseLevel";
 
     private static final List<String> g1HeapRegionTypes;
+    private static final List<String> shenandoahHeapRegionStates;
     private static PrintStream defaultErrorLog = null;
 
     public static int getGcId(RecordedEvent event) {
         return Events.assertField(event, "gcId").getValue();
     }
@@ -171,30 +170,25 @@
     static {
         // young GarbageCollectionMXBeans.
         beanCollectorTypes.put("G1 Young Generation", true);
         beanCollectorTypes.put("Copy", true);
         beanCollectorTypes.put("PS Scavenge", true);
-        beanCollectorTypes.put("ParNew", true);
 
         // old GarbageCollectionMXBeans.
         beanCollectorTypes.put("G1 Old Generation", false);
-        beanCollectorTypes.put("ConcurrentMarkSweep", false);
         beanCollectorTypes.put("PS MarkSweep", false);
         beanCollectorTypes.put("MarkSweepCompact", false);
 
         // List of expected collector overrides. "A.B" means that collector A may use collector B.
         collectorOverrides.add("G1Old.G1Full");
-        collectorOverrides.add("ConcurrentMarkSweep.SerialOld");
         collectorOverrides.add("SerialOld.PSMarkSweep");
 
         requiredEvents.put(gcG1New, new String[] {event_heap_summary, event_young_garbage_collection});
-        requiredEvents.put(gcParNew, new String[] {event_heap_summary, event_heap_metaspace_summary, event_phases_pause, event_phases_level_1, event_young_garbage_collection});
         requiredEvents.put(gcDefNew, new String[] {event_heap_summary, event_heap_metaspace_summary, event_phases_pause, event_phases_level_1, event_young_garbage_collection});
         requiredEvents.put(gcParallelScavenge, new String[] {event_heap_summary, event_heap_ps_summary, event_heap_metaspace_summary, event_reference_statistics, event_phases_pause, event_phases_level_1, event_young_garbage_collection});
         requiredEvents.put(gcG1Old, new String[] {event_heap_summary, event_old_garbage_collection});
         requiredEvents.put(gcG1Full, new String[] {event_heap_summary, event_heap_metaspace_summary, event_phases_pause, event_phases_level_1, event_old_garbage_collection});
-        requiredEvents.put(gcConcurrentMarkSweep, new String[] {event_phases_pause, event_phases_level_1, event_old_garbage_collection});
         requiredEvents.put(gcSerialOld, new String[] {event_heap_summary, event_heap_metaspace_summary, event_phases_pause, event_phases_level_1, event_old_garbage_collection});
         requiredEvents.put(gcParallelOld, new String[] {event_heap_summary, event_heap_ps_summary, event_heap_metaspace_summary, event_reference_statistics, event_phases_pause, event_phases_level_1, event_old_garbage_collection, event_parold_garbage_collection});
 
         String[] g1HeapRegionTypeLiterals = new String[] {
                                                            "Free",
@@ -205,10 +199,25 @@
                                                            "Old",
                                                            "Archive"
                                                          };
 
         g1HeapRegionTypes = Collections.unmodifiableList(Arrays.asList(g1HeapRegionTypeLiterals));
+
+        String[] shenandoahHeapRegionStateLiterals = new String[] {
+                                                                    "Empty Uncommitted",
+                                                                    "Empty Committed",
+                                                                    "Regular",
+                                                                    "Humongous Start",
+                                                                    "Humongous Continuation",
+                                                                    "Humongous Start, Pinned",
+                                                                    "Collection Set",
+                                                                    "Pinned",
+                                                                    "Collection Set, Pinned",
+                                                                    "Trash"
+        };
+
+        shenandoahHeapRegionStates = Collections.unmodifiableList(Arrays.asList(shenandoahHeapRegionStateLiterals));
     }
 
     /**
      * Contains all GC events belonging to the same GC (same gcId).
      */
@@ -441,10 +450,17 @@
 
     public static boolean isValidG1HeapRegionType(final String type) {
         return g1HeapRegionTypes.contains(type);
     }
 
+    public static boolean assertIsValidShenandoahHeapRegionState(final String state) {
+        if (!shenandoahHeapRegionStates.contains(state)) {
+            throw new AssertionError("Unknown state '" + state + "', valid heap region states are " + shenandoahHeapRegionStates);
+        }
+        return true;
+    }
+
     /**
      * Helper function to align heap size up.
      *
      * @param value
      * @param alignment

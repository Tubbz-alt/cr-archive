<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/lib/jdk/test/lib/process/ProcessTools.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="OutputBuffer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StreamPumper.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/lib/jdk/test/lib/process/ProcessTools.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.process;
 25 

 26 import java.io.IOException;
 27 import java.io.InputStream;
 28 import java.io.OutputStream;
 29 import java.io.PrintStream;


 30 import java.util.ArrayList;
 31 import java.util.Arrays;
 32 import java.util.Collections;
 33 import java.util.concurrent.CountDownLatch;
 34 import java.util.Map;
 35 import java.util.concurrent.ExecutionException;
 36 import java.util.concurrent.Future;
 37 import java.util.concurrent.TimeUnit;
 38 import java.util.concurrent.TimeoutException;
 39 import java.util.function.Predicate;
 40 import java.util.function.Consumer;
 41 import java.util.stream.Collectors;
 42 import java.security.AccessController;
 43 import java.security.PrivilegedActionException;
 44 import java.security.PrivilegedExceptionAction;
 45 
 46 import jdk.test.lib.JDKToolFinder;

 47 import jdk.test.lib.Utils;
 48 
 49 public final class ProcessTools {
 50     private static final class LineForwarder extends StreamPumper.LinePump {
 51         private final PrintStream ps;
 52         private final String prefix;
 53         LineForwarder(String prefix, PrintStream os) {
 54             this.ps = os;
 55             this.prefix = prefix;
 56         }
 57         @Override
 58         protected void processLine(String line) {
 59             ps.println(&quot;[&quot; + prefix + &quot;] &quot; + line);
 60         }
 61     }
 62 
 63     private ProcessTools() {
 64     }
 65 
 66     /**
</pre>
<hr />
<pre>
342 
343     /**
344      * Executes a process, waits for it to finish and returns the process output.
345      * The process will have exited before this method returns.
346      * @param pb The ProcessBuilder to execute.
347      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
348      */
349     public static OutputAnalyzer executeProcess(ProcessBuilder pb) throws Exception {
350         return executeProcess(pb, null);
351     }
352 
353     /**
354      * Executes a process, pipe some text into its STDIN, waits for it
355      * to finish and returns the process output. The process will have exited
356      * before this method returns.
357      * @param pb The ProcessBuilder to execute.
358      * @param input The text to pipe into STDIN. Can be null.
359      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
360      */
361     public static OutputAnalyzer executeProcess(ProcessBuilder pb, String input) throws Exception {















362         OutputAnalyzer output = null;
363         Process p = null;
364         boolean failed = false;
365         try {
366             p = privilegedStart(pb);
367             if (input != null) {
368                try (PrintStream ps = new PrintStream(p.getOutputStream())) {
369                    ps.print(input);
370                }
371             }
372 
<span class="line-modified">373             output = new OutputAnalyzer(p);</span>
374             p.waitFor();
375 
376             return output;
377         } catch (Throwable t) {
378             if (p != null) {
379                 p.destroyForcibly().waitFor();
380             }
381 
382             failed = true;
383             System.out.println(&quot;executeProcess() failed: &quot; + t);
384             throw t;
385         } finally {
386             if (failed) {
387                 System.err.println(getProcessLog(pb, output));
388             }
389         }
390     }
391 
392     /**
393      * Executes a process, waits for it to finish and returns the process output.
</pre>
<hr />
<pre>
457      * Executes a process, waits for it to finish, prints the process output
458      * to stdout and returns the process output.
459      *
460      * The process will have exited before this method returns.
461      *
462      * @param pb The ProcessBuilder to execute.
463      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
464      */
465     public static OutputAnalyzer executeCommand(ProcessBuilder pb)
466             throws Throwable {
467         String cmdLine = pb.command().stream()
468                 .map(x -&gt; (x.contains(&quot; &quot;) || x.contains(&quot;$&quot;))
469                         ? (&quot;&#39;&quot; + x + &quot;&#39;&quot;) : x)
470                 .collect(Collectors.joining(&quot; &quot;));
471         System.out.println(&quot;Command line: [&quot; + cmdLine + &quot;]&quot;);
472         OutputAnalyzer analyzer = ProcessTools.executeProcess(pb);
473         System.out.println(analyzer.getOutput());
474         return analyzer;
475     }
476 










































477     private static Process privilegedStart(ProcessBuilder pb) throws IOException {
478         try {
479             return AccessController.doPrivileged(
480                 (PrivilegedExceptionAction&lt;Process&gt;) () -&gt; pb.start());
481         } catch (PrivilegedActionException e) {
<span class="line-removed">482             @SuppressWarnings(&quot;unchecked&quot;)</span>
483             IOException t = (IOException) e.getException();
484             throw t;
485         }
486     }
487 
488     private static class ProcessImpl extends Process {
489 
490         private final Process p;
491         private final Future&lt;Void&gt; stdoutTask;
492         private final Future&lt;Void&gt; stderrTask;
493 
494         public ProcessImpl(Process p, Future&lt;Void&gt; stdoutTask, Future&lt;Void&gt; stderrTask) {
495             this.p = p;
496             this.stdoutTask = stdoutTask;
497             this.stderrTask = stderrTask;
498         }
499 
500         @Override
501         public OutputStream getOutputStream() {
502             return p.getOutputStream();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.process;
 25 
<span class="line-added"> 26 import java.io.File;</span>
 27 import java.io.IOException;
 28 import java.io.InputStream;
 29 import java.io.OutputStream;
 30 import java.io.PrintStream;
<span class="line-added"> 31 import java.nio.charset.Charset;</span>
<span class="line-added"> 32 import java.nio.file.Paths;</span>
 33 import java.util.ArrayList;
 34 import java.util.Arrays;
 35 import java.util.Collections;
 36 import java.util.concurrent.CountDownLatch;
 37 import java.util.Map;
 38 import java.util.concurrent.ExecutionException;
 39 import java.util.concurrent.Future;
 40 import java.util.concurrent.TimeUnit;
 41 import java.util.concurrent.TimeoutException;
 42 import java.util.function.Predicate;
 43 import java.util.function.Consumer;
 44 import java.util.stream.Collectors;
 45 import java.security.AccessController;
 46 import java.security.PrivilegedActionException;
 47 import java.security.PrivilegedExceptionAction;
 48 
 49 import jdk.test.lib.JDKToolFinder;
<span class="line-added"> 50 import jdk.test.lib.Platform;</span>
 51 import jdk.test.lib.Utils;
 52 
 53 public final class ProcessTools {
 54     private static final class LineForwarder extends StreamPumper.LinePump {
 55         private final PrintStream ps;
 56         private final String prefix;
 57         LineForwarder(String prefix, PrintStream os) {
 58             this.ps = os;
 59             this.prefix = prefix;
 60         }
 61         @Override
 62         protected void processLine(String line) {
 63             ps.println(&quot;[&quot; + prefix + &quot;] &quot; + line);
 64         }
 65     }
 66 
 67     private ProcessTools() {
 68     }
 69 
 70     /**
</pre>
<hr />
<pre>
346 
347     /**
348      * Executes a process, waits for it to finish and returns the process output.
349      * The process will have exited before this method returns.
350      * @param pb The ProcessBuilder to execute.
351      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
352      */
353     public static OutputAnalyzer executeProcess(ProcessBuilder pb) throws Exception {
354         return executeProcess(pb, null);
355     }
356 
357     /**
358      * Executes a process, pipe some text into its STDIN, waits for it
359      * to finish and returns the process output. The process will have exited
360      * before this method returns.
361      * @param pb The ProcessBuilder to execute.
362      * @param input The text to pipe into STDIN. Can be null.
363      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
364      */
365     public static OutputAnalyzer executeProcess(ProcessBuilder pb, String input) throws Exception {
<span class="line-added">366         return executeProcess(pb, input, null);</span>
<span class="line-added">367     }</span>
<span class="line-added">368 </span>
<span class="line-added">369     /**</span>
<span class="line-added">370      * Executes a process, pipe some text into its STDIN, waits for it</span>
<span class="line-added">371      * to finish and returns the process output. The process will have exited</span>
<span class="line-added">372      * before this method returns.</span>
<span class="line-added">373      * @param pb The ProcessBuilder to execute.</span>
<span class="line-added">374      * @param input The text to pipe into STDIN. Can be null.</span>
<span class="line-added">375      * @param cs The charset used to convert from bytes to chars or null for</span>
<span class="line-added">376      *           the default charset.</span>
<span class="line-added">377      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.</span>
<span class="line-added">378      */</span>
<span class="line-added">379     public static OutputAnalyzer executeProcess(ProcessBuilder pb, String input,</span>
<span class="line-added">380             Charset cs) throws Exception {</span>
381         OutputAnalyzer output = null;
382         Process p = null;
383         boolean failed = false;
384         try {
385             p = privilegedStart(pb);
386             if (input != null) {
387                try (PrintStream ps = new PrintStream(p.getOutputStream())) {
388                    ps.print(input);
389                }
390             }
391 
<span class="line-modified">392             output = new OutputAnalyzer(p, cs);</span>
393             p.waitFor();
394 
395             return output;
396         } catch (Throwable t) {
397             if (p != null) {
398                 p.destroyForcibly().waitFor();
399             }
400 
401             failed = true;
402             System.out.println(&quot;executeProcess() failed: &quot; + t);
403             throw t;
404         } finally {
405             if (failed) {
406                 System.err.println(getProcessLog(pb, output));
407             }
408         }
409     }
410 
411     /**
412      * Executes a process, waits for it to finish and returns the process output.
</pre>
<hr />
<pre>
476      * Executes a process, waits for it to finish, prints the process output
477      * to stdout and returns the process output.
478      *
479      * The process will have exited before this method returns.
480      *
481      * @param pb The ProcessBuilder to execute.
482      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
483      */
484     public static OutputAnalyzer executeCommand(ProcessBuilder pb)
485             throws Throwable {
486         String cmdLine = pb.command().stream()
487                 .map(x -&gt; (x.contains(&quot; &quot;) || x.contains(&quot;$&quot;))
488                         ? (&quot;&#39;&quot; + x + &quot;&#39;&quot;) : x)
489                 .collect(Collectors.joining(&quot; &quot;));
490         System.out.println(&quot;Command line: [&quot; + cmdLine + &quot;]&quot;);
491         OutputAnalyzer analyzer = ProcessTools.executeProcess(pb);
492         System.out.println(analyzer.getOutput());
493         return analyzer;
494     }
495 
<span class="line-added">496     /**</span>
<span class="line-added">497      * Helper method to create a process builder for launching native executable</span>
<span class="line-added">498      * test that uses/loads JVM.</span>
<span class="line-added">499      *</span>
<span class="line-added">500      * @param executableName The name of an executable to be launched.</span>
<span class="line-added">501      * @param args Arguments for the executable.</span>
<span class="line-added">502      * @return New ProcessBuilder instance representing the command.</span>
<span class="line-added">503      */</span>
<span class="line-added">504     public static ProcessBuilder createNativeTestProcessBuilder(String executableName,</span>
<span class="line-added">505                                                                 String... args) throws Exception {</span>
<span class="line-added">506         executableName = Platform.isWindows() ? executableName + &quot;.exe&quot; : executableName;</span>
<span class="line-added">507         String executable = Paths.get(System.getProperty(&quot;test.nativepath&quot;), executableName)</span>
<span class="line-added">508             .toAbsolutePath()</span>
<span class="line-added">509             .toString();</span>
<span class="line-added">510 </span>
<span class="line-added">511         ProcessBuilder pb = new ProcessBuilder(executable);</span>
<span class="line-added">512         pb.command().addAll(Arrays.asList(args));</span>
<span class="line-added">513         addJvmLib(pb);</span>
<span class="line-added">514         return pb;</span>
<span class="line-added">515     }</span>
<span class="line-added">516 </span>
<span class="line-added">517     /**</span>
<span class="line-added">518      * Adds JVM library path to the native library path.</span>
<span class="line-added">519      *</span>
<span class="line-added">520      * @param pb ProcessBuilder to be updated with JVM library path.</span>
<span class="line-added">521      * @return pb Update ProcessBuilder instance.</span>
<span class="line-added">522      */</span>
<span class="line-added">523     public static ProcessBuilder addJvmLib(ProcessBuilder pb) throws Exception {</span>
<span class="line-added">524         String jvmLibDir = Platform.jvmLibDir().toString();</span>
<span class="line-added">525         String libPathVar = Platform.sharedLibraryPathVariableName();</span>
<span class="line-added">526         String currentLibPath = pb.environment().get(libPathVar);</span>
<span class="line-added">527 </span>
<span class="line-added">528         String newLibPath = jvmLibDir;</span>
<span class="line-added">529         if ( (currentLibPath != null) &amp;&amp; !currentLibPath.isEmpty() ) {</span>
<span class="line-added">530             newLibPath = currentLibPath + File.pathSeparator + jvmLibDir;</span>
<span class="line-added">531         }</span>
<span class="line-added">532 </span>
<span class="line-added">533         pb.environment().put(libPathVar, newLibPath);</span>
<span class="line-added">534 </span>
<span class="line-added">535         return pb;</span>
<span class="line-added">536     }</span>
<span class="line-added">537 </span>
538     private static Process privilegedStart(ProcessBuilder pb) throws IOException {
539         try {
540             return AccessController.doPrivileged(
541                 (PrivilegedExceptionAction&lt;Process&gt;) () -&gt; pb.start());
542         } catch (PrivilegedActionException e) {

543             IOException t = (IOException) e.getException();
544             throw t;
545         }
546     }
547 
548     private static class ProcessImpl extends Process {
549 
550         private final Process p;
551         private final Future&lt;Void&gt; stdoutTask;
552         private final Future&lt;Void&gt; stderrTask;
553 
554         public ProcessImpl(Process p, Future&lt;Void&gt; stdoutTask, Future&lt;Void&gt; stderrTask) {
555             this.p = p;
556             this.stdoutTask = stdoutTask;
557             this.stderrTask = stderrTask;
558         }
559 
560         @Override
561         public OutputStream getOutputStream() {
562             return p.getOutputStream();
</pre>
</td>
</tr>
</table>
<center><a href="OutputBuffer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StreamPumper.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
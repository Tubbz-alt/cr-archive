<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/lib/jdk/test/lib/util/FileUtils.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.util;
 25 
 26 import jdk.test.lib.Platform;
 27 
 28 import java.io.IOException;
 29 import java.io.PrintStream;
 30 import java.io.UncheckedIOException;
 31 import java.lang.ProcessBuilder.Redirect;
 32 import java.nio.file.DirectoryNotEmptyException;
 33 import java.nio.file.FileVisitResult;
 34 import java.nio.file.Files;
 35 import java.nio.file.NoSuchFileException;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.nio.file.SimpleFileVisitor;
 39 import java.nio.file.attribute.BasicFileAttributes;
 40 import java.time.Instant;
 41 import java.time.Duration;
 42 import java.util.Arrays;
 43 import java.util.ArrayList;
 44 import java.util.ArrayDeque;
 45 import java.util.HashSet;
 46 import java.util.List;
 47 import java.util.Optional;
 48 import java.util.concurrent.TimeUnit;
 49 
 50 /**
 51  * Common library for various test file utility functions.
 52  */
 53 public final class FileUtils {
 54     private static final boolean IS_WINDOWS = Platform.isWindows();
 55     private static final int RETRY_DELETE_MILLIS = IS_WINDOWS ? 500 : 0;
 56     private static final int MAX_RETRY_DELETE_TIMES = IS_WINDOWS ? 15 : 0;
 57 
 58     /**
 59      * Deletes a file, retrying if necessary.
 60      *
 61      * @param path  the file to delete
 62      *
 63      * @throws NoSuchFileException
 64      *         if the file does not exist (optional specific exception)
 65      * @throws DirectoryNotEmptyException
 66      *         if the file is a directory and could not otherwise be deleted
 67      *         because the directory is not empty (optional specific exception)
 68      * @throws IOException
 69      *         if an I/O error occurs
 70      */
 71     public static void deleteFileWithRetry(Path path) throws IOException {
 72         try {
 73             deleteFileWithRetry0(path);
 74         } catch (InterruptedException x) {
 75             throw new IOException(&quot;Interrupted while deleting.&quot;, x);
 76         }
 77     }
 78 
 79     /**
 80      * Deletes a file, retrying if necessary.
 81      * No exception thrown if file doesn&#39;t exist.
 82      *
 83      * @param path  the file to delete
 84      *
 85      * @throws NoSuchFileException
 86      *         if the file does not exist (optional specific exception)
 87      * @throws DirectoryNotEmptyException
 88      *         if the file is a directory and could not otherwise be deleted
 89      *         because the directory is not empty (optional specific exception)
 90      * @throws IOException
 91      *         if an I/O error occurs
 92      */
 93     public static void deleteFileIfExistsWithRetry(Path path) throws IOException {
 94         try {
 95             if (Files.exists(path)) {
 96                 deleteFileWithRetry0(path);
 97             }
 98         } catch (InterruptedException x) {
 99             throw new IOException(&quot;Interrupted while deleting.&quot;, x);
100         }
101     }
102 
103     private static void deleteFileWithRetry0(Path path)
104             throws IOException, InterruptedException {
105         int times = 0;
106         IOException ioe = null;
107         while (true) {
108             try {
109                 Files.delete(path);
110                 // Checks for absence of the file. Semantics of Files.exists() is not the same.
111                 while (!Files.notExists(path)) {
112                     times++;
113                     if (times &gt; MAX_RETRY_DELETE_TIMES) {
114                         throw new IOException(&quot;File still exists after &quot; + times + &quot; waits.&quot;);
115                     }
116                     Thread.sleep(RETRY_DELETE_MILLIS);
117                 }
118                 break;
119             } catch (NoSuchFileException | DirectoryNotEmptyException x) {
120                 throw x;
121             } catch (IOException x) {
122                 // Backoff/retry in case another process is accessing the file
123                 times++;
124                 if (ioe == null) {
125                     ioe = x;
126                 } else {
127                     ioe.addSuppressed(x);
128                 }
129 
130                 if (times &gt; MAX_RETRY_DELETE_TIMES) {
131                     throw ioe;
132                 }
133                 Thread.sleep(RETRY_DELETE_MILLIS);
134             }
135         }
136     }
137 
138     /**
139      * Deletes a directory and its subdirectories, retrying if necessary.
140      *
141      * @param dir  the directory to delete
142      *
143      * @throws  IOException
144      *          If an I/O error occurs. Any such exceptions are caught
145      *          internally. If only one is caught, then it is re-thrown.
146      *          If more than one exception is caught, then the second and
147      *          following exceptions are added as suppressed exceptions of the
148      *          first one caught, which is then re-thrown.
149      */
150     public static void deleteFileTreeWithRetry(Path dir) throws IOException {
151         IOException ioe = null;
152         final List&lt;IOException&gt; excs = deleteFileTreeUnchecked(dir);
153         if (!excs.isEmpty()) {
154             ioe = excs.remove(0);
155             for (IOException x : excs) {
156                 ioe.addSuppressed(x);
157             }
158         }
159         if (ioe != null) {
160             throw ioe;
161         }
162     }
163 
164     public static List&lt;IOException&gt; deleteFileTreeUnchecked(Path dir) {
165         final List&lt;IOException&gt; excs = new ArrayList&lt;&gt;();
166         try {
167             java.nio.file.Files.walkFileTree(dir, new SimpleFileVisitor&lt;&gt;() {
168                 @Override
169                 public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
170                     try {
171                         deleteFileWithRetry0(file);
172                     } catch (IOException x) {
173                         excs.add(x);
174                     } catch (InterruptedException x) {
175                         excs.add(new IOException(&quot;Interrupted while deleting.&quot;, x));
176                         return FileVisitResult.TERMINATE;
177                     }
178                     return FileVisitResult.CONTINUE;
179                 }
180                 @Override
181                 public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
182                     try {
183                         deleteFileWithRetry0(dir);
184                     } catch (IOException x) {
185                         excs.add(x);
186                     } catch (InterruptedException x) {
187                         excs.add(new IOException(&quot;Interrupted while deleting.&quot;, x));
188                         return FileVisitResult.TERMINATE;
189                     }
190                     return FileVisitResult.CONTINUE;
191                 }
192                 @Override
193                 public FileVisitResult visitFileFailed(Path file, IOException exc) {
194                     excs.add(exc);
195                     return FileVisitResult.CONTINUE;
196                 }
197             });
198         } catch (IOException x) {
199             excs.add(x);
200         }
201         return excs;
202     }
203 
204     /**
205      * Checks whether all file systems are accessible. This is performed
206      * by checking free disk space on all mounted file systems via a
207      * separate, spawned process. File systems are considered to be
208      * accessible if this process completes successfully before a given
209      * fixed duration has elapsed.
210      *
211      * @implNote On Unix this executes the {@code df} command in a separate
212      * process and on Windows always returns {@code true}.
213      */
214     public static boolean areFileSystemsAccessible() throws IOException {
215         boolean areFileSystemsAccessible = true;
216         if (!IS_WINDOWS) {
217             // try to check whether &#39;df&#39; hangs
218             System.out.println(&quot;\n--- df output ---&quot;);
219             System.out.flush();
220             Process proc = new ProcessBuilder(&quot;df&quot;).inheritIO().start();
221             try {
222                 proc.waitFor(90, TimeUnit.SECONDS);
223             } catch (InterruptedException ignored) {
224             }
225             try {
226                 int exitValue = proc.exitValue();
227                 if (exitValue != 0) {
228                     System.err.printf(&quot;df process exited with %d != 0%n&quot;,
229                         exitValue);
230                     areFileSystemsAccessible = false;
231                 }
232             } catch (IllegalThreadStateException ignored) {
233                 System.err.println(&quot;df command apparently hung&quot;);
234                 areFileSystemsAccessible = false;
235             }
236         }
237         return areFileSystemsAccessible;
238     }
239 
240     /**
241      * List the open file descriptors (if supported by the &#39;lsof&#39; command).
242      * @param ps a printStream to send the output to
243      * @throws UncheckedIOException if an error occurs
244      */
245     public static void listFileDescriptors(PrintStream ps) {
246 
247         Optional&lt;String[]&gt; lsof = Arrays.stream(lsCommands)
248                 .filter(args -&gt; Files.isExecutable(Path.of(args[0])))
249                 .findFirst();
250         lsof.ifPresent(args -&gt; {
251             try {
252                 ps.printf(&quot;Open File Descriptors:%n&quot;);
253                 long pid = ProcessHandle.current().pid();
254                 ProcessBuilder pb = new ProcessBuilder(args[0], args[1], Integer.toString((int) pid));
255                 pb.redirectErrorStream(true);   // combine stderr and stdout
256                 pb.redirectOutput(Redirect.PIPE);
257 
258                 Process p = pb.start();
259                 Instant start = Instant.now();
260                 p.getInputStream().transferTo(ps);
261 
262                 try {
263                     int timeout = 10;
264                     if (!p.waitFor(timeout, TimeUnit.SECONDS)) {
265                         System.out.printf(&quot;waitFor timed out: %d%n&quot;, timeout);
266                     }
267                 } catch (InterruptedException ie) {
268                     throw new IOException(&quot;interrupted&quot;, ie);
269                 }
270                 ps.println();
271             } catch (IOException ioe) {
272                 throw new UncheckedIOException(&quot;error listing file descriptors&quot;, ioe);
273             }
274         });
275     }
276 
277     // Possible command locations and arguments
278     static String[][] lsCommands = new String[][] {
279             {&quot;/usr/bin/lsof&quot;, &quot;-p&quot;},
280             {&quot;/usr/sbin/lsof&quot;, &quot;-p&quot;},
281             {&quot;/bin/lsof&quot;, &quot;-p&quot;},
282             {&quot;/sbin/lsof&quot;, &quot;-p&quot;},
283             {&quot;/usr/local/bin/lsof&quot;, &quot;-p&quot;},
284             {&quot;/usr/bin/pfiles&quot;, &quot;-F&quot;},   // Solaris
285     };
286 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/lib/jdk/test/lib/util/FileUtils.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../security/JDKSecurityProperties.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../sun/hotspot/WhiteBox.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/lib/jdk/test/lib/util/FileUtils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.util;
 25 
 26 import jdk.test.lib.Platform;
 27 


 28 import java.io.IOException;
 29 import java.io.PrintStream;
 30 import java.io.UncheckedIOException;
 31 import java.lang.ProcessBuilder.Redirect;
 32 import java.nio.file.DirectoryNotEmptyException;
 33 import java.nio.file.FileVisitResult;
 34 import java.nio.file.Files;
 35 import java.nio.file.NoSuchFileException;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.nio.file.SimpleFileVisitor;
 39 import java.nio.file.attribute.BasicFileAttributes;
 40 import java.time.Instant;
 41 import java.time.Duration;
 42 import java.util.Arrays;
 43 import java.util.ArrayList;
 44 import java.util.ArrayDeque;
 45 import java.util.HashSet;
 46 import java.util.List;
 47 import java.util.Optional;



 48 import java.util.concurrent.TimeUnit;
 49 
 50 /**
 51  * Common library for various test file utility functions.
 52  */
 53 public final class FileUtils {
 54     private static final boolean IS_WINDOWS = Platform.isWindows();
 55     private static final int RETRY_DELETE_MILLIS = IS_WINDOWS ? 500 : 0;
 56     private static final int MAX_RETRY_DELETE_TIMES = IS_WINDOWS ? 15 : 0;
 57 
 58     /**
 59      * Deletes a file, retrying if necessary.
 60      *
 61      * @param path  the file to delete
 62      *
 63      * @throws NoSuchFileException
 64      *         if the file does not exist (optional specific exception)
 65      * @throws DirectoryNotEmptyException
 66      *         if the file is a directory and could not otherwise be deleted
 67      *         because the directory is not empty (optional specific exception)
</pre>
<hr />
<pre>
 75             throw new IOException(&quot;Interrupted while deleting.&quot;, x);
 76         }
 77     }
 78 
 79     /**
 80      * Deletes a file, retrying if necessary.
 81      * No exception thrown if file doesn&#39;t exist.
 82      *
 83      * @param path  the file to delete
 84      *
 85      * @throws NoSuchFileException
 86      *         if the file does not exist (optional specific exception)
 87      * @throws DirectoryNotEmptyException
 88      *         if the file is a directory and could not otherwise be deleted
 89      *         because the directory is not empty (optional specific exception)
 90      * @throws IOException
 91      *         if an I/O error occurs
 92      */
 93     public static void deleteFileIfExistsWithRetry(Path path) throws IOException {
 94         try {
<span class="line-modified"> 95             if (Files.exists(path)) {</span>
 96                 deleteFileWithRetry0(path);
 97             }
 98         } catch (InterruptedException x) {
 99             throw new IOException(&quot;Interrupted while deleting.&quot;, x);
100         }
101     }
102 
103     private static void deleteFileWithRetry0(Path path)
104             throws IOException, InterruptedException {
105         int times = 0;
106         IOException ioe = null;
107         while (true) {
108             try {
109                 Files.delete(path);
110                 // Checks for absence of the file. Semantics of Files.exists() is not the same.
111                 while (!Files.notExists(path)) {
112                     times++;
113                     if (times &gt; MAX_RETRY_DELETE_TIMES) {
114                         throw new IOException(&quot;File still exists after &quot; + times + &quot; waits.&quot;);
115                     }
</pre>
<hr />
<pre>
220             Process proc = new ProcessBuilder(&quot;df&quot;).inheritIO().start();
221             try {
222                 proc.waitFor(90, TimeUnit.SECONDS);
223             } catch (InterruptedException ignored) {
224             }
225             try {
226                 int exitValue = proc.exitValue();
227                 if (exitValue != 0) {
228                     System.err.printf(&quot;df process exited with %d != 0%n&quot;,
229                         exitValue);
230                     areFileSystemsAccessible = false;
231                 }
232             } catch (IllegalThreadStateException ignored) {
233                 System.err.println(&quot;df command apparently hung&quot;);
234                 areFileSystemsAccessible = false;
235             }
236         }
237         return areFileSystemsAccessible;
238     }
239 




















































































240     /**
241      * List the open file descriptors (if supported by the &#39;lsof&#39; command).
242      * @param ps a printStream to send the output to
243      * @throws UncheckedIOException if an error occurs
244      */
245     public static void listFileDescriptors(PrintStream ps) {
246 
247         Optional&lt;String[]&gt; lsof = Arrays.stream(lsCommands)
248                 .filter(args -&gt; Files.isExecutable(Path.of(args[0])))
249                 .findFirst();
250         lsof.ifPresent(args -&gt; {
251             try {
252                 ps.printf(&quot;Open File Descriptors:%n&quot;);
253                 long pid = ProcessHandle.current().pid();
254                 ProcessBuilder pb = new ProcessBuilder(args[0], args[1], Integer.toString((int) pid));
255                 pb.redirectErrorStream(true);   // combine stderr and stdout
256                 pb.redirectOutput(Redirect.PIPE);
257 
258                 Process p = pb.start();
259                 Instant start = Instant.now();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.util;
 25 
 26 import jdk.test.lib.Platform;
 27 
<span class="line-added"> 28 import java.io.BufferedReader;</span>
<span class="line-added"> 29 import java.io.InputStreamReader;</span>
 30 import java.io.IOException;
 31 import java.io.PrintStream;
 32 import java.io.UncheckedIOException;
 33 import java.lang.ProcessBuilder.Redirect;
 34 import java.nio.file.DirectoryNotEmptyException;
 35 import java.nio.file.FileVisitResult;
 36 import java.nio.file.Files;
 37 import java.nio.file.NoSuchFileException;
 38 import java.nio.file.Path;
 39 import java.nio.file.Paths;
 40 import java.nio.file.SimpleFileVisitor;
 41 import java.nio.file.attribute.BasicFileAttributes;
 42 import java.time.Instant;
 43 import java.time.Duration;
 44 import java.util.Arrays;
 45 import java.util.ArrayList;
 46 import java.util.ArrayDeque;
 47 import java.util.HashSet;
 48 import java.util.List;
 49 import java.util.Optional;
<span class="line-added"> 50 import java.util.Set;</span>
<span class="line-added"> 51 import java.util.concurrent.atomic.AtomicBoolean;</span>
<span class="line-added"> 52 import java.util.concurrent.atomic.AtomicReference;</span>
 53 import java.util.concurrent.TimeUnit;
 54 
 55 /**
 56  * Common library for various test file utility functions.
 57  */
 58 public final class FileUtils {
 59     private static final boolean IS_WINDOWS = Platform.isWindows();
 60     private static final int RETRY_DELETE_MILLIS = IS_WINDOWS ? 500 : 0;
 61     private static final int MAX_RETRY_DELETE_TIMES = IS_WINDOWS ? 15 : 0;
 62 
 63     /**
 64      * Deletes a file, retrying if necessary.
 65      *
 66      * @param path  the file to delete
 67      *
 68      * @throws NoSuchFileException
 69      *         if the file does not exist (optional specific exception)
 70      * @throws DirectoryNotEmptyException
 71      *         if the file is a directory and could not otherwise be deleted
 72      *         because the directory is not empty (optional specific exception)
</pre>
<hr />
<pre>
 80             throw new IOException(&quot;Interrupted while deleting.&quot;, x);
 81         }
 82     }
 83 
 84     /**
 85      * Deletes a file, retrying if necessary.
 86      * No exception thrown if file doesn&#39;t exist.
 87      *
 88      * @param path  the file to delete
 89      *
 90      * @throws NoSuchFileException
 91      *         if the file does not exist (optional specific exception)
 92      * @throws DirectoryNotEmptyException
 93      *         if the file is a directory and could not otherwise be deleted
 94      *         because the directory is not empty (optional specific exception)
 95      * @throws IOException
 96      *         if an I/O error occurs
 97      */
 98     public static void deleteFileIfExistsWithRetry(Path path) throws IOException {
 99         try {
<span class="line-modified">100             if (!Files.notExists(path)) {</span>
101                 deleteFileWithRetry0(path);
102             }
103         } catch (InterruptedException x) {
104             throw new IOException(&quot;Interrupted while deleting.&quot;, x);
105         }
106     }
107 
108     private static void deleteFileWithRetry0(Path path)
109             throws IOException, InterruptedException {
110         int times = 0;
111         IOException ioe = null;
112         while (true) {
113             try {
114                 Files.delete(path);
115                 // Checks for absence of the file. Semantics of Files.exists() is not the same.
116                 while (!Files.notExists(path)) {
117                     times++;
118                     if (times &gt; MAX_RETRY_DELETE_TIMES) {
119                         throw new IOException(&quot;File still exists after &quot; + times + &quot; waits.&quot;);
120                     }
</pre>
<hr />
<pre>
225             Process proc = new ProcessBuilder(&quot;df&quot;).inheritIO().start();
226             try {
227                 proc.waitFor(90, TimeUnit.SECONDS);
228             } catch (InterruptedException ignored) {
229             }
230             try {
231                 int exitValue = proc.exitValue();
232                 if (exitValue != 0) {
233                     System.err.printf(&quot;df process exited with %d != 0%n&quot;,
234                         exitValue);
235                     areFileSystemsAccessible = false;
236                 }
237             } catch (IllegalThreadStateException ignored) {
238                 System.err.println(&quot;df command apparently hung&quot;);
239                 areFileSystemsAccessible = false;
240             }
241         }
242         return areFileSystemsAccessible;
243     }
244 
<span class="line-added">245     /**</span>
<span class="line-added">246      * Checks whether all file systems are accessible and there are no</span>
<span class="line-added">247      * duplicate mount points. This is performed by checking free disk</span>
<span class="line-added">248      * space on all mounted file systems via a separate, spawned process.</span>
<span class="line-added">249      * File systems are considered to be accessible if this process completes</span>
<span class="line-added">250      * successfully before a given fixed duration has elapsed.</span>
<span class="line-added">251      *</span>
<span class="line-added">252      * @implNote On Unix this executes the {@code df} command in a separate</span>
<span class="line-added">253      * process and on Windows always returns {@code true}.</span>
<span class="line-added">254      *</span>
<span class="line-added">255      * @return whether file systems appear to be accessible and duplicate-free</span>
<span class="line-added">256      */</span>
<span class="line-added">257     public static boolean areMountPointsAccessibleAndUnique() {</span>
<span class="line-added">258         if (IS_WINDOWS) return true;</span>
<span class="line-added">259 </span>
<span class="line-added">260         final AtomicBoolean areMountPointsOK = new AtomicBoolean(true);</span>
<span class="line-added">261         Thread thr = new Thread(() -&gt; {</span>
<span class="line-added">262             try {</span>
<span class="line-added">263                 Process proc = new ProcessBuilder(&quot;df&quot;).start();</span>
<span class="line-added">264                 BufferedReader reader = new BufferedReader</span>
<span class="line-added">265                     (new InputStreamReader(proc.getInputStream()));</span>
<span class="line-added">266                 // Skip the first line as it is the &quot;df&quot; output header.</span>
<span class="line-added">267                 if (reader.readLine() != null ) {</span>
<span class="line-added">268                     Set mountPoints = new HashSet();</span>
<span class="line-added">269                     String mountPoint = null;</span>
<span class="line-added">270                     while ((mountPoint = reader.readLine()) != null) {</span>
<span class="line-added">271                         if (!mountPoints.add(mountPoint)) {</span>
<span class="line-added">272                             System.err.printf</span>
<span class="line-added">273                                 (&quot;Config error: duplicate mount point %s%n&quot;,</span>
<span class="line-added">274                                 mountPoint);</span>
<span class="line-added">275                             areMountPointsOK.set(false);</span>
<span class="line-added">276                             break;</span>
<span class="line-added">277                         }</span>
<span class="line-added">278                     }</span>
<span class="line-added">279                 }</span>
<span class="line-added">280 </span>
<span class="line-added">281                 try {</span>
<span class="line-added">282                     proc.waitFor(90, TimeUnit.SECONDS);</span>
<span class="line-added">283                 } catch (InterruptedException ignored) {</span>
<span class="line-added">284                 }</span>
<span class="line-added">285                 try {</span>
<span class="line-added">286                     int exitValue = proc.exitValue();</span>
<span class="line-added">287                     if (exitValue != 0) {</span>
<span class="line-added">288                         System.err.printf(&quot;df process exited with %d != 0%n&quot;,</span>
<span class="line-added">289                             exitValue);</span>
<span class="line-added">290                         areMountPointsOK.set(false);</span>
<span class="line-added">291                     }</span>
<span class="line-added">292                 } catch (IllegalThreadStateException ignored) {</span>
<span class="line-added">293                     System.err.println(&quot;df command apparently hung&quot;);</span>
<span class="line-added">294                     areMountPointsOK.set(false);</span>
<span class="line-added">295                 }</span>
<span class="line-added">296             } catch (IOException ioe) {</span>
<span class="line-added">297                 throw new RuntimeException(ioe);</span>
<span class="line-added">298             };</span>
<span class="line-added">299         });</span>
<span class="line-added">300 </span>
<span class="line-added">301         final AtomicReference throwableReference =</span>
<span class="line-added">302             new AtomicReference&lt;Throwable&gt;();</span>
<span class="line-added">303         thr.setUncaughtExceptionHandler(</span>
<span class="line-added">304             new Thread.UncaughtExceptionHandler() {</span>
<span class="line-added">305                 public void uncaughtException(Thread t, Throwable e) {</span>
<span class="line-added">306                     throwableReference.set(e);</span>
<span class="line-added">307                 }</span>
<span class="line-added">308             });</span>
<span class="line-added">309 </span>
<span class="line-added">310         thr.start();</span>
<span class="line-added">311         try {</span>
<span class="line-added">312             thr.join(120*1000L);</span>
<span class="line-added">313         } catch (InterruptedException ie) {</span>
<span class="line-added">314             throw new RuntimeException(ie);</span>
<span class="line-added">315         }</span>
<span class="line-added">316 </span>
<span class="line-added">317         Throwable uncaughtException = (Throwable)throwableReference.get();</span>
<span class="line-added">318         if (uncaughtException != null) {</span>
<span class="line-added">319             throw new RuntimeException(uncaughtException);</span>
<span class="line-added">320         }</span>
<span class="line-added">321 </span>
<span class="line-added">322         if (thr.isAlive()) {</span>
<span class="line-added">323             throw new RuntimeException(&quot;df thread did not join in time&quot;);</span>
<span class="line-added">324         }</span>
<span class="line-added">325 </span>
<span class="line-added">326         return areMountPointsOK.get();</span>
<span class="line-added">327     }</span>
<span class="line-added">328 </span>
329     /**
330      * List the open file descriptors (if supported by the &#39;lsof&#39; command).
331      * @param ps a printStream to send the output to
332      * @throws UncheckedIOException if an error occurs
333      */
334     public static void listFileDescriptors(PrintStream ps) {
335 
336         Optional&lt;String[]&gt; lsof = Arrays.stream(lsCommands)
337                 .filter(args -&gt; Files.isExecutable(Path.of(args[0])))
338                 .findFirst();
339         lsof.ifPresent(args -&gt; {
340             try {
341                 ps.printf(&quot;Open File Descriptors:%n&quot;);
342                 long pid = ProcessHandle.current().pid();
343                 ProcessBuilder pb = new ProcessBuilder(args[0], args[1], Integer.toString((int) pid));
344                 pb.redirectErrorStream(true);   // combine stderr and stdout
345                 pb.redirectOutput(Redirect.PIPE);
346 
347                 Process p = pb.start();
348                 Instant start = Instant.now();
</pre>
</td>
</tr>
</table>
<center><a href="../security/JDKSecurityProperties.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../sun/hotspot/WhiteBox.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
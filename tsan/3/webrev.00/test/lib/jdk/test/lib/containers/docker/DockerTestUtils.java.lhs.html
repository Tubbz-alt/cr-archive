<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/lib/jdk/test/lib/containers/docker/DockerTestUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.containers.docker;
 25 
 26 import java.io.File;
<a name="2" id="anc2"></a>
 27 import java.io.IOException;
 28 import java.nio.file.Files;
 29 import java.nio.file.FileVisitResult;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.nio.file.SimpleFileVisitor;
 33 import java.nio.file.StandardCopyOption;
 34 import java.nio.file.attribute.BasicFileAttributes;
<a name="3" id="anc3"></a>
 35 import java.util.ArrayList;
 36 import java.util.Collections;
 37 import java.util.List;
<a name="4" id="anc4"></a><span class="line-modified"> 38 import jdk.test.lib.Platform;</span>
 39 import jdk.test.lib.Utils;
 40 import jdk.test.lib.process.OutputAnalyzer;
<a name="5" id="anc5"></a><span class="line-modified"> 41 import jdk.test.lib.process.ProcessTools;</span>
 42 
 43 
 44 public class DockerTestUtils {
<a name="6" id="anc6"></a><span class="line-removed"> 45     private static final String FS = File.separator;</span>
 46     private static boolean isDockerEngineAvailable = false;
 47     private static boolean wasDockerEngineChecked = false;
 48 
<a name="7" id="anc7"></a><span class="line-modified"> 49     // Diagnostics: set to true to enable more diagnostic info</span>
<span class="line-modified"> 50     private static final boolean DEBUG = false;</span>
















 51 
 52     /**
 53      * Optimized check of whether the docker engine is available in a given
 54      * environment. Checks only once, then remembers the result in a singleton.
 55      *
 56      * @return true if docker engine is available
 57      * @throws Exception
 58      */
 59     public static boolean isDockerEngineAvailable() throws Exception {
 60         if (wasDockerEngineChecked)
 61             return isDockerEngineAvailable;
 62 
 63         isDockerEngineAvailable = isDockerEngineAvailableCheck();
 64         wasDockerEngineChecked = true;
 65         return isDockerEngineAvailable;
 66     }
 67 
 68 
 69     /**
 70      * Convenience method, will check if docker engine is available and usable;
 71      * will print the appropriate message when not available.
 72      *
 73      * @return true if docker engine is available
 74      * @throws Exception
 75      */
 76     public static boolean canTestDocker() throws Exception {
 77         if (isDockerEngineAvailable()) {
 78             return true;
 79         } else {
<a name="8" id="anc8"></a><span class="line-modified"> 80             System.out.println(&quot;Docker engine is not available on this system&quot;);</span>
<span class="line-removed"> 81             System.out.println(&quot;This test is SKIPPED&quot;);</span>
<span class="line-removed"> 82             return false;</span>
 83         }
 84     }
 85 
 86 
 87     /**
 88      * Simple check - is docker engine available, accessible and usable.
 89      * Run basic docker command: &#39;docker ps&#39; - list docker instances.
 90      * If docker engine is available and accesible then true is returned
 91      * and we can proceed with testing docker.
 92      *
 93      * @return true if docker engine is available and usable
 94      * @throws Exception
 95      */
 96     private static boolean isDockerEngineAvailableCheck() throws Exception {
 97         try {
<a name="9" id="anc9"></a><span class="line-modified"> 98             execute(&quot;docker&quot;, &quot;ps&quot;)</span>
 99                 .shouldHaveExitValue(0)
100                 .shouldContain(&quot;CONTAINER&quot;)
101                 .shouldContain(&quot;IMAGE&quot;);
102         } catch (Exception e) {
103             return false;
104         }
105         return true;
106     }
107 
108 
109     /**
110      * Build a docker image that contains JDK under test.
111      * The jdk will be placed under the &quot;/jdk/&quot; folder inside the docker file system.
112      *
113      * @param imageName     name of the image to be created, including version tag
114      * @param dockerfile    name of the dockerfile residing in the test source;
115      *                      we check for a platform specific dockerfile as well
116      *                      and use this one in case it exists
117      * @param buildDirName  name of the docker build/staging directory, which will
118      *                      be created in the jtreg&#39;s scratch folder
119      * @throws Exception
120      */
121     public static void
122         buildJdkDockerImage(String imageName, String dockerfile, String buildDirName)
123             throws Exception {
124 
125         Path buildDir = Paths.get(&quot;.&quot;, buildDirName);
126         if (Files.exists(buildDir)) {
127             throw new RuntimeException(&quot;The docker build directory already exists: &quot; + buildDir);
128         }
<a name="10" id="anc10"></a><span class="line-removed">129         // check for the existance of a platform specific docker file as well</span>
<span class="line-removed">130         String platformSpecificDockerfile = dockerfile + &quot;-&quot; + Platform.getOsArch();</span>
<span class="line-removed">131         if (Files.exists(Paths.get(Utils.TEST_SRC, platformSpecificDockerfile))) {</span>
<span class="line-removed">132           dockerfile = platformSpecificDockerfile;</span>
<span class="line-removed">133         }</span>
134 
<a name="11" id="anc11"></a><span class="line-modified">135         Path jdkSrcDir = Paths.get(Utils.TEST_JDK);</span>
136         Path jdkDstDir = buildDir.resolve(&quot;jdk&quot;);
137 
138         Files.createDirectories(jdkDstDir);
139 
140         // Copy JDK-under-test tree to the docker build directory.
141         // This step is required for building a docker image.
142         Files.walkFileTree(jdkSrcDir, new CopyFileVisitor(jdkSrcDir, jdkDstDir));
143         buildDockerImage(imageName, Paths.get(Utils.TEST_SRC, dockerfile), buildDir);
144     }
145 
146 
147     /**
148      * Build a docker image based on given docker file and docker build directory.
149      *
150      * @param imageName  name of the image to be created, including version tag
151      * @param dockerfile  path to the Dockerfile to be used for building the docker
152      *        image. The specified dockerfile will be copied to the docker build
153      *        directory as &#39;Dockerfile&#39;
154      * @param buildDir  build directory; it should already contain all the content
155      *        needed to build the docker image.
156      * @throws Exception
157      */
158     public static void
159         buildDockerImage(String imageName, Path dockerfile, Path buildDir) throws Exception {
160 
<a name="12" id="anc12"></a><span class="line-modified">161         // Copy docker file to the build dir</span>
<span class="line-modified">162         Files.copy(dockerfile, buildDir.resolve(&quot;Dockerfile&quot;));</span>
<span class="line-modified">163 </span>
<span class="line-modified">164         // Build the docker</span>
<span class="line-modified">165         execute(&quot;docker&quot;, &quot;build&quot;, &quot;--no-cache&quot;, &quot;--tag&quot;, imageName, buildDir.toString())</span>
<span class="line-modified">166             .shouldHaveExitValue(0)</span>
<span class="line-modified">167             .shouldContain(&quot;Successfully built&quot;);</span>






168     }
169 
170 
171     /**
<a name="13" id="anc13"></a><span class="line-modified">172      * Run Java inside the docker image with specified parameters and options.</span>
173      *
<a name="14" id="anc14"></a><span class="line-modified">174      * @param DockerRunOptions optins for running docker</span>
175      *
<a name="15" id="anc15"></a><span class="line-modified">176      * @return output of the run command</span>
177      * @throws Exception
178      */
<a name="16" id="anc16"></a><span class="line-modified">179     public static OutputAnalyzer dockerRunJava(DockerRunOptions opts) throws Exception {</span>
<span class="line-modified">180         ArrayList&lt;String&gt; cmd = new ArrayList&lt;&gt;();</span>
181 
<a name="17" id="anc17"></a><span class="line-modified">182         cmd.add(&quot;docker&quot;);</span>
183         cmd.add(&quot;run&quot;);
184         if (opts.tty)
185             cmd.add(&quot;--tty=true&quot;);
186         if (opts.removeContainerAfterUse)
187             cmd.add(&quot;--rm&quot;);
188 
189         cmd.addAll(opts.dockerOpts);
190         cmd.add(opts.imageNameAndTag);
191         cmd.add(opts.command);
192 
193         cmd.addAll(opts.javaOpts);
194         if (opts.appendTestJavaOptions) {
195             Collections.addAll(cmd, Utils.getTestJavaOpts());
196         }
<a name="18" id="anc18"></a>
197 
198         cmd.add(opts.classToRun);
199         cmd.addAll(opts.classParams);
200 
<a name="19" id="anc19"></a><span class="line-modified">201         return execute(cmd);</span>












202     }
203 
204 
205      /**
206      * Remove docker image
207      *
<a name="20" id="anc20"></a><span class="line-modified">208      * @param DockerRunOptions optins for running docker</span>
<span class="line-removed">209      * @return output of the command</span>
210      * @throws Exception
211      */
<a name="21" id="anc21"></a><span class="line-modified">212     public static OutputAnalyzer removeDockerImage(String imageNameAndTag) throws Exception {</span>
<span class="line-modified">213         return execute(&quot;docker&quot;, &quot;rmi&quot;, &quot;--force&quot;, imageNameAndTag);</span>
214     }
215 
216 
217 
218     /**
219      * Convenience method - express command as sequence of strings
220      *
221      * @param command to execute
222      * @return The output from the process
223      * @throws Exception
224      */
225     public static OutputAnalyzer execute(List&lt;String&gt; command) throws Exception {
226         return execute(command.toArray(new String[command.size()]));
227     }
228 
229 
230     /**
231      * Execute a specified command in a process, report diagnostic info.
232      *
233      * @param command to be executed
234      * @return The output from the process
235      * @throws Exception
236      */
237     public static OutputAnalyzer execute(String... command) throws Exception {
238 
239         ProcessBuilder pb = new ProcessBuilder(command);
240         System.out.println(&quot;[COMMAND]\n&quot; + Utils.getCommandLine(pb));
241 
242         long started = System.currentTimeMillis();
<a name="22" id="anc22"></a><span class="line-modified">243         OutputAnalyzer output = new OutputAnalyzer(pb.start());</span>


244 
<a name="23" id="anc23"></a>
245         System.out.println(&quot;[ELAPSED: &quot; + (System.currentTimeMillis() - started) + &quot; ms]&quot;);
246         System.out.println(&quot;[STDERR]\n&quot; + output.getStderr());
<a name="24" id="anc24"></a><span class="line-modified">247         System.out.println(&quot;[STDOUT]\n&quot; + output.getStdout());</span>





248 
249         return output;
250     }
251 
252 
<a name="25" id="anc25"></a>




























253     private static class CopyFileVisitor extends SimpleFileVisitor&lt;Path&gt; {
254         private final Path src;
255         private final Path dst;
256 
257         public CopyFileVisitor(Path src, Path dst) {
258             this.src = src;
259             this.dst = dst;
260         }
261 
262 
263         @Override
264         public FileVisitResult preVisitDirectory(Path file,
265                 BasicFileAttributes attrs) throws IOException {
266             Path dstDir = dst.resolve(src.relativize(file));
267             if (!dstDir.toFile().exists()) {
268                 Files.createDirectories(dstDir);
269             }
270             return FileVisitResult.CONTINUE;
271         }
272 
273 
274         @Override
275         public FileVisitResult visitFile(Path file,
276                 BasicFileAttributes attrs) throws IOException {
277             if (!file.toFile().isFile()) {
278                 return FileVisitResult.CONTINUE;
279             }
280             Path dstFile = dst.resolve(src.relativize(file));
281             Files.copy(file, dstFile, StandardCopyOption.COPY_ATTRIBUTES);
282             return FileVisitResult.CONTINUE;
283         }
284     }
285 }
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
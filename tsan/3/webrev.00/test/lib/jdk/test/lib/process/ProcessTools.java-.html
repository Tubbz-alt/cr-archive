<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/lib/jdk/test/lib/process/ProcessTools.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.process;
 25 
 26 import java.io.IOException;
 27 import java.io.InputStream;
 28 import java.io.OutputStream;
 29 import java.io.PrintStream;
 30 import java.util.ArrayList;
 31 import java.util.Arrays;
 32 import java.util.Collections;
 33 import java.util.concurrent.CountDownLatch;
 34 import java.util.Map;
 35 import java.util.concurrent.ExecutionException;
 36 import java.util.concurrent.Future;
 37 import java.util.concurrent.TimeUnit;
 38 import java.util.concurrent.TimeoutException;
 39 import java.util.function.Predicate;
 40 import java.util.function.Consumer;
 41 import java.util.stream.Collectors;
 42 import java.security.AccessController;
 43 import java.security.PrivilegedActionException;
 44 import java.security.PrivilegedExceptionAction;
 45 
 46 import jdk.test.lib.JDKToolFinder;
 47 import jdk.test.lib.Utils;
 48 
 49 public final class ProcessTools {
 50     private static final class LineForwarder extends StreamPumper.LinePump {
 51         private final PrintStream ps;
 52         private final String prefix;
 53         LineForwarder(String prefix, PrintStream os) {
 54             this.ps = os;
 55             this.prefix = prefix;
 56         }
 57         @Override
 58         protected void processLine(String line) {
 59             ps.println(&quot;[&quot; + prefix + &quot;] &quot; + line);
 60         }
 61     }
 62 
 63     private ProcessTools() {
 64     }
 65 
 66     /**
 67      * &lt;p&gt;Starts a process from its builder.&lt;/p&gt;
 68      * &lt;span&gt;The default redirects of STDOUT and STDERR are started&lt;/span&gt;
 69      * @param name The process name
 70      * @param processBuilder The process builder
 71      * @return Returns the initialized process
 72      * @throws IOException
 73      */
 74     public static Process startProcess(String name,
 75                                        ProcessBuilder processBuilder)
 76     throws IOException {
 77         return startProcess(name, processBuilder, (Consumer&lt;String&gt;)null);
 78     }
 79 
 80     /**
 81      * &lt;p&gt;Starts a process from its builder.&lt;/p&gt;
 82      * &lt;span&gt;The default redirects of STDOUT and STDERR are started&lt;/span&gt;
 83      * &lt;p&gt;It is possible to monitor the in-streams via the provided {@code consumer}
 84      * @param name The process name
 85      * @param consumer {@linkplain Consumer} instance to process the in-streams
 86      * @param processBuilder The process builder
 87      * @return Returns the initialized process
 88      * @throws IOException
 89      */
 90     @SuppressWarnings(&quot;overloads&quot;)
 91     public static Process startProcess(String name,
 92                                        ProcessBuilder processBuilder,
 93                                        Consumer&lt;String&gt; consumer)
 94     throws IOException {
 95         try {
 96             return startProcess(name, processBuilder, consumer, null, -1, TimeUnit.NANOSECONDS);
 97         } catch (InterruptedException | TimeoutException e) {
 98             // will never happen
 99             throw new RuntimeException(e);
100         }
101     }
102 
103     /**
104      * &lt;p&gt;Starts a process from its builder.&lt;/p&gt;
105      * &lt;span&gt;The default redirects of STDOUT and STDERR are started&lt;/span&gt;
106      * &lt;p&gt;
107      * It is possible to wait for the process to get to a warmed-up state
108      * via {@linkplain Predicate} condition on the STDOUT
109      * &lt;/p&gt;
110      * @param name The process name
111      * @param processBuilder The process builder
112      * @param linePredicate The {@linkplain Predicate} to use on the STDOUT
113      *                      Used to determine the moment the target app is
114      *                      properly warmed-up.
115      *                      It can be null - in that case the warmup is skipped.
116      * @param timeout The timeout for the warmup waiting; -1 = no wait; 0 = wait forever
117      * @param unit The timeout {@linkplain TimeUnit}
118      * @return Returns the initialized {@linkplain Process}
119      * @throws IOException
120      * @throws InterruptedException
121      * @throws TimeoutException
122      */
123     public static Process startProcess(String name,
124                                        ProcessBuilder processBuilder,
125                                        final Predicate&lt;String&gt; linePredicate,
126                                        long timeout,
127                                        TimeUnit unit)
128     throws IOException, InterruptedException, TimeoutException {
129         return startProcess(name, processBuilder, null, linePredicate, timeout, unit);
130     }
131 
132     /**
133      * &lt;p&gt;Starts a process from its builder.&lt;/p&gt;
134      * &lt;span&gt;The default redirects of STDOUT and STDERR are started&lt;/span&gt;
135      * &lt;p&gt;
136      * It is possible to wait for the process to get to a warmed-up state
137      * via {@linkplain Predicate} condition on the STDOUT and monitor the
138      * in-streams via the provided {@linkplain Consumer}
139      * &lt;/p&gt;
140      * @param name The process name
141      * @param processBuilder The process builder
142      * @param lineConsumer  The {@linkplain Consumer} the lines will be forwarded to
143      * @param linePredicate The {@linkplain Predicate} to use on the STDOUT
144      *                      Used to determine the moment the target app is
145      *                      properly warmed-up.
146      *                      It can be null - in that case the warmup is skipped.
147      * @param timeout The timeout for the warmup waiting; -1 = no wait; 0 = wait forever
148      * @param unit The timeout {@linkplain TimeUnit}
149      * @return Returns the initialized {@linkplain Process}
150      * @throws IOException
151      * @throws InterruptedException
152      * @throws TimeoutException
153      */
154     public static Process startProcess(String name,
155                                        ProcessBuilder processBuilder,
156                                        final Consumer&lt;String&gt; lineConsumer,
157                                        final Predicate&lt;String&gt; linePredicate,
158                                        long timeout,
159                                        TimeUnit unit)
160     throws IOException, InterruptedException, TimeoutException {
161         System.out.println(&quot;[&quot;+name+&quot;]:&quot; + processBuilder.command().stream().collect(Collectors.joining(&quot; &quot;)));
162         Process p = privilegedStart(processBuilder);
163         StreamPumper stdout = new StreamPumper(p.getInputStream());
164         StreamPumper stderr = new StreamPumper(p.getErrorStream());
165 
166         stdout.addPump(new LineForwarder(name, System.out));
167         stderr.addPump(new LineForwarder(name, System.err));
168         if (lineConsumer != null) {
169             StreamPumper.LinePump pump = new StreamPumper.LinePump() {
170                 @Override
171                 protected void processLine(String line) {
172                     lineConsumer.accept(line);
173                 }
174             };
175             stdout.addPump(pump);
176             stderr.addPump(pump);
177         }
178 
179 
180         CountDownLatch latch = new CountDownLatch(1);
181         if (linePredicate != null) {
182             StreamPumper.LinePump pump = new StreamPumper.LinePump() {
183                 @Override
184                 protected void processLine(String line) {
185                     if (latch.getCount() &gt; 0 &amp;&amp; linePredicate.test(line)) {
186                         latch.countDown();
187                     }
188                 }
189             };
190             stdout.addPump(pump);
191             stderr.addPump(pump);
192         } else {
193             latch.countDown();
194         }
195         final Future&lt;Void&gt; stdoutTask = stdout.process();
196         final Future&lt;Void&gt; stderrTask = stderr.process();
197 
198         try {
199             if (timeout &gt; -1) {
200                 if (timeout == 0) {
201                     latch.await();
202                 } else {
203                     if (!latch.await(Utils.adjustTimeout(timeout), unit)) {
204                         throw new TimeoutException();
205                     }
206                 }
207             }
208         } catch (TimeoutException | InterruptedException e) {
209             System.err.println(&quot;Failed to start a process (thread dump follows)&quot;);
210             for(Map.Entry&lt;Thread, StackTraceElement[]&gt; s : Thread.getAllStackTraces().entrySet()) {
211                 printStack(s.getKey(), s.getValue());
212             }
213 
214             if (p.isAlive()) {
215                 p.destroyForcibly();
216             }
217 
218             stdoutTask.cancel(true);
219             stderrTask.cancel(true);
220             throw e;
221         }
222 
223         return new ProcessImpl(p, stdoutTask, stderrTask);
224     }
225 
226     /**
227      * &lt;p&gt;Starts a process from its builder.&lt;/p&gt;
228      * &lt;span&gt;The default redirects of STDOUT and STDERR are started&lt;/span&gt;
229      * &lt;p&gt;
230      * It is possible to wait for the process to get to a warmed-up state
231      * via {@linkplain Predicate} condition on the STDOUT. The warm-up will
232      * wait indefinitely.
233      * &lt;/p&gt;
234      * @param name The process name
235      * @param processBuilder The process builder
236      * @param linePredicate The {@linkplain Predicate} to use on the STDOUT
237      *                      Used to determine the moment the target app is
238      *                      properly warmed-up.
239      *                      It can be null - in that case the warmup is skipped.
240      * @return Returns the initialized {@linkplain Process}
241      * @throws IOException
242      * @throws InterruptedException
243      * @throws TimeoutException
244      */
245     @SuppressWarnings(&quot;overloads&quot;)
246     public static Process startProcess(String name,
247                                        ProcessBuilder processBuilder,
248                                        final Predicate&lt;String&gt; linePredicate)
249     throws IOException, InterruptedException, TimeoutException {
250         return startProcess(name, processBuilder, linePredicate, 0, TimeUnit.SECONDS);
251     }
252 
253     /**
254      * Get the process id of the current running Java process
255      *
256      * @return Process id
257      */
258     public static long getProcessId() throws Exception {
259         return ProcessHandle.current().pid();
260     }
261 
262 
263 
264     /**
265      * Create ProcessBuilder using the java launcher from the jdk to be tested and
266      * with any platform specific arguments prepended
267      */
268     public static ProcessBuilder createJavaProcessBuilder(String... command) {
269         return createJavaProcessBuilder(false, command);
270     }
271 
272     /**
273      * Create ProcessBuilder using the java launcher from the jdk to be tested,
274      * and with any platform specific arguments prepended.
275      *
276      * @param addTestVmAndJavaOptions If true, adds test.vm.opts and test.java.opts
277      *        to the java arguments.
278      * @param command Arguments to pass to the java command.
279      * @return The ProcessBuilder instance representing the java command.
280      */
281     public static ProcessBuilder createJavaProcessBuilder(boolean addTestVmAndJavaOptions, String... command) {
282         String javapath = JDKToolFinder.getJDKTool(&quot;java&quot;);
283 
284         ArrayList&lt;String&gt; args = new ArrayList&lt;&gt;();
285         args.add(javapath);
286 
287         args.add(&quot;-cp&quot;);
288         args.add(System.getProperty(&quot;java.class.path&quot;));
289 
290         if (addTestVmAndJavaOptions) {
291             Collections.addAll(args, Utils.getTestJavaOpts());
292         }
293 
294         Collections.addAll(args, command);
295 
296         // Reporting
297         StringBuilder cmdLine = new StringBuilder();
298         for (String cmd : args)
299             cmdLine.append(cmd).append(&#39; &#39;);
300         System.out.println(&quot;Command line: [&quot; + cmdLine.toString() + &quot;]&quot;);
301 
302         return new ProcessBuilder(args.toArray(new String[args.size()]));
303     }
304 
305     private static void printStack(Thread t, StackTraceElement[] stack) {
306         System.out.println(&quot;\t&quot; +  t +
307                            &quot; stack: (length = &quot; + stack.length + &quot;)&quot;);
308         if (t != null) {
309             for (StackTraceElement stack1 : stack) {
310                 System.out.println(&quot;\t&quot; + stack1);
311             }
312             System.out.println();
313         }
314     }
315 
316     /**
317      * Executes a test jvm process, waits for it to finish and returns the process output.
318      * The default jvm options from jtreg, test.vm.opts and test.java.opts, are added.
319      * The java from the test.jdk is used to execute the command.
320      *
321      * The command line will be like:
322      * {test.jdk}/bin/java {test.vm.opts} {test.java.opts} cmds
323      *
324      * The jvm process will have exited before this method returns.
325      *
326      * @param cmds User specified arguments.
327      * @return The output from the process.
328      */
329     public static OutputAnalyzer executeTestJvm(String... cmds) throws Exception {
330         ProcessBuilder pb = createJavaProcessBuilder(Utils.addTestJavaOpts(cmds));
331         return executeProcess(pb);
332     }
333 
334     /**
335      * @see #executeTestJvm(String...)
336      * @param cmds User specified arguments.
337      * @return The output from the process.
338      */
339     public static OutputAnalyzer executeTestJava(String... cmds) throws Exception {
340         return executeTestJvm(cmds);
341     }
342 
343     /**
344      * Executes a process, waits for it to finish and returns the process output.
345      * The process will have exited before this method returns.
346      * @param pb The ProcessBuilder to execute.
347      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
348      */
349     public static OutputAnalyzer executeProcess(ProcessBuilder pb) throws Exception {
350         return executeProcess(pb, null);
351     }
352 
353     /**
354      * Executes a process, pipe some text into its STDIN, waits for it
355      * to finish and returns the process output. The process will have exited
356      * before this method returns.
357      * @param pb The ProcessBuilder to execute.
358      * @param input The text to pipe into STDIN. Can be null.
359      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
360      */
361     public static OutputAnalyzer executeProcess(ProcessBuilder pb, String input) throws Exception {
362         OutputAnalyzer output = null;
363         Process p = null;
364         boolean failed = false;
365         try {
366             p = privilegedStart(pb);
367             if (input != null) {
368                try (PrintStream ps = new PrintStream(p.getOutputStream())) {
369                    ps.print(input);
370                }
371             }
372 
373             output = new OutputAnalyzer(p);
374             p.waitFor();
375 
376             return output;
377         } catch (Throwable t) {
378             if (p != null) {
379                 p.destroyForcibly().waitFor();
380             }
381 
382             failed = true;
383             System.out.println(&quot;executeProcess() failed: &quot; + t);
384             throw t;
385         } finally {
386             if (failed) {
387                 System.err.println(getProcessLog(pb, output));
388             }
389         }
390     }
391 
392     /**
393      * Executes a process, waits for it to finish and returns the process output.
394      *
395      * The process will have exited before this method returns.
396      *
397      * @param cmds The command line to execute.
398      * @return The output from the process.
399      */
400     public static OutputAnalyzer executeProcess(String... cmds) throws Throwable {
401         return executeProcess(new ProcessBuilder(cmds));
402     }
403 
404     /**
405      * Used to log command line, stdout, stderr and exit code from an executed process.
406      * @param pb The executed process.
407      * @param output The output from the process.
408      */
409     public static String getProcessLog(ProcessBuilder pb, OutputAnalyzer output) {
410         String stderr = output == null ? &quot;null&quot; : output.getStderr();
411         String stdout = output == null ? &quot;null&quot; : output.getStdout();
412         String exitValue = output == null ? &quot;null&quot;: Integer.toString(output.getExitValue());
413         StringBuilder logMsg = new StringBuilder();
414         final String nl = System.getProperty(&quot;line.separator&quot;);
415         logMsg.append(&quot;--- ProcessLog ---&quot; + nl);
416         logMsg.append(&quot;cmd: &quot; + getCommandLine(pb) + nl);
417         logMsg.append(&quot;exitvalue: &quot; + exitValue + nl);
418         logMsg.append(&quot;stderr: &quot; + stderr + nl);
419         logMsg.append(&quot;stdout: &quot; + stdout + nl);
420 
421         return logMsg.toString();
422     }
423 
424     /**
425      * @return The full command line for the ProcessBuilder.
426      */
427     public static String getCommandLine(ProcessBuilder pb) {
428         if (pb == null) {
429             return &quot;null&quot;;
430         }
431         StringBuilder cmd = new StringBuilder();
432         for (String s : pb.command()) {
433             cmd.append(s).append(&quot; &quot;);
434         }
435         return cmd.toString().trim();
436     }
437 
438     /**
439      * Executes a process, waits for it to finish, prints the process output
440      * to stdout, and returns the process output.
441      *
442      * The process will have exited before this method returns.
443      *
444      * @param cmds The command line to execute.
445      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
446      */
447     public static OutputAnalyzer executeCommand(String... cmds)
448             throws Throwable {
449         String cmdLine = Arrays.stream(cmds).collect(Collectors.joining(&quot; &quot;));
450         System.out.println(&quot;Command line: [&quot; + cmdLine + &quot;]&quot;);
451         OutputAnalyzer analyzer = ProcessTools.executeProcess(cmds);
452         System.out.println(analyzer.getOutput());
453         return analyzer;
454     }
455 
456     /**
457      * Executes a process, waits for it to finish, prints the process output
458      * to stdout and returns the process output.
459      *
460      * The process will have exited before this method returns.
461      *
462      * @param pb The ProcessBuilder to execute.
463      * @return The {@linkplain OutputAnalyzer} instance wrapping the process.
464      */
465     public static OutputAnalyzer executeCommand(ProcessBuilder pb)
466             throws Throwable {
467         String cmdLine = pb.command().stream()
468                 .map(x -&gt; (x.contains(&quot; &quot;) || x.contains(&quot;$&quot;))
469                         ? (&quot;&#39;&quot; + x + &quot;&#39;&quot;) : x)
470                 .collect(Collectors.joining(&quot; &quot;));
471         System.out.println(&quot;Command line: [&quot; + cmdLine + &quot;]&quot;);
472         OutputAnalyzer analyzer = ProcessTools.executeProcess(pb);
473         System.out.println(analyzer.getOutput());
474         return analyzer;
475     }
476 
477     private static Process privilegedStart(ProcessBuilder pb) throws IOException {
478         try {
479             return AccessController.doPrivileged(
480                 (PrivilegedExceptionAction&lt;Process&gt;) () -&gt; pb.start());
481         } catch (PrivilegedActionException e) {
482             @SuppressWarnings(&quot;unchecked&quot;)
483             IOException t = (IOException) e.getException();
484             throw t;
485         }
486     }
487 
488     private static class ProcessImpl extends Process {
489 
490         private final Process p;
491         private final Future&lt;Void&gt; stdoutTask;
492         private final Future&lt;Void&gt; stderrTask;
493 
494         public ProcessImpl(Process p, Future&lt;Void&gt; stdoutTask, Future&lt;Void&gt; stderrTask) {
495             this.p = p;
496             this.stdoutTask = stdoutTask;
497             this.stderrTask = stderrTask;
498         }
499 
500         @Override
501         public OutputStream getOutputStream() {
502             return p.getOutputStream();
503         }
504 
505         @Override
506         public InputStream getInputStream() {
507             return p.getInputStream();
508         }
509 
510         @Override
511         public InputStream getErrorStream() {
512             return p.getErrorStream();
513         }
514 
515         @Override
516         public int waitFor() throws InterruptedException {
517             int rslt = p.waitFor();
518             waitForStreams();
519             return rslt;
520         }
521 
522         @Override
523         public int exitValue() {
524             return p.exitValue();
525         }
526 
527         @Override
528         public void destroy() {
529             p.destroy();
530         }
531 
532         @Override
533         public long pid() {
534             return p.pid();
535         }
536 
537         @Override
538         public boolean isAlive() {
539             return p.isAlive();
540         }
541 
542         @Override
543         public Process destroyForcibly() {
544             return p.destroyForcibly();
545         }
546 
547         @Override
548         public boolean waitFor(long timeout, TimeUnit unit) throws InterruptedException {
549             boolean rslt = p.waitFor(timeout, unit);
550             if (rslt) {
551                 waitForStreams();
552             }
553             return rslt;
554         }
555 
556         private void waitForStreams() throws InterruptedException {
557             try {
558                 stdoutTask.get();
559             } catch (ExecutionException e) {
560             }
561             try {
562                 stderrTask.get();
563             } catch (ExecutionException e) {
564             }
565         }
566     }
567 }
    </pre>
  </body>
</html>
diff a/test/lib/jdk/test/lib/process/OutputAnalyzer.java b/test/lib/jdk/test/lib/process/OutputAnalyzer.java
--- a/test/lib/jdk/test/lib/process/OutputAnalyzer.java
+++ b/test/lib/jdk/test/lib/process/OutputAnalyzer.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,19 +25,34 @@
 
 import jdk.test.lib.Asserts;
 
 import java.io.IOException;
 import java.io.PrintStream;
+import java.nio.charset.Charset;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.Arrays;
 import java.util.List;
 import java.util.stream.Collectors;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 public final class OutputAnalyzer {
 
     private final OutputBuffer buffer;
+    /**
+     * Create an OutputAnalyzer, a utility class for verifying output and exit
+     * value from a Process
+     *
+     * @param process Process to analyze
+     * @param cs The charset used to convert stdout/stderr from bytes to chars
+     *           or null for the default charset.
+     * @throws IOException If an I/O error occurs.
+     */
+    public OutputAnalyzer(Process process, Charset cs) throws IOException {
+        buffer = OutputBuffer.of(process, cs);
+    }
     /**
      * Create an OutputAnalyzer, a utility class for verifying output and exit
      * value from a Process
      *
      * @param process Process to analyze
@@ -54,20 +69,41 @@
      */
     public OutputAnalyzer(String buf) {
         buffer = OutputBuffer.of(buf, buf);
     }
 
+    /**
+     * Create an OutputAnalyzer, a utility class for verifying output
+     *
+     * @param file File to analyze
+     */
+    public OutputAnalyzer(Path file) throws IOException {
+        this(Files.readString(file));
+    }
+
     /**
      * Create an OutputAnalyzer, a utility class for verifying output
      *
      * @param stdout stdout buffer to analyze
      * @param stderr stderr buffer to analyze
      */
     public OutputAnalyzer(String stdout, String stderr) {
         buffer = OutputBuffer.of(stdout, stderr);
     }
 
+    /**
+     * Create an OutputAnalyzer, a utility class for verifying output
+     *
+     * @param stdout stdout buffer to analyze
+     * @param stderr stderr buffer to analyze
+     * @param stderr exitValue result to analyze
+     */
+    public OutputAnalyzer(String stdout, String stderr, int exitValue)
+    {
+        buffer = OutputBuffer.of(stdout, stderr, exitValue);
+    }
+
     /**
      * Verify that the stdout contents of output buffer is empty
      *
      * @throws RuntimeException
      *             If stdout was not empty
@@ -610,14 +646,14 @@
      * Verify that the stdout and stderr contents of output buffer match the
      * {@code pattern} line by line. The whole output could be matched or
      * just a subset of it.
      *
      * @param from
-     *            The line from where output will be matched.
+     *            The line (excluded) from where output will be matched.
      *            Set {@code from} to null for matching from the first line.
      * @param to
-     *            The line until where output will be matched.
+     *            The line (excluded) until where output will be matched.
      *            Set {@code to} to null for matching until the last line.
      * @param pattern
      *            Matching pattern
      */
     public OutputAnalyzer shouldMatchByLine(String from, String to, String pattern) {
@@ -628,14 +664,14 @@
      * Verify that the stdout contents of output buffer matches the
      * {@code pattern} line by line. The whole stdout could be matched or
      * just a subset of it.
      *
      * @param from
-     *            The line from where stdout will be matched.
+     *            The line (excluded) from where stdout will be matched.
      *            Set {@code from} to null for matching from the first line.
      * @param to
-     *            The line until where stdout will be matched.
+     *            The line (excluded) until where stdout will be matched.
      *            Set {@code to} to null for matching until the last line.
      * @param pattern
      *            Matching pattern
      */
     public OutputAnalyzer stdoutShouldMatchByLine(String from, String to, String pattern) {
@@ -645,43 +681,45 @@
     private OutputAnalyzer shouldMatchByLine(String buffer, String from, String to, String pattern) {
         List<String> lines = asLines(buffer);
 
         int fromIndex = 0;
         if (from != null) {
-            fromIndex = indexOf(lines, from);
-            Asserts.assertGreaterThan(fromIndex, -1,
+            fromIndex = indexOf(lines, from, 0) + 1; // + 1 -> apply 'pattern' to lines after 'from' match
+            Asserts.assertGreaterThan(fromIndex, 0,
                     "The line/pattern '" + from + "' from where the output should match can not be found");
         }
 
         int toIndex = lines.size();
         if (to != null) {
-            toIndex = indexOf(lines, to);
-            Asserts.assertGreaterThan(toIndex, -1,
+            toIndex = indexOf(lines, to, fromIndex);
+            Asserts.assertGreaterThan(toIndex, fromIndex,
                     "The line/pattern '" + to + "' until where the output should match can not be found");
         }
 
         List<String> subList = lines.subList(fromIndex, toIndex);
-        Asserts.assertFalse(subList.isEmpty(), "There are no lines to check");
+        Asserts.assertFalse(subList.isEmpty(), "There are no lines to check:"
+                + " range " + fromIndex + ".." + toIndex + ", subList = " + subList);
 
         subList.stream()
                .filter(Pattern.compile(pattern).asPredicate().negate())
                .findAny()
-               .ifPresent(line -> Asserts.assertTrue(false,
+               .ifPresent(line -> Asserts.fail(
                        "The line '" + line + "' does not match pattern '" + pattern + "'"));
 
         return this;
     }
 
     /**
      * Check if there is a line matching {@code regexp} and return its index
      *
      * @param regexp Matching pattern
+     * @param fromIndex Start matching after so many lines skipped
      * @return Index of first matching line
      */
-    private int indexOf(List<String> lines, String regexp) {
+    private int indexOf(List<String> lines, String regexp, int fromIndex) {
         Pattern pattern = Pattern.compile(regexp);
-        for (int i = 0; i < lines.size(); i++) {
+        for (int i = fromIndex; i < lines.size(); i++) {
             if (pattern.matcher(lines.get(i)).matches()) {
                 return i;
             }
         }
         return -1;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/lib/jdk/test/lib/jfr/GCHelper.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.test.lib.jfr;
 26 
 27 import static jdk.test.lib.Asserts.assertEquals;
 28 import static jdk.test.lib.Asserts.assertNotEquals;
 29 import static jdk.test.lib.Asserts.assertNotNull;
 30 import static jdk.test.lib.Asserts.assertNull;
 31 import static jdk.test.lib.Asserts.fail;
 32 
 33 import java.io.FileOutputStream;
 34 import java.io.IOException;
 35 import java.io.PrintStream;
 36 import java.lang.management.GarbageCollectorMXBean;
 37 import java.lang.management.ManagementFactory;
 38 import java.time.Instant;
 39 import java.util.ArrayList;
 40 import java.util.Arrays;
 41 import java.util.Collections;
 42 import java.util.HashMap;
 43 import java.util.HashSet;
 44 import java.util.List;
 45 import java.util.Map;
 46 import java.util.Set;
 47 import java.util.Stack;
 48 
 49 import jdk.jfr.ValueDescriptor;
 50 import jdk.jfr.consumer.RecordedEvent;
 51 
 52 /**
 53  * Mixed helper classes to test GC events.
 54  */
 55 public class GCHelper {
 56     public static final String event_garbage_collection = EventNames.GarbageCollection;
 57     public static final String event_young_garbage_collection = EventNames.YoungGarbageCollection;
 58     public static final String event_old_garbage_collection = EventNames.OldGarbageCollection;
 59     public static final String event_parold_garbage_collection = EventNames.ParallelOldCollection;
 60     public static final String event_g1_garbage_collection = EventNames.G1GarbageCollection;
 61     public static final String event_heap_summary = EventNames.GCHeapSummary;
 62     public static final String event_heap_ps_summary = EventNames.PSHeapSummary;
 63     public static final String event_heap_metaspace_summary = EventNames.MetaspaceSummary;
 64     public static final String event_reference_statistics = EventNames.GCReferenceStatistics;
 65     public static final String event_phases_pause = EventNames.GCPhasePause;
 66     public static final String event_phases_level_1 = EventNames.GCPhasePauseLevel1;
 67     public static final String event_phases_level_2 = EventNames.GCPhasePauseLevel2;
 68     public static final String event_phases_level_3 = EventNames.GCPhasePauseLevel3;
 69 
 70     public static final String gcG1New = &quot;G1New&quot;;
<a name="2" id="anc2"></a>
 71     public static final String gcDefNew = &quot;DefNew&quot;;
 72     public static final String gcParallelScavenge = &quot;ParallelScavenge&quot;;
 73     public static final String gcG1Old = &quot;G1Old&quot;;
 74     public static final String gcG1Full = &quot;G1Full&quot;;
<a name="3" id="anc3"></a>
 75     public static final String gcSerialOld = &quot;SerialOld&quot;;
 76     public static final String gcPSMarkSweep = &quot;PSMarkSweep&quot;;
 77     public static final String gcParallelOld = &quot;ParallelOld&quot;;
 78     public static final String pauseLevelEvent = &quot;GCPhasePauseLevel&quot;;
 79 
 80     private static final List&lt;String&gt; g1HeapRegionTypes;
<a name="4" id="anc4"></a><span class="line-added"> 81     private static final List&lt;String&gt; shenandoahHeapRegionStates;</span>
 82     private static PrintStream defaultErrorLog = null;
 83 
 84     public static int getGcId(RecordedEvent event) {
 85         return Events.assertField(event, &quot;gcId&quot;).getValue();
 86     }
 87 
 88     public static boolean isGcEvent(RecordedEvent event) {
 89         for (ValueDescriptor v : event.getFields()) {
 90             if (&quot;gcId&quot;.equals(v.getName())) {
 91                 return true;
 92             }
 93         }
 94         return false;
 95     }
 96 
 97 //    public static String getEventDesc(RecordedEvent event) {
 98 //      final String path = event.getEventType().getName();
 99 //        if (!isGcEvent(event)) {
100 //            return path;
101 //        }
102 //        if (event_garbage_collection.equals(path)) {
103 //            String name = Events.assertField(event, &quot;name&quot;).getValue();
104 //            String cause = Events.assertField(event, &quot;cause&quot;).getValue();
105 //            return String.format(&quot;path=%s, gcId=%d, endTime=%d, name=%s, cause=%s, startTime=%d&quot;,
106 //                    path, getGcId(event), event.getEndTime(), name, cause, event.getStartTime());
107 //        } else {
108 //            return String.format(&quot;path=%s, gcId=%d, endTime=%d&quot;, path, getGcId(event), event.getEndTime());
109 //        }
110 //    }
111 
112     public static RecordedEvent getConfigEvent(List&lt;RecordedEvent&gt; events) throws Exception {
113         for (RecordedEvent event : events) {
114             if (EventNames.GCConfiguration.equals(event.getEventType().getName())) {
115                 return event;
116             }
117         }
118         fail(&quot;Could not find event &quot; + EventNames.GCConfiguration);
119         return null;
120     }
121 
122     public static void callSystemGc(int num, boolean withGarbage) {
123         for (int i = 0; i &lt; num; i++) {
124             if (withGarbage) {
125                 makeGarbage();
126             }
127             System.gc();
128         }
129     }
130 
131     private static void makeGarbage() {
132         Object[] garbage = new Object[1024];
133         for (int i = 0; i &lt; 1024; i++) {
134             garbage[i] = new Object();
135         }
136     }
137 
138     // Removes gcEvents with lowest and highest gcID. This is used to filter out
139     // any incomplete GCs if the recording started/stopped in the middle of a GC.
140     // We also filters out events without gcId. Those events are not needed.
141     public static List&lt;RecordedEvent&gt; removeFirstAndLastGC(List&lt;RecordedEvent&gt; events) {
142         int minGcId = Integer.MAX_VALUE;
143         int maxGcId = Integer.MIN_VALUE;
144         // Find min/max gcId
145         for (RecordedEvent event : events) {
146             if (Events.hasField(event, &quot;gcId&quot;)) {
147                 int gcId = Events.assertField(event, &quot;gcId&quot;).getValue();
148                 minGcId = Math.min(gcId, minGcId);
149                 maxGcId = Math.max(gcId, maxGcId);
150             }
151         }
152 
153         // Add all events except those with gcId = min/max gcId
154         List&lt;RecordedEvent&gt; filteredEvents = new ArrayList&lt;&gt;();
155         for (RecordedEvent event : events) {
156             if (Events.hasField(event, &quot;gcId&quot;)) {
157                 int gcId = Events.assertField(event, &quot;gcId&quot;).getValue();
158                 if (gcId != minGcId &amp;&amp; gcId != maxGcId) {
159                     filteredEvents.add(event);
160                 }
161             }
162         }
163         return filteredEvents;
164     }
165 
166     public static Map&lt;String, Boolean&gt; beanCollectorTypes = new HashMap&lt;&gt;();
167     public static Set&lt;String&gt; collectorOverrides = new HashSet&lt;&gt;();
168     public static Map&lt;String, String[]&gt; requiredEvents = new HashMap&lt;&gt;();
169 
170     static {
171         // young GarbageCollectionMXBeans.
172         beanCollectorTypes.put(&quot;G1 Young Generation&quot;, true);
173         beanCollectorTypes.put(&quot;Copy&quot;, true);
174         beanCollectorTypes.put(&quot;PS Scavenge&quot;, true);
<a name="5" id="anc5"></a>
175 
176         // old GarbageCollectionMXBeans.
177         beanCollectorTypes.put(&quot;G1 Old Generation&quot;, false);
<a name="6" id="anc6"></a>
178         beanCollectorTypes.put(&quot;PS MarkSweep&quot;, false);
179         beanCollectorTypes.put(&quot;MarkSweepCompact&quot;, false);
180 
181         // List of expected collector overrides. &quot;A.B&quot; means that collector A may use collector B.
182         collectorOverrides.add(&quot;G1Old.G1Full&quot;);
<a name="7" id="anc7"></a>
183         collectorOverrides.add(&quot;SerialOld.PSMarkSweep&quot;);
184 
185         requiredEvents.put(gcG1New, new String[] {event_heap_summary, event_young_garbage_collection});
<a name="8" id="anc8"></a>
186         requiredEvents.put(gcDefNew, new String[] {event_heap_summary, event_heap_metaspace_summary, event_phases_pause, event_phases_level_1, event_young_garbage_collection});
187         requiredEvents.put(gcParallelScavenge, new String[] {event_heap_summary, event_heap_ps_summary, event_heap_metaspace_summary, event_reference_statistics, event_phases_pause, event_phases_level_1, event_young_garbage_collection});
188         requiredEvents.put(gcG1Old, new String[] {event_heap_summary, event_old_garbage_collection});
189         requiredEvents.put(gcG1Full, new String[] {event_heap_summary, event_heap_metaspace_summary, event_phases_pause, event_phases_level_1, event_old_garbage_collection});
<a name="9" id="anc9"></a>
190         requiredEvents.put(gcSerialOld, new String[] {event_heap_summary, event_heap_metaspace_summary, event_phases_pause, event_phases_level_1, event_old_garbage_collection});
191         requiredEvents.put(gcParallelOld, new String[] {event_heap_summary, event_heap_ps_summary, event_heap_metaspace_summary, event_reference_statistics, event_phases_pause, event_phases_level_1, event_old_garbage_collection, event_parold_garbage_collection});
192 
193         String[] g1HeapRegionTypeLiterals = new String[] {
194                                                            &quot;Free&quot;,
195                                                            &quot;Eden&quot;,
196                                                            &quot;Survivor&quot;,
197                                                            &quot;Starts Humongous&quot;,
198                                                            &quot;Continues Humongous&quot;,
199                                                            &quot;Old&quot;,
200                                                            &quot;Archive&quot;
201                                                          };
202 
203         g1HeapRegionTypes = Collections.unmodifiableList(Arrays.asList(g1HeapRegionTypeLiterals));
<a name="10" id="anc10"></a><span class="line-added">204 </span>
<span class="line-added">205         String[] shenandoahHeapRegionStateLiterals = new String[] {</span>
<span class="line-added">206                                                                     &quot;Empty Uncommitted&quot;,</span>
<span class="line-added">207                                                                     &quot;Empty Committed&quot;,</span>
<span class="line-added">208                                                                     &quot;Regular&quot;,</span>
<span class="line-added">209                                                                     &quot;Humongous Start&quot;,</span>
<span class="line-added">210                                                                     &quot;Humongous Continuation&quot;,</span>
<span class="line-added">211                                                                     &quot;Humongous Start, Pinned&quot;,</span>
<span class="line-added">212                                                                     &quot;Collection Set&quot;,</span>
<span class="line-added">213                                                                     &quot;Pinned&quot;,</span>
<span class="line-added">214                                                                     &quot;Collection Set, Pinned&quot;,</span>
<span class="line-added">215                                                                     &quot;Trash&quot;</span>
<span class="line-added">216         };</span>
<span class="line-added">217 </span>
<span class="line-added">218         shenandoahHeapRegionStates = Collections.unmodifiableList(Arrays.asList(shenandoahHeapRegionStateLiterals));</span>
219     }
220 
221     /**
222      * Contains all GC events belonging to the same GC (same gcId).
223      */
224     public static class GcBatch {
225         private List&lt;RecordedEvent&gt; events = new ArrayList&lt;&gt;();
226 
227         public int getGcId() {
228             if (events.isEmpty()) {
229                 return -1;
230             }
231             return GCHelper.getGcId(events.get(0));
232         }
233 
234         public String getName() {
235             RecordedEvent endEvent = getEndEvent();
236             String name = endEvent == null ? null : Events.assertField(endEvent, &quot;name&quot;).getValue();
237             return name == null ? &quot;null&quot; : name;
238         }
239 
240         public RecordedEvent getEndEvent() {
241             return getEvent(event_garbage_collection);
242         }
243 
244         public boolean addEvent(RecordedEvent event) {
245             if (!events.isEmpty()) {
246                 assertEquals(getGcId(), GCHelper.getGcId(event), &quot;Wrong gcId in event. Error in test code.&quot;);
247             }
248             boolean isEndEvent = event_garbage_collection.equals(event.getEventType().getName());
249             if (isEndEvent) {
250                 // Verify that we have not already got a garbage_collection event with this gcId.
251                 assertNull(getEndEvent(), String.format(&quot;Multiple %s for gcId %d&quot;, event_garbage_collection, getGcId()));
252             }
253             events.add(event);
254             return isEndEvent;
255         }
256 
257         public boolean isYoungCollection() {
258             boolean isYoung = containsEvent(event_young_garbage_collection);
259             boolean isOld = containsEvent(event_old_garbage_collection);
260             assertNotEquals(isYoung, isOld, &quot;isYoung and isOld was same for batch: &quot; + toString());
261             return isYoung;
262         }
263 
264         public int getEventCount() {
265             return events.size();
266         }
267 
268         public RecordedEvent getEvent(int index) {
269             return events.get(index);
270         }
271 
272         public List&lt;RecordedEvent&gt; getEvents() {
273             return events;
274         }
275 
276         public RecordedEvent getEvent(String eventPath) {
277             for (RecordedEvent event : events) {
278                 if (eventPath.equals(event.getEventType().getName())) {
279                     return event;
280                 }
281             }
282             return null;
283         }
284 
285         public boolean containsEvent(String eventPath) {
286             return getEvent(eventPath) != null;
287         }
288 
289         public String toString() {
290             RecordedEvent endEvent = getEndEvent();
291             Instant startTime = Instant.EPOCH;
292             String cause = &quot;?&quot;;
293             String name = &quot;?&quot;;
294             if (endEvent != null) {
295                 name = getName();
296                 startTime = endEvent.getStartTime();
297                 cause = Events.assertField(endEvent, &quot;cause&quot;).getValue();
298             }
299             return String.format(&quot;GcEvent: gcId=%d, method=%s, cause=%s, startTime=%s&quot;,
300                     getGcId(), name, cause, startTime);
301         }
302 
303         public String getLog() {
304             StringBuilder sb = new StringBuilder();
305             sb.append(this.toString() + System.getProperty(&quot;line.separator&quot;));
306             for (RecordedEvent event : events) {
307                 sb.append(String.format(&quot;event: %s%n&quot;, event));
308             }
309             return sb.toString();
310         }
311 
312         // Group all events info batches.
313         public static List&lt;GcBatch&gt; createFromEvents(List&lt;RecordedEvent&gt; events) throws Exception {
314             Stack&lt;Integer&gt; openGcIds = new Stack&lt;&gt;();
315             List&lt;GcBatch&gt; batches = new ArrayList&lt;&gt;();
316             GcBatch currBatch = null;
317 
318             for (RecordedEvent event : events) {
319                 if (!isGcEvent(event)) {
320                     continue;
321                 }
322                 int gcId = GCHelper.getGcId(event);
323                 if (currBatch == null || currBatch.getGcId() != gcId) {
324                     currBatch = null;
325                     // Search for existing batch
326                     for (GcBatch loopBatch : batches) {
327                         if (gcId == loopBatch.getGcId()) {
328                             currBatch = loopBatch;
329                             break;
330                         }
331                     }
332                     if (currBatch == null) {
333                         // No existing batch. Create new.
334                         currBatch = new GcBatch();
335                         batches.add(currBatch);
336                         openGcIds.push(new Integer(gcId));
337                     }
338                 }
339                 boolean isEndEvent = currBatch.addEvent(event);
340                 if (isEndEvent) {
341                     openGcIds.pop();
342                 }
343             }
344             // Verify that all start_garbage_collection events have received a corresponding &quot;garbage_collection&quot; event.
345             for (GcBatch batch : batches) {
346                 if (batch.getEndEvent() == null) {
347                     System.out.println(batch.getLog());
348                 }
349                 assertNotNull(batch.getEndEvent(), &quot;GcBatch has no end event&quot;);
350             }
351             return batches;
352         }
353     }
354 
355     /**
356      * Contains number of collections and sum pause time for young and old collections.
357      */
358     public static class CollectionSummary {
359         public long collectionCountOld;
360         public long collectionCountYoung;
361         public long collectionTimeOld;
362         public long collectionTimeYoung;
363         private Set&lt;String&gt; names = new HashSet&lt;&gt;();
364 
365         public void add(String collectorName, boolean isYoung, long count, long time) {
366             if (isYoung) {
367                 collectionCountYoung += count;
368                 collectionTimeYoung += time;
369             } else {
370                 collectionCountOld += count;
371                 collectionTimeOld += time;
372             }
373             if (!names.contains(collectorName)) {
374                 names.add(collectorName);
375             }
376         }
377 
378         public long sum() {
379             return collectionCountOld + collectionCountYoung;
380         }
381 
382         public CollectionSummary calcDelta(CollectionSummary prev) {
383             CollectionSummary delta = new CollectionSummary();
384             delta.collectionCountOld = this.collectionCountOld - prev.collectionCountOld;
385             delta.collectionTimeOld = this.collectionTimeOld - prev.collectionTimeOld;
386             delta.collectionCountYoung = this.collectionCountYoung - prev.collectionCountYoung;
387             delta.collectionTimeYoung = this.collectionTimeYoung - prev.collectionTimeYoung;
388             delta.names.addAll(this.names);
389             delta.names.addAll(prev.names);
390             return delta;
391         }
392 
393         public static CollectionSummary createFromMxBeans() {
394             CollectionSummary summary = new CollectionSummary();
395             List&lt;GarbageCollectorMXBean&gt; gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
396             for (int c=0; c&lt;gcBeans.size(); c++) {
397                 GarbageCollectorMXBean currBean = gcBeans.get(c);
398                 Boolean isYoung = beanCollectorTypes.get(currBean.getName());
399                 assertNotNull(isYoung, &quot;Unknown MXBean name: &quot; + currBean.getName());
400                 long collectionTime = currBean.getCollectionTime() * 1000; // Convert from millis to micros.
401                 summary.add(currBean.getName(), isYoung.booleanValue(), currBean.getCollectionCount(), collectionTime);
402             }
403             return summary;
404         }
405 
406         public static CollectionSummary createFromEvents(List&lt;GcBatch&gt; batches) {
407             CollectionSummary summary = new CollectionSummary();
408             for (GcBatch batch : batches) {
409                 RecordedEvent endEvent = batch.getEndEvent();
410                 assertNotNull(endEvent, &quot;No end event in batch with gcId &quot; + batch.getGcId());
411                 String name = batch.getName();
412                 summary.add(name, batch.isYoungCollection(), 1, Events.assertField(endEvent, &quot;sumOfPauses&quot;).getValue());
413             }
414             return summary;
415         }
416 
417         public String toString() {
418             StringBuilder collectorNames = new StringBuilder();
419             for (String s : names) {
420                 if (collectorNames.length() &gt; 0) {
421                     collectorNames.append(&quot;, &quot;);
422                 }
423                 collectorNames.append(s);
424             }
425             return String.format(&quot;CollectionSummary: young.collections=%d, young.time=%d, old.collections=%d, old.time=%d, collectors=(%s)&quot;,
426                     collectionCountYoung, collectionTimeYoung, collectionCountOld, collectionTimeOld, collectorNames);
427         }
428     }
429 
430     public static PrintStream getDefaultErrorLog() {
431         if (defaultErrorLog == null) {
432             try {
433                 defaultErrorLog = new PrintStream(new FileOutputStream(&quot;error.log&quot;, true));
434             } catch (IOException e) {
435                 e.printStackTrace();
436                 defaultErrorLog = System.err;
437             }
438         }
439         return defaultErrorLog;
440     }
441 
442     public static void log(Object msg) {
443         log(msg, System.err);
444         log(msg, getDefaultErrorLog());
445     }
446 
447     public static void log(Object msg, PrintStream ps) {
448         ps.println(msg);
449     }
450 
451     public static boolean isValidG1HeapRegionType(final String type) {
452         return g1HeapRegionTypes.contains(type);
453     }
454 
<a name="11" id="anc11"></a><span class="line-added">455     public static boolean assertIsValidShenandoahHeapRegionState(final String state) {</span>
<span class="line-added">456         if (!shenandoahHeapRegionStates.contains(state)) {</span>
<span class="line-added">457             throw new AssertionError(&quot;Unknown state &#39;&quot; + state + &quot;&#39;, valid heap region states are &quot; + shenandoahHeapRegionStates);</span>
<span class="line-added">458         }</span>
<span class="line-added">459         return true;</span>
<span class="line-added">460     }</span>
<span class="line-added">461 </span>
462     /**
463      * Helper function to align heap size up.
464      *
465      * @param value
466      * @param alignment
467      * @return aligned value
468      */
469     public static long alignUp(long value, long alignment) {
470         return (value + alignment - 1) &amp; ~(alignment - 1);
471     }
472 
473     /**
474      * Helper function to align heap size down.
475      *
476      * @param value
477      * @param alignment
478      * @return aligned value
479      */
480     public static long alignDown(long value, long alignment) {
481         return value &amp; ~(alignment - 1);
482     }
483 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
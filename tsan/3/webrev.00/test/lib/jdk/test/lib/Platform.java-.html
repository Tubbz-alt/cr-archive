<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/lib/jdk/test/lib/Platform.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib;
 25 
 26 import java.io.File;
 27 import java.io.IOException;
 28 import java.io.RandomAccessFile;
 29 import java.util.regex.Pattern;
 30 import java.security.AccessController;
 31 import java.security.PrivilegedAction;
 32 import java.security.PrivilegedActionException;
 33 import java.security.PrivilegedExceptionAction;
 34 
 35 public class Platform {
 36     public  static final String vmName      = privilegedGetProperty(&quot;java.vm.name&quot;);
 37     public  static final String vmInfo      = privilegedGetProperty(&quot;java.vm.info&quot;);
 38     private static final String osVersion   = privilegedGetProperty(&quot;os.version&quot;);
 39     private static       int osVersionMajor = -1;
 40     private static       int osVersionMinor = -1;
 41     private static final String osName      = privilegedGetProperty(&quot;os.name&quot;);
 42     private static final String dataModel   = privilegedGetProperty(&quot;sun.arch.data.model&quot;);
 43     private static final String vmVersion   = privilegedGetProperty(&quot;java.vm.version&quot;);
 44     private static final String jdkDebug    = privilegedGetProperty(&quot;jdk.debug&quot;);
 45     private static final String osArch      = privilegedGetProperty(&quot;os.arch&quot;);
 46     private static final String userName    = privilegedGetProperty(&quot;user.name&quot;);
 47     private static final String compiler    = privilegedGetProperty(&quot;sun.management.compiler&quot;);
 48 
 49     private static String privilegedGetProperty(String key) {
 50         return AccessController.doPrivileged((
 51                 PrivilegedAction&lt;String&gt;) () -&gt; System.getProperty(key));
 52     }
 53 
 54     public static boolean isClient() {
 55         return vmName.endsWith(&quot; Client VM&quot;);
 56     }
 57 
 58     public static boolean isServer() {
 59         return vmName.endsWith(&quot; Server VM&quot;);
 60     }
 61 
 62     public static boolean isGraal() {
 63         return vmName.endsWith(&quot; Graal VM&quot;);
 64     }
 65 
 66     public static boolean isZero() {
 67         return vmName.endsWith(&quot; Zero VM&quot;);
 68     }
 69 
 70     public static boolean isMinimal() {
 71         return vmName.endsWith(&quot; Minimal VM&quot;);
 72     }
 73 
 74     public static boolean isEmbedded() {
 75         return vmName.contains(&quot;Embedded&quot;);
 76     }
 77 
 78     public static boolean isEmulatedClient() {
 79         return vmInfo.contains(&quot; emulated-client&quot;);
 80     }
 81 
 82     public static boolean isTieredSupported() {
 83         return compiler.contains(&quot;Tiered Compilers&quot;);
 84     }
 85 
 86     public static boolean isInt() {
 87         return vmInfo.contains(&quot;interpreted&quot;);
 88     }
 89 
 90     public static boolean isMixed() {
 91         return vmInfo.contains(&quot;mixed&quot;);
 92     }
 93 
 94     public static boolean isComp() {
 95         return vmInfo.contains(&quot;compiled&quot;);
 96     }
 97 
 98     public static boolean is32bit() {
 99         return dataModel.equals(&quot;32&quot;);
100     }
101 
102     public static boolean is64bit() {
103         return dataModel.equals(&quot;64&quot;);
104     }
105 
106     public static boolean isAix() {
107         return isOs(&quot;aix&quot;);
108     }
109 
110     public static boolean isLinux() {
111         return isOs(&quot;linux&quot;);
112     }
113 
114     public static boolean isOSX() {
115         return isOs(&quot;mac&quot;);
116     }
117 
118     public static boolean isSolaris() {
119         return isOs(&quot;sunos&quot;);
120     }
121 
122     public static boolean isWindows() {
123         return isOs(&quot;win&quot;);
124     }
125 
126     private static boolean isOs(String osname) {
127         return osName.toLowerCase().startsWith(osname.toLowerCase());
128     }
129 
130     public static String getOsName() {
131         return osName;
132     }
133 
134     // Os version support.
135     private static void init_version() {
136         String[] osVersionTokens = osVersion.split(&quot;\\.&quot;);
137         try {
138             if (osVersionTokens.length &gt; 0) {
139                 osVersionMajor = Integer.parseInt(osVersionTokens[0]);
140                 if (osVersionTokens.length &gt; 1) {
141                     osVersionMinor = Integer.parseInt(osVersionTokens[1]);
142                 }
143             }
144         } catch (NumberFormatException e) {
145             osVersionMajor = osVersionMinor = 0;
146         }
147     }
148 
149     public static String getOsVersion() {
150         return osVersion;
151     }
152 
153     // Returns major version number from os.version system property.
154     // E.g. 5 on Solaris 10 and 3 on SLES 11.3 (for the linux kernel version).
155     public static int getOsVersionMajor() {
156         if (osVersionMajor == -1) init_version();
157         return osVersionMajor;
158     }
159 
160     // Returns minor version number from os.version system property.
161     // E.g. 10 on Solaris 10 and 0 on SLES 11.3 (for the linux kernel version).
162     public static int getOsVersionMinor() {
163         if (osVersionMinor == -1) init_version();
164         return osVersionMinor;
165     }
166 
167     public static boolean isDebugBuild() {
168         return (jdkDebug.toLowerCase().contains(&quot;debug&quot;));
169     }
170 
171     public static boolean isSlowDebugBuild() {
172         return (jdkDebug.toLowerCase().equals(&quot;slowdebug&quot;));
173     }
174 
175     public static boolean isFastDebugBuild() {
176         return (jdkDebug.toLowerCase().equals(&quot;fastdebug&quot;));
177     }
178 
179     public static String getVMVersion() {
180         return vmVersion;
181     }
182 
183     public static boolean isAArch64() {
184         return isArch(&quot;aarch64&quot;);
185     }
186 
187     public static boolean isARM() {
188         return isArch(&quot;arm.*&quot;);
189     }
190 
191     public static boolean isPPC() {
192         return isArch(&quot;ppc.*&quot;);
193     }
194 
195     // Returns true for IBM z System running linux.
196     public static boolean isS390x() {
197         return isArch(&quot;s390.*&quot;) || isArch(&quot;s/390.*&quot;) || isArch(&quot;zArch_64&quot;);
198     }
199 
200     // Returns true for sparc and sparcv9.
201     public static boolean isSparc() {
202         return isArch(&quot;sparc.*&quot;);
203     }
204 
205     public static boolean isX64() {
206         // On OSX it&#39;s &#39;x86_64&#39; and on other (Linux, Windows and Solaris) platforms it&#39;s &#39;amd64&#39;
207         return isArch(&quot;(amd64)|(x86_64)&quot;);
208     }
209 
210     public static boolean isX86() {
211         // On Linux it&#39;s &#39;i386&#39;, Windows &#39;x86&#39; without &#39;_64&#39; suffix.
212         return isArch(&quot;(i386)|(x86(?!_64))&quot;);
213     }
214 
215     public static String getOsArch() {
216         return osArch;
217     }
218 
219     /**
220      * Return a boolean for whether SA and jhsdb are ported/available
221      * on this platform.
222      */
223     public static boolean hasSA() {
224         if (isAix()) {
225             return false; // SA not implemented.
226         } else if (isLinux()) {
227             if (isS390x() || isARM()) {
228                 return false; // SA not implemented.
229             }
230         }
231         // Other platforms expected to work:
232         return true;
233     }
234 
235     /**
236      * Return a boolean for whether we expect to be able to attach
237      * the SA to our own processes on this system.  This requires
238      * that SA is ported/available on this platform.
239      */
240     public static boolean shouldSAAttach() throws IOException {
241         if (!hasSA()) return false;
242         if (isLinux()) {
243             return canPtraceAttachLinux();
244         } else if (isOSX()) {
245             return canAttachOSX();
246         } else {
247             // Other platforms expected to work:
248             return true;
249         }
250     }
251 
252     /**
253      * On Linux, first check the SELinux boolean &quot;deny_ptrace&quot; and return false
254      * as we expect to be denied if that is &quot;1&quot;.  Then expect permission to attach
255      * if we are root, so return true.  Then return false for an expected denial
256      * if &quot;ptrace_scope&quot; is 1, and true otherwise.
257      */
258     private static boolean canPtraceAttachLinux() throws IOException {
259         // SELinux deny_ptrace:
260         File deny_ptrace = new File(&quot;/sys/fs/selinux/booleans/deny_ptrace&quot;);
261         if (deny_ptrace.exists()) {
262             try (RandomAccessFile file = AccessController.doPrivileged(
263                     (PrivilegedExceptionAction&lt;RandomAccessFile&gt;) () -&gt; new RandomAccessFile(deny_ptrace, &quot;r&quot;))) {
264                 if (file.readByte() != &#39;0&#39;) {
265                     return false;
266                 }
267             } catch (PrivilegedActionException e) {
268                 @SuppressWarnings(&quot;unchecked&quot;)
269                 IOException t = (IOException) e.getException();
270                 throw t;
271             }
272         }
273 
274         // YAMA enhanced security ptrace_scope:
275         // 0 - a process can PTRACE_ATTACH to any other process running under the same uid
276         // 1 - restricted ptrace: a process must be a children of the inferior or user is root
277         // 2 - only processes with CAP_SYS_PTRACE may use ptrace or user is root
278         // 3 - no attach: no processes may use ptrace with PTRACE_ATTACH
279         File ptrace_scope = new File(&quot;/proc/sys/kernel/yama/ptrace_scope&quot;);
280         if (ptrace_scope.exists()) {
281             try (RandomAccessFile file = AccessController.doPrivileged(
282                     (PrivilegedExceptionAction&lt;RandomAccessFile&gt;) () -&gt; new RandomAccessFile(ptrace_scope, &quot;r&quot;))) {
283                 byte yama_scope = file.readByte();
284                 if (yama_scope == &#39;3&#39;) {
285                     return false;
286                 }
287 
288                 if (!userName.equals(&quot;root&quot;) &amp;&amp; yama_scope != &#39;0&#39;) {
289                     return false;
290                 }
291             } catch (PrivilegedActionException e) {
292                 @SuppressWarnings(&quot;unchecked&quot;)
293                 IOException t = (IOException) e.getException();
294                 throw t;
295             }
296         }
297         // Otherwise expect to be permitted:
298         return true;
299     }
300 
301     /**
302      * On OSX, expect permission to attach only if we are root.
303      */
304     private static boolean canAttachOSX() {
305         return userName.equals(&quot;root&quot;);
306     }
307 
308     private static boolean isArch(String archnameRE) {
309         return Pattern.compile(archnameRE, Pattern.CASE_INSENSITIVE)
310                       .matcher(osArch)
311                       .matches();
312     }
313 
314     /**
315      * Returns file extension of shared library, e.g. &quot;so&quot; on linux, &quot;dll&quot; on windows.
316      * @return file extension
317      */
318     public static String sharedLibraryExt() {
319         if (isWindows()) {
320             return &quot;dll&quot;;
321         } else if (isOSX()) {
322             return &quot;dylib&quot;;
323         } else {
324             return &quot;so&quot;;
325         }
326     }
327 
328     /*
329      * Returns name of system variable containing paths to shared native libraries.
330      */
331     public static String sharedLibraryPathVariableName() {
332         if (isWindows()) {
333             return &quot;PATH&quot;;
334         } else if (isOSX()) {
335             return &quot;DYLD_LIBRARY_PATH&quot;;
336         } else if (isAix()) {
337             return &quot;LIBPATH&quot;;
338         } else {
339             return &quot;LD_LIBRARY_PATH&quot;;
340         }
341     }
342 
343     public static boolean isDefaultCDSArchiveSupported() {
344         return (is64bit()  &amp;&amp;
345                 isServer() &amp;&amp;
346                 (isLinux()   ||
347                  isOSX()     ||
348                  isSolaris() ||
349                  isWindows()) &amp;&amp;
350                 !isZero()    &amp;&amp;
351                 !isMinimal() &amp;&amp;
352                 !isAArch64() &amp;&amp;
353                 !isARM());
354     }
355 
356     /*
357      * This should match the #if condition in ClassListParser::load_class_from_source().
358      */
359     public static boolean areCustomLoadersSupportedForCDS() {
360         return (is64bit() &amp;&amp; (isLinux() || isSolaris() || isOSX()));
361     }
362 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/lib/jdk/test/lib/process/OutputAnalyzer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../jfr/GCHelper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="OutputBuffer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/lib/jdk/test/lib/process/OutputAnalyzer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.process;
 25 
 26 import jdk.test.lib.Asserts;
 27 
 28 import java.io.IOException;
 29 import java.io.PrintStream;



 30 import java.util.Arrays;
 31 import java.util.List;
 32 import java.util.stream.Collectors;
 33 import java.util.regex.Matcher;
 34 import java.util.regex.Pattern;
 35 
 36 public final class OutputAnalyzer {
 37 
 38     private final OutputBuffer buffer;












 39     /**
 40      * Create an OutputAnalyzer, a utility class for verifying output and exit
 41      * value from a Process
 42      *
 43      * @param process Process to analyze
 44      * @throws IOException If an I/O error occurs.
 45      */
 46     public OutputAnalyzer(Process process) throws IOException {
 47         buffer = OutputBuffer.of(process);
 48     }
 49 
 50     /**
 51      * Create an OutputAnalyzer, a utility class for verifying output
 52      *
 53      * @param buf String buffer to analyze
 54      */
 55     public OutputAnalyzer(String buf) {
 56         buffer = OutputBuffer.of(buf, buf);
 57     }
 58 









 59     /**
 60      * Create an OutputAnalyzer, a utility class for verifying output
 61      *
 62      * @param stdout stdout buffer to analyze
 63      * @param stderr stderr buffer to analyze
 64      */
 65     public OutputAnalyzer(String stdout, String stderr) {
 66         buffer = OutputBuffer.of(stdout, stderr);
 67     }
 68 












 69     /**
 70      * Verify that the stdout contents of output buffer is empty
 71      *
 72      * @throws RuntimeException
 73      *             If stdout was not empty
 74      */
 75     public OutputAnalyzer stdoutShouldBeEmpty() {
 76         if (!getStdout().isEmpty()) {
 77             reportDiagnosticSummary();
 78             throw new RuntimeException(&quot;stdout was not empty&quot;);
 79         }
 80         return this;
 81     }
 82 
 83     /**
 84      * Verify that the stderr contents of output buffer is empty
 85      *
 86      * @throws RuntimeException
 87      *             If stderr was not empty
 88      */
</pre>
<hr />
<pre>
595     /**
596      * @see #shouldMatchByLine(String, String, String)
597      */
598     public OutputAnalyzer shouldMatchByLineFrom(String from, String pattern) {
599         return shouldMatchByLine(from, null, pattern);
600     }
601 
602     /**
603      * @see #shouldMatchByLine(String, String, String)
604      */
605     public OutputAnalyzer shouldMatchByLineTo(String to, String pattern) {
606         return shouldMatchByLine(null, to, pattern);
607     }
608 
609     /**
610      * Verify that the stdout and stderr contents of output buffer match the
611      * {@code pattern} line by line. The whole output could be matched or
612      * just a subset of it.
613      *
614      * @param from
<span class="line-modified">615      *            The line from where output will be matched.</span>
616      *            Set {@code from} to null for matching from the first line.
617      * @param to
<span class="line-modified">618      *            The line until where output will be matched.</span>
619      *            Set {@code to} to null for matching until the last line.
620      * @param pattern
621      *            Matching pattern
622      */
623     public OutputAnalyzer shouldMatchByLine(String from, String to, String pattern) {
624         return shouldMatchByLine(getOutput(), from, to, pattern);
625     }
626 
627     /**
628      * Verify that the stdout contents of output buffer matches the
629      * {@code pattern} line by line. The whole stdout could be matched or
630      * just a subset of it.
631      *
632      * @param from
<span class="line-modified">633      *            The line from where stdout will be matched.</span>
634      *            Set {@code from} to null for matching from the first line.
635      * @param to
<span class="line-modified">636      *            The line until where stdout will be matched.</span>
637      *            Set {@code to} to null for matching until the last line.
638      * @param pattern
639      *            Matching pattern
640      */
641     public OutputAnalyzer stdoutShouldMatchByLine(String from, String to, String pattern) {
642         return shouldMatchByLine(getStdout(), from, to, pattern);
643     }
644 
645     private OutputAnalyzer shouldMatchByLine(String buffer, String from, String to, String pattern) {
646         List&lt;String&gt; lines = asLines(buffer);
647 
648         int fromIndex = 0;
649         if (from != null) {
<span class="line-modified">650             fromIndex = indexOf(lines, from);</span>
<span class="line-modified">651             Asserts.assertGreaterThan(fromIndex, -1,</span>
652                     &quot;The line/pattern &#39;&quot; + from + &quot;&#39; from where the output should match can not be found&quot;);
653         }
654 
655         int toIndex = lines.size();
656         if (to != null) {
<span class="line-modified">657             toIndex = indexOf(lines, to);</span>
<span class="line-modified">658             Asserts.assertGreaterThan(toIndex, -1,</span>
659                     &quot;The line/pattern &#39;&quot; + to + &quot;&#39; until where the output should match can not be found&quot;);
660         }
661 
662         List&lt;String&gt; subList = lines.subList(fromIndex, toIndex);
<span class="line-modified">663         Asserts.assertFalse(subList.isEmpty(), &quot;There are no lines to check&quot;);</span>

664 
665         subList.stream()
666                .filter(Pattern.compile(pattern).asPredicate().negate())
667                .findAny()
<span class="line-modified">668                .ifPresent(line -&gt; Asserts.assertTrue(false,</span>
669                        &quot;The line &#39;&quot; + line + &quot;&#39; does not match pattern &#39;&quot; + pattern + &quot;&#39;&quot;));
670 
671         return this;
672     }
673 
674     /**
675      * Check if there is a line matching {@code regexp} and return its index
676      *
677      * @param regexp Matching pattern

678      * @return Index of first matching line
679      */
<span class="line-modified">680     private int indexOf(List&lt;String&gt; lines, String regexp) {</span>
681         Pattern pattern = Pattern.compile(regexp);
<span class="line-modified">682         for (int i = 0; i &lt; lines.size(); i++) {</span>
683             if (pattern.matcher(lines.get(i)).matches()) {
684                 return i;
685             }
686         }
687         return -1;
688     }
689 
690 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.process;
 25 
 26 import jdk.test.lib.Asserts;
 27 
 28 import java.io.IOException;
 29 import java.io.PrintStream;
<span class="line-added"> 30 import java.nio.charset.Charset;</span>
<span class="line-added"> 31 import java.nio.file.Files;</span>
<span class="line-added"> 32 import java.nio.file.Path;</span>
 33 import java.util.Arrays;
 34 import java.util.List;
 35 import java.util.stream.Collectors;
 36 import java.util.regex.Matcher;
 37 import java.util.regex.Pattern;
 38 
 39 public final class OutputAnalyzer {
 40 
 41     private final OutputBuffer buffer;
<span class="line-added"> 42     /**</span>
<span class="line-added"> 43      * Create an OutputAnalyzer, a utility class for verifying output and exit</span>
<span class="line-added"> 44      * value from a Process</span>
<span class="line-added"> 45      *</span>
<span class="line-added"> 46      * @param process Process to analyze</span>
<span class="line-added"> 47      * @param cs The charset used to convert stdout/stderr from bytes to chars</span>
<span class="line-added"> 48      *           or null for the default charset.</span>
<span class="line-added"> 49      * @throws IOException If an I/O error occurs.</span>
<span class="line-added"> 50      */</span>
<span class="line-added"> 51     public OutputAnalyzer(Process process, Charset cs) throws IOException {</span>
<span class="line-added"> 52         buffer = OutputBuffer.of(process, cs);</span>
<span class="line-added"> 53     }</span>
 54     /**
 55      * Create an OutputAnalyzer, a utility class for verifying output and exit
 56      * value from a Process
 57      *
 58      * @param process Process to analyze
 59      * @throws IOException If an I/O error occurs.
 60      */
 61     public OutputAnalyzer(Process process) throws IOException {
 62         buffer = OutputBuffer.of(process);
 63     }
 64 
 65     /**
 66      * Create an OutputAnalyzer, a utility class for verifying output
 67      *
 68      * @param buf String buffer to analyze
 69      */
 70     public OutputAnalyzer(String buf) {
 71         buffer = OutputBuffer.of(buf, buf);
 72     }
 73 
<span class="line-added"> 74     /**</span>
<span class="line-added"> 75      * Create an OutputAnalyzer, a utility class for verifying output</span>
<span class="line-added"> 76      *</span>
<span class="line-added"> 77      * @param file File to analyze</span>
<span class="line-added"> 78      */</span>
<span class="line-added"> 79     public OutputAnalyzer(Path file) throws IOException {</span>
<span class="line-added"> 80         this(Files.readString(file));</span>
<span class="line-added"> 81     }</span>
<span class="line-added"> 82 </span>
 83     /**
 84      * Create an OutputAnalyzer, a utility class for verifying output
 85      *
 86      * @param stdout stdout buffer to analyze
 87      * @param stderr stderr buffer to analyze
 88      */
 89     public OutputAnalyzer(String stdout, String stderr) {
 90         buffer = OutputBuffer.of(stdout, stderr);
 91     }
 92 
<span class="line-added"> 93     /**</span>
<span class="line-added"> 94      * Create an OutputAnalyzer, a utility class for verifying output</span>
<span class="line-added"> 95      *</span>
<span class="line-added"> 96      * @param stdout stdout buffer to analyze</span>
<span class="line-added"> 97      * @param stderr stderr buffer to analyze</span>
<span class="line-added"> 98      * @param stderr exitValue result to analyze</span>
<span class="line-added"> 99      */</span>
<span class="line-added">100     public OutputAnalyzer(String stdout, String stderr, int exitValue)</span>
<span class="line-added">101     {</span>
<span class="line-added">102         buffer = OutputBuffer.of(stdout, stderr, exitValue);</span>
<span class="line-added">103     }</span>
<span class="line-added">104 </span>
105     /**
106      * Verify that the stdout contents of output buffer is empty
107      *
108      * @throws RuntimeException
109      *             If stdout was not empty
110      */
111     public OutputAnalyzer stdoutShouldBeEmpty() {
112         if (!getStdout().isEmpty()) {
113             reportDiagnosticSummary();
114             throw new RuntimeException(&quot;stdout was not empty&quot;);
115         }
116         return this;
117     }
118 
119     /**
120      * Verify that the stderr contents of output buffer is empty
121      *
122      * @throws RuntimeException
123      *             If stderr was not empty
124      */
</pre>
<hr />
<pre>
631     /**
632      * @see #shouldMatchByLine(String, String, String)
633      */
634     public OutputAnalyzer shouldMatchByLineFrom(String from, String pattern) {
635         return shouldMatchByLine(from, null, pattern);
636     }
637 
638     /**
639      * @see #shouldMatchByLine(String, String, String)
640      */
641     public OutputAnalyzer shouldMatchByLineTo(String to, String pattern) {
642         return shouldMatchByLine(null, to, pattern);
643     }
644 
645     /**
646      * Verify that the stdout and stderr contents of output buffer match the
647      * {@code pattern} line by line. The whole output could be matched or
648      * just a subset of it.
649      *
650      * @param from
<span class="line-modified">651      *            The line (excluded) from where output will be matched.</span>
652      *            Set {@code from} to null for matching from the first line.
653      * @param to
<span class="line-modified">654      *            The line (excluded) until where output will be matched.</span>
655      *            Set {@code to} to null for matching until the last line.
656      * @param pattern
657      *            Matching pattern
658      */
659     public OutputAnalyzer shouldMatchByLine(String from, String to, String pattern) {
660         return shouldMatchByLine(getOutput(), from, to, pattern);
661     }
662 
663     /**
664      * Verify that the stdout contents of output buffer matches the
665      * {@code pattern} line by line. The whole stdout could be matched or
666      * just a subset of it.
667      *
668      * @param from
<span class="line-modified">669      *            The line (excluded) from where stdout will be matched.</span>
670      *            Set {@code from} to null for matching from the first line.
671      * @param to
<span class="line-modified">672      *            The line (excluded) until where stdout will be matched.</span>
673      *            Set {@code to} to null for matching until the last line.
674      * @param pattern
675      *            Matching pattern
676      */
677     public OutputAnalyzer stdoutShouldMatchByLine(String from, String to, String pattern) {
678         return shouldMatchByLine(getStdout(), from, to, pattern);
679     }
680 
681     private OutputAnalyzer shouldMatchByLine(String buffer, String from, String to, String pattern) {
682         List&lt;String&gt; lines = asLines(buffer);
683 
684         int fromIndex = 0;
685         if (from != null) {
<span class="line-modified">686             fromIndex = indexOf(lines, from, 0) + 1; // + 1 -&gt; apply &#39;pattern&#39; to lines after &#39;from&#39; match</span>
<span class="line-modified">687             Asserts.assertGreaterThan(fromIndex, 0,</span>
688                     &quot;The line/pattern &#39;&quot; + from + &quot;&#39; from where the output should match can not be found&quot;);
689         }
690 
691         int toIndex = lines.size();
692         if (to != null) {
<span class="line-modified">693             toIndex = indexOf(lines, to, fromIndex);</span>
<span class="line-modified">694             Asserts.assertGreaterThan(toIndex, fromIndex,</span>
695                     &quot;The line/pattern &#39;&quot; + to + &quot;&#39; until where the output should match can not be found&quot;);
696         }
697 
698         List&lt;String&gt; subList = lines.subList(fromIndex, toIndex);
<span class="line-modified">699         Asserts.assertFalse(subList.isEmpty(), &quot;There are no lines to check:&quot;</span>
<span class="line-added">700                 + &quot; range &quot; + fromIndex + &quot;..&quot; + toIndex + &quot;, subList = &quot; + subList);</span>
701 
702         subList.stream()
703                .filter(Pattern.compile(pattern).asPredicate().negate())
704                .findAny()
<span class="line-modified">705                .ifPresent(line -&gt; Asserts.fail(</span>
706                        &quot;The line &#39;&quot; + line + &quot;&#39; does not match pattern &#39;&quot; + pattern + &quot;&#39;&quot;));
707 
708         return this;
709     }
710 
711     /**
712      * Check if there is a line matching {@code regexp} and return its index
713      *
714      * @param regexp Matching pattern
<span class="line-added">715      * @param fromIndex Start matching after so many lines skipped</span>
716      * @return Index of first matching line
717      */
<span class="line-modified">718     private int indexOf(List&lt;String&gt; lines, String regexp, int fromIndex) {</span>
719         Pattern pattern = Pattern.compile(regexp);
<span class="line-modified">720         for (int i = fromIndex; i &lt; lines.size(); i++) {</span>
721             if (pattern.matcher(lines.get(i)).matches()) {
722                 return i;
723             }
724         }
725         return -1;
726     }
727 
728 }
</pre>
</td>
</tr>
</table>
<center><a href="../jfr/GCHelper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="OutputBuffer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/lib/jdk/test/lib/containers/docker/DockerTestUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DockerRunOptions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../jfr/EventNames.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/lib/jdk/test/lib/containers/docker/DockerTestUtils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.containers.docker;
 25 
 26 import java.io.File;

 27 import java.io.IOException;
 28 import java.nio.file.Files;
 29 import java.nio.file.FileVisitResult;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.nio.file.SimpleFileVisitor;
 33 import java.nio.file.StandardCopyOption;
 34 import java.nio.file.attribute.BasicFileAttributes;

 35 import java.util.ArrayList;
 36 import java.util.Collections;
 37 import java.util.List;
<span class="line-modified"> 38 import jdk.test.lib.Platform;</span>
 39 import jdk.test.lib.Utils;
 40 import jdk.test.lib.process.OutputAnalyzer;
<span class="line-modified"> 41 import jdk.test.lib.process.ProcessTools;</span>
 42 
 43 
 44 public class DockerTestUtils {
<span class="line-removed"> 45     private static final String FS = File.separator;</span>
 46     private static boolean isDockerEngineAvailable = false;
 47     private static boolean wasDockerEngineChecked = false;
 48 
<span class="line-modified"> 49     // Diagnostics: set to true to enable more diagnostic info</span>
<span class="line-modified"> 50     private static final boolean DEBUG = false;</span>
















 51 
 52     /**
 53      * Optimized check of whether the docker engine is available in a given
 54      * environment. Checks only once, then remembers the result in a singleton.
 55      *
 56      * @return true if docker engine is available
 57      * @throws Exception
 58      */
 59     public static boolean isDockerEngineAvailable() throws Exception {
 60         if (wasDockerEngineChecked)
 61             return isDockerEngineAvailable;
 62 
 63         isDockerEngineAvailable = isDockerEngineAvailableCheck();
 64         wasDockerEngineChecked = true;
 65         return isDockerEngineAvailable;
 66     }
 67 
 68 
 69     /**
 70      * Convenience method, will check if docker engine is available and usable;
 71      * will print the appropriate message when not available.
 72      *
 73      * @return true if docker engine is available
 74      * @throws Exception
 75      */
 76     public static boolean canTestDocker() throws Exception {
 77         if (isDockerEngineAvailable()) {
 78             return true;
 79         } else {
<span class="line-modified"> 80             System.out.println(&quot;Docker engine is not available on this system&quot;);</span>
<span class="line-removed"> 81             System.out.println(&quot;This test is SKIPPED&quot;);</span>
<span class="line-removed"> 82             return false;</span>
 83         }
 84     }
 85 
 86 
 87     /**
 88      * Simple check - is docker engine available, accessible and usable.
 89      * Run basic docker command: &#39;docker ps&#39; - list docker instances.
 90      * If docker engine is available and accesible then true is returned
 91      * and we can proceed with testing docker.
 92      *
 93      * @return true if docker engine is available and usable
 94      * @throws Exception
 95      */
 96     private static boolean isDockerEngineAvailableCheck() throws Exception {
 97         try {
<span class="line-modified"> 98             execute(&quot;docker&quot;, &quot;ps&quot;)</span>
 99                 .shouldHaveExitValue(0)
100                 .shouldContain(&quot;CONTAINER&quot;)
101                 .shouldContain(&quot;IMAGE&quot;);
102         } catch (Exception e) {
103             return false;
104         }
105         return true;
106     }
107 
108 
109     /**
110      * Build a docker image that contains JDK under test.
111      * The jdk will be placed under the &quot;/jdk/&quot; folder inside the docker file system.
112      *
113      * @param imageName     name of the image to be created, including version tag
114      * @param dockerfile    name of the dockerfile residing in the test source;
115      *                      we check for a platform specific dockerfile as well
116      *                      and use this one in case it exists
117      * @param buildDirName  name of the docker build/staging directory, which will
118      *                      be created in the jtreg&#39;s scratch folder
119      * @throws Exception
120      */
121     public static void
122         buildJdkDockerImage(String imageName, String dockerfile, String buildDirName)
123             throws Exception {
124 
125         Path buildDir = Paths.get(&quot;.&quot;, buildDirName);
126         if (Files.exists(buildDir)) {
127             throw new RuntimeException(&quot;The docker build directory already exists: &quot; + buildDir);
128         }
<span class="line-removed">129         // check for the existance of a platform specific docker file as well</span>
<span class="line-removed">130         String platformSpecificDockerfile = dockerfile + &quot;-&quot; + Platform.getOsArch();</span>
<span class="line-removed">131         if (Files.exists(Paths.get(Utils.TEST_SRC, platformSpecificDockerfile))) {</span>
<span class="line-removed">132           dockerfile = platformSpecificDockerfile;</span>
<span class="line-removed">133         }</span>
134 
<span class="line-modified">135         Path jdkSrcDir = Paths.get(Utils.TEST_JDK);</span>
136         Path jdkDstDir = buildDir.resolve(&quot;jdk&quot;);
137 
138         Files.createDirectories(jdkDstDir);
139 
140         // Copy JDK-under-test tree to the docker build directory.
141         // This step is required for building a docker image.
142         Files.walkFileTree(jdkSrcDir, new CopyFileVisitor(jdkSrcDir, jdkDstDir));
143         buildDockerImage(imageName, Paths.get(Utils.TEST_SRC, dockerfile), buildDir);
144     }
145 
146 
147     /**
148      * Build a docker image based on given docker file and docker build directory.
149      *
150      * @param imageName  name of the image to be created, including version tag
151      * @param dockerfile  path to the Dockerfile to be used for building the docker
152      *        image. The specified dockerfile will be copied to the docker build
153      *        directory as &#39;Dockerfile&#39;
154      * @param buildDir  build directory; it should already contain all the content
155      *        needed to build the docker image.
156      * @throws Exception
157      */
158     public static void
159         buildDockerImage(String imageName, Path dockerfile, Path buildDir) throws Exception {
160 
<span class="line-modified">161         // Copy docker file to the build dir</span>
<span class="line-modified">162         Files.copy(dockerfile, buildDir.resolve(&quot;Dockerfile&quot;));</span>
<span class="line-modified">163 </span>
<span class="line-modified">164         // Build the docker</span>
<span class="line-modified">165         execute(&quot;docker&quot;, &quot;build&quot;, &quot;--no-cache&quot;, &quot;--tag&quot;, imageName, buildDir.toString())</span>
<span class="line-modified">166             .shouldHaveExitValue(0)</span>
<span class="line-modified">167             .shouldContain(&quot;Successfully built&quot;);</span>






168     }
169 
170 
171     /**
<span class="line-modified">172      * Run Java inside the docker image with specified parameters and options.</span>
173      *
<span class="line-modified">174      * @param DockerRunOptions optins for running docker</span>
175      *
<span class="line-modified">176      * @return output of the run command</span>
177      * @throws Exception
178      */
<span class="line-modified">179     public static OutputAnalyzer dockerRunJava(DockerRunOptions opts) throws Exception {</span>
<span class="line-modified">180         ArrayList&lt;String&gt; cmd = new ArrayList&lt;&gt;();</span>
181 
<span class="line-modified">182         cmd.add(&quot;docker&quot;);</span>
183         cmd.add(&quot;run&quot;);
184         if (opts.tty)
185             cmd.add(&quot;--tty=true&quot;);
186         if (opts.removeContainerAfterUse)
187             cmd.add(&quot;--rm&quot;);
188 
189         cmd.addAll(opts.dockerOpts);
190         cmd.add(opts.imageNameAndTag);
191         cmd.add(opts.command);
192 
193         cmd.addAll(opts.javaOpts);
194         if (opts.appendTestJavaOptions) {
195             Collections.addAll(cmd, Utils.getTestJavaOpts());
196         }

197 
198         cmd.add(opts.classToRun);
199         cmd.addAll(opts.classParams);
200 
<span class="line-modified">201         return execute(cmd);</span>












202     }
203 
204 
205      /**
206      * Remove docker image
207      *
<span class="line-modified">208      * @param DockerRunOptions optins for running docker</span>
<span class="line-removed">209      * @return output of the command</span>
210      * @throws Exception
211      */
<span class="line-modified">212     public static OutputAnalyzer removeDockerImage(String imageNameAndTag) throws Exception {</span>
<span class="line-modified">213         return execute(&quot;docker&quot;, &quot;rmi&quot;, &quot;--force&quot;, imageNameAndTag);</span>
214     }
215 
216 
217 
218     /**
219      * Convenience method - express command as sequence of strings
220      *
221      * @param command to execute
222      * @return The output from the process
223      * @throws Exception
224      */
225     public static OutputAnalyzer execute(List&lt;String&gt; command) throws Exception {
226         return execute(command.toArray(new String[command.size()]));
227     }
228 
229 
230     /**
231      * Execute a specified command in a process, report diagnostic info.
232      *
233      * @param command to be executed
234      * @return The output from the process
235      * @throws Exception
236      */
237     public static OutputAnalyzer execute(String... command) throws Exception {
238 
239         ProcessBuilder pb = new ProcessBuilder(command);
240         System.out.println(&quot;[COMMAND]\n&quot; + Utils.getCommandLine(pb));
241 
242         long started = System.currentTimeMillis();
<span class="line-modified">243         OutputAnalyzer output = new OutputAnalyzer(pb.start());</span>


244 

245         System.out.println(&quot;[ELAPSED: &quot; + (System.currentTimeMillis() - started) + &quot; ms]&quot;);
246         System.out.println(&quot;[STDERR]\n&quot; + output.getStderr());
<span class="line-modified">247         System.out.println(&quot;[STDOUT]\n&quot; + output.getStdout());</span>





248 
249         return output;
250     }
251 
252 





























253     private static class CopyFileVisitor extends SimpleFileVisitor&lt;Path&gt; {
254         private final Path src;
255         private final Path dst;
256 
257         public CopyFileVisitor(Path src, Path dst) {
258             this.src = src;
259             this.dst = dst;
260         }
261 
262 
263         @Override
264         public FileVisitResult preVisitDirectory(Path file,
265                 BasicFileAttributes attrs) throws IOException {
266             Path dstDir = dst.resolve(src.relativize(file));
267             if (!dstDir.toFile().exists()) {
268                 Files.createDirectories(dstDir);
269             }
270             return FileVisitResult.CONTINUE;
271         }
272 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.containers.docker;
 25 
 26 import java.io.File;
<span class="line-added"> 27 import java.io.FileWriter;</span>
 28 import java.io.IOException;
 29 import java.nio.file.Files;
 30 import java.nio.file.FileVisitResult;
 31 import java.nio.file.Path;
 32 import java.nio.file.Paths;
 33 import java.nio.file.SimpleFileVisitor;
 34 import java.nio.file.StandardCopyOption;
 35 import java.nio.file.attribute.BasicFileAttributes;
<span class="line-added"> 36 import java.util.Arrays;</span>
 37 import java.util.ArrayList;
 38 import java.util.Collections;
 39 import java.util.List;
<span class="line-modified"> 40 import jdk.test.lib.Container;</span>
 41 import jdk.test.lib.Utils;
 42 import jdk.test.lib.process.OutputAnalyzer;
<span class="line-modified"> 43 import jtreg.SkippedException;</span>
 44 
 45 
 46 public class DockerTestUtils {

 47     private static boolean isDockerEngineAvailable = false;
 48     private static boolean wasDockerEngineChecked = false;
 49 
<span class="line-modified"> 50     // Specifies how many lines to copy from child STDOUT to main test output.</span>
<span class="line-modified"> 51     // Having too many lines in the main test output will result</span>
<span class="line-added"> 52     // in JT harness trimming the output, and can lead to loss of useful</span>
<span class="line-added"> 53     // diagnostic information.</span>
<span class="line-added"> 54     private static final int MAX_LINES_TO_COPY_FOR_CHILD_STDOUT = 100;</span>
<span class="line-added"> 55 </span>
<span class="line-added"> 56     // Set this property to true to retain image after test. By default</span>
<span class="line-added"> 57     // images are removed after test execution completes.</span>
<span class="line-added"> 58     // Retaining the image can be useful for diagnostics and image inspection.</span>
<span class="line-added"> 59     // E.g.: start image interactively: docker run -it &lt;IMAGE_NAME&gt;.</span>
<span class="line-added"> 60     public static final boolean RETAIN_IMAGE_AFTER_TEST =</span>
<span class="line-added"> 61         Boolean.getBoolean(&quot;jdk.test.docker.retain.image&quot;);</span>
<span class="line-added"> 62 </span>
<span class="line-added"> 63     // Path to a JDK under test.</span>
<span class="line-added"> 64     // This may be useful when developing tests on non-Linux platforms.</span>
<span class="line-added"> 65     public static final String JDK_UNDER_TEST =</span>
<span class="line-added"> 66         System.getProperty(&quot;jdk.test.docker.jdk&quot;, Utils.TEST_JDK);</span>
<span class="line-added"> 67 </span>
 68 
 69     /**
 70      * Optimized check of whether the docker engine is available in a given
 71      * environment. Checks only once, then remembers the result in a singleton.
 72      *
 73      * @return true if docker engine is available
 74      * @throws Exception
 75      */
 76     public static boolean isDockerEngineAvailable() throws Exception {
 77         if (wasDockerEngineChecked)
 78             return isDockerEngineAvailable;
 79 
 80         isDockerEngineAvailable = isDockerEngineAvailableCheck();
 81         wasDockerEngineChecked = true;
 82         return isDockerEngineAvailable;
 83     }
 84 
 85 
 86     /**
 87      * Convenience method, will check if docker engine is available and usable;
 88      * will print the appropriate message when not available.
 89      *
 90      * @return true if docker engine is available
 91      * @throws Exception
 92      */
 93     public static boolean canTestDocker() throws Exception {
 94         if (isDockerEngineAvailable()) {
 95             return true;
 96         } else {
<span class="line-modified"> 97             throw new SkippedException(&quot;Docker engine is not available on this system&quot;);</span>


 98         }
 99     }
100 
101 
102     /**
103      * Simple check - is docker engine available, accessible and usable.
104      * Run basic docker command: &#39;docker ps&#39; - list docker instances.
105      * If docker engine is available and accesible then true is returned
106      * and we can proceed with testing docker.
107      *
108      * @return true if docker engine is available and usable
109      * @throws Exception
110      */
111     private static boolean isDockerEngineAvailableCheck() throws Exception {
112         try {
<span class="line-modified">113             execute(Container.ENGINE_COMMAND, &quot;ps&quot;)</span>
114                 .shouldHaveExitValue(0)
115                 .shouldContain(&quot;CONTAINER&quot;)
116                 .shouldContain(&quot;IMAGE&quot;);
117         } catch (Exception e) {
118             return false;
119         }
120         return true;
121     }
122 
123 
124     /**
125      * Build a docker image that contains JDK under test.
126      * The jdk will be placed under the &quot;/jdk/&quot; folder inside the docker file system.
127      *
128      * @param imageName     name of the image to be created, including version tag
129      * @param dockerfile    name of the dockerfile residing in the test source;
130      *                      we check for a platform specific dockerfile as well
131      *                      and use this one in case it exists
132      * @param buildDirName  name of the docker build/staging directory, which will
133      *                      be created in the jtreg&#39;s scratch folder
134      * @throws Exception
135      */
136     public static void
137         buildJdkDockerImage(String imageName, String dockerfile, String buildDirName)
138             throws Exception {
139 
140         Path buildDir = Paths.get(&quot;.&quot;, buildDirName);
141         if (Files.exists(buildDir)) {
142             throw new RuntimeException(&quot;The docker build directory already exists: &quot; + buildDir);
143         }





144 
<span class="line-modified">145         Path jdkSrcDir = Paths.get(JDK_UNDER_TEST);</span>
146         Path jdkDstDir = buildDir.resolve(&quot;jdk&quot;);
147 
148         Files.createDirectories(jdkDstDir);
149 
150         // Copy JDK-under-test tree to the docker build directory.
151         // This step is required for building a docker image.
152         Files.walkFileTree(jdkSrcDir, new CopyFileVisitor(jdkSrcDir, jdkDstDir));
153         buildDockerImage(imageName, Paths.get(Utils.TEST_SRC, dockerfile), buildDir);
154     }
155 
156 
157     /**
158      * Build a docker image based on given docker file and docker build directory.
159      *
160      * @param imageName  name of the image to be created, including version tag
161      * @param dockerfile  path to the Dockerfile to be used for building the docker
162      *        image. The specified dockerfile will be copied to the docker build
163      *        directory as &#39;Dockerfile&#39;
164      * @param buildDir  build directory; it should already contain all the content
165      *        needed to build the docker image.
166      * @throws Exception
167      */
168     public static void
169         buildDockerImage(String imageName, Path dockerfile, Path buildDir) throws Exception {
170 
<span class="line-modified">171         generateDockerFile(buildDir.resolve(&quot;Dockerfile&quot;),</span>
<span class="line-modified">172                            DockerfileConfig.getBaseImageName(),</span>
<span class="line-modified">173                            DockerfileConfig.getBaseImageVersion());</span>
<span class="line-modified">174         try {</span>
<span class="line-modified">175             // Build the docker</span>
<span class="line-modified">176             execute(Container.ENGINE_COMMAND, &quot;build&quot;, &quot;--no-cache&quot;, &quot;--tag&quot;, imageName, buildDir.toString())</span>
<span class="line-modified">177                 .shouldHaveExitValue(0);</span>
<span class="line-added">178         } catch (Exception e) {</span>
<span class="line-added">179             // If docker image building fails there is a good chance it happens due to environment and/or</span>
<span class="line-added">180             // configuration other than product failure. Throw jtreg skipped exception in such case</span>
<span class="line-added">181             // instead of failing the test.</span>
<span class="line-added">182             throw new SkippedException(&quot;Building docker image failed. Details: \n&quot; + e.getMessage());</span>
<span class="line-added">183         }</span>
184     }
185 
186 
187     /**
<span class="line-modified">188      * Build the docker command to run java inside a container</span>
189      *
<span class="line-modified">190      * @param DockerRunOptions options for running docker</span>
191      *
<span class="line-modified">192      * @return command</span>
193      * @throws Exception
194      */
<span class="line-modified">195     public static List&lt;String&gt; buildJavaCommand(DockerRunOptions opts) throws Exception {</span>
<span class="line-modified">196         List&lt;String&gt; cmd = new ArrayList&lt;&gt;();</span>
197 
<span class="line-modified">198         cmd.add(Container.ENGINE_COMMAND);</span>
199         cmd.add(&quot;run&quot;);
200         if (opts.tty)
201             cmd.add(&quot;--tty=true&quot;);
202         if (opts.removeContainerAfterUse)
203             cmd.add(&quot;--rm&quot;);
204 
205         cmd.addAll(opts.dockerOpts);
206         cmd.add(opts.imageNameAndTag);
207         cmd.add(opts.command);
208 
209         cmd.addAll(opts.javaOpts);
210         if (opts.appendTestJavaOptions) {
211             Collections.addAll(cmd, Utils.getTestJavaOpts());
212         }
<span class="line-added">213         cmd.addAll(opts.javaOptsAppended);</span>
214 
215         cmd.add(opts.classToRun);
216         cmd.addAll(opts.classParams);
217 
<span class="line-modified">218         return cmd;</span>
<span class="line-added">219     }</span>
<span class="line-added">220 </span>
<span class="line-added">221     /**</span>
<span class="line-added">222      * Run Java inside the docker image with specified parameters and options.</span>
<span class="line-added">223      *</span>
<span class="line-added">224      * @param DockerRunOptions options for running docker</span>
<span class="line-added">225      *</span>
<span class="line-added">226      * @return output of the run command</span>
<span class="line-added">227      * @throws Exception</span>
<span class="line-added">228      */</span>
<span class="line-added">229     public static OutputAnalyzer dockerRunJava(DockerRunOptions opts) throws Exception {</span>
<span class="line-added">230         return execute(buildJavaCommand(opts));</span>
231     }
232 
233 
234      /**
235      * Remove docker image
236      *
<span class="line-modified">237      * @param DockerRunOptions options for running docker</span>

238      * @throws Exception
239      */
<span class="line-modified">240     public static void removeDockerImage(String imageNameAndTag) throws Exception {</span>
<span class="line-modified">241             execute(Container.ENGINE_COMMAND, &quot;rmi&quot;, &quot;--force&quot;, imageNameAndTag);</span>
242     }
243 
244 
245 
246     /**
247      * Convenience method - express command as sequence of strings
248      *
249      * @param command to execute
250      * @return The output from the process
251      * @throws Exception
252      */
253     public static OutputAnalyzer execute(List&lt;String&gt; command) throws Exception {
254         return execute(command.toArray(new String[command.size()]));
255     }
256 
257 
258     /**
259      * Execute a specified command in a process, report diagnostic info.
260      *
261      * @param command to be executed
262      * @return The output from the process
263      * @throws Exception
264      */
265     public static OutputAnalyzer execute(String... command) throws Exception {
266 
267         ProcessBuilder pb = new ProcessBuilder(command);
268         System.out.println(&quot;[COMMAND]\n&quot; + Utils.getCommandLine(pb));
269 
270         long started = System.currentTimeMillis();
<span class="line-modified">271         Process p = pb.start();</span>
<span class="line-added">272         long pid = p.pid();</span>
<span class="line-added">273         OutputAnalyzer output = new OutputAnalyzer(p);</span>
274 
<span class="line-added">275         String stdoutLogFile = String.format(&quot;docker-stdout-%d.log&quot;, pid);</span>
276         System.out.println(&quot;[ELAPSED: &quot; + (System.currentTimeMillis() - started) + &quot; ms]&quot;);
277         System.out.println(&quot;[STDERR]\n&quot; + output.getStderr());
<span class="line-modified">278         System.out.println(&quot;[STDOUT]\n&quot; +</span>
<span class="line-added">279                            trimLines(output.getStdout(),MAX_LINES_TO_COPY_FOR_CHILD_STDOUT));</span>
<span class="line-added">280         System.out.printf(&quot;Child process STDOUT is trimmed to %d lines \n&quot;,</span>
<span class="line-added">281                            MAX_LINES_TO_COPY_FOR_CHILD_STDOUT);</span>
<span class="line-added">282         writeOutputToFile(output.getStdout(), stdoutLogFile);</span>
<span class="line-added">283         System.out.println(&quot;Full child process STDOUT was saved to &quot; + stdoutLogFile);</span>
284 
285         return output;
286     }
287 
288 
<span class="line-added">289     private static void writeOutputToFile(String output, String fileName) throws Exception {</span>
<span class="line-added">290         try (FileWriter fw = new FileWriter(fileName)) {</span>
<span class="line-added">291             fw.write(output, 0, output.length());</span>
<span class="line-added">292         }</span>
<span class="line-added">293     }</span>
<span class="line-added">294 </span>
<span class="line-added">295 </span>
<span class="line-added">296     private static String trimLines(String buffer, int nrOfLines) {</span>
<span class="line-added">297         List&lt;String&gt; l = Arrays.asList(buffer.split(&quot;\\R&quot;));</span>
<span class="line-added">298         if (l.size() &lt; nrOfLines) {</span>
<span class="line-added">299             return buffer;</span>
<span class="line-added">300         }</span>
<span class="line-added">301 </span>
<span class="line-added">302         return String.join(&quot;\n&quot;, l.subList(0, nrOfLines));</span>
<span class="line-added">303     }</span>
<span class="line-added">304 </span>
<span class="line-added">305 </span>
<span class="line-added">306     private static void generateDockerFile(Path dockerfile, String baseImage,</span>
<span class="line-added">307                                            String baseImageVersion) throws Exception {</span>
<span class="line-added">308         String template =</span>
<span class="line-added">309             &quot;FROM %s:%s\n&quot; +</span>
<span class="line-added">310             &quot;COPY /jdk /jdk\n&quot; +</span>
<span class="line-added">311             &quot;ENV JAVA_HOME=/jdk\n&quot; +</span>
<span class="line-added">312             &quot;CMD [\&quot;/bin/bash\&quot;]\n&quot;;</span>
<span class="line-added">313         String dockerFileStr = String.format(template, baseImage, baseImageVersion);</span>
<span class="line-added">314         Files.writeString(dockerfile, dockerFileStr);</span>
<span class="line-added">315     }</span>
<span class="line-added">316 </span>
<span class="line-added">317 </span>
318     private static class CopyFileVisitor extends SimpleFileVisitor&lt;Path&gt; {
319         private final Path src;
320         private final Path dst;
321 
322         public CopyFileVisitor(Path src, Path dst) {
323             this.src = src;
324             this.dst = dst;
325         }
326 
327 
328         @Override
329         public FileVisitResult preVisitDirectory(Path file,
330                 BasicFileAttributes attrs) throws IOException {
331             Path dstDir = dst.resolve(src.relativize(file));
332             if (!dstDir.toFile().exists()) {
333                 Files.createDirectories(dstDir);
334             }
335             return FileVisitResult.CONTINUE;
336         }
337 
</pre>
</td>
</tr>
</table>
<center><a href="DockerRunOptions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../jfr/EventNames.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
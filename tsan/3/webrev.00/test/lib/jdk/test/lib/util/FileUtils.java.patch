diff a/test/lib/jdk/test/lib/util/FileUtils.java b/test/lib/jdk/test/lib/util/FileUtils.java
--- a/test/lib/jdk/test/lib/util/FileUtils.java
+++ b/test/lib/jdk/test/lib/util/FileUtils.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,10 +23,12 @@
 
 package jdk.test.lib.util;
 
 import jdk.test.lib.Platform;
 
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.io.UncheckedIOException;
 import java.lang.ProcessBuilder.Redirect;
 import java.nio.file.DirectoryNotEmptyException;
@@ -43,10 +45,13 @@
 import java.util.ArrayList;
 import java.util.ArrayDeque;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.TimeUnit;
 
 /**
  * Common library for various test file utility functions.
  */
@@ -90,11 +95,11 @@
      * @throws IOException
      *         if an I/O error occurs
      */
     public static void deleteFileIfExistsWithRetry(Path path) throws IOException {
         try {
-            if (Files.exists(path)) {
+            if (!Files.notExists(path)) {
                 deleteFileWithRetry0(path);
             }
         } catch (InterruptedException x) {
             throw new IOException("Interrupted while deleting.", x);
         }
@@ -235,10 +240,94 @@
             }
         }
         return areFileSystemsAccessible;
     }
 
+    /**
+     * Checks whether all file systems are accessible and there are no
+     * duplicate mount points. This is performed by checking free disk
+     * space on all mounted file systems via a separate, spawned process.
+     * File systems are considered to be accessible if this process completes
+     * successfully before a given fixed duration has elapsed.
+     *
+     * @implNote On Unix this executes the {@code df} command in a separate
+     * process and on Windows always returns {@code true}.
+     *
+     * @return whether file systems appear to be accessible and duplicate-free
+     */
+    public static boolean areMountPointsAccessibleAndUnique() {
+        if (IS_WINDOWS) return true;
+
+        final AtomicBoolean areMountPointsOK = new AtomicBoolean(true);
+        Thread thr = new Thread(() -> {
+            try {
+                Process proc = new ProcessBuilder("df").start();
+                BufferedReader reader = new BufferedReader
+                    (new InputStreamReader(proc.getInputStream()));
+                // Skip the first line as it is the "df" output header.
+                if (reader.readLine() != null ) {
+                    Set mountPoints = new HashSet();
+                    String mountPoint = null;
+                    while ((mountPoint = reader.readLine()) != null) {
+                        if (!mountPoints.add(mountPoint)) {
+                            System.err.printf
+                                ("Config error: duplicate mount point %s%n",
+                                mountPoint);
+                            areMountPointsOK.set(false);
+                            break;
+                        }
+                    }
+                }
+
+                try {
+                    proc.waitFor(90, TimeUnit.SECONDS);
+                } catch (InterruptedException ignored) {
+                }
+                try {
+                    int exitValue = proc.exitValue();
+                    if (exitValue != 0) {
+                        System.err.printf("df process exited with %d != 0%n",
+                            exitValue);
+                        areMountPointsOK.set(false);
+                    }
+                } catch (IllegalThreadStateException ignored) {
+                    System.err.println("df command apparently hung");
+                    areMountPointsOK.set(false);
+                }
+            } catch (IOException ioe) {
+                throw new RuntimeException(ioe);
+            };
+        });
+
+        final AtomicReference throwableReference =
+            new AtomicReference<Throwable>();
+        thr.setUncaughtExceptionHandler(
+            new Thread.UncaughtExceptionHandler() {
+                public void uncaughtException(Thread t, Throwable e) {
+                    throwableReference.set(e);
+                }
+            });
+
+        thr.start();
+        try {
+            thr.join(120*1000L);
+        } catch (InterruptedException ie) {
+            throw new RuntimeException(ie);
+        }
+
+        Throwable uncaughtException = (Throwable)throwableReference.get();
+        if (uncaughtException != null) {
+            throw new RuntimeException(uncaughtException);
+        }
+
+        if (thr.isAlive()) {
+            throw new RuntimeException("df thread did not join in time");
+        }
+
+        return areMountPointsOK.get();
+    }
+
     /**
      * List the open file descriptors (if supported by the 'lsof' command).
      * @param ps a printStream to send the output to
      * @throws UncheckedIOException if an error occurs
      */

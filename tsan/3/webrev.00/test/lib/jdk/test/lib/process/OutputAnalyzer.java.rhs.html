<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/lib/jdk/test/lib/process/OutputAnalyzer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.process;
 25 
 26 import jdk.test.lib.Asserts;
 27 
 28 import java.io.IOException;
 29 import java.io.PrintStream;
<a name="2" id="anc2"></a><span class="line-added"> 30 import java.nio.charset.Charset;</span>
<span class="line-added"> 31 import java.nio.file.Files;</span>
<span class="line-added"> 32 import java.nio.file.Path;</span>
 33 import java.util.Arrays;
 34 import java.util.List;
 35 import java.util.stream.Collectors;
 36 import java.util.regex.Matcher;
 37 import java.util.regex.Pattern;
 38 
 39 public final class OutputAnalyzer {
 40 
 41     private final OutputBuffer buffer;
<a name="3" id="anc3"></a><span class="line-added"> 42     /**</span>
<span class="line-added"> 43      * Create an OutputAnalyzer, a utility class for verifying output and exit</span>
<span class="line-added"> 44      * value from a Process</span>
<span class="line-added"> 45      *</span>
<span class="line-added"> 46      * @param process Process to analyze</span>
<span class="line-added"> 47      * @param cs The charset used to convert stdout/stderr from bytes to chars</span>
<span class="line-added"> 48      *           or null for the default charset.</span>
<span class="line-added"> 49      * @throws IOException If an I/O error occurs.</span>
<span class="line-added"> 50      */</span>
<span class="line-added"> 51     public OutputAnalyzer(Process process, Charset cs) throws IOException {</span>
<span class="line-added"> 52         buffer = OutputBuffer.of(process, cs);</span>
<span class="line-added"> 53     }</span>
 54     /**
 55      * Create an OutputAnalyzer, a utility class for verifying output and exit
 56      * value from a Process
 57      *
 58      * @param process Process to analyze
 59      * @throws IOException If an I/O error occurs.
 60      */
 61     public OutputAnalyzer(Process process) throws IOException {
 62         buffer = OutputBuffer.of(process);
 63     }
 64 
 65     /**
 66      * Create an OutputAnalyzer, a utility class for verifying output
 67      *
 68      * @param buf String buffer to analyze
 69      */
 70     public OutputAnalyzer(String buf) {
 71         buffer = OutputBuffer.of(buf, buf);
 72     }
 73 
<a name="4" id="anc4"></a><span class="line-added"> 74     /**</span>
<span class="line-added"> 75      * Create an OutputAnalyzer, a utility class for verifying output</span>
<span class="line-added"> 76      *</span>
<span class="line-added"> 77      * @param file File to analyze</span>
<span class="line-added"> 78      */</span>
<span class="line-added"> 79     public OutputAnalyzer(Path file) throws IOException {</span>
<span class="line-added"> 80         this(Files.readString(file));</span>
<span class="line-added"> 81     }</span>
<span class="line-added"> 82 </span>
 83     /**
 84      * Create an OutputAnalyzer, a utility class for verifying output
 85      *
 86      * @param stdout stdout buffer to analyze
 87      * @param stderr stderr buffer to analyze
 88      */
 89     public OutputAnalyzer(String stdout, String stderr) {
 90         buffer = OutputBuffer.of(stdout, stderr);
 91     }
 92 
<a name="5" id="anc5"></a><span class="line-added"> 93     /**</span>
<span class="line-added"> 94      * Create an OutputAnalyzer, a utility class for verifying output</span>
<span class="line-added"> 95      *</span>
<span class="line-added"> 96      * @param stdout stdout buffer to analyze</span>
<span class="line-added"> 97      * @param stderr stderr buffer to analyze</span>
<span class="line-added"> 98      * @param stderr exitValue result to analyze</span>
<span class="line-added"> 99      */</span>
<span class="line-added">100     public OutputAnalyzer(String stdout, String stderr, int exitValue)</span>
<span class="line-added">101     {</span>
<span class="line-added">102         buffer = OutputBuffer.of(stdout, stderr, exitValue);</span>
<span class="line-added">103     }</span>
<span class="line-added">104 </span>
105     /**
106      * Verify that the stdout contents of output buffer is empty
107      *
108      * @throws RuntimeException
109      *             If stdout was not empty
110      */
111     public OutputAnalyzer stdoutShouldBeEmpty() {
112         if (!getStdout().isEmpty()) {
113             reportDiagnosticSummary();
114             throw new RuntimeException(&quot;stdout was not empty&quot;);
115         }
116         return this;
117     }
118 
119     /**
120      * Verify that the stderr contents of output buffer is empty
121      *
122      * @throws RuntimeException
123      *             If stderr was not empty
124      */
125     public OutputAnalyzer stderrShouldBeEmpty() {
126         if (!getStderr().isEmpty()) {
127             reportDiagnosticSummary();
128             throw new RuntimeException(&quot;stderr was not empty&quot;);
129         }
130         return this;
131     }
132 
133     /**
134      * Verify that the stderr contents of output buffer is empty,
135      * after filtering out the Hotspot warning messages
136      *
137      * @throws RuntimeException
138      *             If stderr was not empty
139      */
140     public OutputAnalyzer stderrShouldBeEmptyIgnoreVMWarnings() {
141         if (!getStderr().replaceAll(jvmwarningmsg + &quot;\\R&quot;, &quot;&quot;).isEmpty()) {
142             reportDiagnosticSummary();
143             throw new RuntimeException(&quot;stderr was not empty&quot;);
144         }
145         return this;
146     }
147 
148     /**
149      * Verify that the stdout contents of output buffer is not empty
150      *
151      * @throws RuntimeException
152      *             If stdout was empty
153      */
154     public OutputAnalyzer stdoutShouldNotBeEmpty() {
155         if (getStdout().isEmpty()) {
156             reportDiagnosticSummary();
157             throw new RuntimeException(&quot;stdout was empty&quot;);
158         }
159         return this;
160     }
161 
162     /**
163      * Verify that the stderr contents of output buffer is not empty
164      *
165      * @throws RuntimeException
166      *             If stderr was empty
167      */
168     public OutputAnalyzer stderrShouldNotBeEmpty() {
169         if (getStderr().isEmpty()) {
170             reportDiagnosticSummary();
171             throw new RuntimeException(&quot;stderr was empty&quot;);
172         }
173         return this;
174     }
175 
176     /**
177      * Verify that the stdout and stderr contents of output buffer contains the string
178      *
179      * @param expectedString String that buffer should contain
180      * @throws RuntimeException If the string was not found
181      */
182     public OutputAnalyzer shouldContain(String expectedString) {
183         String stdout = getStdout();
184         String stderr = getStderr();
185         if (!stdout.contains(expectedString) &amp;&amp; !stderr.contains(expectedString)) {
186             reportDiagnosticSummary();
187             throw new RuntimeException(&quot;&#39;&quot; + expectedString + &quot;&#39; missing from stdout/stderr \n&quot;);
188         }
189         return this;
190     }
191 
192     /**
193      * Verify that the stdout contents of output buffer contains the string
194      *
195      * @param expectedString String that buffer should contain
196      * @throws RuntimeException If the string was not found
197      */
198     public OutputAnalyzer stdoutShouldContain(String expectedString) {
199         String stdout = getStdout();
200         if (!stdout.contains(expectedString)) {
201             reportDiagnosticSummary();
202             throw new RuntimeException(&quot;&#39;&quot; + expectedString + &quot;&#39; missing from stdout \n&quot;);
203         }
204         return this;
205     }
206 
207     /**
208      * Verify that the stderr contents of output buffer contains the string
209      *
210      * @param expectedString String that buffer should contain
211      * @throws RuntimeException If the string was not found
212      */
213     public OutputAnalyzer stderrShouldContain(String expectedString) {
214         String stderr = getStderr();
215         if (!stderr.contains(expectedString)) {
216             reportDiagnosticSummary();
217             throw new RuntimeException(&quot;&#39;&quot; + expectedString + &quot;&#39; missing from stderr \n&quot;);
218         }
219         return this;
220     }
221 
222     /**
223      * Verify that the stdout and stderr contents of output buffer does not contain the string
224      *
225      * @param notExpectedString String that the buffer should not contain
226      * @throws RuntimeException If the string was found
227      */
228     public OutputAnalyzer shouldNotContain(String notExpectedString) {
229         String stdout = getStdout();
230         String stderr = getStderr();
231         if (stdout.contains(notExpectedString)) {
232             reportDiagnosticSummary();
233             throw new RuntimeException(&quot;&#39;&quot; + notExpectedString + &quot;&#39; found in stdout \n&quot;);
234         }
235         if (stderr.contains(notExpectedString)) {
236             reportDiagnosticSummary();
237             throw new RuntimeException(&quot;&#39;&quot; + notExpectedString + &quot;&#39; found in stderr \n&quot;);
238         }
239         return this;
240     }
241 
242     /**
243      * Verify that the stdout and stderr contents of output buffer are empty
244      *
245      * @throws RuntimeException If the stdout and stderr are not empty
246      */
247     public OutputAnalyzer shouldBeEmpty() {
248         String stdout = getStdout();
249         String stderr = getStderr();
250         if (!stdout.isEmpty()) {
251             reportDiagnosticSummary();
252             throw new RuntimeException(&quot;stdout was not empty&quot;);
253         }
254         if (!stderr.isEmpty()) {
255             reportDiagnosticSummary();
256             throw new RuntimeException(&quot;stderr was not empty&quot;);
257         }
258         return this;
259     }
260 
261     /**
262      * Verify that the stdout contents of output buffer does not contain the string
263      *
264      * @param notExpectedString String that the buffer should not contain
265      * @throws RuntimeException If the string was found
266      */
267     public OutputAnalyzer stdoutShouldNotContain(String notExpectedString) {
268         String stdout = getStdout();
269         if (stdout.contains(notExpectedString)) {
270             reportDiagnosticSummary();
271             throw new RuntimeException(&quot;&#39;&quot; + notExpectedString + &quot;&#39; found in stdout \n&quot;);
272         }
273         return this;
274     }
275 
276     /**
277      * Verify that the stderr contents of output buffer does not contain the string
278      *
279      * @param notExpectedString String that the buffer should not contain
280      * @throws RuntimeException If the string was found
281      */
282     public OutputAnalyzer stderrShouldNotContain(String notExpectedString) {
283         String stderr = getStderr();
284         if (stderr.contains(notExpectedString)) {
285             reportDiagnosticSummary();
286             throw new RuntimeException(&quot;&#39;&quot; + notExpectedString + &quot;&#39; found in stderr \n&quot;);
287         }
288         return this;
289     }
290 
291     /**
292      * Verify that the stdout and stderr contents of output buffer matches
293      * the pattern
294      *
295      * @param regexp
296      * @throws RuntimeException If the pattern was not found
297      */
298     public OutputAnalyzer shouldMatch(String regexp) {
299         String stdout = getStdout();
300         String stderr = getStderr();
301         Pattern pattern = Pattern.compile(regexp, Pattern.MULTILINE);
302         Matcher stdoutMatcher = pattern.matcher(stdout);
303         Matcher stderrMatcher = pattern.matcher(stderr);
304         if (!stdoutMatcher.find() &amp;&amp; !stderrMatcher.find()) {
305             reportDiagnosticSummary();
306             throw new RuntimeException(&quot;&#39;&quot; + regexp
307                   + &quot;&#39; missing from stdout/stderr \n&quot;);
308         }
309         return this;
310     }
311 
312     /**
313      * Verify that the stdout contents of output buffer matches the
314      * pattern
315      *
316      * @param regexp
317      * @throws RuntimeException If the pattern was not found
318      */
319     public OutputAnalyzer stdoutShouldMatch(String regexp) {
320         String stdout = getStdout();
321         Matcher matcher = Pattern.compile(regexp, Pattern.MULTILINE).matcher(stdout);
322         if (!matcher.find()) {
323             reportDiagnosticSummary();
324             throw new RuntimeException(&quot;&#39;&quot; + regexp
325                   + &quot;&#39; missing from stdout \n&quot;);
326         }
327         return this;
328     }
329 
330     /**
331      * Verify that the stderr contents of output buffer matches the
332      * pattern
333      *
334      * @param pattern
335      * @throws RuntimeException If the pattern was not found
336      */
337     public OutputAnalyzer stderrShouldMatch(String pattern) {
338         String stderr = getStderr();
339         Matcher matcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stderr);
340         if (!matcher.find()) {
341             reportDiagnosticSummary();
342             throw new RuntimeException(&quot;&#39;&quot; + pattern
343                   + &quot;&#39; missing from stderr \n&quot;);
344         }
345         return this;
346     }
347 
348     /**
349      * Verify that the stdout and stderr contents of output buffer does not
350      * match the pattern
351      *
352      * @param regexp
353      * @throws RuntimeException If the pattern was found
354      */
355     public OutputAnalyzer shouldNotMatch(String regexp) {
356         String stdout = getStdout();
357         Pattern pattern = Pattern.compile(regexp, Pattern.MULTILINE);
358         Matcher matcher = pattern.matcher(stdout);
359         if (matcher.find()) {
360             reportDiagnosticSummary();
361             throw new RuntimeException(&quot;&#39;&quot; + regexp
362                     + &quot;&#39; found in stdout: &#39;&quot; + matcher.group() + &quot;&#39; \n&quot;);
363         }
364 
365         String stderr = getStderr();
366         matcher = pattern.matcher(stderr);
367         if (matcher.find()) {
368             reportDiagnosticSummary();
369             throw new RuntimeException(&quot;&#39;&quot; + regexp
370                     + &quot;&#39; found in stderr: &#39;&quot; + matcher.group() + &quot;&#39; \n&quot;);
371         }
372 
373         return this;
374     }
375 
376     /**
377      * Verify that the stdout contents of output buffer does not match the
378      * pattern
379      *
380      * @param regexp
381      * @throws RuntimeException If the pattern was found
382      */
383     public OutputAnalyzer stdoutShouldNotMatch(String regexp) {
384         String stdout = getStdout();
385         Matcher matcher = Pattern.compile(regexp, Pattern.MULTILINE).matcher(stdout);
386         if (matcher.find()) {
387             reportDiagnosticSummary();
388             throw new RuntimeException(&quot;&#39;&quot; + regexp
389                     + &quot;&#39; found in stdout \n&quot;);
390         }
391         return this;
392     }
393 
394     /**
395      * Verify that the stderr contents of output buffer does not match the
396      * pattern
397      *
398      * @param regexp
399      * @throws RuntimeException If the pattern was found
400      */
401     public OutputAnalyzer stderrShouldNotMatch(String regexp) {
402         String stderr = getStderr();
403         Matcher matcher = Pattern.compile(regexp, Pattern.MULTILINE).matcher(stderr);
404         if (matcher.find()) {
405             reportDiagnosticSummary();
406             throw new RuntimeException(&quot;&#39;&quot; + regexp
407                     + &quot;&#39; found in stderr \n&quot;);
408         }
409         return this;
410     }
411 
412     /**
413      * Get the captured group of the first string matching the pattern.
414      * stderr is searched before stdout.
415      *
416      * @param regexp The multi-line pattern to match
417      * @param group The group to capture
418      * @return The matched string or null if no match was found
419      */
420     public String firstMatch(String regexp, int group) {
421         Pattern pattern = Pattern.compile(regexp, Pattern.MULTILINE);
422         String stderr = getStderr();
423         Matcher stderrMatcher = pattern.matcher(stderr);
424         if (stderrMatcher.find()) {
425             return stderrMatcher.group(group);
426         }
427         String stdout = getStdout();
428         Matcher stdoutMatcher = pattern.matcher(stdout);
429         if (stdoutMatcher.find()) {
430             return stdoutMatcher.group(group);
431         }
432         return null;
433     }
434 
435     /**
436      * Get the first string matching the pattern.
437      * stderr is searched before stdout.
438      *
439      * @param pattern The multi-line pattern to match
440      * @return The matched string or null if no match was found
441      */
442     public String firstMatch(String pattern) {
443         return firstMatch(pattern, 0);
444     }
445 
446     /**
447      * Verify the exit value of the process
448      *
449      * @param expectedExitValue Expected exit value from process
450      * @throws RuntimeException If the exit value from the process did not match the expected value
451      */
452     public OutputAnalyzer shouldHaveExitValue(int expectedExitValue) {
453         if (getExitValue() != expectedExitValue) {
454             reportDiagnosticSummary();
455             throw new RuntimeException(&quot;Expected to get exit value of [&quot;
456                     + expectedExitValue + &quot;]\n&quot;);
457         }
458         return this;
459     }
460 
461     /**
462      * Verify the exit value of the process
463      *
464      * @param notExpectedExitValue Unexpected exit value from process
465      * @throws RuntimeException If the exit value from the process did match the expected value
466      */
467     public OutputAnalyzer shouldNotHaveExitValue(int notExpectedExitValue) {
468         if (getExitValue() == notExpectedExitValue) {
469             reportDiagnosticSummary();
470             throw new RuntimeException(&quot;Unexpected to get exit value of [&quot;
471                     + notExpectedExitValue + &quot;]\n&quot;);
472         }
473         return this;
474     }
475 
476 
477     /**
478      * Report summary that will help to diagnose the problem
479      * Currently includes:
480      *  - standard input produced by the process under test
481      *  - standard output
482      *  - exit code
483      *  Note: the command line is printed by the ProcessTools
484      */
485     public void reportDiagnosticSummary() {
486         String msg =
487             &quot; stdout: [&quot; + getStdout() + &quot;];\n&quot; +
488             &quot; stderr: [&quot; + getStderr() + &quot;]\n&quot; +
489             &quot; exitValue = &quot; + getExitValue() + &quot;\n&quot;;
490 
491         System.err.println(msg);
492     }
493 
494     /**
495      * Print the stdout buffer to the given {@code PrintStream}.
496      *
497      * @return this OutputAnalyzer
498      */
499     public OutputAnalyzer outputTo(PrintStream out) {
500         out.println(getStdout());
501         return this;
502     }
503 
504     /**
505      * Print the stderr buffer to the given {@code PrintStream}.
506      *
507      * @return this OutputAnalyzer
508      */
509     public OutputAnalyzer errorTo(PrintStream out) {
510         out.println(getStderr());
511         return this;
512     }
513 
514     /**
515      * Get the contents of the output buffer (stdout and stderr)
516      *
517      * @return Content of the output buffer
518      */
519     public String getOutput() {
520         return getStdout() + getStderr();
521     }
522 
523     /**
524      * Get the contents of the stdout buffer
525      *
526      * @return Content of the stdout buffer
527      */
528     public String getStdout() {
529         return buffer.getStdout();
530     }
531 
532     /**
533      * Get the contents of the stderr buffer
534      *
535      * @return Content of the stderr buffer
536      */
537     public String getStderr() {
538         return buffer.getStderr();
539     }
540 
541     /**
542      * Get the process exit value
543      *
544      * @return Process exit value
545      */
546     public int getExitValue() {
547         return buffer.getExitValue();
548     }
549 
550     /**
551      * Get the contents of the output buffer (stdout and stderr) as list of strings.
552      * Output will be split by newlines.
553      *
554      * @return Contents of the output buffer as list of strings
555      */
556     public List&lt;String&gt; asLines() {
557         return asLines(getOutput());
558     }
559 
560     private List&lt;String&gt; asLines(String buffer) {
561         return Arrays.asList(buffer.split(&quot;\\R&quot;));
562     }
563 
564 
565     private static final String jvmwarningmsg = &quot;.* VM warning:.*&quot;;
566 
567     /**
568      * Verifies that the stdout and stderr contents of output buffer are empty, after
569      * filtering out the HotSpot warning messages.
570      *
571      * @throws RuntimeException If the stdout and stderr are not empty
572      */
573     public OutputAnalyzer shouldBeEmptyIgnoreVMWarnings() {
574         String stdout = getStdout();
575         String stderr = getStderr();
576         if (!stdout.isEmpty()) {
577             reportDiagnosticSummary();
578             throw new RuntimeException(&quot;stdout was not empty&quot;);
579         }
580         if (!stderr.replaceAll(jvmwarningmsg + &quot;\\R&quot;, &quot;&quot;).isEmpty()) {
581             reportDiagnosticSummary();
582             throw new RuntimeException(&quot;stderr was not empty&quot;);
583         }
584         return this;
585     }
586 
587     /**
588      * Verify that the stderr contents of output buffer matches the pattern,
589      * after filtering out the Hotespot warning messages
590      *
591      * @param pattern
592      * @throws RuntimeException If the pattern was not found
593      */
594     public OutputAnalyzer stderrShouldMatchIgnoreVMWarnings(String pattern) {
595         String stderr = getStderr().replaceAll(jvmwarningmsg + &quot;\\R&quot;, &quot;&quot;);
596         Matcher matcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stderr);
597         if (!matcher.find()) {
598             reportDiagnosticSummary();
599             throw new RuntimeException(&quot;&#39;&quot; + pattern
600                   + &quot;&#39; missing from stderr \n&quot;);
601         }
602         return this;
603     }
604 
605     /**
606      * Returns the contents of the output buffer (stdout and stderr), without those
607      * JVM warning msgs, as list of strings. Output is split by newlines.
608      *
609      * @return Contents of the output buffer as list of strings
610      */
611     public List&lt;String&gt; asLinesWithoutVMWarnings() {
612         return Arrays.stream(getOutput().split(&quot;\\R&quot;))
613                      .filter(Pattern.compile(jvmwarningmsg).asPredicate().negate())
614                      .collect(Collectors.toList());
615     }
616 
617     /**
618      * @see #shouldMatchByLine(String, String, String)
619      */
620     public OutputAnalyzer shouldMatchByLine(String pattern) {
621         return shouldMatchByLine(null, null, pattern);
622     }
623 
624     /**
625      * @see #stdoutShouldMatchByLine(String, String, String)
626      */
627     public OutputAnalyzer stdoutShouldMatchByLine(String pattern) {
628         return stdoutShouldMatchByLine(null, null, pattern);
629     }
630 
631     /**
632      * @see #shouldMatchByLine(String, String, String)
633      */
634     public OutputAnalyzer shouldMatchByLineFrom(String from, String pattern) {
635         return shouldMatchByLine(from, null, pattern);
636     }
637 
638     /**
639      * @see #shouldMatchByLine(String, String, String)
640      */
641     public OutputAnalyzer shouldMatchByLineTo(String to, String pattern) {
642         return shouldMatchByLine(null, to, pattern);
643     }
644 
645     /**
646      * Verify that the stdout and stderr contents of output buffer match the
647      * {@code pattern} line by line. The whole output could be matched or
648      * just a subset of it.
649      *
650      * @param from
<a name="6" id="anc6"></a><span class="line-modified">651      *            The line (excluded) from where output will be matched.</span>
652      *            Set {@code from} to null for matching from the first line.
653      * @param to
<a name="7" id="anc7"></a><span class="line-modified">654      *            The line (excluded) until where output will be matched.</span>
655      *            Set {@code to} to null for matching until the last line.
656      * @param pattern
657      *            Matching pattern
658      */
659     public OutputAnalyzer shouldMatchByLine(String from, String to, String pattern) {
660         return shouldMatchByLine(getOutput(), from, to, pattern);
661     }
662 
663     /**
664      * Verify that the stdout contents of output buffer matches the
665      * {@code pattern} line by line. The whole stdout could be matched or
666      * just a subset of it.
667      *
668      * @param from
<a name="8" id="anc8"></a><span class="line-modified">669      *            The line (excluded) from where stdout will be matched.</span>
670      *            Set {@code from} to null for matching from the first line.
671      * @param to
<a name="9" id="anc9"></a><span class="line-modified">672      *            The line (excluded) until where stdout will be matched.</span>
673      *            Set {@code to} to null for matching until the last line.
674      * @param pattern
675      *            Matching pattern
676      */
677     public OutputAnalyzer stdoutShouldMatchByLine(String from, String to, String pattern) {
678         return shouldMatchByLine(getStdout(), from, to, pattern);
679     }
680 
681     private OutputAnalyzer shouldMatchByLine(String buffer, String from, String to, String pattern) {
682         List&lt;String&gt; lines = asLines(buffer);
683 
684         int fromIndex = 0;
685         if (from != null) {
<a name="10" id="anc10"></a><span class="line-modified">686             fromIndex = indexOf(lines, from, 0) + 1; // + 1 -&gt; apply &#39;pattern&#39; to lines after &#39;from&#39; match</span>
<span class="line-modified">687             Asserts.assertGreaterThan(fromIndex, 0,</span>
688                     &quot;The line/pattern &#39;&quot; + from + &quot;&#39; from where the output should match can not be found&quot;);
689         }
690 
691         int toIndex = lines.size();
692         if (to != null) {
<a name="11" id="anc11"></a><span class="line-modified">693             toIndex = indexOf(lines, to, fromIndex);</span>
<span class="line-modified">694             Asserts.assertGreaterThan(toIndex, fromIndex,</span>
695                     &quot;The line/pattern &#39;&quot; + to + &quot;&#39; until where the output should match can not be found&quot;);
696         }
697 
698         List&lt;String&gt; subList = lines.subList(fromIndex, toIndex);
<a name="12" id="anc12"></a><span class="line-modified">699         Asserts.assertFalse(subList.isEmpty(), &quot;There are no lines to check:&quot;</span>
<span class="line-added">700                 + &quot; range &quot; + fromIndex + &quot;..&quot; + toIndex + &quot;, subList = &quot; + subList);</span>
701 
702         subList.stream()
703                .filter(Pattern.compile(pattern).asPredicate().negate())
704                .findAny()
<a name="13" id="anc13"></a><span class="line-modified">705                .ifPresent(line -&gt; Asserts.fail(</span>
706                        &quot;The line &#39;&quot; + line + &quot;&#39; does not match pattern &#39;&quot; + pattern + &quot;&#39;&quot;));
707 
708         return this;
709     }
710 
711     /**
712      * Check if there is a line matching {@code regexp} and return its index
713      *
714      * @param regexp Matching pattern
<a name="14" id="anc14"></a><span class="line-added">715      * @param fromIndex Start matching after so many lines skipped</span>
716      * @return Index of first matching line
717      */
<a name="15" id="anc15"></a><span class="line-modified">718     private int indexOf(List&lt;String&gt; lines, String regexp, int fromIndex) {</span>
719         Pattern pattern = Pattern.compile(regexp);
<a name="16" id="anc16"></a><span class="line-modified">720         for (int i = fromIndex; i &lt; lines.size(); i++) {</span>
721             if (pattern.matcher(lines.get(i)).matches()) {
722                 return i;
723             }
724         }
725         return -1;
726     }
727 
728 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
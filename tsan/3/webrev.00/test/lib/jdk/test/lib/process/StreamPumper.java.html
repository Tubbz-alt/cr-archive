<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/lib/jdk/test/lib/process/StreamPumper.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.process;
 25 
 26 import java.io.BufferedInputStream;
 27 import java.io.ByteArrayOutputStream;
 28 import java.io.OutputStream;
 29 import java.io.InputStream;
 30 import java.io.IOException;
 31 import java.util.HashSet;
 32 import java.util.Set;
 33 import java.util.concurrent.Future;
 34 import java.util.concurrent.FutureTask;
 35 import java.util.concurrent.atomic.AtomicBoolean;
 36 
 37 public final class StreamPumper implements Runnable {
 38 
 39     private static final int BUF_SIZE = 256;
 40 
 41     /**
 42      * Pump will be called by the StreamPumper to process the incoming data
 43      */
 44     public abstract static class Pump {
 45         abstract void register(StreamPumper d);
 46     }
 47 
 48     /**
 49      * OutputStream -&gt; Pump adapter
 50      */
 51     public final static class StreamPump extends Pump {
 52         private final OutputStream out;
 53         public StreamPump(OutputStream out) {
 54             this.out = out;
 55         }
 56 
 57         @Override
 58         void register(StreamPumper sp) {
 59             sp.addOutputStream(out);
 60         }
 61     }
 62 
 63     /**
 64      * Used to process the incoming data line-by-line
 65      */
 66     public abstract static class LinePump extends Pump {
 67         @Override
 68         final void register(StreamPumper sp) {
 69             sp.addLineProcessor(this);
 70         }
 71 
 72         protected abstract void processLine(String line);
 73     }
 74 
 75     private final InputStream in;
 76     private final Set&lt;OutputStream&gt; outStreams = new HashSet&lt;&gt;();
 77     private final Set&lt;LinePump&gt; linePumps = new HashSet&lt;&gt;();
 78 
 79     private final AtomicBoolean processing = new AtomicBoolean(false);
 80 
 81     public StreamPumper(InputStream in) {
 82         this.in = in;
 83     }
 84 
 85     /**
 86      * Create a StreamPumper that reads from in and writes to out.
 87      *
 88      * @param in The stream to read from.
 89      * @param out The stream to write to.
 90      */
 91     public StreamPumper(InputStream in, OutputStream out) {
 92         this(in);
 93         this.addOutputStream(out);
 94     }
 95 
 96     /**
 97      * Implements Thread.run(). Continuously read from {@code in} and write to
 98      * {@code out} until {@code in} has reached end of stream. Abort on
 99      * interruption. Abort on IOExceptions.
100      */
101     @Override
102     public void run() {
103         try (BufferedInputStream is = new BufferedInputStream(in)) {
104             ByteArrayOutputStream lineBos = new ByteArrayOutputStream();
105             byte[] buf = new byte[BUF_SIZE];
106             int len = 0;
107             int linelen = 0;
108 
109             while ((len = is.read(buf)) &gt; 0 &amp;&amp; !Thread.interrupted()) {
110                 for (OutputStream out : outStreams) {
111                     out.write(buf, 0, len);
112                 }
113                 if (!linePumps.isEmpty()) {
114                     int i = 0;
115                     int lastcrlf = -1;
116                     while (i &lt; len) {
117                         if (buf[i] == &#39;\n&#39; || buf[i] == &#39;\r&#39;) {
118                             int bufLinelen = i - lastcrlf - 1;
119                             if (bufLinelen &gt; 0) {
120                                 lineBos.write(buf, lastcrlf + 1, bufLinelen);
121                             }
122                             linelen += bufLinelen;
123 
124                             if (linelen &gt; 0) {
125                                 lineBos.flush();
126                                 final String line = lineBos.toString();
127                                 linePumps.forEach((lp) -&gt; lp.processLine(line));
128                                 lineBos.reset();
129                                 linelen = 0;
130                             }
131                             lastcrlf = i;
132                         }
133 
134                         i++;
135                     }
136                     if (lastcrlf == -1) {
137                         lineBos.write(buf, 0, len);
138                         linelen += len;
139                     } else if (lastcrlf &lt; len - 1) {
140                         lineBos.write(buf, lastcrlf + 1, len - lastcrlf - 1);
141                         linelen += len - lastcrlf - 1;
142                     }
143                 }
144             }
145 
146         } catch (IOException e) {
147             if (!e.getMessage().equalsIgnoreCase(&quot;stream closed&quot;)) {
148                 e.printStackTrace();
149             }
150         } finally {
151             for (OutputStream out : outStreams) {
152                 try {
153                     out.flush();
154                 } catch (IOException e) {}
155             }
156             try {
157                 in.close();
158             } catch (IOException e) {}
159         }
160     }
161 
162     final void addOutputStream(OutputStream out) {
163         outStreams.add(out);
164     }
165 
166     final void addLineProcessor(LinePump lp) {
167         linePumps.add(lp);
168     }
169 
170     public final StreamPumper addPump(Pump ... pump) {
171         if (processing.get()) {
172             throw new IllegalStateException(&quot;Can not modify pumper while &quot; +
173                                             &quot;processing is in progress&quot;);
174         }
175         for (Pump p : pump) {
176             p.register(this);
177         }
178         return this;
179     }
180 
181     public final Future&lt;Void&gt; process() {
182         if (!processing.compareAndSet(false, true)) {
183             throw new IllegalStateException(&quot;Can not re-run the processing&quot;);
184         }
185         FutureTask&lt;Void&gt; result = new FutureTask&lt;&gt;(this, null);
186         Thread t = new Thread(result);
187         t.setDaemon(true);
188         t.start();
189 
190         return result;
191     }
192 }
    </pre>
  </body>
</html>
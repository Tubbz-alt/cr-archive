<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/lib/jdk/test/lib/cds/CDSTestUtils.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../artifacts/JibArtifactManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../cli/CommandLineOptionTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/lib/jdk/test/lib/cds/CDSTestUtils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.test.lib.cds;
 24 
 25 import java.io.IOException;
 26 import java.io.File;
 27 import java.io.FileOutputStream;
 28 import java.io.PrintStream;
 29 import java.text.SimpleDateFormat;
 30 import java.util.ArrayList;
 31 import java.util.Date;
 32 import jdk.test.lib.Utils;
 33 import jdk.test.lib.process.OutputAnalyzer;
 34 import jdk.test.lib.process.ProcessTools;
 35 import jtreg.SkippedException;
 36 
 37 // This class contains common test utilities for testing CDS
 38 public class CDSTestUtils {
 39     public static final String MSG_RANGE_NOT_WITHIN_HEAP =
 40         &quot;UseSharedSpaces: Unable to allocate region, range is not within java heap.&quot;;
 41     public static final String MSG_RANGE_ALREADT_IN_USE =
 42         &quot;Unable to allocate region, java heap range is already in use.&quot;;
<span class="line-modified"> 43     public static final String MSG_COMPRESSION_MUST_BE_USED =</span>
<span class="line-modified"> 44         &quot;Unable to use shared archive: UseCompressedOops and UseCompressedClassPointers must be on for UseSharedSpaces.&quot;;</span>
 45 
 46     public interface Checker {
 47         public void check(OutputAnalyzer output) throws Exception;
 48     }
 49 
 50     /*
 51      * INTRODUCTION
 52      *
 53      * When testing various CDS functionalities, we need to launch JVM processes
 54      * using a &quot;launch method&quot; (such as TestCommon.run), and analyze the results of these
 55      * processes.
 56      *
 57      * While typical jtreg tests would use OutputAnalyzer in such cases, due to the
 58      * complexity of CDS failure modes, we have added the CDSTestUtils.Result class
 59      * to make the analysis more convenient and less error prone.
 60      *
 61      * A Java process can end in one of the following 4 states:
 62      *
 63      *    1: Unexpected error - such as JVM crashing. In this case, the &quot;launch method&quot;
 64      *                          will throw a RuntimeException.
</pre>
<hr />
<pre>
229     // To specify suffix explicitly use CDSOptions.addSuffix()
230     public static OutputAnalyzer createArchive(String... cliPrefix)
231         throws Exception {
232         return createArchive((new CDSOptions()).addPrefix(cliPrefix));
233     }
234 
235     // Create bootstrap CDS archive
236     public static OutputAnalyzer createArchive(CDSOptions opts)
237         throws Exception {
238 
239         startNewArchiveName();
240 
241         ArrayList&lt;String&gt; cmd = new ArrayList&lt;String&gt;();
242 
243         for (String p : opts.prefix) cmd.add(p);
244 
245         cmd.add(&quot;-Xshare:dump&quot;);
246         cmd.add(&quot;-Xlog:cds,cds+hashtables&quot;);
247         if (opts.archiveName == null)
248             opts.archiveName = getDefaultArchiveName();
<span class="line-modified">249         cmd.add(&quot;-XX:SharedArchiveFile=./&quot; + opts.archiveName);</span>
250 
251         if (opts.classList != null) {
252             File classListFile = makeClassList(opts.classList);
253             cmd.add(&quot;-XX:ExtraSharedClassListFile=&quot; + classListFile.getPath());
254         }
255 
256         for (String s : opts.suffix) cmd.add(s);
257 
258         String[] cmdLine = cmd.toArray(new String[cmd.size()]);
259         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, cmdLine);
260         return executeAndLog(pb, &quot;dump&quot;);
261     }
262 



263 
264     // check result of &#39;dump-the-archive&#39; operation, that is &quot;-Xshare:dump&quot;
265     public static OutputAnalyzer checkDump(OutputAnalyzer output, String... extraMatches)
266         throws Exception {
267 
<span class="line-modified">268         output.shouldContain(&quot;Loading classes to share&quot;);</span>





269         output.shouldHaveExitValue(0);
270 
271         for (String match : extraMatches) {
272             output.shouldContain(match);
273         }
274 
275         return output;
276     }
277 
278 
279     // A commonly used convenience methods to create an archive and check the results
280     // Creates an archive and checks for errors
281     public static OutputAnalyzer createArchiveAndCheck(CDSOptions opts)
282         throws Exception {
283         return checkDump(createArchive(opts));
284     }
285 
286 
287     public static OutputAnalyzer createArchiveAndCheck(String... cliPrefix)
288         throws Exception {
289         return checkDump(createArchive(cliPrefix));
290     }
291 
292 
293     // This method should be used to check the output of child VM for common exceptions.
294     // Most of CDS tests deal with child VM processes for creating and using the archive.
295     // However exceptions that occur in the child process do not automatically propagate
296     // to the parent process. This mechanism aims to improve the propagation
297     // of exceptions and common errors.
298     // Exception e argument - an exception to be re-thrown if none of the common
299     // exceptions match. Pass null if you wish not to re-throw any exception.
300     public static void checkCommonExecExceptions(OutputAnalyzer output, Exception e)
301         throws Exception {
<span class="line-modified">302         if (output.getStdout().contains(&quot;http://bugreport.java.com/bugreport/crash.jsp&quot;)) {</span>
303             throw new RuntimeException(&quot;Hotspot crashed&quot;);
304         }
305         if (output.getStdout().contains(&quot;TEST FAILED&quot;)) {
306             throw new RuntimeException(&quot;Test Failed&quot;);
307         }
308         if (output.getOutput().contains(&quot;Unable to unmap shared space&quot;)) {
309             throw new RuntimeException(&quot;Unable to unmap shared space&quot;);
310         }
311 
312         // Special case -- sometimes Xshare:on fails because it failed to map
313         // at given address. This behavior is platform-specific, machine config-specific
314         // and can be random (see ASLR).
315         if (isUnableToMap(output)) {
316             throw new SkippedException(UnableToMapMsg);
317         }
318 
319         if (e != null) {
320             throw e;
321         }
322     }
</pre>
<hr />
<pre>
330     // Performance note: this check seems to be rather costly - searching the entire
331     // output stream of a child process for multiple strings. However, it is necessary
332     // to detect this condition, a failure to map an archive, since this is not a real
333     // failure of the test or VM operation, and results in a test being &quot;skipped&quot;.
334     // Suggestions to improve:
335     // 1. VM can designate a special exit code for such condition.
336     // 2. VM can print a single distinct string indicating failure to map an archive,
337     //    instead of utilizing multiple messages.
338     // These are suggestions to improve testibility of the VM. However, implementing them
339     // could also improve usability in the field.
340     public static boolean isUnableToMap(OutputAnalyzer output) {
341         String outStr = output.getOutput();
342         if ((output.getExitValue() == 1) &amp;&amp; (
343             outStr.contains(&quot;Unable to reserve shared space at required address&quot;) ||
344             outStr.contains(&quot;Unable to map ReadOnly shared space at required address&quot;) ||
345             outStr.contains(&quot;Unable to map ReadWrite shared space at required address&quot;) ||
346             outStr.contains(&quot;Unable to map MiscData shared space at required address&quot;) ||
347             outStr.contains(&quot;Unable to map MiscCode shared space at required address&quot;) ||
348             outStr.contains(&quot;Unable to map OptionalData shared space at required address&quot;) ||
349             outStr.contains(&quot;Could not allocate metaspace at a compatible address&quot;) ||
<span class="line-modified">350             outStr.contains(&quot;UseSharedSpaces: Unable to allocate region, range is not within java heap&quot;) ))</span>

351         {
352             return true;
353         }
354 
355         return false;
356     }
357 
358     public static void checkMappingFailure(OutputAnalyzer out) throws SkippedException {
359         if (isUnableToMap(out)) {
360             throw new SkippedException(UnableToMapMsg);
361         }
362     }
363 
364     public static Result run(String... cliPrefix) throws Exception {
365         CDSOptions opts = new CDSOptions();
366         opts.setArchiveName(getDefaultArchiveName());
367         opts.addPrefix(cliPrefix);
368         return new Result(opts, runWithArchive(opts));
369     }
370 
</pre>
<hr />
<pre>
573         writeFile(getOutputFile(outputFileNamePrefix + &quot;.stderr&quot;), output.getStderr());
574         System.out.println(&quot;[ELAPSED: &quot; + (System.currentTimeMillis() - started) + &quot; ms]&quot;);
575         System.out.println(&quot;[logging stdout to &quot; + outputFileNamePrefix + &quot;.stdout]&quot;);
576         System.out.println(&quot;[logging stderr to &quot; + outputFileNamePrefix + &quot;.stderr]&quot;);
577         System.out.println(&quot;[STDERR]\n&quot; + output.getStderr());
578 
579         if (copyChildStdoutToMainStdout)
580             System.out.println(&quot;[STDOUT]\n&quot; + output.getStdout());
581 
582         return output;
583     }
584 
585 
586     private static void writeFile(File file, String content) throws Exception {
587         FileOutputStream fos = new FileOutputStream(file);
588         PrintStream ps = new PrintStream(fos);
589         ps.print(content);
590         ps.close();
591         fos.close();
592     }




























































593 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.test.lib.cds;
 24 
 25 import java.io.IOException;
 26 import java.io.File;
 27 import java.io.FileOutputStream;
 28 import java.io.PrintStream;
 29 import java.text.SimpleDateFormat;
 30 import java.util.ArrayList;
 31 import java.util.Date;
 32 import jdk.test.lib.Utils;
 33 import jdk.test.lib.process.OutputAnalyzer;
 34 import jdk.test.lib.process.ProcessTools;
 35 import jtreg.SkippedException;
 36 
 37 // This class contains common test utilities for testing CDS
 38 public class CDSTestUtils {
 39     public static final String MSG_RANGE_NOT_WITHIN_HEAP =
 40         &quot;UseSharedSpaces: Unable to allocate region, range is not within java heap.&quot;;
 41     public static final String MSG_RANGE_ALREADT_IN_USE =
 42         &quot;Unable to allocate region, java heap range is already in use.&quot;;
<span class="line-modified"> 43 </span>
<span class="line-modified"> 44     public static final boolean DYNAMIC_DUMP = Boolean.getBoolean(&quot;test.dynamic.cds.archive&quot;);</span>
 45 
 46     public interface Checker {
 47         public void check(OutputAnalyzer output) throws Exception;
 48     }
 49 
 50     /*
 51      * INTRODUCTION
 52      *
 53      * When testing various CDS functionalities, we need to launch JVM processes
 54      * using a &quot;launch method&quot; (such as TestCommon.run), and analyze the results of these
 55      * processes.
 56      *
 57      * While typical jtreg tests would use OutputAnalyzer in such cases, due to the
 58      * complexity of CDS failure modes, we have added the CDSTestUtils.Result class
 59      * to make the analysis more convenient and less error prone.
 60      *
 61      * A Java process can end in one of the following 4 states:
 62      *
 63      *    1: Unexpected error - such as JVM crashing. In this case, the &quot;launch method&quot;
 64      *                          will throw a RuntimeException.
</pre>
<hr />
<pre>
229     // To specify suffix explicitly use CDSOptions.addSuffix()
230     public static OutputAnalyzer createArchive(String... cliPrefix)
231         throws Exception {
232         return createArchive((new CDSOptions()).addPrefix(cliPrefix));
233     }
234 
235     // Create bootstrap CDS archive
236     public static OutputAnalyzer createArchive(CDSOptions opts)
237         throws Exception {
238 
239         startNewArchiveName();
240 
241         ArrayList&lt;String&gt; cmd = new ArrayList&lt;String&gt;();
242 
243         for (String p : opts.prefix) cmd.add(p);
244 
245         cmd.add(&quot;-Xshare:dump&quot;);
246         cmd.add(&quot;-Xlog:cds,cds+hashtables&quot;);
247         if (opts.archiveName == null)
248             opts.archiveName = getDefaultArchiveName();
<span class="line-modified">249         cmd.add(&quot;-XX:SharedArchiveFile=&quot; + opts.archiveName);</span>
250 
251         if (opts.classList != null) {
252             File classListFile = makeClassList(opts.classList);
253             cmd.add(&quot;-XX:ExtraSharedClassListFile=&quot; + classListFile.getPath());
254         }
255 
256         for (String s : opts.suffix) cmd.add(s);
257 
258         String[] cmdLine = cmd.toArray(new String[cmd.size()]);
259         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, cmdLine);
260         return executeAndLog(pb, &quot;dump&quot;);
261     }
262 
<span class="line-added">263     public static boolean isDynamicArchive() {</span>
<span class="line-added">264         return DYNAMIC_DUMP;</span>
<span class="line-added">265     }</span>
266 
267     // check result of &#39;dump-the-archive&#39; operation, that is &quot;-Xshare:dump&quot;
268     public static OutputAnalyzer checkDump(OutputAnalyzer output, String... extraMatches)
269         throws Exception {
270 
<span class="line-modified">271         if (!DYNAMIC_DUMP) {</span>
<span class="line-added">272             output.shouldContain(&quot;Loading classes to share&quot;);</span>
<span class="line-added">273         } else {</span>
<span class="line-added">274             output.shouldContain(&quot;Buffer-space to target-space delta&quot;)</span>
<span class="line-added">275                   .shouldContain(&quot;Written dynamic archive 0x&quot;);</span>
<span class="line-added">276         }</span>
277         output.shouldHaveExitValue(0);
278 
279         for (String match : extraMatches) {
280             output.shouldContain(match);
281         }
282 
283         return output;
284     }
285 
286 
287     // A commonly used convenience methods to create an archive and check the results
288     // Creates an archive and checks for errors
289     public static OutputAnalyzer createArchiveAndCheck(CDSOptions opts)
290         throws Exception {
291         return checkDump(createArchive(opts));
292     }
293 
294 
295     public static OutputAnalyzer createArchiveAndCheck(String... cliPrefix)
296         throws Exception {
297         return checkDump(createArchive(cliPrefix));
298     }
299 
300 
301     // This method should be used to check the output of child VM for common exceptions.
302     // Most of CDS tests deal with child VM processes for creating and using the archive.
303     // However exceptions that occur in the child process do not automatically propagate
304     // to the parent process. This mechanism aims to improve the propagation
305     // of exceptions and common errors.
306     // Exception e argument - an exception to be re-thrown if none of the common
307     // exceptions match. Pass null if you wish not to re-throw any exception.
308     public static void checkCommonExecExceptions(OutputAnalyzer output, Exception e)
309         throws Exception {
<span class="line-modified">310         if (output.getStdout().contains(&quot;https://bugreport.java.com/bugreport/crash.jsp&quot;)) {</span>
311             throw new RuntimeException(&quot;Hotspot crashed&quot;);
312         }
313         if (output.getStdout().contains(&quot;TEST FAILED&quot;)) {
314             throw new RuntimeException(&quot;Test Failed&quot;);
315         }
316         if (output.getOutput().contains(&quot;Unable to unmap shared space&quot;)) {
317             throw new RuntimeException(&quot;Unable to unmap shared space&quot;);
318         }
319 
320         // Special case -- sometimes Xshare:on fails because it failed to map
321         // at given address. This behavior is platform-specific, machine config-specific
322         // and can be random (see ASLR).
323         if (isUnableToMap(output)) {
324             throw new SkippedException(UnableToMapMsg);
325         }
326 
327         if (e != null) {
328             throw e;
329         }
330     }
</pre>
<hr />
<pre>
338     // Performance note: this check seems to be rather costly - searching the entire
339     // output stream of a child process for multiple strings. However, it is necessary
340     // to detect this condition, a failure to map an archive, since this is not a real
341     // failure of the test or VM operation, and results in a test being &quot;skipped&quot;.
342     // Suggestions to improve:
343     // 1. VM can designate a special exit code for such condition.
344     // 2. VM can print a single distinct string indicating failure to map an archive,
345     //    instead of utilizing multiple messages.
346     // These are suggestions to improve testibility of the VM. However, implementing them
347     // could also improve usability in the field.
348     public static boolean isUnableToMap(OutputAnalyzer output) {
349         String outStr = output.getOutput();
350         if ((output.getExitValue() == 1) &amp;&amp; (
351             outStr.contains(&quot;Unable to reserve shared space at required address&quot;) ||
352             outStr.contains(&quot;Unable to map ReadOnly shared space at required address&quot;) ||
353             outStr.contains(&quot;Unable to map ReadWrite shared space at required address&quot;) ||
354             outStr.contains(&quot;Unable to map MiscData shared space at required address&quot;) ||
355             outStr.contains(&quot;Unable to map MiscCode shared space at required address&quot;) ||
356             outStr.contains(&quot;Unable to map OptionalData shared space at required address&quot;) ||
357             outStr.contains(&quot;Could not allocate metaspace at a compatible address&quot;) ||
<span class="line-modified">358             outStr.contains(&quot;UseSharedSpaces: Unable to allocate region, range is not within java heap&quot;) ||</span>
<span class="line-added">359             outStr.contains(&quot;DynamicDumpSharedSpaces is unsupported when base CDS archive is not loaded&quot;) ))</span>
360         {
361             return true;
362         }
363 
364         return false;
365     }
366 
367     public static void checkMappingFailure(OutputAnalyzer out) throws SkippedException {
368         if (isUnableToMap(out)) {
369             throw new SkippedException(UnableToMapMsg);
370         }
371     }
372 
373     public static Result run(String... cliPrefix) throws Exception {
374         CDSOptions opts = new CDSOptions();
375         opts.setArchiveName(getDefaultArchiveName());
376         opts.addPrefix(cliPrefix);
377         return new Result(opts, runWithArchive(opts));
378     }
379 
</pre>
<hr />
<pre>
582         writeFile(getOutputFile(outputFileNamePrefix + &quot;.stderr&quot;), output.getStderr());
583         System.out.println(&quot;[ELAPSED: &quot; + (System.currentTimeMillis() - started) + &quot; ms]&quot;);
584         System.out.println(&quot;[logging stdout to &quot; + outputFileNamePrefix + &quot;.stdout]&quot;);
585         System.out.println(&quot;[logging stderr to &quot; + outputFileNamePrefix + &quot;.stderr]&quot;);
586         System.out.println(&quot;[STDERR]\n&quot; + output.getStderr());
587 
588         if (copyChildStdoutToMainStdout)
589             System.out.println(&quot;[STDOUT]\n&quot; + output.getStdout());
590 
591         return output;
592     }
593 
594 
595     private static void writeFile(File file, String content) throws Exception {
596         FileOutputStream fos = new FileOutputStream(file);
597         PrintStream ps = new PrintStream(fos);
598         ps.print(content);
599         ps.close();
600         fos.close();
601     }
<span class="line-added">602 </span>
<span class="line-added">603     // Format a line that defines an extra symbol in the file specify by -XX:SharedArchiveConfigFile=&lt;file&gt;</span>
<span class="line-added">604     public static String formatArchiveConfigSymbol(String symbol) {</span>
<span class="line-added">605         int refCount = -1; // This is always -1 in the current HotSpot implementation.</span>
<span class="line-added">606         if (isAsciiPrintable(symbol)) {</span>
<span class="line-added">607             return symbol.length() + &quot; &quot; + refCount + &quot;: &quot; + symbol;</span>
<span class="line-added">608         } else {</span>
<span class="line-added">609             StringBuilder sb = new StringBuilder();</span>
<span class="line-added">610             int utf8_length = escapeArchiveConfigString(sb, symbol);</span>
<span class="line-added">611             return utf8_length + &quot; &quot; + refCount + &quot;: &quot; + sb.toString();</span>
<span class="line-added">612         }</span>
<span class="line-added">613     }</span>
<span class="line-added">614 </span>
<span class="line-added">615     // This method generates the same format as HashtableTextDump::put_utf8() in HotSpot,</span>
<span class="line-added">616     // to be used by -XX:SharedArchiveConfigFile=&lt;file&gt;.</span>
<span class="line-added">617     private static int escapeArchiveConfigString(StringBuilder sb, String s) {</span>
<span class="line-added">618         byte arr[];</span>
<span class="line-added">619         try {</span>
<span class="line-added">620             arr = s.getBytes(&quot;UTF8&quot;);</span>
<span class="line-added">621         } catch (java.io.UnsupportedEncodingException e) {</span>
<span class="line-added">622             throw new RuntimeException(&quot;Unexpected&quot;, e);</span>
<span class="line-added">623         }</span>
<span class="line-added">624         for (int i = 0; i &lt; arr.length; i++) {</span>
<span class="line-added">625             char ch = (char)(arr[i] &amp; 0xff);</span>
<span class="line-added">626             if (isAsciiPrintable(ch)) {</span>
<span class="line-added">627                 sb.append(ch);</span>
<span class="line-added">628             } else if (ch == &#39;\t&#39;) {</span>
<span class="line-added">629                 sb.append(&quot;\\t&quot;);</span>
<span class="line-added">630             } else if (ch == &#39;\r&#39;) {</span>
<span class="line-added">631                 sb.append(&quot;\\r&quot;);</span>
<span class="line-added">632             } else if (ch == &#39;\n&#39;) {</span>
<span class="line-added">633                 sb.append(&quot;\\n&quot;);</span>
<span class="line-added">634             } else if (ch == &#39;\\&#39;) {</span>
<span class="line-added">635                 sb.append(&quot;\\\\&quot;);</span>
<span class="line-added">636             } else {</span>
<span class="line-added">637                 String hex = Integer.toHexString(ch);</span>
<span class="line-added">638                 if (ch &lt; 16) {</span>
<span class="line-added">639                     sb.append(&quot;\\x0&quot;);</span>
<span class="line-added">640                 } else {</span>
<span class="line-added">641                     sb.append(&quot;\\x&quot;);</span>
<span class="line-added">642                 }</span>
<span class="line-added">643                 sb.append(hex);</span>
<span class="line-added">644             }</span>
<span class="line-added">645         }</span>
<span class="line-added">646 </span>
<span class="line-added">647         return arr.length;</span>
<span class="line-added">648     }</span>
<span class="line-added">649 </span>
<span class="line-added">650     private static boolean isAsciiPrintable(String s) {</span>
<span class="line-added">651         for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="line-added">652             if (!isAsciiPrintable(s.charAt(i))) {</span>
<span class="line-added">653                 return false;</span>
<span class="line-added">654             }</span>
<span class="line-added">655         }</span>
<span class="line-added">656         return true;</span>
<span class="line-added">657     }</span>
<span class="line-added">658 </span>
<span class="line-added">659     private static boolean isAsciiPrintable(char ch) {</span>
<span class="line-added">660         return ch &gt;= 32 &amp;&amp; ch &lt; 127;</span>
<span class="line-added">661     }</span>
662 }
</pre>
</td>
</tr>
</table>
<center><a href="../artifacts/JibArtifactManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../cli/CommandLineOptionTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
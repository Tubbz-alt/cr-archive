<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/lib/jdk/test/lib/Utils.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib;
 25 
 26 import java.io.File;
 27 import java.io.IOException;
 28 import java.net.InetAddress;
 29 import java.net.InetSocketAddress;
 30 import java.net.MalformedURLException;
 31 import java.net.ServerSocket;
 32 import java.net.URL;
 33 import java.net.URLClassLoader;
 34 import java.net.UnknownHostException;
 35 import java.nio.file.Files;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.nio.file.attribute.FileAttribute;
 39 import java.nio.channels.SocketChannel;
 40 import java.util.ArrayList;
 41 import java.util.Arrays;
 42 import java.util.Collection;
 43 import java.util.Collections;
 44 import java.util.Iterator;
 45 import java.util.Map;
 46 import java.util.HashMap;
 47 import java.util.List;
 48 import java.util.Objects;
 49 import java.util.Random;
 50 import java.util.function.BooleanSupplier;
 51 import java.util.concurrent.TimeUnit;
 52 import java.util.function.Consumer;
 53 import java.util.function.Function;
 54 import java.util.regex.Matcher;
 55 import java.util.regex.Pattern;
 56 
 57 import static jdk.test.lib.Asserts.assertTrue;
 58 import jdk.test.lib.process.ProcessTools;
 59 import jdk.test.lib.process.OutputAnalyzer;
 60 
 61 /**
 62  * Common library for various test helper functions.
 63  */
 64 public final class Utils {
 65 
 66     /**
 67      * Returns the value of &#39;test.class.path&#39; system property.
 68      */
 69     public static final String TEST_CLASS_PATH = System.getProperty(&quot;test.class.path&quot;, &quot;.&quot;);
 70 
 71     /**
 72      * Returns the sequence used by operating system to separate lines.
 73      */
 74     public static final String NEW_LINE = System.getProperty(&quot;line.separator&quot;);
 75 
 76     /**
 77      * Returns the value of &#39;test.vm.opts&#39; system property.
 78      */
 79     public static final String VM_OPTIONS = System.getProperty(&quot;test.vm.opts&quot;, &quot;&quot;).trim();
 80 
 81     /**
 82      * Returns the value of &#39;test.java.opts&#39; system property.
 83      */
 84     public static final String JAVA_OPTIONS = System.getProperty(&quot;test.java.opts&quot;, &quot;&quot;).trim();
 85 
 86     /**
 87      * Returns the value of &#39;test.src&#39; system property.
 88      */
 89     public static final String TEST_SRC = System.getProperty(&quot;test.src&quot;, &quot;&quot;).trim();
 90 
 91     /**
 92      * Returns the value of &#39;test.root&#39; system property.
 93      */
 94     public static final String TEST_ROOT = System.getProperty(&quot;test.root&quot;, &quot;&quot;).trim();
 95 
 96     /*
 97      * Returns the value of &#39;test.jdk&#39; system property
 98      */
 99     public static final String TEST_JDK = System.getProperty(&quot;test.jdk&quot;);
100 
101     /*
102      * Returns the value of &#39;compile.jdk&#39; system property
103      */
104     public static final String COMPILE_JDK = System.getProperty(&quot;compile.jdk&quot;, TEST_JDK);
105 
106     /**
107      * Returns the value of &#39;test.classes&#39; system property
108      */
109     public static final String TEST_CLASSES = System.getProperty(&quot;test.classes&quot;, &quot;.&quot;);
110 
111     /**
112      * Defines property name for seed value.
113      */
114     public static final String SEED_PROPERTY_NAME = &quot;jdk.test.lib.random.seed&quot;;
115 
116     /* (non-javadoc)
117      * Random generator with (or without) predefined seed. Depends on
118      * &quot;jdk.test.lib.random.seed&quot; property value.
119      */
120     private static volatile Random RANDOM_GENERATOR;
121 
122     /**
123      * Contains the seed value used for {@link java.util.Random} creation.
124      */
125     public static final long SEED = Long.getLong(SEED_PROPERTY_NAME, new Random().nextLong());
126     /**
127      * Returns the value of &#39;test.timeout.factor&#39; system property
128      * converted to {@code double}.
129      */
130     public static final double TIMEOUT_FACTOR;
131     static {
132         String toFactor = System.getProperty(&quot;test.timeout.factor&quot;, &quot;1.0&quot;);
133         TIMEOUT_FACTOR = Double.parseDouble(toFactor);
134     }
135 
136     /**
137      * Returns the value of JTREG default test timeout in milliseconds
138      * converted to {@code long}.
139      */
140     public static final long DEFAULT_TEST_TIMEOUT = TimeUnit.SECONDS.toMillis(120);
141 
142     private Utils() {
143         // Private constructor to prevent class instantiation
144     }
145 
146     /**
147      * Returns the list of VM options.
148      *
149      * @return List of VM options
150      */
151     public static List&lt;String&gt; getVmOptions() {
152         return Arrays.asList(safeSplitString(VM_OPTIONS));
153     }
154 
155     /**
156      * Returns the list of VM options with -J prefix.
157      *
158      * @return The list of VM options with -J prefix
159      */
160     public static List&lt;String&gt; getForwardVmOptions() {
161         String[] opts = safeSplitString(VM_OPTIONS);
162         for (int i = 0; i &lt; opts.length; i++) {
163             opts[i] = &quot;-J&quot; + opts[i];
164         }
165         return Arrays.asList(opts);
166     }
167 
168     /**
169      * Returns the default JTReg arguments for a jvm running a test.
170      * This is the combination of JTReg arguments test.vm.opts and test.java.opts.
171      * @return An array of options, or an empty array if no options.
172      */
173     public static String[] getTestJavaOpts() {
174         List&lt;String&gt; opts = new ArrayList&lt;String&gt;();
175         Collections.addAll(opts, safeSplitString(VM_OPTIONS));
176         Collections.addAll(opts, safeSplitString(JAVA_OPTIONS));
177         return opts.toArray(new String[0]);
178     }
179 
180     /**
181      * Combines given arguments with default JTReg arguments for a jvm running a test.
182      * This is the combination of JTReg arguments test.vm.opts and test.java.opts
183      * @return The combination of JTReg test java options and user args.
184      */
185     public static String[] addTestJavaOpts(String... userArgs) {
186         List&lt;String&gt; opts = new ArrayList&lt;String&gt;();
187         Collections.addAll(opts, getTestJavaOpts());
188         Collections.addAll(opts, userArgs);
189         return opts.toArray(new String[0]);
190     }
191 
192     /**
193      * Removes any options specifying which GC to use, for example &quot;-XX:+UseG1GC&quot;.
194      * Removes any options matching: -XX:(+/-)Use*GC
195      * Used when a test need to set its own GC version. Then any
196      * GC specified by the framework must first be removed.
197      * @return A copy of given opts with all GC options removed.
198      */
199     private static final Pattern useGcPattern = Pattern.compile(
200             &quot;(?:\\-XX\\:[\\+\\-]Use.+GC)&quot;
201             + &quot;|(?:\\-Xconcgc)&quot;);
202     public static List&lt;String&gt; removeGcOpts(List&lt;String&gt; opts) {
203         List&lt;String&gt; optsWithoutGC = new ArrayList&lt;String&gt;();
204         for (String opt : opts) {
205             if (useGcPattern.matcher(opt).matches()) {
206                 System.out.println(&quot;removeGcOpts: removed &quot; + opt);
207             } else {
208                 optsWithoutGC.add(opt);
209             }
210         }
211         return optsWithoutGC;
212     }
213 
214     /**
215      * Returns the default JTReg arguments for a jvm running a test without
216      * options that matches regular expressions in {@code filters}.
217      * This is the combination of JTReg arguments test.vm.opts and test.java.opts.
218      * @param filters Regular expressions used to filter out options.
219      * @return An array of options, or an empty array if no options.
220      */
221     public static String[] getFilteredTestJavaOpts(String... filters) {
222         String options[] = getTestJavaOpts();
223 
224         if (filters.length == 0) {
225             return options;
226         }
227 
228         List&lt;String&gt; filteredOptions = new ArrayList&lt;String&gt;(options.length);
229         Pattern patterns[] = new Pattern[filters.length];
230         for (int i = 0; i &lt; filters.length; i++) {
231             patterns[i] = Pattern.compile(filters[i]);
232         }
233 
234         for (String option : options) {
235             boolean matched = false;
236             for (int i = 0; i &lt; patterns.length &amp;&amp; !matched; i++) {
237                 Matcher matcher = patterns[i].matcher(option);
238                 matched = matcher.find();
239             }
240             if (!matched) {
241                 filteredOptions.add(option);
242             }
243         }
244 
245         return filteredOptions.toArray(new String[filteredOptions.size()]);
246     }
247 
248     /**
249      * Splits a string by white space.
250      * Works like String.split(), but returns an empty array
251      * if the string is null or empty.
252      */
253     private static String[] safeSplitString(String s) {
254         if (s == null || s.trim().isEmpty()) {
255             return new String[] {};
256         }
257         return s.trim().split(&quot;\\s+&quot;);
258     }
259 
260     /**
261      * @return The full command line for the ProcessBuilder.
262      */
263     public static String getCommandLine(ProcessBuilder pb) {
264         StringBuilder cmd = new StringBuilder();
265         for (String s : pb.command()) {
266             cmd.append(s).append(&quot; &quot;);
267         }
268         return cmd.toString();
269     }
270 
271     /**
272      * Returns the socket address of an endpoint that refuses connections. The
273      * endpoint is an InetSocketAddress where the address is the loopback address
274      * and the port is a system port (1-1023 range).
275      * This method is a better choice than getFreePort for tests that need
276      * an endpoint that refuses connections.
277      */
278     public static InetSocketAddress refusingEndpoint() {
279         InetAddress lb = InetAddress.getLoopbackAddress();
280         int port = 1;
281         while (port &lt; 1024) {
282             InetSocketAddress sa = new InetSocketAddress(lb, port);
283             try {
284                 SocketChannel.open(sa).close();
285             } catch (IOException ioe) {
286                 return sa;
287             }
288             port++;
289         }
290         throw new RuntimeException(&quot;Unable to find system port that is refusing connections&quot;);
291     }
292 
293     /**
294      * Returns the free port on the local host.
295      *
296      * @return The port number
297      * @throws IOException if an I/O error occurs when opening the socket
298      */
299     public static int getFreePort() throws IOException {
300         try (ServerSocket serverSocket =
301                 new ServerSocket(0, 5, InetAddress.getLoopbackAddress());) {
302             return serverSocket.getLocalPort();
303         }
304     }
305 
306     /**
307      * Returns the name of the local host.
308      *
309      * @return The host name
310      * @throws UnknownHostException if IP address of a host could not be determined
311      */
312     public static String getHostname() throws UnknownHostException {
313         InetAddress inetAddress = InetAddress.getLocalHost();
314         String hostName = inetAddress.getHostName();
315 
316         assertTrue((hostName != null &amp;&amp; !hostName.isEmpty()),
317                 &quot;Cannot get hostname&quot;);
318 
319         return hostName;
320     }
321 
322     /**
323      * Uses &quot;jcmd -l&quot; to search for a jvm pid. This function will wait
324      * forever (until jtreg timeout) for the pid to be found.
325      * @param key Regular expression to search for
326      * @return The found pid.
327      */
328     public static int waitForJvmPid(String key) throws Throwable {
329         final long iterationSleepMillis = 250;
330         System.out.println(&quot;waitForJvmPid: Waiting for key &#39;&quot; + key + &quot;&#39;&quot;);
331         System.out.flush();
332         while (true) {
333             int pid = tryFindJvmPid(key);
334             if (pid &gt;= 0) {
335                 return pid;
336             }
337             Thread.sleep(iterationSleepMillis);
338         }
339     }
340 
341     /**
342      * Searches for a jvm pid in the output from &quot;jcmd -l&quot;.
343      *
344      * Example output from jcmd is:
345      * 12498 sun.tools.jcmd.JCmd -l
346      * 12254 /tmp/jdk8/tl/jdk/JTwork/classes/com/sun/tools/attach/Application.jar
347      *
348      * @param key A regular expression to search for.
349      * @return The found pid, or -1 if not found.
350      * @throws Exception If multiple matching jvms are found.
351      */
352     public static int tryFindJvmPid(String key) throws Throwable {
353         OutputAnalyzer output = null;
354         try {
355             JDKToolLauncher jcmdLauncher = JDKToolLauncher.create(&quot;jcmd&quot;);
356             jcmdLauncher.addToolArg(&quot;-l&quot;);
357             output = ProcessTools.executeProcess(jcmdLauncher.getCommand());
358             output.shouldHaveExitValue(0);
359 
360             // Search for a line starting with numbers (pid), follwed by the key.
361             Pattern pattern = Pattern.compile(&quot;([0-9]+)\\s.*(&quot; + key + &quot;).*\\r?\\n&quot;);
362             Matcher matcher = pattern.matcher(output.getStdout());
363 
364             int pid = -1;
365             if (matcher.find()) {
366                 pid = Integer.parseInt(matcher.group(1));
367                 System.out.println(&quot;findJvmPid.pid: &quot; + pid);
368                 if (matcher.find()) {
369                     throw new Exception(&quot;Found multiple JVM pids for key: &quot; + key);
370                 }
371             }
372             return pid;
373         } catch (Throwable t) {
374             System.out.println(String.format(&quot;Utils.findJvmPid(%s) failed: %s&quot;, key, t));
375             throw t;
376         }
377     }
378 
379     /**
380      * Adjusts the provided timeout value for the TIMEOUT_FACTOR
381      * @param tOut the timeout value to be adjusted
382      * @return The timeout value adjusted for the value of &quot;test.timeout.factor&quot;
383      *         system property
384      */
385     public static long adjustTimeout(long tOut) {
386         return Math.round(tOut * Utils.TIMEOUT_FACTOR);
387     }
388 
389     /**
390      * Return the contents of the named file as a single String,
391      * or null if not found.
392      * @param filename name of the file to read
393      * @return String contents of file, or null if file not found.
394      * @throws  IOException
395      *          if an I/O error occurs reading from the file or a malformed or
396      *          unmappable byte sequence is read
397      */
398     public static String fileAsString(String filename) throws IOException {
399         Path filePath = Paths.get(filename);
400         if (!Files.exists(filePath)) return null;
401         return new String(Files.readAllBytes(filePath));
402     }
403 
404     private static final char[] hexArray = new char[]{&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;};
405 
406     /**
407      * Returns hex view of byte array
408      *
409      * @param bytes byte array to process
410      * @return space separated hexadecimal string representation of bytes
411      */
412      public static String toHexString(byte[] bytes) {
413          char[] hexView = new char[bytes.length * 3 - 1];
414          for (int i = 0; i &lt; bytes.length - 1; i++) {
415              hexView[i * 3] = hexArray[(bytes[i] &gt;&gt; 4) &amp; 0x0F];
416              hexView[i * 3 + 1] = hexArray[bytes[i] &amp; 0x0F];
417              hexView[i * 3 + 2] = &#39; &#39;;
418          }
419          hexView[hexView.length - 2] = hexArray[(bytes[bytes.length - 1] &gt;&gt; 4) &amp; 0x0F];
420          hexView[hexView.length - 1] = hexArray[bytes[bytes.length - 1] &amp; 0x0F];
421          return new String(hexView);
422      }
423 
424      /**
425       * Returns byte array of hex view
426       *
427       * @param hex hexadecimal string representation
428       * @return byte array
429       */
430      public static byte[] toByteArray(String hex) {
431          int length = hex.length();
432          byte[] bytes = new byte[length / 2];
433          for (int i = 0; i &lt; length; i += 2) {
434              bytes[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) &lt;&lt; 4)
435                      + Character.digit(hex.charAt(i + 1), 16));
436          }
437          return bytes;
438      }
439 
440     /**
441      * Returns {@link java.util.Random} generator initialized with particular seed.
442      * The seed could be provided via system property {@link Utils#SEED_PROPERTY_NAME}
443      * In case no seed is provided, the method uses a random number.
444      * The used seed printed to stdout.
445      * @return {@link java.util.Random} generator with particular seed.
446      */
447     public static Random getRandomInstance() {
448         if (RANDOM_GENERATOR == null) {
449             synchronized (Utils.class) {
450                 if (RANDOM_GENERATOR == null) {
451                     RANDOM_GENERATOR = new Random(SEED);
452                     System.out.printf(&quot;For random generator using seed: %d%n&quot;, SEED);
453                     System.out.printf(&quot;To re-run test with same seed value please add \&quot;-D%s=%d\&quot; to command line.%n&quot;, SEED_PROPERTY_NAME, SEED);
454                 }
455             }
456         }
457         return RANDOM_GENERATOR;
458     }
459 
460     /**
461      * Returns random element of non empty collection
462      *
463      * @param &lt;T&gt; a type of collection element
464      * @param collection collection of elements
465      * @return random element of collection
466      * @throws IllegalArgumentException if collection is empty
467      */
468     public static &lt;T&gt; T getRandomElement(Collection&lt;T&gt; collection)
469             throws IllegalArgumentException {
470         if (collection.isEmpty()) {
471             throw new IllegalArgumentException(&quot;Empty collection&quot;);
472         }
473         Random random = getRandomInstance();
474         int elementIndex = 1 + random.nextInt(collection.size() - 1);
475         Iterator&lt;T&gt; iterator = collection.iterator();
476         while (--elementIndex != 0) {
477             iterator.next();
478         }
479         return iterator.next();
480     }
481 
482     /**
483      * Returns random element of non empty array
484      *
485      * @param &lt;T&gt; a type of array element
486      * @param array array of elements
487      * @return random element of array
488      * @throws IllegalArgumentException if array is empty
489      */
490     public static &lt;T&gt; T getRandomElement(T[] array)
491             throws IllegalArgumentException {
492         if (array == null || array.length == 0) {
493             throw new IllegalArgumentException(&quot;Empty or null array&quot;);
494         }
495         Random random = getRandomInstance();
496         return array[random.nextInt(array.length)];
497     }
498 
499     /**
500      * Wait for condition to be true
501      *
502      * @param condition, a condition to wait for
503      */
504     public static final void waitForCondition(BooleanSupplier condition) {
505         waitForCondition(condition, -1L, 100L);
506     }
507 
508     /**
509      * Wait until timeout for condition to be true
510      *
511      * @param condition, a condition to wait for
512      * @param timeout a time in milliseconds to wait for condition to be true
513      * specifying -1 will wait forever
514      * @return condition value, to determine if wait was successful
515      */
516     public static final boolean waitForCondition(BooleanSupplier condition,
517             long timeout) {
518         return waitForCondition(condition, timeout, 100L);
519     }
520 
521     /**
522      * Wait until timeout for condition to be true for specified time
523      *
524      * @param condition, a condition to wait for
525      * @param timeout a time in milliseconds to wait for condition to be true,
526      * specifying -1 will wait forever
527      * @param sleepTime a time to sleep value in milliseconds
528      * @return condition value, to determine if wait was successful
529      */
530     public static final boolean waitForCondition(BooleanSupplier condition,
531             long timeout, long sleepTime) {
532         long startTime = System.currentTimeMillis();
533         while (!(condition.getAsBoolean() || (timeout != -1L
534                 &amp;&amp; ((System.currentTimeMillis() - startTime) &gt; timeout)))) {
535             try {
536                 Thread.sleep(sleepTime);
537             } catch (InterruptedException e) {
538                 Thread.currentThread().interrupt();
539                 throw new Error(e);
540             }
541         }
542         return condition.getAsBoolean();
543     }
544 
545     /**
546      * Interface same as java.lang.Runnable but with
547      * method {@code run()} able to throw any Throwable.
548      */
549     public static interface ThrowingRunnable {
550         void run() throws Throwable;
551     }
552 
553     /**
554      * Filters out an exception that may be thrown by the given
555      * test according to the given filter.
556      *
557      * @param test - method that is invoked and checked for exception.
558      * @param filter - function that checks if the thrown exception matches
559      *                 criteria given in the filter&#39;s implementation.
560      * @return - exception that matches the filter if it has been thrown or
561      *           {@code null} otherwise.
562      * @throws Throwable - if test has thrown an exception that does not
563      *                     match the filter.
564      */
565     public static Throwable filterException(ThrowingRunnable test,
566             Function&lt;Throwable, Boolean&gt; filter) throws Throwable {
567         try {
568             test.run();
569         } catch (Throwable t) {
570             if (filter.apply(t)) {
571                 return t;
572             } else {
573                 throw t;
574             }
575         }
576         return null;
577     }
578 
579     /**
580      * Ensures a requested class is loaded
581      * @param aClass class to load
582      */
583     public static void ensureClassIsLoaded(Class&lt;?&gt; aClass) {
584         if (aClass == null) {
585             throw new Error(&quot;Requested null class&quot;);
586         }
587         try {
588             Class.forName(aClass.getName(), /* initialize = */ true,
589                     ClassLoader.getSystemClassLoader());
590         } catch (ClassNotFoundException e) {
591             throw new Error(&quot;Class not found&quot;, e);
592         }
593     }
594     /**
595      * @param parent a class loader to be the parent for the returned one
596      * @return an UrlClassLoader with urls made of the &#39;test.class.path&#39; jtreg
597      *         property and with the given parent
598      */
599     public static URLClassLoader getTestClassPathURLClassLoader(ClassLoader parent) {
600         URL[] urls = Arrays.stream(TEST_CLASS_PATH.split(File.pathSeparator))
601                 .map(Paths::get)
602                 .map(Path::toUri)
603                 .map(x -&gt; {
604                     try {
605                         return x.toURL();
606                     } catch (MalformedURLException ex) {
607                         throw new Error(&quot;Test issue. JTREG property&quot;
608                                 + &quot; &#39;test.class.path&#39;&quot;
609                                 + &quot; is not defined correctly&quot;, ex);
610                     }
611                 }).toArray(URL[]::new);
612         return new URLClassLoader(urls, parent);
613     }
614 
615     /**
616      * Runs runnable and checks that it throws expected exception. If exceptionException is null it means
617      * that we expect no exception to be thrown.
618      * @param runnable what we run
619      * @param expectedException expected exception
620      */
621     public static void runAndCheckException(ThrowingRunnable runnable, Class&lt;? extends Throwable&gt; expectedException) {
622         runAndCheckException(runnable, t -&gt; {
623             if (t == null) {
624                 if (expectedException != null) {
625                     throw new AssertionError(&quot;Didn&#39;t get expected exception &quot; + expectedException.getSimpleName());
626                 }
627             } else {
628                 String message = &quot;Got unexpected exception &quot; + t.getClass().getSimpleName();
629                 if (expectedException == null) {
630                     throw new AssertionError(message, t);
631                 } else if (!expectedException.isAssignableFrom(t.getClass())) {
632                     message += &quot; instead of &quot; + expectedException.getSimpleName();
633                     throw new AssertionError(message, t);
634                 }
635             }
636         });
637     }
638 
639     /**
640      * Runs runnable and makes some checks to ensure that it throws expected exception.
641      * @param runnable what we run
642      * @param checkException a consumer which checks that we got expected exception and raises a new exception otherwise
643      */
644     public static void runAndCheckException(ThrowingRunnable runnable, Consumer&lt;Throwable&gt; checkException) {
645         Throwable throwable = null;
646         try {
647             runnable.run();
648         } catch (Throwable t) {
649             throwable = t;
650         }
651         checkException.accept(throwable);
652     }
653 
654     /**
655      * Converts to VM type signature
656      *
657      * @param type Java type to convert
658      * @return string representation of VM type
659      */
660     public static String toJVMTypeSignature(Class&lt;?&gt; type) {
661         if (type.isPrimitive()) {
662             if (type == boolean.class) {
663                 return &quot;Z&quot;;
664             } else if (type == byte.class) {
665                 return &quot;B&quot;;
666             } else if (type == char.class) {
667                 return &quot;C&quot;;
668             } else if (type == double.class) {
669                 return &quot;D&quot;;
670             } else if (type == float.class) {
671                 return &quot;F&quot;;
672             } else if (type == int.class) {
673                 return &quot;I&quot;;
674             } else if (type == long.class) {
675                 return &quot;J&quot;;
676             } else if (type == short.class) {
677                 return &quot;S&quot;;
678             } else if (type == void.class) {
679                 return &quot;V&quot;;
680             } else {
681                 throw new Error(&quot;Unsupported type: &quot; + type);
682             }
683         }
684         String result = type.getName().replaceAll(&quot;\\.&quot;, &quot;/&quot;);
685         if (!type.isArray()) {
686             return &quot;L&quot; + result + &quot;;&quot;;
687         }
688         return result;
689     }
690 
691     public static Object[] getNullValues(Class&lt;?&gt;... types) {
692         Object[] result = new Object[types.length];
693         int i = 0;
694         for (Class&lt;?&gt; type : types) {
695             result[i++] = NULL_VALUES.get(type);
696         }
697         return result;
698     }
699     private static Map&lt;Class&lt;?&gt;, Object&gt; NULL_VALUES = new HashMap&lt;&gt;();
700     static {
701         NULL_VALUES.put(boolean.class, false);
702         NULL_VALUES.put(byte.class, (byte) 0);
703         NULL_VALUES.put(short.class, (short) 0);
704         NULL_VALUES.put(char.class, &#39;\0&#39;);
705         NULL_VALUES.put(int.class, 0);
706         NULL_VALUES.put(long.class, 0L);
707         NULL_VALUES.put(float.class, 0.0f);
708         NULL_VALUES.put(double.class, 0.0d);
709     }
710 
711     /**
712      * Returns mandatory property value
713      * @param propName is a name of property to request
714      * @return a String with requested property value
715      */
716     public static String getMandatoryProperty(String propName) {
717         Objects.requireNonNull(propName, &quot;Requested null property&quot;);
718         String prop = System.getProperty(propName);
719         Objects.requireNonNull(prop,
720                 String.format(&quot;A mandatory property &#39;%s&#39; isn&#39;t set&quot;, propName));
721         return prop;
722     }
723 
724     /*
725      * Run uname with specified arguments.
726      */
727     public static OutputAnalyzer uname(String... args) throws Throwable {
728         String[] cmds = new String[args.length + 1];
729         cmds[0] = &quot;uname&quot;;
730         System.arraycopy(args, 0, cmds, 1, args.length);
731         return ProcessTools.executeCommand(cmds);
732     }
733 
734     /*
735      * Returns the system distro.
736      */
737     public static String distro() {
738         try {
739             return uname(&quot;-v&quot;).asLines().get(0);
740         } catch (Throwable t) {
741             throw new RuntimeException(&quot;Failed to determine distro.&quot;, t);
742         }
743     }
744 
745     // This method is intended to be called from a jtreg test.
746     // It will identify the name of the test by means of stack walking.
747     // It can handle both jtreg tests and a testng tests wrapped inside jtreg tests.
748     // For jtreg tests the name of the test will be searched by stack-walking
749     // until the method main() is found; the class containing that method is the
750     // main test class and will be returned as the name of the test.
751     // Special handling is used for testng tests.
752     public static String getTestName() {
753         String result = null;
754         // If we are using testng, then we should be able to load the &quot;Test&quot; annotation.
755         Class testClassAnnotation;
756 
757         try {
758             testClassAnnotation = Class.forName(&quot;org.testng.annotations.Test&quot;);
759         } catch (ClassNotFoundException e) {
760             testClassAnnotation = null;
761         }
762 
763         StackTraceElement[] elms = (new Throwable()).getStackTrace();
764         for (StackTraceElement n: elms) {
765             String className = n.getClassName();
766 
767             // If this is a &quot;main&quot; method, then use its class name, but only
768             // if we are not using testng.
769             if (testClassAnnotation == null &amp;&amp; &quot;main&quot;.equals(n.getMethodName())) {
770                 result = className;
771                 break;
772             }
773 
774             // If this is a testng test, the test will have no &quot;main&quot; method. We can
775             // detect a testng test class by looking for the org.testng.annotations.Test
776             // annotation. If present, then use the name of this class.
777             if (testClassAnnotation != null) {
778                 try {
779                     Class c = Class.forName(className);
780                     if (c.isAnnotationPresent(testClassAnnotation)) {
781                         result = className;
782                         break;
783                     }
784                 } catch (ClassNotFoundException e) {
785                     throw new RuntimeException(&quot;Unexpected exception: &quot; + e, e);
786                 }
787             }
788         }
789 
790         if (result == null) {
791             throw new RuntimeException(&quot;Couldn&#39;t find main test class in stack trace&quot;);
792         }
793 
794         return result;
795     }
796 
797     /**
798      * Creates an empty file in &quot;user.dir&quot; if the property set.
799      * &lt;p&gt;
800      * This method is meant as a replacement for {@code Files#createTempFile(String, String, FileAttribute...)}
801      * that doesn&#39;t leave files behind in /tmp directory of the test machine
802      * &lt;p&gt;
803      * If the property &quot;user.dir&quot; is not set, &quot;.&quot; will be used.
804      *
805      * @param prefix
806      * @param suffix
807      * @param attrs
808      * @return the path to the newly created file that did not exist before this
809      *         method was invoked
810      * @throws IOException
811      *
812      * @see {@link Files#createTempFile(String, String, FileAttribute...)}
813      */
814     public static Path createTempFile(String prefix, String suffix, FileAttribute&lt;?&gt;... attrs) throws IOException {
815         Path dir = Paths.get(System.getProperty(&quot;user.dir&quot;, &quot;.&quot;));
816         return Files.createTempFile(dir, prefix, suffix);
817     }
818 }
    </pre>
  </body>
</html>
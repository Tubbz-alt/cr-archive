<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/lib/jdk/test/lib/containers/docker/DockerTestUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib.containers.docker;
 25 
 26 import java.io.File;
 27 import java.io.FileWriter;
 28 import java.io.IOException;
 29 import java.nio.file.Files;
 30 import java.nio.file.FileVisitResult;
 31 import java.nio.file.Path;
 32 import java.nio.file.Paths;
 33 import java.nio.file.SimpleFileVisitor;
 34 import java.nio.file.StandardCopyOption;
 35 import java.nio.file.attribute.BasicFileAttributes;
 36 import java.util.Arrays;
 37 import java.util.ArrayList;
 38 import java.util.Collections;
 39 import java.util.List;
 40 import jdk.test.lib.Container;
 41 import jdk.test.lib.Utils;
 42 import jdk.test.lib.process.OutputAnalyzer;
 43 import jtreg.SkippedException;
 44 
 45 
 46 public class DockerTestUtils {
 47     private static boolean isDockerEngineAvailable = false;
 48     private static boolean wasDockerEngineChecked = false;
 49 
 50     // Specifies how many lines to copy from child STDOUT to main test output.
 51     // Having too many lines in the main test output will result
 52     // in JT harness trimming the output, and can lead to loss of useful
 53     // diagnostic information.
 54     private static final int MAX_LINES_TO_COPY_FOR_CHILD_STDOUT = 100;
 55 
 56     // Set this property to true to retain image after test. By default
 57     // images are removed after test execution completes.
 58     // Retaining the image can be useful for diagnostics and image inspection.
 59     // E.g.: start image interactively: docker run -it &lt;IMAGE_NAME&gt;.
 60     public static final boolean RETAIN_IMAGE_AFTER_TEST =
 61         Boolean.getBoolean(&quot;jdk.test.docker.retain.image&quot;);
 62 
 63     // Path to a JDK under test.
 64     // This may be useful when developing tests on non-Linux platforms.
 65     public static final String JDK_UNDER_TEST =
 66         System.getProperty(&quot;jdk.test.docker.jdk&quot;, Utils.TEST_JDK);
 67 
 68 
 69     /**
 70      * Optimized check of whether the docker engine is available in a given
 71      * environment. Checks only once, then remembers the result in a singleton.
 72      *
 73      * @return true if docker engine is available
 74      * @throws Exception
 75      */
 76     public static boolean isDockerEngineAvailable() throws Exception {
 77         if (wasDockerEngineChecked)
 78             return isDockerEngineAvailable;
 79 
 80         isDockerEngineAvailable = isDockerEngineAvailableCheck();
 81         wasDockerEngineChecked = true;
 82         return isDockerEngineAvailable;
 83     }
 84 
 85 
 86     /**
 87      * Convenience method, will check if docker engine is available and usable;
 88      * will print the appropriate message when not available.
 89      *
 90      * @return true if docker engine is available
 91      * @throws Exception
 92      */
 93     public static boolean canTestDocker() throws Exception {
 94         if (isDockerEngineAvailable()) {
 95             return true;
 96         } else {
 97             throw new SkippedException(&quot;Docker engine is not available on this system&quot;);
 98         }
 99     }
100 
101 
102     /**
103      * Simple check - is docker engine available, accessible and usable.
104      * Run basic docker command: &#39;docker ps&#39; - list docker instances.
105      * If docker engine is available and accesible then true is returned
106      * and we can proceed with testing docker.
107      *
108      * @return true if docker engine is available and usable
109      * @throws Exception
110      */
111     private static boolean isDockerEngineAvailableCheck() throws Exception {
112         try {
113             execute(Container.ENGINE_COMMAND, &quot;ps&quot;)
114                 .shouldHaveExitValue(0)
115                 .shouldContain(&quot;CONTAINER&quot;)
116                 .shouldContain(&quot;IMAGE&quot;);
117         } catch (Exception e) {
118             return false;
119         }
120         return true;
121     }
122 
123 
124     /**
125      * Build a docker image that contains JDK under test.
126      * The jdk will be placed under the &quot;/jdk/&quot; folder inside the docker file system.
127      *
128      * @param imageName     name of the image to be created, including version tag
129      * @param dockerfile    name of the dockerfile residing in the test source;
130      *                      we check for a platform specific dockerfile as well
131      *                      and use this one in case it exists
132      * @param buildDirName  name of the docker build/staging directory, which will
133      *                      be created in the jtreg&#39;s scratch folder
134      * @throws Exception
135      */
136     public static void
137         buildJdkDockerImage(String imageName, String dockerfile, String buildDirName)
138             throws Exception {
139 
140         Path buildDir = Paths.get(&quot;.&quot;, buildDirName);
141         if (Files.exists(buildDir)) {
142             throw new RuntimeException(&quot;The docker build directory already exists: &quot; + buildDir);
143         }
144 
145         Path jdkSrcDir = Paths.get(JDK_UNDER_TEST);
146         Path jdkDstDir = buildDir.resolve(&quot;jdk&quot;);
147 
148         Files.createDirectories(jdkDstDir);
149 
150         // Copy JDK-under-test tree to the docker build directory.
151         // This step is required for building a docker image.
152         Files.walkFileTree(jdkSrcDir, new CopyFileVisitor(jdkSrcDir, jdkDstDir));
153         buildDockerImage(imageName, Paths.get(Utils.TEST_SRC, dockerfile), buildDir);
154     }
155 
156 
157     /**
158      * Build a docker image based on given docker file and docker build directory.
159      *
160      * @param imageName  name of the image to be created, including version tag
161      * @param dockerfile  path to the Dockerfile to be used for building the docker
162      *        image. The specified dockerfile will be copied to the docker build
163      *        directory as &#39;Dockerfile&#39;
164      * @param buildDir  build directory; it should already contain all the content
165      *        needed to build the docker image.
166      * @throws Exception
167      */
168     public static void
169         buildDockerImage(String imageName, Path dockerfile, Path buildDir) throws Exception {
170 
171         generateDockerFile(buildDir.resolve(&quot;Dockerfile&quot;),
172                            DockerfileConfig.getBaseImageName(),
173                            DockerfileConfig.getBaseImageVersion());
174         try {
175             // Build the docker
176             execute(Container.ENGINE_COMMAND, &quot;build&quot;, &quot;--no-cache&quot;, &quot;--tag&quot;, imageName, buildDir.toString())
177                 .shouldHaveExitValue(0);
178         } catch (Exception e) {
179             // If docker image building fails there is a good chance it happens due to environment and/or
180             // configuration other than product failure. Throw jtreg skipped exception in such case
181             // instead of failing the test.
182             throw new SkippedException(&quot;Building docker image failed. Details: \n&quot; + e.getMessage());
183         }
184     }
185 
186 
187     /**
188      * Build the docker command to run java inside a container
189      *
190      * @param DockerRunOptions options for running docker
191      *
192      * @return command
193      * @throws Exception
194      */
195     public static List&lt;String&gt; buildJavaCommand(DockerRunOptions opts) throws Exception {
196         List&lt;String&gt; cmd = new ArrayList&lt;&gt;();
197 
198         cmd.add(Container.ENGINE_COMMAND);
199         cmd.add(&quot;run&quot;);
200         if (opts.tty)
201             cmd.add(&quot;--tty=true&quot;);
202         if (opts.removeContainerAfterUse)
203             cmd.add(&quot;--rm&quot;);
204 
205         cmd.addAll(opts.dockerOpts);
206         cmd.add(opts.imageNameAndTag);
207         cmd.add(opts.command);
208 
209         cmd.addAll(opts.javaOpts);
210         if (opts.appendTestJavaOptions) {
211             Collections.addAll(cmd, Utils.getTestJavaOpts());
212         }
213         cmd.addAll(opts.javaOptsAppended);
214 
215         cmd.add(opts.classToRun);
216         cmd.addAll(opts.classParams);
217 
218         return cmd;
219     }
220 
221     /**
222      * Run Java inside the docker image with specified parameters and options.
223      *
224      * @param DockerRunOptions options for running docker
225      *
226      * @return output of the run command
227      * @throws Exception
228      */
229     public static OutputAnalyzer dockerRunJava(DockerRunOptions opts) throws Exception {
230         return execute(buildJavaCommand(opts));
231     }
232 
233 
234      /**
235      * Remove docker image
236      *
237      * @param DockerRunOptions options for running docker
238      * @throws Exception
239      */
240     public static void removeDockerImage(String imageNameAndTag) throws Exception {
241             execute(Container.ENGINE_COMMAND, &quot;rmi&quot;, &quot;--force&quot;, imageNameAndTag);
242     }
243 
244 
245 
246     /**
247      * Convenience method - express command as sequence of strings
248      *
249      * @param command to execute
250      * @return The output from the process
251      * @throws Exception
252      */
253     public static OutputAnalyzer execute(List&lt;String&gt; command) throws Exception {
254         return execute(command.toArray(new String[command.size()]));
255     }
256 
257 
258     /**
259      * Execute a specified command in a process, report diagnostic info.
260      *
261      * @param command to be executed
262      * @return The output from the process
263      * @throws Exception
264      */
265     public static OutputAnalyzer execute(String... command) throws Exception {
266 
267         ProcessBuilder pb = new ProcessBuilder(command);
268         System.out.println(&quot;[COMMAND]\n&quot; + Utils.getCommandLine(pb));
269 
270         long started = System.currentTimeMillis();
271         Process p = pb.start();
272         long pid = p.pid();
273         OutputAnalyzer output = new OutputAnalyzer(p);
274 
275         String stdoutLogFile = String.format(&quot;docker-stdout-%d.log&quot;, pid);
276         System.out.println(&quot;[ELAPSED: &quot; + (System.currentTimeMillis() - started) + &quot; ms]&quot;);
277         System.out.println(&quot;[STDERR]\n&quot; + output.getStderr());
278         System.out.println(&quot;[STDOUT]\n&quot; +
279                            trimLines(output.getStdout(),MAX_LINES_TO_COPY_FOR_CHILD_STDOUT));
280         System.out.printf(&quot;Child process STDOUT is trimmed to %d lines \n&quot;,
281                            MAX_LINES_TO_COPY_FOR_CHILD_STDOUT);
282         writeOutputToFile(output.getStdout(), stdoutLogFile);
283         System.out.println(&quot;Full child process STDOUT was saved to &quot; + stdoutLogFile);
284 
285         return output;
286     }
287 
288 
289     private static void writeOutputToFile(String output, String fileName) throws Exception {
290         try (FileWriter fw = new FileWriter(fileName)) {
291             fw.write(output, 0, output.length());
292         }
293     }
294 
295 
296     private static String trimLines(String buffer, int nrOfLines) {
297         List&lt;String&gt; l = Arrays.asList(buffer.split(&quot;\\R&quot;));
298         if (l.size() &lt; nrOfLines) {
299             return buffer;
300         }
301 
302         return String.join(&quot;\n&quot;, l.subList(0, nrOfLines));
303     }
304 
305 
306     private static void generateDockerFile(Path dockerfile, String baseImage,
307                                            String baseImageVersion) throws Exception {
308         String template =
309             &quot;FROM %s:%s\n&quot; +
310             &quot;COPY /jdk /jdk\n&quot; +
311             &quot;ENV JAVA_HOME=/jdk\n&quot; +
312             &quot;CMD [\&quot;/bin/bash\&quot;]\n&quot;;
313         String dockerFileStr = String.format(template, baseImage, baseImageVersion);
314         Files.writeString(dockerfile, dockerFileStr);
315     }
316 
317 
318     private static class CopyFileVisitor extends SimpleFileVisitor&lt;Path&gt; {
319         private final Path src;
320         private final Path dst;
321 
322         public CopyFileVisitor(Path src, Path dst) {
323             this.src = src;
324             this.dst = dst;
325         }
326 
327 
328         @Override
329         public FileVisitResult preVisitDirectory(Path file,
330                 BasicFileAttributes attrs) throws IOException {
331             Path dstDir = dst.resolve(src.relativize(file));
332             if (!dstDir.toFile().exists()) {
333                 Files.createDirectories(dstDir);
334             }
335             return FileVisitResult.CONTINUE;
336         }
337 
338 
339         @Override
340         public FileVisitResult visitFile(Path file,
341                 BasicFileAttributes attrs) throws IOException {
342             if (!file.toFile().isFile()) {
343                 return FileVisitResult.CONTINUE;
344             }
345             Path dstFile = dst.resolve(src.relativize(file));
346             Files.copy(file, dstFile, StandardCopyOption.COPY_ATTRIBUTES);
347             return FileVisitResult.CONTINUE;
348         }
349     }
350 }
    </pre>
  </body>
</html>
diff a/test/lib/jdk/test/lib/process/OutputBuffer.java b/test/lib/jdk/test/lib/process/OutputBuffer.java
--- a/test/lib/jdk/test/lib/process/OutputBuffer.java
+++ b/test/lib/jdk/test/lib/process/OutputBuffer.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,10 +23,12 @@
 
 package jdk.test.lib.process;
 
 import java.io.ByteArrayOutputStream;
 import java.io.InputStream;
+import java.nio.charset.Charset;
+import java.time.Instant;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 
 public interface OutputBuffer {
@@ -50,12 +52,16 @@
    * @return stderr result
    */
   public String getStderr();
   public int getExitValue();
 
+  public static OutputBuffer of(Process p, Charset cs) {
+    return new LazyOutputBuffer(p, cs);
+  }
+
   public static OutputBuffer of(Process p) {
-    return new LazyOutputBuffer(p);
+    return new LazyOutputBuffer(p, null);
   }
 
   public static OutputBuffer of(String stdout, String stderr, int exitValue) {
     return new EagerOutputBuffer(stdout, stderr, exitValue);
   }
@@ -66,20 +72,22 @@
 
   class LazyOutputBuffer implements OutputBuffer {
     private static class StreamTask {
       private final ByteArrayOutputStream buffer;
       private final Future<Void> future;
+      private final Charset cs;
 
-      private StreamTask(InputStream stream) {
+      private StreamTask(InputStream stream, Charset cs) {
         this.buffer = new ByteArrayOutputStream();
+        this.cs = cs;
         this.future = new StreamPumper(stream, buffer).process();
       }
 
       public String get() {
         try {
           future.get();
-          return buffer.toString();
+          return cs == null ? buffer.toString() : buffer.toString(cs);
         } catch (InterruptedException e) {
           Thread.currentThread().interrupt();
           throw new OutputBufferException(e);
         } catch (ExecutionException | CancellationException e) {
           throw new OutputBufferException(e);
@@ -89,14 +97,21 @@
 
     private final StreamTask outTask;
     private final StreamTask errTask;
     private final Process p;
 
-    private LazyOutputBuffer(Process p) {
+    private final void logProgress(String state) {
+        System.out.println("[" + Instant.now().toString() + "] " + state
+                           + " for process " + p.pid());
+        System.out.flush();
+    }
+
+    private LazyOutputBuffer(Process p, Charset cs) {
       this.p = p;
-      outTask = new StreamTask(p.getInputStream());
-      errTask = new StreamTask(p.getErrorStream());
+      logProgress("Gathering output");
+      outTask = new StreamTask(p.getInputStream(), cs);
+      errTask = new StreamTask(p.getErrorStream(), cs);
     }
 
     @Override
     public String getStdout() {
       return outTask.get();
@@ -108,11 +123,22 @@
     }
 
     @Override
     public int getExitValue() {
       try {
-        return p.waitFor();
+          logProgress("Waiting for completion");
+          boolean aborted = true;
+          try {
+              int result = p.waitFor();
+              logProgress("Waiting for completion finished");
+              aborted = false;
+              return result;
+          } finally {
+              if (aborted) {
+                  logProgress("Waiting for completion FAILED");
+              }
+          }
       } catch (InterruptedException e) {
         Thread.currentThread().interrupt();
         throw new OutputBufferException(e);
       }
     }

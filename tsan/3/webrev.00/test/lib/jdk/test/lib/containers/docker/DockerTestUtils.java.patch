diff a/test/lib/jdk/test/lib/containers/docker/DockerTestUtils.java b/test/lib/jdk/test/lib/containers/docker/DockerTestUtils.java
--- a/test/lib/jdk/test/lib/containers/docker/DockerTestUtils.java
+++ b/test/lib/jdk/test/lib/containers/docker/DockerTestUtils.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,34 +22,51 @@
  */
 
 package jdk.test.lib.containers.docker;
 
 import java.io.File;
+import java.io.FileWriter;
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.FileVisitResult;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.SimpleFileVisitor;
 import java.nio.file.StandardCopyOption;
 import java.nio.file.attribute.BasicFileAttributes;
+import java.util.Arrays;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import jdk.test.lib.Platform;
+import jdk.test.lib.Container;
 import jdk.test.lib.Utils;
 import jdk.test.lib.process.OutputAnalyzer;
-import jdk.test.lib.process.ProcessTools;
+import jtreg.SkippedException;
 
 
 public class DockerTestUtils {
-    private static final String FS = File.separator;
     private static boolean isDockerEngineAvailable = false;
     private static boolean wasDockerEngineChecked = false;
 
-    // Diagnostics: set to true to enable more diagnostic info
-    private static final boolean DEBUG = false;
+    // Specifies how many lines to copy from child STDOUT to main test output.
+    // Having too many lines in the main test output will result
+    // in JT harness trimming the output, and can lead to loss of useful
+    // diagnostic information.
+    private static final int MAX_LINES_TO_COPY_FOR_CHILD_STDOUT = 100;
+
+    // Set this property to true to retain image after test. By default
+    // images are removed after test execution completes.
+    // Retaining the image can be useful for diagnostics and image inspection.
+    // E.g.: start image interactively: docker run -it <IMAGE_NAME>.
+    public static final boolean RETAIN_IMAGE_AFTER_TEST =
+        Boolean.getBoolean("jdk.test.docker.retain.image");
+
+    // Path to a JDK under test.
+    // This may be useful when developing tests on non-Linux platforms.
+    public static final String JDK_UNDER_TEST =
+        System.getProperty("jdk.test.docker.jdk", Utils.TEST_JDK);
+
 
     /**
      * Optimized check of whether the docker engine is available in a given
      * environment. Checks only once, then remembers the result in a singleton.
      *
@@ -75,13 +92,11 @@
      */
     public static boolean canTestDocker() throws Exception {
         if (isDockerEngineAvailable()) {
             return true;
         } else {
-            System.out.println("Docker engine is not available on this system");
-            System.out.println("This test is SKIPPED");
-            return false;
+            throw new SkippedException("Docker engine is not available on this system");
         }
     }
 
 
     /**
@@ -93,11 +108,11 @@
      * @return true if docker engine is available and usable
      * @throws Exception
      */
     private static boolean isDockerEngineAvailableCheck() throws Exception {
         try {
-            execute("docker", "ps")
+            execute(Container.ENGINE_COMMAND, "ps")
                 .shouldHaveExitValue(0)
                 .shouldContain("CONTAINER")
                 .shouldContain("IMAGE");
         } catch (Exception e) {
             return false;
@@ -124,17 +139,12 @@
 
         Path buildDir = Paths.get(".", buildDirName);
         if (Files.exists(buildDir)) {
             throw new RuntimeException("The docker build directory already exists: " + buildDir);
         }
-        // check for the existance of a platform specific docker file as well
-        String platformSpecificDockerfile = dockerfile + "-" + Platform.getOsArch();
-        if (Files.exists(Paths.get(Utils.TEST_SRC, platformSpecificDockerfile))) {
-          dockerfile = platformSpecificDockerfile;
-        }
 
-        Path jdkSrcDir = Paths.get(Utils.TEST_JDK);
+        Path jdkSrcDir = Paths.get(JDK_UNDER_TEST);
         Path jdkDstDir = buildDir.resolve("jdk");
 
         Files.createDirectories(jdkDstDir);
 
         // Copy JDK-under-test tree to the docker build directory.
@@ -156,32 +166,38 @@
      * @throws Exception
      */
     public static void
         buildDockerImage(String imageName, Path dockerfile, Path buildDir) throws Exception {
 
-        // Copy docker file to the build dir
-        Files.copy(dockerfile, buildDir.resolve("Dockerfile"));
-
-        // Build the docker
-        execute("docker", "build", "--no-cache", "--tag", imageName, buildDir.toString())
-            .shouldHaveExitValue(0)
-            .shouldContain("Successfully built");
+        generateDockerFile(buildDir.resolve("Dockerfile"),
+                           DockerfileConfig.getBaseImageName(),
+                           DockerfileConfig.getBaseImageVersion());
+        try {
+            // Build the docker
+            execute(Container.ENGINE_COMMAND, "build", "--no-cache", "--tag", imageName, buildDir.toString())
+                .shouldHaveExitValue(0);
+        } catch (Exception e) {
+            // If docker image building fails there is a good chance it happens due to environment and/or
+            // configuration other than product failure. Throw jtreg skipped exception in such case
+            // instead of failing the test.
+            throw new SkippedException("Building docker image failed. Details: \n" + e.getMessage());
+        }
     }
 
 
     /**
-     * Run Java inside the docker image with specified parameters and options.
+     * Build the docker command to run java inside a container
      *
-     * @param DockerRunOptions optins for running docker
+     * @param DockerRunOptions options for running docker
      *
-     * @return output of the run command
+     * @return command
      * @throws Exception
      */
-    public static OutputAnalyzer dockerRunJava(DockerRunOptions opts) throws Exception {
-        ArrayList<String> cmd = new ArrayList<>();
+    public static List<String> buildJavaCommand(DockerRunOptions opts) throws Exception {
+        List<String> cmd = new ArrayList<>();
 
-        cmd.add("docker");
+        cmd.add(Container.ENGINE_COMMAND);
         cmd.add("run");
         if (opts.tty)
             cmd.add("--tty=true");
         if (opts.removeContainerAfterUse)
             cmd.add("--rm");
@@ -192,27 +208,39 @@
 
         cmd.addAll(opts.javaOpts);
         if (opts.appendTestJavaOptions) {
             Collections.addAll(cmd, Utils.getTestJavaOpts());
         }
+        cmd.addAll(opts.javaOptsAppended);
 
         cmd.add(opts.classToRun);
         cmd.addAll(opts.classParams);
 
-        return execute(cmd);
+        return cmd;
+    }
+
+    /**
+     * Run Java inside the docker image with specified parameters and options.
+     *
+     * @param DockerRunOptions options for running docker
+     *
+     * @return output of the run command
+     * @throws Exception
+     */
+    public static OutputAnalyzer dockerRunJava(DockerRunOptions opts) throws Exception {
+        return execute(buildJavaCommand(opts));
     }
 
 
      /**
      * Remove docker image
      *
-     * @param DockerRunOptions optins for running docker
-     * @return output of the command
+     * @param DockerRunOptions options for running docker
      * @throws Exception
      */
-    public static OutputAnalyzer removeDockerImage(String imageNameAndTag) throws Exception {
-        return execute("docker", "rmi", "--force", imageNameAndTag);
+    public static void removeDockerImage(String imageNameAndTag) throws Exception {
+            execute(Container.ENGINE_COMMAND, "rmi", "--force", imageNameAndTag);
     }
 
 
 
     /**
@@ -238,20 +266,57 @@
 
         ProcessBuilder pb = new ProcessBuilder(command);
         System.out.println("[COMMAND]\n" + Utils.getCommandLine(pb));
 
         long started = System.currentTimeMillis();
-        OutputAnalyzer output = new OutputAnalyzer(pb.start());
+        Process p = pb.start();
+        long pid = p.pid();
+        OutputAnalyzer output = new OutputAnalyzer(p);
 
+        String stdoutLogFile = String.format("docker-stdout-%d.log", pid);
         System.out.println("[ELAPSED: " + (System.currentTimeMillis() - started) + " ms]");
         System.out.println("[STDERR]\n" + output.getStderr());
-        System.out.println("[STDOUT]\n" + output.getStdout());
+        System.out.println("[STDOUT]\n" +
+                           trimLines(output.getStdout(),MAX_LINES_TO_COPY_FOR_CHILD_STDOUT));
+        System.out.printf("Child process STDOUT is trimmed to %d lines \n",
+                           MAX_LINES_TO_COPY_FOR_CHILD_STDOUT);
+        writeOutputToFile(output.getStdout(), stdoutLogFile);
+        System.out.println("Full child process STDOUT was saved to " + stdoutLogFile);
 
         return output;
     }
 
 
+    private static void writeOutputToFile(String output, String fileName) throws Exception {
+        try (FileWriter fw = new FileWriter(fileName)) {
+            fw.write(output, 0, output.length());
+        }
+    }
+
+
+    private static String trimLines(String buffer, int nrOfLines) {
+        List<String> l = Arrays.asList(buffer.split("\\R"));
+        if (l.size() < nrOfLines) {
+            return buffer;
+        }
+
+        return String.join("\n", l.subList(0, nrOfLines));
+    }
+
+
+    private static void generateDockerFile(Path dockerfile, String baseImage,
+                                           String baseImageVersion) throws Exception {
+        String template =
+            "FROM %s:%s\n" +
+            "COPY /jdk /jdk\n" +
+            "ENV JAVA_HOME=/jdk\n" +
+            "CMD [\"/bin/bash\"]\n";
+        String dockerFileStr = String.format(template, baseImage, baseImageVersion);
+        Files.writeString(dockerfile, dockerFileStr);
+    }
+
+
     private static class CopyFileVisitor extends SimpleFileVisitor<Path> {
         private final Path src;
         private final Path dst;
 
         public CopyFileVisitor(Path src, Path dst) {

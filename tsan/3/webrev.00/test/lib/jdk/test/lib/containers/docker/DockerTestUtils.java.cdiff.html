<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/lib/jdk/test/lib/containers/docker/DockerTestUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DockerRunOptions.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../jfr/EventNames.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/lib/jdk/test/lib/containers/docker/DockerTestUtils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,34 ***</span>
   */
  
  package jdk.test.lib.containers.docker;
  
  import java.io.File;
  import java.io.IOException;
  import java.nio.file.Files;
  import java.nio.file.FileVisitResult;
  import java.nio.file.Path;
  import java.nio.file.Paths;
  import java.nio.file.SimpleFileVisitor;
  import java.nio.file.StandardCopyOption;
  import java.nio.file.attribute.BasicFileAttributes;
  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.List;
<span class="line-modified">! import jdk.test.lib.Platform;</span>
  import jdk.test.lib.Utils;
  import jdk.test.lib.process.OutputAnalyzer;
<span class="line-modified">! import jdk.test.lib.process.ProcessTools;</span>
  
  
  public class DockerTestUtils {
<span class="line-removed">-     private static final String FS = File.separator;</span>
      private static boolean isDockerEngineAvailable = false;
      private static boolean wasDockerEngineChecked = false;
  
<span class="line-modified">!     // Diagnostics: set to true to enable more diagnostic info</span>
<span class="line-modified">!     private static final boolean DEBUG = false;</span>
  
      /**
       * Optimized check of whether the docker engine is available in a given
       * environment. Checks only once, then remembers the result in a singleton.
       *
<span class="line-new-header">--- 22,51 ---</span>
   */
  
  package jdk.test.lib.containers.docker;
  
  import java.io.File;
<span class="line-added">+ import java.io.FileWriter;</span>
  import java.io.IOException;
  import java.nio.file.Files;
  import java.nio.file.FileVisitResult;
  import java.nio.file.Path;
  import java.nio.file.Paths;
  import java.nio.file.SimpleFileVisitor;
  import java.nio.file.StandardCopyOption;
  import java.nio.file.attribute.BasicFileAttributes;
<span class="line-added">+ import java.util.Arrays;</span>
  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.List;
<span class="line-modified">! import jdk.test.lib.Container;</span>
  import jdk.test.lib.Utils;
  import jdk.test.lib.process.OutputAnalyzer;
<span class="line-modified">! import jtreg.SkippedException;</span>
  
  
  public class DockerTestUtils {
      private static boolean isDockerEngineAvailable = false;
      private static boolean wasDockerEngineChecked = false;
  
<span class="line-modified">!     // Specifies how many lines to copy from child STDOUT to main test output.</span>
<span class="line-modified">!     // Having too many lines in the main test output will result</span>
<span class="line-added">+     // in JT harness trimming the output, and can lead to loss of useful</span>
<span class="line-added">+     // diagnostic information.</span>
<span class="line-added">+     private static final int MAX_LINES_TO_COPY_FOR_CHILD_STDOUT = 100;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Set this property to true to retain image after test. By default</span>
<span class="line-added">+     // images are removed after test execution completes.</span>
<span class="line-added">+     // Retaining the image can be useful for diagnostics and image inspection.</span>
<span class="line-added">+     // E.g.: start image interactively: docker run -it &lt;IMAGE_NAME&gt;.</span>
<span class="line-added">+     public static final boolean RETAIN_IMAGE_AFTER_TEST =</span>
<span class="line-added">+         Boolean.getBoolean(&quot;jdk.test.docker.retain.image&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Path to a JDK under test.</span>
<span class="line-added">+     // This may be useful when developing tests on non-Linux platforms.</span>
<span class="line-added">+     public static final String JDK_UNDER_TEST =</span>
<span class="line-added">+         System.getProperty(&quot;jdk.test.docker.jdk&quot;, Utils.TEST_JDK);</span>
<span class="line-added">+ </span>
  
      /**
       * Optimized check of whether the docker engine is available in a given
       * environment. Checks only once, then remembers the result in a singleton.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 75,13 ***</span>
       */
      public static boolean canTestDocker() throws Exception {
          if (isDockerEngineAvailable()) {
              return true;
          } else {
<span class="line-modified">!             System.out.println(&quot;Docker engine is not available on this system&quot;);</span>
<span class="line-removed">-             System.out.println(&quot;This test is SKIPPED&quot;);</span>
<span class="line-removed">-             return false;</span>
          }
      }
  
  
      /**
<span class="line-new-header">--- 92,11 ---</span>
       */
      public static boolean canTestDocker() throws Exception {
          if (isDockerEngineAvailable()) {
              return true;
          } else {
<span class="line-modified">!             throw new SkippedException(&quot;Docker engine is not available on this system&quot;);</span>
          }
      }
  
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,11 ***</span>
       * @return true if docker engine is available and usable
       * @throws Exception
       */
      private static boolean isDockerEngineAvailableCheck() throws Exception {
          try {
<span class="line-modified">!             execute(&quot;docker&quot;, &quot;ps&quot;)</span>
                  .shouldHaveExitValue(0)
                  .shouldContain(&quot;CONTAINER&quot;)
                  .shouldContain(&quot;IMAGE&quot;);
          } catch (Exception e) {
              return false;
<span class="line-new-header">--- 108,11 ---</span>
       * @return true if docker engine is available and usable
       * @throws Exception
       */
      private static boolean isDockerEngineAvailableCheck() throws Exception {
          try {
<span class="line-modified">!             execute(Container.ENGINE_COMMAND, &quot;ps&quot;)</span>
                  .shouldHaveExitValue(0)
                  .shouldContain(&quot;CONTAINER&quot;)
                  .shouldContain(&quot;IMAGE&quot;);
          } catch (Exception e) {
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,17 ***</span>
  
          Path buildDir = Paths.get(&quot;.&quot;, buildDirName);
          if (Files.exists(buildDir)) {
              throw new RuntimeException(&quot;The docker build directory already exists: &quot; + buildDir);
          }
<span class="line-removed">-         // check for the existance of a platform specific docker file as well</span>
<span class="line-removed">-         String platformSpecificDockerfile = dockerfile + &quot;-&quot; + Platform.getOsArch();</span>
<span class="line-removed">-         if (Files.exists(Paths.get(Utils.TEST_SRC, platformSpecificDockerfile))) {</span>
<span class="line-removed">-           dockerfile = platformSpecificDockerfile;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         Path jdkSrcDir = Paths.get(Utils.TEST_JDK);</span>
          Path jdkDstDir = buildDir.resolve(&quot;jdk&quot;);
  
          Files.createDirectories(jdkDstDir);
  
          // Copy JDK-under-test tree to the docker build directory.
<span class="line-new-header">--- 139,12 ---</span>
  
          Path buildDir = Paths.get(&quot;.&quot;, buildDirName);
          if (Files.exists(buildDir)) {
              throw new RuntimeException(&quot;The docker build directory already exists: &quot; + buildDir);
          }
  
<span class="line-modified">!         Path jdkSrcDir = Paths.get(JDK_UNDER_TEST);</span>
          Path jdkDstDir = buildDir.resolve(&quot;jdk&quot;);
  
          Files.createDirectories(jdkDstDir);
  
          // Copy JDK-under-test tree to the docker build directory.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 156,32 ***</span>
       * @throws Exception
       */
      public static void
          buildDockerImage(String imageName, Path dockerfile, Path buildDir) throws Exception {
  
<span class="line-modified">!         // Copy docker file to the build dir</span>
<span class="line-modified">!         Files.copy(dockerfile, buildDir.resolve(&quot;Dockerfile&quot;));</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Build the docker</span>
<span class="line-modified">!         execute(&quot;docker&quot;, &quot;build&quot;, &quot;--no-cache&quot;, &quot;--tag&quot;, imageName, buildDir.toString())</span>
<span class="line-modified">!             .shouldHaveExitValue(0)</span>
<span class="line-modified">!             .shouldContain(&quot;Successfully built&quot;);</span>
      }
  
  
      /**
<span class="line-modified">!      * Run Java inside the docker image with specified parameters and options.</span>
       *
<span class="line-modified">!      * @param DockerRunOptions optins for running docker</span>
       *
<span class="line-modified">!      * @return output of the run command</span>
       * @throws Exception
       */
<span class="line-modified">!     public static OutputAnalyzer dockerRunJava(DockerRunOptions opts) throws Exception {</span>
<span class="line-modified">!         ArrayList&lt;String&gt; cmd = new ArrayList&lt;&gt;();</span>
  
<span class="line-modified">!         cmd.add(&quot;docker&quot;);</span>
          cmd.add(&quot;run&quot;);
          if (opts.tty)
              cmd.add(&quot;--tty=true&quot;);
          if (opts.removeContainerAfterUse)
              cmd.add(&quot;--rm&quot;);
<span class="line-new-header">--- 166,38 ---</span>
       * @throws Exception
       */
      public static void
          buildDockerImage(String imageName, Path dockerfile, Path buildDir) throws Exception {
  
<span class="line-modified">!         generateDockerFile(buildDir.resolve(&quot;Dockerfile&quot;),</span>
<span class="line-modified">!                            DockerfileConfig.getBaseImageName(),</span>
<span class="line-modified">!                            DockerfileConfig.getBaseImageVersion());</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             // Build the docker</span>
<span class="line-modified">!             execute(Container.ENGINE_COMMAND, &quot;build&quot;, &quot;--no-cache&quot;, &quot;--tag&quot;, imageName, buildDir.toString())</span>
<span class="line-modified">!                 .shouldHaveExitValue(0);</span>
<span class="line-added">+         } catch (Exception e) {</span>
<span class="line-added">+             // If docker image building fails there is a good chance it happens due to environment and/or</span>
<span class="line-added">+             // configuration other than product failure. Throw jtreg skipped exception in such case</span>
<span class="line-added">+             // instead of failing the test.</span>
<span class="line-added">+             throw new SkippedException(&quot;Building docker image failed. Details: \n&quot; + e.getMessage());</span>
<span class="line-added">+         }</span>
      }
  
  
      /**
<span class="line-modified">!      * Build the docker command to run java inside a container</span>
       *
<span class="line-modified">!      * @param DockerRunOptions options for running docker</span>
       *
<span class="line-modified">!      * @return command</span>
       * @throws Exception
       */
<span class="line-modified">!     public static List&lt;String&gt; buildJavaCommand(DockerRunOptions opts) throws Exception {</span>
<span class="line-modified">!         List&lt;String&gt; cmd = new ArrayList&lt;&gt;();</span>
  
<span class="line-modified">!         cmd.add(Container.ENGINE_COMMAND);</span>
          cmd.add(&quot;run&quot;);
          if (opts.tty)
              cmd.add(&quot;--tty=true&quot;);
          if (opts.removeContainerAfterUse)
              cmd.add(&quot;--rm&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 192,27 ***</span>
  
          cmd.addAll(opts.javaOpts);
          if (opts.appendTestJavaOptions) {
              Collections.addAll(cmd, Utils.getTestJavaOpts());
          }
  
          cmd.add(opts.classToRun);
          cmd.addAll(opts.classParams);
  
<span class="line-modified">!         return execute(cmd);</span>
      }
  
  
       /**
       * Remove docker image
       *
<span class="line-modified">!      * @param DockerRunOptions optins for running docker</span>
<span class="line-removed">-      * @return output of the command</span>
       * @throws Exception
       */
<span class="line-modified">!     public static OutputAnalyzer removeDockerImage(String imageNameAndTag) throws Exception {</span>
<span class="line-modified">!         return execute(&quot;docker&quot;, &quot;rmi&quot;, &quot;--force&quot;, imageNameAndTag);</span>
      }
  
  
  
      /**
<span class="line-new-header">--- 208,39 ---</span>
  
          cmd.addAll(opts.javaOpts);
          if (opts.appendTestJavaOptions) {
              Collections.addAll(cmd, Utils.getTestJavaOpts());
          }
<span class="line-added">+         cmd.addAll(opts.javaOptsAppended);</span>
  
          cmd.add(opts.classToRun);
          cmd.addAll(opts.classParams);
  
<span class="line-modified">!         return cmd;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Run Java inside the docker image with specified parameters and options.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param DockerRunOptions options for running docker</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return output of the run command</span>
<span class="line-added">+      * @throws Exception</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static OutputAnalyzer dockerRunJava(DockerRunOptions opts) throws Exception {</span>
<span class="line-added">+         return execute(buildJavaCommand(opts));</span>
      }
  
  
       /**
       * Remove docker image
       *
<span class="line-modified">!      * @param DockerRunOptions options for running docker</span>
       * @throws Exception
       */
<span class="line-modified">!     public static void removeDockerImage(String imageNameAndTag) throws Exception {</span>
<span class="line-modified">!             execute(Container.ENGINE_COMMAND, &quot;rmi&quot;, &quot;--force&quot;, imageNameAndTag);</span>
      }
  
  
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 238,20 ***</span>
  
          ProcessBuilder pb = new ProcessBuilder(command);
          System.out.println(&quot;[COMMAND]\n&quot; + Utils.getCommandLine(pb));
  
          long started = System.currentTimeMillis();
<span class="line-modified">!         OutputAnalyzer output = new OutputAnalyzer(pb.start());</span>
  
          System.out.println(&quot;[ELAPSED: &quot; + (System.currentTimeMillis() - started) + &quot; ms]&quot;);
          System.out.println(&quot;[STDERR]\n&quot; + output.getStderr());
<span class="line-modified">!         System.out.println(&quot;[STDOUT]\n&quot; + output.getStdout());</span>
  
          return output;
      }
  
  
      private static class CopyFileVisitor extends SimpleFileVisitor&lt;Path&gt; {
          private final Path src;
          private final Path dst;
  
          public CopyFileVisitor(Path src, Path dst) {
<span class="line-new-header">--- 266,57 ---</span>
  
          ProcessBuilder pb = new ProcessBuilder(command);
          System.out.println(&quot;[COMMAND]\n&quot; + Utils.getCommandLine(pb));
  
          long started = System.currentTimeMillis();
<span class="line-modified">!         Process p = pb.start();</span>
<span class="line-added">+         long pid = p.pid();</span>
<span class="line-added">+         OutputAnalyzer output = new OutputAnalyzer(p);</span>
  
<span class="line-added">+         String stdoutLogFile = String.format(&quot;docker-stdout-%d.log&quot;, pid);</span>
          System.out.println(&quot;[ELAPSED: &quot; + (System.currentTimeMillis() - started) + &quot; ms]&quot;);
          System.out.println(&quot;[STDERR]\n&quot; + output.getStderr());
<span class="line-modified">!         System.out.println(&quot;[STDOUT]\n&quot; +</span>
<span class="line-added">+                            trimLines(output.getStdout(),MAX_LINES_TO_COPY_FOR_CHILD_STDOUT));</span>
<span class="line-added">+         System.out.printf(&quot;Child process STDOUT is trimmed to %d lines \n&quot;,</span>
<span class="line-added">+                            MAX_LINES_TO_COPY_FOR_CHILD_STDOUT);</span>
<span class="line-added">+         writeOutputToFile(output.getStdout(), stdoutLogFile);</span>
<span class="line-added">+         System.out.println(&quot;Full child process STDOUT was saved to &quot; + stdoutLogFile);</span>
  
          return output;
      }
  
  
<span class="line-added">+     private static void writeOutputToFile(String output, String fileName) throws Exception {</span>
<span class="line-added">+         try (FileWriter fw = new FileWriter(fileName)) {</span>
<span class="line-added">+             fw.write(output, 0, output.length());</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     private static String trimLines(String buffer, int nrOfLines) {</span>
<span class="line-added">+         List&lt;String&gt; l = Arrays.asList(buffer.split(&quot;\\R&quot;));</span>
<span class="line-added">+         if (l.size() &lt; nrOfLines) {</span>
<span class="line-added">+             return buffer;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return String.join(&quot;\n&quot;, l.subList(0, nrOfLines));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     private static void generateDockerFile(Path dockerfile, String baseImage,</span>
<span class="line-added">+                                            String baseImageVersion) throws Exception {</span>
<span class="line-added">+         String template =</span>
<span class="line-added">+             &quot;FROM %s:%s\n&quot; +</span>
<span class="line-added">+             &quot;COPY /jdk /jdk\n&quot; +</span>
<span class="line-added">+             &quot;ENV JAVA_HOME=/jdk\n&quot; +</span>
<span class="line-added">+             &quot;CMD [\&quot;/bin/bash\&quot;]\n&quot;;</span>
<span class="line-added">+         String dockerFileStr = String.format(template, baseImage, baseImageVersion);</span>
<span class="line-added">+         Files.writeString(dockerfile, dockerFileStr);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
      private static class CopyFileVisitor extends SimpleFileVisitor&lt;Path&gt; {
          private final Path src;
          private final Path dst;
  
          public CopyFileVisitor(Path src, Path dst) {
</pre>
<center><a href="DockerRunOptions.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../jfr/EventNames.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
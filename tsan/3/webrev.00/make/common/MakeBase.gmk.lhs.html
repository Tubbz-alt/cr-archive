<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/common/MakeBase.gmk</title>
    <link rel="stylesheet" href="../../style.css" />
    <script type="text/javascript" src="../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 #
  2 # Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4 #
  5 # This code is free software; you can redistribute it and/or modify it
  6 # under the terms of the GNU General Public License version 2 only, as
  7 # published by the Free Software Foundation.  Oracle designates this
  8 # particular file as subject to the &quot;Classpath&quot; exception as provided
  9 # by Oracle in the LICENSE file that accompanied this code.
 10 #
 11 # This code is distributed in the hope that it will be useful, but WITHOUT
 12 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14 # version 2 for more details (a copy is included in the LICENSE file that
 15 # accompanied this code).
 16 #
 17 # You should have received a copy of the GNU General Public License version
 18 # 2 along with this work; if not, write to the Free Software Foundation,
 19 # Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20 #
 21 # Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22 # or visit www.oracle.com if you need additional information or have any
 23 # questions.
 24 #
 25 
 26 ################################################################
 27 #
 28 # Setup common utility functions.
 29 #
 30 ################################################################
 31 
 32 ifndef _MAKEBASE_GMK
 33 _MAKEBASE_GMK := 1
 34 
 35 ifeq ($(wildcard $(SPEC)),)
 36   $(error MakeBase.gmk needs SPEC set to a proper spec.gmk)
 37 endif
 38 
 39 # By defining this pseudo target, make will automatically remove targets
 40 # if their recipe fails so that a rebuild is automatically triggered on the
 41 # next make invocation.
 42 .DELETE_ON_ERROR:
 43 
 44 ################################################################################
 45 # Definitions for special characters
 46 ################################################################################
 47 
 48 # When calling macros, the spaces between arguments are
 49 # often semantically important! Sometimes we need to subst
 50 # spaces and commas, therefore we need the following macros.
 51 X:=
 52 SPACE:=$(X) $(X)
 53 COMMA:=,
 54 DOLLAR:=$$
 55 HASH:=\#
 56 LEFT_PAREN:=(
 57 RIGHT_PAREN:=)
 58 SQUOTE:=&#39;
 59 #&#39;
 60 DQUOTE:=&quot;
 61 #&quot;
 62 define NEWLINE
 63 
 64 
 65 endef
 66 
<a name="1" id="anc1"></a><span class="line-modified"> 67 # In GNU Make 4.0 and higher, there is a file function for writing to files.</span>

 68 ifeq (4.0, $(firstword $(sort 4.0 $(MAKE_VERSION))))
 69   HAS_FILE_FUNCTION := true
 70   CORRECT_FUNCTION_IN_RECIPE_EVALUATION := true
<a name="2" id="anc2"></a>
 71 endif
 72 
 73 
 74 # For convenience, MakeBase.gmk continues to include these separate files, at
 75 # least for now.
 76 
 77 include $(TOPDIR)/make/common/Utils.gmk
 78 include $(TOPDIR)/make/common/MakeIO.gmk
 79 include $(TOPDIR)/make/common/CopyFiles.gmk
 80 
 81 ################################################################################
 82 # Functions for timers
 83 ################################################################################
 84 
 85 # Store the build times in this directory.
 86 BUILDTIMESDIR=$(OUTPUTDIR)/make-support/build-times
 87 
 88 # Record starting time for build of a sub repository.
 89 define RecordStartTime
 90 	$(DATE) &#39;+%Y %m %d %H %M %S&#39; | $(NAWK) &#39;{ print $$1,$$2,$$3,$$4,$$5,$$6,($$4*3600+$$5*60+$$6) }&#39; &gt; $(BUILDTIMESDIR)/build_time_start_$(strip $1) &amp;&amp; \
 91 	$(DATE) &#39;+%Y-%m-%d %H:%M:%S&#39; &gt; $(BUILDTIMESDIR)/build_time_start_$(strip $1)_human_readable
 92 endef
 93 
 94 # Record ending time and calculate the difference and store it in a
 95 # easy to read format. Handles builds that cross midnight. Expects
 96 # that a build will never take 24 hours or more.
 97 define RecordEndTime
 98 	$(DATE) &#39;+%Y %m %d %H %M %S&#39; | $(NAWK) &#39;{ print $$1,$$2,$$3,$$4,$$5,$$6,($$4*3600+$$5*60+$$6) }&#39; &gt; $(BUILDTIMESDIR)/build_time_end_$(strip $1)
 99 	$(DATE) &#39;+%Y-%m-%d %H:%M:%S&#39; &gt; $(BUILDTIMESDIR)/build_time_end_$(strip $1)_human_readable
100 	$(ECHO) `$(CAT) $(BUILDTIMESDIR)/build_time_start_$(strip $1)` `$(CAT) $(BUILDTIMESDIR)/build_time_end_$(strip $1)` $1 | \
101 	    $(NAWK) &#39;{ F=$$7; T=$$14; if (F &gt; T) { T+=3600*24 }; D=T-F; H=int(D/3600); \
102 	    M=int((D-H*3600)/60); S=D-H*3600-M*60; printf(&quot;%02d:%02d:%02d %s\n&quot;,H,M,S,$$15); }&#39; \
103 	    &gt; $(BUILDTIMESDIR)/build_time_diff_$(strip $1)
104 endef
105 
106 # Hook to be called when starting to execute a top-level target
107 define TargetEnter
108 	$(PRINTF) &quot;## Starting $(patsubst %-only,%,$@)\n&quot;
109 	$(call RecordStartTime,$(patsubst %-only,%,$@))
110 endef
111 
112 # Hook to be called when finish executing a top-level target
113 define TargetExit
114 	$(call RecordEndTime,$(patsubst %-only,%,$@))
115 	$(PRINTF) &quot;## Finished $(patsubst %-only,%,$@) (build time %s)\n\n&quot; \
116 	    &quot;`$(CAT) $(BUILDTIMESDIR)/build_time_diff_$(patsubst %-only,%,$@) | $(CUT) -f 1 -d &#39; &#39;`&quot;
117 endef
118 
119 ################################################################################
120 
121 # A file containing a way to uniquely identify the source code revision that
122 # the build was created from
123 SOURCE_REVISION_TRACKER := $(SUPPORT_OUTPUTDIR)/src-rev/source-revision-tracker
124 
125 # Locate all hg repositories included in the forest, as absolute paths
126 FindAllReposAbs = \
127     $(strip $(sort $(dir $(filter-out $(TOPDIR)/build/%, $(wildcard \
128         $(addprefix $(TOPDIR)/, .hg */.hg */*/.hg */*/*/.hg */*/*/*/.hg) \
129         $(addprefix $(TOPDIR)/, .git */.git */*/.git */*/*/.git */*/*/*/.git) \
130     )))))
131 
132 # Locate all hg repositories included in the forest, as relative paths
133 FindAllReposRel = \
134     $(strip $(subst $(TOPDIR)/,.,$(patsubst $(TOPDIR)/%/, %, $(FindAllReposAbs))))
135 
136 ################################################################################
137 
138 define SetupLogging
139   ifeq ($$(LOG_PROFILE_TIMES_FILE), true)
140     ifeq ($$(IS_GNU_TIME), yes)
141       SHELL :=  $$(BASH) $$(TOPDIR)/make/scripts/shell-profiler.sh \
142                 gnutime $$(TIME) \
143                 $$(OUTPUTDIR)/build-profile.log $$(SHELL)
144     else ifneq ($$(FLOCK), )
145       SHELL :=  $$(BASH) $$(TOPDIR)/make/scripts/shell-profiler.sh \
146                 flock $$(FLOCK) \
147                 $$(OUTPUTDIR)/build-profile.log $$(SHELL)
148     endif
149   endif
150 
151   ifeq ($$(LOG_LEVEL), trace)
152     SHELL_NO_RECURSE := $$(SHELL)
153     # Shell redefinition trick inspired by http://www.cmcrossroads.com/ask-mr-make/6535-tracing-rule-execution-in-gnu-make
154     # For each target executed, will print
155     # Building &lt;TARGET&gt; (from &lt;FIRST PREREQUISITE&gt;) (&lt;ALL NEWER PREREQUISITES&gt; newer)
156     # but with a limit of 20 on &lt;ALL NEWER PREREQUISITES&gt;, to avoid cluttering logs too much
157     # (and causing a crash on Cygwin).
158     SHELL = $$(warning $$(if $$@,Building $$@,Running shell command) $$(if $$&lt;, (from $$&lt;))$$(if $$?, ($$(wordlist 1, 20, $$?) $$(if $$(wordlist 21, 22, $$?), ... [in total $$(words $$?) files]) newer)))$$(SHELL_NO_RECURSE) -x
159   endif
160 
<a name="3" id="anc3"></a>
161   # The warn level can never be turned off
<a name="4" id="anc4"></a><span class="line-modified">162   LogWarn = $$(info $$(strip $$1))</span>
163   LOG_WARN :=
164   ifneq ($$(findstring $$(LOG_LEVEL), info debug trace),)
<a name="5" id="anc5"></a><span class="line-modified">165     LogInfo = $$(info $$(strip $$1))</span>
166     LOG_INFO :=
167   else
168     LogInfo =
169     LOG_INFO := &gt; /dev/null
170   endif
171   ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)
<a name="6" id="anc6"></a><span class="line-modified">172     LogDebug = $$(info $$(strip $$1))</span>
173     LOG_DEBUG :=
174   else
175     LogDebug =
176     LOG_DEBUG := &gt; /dev/null
177   endif
178   ifneq ($$(findstring $$(LOG_LEVEL), trace),)
<a name="7" id="anc7"></a><span class="line-modified">179     LogTrace = $$(info $$(strip $$1))</span>
180     LOG_TRACE :=
181   else
182     LogTrace =
183     LOG_TRACE := &gt; /dev/null
184   endif
185 endef
186 
187 # Make sure logging is setup for everyone that includes MakeBase.gmk.
188 $(eval $(call SetupLogging))
189 
190 ################################################################################
191 
192 MAX_PARAMS := 36
193 PARAM_SEQUENCE := $(call sequence, 2, $(MAX_PARAMS))
194 
195 # Template for creating a macro taking named parameters. To use it, assign the
196 # template to a variable with the name you want for your macro, using &#39;=&#39;
197 # assignment. Then define a macro body with the suffix &quot;Body&quot;. The Body macro
198 # should take 1 parameter which should be a unique string for that invocation
199 # of the macro.
200 # Ex:
201 # SetupFoo = $(NamedParamsMacroTemplate)
202 # define SetupFooBody
203 #   # do something
204 #   # access parameters as $$($1_BAR)
205 # endef
206 # Call it like this
207 # $(eval $(call SetupFoo, BUILD_SOMETHING, \
208 #     BAR := some parameter value, \
209 # ))
210 define NamedParamsMacroTemplate
211   $(if $($(MAX_PARAMS)),$(error Internal makefile error: \
212       Too many named arguments to macro, please update MAX_PARAMS in MakeBase.gmk))
213   # Iterate over 2 3 4... and evaluate the named parameters with $1_ as prefix
214   $(foreach i,$(PARAM_SEQUENCE), $(if $(strip $($i)),\
215     $(strip $1)_$(strip $(call EscapeHash, $(call DoubleDollar, $($i))))$(NEWLINE)))
216   # Debug print all named parameter names and values
217   $(if $(findstring $(LOG_LEVEL),debug trace), \
218     $(info $0 $(strip $1) $(foreach i,$(PARAM_SEQUENCE), \
219       $(if $(strip $($i)),$(NEWLINE) $(strip [$i] $(if $(filter $(LOG_LEVEL), trace), \
220         $($i), $(wordlist 1, 20, $($(i))) $(if $(word 21, $($(i))), ...)))))))
221 
222   $(if $(DEBUG_$(strip $1)),
223     $(info -------- &lt;&lt;&lt; Begin expansion of $(strip $1)) \
224     $(info $(call $(0)Body,$(strip $1))) \
225     $(info -------- &gt;&gt;&gt; End expansion of $(strip $1)) \
226   )
227 
228   $(call $(0)Body,$(strip $1))
229 endef
230 
231 ################################################################################
232 # Make directory without forking mkdir if not needed.
233 #
234 # If a directory with an encoded space is provided, the wildcard function
235 # sometimes returns false answers (typically if the dir existed when the
236 # makefile was parsed, but was deleted by a previous rule). In that case, always
237 # call mkdir regardless of what wildcard says.
238 #
239 # 1: List of directories to create
240 MakeDir = \
241     $(strip \
242         $(eval MakeDir_dirs_to_make := $(strip $(foreach d, $1, \
243           $(if $(findstring ?, $d), &#39;$(call DecodeSpace, $d)&#39;, \
244             $(if $(wildcard $d), , $d) \
245           ) \
246         ))) \
247         $(if $(MakeDir_dirs_to_make), $(shell $(MKDIR) -p $(MakeDir_dirs_to_make))) \
248     )
249 
250 # Make directory for target file. Should handle spaces in filenames. Just
251 # calling $(call MakeDir $(@D)) will not work if the directory contains a space
252 # and the target file already exists. In that case, the target file will have
253 # its wildcard ? resolved and the $(@D) will evaluate each space separated dir
254 # part on its own.
255 MakeTargetDir = \
256     $(call MakeDir, $(dir $(call EncodeSpace, $@)))
257 
258 ################################################################################
259 # All install-file and related macros automatically call DecodeSpace when needed.
260 
261 ifeq ($(call isTargetOs, solaris), true)
262   # On Solaris, if the target is a symlink and exists, cp won&#39;t overwrite.
263   # Cp has to operate in recursive mode to allow for -P flag, to preserve soft links. If the
264   # name of the target file differs from the source file, rename after copy.
265   # If the source and target parent directories are the same, recursive copy doesn&#39;t work
266   # so we fall back on regular copy, which isn&#39;t preserving symlinks.
267   define install-file
268 	$(call MakeTargetDir)
269 	$(RM) &#39;$(call DecodeSpace, $@)&#39;
270 	if [ &#39;$(call DecodeSpace, $(dir $(call EncodeSpace, $@)))&#39; != \
271 	    &#39;$(call DecodeSpace, $(dir $(call EncodeSpace, $&lt;)))&#39; ]; then \
272 	  $(CP) -f -r -P &#39;$(call DecodeSpace, $&lt;)&#39; \
273 	      &#39;$(call DecodeSpace, $(dir $(call EncodeSpace, $@)))&#39;; \
274 	  if [ &#39;$(call DecodeSpace, $(notdir $(call EncodeSpace, $@)))&#39; != \
275 	      &#39;$(call DecodeSpace, $(notdir $(call EncodeSpace, $(&lt;))))&#39; ]; then \
276 	    $(MV) &#39;$(call DecodeSpace, $(dir $(call EncodeSpace, $@))/$(notdir $(call EncodeSpace, $&lt;)))&#39; \
277 	        &#39;$(call DecodeSpace, $@)&#39;; \
278 	  fi; \
279 	else \
280 	  if [ -L &#39;$(call DecodeSpace, $&lt;)&#39; ]; then \
281 	    $(ECHO) &quot;Source file is a symlink and target is in the same directory: $&lt; $@&quot; ; \
282 	    exit 1; \
283 	  fi; \
284 	  $(CP) -f &#39;$(call DecodeSpace, $&lt;)&#39; &#39;$(call DecodeSpace, $@)&#39;; \
285 	fi
286   endef
287 else ifeq ($(call isTargetOs, macosx), true)
288   # On mac, extended attributes sometimes creep into the source files, which may later
289   # cause the creation of ._* files which confuses testing. Clear these with xattr if
290   # set. Some files get their write permissions removed after being copied to the
291   # output dir. When these are copied again to images, xattr would fail. By only clearing
292   # attributes when they are present, failing on this is avoided.
293   #
294   # If copying a soft link to a directory, need to delete the target first to avoid
295   # weird errors.
296   define install-file
297 	$(call MakeTargetDir)
298 	$(RM) &#39;$(call DecodeSpace, $@)&#39;
299         # Work around a weirdness with cp on Macosx. When copying a symlink, if
300         # the target of the link is write protected (e.g. 444), cp will add
301         # write permission for the user on the target file (644). Avoid this by
302         # using ln to create a new link instead.
303 	if [ -h &#39;$(call DecodeSpace, $&lt;)&#39; ]; then \
304 	  $(LN) -s &quot;`$(READLINK) &#39;$(call DecodeSpace, $&lt;)&#39;`&quot; &#39;$(call DecodeSpace, $@)&#39;; \
305 	else \
306 	  $(CP) -fRP &#39;$(call DecodeSpace, $&lt;)&#39; &#39;$(call DecodeSpace, $@)&#39;; \
307 	fi
308 	if [ -n &quot;`$(XATTR) -ls &#39;$(call DecodeSpace, $@)&#39;`&quot; ]; then \
309 	  $(XATTR) -cs &#39;$(call DecodeSpace, $@)&#39;; \
310 	fi
311   endef
312 else
313   define install-file
314 	$(call MakeTargetDir)
315 	$(CP) -fP &#39;$(call DecodeSpace, $&lt;)&#39; &#39;$(call DecodeSpace, $@)&#39;
316   endef
317 endif
318 
319 # Variant of install file that does not preserve symlinks
320 define install-file-nolink
321 	$(call MakeTargetDir)
322 	$(CP) -f &#39;$(call DecodeSpace, $&lt;)&#39; &#39;$(call DecodeSpace, $@)&#39;
323 endef
324 
325 ################################################################################
326 # link-file-* works similarly to install-file but creates a symlink instead.
327 # There are two versions, either creating a relative or an absolute link. Be
328 # careful when using this on Windows since the symlink created is only valid in
329 # the unix emulation environment.
330 define link-file-relative
331 	$(call MakeTargetDir)
332 	$(RM) &#39;$(call DecodeSpace, $@)&#39;
333 	$(LN) -s &#39;$(call DecodeSpace, $(call RelativePath, $&lt;, $(@D)))&#39; &#39;$(call DecodeSpace, $@)&#39;
334 endef
335 
336 define link-file-absolute
337 	$(call MakeTargetDir)
338 	$(RM) &#39;$(call DecodeSpace, $@)&#39;
339 	$(LN) -s &#39;$(call DecodeSpace, $&lt;)&#39; &#39;$(call DecodeSpace, $@)&#39;
340 endef
341 
342 ################################################################################
343 
<a name="8" id="anc8"></a><span class="line-modified">344 ifneq ($(DISABLE_CACHE_FIND), true)</span>
<span class="line-modified">345   # In Cygwin, finds are very costly, both because of expensive forks and because</span>
<span class="line-modified">346   # of bad file system caching. Find is used extensively in $(shell) commands to</span>
<span class="line-modified">347   # find source files. This makes rerunning make with no or few changes rather</span>
<span class="line-modified">348   # expensive. To speed this up, these two macros are used to cache the results</span>
<span class="line-modified">349   # of simple find commands for reuse.</span>
<span class="line-modified">350   #</span>
<span class="line-modified">351   # Runs a find and stores both the directories where it was run and the results.</span>
<span class="line-modified">352   # This macro can be called multiple times to add to the cache. Only finds files</span>
<span class="line-modified">353   # with no filters.</span>
<span class="line-modified">354   #</span>
<span class="line-modified">355   # Files containing space will get spaces replaced with ? because GNU Make</span>
<span class="line-modified">356   # cannot handle lists of files with space in them. By using ?, make will match</span>
<span class="line-modified">357   # the wildcard to space in many situations so we don&#39;t need to replace back</span>
<span class="line-removed">358   # to space on every use. While not a complete solution it does allow some uses</span>
<span class="line-removed">359   # of CacheFind to function with spaces in file names, including for</span>
<span class="line-removed">360   # SetupCopyFiles.</span>
<span class="line-removed">361   #</span>
<span class="line-removed">362   # Needs to be called with $(eval )</span>
<span class="line-removed">363   #</span>
<span class="line-removed">364   # Even if the performance benifit is negligible on other platforms, keep the</span>
<span class="line-removed">365   # functionality active unless explicitly disabled to exercise it more.</span>
<span class="line-removed">366   #</span>
<span class="line-removed">367   # Initialize FIND_CACHE_DIRS with := to make it a non recursively-expanded variable</span>
<span class="line-removed">368   FIND_CACHE_DIRS :=</span>
<span class="line-removed">369   # Param 1 - Dirs to find in</span>
<span class="line-removed">370   # Param 2 - (optional) specialization. Normally &quot;-a \( ... \)&quot; expression.</span>
<span class="line-removed">371   define FillCacheFind</span>
<span class="line-removed">372     # Filter out already cached dirs. The - is needed when FIND_CACHE_DIRS is empty</span>
<span class="line-removed">373     # since filter out will then return empty.</span>
<span class="line-removed">374     FIND_CACHE_NEW_DIRS := $$(filter-out $$(addsuffix /%,\</span>
<span class="line-removed">375         - $(FIND_CACHE_DIRS)) $(FIND_CACHE_DIRS), $1)</span>
<span class="line-removed">376     ifneq ($$(FIND_CACHE_NEW_DIRS), )</span>
<span class="line-removed">377       # Remove any trailing slash from dirs in the cache dir list</span>
<span class="line-removed">378       FIND_CACHE_DIRS += $$(patsubst %/,%, $$(FIND_CACHE_NEW_DIRS))</span>
<span class="line-removed">379       FIND_CACHE := $$(sort $$(FIND_CACHE) \</span>
<span class="line-removed">380           $$(shell $(FIND) $$(wildcard $$(FIND_CACHE_NEW_DIRS)) \</span>
<span class="line-removed">381               \( -type f -o -type l \) $2 | $(TR) &#39; &#39; &#39;?&#39;))</span>
<span class="line-removed">382     endif</span>
<span class="line-removed">383   endef</span>
384 
<a name="9" id="anc9"></a><span class="line-modified">385   # Mimics find by looking in the cache if all of the directories have been cached.</span>
<span class="line-modified">386   # Otherwise reverts to shell find. This is safe to call on all platforms, even if</span>
<span class="line-modified">387   # cache is deactivated.</span>
<span class="line-modified">388   #</span>
<span class="line-modified">389   # $1 can be either a directory or a file. If it&#39;s a directory, make</span>
<span class="line-modified">390   # sure we have exactly one trailing slash before the wildcard.</span>
<span class="line-modified">391   # The extra - is needed when FIND_CACHE_DIRS is empty but should be harmless.</span>
<span class="line-modified">392   #</span>
<span class="line-modified">393   # Param 1 - Dirs to find in</span>
<span class="line-modified">394   # Param 2 - (optional) specialization. Normally &quot;-a \( ... \)&quot; expression.</span>
<span class="line-modified">395   # Param 3 - (optional) options to find.</span>
<span class="line-modified">396   define CacheFind</span>
<span class="line-modified">397     $(if $(filter-out $(addsuffix /%,- $(FIND_CACHE_DIRS)) $(FIND_CACHE_DIRS),$1), \</span>
<span class="line-modified">398       $(if $(wildcard $1), $(shell $(FIND) $3 $(wildcard $1) \( -type f -o -type l \) $2 \</span>
<span class="line-modified">399           | $(TR) &#39; &#39; &#39;?&#39;)), \</span>
<span class="line-modified">400       $(filter $(addsuffix /%,$(patsubst %/,%,$1)) $1,$(FIND_CACHE)))</span>
<span class="line-modified">401   endef</span>






















402 
<a name="10" id="anc10"></a>






403 else
<a name="11" id="anc11"></a><span class="line-modified">404   # If CacheFind is disabled, just run the find command.</span>
<span class="line-modified">405   # Param 1 - Dirs to find in</span>
<span class="line-modified">406   # Param 2 - (optional) specialization. Normally &quot;-a \( ... \)&quot; expression.</span>
<span class="line-modified">407   define CacheFind</span>
<span class="line-modified">408     $(if $(wildcard $1, \</span>
<span class="line-modified">409       $(shell $(FIND) $(wildcard $1) \( -type f -o -type l \) $2 | $(TR) &#39; &#39; &#39;?&#39;) \</span>
















410     )
<a name="12" id="anc12"></a><span class="line-modified">411   endef</span>























412 endif
413 
414 ################################################################################
415 # FixPath
416 #
417 # On Windows, converts a path from cygwin/unix style (e.g. /bin/foo) into
418 # &quot;mixed mode&quot; (e.g. c:/cygwin/bin/foo). On other platforms, return the path
419 # unchanged.
420 # This is normally not needed since we use the FIXPATH prefix for command lines,
421 # but might be needed in certain circumstances.
422 ifeq ($(call isTargetOs, windows), true)
423   FixPath = \
424       $(shell $(CYGPATH) -m $1)
425 else
426   FixPath = \
427       $1
428 endif
429 
<a name="13" id="anc13"></a>















430 ################################################################################
431 # DependOnVariable
432 #
433 # This macro takes a variable name and puts the value in a file only if the
434 # value has changed since last. The name of the file is returned. This can be
435 # used to create rule dependencies on make variable values. The following
436 # example would get rebuilt if the value of SOME_VAR was changed:
437 #
438 # path/to/some-file: $(call DependOnVariable, SOME_VAR)
439 #         echo $(SOME_VAR) &gt; $@
440 #
441 # Note that leading and trailing white space in the value is ignored.
442 #
443 
444 # Defines the sub directory structure to store variable value file in
445 DependOnVariableDirName = \
446     $(strip $(addsuffix $(if $(MODULE),/$(MODULE)), \
447         $(subst $(TOPDIR)/,, $(if $(filter /%, $(firstword $(MAKEFILE_LIST))), \
448           $(firstword $(MAKEFILE_LIST)), \
449           $(CURDIR)/$(firstword $(MAKEFILE_LIST))))))
450 
451 # Defines the name of the file to store variable value in. Generates a name
452 # unless parameter 2 is given.
453 # Param 1 - Name of variable
454 # Param 2 - (optional) name of file to store value in
455 DependOnVariableFileName = \
456     $(strip $(if $(strip $2), $2, \
457       $(MAKESUPPORT_OUTPUTDIR)/vardeps/$(DependOnVariableDirName)/$(strip $1).vardeps))
458 
459 # Does the actual work with parameters stripped.
460 # If the file exists AND the contents is the same as the variable, do nothing
461 # else print a new file.
462 # Always returns the name of the file where the value was printed.
463 # Param 1 - Name of variable
464 # Param 2 - (optional) name of file to store value in
465 DependOnVariableHelper = \
466     $(strip \
<a name="14" id="anc14"></a><span class="line-modified">467         $(eval -include $(call DependOnVariableFileName, $1, $2)) \</span>

468         $(if $(call equals, $(strip $($1)), $(strip $($1_old))),,\
<a name="15" id="anc15"></a><span class="line-modified">469           $(call MakeDir, $(dir $(call DependOnVariableFileName, $1, $2))) \</span>
470           $(if $(findstring $(LOG_LEVEL), trace), \
471               $(info NewVariable $1: &gt;$(strip $($1))&lt;) \
472               $(info OldVariable $1: &gt;$(strip $($1_old))&lt;)) \
473           $(call WriteFile, $1_old:=$(call DoubleDollar,$(call EscapeHash,$($1))), \
<a name="16" id="anc16"></a><span class="line-modified">474               $(call DependOnVariableFileName, $1, $2))) \</span>
<span class="line-modified">475         $(call DependOnVariableFileName, $1, $2) \</span>
476     )
477 
478 # Main macro
479 # Param 1 - Name of variable
480 # Param 2 - (optional) name of file to store value in
481 DependOnVariable = \
482     $(call DependOnVariableHelper,$(strip $1),$(strip $2))
483 
484 # LogCmdlines is only intended to be used by ExecuteWithLog
485 ifeq ($(LOG_CMDLINES), true)
486   LogCmdlines = $(info $(strip $1))
487 else
488   LogCmdlines =
489 endif
490 
491 ################################################################################
492 # ExecuteWithLog will run a command and log the output appropriately. This is
493 # meant to be used by commands that do &quot;real&quot; work, like a compilation.
494 # The output is stored in a specified log file, which is displayed at the end
495 # of the build in case of failure. The  command line itself is stored in a file,
496 # and also logged to stdout if the LOG=cmdlines option has been given.
497 #
498 # NOTE: If the command redirects stdout, the caller needs to wrap it in a
499 # subshell (by adding parentheses around it), otherwise the redirect to the
500 # subshell tee process will create a race condition where the target file may
501 # not be fully written when the make recipe is done.
502 #
503 # Param 1 - The path to base the name of the log file / command line file on
504 # Param 2 - The command to run
505 ExecuteWithLog = \
<a name="17" id="anc17"></a><span class="line-modified">506   $(call LogCmdlines, Exececuting: [$(strip $2)]) \</span>
<span class="line-modified">507   $(call MakeDir, $(dir $(strip $1))) \</span>
508   $(call WriteFile, $2, $(strip $1).cmdline) \
509   ( $(RM) $(strip $1).log &amp;&amp; $(strip $2) &gt; &gt;($(TEE) -a $(strip $1).log) 2&gt; &gt;($(TEE) -a $(strip $1).log &gt;&amp;2) || \
510       ( exitcode=$(DOLLAR)? &amp;&amp; \
511       $(CP) $(strip $1).log $(MAKESUPPORT_OUTPUTDIR)/failure-logs/$(subst /,_,$(patsubst $(OUTPUTDIR)/%,%,$(strip $1))).log &amp;&amp; \
512       $(CP) $(strip $1).cmdline $(MAKESUPPORT_OUTPUTDIR)/failure-logs/$(subst /,_,$(patsubst $(OUTPUTDIR)/%,%,$(strip $1))).cmdline &amp;&amp; \
513       exit $(DOLLAR)exitcode ) )
514 
515 ################################################################################
516 
517 # Hook to include the corresponding custom file, if present.
518 $(eval $(call IncludeCustomExtension, common/MakeBase.gmk))
519 
520 endif # _MAKEBASE_GMK
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
diff a/make/common/MakeBase.gmk b/make/common/MakeBase.gmk
--- a/make/common/MakeBase.gmk
+++ b/make/common/MakeBase.gmk
@@ -62,14 +62,16 @@
 define NEWLINE
 
 
 endef
 
-# In GNU Make 4.0 and higher, there is a file function for writing to files.
+# Certain features only work in newer version of GNU Make. The build will still
+# function in 3.81, but will be less performant.
 ifeq (4.0, $(firstword $(sort 4.0 $(MAKE_VERSION))))
   HAS_FILE_FUNCTION := true
   CORRECT_FUNCTION_IN_RECIPE_EVALUATION := true
+  RWILDCARD_WORKS := true
 endif
 
 
 # For convenience, MakeBase.gmk continues to include these separate files, at
 # least for now.
@@ -156,29 +158,30 @@
     # but with a limit of 20 on <ALL NEWER PREREQUISITES>, to avoid cluttering logs too much
     # (and causing a crash on Cygwin).
     SHELL = $$(warning $$(if $$@,Building $$@,Running shell command) $$(if $$<, (from $$<))$$(if $$?, ($$(wordlist 1, 20, $$?) $$(if $$(wordlist 21, 22, $$?), ... [in total $$(words $$?) files]) newer)))$$(SHELL_NO_RECURSE) -x
   endif
 
+  # The LOG_PREFIX is set for sub recursive calls like buildjdk and bootcycle.
   # The warn level can never be turned off
-  LogWarn = $$(info $$(strip $$1))
+  LogWarn = $$(info $(LOG_PREFIX)$$(strip $$1))
   LOG_WARN :=
   ifneq ($$(findstring $$(LOG_LEVEL), info debug trace),)
-    LogInfo = $$(info $$(strip $$1))
+    LogInfo = $$(info $(LOG_PREFIX)$$(strip $$1))
     LOG_INFO :=
   else
     LogInfo =
     LOG_INFO := > /dev/null
   endif
   ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)
-    LogDebug = $$(info $$(strip $$1))
+    LogDebug = $$(info $(LOG_PREFIX)$$(strip $$1))
     LOG_DEBUG :=
   else
     LogDebug =
     LOG_DEBUG := > /dev/null
   endif
   ifneq ($$(findstring $$(LOG_LEVEL), trace),)
-    LogTrace = $$(info $$(strip $$1))
+    LogTrace = $$(info $(LOG_PREFIX)$$(strip $$1))
     LOG_TRACE :=
   else
     LogTrace =
     LOG_TRACE := > /dev/null
   endif
@@ -339,78 +342,120 @@
 	$(LN) -s '$(call DecodeSpace, $<)' '$(call DecodeSpace, $@)'
 endef
 
 ################################################################################
 
-ifneq ($(DISABLE_CACHE_FIND), true)
-  # In Cygwin, finds are very costly, both because of expensive forks and because
-  # of bad file system caching. Find is used extensively in $(shell) commands to
-  # find source files. This makes rerunning make with no or few changes rather
-  # expensive. To speed this up, these two macros are used to cache the results
-  # of simple find commands for reuse.
-  #
-  # Runs a find and stores both the directories where it was run and the results.
-  # This macro can be called multiple times to add to the cache. Only finds files
-  # with no filters.
-  #
-  # Files containing space will get spaces replaced with ? because GNU Make
-  # cannot handle lists of files with space in them. By using ?, make will match
-  # the wildcard to space in many situations so we don't need to replace back
-  # to space on every use. While not a complete solution it does allow some uses
-  # of CacheFind to function with spaces in file names, including for
-  # SetupCopyFiles.
-  #
-  # Needs to be called with $(eval )
-  #
-  # Even if the performance benifit is negligible on other platforms, keep the
-  # functionality active unless explicitly disabled to exercise it more.
-  #
-  # Initialize FIND_CACHE_DIRS with := to make it a non recursively-expanded variable
-  FIND_CACHE_DIRS :=
-  # Param 1 - Dirs to find in
-  # Param 2 - (optional) specialization. Normally "-a \( ... \)" expression.
-  define FillCacheFind
-    # Filter out already cached dirs. The - is needed when FIND_CACHE_DIRS is empty
-    # since filter out will then return empty.
-    FIND_CACHE_NEW_DIRS := $$(filter-out $$(addsuffix /%,\
-        - $(FIND_CACHE_DIRS)) $(FIND_CACHE_DIRS), $1)
-    ifneq ($$(FIND_CACHE_NEW_DIRS), )
-      # Remove any trailing slash from dirs in the cache dir list
-      FIND_CACHE_DIRS += $$(patsubst %/,%, $$(FIND_CACHE_NEW_DIRS))
-      FIND_CACHE := $$(sort $$(FIND_CACHE) \
-          $$(shell $(FIND) $$(wildcard $$(FIND_CACHE_NEW_DIRS)) \
-              \( -type f -o -type l \) $2 | $(TR) ' ' '?'))
-    endif
-  endef
+# Recursive wildcard function. Walks down directories recursively and matches
+# files with the search patterns. Patterns use standard file wildcards (* and
+# ?).
+#
+# $1 - Directories to start search in
+# $2 - Search patterns
+rwildcard = \
+    $(strip \
+        $(foreach d, \
+          $(patsubst %/,%,$(sort $(dir $(wildcard $(addsuffix /*/*, $(strip $1)))))), \
+          $(call rwildcard,$d,$2) \
+        ) \
+        $(call DoubleDollar, $(wildcard $(foreach p, $2, $(addsuffix /$(strip $p), $(strip $1))))) \
+    )
 
-  # Mimics find by looking in the cache if all of the directories have been cached.
-  # Otherwise reverts to shell find. This is safe to call on all platforms, even if
-  # cache is deactivated.
-  #
-  # $1 can be either a directory or a file. If it's a directory, make
-  # sure we have exactly one trailing slash before the wildcard.
-  # The extra - is needed when FIND_CACHE_DIRS is empty but should be harmless.
-  #
-  # Param 1 - Dirs to find in
-  # Param 2 - (optional) specialization. Normally "-a \( ... \)" expression.
-  # Param 3 - (optional) options to find.
-  define CacheFind
-    $(if $(filter-out $(addsuffix /%,- $(FIND_CACHE_DIRS)) $(FIND_CACHE_DIRS),$1), \
-      $(if $(wildcard $1), $(shell $(FIND) $3 $(wildcard $1) \( -type f -o -type l \) $2 \
-          | $(TR) ' ' '?')), \
-      $(filter $(addsuffix /%,$(patsubst %/,%,$1)) $1,$(FIND_CACHE)))
-  endef
+# Find non directories using recursive wildcard function. This function may
+# be used directly when a small amount of directories is expected to be
+# searched and caching is not expected to be of use.
+#
+# $1 - Directory to start search in
+# $2 - Optional search patterns, defaults to '*'.
+WildcardFindFiles = \
+    $(sort $(strip \
+        $(eval WildcardFindFiles_result := $(call rwildcard,$(patsubst %/,%,$1),$(if $(strip $2),$2,*))) \
+        $(filter-out $(patsubst %/,%,$(sort $(dir $(WildcardFindFiles_result)))), \
+            $(WildcardFindFiles_result) \
+        ) \
+    ))
+
+# Find non directories using the find utility in the shell. Safe to call for
+# non existing directories, or directories containing wildcards.
+#
+# Files containing space will get spaces replaced with ? because GNU Make
+# cannot handle lists of files with space in them. By using ?, make will match
+# the wildcard to space in many situations so we don't need to replace back
+# to space on every use. While not a complete solution it does allow some uses
+# of FindFiles to function with spaces in file names, including for
+# SetupCopyFiles. Unfortunately this does not work for WildcardFindFiles so
+# if files with spaces are anticipated, use ShellFindFiles directly.
+#
+# $1 - Directories to start search in.
+# $2 - Optional search patterns, empty means find everything. Patterns use
+#      standard file wildcards (* and ?) and should not be quoted.
+# $3 - Optional options to find.
+ShellFindFiles = \
+    $(if $(wildcard $1), \
+      $(sort \
+          $(shell $(FIND) $3 $(patsubst %/,%,$(wildcard $1)) \( -type f -o -type l \) \
+              $(if $(strip $2), -a \( -name "$(firstword $2)" \
+              $(foreach p, $(filter-out $(firstword $2), $2), -o -name "$(p)") \)) \
+              | $(TR) ' ' '?' \
+          ) \
+      ) \
+    )
 
+# Find non directories using the method most likely to work best for the
+# current build host
+#
+# $1 - Directory to start search in
+# $2 - Optional search patterns, defaults to '*'.
+ifeq ($(OPENJDK_BUILD_OS)-$(RWILDCARD_WORKS), windows-true)
+  DirectFindFiles = $(WildcardFindFiles)
 else
-  # If CacheFind is disabled, just run the find command.
-  # Param 1 - Dirs to find in
-  # Param 2 - (optional) specialization. Normally "-a \( ... \)" expression.
-  define CacheFind
-    $(if $(wildcard $1, \
-      $(shell $(FIND) $(wildcard $1) \( -type f -o -type l \) $2 | $(TR) ' ' '?') \
+  DirectFindFiles = $(ShellFindFiles)
+endif
+
+# Finds files using a cache that is populated by FillFindCache below. If any of
+# the directories given have not been cached, DirectFindFiles is used for
+# everything. Caching is especially useful in Cygwin, where file finds are very
+# costly.
+#
+# $1 - Directories to start search in.
+# $2 - Optional search patterns. If used, no caching is done.
+CacheFindFiles_CACHED_DIRS :=
+CacheFindFiles_CACHED_FILES :=
+CacheFindFiles = \
+    $(if $2, \
+      $(call DirectFindFiles, $1, $2) \
+    , \
+      $(if $(filter-out $(addsuffix /%, $(CacheFindFiles_CACHED_DIRS)) \
+          $(CacheFindFiles_CACHED_DIRS), $1), \
+        $(call DirectFindFiles, $1) \
+      , \
+        $(filter $(addsuffix /%,$(patsubst %/,%,$1)) $1,$(CacheFindFiles_CACHED_FILES)) \
+      ) \
     )
-  endef
+
+# Explicitly adds files to the find cache used by CacheFindFiles.
+#
+# $1 - Directories to start search in
+FillFindCache = \
+    $(eval CacheFindFiles_NEW_DIRS := $$(filter-out $$(addsuffix /%,\
+        $$(CacheFindFiles_CACHED_DIRS)) $$(CacheFindFiles_CACHED_DIRS), $1)) \
+    $(if $(CacheFindFiles_NEW_DIRS), \
+      $(eval CacheFindFiles_CACHED_DIRS += $$(patsubst %/,%,$$(CacheFindFiles_NEW_DIRS))) \
+      $(eval CacheFindFiles_CACHED_FILES := $$(sort $$(CacheFindFiles_CACHED_FILES) \
+          $$(call DirectFindFiles, $$(CacheFindFiles_NEW_DIRS)))) \
+    )
+
+# Findfiles is the default macro that should be used to find files in the file
+# system. This function does not always support files with spaces in the names.
+# If files with spaces are anticipated, use ShellFindFiles directly.
+#
+# $1 - Directories to start search in.
+# $2 - Optional search patterns, empty means find everything. Patterns use
+#      standard file wildcards (* and ?) and should not be quoted.
+ifeq ($(DISABLE_CACHE_FIND), true)
+  FindFiles = $(DirectFindFiles)
+else
+  FindFiles = $(CacheFindFiles)
 endif
 
 ################################################################################
 # FixPath
 #
@@ -425,10 +470,26 @@
 else
   FixPath = \
       $1
 endif
 
+################################################################################
+# FixPathList
+#
+# On Windows, converts a cygwin/unix style path list (colon-separated) into
+# the native format (mixed mode, semicolon-separated). On other platforms,
+# return the path list unchanged.
+################################################################################
+ifeq ($(call isTargetOs, windows), true)
+  FixPathList = \
+      $(subst @,$(SPACE),$(subst $(SPACE),;,$(foreach entry,$(subst :,$(SPACE),\
+      $(subst $(SPACE),@,$(strip $1))),$(call FixPath, $(entry)))))
+else
+  FixPathList = \
+      $1
+endif
+
 ################################################################################
 # DependOnVariable
 #
 # This macro takes a variable name and puts the value in a file only if the
 # value has changed since last. The name of the file is returned. This can be
@@ -462,19 +523,20 @@
 # Always returns the name of the file where the value was printed.
 # Param 1 - Name of variable
 # Param 2 - (optional) name of file to store value in
 DependOnVariableHelper = \
     $(strip \
-        $(eval -include $(call DependOnVariableFileName, $1, $2)) \
+        $(eval $1_filename := $(call DependOnVariableFileName, $1, $2)) \
+        $(if $(wildcard $($1_filename)), $(eval include $($1_filename))) \
         $(if $(call equals, $(strip $($1)), $(strip $($1_old))),,\
-          $(call MakeDir, $(dir $(call DependOnVariableFileName, $1, $2))) \
+          $(call MakeDir, $(dir $($1_filename))) \
           $(if $(findstring $(LOG_LEVEL), trace), \
               $(info NewVariable $1: >$(strip $($1))<) \
               $(info OldVariable $1: >$(strip $($1_old))<)) \
           $(call WriteFile, $1_old:=$(call DoubleDollar,$(call EscapeHash,$($1))), \
-              $(call DependOnVariableFileName, $1, $2))) \
-        $(call DependOnVariableFileName, $1, $2) \
+              $($1_filename))) \
+        $($1_filename) \
     )
 
 # Main macro
 # Param 1 - Name of variable
 # Param 2 - (optional) name of file to store value in
@@ -501,12 +563,12 @@
 # not be fully written when the make recipe is done.
 #
 # Param 1 - The path to base the name of the log file / command line file on
 # Param 2 - The command to run
 ExecuteWithLog = \
-  $(call LogCmdlines, Exececuting: [$(strip $2)]) \
-  $(call MakeDir, $(dir $(strip $1))) \
+  $(call LogCmdlines, Executing: [$(strip $2)]) \
+  $(call MakeDir, $(dir $(strip $1)) $(MAKESUPPORT_OUTPUTDIR)/failure-logs) \
   $(call WriteFile, $2, $(strip $1).cmdline) \
   ( $(RM) $(strip $1).log && $(strip $2) > >($(TEE) -a $(strip $1).log) 2> >($(TEE) -a $(strip $1).log >&2) || \
       ( exitcode=$(DOLLAR)? && \
       $(CP) $(strip $1).log $(MAKESUPPORT_OUTPUTDIR)/failure-logs/$(subst /,_,$(patsubst $(OUTPUTDIR)/%,%,$(strip $1))).log && \
       $(CP) $(strip $1).cmdline $(MAKESUPPORT_OUTPUTDIR)/failure-logs/$(subst /,_,$(patsubst $(OUTPUTDIR)/%,%,$(strip $1))).cmdline && \

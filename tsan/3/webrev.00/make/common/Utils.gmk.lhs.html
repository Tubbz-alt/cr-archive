<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/common/Utils.gmk</title>
    <link rel="stylesheet" href="../../style.css" />
    <script type="text/javascript" src="../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 #
  2 # Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4 #
  5 # This code is free software; you can redistribute it and/or modify it
  6 # under the terms of the GNU General Public License version 2 only, as
  7 # published by the Free Software Foundation.  Oracle designates this
  8 # particular file as subject to the &quot;Classpath&quot; exception as provided
  9 # by Oracle in the LICENSE file that accompanied this code.
 10 #
 11 # This code is distributed in the hope that it will be useful, but WITHOUT
 12 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14 # version 2 for more details (a copy is included in the LICENSE file that
 15 # accompanied this code).
 16 #
 17 # You should have received a copy of the GNU General Public License version
 18 # 2 along with this work; if not, write to the Free Software Foundation,
 19 # Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20 #
 21 # Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22 # or visit www.oracle.com if you need additional information or have any
 23 # questions.
 24 #
 25 
 26 ifeq (,$(_MAKEBASE_GMK))
 27   $(error You must include MakeBase.gmk prior to including Utils.gmk)
 28 endif
 29 
 30 ################################################################################
 31 #
 32 # Common utility functions
 33 #
 34 ################################################################################
 35 
 36 ### Debug functions
 37 
 38 # Prints the name and value of a variable
 39 PrintVar = \
 40     $(info $(strip $1) &gt;$($(strip $1))&lt;)
 41 
 42 ################################################################################
 43 # This macro translates $ into \$ to protect the $ from expansion in the shell.
 44 # To make this macro resilient against already escaped strings, first remove
 45 # any present escapes before escaping so that no double escapes are added.
 46 EscapeDollar = $(subst $$,\$$,$(subst \$$,$$,$(strip $1)))
 47 
 48 ################################################################################
 49 # This macro works just like EscapeDollar above, but for #.
 50 EscapeHash = $(subst \#,\\\#,$(subst \\\#,\#,$(strip $1)))
 51 
 52 ################################################################################
 53 # This macro translates $ into $$ to protect the string from make itself.
 54 DoubleDollar = $(subst $$,$$$$,$(strip $1))
 55 
 56 ################################################################################
 57 # Creates a sequence of increasing numbers (inclusive).
 58 # Param 1 - starting number
 59 # Param 2 - ending number
 60 sequence = \
 61     $(wordlist $1, $2, $(strip \
 62         $(eval SEQUENCE_COUNT :=) \
 63         $(call _sequence-do,$(strip $2))))
 64 
 65 _sequence-do = \
 66     $(if $(word $1, $(SEQUENCE_COUNT)),, \
 67       $(eval SEQUENCE_COUNT += .) \
 68       $(words $(SEQUENCE_COUNT)) \
 69       $(call _sequence-do,$1))
 70 
 71 ################################################################################
 72 # Replace question marks with space in string. This macro needs to be called on
<a name="1" id="anc1"></a><span class="line-modified"> 73 # files from CacheFind in case any of them contains space in their file name,</span>
<span class="line-modified"> 74 # since CacheFind replaces space with ?.</span>
 75 # Param 1 - String to replace in
 76 DecodeSpace = \
 77     $(subst ?,$(SPACE),$(strip $1))
 78 
 79 EncodeSpace = \
 80     $(subst $(SPACE),?,$(strip $1))
 81 
 82 ################################################################################
 83 # Assign a variable only if it is empty
 84 # Param 1 - Variable to assign
 85 # Param 2 - Value to assign
 86 SetIfEmpty = \
 87     $(if $($(strip $1)),,$(eval $(strip $1) := $2))
 88 
 89 ################################################################################
 90 # Take two paths and return the path of the last common directory.
 91 # Ex: /foo/bar/baz, /foo/bar/banan -&gt; /foo/bar
 92 #     foo/bar/baz, /foo/bar -&gt; &lt;empty&gt;
 93 #
 94 # The x prefix is used to preserve the presence of the initial slash
 95 #
 96 # $1 - Path to compare
 97 # $2 - Other path to compare
 98 FindCommonPathPrefix = \
 99     $(patsubst x%,%,$(subst $(SPACE),/,$(strip \
100         $(call FindCommonPathPrefixHelper, \
101             $(subst /,$(SPACE),x$(strip $1)), $(subst /,$(SPACE),x$(strip $2))) \
102     )))
103 
104 FindCommonPathPrefixHelper = \
105     $(if $(call equals, $(firstword $1), $(firstword $2)), \
106       $(firstword $1) \
107       $(call FindCommonPathPrefixHelper, \
108           $(wordlist 2, $(words $1), $1), $(wordlist 2, $(words $2), $2) \
109       ) \
110     )
111 
112 # Convert a partial path into as many directory levels of ../, removing
113 # leading and following /.
114 # Ex: foo/bar/baz/ -&gt; ../../..
115 #     foo/bar -&gt; ../..
116 #     /foo -&gt; ..
117 DirToDotDot = \
118     $(subst $(SPACE),/,$(foreach d, $(subst /,$(SPACE),$1),..))
119 
120 # Computes the relative path from a directory to a file
121 # $1 - File to compute the relative path to
122 # $2 - Directory to compute the relative path from
123 RelativePath = \
124     $(eval $1_prefix := $(call FindCommonPathPrefix, $1, $2)) \
<a name="2" id="anc2"></a><span class="line-modified">125     $(eval $1_dotdots := $(call DirToDotDot, $(patsubst $($(strip $1)_prefix)/%, %, $2))) \</span>

126     $(eval $1_suffix := $(patsubst $($(strip $1)_prefix)/%, %, $1)) \
127     $($(strip $1)_dotdots)/$($(strip $1)_suffix)
128 
129 ################################################################################
130 # Filter out duplicate sub strings while preserving order. Keeps the first occurance.
131 uniq = \
132     $(strip $(if $1,$(firstword $1) $(call uniq,$(filter-out $(firstword $1),$1))))
133 
134 # Returns all whitespace-separated words in $2 where at least one of the
135 # whitespace-separated words in $1 is a substring.
136 containing = \
137     $(strip \
138         $(foreach v,$(strip $2),\
139           $(call uniq,$(foreach p,$(strip $1),$(if $(findstring $p,$v),$v)))))
140 
141 # Returns all whitespace-separated words in $2 where none of the
142 # whitespace-separated words in $1 is a substring.
143 not-containing = \
144     $(strip $(filter-out $(call containing,$1,$2),$2))
145 
146 # Return a list of all string elements that are duplicated in $1.
147 dups = \
148     $(strip $(foreach v, $(sort $1), $(if $(filter-out 1, \
149         $(words $(filter $v, $1))), $v)))
150 
151 # String equals
152 equals = \
153     $(if $(strip $1)$(strip $2),$(strip \
154       $(and $(findstring $(strip $1),$(strip $2)),\
155         $(findstring $(strip $2),$(strip $1)))), \
156       true \
157     )
158 
159 # Remove a whole list of prefixes
160 # $1 - List of prefixes
161 # $2 - List of elements to process
162 remove-prefixes = \
163     $(strip $(if $1,$(patsubst $(firstword $1)%,%,\
164       $(call remove-prefixes,$(filter-out $(firstword $1),$1),$2)),$2))
165 
166 # Convert the string given to upper case, without any $(shell)
167 # Inspired by http://lists.gnu.org/archive/html/help-make/2013-09/msg00009.html
168 uppercase_table := a,A b,B c,C d,D e,E f,F g,G h,H i,I j,J k,K l,L m,M n,N o,O \
169     p,P q,Q r,R s,S t,T u,U v,V w,W x,X y,Y z,Z
170 
171 uppercase_internal = \
172   $(if $(strip $1), $$(subst $(firstword $1), $(call uppercase_internal, \
173       $(wordlist 2, $(words $1), $1), $2)), $2)
174 
175 # Convert a string to upper case. Works only on a-z.
176 # $1 - The string to convert
177 uppercase = \
178   $(strip \
179     $(eval uppercase_result := $(call uppercase_internal, $(uppercase_table), $1)) \
180     $(uppercase_result) \
181   )
182 
183 ################################################################################
184 # Boolean operators.
185 
186 # Return the word &quot;true&quot; if all the boolean words given as argument is &quot;true&quot;,
187 # and returns &quot;false&quot; otherwise. Boolean words must be &quot;true&quot; or &quot;false&quot;. It is
188 # an error to supply a non-boolean word. An empty string is considered &quot;true&quot;.
189 And = \
190   $(strip $(if $(filter-out true false, $1), $(error Non-boolean values: $1)) \
191   $(if $(strip $(filter-out true, $1)), false, true))
192 
193 # Return the word &quot;false&quot; if all the boolean words given as argument is &quot;false&quot;,
194 # and returns &quot;true&quot; otherwise. Boolean words must be &quot;true&quot; or &quot;false&quot;. It is
195 # an error to supply a non-boolean word.  An empty string is considered &quot;false&quot;.
196 Or = \
197   $(strip $(if $(filter-out true false, $1), $(error Non-boolean values: $1)) \
198   $(if $(strip $(filter-out false, $1)), true, false))
199 
200 ################################################################################
201 # Parse a multiple-keyword variable, like FOO=&quot;KEYWORD1=val1;KEYWORD2=val2;...&quot;
202 # These will be converted into a series of variables like FOO_KEYWORD1=val1,
203 # FOO_KEYWORD2=val2, etc. Unknown keywords will cause an error.
204 #
205 # Parameter 1 is the name of the rule, and is also the name of the variable.
206 #
207 # Remaining parameters are named arguments. These include:
208 #   SINGLE_KEYWORDS   A list of valid keywords with single string values
209 #   STRING_KEYWORDS   A list of valid keywords, processed as string. This means
210 #       that &#39;%20&#39; will be replaced by &#39; &#39; to allow for multi-word strings.
211 #
212 ParseKeywordVariable = $(NamedParamsMacroTemplate)
213 define ParseKeywordVariableBody
214   ifneq ($$($1), )
215     # To preserve spaces, substitute them with a hopefully unique pattern
216     # before splitting and then re-substitute spaces back.
217     $1_MANGLED := $$(subst $$(SPACE),||||,$$($1))
218     $$(foreach mangled_part, $$(subst ;, , $$($1_MANGLED)), \
219       $$(eval mangled_part_eval := $$(call DoubleDollar, $$(mangled_part))) \
220       $$(eval part := $$$$(subst ||||,$$$$(SPACE),$$$$(mangled_part_eval))) \
221       $$(eval $1_NO_MATCH := true) \
222       $$(foreach keyword, $$($1_SINGLE_KEYWORDS), \
223         $$(eval keyword_eval := $$(call DoubleDollar, $$(keyword))) \
224         $$(if $$(filter $$(keyword)=%, $$(part)), \
225           $$(eval $(strip $1)_$$$$(keyword_eval) := $$$$(strip $$$$(patsubst $$$$(keyword_eval)=%, %, $$$$(part)))) \
226           $$(eval $1_NO_MATCH := ) \
227         ) \
228       ) \
229       $$(foreach keyword, $$($1_STRING_KEYWORDS), \
230         $$(eval keyword_eval := $$(call DoubleDollar, $$(keyword))) \
231         $$(if $$(filter $$(keyword)=%, $$(part)), \
232           $$(eval $(strip $1)_$$$$(keyword_eval) := $$$$(strip $$$$(subst %20, , $$$$(patsubst $$$$(keyword_eval)=%, %, $$$$(part))))) \
233           $$(eval $1_NO_MATCH := ) \
234         ) \
235       ) \
236       $$(if $$($1_NO_MATCH), \
237         $$(if $$(filter $$(part), $$($1_SINGLE_KEYWORDS) $$($1_STRING_KEYWORDS)), \
238           $$(info Keyword $$(part) for $1 needs to be assigned a value.) \
239         , \
240           $$(info $$(part) is not a valid keyword for $1.) \
241           $$(info Valid keywords: $$($1_SINGLE_KEYWORDS) $$($1_STRING_KEYWORDS).) \
242         ) \
243         $$(error Cannot continue) \
244       ) \
245     )
246   endif
247 endef
248 
249 ################################################################################
250 # ShellQuote
251 #
252 # Quotes a string with single quotes and replaces single quotes with &#39;\&#39;&#39; so
253 # that the contents survives being given to the shell.
254 ShellQuote = \
255     $(SQUOTE)$(subst $(SQUOTE),$(SQUOTE)\$(SQUOTE)$(SQUOTE),$(strip $1))$(SQUOTE)
256 
257 ################################################################################
258 # Find lib dir for module
259 # Param 1 - module name
260 FindLibDirForModule = \
261     $(SUPPORT_OUTPUTDIR)/modules_libs/$(strip $1)
262 
263 ################################################################################
264 # Find executable dir for module
265 # Param 1 - module name
266 FindExecutableDirForModule = \
267     $(SUPPORT_OUTPUTDIR)/modules_cmds/$(strip $1)
268 
269 ################################################################################
270 # Return a string suitable for use after a -classpath or --module-path option. It
271 # will be correct and safe to use on all platforms. Arguments are given as space
272 # separate classpath entries. Safe for multiple nested calls.
273 # param 1 : A space separated list of classpath entries
274 # The surrounding strip is needed to keep additional whitespace out
275 PathList = \
276   &quot;$(subst $(SPACE),$(PATH_SEP),$(strip $(subst $(DQUOTE),,$1)))&quot;
277 
278 ################################################################################
279 # Check if a specified hotspot variant is being built, or at least one of a
280 # list of variants. Will return &#39;true&#39; or &#39;false&#39;.
281 # $1 - the variant to test for
282 check-jvm-variant = \
283   $(strip \
284     $(if $(filter-out $(VALID_JVM_VARIANTS), $1), \
285       $(error Internal error: Invalid variant tested: $1)) \
286     $(if $(filter $1, $(JVM_VARIANTS)), true, false))
287 
288 ################################################################################
289 # Check if our build or target conforms to certain restrictions. This set of
290 # functions all work in similar ways, testing the property that the name
291 # implies, so e.g. isTargetCpu test the CPU of the target system.
292 #
293 # $1 - A property, or a space separated list of properties to test for.
294 #
295 # Returns true if the actual property matches one of the properties in the list,
296 # and false otherwise.
297 #
298 # Examples: $(call isTargetOs, linux solaris) will return true when executed
299 # on either linux or solaris, and false otherwise.
300 # $(call isBuildCpuArch, x86) will return true iff the build CPU Arch is x86.
301 
302 isTargetOs = \
303   $(strip $(if $(filter $(OPENJDK_TARGET_OS), $1), true, false))
304 
305 isTargetOsType = \
306   $(strip $(if $(filter $(OPENJDK_TARGET_OS_TYPE), $1), true, false))
307 
308 isTargetCpu = \
309   $(strip $(if $(filter $(OPENJDK_TARGET_CPU), $1), true, false))
310 
311 isTargetCpuArch = \
312   $(strip $(if $(filter $(OPENJDK_TARGET_CPU_ARCH), $1), true, false))
313 
314 isTargetCpuBits = \
315   $(strip $(if $(filter $(OPENJDK_TARGET_CPU_BITS), $1), true, false))
316 
317 isBuildOs = \
318   $(strip $(if $(filter $(OPENJDK_BUILD_OS), $1), true, false))
319 
320 isBuildOsType = \
321   $(strip $(if $(filter $(OPENJDK_BUILD_OS_TYPE), $1), true, false))
322 
323 isBuildOsEnv = \
324   $(strip $(if $(filter $(OPENJDK_BUILD_OS_ENV), $1), true, false))
325 
326 isBuildCpu = \
327   $(strip $(if $(filter $(OPENJDK_BUILD_CPU), $1), true, false))
328 
329 isBuildCpuArch = \
330   $(strip $(if $(filter $(OPENJDK_BUILD_CPU_ARCH), $1), true, false))
331 
332 ################################################################################
333 # Converts a space separated list to a comma separated list.
334 #
335 # Replacing double-comma with a single comma is to workaround the issue with
336 # some version of make on windows that doesn&#39;t substitute spaces with one comma
337 # properly.
338 CommaList = \
339   $(strip \
340       $(subst $(COMMA)$(COMMA),$(COMMA),$(subst $(SPACE),$(COMMA),$(strip $1))) \
341   )
342 
343 ################################################################################
344 # Converts a space separated list to a colon separated list.
345 #
346 # Replacing double-colon with a single colon is to workaround the issue with
347 # some version of make on windows that doesn&#39;t substitute spaces with one colon
348 # properly.
349 ColonList = \
350   $(strip \
351       $(subst ::,:,$(subst $(SPACE),:,$(strip $1))) \
352   )
353 
354 ################################################################################
355 # Given a list of files, filters out locale specific files for translations
356 # that should be excluded from this build.
357 # $1 - The list of files to filter
358 # $2 - The suffix of the files that should be considered (.java or .properties)
359 FilterExcludedTranslations = \
360   $(strip $(if $(EXCLUDE_TRANSLATIONS), \
361     $(filter-out \
362         $(foreach suffix, $2, \
363           $(addprefix %_, $(addsuffix $(suffix), $(EXCLUDE_TRANSLATIONS))) \
364         ), \
365         $1 \
366     ), \
367     $1 \
368   ))
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff make/common/MakeBase.gmk</title>
    <link rel="stylesheet" href="../../style.css" />
  </head>
<body>
<center><a href="JdkNativeCompilation.gmk.cdiff.html" target="_top">&lt; prev</a> <a href="../../index.html" target="_top">index</a> <a href="Modules.gmk.cdiff.html" target="_top">next &gt;</a></center>    <h2>make/common/MakeBase.gmk</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 62,14 ***</span>
  define NEWLINE
  
  
  endef
  
<span class="line-modified">! # In GNU Make 4.0 and higher, there is a file function for writing to files.</span>
  ifeq (4.0, $(firstword $(sort 4.0 $(MAKE_VERSION))))
    HAS_FILE_FUNCTION := true
    CORRECT_FUNCTION_IN_RECIPE_EVALUATION := true
  endif
  
  
  # For convenience, MakeBase.gmk continues to include these separate files, at
  # least for now.
<span class="line-new-header">--- 62,16 ---</span>
  define NEWLINE
  
  
  endef
  
<span class="line-modified">! # Certain features only work in newer version of GNU Make. The build will still</span>
<span class="line-added">+ # function in 3.81, but will be less performant.</span>
  ifeq (4.0, $(firstword $(sort 4.0 $(MAKE_VERSION))))
    HAS_FILE_FUNCTION := true
    CORRECT_FUNCTION_IN_RECIPE_EVALUATION := true
<span class="line-added">+   RWILDCARD_WORKS := true</span>
  endif
  
  
  # For convenience, MakeBase.gmk continues to include these separate files, at
  # least for now.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 156,29 ***</span>
      # but with a limit of 20 on &lt;ALL NEWER PREREQUISITES&gt;, to avoid cluttering logs too much
      # (and causing a crash on Cygwin).
      SHELL = $$(warning $$(if $$@,Building $$@,Running shell command) $$(if $$&lt;, (from $$&lt;))$$(if $$?, ($$(wordlist 1, 20, $$?) $$(if $$(wordlist 21, 22, $$?), ... [in total $$(words $$?) files]) newer)))$$(SHELL_NO_RECURSE) -x
    endif
  
    # The warn level can never be turned off
<span class="line-modified">!   LogWarn = $$(info $$(strip $$1))</span>
    LOG_WARN :=
    ifneq ($$(findstring $$(LOG_LEVEL), info debug trace),)
<span class="line-modified">!     LogInfo = $$(info $$(strip $$1))</span>
      LOG_INFO :=
    else
      LogInfo =
      LOG_INFO := &gt; /dev/null
    endif
    ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)
<span class="line-modified">!     LogDebug = $$(info $$(strip $$1))</span>
      LOG_DEBUG :=
    else
      LogDebug =
      LOG_DEBUG := &gt; /dev/null
    endif
    ifneq ($$(findstring $$(LOG_LEVEL), trace),)
<span class="line-modified">!     LogTrace = $$(info $$(strip $$1))</span>
      LOG_TRACE :=
    else
      LogTrace =
      LOG_TRACE := &gt; /dev/null
    endif
<span class="line-new-header">--- 158,30 ---</span>
      # but with a limit of 20 on &lt;ALL NEWER PREREQUISITES&gt;, to avoid cluttering logs too much
      # (and causing a crash on Cygwin).
      SHELL = $$(warning $$(if $$@,Building $$@,Running shell command) $$(if $$&lt;, (from $$&lt;))$$(if $$?, ($$(wordlist 1, 20, $$?) $$(if $$(wordlist 21, 22, $$?), ... [in total $$(words $$?) files]) newer)))$$(SHELL_NO_RECURSE) -x
    endif
  
<span class="line-added">+   # The LOG_PREFIX is set for sub recursive calls like buildjdk and bootcycle.</span>
    # The warn level can never be turned off
<span class="line-modified">!   LogWarn = $$(info $(LOG_PREFIX)$$(strip $$1))</span>
    LOG_WARN :=
    ifneq ($$(findstring $$(LOG_LEVEL), info debug trace),)
<span class="line-modified">!     LogInfo = $$(info $(LOG_PREFIX)$$(strip $$1))</span>
      LOG_INFO :=
    else
      LogInfo =
      LOG_INFO := &gt; /dev/null
    endif
    ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)
<span class="line-modified">!     LogDebug = $$(info $(LOG_PREFIX)$$(strip $$1))</span>
      LOG_DEBUG :=
    else
      LogDebug =
      LOG_DEBUG := &gt; /dev/null
    endif
    ifneq ($$(findstring $$(LOG_LEVEL), trace),)
<span class="line-modified">!     LogTrace = $$(info $(LOG_PREFIX)$$(strip $$1))</span>
      LOG_TRACE :=
    else
      LogTrace =
      LOG_TRACE := &gt; /dev/null
    endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 339,78 ***</span>
  	$(LN) -s &#39;$(call DecodeSpace, $&lt;)&#39; &#39;$(call DecodeSpace, $@)&#39;
  endef
  
  ################################################################################
  
<span class="line-modified">! ifneq ($(DISABLE_CACHE_FIND), true)</span>
<span class="line-modified">!   # In Cygwin, finds are very costly, both because of expensive forks and because</span>
<span class="line-modified">!   # of bad file system caching. Find is used extensively in $(shell) commands to</span>
<span class="line-modified">!   # find source files. This makes rerunning make with no or few changes rather</span>
<span class="line-modified">!   # expensive. To speed this up, these two macros are used to cache the results</span>
<span class="line-modified">!   # of simple find commands for reuse.</span>
<span class="line-modified">!   #</span>
<span class="line-modified">!   # Runs a find and stores both the directories where it was run and the results.</span>
<span class="line-modified">!   # This macro can be called multiple times to add to the cache. Only finds files</span>
<span class="line-modified">!   # with no filters.</span>
<span class="line-modified">!   #</span>
<span class="line-modified">!   # Files containing space will get spaces replaced with ? because GNU Make</span>
<span class="line-modified">!   # cannot handle lists of files with space in them. By using ?, make will match</span>
<span class="line-modified">!   # the wildcard to space in many situations so we don&#39;t need to replace back</span>
<span class="line-removed">-   # to space on every use. While not a complete solution it does allow some uses</span>
<span class="line-removed">-   # of CacheFind to function with spaces in file names, including for</span>
<span class="line-removed">-   # SetupCopyFiles.</span>
<span class="line-removed">-   #</span>
<span class="line-removed">-   # Needs to be called with $(eval )</span>
<span class="line-removed">-   #</span>
<span class="line-removed">-   # Even if the performance benifit is negligible on other platforms, keep the</span>
<span class="line-removed">-   # functionality active unless explicitly disabled to exercise it more.</span>
<span class="line-removed">-   #</span>
<span class="line-removed">-   # Initialize FIND_CACHE_DIRS with := to make it a non recursively-expanded variable</span>
<span class="line-removed">-   FIND_CACHE_DIRS :=</span>
<span class="line-removed">-   # Param 1 - Dirs to find in</span>
<span class="line-removed">-   # Param 2 - (optional) specialization. Normally &quot;-a \( ... \)&quot; expression.</span>
<span class="line-removed">-   define FillCacheFind</span>
<span class="line-removed">-     # Filter out already cached dirs. The - is needed when FIND_CACHE_DIRS is empty</span>
<span class="line-removed">-     # since filter out will then return empty.</span>
<span class="line-removed">-     FIND_CACHE_NEW_DIRS := $$(filter-out $$(addsuffix /%,\</span>
<span class="line-removed">-         - $(FIND_CACHE_DIRS)) $(FIND_CACHE_DIRS), $1)</span>
<span class="line-removed">-     ifneq ($$(FIND_CACHE_NEW_DIRS), )</span>
<span class="line-removed">-       # Remove any trailing slash from dirs in the cache dir list</span>
<span class="line-removed">-       FIND_CACHE_DIRS += $$(patsubst %/,%, $$(FIND_CACHE_NEW_DIRS))</span>
<span class="line-removed">-       FIND_CACHE := $$(sort $$(FIND_CACHE) \</span>
<span class="line-removed">-           $$(shell $(FIND) $$(wildcard $$(FIND_CACHE_NEW_DIRS)) \</span>
<span class="line-removed">-               \( -type f -o -type l \) $2 | $(TR) &#39; &#39; &#39;?&#39;))</span>
<span class="line-removed">-     endif</span>
<span class="line-removed">-   endef</span>
  
<span class="line-modified">!   # Mimics find by looking in the cache if all of the directories have been cached.</span>
<span class="line-modified">!   # Otherwise reverts to shell find. This is safe to call on all platforms, even if</span>
<span class="line-modified">!   # cache is deactivated.</span>
<span class="line-modified">!   #</span>
<span class="line-modified">!   # $1 can be either a directory or a file. If it&#39;s a directory, make</span>
<span class="line-modified">!   # sure we have exactly one trailing slash before the wildcard.</span>
<span class="line-modified">!   # The extra - is needed when FIND_CACHE_DIRS is empty but should be harmless.</span>
<span class="line-modified">!   #</span>
<span class="line-modified">!   # Param 1 - Dirs to find in</span>
<span class="line-modified">!   # Param 2 - (optional) specialization. Normally &quot;-a \( ... \)&quot; expression.</span>
<span class="line-modified">!   # Param 3 - (optional) options to find.</span>
<span class="line-modified">!   define CacheFind</span>
<span class="line-modified">!     $(if $(filter-out $(addsuffix /%,- $(FIND_CACHE_DIRS)) $(FIND_CACHE_DIRS),$1), \</span>
<span class="line-modified">!       $(if $(wildcard $1), $(shell $(FIND) $3 $(wildcard $1) \( -type f -o -type l \) $2 \</span>
<span class="line-modified">!           | $(TR) &#39; &#39; &#39;?&#39;)), \</span>
<span class="line-modified">!       $(filter $(addsuffix /%,$(patsubst %/,%,$1)) $1,$(FIND_CACHE)))</span>
<span class="line-modified">!   endef</span>
  
  else
<span class="line-modified">!   # If CacheFind is disabled, just run the find command.</span>
<span class="line-modified">!   # Param 1 - Dirs to find in</span>
<span class="line-modified">!   # Param 2 - (optional) specialization. Normally &quot;-a \( ... \)&quot; expression.</span>
<span class="line-modified">!   define CacheFind</span>
<span class="line-modified">!     $(if $(wildcard $1, \</span>
<span class="line-modified">!       $(shell $(FIND) $(wildcard $1) \( -type f -o -type l \) $2 | $(TR) &#39; &#39; &#39;?&#39;) \</span>
      )
<span class="line-modified">!   endef</span>
  endif
  
  ################################################################################
  # FixPath
  #
<span class="line-new-header">--- 342,120 ---</span>
  	$(LN) -s &#39;$(call DecodeSpace, $&lt;)&#39; &#39;$(call DecodeSpace, $@)&#39;
  endef
  
  ################################################################################
  
<span class="line-modified">! # Recursive wildcard function. Walks down directories recursively and matches</span>
<span class="line-modified">! # files with the search patterns. Patterns use standard file wildcards (* and</span>
<span class="line-modified">! # ?).</span>
<span class="line-modified">! #</span>
<span class="line-modified">! # $1 - Directories to start search in</span>
<span class="line-modified">! # $2 - Search patterns</span>
<span class="line-modified">! rwildcard = \</span>
<span class="line-modified">!     $(strip \</span>
<span class="line-modified">!         $(foreach d, \</span>
<span class="line-modified">!           $(patsubst %/,%,$(sort $(dir $(wildcard $(addsuffix /*/*, $(strip $1)))))), \</span>
<span class="line-modified">!           $(call rwildcard,$d,$2) \</span>
<span class="line-modified">!         ) \</span>
<span class="line-modified">!         $(call DoubleDollar, $(wildcard $(foreach p, $2, $(addsuffix /$(strip $p), $(strip $1))))) \</span>
<span class="line-modified">!     )</span>
  
<span class="line-modified">! # Find non directories using recursive wildcard function. This function may</span>
<span class="line-modified">! # be used directly when a small amount of directories is expected to be</span>
<span class="line-modified">! # searched and caching is not expected to be of use.</span>
<span class="line-modified">! #</span>
<span class="line-modified">! # $1 - Directory to start search in</span>
<span class="line-modified">! # $2 - Optional search patterns, defaults to &#39;*&#39;.</span>
<span class="line-modified">! WildcardFindFiles = \</span>
<span class="line-modified">!     $(sort $(strip \</span>
<span class="line-modified">!         $(eval WildcardFindFiles_result := $(call rwildcard,$(patsubst %/,%,$1),$(if $(strip $2),$2,*))) \</span>
<span class="line-modified">!         $(filter-out $(patsubst %/,%,$(sort $(dir $(WildcardFindFiles_result)))), \</span>
<span class="line-modified">!             $(WildcardFindFiles_result) \</span>
<span class="line-modified">!         ) \</span>
<span class="line-modified">!     ))</span>
<span class="line-modified">! </span>
<span class="line-modified">! # Find non directories using the find utility in the shell. Safe to call for</span>
<span class="line-modified">! # non existing directories, or directories containing wildcards.</span>
<span class="line-modified">! #</span>
<span class="line-added">+ # Files containing space will get spaces replaced with ? because GNU Make</span>
<span class="line-added">+ # cannot handle lists of files with space in them. By using ?, make will match</span>
<span class="line-added">+ # the wildcard to space in many situations so we don&#39;t need to replace back</span>
<span class="line-added">+ # to space on every use. While not a complete solution it does allow some uses</span>
<span class="line-added">+ # of FindFiles to function with spaces in file names, including for</span>
<span class="line-added">+ # SetupCopyFiles. Unfortunately this does not work for WildcardFindFiles so</span>
<span class="line-added">+ # if files with spaces are anticipated, use ShellFindFiles directly.</span>
<span class="line-added">+ #</span>
<span class="line-added">+ # $1 - Directories to start search in.</span>
<span class="line-added">+ # $2 - Optional search patterns, empty means find everything. Patterns use</span>
<span class="line-added">+ #      standard file wildcards (* and ?) and should not be quoted.</span>
<span class="line-added">+ # $3 - Optional options to find.</span>
<span class="line-added">+ ShellFindFiles = \</span>
<span class="line-added">+     $(if $(wildcard $1), \</span>
<span class="line-added">+       $(sort \</span>
<span class="line-added">+           $(shell $(FIND) $3 $(patsubst %/,%,$(wildcard $1)) \( -type f -o -type l \) \</span>
<span class="line-added">+               $(if $(strip $2), -a \( -name &quot;$(firstword $2)&quot; \</span>
<span class="line-added">+               $(foreach p, $(filter-out $(firstword $2), $2), -o -name &quot;$(p)&quot;) \)) \</span>
<span class="line-added">+               | $(TR) &#39; &#39; &#39;?&#39; \</span>
<span class="line-added">+           ) \</span>
<span class="line-added">+       ) \</span>
<span class="line-added">+     )</span>
  
<span class="line-added">+ # Find non directories using the method most likely to work best for the</span>
<span class="line-added">+ # current build host</span>
<span class="line-added">+ #</span>
<span class="line-added">+ # $1 - Directory to start search in</span>
<span class="line-added">+ # $2 - Optional search patterns, defaults to &#39;*&#39;.</span>
<span class="line-added">+ ifeq ($(OPENJDK_BUILD_OS)-$(RWILDCARD_WORKS), windows-true)</span>
<span class="line-added">+   DirectFindFiles = $(WildcardFindFiles)</span>
  else
<span class="line-modified">!   DirectFindFiles = $(ShellFindFiles)</span>
<span class="line-modified">! endif</span>
<span class="line-modified">! </span>
<span class="line-modified">! # Finds files using a cache that is populated by FillFindCache below. If any of</span>
<span class="line-modified">! # the directories given have not been cached, DirectFindFiles is used for</span>
<span class="line-modified">! # everything. Caching is especially useful in Cygwin, where file finds are very</span>
<span class="line-added">+ # costly.</span>
<span class="line-added">+ #</span>
<span class="line-added">+ # $1 - Directories to start search in.</span>
<span class="line-added">+ # $2 - Optional search patterns. If used, no caching is done.</span>
<span class="line-added">+ CacheFindFiles_CACHED_DIRS :=</span>
<span class="line-added">+ CacheFindFiles_CACHED_FILES :=</span>
<span class="line-added">+ CacheFindFiles = \</span>
<span class="line-added">+     $(if $2, \</span>
<span class="line-added">+       $(call DirectFindFiles, $1, $2) \</span>
<span class="line-added">+     , \</span>
<span class="line-added">+       $(if $(filter-out $(addsuffix /%, $(CacheFindFiles_CACHED_DIRS)) \</span>
<span class="line-added">+           $(CacheFindFiles_CACHED_DIRS), $1), \</span>
<span class="line-added">+         $(call DirectFindFiles, $1) \</span>
<span class="line-added">+       , \</span>
<span class="line-added">+         $(filter $(addsuffix /%,$(patsubst %/,%,$1)) $1,$(CacheFindFiles_CACHED_FILES)) \</span>
<span class="line-added">+       ) \</span>
      )
<span class="line-modified">! </span>
<span class="line-added">+ # Explicitly adds files to the find cache used by CacheFindFiles.</span>
<span class="line-added">+ #</span>
<span class="line-added">+ # $1 - Directories to start search in</span>
<span class="line-added">+ FillFindCache = \</span>
<span class="line-added">+     $(eval CacheFindFiles_NEW_DIRS := $$(filter-out $$(addsuffix /%,\</span>
<span class="line-added">+         $$(CacheFindFiles_CACHED_DIRS)) $$(CacheFindFiles_CACHED_DIRS), $1)) \</span>
<span class="line-added">+     $(if $(CacheFindFiles_NEW_DIRS), \</span>
<span class="line-added">+       $(eval CacheFindFiles_CACHED_DIRS += $$(patsubst %/,%,$$(CacheFindFiles_NEW_DIRS))) \</span>
<span class="line-added">+       $(eval CacheFindFiles_CACHED_FILES := $$(sort $$(CacheFindFiles_CACHED_FILES) \</span>
<span class="line-added">+           $$(call DirectFindFiles, $$(CacheFindFiles_NEW_DIRS)))) \</span>
<span class="line-added">+     )</span>
<span class="line-added">+ </span>
<span class="line-added">+ # Findfiles is the default macro that should be used to find files in the file</span>
<span class="line-added">+ # system. This function does not always support files with spaces in the names.</span>
<span class="line-added">+ # If files with spaces are anticipated, use ShellFindFiles directly.</span>
<span class="line-added">+ #</span>
<span class="line-added">+ # $1 - Directories to start search in.</span>
<span class="line-added">+ # $2 - Optional search patterns, empty means find everything. Patterns use</span>
<span class="line-added">+ #      standard file wildcards (* and ?) and should not be quoted.</span>
<span class="line-added">+ ifeq ($(DISABLE_CACHE_FIND), true)</span>
<span class="line-added">+   FindFiles = $(DirectFindFiles)</span>
<span class="line-added">+ else</span>
<span class="line-added">+   FindFiles = $(CacheFindFiles)</span>
  endif
  
  ################################################################################
  # FixPath
  #
</pre>
<hr />
<pre>
<span class="line-old-header">*** 425,10 ***</span>
<span class="line-new-header">--- 470,26 ---</span>
  else
    FixPath = \
        $1
  endif
  
<span class="line-added">+ ################################################################################</span>
<span class="line-added">+ # FixPathList</span>
<span class="line-added">+ #</span>
<span class="line-added">+ # On Windows, converts a cygwin/unix style path list (colon-separated) into</span>
<span class="line-added">+ # the native format (mixed mode, semicolon-separated). On other platforms,</span>
<span class="line-added">+ # return the path list unchanged.</span>
<span class="line-added">+ ################################################################################</span>
<span class="line-added">+ ifeq ($(call isTargetOs, windows), true)</span>
<span class="line-added">+   FixPathList = \</span>
<span class="line-added">+       $(subst @,$(SPACE),$(subst $(SPACE),;,$(foreach entry,$(subst :,$(SPACE),\</span>
<span class="line-added">+       $(subst $(SPACE),@,$(strip $1))),$(call FixPath, $(entry)))))</span>
<span class="line-added">+ else</span>
<span class="line-added">+   FixPathList = \</span>
<span class="line-added">+       $1</span>
<span class="line-added">+ endif</span>
<span class="line-added">+ </span>
  ################################################################################
  # DependOnVariable
  #
  # This macro takes a variable name and puts the value in a file only if the
  # value has changed since last. The name of the file is returned. This can be
</pre>
<hr />
<pre>
<span class="line-old-header">*** 462,19 ***</span>
  # Always returns the name of the file where the value was printed.
  # Param 1 - Name of variable
  # Param 2 - (optional) name of file to store value in
  DependOnVariableHelper = \
      $(strip \
<span class="line-modified">!         $(eval -include $(call DependOnVariableFileName, $1, $2)) \</span>
          $(if $(call equals, $(strip $($1)), $(strip $($1_old))),,\
<span class="line-modified">!           $(call MakeDir, $(dir $(call DependOnVariableFileName, $1, $2))) \</span>
            $(if $(findstring $(LOG_LEVEL), trace), \
                $(info NewVariable $1: &gt;$(strip $($1))&lt;) \
                $(info OldVariable $1: &gt;$(strip $($1_old))&lt;)) \
            $(call WriteFile, $1_old:=$(call DoubleDollar,$(call EscapeHash,$($1))), \
<span class="line-modified">!               $(call DependOnVariableFileName, $1, $2))) \</span>
<span class="line-modified">!         $(call DependOnVariableFileName, $1, $2) \</span>
      )
  
  # Main macro
  # Param 1 - Name of variable
  # Param 2 - (optional) name of file to store value in
<span class="line-new-header">--- 523,20 ---</span>
  # Always returns the name of the file where the value was printed.
  # Param 1 - Name of variable
  # Param 2 - (optional) name of file to store value in
  DependOnVariableHelper = \
      $(strip \
<span class="line-modified">!         $(eval $1_filename := $(call DependOnVariableFileName, $1, $2)) \</span>
<span class="line-added">+         $(if $(wildcard $($1_filename)), $(eval include $($1_filename))) \</span>
          $(if $(call equals, $(strip $($1)), $(strip $($1_old))),,\
<span class="line-modified">!           $(call MakeDir, $(dir $($1_filename))) \</span>
            $(if $(findstring $(LOG_LEVEL), trace), \
                $(info NewVariable $1: &gt;$(strip $($1))&lt;) \
                $(info OldVariable $1: &gt;$(strip $($1_old))&lt;)) \
            $(call WriteFile, $1_old:=$(call DoubleDollar,$(call EscapeHash,$($1))), \
<span class="line-modified">!               $($1_filename))) \</span>
<span class="line-modified">!         $($1_filename) \</span>
      )
  
  # Main macro
  # Param 1 - Name of variable
  # Param 2 - (optional) name of file to store value in
</pre>
<hr />
<pre>
<span class="line-old-header">*** 501,12 ***</span>
  # not be fully written when the make recipe is done.
  #
  # Param 1 - The path to base the name of the log file / command line file on
  # Param 2 - The command to run
  ExecuteWithLog = \
<span class="line-modified">!   $(call LogCmdlines, Exececuting: [$(strip $2)]) \</span>
<span class="line-modified">!   $(call MakeDir, $(dir $(strip $1))) \</span>
    $(call WriteFile, $2, $(strip $1).cmdline) \
    ( $(RM) $(strip $1).log &amp;&amp; $(strip $2) &gt; &gt;($(TEE) -a $(strip $1).log) 2&gt; &gt;($(TEE) -a $(strip $1).log &gt;&amp;2) || \
        ( exitcode=$(DOLLAR)? &amp;&amp; \
        $(CP) $(strip $1).log $(MAKESUPPORT_OUTPUTDIR)/failure-logs/$(subst /,_,$(patsubst $(OUTPUTDIR)/%,%,$(strip $1))).log &amp;&amp; \
        $(CP) $(strip $1).cmdline $(MAKESUPPORT_OUTPUTDIR)/failure-logs/$(subst /,_,$(patsubst $(OUTPUTDIR)/%,%,$(strip $1))).cmdline &amp;&amp; \
<span class="line-new-header">--- 563,12 ---</span>
  # not be fully written when the make recipe is done.
  #
  # Param 1 - The path to base the name of the log file / command line file on
  # Param 2 - The command to run
  ExecuteWithLog = \
<span class="line-modified">!   $(call LogCmdlines, Executing: [$(strip $2)]) \</span>
<span class="line-modified">!   $(call MakeDir, $(dir $(strip $1)) $(MAKESUPPORT_OUTPUTDIR)/failure-logs) \</span>
    $(call WriteFile, $2, $(strip $1).cmdline) \
    ( $(RM) $(strip $1).log &amp;&amp; $(strip $2) &gt; &gt;($(TEE) -a $(strip $1).log) 2&gt; &gt;($(TEE) -a $(strip $1).log &gt;&amp;2) || \
        ( exitcode=$(DOLLAR)? &amp;&amp; \
        $(CP) $(strip $1).log $(MAKESUPPORT_OUTPUTDIR)/failure-logs/$(subst /,_,$(patsubst $(OUTPUTDIR)/%,%,$(strip $1))).log &amp;&amp; \
        $(CP) $(strip $1).cmdline $(MAKESUPPORT_OUTPUTDIR)/failure-logs/$(subst /,_,$(patsubst $(OUTPUTDIR)/%,%,$(strip $1))).cmdline &amp;&amp; \
</pre>
<center><a href="JdkNativeCompilation.gmk.cdiff.html" target="_top">&lt; prev</a> <a href="../../index.html" target="_top">index</a> <a href="Modules.gmk.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/common/MakeBase.gmk</title>
    <link rel="stylesheet" href="../../style.css" />
  </head>
<body>
<center><a href="JdkNativeCompilation.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../index.html" target="_top">index</a> <a href="Modules.gmk.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/common/MakeBase.gmk</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 47 
 48 # When calling macros, the spaces between arguments are
 49 # often semantically important! Sometimes we need to subst
 50 # spaces and commas, therefore we need the following macros.
 51 X:=
 52 SPACE:=$(X) $(X)
 53 COMMA:=,
 54 DOLLAR:=$$
 55 HASH:=\#
 56 LEFT_PAREN:=(
 57 RIGHT_PAREN:=)
 58 SQUOTE:=&#39;
 59 #&#39;
 60 DQUOTE:=&quot;
 61 #&quot;
 62 define NEWLINE
 63 
 64 
 65 endef
 66 
<span class="line-modified"> 67 # In GNU Make 4.0 and higher, there is a file function for writing to files.</span>

 68 ifeq (4.0, $(firstword $(sort 4.0 $(MAKE_VERSION))))
 69   HAS_FILE_FUNCTION := true
 70   CORRECT_FUNCTION_IN_RECIPE_EVALUATION := true

 71 endif
 72 
 73 
 74 # For convenience, MakeBase.gmk continues to include these separate files, at
 75 # least for now.
 76 
 77 include $(TOPDIR)/make/common/Utils.gmk
 78 include $(TOPDIR)/make/common/MakeIO.gmk
 79 include $(TOPDIR)/make/common/CopyFiles.gmk
 80 
 81 ################################################################################
 82 # Functions for timers
 83 ################################################################################
 84 
 85 # Store the build times in this directory.
 86 BUILDTIMESDIR=$(OUTPUTDIR)/make-support/build-times
 87 
 88 # Record starting time for build of a sub repository.
 89 define RecordStartTime
 90 	$(DATE) &#39;+%Y %m %d %H %M %S&#39; | $(NAWK) &#39;{ print $$1,$$2,$$3,$$4,$$5,$$6,($$4*3600+$$5*60+$$6) }&#39; &gt; $(BUILDTIMESDIR)/build_time_start_$(strip $1) &amp;&amp; \
</pre>
<hr />
<pre>
141       SHELL :=  $$(BASH) $$(TOPDIR)/make/scripts/shell-profiler.sh \
142                 gnutime $$(TIME) \
143                 $$(OUTPUTDIR)/build-profile.log $$(SHELL)
144     else ifneq ($$(FLOCK), )
145       SHELL :=  $$(BASH) $$(TOPDIR)/make/scripts/shell-profiler.sh \
146                 flock $$(FLOCK) \
147                 $$(OUTPUTDIR)/build-profile.log $$(SHELL)
148     endif
149   endif
150 
151   ifeq ($$(LOG_LEVEL), trace)
152     SHELL_NO_RECURSE := $$(SHELL)
153     # Shell redefinition trick inspired by http://www.cmcrossroads.com/ask-mr-make/6535-tracing-rule-execution-in-gnu-make
154     # For each target executed, will print
155     # Building &lt;TARGET&gt; (from &lt;FIRST PREREQUISITE&gt;) (&lt;ALL NEWER PREREQUISITES&gt; newer)
156     # but with a limit of 20 on &lt;ALL NEWER PREREQUISITES&gt;, to avoid cluttering logs too much
157     # (and causing a crash on Cygwin).
158     SHELL = $$(warning $$(if $$@,Building $$@,Running shell command) $$(if $$&lt;, (from $$&lt;))$$(if $$?, ($$(wordlist 1, 20, $$?) $$(if $$(wordlist 21, 22, $$?), ... [in total $$(words $$?) files]) newer)))$$(SHELL_NO_RECURSE) -x
159   endif
160 

161   # The warn level can never be turned off
<span class="line-modified">162   LogWarn = $$(info $$(strip $$1))</span>
163   LOG_WARN :=
164   ifneq ($$(findstring $$(LOG_LEVEL), info debug trace),)
<span class="line-modified">165     LogInfo = $$(info $$(strip $$1))</span>
166     LOG_INFO :=
167   else
168     LogInfo =
169     LOG_INFO := &gt; /dev/null
170   endif
171   ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)
<span class="line-modified">172     LogDebug = $$(info $$(strip $$1))</span>
173     LOG_DEBUG :=
174   else
175     LogDebug =
176     LOG_DEBUG := &gt; /dev/null
177   endif
178   ifneq ($$(findstring $$(LOG_LEVEL), trace),)
<span class="line-modified">179     LogTrace = $$(info $$(strip $$1))</span>
180     LOG_TRACE :=
181   else
182     LogTrace =
183     LOG_TRACE := &gt; /dev/null
184   endif
185 endef
186 
187 # Make sure logging is setup for everyone that includes MakeBase.gmk.
188 $(eval $(call SetupLogging))
189 
190 ################################################################################
191 
192 MAX_PARAMS := 36
193 PARAM_SEQUENCE := $(call sequence, 2, $(MAX_PARAMS))
194 
195 # Template for creating a macro taking named parameters. To use it, assign the
196 # template to a variable with the name you want for your macro, using &#39;=&#39;
197 # assignment. Then define a macro body with the suffix &quot;Body&quot;. The Body macro
198 # should take 1 parameter which should be a unique string for that invocation
199 # of the macro.
</pre>
<hr />
<pre>
324 
325 ################################################################################
326 # link-file-* works similarly to install-file but creates a symlink instead.
327 # There are two versions, either creating a relative or an absolute link. Be
328 # careful when using this on Windows since the symlink created is only valid in
329 # the unix emulation environment.
330 define link-file-relative
331 	$(call MakeTargetDir)
332 	$(RM) &#39;$(call DecodeSpace, $@)&#39;
333 	$(LN) -s &#39;$(call DecodeSpace, $(call RelativePath, $&lt;, $(@D)))&#39; &#39;$(call DecodeSpace, $@)&#39;
334 endef
335 
336 define link-file-absolute
337 	$(call MakeTargetDir)
338 	$(RM) &#39;$(call DecodeSpace, $@)&#39;
339 	$(LN) -s &#39;$(call DecodeSpace, $&lt;)&#39; &#39;$(call DecodeSpace, $@)&#39;
340 endef
341 
342 ################################################################################
343 
<span class="line-modified">344 ifneq ($(DISABLE_CACHE_FIND), true)</span>
<span class="line-modified">345   # In Cygwin, finds are very costly, both because of expensive forks and because</span>
<span class="line-modified">346   # of bad file system caching. Find is used extensively in $(shell) commands to</span>
<span class="line-modified">347   # find source files. This makes rerunning make with no or few changes rather</span>
<span class="line-modified">348   # expensive. To speed this up, these two macros are used to cache the results</span>
<span class="line-modified">349   # of simple find commands for reuse.</span>
<span class="line-modified">350   #</span>
<span class="line-modified">351   # Runs a find and stores both the directories where it was run and the results.</span>
<span class="line-modified">352   # This macro can be called multiple times to add to the cache. Only finds files</span>
<span class="line-modified">353   # with no filters.</span>
<span class="line-modified">354   #</span>
<span class="line-modified">355   # Files containing space will get spaces replaced with ? because GNU Make</span>
<span class="line-modified">356   # cannot handle lists of files with space in them. By using ?, make will match</span>
<span class="line-modified">357   # the wildcard to space in many situations so we don&#39;t need to replace back</span>
<span class="line-removed">358   # to space on every use. While not a complete solution it does allow some uses</span>
<span class="line-removed">359   # of CacheFind to function with spaces in file names, including for</span>
<span class="line-removed">360   # SetupCopyFiles.</span>
<span class="line-removed">361   #</span>
<span class="line-removed">362   # Needs to be called with $(eval )</span>
<span class="line-removed">363   #</span>
<span class="line-removed">364   # Even if the performance benifit is negligible on other platforms, keep the</span>
<span class="line-removed">365   # functionality active unless explicitly disabled to exercise it more.</span>
<span class="line-removed">366   #</span>
<span class="line-removed">367   # Initialize FIND_CACHE_DIRS with := to make it a non recursively-expanded variable</span>
<span class="line-removed">368   FIND_CACHE_DIRS :=</span>
<span class="line-removed">369   # Param 1 - Dirs to find in</span>
<span class="line-removed">370   # Param 2 - (optional) specialization. Normally &quot;-a \( ... \)&quot; expression.</span>
<span class="line-removed">371   define FillCacheFind</span>
<span class="line-removed">372     # Filter out already cached dirs. The - is needed when FIND_CACHE_DIRS is empty</span>
<span class="line-removed">373     # since filter out will then return empty.</span>
<span class="line-removed">374     FIND_CACHE_NEW_DIRS := $$(filter-out $$(addsuffix /%,\</span>
<span class="line-removed">375         - $(FIND_CACHE_DIRS)) $(FIND_CACHE_DIRS), $1)</span>
<span class="line-removed">376     ifneq ($$(FIND_CACHE_NEW_DIRS), )</span>
<span class="line-removed">377       # Remove any trailing slash from dirs in the cache dir list</span>
<span class="line-removed">378       FIND_CACHE_DIRS += $$(patsubst %/,%, $$(FIND_CACHE_NEW_DIRS))</span>
<span class="line-removed">379       FIND_CACHE := $$(sort $$(FIND_CACHE) \</span>
<span class="line-removed">380           $$(shell $(FIND) $$(wildcard $$(FIND_CACHE_NEW_DIRS)) \</span>
<span class="line-removed">381               \( -type f -o -type l \) $2 | $(TR) &#39; &#39; &#39;?&#39;))</span>
<span class="line-removed">382     endif</span>
<span class="line-removed">383   endef</span>
384 
<span class="line-modified">385   # Mimics find by looking in the cache if all of the directories have been cached.</span>
<span class="line-modified">386   # Otherwise reverts to shell find. This is safe to call on all platforms, even if</span>
<span class="line-modified">387   # cache is deactivated.</span>
<span class="line-modified">388   #</span>
<span class="line-modified">389   # $1 can be either a directory or a file. If it&#39;s a directory, make</span>
<span class="line-modified">390   # sure we have exactly one trailing slash before the wildcard.</span>
<span class="line-modified">391   # The extra - is needed when FIND_CACHE_DIRS is empty but should be harmless.</span>
<span class="line-modified">392   #</span>
<span class="line-modified">393   # Param 1 - Dirs to find in</span>
<span class="line-modified">394   # Param 2 - (optional) specialization. Normally &quot;-a \( ... \)&quot; expression.</span>
<span class="line-modified">395   # Param 3 - (optional) options to find.</span>
<span class="line-modified">396   define CacheFind</span>
<span class="line-modified">397     $(if $(filter-out $(addsuffix /%,- $(FIND_CACHE_DIRS)) $(FIND_CACHE_DIRS),$1), \</span>
<span class="line-modified">398       $(if $(wildcard $1), $(shell $(FIND) $3 $(wildcard $1) \( -type f -o -type l \) $2 \</span>
<span class="line-modified">399           | $(TR) &#39; &#39; &#39;?&#39;)), \</span>
<span class="line-modified">400       $(filter $(addsuffix /%,$(patsubst %/,%,$1)) $1,$(FIND_CACHE)))</span>
<span class="line-modified">401   endef</span>






















402 







403 else
<span class="line-modified">404   # If CacheFind is disabled, just run the find command.</span>
<span class="line-modified">405   # Param 1 - Dirs to find in</span>
<span class="line-modified">406   # Param 2 - (optional) specialization. Normally &quot;-a \( ... \)&quot; expression.</span>
<span class="line-modified">407   define CacheFind</span>
<span class="line-modified">408     $(if $(wildcard $1, \</span>
<span class="line-modified">409       $(shell $(FIND) $(wildcard $1) \( -type f -o -type l \) $2 | $(TR) &#39; &#39; &#39;?&#39;) \</span>
















410     )
<span class="line-modified">411   endef</span>























412 endif
413 
414 ################################################################################
415 # FixPath
416 #
417 # On Windows, converts a path from cygwin/unix style (e.g. /bin/foo) into
418 # &quot;mixed mode&quot; (e.g. c:/cygwin/bin/foo). On other platforms, return the path
419 # unchanged.
420 # This is normally not needed since we use the FIXPATH prefix for command lines,
421 # but might be needed in certain circumstances.
422 ifeq ($(call isTargetOs, windows), true)
423   FixPath = \
424       $(shell $(CYGPATH) -m $1)
425 else
426   FixPath = \
427       $1
428 endif
429 
















430 ################################################################################
431 # DependOnVariable
432 #
433 # This macro takes a variable name and puts the value in a file only if the
434 # value has changed since last. The name of the file is returned. This can be
435 # used to create rule dependencies on make variable values. The following
436 # example would get rebuilt if the value of SOME_VAR was changed:
437 #
438 # path/to/some-file: $(call DependOnVariable, SOME_VAR)
439 #         echo $(SOME_VAR) &gt; $@
440 #
441 # Note that leading and trailing white space in the value is ignored.
442 #
443 
444 # Defines the sub directory structure to store variable value file in
445 DependOnVariableDirName = \
446     $(strip $(addsuffix $(if $(MODULE),/$(MODULE)), \
447         $(subst $(TOPDIR)/,, $(if $(filter /%, $(firstword $(MAKEFILE_LIST))), \
448           $(firstword $(MAKEFILE_LIST)), \
449           $(CURDIR)/$(firstword $(MAKEFILE_LIST))))))
450 
451 # Defines the name of the file to store variable value in. Generates a name
452 # unless parameter 2 is given.
453 # Param 1 - Name of variable
454 # Param 2 - (optional) name of file to store value in
455 DependOnVariableFileName = \
456     $(strip $(if $(strip $2), $2, \
457       $(MAKESUPPORT_OUTPUTDIR)/vardeps/$(DependOnVariableDirName)/$(strip $1).vardeps))
458 
459 # Does the actual work with parameters stripped.
460 # If the file exists AND the contents is the same as the variable, do nothing
461 # else print a new file.
462 # Always returns the name of the file where the value was printed.
463 # Param 1 - Name of variable
464 # Param 2 - (optional) name of file to store value in
465 DependOnVariableHelper = \
466     $(strip \
<span class="line-modified">467         $(eval -include $(call DependOnVariableFileName, $1, $2)) \</span>

468         $(if $(call equals, $(strip $($1)), $(strip $($1_old))),,\
<span class="line-modified">469           $(call MakeDir, $(dir $(call DependOnVariableFileName, $1, $2))) \</span>
470           $(if $(findstring $(LOG_LEVEL), trace), \
471               $(info NewVariable $1: &gt;$(strip $($1))&lt;) \
472               $(info OldVariable $1: &gt;$(strip $($1_old))&lt;)) \
473           $(call WriteFile, $1_old:=$(call DoubleDollar,$(call EscapeHash,$($1))), \
<span class="line-modified">474               $(call DependOnVariableFileName, $1, $2))) \</span>
<span class="line-modified">475         $(call DependOnVariableFileName, $1, $2) \</span>
476     )
477 
478 # Main macro
479 # Param 1 - Name of variable
480 # Param 2 - (optional) name of file to store value in
481 DependOnVariable = \
482     $(call DependOnVariableHelper,$(strip $1),$(strip $2))
483 
484 # LogCmdlines is only intended to be used by ExecuteWithLog
485 ifeq ($(LOG_CMDLINES), true)
486   LogCmdlines = $(info $(strip $1))
487 else
488   LogCmdlines =
489 endif
490 
491 ################################################################################
492 # ExecuteWithLog will run a command and log the output appropriately. This is
493 # meant to be used by commands that do &quot;real&quot; work, like a compilation.
494 # The output is stored in a specified log file, which is displayed at the end
495 # of the build in case of failure. The  command line itself is stored in a file,
496 # and also logged to stdout if the LOG=cmdlines option has been given.
497 #
498 # NOTE: If the command redirects stdout, the caller needs to wrap it in a
499 # subshell (by adding parentheses around it), otherwise the redirect to the
500 # subshell tee process will create a race condition where the target file may
501 # not be fully written when the make recipe is done.
502 #
503 # Param 1 - The path to base the name of the log file / command line file on
504 # Param 2 - The command to run
505 ExecuteWithLog = \
<span class="line-modified">506   $(call LogCmdlines, Exececuting: [$(strip $2)]) \</span>
<span class="line-modified">507   $(call MakeDir, $(dir $(strip $1))) \</span>
508   $(call WriteFile, $2, $(strip $1).cmdline) \
509   ( $(RM) $(strip $1).log &amp;&amp; $(strip $2) &gt; &gt;($(TEE) -a $(strip $1).log) 2&gt; &gt;($(TEE) -a $(strip $1).log &gt;&amp;2) || \
510       ( exitcode=$(DOLLAR)? &amp;&amp; \
511       $(CP) $(strip $1).log $(MAKESUPPORT_OUTPUTDIR)/failure-logs/$(subst /,_,$(patsubst $(OUTPUTDIR)/%,%,$(strip $1))).log &amp;&amp; \
512       $(CP) $(strip $1).cmdline $(MAKESUPPORT_OUTPUTDIR)/failure-logs/$(subst /,_,$(patsubst $(OUTPUTDIR)/%,%,$(strip $1))).cmdline &amp;&amp; \
513       exit $(DOLLAR)exitcode ) )
514 
515 ################################################################################
516 
517 # Hook to include the corresponding custom file, if present.
518 $(eval $(call IncludeCustomExtension, common/MakeBase.gmk))
519 
520 endif # _MAKEBASE_GMK
</pre>
</td>
<td>
<hr />
<pre>
 47 
 48 # When calling macros, the spaces between arguments are
 49 # often semantically important! Sometimes we need to subst
 50 # spaces and commas, therefore we need the following macros.
 51 X:=
 52 SPACE:=$(X) $(X)
 53 COMMA:=,
 54 DOLLAR:=$$
 55 HASH:=\#
 56 LEFT_PAREN:=(
 57 RIGHT_PAREN:=)
 58 SQUOTE:=&#39;
 59 #&#39;
 60 DQUOTE:=&quot;
 61 #&quot;
 62 define NEWLINE
 63 
 64 
 65 endef
 66 
<span class="line-modified"> 67 # Certain features only work in newer version of GNU Make. The build will still</span>
<span class="line-added"> 68 # function in 3.81, but will be less performant.</span>
 69 ifeq (4.0, $(firstword $(sort 4.0 $(MAKE_VERSION))))
 70   HAS_FILE_FUNCTION := true
 71   CORRECT_FUNCTION_IN_RECIPE_EVALUATION := true
<span class="line-added"> 72   RWILDCARD_WORKS := true</span>
 73 endif
 74 
 75 
 76 # For convenience, MakeBase.gmk continues to include these separate files, at
 77 # least for now.
 78 
 79 include $(TOPDIR)/make/common/Utils.gmk
 80 include $(TOPDIR)/make/common/MakeIO.gmk
 81 include $(TOPDIR)/make/common/CopyFiles.gmk
 82 
 83 ################################################################################
 84 # Functions for timers
 85 ################################################################################
 86 
 87 # Store the build times in this directory.
 88 BUILDTIMESDIR=$(OUTPUTDIR)/make-support/build-times
 89 
 90 # Record starting time for build of a sub repository.
 91 define RecordStartTime
 92 	$(DATE) &#39;+%Y %m %d %H %M %S&#39; | $(NAWK) &#39;{ print $$1,$$2,$$3,$$4,$$5,$$6,($$4*3600+$$5*60+$$6) }&#39; &gt; $(BUILDTIMESDIR)/build_time_start_$(strip $1) &amp;&amp; \
</pre>
<hr />
<pre>
143       SHELL :=  $$(BASH) $$(TOPDIR)/make/scripts/shell-profiler.sh \
144                 gnutime $$(TIME) \
145                 $$(OUTPUTDIR)/build-profile.log $$(SHELL)
146     else ifneq ($$(FLOCK), )
147       SHELL :=  $$(BASH) $$(TOPDIR)/make/scripts/shell-profiler.sh \
148                 flock $$(FLOCK) \
149                 $$(OUTPUTDIR)/build-profile.log $$(SHELL)
150     endif
151   endif
152 
153   ifeq ($$(LOG_LEVEL), trace)
154     SHELL_NO_RECURSE := $$(SHELL)
155     # Shell redefinition trick inspired by http://www.cmcrossroads.com/ask-mr-make/6535-tracing-rule-execution-in-gnu-make
156     # For each target executed, will print
157     # Building &lt;TARGET&gt; (from &lt;FIRST PREREQUISITE&gt;) (&lt;ALL NEWER PREREQUISITES&gt; newer)
158     # but with a limit of 20 on &lt;ALL NEWER PREREQUISITES&gt;, to avoid cluttering logs too much
159     # (and causing a crash on Cygwin).
160     SHELL = $$(warning $$(if $$@,Building $$@,Running shell command) $$(if $$&lt;, (from $$&lt;))$$(if $$?, ($$(wordlist 1, 20, $$?) $$(if $$(wordlist 21, 22, $$?), ... [in total $$(words $$?) files]) newer)))$$(SHELL_NO_RECURSE) -x
161   endif
162 
<span class="line-added">163   # The LOG_PREFIX is set for sub recursive calls like buildjdk and bootcycle.</span>
164   # The warn level can never be turned off
<span class="line-modified">165   LogWarn = $$(info $(LOG_PREFIX)$$(strip $$1))</span>
166   LOG_WARN :=
167   ifneq ($$(findstring $$(LOG_LEVEL), info debug trace),)
<span class="line-modified">168     LogInfo = $$(info $(LOG_PREFIX)$$(strip $$1))</span>
169     LOG_INFO :=
170   else
171     LogInfo =
172     LOG_INFO := &gt; /dev/null
173   endif
174   ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)
<span class="line-modified">175     LogDebug = $$(info $(LOG_PREFIX)$$(strip $$1))</span>
176     LOG_DEBUG :=
177   else
178     LogDebug =
179     LOG_DEBUG := &gt; /dev/null
180   endif
181   ifneq ($$(findstring $$(LOG_LEVEL), trace),)
<span class="line-modified">182     LogTrace = $$(info $(LOG_PREFIX)$$(strip $$1))</span>
183     LOG_TRACE :=
184   else
185     LogTrace =
186     LOG_TRACE := &gt; /dev/null
187   endif
188 endef
189 
190 # Make sure logging is setup for everyone that includes MakeBase.gmk.
191 $(eval $(call SetupLogging))
192 
193 ################################################################################
194 
195 MAX_PARAMS := 36
196 PARAM_SEQUENCE := $(call sequence, 2, $(MAX_PARAMS))
197 
198 # Template for creating a macro taking named parameters. To use it, assign the
199 # template to a variable with the name you want for your macro, using &#39;=&#39;
200 # assignment. Then define a macro body with the suffix &quot;Body&quot;. The Body macro
201 # should take 1 parameter which should be a unique string for that invocation
202 # of the macro.
</pre>
<hr />
<pre>
327 
328 ################################################################################
329 # link-file-* works similarly to install-file but creates a symlink instead.
330 # There are two versions, either creating a relative or an absolute link. Be
331 # careful when using this on Windows since the symlink created is only valid in
332 # the unix emulation environment.
333 define link-file-relative
334 	$(call MakeTargetDir)
335 	$(RM) &#39;$(call DecodeSpace, $@)&#39;
336 	$(LN) -s &#39;$(call DecodeSpace, $(call RelativePath, $&lt;, $(@D)))&#39; &#39;$(call DecodeSpace, $@)&#39;
337 endef
338 
339 define link-file-absolute
340 	$(call MakeTargetDir)
341 	$(RM) &#39;$(call DecodeSpace, $@)&#39;
342 	$(LN) -s &#39;$(call DecodeSpace, $&lt;)&#39; &#39;$(call DecodeSpace, $@)&#39;
343 endef
344 
345 ################################################################################
346 
<span class="line-modified">347 # Recursive wildcard function. Walks down directories recursively and matches</span>
<span class="line-modified">348 # files with the search patterns. Patterns use standard file wildcards (* and</span>
<span class="line-modified">349 # ?).</span>
<span class="line-modified">350 #</span>
<span class="line-modified">351 # $1 - Directories to start search in</span>
<span class="line-modified">352 # $2 - Search patterns</span>
<span class="line-modified">353 rwildcard = \</span>
<span class="line-modified">354     $(strip \</span>
<span class="line-modified">355         $(foreach d, \</span>
<span class="line-modified">356           $(patsubst %/,%,$(sort $(dir $(wildcard $(addsuffix /*/*, $(strip $1)))))), \</span>
<span class="line-modified">357           $(call rwildcard,$d,$2) \</span>
<span class="line-modified">358         ) \</span>
<span class="line-modified">359         $(call DoubleDollar, $(wildcard $(foreach p, $2, $(addsuffix /$(strip $p), $(strip $1))))) \</span>
<span class="line-modified">360     )</span>


























361 
<span class="line-modified">362 # Find non directories using recursive wildcard function. This function may</span>
<span class="line-modified">363 # be used directly when a small amount of directories is expected to be</span>
<span class="line-modified">364 # searched and caching is not expected to be of use.</span>
<span class="line-modified">365 #</span>
<span class="line-modified">366 # $1 - Directory to start search in</span>
<span class="line-modified">367 # $2 - Optional search patterns, defaults to &#39;*&#39;.</span>
<span class="line-modified">368 WildcardFindFiles = \</span>
<span class="line-modified">369     $(sort $(strip \</span>
<span class="line-modified">370         $(eval WildcardFindFiles_result := $(call rwildcard,$(patsubst %/,%,$1),$(if $(strip $2),$2,*))) \</span>
<span class="line-modified">371         $(filter-out $(patsubst %/,%,$(sort $(dir $(WildcardFindFiles_result)))), \</span>
<span class="line-modified">372             $(WildcardFindFiles_result) \</span>
<span class="line-modified">373         ) \</span>
<span class="line-modified">374     ))</span>
<span class="line-modified">375 </span>
<span class="line-modified">376 # Find non directories using the find utility in the shell. Safe to call for</span>
<span class="line-modified">377 # non existing directories, or directories containing wildcards.</span>
<span class="line-modified">378 #</span>
<span class="line-added">379 # Files containing space will get spaces replaced with ? because GNU Make</span>
<span class="line-added">380 # cannot handle lists of files with space in them. By using ?, make will match</span>
<span class="line-added">381 # the wildcard to space in many situations so we don&#39;t need to replace back</span>
<span class="line-added">382 # to space on every use. While not a complete solution it does allow some uses</span>
<span class="line-added">383 # of FindFiles to function with spaces in file names, including for</span>
<span class="line-added">384 # SetupCopyFiles. Unfortunately this does not work for WildcardFindFiles so</span>
<span class="line-added">385 # if files with spaces are anticipated, use ShellFindFiles directly.</span>
<span class="line-added">386 #</span>
<span class="line-added">387 # $1 - Directories to start search in.</span>
<span class="line-added">388 # $2 - Optional search patterns, empty means find everything. Patterns use</span>
<span class="line-added">389 #      standard file wildcards (* and ?) and should not be quoted.</span>
<span class="line-added">390 # $3 - Optional options to find.</span>
<span class="line-added">391 ShellFindFiles = \</span>
<span class="line-added">392     $(if $(wildcard $1), \</span>
<span class="line-added">393       $(sort \</span>
<span class="line-added">394           $(shell $(FIND) $3 $(patsubst %/,%,$(wildcard $1)) \( -type f -o -type l \) \</span>
<span class="line-added">395               $(if $(strip $2), -a \( -name &quot;$(firstword $2)&quot; \</span>
<span class="line-added">396               $(foreach p, $(filter-out $(firstword $2), $2), -o -name &quot;$(p)&quot;) \)) \</span>
<span class="line-added">397               | $(TR) &#39; &#39; &#39;?&#39; \</span>
<span class="line-added">398           ) \</span>
<span class="line-added">399       ) \</span>
<span class="line-added">400     )</span>
401 
<span class="line-added">402 # Find non directories using the method most likely to work best for the</span>
<span class="line-added">403 # current build host</span>
<span class="line-added">404 #</span>
<span class="line-added">405 # $1 - Directory to start search in</span>
<span class="line-added">406 # $2 - Optional search patterns, defaults to &#39;*&#39;.</span>
<span class="line-added">407 ifeq ($(OPENJDK_BUILD_OS)-$(RWILDCARD_WORKS), windows-true)</span>
<span class="line-added">408   DirectFindFiles = $(WildcardFindFiles)</span>
409 else
<span class="line-modified">410   DirectFindFiles = $(ShellFindFiles)</span>
<span class="line-modified">411 endif</span>
<span class="line-modified">412 </span>
<span class="line-modified">413 # Finds files using a cache that is populated by FillFindCache below. If any of</span>
<span class="line-modified">414 # the directories given have not been cached, DirectFindFiles is used for</span>
<span class="line-modified">415 # everything. Caching is especially useful in Cygwin, where file finds are very</span>
<span class="line-added">416 # costly.</span>
<span class="line-added">417 #</span>
<span class="line-added">418 # $1 - Directories to start search in.</span>
<span class="line-added">419 # $2 - Optional search patterns. If used, no caching is done.</span>
<span class="line-added">420 CacheFindFiles_CACHED_DIRS :=</span>
<span class="line-added">421 CacheFindFiles_CACHED_FILES :=</span>
<span class="line-added">422 CacheFindFiles = \</span>
<span class="line-added">423     $(if $2, \</span>
<span class="line-added">424       $(call DirectFindFiles, $1, $2) \</span>
<span class="line-added">425     , \</span>
<span class="line-added">426       $(if $(filter-out $(addsuffix /%, $(CacheFindFiles_CACHED_DIRS)) \</span>
<span class="line-added">427           $(CacheFindFiles_CACHED_DIRS), $1), \</span>
<span class="line-added">428         $(call DirectFindFiles, $1) \</span>
<span class="line-added">429       , \</span>
<span class="line-added">430         $(filter $(addsuffix /%,$(patsubst %/,%,$1)) $1,$(CacheFindFiles_CACHED_FILES)) \</span>
<span class="line-added">431       ) \</span>
432     )
<span class="line-modified">433 </span>
<span class="line-added">434 # Explicitly adds files to the find cache used by CacheFindFiles.</span>
<span class="line-added">435 #</span>
<span class="line-added">436 # $1 - Directories to start search in</span>
<span class="line-added">437 FillFindCache = \</span>
<span class="line-added">438     $(eval CacheFindFiles_NEW_DIRS := $$(filter-out $$(addsuffix /%,\</span>
<span class="line-added">439         $$(CacheFindFiles_CACHED_DIRS)) $$(CacheFindFiles_CACHED_DIRS), $1)) \</span>
<span class="line-added">440     $(if $(CacheFindFiles_NEW_DIRS), \</span>
<span class="line-added">441       $(eval CacheFindFiles_CACHED_DIRS += $$(patsubst %/,%,$$(CacheFindFiles_NEW_DIRS))) \</span>
<span class="line-added">442       $(eval CacheFindFiles_CACHED_FILES := $$(sort $$(CacheFindFiles_CACHED_FILES) \</span>
<span class="line-added">443           $$(call DirectFindFiles, $$(CacheFindFiles_NEW_DIRS)))) \</span>
<span class="line-added">444     )</span>
<span class="line-added">445 </span>
<span class="line-added">446 # Findfiles is the default macro that should be used to find files in the file</span>
<span class="line-added">447 # system. This function does not always support files with spaces in the names.</span>
<span class="line-added">448 # If files with spaces are anticipated, use ShellFindFiles directly.</span>
<span class="line-added">449 #</span>
<span class="line-added">450 # $1 - Directories to start search in.</span>
<span class="line-added">451 # $2 - Optional search patterns, empty means find everything. Patterns use</span>
<span class="line-added">452 #      standard file wildcards (* and ?) and should not be quoted.</span>
<span class="line-added">453 ifeq ($(DISABLE_CACHE_FIND), true)</span>
<span class="line-added">454   FindFiles = $(DirectFindFiles)</span>
<span class="line-added">455 else</span>
<span class="line-added">456   FindFiles = $(CacheFindFiles)</span>
457 endif
458 
459 ################################################################################
460 # FixPath
461 #
462 # On Windows, converts a path from cygwin/unix style (e.g. /bin/foo) into
463 # &quot;mixed mode&quot; (e.g. c:/cygwin/bin/foo). On other platforms, return the path
464 # unchanged.
465 # This is normally not needed since we use the FIXPATH prefix for command lines,
466 # but might be needed in certain circumstances.
467 ifeq ($(call isTargetOs, windows), true)
468   FixPath = \
469       $(shell $(CYGPATH) -m $1)
470 else
471   FixPath = \
472       $1
473 endif
474 
<span class="line-added">475 ################################################################################</span>
<span class="line-added">476 # FixPathList</span>
<span class="line-added">477 #</span>
<span class="line-added">478 # On Windows, converts a cygwin/unix style path list (colon-separated) into</span>
<span class="line-added">479 # the native format (mixed mode, semicolon-separated). On other platforms,</span>
<span class="line-added">480 # return the path list unchanged.</span>
<span class="line-added">481 ################################################################################</span>
<span class="line-added">482 ifeq ($(call isTargetOs, windows), true)</span>
<span class="line-added">483   FixPathList = \</span>
<span class="line-added">484       $(subst @,$(SPACE),$(subst $(SPACE),;,$(foreach entry,$(subst :,$(SPACE),\</span>
<span class="line-added">485       $(subst $(SPACE),@,$(strip $1))),$(call FixPath, $(entry)))))</span>
<span class="line-added">486 else</span>
<span class="line-added">487   FixPathList = \</span>
<span class="line-added">488       $1</span>
<span class="line-added">489 endif</span>
<span class="line-added">490 </span>
491 ################################################################################
492 # DependOnVariable
493 #
494 # This macro takes a variable name and puts the value in a file only if the
495 # value has changed since last. The name of the file is returned. This can be
496 # used to create rule dependencies on make variable values. The following
497 # example would get rebuilt if the value of SOME_VAR was changed:
498 #
499 # path/to/some-file: $(call DependOnVariable, SOME_VAR)
500 #         echo $(SOME_VAR) &gt; $@
501 #
502 # Note that leading and trailing white space in the value is ignored.
503 #
504 
505 # Defines the sub directory structure to store variable value file in
506 DependOnVariableDirName = \
507     $(strip $(addsuffix $(if $(MODULE),/$(MODULE)), \
508         $(subst $(TOPDIR)/,, $(if $(filter /%, $(firstword $(MAKEFILE_LIST))), \
509           $(firstword $(MAKEFILE_LIST)), \
510           $(CURDIR)/$(firstword $(MAKEFILE_LIST))))))
511 
512 # Defines the name of the file to store variable value in. Generates a name
513 # unless parameter 2 is given.
514 # Param 1 - Name of variable
515 # Param 2 - (optional) name of file to store value in
516 DependOnVariableFileName = \
517     $(strip $(if $(strip $2), $2, \
518       $(MAKESUPPORT_OUTPUTDIR)/vardeps/$(DependOnVariableDirName)/$(strip $1).vardeps))
519 
520 # Does the actual work with parameters stripped.
521 # If the file exists AND the contents is the same as the variable, do nothing
522 # else print a new file.
523 # Always returns the name of the file where the value was printed.
524 # Param 1 - Name of variable
525 # Param 2 - (optional) name of file to store value in
526 DependOnVariableHelper = \
527     $(strip \
<span class="line-modified">528         $(eval $1_filename := $(call DependOnVariableFileName, $1, $2)) \</span>
<span class="line-added">529         $(if $(wildcard $($1_filename)), $(eval include $($1_filename))) \</span>
530         $(if $(call equals, $(strip $($1)), $(strip $($1_old))),,\
<span class="line-modified">531           $(call MakeDir, $(dir $($1_filename))) \</span>
532           $(if $(findstring $(LOG_LEVEL), trace), \
533               $(info NewVariable $1: &gt;$(strip $($1))&lt;) \
534               $(info OldVariable $1: &gt;$(strip $($1_old))&lt;)) \
535           $(call WriteFile, $1_old:=$(call DoubleDollar,$(call EscapeHash,$($1))), \
<span class="line-modified">536               $($1_filename))) \</span>
<span class="line-modified">537         $($1_filename) \</span>
538     )
539 
540 # Main macro
541 # Param 1 - Name of variable
542 # Param 2 - (optional) name of file to store value in
543 DependOnVariable = \
544     $(call DependOnVariableHelper,$(strip $1),$(strip $2))
545 
546 # LogCmdlines is only intended to be used by ExecuteWithLog
547 ifeq ($(LOG_CMDLINES), true)
548   LogCmdlines = $(info $(strip $1))
549 else
550   LogCmdlines =
551 endif
552 
553 ################################################################################
554 # ExecuteWithLog will run a command and log the output appropriately. This is
555 # meant to be used by commands that do &quot;real&quot; work, like a compilation.
556 # The output is stored in a specified log file, which is displayed at the end
557 # of the build in case of failure. The  command line itself is stored in a file,
558 # and also logged to stdout if the LOG=cmdlines option has been given.
559 #
560 # NOTE: If the command redirects stdout, the caller needs to wrap it in a
561 # subshell (by adding parentheses around it), otherwise the redirect to the
562 # subshell tee process will create a race condition where the target file may
563 # not be fully written when the make recipe is done.
564 #
565 # Param 1 - The path to base the name of the log file / command line file on
566 # Param 2 - The command to run
567 ExecuteWithLog = \
<span class="line-modified">568   $(call LogCmdlines, Executing: [$(strip $2)]) \</span>
<span class="line-modified">569   $(call MakeDir, $(dir $(strip $1)) $(MAKESUPPORT_OUTPUTDIR)/failure-logs) \</span>
570   $(call WriteFile, $2, $(strip $1).cmdline) \
571   ( $(RM) $(strip $1).log &amp;&amp; $(strip $2) &gt; &gt;($(TEE) -a $(strip $1).log) 2&gt; &gt;($(TEE) -a $(strip $1).log &gt;&amp;2) || \
572       ( exitcode=$(DOLLAR)? &amp;&amp; \
573       $(CP) $(strip $1).log $(MAKESUPPORT_OUTPUTDIR)/failure-logs/$(subst /,_,$(patsubst $(OUTPUTDIR)/%,%,$(strip $1))).log &amp;&amp; \
574       $(CP) $(strip $1).cmdline $(MAKESUPPORT_OUTPUTDIR)/failure-logs/$(subst /,_,$(patsubst $(OUTPUTDIR)/%,%,$(strip $1))).cmdline &amp;&amp; \
575       exit $(DOLLAR)exitcode ) )
576 
577 ################################################################################
578 
579 # Hook to include the corresponding custom file, if present.
580 $(eval $(call IncludeCustomExtension, common/MakeBase.gmk))
581 
582 endif # _MAKEBASE_GMK
</pre>
</td>
</tr>
</table>
<center><a href="JdkNativeCompilation.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../index.html" target="_top">index</a> <a href="Modules.gmk.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
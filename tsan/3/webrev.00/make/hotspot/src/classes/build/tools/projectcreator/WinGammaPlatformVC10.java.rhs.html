<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/hotspot/src/classes/build/tools/projectcreator/WinGammaPlatformVC10.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package build.tools.projectcreator;
 26 
 27 import java.io.File;
 28 import java.io.FileNotFoundException;
 29 import java.io.IOException;
 30 import java.io.PrintWriter;
 31 import java.io.UnsupportedEncodingException;
 32 import java.nio.file.FileSystems;
 33 import java.util.Iterator;
 34 import java.util.LinkedList;
 35 import java.util.UUID;
 36 import java.util.Vector;
 37 
 38 public class WinGammaPlatformVC10 extends WinGammaPlatform {
 39 
 40 
 41    LinkedList &lt;String&gt;filters = new LinkedList&lt;String&gt;();
 42    LinkedList &lt;String[]&gt;filterDeps = new LinkedList&lt;String[]&gt;();
 43 
 44     @Override
 45     protected String getProjectExt() {
 46         return &quot;.vcxproj&quot;;
 47     }
 48 
 49     @Override
 50     public void writeProjectFile(String projectFileName, String projectName,
 51             Vector&lt;BuildConfig&gt; allConfigs) throws IOException {
 52         System.out.println();
 53         System.out.println(&quot;    Writing .vcxproj file: &quot; + projectFileName);
 54 
 55         String projDir = Util.normalize(new File(projectFileName).getParent());
 56 
 57         printWriter = new PrintWriter(projectFileName, &quot;UTF-8&quot;);
 58         printWriter.println(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;);
 59         startTag(&quot;Project&quot;,
 60                 &quot;DefaultTargets&quot;, &quot;Build&quot;,
 61                 &quot;ToolsVersion&quot;, &quot;4.0&quot;,
 62                 &quot;xmlns&quot;, &quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;);
 63         startTag(&quot;ItemGroup&quot;,
 64                 &quot;Label&quot;, &quot;ProjectConfigurations&quot;);
 65         for (BuildConfig cfg : allConfigs) {
 66             startTag(&quot;ProjectConfiguration&quot;,
 67                     &quot;Include&quot;, cfg.get(&quot;Name&quot;));
 68             tagData(&quot;Configuration&quot;, cfg.get(&quot;Id&quot;));
 69             tagData(&quot;Platform&quot;, cfg.get(&quot;PlatformName&quot;));
 70             endTag();
 71         }
 72         endTag();
 73 
 74         startTag(&quot;PropertyGroup&quot;, &quot;Label&quot;, &quot;Globals&quot;);
 75         tagData(&quot;ProjectGuid&quot;, &quot;{8822CB5C-1C41-41C2-8493-9F6E1994338B}&quot;);
 76         tagData(&quot;Keyword&quot;, &quot;MakeFileProj&quot;);
 77         tag(&quot;SccProjectName&quot;);
 78         tag(&quot;SccLocalPath&quot;);
 79         endTag();
 80 
 81         tag(&quot;Import&quot;, &quot;Project&quot;, &quot;$(VCTargetsPath)\\Microsoft.Cpp.Default.props&quot;);
 82 
 83         for (BuildConfig cfg : allConfigs) {
 84             startTag(cfg, &quot;PropertyGroup&quot;, &quot;Label&quot;, &quot;Configuration&quot;);
 85             tagData(&quot;ConfigurationType&quot;, &quot;Makefile&quot;);
 86             tagData(&quot;UseDebugLibraries&quot;, &quot;true&quot;);
 87             endTag();
 88         }
 89 
 90         tag(&quot;Import&quot;, &quot;Project&quot;, &quot;$(VCTargetsPath)\\Microsoft.Cpp.props&quot;);
 91         startTag(&quot;ImportGroup&quot;, &quot;Label&quot;, &quot;ExtensionSettings&quot;);
 92         endTag();
 93         for (BuildConfig cfg : allConfigs) {
 94             startTag(cfg, &quot;ImportGroup&quot;, &quot;Label&quot;, &quot;PropertySheets&quot;);
 95             tag(&quot;Import&quot;,
 96                     &quot;Project&quot;, &quot;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&quot;,
 97                     &quot;Condition&quot;, &quot;exists(&#39;$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props&#39;)&quot;,
 98                     &quot;Label&quot;, &quot;LocalAppDataPlatform&quot;);
 99             endTag();
100         }
101 
102         tag(&quot;PropertyGroup&quot;, &quot;Label&quot;, &quot;UserMacros&quot;);
103 
104         startTag(&quot;PropertyGroup&quot;);
105         tagData(&quot;_ProjectFileVersion&quot;, &quot;10.0.30319.1&quot;);
106         for (BuildConfig cfg : allConfigs) {
107             tagData(cfg, &quot;OutDir&quot;, cfg.get(&quot;OutputDir&quot;) + Util.sep);
108             tagData(cfg, &quot;IntDir&quot;, cfg.get(&quot;OutputDir&quot;) + Util.sep);
109             tagData(cfg, &quot;LinkIncremental&quot;, &quot;false&quot;);
110         }
111         for (BuildConfig cfg : allConfigs) {
112             tagData(cfg, &quot;CodeAnalysisRuleSet&quot;, &quot;AllRules.ruleset&quot;);
113             tag(cfg, &quot;CodeAnalysisRules&quot;);
114             tag(cfg, &quot;CodeAnalysisRuleAssemblies&quot;);
115         }
116         for (BuildConfig cfg : allConfigs) {
117             tagData(cfg, &quot;NMakeBuildCommandLine&quot;, cfg.get(&quot;MakeBinary&quot;) + &quot; -f ../../Makefile hotspot LOG=info&quot;);
118             tagData(cfg, &quot;NMakeReBuildCommandLine&quot;, cfg.get(&quot;MakeBinary&quot;) + &quot; -f ../../Makefile clean-hotspot hotspot LOG=info&quot;);
119             tagData(cfg, &quot;NMakeCleanCommandLine&quot;, cfg.get(&quot;MakeBinary&quot;) + &quot; -f ../../Makefile clean-hotspot LOG=info&quot;);
120             tagData(cfg, &quot;NMakeOutput&quot;, cfg.get(&quot;MakeOutput&quot;) + Util.sep + &quot;jvm.dll&quot;);
121             tagData(cfg, &quot;NMakePreprocessorDefinitions&quot;, Util.join(&quot;;&quot;, cfg.getDefines()));
122             tagData(cfg, &quot;NMakeIncludeSearchPath&quot;, Util.join(&quot;;&quot;, cfg.getIncludes()));
123         }
124         endTag();
125 
126         for (BuildConfig cfg : allConfigs) {
127             startTag(cfg, &quot;ItemDefinitionGroup&quot;);
128             startTag(&quot;ClCompile&quot;);
129             tagV(cfg.getV(&quot;CompilerFlags&quot;));
130             endTag();
131 
132             startTag(&quot;Link&quot;);
133             tagV(cfg.getV(&quot;LinkerFlags&quot;));
134             endTag();
135 
136             endTag();
137         }
138 
139         writeFiles(allConfigs, projDir);
140 
141         tag(&quot;Import&quot;, &quot;Project&quot;, &quot;$(VCTargetsPath)\\Microsoft.Cpp.targets&quot;);
142         startTag(&quot;ImportGroup&quot;, &quot;Label&quot;, &quot;ExtensionTargets&quot;);
143         endTag();
144 
145         endTag();
146         printWriter.close();
147         System.out.println(&quot;    Done writing .vcxproj file.&quot;);
148 
149         writeFilterFile(projectFileName, projectName, allConfigs, projDir);
150         writeUserFile(projectFileName, allConfigs);
151     }
152 
153 
154     private void writeUserFile(String projectFileName, Vector&lt;BuildConfig&gt; allConfigs) throws FileNotFoundException, UnsupportedEncodingException {
155         String userFileName = projectFileName + &quot;.user&quot;;
156         if (new File(userFileName).exists()) {
157             return;
158         }
159         System.out.print(&quot;    Writing .vcxproj.user file: &quot; + userFileName);
160         printWriter = new PrintWriter(userFileName, &quot;UTF-8&quot;);
161 
162         printWriter.println(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;);
163         startTag(&quot;Project&quot;,
164                 &quot;ToolsVersion&quot;, &quot;4.0&quot;,
165                 &quot;xmlns&quot;, &quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;);
166 
167         for (BuildConfig cfg : allConfigs) {
168             startTag(cfg, &quot;PropertyGroup&quot;);
169             tagData(&quot;LocalDebuggerCommand&quot;, cfg.get(&quot;JdkTargetRoot&quot;) + &quot;\\bin\\java.exe&quot;);
170             // Since we run &quot;make hotspot-import&quot;, we get the correct jvm.dll by java.exe.
171             // The &#39;-XX:+PauseAtExit&#39; option
172             // causes the VM to wait for key press before exiting; this
173             // allows any stdout or stderr messages to be seen before
174             // the cmdtool exits.
175             tagData(&quot;LocalDebuggerCommandArguments&quot;,
176                     &quot;-XX:+UnlockDiagnosticVMOptions -XX:+PauseAtExit&quot;);
177             tagData(&quot;LocalDebuggerEnvironment&quot;, &quot;JAVA_HOME=&quot; + cfg.get(&quot;JdkTargetRoot&quot;));
178             endTag();
179         }
180 
181         endTag();
182         printWriter.close();
183         System.out.println(&quot;    Done.&quot;);
184     }
185 
186     public void addFilter(String rPath) {
187        filters.add(rPath);
188     }
189 
190     public void addFilterDependency(String fileLoc, String filter) {
191       filterDeps.add(new String[] {fileLoc, filter});
192     }
193 
194     private void writeFilterFile(String projectFileName, String projectName,
195             Vector&lt;BuildConfig&gt; allConfigs, String base) throws FileNotFoundException, UnsupportedEncodingException {
196         String filterFileName = projectFileName + &quot;.filters&quot;;
197         System.out.print(&quot;    Writing .vcxproj.filters file: &quot; + filterFileName);
198         printWriter = new PrintWriter(filterFileName, &quot;UTF-8&quot;);
199 
200         printWriter.println(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;);
201         startTag(&quot;Project&quot;,
202                 &quot;ToolsVersion&quot;, &quot;4.0&quot;,
203                 &quot;xmlns&quot;, &quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;);
204 
205         startTag(&quot;ItemGroup&quot;);
206         for (String filter : filters) {
207            startTag(&quot;Filter&quot;, &quot;Include&quot;,filter);
208            UUID uuid = UUID.randomUUID();
209            tagData(&quot;UniqueIdentifier&quot;, &quot;{&quot; + uuid.toString() + &quot;}&quot;);
210            endTag();
211         }
212         endTag();
213 
214         //TODO - do I need to split cpp and hpp files?
215 
216         // then all files
217         startTag(&quot;ItemGroup&quot;);
218         for (String[] dep : filterDeps) {
219            String tagName = getFileTagFromSuffix(dep[0]);
220 
221            startTag(tagName, &quot;Include&quot;, dep[0]);
222            tagData(&quot;Filter&quot;, dep[1]);
223            endTag();
224         }
225         endTag();
226 
227         endTag();
228         printWriter.close();
229         System.out.println(&quot;    Done.&quot;);
230     }
231 
232     public String getFileTagFromSuffix(String fileName) {
233        if (fileName.endsWith(&quot;.cpp&quot;)) {
234           return&quot;ClCompile&quot;;
235        } else if (fileName.endsWith(&quot;.c&quot;)) {
236           return &quot;ClCompile&quot;;
237        } else if (fileName.endsWith(&quot;.hpp&quot;)) {
238           return&quot;ClInclude&quot;;
239        } else if (fileName.endsWith(&quot;.h&quot;)) {
240           return &quot;ClInclude&quot;;
241        } else {
242           return&quot;None&quot;;
243        }
244     }
245 
246     void writeFiles(Vector&lt;BuildConfig&gt; allConfigs, String projDir) {
247        // This code assummes there are no config specific includes.
248        startTag(&quot;ItemGroup&quot;);
249 
250        String sourceBase = BuildConfig.getFieldString(null, &quot;SourceBase&quot;);
251 
252        // Use first config for all global absolute includes.
253        BuildConfig baseConfig = allConfigs.firstElement();
254        Vector&lt;String&gt; rv = new Vector&lt;String&gt;();
255 
256        // Then use first config for all relative includes
257        Vector&lt;String&gt; ri = new Vector&lt;String&gt;();
258        baseConfig.collectRelevantVectors(ri, &quot;RelativeSrcInclude&quot;);
259        for (String f : ri) {
260           rv.add(sourceBase + Util.sep + f);
261        }
262 
263        baseConfig.collectRelevantVectors(rv, &quot;AbsoluteSrcInclude&quot;);
264 
265        handleIncludes(rv, allConfigs);
266 
267        endTag();
268     }
269 
270     // Will visit file tree for each include
271     private void handleIncludes(Vector&lt;String&gt; includes, Vector&lt;BuildConfig&gt; allConfigs) {
272        for (String path : includes)  {
273           FileTreeCreatorVC10 ftc = new FileTreeCreatorVC10(FileSystems.getDefault().getPath(path) , allConfigs, this);
274           try {
275              ftc.writeFileTree();
276           } catch (IOException e) {
277              e.printStackTrace();
278           }
279        }
280     }
281 
282     String buildCond(BuildConfig cfg) {
283         return &quot;&#39;$(Configuration)|$(Platform)&#39;==&#39;&quot;+cfg.get(&quot;Name&quot;)+&quot;&#39;&quot;;
284     }
285 
286     void tagV(Vector&lt;String&gt; v) {
287         Iterator&lt;String&gt; i = v.iterator();
288         while(i.hasNext()) {
289             String name = i.next();
290             String data = i.next();
291             tagData(name, data);
292         }
293     }
294 
295     void tagData(BuildConfig cfg, String name, String data) {
296         tagData(name, data, &quot;Condition&quot;, buildCond(cfg));
297     }
298 
299     void tag(BuildConfig cfg, String name, String... attrs) {
300         String[] ss = new String[attrs.length + 2];
301         ss[0] = &quot;Condition&quot;;
302         ss[1] = buildCond(cfg);
303         System.arraycopy(attrs, 0, ss, 2, attrs.length);
304 
305         tag(name, ss);
306     }
307 
308     void startTag(BuildConfig cfg, String name, String... attrs) {
309         String[] ss = new String[attrs.length + 2];
310         ss[0] = &quot;Condition&quot;;
311         ss[1] = buildCond(cfg);
312         System.arraycopy(attrs, 0, ss, 2, attrs.length);
313 
314         startTag(name, ss);
315     }
316 
317 }
318 
319 class CompilerInterfaceVC10 extends CompilerInterface {
320 
321     @Override
322     Vector getBaseCompilerFlags(Vector defines, Vector includes, String outDir) {
323         Vector rv = new Vector();
324 
325         addAttr(rv, &quot;AdditionalIncludeDirectories&quot;, Util.join(&quot;;&quot;, includes));
326         addAttr(rv, &quot;PreprocessorDefinitions&quot;,
327                 Util.join(&quot;;&quot;, defines).replace(&quot;\\\&quot;&quot;, &quot;\&quot;&quot;));
328         addAttr(rv, &quot;PrecompiledHeaderFile&quot;, &quot;precompiled.hpp&quot;);
329         addAttr(rv, &quot;PrecompiledHeaderOutputFile&quot;, outDir+Util.sep+&quot;vm.pch&quot;);
330         addAttr(rv, &quot;AssemblerListingLocation&quot;, outDir);
331         addAttr(rv, &quot;ObjectFileName&quot;, outDir+Util.sep);
332         addAttr(rv, &quot;ProgramDataBaseFileName&quot;, outDir+Util.sep+&quot;jvm.pdb&quot;);
333         // Set /nologo option
334         addAttr(rv, &quot;SuppressStartupBanner&quot;, &quot;true&quot;);
335         // Surpass the default /Tc or /Tp.
336         addAttr(rv, &quot;CompileAs&quot;, &quot;Default&quot;);
337         // Set /W3 option.
338         addAttr(rv, &quot;WarningLevel&quot;, &quot;Level3&quot;);
339         // Set /WX option,
340         addAttr(rv, &quot;TreatWarningAsError&quot;, &quot;true&quot;);
341         // Set /GS option
342         addAttr(rv, &quot;BufferSecurityCheck&quot;, &quot;false&quot;);
343         // Set /Zi option.
344         addAttr(rv, &quot;DebugInformationFormat&quot;, &quot;ProgramDatabase&quot;);
345         // Set /Yu option.
346         addAttr(rv, &quot;PrecompiledHeader&quot;, &quot;Use&quot;);
347         // Set /EHsc- option
348         addAttr(rv, &quot;ExceptionHandling&quot;, &quot;&quot;);
349 
350         addAttr(rv, &quot;MultiProcessorCompilation&quot;, &quot;true&quot;);
351 
352         return rv;
353     }
354 
355     @Override
356     Vector getDebugCompilerFlags(String opt, String platformName) {
357         Vector rv = new Vector();
358 
359         // Set /On option
360         addAttr(rv, &quot;Optimization&quot;, opt);
361         // Set /MD option.
362         addAttr(rv, &quot;RuntimeLibrary&quot;, &quot;MultiThreadedDLL&quot;);
363         // Set /Oy- option
364         addAttr(rv, &quot;OmitFramePointers&quot;, &quot;false&quot;);
365         // Set /homeparams for x64 debug builds
366         if(platformName.equals(&quot;x64&quot;)) {
367             addAttr(rv, &quot;AdditionalOptions&quot;, &quot;/homeparams&quot;);
368         }
369 
370         return rv;
371     }
372 
373     @Override
374     Vector getProductCompilerFlags() {
375         Vector rv = new Vector();
376 
377         // Set /O2 option.
378         addAttr(rv, &quot;Optimization&quot;, &quot;MaxSpeed&quot;);
379         // Set /Oy- option
380         addAttr(rv, &quot;OmitFramePointers&quot;, &quot;false&quot;);
381         // Set /Ob option.  1 is expandOnlyInline
382         addAttr(rv, &quot;InlineFunctionExpansion&quot;, &quot;OnlyExplicitInline&quot;);
383         // Set /GF option.
384         addAttr(rv, &quot;StringPooling&quot;, &quot;true&quot;);
385         // Set /MD option. 2 is rtMultiThreadedDLL
386         addAttr(rv, &quot;RuntimeLibrary&quot;, &quot;MultiThreadedDLL&quot;);
387         // Set /Gy option
388         addAttr(rv, &quot;FunctionLevelLinking&quot;, &quot;true&quot;);
389 
390         return rv;
391     }
392 
393     @Override
394     Vector getBaseLinkerFlags(String outDir, String outDll, String platformName) {
395         Vector rv = new Vector();
396 
397         if(platformName.equals(&quot;Win32&quot;)) {
398             addAttr(rv, &quot;AdditionalOptions&quot;,
399                     &quot;/export:JNI_GetDefaultJavaVMInitArgs &quot; +
400                     &quot;/export:JNI_CreateJavaVM &quot; +
401                     &quot;/export:JVM_FindClassFromBootLoader &quot;+
402                     &quot;/export:JNI_GetCreatedJavaVMs &quot;+
403                     &quot;/export:jio_snprintf /export:jio_printf &quot;+
404                     &quot;/export:jio_fprintf /export:jio_vfprintf &quot;+
405                     &quot;/export:jio_vsnprintf &quot;+
<a name="1" id="anc1"></a>
406                     &quot;/export:JVM_InitAgentProperties&quot;);
407         }
408         addAttr(rv, &quot;AdditionalDependencies&quot;, &quot;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;Wsock32.lib;winmm.lib;psapi.lib;version.lib&quot;);
409         addAttr(rv, &quot;OutputFile&quot;, outDll);
410         addAttr(rv, &quot;SuppressStartupBanner&quot;, &quot;true&quot;);
411         addAttr(rv, &quot;ModuleDefinitionFile&quot;, outDir+Util.sep+&quot;vm.def&quot;);
412         addAttr(rv, &quot;ProgramDatabaseFile&quot;, outDir+Util.sep+&quot;jvm.pdb&quot;);
413         addAttr(rv, &quot;SubSystem&quot;, &quot;Windows&quot;);
414         addAttr(rv, &quot;BaseAddress&quot;, &quot;0x8000000&quot;);
415         addAttr(rv, &quot;ImportLibrary&quot;, outDir+Util.sep+&quot;jvm.lib&quot;);
416 
417         if(platformName.equals(&quot;Win32&quot;)) {
418             addAttr(rv, &quot;TargetMachine&quot;, &quot;MachineX86&quot;);
419         } else {
420             addAttr(rv, &quot;TargetMachine&quot;, &quot;MachineX64&quot;);
421         }
422 
423         // We always want the /DEBUG option to get full symbol information in the pdb files
424         addAttr(rv, &quot;GenerateDebugInformation&quot;, &quot;true&quot;);
425 
426         return rv;
427     }
428 
429     @Override
430     Vector getDebugLinkerFlags() {
431         Vector rv = new Vector();
432 
433         // Empty now that /DEBUG option is used by all configs
434 
435         return rv;
436     }
437 
438     @Override
439     Vector getProductLinkerFlags() {
440         Vector rv = new Vector();
441 
442         // Set /OPT:REF option.
443         addAttr(rv, &quot;OptimizeReferences&quot;, &quot;true&quot;);
444         // Set /OPT:ICF option.
445         addAttr(rv, &quot;EnableCOMDATFolding&quot;, &quot;true&quot;);
446 
447         return rv;
448     }
449 
450     @Override
451     void getAdditionalNonKernelLinkerFlags(Vector rv) {
452         extAttr(rv, &quot;AdditionalOptions&quot;, &quot; /export:AsyncGetCallTrace&quot;);
453     }
454 
455     @Override
456     String getOptFlag() {
457         return &quot;MaxSpeed&quot;;
458     }
459 
460     @Override
461     String getNoOptFlag() {
462         return &quot;Disabled&quot;;
463     }
464 
465     @Override
466     String makeCfgName(String flavourBuild, String platform) {
467         return  flavourBuild + &quot;|&quot; + platform;
468     }
469 
470 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old make/src/classes/build/tools/jfr/GenerateJfrFiles.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 package build.tools.jfr;
  2 
  3 import java.io.BufferedOutputStream;
  4 import java.io.File;
  5 import java.io.FileNotFoundException;
  6 import java.io.FileOutputStream;
  7 import java.io.IOException;
  8 import java.io.PrintStream;
  9 import java.util.ArrayList;
 10 import java.util.HashMap;
 11 import java.util.LinkedHashMap;
 12 import java.util.List;
 13 import java.util.Map;
 14 import java.util.StringJoiner;
 15 import java.util.function.Predicate;
 16 
 17 import javax.xml.XMLConstants;
 18 import javax.xml.parsers.ParserConfigurationException;
 19 import javax.xml.parsers.SAXParser;
 20 import javax.xml.parsers.SAXParserFactory;
 21 import javax.xml.validation.SchemaFactory;
 22 
 23 import org.xml.sax.Attributes;
 24 import org.xml.sax.SAXException;
 25 import org.xml.sax.SAXParseException;
 26 import org.xml.sax.helpers.DefaultHandler;
 27 
 28 public class GenerateJfrFiles {
 29 
 30     public static void main(String... args) throws Exception {
 31         if (args.length != 3) {
 32             System.err.println(&quot;Incorrect number of command line arguments.&quot;);
 33             System.err.println(&quot;Usage:&quot;);
 34             System.err.println(&quot;java GenerateJfrFiles[.java] &lt;path-to-metadata.xml&gt; &lt;path-to-metadata.xsd&gt; &lt;output-directory&gt;&quot;);
 35             System.exit(1);
 36         }
 37         try {
 38             File metadataXml = new File(args[0]);
 39             File metadataSchema = new File(args[1]);
 40             File outputDirectory = new File(args[2]);
 41 
 42             Metadata metadata = new Metadata(metadataXml, metadataSchema);
 43             metadata.verify();
 44             metadata.wireUpTypes();
 45 
 46             printJfrPeriodicHpp(metadata, outputDirectory);
 47             printJfrEventIdsHpp(metadata, outputDirectory);
 48             printJfrEventControlHpp(metadata, outputDirectory);
 49             printJfrTypesHpp(metadata, outputDirectory);
 50             printJfrEventClassesHpp(metadata, outputDirectory);
 51 
 52         } catch (Exception e) {
 53             e.printStackTrace();
 54             System.exit(1);
 55         }
 56     }
 57 
 58     static class XmlType {
 59         final String fieldType;
 60         final String parameterType;
 61         XmlType(String fieldType, String parameterType) {
 62             this.fieldType = fieldType;
 63             this.parameterType = parameterType;
 64         }
 65     }
 66 
 67     static class TypeElement {
 68         List&lt;FieldElement&gt; fields = new ArrayList&lt;&gt;();
 69         String name;
 70         String fieldType;
 71         String parameterType;
 72         boolean supportStruct;
 73     }
 74 
 75     static class Metadata {
 76         final Map&lt;String, TypeElement&gt; types = new LinkedHashMap&lt;&gt;();
 77         final Map&lt;String, XmlType&gt; xmlTypes = new HashMap&lt;&gt;();
 78         Metadata(File metadataXml, File metadataSchema) throws ParserConfigurationException, SAXException, FileNotFoundException, IOException {
 79             SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
 80             SAXParserFactory factory = SAXParserFactory.newInstance();
 81             factory.setSchema(schemaFactory.newSchema(metadataSchema));
 82             SAXParser sp = factory.newSAXParser();
 83             sp.parse(metadataXml, new MetadataHandler(this));
 84         }
 85 
 86         List&lt;EventElement&gt; getEvents() {
 87             return getList(t -&gt; t.getClass() == EventElement.class);
 88         }
 89 
 90         List&lt;TypeElement&gt; getEventsAndStructs() {
 91             return getList(t -&gt; t.getClass() == EventElement.class || t.supportStruct);
 92         }
 93 
 94         List&lt;TypeElement&gt; getTypesAndStructs() {
 95             return getList(t -&gt; t.getClass() == TypeElement.class || t.supportStruct);
 96         }
 97 
 98         @SuppressWarnings(&quot;unchecked&quot;)
 99         &lt;T&gt; List&lt;T&gt; getList(Predicate&lt;? super TypeElement&gt; pred) {
100             List&lt;T&gt; result = new ArrayList&lt;&gt;(types.size());
101             for (TypeElement t : types.values()) {
102                 if (pred.test(t)) {
103                     result.add((T) t);
104                 }
105             }
106             return result;
107         }
108 
109         List&lt;EventElement&gt; getPeriodicEvents() {
110             return getList(t -&gt; t.getClass() == EventElement.class &amp;&amp; ((EventElement) t).periodic);
111         }
112 
113         List&lt;TypeElement&gt; getNonEventsAndNonStructs() {
114             return getList(t -&gt; t.getClass() != EventElement.class &amp;&amp; !t.supportStruct);
115         }
116 
117         List&lt;TypeElement&gt; getTypes() {
118             return getList(t -&gt; t.getClass() == TypeElement.class &amp;&amp; !t.supportStruct);
119         }
120 
121         List&lt;TypeElement&gt; getStructs() {
122             return getList(t -&gt; t.getClass() == TypeElement.class &amp;&amp; t.supportStruct);
123         }
124 
125         void verify()  {
126             for (TypeElement t : types.values()) {
127                 for (FieldElement f : t.fields) {
128                     if (!xmlTypes.containsKey(f.typeName)) { // ignore primitives
129                         if (!types.containsKey(f.typeName)) {
130                             throw new IllegalStateException(&quot;Could not find definition of type &#39;&quot; + f.typeName + &quot;&#39; used by &quot; + t.name + &quot;#&quot; + f.name);
131                         }
132                     }
133                 }
134             }
135         }
136 
137         void wireUpTypes() {
138             for (TypeElement t : types.values()) {
139                 for (FieldElement f : t.fields) {
140                     TypeElement type = types.get(f.typeName);
141                     if (f.struct) {
142                         type.supportStruct = true;
143                     }
144                     f.type = type;
145                 }
146             }
147         }
148     }
149 
150     static class EventElement extends TypeElement {
151         String representation;
152         boolean thread;
153         boolean stackTrace;
154         boolean startTime;
155         boolean periodic;
156         boolean cutoff;
157     }
158 
159     static class FieldElement {
160         final Metadata metadata;
161         TypeElement type;
162         String name;
163         String typeName;
164         boolean struct;
165 
166         FieldElement(Metadata metadata) {
167             this.metadata = metadata;
168         }
169 
170         String getParameterType() {
171             if (struct) {
172                 return &quot;const JfrStruct&quot; + typeName + &quot;&amp;&quot;;
173             }
174             XmlType xmlType = metadata.xmlTypes.get(typeName);
175             if (xmlType != null) {
176                 return xmlType.parameterType;
177             }
178             return type != null ? &quot;u8&quot; : typeName;
179         }
180 
181         String getParameterName() {
182             return struct ? &quot;value&quot; : &quot;new_value&quot;;
183         }
184 
185         String getFieldType() {
186             if (struct) {
187                 return &quot;JfrStruct&quot; + typeName;
188             }
189             XmlType xmlType = metadata.xmlTypes.get(typeName);
190             if (xmlType != null) {
191                 return xmlType.fieldType;
192             }
193             return type != null ? &quot;u8&quot; : typeName;
194         }
195     }
196 
197     static class MetadataHandler extends DefaultHandler {
198         final Metadata metadata;
199         FieldElement currentField;
200         TypeElement currentType;
201         MetadataHandler(Metadata metadata) {
202             this.metadata = metadata;
203         }
204         @Override
205         public void error(SAXParseException e) throws SAXException {
206           throw e;
207         }
208         @Override
209         public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
210             switch (qName) {
211             case &quot;XmlType&quot;:
212                 String name = attributes.getValue(&quot;name&quot;);
213                 String parameterType = attributes.getValue(&quot;parameterType&quot;);
214                 String fieldType = attributes.getValue(&quot;fieldType&quot;);
215                 metadata.xmlTypes.put(name, new XmlType(fieldType, parameterType));
216                 break;
217             case &quot;Type&quot;:
218                 currentType = new TypeElement();
219                 currentType.name = attributes.getValue(&quot;name&quot;);
220                 break;
221             case &quot;Event&quot;:
222                 EventElement eventtType = new EventElement();
223                 eventtType.name = attributes.getValue(&quot;name&quot;);
224                 eventtType.thread = getBoolean(attributes, &quot;thread&quot;, false);
225                 eventtType.stackTrace = getBoolean(attributes, &quot;stackTrace&quot;, false);
226                 eventtType.startTime = getBoolean(attributes, &quot;startTime&quot;, true);
227                 eventtType.periodic = attributes.getValue(&quot;period&quot;) != null;
228                 eventtType.cutoff = getBoolean(attributes, &quot;cutoff&quot;, false);
229                 currentType = eventtType;
230                 break;
231             case &quot;Field&quot;:
232                 currentField = new FieldElement(metadata);
233                 currentField.struct = getBoolean(attributes, &quot;struct&quot;, false);
234                 currentField.name = attributes.getValue(&quot;name&quot;);
235                 currentField.typeName = attributes.getValue(&quot;type&quot;);
236                 break;
237             }
238         }
239 
240         private boolean getBoolean(Attributes attributes, String name, boolean defaultValue) {
241             String value = attributes.getValue(name);
242             return value == null ? defaultValue : Boolean.valueOf(value);
243         }
244 
245         @Override
246         public void endElement(String uri, String localName, String qName) {
247             switch (qName) {
248             case &quot;Type&quot;:
249             case &quot;Event&quot;:
250                 metadata.types.put(currentType.name, currentType);
251                 currentType = null;
252                 break;
253             case &quot;Field&quot;:
254                 currentType.fields.add(currentField);
255                 currentField = null;
256                 break;
257             }
258         }
259     }
260 
261     static class Printer implements AutoCloseable {
262         final PrintStream out;
263         Printer(File outputDirectory, String filename) throws FileNotFoundException {
264             out = new PrintStream(new BufferedOutputStream(new FileOutputStream(new File(outputDirectory, filename))));
265             write(&quot;/* AUTOMATICALLY GENERATED FILE - DO NOT EDIT */&quot;);
266             write(&quot;&quot;);
267         }
268 
269         void write(String text) {
270             out.print(text);
271             out.print(&quot;\n&quot;); // Don&#39;t use Windows line endings
272         }
273 
274         @Override
275         public void close() throws Exception {
276             out.close();
277         }
278     }
279 
280     private static void printJfrPeriodicHpp(Metadata metadata, File outputDirectory) throws Exception {
281         try (Printer out = new Printer(outputDirectory, &quot;jfrPeriodic.hpp&quot;)) {
282             out.write(&quot;#ifndef JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
283             out.write(&quot;#define JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
284             out.write(&quot;&quot;);
285             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
286             out.write(&quot;#if INCLUDE_JFR&quot;);
287             out.write(&quot;#include \&quot;jfrfiles/jfrEventIds.hpp\&quot;&quot;);
288             out.write(&quot;#include \&quot;memory/allocation.hpp\&quot;&quot;);
289             out.write(&quot;&quot;);
290             out.write(&quot;class JfrPeriodicEventSet : public AllStatic {&quot;);
291             out.write(&quot; public:&quot;);
292             out.write(&quot;  static void requestEvent(JfrEventId id) {&quot;);
293             out.write(&quot;    switch(id) {&quot;);
294             out.write(&quot;  &quot;);
295             for (EventElement e : metadata.getPeriodicEvents()) {
296                 out.write(&quot;      case Jfr&quot; + e.name + &quot;Event:&quot;);
297                 out.write(&quot;        request&quot; + e.name + &quot;();&quot;);
298                 out.write(&quot;        break;&quot;);
299                 out.write(&quot;  &quot;);
300             }
301             out.write(&quot;      default:&quot;);
302             out.write(&quot;        break;&quot;);
303             out.write(&quot;      }&quot;);
304             out.write(&quot;    }&quot;);
305             out.write(&quot;&quot;);
306             out.write(&quot; private:&quot;);
307             out.write(&quot;&quot;);
308             for (EventElement e : metadata.getPeriodicEvents()) {
309                 out.write(&quot;  static void request&quot; + e.name + &quot;(void);&quot;);
310                 out.write(&quot;&quot;);
311             }
312             out.write(&quot;};&quot;);
313             out.write(&quot;&quot;);
314             out.write(&quot;#endif // INCLUDE_JFR&quot;);
315             out.write(&quot;#endif // JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
316         }
317     }
318 
319     private static void printJfrEventControlHpp(Metadata metadata, File outputDirectory) throws Exception {
320         try (Printer out = new Printer(outputDirectory, &quot;jfrEventControl.hpp&quot;)) {
321             out.write(&quot;#ifndef JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
322             out.write(&quot;#define JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
323             out.write(&quot;&quot;);
324             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
325             out.write(&quot;#if INCLUDE_JFR&quot;);
326             out.write(&quot;#include \&quot;jfrfiles/jfrEventIds.hpp\&quot;&quot;);
327             out.write(&quot;&quot;);
328             out.write(&quot;/**&quot;);
329             out.write(&quot; * Event setting. We add some padding so we can use our&quot;);
330             out.write(&quot; * event IDs as indexes into this.&quot;);
331             out.write(&quot; */&quot;);
332             out.write(&quot;&quot;);
333             out.write(&quot;struct jfrNativeEventSetting {&quot;);
334             out.write(&quot;  jlong  threshold_ticks;&quot;);
335             out.write(&quot;  jlong  cutoff_ticks;&quot;);
336             out.write(&quot;  u1     stacktrace;&quot;);
337             out.write(&quot;  u1     enabled;&quot;);
338             out.write(&quot;  u1     pad[6]; // Because GCC on linux ia32 at least tries to pack this.&quot;);
339             out.write(&quot;};&quot;);
340             out.write(&quot;&quot;);
341             out.write(&quot;union JfrNativeSettings {&quot;);
342             out.write(&quot;  // Array version.&quot;);
343             out.write(&quot;  jfrNativeEventSetting bits[MaxJfrEventId];&quot;);
344             out.write(&quot;  // Then, to make it easy to debug,&quot;);
345             out.write(&quot;  // add named struct members also.&quot;);
346             out.write(&quot;  struct {&quot;);
347             out.write(&quot;    jfrNativeEventSetting pad[NUM_RESERVED_EVENTS];&quot;);
348             for (TypeElement t : metadata.getEventsAndStructs()) {
349                 out.write(&quot;    jfrNativeEventSetting &quot; + t.name + &quot;;&quot;);
350             }
351             out.write(&quot;  } ev;&quot;);
352             out.write(&quot;};&quot;);
353             out.write(&quot;&quot;);
354             out.write(&quot;#endif // INCLUDE_JFR&quot;);
355             out.write(&quot;#endif // JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
356         }
357     }
358 
359     private static void printJfrEventIdsHpp(Metadata metadata, File outputDirectory) throws Exception {
360         try (Printer out = new Printer(outputDirectory, &quot;jfrEventIds.hpp&quot;)) {
361             out.write(&quot;#ifndef JFRFILES_JFREVENTIDS_HPP&quot;);
362             out.write(&quot;#define JFRFILES_JFREVENTIDS_HPP&quot;);
363             out.write(&quot;&quot;);
364             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
365             out.write(&quot;#if INCLUDE_JFR&quot;);
366             out.write(&quot;#include \&quot;jfrfiles/jfrTypes.hpp\&quot;&quot;);
367             out.write(&quot;&quot;);
368             out.write(&quot;/**&quot;);
369             out.write(&quot; * Enum of the event types in the JVM&quot;);
370             out.write(&quot; */&quot;);
371             out.write(&quot;enum JfrEventId {&quot;);
372             out.write(&quot;  _jfreventbase = (NUM_RESERVED_EVENTS-1), // Make sure we start at right index.&quot;);
373             out.write(&quot;  &quot;);
374             out.write(&quot;  // Events -&gt; enum entry&quot;);
375             for (TypeElement t : metadata.getEventsAndStructs()) {
376                 out.write(&quot;  Jfr&quot; + t.name + &quot;Event,&quot;);
377             }
378             out.write(&quot;&quot;);
379             out.write(&quot;  MaxJfrEventId&quot;);
380             out.write(&quot;};&quot;);
381             out.write(&quot;&quot;);
382             out.write(&quot;/**&quot;);
383             out.write(&quot; * Struct types in the JVM&quot;);
384             out.write(&quot; */&quot;);
385             out.write(&quot;enum JfrStructId {&quot;);
386             for (TypeElement t : metadata.getNonEventsAndNonStructs()) {
387                 out.write(&quot;  Jfr&quot; + t.name + &quot;Struct,&quot;);
388             }
389             for (TypeElement t : metadata.getEventsAndStructs()) {
390                 out.write(&quot;  Jfr&quot; + t.name + &quot;Struct,&quot;);
391             }
392             out.write(&quot;&quot;);
393             out.write(&quot;  MaxJfrStructId&quot;);
394             out.write(&quot;};&quot;);
395             out.write(&quot;&quot;);
396             out.write(&quot;typedef enum JfrEventId JfrEventId;&quot;);
397             out.write(&quot;typedef enum JfrStructId JfrStructId;&quot;);
398             out.write(&quot;&quot;);
399             out.write(&quot;#endif // INCLUDE_JFR&quot;);
400             out.write(&quot;#endif // JFRFILES_JFREVENTIDS_HPP&quot;);
401         }
402     }
403 
404     private static void printJfrTypesHpp(Metadata metadata, File outputDirectory) throws Exception {
405         List&lt;String&gt; knownTypes = List.of(&quot;Thread&quot;, &quot;StackTrace&quot;, &quot;Class&quot;, &quot;StackFrame&quot;);
406         try (Printer out = new Printer(outputDirectory, &quot;jfrTypes.hpp&quot;)) {
407             out.write(&quot;#ifndef JFRFILES_JFRTYPES_HPP&quot;);
408             out.write(&quot;#define JFRFILES_JFRTYPES_HPP&quot;);
409             out.write(&quot;&quot;);
410             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
411             out.write(&quot;#if INCLUDE_JFR&quot;);
412             out.write(&quot;&quot;);
413             out.write(&quot;enum JfrTypeId {&quot;);
414             out.write(&quot;  TYPE_NONE             = 0,&quot;);
415             out.write(&quot;  TYPE_CLASS            = 20,&quot;);
416             out.write(&quot;  TYPE_STRING           = 21,&quot;);
417             out.write(&quot;  TYPE_THREAD           = 22,&quot;);
418             out.write(&quot;  TYPE_STACKTRACE       = 23,&quot;);
419             out.write(&quot;  TYPE_BYTES            = 24,&quot;);
420             out.write(&quot;  TYPE_EPOCHMILLIS      = 25,&quot;);
421             out.write(&quot;  TYPE_MILLIS           = 26,&quot;);
422             out.write(&quot;  TYPE_NANOS            = 27,&quot;);
423             out.write(&quot;  TYPE_TICKS            = 28,&quot;);
424             out.write(&quot;  TYPE_ADDRESS          = 29,&quot;);
425             out.write(&quot;  TYPE_PERCENTAGE       = 30,&quot;);
426             out.write(&quot;  TYPE_DUMMY,&quot;);
427             out.write(&quot;  TYPE_DUMMY_1,&quot;);
428             for (TypeElement type : metadata.getTypes()) {
429                 if (!knownTypes.contains(type.name)) {
430                     out.write(&quot;  TYPE_&quot; + type.name.toUpperCase() + &quot;,&quot;);
431                 }
432             }
433             out.write(&quot;&quot;);
434             out.write(&quot;  NUM_JFR_TYPES,&quot;);
435             out.write(&quot;  TYPES_END             = 255&quot;);
436             out.write(&quot;};&quot;);
437             out.write(&quot;&quot;);
438             out.write(&quot;enum ReservedEvent {&quot;);
439             out.write(&quot;  EVENT_METADATA,&quot;);
440             out.write(&quot;  EVENT_CHECKPOINT,&quot;);
441             out.write(&quot;  EVENT_BUFFERLOST,&quot;);
442             out.write(&quot;  NUM_RESERVED_EVENTS = TYPES_END&quot;);
443             out.write(&quot;};&quot;);
444             out.write(&quot;&quot;);
445             out.write(&quot;#endif // INCLUDE_JFR&quot;);
446             out.write(&quot;#endif // JFRFILES_JFRTYPES_HPP&quot;);
447           };
448     }
449 
450     private static void printJfrEventClassesHpp(Metadata metadata, File outputDirectory) throws Exception {
451         try (Printer out = new Printer(outputDirectory, &quot;jfrEventClasses.hpp&quot;)) {
452             out.write(&quot;#ifndef JFRFILES_JFREVENTCLASSES_HPP&quot;);
453             out.write(&quot;#define JFRFILES_JFREVENTCLASSES_HPP&quot;);
454             out.write(&quot;&quot;);
455             out.write(&quot;#include \&quot;oops/klass.hpp\&quot;&quot;);
456             out.write(&quot;#include \&quot;jfrfiles/jfrTypes.hpp\&quot;&quot;);
457             out.write(&quot;#include \&quot;jfr/utilities/jfrTypes.hpp\&quot;&quot;);
458             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
459             out.write(&quot;#include \&quot;utilities/ticks.hpp\&quot;&quot;);
460             out.write(&quot;#if INCLUDE_JFR&quot;);
461             out.write(&quot;#include \&quot;jfr/recorder/service/jfrEvent.hpp\&quot;&quot;);
462             out.write(&quot;/*&quot;);
463             out.write(&quot; * Each event class has an assert member function verify() which is invoked&quot;);
464             out.write(&quot; * just before the engine writes the event and its fields to the data stream.&quot;);
465             out.write(&quot; * The purpose of verify() is to ensure that all fields in the event are initialized&quot;);
466             out.write(&quot; * and set before attempting to commit.&quot;);
467             out.write(&quot; *&quot;);
468             out.write(&quot; * We enforce this requirement because events are generally stack allocated and therefore&quot;);
469             out.write(&quot; * *not* initialized to default values. This prevents us from inadvertently committing&quot;);
470             out.write(&quot; * uninitialized values to the data stream.&quot;);
471             out.write(&quot; *&quot;);
472             out.write(&quot; * The assert message contains both the index (zero based) as well as the name of the field.&quot;);
473             out.write(&quot; */&quot;);
474             out.write(&quot;&quot;);
475             printTypes(out, metadata, false);
476             out.write(&quot;&quot;);
477             out.write(&quot;&quot;);
478             out.write(&quot;#else // !INCLUDE_JFR&quot;);
479             out.write(&quot;&quot;);
480             out.write(&quot;template &lt;typename T&gt;&quot;);
481             out.write(&quot;class JfrEvent {&quot;);
482             out.write(&quot; public:&quot;);
483             out.write(&quot;  JfrEvent() {}&quot;);
484             out.write(&quot;  void set_starttime(const Ticks&amp;) const {}&quot;);
485             out.write(&quot;  void set_endtime(const Ticks&amp;) const {}&quot;);
486             out.write(&quot;  bool should_commit() const { return false; }&quot;);
487             out.write(&quot;  static bool is_enabled() { return false; }&quot;);
488             out.write(&quot;  void commit() {}&quot;);
489             out.write(&quot;};&quot;);
490             out.write(&quot;&quot;);
491             printTypes(out, metadata, true);
492             out.write(&quot;&quot;);
493             out.write(&quot;&quot;);
494             out.write(&quot;#endif // INCLUDE_JFR&quot;);
495             out.write(&quot;#endif // JFRFILES_JFREVENTCLASSES_HPP&quot;);
496         }
497     }
498 
499     private static void printTypes(Printer out, Metadata metadata, boolean empty) {
500         for (TypeElement t : metadata.getStructs()) {
501             printType(out, t, empty);
502             out.write(&quot;&quot;);
503         }
504         for (EventElement e : metadata.getEvents()) {
505             printEvent(out, e, empty);
506             out.write(&quot;&quot;);
507         }
508     }
509 
510     private static void printType(Printer out, TypeElement t, boolean empty) {
511         out.write(&quot;struct JfrStruct&quot; + t.name);
512         out.write(&quot;{&quot;);
513         if (!empty) {
514           out.write(&quot; private:&quot;);
515           for (FieldElement f : t.fields) {
516               printField(out, f);
517           }
518           out.write(&quot;&quot;);
519         }
520         out.write(&quot; public:&quot;);
521         for (FieldElement f : t.fields) {
522            printTypeSetter(out, f, empty);
523         }
524         out.write(&quot;&quot;);
525         if (!empty) {
526           printWriteData(out, t.fields);
527         }
528         out.write(&quot;};&quot;);
529         out.write(&quot;&quot;);
530     }
531 
532     private static void printEvent(Printer out, EventElement event, boolean empty) {
533         out.write(&quot;class Event&quot; + event.name + &quot; : public JfrEvent&lt;Event&quot; + event.name + &quot;&gt;&quot;);
534         out.write(&quot;{&quot;);
535         if (!empty) {
536           out.write(&quot; private:&quot;);
537           for (FieldElement f : event.fields) {
538               printField(out, f);
539           }
540           out.write(&quot;&quot;);
541         }
542         out.write(&quot; public:&quot;);
543         if (!empty) {
544           out.write(&quot;  static const bool hasThread = &quot; + event.thread + &quot;;&quot;);
545           out.write(&quot;  static const bool hasStackTrace = &quot; + event.stackTrace + &quot;;&quot;);
546           out.write(&quot;  static const bool isInstant = &quot; + !event.startTime + &quot;;&quot;);
547           out.write(&quot;  static const bool hasCutoff = &quot; + event.cutoff + &quot;;&quot;);
548           out.write(&quot;  static const bool isRequestable = &quot; + event.periodic + &quot;;&quot;);
549           out.write(&quot;  static const JfrEventId eventId = Jfr&quot; + event.name + &quot;Event;&quot;);
550           out.write(&quot;&quot;);
551         }
552         if (!empty) {
553           out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) : JfrEvent&lt;Event&quot; + event.name + &quot;&gt;(timing) {}&quot;);
554         } else {
555           out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) {}&quot;);
556         }
557         out.write(&quot;&quot;);
558         int index = 0;
559         for (FieldElement f : event.fields) {
560             out.write(&quot;  void set_&quot; + f.name + &quot;(&quot; + f.getParameterType() + &quot; &quot; + f.getParameterName() + &quot;) {&quot;);
561             if (!empty) {
562               out.write(&quot;    this-&gt;_&quot; + f.name + &quot; = &quot; + f.getParameterName() + &quot;;&quot;);
563               out.write(&quot;    DEBUG_ONLY(set_field_bit(&quot; + index++ + &quot;));&quot;);
564             }
565             out.write(&quot;  }&quot;);
566         }
567         out.write(&quot;&quot;);
568         if (!empty) {
569           printWriteData(out, event.fields);
570           out.write(&quot;&quot;);
571         }
572         out.write(&quot;  using JfrEvent&lt;Event&quot; + event.name + &quot;&gt;::commit; // else commit() is hidden by overloaded versions in this class&quot;);
573         printConstructor2(out, event, empty);
574         printCommitMethod(out, event, empty);
575         if (!empty) {
576           printVerify(out, event.fields);
577         }
578         out.write(&quot;};&quot;);
579     }
580 
581     private static void printWriteData(Printer out, List&lt;FieldElement&gt; fields) {
582         out.write(&quot;  template &lt;typename Writer&gt;&quot;);
583         out.write(&quot;  void writeData(Writer&amp; w) {&quot;);
584         for (FieldElement field : fields) {
585             if (field.struct) {
586                 out.write(&quot;    _&quot; + field.name + &quot;.writeData(w);&quot;);
587             } else {
588                 out.write(&quot;    w.write(_&quot; + field.name + &quot;);&quot;);
589             }
590         }
591         out.write(&quot;  }&quot;);
592     }
593 
594     private static void printTypeSetter(Printer out, FieldElement field, boolean empty) {
595         if (!empty) {
596           out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { this-&gt;_&quot; + field.name + &quot; = new_value; }&quot;);
597         } else {
598           out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { }&quot;);
599         }
600     }
601 
602     private static void printVerify(Printer out, List&lt;FieldElement&gt; fields) {
603         out.write(&quot;&quot;);
604         out.write(&quot;#ifdef ASSERT&quot;);
605         out.write(&quot;  void verify() const {&quot;);
606         int index = 0;
607         for (FieldElement f : fields) {
608             out.write(&quot;    assert(verify_field_bit(&quot; + index++ + &quot;), \&quot;Attempting to write an uninitialized event field: %s\&quot;, \&quot;_&quot; + f.name + &quot;\&quot;);&quot;);
609         }
610         out.write(&quot;  }&quot;);
611         out.write(&quot;#endif&quot;);
612     }
613 
614     private static void printCommitMethod(Printer out, EventElement event, boolean empty) {
615         if (event.startTime) {
616             StringJoiner sj = new StringJoiner(&quot;,\n              &quot;);
617             for (FieldElement f : event.fields) {
618                 sj.add(f.getParameterType() + &quot; &quot; + f.name);
619             }
620             out.write(&quot;&quot;);
621             out.write(&quot;  void commit(&quot; + sj.toString() + &quot;) {&quot;);
622             if (!empty) {
623               out.write(&quot;    if (should_commit()) {&quot;);
624               for (FieldElement f : event.fields) {
625                   out.write(&quot;      set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);
626               }
627               out.write(&quot;      commit();&quot;);
628               out.write(&quot;    }&quot;);
629             }
630             out.write(&quot;  }&quot;);
631         }
632         out.write(&quot;&quot;);
633         StringJoiner sj = new StringJoiner(&quot;,\n                     &quot;);
634         if (event.startTime) {
635             sj.add(&quot;const Ticks&amp; startTicks&quot;);
636             sj.add(&quot;const Ticks&amp; endTicks&quot;);
637         }
638         for (FieldElement f : event.fields) {
639             sj.add(f.getParameterType() + &quot; &quot; + f.name);
640         }
641         out.write(&quot;  static void commit(&quot; + sj.toString() + &quot;) {&quot;);
642         if (!empty) {
643           out.write(&quot;    Event&quot; + event.name + &quot; me(UNTIMED);&quot;);
644           out.write(&quot;&quot;);
645           out.write(&quot;    if (me.should_commit()) {&quot;);
646           if (event.startTime) {
647               out.write(&quot;      me.set_starttime(startTicks);&quot;);
648               out.write(&quot;      me.set_endtime(endTicks);&quot;);
649           }
650           for (FieldElement f : event.fields) {
651               out.write(&quot;      me.set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);
652           }
653           out.write(&quot;      me.commit();&quot;);
654           out.write(&quot;    }&quot;);
655         }
656         out.write(&quot;  }&quot;);
657     }
658 
659     private static void printConstructor2(Printer out, EventElement event, boolean empty) {
660         if (!event.startTime) {
661             out.write(&quot;&quot;);
662             out.write(&quot;&quot;);
663         }
664         if (event.startTime) {
665             out.write(&quot;&quot;);
666             out.write(&quot;  Event&quot; + event.name + &quot;(&quot;);
667             StringJoiner sj = new StringJoiner(&quot;,\n    &quot;);
668             for (FieldElement f : event.fields) {
669                 sj.add(f.getParameterType() + &quot; &quot; + f.name);
670             }
671             if (!empty) {
672               out.write(&quot;    &quot; + sj.toString() + &quot;) : JfrEvent&lt;Event&quot; + event.name + &quot;&gt;(TIMED) {&quot;);
673               out.write(&quot;    if (should_commit()) {&quot;);
674               for (FieldElement f : event.fields) {
675                   out.write(&quot;      set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);
676               }
677               out.write(&quot;    }&quot;);
678             } else {
679               out.write(&quot;    &quot; + sj.toString() + &quot;) {&quot;);
680             }
681             out.write(&quot;  }&quot;);
682         }
683     }
684 
685     private static void printField(Printer out, FieldElement field) {
686         out.write(&quot;  &quot; + field.getFieldType() + &quot; _&quot; + field.name + &quot;;&quot;);
687     }
688 }
    </pre>
  </body>
</html>
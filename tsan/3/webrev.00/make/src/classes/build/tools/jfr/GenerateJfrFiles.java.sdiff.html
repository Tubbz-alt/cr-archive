<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/src/classes/build/tools/jfr/GenerateJfrFiles.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../scripts/genExceptions.sh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/BuildFailureHandler.gmk.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/src/classes/build/tools/jfr/GenerateJfrFiles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
137         void wireUpTypes() {
138             for (TypeElement t : types.values()) {
139                 for (FieldElement f : t.fields) {
140                     TypeElement type = types.get(f.typeName);
141                     if (f.struct) {
142                         type.supportStruct = true;
143                     }
144                     f.type = type;
145                 }
146             }
147         }
148     }
149 
150     static class EventElement extends TypeElement {
151         String representation;
152         boolean thread;
153         boolean stackTrace;
154         boolean startTime;
155         boolean periodic;
156         boolean cutoff;

157     }
158 
159     static class FieldElement {
160         final Metadata metadata;
161         TypeElement type;
162         String name;
163         String typeName;
164         boolean struct;
165 
166         FieldElement(Metadata metadata) {
167             this.metadata = metadata;
168         }
169 
170         String getParameterType() {
171             if (struct) {
172                 return &quot;const JfrStruct&quot; + typeName + &quot;&amp;&quot;;
173             }
174             XmlType xmlType = metadata.xmlTypes.get(typeName);
175             if (xmlType != null) {
176                 return xmlType.parameterType;
</pre>
<hr />
<pre>
202             this.metadata = metadata;
203         }
204         @Override
205         public void error(SAXParseException e) throws SAXException {
206           throw e;
207         }
208         @Override
209         public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
210             switch (qName) {
211             case &quot;XmlType&quot;:
212                 String name = attributes.getValue(&quot;name&quot;);
213                 String parameterType = attributes.getValue(&quot;parameterType&quot;);
214                 String fieldType = attributes.getValue(&quot;fieldType&quot;);
215                 metadata.xmlTypes.put(name, new XmlType(fieldType, parameterType));
216                 break;
217             case &quot;Type&quot;:
218                 currentType = new TypeElement();
219                 currentType.name = attributes.getValue(&quot;name&quot;);
220                 break;
221             case &quot;Event&quot;:
<span class="line-modified">222                 EventElement eventtType = new EventElement();</span>
<span class="line-modified">223                 eventtType.name = attributes.getValue(&quot;name&quot;);</span>
<span class="line-modified">224                 eventtType.thread = getBoolean(attributes, &quot;thread&quot;, false);</span>
<span class="line-modified">225                 eventtType.stackTrace = getBoolean(attributes, &quot;stackTrace&quot;, false);</span>
<span class="line-modified">226                 eventtType.startTime = getBoolean(attributes, &quot;startTime&quot;, true);</span>
<span class="line-modified">227                 eventtType.periodic = attributes.getValue(&quot;period&quot;) != null;</span>
<span class="line-modified">228                 eventtType.cutoff = getBoolean(attributes, &quot;cutoff&quot;, false);</span>
<span class="line-modified">229                 currentType = eventtType;</span>

230                 break;
231             case &quot;Field&quot;:
232                 currentField = new FieldElement(metadata);
233                 currentField.struct = getBoolean(attributes, &quot;struct&quot;, false);
234                 currentField.name = attributes.getValue(&quot;name&quot;);
235                 currentField.typeName = attributes.getValue(&quot;type&quot;);
236                 break;
237             }
238         }
239 
240         private boolean getBoolean(Attributes attributes, String name, boolean defaultValue) {
241             String value = attributes.getValue(name);
242             return value == null ? defaultValue : Boolean.valueOf(value);
243         }
244 
245         @Override
246         public void endElement(String uri, String localName, String qName) {
247             switch (qName) {
248             case &quot;Type&quot;:
249             case &quot;Event&quot;:
</pre>
<hr />
<pre>
442             out.write(&quot;  NUM_RESERVED_EVENTS = TYPES_END&quot;);
443             out.write(&quot;};&quot;);
444             out.write(&quot;&quot;);
445             out.write(&quot;#endif // INCLUDE_JFR&quot;);
446             out.write(&quot;#endif // JFRFILES_JFRTYPES_HPP&quot;);
447           };
448     }
449 
450     private static void printJfrEventClassesHpp(Metadata metadata, File outputDirectory) throws Exception {
451         try (Printer out = new Printer(outputDirectory, &quot;jfrEventClasses.hpp&quot;)) {
452             out.write(&quot;#ifndef JFRFILES_JFREVENTCLASSES_HPP&quot;);
453             out.write(&quot;#define JFRFILES_JFREVENTCLASSES_HPP&quot;);
454             out.write(&quot;&quot;);
455             out.write(&quot;#include \&quot;oops/klass.hpp\&quot;&quot;);
456             out.write(&quot;#include \&quot;jfrfiles/jfrTypes.hpp\&quot;&quot;);
457             out.write(&quot;#include \&quot;jfr/utilities/jfrTypes.hpp\&quot;&quot;);
458             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
459             out.write(&quot;#include \&quot;utilities/ticks.hpp\&quot;&quot;);
460             out.write(&quot;#if INCLUDE_JFR&quot;);
461             out.write(&quot;#include \&quot;jfr/recorder/service/jfrEvent.hpp\&quot;&quot;);

462             out.write(&quot;/*&quot;);
463             out.write(&quot; * Each event class has an assert member function verify() which is invoked&quot;);
464             out.write(&quot; * just before the engine writes the event and its fields to the data stream.&quot;);
465             out.write(&quot; * The purpose of verify() is to ensure that all fields in the event are initialized&quot;);
466             out.write(&quot; * and set before attempting to commit.&quot;);
467             out.write(&quot; *&quot;);
468             out.write(&quot; * We enforce this requirement because events are generally stack allocated and therefore&quot;);
469             out.write(&quot; * *not* initialized to default values. This prevents us from inadvertently committing&quot;);
470             out.write(&quot; * uninitialized values to the data stream.&quot;);
471             out.write(&quot; *&quot;);
472             out.write(&quot; * The assert message contains both the index (zero based) as well as the name of the field.&quot;);
473             out.write(&quot; */&quot;);
474             out.write(&quot;&quot;);
475             printTypes(out, metadata, false);
476             out.write(&quot;&quot;);
477             out.write(&quot;&quot;);
478             out.write(&quot;#else // !INCLUDE_JFR&quot;);
479             out.write(&quot;&quot;);
480             out.write(&quot;template &lt;typename T&gt;&quot;);
481             out.write(&quot;class JfrEvent {&quot;);
</pre>
<hr />
<pre>
506             out.write(&quot;&quot;);
507         }
508     }
509 
510     private static void printType(Printer out, TypeElement t, boolean empty) {
511         out.write(&quot;struct JfrStruct&quot; + t.name);
512         out.write(&quot;{&quot;);
513         if (!empty) {
514           out.write(&quot; private:&quot;);
515           for (FieldElement f : t.fields) {
516               printField(out, f);
517           }
518           out.write(&quot;&quot;);
519         }
520         out.write(&quot; public:&quot;);
521         for (FieldElement f : t.fields) {
522            printTypeSetter(out, f, empty);
523         }
524         out.write(&quot;&quot;);
525         if (!empty) {
<span class="line-modified">526           printWriteData(out, t.fields);</span>
527         }
528         out.write(&quot;};&quot;);
529         out.write(&quot;&quot;);
530     }
531 
532     private static void printEvent(Printer out, EventElement event, boolean empty) {
533         out.write(&quot;class Event&quot; + event.name + &quot; : public JfrEvent&lt;Event&quot; + event.name + &quot;&gt;&quot;);
534         out.write(&quot;{&quot;);
535         if (!empty) {
536           out.write(&quot; private:&quot;);
537           for (FieldElement f : event.fields) {
538               printField(out, f);
539           }
540           out.write(&quot;&quot;);
541         }
542         out.write(&quot; public:&quot;);
543         if (!empty) {
544           out.write(&quot;  static const bool hasThread = &quot; + event.thread + &quot;;&quot;);
545           out.write(&quot;  static const bool hasStackTrace = &quot; + event.stackTrace + &quot;;&quot;);
546           out.write(&quot;  static const bool isInstant = &quot; + !event.startTime + &quot;;&quot;);
</pre>
<hr />
<pre>
549           out.write(&quot;  static const JfrEventId eventId = Jfr&quot; + event.name + &quot;Event;&quot;);
550           out.write(&quot;&quot;);
551         }
552         if (!empty) {
553           out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) : JfrEvent&lt;Event&quot; + event.name + &quot;&gt;(timing) {}&quot;);
554         } else {
555           out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) {}&quot;);
556         }
557         out.write(&quot;&quot;);
558         int index = 0;
559         for (FieldElement f : event.fields) {
560             out.write(&quot;  void set_&quot; + f.name + &quot;(&quot; + f.getParameterType() + &quot; &quot; + f.getParameterName() + &quot;) {&quot;);
561             if (!empty) {
562               out.write(&quot;    this-&gt;_&quot; + f.name + &quot; = &quot; + f.getParameterName() + &quot;;&quot;);
563               out.write(&quot;    DEBUG_ONLY(set_field_bit(&quot; + index++ + &quot;));&quot;);
564             }
565             out.write(&quot;  }&quot;);
566         }
567         out.write(&quot;&quot;);
568         if (!empty) {
<span class="line-modified">569           printWriteData(out, event.fields);</span>
570           out.write(&quot;&quot;);
571         }
572         out.write(&quot;  using JfrEvent&lt;Event&quot; + event.name + &quot;&gt;::commit; // else commit() is hidden by overloaded versions in this class&quot;);
573         printConstructor2(out, event, empty);
574         printCommitMethod(out, event, empty);
575         if (!empty) {
576           printVerify(out, event.fields);
577         }
578         out.write(&quot;};&quot;);
579     }
580 
<span class="line-modified">581     private static void printWriteData(Printer out, List&lt;FieldElement&gt; fields) {</span>
582         out.write(&quot;  template &lt;typename Writer&gt;&quot;);
583         out.write(&quot;  void writeData(Writer&amp; w) {&quot;);




584         for (FieldElement field : fields) {
585             if (field.struct) {
586                 out.write(&quot;    _&quot; + field.name + &quot;.writeData(w);&quot;);
587             } else {
588                 out.write(&quot;    w.write(_&quot; + field.name + &quot;);&quot;);
589             }
590         }
591         out.write(&quot;  }&quot;);
592     }
593 
594     private static void printTypeSetter(Printer out, FieldElement field, boolean empty) {
595         if (!empty) {
596           out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { this-&gt;_&quot; + field.name + &quot; = new_value; }&quot;);
597         } else {
598           out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { }&quot;);
599         }
600     }
601 
602     private static void printVerify(Printer out, List&lt;FieldElement&gt; fields) {
603         out.write(&quot;&quot;);
</pre>
</td>
<td>
<hr />
<pre>
137         void wireUpTypes() {
138             for (TypeElement t : types.values()) {
139                 for (FieldElement f : t.fields) {
140                     TypeElement type = types.get(f.typeName);
141                     if (f.struct) {
142                         type.supportStruct = true;
143                     }
144                     f.type = type;
145                 }
146             }
147         }
148     }
149 
150     static class EventElement extends TypeElement {
151         String representation;
152         boolean thread;
153         boolean stackTrace;
154         boolean startTime;
155         boolean periodic;
156         boolean cutoff;
<span class="line-added">157         String commitState;</span>
158     }
159 
160     static class FieldElement {
161         final Metadata metadata;
162         TypeElement type;
163         String name;
164         String typeName;
165         boolean struct;
166 
167         FieldElement(Metadata metadata) {
168             this.metadata = metadata;
169         }
170 
171         String getParameterType() {
172             if (struct) {
173                 return &quot;const JfrStruct&quot; + typeName + &quot;&amp;&quot;;
174             }
175             XmlType xmlType = metadata.xmlTypes.get(typeName);
176             if (xmlType != null) {
177                 return xmlType.parameterType;
</pre>
<hr />
<pre>
203             this.metadata = metadata;
204         }
205         @Override
206         public void error(SAXParseException e) throws SAXException {
207           throw e;
208         }
209         @Override
210         public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
211             switch (qName) {
212             case &quot;XmlType&quot;:
213                 String name = attributes.getValue(&quot;name&quot;);
214                 String parameterType = attributes.getValue(&quot;parameterType&quot;);
215                 String fieldType = attributes.getValue(&quot;fieldType&quot;);
216                 metadata.xmlTypes.put(name, new XmlType(fieldType, parameterType));
217                 break;
218             case &quot;Type&quot;:
219                 currentType = new TypeElement();
220                 currentType.name = attributes.getValue(&quot;name&quot;);
221                 break;
222             case &quot;Event&quot;:
<span class="line-modified">223                 EventElement eventType = new EventElement();</span>
<span class="line-modified">224                 eventType.name = attributes.getValue(&quot;name&quot;);</span>
<span class="line-modified">225                 eventType.thread = getBoolean(attributes, &quot;thread&quot;, false);</span>
<span class="line-modified">226                 eventType.stackTrace = getBoolean(attributes, &quot;stackTrace&quot;, false);</span>
<span class="line-modified">227                 eventType.startTime = getBoolean(attributes, &quot;startTime&quot;, true);</span>
<span class="line-modified">228                 eventType.periodic = attributes.getValue(&quot;period&quot;) != null;</span>
<span class="line-modified">229                 eventType.cutoff = getBoolean(attributes, &quot;cutoff&quot;, false);</span>
<span class="line-modified">230                 eventType.commitState = attributes.getValue(&quot;commitState&quot;);</span>
<span class="line-added">231                 currentType = eventType;</span>
232                 break;
233             case &quot;Field&quot;:
234                 currentField = new FieldElement(metadata);
235                 currentField.struct = getBoolean(attributes, &quot;struct&quot;, false);
236                 currentField.name = attributes.getValue(&quot;name&quot;);
237                 currentField.typeName = attributes.getValue(&quot;type&quot;);
238                 break;
239             }
240         }
241 
242         private boolean getBoolean(Attributes attributes, String name, boolean defaultValue) {
243             String value = attributes.getValue(name);
244             return value == null ? defaultValue : Boolean.valueOf(value);
245         }
246 
247         @Override
248         public void endElement(String uri, String localName, String qName) {
249             switch (qName) {
250             case &quot;Type&quot;:
251             case &quot;Event&quot;:
</pre>
<hr />
<pre>
444             out.write(&quot;  NUM_RESERVED_EVENTS = TYPES_END&quot;);
445             out.write(&quot;};&quot;);
446             out.write(&quot;&quot;);
447             out.write(&quot;#endif // INCLUDE_JFR&quot;);
448             out.write(&quot;#endif // JFRFILES_JFRTYPES_HPP&quot;);
449           };
450     }
451 
452     private static void printJfrEventClassesHpp(Metadata metadata, File outputDirectory) throws Exception {
453         try (Printer out = new Printer(outputDirectory, &quot;jfrEventClasses.hpp&quot;)) {
454             out.write(&quot;#ifndef JFRFILES_JFREVENTCLASSES_HPP&quot;);
455             out.write(&quot;#define JFRFILES_JFREVENTCLASSES_HPP&quot;);
456             out.write(&quot;&quot;);
457             out.write(&quot;#include \&quot;oops/klass.hpp\&quot;&quot;);
458             out.write(&quot;#include \&quot;jfrfiles/jfrTypes.hpp\&quot;&quot;);
459             out.write(&quot;#include \&quot;jfr/utilities/jfrTypes.hpp\&quot;&quot;);
460             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
461             out.write(&quot;#include \&quot;utilities/ticks.hpp\&quot;&quot;);
462             out.write(&quot;#if INCLUDE_JFR&quot;);
463             out.write(&quot;#include \&quot;jfr/recorder/service/jfrEvent.hpp\&quot;&quot;);
<span class="line-added">464             out.write(&quot;#include \&quot;jfr/support/jfrEpochSynchronization.hpp\&quot;&quot;);</span>
465             out.write(&quot;/*&quot;);
466             out.write(&quot; * Each event class has an assert member function verify() which is invoked&quot;);
467             out.write(&quot; * just before the engine writes the event and its fields to the data stream.&quot;);
468             out.write(&quot; * The purpose of verify() is to ensure that all fields in the event are initialized&quot;);
469             out.write(&quot; * and set before attempting to commit.&quot;);
470             out.write(&quot; *&quot;);
471             out.write(&quot; * We enforce this requirement because events are generally stack allocated and therefore&quot;);
472             out.write(&quot; * *not* initialized to default values. This prevents us from inadvertently committing&quot;);
473             out.write(&quot; * uninitialized values to the data stream.&quot;);
474             out.write(&quot; *&quot;);
475             out.write(&quot; * The assert message contains both the index (zero based) as well as the name of the field.&quot;);
476             out.write(&quot; */&quot;);
477             out.write(&quot;&quot;);
478             printTypes(out, metadata, false);
479             out.write(&quot;&quot;);
480             out.write(&quot;&quot;);
481             out.write(&quot;#else // !INCLUDE_JFR&quot;);
482             out.write(&quot;&quot;);
483             out.write(&quot;template &lt;typename T&gt;&quot;);
484             out.write(&quot;class JfrEvent {&quot;);
</pre>
<hr />
<pre>
509             out.write(&quot;&quot;);
510         }
511     }
512 
513     private static void printType(Printer out, TypeElement t, boolean empty) {
514         out.write(&quot;struct JfrStruct&quot; + t.name);
515         out.write(&quot;{&quot;);
516         if (!empty) {
517           out.write(&quot; private:&quot;);
518           for (FieldElement f : t.fields) {
519               printField(out, f);
520           }
521           out.write(&quot;&quot;);
522         }
523         out.write(&quot; public:&quot;);
524         for (FieldElement f : t.fields) {
525            printTypeSetter(out, f, empty);
526         }
527         out.write(&quot;&quot;);
528         if (!empty) {
<span class="line-modified">529           printWriteData(out, t.fields, null);</span>
530         }
531         out.write(&quot;};&quot;);
532         out.write(&quot;&quot;);
533     }
534 
535     private static void printEvent(Printer out, EventElement event, boolean empty) {
536         out.write(&quot;class Event&quot; + event.name + &quot; : public JfrEvent&lt;Event&quot; + event.name + &quot;&gt;&quot;);
537         out.write(&quot;{&quot;);
538         if (!empty) {
539           out.write(&quot; private:&quot;);
540           for (FieldElement f : event.fields) {
541               printField(out, f);
542           }
543           out.write(&quot;&quot;);
544         }
545         out.write(&quot; public:&quot;);
546         if (!empty) {
547           out.write(&quot;  static const bool hasThread = &quot; + event.thread + &quot;;&quot;);
548           out.write(&quot;  static const bool hasStackTrace = &quot; + event.stackTrace + &quot;;&quot;);
549           out.write(&quot;  static const bool isInstant = &quot; + !event.startTime + &quot;;&quot;);
</pre>
<hr />
<pre>
552           out.write(&quot;  static const JfrEventId eventId = Jfr&quot; + event.name + &quot;Event;&quot;);
553           out.write(&quot;&quot;);
554         }
555         if (!empty) {
556           out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) : JfrEvent&lt;Event&quot; + event.name + &quot;&gt;(timing) {}&quot;);
557         } else {
558           out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) {}&quot;);
559         }
560         out.write(&quot;&quot;);
561         int index = 0;
562         for (FieldElement f : event.fields) {
563             out.write(&quot;  void set_&quot; + f.name + &quot;(&quot; + f.getParameterType() + &quot; &quot; + f.getParameterName() + &quot;) {&quot;);
564             if (!empty) {
565               out.write(&quot;    this-&gt;_&quot; + f.name + &quot; = &quot; + f.getParameterName() + &quot;;&quot;);
566               out.write(&quot;    DEBUG_ONLY(set_field_bit(&quot; + index++ + &quot;));&quot;);
567             }
568             out.write(&quot;  }&quot;);
569         }
570         out.write(&quot;&quot;);
571         if (!empty) {
<span class="line-modified">572           printWriteData(out, event.fields, event.commitState);</span>
573           out.write(&quot;&quot;);
574         }
575         out.write(&quot;  using JfrEvent&lt;Event&quot; + event.name + &quot;&gt;::commit; // else commit() is hidden by overloaded versions in this class&quot;);
576         printConstructor2(out, event, empty);
577         printCommitMethod(out, event, empty);
578         if (!empty) {
579           printVerify(out, event.fields);
580         }
581         out.write(&quot;};&quot;);
582     }
583 
<span class="line-modified">584     private static void printWriteData(Printer out, List&lt;FieldElement&gt; fields, String commitState) {</span>
585         out.write(&quot;  template &lt;typename Writer&gt;&quot;);
586         out.write(&quot;  void writeData(Writer&amp; w) {&quot;);
<span class="line-added">587         if ((&quot;_thread_in_native&quot;).equals(commitState)) {</span>
<span class="line-added">588             out.write(&quot;    // explicit epoch synchronization check&quot;);</span>
<span class="line-added">589             out.write(&quot;    JfrEpochSynchronization sync;&quot;);</span>
<span class="line-added">590         }</span>
591         for (FieldElement field : fields) {
592             if (field.struct) {
593                 out.write(&quot;    _&quot; + field.name + &quot;.writeData(w);&quot;);
594             } else {
595                 out.write(&quot;    w.write(_&quot; + field.name + &quot;);&quot;);
596             }
597         }
598         out.write(&quot;  }&quot;);
599     }
600 
601     private static void printTypeSetter(Printer out, FieldElement field, boolean empty) {
602         if (!empty) {
603           out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { this-&gt;_&quot; + field.name + &quot; = new_value; }&quot;);
604         } else {
605           out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { }&quot;);
606         }
607     }
608 
609     private static void printVerify(Printer out, List&lt;FieldElement&gt; fields) {
610         out.write(&quot;&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../scripts/genExceptions.sh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/BuildFailureHandler.gmk.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
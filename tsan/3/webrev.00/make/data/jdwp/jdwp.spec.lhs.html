<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/data/jdwp/jdwp.spec</title>
    <link rel="stylesheet" href="../../../style.css" />
    <script type="text/javascript" src="../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 JDWP &quot;Java(tm) Debug Wire Protocol&quot;
  27 (CommandSet VirtualMachine=1
  28     (Command Version=1
  29         &quot;Returns the JDWP version implemented by the target VM. &quot;
  30         &quot;The version string format is implementation dependent. &quot;
  31         (Out
  32         )
  33         (Reply
  34             (string description &quot;Text information on the VM version&quot;)
  35             (int    jdwpMajor   &quot;Major JDWP Version number&quot;)
  36             (int    jdwpMinor   &quot;Minor JDWP Version number&quot;)
  37             (string vmVersion   &quot;Target VM JRE version, as in the java.version property&quot;)
  38             (string vmName      &quot;Target VM name, as in the java.vm.name property&quot;)
  39         )
  40         (ErrorSet
  41             (Error VM_DEAD)
  42         )
  43     )
  44     (Command ClassesBySignature=2
  45         &quot;Returns reference types for all the classes loaded by the target VM &quot;
  46         &quot;which match the given signature. &quot;
  47         &quot;Multple reference types will be returned if two or more class &quot;
  48         &quot;loaders have loaded a class of the same name. &quot;
  49         &quot;The search is confined to loaded classes only; no attempt is made &quot;
  50         &quot;to load a class of the given signature. &quot;
  51         (Out
  52             (string signature &quot;JNI signature of the class to find &quot;
  53                               &quot;(for example, \&quot;Ljava/lang/String;\&quot;). &quot;
  54             )
  55         )
  56         (Reply
  57             (Repeat classes &quot;Number of reference types that follow.&quot;
  58                 (Group ClassInfo
  59                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
  60                                       &quot;of following reference type. &quot;)
  61                     (referenceTypeID typeID &quot;Matching loaded reference type&quot;)
  62                     (int status &quot;The current class &quot;
  63                                 &quot;&lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;status.&lt;/a&gt; &quot;)
  64                 )
  65             )
  66         )
  67         (ErrorSet
  68             (Error VM_DEAD)
  69         )
  70     )
  71     (Command AllClasses=3
  72         &quot;Returns reference types for all classes currently loaded by the &quot;
  73         &quot;target VM.&quot;
  74         (Out
  75         )
  76         (Reply
  77             (Repeat classes &quot;Number of reference types that follow.&quot;
  78                 (Group ClassInfo
  79                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
  80                                       &quot;of following reference type. &quot;)
  81                     (referenceTypeID typeID &quot;Loaded reference type&quot;)
  82                     (string signature
  83                                 &quot;The JNI signature of the loaded reference type&quot;)
  84                     (int status &quot;The current class &quot;
  85                                 &quot;&lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;status.&lt;/a&gt; &quot;)
  86                 )
  87             )
  88         )
  89         (ErrorSet
  90             (Error VM_DEAD)
  91         )
  92     )
  93     (Command AllThreads=4
  94         &quot;Returns all threads currently running in the target VM . &quot;
  95         &quot;The returned list contains threads created through &quot;
  96         &quot;java.lang.Thread, all native threads attached to &quot;
  97         &quot;the target VM through JNI, and system threads created &quot;
  98         &quot;by the target VM. Threads that have not yet been started &quot;
  99         &quot;and threads that have completed their execution are not &quot;
 100         &quot;included in the returned list. &quot;
 101         (Out
 102         )
 103         (Reply
 104             (Repeat threads &quot;Number of threads that follow.&quot;
 105                 (threadObject thread &quot;A running thread&quot;)
 106             )
 107         )
 108         (ErrorSet
 109             (Error VM_DEAD)
 110         )
 111     )
 112     (Command TopLevelThreadGroups=5
 113         &quot;Returns all thread groups that do not have a parent. This command &quot;
 114         &quot;may be used as the first step in building a tree (or trees) of the &quot;
 115         &quot;existing thread groups.&quot;
 116         (Out
 117         )
 118         (Reply
 119             (Repeat groups &quot;Number of thread groups that follow.&quot;
 120                 (threadGroupObject group &quot;A top level thread group&quot;)
 121             )
 122         )
 123         (ErrorSet
 124             (Error VM_DEAD)
 125         )
 126     )
 127     (Command Dispose=6
 128         &quot;Invalidates this virtual machine mirror. &quot;
 129         &quot;The communication channel to the target VM is closed, and &quot;
 130         &quot;the target VM prepares to accept another subsequent connection &quot;
 131         &quot;from this debugger or another debugger, including the &quot;
 132         &quot;following tasks: &quot;
 133         &quot;&lt;ul&gt;&quot;
 134         &quot;&lt;li&gt;All event requests are cancelled. &quot;
 135         &quot;&lt;li&gt;All threads suspended by the thread-level &quot;
 136         &quot;&lt;a href=\&quot;#JDWP_ThreadReference_Resume\&quot;&gt;resume&lt;/a&gt; command &quot;
 137         &quot;or the VM-level &quot;
 138         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Resume\&quot;&gt;resume&lt;/a&gt; command &quot;
 139         &quot;are resumed as many times as necessary for them to run. &quot;
 140         &quot;&lt;li&gt;Garbage collection is re-enabled in all cases where it was &quot;
 141         &quot;&lt;a href=\&quot;#JDWP_ObjectReference_DisableCollection\&quot;&gt;disabled&lt;/a&gt; &quot;
 142         &quot;&lt;/ul&gt;&quot;
 143         &quot;Any current method invocations executing in the target VM &quot;
 144         &quot;are continued after the disconnection. Upon completion of any such &quot;
 145         &quot;method invocation, the invoking thread continues from the &quot;
 146         &quot;location where it was originally stopped. &quot;
 147         &quot;&lt;p&gt;&quot;
 148         &quot;Resources originating in  &quot;
 149         &quot;this VirtualMachine (ObjectReferences, ReferenceTypes, etc.) &quot;
 150         &quot;will become invalid. &quot;
 151         (Out
 152         )
 153         (Reply
 154         )
 155         (ErrorSet
 156         )
 157     )
 158     (Command IDSizes=7
 159         &quot;Returns the sizes of variably-sized data types in the target VM.&quot;
 160         &quot;The returned values indicate the number of bytes used by the &quot;
 161         &quot;identifiers in command and reply packets.&quot;
 162         (Out
 163         )
 164         (Reply
 165             (int fieldIDSize &quot;fieldID size in bytes &quot;)
 166             (int methodIDSize &quot;methodID size in bytes &quot;)
 167             (int objectIDSize &quot;objectID size in bytes &quot;)
 168             (int referenceTypeIDSize &quot;referenceTypeID size in bytes &quot;)
 169             (int frameIDSize &quot;frameID size in bytes &quot;)
 170         )
 171         (ErrorSet
 172             (Error VM_DEAD)
 173         )
 174     )
 175     (Command Suspend=8
 176         &quot;Suspends the execution of the application running in the target &quot;
 177         &quot;VM. All Java threads currently running will be suspended. &quot;
 178         &quot;&lt;p&gt;&quot;
 179         &quot;Unlike java.lang.Thread.suspend, &quot;
 180         &quot;suspends of both the virtual machine and individual threads are &quot;
 181         &quot;counted. Before a thread will run again, it must be resumed through &quot;
 182         &quot;the &lt;a href=\&quot;#JDWP_VirtualMachine_Resume\&quot;&gt;VM-level resume&lt;/a&gt; command &quot;
 183         &quot;or the &lt;a href=\&quot;#JDWP_ThreadReference_Resume\&quot;&gt;thread-level resume&lt;/a&gt; command &quot;
 184         &quot;the same number of times it has been suspended. &quot;
 185         (Out
 186         )
 187         (Reply
 188         )
 189         (ErrorSet
 190             (Error VM_DEAD)
 191         )
 192     )
 193     (Command Resume=9
 194         &quot;Resumes execution of the application after the suspend &quot;
 195         &quot;command or an event has stopped it. &quot;
 196         &quot;Suspensions of the Virtual Machine and individual threads are &quot;
 197         &quot;counted. If a particular thread is suspended n times, it must &quot;
 198         &quot;resumed n times before it will continue. &quot;
 199         (Out
 200         )
 201         (Reply
 202         )
 203         (ErrorSet
 204         )
 205     )
 206     (Command Exit=10
 207         &quot;Terminates the target VM with the given exit code. &quot;
 208         &quot;On some platforms, the exit code might be truncated, for &quot;
 209         &quot;example, to the low order 8 bits. &quot;
 210         &quot;All ids previously returned from the target VM become invalid. &quot;
 211         &quot;Threads running in the VM are abruptly terminated. &quot;
 212         &quot;A thread death exception is not thrown and &quot;
 213         &quot;finally blocks are not run.&quot;
 214         (Out
 215             (int exitCode &quot;the exit code&quot;)
 216         )
 217         (Reply
 218         )
 219         (ErrorSet
 220         )
 221     )
 222     (Command CreateString=11
 223         &quot;Creates a new string object in the target VM and returns &quot;
 224         &quot;its id. &quot;
 225         (Out
 226             (string utf &quot;UTF-8 characters to use in the created string. &quot;)
 227         )
 228         (Reply
 229             (stringObject stringObject
 230                 &quot;Created string (instance of java.lang.String) &quot;)
 231         )
 232         (ErrorSet
 233             (Error VM_DEAD)
 234         )
 235     )
 236     (Command Capabilities=12
 237         &quot;Retrieve this VM&#39;s capabilities. The capabilities are returned &quot;
 238         &quot;as booleans, each indicating the presence or absence of a &quot;
 239         &quot;capability. The commands associated with each capability will &quot;
 240         &quot;return the NOT_IMPLEMENTED error if the cabability is not &quot;
 241         &quot;available.&quot;
 242         (Out
 243         )
 244         (Reply
 245             (boolean canWatchFieldModification
 246                      &quot;Can the VM watch field modification, and therefore &quot;
 247                      &quot;can it send the Modification Watchpoint Event?&quot;)
 248             (boolean canWatchFieldAccess
 249                      &quot;Can the VM watch field access, and therefore &quot;
 250                      &quot;can it send the Access Watchpoint Event?&quot;)
 251             (boolean canGetBytecodes
 252                      &quot;Can the VM get the bytecodes of a given method? &quot;)
 253             (boolean canGetSyntheticAttribute
 254                      &quot;Can the VM determine whether a field or method is &quot;
 255                      &quot;synthetic? (that is, can the VM determine if the &quot;
 256                      &quot;method or the field was invented by the compiler?) &quot;)
 257             (boolean canGetOwnedMonitorInfo
 258                      &quot;Can the VM get the owned monitors infornation for &quot;
 259                      &quot;a thread?&quot;)
 260             (boolean canGetCurrentContendedMonitor
 261                      &quot;Can the VM get the current contended monitor of a thread?&quot;)
 262             (boolean canGetMonitorInfo
 263                      &quot;Can the VM get the monitor information for a given object? &quot;)
 264         )
 265         (ErrorSet
 266             (Error VM_DEAD)
 267         )
 268     )
 269     (Command ClassPaths=13
 270         &quot;Retrieve the classpath and bootclasspath of the target VM. &quot;
 271         &quot;If the classpath is not defined, returns an empty list. If the &quot;
 272         &quot;bootclasspath is not defined returns an empty list.&quot;
 273         (Out
 274         )
 275         (Reply
 276             (string baseDir &quot;Base directory used to resolve relative &quot;
 277                             &quot;paths in either of the following lists.&quot;)
 278             (Repeat classpaths &quot;Number of paths in classpath.&quot;
 279                 (string path &quot;One component of classpath&quot;) )
 280             (Repeat bootclasspaths &quot;Number of paths in bootclasspath.&quot;
 281                 (string path &quot;One component of bootclasspath&quot;) )
 282         )
 283         (ErrorSet
 284             (Error VM_DEAD)
 285         )
 286     )
 287     (Command DisposeObjects=14
 288         &quot;Releases a list of object IDs. For each object in the list, the &quot;
 289         &quot;following applies. &quot;
 290         &quot;The count of references held by the back-end (the reference &quot;
 291         &quot;count) will be decremented by refCnt. &quot;
 292         &quot;If thereafter the reference count is less than &quot;
 293         &quot;or equal to zero, the ID is freed. &quot;
 294         &quot;Any back-end resources associated with the freed ID may &quot;
 295         &quot;be freed, and if garbage collection was &quot;
 296         &quot;disabled for the object, it will be re-enabled. &quot;
 297         &quot;The sender of this command &quot;
 298         &quot;promises that no further commands will be sent &quot;
 299         &quot;referencing a freed ID.
 300         &quot;&lt;p&gt;&quot;
 301         &quot;Use of this command is not required. If it is not sent, &quot;
 302         &quot;resources associated with each ID will be freed by the back-end &quot;
 303         &quot;at some time after the corresponding object is garbage collected. &quot;
 304         &quot;It is most useful to use this command to reduce the load on the &quot;
 305         &quot;back-end if a very large number of &quot;
 306         &quot;objects has been retrieved from the back-end (a large array, &quot;
 307         &quot;for example) but may not be garbage collected any time soon. &quot;
 308         &quot;&lt;p&gt;&quot;
 309         &quot;IDs may be re-used by the back-end after they &quot;
 310         &quot;have been freed with this command.&quot;
 311         &quot;This description assumes reference counting, &quot;
 312         &quot;a back-end may use any implementation which operates &quot;
 313         &quot;equivalently. &quot;
 314         (Out
 315             (Repeat requests &quot;Number of object dispose requests that follow&quot;
 316                 (Group Request
 317                     (object object &quot;The object ID&quot;)
 318                     (int refCnt &quot;The number of times this object ID has been &quot;
 319                                 &quot;part of a packet received from the back-end. &quot;
 320                                 &quot;An accurate count prevents the object ID &quot;
 321                                 &quot;from being freed on the back-end if &quot;
 322                                 &quot;it is part of an incoming packet, not yet &quot;
 323                                 &quot;handled by the front-end.&quot;)
 324                 )
 325             )
 326         )
 327         (Reply
 328         )
 329         (ErrorSet
 330         )
 331     )
 332     (Command HoldEvents=15
 333         &quot;Tells the target VM to stop sending events. Events are not discarded; &quot;
 334         &quot;they are held until a subsequent ReleaseEvents command is sent. &quot;
 335         &quot;This command is useful to control the number of events sent &quot;
 336         &quot;to the debugger VM in situations where very large numbers of events &quot;
 337         &quot;are generated. &quot;
 338         &quot;While events are held by the debugger back-end, application &quot;
 339         &quot;execution may be frozen by the debugger back-end to prevent &quot;
 340         &quot;buffer overflows on the back end.
 341         &quot;Responses to commands are never held and are not affected by this
 342         &quot;command. If events are already being held, this command is &quot;
 343         &quot;ignored.&quot;
 344         (Out
 345         )
 346         (Reply
 347         )
 348         (ErrorSet
 349         )
 350     )
 351     (Command ReleaseEvents=16
 352         &quot;Tells the target VM to continue sending events. This command is &quot;
 353         &quot;used to restore normal activity after a HoldEvents command. If &quot;
 354         &quot;there is no current HoldEvents command in effect, this command is &quot;
 355         &quot;ignored.&quot;
 356         (Out
 357         )
 358         (Reply
 359         )
 360         (ErrorSet
 361         )
 362     )
 363     (Command CapabilitiesNew=17
 364         &quot;Retrieve all of this VM&#39;s capabilities. The capabilities are returned &quot;
 365         &quot;as booleans, each indicating the presence or absence of a &quot;
 366         &quot;capability. The commands associated with each capability will &quot;
 367         &quot;return the NOT_IMPLEMENTED error if the cabability is not &quot;
 368         &quot;available.&quot;
 369         &quot;Since JDWP version 1.4.&quot;
 370         (Out
 371         )
 372         (Reply
 373             (boolean canWatchFieldModification
 374                      &quot;Can the VM watch field modification, and therefore &quot;
 375                      &quot;can it send the Modification Watchpoint Event?&quot;)
 376             (boolean canWatchFieldAccess
 377                      &quot;Can the VM watch field access, and therefore &quot;
 378                      &quot;can it send the Access Watchpoint Event?&quot;)
 379             (boolean canGetBytecodes
 380                      &quot;Can the VM get the bytecodes of a given method? &quot;)
 381             (boolean canGetSyntheticAttribute
 382                      &quot;Can the VM determine whether a field or method is &quot;
 383                      &quot;synthetic? (that is, can the VM determine if the &quot;
 384                      &quot;method or the field was invented by the compiler?) &quot;)
 385             (boolean canGetOwnedMonitorInfo
 386                      &quot;Can the VM get the owned monitors infornation for &quot;
 387                      &quot;a thread?&quot;)
 388             (boolean canGetCurrentContendedMonitor
 389                      &quot;Can the VM get the current contended monitor of a thread?&quot;)
 390             (boolean canGetMonitorInfo
 391                      &quot;Can the VM get the monitor information for a given object? &quot;)
 392             (boolean canRedefineClasses
 393                      &quot;Can the VM redefine classes?&quot;)
 394             (boolean canAddMethod
 395                      &quot;Can the VM add methods when redefining &quot;
 396                      &quot;classes?&quot;)
 397             (boolean canUnrestrictedlyRedefineClasses
 398                      &quot;Can the VM redefine classes &quot;
 399                      &quot;in ways that are normally restricted?&quot;)
 400             (boolean canPopFrames
 401                      &quot;Can the VM pop stack frames?&quot;)
 402             (boolean canUseInstanceFilters
 403                      &quot;Can the VM filter events by specific object?&quot;)
 404             (boolean canGetSourceDebugExtension
 405                      &quot;Can the VM get the source debug extension?&quot;)
 406             (boolean canRequestVMDeathEvent
 407                      &quot;Can the VM request VM death events?&quot;)
 408             (boolean canSetDefaultStratum
 409                      &quot;Can the VM set a default stratum?&quot;)
 410             (boolean canGetInstanceInfo
 411                      &quot;Can the VM return instances, counts of instances of classes &quot;
 412                      &quot;and referring objects?&quot;)
 413             (boolean canRequestMonitorEvents
 414                      &quot;Can the VM request monitor events?&quot;)
 415             (boolean canGetMonitorFrameInfo
 416                      &quot;Can the VM get monitors with frame depth info?&quot;)
 417             (boolean canUseSourceNameFilters
 418                      &quot;Can the VM filter class prepare events by source name?&quot;)
 419             (boolean canGetConstantPool
 420                      &quot;Can the VM return the constant pool information?&quot;)
 421             (boolean canForceEarlyReturn
 422                      &quot;Can the VM force early return from a method?&quot;)
 423             (boolean reserved22
 424                      &quot;Reserved for future capability&quot;)
 425             (boolean reserved23
 426                      &quot;Reserved for future capability&quot;)
 427             (boolean reserved24
 428                      &quot;Reserved for future capability&quot;)
 429             (boolean reserved25
 430                      &quot;Reserved for future capability&quot;)
 431             (boolean reserved26
 432                      &quot;Reserved for future capability&quot;)
 433             (boolean reserved27
 434                      &quot;Reserved for future capability&quot;)
 435             (boolean reserved28
 436                      &quot;Reserved for future capability&quot;)
 437             (boolean reserved29
 438                      &quot;Reserved for future capability&quot;)
 439             (boolean reserved30
 440                      &quot;Reserved for future capability&quot;)
 441             (boolean reserved31
 442                      &quot;Reserved for future capability&quot;)
 443             (boolean reserved32
 444                      &quot;Reserved for future capability&quot;)
 445         )
 446         (ErrorSet
 447             (Error VM_DEAD)
 448         )
 449     )
 450     (Command RedefineClasses=18
 451         &quot;Installs new class definitions. &quot;
 452         &quot;If there are active stack frames in methods of the redefined classes in the &quot;
 453         &quot;target VM then those active frames continue to run the bytecodes of the &quot;
 454         &quot;original method. These methods are considered obsolete - see &quot;
 455         &quot;&lt;a href=\&quot;#JDWP_Method_IsObsolete\&quot;&gt;IsObsolete&lt;/a&gt;. The methods in the &quot;
 456         &quot;redefined classes will be used for new invokes in the target VM. &quot;
 457         &quot;The original method ID refers to the redefined method. &quot;
 458         &quot;All breakpoints in the redefined classes are cleared.&quot;
 459         &quot;If resetting of stack frames is desired, the &quot;
 460         &quot;&lt;a href=\&quot;#JDWP_StackFrame_PopFrames\&quot;&gt;PopFrames&lt;/a&gt; command can be used &quot;
 461         &quot;to pop frames with obsolete methods.&quot;
 462         &quot;&lt;p&gt;&quot;
 463         &quot;Unless the canUnrestrictedlyRedefineClasses capability is present the following &quot;
 464         &quot;redefinitions are restricted: &quot;
 465         &quot;&lt;ul&gt;&quot;
 466         &quot;&lt;li&gt;changing the schema (the fields)&lt;/li&gt;&quot;
 467         &quot;&lt;li&gt;changing the hierarchy (superclasses, interfaces)&lt;/li&gt;&quot;
 468         &quot;&lt;li&gt;deleting a method&lt;/li&gt;&quot;
 469         &quot;&lt;li&gt;changing class modifiers&lt;/li&gt;&quot;
 470         &quot;&lt;li&gt;changing method modifiers&lt;/li&gt;&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 471         &quot;&lt;li&gt;changing the &lt;code&gt;NestHost&lt;/code&gt; or &lt;code&gt;NestMembers&lt;/code&gt; class attributes&lt;/li&gt;&quot;</span>
 472         &quot;&lt;/ul&gt;&quot;
 473         &quot;&lt;p&gt;&quot;
 474         &quot;Requires canRedefineClasses capability - see &quot;
 475         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
 476         &quot;In addition to the canRedefineClasses capability, the target VM must &quot;
 477         &quot;have the canAddMethod capability to add methods when redefining classes, &quot;
 478         &quot;or the canUnrestrictedlyRedefineClasses capability to redefine classes in ways &quot;
 479         &quot;that are normally restricted.&quot;
 480         (Out
 481             (Repeat classes &quot;Number of reference types that follow.&quot;
 482                 (Group ClassDef
 483                     (referenceType refType &quot;The reference type.&quot;)
 484                     (Repeat classfile &quot;Number of bytes defining class (below)&quot;
 485                          (byte classbyte &quot;byte in JVM class file &quot;
 486                                          &quot;format.&quot;)
 487                     )
 488                 )
 489             )
 490         )
 491         (Reply
 492         )
 493         (ErrorSet
 494             (Error INVALID_CLASS    &quot;One of the refTypes is not the ID of a reference &quot;
 495                                     &quot;type.&quot;)
 496             (Error INVALID_OBJECT   &quot;One of the refTypes is not a known ID.&quot;)
 497             (Error UNSUPPORTED_VERSION)
 498             (Error INVALID_CLASS_FORMAT)
 499             (Error CIRCULAR_CLASS_DEFINITION)
 500             (Error FAILS_VERIFICATION)
 501             (Error NAMES_DONT_MATCH)
 502             (Error NOT_IMPLEMENTED  &quot;No aspect of this functionality is implemented &quot;
 503                                     &quot;(CapabilitiesNew.canRedefineClasses is false)&quot;)
 504             (Error ADD_METHOD_NOT_IMPLEMENTED)
 505             (Error SCHEMA_CHANGE_NOT_IMPLEMENTED)
 506             (Error HIERARCHY_CHANGE_NOT_IMPLEMENTED)
 507             (Error DELETE_METHOD_NOT_IMPLEMENTED)
 508             (Error CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED)
 509             (Error METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED)
 510             (Error CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED)
 511             (Error VM_DEAD)
 512         )
 513     )
 514     (Command SetDefaultStratum=19
 515         &quot;Set the default stratum. Requires canSetDefaultStratum capability - see &quot;
 516         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
 517         (Out
 518             (string stratumID &quot;default stratum, or empty string to use &quot;
 519                               &quot;reference type default.&quot;)
 520         )
 521         (Reply
 522         )
 523         (ErrorSet
 524             (Error NOT_IMPLEMENTED)
 525             (Error VM_DEAD)
 526         )
 527     )
 528     (Command AllClassesWithGeneric=20
 529         &quot;Returns reference types for all classes currently loaded by the &quot;
 530         &quot;target VM.  &quot;
 531         &quot;Both the JNI signature and the generic signature are &quot;
 532         &quot;returned for each class.  &quot;
 533         &quot;Generic signatures are described in the signature attribute &quot;
 534         &quot;section in &quot;
 535         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 536         &quot;Since JDWP version 1.5.&quot;
 537         (Out
 538         )
 539         (Reply
 540             (Repeat classes &quot;Number of reference types that follow.&quot;
 541                 (Group ClassInfo
 542                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
 543                                       &quot;of following reference type. &quot;)
 544                     (referenceTypeID typeID &quot;Loaded reference type&quot;)
 545                     (string signature
 546                                 &quot;The JNI signature of the loaded reference type.&quot;)
 547                     (string genericSignature
 548                                 &quot;The generic signature of the loaded reference type &quot;
 549                                 &quot;or an empty string if there is none.&quot;)
 550                     (int status &quot;The current class &quot;
 551                                 &quot;&lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;status.&lt;/a&gt; &quot;)
 552                 )
 553             )
 554         )
 555         (ErrorSet
 556             (Error VM_DEAD)
 557         )
 558     )
 559 
 560     (Command InstanceCounts=21
 561         &quot;Returns the number of instances of each reference type in the input list. &quot;
 562         &quot;Only instances that are reachable for the purposes of &quot;
 563         &quot;garbage collection are counted.  If a reference type is invalid, &quot;
 564         &quot;eg. it has been unloaded, zero is returned for its instance count.&quot;
 565         &quot;&lt;p&gt;Since JDWP version 1.6. Requires canGetInstanceInfo capability - see &quot;
 566         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
 567         (Out
 568             (Repeat refTypesCount &quot;Number of reference types that follow.    Must be non-negative.&quot;
 569                 (referenceType refType &quot;A reference type ID.&quot;)
 570             )
 571           )
 572         (Reply
 573             (Repeat counts &quot;The number of counts that follow.&quot;
 574               (long instanceCount &quot;The number of instances for the corresponding reference type &quot;
 575                                   &quot;in &#39;Out Data&#39;.&quot;)
 576             )
 577         )
 578         (ErrorSet
 579             (Error ILLEGAL_ARGUMENT   &quot;refTypesCount is less than zero.&quot;)
 580             (Error NOT_IMPLEMENTED)
 581             (Error VM_DEAD)
 582         )
 583     )
 584     (Command AllModules=22
 585         &quot;Returns all modules in the target VM.&quot;
 586         &quot;&lt;p&gt;Since JDWP version 9.&quot;
 587         (Out
 588         )
 589         (Reply
 590             (Repeat modules &quot;The number of the modules that follow.&quot;
 591                 (moduleID module &quot;One of the modules.&quot;)
 592             )
 593         )
 594         (ErrorSet
 595             (Error NOT_IMPLEMENTED)
 596             (Error VM_DEAD)
 597         )
 598     )
 599 )
 600 
 601 (CommandSet ReferenceType=2
 602     (Command Signature=1
 603         &quot;Returns the JNI signature of a reference type. &quot;
 604         &quot;JNI signature formats are described in the &quot;
<a name="3" id="anc3"></a><span class="line-modified"> 605         &quot;&lt;a href=\&quot;http://java.sun.com/products/jdk/1.2/docs/guide/jni/index.html\&quot;&gt;Java Native Inteface Specification&lt;/a&gt;&quot;</span>
 606         &quot;&lt;p&gt;
 607         &quot;For primitive classes &quot;
 608         &quot;the returned signature is the signature of the corresponding primitive &quot;
 609         &quot;type; for example, \&quot;I\&quot; is returned as the signature of the class &quot;
 610         &quot;represented by java.lang.Integer.TYPE.&quot;
 611         (Out
 612             (referenceType refType &quot;The reference type ID.&quot;)
 613         )
 614         (Reply
 615             (string signature
 616                 &quot;The JNI signature for the reference type.&quot;)
 617         )
 618         (ErrorSet
 619             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 620                                      &quot;type.&quot;)
 621             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 622             (Error VM_DEAD)
 623         )
 624     )
 625     (Command ClassLoader=2
 626         &quot;Returns the instance of java.lang.ClassLoader which loaded &quot;
 627         &quot;a given reference type. If the reference type was loaded by the &quot;
 628         &quot;system class loader, the returned object ID is null.&quot;
 629         (Out
 630             (referenceType refType &quot;The reference type ID.&quot;)
 631         )
 632         (Reply
 633             (classLoaderObject classLoader &quot;The class loader for the reference type. &quot;)
 634         )
 635         (ErrorSet
 636             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 637                                      &quot;type.&quot;)
 638             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 639             (Error VM_DEAD)
 640         )
 641     )
 642     (Command Modifiers=3
 643         &quot;Returns the modifiers (also known as access flags) for a reference type. &quot;
 644         &quot;The returned bit mask contains information on the declaration &quot;
 645         &quot;of the reference type. If the reference type is an array or &quot;
 646         &quot;a primitive class (for example, java.lang.Integer.TYPE), the &quot;
 647         &quot;value of the returned bit mask is undefined.&quot;
 648         (Out
 649             (referenceType refType &quot;The reference type ID.&quot;)
 650         )
 651         (Reply
 652             (int modBits &quot;Modifier bits as defined in Chapter 4 of &quot;
 653                          &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;&quot;)
 654         )
 655         (ErrorSet
 656             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 657                                      &quot;type.&quot;)
 658             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 659             (Error VM_DEAD)
 660         )
 661     )
 662     (Command Fields=4
 663         &quot;Returns information for each field in a reference type. &quot;
 664         &quot;Inherited fields are not included. &quot;
 665         &quot;The field list will include any synthetic fields created &quot;
 666         &quot;by the compiler. &quot;
 667         &quot;Fields are returned in the order they occur in the class file.&quot;
 668         (Out
 669             (referenceType refType &quot;The reference type ID.&quot;)
 670         )
 671         (Reply
 672             (Repeat declared &quot;Number of declared fields.&quot;
 673                 (Group FieldInfo
 674                     (field fieldID &quot;Field ID.&quot;)
 675                     (string name &quot;Name of field.&quot;)
 676                     (string signature &quot;JNI Signature of field.&quot;)
 677                     (int modBits &quot;The modifier bit flags (also known as access flags) &quot;
 678                                  &quot;which provide additional information on the  &quot;
 679                                  &quot;field declaration. Individual flag values are &quot;
 680                                  &quot;defined in Chapter 4 of &quot;
 681                                  &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 682                                  &quot;In addition, The &lt;code&gt;0xf0000000&lt;/code&gt; bit identifies &quot;
 683                                  &quot;the field as synthetic, if the synthetic attribute &quot;
 684                                  &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Capabilities\&quot;&gt;capability&lt;/a&gt; is available.&quot;)
 685                 )
 686             )
 687         )
 688         (ErrorSet
 689             (Error CLASS_NOT_PREPARED)
 690             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 691                                      &quot;type.&quot;)
 692             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 693             (Error VM_DEAD)
 694         )
 695     )
 696     (Command Methods=5
 697         &quot;Returns information for each method in a reference type. &quot;
 698         &quot;Inherited methods are not included. The list of methods will &quot;
 699         &quot;include constructors (identified with the name \&quot;&amp;lt;init&amp;gt;\&quot;), &quot;
 700         &quot;the initialization method (identified with the name \&quot;&amp;lt;clinit&amp;gt;\&quot;) &quot;
 701         &quot;if present, and any synthetic methods created by the compiler. &quot;
 702         &quot;Methods are returned in the order they occur in the class file.&quot;
 703         (Out
 704             (referenceType refType &quot;The reference type ID.&quot;)
 705         )
 706         (Reply
 707             (Repeat declared &quot;Number of declared methods.&quot;
 708                 (Group MethodInfo
 709                     (method methodID &quot;Method ID.&quot;)
 710                     (string name &quot;Name of method.&quot;)
 711                     (string signature &quot;JNI signature of method.&quot;)
 712                     (int modBits &quot;The modifier bit flags (also known as access flags) &quot;
 713                                  &quot;which provide additional information on the  &quot;
 714                                  &quot;method declaration. Individual flag values are &quot;
 715                                  &quot;defined in Chapter 4 of &quot;
 716                                  &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 717                                  &quot;In addition, The &lt;code&gt;0xf0000000&lt;/code&gt; bit identifies &quot;
 718                                  &quot;the method as synthetic, if the synthetic attribute &quot;
 719                                  &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Capabilities\&quot;&gt;capability&lt;/a&gt; is available.&quot;)
 720                 )
 721             )
 722         )
 723         (ErrorSet
 724             (Error CLASS_NOT_PREPARED)
 725             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 726                                      &quot;type.&quot;)
 727             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 728             (Error VM_DEAD)
 729         )
 730     )
 731     (Command GetValues=6
 732         &quot;Returns the value of one or more static fields of the &quot;
 733         &quot;reference type. Each field must be member of the reference type &quot;
 734         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
 735         &quot;Access control is not enforced; for example, the values of private &quot;
 736         &quot;fields can be obtained.&quot;
 737         (Out
 738             (referenceType refType &quot;The reference type ID.&quot;)
 739             (Repeat fields &quot;The number of values to get&quot;
 740                 (Group Field
 741                     (field fieldID &quot;A field to get&quot;)
 742                 )
 743             )
 744         )
 745         (Reply
 746             (Repeat values &quot;The number of values returned, always equal to fields, &quot;
 747                            &quot;the number of values to get.&quot;
 748                 (value value &quot;The field value&quot;)
 749             )
 750         )
 751         (ErrorSet
 752             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 753                                      &quot;type.&quot;)
 754             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 755             (Error INVALID_FIELDID)
 756             (Error VM_DEAD)
 757         )
 758     )
 759     (Command SourceFile=7
 760         &quot;Returns the name of source file in which a reference type was &quot;
 761         &quot;declared. &quot;
 762         (Out
 763             (referenceType refType &quot;The reference type ID.&quot;)
 764         )
 765         (Reply
 766             (string sourceFile &quot;The source file name. No path information &quot;
 767                                &quot;for the file is included&quot;)
 768         )
 769         (ErrorSet
 770             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 771                                      &quot;type.&quot;)
 772             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 773             (Error ABSENT_INFORMATION &quot;The source file attribute is absent.&quot;)
 774             (Error VM_DEAD)
 775         )
 776     )
 777     (Command NestedTypes=8
 778         &quot;Returns the classes and interfaces directly nested within this type.&quot;
 779         &quot;Types further nested within those types are not included. &quot;
 780         (Out
 781             (referenceType refType &quot;The reference type ID.&quot;)
 782         )
 783         (Reply
 784             (Repeat classes &quot;The number of nested classes and interfaces&quot;
 785                 (Group TypeInfo
 786                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
 787                                       &quot;of following reference type. &quot;)
 788                     (referenceTypeID typeID &quot;The nested class or interface ID.&quot;)
 789                 )
 790             )
 791         )
 792         (ErrorSet
 793             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 794                                      &quot;type.&quot;)
 795             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 796             (Error VM_DEAD)
 797         )
 798     )
 799     (Command Status=9
 800         &quot;Returns the current status of the reference type. The status &quot;
 801         &quot;indicates the extent to which the reference type has been &quot;
 802         &quot;initialized, as described in section 2.1.6 of &quot;
 803         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 804         &quot;If the class is linked the PREPARED and VERIFIED bits in the returned status bits &quot;
 805         &quot;will be set. If the class is initialized the INITIALIZED bit in the returned &quot;
 806         &quot;status bits will be set. If an error occured during initialization then the &quot;
 807         &quot;ERROR bit in the returned status bits will be set. &quot;
 808         &quot;The returned status bits are undefined for array types and for &quot;
 809         &quot;primitive classes (such as java.lang.Integer.TYPE). &quot;
 810         (Out
 811             (referenceType refType &quot;The reference type ID.&quot;)
 812         )
 813         (Reply
 814             (int status &quot;&lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;Status&lt;/a&gt; bits:&quot;
 815                         &quot;See &lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;JDWP.ClassStatus&lt;/a&gt;&quot;)
 816         )
 817         (ErrorSet
 818             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 819                                      &quot;type.&quot;)
 820             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 821             (Error VM_DEAD)
 822         )
 823     )
 824     (Command Interfaces=10
 825         &quot;Returns the interfaces declared as implemented by this class. &quot;
 826         &quot;Interfaces indirectly implemented (extended by the implemented &quot;
 827         &quot;interface or implemented by a superclass) are not included.&quot;
 828         (Out
 829             (referenceType refType &quot;The reference type ID.&quot;)
 830         )
 831         (Reply
 832             (Repeat interfaces &quot;The number of implemented interfaces&quot;
 833                 (interfaceType interfaceType &quot;implemented interface.&quot;)
 834             )
 835         )
 836         (ErrorSet
 837             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 838                                      &quot;type.&quot;)
 839             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 840             (Error VM_DEAD)
 841         )
 842     )
 843     (Command ClassObject=11
 844         &quot;Returns the class object corresponding to this type. &quot;
 845         (Out
 846             (referenceType refType &quot;The reference type ID.&quot;)
 847         )
 848         (Reply
 849             (classObject classObject &quot;class object.&quot;)
 850         )
 851         (ErrorSet
 852             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 853                                      &quot;type.&quot;)
 854             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 855             (Error VM_DEAD)
 856         )
 857     )
 858     (Command SourceDebugExtension=12
 859         &quot;Returns the value of the SourceDebugExtension attribute. &quot;
 860         &quot;Since JDWP version 1.4. Requires canGetSourceDebugExtension capability - see &quot;
 861         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
 862         (Out
 863             (referenceType refType &quot;The reference type ID.&quot;)
 864         )
 865         (Reply
 866             (string extension &quot;extension attribute&quot;)
 867         )
 868         (ErrorSet
 869             (Error INVALID_CLASS      &quot;refType is not the ID of a reference &quot;
 870                                       &quot;type.&quot;)
 871             (Error INVALID_OBJECT     &quot;refType is not a known ID.&quot;)
 872             (Error ABSENT_INFORMATION &quot;If the extension is not specified.&quot;)
 873             (Error NOT_IMPLEMENTED)
 874             (Error VM_DEAD)
 875         )
 876     )
 877     (Command SignatureWithGeneric=13
 878         &quot;Returns the JNI signature of a reference type along with the &quot;
 879         &quot;generic signature if there is one.  &quot;
 880         &quot;Generic signatures are described in the signature attribute &quot;
 881         &quot;section in &quot;
 882         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 883         &quot;Since JDWP version 1.5.&quot;
 884         (Out
 885             (referenceType refType &quot;The reference type ID.&quot;)
 886         )
 887         (Reply
 888             (string signature
 889                 &quot;The JNI signature for the reference type.&quot;)
 890             (string genericSignature
 891                 &quot;The generic signature for the reference type or an empty &quot;
 892                 &quot;string if there is none.&quot;)
 893         )
 894         (ErrorSet
 895             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 896                                      &quot;type.&quot;)
 897             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 898             (Error VM_DEAD)
 899         )
 900     )
 901     (Command FieldsWithGeneric=14
 902         &quot;Returns information, including the generic signature if any, &quot;
 903         &quot;for each field in a reference type. &quot;
 904         &quot;Inherited fields are not included. &quot;
 905         &quot;The field list will include any synthetic fields created &quot;
 906         &quot;by the compiler. &quot;
 907         &quot;Fields are returned in the order they occur in the class file.  &quot;
 908         &quot;Generic signatures are described in the signature attribute &quot;
 909         &quot;section in &quot;
 910         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 911         &quot;Since JDWP version 1.5.&quot;
 912         (Out
 913             (referenceType refType &quot;The reference type ID.&quot;)
 914         )
 915         (Reply
 916             (Repeat declared &quot;Number of declared fields.&quot;
 917                 (Group FieldInfo
 918                     (field fieldID &quot;Field ID.&quot;)
 919                     (string name &quot;The name of the field.&quot;)
 920                     (string signature &quot;The JNI signature of the field.&quot;)
 921                     (string genericSignature &quot;The generic signature of the &quot;
 922                                              &quot;field, or an empty string if there is none.&quot;)
 923                     (int modBits &quot;The modifier bit flags (also known as access flags) &quot;
 924                                  &quot;which provide additional information on the  &quot;
 925                                  &quot;field declaration. Individual flag values are &quot;
 926                                  &quot;defined in Chapter 4 of &quot;
 927                                  &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 928                                  &quot;In addition, The &lt;code&gt;0xf0000000&lt;/code&gt; bit identifies &quot;
 929                                  &quot;the field as synthetic, if the synthetic attribute &quot;
 930                                  &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Capabilities\&quot;&gt;capability&lt;/a&gt; is available.&quot;)
 931                 )
 932             )
 933         )
 934         (ErrorSet
 935             (Error CLASS_NOT_PREPARED)
 936             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 937                                      &quot;type.&quot;)
 938             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 939             (Error VM_DEAD)
 940         )
 941     )
 942     (Command MethodsWithGeneric=15
 943         &quot;Returns information, including the generic signature if any, &quot;
 944         &quot;for each method in a reference type. &quot;
 945         &quot;Inherited methodss are not included. The list of methods will &quot;
 946         &quot;include constructors (identified with the name \&quot;&amp;lt;init&amp;gt;\&quot;), &quot;
 947         &quot;the initialization method (identified with the name \&quot;&amp;lt;clinit&amp;gt;\&quot;) &quot;
 948         &quot;if present, and any synthetic methods created by the compiler. &quot;
 949         &quot;Methods are returned in the order they occur in the class file.  &quot;
 950         &quot;Generic signatures are described in the signature attribute &quot;
 951         &quot;section in &quot;
 952         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 953         &quot;Since JDWP version 1.5.&quot;
 954         (Out
 955             (referenceType refType &quot;The reference type ID.&quot;)
 956         )
 957         (Reply
 958             (Repeat declared &quot;Number of declared methods.&quot;
 959                 (Group MethodInfo
 960                     (method methodID &quot;Method ID.&quot;)
 961                     (string name &quot;The name of the method.&quot;)
 962                     (string signature &quot;The JNI signature of the method.&quot;)
 963                     (string genericSignature &quot;The generic signature of the method, or &quot;
 964                                              &quot;an empty string if there is none.&quot;)
 965                     (int modBits &quot;The modifier bit flags (also known as access flags) &quot;
 966                                  &quot;which provide additional information on the  &quot;
 967                                  &quot;method declaration. Individual flag values are &quot;
 968                                  &quot;defined in Chapter 4 of &quot;
 969                                  &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 970                                  &quot;In addition, The &lt;code&gt;0xf0000000&lt;/code&gt; bit identifies &quot;
 971                                  &quot;the method as synthetic, if the synthetic attribute &quot;
 972                                  &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Capabilities\&quot;&gt;capability&lt;/a&gt; is available.&quot;)
 973                 )
 974             )
 975         )
 976         (ErrorSet
 977             (Error CLASS_NOT_PREPARED)
 978             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 979                                      &quot;type.&quot;)
 980             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 981             (Error VM_DEAD)
 982         )
 983     )
 984     (Command Instances=16
 985         &quot;Returns instances of this reference type. &quot;
 986         &quot;Only instances that are reachable for the purposes of &quot;
 987         &quot;garbage collection are returned. &quot;
 988         &quot;&lt;p&gt;Since JDWP version 1.6. Requires canGetInstanceInfo capability - see &quot;
 989         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
 990         (Out
 991             (referenceType refType &quot;The reference type ID.&quot;)
 992             (int maxInstances &quot;Maximum number of instances to return.  Must be non-negative. &quot;
 993                               &quot;If zero, all instances are returned.&quot;)
 994         )
 995         (Reply
 996             (Repeat instances &quot;The number of instances that follow.&quot;
 997                  (tagged-object instance &quot;An instance of this reference type.&quot;)
 998              )
 999         )
1000         (ErrorSet
1001             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1002                                      &quot;type.&quot;)
1003             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1004             (Error ILLEGAL_ARGUMENT  &quot;maxInstances is less than zero.&quot;)
1005             (Error NOT_IMPLEMENTED)
1006             (Error VM_DEAD)
1007         )
1008     )
1009     (Command ClassFileVersion=17
1010         &quot;Returns the class file major and minor version numbers, as defined in the class &quot;
1011         &quot;file format of the Java Virtual Machine specification. &quot;
1012          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
1013         (Out
1014             (referenceType refType &quot;The class.&quot;)
1015         )
1016         (Reply
1017             (int majorVersion &quot;Major version number&quot;)
1018             (int minorVersion &quot;Minor version number&quot;)
1019         )
1020         (ErrorSet
1021             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1022                                      &quot;type.&quot;)
1023             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1024             (Error ABSENT_INFORMATION &quot;The class file version information is &quot;
1025                                       &quot;absent for primitive and array types.&quot;)
1026             (Error VM_DEAD)
1027         )
1028     )
1029     (Command ConstantPool=18
1030         &quot;Return the raw bytes of the constant pool in the format of the &quot;
1031         &quot;constant_pool item of the Class File Format in &quot;
1032         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
1033         &quot;&lt;p&gt;Since JDWP version 1.6. Requires canGetConstantPool capability - see &quot;
1034         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;&quot;
1035         (Out
1036             (referenceType refType &quot;The class.&quot;)
1037         )
1038         (Reply
1039             (int count &quot;Total number of constant pool entries plus one. This &quot;
1040                        &quot;corresponds to the constant_pool_count item of the &quot;
1041                        &quot;Class File Format in &quot;
1042                        &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;)
1043             (Repeat bytes
1044                 (byte cpbytes &quot;Raw bytes of constant pool&quot;)
1045             )
1046         )
1047         (ErrorSet
1048             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1049                                      &quot;type.&quot;)
1050             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1051             (Error NOT_IMPLEMENTED   &quot;If the target virtual machine does not &quot;
1052                                      &quot;support the retrieval of constant pool information.&quot;)
1053             (Error ABSENT_INFORMATION &quot;The Constant Pool information is &quot;
1054                                       &quot;absent for primitive and array types.&quot;)
1055             (Error VM_DEAD)
1056         )
1057     )
1058     (Command Module=19
1059         &quot;Returns the module that this reference type belongs to.&quot;
1060         &quot;&lt;p&gt;Since JDWP version 9.&quot;
1061         (Out
1062             (referenceType refType &quot;The reference type.&quot;)
1063         )
1064         (Reply
1065             (moduleID module &quot;The module this reference type belongs to.&quot;)
1066         )
1067         (ErrorSet
1068             (Error INVALID_CLASS   &quot;refType is not the ID of a reference type.&quot;)
1069             (Error INVALID_OBJECT  &quot;refType is not a known ID.&quot;)
1070             (Error NOT_IMPLEMENTED)
1071             (Error VM_DEAD)
1072         )
1073     )
1074 )
1075 (CommandSet ClassType=3
1076     (Command Superclass=1
1077         &quot;Returns the immediate superclass of a class.&quot;
1078         (Out
1079             (classType clazz &quot;The class type ID.&quot;)
1080         )
1081         (Reply
1082             (classType superclass
1083                 &quot;The superclass (null if the class ID for java.lang.Object is specified).&quot;)
1084         )
1085         (ErrorSet
1086             (Error INVALID_CLASS     &quot;clazz is not the ID of a class.&quot;)
1087             (Error INVALID_OBJECT    &quot;clazz is not a known ID.&quot;)
1088             (Error VM_DEAD)
1089         )
1090     )
1091     (Command SetValues=2
1092         &quot;Sets the value of one or more static fields. &quot;
1093         &quot;Each field must be member of the class type &quot;
1094         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
1095         &quot;Access control is not enforced; for example, the values of private &quot;
1096         &quot;fields can be set. Final fields cannot be set.&quot;
1097         &quot;For primitive values, the value&#39;s type must match the &quot;
1098         &quot;field&#39;s type exactly. For object values, there must exist a &quot;
1099         &quot;widening reference conversion from the value&#39;s type to the
1100         &quot;field&#39;s type and the field&#39;s type must be loaded. &quot;
1101         (Out
1102             (classType clazz &quot;The class type ID.&quot;)
1103             (Repeat values &quot;The number of fields to set.&quot;
1104                 (Group FieldValue &quot;A Field/Value pair.&quot;
1105                     (field fieldID &quot;Field to set.&quot;)
1106                     (untagged-value value &quot;Value to put in the field.&quot;)
1107                 )
1108             )
1109         )
1110         (Reply &quot;none&quot;
1111         )
1112         (ErrorSet
1113             (Error INVALID_CLASS     &quot;clazz is not the ID of a class.&quot;)
1114             (Error CLASS_NOT_PREPARED)
1115             (Error INVALID_OBJECT    &quot;clazz is not a known ID or a value of an &quot;
1116                                      &quot;object field is not a known ID.&quot;)
1117             (Error INVALID_FIELDID)
1118             (Error VM_DEAD)
1119         )
1120     )
1121     (Command InvokeMethod=3
1122         &quot;Invokes a static method. &quot;
1123         &quot;The method must be member of the class type &quot;
1124         &quot;or one of its superclasses. &quot;
1125         &quot;Access control is not enforced; for example, private &quot;
1126         &quot;methods can be invoked.&quot;
1127         &quot;&lt;p&gt;&quot;
1128         &quot;The method invocation will occur in the specified thread. &quot;
1129         &quot;Method invocation can occur only if the specified thread &quot;
1130         &quot;has been suspended by an event. &quot;
1131         &quot;Method invocation is not supported &quot;
1132         &quot;when the target VM has been suspended by the front-end. &quot;
1133         &quot;&lt;p&gt;&quot;
1134         &quot;The specified method is invoked with the arguments in the specified &quot;
1135         &quot;argument list. &quot;
1136         &quot;The method invocation is synchronous; the reply packet is not &quot;
1137         &quot;sent until the invoked method returns in the target VM. &quot;
1138         &quot;The return value (possibly the void value) is &quot;
1139         &quot;included in the reply packet. &quot;
1140         &quot;If the invoked method throws an exception, the &quot;
1141         &quot;exception object ID is set in the reply packet; otherwise, the &quot;
1142         &quot;exception object ID is null. &quot;
1143         &quot;&lt;p&gt;&quot;
1144         &quot;For primitive arguments, the argument value&#39;s type must match the &quot;
1145         &quot;argument&#39;s type exactly. For object arguments, there must exist a &quot;
1146         &quot;widening reference conversion from the argument value&#39;s type to the &quot;
1147         &quot;argument&#39;s type and the argument&#39;s type must be loaded. &quot;
1148         &quot;&lt;p&gt;&quot;
1149         &quot;By default, all threads in the target VM are resumed while &quot;
1150         &quot;the method is being invoked if they were previously &quot;
1151         &quot;suspended by an event or by command. &quot;
1152         &quot;This is done to prevent the deadlocks &quot;
1153         &quot;that will occur if any of the threads own monitors &quot;
1154         &quot;that will be needed by the invoked method. It is possible that &quot;
1155         &quot;breakpoints or other events might occur during the invocation. &quot;
1156         &quot;Note, however, that this implicit resume acts exactly like &quot;
1157         &quot;the ThreadReference resume command, so if the thread&#39;s suspend &quot;
1158         &quot;count is greater than 1, it will remain in a suspended state &quot;
1159         &quot;during the invocation. By default, when the invocation completes, &quot;
1160         &quot;all threads in the target VM are suspended, regardless their state &quot;
1161         &quot;before the invocation. &quot;
1162         &quot;&lt;p&gt;&quot;
1163         &quot;The resumption of other threads during the invoke can be prevented &quot;
1164         &quot;by specifying the INVOKE_SINGLE_THREADED &quot;
1165         &quot;bit flag in the &lt;code&gt;options&lt;/code&gt; field; however, &quot;
1166         &quot;there is no protection against or recovery from the deadlocks &quot;
1167         &quot;described above, so this option should be used with great caution. &quot;
1168         &quot;Only the specified thread will be resumed (as described for all &quot;
1169         &quot;threads above). Upon completion of a single threaded invoke, the invoking thread &quot;
1170         &quot;will be suspended once again. Note that any threads started during &quot;
1171         &quot;the single threaded invocation will not be suspended when the &quot;
1172         &quot;invocation completes. &quot;
1173         &quot;&lt;p&gt;&quot;
1174         &quot;If the target VM is disconnected during the invoke (for example, through &quot;
1175         &quot;the VirtualMachine dispose command) the method invocation continues. &quot;
1176         (Out
1177             (classType clazz &quot;The class type ID.&quot;)
1178             (threadObject thread &quot;The thread in which to invoke.&quot;)
1179             (method methodID &quot;The method to invoke.&quot;)
1180             (Repeat arguments
1181                 (value arg &quot;The argument value.&quot;)
1182             )
1183             (int options &quot;Invocation &lt;a href=\&quot;#JDWP_InvokeOptions\&quot;&gt;options&lt;/a&gt;&quot;)
1184         )
1185         (Reply
1186             (value returnValue &quot;The returned value.&quot;)
1187             (tagged-object exception &quot;The thrown exception.&quot;)
1188         )
1189         (ErrorSet
1190             (Error INVALID_CLASS     &quot;clazz is not the ID of a class.&quot;)
1191             (Error INVALID_OBJECT    &quot;clazz is not a known ID.&quot;)
1192             (Error INVALID_METHODID  &quot;methodID is not the ID of a static method in &quot;
1193                                      &quot;this class type or one of its superclasses.&quot;)
1194             (Error INVALID_THREAD)
1195             (Error THREAD_NOT_SUSPENDED)
1196             (Error VM_DEAD)
1197         )
1198     )
1199     (Command NewInstance=4
1200         &quot;Creates a new object of this type, invoking the specified &quot;
1201         &quot;constructor. The constructor method ID must be a member of &quot;
1202         &quot;the class type.&quot;
1203         &quot;&lt;p&gt;&quot;
1204         &quot;Instance creation will occur in the specified thread. &quot;
1205         &quot;Instance creation can occur only if the specified thread &quot;
1206         &quot;has been suspended by an event. &quot;
1207         &quot;Method invocation is not supported &quot;
1208         &quot;when the target VM has been suspended by the front-end. &quot;
1209         &quot;&lt;p&gt;&quot;
1210         &quot;The specified constructor is invoked with the arguments in the specified &quot;
1211         &quot;argument list. &quot;
1212         &quot;The constructor invocation is synchronous; the reply packet is not &quot;
1213         &quot;sent until the invoked method returns in the target VM. &quot;
1214         &quot;The return value (possibly the void value) is &quot;
1215         &quot;included in the reply packet. &quot;
1216         &quot;If the constructor throws an exception, the &quot;
1217         &quot;exception object ID is set in the reply packet; otherwise, the &quot;
1218         &quot;exception object ID is null. &quot;
1219         &quot;&lt;p&gt;&quot;
1220         &quot;For primitive arguments, the argument value&#39;s type must match the &quot;
1221         &quot;argument&#39;s type exactly. For object arguments, there must exist a &quot;
1222         &quot;widening reference conversion from the argument value&#39;s type to the &quot;
1223         &quot;argument&#39;s type and the argument&#39;s type must be loaded. &quot;
1224         &quot;&lt;p&gt;&quot;
1225         &quot;By default, all threads in the target VM are resumed while &quot;
1226         &quot;the method is being invoked if they were previously &quot;
1227         &quot;suspended by an event or by command. &quot;
1228         &quot;This is done to prevent the deadlocks &quot;
1229         &quot;that will occur if any of the threads own monitors &quot;
1230         &quot;that will be needed by the invoked method. It is possible that &quot;
1231         &quot;breakpoints or other events might occur during the invocation. &quot;
1232         &quot;Note, however, that this implicit resume acts exactly like &quot;
1233         &quot;the ThreadReference resume command, so if the thread&#39;s suspend &quot;
1234         &quot;count is greater than 1, it will remain in a suspended state &quot;
1235         &quot;during the invocation. By default, when the invocation completes, &quot;
1236         &quot;all threads in the target VM are suspended, regardless their state &quot;
1237         &quot;before the invocation. &quot;
1238         &quot;&lt;p&gt;&quot;
1239         &quot;The resumption of other threads during the invoke can be prevented &quot;
1240         &quot;by specifying the INVOKE_SINGLE_THREADED &quot;
1241         &quot;bit flag in the &lt;code&gt;options&lt;/code&gt; field; however, &quot;
1242         &quot;there is no protection against or recovery from the deadlocks &quot;
1243         &quot;described above, so this option should be used with great caution. &quot;
1244         &quot;Only the specified thread will be resumed (as described for all &quot;
1245         &quot;threads above). Upon completion of a single threaded invoke, the invoking thread &quot;
1246         &quot;will be suspended once again. Note that any threads started during &quot;
1247         &quot;the single threaded invocation will not be suspended when the &quot;
1248         &quot;invocation completes. &quot;
1249         &quot;&lt;p&gt;&quot;
1250         &quot;If the target VM is disconnected during the invoke (for example, through &quot;
1251         &quot;the VirtualMachine dispose command) the method invocation continues. &quot;
1252         (Out
1253             (classType clazz &quot;The class type ID.&quot;)
1254             (threadObject thread &quot;The thread in which to invoke the constructor.&quot;)
1255             (method methodID &quot;The constructor to invoke.&quot;)
1256             (Repeat arguments
1257                 (value arg &quot;The argument value.&quot;)
1258             )
1259             (int options &quot;Constructor invocation &lt;a href=\&quot;#JDWP_InvokeOptions\&quot;&gt;options&lt;/a&gt;&quot;)
1260         )
1261         (Reply
1262             (tagged-object newObject &quot;The newly created object, or null &quot;
1263                                      &quot;if the constructor threw an exception.&quot;)
1264             (tagged-object exception &quot;The thrown exception, if any; otherwise, null.&quot;)
1265         )
1266         (ErrorSet
1267             (Error INVALID_CLASS     &quot;clazz is not the ID of a class.&quot;)
1268             (Error INVALID_OBJECT    &quot;clazz is not a known ID or a value of an &quot;
1269                                      &quot;object parameter is not a known ID..&quot;)
1270             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1271             (Error INVALID_OBJECT)
1272             (Error INVALID_THREAD)
1273             (Error THREAD_NOT_SUSPENDED)
1274             (Error VM_DEAD)
1275         )
1276     )
1277 )
1278 (CommandSet ArrayType=4
1279     (Command NewInstance=1
1280         &quot;Creates a new array object of this type with a given length.&quot;
1281         (Out
1282             (arrayType arrType &quot;The array type of the new instance.&quot;)
1283             (int length &quot;The length of the array.&quot;)
1284         )
1285         (Reply
1286             (tagged-object newArray &quot;The newly created array object. &quot;)
1287         )
1288         (ErrorSet
1289             (Error INVALID_ARRAY)
1290             (Error INVALID_OBJECT)
1291             (Error VM_DEAD)
1292         )
1293     )
1294 )
1295 (CommandSet InterfaceType=5
1296     (Command InvokeMethod=1
1297         &quot;Invokes a static method. &quot;
1298         &quot;The method must not be a static initializer. &quot;
1299         &quot;The method must be a member of the interface type. &quot;
1300         &quot;&lt;p&gt;Since JDWP version 1.8 &quot;
1301         &quot;&lt;p&gt;&quot;
1302         &quot;The method invocation will occur in the specified thread. &quot;
1303         &quot;Method invocation can occur only if the specified thread &quot;
1304         &quot;has been suspended by an event. &quot;
1305         &quot;Method invocation is not supported &quot;
1306         &quot;when the target VM has been suspended by the front-end. &quot;
1307         &quot;&lt;p&gt;&quot;
1308         &quot;The specified method is invoked with the arguments in the specified &quot;
1309         &quot;argument list. &quot;
1310         &quot;The method invocation is synchronous; the reply packet is not &quot;
1311         &quot;sent until the invoked method returns in the target VM. &quot;
1312         &quot;The return value (possibly the void value) is &quot;
1313         &quot;included in the reply packet. &quot;
1314         &quot;If the invoked method throws an exception, the &quot;
1315         &quot;exception object ID is set in the reply packet; otherwise, the &quot;
1316         &quot;exception object ID is null. &quot;
1317         &quot;&lt;p&gt;&quot;
1318         &quot;For primitive arguments, the argument value&#39;s type must match the &quot;
1319         &quot;argument&#39;s type exactly. For object arguments, there must exist a &quot;
1320         &quot;widening reference conversion from the argument value&#39;s type to the &quot;
1321         &quot;argument&#39;s type and the argument&#39;s type must be loaded. &quot;
1322         &quot;&lt;p&gt;&quot;
1323         &quot;By default, all threads in the target VM are resumed while &quot;
1324         &quot;the method is being invoked if they were previously &quot;
1325         &quot;suspended by an event or by a command. &quot;
1326         &quot;This is done to prevent the deadlocks &quot;
1327         &quot;that will occur if any of the threads own monitors &quot;
1328         &quot;that will be needed by the invoked method. It is possible that &quot;
1329         &quot;breakpoints or other events might occur during the invocation. &quot;
1330         &quot;Note, however, that this implicit resume acts exactly like &quot;
1331         &quot;the ThreadReference resume command, so if the thread&#39;s suspend &quot;
1332         &quot;count is greater than 1, it will remain in a suspended state &quot;
1333         &quot;during the invocation. By default, when the invocation completes, &quot;
1334         &quot;all threads in the target VM are suspended, regardless their state &quot;
1335         &quot;before the invocation. &quot;
1336         &quot;&lt;p&gt;&quot;
1337         &quot;The resumption of other threads during the invoke can be prevented &quot;
1338         &quot;by specifying the INVOKE_SINGLE_THREADED &quot;
1339         &quot;bit flag in the &lt;code&gt;options&lt;/code&gt; field; however, &quot;
1340         &quot;there is no protection against or recovery from the deadlocks &quot;
1341         &quot;described above, so this option should be used with great caution. &quot;
1342         &quot;Only the specified thread will be resumed (as described for all &quot;
1343         &quot;threads above). Upon completion of a single threaded invoke, the invoking thread &quot;
1344         &quot;will be suspended once again. Note that any threads started during &quot;
1345         &quot;the single threaded invocation will not be suspended when the &quot;
1346         &quot;invocation completes. &quot;
1347         &quot;&lt;p&gt;&quot;
1348         &quot;If the target VM is disconnected during the invoke (for example, through &quot;
1349         &quot;the VirtualMachine dispose command) the method invocation continues. &quot;
1350         (Out
1351             (interfaceType clazz &quot;The interface type ID.&quot;)
1352             (threadObject thread &quot;The thread in which to invoke.&quot;)
1353             (method methodID &quot;The method to invoke.&quot;)
1354             (Repeat arguments
1355                 (value arg &quot;The argument value.&quot;)
1356             )
1357             (int options &quot;Invocation &lt;a href=\&quot;#JDWP_InvokeOptions\&quot;&gt;options&lt;/a&gt;&quot;)
1358         )
1359         (Reply
1360             (value returnValue &quot;The returned value.&quot;)
1361             (tagged-object exception &quot;The thrown exception.&quot;)
1362         )
1363         (ErrorSet
1364             (Error INVALID_CLASS     &quot;clazz is not the ID of an interface.&quot;)
1365             (Error INVALID_OBJECT    &quot;clazz is not a known ID.&quot;)
1366             (Error INVALID_METHODID  &quot;methodID is not the ID of a static method in this &quot;
1367                                      &quot;interface type or is the ID of a static initializer.&quot;)
1368             (Error INVALID_THREAD)
1369             (Error THREAD_NOT_SUSPENDED)
1370             (Error VM_DEAD)
1371         )
1372     )
1373 )
1374 (CommandSet Method=6
1375     (Command LineTable=1
1376         &quot;Returns line number information for the method, if present. &quot;
1377         &quot;The line table maps source line numbers to the initial code index &quot;
1378         &quot;of the line. The line table &quot;
1379         &quot;is ordered by code index (from lowest to highest). The line number &quot;
1380         &quot;information is constant unless a new class definition is installed &quot;
1381         &quot;using &lt;a href=\&quot;#JDWP_VirtualMachine_RedefineClasses\&quot;&gt;RedefineClasses&lt;/a&gt;.&quot;
1382         (Out
1383             (referenceType refType &quot;The class.&quot;)
1384             (method methodID &quot;The method.&quot;)
1385         )
1386         (Reply
1387             (long start &quot;Lowest valid code index for the method, &gt;=0, or -1 if the method is native &quot;)
1388             (long end &quot;Highest valid code index for the method, &gt;=0, or -1 if the method is native&quot;)
1389             (Repeat lines &quot;The number of entries in the line table for this method.&quot;
1390                 (Group LineInfo
1391                     (long lineCodeIndex &quot;Initial code index of the line, &quot;
1392                                         &quot;start &amp;lt;= lineCodeIndex &amp;lt; end&quot;)
1393                     (int lineNumber &quot;Line number.&quot;)
1394                 )
1395             )
1396         )
1397         (ErrorSet
1398             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1399                                      &quot;type.&quot;)
1400             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1401             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1402             (Error VM_DEAD)
1403         )
1404     )
1405     (Command VariableTable=2
1406         &quot;Returns variable information for the method. The variable table &quot;
1407         &quot;includes arguments and locals declared within the method. For &quot;
1408         &quot;instance methods, the \&quot;this\&quot; reference is included in the &quot;
1409         &quot;table. Also, synthetic variables may be present. &quot;
1410         (Out
1411             (referenceType refType &quot;The class.&quot;)
1412             (method methodID &quot;The method.&quot;)
1413         )
1414         (Reply
1415             (int argCnt &quot;The number of words in the frame used by arguments. &quot;
1416                         &quot;Eight-byte arguments use two words; all others use one. &quot;)
1417             (Repeat slots &quot;The number of variables.&quot;
1418                 (Group SlotInfo &quot;Information about the variable.&quot;
1419                     (long codeIndex
1420                         &quot;First code index at which the variable is visible (unsigned). &quot;
1421                         &quot;Used in conjunction with &lt;code&gt;length&lt;/code&gt;. &quot;
1422                         &quot;The variable can be get or set only when the current &quot;
1423                         &quot;&lt;code&gt;codeIndex&lt;/code&gt; &amp;lt;= current frame code index &amp;lt; &lt;code&gt;codeIndex + length&lt;/code&gt; &quot;)
1424                     (string name &quot;The variable&#39;s name.&quot;)
1425                     (string signature &quot;The variable type&#39;s JNI signature.&quot;)
1426                     (int length
1427                         &quot;Unsigned value used in conjunction with &lt;code&gt;codeIndex&lt;/code&gt;. &quot;
1428                         &quot;The variable can be get or set only when the current &quot;
1429                         &quot;&lt;code&gt;codeIndex&lt;/code&gt; &amp;lt;= current frame code index &amp;lt; &lt;code&gt;code index + length&lt;/code&gt; &quot;)
1430                     (int slot &quot;The local variable&#39;s index in its frame&quot;)
1431                 )
1432             )
1433         )
1434         (ErrorSet
1435             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1436                                      &quot;type.&quot;)
1437             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1438             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1439             (Error ABSENT_INFORMATION &quot;there is no variable information for the method.&quot;)
1440             (Error VM_DEAD)
1441         )
1442     )
1443     (Command Bytecodes=3
1444         &quot;Retrieve the method&#39;s bytecodes as defined in &quot;
1445         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
1446         &quot;Requires canGetBytecodes capability - see &quot;
1447         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1448         (Out
1449             (referenceType refType &quot;The class.&quot;)
1450             (method methodID &quot;The method.&quot;)
1451         )
1452         (Reply
1453             (Repeat bytes
1454                 (byte bytecode &quot;A Java bytecode.&quot;)
1455             )
1456         )
1457         (ErrorSet
1458             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1459                                      &quot;type.&quot;)
1460             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1461             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1462             (Error NOT_IMPLEMENTED   &quot;If the target virtual machine does not &quot;
1463                                      &quot;support the retrieval of bytecodes.&quot;)
1464             (Error VM_DEAD)
1465         )
1466     )
1467     (Command IsObsolete=4
1468         &quot;Determine if this method is obsolete. A method is obsolete if it has been replaced &quot;
1469         &quot;by a non-equivalent method using the &quot;
1470         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_RedefineClasses\&quot;&gt;RedefineClasses&lt;/a&gt; command. &quot;
1471         &quot;The original and redefined methods are considered equivalent if their bytecodes are &quot;
1472         &quot;the same except for indices into the constant pool and the referenced constants are &quot;
1473         &quot;equal.&quot;
1474         (Out
1475             (referenceType refType &quot;The class.&quot;)
1476             (method methodID &quot;The method.&quot;)
1477         )
1478         (Reply
1479             (boolean isObsolete    &quot;true if this method has been replaced&quot;
1480                                    &quot;by a non-equivalent method using&quot;
1481                                    &quot;the RedefineClasses command.&quot;)
1482         )
1483         (ErrorSet
1484             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1485                                      &quot;type.&quot;)
1486             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1487             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1488             (Error NOT_IMPLEMENTED   &quot;If the target virtual machine does &quot;
1489                                      &quot;not support this query.&quot;)
1490             (Error VM_DEAD)
1491         )
1492     )
1493     (Command VariableTableWithGeneric=5
1494         &quot;Returns variable information for the method, including &quot;
1495         &quot;generic signatures for the variables. The variable table &quot;
1496         &quot;includes arguments and locals declared within the method. For &quot;
1497         &quot;instance methods, the \&quot;this\&quot; reference is included in the &quot;
1498         &quot;table. Also, synthetic variables may be present. &quot;
1499         &quot;Generic signatures are described in the signature attribute &quot;
1500         &quot;section in &quot;
1501         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
1502         &quot;Since JDWP version 1.5.&quot;
1503         (Out
1504             (referenceType refType &quot;The class.&quot;)
1505             (method methodID &quot;The method.&quot;)
1506         )
1507         (Reply
1508             (int argCnt &quot;The number of words in the frame used by arguments. &quot;
1509                         &quot;Eight-byte arguments use two words; all others use one. &quot;)
1510             (Repeat slots &quot;The number of variables.&quot;
1511                 (Group SlotInfo &quot;Information about the variable.&quot;
1512                     (long codeIndex
1513                         &quot;First code index at which the variable is visible (unsigned). &quot;
1514                         &quot;Used in conjunction with &lt;code&gt;length&lt;/code&gt;. &quot;
1515                         &quot;The variable can be get or set only when the current &quot;
1516                         &quot;&lt;code&gt;codeIndex&lt;/code&gt; &amp;lt;= current frame code index &amp;lt; &lt;code&gt;codeIndex + length&lt;/code&gt; &quot;)
1517                     (string name &quot;The variable&#39;s name.&quot;)
1518                     (string signature &quot;The variable type&#39;s JNI signature.&quot;)
1519                     (string genericSignature &quot;The variable type&#39;s generic &quot;
1520                          &quot;signature or an empty string if there is none.&quot;)
1521                     (int length
1522                         &quot;Unsigned value used in conjunction with &lt;code&gt;codeIndex&lt;/code&gt;. &quot;
1523                         &quot;The variable can be get or set only when the current &quot;
1524                         &quot;&lt;code&gt;codeIndex&lt;/code&gt; &amp;lt;= current frame code index &amp;lt; &lt;code&gt;code index + length&lt;/code&gt; &quot;)
1525                     (int slot &quot;The local variable&#39;s index in its frame&quot;)
1526                 )
1527             )
1528         )
1529         (ErrorSet
1530             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1531                                      &quot;type.&quot;)
1532             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1533             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1534             (Error ABSENT_INFORMATION &quot;there is no variable information for the method.&quot;)
1535             (Error VM_DEAD)
1536         )
1537     )
1538 
1539 )
1540 (CommandSet Field=8
1541 )
1542 (CommandSet ObjectReference=9
1543     (Command ReferenceType=1
1544         &quot;Returns the runtime type of the object. &quot;
1545         &quot;The runtime type will be a class or an array. &quot;
1546         (Out
1547             (object object &quot;The object ID&quot;)
1548         )
1549         (Reply
1550             (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
1551                               &quot;of following reference type. &quot;)
1552             (referenceTypeID typeID &quot;The runtime reference type.&quot;)
1553         )
1554         (ErrorSet
1555             (Error INVALID_OBJECT)
1556             (Error VM_DEAD)
1557         )
1558     )
1559     (Command GetValues=2
1560         &quot;Returns the value of one or more instance fields. &quot;
1561         &quot;Each field must be member of the object&#39;s type &quot;
1562         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
1563         &quot;Access control is not enforced; for example, the values of private &quot;
1564         &quot;fields can be obtained.&quot;
1565         (Out
1566             (object object &quot;The object ID&quot;)
1567             (Repeat fields &quot;The number of values to get&quot;
1568                 (Group Field
1569                     (field fieldID &quot;Field to get.&quot;)
1570                 )
1571             )
1572         )
1573         (Reply
1574             (Repeat values &quot;The number of values returned, always equal to &#39;fields&#39;, &quot;
1575                            &quot;the number of values to get. Field values are ordered &quot;
1576                            &quot;in the reply in the same order as corresponding fieldIDs &quot;
1577                            &quot;in the command.&quot;
1578                 (value value &quot;The field value&quot;)
1579             )
1580         )
1581         (ErrorSet
1582             (Error INVALID_OBJECT)
1583             (Error INVALID_FIELDID)
1584             (Error VM_DEAD)
1585         )
1586     )
1587     (Command SetValues=3
1588         &quot;Sets the value of one or more instance fields. &quot;
1589         &quot;Each field must be member of the object&#39;s type &quot;
1590         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
1591         &quot;Access control is not enforced; for example, the values of private &quot;
1592         &quot;fields can be set. &quot;
1593         &quot;For primitive values, the value&#39;s type must match the &quot;
1594         &quot;field&#39;s type exactly. For object values, there must be a &quot;
1595         &quot;widening reference conversion from the value&#39;s type to the
1596         &quot;field&#39;s type and the field&#39;s type must be loaded. &quot;
1597         (Out
1598             (object object &quot;The object ID&quot;)
1599             (Repeat values &quot;The number of fields to set.&quot;
1600                 (Group FieldValue &quot;A Field/Value pair.&quot;
1601                     (field fieldID &quot;Field to set.&quot;)
1602                     (untagged-value value &quot;Value to put in the field.&quot;)
1603                 )
1604             )
1605         )
1606         (Reply &quot;none&quot;
1607         )
1608         (ErrorSet
1609             (Error INVALID_OBJECT)
1610             (Error INVALID_FIELDID)
1611             (Error VM_DEAD)
1612         )
1613     )
1614     (Command MonitorInfo=5
1615         &quot;Returns monitor information for an object. All threads int the VM must &quot;
1616         &quot;be suspended.&quot;
1617         &quot;Requires canGetMonitorInfo capability - see &quot;
1618         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1619         (Out
1620             (object object &quot;The object ID&quot;)
1621         )
1622         (Reply
1623             (threadObject owner &quot;The monitor owner, or null if it is not currently owned.&quot;)
1624             (int entryCount &quot;The number of times the monitor has been entered.&quot;)
1625             (Repeat waiters &quot;The number of threads that are waiting for the monitor &quot;
1626                             &quot;0 if there is no current owner&quot;
1627                 (threadObject thread &quot;A thread waiting for this monitor.&quot;)
1628             )
1629         )
1630         (ErrorSet
1631             (Error INVALID_OBJECT)
1632             (Error NOT_IMPLEMENTED)
1633             (Error VM_DEAD)
1634         )
1635     )
1636     (Command InvokeMethod=6
1637         &quot;Invokes a instance method. &quot;
1638         &quot;The method must be member of the object&#39;s type &quot;
1639         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
1640         &quot;Access control is not enforced; for example, private &quot;
1641         &quot;methods can be invoked.&quot;
1642         &quot;&lt;p&gt;&quot;
1643         &quot;The method invocation will occur in the specified thread. &quot;
1644         &quot;Method invocation can occur only if the specified thread &quot;
1645         &quot;has been suspended by an event. &quot;
1646         &quot;Method invocation is not supported &quot;
1647         &quot;when the target VM has been suspended by the front-end. &quot;
1648         &quot;&lt;p&gt;&quot;
1649         &quot;The specified method is invoked with the arguments in the specified &quot;
1650         &quot;argument list. &quot;
1651         &quot;The method invocation is synchronous; the reply packet is not &quot;
1652         &quot;sent until the invoked method returns in the target VM. &quot;
1653         &quot;The return value (possibly the void value) is &quot;
1654         &quot;included in the reply packet. &quot;
1655         &quot;If the invoked method throws an exception, the &quot;
1656         &quot;exception object ID is set in the reply packet; otherwise, the &quot;
1657         &quot;exception object ID is null. &quot;
1658         &quot;&lt;p&gt;&quot;
1659         &quot;For primitive arguments, the argument value&#39;s type must match the &quot;
1660         &quot;argument&#39;s type exactly. For object arguments, there must be a &quot;
1661         &quot;widening reference conversion from the argument value&#39;s type to the &quot;
1662         &quot;argument&#39;s type and the argument&#39;s type must be loaded. &quot;
1663         &quot;&lt;p&gt;&quot;
1664         &quot;By default, all threads in the target VM are resumed while &quot;
1665         &quot;the method is being invoked if they were previously &quot;
1666         &quot;suspended by an event or by a command. &quot;
1667         &quot;This is done to prevent the deadlocks &quot;
1668         &quot;that will occur if any of the threads own monitors &quot;
1669         &quot;that will be needed by the invoked method. It is possible that &quot;
1670         &quot;breakpoints or other events might occur during the invocation. &quot;
1671         &quot;Note, however, that this implicit resume acts exactly like &quot;
1672         &quot;the ThreadReference resume command, so if the thread&#39;s suspend &quot;
1673         &quot;count is greater than 1, it will remain in a suspended state &quot;
1674         &quot;during the invocation. By default, when the invocation completes, &quot;
1675         &quot;all threads in the target VM are suspended, regardless their state &quot;
1676         &quot;before the invocation. &quot;
1677         &quot;&lt;p&gt;&quot;
1678         &quot;The resumption of other threads during the invoke can be prevented &quot;
1679         &quot;by specifying the INVOKE_SINGLE_THREADED &quot;
1680         &quot;bit flag in the &lt;code&gt;options&lt;/code&gt; field; however, &quot;
1681         &quot;there is no protection against or recovery from the deadlocks &quot;
1682         &quot;described above, so this option should be used with great caution. &quot;
1683         &quot;Only the specified thread will be resumed (as described for all &quot;
1684         &quot;threads above). Upon completion of a single threaded invoke, the invoking thread &quot;
1685         &quot;will be suspended once again. Note that any threads started during &quot;
1686         &quot;the single threaded invocation will not be suspended when the &quot;
1687         &quot;invocation completes. &quot;
1688         &quot;&lt;p&gt;&quot;
1689         &quot;If the target VM is disconnected during the invoke (for example, through &quot;
1690         &quot;the VirtualMachine dispose command) the method invocation continues. &quot;
1691         (Out
1692             (object object &quot;The object ID&quot;)
1693             (threadObject thread &quot;The thread in which to invoke.&quot;)
1694             (classType clazz &quot;The class type.&quot;)
1695             (method methodID &quot;The method to invoke.&quot;)
1696             (Repeat arguments &quot;The number of arguments.&quot;
1697                 (value arg &quot;The argument value.&quot;)
1698             )
1699             (int options &quot;Invocation &lt;a href=\&quot;#JDWP_InvokeOptions\&quot;&gt;options&lt;/a&gt;&quot;)
1700         )
1701         (Reply
1702             (value returnValue &quot;The returned value, or null if an exception is thrown.&quot;)
1703             (tagged-object exception &quot;The thrown exception, if any.&quot;)
1704         )
1705         (ErrorSet
1706             (Error INVALID_OBJECT)
1707             (Error INVALID_CLASS     &quot;clazz is not the ID of a reference &quot;
1708                                      &quot;type.&quot;)
1709             (Error INVALID_METHODID  &quot;methodID is not the ID of an instance method &quot;
1710                                      &quot;in this object&#39;s type or one of its superclasses, &quot;
1711                                      &quot;superinterfaces, or implemented interfaces.&quot;)
1712             (Error INVALID_THREAD)
1713             (Error THREAD_NOT_SUSPENDED)
1714             (Error VM_DEAD)
1715         )
1716     )
1717     (Command DisableCollection=7
1718         &quot;Prevents garbage collection for the given object. By &quot;
1719         &quot;default all objects in back-end replies may be &quot;
1720         &quot;collected at any time the target VM is running. A call to &quot;
1721         &quot;this command guarantees that the object will not be &quot;
1722         &quot;collected. The &quot;
1723         &quot;&lt;a href=\&quot;#JDWP_ObjectReference_EnableCollection\&quot;&gt;EnableCollection&lt;/a&gt; &quot;
1724         &quot;command can be used to &quot;
1725         &quot;allow collection once again. &quot;
1726         &quot;&lt;p&gt;&quot;
1727         &quot;Note that while the target VM is suspended, no garbage &quot;
1728         &quot;collection will occur because all threads are suspended. &quot;
1729         &quot;The typical examination of variables, fields, and arrays &quot;
1730         &quot;during the suspension is safe without explicitly disabling &quot;
1731         &quot;garbage collection. &quot;
1732         &quot;&lt;p&gt;&quot;
1733         &quot;This method should be used sparingly, as it alters the &quot;
1734         &quot;pattern of garbage collection in the target VM and, &quot;
1735         &quot;consequently, may result in application behavior under the &quot;
1736         &quot;debugger that differs from its non-debugged behavior. &quot;
1737         (Out
1738             (object object &quot;The object ID&quot;)
1739         )
1740         (Reply &quot;none&quot;
1741         )
1742         (ErrorSet
1743             (Error INVALID_OBJECT)
1744             (Error VM_DEAD)
1745         )
1746     )
1747     (Command EnableCollection=8
1748         &quot;Permits garbage collection for this object. By default all &quot;
1749         &quot;objects returned by JDWP may become unreachable in the target VM, &quot;
1750         &quot;and hence may be garbage collected. A call to this command is &quot;
1751         &quot;necessary only if garbage collection was previously disabled with &quot;
1752         &quot;the &lt;a href=\&quot;#JDWP_ObjectReference_DisableCollection\&quot;&gt;DisableCollection&lt;/a&gt; &quot;
1753         &quot;command.&quot;
1754         (Out
1755             (object object &quot;The object ID&quot;)
1756         )
1757         (Reply &quot;none&quot;
1758         )
1759         (ErrorSet
1760             (Error VM_DEAD)
1761         )
1762     )
1763     (Command IsCollected=9
1764         &quot;Determines whether an object has been garbage collected in the &quot;
1765         &quot;target VM. &quot;
1766         (Out
1767             (object object &quot;The object ID&quot;)
1768         )
1769         (Reply
1770             (boolean isCollected &quot;true if the object has been collected; false otherwise&quot;)
1771         )
1772         (ErrorSet
1773             (Error INVALID_OBJECT)
1774             (Error VM_DEAD)
1775         )
1776     )
1777     (Command ReferringObjects=10
1778         &quot;Returns objects that directly reference this object.  &quot;
1779         &quot;Only objects that are reachable for the purposes &quot;
1780         &quot;of garbage collection are returned. &quot;
1781         &quot;Note that an object can also be referenced in other ways, &quot;
1782         &quot;such as from a local variable in a stack frame, or from a JNI global &quot;
1783         &quot;reference.  Such non-object referrers are not returned by this command. &quot;
1784         &quot;&lt;p&gt;Since JDWP version 1.6. Requires canGetInstanceInfo capability - see &quot;
1785         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1786         (Out
1787             (object object &quot;The object ID&quot;)
1788             (int maxReferrers &quot;Maximum number of referring objects to return. &quot;
1789                               &quot;Must be non-negative. If zero, all referring &quot;
1790                               &quot;objects are returned.&quot;)
1791         )
1792         (Reply
1793             (Repeat referringObjects &quot;The number of objects that follow.&quot;
1794                 (tagged-object instance &quot;An object that references this object.&quot;)
1795              )
1796         )
1797         (ErrorSet
1798             (Error INVALID_OBJECT    &quot;object is not a known ID.&quot;)
1799             (Error ILLEGAL_ARGUMENT  &quot;maxReferrers is less than zero.&quot;)
1800             (Error NOT_IMPLEMENTED)
1801             (Error VM_DEAD)
1802         )
1803     )
1804 )
1805 
1806 (CommandSet StringReference=10
1807     (Command Value=1
1808         &quot;Returns the characters contained in the string. &quot;
1809         (Out
1810             (object stringObject &quot;The String object ID. &quot;)
1811         )
1812         (Reply
1813             (string stringValue &quot;UTF-8 representation of the string value.&quot;)
1814        )
1815         (ErrorSet
1816             (Error INVALID_STRING)
1817             (Error INVALID_OBJECT)
1818             (Error VM_DEAD)
1819         )
1820     )
1821 )
1822 (CommandSet ThreadReference=11
1823     (Command Name=1
1824         &quot;Returns the thread name. &quot;
1825         (Out
1826             (threadObject thread &quot;The thread object ID. &quot;)
1827         )
1828         (Reply
1829             (string threadName &quot;The thread name.&quot;)
1830         )
1831         (ErrorSet
1832             (Error INVALID_THREAD)
1833             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1834             (Error VM_DEAD)
1835         )
1836     )
1837     (Command Suspend=2
1838         &quot;Suspends the thread. &quot;
1839         &quot;&lt;p&gt;&quot;
1840         &quot;Unlike java.lang.Thread.suspend(), suspends of both &quot;
1841         &quot;the virtual machine and individual threads are counted. Before &quot;
1842         &quot;a thread will run again, it must be resumed the same number &quot;
1843         &quot;of times it has been suspended. &quot;
1844         &quot;&lt;p&gt;&quot;
1845         &quot;Suspending single threads with command has the same &quot;
1846         &quot;dangers java.lang.Thread.suspend(). If the suspended &quot;
1847         &quot;thread holds a monitor needed by another running thread, &quot;
1848         &quot;deadlock is possible in the target VM (at least until the &quot;
1849         &quot;suspended thread is resumed again). &quot;
1850         &quot;&lt;p&gt;&quot;
1851         &quot;The suspended thread is guaranteed to remain suspended until &quot;
1852         &quot;resumed through one of the JDI resume methods mentioned above; &quot;
1853         &quot;the application in the target VM cannot resume the suspended thread &quot;
1854         &quot;through {@link java.lang.Thread#resume}. &quot;
1855         &quot;&lt;p&gt;&quot;
1856         &quot;Note that this doesn&#39;t change the status of the thread (see the &quot;
1857         &quot;&lt;a href=\&quot;#JDWP_ThreadReference_Status\&quot;&gt;ThreadStatus&lt;/a&gt; command.) &quot;
1858         &quot;For example, if it was &quot;
1859         &quot;Running, it will still appear running to other threads. &quot;
1860         (Out
1861             (threadObject thread &quot;The thread object ID. &quot;)
1862         )
1863         (Reply &quot;none&quot;
1864         )
1865         (ErrorSet
1866             (Error INVALID_THREAD)
1867             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1868             (Error VM_DEAD)
1869         )
1870     )
1871     (Command Resume=3
1872         &quot;Resumes the execution of a given thread. If this thread was &quot;
1873         &quot;not previously suspended by the front-end, &quot;
1874         &quot;calling this command has no effect. &quot;
1875         &quot;Otherwise, the count of pending suspends on this thread is &quot;
1876         &quot;decremented. If it is decremented to 0, the thread will &quot;
1877         &quot;continue to execute. &quot;
1878         (Out
1879             (threadObject thread &quot;The thread object ID. &quot;)
1880         )
1881         (Reply &quot;none&quot;
1882         )
1883         (ErrorSet
1884             (Error INVALID_THREAD)
1885             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1886             (Error VM_DEAD)
1887         )
1888     )
1889     (Command Status=4
1890         &quot;Returns the current status of a thread. The thread status &quot;
1891         &quot;reply indicates the thread status the last time it was running. &quot;
1892         &quot;the suspend status provides information on the thread&#39;s &quot;
1893         &quot;suspension, if any.&quot;
1894         (Out
1895             (threadObject thread &quot;The thread object ID. &quot;)
1896         )
1897         (Reply
1898             (int threadStatus &quot;One of the thread status codes &quot;
1899                     &quot;See &lt;a href=\&quot;#JDWP_ThreadStatus\&quot;&gt;JDWP.ThreadStatus&lt;/a&gt;&quot;)
1900             (int suspendStatus &quot;One of the suspend status codes &quot;
1901                     &quot;See &lt;a href=\&quot;#JDWP_SuspendStatus\&quot;&gt;JDWP.SuspendStatus&lt;/a&gt;&quot;)
1902         )
1903         (ErrorSet
1904             (Error INVALID_THREAD)
1905             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1906             (Error VM_DEAD)
1907         )
1908     )
1909     (Command ThreadGroup=5
1910         &quot;Returns the thread group that contains a given thread. &quot;
1911         (Out
1912             (threadObject thread &quot;The thread object ID. &quot;)
1913         )
1914         (Reply
1915             (threadGroupObject group &quot;The thread group of this thread. &quot;)
1916         )
1917         (ErrorSet
1918             (Error INVALID_THREAD)
1919             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1920             (Error VM_DEAD)
1921         )
1922     )
1923     (Command Frames=6
1924         &quot;Returns the current call stack of a suspended thread. &quot;
1925         &quot;The sequence of frames starts with &quot;
1926         &quot;the currently executing frame, followed by its caller, &quot;
1927         &quot;and so on. The thread must be suspended, and the returned &quot;
1928         &quot;frameID is valid only while the thread is suspended. &quot;
1929         (Out
1930             (threadObject thread &quot;The thread object ID. &quot;)
1931             (int startFrame &quot;The index of the first frame to retrieve.&quot;)
1932             (int length
1933                         &quot;The count of frames to retrieve &quot;
1934                         &quot;(-1 means all remaining). &quot;)
1935         )
1936         (Reply
1937             (Repeat frames &quot;The number of frames retreived&quot;
1938                 (Group Frame
1939                     (frame frameID &quot;The ID of this frame. &quot;)
1940                     (location location &quot;The current location of this frame&quot;)
1941                 )
1942             )
1943         )
1944         (ErrorSet
1945             (Error INVALID_THREAD)
1946             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1947             (Error VM_DEAD)
1948         )
1949     )
1950     (Command FrameCount=7
1951         &quot;Returns the count of frames on this thread&#39;s stack. &quot;
1952         &quot;The thread must be suspended, and the returned &quot;
1953         &quot;count is valid only while the thread is suspended. &quot;
1954         &quot;Returns JDWP.Error.errorThreadNotSuspended if not suspended. &quot;
1955         (Out
1956             (threadObject thread &quot;The thread object ID. &quot;)
1957         )
1958         (Reply
1959             (int frameCount &quot;The count of frames on this thread&#39;s stack. &quot;)
1960         )
1961         (ErrorSet
1962             (Error INVALID_THREAD)
1963             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1964             (Error VM_DEAD)
1965         )
1966     )
1967     (Command OwnedMonitors=8
1968         &quot;Returns the objects whose monitors have been entered by this thread. &quot;
1969         &quot;The thread must be suspended, and the returned information is &quot;
1970         &quot;relevant only while the thread is suspended. &quot;
1971         &quot;Requires canGetOwnedMonitorInfo capability - see &quot;
1972         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1973         (Out
1974             (threadObject thread &quot;The thread object ID. &quot;)
1975         )
1976         (Reply
1977             (Repeat owned &quot;The number of owned monitors&quot;
1978                 (tagged-object monitor &quot;An owned monitor&quot;)
1979             )
1980         )
1981         (ErrorSet
1982             (Error INVALID_THREAD)
1983             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1984             (Error NOT_IMPLEMENTED)
1985             (Error VM_DEAD)
1986         )
1987     )
1988     (Command CurrentContendedMonitor=9
1989         &quot;Returns the object, if any, for which this thread is waiting. The &quot;
1990         &quot;thread may be waiting to enter a monitor, or it may be waiting, via &quot;
1991         &quot;the java.lang.Object.wait method, for another thread to invoke the &quot;
1992         &quot;notify method. &quot;
1993         &quot;The thread must be suspended, and the returned information is &quot;
1994         &quot;relevant only while the thread is suspended. &quot;
1995         &quot;Requires canGetCurrentContendedMonitor capability - see &quot;
1996         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1997         (Out
1998             (threadObject thread &quot;The thread object ID. &quot;)
1999         )
2000         (Reply
2001             (tagged-object monitor &quot;The contended monitor, or null if &quot;
2002                                    &quot;there is no current contended monitor. &quot;)
2003         )
2004         (ErrorSet
2005             (Error INVALID_THREAD)
2006             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
2007             (Error NOT_IMPLEMENTED)
2008             (Error VM_DEAD)
2009         )
2010     )
2011     (Command Stop=10
2012         &quot;Stops the thread with an asynchronous exception. &quot;
2013         (Out
2014             (threadObject thread &quot;The thread object ID. &quot;)
2015             (object throwable &quot;Asynchronous exception. This object must &quot;
2016                               &quot;be an instance of java.lang.Throwable or a subclass&quot;)
2017         )
2018         (Reply &quot;none&quot;
2019         )
2020         (ErrorSet
2021             (Error INVALID_THREAD)
2022             (Error INVALID_OBJECT &quot;If thread is not a known ID or the asynchronous &quot;
2023                                   &quot;exception has been garbage collected.&quot;)
2024             (Error VM_DEAD)
2025         )
2026     )
2027     (Command Interrupt=11
2028         &quot;Interrupt the thread, as if done by java.lang.Thread.interrupt &quot;
2029         (Out
2030             (threadObject thread &quot;The thread object ID. &quot;)
2031         )
2032         (Reply &quot;none&quot;
2033         )
2034         (ErrorSet
2035             (Error INVALID_THREAD)
2036             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
2037             (Error VM_DEAD)
2038         )
2039     )
2040     (Command SuspendCount=12
2041         &quot;Get the suspend count for this thread. The suspend count is the  &quot;
2042         &quot;number of times the thread has been suspended through the &quot;
2043         &quot;thread-level or VM-level suspend commands without a corresponding resume &quot;
2044         (Out
2045             (threadObject thread &quot;The thread object ID. &quot;)
2046         )
2047         (Reply
2048             (int suspendCount &quot;The number of outstanding suspends of this thread. &quot;)
2049         )
2050         (ErrorSet
2051             (Error INVALID_THREAD)
2052             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
2053             (Error VM_DEAD)
2054         )
2055     )
2056     (Command OwnedMonitorsStackDepthInfo=13
2057         &quot;Returns monitor objects owned by the thread, along with stack depth at which &quot;
2058         &quot;the monitor was acquired. Returns stack depth of -1  if &quot;
2059         &quot;the implementation cannot determine the stack depth &quot;
2060         &quot;(e.g., for monitors acquired by JNI MonitorEnter).&quot;
2061         &quot;The thread must be suspended, and the returned information is &quot;
2062         &quot;relevant only while the thread is suspended. &quot;
2063         &quot;Requires canGetMonitorFrameInfo capability - see &quot;
2064         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2065         &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2066 
2067         (Out
2068             (threadObject thread &quot;The thread object ID. &quot;)
2069         )
2070         (Reply
2071             (Repeat owned &quot;The number of owned monitors&quot;
2072                (Group monitor
2073                   (tagged-object monitor &quot;An owned monitor&quot;)
2074                   (int stack_depth &quot;Stack depth location where monitor was acquired&quot;)
2075                )
2076             )
2077         )
2078         (ErrorSet
2079             (Error INVALID_THREAD)
2080             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
2081             (Error NOT_IMPLEMENTED)
2082             (Error VM_DEAD)
2083         )
2084     )
2085     (Command ForceEarlyReturn=14
2086         &quot;Force a method to return before it reaches a return &quot;
2087         &quot;statement.  &quot;
2088         &quot;&lt;p&gt;&quot;
2089         &quot;The method which will return early is referred to as the &quot;
2090         &quot;called method. The called method is the current method (as &quot;
2091         &quot;defined by the Frames section in &quot;
2092         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;) &quot;
2093         &quot;for the specified thread at the time this command &quot;
2094         &quot;is received. &quot;
2095         &quot;&lt;p&gt;&quot;
2096         &quot;The specified thread must be suspended. &quot;
2097         &quot;The return occurs when execution of Java programming &quot;
2098         &quot;language code is resumed on this thread. Between sending this &quot;
2099         &quot;command and resumption of thread execution, the &quot;
2100         &quot;state of the stack is undefined. &quot;
2101         &quot;&lt;p&gt;&quot;
2102         &quot;No further instructions are executed in the called &quot;
2103         &quot;method. Specifically, finally blocks are not executed. Note: &quot;
2104         &quot;this can cause inconsistent states in the application. &quot;
2105         &quot;&lt;p&gt;&quot;
2106         &quot;A lock acquired by calling the called method (if it is a &quot;
2107         &quot;synchronized method) and locks acquired by entering &quot;
2108         &quot;synchronized blocks within the called method are &quot;
2109         &quot;released. Note: this does not apply to JNI locks or &quot;
2110         &quot;java.util.concurrent.locks locks. &quot;
2111         &quot;&lt;p&gt;&quot;
2112         &quot;Events, such as MethodExit, are generated as they would be in &quot;
2113         &quot;a normal return. &quot;
2114         &quot;&lt;p&gt;&quot;
2115         &quot;The called method must be a non-native Java programming &quot;
2116         &quot;language method. Forcing return on a thread with only one &quot;
2117         &quot;frame on the stack causes the thread to exit when resumed. &quot;
2118         &quot;&lt;p&gt;&quot;
2119         &quot;For void methods, the value must be a void value. &quot;
2120         &quot;For methods that return primitive values, the value&#39;s type must &quot;
2121         &quot;match the return type exactly.  For object values, there must be a &quot;
2122         &quot;widening reference conversion from the value&#39;s type to the &quot;
2123         &quot;return type type and the return type must be loaded. &quot;
2124         &quot;&lt;p&gt;&quot;
2125         &quot;Since JDWP version 1.6. Requires canForceEarlyReturn capability - see &quot;
2126         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
2127         (Out
2128             (threadObject thread &quot;The thread object ID. &quot;)
2129             (value value &quot;The value to return. &quot;)
2130         )
2131         (Reply &quot;none&quot;
2132         )
2133         (ErrorSet
2134             (Error INVALID_THREAD)
2135             (Error INVALID_OBJECT    &quot;Thread or value is not a known ID.&quot;)
2136             (Error THREAD_NOT_SUSPENDED)
2137             (Error THREAD_NOT_ALIVE)
2138             (Error OPAQUE_FRAME      &quot;Attempted to return early from &quot;
2139                                      &quot;a frame corresponding to a native &quot;
2140                                      &quot;method. Or the implementation is &quot;
2141                                      &quot;unable to provide this functionality &quot;
2142                                      &quot;on this frame.&quot;)
2143             (Error NO_MORE_FRAMES)
2144             (Error NOT_IMPLEMENTED)
2145             (Error TYPE_MISMATCH   &quot;Value is not an appropriate type for the &quot;
2146                                    &quot;return value of the method.&quot;)
2147             (Error VM_DEAD)
2148         )
2149     )
2150 
2151 )
2152 (CommandSet ThreadGroupReference=12
2153     (Command Name=1
2154         &quot;Returns the thread group name. &quot;
2155         (Out
2156             (threadGroupObject group &quot;The thread group object ID. &quot;)
2157         )
2158         (Reply
2159             (string groupName &quot;The thread group&#39;s name.&quot;)
2160         )
2161         (ErrorSet
2162             (Error INVALID_THREAD_GROUP)
2163             (Error INVALID_OBJECT    &quot;group is not a known ID.&quot;)
2164             (Error VM_DEAD)
2165         )
2166     )
2167     (Command Parent=2
2168         &quot;Returns the thread group, if any, which contains a given thread group. &quot;
2169         (Out
2170             (threadGroupObject group &quot;The thread group object ID. &quot;)
2171         )
2172         (Reply
2173             (threadGroupObject parentGroup &quot;The parent thread group object, or &quot;
2174                                            &quot;null if the given thread group &quot;
2175                                            &quot;is a top-level thread group&quot;)
2176         )
2177         (ErrorSet
2178             (Error INVALID_THREAD_GROUP)
2179             (Error INVALID_OBJECT    &quot;group is not a known ID.&quot;)
2180             (Error VM_DEAD)
2181         )
2182     )
2183     (Command Children=3
2184         &quot;Returns the live threads and active thread groups directly contained &quot;
2185         &quot;in this thread group. Threads and thread groups in child &quot;
2186         &quot;thread groups are not included. &quot;
2187         &quot;A thread is alive if it has been started and has not yet been stopped. &quot;
2188         &quot;See &lt;a href=../../api/java.base/java/lang/ThreadGroup.html&gt;java.lang.ThreadGroup &lt;/a&gt;
2189         &quot;for information about active ThreadGroups.
2190         (Out
2191             (threadGroupObject group &quot;The thread group object ID. &quot;)
2192         )
2193         (Reply
2194             (Repeat childThreads &quot;The number of live child threads. &quot;
2195                 (threadObject childThread &quot;A direct child thread ID. &quot;)
2196             )
2197             (Repeat childGroups &quot;The number of active child thread groups. &quot;
2198                 (threadGroupObject childGroup &quot;A direct child thread group ID. &quot;)
2199             )
2200         )
2201         (ErrorSet
2202             (Error INVALID_THREAD_GROUP)
2203             (Error INVALID_OBJECT    &quot;group is not a known ID.&quot;)
2204             (Error VM_DEAD)
2205         )
2206     )
2207 )
2208 (CommandSet ArrayReference=13
2209     (Command Length=1
2210         &quot;Returns the number of components in a given array. &quot;
2211         (Out
2212             (arrayObject arrayObject &quot;The array object ID. &quot;)
2213         )
2214         (Reply
2215             (int arrayLength &quot;The length of the array.&quot;)
2216         )
2217         (ErrorSet
2218             (Error INVALID_OBJECT    &quot;arrayObject is not a known ID.&quot;)
2219             (Error INVALID_ARRAY)
2220             (Error VM_DEAD)
2221         )
2222     )
2223     (Command GetValues=2
2224         &quot;Returns a range of array components. The specified range must &quot;
2225         &quot;be within the bounds of the array. &quot;
2226         (Out
2227             (arrayObject arrayObject &quot;The array object ID. &quot;)
2228             (int firstIndex &quot;The first index to retrieve.&quot;)
2229             (int length &quot;The number of components to retrieve.&quot;)
2230         )
2231         (Reply
2232             (typed-sequence values &quot;The retrieved values. If the values &quot;
2233                                    &quot;are objects, they are tagged-values; &quot;
2234                                    &quot;otherwise, they are untagged-values&quot;)
2235         )
2236         (ErrorSet
2237             (Error INVALID_LENGTH &quot;If index is beyond the end of this array.&quot;)
2238             (Error INVALID_OBJECT    &quot;arrayObject is not a known ID.&quot;)
2239             (Error INVALID_ARRAY)
2240             (Error VM_DEAD)
2241         )
2242     )
2243     (Command SetValues=3
2244         &quot;Sets a range of array components. The specified range must &quot;
2245         &quot;be within the bounds of the array. &quot;
2246         &quot;For primitive values, each value&#39;s type must match the &quot;
2247         &quot;array component type exactly. For object values, there must be a &quot;
2248         &quot;widening reference conversion from the value&#39;s type to the
2249         &quot;array component type and the array component type must be loaded. &quot;
2250         (Out
2251             (arrayObject arrayObject &quot;The array object ID. &quot;)
2252             (int firstIndex &quot;The first index to set.&quot;)
2253             (Repeat values &quot;The number of values to set. &quot;
2254                 (untagged-value value &quot;A value to set. &quot;)
2255             )
2256         )
2257         (Reply &quot;none&quot;
2258         )
2259         (ErrorSet
2260             (Error INVALID_LENGTH &quot;If index is beyond the end of this array.&quot;)
2261             (Error INVALID_OBJECT    &quot;arrayObject is not a known ID.&quot;)
2262             (Error INVALID_ARRAY)
2263             (Error VM_DEAD)
2264         )
2265     )
2266 )
2267 (CommandSet ClassLoaderReference=14
2268     (Command VisibleClasses=1
2269         &quot;Returns a list of all classes which this class loader has &quot;
2270         &quot;been requested to load. This class loader is considered to be &quot;
2271         &quot;an &lt;i&gt;initiating&lt;/i&gt; class loader for each class in the returned &quot;
2272         &quot;list. The list contains each &quot;
2273         &quot;reference type defined by this loader and any types for which &quot;
2274         &quot;loading was delegated by this class loader to another class loader. &quot;
2275         &quot;&lt;p&gt;&quot;
2276         &quot;The visible class list has useful properties with respect to &quot;
2277         &quot;the type namespace. A particular type name will occur at most &quot;
2278         &quot;once in the list. Each field or variable declared with that &quot;
2279         &quot;type name in a class defined by &quot;
2280         &quot;this class loader must be resolved to that single type. &quot;
2281         &quot;&lt;p&gt;&quot;
2282         &quot;No ordering of the returned list is guaranteed. &quot;
2283         (Out
2284             (classLoaderObject classLoaderObject &quot;The class loader object ID. &quot;)
2285         )
2286         (Reply
2287             (Repeat classes &quot;The number of visible classes. &quot;
2288                 (Group ClassInfo
2289                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
2290                                       &quot;of following reference type. &quot;)
2291                     (referenceTypeID typeID
2292                         &quot;A class visible to this class loader.&quot;)
2293                 )
2294             )
2295         )
2296         (ErrorSet
2297             (Error INVALID_OBJECT)
2298             (Error INVALID_CLASS_LOADER)
2299             (Error VM_DEAD)
2300         )
2301     )
2302 )
2303 (CommandSet EventRequest=15
2304     (Command Set=1
2305         &quot;Set an event request. When the event described by this request &quot;
2306         &quot;occurs, an &lt;a href=\&quot;#JDWP_Event\&quot;&gt;event&lt;/a&gt; is sent from the &quot;
2307         &quot;target VM. If an event occurs that has not been requested then it is not sent &quot;
2308         &quot;from the target VM. The two exceptions to this are the VM Start Event and &quot;
2309         &quot;the VM Death Event which are automatically generated events - see &quot;
2310         &quot;&lt;a href=\&quot;#JDWP_Event_Composite\&quot;&gt;Composite Command&lt;/a&gt; for further details.&quot;
2311         (Out
2312             (byte eventKind &quot;Event kind to request. &quot;
2313                       &quot;See &lt;a href=\&quot;#JDWP_EventKind\&quot;&gt;JDWP.EventKind&lt;/a&gt; &quot;
2314                       &quot;for a complete list of events that can be requested; &quot;
2315                       &quot;some events may require a capability in order to be requested. &quot;
2316                       )
2317             (byte suspendPolicy
2318                       &quot;What threads are suspended when this event occurs? &quot;
2319                       &quot;Note that the order of events and command replies &quot;
2320                       &quot;accurately reflects the order in which threads are &quot;
2321                       &quot;suspended and resumed. For example, if a &quot;
2322                       &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Resume\&quot;&gt;VM-wide resume&lt;/a&gt; &quot;
2323                       &quot;is processed before an event occurs which suspends the &quot;
2324                       &quot;VM, the reply to the resume command will be written to &quot;
2325                       &quot;the transport before the suspending event.&quot;)
2326             (Repeat modifiers &quot;Constraints used to control the number &quot;
2327                               &quot;of generated events.&quot;
2328                               &quot;Modifiers specify additional tests that &quot;
2329                               &quot;an event must satisfy before it is placed &quot;
2330                               &quot;in the event queue. Events are filtered by &quot;
2331                               &quot;applying each modifier to an event in the &quot;
2332                               &quot;order they are specified in this collection &quot;
2333                               &quot;Only events that satisfy all modifiers &quot;
2334                               &quot;are reported. A value of 0 means there are no &quot;
2335                               &quot;modifiers in the request.&quot;
2336                               &quot;&lt;p&gt;&quot;
2337                               &quot;Filtering can improve &quot;
2338                               &quot;debugger performance dramatically by
2339                               &quot;reducing the &quot;
2340                               &quot;amount of event traffic sent from the &quot;
2341                               &quot;target VM to the debugger VM. &quot;
2342                 (Select Modifier
2343                     (byte modKind &quot;Modifier kind&quot;)
2344                     (Alt Count=1
2345                         &quot;Limit the requested event to be reported at most once after a &quot;
2346                         &quot;given number of occurrences.  The event is not reported &quot;
2347                         &quot;the first &lt;code&gt;count - 1&lt;/code&gt; times this filter is reached. &quot;
2348                         &quot;To request a one-off event, call this method with a count of 1. &quot;
2349                         &quot;&lt;p&gt;&quot;
2350                         &quot;Once the count reaches 0, any subsequent filters in this request &quot;
2351                         &quot;are applied. If none of those filters cause the event to be &quot;
2352                         &quot;suppressed, the event is reported. Otherwise, the event is not &quot;
2353                         &quot;reported. In either case subsequent events are never reported for &quot;
2354                         &quot;this request. &quot;
2355                         &quot;This modifier can be used with any event kind.&quot;
2356 
2357                         (int count &quot;Count before event. One for one-off.&quot;)
2358                     )
2359                     (Alt Conditional=2 &quot;Conditional on expression&quot;
2360                         (int exprID &quot;For the future&quot;)
2361                     )
2362                     (Alt ThreadOnly=3
2363                         &quot;Restricts reported events to &quot;
2364                         &quot;those in the given thread. &quot;
2365                         &quot;This modifier can be used with any event kind &quot;
2366                         &quot;except for class unload. &quot;
2367 
2368                         (threadObject thread &quot;Required thread&quot;)
2369                     )
2370                     (Alt ClassOnly=4
2371                         &quot;For class prepare events, restricts the events &quot;
2372                         &quot;generated by this request to be the &quot;
2373                         &quot;preparation of the given reference type and any subtypes. &quot;
2374                         &quot;For monitor wait and waited events, restricts the events &quot;
2375                         &quot;generated by this request to those whose monitor object &quot;
2376                         &quot;is of the given reference type or any of its subtypes. &quot;
2377                         &quot;For other events, restricts the events generated &quot;
2378                         &quot;by this request to those &quot;
2379                         &quot;whose location is in the given reference type or any of its subtypes. &quot;
2380                         &quot;An event will be generated for any location in a reference type that can &quot;
2381                         &quot;be safely cast to the given reference type. &quot;
2382                         &quot;This modifier can be used with any event kind except &quot;
2383                         &quot;class unload, thread start, and thread end. &quot;
2384 
2385                         (referenceType clazz &quot;Required class&quot;)
2386                     )
2387                     (Alt ClassMatch=5
2388                         &quot;Restricts reported events to those for classes whose name &quot;
2389                         &quot;matches the given restricted regular expression. &quot;
2390                         &quot;For class prepare events, the prepared class name &quot;
2391                         &quot;is matched. For class unload events, the &quot;
2392                         &quot;unloaded class name is matched. For monitor wait &quot;
2393                         &quot;and waited events, the name of the class of the &quot;
2394                         &quot;monitor object is matched. For other events, &quot;
2395                         &quot;the class name of the event&#39;s location is matched. &quot;
2396                         &quot;This modifier can be used with any event kind except &quot;
2397                         &quot;thread start and thread end. &quot;
2398 
2399                         (string classPattern &quot;Required class pattern. &quot;
2400                                 &quot;Matches are limited to exact matches of the &quot;
2401                                 &quot;given class pattern and matches of patterns that &quot;
2402                                 &quot;begin or end with &#39;*&#39;; for example, &quot;
2403                                 &quot;\&quot;*.Foo\&quot; or \&quot;java.*\&quot;. &quot;
2404                         )
2405 
2406                     )
2407                     (Alt ClassExclude=6
2408                         &quot;Restricts reported events to those for classes whose name &quot;
2409                         &quot;does not match the given restricted regular expression. &quot;
2410                         &quot;For class prepare events, the prepared class name &quot;
2411                         &quot;is matched. For class unload events, the &quot;
2412                         &quot;unloaded class name is matched. For monitor wait and &quot;
2413                         &quot;waited events, the name of the class of the monitor &quot;
2414                         &quot;object is matched. For other events, &quot;
2415                         &quot;the class name of the event&#39;s location is matched. &quot;
2416                         &quot;This modifier can be used with any event kind except &quot;
2417                         &quot;thread start and thread end. &quot;
2418 
2419                         (string classPattern &quot;Disallowed class pattern. &quot;
2420                                 &quot;Matches are limited to exact matches of the &quot;
2421                                 &quot;given class pattern and matches of patterns that &quot;
2422                                 &quot;begin or end with &#39;*&#39;; for example, &quot;
2423                                 &quot;\&quot;*.Foo\&quot; or \&quot;java.*\&quot;. &quot;
2424                         )
2425                     )
2426                     (Alt LocationOnly=7
2427                         &quot;Restricts reported events to those that occur at &quot;
2428                         &quot;the given location. &quot;
2429                         &quot;This modifier can be used with &quot;
2430                         &quot;breakpoint, field access, field modification, &quot;
2431                         &quot;step, and exception event kinds. &quot;
2432 
2433                         (location loc &quot;Required location&quot;)
2434                     )
2435                     (Alt ExceptionOnly=8
2436                         &quot;Restricts reported exceptions by their class and &quot;
2437                         &quot;whether they are caught or uncaught. &quot;
2438                         &quot;This modifier can be used with &quot;
2439                         &quot;exception event kinds only. &quot;
2440 
2441                         (referenceType exceptionOrNull
2442                                 &quot;Exception to report. Null (0) means report &quot;
2443                                 &quot;exceptions of all types. &quot;
2444                                 &quot;A non-null type restricts the reported exception &quot;
2445                                 &quot;events to exceptions of the given type or &quot;
2446                                 &quot;any of its subtypes. &quot;
2447                         )
2448                         (boolean caught &quot;Report caught exceptions&quot;)
2449                         (boolean uncaught &quot;Report uncaught exceptions. &quot;
2450                                 &quot;Note that it &quot;
2451                                 &quot;is not always possible to determine whether an &quot;
2452                                 &quot;exception is caught or uncaught at the time it is &quot;
2453                                 &quot;thrown. See the exception event catch location under &quot;
2454                                 &quot;&lt;a href=\&quot;#JDWP_Event_Composite\&quot;&gt;composite events&lt;/a&gt; &quot;
2455                                 &quot;for more information. &quot;
2456                         )
2457 
2458                     )
2459                     (Alt FieldOnly=9
2460                         &quot;Restricts reported events to those that occur for &quot;
2461                         &quot;a given field. &quot;
2462                         &quot;This modifier can be used with &quot;
2463                         &quot;field access and field modification event kinds only. &quot;
2464 
2465                         (referenceType declaring &quot;Type in which field is declared.&quot;)
2466                         (field fieldID &quot;Required field&quot;)
2467                     )
2468                     (Alt Step=10
2469                         &quot;Restricts reported step events &quot;
2470                         &quot;to those which satisfy &quot;
2471                         &quot;depth and size constraints. &quot;
2472                         &quot;This modifier can be used with &quot;
2473                         &quot;step event kinds only. &quot;
2474 
2475                         (threadObject thread &quot;Thread in which to step&quot;)
2476                         (int size &quot;size of each step. &quot;
2477                            &quot;See &lt;a href=\&quot;#JDWP_StepSize\&quot;&gt;JDWP.StepSize&lt;/a&gt;&quot;)
2478                         (int depth &quot;relative call stack limit. &quot;
2479                            &quot;See &lt;a href=\&quot;#JDWP_StepDepth\&quot;&gt;JDWP.StepDepth&lt;/a&gt;&quot;)
2480                     )
2481                     (Alt InstanceOnly=11
2482                         &quot;Restricts reported events to those whose &quot;
2483                         &quot;active &#39;this&#39; object is the given object. &quot;
2484                         &quot;Match value is the null object for static methods. &quot;
2485                         &quot;This modifier can be used with any event kind &quot;
2486                         &quot;except class prepare, class unload, thread start, &quot;
2487                         &quot;and thread end. Introduced in JDWP version 1.4.&quot;
2488 
2489                         (object instance &quot;Required &#39;this&#39; object&quot;)
2490                     )
2491                     (Alt SourceNameMatch=12
2492                         &quot;Restricts reported class prepare events to those &quot;
2493                         &quot;for reference types which have a source name &quot;
2494                         &quot;which matches the given restricted regular expression. &quot;
2495                         &quot;The source names are determined by the reference type&#39;s &quot;
2496                         &quot;&lt;a href=\&quot;#JDWP_ReferenceType_SourceDebugExtension\&quot;&gt; &quot;
2497                         &quot;SourceDebugExtension&lt;/a&gt;. &quot;
2498                         &quot;This modifier can only be used with class prepare &quot;
2499                         &quot;events. &quot;
2500                         &quot;Since JDWP version 1.6. Requires the canUseSourceNameFilters &quot;
2501                         &quot;capability - see &quot;
2502                         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
2503 
2504                         (string sourceNamePattern &quot;Required source name pattern. &quot;
2505                                 &quot;Matches are limited to exact matches of the &quot;
2506                                 &quot;given pattern and matches of patterns that &quot;
2507                                 &quot;begin or end with &#39;*&#39;; for example, &quot;
2508                                 &quot;\&quot;*.Foo\&quot; or \&quot;java.*\&quot;. &quot;
2509                         )
2510                     )
2511 
2512                 )
2513             )
2514         )
2515         (Reply
2516             (int requestID &quot;ID of created request&quot;)
2517         )
2518         (ErrorSet
2519             (Error INVALID_THREAD)
2520             (Error INVALID_CLASS)
2521             (Error INVALID_STRING)
2522             (Error INVALID_OBJECT)
2523             (Error INVALID_COUNT)
2524             (Error INVALID_FIELDID)
2525             (Error INVALID_METHODID)
2526             (Error INVALID_LOCATION)
2527             (Error INVALID_EVENT_TYPE)
2528             (Error NOT_IMPLEMENTED)
2529             (Error VM_DEAD)
2530         )
2531     )
2532     (Command Clear=2
2533         &quot;Clear an event request. See &lt;a href=\&quot;#JDWP_EventKind\&quot;&gt;JDWP.EventKind&lt;/a&gt; &quot;
2534         &quot;for a complete list of events that can be cleared. Only the event request matching &quot;
2535         &quot;the specified event kind and requestID is cleared. If there isn&#39;t a matching event &quot;
2536         &quot;request the command is a no-op and does not result in an error. Automatically &quot;
2537         &quot;generated events do not have a corresponding event request and may not be cleared &quot;
2538         &quot;using this command.&quot;
2539         (Out
2540             (byte eventKind &quot;Event kind to clear&quot;)
2541             (int requestID &quot;ID of request to clear&quot;)
2542         )
2543         (Reply &quot;none&quot;
2544         )
2545         (ErrorSet
2546             (Error VM_DEAD)
2547             (Error INVALID_EVENT_TYPE)
2548         )
2549     )
2550     (Command ClearAllBreakpoints=3
2551         &quot;Removes all set breakpoints, a no-op if there are no breakpoints set.&quot;
2552         (Out &quot;none&quot;
2553         )
2554         (Reply &quot;none&quot;
2555         )
2556         (ErrorSet
2557             (Error VM_DEAD)
2558         )
2559     )
2560 )
2561 (CommandSet StackFrame=16
2562     (Command GetValues=1
2563         &quot;Returns the value of one or more local variables in a &quot;
2564         &quot;given frame. Each variable must be visible at the frame&#39;s code index. &quot;
2565         &quot;Even if local variable information is not available, values can &quot;
2566         &quot;be retrieved if the front-end is able to &quot;
2567         &quot;determine the correct local variable index. (Typically, this &quot;
2568         &quot;index can be determined for method arguments from the method &quot;
2569         &quot;signature without access to the local variable table information.) &quot;
2570         (Out
2571             (threadObject thread &quot;The frame&#39;s thread. &quot;)
2572             (frame frame &quot;The frame ID. &quot;)
2573             (Repeat slots &quot;The number of values to get. &quot;
2574                 (Group SlotInfo
2575                     (int slot &quot;The local variable&#39;s index in the frame. &quot;)
2576                     (byte sigbyte &quot;A &lt;a href=\&quot;#JDWP_Tag\&quot;&gt;tag&lt;/a&gt; &quot;
2577                                   &quot;identifying the type of the variable &quot;)
2578                 )
2579             )
2580         )
2581         (Reply
2582             (Repeat values &quot;The number of values retrieved, always equal to slots, &quot;
2583                            &quot;the number of values to get.&quot;
2584                 (value slotValue &quot;The value of the local variable. &quot;)
2585             )
2586         )
2587         (ErrorSet
2588             (Error INVALID_THREAD)
2589             (Error INVALID_OBJECT)
2590             (Error INVALID_FRAMEID)
2591             (Error INVALID_SLOT)
2592             (Error VM_DEAD)
2593         )
2594     )
2595     (Command SetValues=2
2596         &quot;Sets the value of one or more local variables. &quot;
2597         &quot;Each variable must be visible at the current frame code index. &quot;
2598         &quot;For primitive values, the value&#39;s type must match the &quot;
2599         &quot;variable&#39;s type exactly. For object values, there must be a &quot;
2600         &quot;widening reference conversion from the value&#39;s type to the
2601         &quot;variable&#39;s type and the variable&#39;s type must be loaded. &quot;
2602         &quot;&lt;p&gt;&quot;
2603         &quot;Even if local variable information is not available, values can &quot;
2604         &quot;be set, if the front-end is able to &quot;
2605         &quot;determine the correct local variable index. (Typically, this
2606         &quot;index can be determined for method arguments from the method &quot;
2607         &quot;signature without access to the local variable table information.) &quot;
2608         (Out
2609             (threadObject thread &quot;The frame&#39;s thread. &quot;)
2610             (frame frame &quot;The frame ID. &quot;)
2611             (Repeat slotValues &quot;The number of values to set. &quot;
2612                 (Group SlotInfo
2613                     (int slot &quot;The slot ID. &quot;)
2614                     (value slotValue &quot;The value to set. &quot;)
2615                 )
2616             )
2617         )
2618         (Reply &quot;none&quot;
2619         )
2620         (ErrorSet
2621             (Error INVALID_THREAD)
2622             (Error INVALID_OBJECT)
2623             (Error INVALID_FRAMEID)
2624             (Error VM_DEAD)
2625         )
2626     )
2627     (Command ThisObject=3
2628         &quot;Returns the value of the &#39;this&#39; reference for this frame. &quot;
2629         &quot;If the frame&#39;s method is static or native, the reply &quot;
2630         &quot;will contain the null object reference. &quot;
2631         (Out
2632             (threadObject thread &quot;The frame&#39;s thread. &quot;)
2633             (frame frame &quot;The frame ID. &quot;)
2634         )
2635         (Reply
2636             (tagged-object objectThis &quot;The &#39;this&#39; object for this frame. &quot;)
2637         )
2638         (ErrorSet
2639             (Error INVALID_THREAD)
2640             (Error INVALID_OBJECT)
2641             (Error INVALID_FRAMEID)
2642             (Error VM_DEAD)
2643         )
2644     )
2645     (Command PopFrames=4
2646         &quot;Pop the top-most stack frames of the thread stack, up to, and including &#39;frame&#39;. &quot;
2647         &quot;The thread must be suspended to perform this command. &quot;
2648         &quot;The top-most stack frames are discarded and the stack frame previous to &#39;frame&#39; &quot;
2649         &quot;becomes the current frame. The operand stack is restored -- the argument values &quot;
2650         &quot;are added back and if the invoke was not &lt;code&gt;invokestatic&lt;/code&gt;, &quot;
2651         &quot;&lt;code&gt;objectref&lt;/code&gt; is added back as well. The Java virtual machine &quot;
2652         &quot;program counter is restored to the opcode of the invoke instruction.&quot;
2653         &quot;&lt;p&gt;&quot;
2654         &quot;Since JDWP version 1.4. Requires canPopFrames capability - see &quot;
2655         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
2656         (Out
2657             (threadObject thread &quot;The thread object ID. &quot;)
2658             (frame frame &quot;The frame ID. &quot;)
2659         )
2660         (Reply &quot;none&quot;
2661         )
2662         (ErrorSet
2663             (Error INVALID_THREAD)
2664             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
2665             (Error INVALID_FRAMEID)
2666             (Error THREAD_NOT_SUSPENDED)
2667             (Error NO_MORE_FRAMES)
2668             (Error INVALID_FRAMEID)
2669             (Error NOT_IMPLEMENTED)
2670             (Error VM_DEAD)
2671         )
2672     )
2673 )
2674 (CommandSet ClassObjectReference=17
2675     (Command ReflectedType = 1
2676         &quot;Returns the reference type reflected by this class object.&quot;
2677         (Out
2678             (classObject classObject &quot;The class object. &quot;)
2679         )
2680         (Reply
2681             (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
2682                               &quot;of following reference type. &quot;)
2683             (referenceTypeID typeID &quot;reflected reference type&quot;)
2684         )
2685         (ErrorSet
2686             (Error INVALID_OBJECT)
2687             (Error VM_DEAD)
2688         )
2689     )
2690 )
2691 (CommandSet ModuleReference=18
2692     (Command Name=1
2693         &quot;Returns the name of this module.&quot;
2694         &quot;&lt;p&gt;Since JDWP version 9.&quot;
2695         (Out
2696             (moduleID module &quot;This module.&quot;)
2697         )
2698         (Reply
2699             (string name  &quot;The module&#39;s name.&quot;)
2700         )
2701         (ErrorSet
2702             (Error INVALID_MODULE)
2703             (Error NOT_IMPLEMENTED)
2704             (Error VM_DEAD)
2705         )
2706     )
2707     (Command ClassLoader=2
2708         &quot;Returns the class loader of this module.&quot;
2709         &quot;&lt;p&gt;Since JDWP version 9.&quot;
2710         (Out
2711             (moduleID module &quot;This module.&quot;)
2712         )
2713         (Reply
2714             (classLoaderObject classLoader  &quot;The module&#39;s class loader.&quot;)
2715         )
2716         (ErrorSet
2717             (Error INVALID_MODULE)
2718             (Error NOT_IMPLEMENTED)
2719             (Error VM_DEAD)
2720         )
2721     )
2722 )
2723 (CommandSet Event=64
2724     (Command Composite=100
2725         &quot;Several events may occur at a given time in the target VM. &quot;
2726         &quot;For example, there may be more than one breakpoint request &quot;
2727         &quot;for a given location &quot;
2728         &quot;or you might single step to the same location as a &quot;
2729         &quot;breakpoint request.  These events are delivered &quot;
2730         &quot;together as a composite event.  For uniformity, a &quot;
2731         &quot;composite event is always used &quot;
2732         &quot;to deliver events, even if there is only one event to report. &quot;
2733         &quot;&lt;P&gt;&quot;
2734         &quot;The events that are grouped in a composite event are restricted in the &quot;
2735         &quot;following ways: &quot;
2736         &quot;&lt;UL&gt;&quot;
2737         &quot;&lt;LI&gt;Only with other thread start events for the same thread:&quot;
2738         &quot;    &lt;UL&gt;&quot;
2739         &quot;    &lt;LI&gt;Thread Start Event&quot;
2740         &quot;    &lt;/UL&gt;&quot;
2741         &quot;&lt;LI&gt;Only with other thread death events for the same thread:&quot;
2742         &quot;    &lt;UL&gt;&quot;
2743         &quot;    &lt;LI&gt;Thread Death Event&quot;
2744         &quot;    &lt;/UL&gt;&quot;
2745         &quot;&lt;LI&gt;Only with other class prepare events for the same class:&quot;
2746         &quot;    &lt;UL&gt;&quot;
2747         &quot;    &lt;LI&gt;Class Prepare Event&quot;
2748         &quot;    &lt;/UL&gt;&quot;
2749         &quot;&lt;LI&gt;Only with other class unload events for the same class:&quot;
2750         &quot;    &lt;UL&gt;&quot;
2751         &quot;    &lt;LI&gt;Class Unload Event&quot;
2752         &quot;    &lt;/UL&gt;&quot;
2753         &quot;&lt;LI&gt;Only with other access watchpoint events for the same field access:&quot;
2754         &quot;    &lt;UL&gt;&quot;
2755         &quot;    &lt;LI&gt;Access Watchpoint Event&quot;
2756         &quot;    &lt;/UL&gt;&quot;
2757         &quot;&lt;LI&gt;Only with other modification watchpoint events for the same field &quot;
2758         &quot;modification:&quot;
2759         &quot;    &lt;UL&gt;&quot;
2760         &quot;    &lt;LI&gt;Modification Watchpoint Event&quot;
2761         &quot;    &lt;/UL&gt;&quot;
2762         &quot;&lt;LI&gt;Only with other Monitor contended enter events for the same monitor object: &quot;
2763         &quot;    &lt;UL&gt;&quot;
2764         &quot;    &lt;LI&gt;Monitor Contended Enter Event&quot;
2765         &quot;    &lt;/UL&gt;&quot;
2766         &quot;&lt;LI&gt;Only with other Monitor contended entered events for the same monitor object: &quot;
2767         &quot;    &lt;UL&gt;&quot;
2768         &quot;    &lt;LI&gt;Monitor Contended Entered Event&quot;
2769         &quot;    &lt;/UL&gt;&quot;
2770         &quot;&lt;LI&gt;Only with other Monitor wait events for the same monitor object: &quot;
2771         &quot;    &lt;UL&gt;&quot;
2772         &quot;    &lt;LI&gt;Monitor Wait Event&quot;
2773         &quot;    &lt;/UL&gt;&quot;
2774         &quot;&lt;LI&gt;Only with other Monitor waited events for the same monitor object: &quot;
2775         &quot;    &lt;UL&gt;&quot;
2776         &quot;    &lt;LI&gt;Monitor Waited Event&quot;
2777         &quot;    &lt;/UL&gt;&quot;
2778         &quot;&lt;LI&gt;Only with other ExceptionEvents for the same exception occurrance:&quot;
2779         &quot;    &lt;UL&gt;&quot;
2780         &quot;    &lt;LI&gt;ExceptionEvent&quot;
2781         &quot;    &lt;/UL&gt;&quot;
2782         &quot;&lt;LI&gt;Only with other members of this group, at the same location &quot;
2783         &quot;and in the same thread: &quot;
2784         &quot;    &lt;UL&gt;&quot;
2785         &quot;    &lt;LI&gt;Breakpoint Event&quot;
2786         &quot;    &lt;LI&gt;Step Event&quot;
2787         &quot;    &lt;LI&gt;Method Entry Event&quot;
2788         &quot;    &lt;LI&gt;Method Exit Event&quot;
2789         &quot;    &lt;/UL&gt;&quot;
2790         &quot;&lt;/UL&gt;&quot;
2791         &quot;&lt;P&gt;&quot;
2792         &quot;The VM Start Event and VM Death Event are automatically generated events. &quot;
2793         &quot;This means they do not need to be requested using the &quot;
2794         &quot;&lt;a href=\&quot;#JDWP_EventRequest_Set\&quot;&gt;EventRequest.Set&lt;/a&gt; command. &quot;
2795         &quot;The VM Start event signals the completion of VM initialization. The VM Death &quot;
2796         &quot;event signals the termination of the VM.&quot;
2797         &quot;If there is a debugger connected at the time when an automatically generated &quot;
2798         &quot;event occurs it is sent from the target VM. Automatically generated events may &quot;
2799         &quot;also be requested using the EventRequest.Set command and thus multiple events &quot;
2800         &quot;of the same event kind will be sent from the target VM when an event occurs.&quot;
2801         &quot;Automatically generated events are sent with the requestID field &quot;
2802         &quot;in the Event Data set to 0. The value of the suspendPolicy field in the &quot;
2803         &quot;Event Data depends on the event. For the automatically generated VM Start &quot;
2804         &quot;Event the value of suspendPolicy is not defined and is therefore implementation &quot;
2805         &quot;or configuration specific. In the Sun implementation, for example, the &quot;
2806         &quot;suspendPolicy is specified as an option to the JDWP agent at launch-time.&quot;
2807         &quot;The automatically generated VM Death Event will have the suspendPolicy set to &quot;
2808         &quot;NONE.&quot;
2809 
2810        (Event &quot;Generated event&quot;
2811             (byte suspendPolicy
2812                 &quot;Which threads where suspended by this composite event?&quot;)
2813             (Repeat events &quot;Events in set.&quot;
2814                 (Select Events
2815                     (byte eventKind &quot;Event kind selector&quot;)
2816                     (Alt VMStart=JDWP.EventKind.VM_START
2817                         &quot;Notification of initialization of a target VM.  This event is &quot;
2818                         &quot;received before the main thread is started and before any &quot;
2819                         &quot;application code has been executed. Before this event occurs &quot;
2820                         &quot;a significant amount of system code has executed and a number &quot;
2821                         &quot;of system classes have been loaded. &quot;
2822                         &quot;This event is always generated by the target VM, even &quot;
2823                         &quot;if not explicitly requested.&quot;
2824 
2825                      (int requestID
2826                              &quot;Request that generated event (or 0 if this &quot;
2827                              &quot;event is automatically generated.&quot;)
2828                         (threadObject thread &quot;Initial thread&quot;)
2829                     )
2830                     (Alt SingleStep=JDWP.EventKind.SINGLE_STEP
2831                         &quot;Notification of step completion in the target VM. The step event &quot;
2832                         &quot;is generated before the code at its location is executed. &quot;
2833 
2834                         (int requestID &quot;Request that generated event&quot;)
2835                         (threadObject thread &quot;Stepped thread&quot;)
2836                         (location location &quot;Location stepped to&quot;)
2837                     )
2838                     (Alt Breakpoint=JDWP.EventKind.BREAKPOINT
2839                         &quot;Notification of a breakpoint in the target VM. The breakpoint event &quot;
2840                         &quot;is generated before the code at its location is executed. &quot;
2841 
2842                         (int requestID &quot;Request that generated event&quot;)
2843                         (threadObject thread &quot;Thread which hit breakpoint&quot;)
2844                         (location location &quot;Location hit&quot;)
2845                     )
2846                     (Alt MethodEntry=JDWP.EventKind.METHOD_ENTRY
2847                          &quot;Notification of a method invocation in the target VM. This event &quot;
2848                          &quot;is generated before any code in the invoked method has executed. &quot;
2849                          &quot;Method entry events are generated for both native and non-native &quot;
2850                          &quot;methods. &quot;
2851                          &quot;&lt;P&gt;&quot;
2852                          &quot;In some VMs method entry events can occur for a particular thread &quot;
2853                          &quot;before its thread start event occurs if methods are called &quot;
2854                          &quot;as part of the thread&#39;s initialization. &quot;
2855 
2856                         (int requestID &quot;Request that generated event&quot;)
2857                         (threadObject thread &quot;Thread which entered method&quot;)
2858                         (location location &quot;The initial executable location in the method.&quot;)
2859                     )
2860                     (Alt MethodExit=JDWP.EventKind.METHOD_EXIT
2861                          &quot;Notification of a method return in the target VM. This event &quot;
2862                          &quot;is generated after all code in the method has executed, but the &quot;
2863                          &quot;location of this event is the last executed location in the method. &quot;
2864                          &quot;Method exit events are generated for both native and non-native &quot;
2865                          &quot;methods. Method exit events are not generated if the method terminates &quot;
2866                          &quot;with a thrown exception. &quot;
2867 
2868                         (int requestID &quot;Request that generated event&quot;)
2869                         (threadObject thread &quot;Thread which exited method&quot;)
2870                         (location location &quot;Location of exit&quot;)
2871                     )
2872                     (Alt MethodExitWithReturnValue=JDWP.EventKind.METHOD_EXIT_WITH_RETURN_VALUE
2873                          &quot;Notification of a method return in the target VM. This event &quot;
2874                          &quot;is generated after all code in the method has executed, but the &quot;
2875                          &quot;location of this event is the last executed location in the method. &quot;
2876                          &quot;Method exit events are generated for both native and non-native &quot;
2877                          &quot;methods. Method exit events are not generated if the method terminates &quot;
2878                          &quot;with a thrown exception. &lt;p&gt;Since JDWP version 1.6. &quot;
2879 
2880                         (int requestID &quot;Request that generated event&quot;)
2881                         (threadObject thread &quot;Thread which exited method&quot;)
2882                         (location location &quot;Location of exit&quot;)
2883                         (value value &quot;Value that will be returned by the method&quot;)
2884                     )
2885                     (Alt MonitorContendedEnter=JDWP.EventKind.MONITOR_CONTENDED_ENTER
2886                          &quot;Notification that a thread in the target VM is attempting &quot;
2887                          &quot;to enter a monitor that is already acquired by another thread. &quot;
2888                          &quot;Requires canRequestMonitorEvents capability - see &quot;
2889                          &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2890                          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2891 
2892                         (int requestID
2893                                 &quot;Request that generated event&quot;)
2894                         (threadObject thread &quot;Thread which is trying to enter the monitor&quot;)
2895                         (tagged-object object &quot;Monitor object reference&quot;)
2896                         (location location &quot;Location of contended monitor enter&quot;)
2897                     )
2898                     (Alt MonitorContendedEntered=JDWP.EventKind.MONITOR_CONTENDED_ENTERED
2899                          &quot;Notification of a thread in the target VM is entering a monitor &quot;
2900                          &quot;after waiting for it to be released by another thread. &quot;
2901                          &quot;Requires canRequestMonitorEvents capability - see &quot;
2902                          &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2903                          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2904 
2905                         (int requestID
2906                                 &quot;Request that generated event&quot;)
2907                         (threadObject thread &quot;Thread which entered monitor&quot;)
2908                         (tagged-object object &quot;Monitor object reference&quot;)
2909                         (location location &quot;Location of contended monitor enter&quot;)
2910                     )
2911                     (Alt MonitorWait=JDWP.EventKind.MONITOR_WAIT
2912                          &quot;Notification of a thread about to wait on a monitor object. &quot;
2913                          &quot;Requires canRequestMonitorEvents capability - see &quot;
2914                          &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2915                          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2916 
2917                         (int requestID
2918                                 &quot;Request that generated event&quot;)
2919                         (threadObject thread &quot;Thread which is about to wait&quot;)
2920                         (tagged-object object &quot;Monitor object reference&quot;)
2921                         (location location &quot;Location at which the wait will occur&quot;)
2922                         (long     timeout  &quot;Thread wait time in milliseconds&quot;)
2923                     )
2924                     (Alt MonitorWaited=JDWP.EventKind.MONITOR_WAITED
2925                          &quot;Notification that a thread in the target VM has finished waiting on &quot;
2926                          &quot;Requires canRequestMonitorEvents capability - see &quot;
2927                          &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2928                          &quot;a monitor object. &quot;
2929                          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2930 
2931                         (int requestID
2932                                 &quot;Request that generated event&quot;)
2933                         (threadObject thread &quot;Thread which waited&quot;)
2934                         (tagged-object object &quot;Monitor object reference&quot;)
2935                         (location location &quot;Location at which the wait occured&quot;)
2936                         (boolean  timed_out &quot;True if timed out&quot;)
2937                     )
2938                     (Alt Exception=JDWP.EventKind.EXCEPTION
2939                          &quot;Notification of an exception in the target VM. &quot;
2940                          &quot;If the exception is thrown from a non-native method, &quot;
2941                          &quot;the exception event is generated at the location where the &quot;
2942                          &quot;exception is thrown. &quot;
2943                          &quot;If the exception is thrown from a native method, the exception event &quot;
2944                          &quot;is generated at the first non-native location reached after the exception &quot;
2945                          &quot;is thrown. &quot;
2946 
2947                         (int requestID &quot;Request that generated event&quot;)
2948                         (threadObject thread &quot;Thread with exception&quot;)
2949                         (location location &quot;Location of exception throw &quot;
2950                         &quot;(or first non-native location after throw if thrown from a native method)&quot;)
2951                         (tagged-object exception &quot;Thrown exception&quot;)
2952                         (location catchLocation
2953                             &quot;Location of catch, or 0 if not caught. An exception &quot;
2954                             &quot;is considered to be caught if, at the point of the throw, the &quot;
2955                             &quot;current location is dynamically enclosed in a try statement that &quot;
2956                             &quot;handles the exception. (See the JVM specification for details). &quot;
2957                             &quot;If there is such a try statement, the catch location is the &quot;
2958                             &quot;first location in the appropriate catch clause. &quot;
2959                             &quot;&lt;p&gt;&quot;
2960                             &quot;If there are native methods in the call stack at the time of the &quot;
2961                             &quot;exception, there are important restrictions to note about the &quot;
2962                             &quot;returned catch location. In such cases, &quot;
2963                             &quot;it is not possible to predict whether an exception will be handled &quot;
2964                             &quot;by some native method on the call stack. &quot;
2965                             &quot;Thus, it is possible that exceptions considered uncaught &quot;
2966                             &quot;here will, in fact, be handled by a native method and not cause &quot;
2967                             &quot;termination of the target VM. Furthermore, it cannot be assumed that the &quot;
2968                             &quot;catch location returned here will ever be reached by the throwing &quot;
2969                             &quot;thread. If there is &quot;
2970                             &quot;a native frame between the current location and the catch location, &quot;
2971                             &quot;the exception might be handled and cleared in that native method &quot;
2972                             &quot;instead. &quot;
2973                             &quot;&lt;p&gt;&quot;
2974                             &quot;Note that compilers can generate try-catch blocks in some cases &quot;
2975                             &quot;where they are not explicit in the source code; for example, &quot;
2976                             &quot;the code generated for &lt;code&gt;synchronized&lt;/code&gt; and &quot;
2977                             &quot;&lt;code&gt;finally&lt;/code&gt; blocks can contain implicit try-catch blocks. &quot;
2978                             &quot;If such an implicitly generated try-catch is &quot;
2979                             &quot;present on the call stack at the time of the throw, the exception &quot;
2980                             &quot;will be considered caught even though it appears to be uncaught from &quot;
2981                             &quot;examination of the source code. &quot;
2982                         )
2983                     )
2984                     (Alt ThreadStart=JDWP.EventKind.THREAD_START
2985                         &quot;Notification of a new running thread in the target VM. &quot;
2986                         &quot;The new thread can be the result of a call to &quot;
2987                         &quot;&lt;code&gt;java.lang.Thread.start&lt;/code&gt; or the result of &quot;
2988                         &quot;attaching a new thread to the VM though JNI. The &quot;
2989                         &quot;notification is generated by the new thread some time before &quot;
2990                         &quot;its execution starts. &quot;
2991                         &quot;Because of this timing, it is possible to receive other events &quot;
2992                         &quot;for the thread before this event is received. (Notably, &quot;
2993                         &quot;Method Entry Events and Method Exit Events might occur &quot;
2994                         &quot;during thread initialization. &quot;
2995                         &quot;It is also possible for the &quot;
2996                         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_AllThreads\&quot;&gt;VirtualMachine AllThreads&lt;/a&gt; &quot;
2997                         &quot;command to return &quot;
2998                         &quot;a thread before its thread start event is received. &quot;
2999                         &quot;&lt;p&gt;&quot;
3000                         &quot;Note that this event gives no information &quot;
3001                         &quot;about the creation of the thread object which may have happened &quot;
3002                         &quot;much earlier, depending on the VM being debugged. &quot;
3003 
3004                         (int requestID &quot;Request that generated event&quot;)
3005                         (threadObject thread &quot;Started thread&quot;)
3006                     )
3007                     (Alt ThreadDeath=JDWP.EventKind.THREAD_DEATH
3008                         &quot;Notification of a completed thread in the target VM. The &quot;
3009                         &quot;notification is generated by the dying thread before it terminates. &quot;
3010                         &quot;Because of this timing, it is possible &quot;
3011                         &quot;for {@link VirtualMachine#allThreads} to return this thread &quot;
3012                         &quot;after this event is received. &quot;
3013                         &quot;&lt;p&gt;&quot;
3014                         &quot;Note that this event gives no information &quot;
3015                         &quot;about the lifetime of the thread object. It may or may not be collected &quot;
3016                         &quot;soon depending on what references exist in the target VM. &quot;
3017 
3018                         (int requestID &quot;Request that generated event&quot;)
3019                         (threadObject thread &quot;Ending thread&quot;)
3020                     )
3021                     (Alt ClassPrepare=JDWP.EventKind.CLASS_PREPARE
3022                         &quot;Notification of a class prepare in the target VM. See the JVM &quot;
3023                         &quot;specification for a definition of class preparation. Class prepare &quot;
3024                         &quot;events are not generated for primtiive classes (for example, &quot;
3025                         &quot;java.lang.Integer.TYPE). &quot;
3026 
3027                         (int requestID &quot;Request that generated event&quot;)
3028                         (threadObject thread &quot;Preparing thread. &quot;
3029                              &quot;In rare cases, this event may occur in a debugger system &quot;
3030                              &quot;thread within the target VM. Debugger threads take precautions &quot;
3031                              &quot;to prevent these events, but they cannot be avoided under some &quot;
3032                              &quot;conditions, especially for some subclasses of &quot;
3033                              &quot;java.lang.Error. &quot;
3034                              &quot;If the event was generated by a debugger system thread, the &quot;
3035                              &quot;value returned by this method is null, and if the requested  &quot;
3036                              &quot;&lt;a href=\&quot;#JDWP_SuspendPolicy\&quot;&gt;suspend policy&lt;/a&gt; &quot;
3037                              &quot;for the event was EVENT_THREAD &quot;
3038                              &quot;all threads will be suspended instead, and the &quot;
3039                              &quot;composite event&#39;s suspend policy will reflect this change. &quot;
3040                              &quot;&lt;p&gt;&quot;
3041                              &quot;Note that the discussion above does not apply to system threads &quot;
3042                              &quot;created by the target VM during its normal (non-debug) operation. &quot;
3043                         )
3044                         (byte refTypeTag  &quot;Kind of reference type. &quot;
3045                            &quot;See &lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;JDWP.TypeTag&lt;/a&gt;&quot;)
3046                         (referenceTypeID typeID &quot;Type being prepared&quot;)
3047                         (string signature &quot;Type signature&quot;)
3048                         (int status &quot;Status of type. &quot;
3049                          &quot;See &lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;JDWP.ClassStatus&lt;/a&gt;&quot;)
3050                     )
3051                     (Alt ClassUnload=JDWP.EventKind.CLASS_UNLOAD
3052                          &quot;Notification of a class unload in the target VM. &quot;
3053                          &quot;&lt;p&gt;&quot;
3054                          &quot;There are severe constraints on the debugger back-end during &quot;
3055                          &quot;garbage collection, so unload information is greatly limited. &quot;
3056 
3057                         (int requestID &quot;Request that generated event&quot;)
3058                         (string signature &quot;Type signature&quot;)
3059                     )
3060                     (Alt FieldAccess=JDWP.EventKind.FIELD_ACCESS
3061                         &quot;Notification of a field access in the target VM. &quot;
3062                         &quot;Field modifications &quot;
3063                         &quot;are not considered field accesses. &quot;
3064                         &quot;Requires canWatchFieldAccess capability - see &quot;
3065                         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
3066 
3067                       (int requestID &quot;Request that generated event&quot;)
3068                         (threadObject thread &quot;Accessing thread&quot;)
3069                         (location location &quot;Location of access&quot;)
3070                         (byte refTypeTag  &quot;Kind of reference type. &quot;
3071                            &quot;See &lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;JDWP.TypeTag&lt;/a&gt;&quot;)
3072                         (referenceTypeID typeID &quot;Type of field&quot;)
3073                         (field fieldID &quot;Field being accessed&quot;)
3074                         (tagged-object object
3075                                 &quot;Object being accessed (null=0 for statics&quot;)
3076                     )
3077                     (Alt FieldModification=JDWP.EventKind.FIELD_MODIFICATION
3078                         &quot;Notification of a field modification in the target VM. &quot;
3079                         &quot;Requires canWatchFieldModification capability - see &quot;
3080                         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
3081 
3082                         (int requestID &quot;Request that generated event&quot;)
3083                         (threadObject thread &quot;Modifying thread&quot;)
3084                         (location location &quot;Location of modify&quot;)
3085                         (byte refTypeTag  &quot;Kind of reference type. &quot;
3086                            &quot;See &lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;JDWP.TypeTag&lt;/a&gt;&quot;)
3087                         (referenceTypeID typeID &quot;Type of field&quot;)
3088                         (field fieldID &quot;Field being modified&quot;)
3089                         (tagged-object object
3090                                 &quot;Object being modified (null=0 for statics&quot;)
3091                         (value valueToBe &quot;Value to be assigned&quot;)
3092                     )
3093                     (Alt VMDeath=JDWP.EventKind.VM_DEATH
3094                         (int requestID
3095                                 &quot;Request that generated event&quot;)
3096                     )
3097                 )
3098             )
3099         )
3100     )
3101 )
3102 (ConstantSet Error
3103     (Constant NONE                   =0   &quot;No error has occurred.&quot;)
3104     (Constant INVALID_THREAD         =10  &quot;Passed thread is null, is not a valid thread or has exited.&quot;)
3105     (Constant INVALID_THREAD_GROUP   =11  &quot;Thread group invalid.&quot;)
3106     (Constant INVALID_PRIORITY       =12  &quot;Invalid priority.&quot;)
3107     (Constant THREAD_NOT_SUSPENDED   =13  &quot;If the specified thread has not been &quot;
3108                                           &quot;suspended by an event.&quot;)
3109     (Constant THREAD_SUSPENDED       =14  &quot;Thread already suspended.&quot;)
3110     (Constant THREAD_NOT_ALIVE       =15  &quot;Thread has not been started or is now dead.&quot;)
3111 
3112     (Constant INVALID_OBJECT         =20  &quot;If this reference type has been unloaded &quot;
3113                                           &quot;and garbage collected.&quot;)
3114     (Constant INVALID_CLASS          =21  &quot;Invalid class.&quot;)
3115     (Constant CLASS_NOT_PREPARED     =22  &quot;Class has been loaded but not yet prepared.&quot;)
3116     (Constant INVALID_METHODID       =23  &quot;Invalid method.&quot;)
3117     (Constant INVALID_LOCATION       =24  &quot;Invalid location.&quot;)
3118     (Constant INVALID_FIELDID        =25  &quot;Invalid field.&quot;)
3119     (Constant INVALID_FRAMEID        =30  &quot;Invalid jframeID.&quot;)
3120     (Constant NO_MORE_FRAMES         =31  &quot;There are no more Java or JNI frames on the &quot;
3121                                           &quot;call stack.&quot;)
3122     (Constant OPAQUE_FRAME           =32  &quot;Information about the frame is not available.&quot;)
3123     (Constant NOT_CURRENT_FRAME      =33  &quot;Operation can only be performed on current frame.&quot;)
3124     (Constant TYPE_MISMATCH          =34  &quot;The variable is not an appropriate type for &quot;
3125                                           &quot;the function used.&quot;)
3126     (Constant INVALID_SLOT           =35  &quot;Invalid slot.&quot;)
3127     (Constant DUPLICATE              =40  &quot;Item already set.&quot;)
3128     (Constant NOT_FOUND              =41  &quot;Desired element not found.&quot;)
3129     (Constant INVALID_MODULE         =42  &quot;Invalid module.&quot;)
3130     (Constant INVALID_MONITOR        =50  &quot;Invalid monitor.&quot;)
3131     (Constant NOT_MONITOR_OWNER      =51  &quot;This thread doesn&#39;t own the monitor.&quot;)
3132     (Constant INTERRUPT              =52  &quot;The call has been interrupted before completion.&quot;)
3133     (Constant INVALID_CLASS_FORMAT   =60  &quot;The virtual machine attempted to read a class &quot;
3134                                           &quot;file and determined that the file is malformed &quot;
3135                                           &quot;or otherwise cannot be interpreted as a class file.&quot;)
3136     (Constant CIRCULAR_CLASS_DEFINITION
3137                                      =61  &quot;A circularity has been detected while &quot;
3138                                           &quot;initializing a class.&quot;)
3139     (Constant FAILS_VERIFICATION     =62  &quot;The verifier detected that a class file, &quot;
3140                                           &quot;though well formed, contained some sort of &quot;
3141                                           &quot;internal inconsistency or security problem.&quot;)
3142     (Constant ADD_METHOD_NOT_IMPLEMENTED
3143                                      =63  &quot;Adding methods has not been implemented.&quot;)
3144     (Constant SCHEMA_CHANGE_NOT_IMPLEMENTED
3145                                      =64  &quot;Schema change has not been implemented.&quot;)
3146     (Constant INVALID_TYPESTATE      =65  &quot;The state of the thread has been modified, &quot;
3147                                           &quot;and is now inconsistent.&quot;)
3148     (Constant HIERARCHY_CHANGE_NOT_IMPLEMENTED
3149                                      =66  &quot;A direct superclass is different for the new class &quot;
3150                                           &quot;version, or the set of directly implemented &quot;
3151                                           &quot;interfaces is different &quot;
3152                                           &quot;and canUnrestrictedlyRedefineClasses is false.&quot;)
3153     (Constant DELETE_METHOD_NOT_IMPLEMENTED
3154                                      =67  &quot;The new class version does not declare a method &quot;
3155                                           &quot;declared in the old class version &quot;
3156                                           &quot;and canUnrestrictedlyRedefineClasses is false.&quot;)
3157     (Constant UNSUPPORTED_VERSION    =68  &quot;A class file has a version number not supported &quot;
3158                                           &quot;by this VM.&quot;)
3159     (Constant NAMES_DONT_MATCH       =69  &quot;The class name defined in the new class file is &quot;
3160                                           &quot;different from the name in the old class object.&quot;)
3161     (Constant CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED
3162                                      =70  &quot;The new class version has different modifiers and &quot;
3163                                           &quot;canUnrestrictedlyRedefineClasses is false.&quot;)
3164     (Constant METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED
3165                                      =71  &quot;A method in the new class version has &quot;
3166                                           &quot;different modifiers &quot;
3167                                           &quot;than its counterpart in the old class version and &quot;
3168                                           &quot;canUnrestrictedlyRedefineClasses is false.&quot;)
3169     (Constant CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED
<a name="4" id="anc4"></a><span class="line-modified">3170                                      =72  &quot;The new class version has different NestHost or &quot;</span>
<span class="line-modified">3171                                           &quot;NestMembers class attribute and &quot;</span>
3172                                           &quot;canUnrestrictedlyRedefineClasses is false.&quot;)
3173     (Constant NOT_IMPLEMENTED        =99  &quot;The functionality is not implemented in &quot;
3174                                           &quot;this virtual machine.&quot;)
3175     (Constant NULL_POINTER           =100 &quot;Invalid pointer.&quot;)
3176     (Constant ABSENT_INFORMATION     =101 &quot;Desired information is not available.&quot;)
3177     (Constant INVALID_EVENT_TYPE     =102 &quot;The specified event type id is not recognized.&quot;)
3178     (Constant ILLEGAL_ARGUMENT       =103 &quot;Illegal argument.&quot;)
3179     (Constant OUT_OF_MEMORY          =110 &quot;The function needed to allocate memory and &quot;
3180                                           &quot;no more memory was available for allocation.&quot;)
3181     (Constant ACCESS_DENIED          =111 &quot;Debugging has not been enabled in this &quot;
3182                                           &quot;virtual machine. JVMTI cannot be used.&quot;)
3183     (Constant VM_DEAD                =112 &quot;The virtual machine is not running.&quot;)
3184     (Constant INTERNAL               =113 &quot;An unexpected internal error has occurred.&quot;)
3185     (Constant UNATTACHED_THREAD      =115 &quot;The thread being used to call this function &quot;
3186                                           &quot;is not attached to the virtual machine. &quot;
3187                                           &quot;Calls must be made from attached threads.&quot;)
3188     (Constant INVALID_TAG            =500 &quot;object type id or class tag.&quot;)
3189     (Constant ALREADY_INVOKING       =502 &quot;Previous invoke not complete.&quot;)
3190     (Constant INVALID_INDEX          =503 &quot;Index is invalid.&quot;)
3191     (Constant INVALID_LENGTH         =504 &quot;The length is invalid.&quot;)
3192     (Constant INVALID_STRING         =506 &quot;The string is invalid.&quot;)
3193     (Constant INVALID_CLASS_LOADER   =507 &quot;The class loader is invalid.&quot;)
3194     (Constant INVALID_ARRAY          =508 &quot;The array is invalid.&quot;)
3195     (Constant TRANSPORT_LOAD         =509 &quot;Unable to load the transport.&quot;)
3196     (Constant TRANSPORT_INIT         =510 &quot;Unable to initialize the transport.&quot;)
3197     (Constant NATIVE_METHOD          =511  )
3198     (Constant INVALID_COUNT          =512 &quot;The count is invalid.&quot;)
3199 )
3200 (ConstantSet EventKind
3201     (Constant SINGLE_STEP            =1   )
3202     (Constant BREAKPOINT             =2   )
3203     (Constant FRAME_POP              =3   )
3204     (Constant EXCEPTION              =4   )
3205     (Constant USER_DEFINED           =5   )
3206     (Constant THREAD_START           =6   )
3207     (Constant THREAD_DEATH           =7   )
3208     (Constant THREAD_END             =7   &quot;obsolete - was used in jvmdi&quot;)
3209     (Constant CLASS_PREPARE          =8   )
3210     (Constant CLASS_UNLOAD           =9   )
3211     (Constant CLASS_LOAD             =10  )
3212     (Constant FIELD_ACCESS           =20  )
3213     (Constant FIELD_MODIFICATION     =21  )
3214     (Constant EXCEPTION_CATCH        =30  )
3215     (Constant METHOD_ENTRY           =40  )
3216     (Constant METHOD_EXIT            =41  )
3217     (Constant METHOD_EXIT_WITH_RETURN_VALUE =42  )
3218     (Constant MONITOR_CONTENDED_ENTER          =43  )
3219     (Constant MONITOR_CONTENDED_ENTERED        =44 )
3220     (Constant MONITOR_WAIT           =45 )
3221     (Constant MONITOR_WAITED         =46 )
3222     (Constant VM_START               =90  )
3223     (Constant VM_INIT                =90  &quot;obsolete - was used in jvmdi&quot;)
3224     (Constant VM_DEATH               =99  )
3225     (Constant VM_DISCONNECTED        =100 &quot;Never sent across JDWP&quot;)
3226 )
3227 
3228 (ConstantSet ThreadStatus
3229     (Constant ZOMBIE                 =0  )
3230     (Constant RUNNING                =1  )
3231     (Constant SLEEPING               =2  )
3232     (Constant MONITOR                =3  )
3233     (Constant WAIT                   =4  )
3234 )
3235 
3236 (ConstantSet SuspendStatus
3237     (Constant SUSPEND_STATUS_SUSPENDED = 0x1 )
3238 )
3239 (ConstantSet ClassStatus
3240     (Constant VERIFIED               =1  )
3241     (Constant PREPARED               =2  )
3242     (Constant INITIALIZED            =4  )
3243     (Constant ERROR                  =8  )
3244 )
3245 (ConstantSet TypeTag
3246     (Constant CLASS=1 &quot;ReferenceType is a class. &quot;)
3247     (Constant INTERFACE=2 &quot;ReferenceType is an interface. &quot;)
3248     (Constant ARRAY=3 &quot;ReferenceType is an array. &quot;)
3249 )
3250 (ConstantSet Tag
3251     (Constant ARRAY = &#39;[&#39; &quot;&#39;[&#39; - an array object (objectID size). &quot;)
3252     (Constant BYTE = &#39;B&#39; &quot;&#39;B&#39; - a byte value (1 byte).&quot;)
3253     (Constant CHAR = &#39;C&#39; &quot;&#39;C&#39; - a character value (2 bytes).&quot;)
3254     (Constant OBJECT = &#39;L&#39; &quot;&#39;L&#39; - an object (objectID size).&quot;)
3255     (Constant FLOAT = &#39;F&#39; &quot;&#39;F&#39; - a float value (4 bytes).&quot;)
3256     (Constant DOUBLE = &#39;D&#39; &quot;&#39;D&#39; - a double value (8 bytes).&quot;)
3257     (Constant INT = &#39;I&#39; &quot;&#39;I&#39; - an int value (4 bytes).&quot;)
3258     (Constant LONG = &#39;J&#39; &quot;&#39;J&#39; - a long value (8 bytes).&quot;)
3259     (Constant SHORT = &#39;S&#39; &quot;&#39;S&#39; - a short value (2 bytes).&quot;)
3260     (Constant VOID = &#39;V&#39; &quot;&#39;V&#39; - a void value (no bytes).&quot;)
3261     (Constant BOOLEAN = &#39;Z&#39; &quot;&#39;Z&#39; - a boolean value (1 byte).&quot;)
3262     (Constant STRING = &#39;s&#39; &quot;&#39;s&#39; - a String object (objectID size). &quot;)
3263     (Constant THREAD = &#39;t&#39; &quot;&#39;t&#39; - a Thread object (objectID size). &quot;)
3264     (Constant THREAD_GROUP = &#39;g&#39;
3265         &quot;&#39;g&#39; - a ThreadGroup object (objectID size). &quot;)
3266     (Constant CLASS_LOADER = &#39;l&#39;
3267         &quot;&#39;l&#39; - a ClassLoader object (objectID size). &quot;)
3268     (Constant CLASS_OBJECT = &#39;c&#39;
3269         &quot;&#39;c&#39; - a class object object (objectID size). &quot;)
3270 )
3271 
3272 (ConstantSet StepDepth
3273     (Constant INTO = 0
3274         &quot;Step into any method calls that occur before the end of the step. &quot;)
3275     (Constant OVER = 1
3276         &quot;Step over any method calls that occur before the end of the step. &quot;)
3277     (Constant OUT = 2
3278         &quot;Step out of the current method. &quot;)
3279 )
3280 
3281 (ConstantSet StepSize
3282     (Constant MIN = 0
3283         &quot;Step by the minimum possible amount (often a bytecode instruction). &quot;)
3284     (Constant LINE = 1
3285         &quot;Step to the next source line unless there is no line number information in which case a MIN step is done instead.&quot;)
3286 )
3287 
3288 (ConstantSet SuspendPolicy
3289     (Constant NONE = 0
3290         &quot;Suspend no threads when this event is encountered. &quot;)
3291     (Constant EVENT_THREAD = 1
3292         &quot;Suspend the event thread when this event is encountered. &quot;)
3293     (Constant ALL = 2
3294         &quot;Suspend all threads when this event is encountered. &quot;)
3295 )
3296 
3297 (ConstantSet InvokeOptions
3298     &quot;The invoke options are a combination of zero or more of the following bit flags:&quot;
3299     (Constant INVOKE_SINGLE_THREADED = 0x01
3300         &quot;otherwise, all threads started. &quot;)
3301     (Constant INVOKE_NONVIRTUAL = 0x02
3302         &quot;otherwise, normal virtual invoke (instance methods only)&quot;)
3303 )
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
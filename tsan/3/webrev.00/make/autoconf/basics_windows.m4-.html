<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old make/autoconf/basics_windows.m4</title>
    <link rel="stylesheet" href="../../style.css" />
  </head>
  <body>
    <pre>
  1 #
  2 # Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
  3 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4 #
  5 # This code is free software; you can redistribute it and/or modify it
  6 # under the terms of the GNU General Public License version 2 only, as
  7 # published by the Free Software Foundation.  Oracle designates this
  8 # particular file as subject to the &quot;Classpath&quot; exception as provided
  9 # by Oracle in the LICENSE file that accompanied this code.
 10 #
 11 # This code is distributed in the hope that it will be useful, but WITHOUT
 12 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14 # version 2 for more details (a copy is included in the LICENSE file that
 15 # accompanied this code).
 16 #
 17 # You should have received a copy of the GNU General Public License version
 18 # 2 along with this work; if not, write to the Free Software Foundation,
 19 # Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20 #
 21 # Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22 # or visit www.oracle.com if you need additional information or have any
 23 # questions.
 24 #
 25 
 26 AC_DEFUN([BASIC_WINDOWS_REWRITE_AS_UNIX_PATH],
 27 [
 28   windows_path=&quot;[$]$1&quot;
 29   if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.cygwin&quot;; then
 30     unix_path=`$CYGPATH -u &quot;$windows_path&quot;`
 31     $1=&quot;$unix_path&quot;
 32   elif test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.msys&quot;; then
 33     unix_path=`$ECHO &quot;$windows_path&quot; | $SED -e &#39;s,^\\(.\\):,/\\1,g&#39; -e &#39;s,\\\\,/,g&#39;`
 34     $1=&quot;$unix_path&quot;
 35   elif test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.wsl&quot;; then
 36     # wslpath does not check the input, only call if an actual windows path was
 37     # given.
 38     if $ECHO &quot;$windows_path&quot; | $GREP -q [&quot;^[a-zA-Z]:[\\\\/]&quot;]; then
 39       unix_path=`$WSLPATH -u &quot;$windows_path&quot;`
 40       $1=&quot;$unix_path&quot;
 41     fi
 42   fi
 43 ])
 44 
 45 AC_DEFUN([BASIC_WINDOWS_REWRITE_AS_WINDOWS_MIXED_PATH],
 46 [
 47   unix_path=&quot;[$]$1&quot;
 48   if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.cygwin&quot;; then
 49     windows_path=`$CYGPATH -m &quot;$unix_path&quot;`
 50     $1=&quot;$windows_path&quot;
 51   elif test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.msys&quot;; then
 52     windows_path=`cmd //c echo $unix_path`
 53     $1=&quot;$windows_path&quot;
 54   elif test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.wsl&quot;; then
 55     windows_path=`$WSLPATH -m &quot;$unix_path&quot;`
 56     $1=&quot;$windows_path&quot;
 57   fi
 58 ])
 59 
 60 # Helper function which possibly converts a path using DOS-style short mode.
 61 # If so, the updated path is stored in $new_path.
 62 # $1: The path to check
 63 AC_DEFUN([BASIC_MAKE_WINDOWS_SPACE_SAFE_CYGWIN],
 64 [
 65   input_path=&quot;$1&quot;
 66   # Check if we need to convert this using DOS-style short mode. If the path
 67   # contains just simple characters, use it. Otherwise (spaces, weird characters),
 68   # take no chances and rewrite it.
 69   # Note: m4 eats our [], so we need to use @&lt;:@ and @:&gt;@ instead.
 70   has_forbidden_chars=`$ECHO &quot;$input_path&quot; | $GREP @&lt;:@^-._/a-zA-Z0-9@:&gt;@`
 71   if test &quot;x$has_forbidden_chars&quot; != x; then
 72     # Now convert it to mixed DOS-style, short mode (no spaces, and / instead of \)
 73     shortmode_path=`$CYGPATH -s -m -a &quot;$input_path&quot;`
 74     path_after_shortmode=`$CYGPATH -u &quot;$shortmode_path&quot;`
 75     if test &quot;x$path_after_shortmode&quot; != &quot;x$input_to_shortpath&quot;; then
 76       # Going to short mode and back again did indeed matter. Since short mode is
 77       # case insensitive, let&#39;s make it lowercase to improve readability.
 78       shortmode_path=`$ECHO &quot;$shortmode_path&quot; | $TR &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; &#39;abcdefghijklmnopqrstuvwxyz&#39;`
 79       # Now convert it back to Unix-style (cygpath)
 80       input_path=`$CYGPATH -u &quot;$shortmode_path&quot;`
 81       new_path=&quot;$input_path&quot;
 82     fi
 83   fi
 84 
 85   test_cygdrive_prefix=`$ECHO $input_path | $GREP ^/cygdrive/`
 86   if test &quot;x$test_cygdrive_prefix&quot; = x; then
 87     # As a simple fix, exclude /usr/bin since it&#39;s not a real path.
 88     if test &quot;x`$ECHO $1 | $GREP ^/usr/bin/`&quot; = x; then
 89       # The path is in a Cygwin special directory (e.g. /home). We need this converted to
 90       # a path prefixed by /cygdrive for fixpath to work.
 91       new_path=&quot;$CYGWIN_ROOT_PATH$input_path&quot;
 92     fi
 93   fi
 94 ])
 95 
 96 # Helper function which possibly converts a path using DOS-style short mode.
 97 # If so, the updated path is stored in $new_path.
 98 # $1: The path to check
 99 AC_DEFUN([BASIC_MAKE_WINDOWS_SPACE_SAFE_MSYS],
100 [
101   input_path=&quot;$1&quot;
102   # Check if we need to convert this using DOS-style short mode. If the path
103   # contains just simple characters, use it. Otherwise (spaces, weird characters),
104   # take no chances and rewrite it.
105   # Note: m4 eats our [], so we need to use @&lt;:@ and @:&gt;@ instead.
106   has_forbidden_chars=`$ECHO &quot;$input_path&quot; | $GREP @&lt;:@^-_/:a-zA-Z0-9@:&gt;@`
107   if test &quot;x$has_forbidden_chars&quot; != x; then
108     # Now convert it to mixed DOS-style, short mode (no spaces, and / instead of \)
109     new_path=`cmd /c &quot;for %A in (\&quot;$input_path\&quot;) do @echo %~sA&quot;|$TR \\\\\\\\ / | $TR &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; &#39;abcdefghijklmnopqrstuvwxyz&#39;`
110   fi
111 ])
112 
113 # Helper function which possibly converts a path using DOS-style short mode.
114 # If so, the updated path is stored in $new_path.
115 # $1: The path to check
116 AC_DEFUN([BASIC_MAKE_WINDOWS_SPACE_SAFE_WSL],
117 [
118   input_path=&quot;$1&quot;
119   # Check if we need to convert this using DOS-style short mode. If the path
120   # contains just simple characters, use it. Otherwise (spaces, weird characters),
121   # take no chances and rewrite it.
122   # Note: m4 eats our [], so we need to use @&lt;:@ and @:&gt;@ instead.
123   has_forbidden_chars=`$ECHO &quot;$input_path&quot; | $GREP [[^-_/:a-zA-Z0-9\\.]]`
124   if test &quot;x$has_forbidden_chars&quot; != x; then
125     # Now convert it to mixed DOS-style, short mode (no spaces, and / instead of \)
126     TOPDIR_windows=&quot;$TOPDIR&quot;
127     BASIC_WINDOWS_REWRITE_AS_WINDOWS_MIXED_PATH([TOPDIR_windows])
128     # First convert to Windows path to make input valid for cmd
129     BASIC_WINDOWS_REWRITE_AS_WINDOWS_MIXED_PATH([input_path])
130     new_path=`$CMD /c $TOPDIR_windows/make/scripts/windowsShortName.bat &quot;$input_path&quot; \
131         | $SED -e &#39;s|\r||g&#39; \
132         | $TR \\\\\\\\ / | $TR &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; &#39;abcdefghijklmnopqrstuvwxyz&#39;`
133     # Rewrite back to unix style
134     BASIC_WINDOWS_REWRITE_AS_UNIX_PATH([new_path])
135   fi
136 ])
137 
138 # FIXME: The BASIC_FIXUP_*_CYGWIN/MSYS is most likely too convoluted
139 # and could probably be heavily simplified. However, all changes in this
140 # area tend to need lot of testing in different scenarios, and in lack of
141 # proper unit testing, cleaning this up has not been deemed worth the effort
142 # at the moment.
143 
144 AC_DEFUN([BASIC_FIXUP_PATH_CYGWIN],
145 [
146   # Input might be given as Windows format, start by converting to
147   # unix format.
148   path=&quot;[$]$1&quot;
149   new_path=`$CYGPATH -u &quot;$path&quot;`
150 
151   # Cygwin tries to hide some aspects of the Windows file system, such that binaries are
152   # named .exe but called without that suffix. Therefore, &quot;foo&quot; and &quot;foo.exe&quot; are considered
153   # the same file, most of the time (as in &quot;test -f&quot;). But not when running cygpath -s, then
154   # &quot;foo.exe&quot; is OK but &quot;foo&quot; is an error.
155   #
156   # This test is therefore slightly more accurate than &quot;test -f&quot; to check for file precense.
157   # It is also a way to make sure we got the proper file name for the real test later on.
158   test_shortpath=`$CYGPATH -s -m &quot;$new_path&quot; 2&gt; /dev/null`
159   if test &quot;x$test_shortpath&quot; = x; then
160     AC_MSG_NOTICE([The path of $1, which resolves as &quot;$path&quot;, is invalid.])
161     AC_MSG_ERROR([Cannot locate the the path of $1])
162   fi
163 
164   # Call helper function which possibly converts this using DOS-style short mode.
165   # If so, the updated path is stored in $new_path.
166   BASIC_MAKE_WINDOWS_SPACE_SAFE_CYGWIN([$new_path])
167 
168   if test &quot;x$path&quot; != &quot;x$new_path&quot;; then
169     $1=&quot;$new_path&quot;
170     AC_MSG_NOTICE([Rewriting $1 to &quot;$new_path&quot;])
171   fi
172 ])
173 
174 AC_DEFUN([BASIC_FIXUP_PATH_MSYS],
175 [
176   path=&quot;[$]$1&quot;
177   has_colon=`$ECHO $path | $GREP ^.:`
178   new_path=&quot;$path&quot;
179   if test &quot;x$has_colon&quot; = x; then
180     # Not in mixed or Windows style, start by that.
181     new_path=`cmd //c echo $path`
182   fi
183 
184   BASIC_MAKE_WINDOWS_SPACE_SAFE_MSYS([$new_path])
185   BASIC_WINDOWS_REWRITE_AS_UNIX_PATH(new_path)
186   if test &quot;x$path&quot; != &quot;x$new_path&quot;; then
187     $1=&quot;$new_path&quot;
188     AC_MSG_NOTICE([Rewriting $1 to &quot;$new_path&quot;])
189   fi
190 
191   # Save the first 10 bytes of this path to the storage, so fixpath can work.
192   all_fixpath_prefixes=(&quot;${all_fixpath_prefixes@&lt;:@@@:&gt;@}&quot; &quot;${new_path:0:10}&quot;)
193 ])
194 
195 AC_DEFUN([BASIC_FIXUP_PATH_WSL],
196 [
197   # Input might be given as Windows format, start by converting to
198   # unix format.
199   new_path=&quot;[$]$1&quot;
200   BASIC_WINDOWS_REWRITE_AS_UNIX_PATH([new_path])
201 
202   # Call helper function which possibly converts this using DOS-style short mode.
203   # If so, the updated path is stored in $new_path.
204   BASIC_MAKE_WINDOWS_SPACE_SAFE_WSL([$new_path])
205 
206   if test &quot;x$path&quot; != &quot;x$new_path&quot;; then
207     $1=&quot;$new_path&quot;
208     AC_MSG_NOTICE([Rewriting $1 to &quot;$new_path&quot;])
209   fi
210 ])
211 
212 AC_DEFUN([BASIC_FIXUP_EXECUTABLE_CYGWIN],
213 [
214   # First separate the path from the arguments. This will split at the first
215   # space.
216   complete=&quot;[$]$1&quot;
217   path=&quot;${complete%% *}&quot;
218   tmp=&quot;$complete EOL&quot;
219   arguments=&quot;${tmp#* }&quot;
220 
221   # Input might be given as Windows format, start by converting to
222   # unix format.
223   new_path=`$CYGPATH -u &quot;$path&quot;`
224 
225   # Now try to locate executable using which
226   new_path=`$WHICH &quot;$new_path&quot; 2&gt; /dev/null`
227   # bat and cmd files are not always considered executable in cygwin causing which
228   # to not find them
229   if test &quot;x$new_path&quot; = x \
230       &amp;&amp; test &quot;x`$ECHO \&quot;$path\&quot; | $GREP -i -e \&quot;\\.bat$\&quot; -e \&quot;\\.cmd$\&quot;`&quot; != x \
231       &amp;&amp; test &quot;x`$LS \&quot;$path\&quot; 2&gt;/dev/null`&quot; != x; then
232     new_path=`$CYGPATH -u &quot;$path&quot;`
233   fi
234   if test &quot;x$new_path&quot; = x; then
235     # Oops. Which didn&#39;t find the executable.
236     # The splitting of arguments from the executable at a space might have been incorrect,
237     # since paths with space are more likely in Windows. Give it another try with the whole
238     # argument.
239     path=&quot;$complete&quot;
240     arguments=&quot;EOL&quot;
241     new_path=`$CYGPATH -u &quot;$path&quot;`
242     new_path=`$WHICH &quot;$new_path&quot; 2&gt; /dev/null`
243     # bat and cmd files are not always considered executable in cygwin causing which
244     # to not find them
245     if test &quot;x$new_path&quot; = x \
246         &amp;&amp; test &quot;x`$ECHO \&quot;$path\&quot; | $GREP -i -e \&quot;\\.bat$\&quot; -e \&quot;\\.cmd$\&quot;`&quot; != x \
247         &amp;&amp; test &quot;x`$LS \&quot;$path\&quot; 2&gt;/dev/null`&quot; != x; then
248       new_path=`$CYGPATH -u &quot;$path&quot;`
249     fi
250     if test &quot;x$new_path&quot; = x; then
251       # It&#39;s still not found. Now this is an unrecoverable error.
252       AC_MSG_NOTICE([The path of $1, which resolves as &quot;$complete&quot;, is not found.])
253       has_space=`$ECHO &quot;$complete&quot; | $GREP &quot; &quot;`
254       if test &quot;x$has_space&quot; != x; then
255         AC_MSG_NOTICE([You might be mixing spaces in the path and extra arguments, which is not allowed.])
256       fi
257       AC_MSG_ERROR([Cannot locate the the path of $1])
258     fi
259   fi
260 
261   # Cygwin tries to hide some aspects of the Windows file system, such that binaries are
262   # named .exe but called without that suffix. Therefore, &quot;foo&quot; and &quot;foo.exe&quot; are considered
263   # the same file, most of the time (as in &quot;test -f&quot;). But not when running cygpath -s, then
264   # &quot;foo.exe&quot; is OK but &quot;foo&quot; is an error.
265   #
266   # This test is therefore slightly more accurate than &quot;test -f&quot; to check for file presence.
267   # It is also a way to make sure we got the proper file name for the real test later on.
268   test_shortpath=`$CYGPATH -s -m &quot;$new_path&quot; 2&gt; /dev/null`
269   if test &quot;x$test_shortpath&quot; = x; then
270     # Short path failed, file does not exist as specified.
271     # Try adding .exe or .cmd
272     if test -f &quot;${new_path}.exe&quot;; then
273       input_to_shortpath=&quot;${new_path}.exe&quot;
274     elif test -f &quot;${new_path}.cmd&quot;; then
275       input_to_shortpath=&quot;${new_path}.cmd&quot;
276     else
277       AC_MSG_NOTICE([The path of $1, which resolves as &quot;$new_path&quot;, is invalid.])
278       AC_MSG_NOTICE([Neither &quot;$new_path&quot; nor &quot;$new_path.exe/cmd&quot; can be found])
279       AC_MSG_ERROR([Cannot locate the the path of $1])
280     fi
281   else
282     input_to_shortpath=&quot;$new_path&quot;
283   fi
284 
285   # Call helper function which possibly converts this using DOS-style short mode.
286   # If so, the updated path is stored in $new_path.
287   new_path=&quot;$input_to_shortpath&quot;
288   BASIC_MAKE_WINDOWS_SPACE_SAFE_CYGWIN([$input_to_shortpath])
289   # remove trailing .exe if any
290   new_path=&quot;${new_path/%.exe/}&quot;
291 ])
292 
293 AC_DEFUN([BASIC_FIXUP_EXECUTABLE_MSYS],
294 [
295   # First separate the path from the arguments. This will split at the first
296   # space.
297   complete=&quot;[$]$1&quot;
298   path=&quot;${complete%% *}&quot;
299   tmp=&quot;$complete EOL&quot;
300   arguments=&quot;${tmp#* }&quot;
301 
302   # Input might be given as Windows format, start by converting to
303   # unix format.
304   new_path=&quot;$path&quot;
305   BASIC_WINDOWS_REWRITE_AS_UNIX_PATH(new_path)
306 
307   # Now try to locate executable using which
308   new_path=`$WHICH &quot;$new_path&quot; 2&gt; /dev/null`
309 
310   if test &quot;x$new_path&quot; = x; then
311     # Oops. Which didn&#39;t find the executable.
312     # The splitting of arguments from the executable at a space might have been incorrect,
313     # since paths with space are more likely in Windows. Give it another try with the whole
314     # argument.
315     path=&quot;$complete&quot;
316     arguments=&quot;EOL&quot;
317     new_path=&quot;$path&quot;
318     BASIC_WINDOWS_REWRITE_AS_UNIX_PATH(new_path)
319 
320     new_path=`$WHICH &quot;$new_path&quot; 2&gt; /dev/null`
321     # bat and cmd files are not always considered executable in MSYS causing which
322     # to not find them
323     if test &quot;x$new_path&quot; = x \
324         &amp;&amp; test &quot;x`$ECHO \&quot;$path\&quot; | $GREP -i -e \&quot;\\.bat$\&quot; -e \&quot;\\.cmd$\&quot;`&quot; != x \
325         &amp;&amp; test &quot;x`$LS \&quot;$path\&quot; 2&gt;/dev/null`&quot; != x; then
326       new_path=&quot;$path&quot;
327       BASIC_WINDOWS_REWRITE_AS_UNIX_PATH(new_path)
328     fi
329 
330     if test &quot;x$new_path&quot; = x; then
331       # It&#39;s still not found. Now this is an unrecoverable error.
332       AC_MSG_NOTICE([The path of $1, which resolves as &quot;$complete&quot;, is not found.])
333       has_space=`$ECHO &quot;$complete&quot; | $GREP &quot; &quot;`
334       if test &quot;x$has_space&quot; != x; then
335         AC_MSG_NOTICE([You might be mixing spaces in the path and extra arguments, which is not allowed.])
336       fi
337       AC_MSG_ERROR([Cannot locate the the path of $1])
338     fi
339   fi
340 
341   # Now new_path has a complete unix path to the binary
342   if test &quot;x`$ECHO $new_path | $GREP ^/bin/`&quot; != x; then
343     # Keep paths in /bin as-is, but remove trailing .exe if any
344     new_path=&quot;${new_path/%.exe/}&quot;
345     # Do not save /bin paths to all_fixpath_prefixes!
346   else
347     # Not in mixed or Windows style, start by that.
348     new_path=`cmd //c echo $new_path`
349     BASIC_MAKE_WINDOWS_SPACE_SAFE_MSYS([$new_path])
350     # Output is in $new_path
351     BASIC_WINDOWS_REWRITE_AS_UNIX_PATH(new_path)
352     # remove trailing .exe if any
353     new_path=&quot;${new_path/%.exe/}&quot;
354 
355     # Save the first 10 bytes of this path to the storage, so fixpath can work.
356     all_fixpath_prefixes=(&quot;${all_fixpath_prefixes@&lt;:@@@:&gt;@}&quot; &quot;${new_path:0:10}&quot;)
357   fi
358 ])
359 
360 AC_DEFUN([BASIC_FIXUP_EXECUTABLE_WSL],
361 [
362   # First separate the path from the arguments. This will split at the first
363   # space.
364   complete=&quot;[$]$1&quot;
365   path=&quot;${complete%% *}&quot;
366   tmp=&quot;$complete EOL&quot;
367   arguments=&quot;${tmp#* }&quot;
368 
369   # Input might be given as Windows format, start by converting to
370   # unix format.
371   new_path=&quot;$path&quot;
372   BASIC_WINDOWS_REWRITE_AS_UNIX_PATH([new_path])
373 
374   # Now try to locate executable using which
375   new_path_bak=&quot;$new_path&quot;
376   new_path=`$WHICH &quot;$new_path&quot; 2&gt; /dev/null`
377   # bat and cmd files are not considered executable in WSL
378   if test &quot;x$new_path&quot; = x \
379       &amp;&amp; test &quot;x`$ECHO \&quot;$path\&quot; | $GREP -i -e \&quot;\\.bat$\&quot; -e \&quot;\\.cmd$\&quot;`&quot; != x \
380       &amp;&amp; test &quot;x`$LS \&quot;$path\&quot; 2&gt;/dev/null`&quot; != x; then
381     new_path=&quot;$new_path_back&quot;
382   fi
383   if test &quot;x$new_path&quot; = x; then
384     # Oops. Which didn&#39;t find the executable.
385     # The splitting of arguments from the executable at a space might have been incorrect,
386     # since paths with space are more likely in Windows. Give it another try with the whole
387     # argument.
388     path=&quot;$complete&quot;
389     arguments=&quot;EOL&quot;
390     new_path=&quot;$path&quot;
391     BASIC_WINDOWS_REWRITE_AS_UNIX_PATH([new_path])
392     new_path_bak=&quot;$new_path&quot;
393     new_path=`$WHICH &quot;$new_path&quot; 2&gt; /dev/null`
394     # bat and cmd files are not considered executable in WSL
395     if test &quot;x$new_path&quot; = x \
396         &amp;&amp; test &quot;x`$ECHO \&quot;$path\&quot; | $GREP -i -e \&quot;\\.bat$\&quot; -e \&quot;\\.cmd$\&quot;`&quot; != x \
397         &amp;&amp; test &quot;x`$LS \&quot;$path\&quot; 2&gt;/dev/null`&quot; != x; then
398       new_path=&quot;$new_path_bak&quot;
399     fi
400     if test &quot;x$new_path&quot; = x; then
401       # It&#39;s still not found. Now this is an unrecoverable error.
402       AC_MSG_NOTICE([The path of $1, which resolves as &quot;$complete&quot;, is not found.])
403       has_space=`$ECHO &quot;$complete&quot; | $GREP &quot; &quot;`
404       if test &quot;x$has_space&quot; != x; then
405         AC_MSG_NOTICE([You might be mixing spaces in the path and extra arguments, which is not allowed.])
406       fi
407       AC_MSG_ERROR([Cannot locate the the path of $1])
408     fi
409   fi
410 
411   # In WSL, suffixes must be present for Windows executables
412   if test ! -f &quot;$new_path&quot;; then
413     # Try adding .exe or .cmd
414     if test -f &quot;${new_path}.exe&quot;; then
415       input_to_shortpath=&quot;${new_path}.exe&quot;
416     elif test -f &quot;${new_path}.cmd&quot;; then
417       input_to_shortpath=&quot;${new_path}.cmd&quot;
418     else
419       AC_MSG_NOTICE([The path of $1, which resolves as &quot;$new_path&quot;, is invalid.])
420       AC_MSG_NOTICE([Neither &quot;$new_path&quot; nor &quot;$new_path.exe/cmd&quot; can be found])
421       AC_MSG_ERROR([Cannot locate the the path of $1])
422     fi
423   else
424     input_to_shortpath=&quot;$new_path&quot;
425   fi
426 
427   # Call helper function which possibly converts this using DOS-style short mode.
428   # If so, the updated path is stored in $new_path.
429   new_path=&quot;$input_to_shortpath&quot;
430   BASIC_MAKE_WINDOWS_SPACE_SAFE_WSL([$input_to_shortpath])
431 ])
432 
433 # Setup basic configuration paths, and platform-specific stuff related to PATHs.
434 AC_DEFUN([BASIC_CHECK_PATHS_WINDOWS],
435 [
436   SRC_ROOT_LENGTH=`$THEPWDCMD -L|$WC -m`
437   if test $SRC_ROOT_LENGTH -gt 100; then
438     AC_MSG_ERROR([Your base path is too long. It is $SRC_ROOT_LENGTH characters long, but only 100 is supported])
439   fi
440 
441   if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.cygwin&quot;; then
442     AC_MSG_CHECKING([cygwin release])
443     CYGWIN_VERSION=`$UNAME -r`
444     AC_MSG_RESULT([$CYGWIN_VERSION])
445     WINDOWS_ENV_VENDOR=&#39;cygwin&#39;
446     WINDOWS_ENV_VERSION=&quot;$CYGWIN_VERSION&quot;
447 
448     CYGWIN_VERSION_OLD=`$ECHO $CYGWIN_VERSION | $GREP -e &#39;^1\.[0-6]&#39;`
449     if test &quot;x$CYGWIN_VERSION_OLD&quot; != x; then
450       AC_MSG_NOTICE([Your cygwin is too old. You are running $CYGWIN_VERSION, but at least cygwin 1.7 is required. Please upgrade.])
451       AC_MSG_ERROR([Cannot continue])
452     fi
453     if test &quot;x$CYGPATH&quot; = x; then
454       AC_MSG_ERROR([Something is wrong with your cygwin installation since I cannot find cygpath.exe in your path])
455     fi
456     AC_MSG_CHECKING([cygwin root directory as unix-style path])
457     # The cmd output ends with Windows line endings (CR/LF)
458     cygwin_winpath_root=`cd / ; cmd /c cd | $TR -d &#39;\r\n&#39;`
459     # Force cygpath to report the proper root by including a trailing space, and then stripping it off again.
460     CYGWIN_ROOT_PATH=`$CYGPATH -u &quot;$cygwin_winpath_root &quot; | $CUT -f 1 -d &quot; &quot;`
461     AC_MSG_RESULT([$CYGWIN_ROOT_PATH])
462     WINDOWS_ENV_ROOT_PATH=&quot;$CYGWIN_ROOT_PATH&quot;
463     test_cygdrive_prefix=`$ECHO $CYGWIN_ROOT_PATH | $GREP ^/cygdrive/`
464     if test &quot;x$test_cygdrive_prefix&quot; = x; then
465       AC_MSG_ERROR([Your cygdrive prefix is not /cygdrive. This is currently not supported. Change with mount -c.])
466     fi
467   elif test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.msys&quot;; then
468     AC_MSG_CHECKING([msys release])
469     MSYS_VERSION=`$UNAME -r`
470     AC_MSG_RESULT([$MSYS_VERSION])
471 
472     WINDOWS_ENV_VENDOR=&#39;msys&#39;
473     WINDOWS_ENV_VERSION=&quot;$MSYS_VERSION&quot;
474 
475     AC_MSG_CHECKING([msys root directory as unix-style path])
476     # The cmd output ends with Windows line endings (CR/LF), the grep command will strip that away
477     MSYS_ROOT_PATH=`cd / ; cmd /c cd | $GREP &quot;.*&quot;`
478     BASIC_WINDOWS_REWRITE_AS_UNIX_PATH(MSYS_ROOT_PATH)
479     AC_MSG_RESULT([$MSYS_ROOT_PATH])
480     WINDOWS_ENV_ROOT_PATH=&quot;$MSYS_ROOT_PATH&quot;
481   elif test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.wsl&quot;; then
482     AC_MSG_CHECKING([Windows version])
483     # m4 replaces [ and ] so we use @&lt;:@ and @:&gt;@ instead
484     WINDOWS_VERSION=`$CMD /c ver.exe | $EGREP -o &#39;(@&lt;:@0-9@:&gt;@+\.)+@&lt;:@0-9@:&gt;@+&#39;`
485     AC_MSG_RESULT([$WINDOWS_VERSION])
486 
487     AC_MSG_CHECKING([WSL kernel version])
488     WSL_KERNEL_VERSION=`$UNAME -v`
489     AC_MSG_RESULT([$WSL_KERNEL_VERSION])
490 
491     AC_MSG_CHECKING([WSL kernel release])
492     WSL_KERNEL_RELEASE=`$UNAME -r`
493     AC_MSG_RESULT([$WSL_KERNEL_RELEASE])
494 
495     AC_MSG_CHECKING([WSL distribution])
496     WSL_DISTRIBUTION=`$LSB_RELEASE -d | sed &#39;s/Description:\t//&#39;`
497     AC_MSG_RESULT([$WSL_DISTRIBUTION])
498 
499     WINDOWS_ENV_VENDOR=&#39;WSL&#39;
500     WINDOWS_ENV_VERSION=&quot;$WSL_DISTRIBUTION $WSL_KERNEL_VERSION $WSL_KERNEL_RELEASE (on Windows build $WINDOWS_VERSION)&quot;
501   else
502     AC_MSG_ERROR([Unknown Windows environment. Neither cygwin, msys, nor wsl was detected.])
503   fi
504 
505   # Test if windows or unix (cygwin/msys) find is first in path.
506   AC_MSG_CHECKING([what kind of &#39;find&#39; is first on the PATH])
507   FIND_BINARY_OUTPUT=`find --version 2&gt;&amp;1`
508   if test &quot;x`echo $FIND_BINARY_OUTPUT | $GREP GNU`&quot; != x; then
509     AC_MSG_RESULT([unix style])
510   elif test &quot;x`echo $FIND_BINARY_OUTPUT | $GREP FIND`&quot; != x; then
511     AC_MSG_RESULT([Windows])
512     AC_MSG_NOTICE([Your path contains Windows tools (C:\Windows\system32) before your unix (cygwin or msys) tools.])
513     AC_MSG_NOTICE([This will not work. Please correct and make sure /usr/bin (or similar) is first in path.])
514     AC_MSG_ERROR([Cannot continue])
515   else
516     AC_MSG_RESULT([unknown])
517     AC_MSG_WARN([It seems that your find utility is non-standard.])
518   fi
519 ])
520 
521 AC_DEFUN_ONCE([BASIC_COMPILE_FIXPATH],
522 [
523   # When using cygwin or msys, we need a wrapper binary that renames
524   # /cygdrive/c/ arguments into c:/ arguments and peeks into
525   # @files and rewrites these too! This wrapper binary is
526   # called fixpath.
527   FIXPATH=
528   if test &quot;x$OPENJDK_BUILD_OS&quot; = xwindows; then
529     AC_MSG_CHECKING([if fixpath can be created])
530     FIXPATH_SRC=&quot;$TOPDIR/make/src/native/fixpath.c&quot;
531     FIXPATH_BIN=&quot;$CONFIGURESUPPORT_OUTPUTDIR/bin/fixpath.exe&quot;
532     FIXPATH_DIR=&quot;$CONFIGURESUPPORT_OUTPUTDIR/fixpath&quot;
533     if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = xwindows.cygwin; then
534       # Important to keep the .exe suffix on Cygwin for Hotspot makefiles
535       FIXPATH=&quot;$FIXPATH_BIN -c&quot;
536     elif test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = xwindows.msys; then
537       # Take all collected prefixes and turn them into a -m/c/foo@/c/bar@... command line
538       # @ was chosen as separator to minimize risk of other tools messing around with it
539       all_unique_prefixes=`echo &quot;${all_fixpath_prefixes@&lt;:@@@:&gt;@}&quot; \
540           | tr &#39; &#39; &#39;\n&#39; | $GREP &#39;^/./&#39; | $SORT | $UNIQ`
541       fixpath_argument_list=`echo $all_unique_prefixes  | tr &#39; &#39; &#39;@&#39;`
542       FIXPATH=&quot;$FIXPATH_BIN -m$fixpath_argument_list&quot;
543     elif test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = xwindows.wsl; then
544       FIXPATH=&quot;$FIXPATH_BIN -w&quot;
545     fi
546     FIXPATH_SRC_W=&quot;$FIXPATH_SRC&quot;
547     FIXPATH_BIN_W=&quot;$FIXPATH_BIN&quot;
548     BASIC_WINDOWS_REWRITE_AS_WINDOWS_MIXED_PATH([FIXPATH_SRC_W])
549     BASIC_WINDOWS_REWRITE_AS_WINDOWS_MIXED_PATH([FIXPATH_BIN_W])
550     $RM -rf $FIXPATH_BIN $FIXPATH_DIR
551     $MKDIR -p $FIXPATH_DIR $CONFIGURESUPPORT_OUTPUTDIR/bin
552     cd $FIXPATH_DIR
553     $CC $FIXPATH_SRC_W -Fe$FIXPATH_BIN_W &gt; $FIXPATH_DIR/fixpath1.log 2&gt;&amp;1
554     cd $CURDIR
555 
556     if test ! -x $FIXPATH_BIN; then
557       AC_MSG_RESULT([no])
558       cat $FIXPATH_DIR/fixpath1.log
559       AC_MSG_ERROR([Could not create $FIXPATH_BIN])
560     fi
561     AC_MSG_RESULT([yes])
562 
563     if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.wsl&quot;; then
564       OLD_WSLENV=&quot;$WSLENV&quot;
565       WSLENV=`$ECHO $WSLENV | $SED &#39;s/PATH\/l://&#39;`
566       BASIC_APPEND_TO_PATH(WSLENV, &quot;FIXPATH_PATH&quot;)
567       export WSLENV
568       export FIXPATH_PATH=$VS_PATH_WINDOWS
569       AC_MSG_NOTICE([FIXPATH_PATH is $FIXPATH_PATH])
570       AC_MSG_NOTICE([Rewriting WSLENV from $OLD_WSLENV to $WSLENV])
571     fi
572 
573     AC_MSG_CHECKING([if fixpath.exe works])
574     cd $FIXPATH_DIR
575     $FIXPATH $CC $FIXPATH_SRC -Fe$FIXPATH_DIR/fixpath2.exe \
576         &gt; $FIXPATH_DIR/fixpath2.log 2&gt;&amp;1
577     cd $CURDIR
578     if test ! -x $FIXPATH_DIR/fixpath2.exe; then
579       AC_MSG_RESULT([no])
580       cat $FIXPATH_DIR/fixpath2.log
581       AC_MSG_ERROR([fixpath did not work!])
582     fi
583     AC_MSG_RESULT([yes])
584 
585     FIXPATH_DETACH_FLAG=&quot;--detach&quot;
586   fi
587 
588   AC_SUBST(FIXPATH)
589   AC_SUBST(FIXPATH_DETACH_FLAG)
590 ])
    </pre>
  </body>
</html>
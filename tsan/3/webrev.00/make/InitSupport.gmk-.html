<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old make/InitSupport.gmk</title>
    <link rel="stylesheet" href="../style.css" />
  </head>
  <body>
    <pre>
  1 #
  2 # Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
  3 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4 #
  5 # This code is free software; you can redistribute it and/or modify it
  6 # under the terms of the GNU General Public License version 2 only, as
  7 # published by the Free Software Foundation.  Oracle designates this
  8 # particular file as subject to the &quot;Classpath&quot; exception as provided
  9 # by Oracle in the LICENSE file that accompanied this code.
 10 #
 11 # This code is distributed in the hope that it will be useful, but WITHOUT
 12 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14 # version 2 for more details (a copy is included in the LICENSE file that
 15 # accompanied this code).
 16 #
 17 # You should have received a copy of the GNU General Public License version
 18 # 2 along with this work; if not, write to the Free Software Foundation,
 19 # Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20 #
 21 # Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22 # or visit www.oracle.com if you need additional information or have any
 23 # questions.
 24 #
 25 
 26 ################################################################################
 27 # This file contains helper functions for Init.gmk.
 28 # It is divided in two parts, depending on if a SPEC is present or not
 29 # (HAS_SPEC is true or not).
 30 ################################################################################
 31 
 32 ifndef _INITSUPPORT_GMK
 33 _INITSUPPORT_GMK := 1
 34 
 35 ifeq ($(HAS_SPEC),)
 36 
 37   # COMMA is defined in spec.gmk, but that is not included yet
 38   COMMA := ,
 39 
 40   # Include the corresponding closed file, if present.
 41   ifneq ($(CUSTOM_MAKE_DIR), )
 42     -include $(CUSTOM_MAKE_DIR)/InitSupport.gmk
 43   endif
 44 
 45   ##############################################################################
 46   # Helper functions for the initial part of Init.gmk, before the spec file is
 47   # loaded. Most of these functions provide parsing and setting up make options
 48   # from the command-line.
 49   ##############################################################################
 50 
 51   # Make control variables, handled by Init.gmk
 52   INIT_CONTROL_VARIABLES += LOG CONF CONF_NAME SPEC JOBS TEST_JOBS CONF_CHECK \
 53       COMPARE_BUILD JTREG GTEST MICRO TEST_OPTS TEST_VM_OPTS
 54 
 55   # All known make control variables
 56   MAKE_CONTROL_VARIABLES := $(INIT_CONTROL_VARIABLES) TEST JDK_FILTER
 57 
 58   # Define a simple reverse function.
 59   # Should maybe move to MakeBase.gmk, but we can&#39;t include that file now.
 60   reverse = \
 61       $(if $(strip $(1)), $(call reverse, $(wordlist 2, $(words $(1)), $(1)))) \
 62           $(firstword $(1))
 63 
 64   # The variable MAKEOVERRIDES contains variable assignments from the command
 65   # line, but in reverse order to what the user entered.
 66   # The &#39;\#&#39; &lt;=&gt; &#39;\ &#39;dance is needed to keep values with space in them connected.
 67   COMMAND_LINE_VARIABLES := $(subst \#,\ , $(call reverse, $(subst \ ,\#,$(MAKEOVERRIDES))))
 68 
 69   # A list like FOO=&quot;val1&quot; BAR=&quot;val2&quot; containing all user-supplied make
 70   # variables that we should propagate.
 71   # The &#39;\#&#39; &lt;=&gt; &#39;\ &#39;dance is needed to keep values with space in them connected.
 72   USER_MAKE_VARS := $(subst \#,\ , $(filter-out $(addsuffix =%, $(INIT_CONTROL_VARIABLES)), \
 73       $(subst \ ,\#,$(MAKEOVERRIDES))))
 74 
 75   # Setup information about available configurations, if any.
 76   ifneq ($(CUSTOM_ROOT), )
 77     build_dir=$(CUSTOM_ROOT)/build
 78   else
 79     build_dir=$(topdir)/build
 80   endif
 81   all_spec_files=$(wildcard $(build_dir)/*/spec.gmk)
 82   # Extract the configuration names from the path
 83   all_confs=$(patsubst %/spec.gmk, %, $(patsubst $(build_dir)/%, %, $(all_spec_files)))
 84 
 85   # Check for unknown command-line variables
 86   define CheckControlVariables
 87     command_line_variables := $$(strip $$(foreach var, \
 88         $$(subst \ ,_,$$(MAKEOVERRIDES)), \
 89         $$(firstword $$(subst =, , $$(var)))))
 90     unknown_command_line_variables := $$(strip \
 91         $$(filter-out $$(MAKE_CONTROL_VARIABLES), $$(command_line_variables)))
 92     ifneq ($$(unknown_command_line_variables), )
 93       $$(info Note: Command line contains non-control variables:)
 94       $$(foreach var, $$(unknown_command_line_variables), $$(info * $$(var)=$$($$(var))))
 95       $$(info Make sure it is not mistyped, and that you intend to override this variable.)
 96       $$(info &#39;make help&#39; will list known control variables.)
 97       $$(info )
 98     endif
 99   endef
100 
101   # Check for deprecated ALT_ variables
102   define CheckDeprecatedEnvironment
103     defined_alt_variables := $$(filter ALT_%, $$(.VARIABLES))
104     ifneq ($$(defined_alt_variables), )
105       $$(info Warning: You have the following ALT_ variables set:)
106       $$(foreach var, $$(defined_alt_variables), $$(info * $$(var)=$$($$(var))))
107       $$(info ALT_ variables are deprecated, and may result in a failed build.)
108       $$(info Please clean your environment.)
109       $$(info )
110     endif
111   endef
112 
113   # Check for invalid make flags like -j
114   define CheckInvalidMakeFlags
115     # This is a trick to get this rule to execute before any other rules
116     # MAKEFLAGS only indicate -j if read in a recipe (!)
117     $$(topdir)/make/Init.gmk: .FORCE
118 	$$(if $$(findstring --jobserver, $$(MAKEFLAGS)), \
119 	    $$(info Error: &#39;make -jN&#39; is not supported, use &#39;make JOBS=N&#39;) \
120 	    $$(error Cannot continue) \
121 	)
122     .FORCE:
123     .PHONY: .FORCE
124   endef
125 
126   # Check that the CONF_CHECK option is valid and set up handling
127   define ParseConfCheckOption
128     ifeq ($$(CONF_CHECK), )
129       # Default behavior is fail
130       CONF_CHECK := fail
131     else ifneq ($$(filter-out auto fail ignore, $$(CONF_CHECK)),)
132       $$(info Error: CONF_CHECK must be one of: auto, fail or ignore.)
133       $$(error Cannot continue)
134     endif
135   endef
136 
137   define ParseConfAndSpec
138     ifneq ($$(origin SPEC), undefined)
139       # We have been given a SPEC, check that it works out properly
140       ifneq ($$(origin CONF), undefined)
141         # We also have a CONF argument. We can&#39;t have both.
142         $$(info Error: Cannot use CONF=$$(CONF) and SPEC=$$(SPEC) at the same time. Choose one.)
143         $$(error Cannot continue)
144       endif
145       ifneq ($$(origin CONF_NAME), undefined)
146         # We also have a CONF_NAME argument. We can&#39;t have both.
147         $$(info Error: Cannot use CONF_NAME=$$(CONF_NAME) and SPEC=$$(SPEC) at the same time. Choose one.)
148         $$(error Cannot continue)
149       endif
150       ifeq ($$(wildcard $$(SPEC)),)
151         $$(info Error: Cannot locate spec.gmk, given by SPEC=$$(SPEC).)
152         $$(error Cannot continue)
153       endif
154       ifeq ($$(filter /%, $$(SPEC)),)
155         # If given with relative path, make it absolute
156         SPECS := $$(CURDIR)/$$(strip $$(SPEC))
157       else
158         SPECS := $$(SPEC)
159       endif
160 
161       # For now, unset this SPEC variable.
162       override SPEC :=
163     else
164       # Use spec.gmk files in the build output directory
165       ifeq ($$(all_spec_files),)
166         ifneq ($(CUSTOM_ROOT), )
167           $$(info Error: No configurations found for $$(CUSTOM_ROOT).)
168         else
169           $$(info Error: No configurations found for $$(topdir).)
170         endif
171         $$(info Please run &#39;bash configure&#39; to create a configuration.)
172         $$(info )
173         $$(error Cannot continue)
174       endif
175 
176       ifneq ($$(origin CONF_NAME), undefined)
177         ifneq ($$(origin CONF), undefined)
178           # We also have a CONF argument. We can&#39;t have both.
179           $$(info Error: Cannot use CONF=$$(CONF) and CONF_NAME=$$(CONF_NAME) at the same time. Choose one.)
180           $$(error Cannot continue)
181         endif
182         matching_conf := $$(strip $$(filter $$(CONF_NAME), $$(all_confs)))
183         ifeq ($$(matching_conf),)
184           $$(info Error: No configurations found matching CONF_NAME=$$(CONF_NAME).)
185           $$(info Available configurations in $$(build_dir):)
186           $$(foreach var, $$(all_confs), $$(info * $$(var)))
187           $$(error Cannot continue)
188         else ifneq ($$(words $$(matching_conf)), 1)
189           $$(info Error: Matching more than one configuration CONF_NAME=$$(CONF_NAME).)
190           $$(info Available configurations in $$(build_dir):)
191           $$(foreach var, $$(all_confs), $$(info * $$(var)))
192           $$(error Cannot continue)
193         else
194           $$(info Building configuration &#39;$$(matching_conf)&#39; (matching CONF_NAME=$$(CONF_NAME)))
195         endif
196         # Create a SPEC definition. This will contain the path to exactly one spec file.
197         SPECS := $$(build_dir)/$$(matching_conf)/spec.gmk
198       else ifneq ($$(origin CONF), undefined)
199         # User have given a CONF= argument.
200         ifeq ($$(CONF),)
201           # If given CONF=, match all configurations
202           matching_confs := $$(strip $$(all_confs))
203         else
204           # Otherwise select those that contain the given CONF string
205           matching_confs := $$(strip $$(foreach var, $$(all_confs), \
206               $$(if $$(findstring $$(CONF), $$(var)), $$(var))))
207         endif
208         ifeq ($$(matching_confs),)
209           $$(info Error: No configurations found matching CONF=$$(CONF).)
210           $$(info Available configurations in $$(build_dir):)
211           $$(foreach var, $$(all_confs), $$(info * $$(var)))
212           $$(error Cannot continue)
213         else
214           # Don&#39;t repeat this output on make restarts caused by including
215           # generated files.
216           ifeq ($$(MAKE_RESTARTS),)
217             ifeq ($$(words $$(matching_confs)), 1)
218               ifneq ($$(findstring $$(LOG_LEVEL), info debug trace),)
219                 $$(info Building configuration &#39;$$(matching_confs)&#39; (matching CONF=$$(CONF)))
220               endif
221             else
222               $$(info Building these configurations (matching CONF=$$(CONF)):)
223               $$(foreach var, $$(matching_confs), $$(info * $$(var)))
224             endif
225           endif
226         endif
227 
228         # Create a SPEC definition. This will contain the path to one or more spec.gmk files.
229         SPECS := $$(addsuffix /spec.gmk, $$(addprefix $$(build_dir)/, $$(matching_confs)))
230       else
231         # No CONF or SPEC given, check the available configurations
232         ifneq ($$(words $$(all_spec_files)), 1)
233           $$(info Error: No CONF given, but more than one configuration found.)
234           $$(info Available configurations in $$(build_dir):)
235           $$(foreach var, $$(all_confs), $$(info * $$(var)))
236           $$(info Please retry building with CONF=&lt;config pattern&gt; (or SPEC=&lt;spec file&gt;).)
237           $$(info )
238           $$(error Cannot continue)
239         endif
240 
241         # We found exactly one configuration, use it
242         SPECS := $$(strip $$(all_spec_files))
243       endif
244     endif
245   endef
246 
247   # Extract main targets from Main.gmk using the spec provided in $2.
248   #
249   # Param 1: FORCE = force generation of main-targets.gmk or LAZY = do not force.
250   # Param 2: The SPEC file to use.
251   define DefineMainTargets
252 
253     # We will start by making sure the main-targets.gmk file is removed, if
254     # make has not been restarted. By the -include, we will trigger the
255     # rule for generating the file (which is never there since we removed it),
256     # thus generating it fresh, and make will restart, incrementing the restart
257     # count.
258     main_targets_file := $$(dir $(strip $2))make-support/main-targets.gmk
259 
260     ifeq ($$(MAKE_RESTARTS),)
261       # Only do this if make has not been restarted, and if we do not force it.
262       ifeq ($(strip $1), FORCE)
263         $$(shell rm -f $$(main_targets_file))
264       endif
265     endif
266 
267     # The --no-print-directory is needed to make the call from
268     # FindTest.gmk to Test.gmk work with LOG=debug/trace. See
269     # JDK-8213736
270     $$(main_targets_file):
271 	@( cd $$(topdir) &amp;&amp; \
272 	$$(MAKE) $$(MAKE_LOG_FLAGS) -r -R --no-print-directory \
273 	    -f $$(topdir)/make/Main.gmk \
274 	    -I $$(topdir)/make/common SPEC=$(strip $2) NO_RECIPES=true \
275 	    $$(MAKE_LOG_VARS) \
276 	    create-main-targets-include )
277 
278     # Now include main-targets.gmk. This will define ALL_MAIN_TARGETS.
279     -include $$(main_targets_file)
280   endef
281 
282   define PrintConfCheckFailed
283 	@echo &#39; &#39;
284 	@echo &quot;Please rerun configure! Easiest way to do this is by running&quot;
285 	@echo &quot;&#39;make reconfigure&#39;.&quot;
286 	@echo &quot;This behavior may also be changed using CONF_CHECK=&lt;ignore|auto&gt;.&quot;
287 	@echo &#39; &#39;
288   endef
289 
290 else # $(HAS_SPEC)=true
291   ##############################################################################
292   # Helper functions for the &#39;main&#39; target. These functions assume a single,
293   # proper and existing SPEC is included.
294   ##############################################################################
295 
296   include $(TOPDIR)/make/common/MakeBase.gmk
297 
298   # Define basic logging setup
299   BUILD_LOG := $(OUTPUTDIR)/build.log
300   BUILD_PROFILE_LOG := $(OUTPUTDIR)/build-profile.log
301 
302   BUILD_LOG_PIPE := &gt; &gt;($(TEE) -a $(BUILD_LOG)) 2&gt; &gt;($(TEE) -a $(BUILD_LOG) &gt;&amp;2) &amp;&amp; wait
303 
304   ifneq ($(CUSTOM_ROOT), )
305     topdir=$(CUSTOM_ROOT)
306   else
307     topdir=$(TOPDIR)
308   endif
309 
310   # Parse COMPARE_BUILD into COMPARE_BUILD_*
311   # Syntax: COMPARE_BUILD=CONF=&lt;configure options&gt;:PATCH=&lt;patch file&gt;:
312   #         MAKE=&lt;make targets&gt;:COMP_OPTS=&lt;compare script options&gt;:
313   #         COMP_DIR=&lt;compare script base dir&gt;|&lt;default&gt;:
314   #         FAIL=&lt;bool&gt;
315   # If neither CONF or PATCH is given, assume &lt;default&gt; means CONF if it
316   # begins with &quot;--&quot;, otherwise assume it means PATCH.
317   # MAKE and COMP_OPTS can only be used with CONF and/or PATCH specified.
318   # If any value contains &quot;+&quot;, it will be replaced by space.
319   # FAIL can be set to false to have the return value of compare be ignored.
320   define ParseCompareBuild
321     ifneq ($$(COMPARE_BUILD), )
322       COMPARE_BUILD_OUTPUTDIR := $(topdir)/build/compare-build/$(CONF_NAME)
323       COMPARE_BUILD_FAIL := true
324 
325       ifneq ($$(findstring :, $$(COMPARE_BUILD)), )
326         $$(foreach part, $$(subst :, , $$(COMPARE_BUILD)), \
327           $$(if $$(filter PATCH=%, $$(part)), \
328             $$(eval COMPARE_BUILD_PATCH=$$(strip $$(patsubst PATCH=%, %, $$(part)))) \
329           ) \
330           $$(if $$(filter CONF=%, $$(part)), \
331             $$(eval COMPARE_BUILD_CONF=$$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(part))))) \
332           ) \
333           $$(if $$(filter MAKE=%, $$(part)), \
334             $$(eval COMPARE_BUILD_MAKE=$$(strip $$(subst +, , $$(patsubst MAKE=%, %, $$(part))))) \
335           ) \
336           $$(if $$(filter COMP_OPTS=%, $$(part)), \
337             $$(eval COMPARE_BUILD_COMP_OPTS=$$(strip $$(subst +, , $$(patsubst COMP_OPTS=%, %, $$(part))))) \
338           ) \
339           $$(if $$(filter COMP_DIR=%, $$(part)), \
340             $$(eval COMPARE_BUILD_COMP_DIR=$$(strip $$(subst +, , $$(patsubst COMP_DIR=%, %, $$(part))))) \
341           ) \
342           $$(if $$(filter FAIL=%, $$(part)), \
343             $$(eval COMPARE_BUILD_FAIL=$$(strip $$(subst +, , $$(patsubst FAIL=%, %, $$(part))))) \
344           ) \
345         )
346       else
347         # Separate handling for single field case, to allow for spaces in values.
348         ifneq ($$(filter PATCH=%, $$(COMPARE_BUILD)), )
349           COMPARE_BUILD_PATCH=$$(strip $$(patsubst PATCH=%, %, $$(COMPARE_BUILD)))
350         else ifneq ($$(filter CONF=%, $$(COMPARE_BUILD)), )
351           COMPARE_BUILD_CONF=$$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(COMPARE_BUILD))))
352         else ifneq ($$(filter --%, $$(COMPARE_BUILD)), )
353           # Assume CONF if value begins with --
354           COMPARE_BUILD_CONF=$$(strip $$(subst +, , $$(COMPARE_BUILD)))
355         else
356           # Otherwise assume patch file
357           COMPARE_BUILD_PATCH=$$(strip $$(COMPARE_BUILD))
358         endif
359       endif
360       ifneq ($$(COMPARE_BUILD_PATCH), )
361         ifneq ($$(wildcard $$(topdir)/$$(COMPARE_BUILD_PATCH)), )
362           # Assume relative path, if file exists
363           COMPARE_BUILD_PATCH := $$(wildcard $$(topdir)/$$(COMPARE_BUILD_PATCH))
364         else ifeq ($$(wildcard $$(COMPARE_BUILD_PATCH)), )
365           $$(error Patch file $$(COMPARE_BUILD_PATCH) does not exist)
366         endif
367       endif
368       ifneq ($$(COMPARE_BUILD_FAIL), true)
369         COMPARE_BUILD_IGNORE_RESULT := || true
370       endif
371     endif
372   endef
373 
374   # Prepare for a comparison rebuild
375   define PrepareCompareBuild
376 	$(ECHO) &quot;Preparing for comparison rebuild&quot;
377         # Apply patch, if any
378 	$(if $(COMPARE_BUILD_PATCH), cd $(topdir) &amp;&amp; $(PATCH) -p1 &lt; $(COMPARE_BUILD_PATCH))
379         # Move the first build away temporarily
380 	$(RM) -r $(topdir)/build/.compare-build-temp
381 	$(MKDIR) -p $(topdir)/build/.compare-build-temp
382 	$(MV) $(OUTPUTDIR) $(topdir)/build/.compare-build-temp
383         # Restore an old compare-build, or create a new compare-build directory.
384 	if test -d $(COMPARE_BUILD_OUTPUTDIR); then \
385 	  $(MV) $(COMPARE_BUILD_OUTPUTDIR) $(OUTPUTDIR); \
386 	else \
387 	  $(MKDIR) -p $(OUTPUTDIR); \
388 	fi
389         # Re-run configure with the same arguments (and possibly some additional),
390         # must be done after patching.
391 	( cd $(OUTPUTDIR) &amp;&amp; PATH=&quot;$(ORIGINAL_PATH)&quot; \
392 	    $(BASH) $(topdir)/configure $(CONFIGURE_COMMAND_LINE) $(COMPARE_BUILD_CONF))
393   endef
394 
395   # Cleanup after a compare build
396   define CleanupCompareBuild
397         # If running with a COMPARE_BUILD patch, reverse-apply it
398 	$(if $(COMPARE_BUILD_PATCH), cd $(topdir) &amp;&amp; $(PATCH) -R -p1 &lt; $(COMPARE_BUILD_PATCH))
399         # Move this build away and restore the original build
400 	$(MKDIR) -p $(topdir)/build/compare-build
401 	$(MV) $(OUTPUTDIR) $(COMPARE_BUILD_OUTPUTDIR)
402 	$(MV) $(topdir)/build/.compare-build-temp/$(CONF_NAME) $(OUTPUTDIR)
403 	$(RM) -r $(topdir)/build/.compare-build-temp
404   endef
405 
406   # Do the actual comparison of two builds
407   define CompareBuildDoComparison
408         # Compare first and second build. Ignore any error code from compare.sh.
409 	$(ECHO) &quot;Comparing between comparison rebuild (this/new) and baseline (other/old)&quot;
410 	$(if $(COMPARE_BUILD_COMP_DIR), \
411 	  +(cd $(COMPARE_BUILD_OUTPUTDIR) &amp;&amp; ./compare.sh $(COMPARE_BUILD_COMP_OPTS) \
412 	      -2dirs $(COMPARE_BUILD_OUTPUTDIR)/$(COMPARE_BUILD_COMP_DIR) \
413 	      $(OUTPUTDIR)/$(COMPARE_BUILD_COMP_DIR) $(COMPARE_BUILD_IGNORE_RESULT)), \
414 	  +(cd $(COMPARE_BUILD_OUTPUTDIR) &amp;&amp; ./compare.sh $(COMPARE_BUILD_COMP_OPTS) \
415 	      -o $(OUTPUTDIR) $(COMPARE_BUILD_IGNORE_RESULT)) \
416 	)
417   endef
418 
419   define PrintFailureReports
420 	$(if $(filter none, $(LOG_REPORT)), , \
421 	  $(if $(wildcard $(MAKESUPPORT_OUTPUTDIR)/failure-logs/*.log), \
422 	    $(PRINTF) &quot;\n=== Output from failing command(s) repeated here ===\n&quot; $(NEWLINE) \
423 	    $(foreach logfile, $(sort $(wildcard $(MAKESUPPORT_OUTPUTDIR)/failure-logs/*.log)), \
424 	        $(PRINTF) &quot;* For target $(notdir $(basename $(logfile))):\n&quot; $(NEWLINE) \
425 	        $(if $(filter all, $(LOG_REPORT)), \
426 	          $(GREP) -v -e &quot;^Note: including file:&quot; &lt;  $(logfile) || true $(NEWLINE) \
427 	        , \
428 	          ($(GREP) -v -e &quot;^Note: including file:&quot; &lt;  $(logfile) || true) | $(HEAD) -n 12 $(NEWLINE) \
429 	          if test `$(WC) -l &lt; $(logfile)` -gt 12; then \
430 	            $(ECHO) &quot;   ... (rest of output omitted)&quot; ; \
431 	          fi $(NEWLINE) \
432 	        ) \
433 	    ) \
434 	    $(PRINTF) &quot;\n* All command lines available in $(MAKESUPPORT_OUTPUTDIR)/failure-logs.\n&quot; $(NEWLINE) \
435 	    $(PRINTF) &quot;=== End of repeated output ===\n&quot; \
436 	  ) \
437 	)
438   endef
439 
440   define PrintBuildLogFailures
441 	$(if $(filter none, $(LOG_REPORT)), , \
442 	  if $(GREP) -q &quot;recipe for target .* failed&quot; $(BUILD_LOG) 2&gt; /dev/null; then  \
443 	    $(PRINTF) &quot;\n=== Make failed targets repeated here ===\n&quot; ; \
444 	    $(GREP) &quot;recipe for target .* failed&quot; $(BUILD_LOG) ; \
445 	    $(PRINTF) &quot;=== End of repeated output ===\n&quot; ; \
446 	    $(PRINTF) &quot;\nHint: Try searching the build log for the name of the first failed target.\n&quot; ; \
447 	  else \
448 	    $(PRINTF) &quot;\nNo indication of failed target found.\n&quot; ; \
449 	    $(PRINTF) &quot;Hint: Try searching the build log for &#39;] Error&#39;.\n&quot; ; \
450 	  fi \
451 	)
452   endef
453 
454   define RotateLogFiles
455 	$(RM) $(BUILD_LOG).old 2&gt; /dev/null &amp;&amp; \
456 	$(MV) $(BUILD_LOG) $(BUILD_LOG).old 2&gt; /dev/null || true
457 	$(if $(findstring true, $(LOG_PROFILE_TIMES_FILE)), \
458 	  $(RM) $(BUILD_PROFILE_LOG).old 2&gt; /dev/null &amp;&amp; \
459 	  $(MV) $(BUILD_PROFILE_LOG) $(BUILD_PROFILE_LOG).old 2&gt; /dev/null || true \
460 	)
461   endef
462 
463   # Failure logs are only supported for &quot;parallel&quot; main targets, not the
464   # (trivial) sequential make targets (such as clean and reconfigure),
465   # since the failure-logs directory creation will conflict with clean.
466   define PrepareFailureLogs
467 	$(RM) -r $(MAKESUPPORT_OUTPUTDIR)/failure-logs 2&gt; /dev/null &amp;&amp; \
468 	$(MKDIR) -p $(MAKESUPPORT_OUTPUTDIR)/failure-logs
469 	$(RM) $(MAKESUPPORT_OUTPUTDIR)/exit-with-error 2&gt; /dev/null
470   endef
471 
472   # Remove any javac server logs and port files. This
473   # prevents a new make run to reuse the previous servers.
474   define PrepareSmartJavac
475 	$(if $(SJAVAC_SERVER_DIR), \
476 	  $(RM) -r $(SJAVAC_SERVER_DIR) 2&gt; /dev/null &amp;&amp; \
477 	  $(MKDIR) -p $(SJAVAC_SERVER_DIR) \
478 	)
479   endef
480 
481   define CleanupSmartJavac
482 	[ -f $(SJAVAC_SERVER_DIR)/server.port ] &amp;&amp; $(ECHO) Stopping sjavac server &amp;&amp; \
483 	    $(TOUCH) $(SJAVAC_SERVER_DIR)/server.port.stop; true
484   endef
485 
486   ifeq ($(call isBuildOs, windows), true)
487     # On windows we need to synchronize with the javac server to be able to
488     # move or remove the build output directory. Since we have no proper
489     # synchronization process, wait for a while and hope it helps. This is only
490     # used by build comparisons.
491     define WaitForSmartJavacFinish
492 	$(if $(SJAVAC_SERVER_DIR), \
493 	  sleep 5\
494 	)
495     endef
496   else
497     define WaitForSmartJavacFinish
498     endef
499   endif
500 
501   define StartGlobalTimer
502 	$(RM) -r $(BUILDTIMESDIR) 2&gt; /dev/null &amp;&amp; \
503 	$(MKDIR) -p $(BUILDTIMESDIR) &amp;&amp; \
504 	$(call RecordStartTime,TOTAL)
505   endef
506 
507   define StopGlobalTimer
508 	$(call RecordEndTime,TOTAL)
509   endef
510 
511   # Find all build_time_* files and print their contents in a list sorted
512   # on the name of the sub repository.
513   define ReportBuildTimes
514 	$(PRINTF) $(LOG_INFO) -- \
515 	    &quot;----- Build times -------\nStart %s\nEnd   %s\n%s\n%s\n-------------------------\n&quot; \
516 	    &quot;`$(CAT) $(BUILDTIMESDIR)/build_time_start_TOTAL_human_readable`&quot; \
517 	    &quot;`$(CAT) $(BUILDTIMESDIR)/build_time_end_TOTAL_human_readable`&quot; \
518 	    &quot;`$(LS) $(BUILDTIMESDIR)/build_time_diff_* | $(GREP) -v _TOTAL | \
519 	    $(XARGS) $(CAT) | $(SORT) -k 2`&quot; \
520 	    &quot;`$(CAT) $(BUILDTIMESDIR)/build_time_diff_TOTAL`&quot; \
521 	    $(BUILD_LOG_PIPE)
522   endef
523 
524   define ReportProfileTimes
525     $(if $(findstring true, $(LOG_PROFILE_TIMES_LOG)), \
526       [ ! -f $(BUILD_PROFILE_LOG) ] || \
527       { $(ECHO) Begin $(notdir $(BUILD_PROFILE_LOG)) &amp;&amp; \
528         $(CAT) $(BUILD_PROFILE_LOG) &amp;&amp; \
529         $(ECHO) End $(notdir $(BUILD_PROFILE_LOG)); \
530       } \
531       $(BUILD_LOG_PIPE)
532     )
533   endef
534 
535 endif # HAS_SPEC
536 
537 # Look for a given option in the LOG variable, and if found, set a variable
538 # and remove the option from the LOG variable
539 # $1: The option to look for
540 # $2: The variable to set to &quot;true&quot; if the option is found
541 define ParseLogOption
542   ifneq ($$(findstring $1, $$(LOG)),)
543     override $2 := true
544     # First try to remove &quot;,&lt;option&gt;&quot; if it exists, otherwise just remove &quot;&lt;option&gt;&quot;
545     LOG_STRIPPED := $$(subst $1,, $$(subst $$(COMMA)$$(strip $1),, $$(LOG)))
546     # We might have ended up with a leading comma. Remove it. Need override
547     # since LOG is set from the command line.
548     override LOG := $$(strip $$(patsubst $$(COMMA)%, %, $$(LOG_STRIPPED)))
549   endif
550 endef
551 
552 # Look for a given option with an assignment in the LOG variable, and if found,
553 # set a variable to that value and remove the option from the LOG variable
554 # $1: The option to look for
555 # $2: The variable to set to the value of the option, if found
556 define ParseLogValue
557   ifneq ($$(findstring $1=, $$(LOG)),)
558     # Make words of out comma-separated list and find the one with opt=val
559     value := $$(strip $$(subst $$(strip $1)=,, $$(filter $$(strip $1)=%, $$(subst $$(COMMA), , $$(LOG)))))
560     override $2 := $$(value)
561     # First try to remove &quot;,&lt;option&gt;&quot; if it exists, otherwise just remove &quot;&lt;option&gt;&quot;
562     LOG_STRIPPED := $$(subst $$(strip $1)=$$(value),, \
563         $$(subst $$(COMMA)$$(strip $1)=$$(value),, $$(LOG)))
564     # We might have ended up with a leading comma. Remove it. Need override
565     # since LOG is set from the command line.
566     override LOG := $$(strip $$(patsubst $$(COMMA)%, %, $$(LOG_STRIPPED)))
567   endif
568 endef
569 
570 
571 define ParseLogLevel
572   # Catch old-style VERBOSE= command lines.
573   ifneq ($$(origin VERBOSE), undefined)
574     $$(info Error: VERBOSE is deprecated. Use LOG=&lt;warn|info|debug|trace&gt; instead.)
575     $$(error Cannot continue)
576   endif
577 
578   # Setup logging according to LOG
579 
580   # If &quot;nofile&quot; is present, do not log to a file
581   $$(eval $$(call ParseLogOption, nofile, LOG_NOFILE))
582 
583   # If &quot;cmdline&quot; is present, print all executes &quot;important&quot; command lines.
584   $$(eval $$(call ParseLogOption, cmdlines, LOG_CMDLINES))
585 
586   # If &quot;report&quot; is present, use non-standard reporting options at build failure.
587   $$(eval $$(call ParseLogValue, report, LOG_REPORT))
588   ifneq ($$(LOG_REPORT), )
589     ifeq ($$(filter $$(LOG_REPORT), none all default), )
590       $$(info Error: LOG=report has invalid value: $$(LOG_REPORT).)
591       $$(info Valid values: LOG=report=&lt;none&gt;|&lt;all&gt;|&lt;default&gt;)
592       $$(error Cannot continue)
593     endif
594   endif
595 
596   # If &quot;profile-to-log&quot; is present, write shell times in build log
597   $$(eval $$(call ParseLogOption, profile-to-log, LOG_PROFILE_TIMES_LOG))
598 
599   # If &quot;profile&quot; is present, write shell times in separate log file
600   # IMPORTANT: $(ParseLogOption profile-to-log) should go first. Otherwise
601   # parsing of &#39;LOG=debug,profile-to-log,nofile&#39; ends up in the following error:
602   # Error: LOG contains unknown option or log level: debug-to-log.
603   $$(eval $$(call ParseLogOption, profile, LOG_PROFILE_TIMES_FILE))
604 
605   # Treat LOG=profile-to-log as if it were LOG=profile,profile-to-log
606   LOG_PROFILE_TIMES_FILE := $$(firstword $$(LOG_PROFILE_TIMES_FILE) $$(LOG_PROFILE_TIMES_LOG))
607 
608   override LOG_LEVEL := $$(LOG)
609 
610   ifeq ($$(LOG_LEVEL),)
611     # Set LOG to &quot;warn&quot; as default if not set
612     override LOG_LEVEL := warn
613   endif
614 
615   ifeq ($$(LOG_LEVEL), warn)
616     override MAKE_LOG_FLAGS := -s
617   else ifeq ($$(LOG_LEVEL), info)
618     override MAKE_LOG_FLAGS := -s
619   else ifeq ($$(LOG_LEVEL), debug)
620     override MAKE_LOG_FLAGS :=
621   else ifeq ($$(LOG_LEVEL), trace)
622     override MAKE_LOG_FLAGS :=
623   else
624     $$(info Error: LOG contains unknown option or log level: $$(LOG).)
625     $$(info LOG can be &lt;level&gt;[,&lt;opt&gt;[...]] where &lt;opt&gt; is nofile | cmdlines | profile | profile-to-log)
626     $$(info and &lt;level&gt; is warn | info | debug | trace)
627     $$(error Cannot continue)
628   endif
629 endef
630 
631 MAKE_LOG_VARS = $(foreach v, \
632     LOG_LEVEL LOG_NOFILE LOG_CMDLINES LOG_REPORT LOG_PROFILE_TIMES_LOG \
633     LOG_PROFILE_TIMES_FILE, \
634     $v=$($v) \
635 )
636 
637 endif # _INITSUPPORT_GMK
    </pre>
  </body>
</html>
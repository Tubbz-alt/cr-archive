<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/RunTests.gmk</title>
    <link rel="stylesheet" href="../style.css" />
    <script type="text/javascript" src="../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 #
   2 # Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
   3 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4 #
   5 # This code is free software; you can redistribute it and/or modify it
   6 # under the terms of the GNU General Public License version 2 only, as
   7 # published by the Free Software Foundation.  Oracle designates this
   8 # particular file as subject to the &quot;Classpath&quot; exception as provided
   9 # by Oracle in the LICENSE file that accompanied this code.
  10 #
  11 # This code is distributed in the hope that it will be useful, but WITHOUT
  12 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14 # version 2 for more details (a copy is included in the LICENSE file that
  15 # accompanied this code).
  16 #
  17 # You should have received a copy of the GNU General Public License version
  18 # 2 along with this work; if not, write to the Free Software Foundation,
  19 # Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20 #
  21 # Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22 # or visit www.oracle.com if you need additional information or have any
  23 # questions.
  24 #
  25 
  26 default: all
  27 
  28 include $(SPEC)
  29 include MakeBase.gmk
  30 include FindTests.gmk
  31 
  32 # We will always run multiple tests serially
  33 .NOTPARALLEL:
  34 
  35 ################################################################################
  36 # Parse global control variables
  37 ################################################################################
  38 
  39 ifneq ($(TEST_VM_OPTS), )
  40   ifneq ($(TEST_OPTS), )
  41     TEST_OPTS := $(TEST_OPTS);VM_OPTIONS=$(TEST_VM_OPTS)
  42   else
  43     TEST_OPTS := VM_OPTIONS=$(TEST_VM_OPTS)
  44   endif
  45 endif
  46 
  47 $(eval $(call ParseKeywordVariable, TEST_OPTS, \
  48     SINGLE_KEYWORDS := JOBS TIMEOUT_FACTOR JCOV, \
  49     STRING_KEYWORDS := VM_OPTIONS JAVA_OPTIONS AOT_MODULES, \
  50 ))
  51 
  52 # Helper function to propagate TEST_OPTS values.
  53 #
  54 # Note: No spaces are allowed around the arguments.
  55 # Arg $1 The variable in TEST_OPTS to propagate
  56 # Arg $2 The control variable to propagate it to
  57 define SetTestOpt
  58   ifneq ($$(TEST_OPTS_$1), )
  59     $2_$1 := $$(TEST_OPTS_$1)
  60   endif
  61 endef
  62 
  63 # Setup _NT_SYMBOL_PATH on Windows
  64 ifeq ($(call isTargetOs, windows), true)
  65   ifndef _NT_SYMBOL_PATH
  66     # Can&#39;t use PathList here as it adds quotes around the value.
  67     _NT_SYMBOL_PATH := \
  68         $(subst $(SPACE),;,$(strip \
  69             $(foreach p, $(sort $(dir $(wildcard \
  70                 $(addprefix $(SYMBOLS_IMAGE_DIR)/bin/, *.pdb */*.pdb)))), \
  71               $(call FixPath, $p) \
  72             ) \
  73         ))
  74     export _NT_SYMBOL_PATH
  75     $(call LogDebug, Rewriting _NT_SYMBOL_PATH to $(_NT_SYMBOL_PATH))
  76   endif
  77 endif
  78 
  79 ################################################################################
  80 # Hook to include the corresponding custom file, if present.
  81 $(eval $(call IncludeCustomExtension, RunTests.gmk))
  82 ################################################################################
  83 
  84 # This is the JDK that we will test
  85 JDK_UNDER_TEST := $(JDK_IMAGE_DIR)
  86 
  87 TEST_RESULTS_DIR := $(OUTPUTDIR)/test-results
  88 TEST_SUPPORT_DIR := $(OUTPUTDIR)/test-support
  89 TEST_SUMMARY := $(TEST_RESULTS_DIR)/test-summary.txt
  90 TEST_LAST_IDS := $(TEST_SUPPORT_DIR)/test-last-ids.txt
  91 
  92 ifeq ($(CUSTOM_ROOT), )
  93   JTREG_TOPDIR := $(TOPDIR)
  94 else
  95   JTREG_TOPDIR := $(CUSTOM_ROOT)
  96 endif
  97 
  98 JTREG_FAILURE_HANDLER_DIR := $(TEST_IMAGE_DIR)/failure_handler
  99 JTREG_FAILURE_HANDLER := $(JTREG_FAILURE_HANDLER_DIR)/jtregFailureHandler.jar
 100 
<a name="1" id="anc1"></a>

 101 ifneq ($(wildcard $(JTREG_FAILURE_HANDLER)), )
 102   JTREG_FAILURE_HANDLER_OPTIONS := \
 103       -timeoutHandlerDir:$(JTREG_FAILURE_HANDLER) \
 104       -observerDir:$(JTREG_FAILURE_HANDLER) \
 105       -timeoutHandler:jdk.test.failurehandler.jtreg.GatherProcessInfoTimeoutHandler \
 106       -observer:jdk.test.failurehandler.jtreg.GatherDiagnosticInfoObserver \
<a name="2" id="anc2"></a><span class="line-modified"> 107       -timeoutHandlerTimeout:0</span>
 108 endif
 109 
 110 GTEST_LAUNCHER_DIRS := $(patsubst %/gtestLauncher, %, \
 111     $(wildcard $(TEST_IMAGE_DIR)/hotspot/gtest/*/gtestLauncher))
 112 GTEST_VARIANTS := $(strip $(patsubst $(TEST_IMAGE_DIR)/hotspot/gtest/%, %, \
 113     $(GTEST_LAUNCHER_DIRS)))
 114 
 115 COV_ENVIRONMENT :=
 116 JTREG_COV_OPTIONS :=
 117 
 118 ifeq ($(TEST_OPTS_JCOV), true)
 119   JCOV_OUTPUT_DIR := $(TEST_RESULTS_DIR)/jcov-output
 120   JCOV_GRABBER_LOG := $(JCOV_OUTPUT_DIR)/grabber.log
 121   JCOV_RESULT_FILE := $(JCOV_OUTPUT_DIR)/result.xml
 122   JCOV_REPORT := $(JCOV_OUTPUT_DIR)/report
 123   JCOV_MEM_OPTIONS := -Xms64m -Xmx4g
 124 
 125   # Replace our normal test JDK with the JCov image.
 126   JDK_UNDER_TEST := $(JCOV_IMAGE_DIR)
 127 
 128   COV_ENVIRONMENT += JAVA_TOOL_OPTIONS=&quot;$(JCOV_MEM_OPTIONS)&quot; \
 129       _JAVA_OPTIONS=&quot;$(JCOV_MEM_OPTIONS)&quot;
 130   JTREG_COV_OPTIONS += -e:JAVA_TOOL_OPTIONS=&#39;$(JCOV_MEM_OPTIONS)&#39; \
 131       -e:_JAVA_OPTIONS=&#39;$(JCOV_MEM_OPTIONS)&#39;
 132 endif
 133 
 134 ifeq ($(GCOV_ENABLED), true)
 135   GCOV_OUTPUT_DIR := $(TEST_RESULTS_DIR)/gcov-output
 136   COV_ENVIRONMENT += GCOV_PREFIX=&quot;$(GCOV_OUTPUT_DIR)&quot;
 137   JTREG_COV_OPTIONS += -e:GCOV_PREFIX=&quot;$(GCOV_OUTPUT_DIR)&quot;
 138 endif
 139 
 140 ################################################################################
 141 # Optionally create AOT libraries for specified modules before running tests.
 142 # Note, this could not be done during JDK build time.
 143 ################################################################################
 144 
 145 # Note, this could not be done during JDK build time.
 146 
 147 # Parameter 1 is the name of the rule.
 148 #
 149 # Remaining parameters are named arguments.
 150 #   MODULE      The module to generate a library for
 151 #   BIN         Output directory in which to put the library
 152 #   VM_OPTIONS  List of JVM arguments to use when creating library
 153 #   OPTIONS_VAR Name of variable to put AOT java options in
 154 #   PREREQS_VAR Name of variable to put all AOT prerequisite rule targets in
 155 #               for test rules to depend on
 156 #
 157 SetupAotModule = $(NamedParamsMacroTemplate)
 158 define SetupAotModuleBody
 159   $1_AOT_LIB := $$($1_BIN)/$$(call SHARED_LIBRARY,$$($1_MODULE))
 160   $1_AOT_CCLIST := $$(wildcard $$(TOPDIR)/test/hotspot/jtreg/compiler/aot/scripts/$$($1_MODULE)-list.txt)
 161 
 162   # Create jaotc flags.
 163   # VM flags which don&#39;t affect AOT code generation are filtered out:
 164   # -Xcomp, -XX:+-TieredCompilation
 165   $1_JAOTC_OPTS := \
 166       -J-Xmx4g --info \
 167       $$(addprefix -J, $$(filter-out -Xcomp %TieredCompilation, $$($1_VM_OPTIONS))) \
 168       $$(addprefix --compile-commands$(SPACE), $$($1_AOT_CCLIST)) \
 169       --linker-path $$(LD_JAOTC) \
 170       #
 171 
 172   ifneq ($$(filter -ea, $$($1_VM_OPTIONS)), )
 173     $1_JAOTC_OPTS += --compile-with-assertions
 174   endif
 175 
 176   $$($1_AOT_LIB): $$(JDK_UNDER_TEST)/release \
 177       $$(call DependOnVariable, $1_JAOTC_OPTS) \
 178       $$(call DependOnVariable, JDK_UNDER_TEST)
 179 	$$(call LogWarn, Generating $$(patsubst $$(OUTPUTDIR)/%, %, $$@))
 180 	$$(call MakeTargetDir)
 181 	$$(call ExecuteWithLog, $$@, \
 182 	    $((COV_ENVIRONMENT) \
 183 	    $$(FIXPATH) $$(JDK_UNDER_TEST)/bin/jaotc \
 184 	        $$($1_JAOTC_OPTS) --output $$@ --module $$($1_MODULE) \
 185 	)
<a name="3" id="anc3"></a><span class="line-modified"> 186 	$$(call ExecuteWithLog, $$@.check, \</span>
 187 	    $$(FIXPATH) $$(JDK_UNDER_TEST)/bin/java \
<a name="4" id="anc4"></a><span class="line-modified"> 188 	        $$($1_VM_OPTIONS) -XX:+UnlockDiagnosticVMOptions \</span>
 189 	        -XX:+PrintAOT -XX:+UseAOTStrictLoading \
 190 	        -XX:AOTLibrary=$$@ -version \
 191 	         &gt; $$@.verify-aot \
<a name="5" id="anc5"></a><span class="line-modified"> 192 	)</span>
 193 
<a name="6" id="anc6"></a>
 194   $1_AOT_OPTIONS += -XX:AOTLibrary=$$($1_AOT_LIB)
 195   $1_AOT_TARGETS += $$($1_AOT_LIB)
 196 endef
 197 
 198 # Parameter 1 is the name of the rule.
 199 #
 200 # Remaining parameters are named arguments.
 201 #   MODULES     The modules to generate a library for
 202 #   VM_OPTIONS  List of JVM arguments to use when creating libraries
 203 #
 204 # After calling this, the following variables are defined
 205 #   $1_AOT_OPTIONS List of all java options needed to use the AOT libraries
 206 #   $1_AOT_TARGETS List of all targets that the test rule will need to depend on
 207 #
 208 SetupAot = $(NamedParamsMacroTemplate)
 209 define SetupAotBody
 210   $$(info Running with AOTd libraries for $$($1_MODULES))
 211   # Put aot libraries in a separate directory so they are not deleted between
 212   # test runs and may be reused between make invocations.
 213   $$(foreach m, $$($1_MODULES), \
 214     $$(eval $$(call SetupAotModule, $1_$$m, \
 215         MODULE := $$m, \
 216         BIN := $$(TEST_SUPPORT_DIR)/aot/$1, \
 217         VM_OPTIONS := $$($1_VM_OPTIONS), \
 218     )) \
 219     $$(eval $1_AOT_OPTIONS += $$($1_$$m_AOT_OPTIONS)) \
 220     $$(eval $1_AOT_TARGETS += $$($1_$$m_AOT_TARGETS)) \
 221   )
 222 endef
 223 
 224 ################################################################################
 225 # Setup global test running parameters
 226 ################################################################################
 227 
 228 # Each factor variable comes in 3 variants. The first one is reserved for users
 229 # to use on command line. The other two are for predifined configurations in JDL
 230 # and for machine specific configurations respectively.
 231 TEST_JOBS_FACTOR ?= 1
 232 TEST_JOBS_FACTOR_JDL ?= 1
 233 TEST_JOBS_FACTOR_MACHINE ?= 1
 234 
 235 ifeq ($(TEST_JOBS), 0)
 236   CORES_DIVIDER := 2
 237   ifeq ($(call isTargetCpuArch, sparc), true)
 238     # For smaller SPARC machines we see reasonable scaling of throughput up to
 239     # cpus/4 without affecting test reliability. On the bigger machines, cpus/4
 240     # causes intermittent timeouts.
 241     ifeq ($(shell $(EXPR) $(NUM_CORES) \&gt; 16), 1)
 242       CORES_DIVIDER := 5
 243     else
 244       CORES_DIVIDER := 4
 245     endif
 246   endif
<a name="7" id="anc7"></a>












 247   MEMORY_DIVIDER := 2048
 248   TEST_JOBS := $(shell $(AWK) \
 249     &#39;BEGIN { \
 250       c = $(NUM_CORES) / $(CORES_DIVIDER); \
 251       m = $(MEMORY_SIZE) / $(MEMORY_DIVIDER); \
<a name="8" id="anc8"></a>




 252       if (c &gt; m) c = m; \
 253       c = c * $(TEST_JOBS_FACTOR); \
 254       c = c * $(TEST_JOBS_FACTOR_JDL); \
 255       c = c * $(TEST_JOBS_FACTOR_MACHINE); \
 256       if (c &lt; 1) c = 1; \
 257       printf &quot;%.0f&quot;, c; \
 258     }&#39;)
 259 endif
 260 
 261 ################################################################################
 262 # Parse control variables
 263 ################################################################################
 264 
 265 ifneq ($(TEST_OPTS), )
 266   # Inform the user
 267   $(info Running tests using TEST_OPTS control variable &#39;$(TEST_OPTS)&#39;)
 268 endif
 269 
 270 ### Jtreg
 271 
 272 $(eval $(call SetTestOpt,VM_OPTIONS,JTREG))
 273 $(eval $(call SetTestOpt,JAVA_OPTIONS,JTREG))
 274 $(eval $(call SetTestOpt,AOT_MODULES,JTREG))
 275 
 276 $(eval $(call SetTestOpt,JOBS,JTREG))
 277 $(eval $(call SetTestOpt,TIMEOUT_FACTOR,JTREG))
<a name="9" id="anc9"></a>
 278 
 279 $(eval $(call ParseKeywordVariable, JTREG, \
<a name="10" id="anc10"></a><span class="line-modified"> 280     SINGLE_KEYWORDS := JOBS TIMEOUT_FACTOR TEST_MODE ASSERT VERBOSE RETAIN \</span>
<span class="line-modified"> 281         MAX_MEM, \</span>

 282     STRING_KEYWORDS := OPTIONS JAVA_OPTIONS VM_OPTIONS KEYWORDS \
 283         EXTRA_PROBLEM_LISTS AOT_MODULES, \
 284 ))
 285 
 286 ifneq ($(JTREG), )
 287   # Inform the user
 288   $(info Running tests using JTREG control variable &#39;$(JTREG)&#39;)
 289 endif
 290 
 291 ### Gtest
 292 
 293 $(eval $(call SetTestOpt,VM_OPTIONS,GTEST))
 294 $(eval $(call SetTestOpt,JAVA_OPTIONS,GTEST))
 295 $(eval $(call SetTestOpt,AOT_MODULES,GTEST))
 296 
 297 $(eval $(call ParseKeywordVariable, GTEST, \
 298     SINGLE_KEYWORDS := REPEAT, \
 299     STRING_KEYWORDS := OPTIONS VM_OPTIONS JAVA_OPTIONS AOT_MODULES, \
 300 ))
 301 
 302 ifneq ($(GTEST), )
 303   # Inform the user
 304   $(info Running tests using GTEST control variable &#39;$(GTEST)&#39;)
 305 endif
 306 
 307 ### Microbenchmarks
 308 
 309 $(eval $(call SetTestOpt,VM_OPTIONS,MICRO))
 310 $(eval $(call SetTestOpt,JAVA_OPTIONS,MICRO))
 311 
 312 $(eval $(call ParseKeywordVariable, MICRO, \
 313     SINGLE_KEYWORDS := ITER FORK TIME WARMUP_ITER WARMUP_TIME, \
 314     STRING_KEYWORDS := OPTIONS JAVA_OPTIONS VM_OPTIONS RESULTS_FORMAT TEST_JDK \
 315         BENCHMARKS_JAR, \
 316 ))
 317 
 318 ifneq ($(MICRO), )
 319   # Inform the user
 320   $(info Running tests using MICRO control variable &#39;$(MICRO)&#39;)
 321 endif
 322 
 323 
 324 ################################################################################
 325 # Component-specific Jtreg settings
 326 ################################################################################
 327 
 328 hotspot_JTREG_MAX_MEM := 0
 329 hotspot_JTREG_ASSERT := false
 330 hotspot_JTREG_NATIVEPATH := $(TEST_IMAGE_DIR)/hotspot/jtreg/native
 331 jdk_JTREG_NATIVEPATH := $(TEST_IMAGE_DIR)/jdk/jtreg/native
 332 
 333 jdk_JTREG_PROBLEM_LIST += $(TOPDIR)/test/jdk/ProblemList.txt
 334 jaxp_JTREG_PROBLEM_LIST += $(TOPDIR)/test/jaxp/ProblemList.txt
 335 langtools_JTREG_PROBLEM_LIST += $(TOPDIR)/test/langtools/ProblemList.txt
 336 nashorn_JTREG_PROBLEM_LIST += $(TOPDIR)/test/nashorn/ProblemList.txt
 337 hotspot_JTREG_PROBLEM_LIST += $(TOPDIR)/test/hotspot/jtreg/ProblemList.txt
 338 
 339 langtools_JTREG_MAX_MEM := 768m
 340 
 341 ################################################################################
 342 # Parse test selection
 343 #
 344 # The user has given a test selection in the TEST variable. We must parse it
 345 # and determine what that means in terms of actual calls to the test framework.
 346 #
 347 # The parse functions take as argument a test specification as given by the
 348 # user, and returns a fully qualified test descriptor if it was a match, or
 349 # nothing if not. A single test specification can result in multiple test
 350 # descriptors being returned. A valid test descriptor must always be accepted
 351 # and returned identically.
 352 ################################################################################
 353 
 354 # Helper function to determine if a test specification is a Gtest test
 355 #
 356 # It is a Gtest test if it is either &quot;gtest&quot;, or &quot;gtest:&quot; followed by an optional
 357 # test filter string, and an optional &quot;/&lt;variant&gt;&quot; to select a specific JVM
 358 # variant. If no variant is specified, all found variants are tested.
 359 define ParseGtestTestSelection
 360   $(if $(filter gtest%, $1), \
 361     $(if $(filter gtest, $1), \
 362       $(addprefix gtest:all/, $(GTEST_VARIANTS)) \
 363     , \
 364       $(if $(strip $(or $(filter gtest/%, $1) $(filter gtest:/%, $1))), \
 365         $(patsubst gtest:/%, gtest:all/%, $(patsubst gtest/%, gtest:/%, $1)) \
 366       , \
 367         $(if $(filter gtest:%, $1), \
 368           $(if $(findstring /, $1), \
 369             $1 \
 370           , \
 371             $(addprefix $1/, $(GTEST_VARIANTS)) \
 372           ) \
 373         ) \
 374       ) \
 375     ) \
 376   )
 377 endef
 378 
 379 # Helper function to determine if a test specification is a microbenchmark test
 380 #
 381 # It is a microbenchmark test if it is either &quot;micro&quot;, or &quot;micro:&quot; followed by
 382 # an optional test filter string.
 383 define ParseMicroTestSelection
 384   $(if $(filter micro%, $1), \
 385     $(if $(filter micro, $1), \
 386       micro:all \
 387     , \
 388       $(if $(filter micro:, $1), \
 389         micro:all \
 390       , \
 391         $1 \
 392       ) \
 393     ) \
 394   )
 395 endef
 396 
 397 # Helper function that removes the TOPDIR part
 398 CleanupJtregPath = \
 399   $(strip $(patsubst %/, %, $(subst $(JTREG_TOPDIR)/,, $1)))
 400 
 401 # Take a partial Jtreg root path and return a full, absolute path to that Jtreg
 402 # root. Also support having &quot;hotspot&quot; as an alias for &quot;hotspot/jtreg&quot;.
 403 ExpandJtregRoot = \
 404   $(call CleanupJtregPath, $(wildcard \
 405     $(if $(filter /%, $1), \
 406       $(if $(wildcard $(strip $1)/TEST.ROOT), \
 407         $1 \
 408       ) \
 409     , \
 410       $(filter $(addprefix %, $1), $(JTREG_TESTROOTS) $(addsuffix /, $(JTREG_TESTROOTS))) \
 411       $(filter $(addprefix %, $(strip $1)/jtreg), $(JTREG_TESTROOTS) $(addsuffix /, $(JTREG_TESTROOTS))) \
 412     ) \
 413   ))
 414 
 415 # Take a partial Jtreg test path and return a full, absolute path to that Jtreg
 416 # test. Also support having &quot;hotspot&quot; as an alias for &quot;hotspot/jtreg&quot;.
 417 ExpandJtregPath = \
 418   $(if $(call ExpandJtregRoot, $1), \
 419     $(call ExpandJtregRoot, $1) \
 420   , \
 421     $(call CleanupJtregPath, $(wildcard \
 422       $(if $(filter /%, $1), \
 423         $1 \
 424       , \
 425         $(addsuffix /$(strip $1), $(JTREG_TESTROOTS) $(TEST_BASEDIRS)) \
 426         $(addsuffix $(strip $(patsubst hotspot/%, /hotspot/jtreg/%, $1)), $(JTREG_TESTROOTS) $(TEST_BASEDIRS)) \
 427       ) \
 428     )) \
 429   )
 430 
 431 # Helper function to determine if a test specification is a Jtreg test
 432 #
 433 # It is a Jtreg test if it optionally begins with jtreg:, and then is either
 434 # an unspecified group name (possibly prefixed by :), or a group in a
 435 # specified test root, or a path to a test or test directory,
 436 # either absolute or relative to any of the TEST_BASEDIRS or test roots.
 437 define ParseJtregTestSelection
 438   $(eval TEST_NAME := $(strip $(patsubst jtreg:%, %, $1))) \
 439   $(if $(or $(findstring :, $(TEST_NAME)), $(findstring /, $(TEST_NAME))), , \
 440     $(eval TEST_NAME := :$(TEST_NAME)) \
 441   ) \
 442   $(if $(findstring :, $(TEST_NAME)), \
 443     $(if $(filter :%, $(TEST_NAME)), \
 444       $(eval TEST_GROUP := $(patsubst :%, %, $(TEST_NAME))) \
 445       $(eval TEST_ROOTS := $(foreach test_root, $(JTREG_TESTROOTS), \
 446           $(call CleanupJtregPath, $(test_root)))) \
 447     , \
 448       $(eval TEST_PATH := $(word 1, $(subst :, $(SPACE), $(TEST_NAME)))) \
 449       $(eval TEST_GROUP := $(word 2, $(subst :, $(SPACE), $(TEST_NAME)))) \
 450       $(eval TEST_ROOTS := $(call ExpandJtregRoot, $(TEST_PATH))) \
 451     ) \
 452     $(foreach test_root, $(TEST_ROOTS), \
 453       $(if $(filter /%, $(test_root)), \
 454         jtreg:$(test_root):$(TEST_GROUP) \
 455       , \
 456         $(if $(filter $(TEST_GROUP), $($(JTREG_TOPDIR)/$(test_root)_JTREG_TEST_GROUPS)), \
 457           jtreg:$(test_root):$(TEST_GROUP) \
 458         ) \
 459       ) \
 460     ) \
 461   , \
 462     $(eval TEST_PATHS := $(call ExpandJtregPath, $(TEST_NAME))) \
 463     $(foreach test_path, $(TEST_PATHS), \
 464       jtreg:$(test_path) \
 465     ) \
 466   )
 467 endef
 468 
 469 # Helper function to determine if a test specification is a special test
 470 #
 471 # It is a special test if it is &quot;special:&quot; followed by a test name,
 472 # if it is &quot;make:&quot; or &quot;make-&quot; followed by a make test, or any of the special
 473 # test names as a single word.
 474 define ParseSpecialTestSelection
 475   $(if $(filter special:%, $1), \
 476     $1 \
 477   ) \
 478   $(if $(filter make%, $1), \
 479     $(if $(filter make:%, $1), \
 480       special:$(strip $1) \
 481     ) \
 482     $(if $(filter make-%, $1), \
 483       special:$(patsubst make-%,make:%, $1) \
 484     ) \
 485     $(if $(filter make, $1), \
 486       special:make:all \
 487     )
 488   ) \
 489   $(if $(filter failure-handler, $1), \
 490     special:$(strip $1) \
 491   )
 492 endef
 493 
 494 ifeq ($(TEST), )
 495   $(info No test selection given in TEST!)
 496   $(info Please use e.g. &#39;make test TEST=tier1&#39; or &#39;make test-tier1&#39;)
 497   $(info See doc/testing.[md|html] for help)
 498   $(error Cannot continue)
 499 endif
 500 
 501 # Now intelligently convert the test selection given by the user in TEST
 502 # into a list of fully qualified test descriptors of the tests to run.
 503 TESTS_TO_RUN :=
 504 $(foreach test, $(TEST), \
 505   $(eval PARSED_TESTS := $(call ParseCustomTestSelection, $(test))) \
 506   $(if $(strip $(PARSED_TESTS)), , \
 507     $(eval PARSED_TESTS += $(call ParseGtestTestSelection, $(test))) \
 508   ) \
 509   $(if $(strip $(PARSED_TESTS)), , \
 510     $(eval PARSED_TESTS += $(call ParseMicroTestSelection, $(test))) \
 511   ) \
 512   $(if $(strip $(PARSED_TESTS)), , \
 513     $(eval PARSED_TESTS += $(call ParseJtregTestSelection, $(test))) \
 514   ) \
 515   $(if $(strip $(PARSED_TESTS)), , \
 516     $(eval PARSED_TESTS += $(call ParseSpecialTestSelection, $(test))) \
 517   ) \
 518   $(if $(strip $(PARSED_TESTS)), , \
 519     $(eval UNKNOWN_TEST := $(test)) \
 520   ) \
 521   $(eval TESTS_TO_RUN += $(PARSED_TESTS)) \
 522 )
 523 
 524 ifneq ($(UNKNOWN_TEST), )
 525   $(info Unknown test selection: &#39;$(UNKNOWN_TEST)&#39;)
 526   $(info See doc/testing.[md|html] for help)
 527   $(error Cannot continue)
 528 endif
 529 
 530 TESTS_TO_RUN := $(strip $(TESTS_TO_RUN))
 531 
 532 
 533 # Present the result of our parsing to the user
 534 $(info Test selection &#39;$(TEST)&#39;, will run:)
 535 $(foreach test, $(TESTS_TO_RUN), $(info * $(test)))
 536 
 537 
 538 ################################################################################
 539 # Functions for setting up rules for running the selected tests
 540 #
 541 # The SetupRun*Test functions all have the same interface:
 542 #
 543 # Parameter 1 is the name of the rule. This is the test id, based on the test
 544 # descriptor, and this is also used as variable prefix, and the targets
 545 # generated are listed in a variable by that name.
 546 #
 547 # Remaining parameters are named arguments. Currently this is only:
 548 #   TEST -- The properly formatted fully qualified test descriptor
 549 #
 550 # After the rule named by the test id has been executed, the following
 551 # variables will be available:
 552 # testid_TOTAL - the total number of tests run
 553 # testid_PASSED - the number of successful tests
 554 # testid_FAILED - the number of failed tests
 555 # testid_ERROR - the number of tests was neither successful or failed
 556 #
 557 ################################################################################
 558 
 559 ### Rules for Gtest
 560 
 561 SetupRunGtestTest = $(NamedParamsMacroTemplate)
 562 define SetupRunGtestTestBody
 563   $1_TEST_RESULTS_DIR := $$(TEST_RESULTS_DIR)/$1
 564   $1_TEST_SUPPORT_DIR := $$(TEST_SUPPORT_DIR)/$1
 565   $1_EXITCODE := $$($1_TEST_RESULTS_DIR)/exitcode.txt
 566 
 567   $1_VARIANT :=  $$(lastword $$(subst /, , $$($1_TEST)))
 568   ifeq ($$(filter $$($1_VARIANT), $$(GTEST_VARIANTS)), )
 569     $$(error Invalid gtest variant &#39;$$($1_VARIANT)&#39;. Valid variants: $$(GTEST_VARIANTS))
 570   endif
 571   $1_TEST_NAME := $$(strip $$(patsubst %/$$($1_VARIANT), %, \
 572       $$(patsubst gtest:%, %, $$($1_TEST))))
 573   ifneq ($$($1_TEST_NAME), all)
 574     $1_GTEST_FILTER := --gtest_filter=$$($1_TEST_NAME)*
 575   endif
 576 
 577   ifneq ($$(GTEST_REPEAT), )
 578     $1_GTEST_REPEAT :=--gtest_repeat=$$(GTEST_REPEAT)
 579   endif
 580 
 581   ifneq ($$(GTEST_AOT_MODULES), )
 582     $$(eval $$(call SetupAot, $1, \
 583         MODULES := $$(GTEST_AOT_MODULES), \
 584         VM_OPTIONS := $$(GTEST_VM_OPTIONS) $$(GTEST_JAVA_OPTIONS), \
 585     ))
 586   endif
 587 
 588   run-test-$1: pre-run-test $$($1_AOT_TARGETS)
 589 	$$(call LogWarn)
 590 	$$(call LogWarn, Running test &#39;$$($1_TEST)&#39;)
 591 	$$(call MakeDir, $$($1_TEST_RESULTS_DIR) $$($1_TEST_SUPPORT_DIR))
<a name="11" id="anc11"></a><span class="line-modified"> 592 	$$(call ExecuteWithLog, $$($1_TEST_SUPPORT_DIR)/gtest, \</span>
 593 	    $$(FIXPATH) $$(TEST_IMAGE_DIR)/hotspot/gtest/$$($1_VARIANT)/gtestLauncher \
 594 	        -jdk $(JDK_UNDER_TEST) $$($1_GTEST_FILTER) \
 595 	        --gtest_output=xml:$$($1_TEST_RESULTS_DIR)/gtest.xml \
 596 	        $$($1_GTEST_REPEAT) $$(GTEST_OPTIONS) $$(GTEST_VM_OPTIONS) \
 597 	        $$(GTEST_JAVA_OPTIONS) $$($1_AOT_OPTIONS) \
 598 	        &gt; &gt;($(TEE) $$($1_TEST_RESULTS_DIR)/gtest.txt) \
 599 	    &amp;&amp; $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \
 600 	    || $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \
<a name="12" id="anc12"></a><span class="line-modified"> 601 	)</span>
 602 
 603   $1_RESULT_FILE := $$($1_TEST_RESULTS_DIR)/gtest.txt
 604 
 605   parse-test-$1: run-test-$1
 606 	$$(call LogWarn, Finished running test &#39;$$($1_TEST)&#39;)
 607 	$$(call LogWarn, Test report is stored in $$(strip \
 608 	    $$(subst $$(TOPDIR)/, , $$($1_TEST_RESULTS_DIR))))
 609 	$$(if $$(wildcard $$($1_RESULT_FILE)), \
 610 	  $$(eval $1_TOTAL := $$(shell $$(AWK) &#39;/==========.* tests? from .* \
 611 	      test cases? ran/ { print $$$$2 }&#39; $$($1_RESULT_FILE))) \
 612 	  $$(if $$($1_TOTAL), , $$(eval $1_TOTAL := 0)) \
 613 	  $$(eval $1_PASSED := $$(shell $$(AWK) &#39;/\[  PASSED  \] .* tests?./ \
 614 	      { print $$$$4 }&#39; $$($1_RESULT_FILE))) \
 615 	  $$(if $$($1_PASSED), , $$(eval $1_PASSED := 0)) \
 616 	  $$(eval $1_FAILED := $$(shell $$(AWK) &#39;/\[  FAILED  \] .* tests?, \
 617 	      listed below/ { print $$$$4 }&#39; $$($1_RESULT_FILE))) \
 618 	  $$(if $$($1_FAILED), , $$(eval $1_FAILED := 0)) \
 619 	  $$(eval $1_ERROR := $$(shell \
 620 	      $$(EXPR) $$($1_TOTAL) - $$($1_PASSED) - $$($1_FAILED))) \
 621 	, \
 622 	  $$(eval $1_PASSED := 0) \
 623 	  $$(eval $1_FAILED := 0) \
 624 	  $$(eval $1_ERROR := 1) \
 625 	  $$(eval $1_TOTAL := 1) \
 626 	)
 627 
 628   $1: run-test-$1 parse-test-$1
 629 
 630   TARGETS += $1 run-test-$1 parse-test-$1
 631   TEST_TARGETS += parse-test-$1
 632 
 633 endef
 634 
 635 ################################################################################
 636 
 637 ### Rules for Microbenchmarks
 638 
 639 # Helper function for SetupRunMicroTest. Set a MICRO_* variable from, in order:
 640 # 1) Specified by user on command line
 641 # 2) Generic default
 642 #
 643 # Note: No spaces are allowed around the arguments.
 644 # Arg $1 The test ID (i.e. $1 in SetupRunMicroTest)
 645 # Arg $2 Base variable, e.g. MICRO_TEST_JDK
 646 # Arg $3 The default value (optional)
 647 define SetMicroValue
 648   ifneq ($$($2), )
 649     $1_$2 := $$($2)
 650   else
 651     ifneq ($3, )
 652       $1_$2 := $3
 653     endif
 654   endif
 655 endef
 656 
 657 SetupRunMicroTest = $(NamedParamsMacroTemplate)
 658 define SetupRunMicroTestBody
 659   $1_TEST_RESULTS_DIR := $$(TEST_RESULTS_DIR)/$1
 660   $1_TEST_SUPPORT_DIR := $$(TEST_SUPPORT_DIR)/$1
 661   $1_EXITCODE := $$($1_TEST_RESULTS_DIR)/exitcode.txt
 662 
 663   $1_TEST_NAME := $$(strip $$(patsubst micro:%, %, $$($1_TEST)))
 664 
 665   $$(eval $$(call SetMicroValue,$1,MICRO_BENCHMARKS_JAR,$$(TEST_IMAGE_DIR)/micro/benchmarks.jar))
 666   $$(eval $$(call SetMicroValue,$1,MICRO_TEST_JDK,$$(JDK_UNDER_TEST)))
 667   $$(eval $$(call SetMicroValue,$1,MICRO_JAVA_OPTIONS))
 668 
 669   # Current tests needs to open java.io
 670   $1_MICRO_JAVA_OPTIONS += --add-opens=java.base/java.io=ALL-UNNAMED
 671   # Set library path for native dependencies
 672   $1_MICRO_JAVA_OPTIONS += -Djava.library.path=$$(TEST_IMAGE_DIR)/micro/native
 673 
 674   # Save output as JSON or CSV file
 675   ifneq ($$(MICRO_RESULTS_FORMAT), )
 676     $1_MICRO_BASIC_OPTIONS += -rf $$(MICRO_RESULTS_FORMAT)
 677     $1_MICRO_BASIC_OPTIONS += -rff $$($1_TEST_RESULTS_DIR)/jmh-result.$(MICRO_RESULTS_FORMAT)
 678   endif
 679 
 680   ifneq ($$(MICRO_VM_OPTIONS)$$(MICRO_JAVA_OPTIONS), )
<a name="13" id="anc13"></a><span class="line-modified"> 681     $1_MICRO_VM_OPTIONS := -jvmArgs $$(MICRO_VM_OPTIONS) $$(MICRO_JAVA_OPTIONS)</span>

 682   endif
 683 
 684   ifneq ($$(MICRO_ITER), )
 685     $1_MICRO_ITER := -i $$(MICRO_ITER)
 686   endif
 687   ifneq ($$(MICRO_FORK), )
 688     $1_MICRO_FORK := -f $$(MICRO_FORK)
 689   endif
 690   ifneq ($$(MICRO_TIME), )
 691     $1_MICRO_TIME := -r $$(MICRO_TIME)
 692   endif
 693   ifneq ($$(MICRO_WARMUP_ITER), )
 694     $1_MICRO_WARMUP_ITER := -wi $$(MICRO_WARMUP_ITER)
 695   endif
 696   ifneq ($$(MICRO_WARMUP_TIME), )
 697     $1_MICRO_WARMUP_TIME := -w $$(MICRO_WARMUP_TIME)
 698   endif
 699 
 700   run-test-$1: pre-run-test
 701 	$$(call LogWarn)
 702 	$$(call LogWarn, Running test &#39;$$($1_TEST)&#39;)
 703 	$$(call MakeDir, $$($1_TEST_RESULTS_DIR) $$($1_TEST_SUPPORT_DIR))
<a name="14" id="anc14"></a><span class="line-modified"> 704 	$$(call ExecuteWithLog, $$($1_TEST_SUPPORT_DIR)/micro, \</span>
 705 	    $$(FIXPATH) $$($1_MICRO_TEST_JDK)/bin/java $$($1_MICRO_JAVA_OPTIONS) \
 706 	        -jar $$($1_MICRO_BENCHMARKS_JAR) \
 707 	        $$($1_MICRO_ITER) $$($1_MICRO_FORK) $$($1_MICRO_TIME) \
 708 	        $$($1_MICRO_WARMUP_ITER) $$($1_MICRO_WARMUP_TIME) \
 709 	        $$($1_MICRO_VM_OPTIONS) $$($1_MICRO_BASIC_OPTIONS) $$(MICRO_OPTIONS) \
 710 	        $$($1_TEST_NAME) \
 711 	        &gt; &gt;($(TEE) $$($1_TEST_RESULTS_DIR)/micro.txt) \
 712 	    &amp;&amp; $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \
 713 	    || $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \
<a name="15" id="anc15"></a><span class="line-modified"> 714 	)</span>
 715 
 716   $1_RESULT_FILE := $$($1_TEST_RESULTS_DIR)/micro.txt
 717 
 718   parse-test-$1: run-test-$1
 719 	$$(call LogWarn, Finished running test &#39;$$($1_TEST)&#39;)
 720 	$$(call LogWarn, Test report is stored in $$(strip \
 721 	    $$(subst $$(TOPDIR)/, , $$($1_TEST_RESULTS_DIR))))
 722 	$$(if $$(wildcard $$($1_EXITCODE)), \
 723 	  $$(eval $1_EXIT_CODE := $$(shell $$(CAT) $$($1_EXITCODE))) \
 724 	  $$(if $$(filter 0, $$($1_EXIT_CODE)), \
 725 	    $$(eval $1_PASSED := 1) \
 726 	    $$(eval $1_ERROR := 0) \
 727 	  , \
 728 	    $$(eval $1_PASSED := 0) \
 729 	    $$(eval $1_ERROR := 1) \
 730 	  ) \
 731 	  $$(eval $1_FAILED := 0) \
 732 	  $$(eval $1_TOTAL := $$(shell \
 733 	      $$(EXPR) $$($1_PASSED) + $$($1_ERROR))) \
 734 	, \
 735 	  $$(eval $1_PASSED := 0) \
 736 	  $$(eval $1_FAILED := 0) \
 737 	  $$(eval $1_ERROR := 1) \
 738 	  $$(eval $1_TOTAL := 1) \
 739 	)
 740 
 741   $1: run-test-$1 parse-test-$1
 742 
 743   TARGETS += $1 run-test-$1 parse-test-$1
 744   TEST_TARGETS += parse-test-$1
 745 
 746 endef
 747 
 748 ################################################################################
 749 
 750 ### Rules for Jtreg
 751 
 752 # Helper function for SetupRunJtregTest. Set a JTREG_* variable from, in order:
 753 # 1) Specified by user on command line
 754 # 2) Component-specific default
 755 # 3) Generic default
 756 #
 757 # Note: No spaces are allowed around the arguments.
 758 # Arg $1 The test ID (i.e. $1 in SetupRunJtregTest)
 759 # Arg $2 Base variable, e.g. JTREG_JOBS
 760 # Arg $3 The default value (optional)
 761 define SetJtregValue
 762   ifneq ($$($2), )
 763     $1_$2 := $$($2)
 764   else
 765     ifneq ($$($$($1_COMPONENT)_$2), )
 766       $1_$2 := $$($$($1_COMPONENT)_$2)
 767     else
 768       ifneq ($3, )
 769         $1_$2 := $3
 770       endif
 771     endif
 772   endif
 773 endef
 774 
 775 SetupRunJtregTest = $(NamedParamsMacroTemplate)
 776 define SetupRunJtregTestBody
 777   $1_TEST_RESULTS_DIR := $$(TEST_RESULTS_DIR)/$1
 778   $1_TEST_SUPPORT_DIR := $$(TEST_SUPPORT_DIR)/$1
 779   $1_EXITCODE := $$($1_TEST_RESULTS_DIR)/exitcode.txt
 780 
 781   $1_TEST_NAME := $$(strip $$(patsubst jtreg:%, %, $$($1_TEST)))
 782 
 783   $1_TEST_ROOT := \
 784       $$(strip $$(foreach root, $$(JTREG_TESTROOTS), \
 785         $$(if $$(filter $$(root)%, $$(JTREG_TOPDIR)/$$($1_TEST_NAME)), $$(root)) \
 786       ))
 787   $1_COMPONENT := $$(lastword $$(subst /, $$(SPACE), $$($1_TEST_ROOT)))
 788   # This will work only as long as just hotspot has the additional &quot;jtreg&quot; directory
 789   ifeq ($$($1_COMPONENT), jtreg)
 790     $1_COMPONENT := hotspot
 791   endif
 792 
 793   ifeq ($$(JT_HOME), )
 794     $$(info Error: jtreg framework is not found.)
 795     $$(info Please run configure using --with-jtreg.)
 796     $$(error Cannot continue)
 797   endif
 798 
 799   # Unfortunately, we need different defaults for some JTREG values,
 800   # depending on what component we&#39;re running.
 801 
 802   # Convert JTREG_foo into $1_JTREG_foo with a suitable value.
 803   $$(eval $$(call SetJtregValue,$1,JTREG_TEST_MODE,agentvm))
 804   $$(eval $$(call SetJtregValue,$1,JTREG_ASSERT,true))
 805   $$(eval $$(call SetJtregValue,$1,JTREG_MAX_MEM,512m))
 806   $$(eval $$(call SetJtregValue,$1,JTREG_NATIVEPATH))
 807   $$(eval $$(call SetJtregValue,$1,JTREG_BASIC_OPTIONS))
 808   $$(eval $$(call SetJtregValue,$1,JTREG_PROBLEM_LIST))
 809 
 810   # Only the problem list for the current test root should be used.
 811   $1_JTREG_PROBLEM_LIST := $$(filter $$($1_TEST_ROOT)%, $$($1_JTREG_PROBLEM_LIST))
 812 
 813   ifneq ($(TEST_JOBS), 0)
 814     $$(eval $$(call SetJtregValue,$1,JTREG_JOBS,$$(TEST_JOBS)))
 815   else
 816     $$(eval $$(call SetJtregValue,$1,JTREG_JOBS,$$(JOBS)))
 817   endif
 818 
 819   # Make sure MaxRAMPercentage is high enough to not cause OOM or swapping since
 820   # we may end up with a lot of JVM&#39;s
 821   $1_JTREG_MAX_RAM_PERCENTAGE := $$(shell $$(EXPR) 25 / $$($1_JTREG_JOBS))
 822 
 823   # SPARC is in general slower per core so need to scale up timeouts a bit.
 824   ifeq ($(call isTargetCpuArch, sparc), true)
 825     JTREG_TIMEOUT_FACTOR ?= 8
 826   else
 827     JTREG_TIMEOUT_FACTOR ?= 4
 828   endif
 829   JTREG_VERBOSE ?= fail,error,summary
 830   JTREG_RETAIN ?= fail,error
<a name="16" id="anc16"></a>

 831 
 832   ifneq ($$($1_JTREG_MAX_MEM), 0)
 833     $1_JTREG_BASIC_OPTIONS += -vmoption:-Xmx$$($1_JTREG_MAX_MEM)
 834     $1_JTREG_LAUNCHER_OPTIONS += -Xmx$$($1_JTREG_MAX_MEM)
 835   endif
 836 
 837   $1_JTREG_BASIC_OPTIONS += -$$($1_JTREG_TEST_MODE) \
 838       -verbose:$$(JTREG_VERBOSE) -retain:$$(JTREG_RETAIN) \
 839       -concurrency:$$($1_JTREG_JOBS) -timeoutFactor:$$(JTREG_TIMEOUT_FACTOR) \
 840       -vmoption:-XX:MaxRAMPercentage=$$($1_JTREG_MAX_RAM_PERCENTAGE)
 841 
 842   $1_JTREG_BASIC_OPTIONS += -automatic -ignore:quiet
 843 
 844   # Make it possible to specify the JIB_DATA_DIR for tests using the
 845   # JIB Artifact resolver
 846   $1_JTREG_BASIC_OPTIONS += -e:JIB_DATA_DIR
 847   # Some tests needs to find a boot JDK using the JDK8_HOME variable.
 848   $1_JTREG_BASIC_OPTIONS += -e:JDK8_HOME=$$(BOOT_JDK)
 849   # If running on Windows, propagate the _NT_SYMBOL_PATH to enable
 850   # symbol lookup in hserr files
 851   ifeq ($$(call isTargetOs, windows), true)
 852     $1_JTREG_BASIC_OPTIONS += -e:_NT_SYMBOL_PATH
 853   endif
 854 
 855   $1_JTREG_BASIC_OPTIONS += \
 856       $$(addprefix -javaoption:, $$(JTREG_JAVA_OPTIONS)) \
 857       $$(addprefix -vmoption:, $$(JTREG_VM_OPTIONS)) \
 858       #
 859 
 860   ifeq ($$($1_JTREG_ASSERT), true)
 861     $1_JTREG_BASIC_OPTIONS += -ea -esa
 862   endif
 863 
 864   ifneq ($$($1_JTREG_NATIVEPATH), )
 865     $1_JTREG_BASIC_OPTIONS += -nativepath:$$($1_JTREG_NATIVEPATH)
 866   endif
 867 
<a name="17" id="anc17"></a>





 868   ifneq ($$($1_JTREG_PROBLEM_LIST), )
<a name="18" id="anc18"></a><span class="line-modified"> 869     $1_JTREG_BASIC_OPTIONS += $$(addprefix -exclude:, $$($1_JTREG_PROBLEM_LIST))</span>
 870   endif
 871 
 872   ifneq ($$(JTREG_EXTRA_PROBLEM_LISTS), )
 873     # Accept both absolute paths as well as relative to the current test root.
<a name="19" id="anc19"></a><span class="line-modified"> 874     $1_JTREG_BASIC_OPTIONS += $$(addprefix -exclude:, $$(wildcard \</span>
 875         $$(JTREG_EXTRA_PROBLEM_LISTS) \
 876         $$(addprefix $$($1_TEST_ROOT)/, $$(JTREG_EXTRA_PROBLEM_LISTS)) \
 877     ))
 878   endif
 879 
 880   ifneq ($$(JIB_HOME), )
 881     $1_JTREG_BASIC_OPTIONS += -e:JIB_HOME=$$(JIB_HOME)
 882   endif
 883 
<a name="20" id="anc20"></a><span class="line-modified"> 884   $1_JTREG_BASIC_OPTIONS += -e:TEST_IMAGE_GRAAL_DIR=${TEST_IMAGE_DIR}/hotspot/jtreg/graal</span>

 885 
 886   ifneq ($$(JTREG_FAILURE_HANDLER_OPTIONS), )
 887     $1_JTREG_LAUNCHER_OPTIONS += -Djava.library.path=&quot;$(JTREG_FAILURE_HANDLER_DIR)&quot;
 888   endif
 889 
 890   ifneq ($$(JTREG_KEYWORDS), )
 891     # The keywords string may contain problematic characters and may be quoted
 892     # already when it arrives here. Remove any existing quotes and replace them
 893     # with one set of single quotes.
 894     $1_JTREG_KEYWORDS := \
 895         $$(strip $$(subst $$(SQUOTE),,$$(subst $$(DQUOTE),,$$(JTREG_KEYWORDS))))
 896     ifneq ($$($1_JTREG_KEYWORDS), )
 897       $1_JTREG_BASIC_OPTIONS += -k:&#39;$$($1_JTREG_KEYWORDS)&#39;
 898     endif
 899   endif
 900 
 901   ifneq ($$(JTREG_AOT_MODULES), )
 902     $$(eval $$(call SetupAot, $1, \
 903         MODULES := $$(JTREG_AOT_MODULES), \
 904         VM_OPTIONS := $$(JTREG_VM_OPTIONS) $$(JTREG_JAVA_OPTIONS), \
 905     ))
 906   endif
 907 
 908   ifneq ($$($1_AOT_OPTIONS), )
 909     $1_JTREG_BASIC_OPTIONS += -vmoptions:&quot;$$($1_AOT_OPTIONS)&quot;
 910   endif
 911 
 912   clean-workdir-$1:
 913 	$$(RM) -r $$($1_TEST_SUPPORT_DIR)
 914 
<a name="21" id="anc21"></a>






























 915   run-test-$1: pre-run-test clean-workdir-$1 $$($1_AOT_TARGETS)
 916 	$$(call LogWarn)
 917 	$$(call LogWarn, Running test &#39;$$($1_TEST)&#39;)
 918 	$$(call MakeDir, $$($1_TEST_RESULTS_DIR) $$($1_TEST_SUPPORT_DIR))
<a name="22" id="anc22"></a><span class="line-modified"> 919 	$$(call ExecuteWithLog, $$($1_TEST_SUPPORT_DIR)/jtreg, \</span>
<span class="line-modified"> 920 	    $$(COV_ENVIRONMENT) \</span>
<span class="line-modified"> 921 	    $$(JAVA) $$($1_JTREG_LAUNCHER_OPTIONS) \</span>
<span class="line-removed"> 922 	        -Dprogram=jtreg -jar $$(JT_HOME)/lib/jtreg.jar \</span>
<span class="line-removed"> 923 	        $$($1_JTREG_BASIC_OPTIONS) \</span>
<span class="line-removed"> 924 	        -testjdk:$$(JDK_UNDER_TEST) \</span>
<span class="line-removed"> 925 	        -dir:$$(JTREG_TOPDIR) \</span>
<span class="line-removed"> 926 	        -reportDir:$$($1_TEST_RESULTS_DIR) \</span>
<span class="line-removed"> 927 	        -workDir:$$($1_TEST_SUPPORT_DIR) \</span>
<span class="line-removed"> 928 	        $$(JTREG_OPTIONS) \</span>
<span class="line-removed"> 929 	        $$(JTREG_FAILURE_HANDLER_OPTIONS) \</span>
<span class="line-removed"> 930 	        $$(JTREG_COV_OPTIONS) \</span>
<span class="line-removed"> 931 	        $$($1_TEST_NAME) \</span>
<span class="line-removed"> 932 	    &amp;&amp; $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \</span>
<span class="line-removed"> 933 	    || $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \</span>
<span class="line-removed"> 934 	)</span>
 935 
 936   $1_RESULT_FILE := $$($1_TEST_RESULTS_DIR)/text/stats.txt
 937 
 938   parse-test-$1: run-test-$1
 939 	$$(call LogWarn, Finished running test &#39;$$($1_TEST)&#39;)
 940 	$$(call LogWarn, Test report is stored in $$(strip \
 941 	    $$(subst $$(TOPDIR)/, , $$($1_TEST_RESULTS_DIR))))
 942 	$$(if $$(wildcard $$($1_RESULT_FILE)), \
 943 	  $$(eval $1_PASSED := $$(shell $$(AWK) &#39;{ gsub(/[,;]/, &quot;&quot;); \
 944 	      for (i=1; i&lt;=NF; i++) { if ($$$$i == &quot;passed:&quot;) \
 945 	      print $$$$(i+1) } }&#39; $$($1_RESULT_FILE))) \
 946 	  $$(if $$($1_PASSED), , $$(eval $1_PASSED := 0)) \
 947 	  $$(eval $1_FAILED := $$(shell $$(AWK) &#39;{gsub(/[,;]/, &quot;&quot;); \
 948 	      for (i=1; i&lt;=NF; i++) { if ($$$$i == &quot;failed:&quot;) \
 949 	      print $$$$(i+1) } }&#39; $$($1_RESULT_FILE))) \
 950 	  $$(if $$($1_FAILED), , $$(eval $1_FAILED := 0)) \
 951 	  $$(eval $1_ERROR := $$(shell $$(AWK) &#39;{gsub(/[,;]/, &quot;&quot;); \
 952 	      for (i=1; i&lt;=NF; i++) { if ($$$$i == &quot;error:&quot;) \
 953 	      print $$$$(i+1) } }&#39; $$($1_RESULT_FILE))) \
 954 	  $$(if $$($1_ERROR), , $$(eval $1_ERROR := 0)) \
 955 	  $$(eval $1_TOTAL := $$(shell \
 956 	      $$(EXPR) $$($1_PASSED) + $$($1_FAILED) + $$($1_ERROR))) \
 957 	, \
 958 	  $$(eval $1_PASSED := 0) \
 959 	  $$(eval $1_FAILED := 0) \
 960 	  $$(eval $1_ERROR := 1) \
 961 	  $$(eval $1_TOTAL := 1) \
 962 	)
 963 
 964   $1: run-test-$1 parse-test-$1 clean-workdir-$1
 965 
 966   TARGETS += $1 run-test-$1 parse-test-$1 clean-workdir-$1
 967   TEST_TARGETS += parse-test-$1
 968 
 969 endef
 970 
 971 ################################################################################
 972 
 973 ### Rules for special tests
 974 
 975 SetupRunSpecialTest = $(NamedParamsMacroTemplate)
 976 define SetupRunSpecialTestBody
 977   $1_TEST_RESULTS_DIR := $$(TEST_RESULTS_DIR)/$1
 978   $1_TEST_SUPPORT_DIR := $$(TEST_SUPPORT_DIR)/$1
 979   $1_EXITCODE := $$($1_TEST_RESULTS_DIR)/exitcode.txt
 980 
 981   $1_FULL_TEST_NAME := $$(strip $$(patsubst special:%, %, $$($1_TEST)))
 982   ifneq ($$(findstring :, $$($1_FULL_TEST_NAME)), )
 983     $1_TEST_NAME := $$(firstword $$(subst :, ,$$($1_FULL_TEST_NAME)))
 984     $1_TEST_ARGS := $$(strip $$(patsubst special:$$($1_TEST_NAME):%, %, $$($1_TEST)))
 985   else
 986     $1_TEST_NAME := $$($1_FULL_TEST_NAME)
 987     $1_TEST_ARGS :=
 988   endif
 989 
 990   ifeq ($$($1_TEST_NAME), failure-handler)
 991     ifeq ($(BUILD_FAILURE_HANDLER), true)
 992       $1_TEST_COMMAND_LINE := \
 993           ($(CD) $(TOPDIR)/make/test &amp;&amp; $(MAKE) $(MAKE_ARGS) -f \
 994           BuildFailureHandler.gmk test)
 995     else
 996       $$(error Cannot test failure handler if it is not built)
 997     endif
 998   else ifeq ($$($1_TEST_NAME), make)
 999     $1_TEST_COMMAND_LINE := \
1000         ($(CD) $(TOPDIR)/test/make &amp;&amp; $(MAKE) $(MAKE_ARGS) -f \
1001         TestMake.gmk $$($1_TEST_ARGS))
1002   else
1003     $$(error Invalid special test specification: $$($1_TEST_NAME))
1004   endif
1005 
1006   run-test-$1: pre-run-test
1007 	$$(call LogWarn)
1008 	$$(call LogWarn, Running test &#39;$$($1_TEST)&#39;)
1009 	$$(call MakeDir, $$($1_TEST_RESULTS_DIR) $$($1_TEST_SUPPORT_DIR))
<a name="23" id="anc23"></a><span class="line-modified">1010 	$$(call ExecuteWithLog, $$($1_TEST_SUPPORT_DIR)/test-execution, \</span>
1011 	    $$($1_TEST_COMMAND_LINE) \
1012 	        &gt; &gt;($(TEE) $$($1_TEST_RESULTS_DIR)/test-output.txt) \
1013 	    &amp;&amp; $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \
1014 	    || $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \
<a name="24" id="anc24"></a><span class="line-modified">1015 	)</span>
1016 
1017   $1_RESULT_FILE := $$($1_TEST_RESULTS_DIR)/gtest.txt
1018 
1019   # We can not parse the various &quot;special&quot; tests.
1020   parse-test-$1: run-test-$1
1021 	$$(call LogWarn, Finished running test &#39;$$($1_TEST)&#39;)
1022 	$$(call LogWarn, Test report is stored in $$(strip \
1023 	    $$(subst $$(TOPDIR)/, , $$($1_TEST_RESULTS_DIR))))
1024 	$$(call LogWarn, Warning: Special test results are not properly parsed!)
<a name="25" id="anc25"></a><span class="line-modified">1025 	$$(eval $1_PASSED := 0)</span>
<span class="line-modified">1026 	$$(eval $1_FAILED := 0)</span>




1027 	$$(eval $1_ERROR := 0)
<a name="26" id="anc26"></a><span class="line-modified">1028 	$$(eval $1_TOTAL := 0)</span>
1029 
1030   $1: run-test-$1 parse-test-$1
1031 
1032   TARGETS += $1 run-test-$1 parse-test-$1
1033   TEST_TARGETS += parse-test-$1
1034 
1035 endef
1036 
1037 ################################################################################
1038 # Setup and execute make rules for all selected tests
1039 ################################################################################
1040 
1041 # Helper function to determine which handler to use for the given test
1042 UseGtestTestHandler = \
1043   $(if $(filter gtest:%, $1), true)
1044 
1045 UseMicroTestHandler = \
1046   $(if $(filter micro:%, $1), true)
1047 
1048 UseJtregTestHandler = \
1049   $(if $(filter jtreg:%, $1), true)
1050 
1051 UseSpecialTestHandler = \
1052   $(if $(filter special:%, $1), true)
1053 
1054 # Now process each test to run and setup a proper make rule
1055 $(foreach test, $(TESTS_TO_RUN), \
1056   $(eval TEST_ID := $(shell $(ECHO) $(strip $(test)) | \
1057       $(TR) -cs &#39;[a-z][A-Z][0-9]\n&#39; &#39;[_*1000]&#39;)) \
1058   $(eval ALL_TEST_IDS += $(TEST_ID)) \
1059   $(if $(call UseCustomTestHandler, $(test)), \
1060     $(eval $(call SetupRunCustomTest, $(TEST_ID), \
1061         TEST := $(test), \
1062     )) \
1063   ) \
1064   $(if $(call UseGtestTestHandler, $(test)), \
1065     $(eval $(call SetupRunGtestTest, $(TEST_ID), \
1066         TEST := $(test), \
1067     )) \
1068   ) \
1069   $(if $(call UseMicroTestHandler, $(test)), \
1070     $(eval $(call SetupRunMicroTest, $(TEST_ID), \
1071         TEST := $(test), \
1072     )) \
1073   ) \
1074   $(if $(call UseJtregTestHandler, $(test)), \
1075     $(eval $(call SetupRunJtregTest, $(TEST_ID), \
1076         TEST := $(test), \
1077     )) \
1078   ) \
1079   $(if $(call UseSpecialTestHandler, $(test)), \
1080     $(eval $(call SetupRunSpecialTest, $(TEST_ID), \
1081         TEST := $(test), \
1082     )) \
1083   ) \
1084 )
1085 
1086 # Sort also removes duplicates, so if there is any we&#39;ll get fewer words.
1087 ifneq ($(words $(ALL_TEST_IDS)), $(words $(sort $(ALL_TEST_IDS))))
1088   $(error Duplicate test specification)
1089 endif
1090 
1091 
1092 ################################################################################
1093 # The main target for RunTests.gmk
1094 ################################################################################
1095 
1096 #
1097 # Provide hooks for adding functionality before and after all tests are run.
1098 #
1099 
1100 $(call LogInfo, RunTest setup starting)
1101 
1102 # This target depends on all actual test having been run (TEST_TARGETS has beeen
1103 # populated by the SetupRun*Test functions). If you need to provide a teardown
1104 # hook, you must let it depend on this target.
1105 run-all-tests: $(TEST_TARGETS)
1106 	$(call LogInfo, RunTest teardown starting)
1107 
1108 # This is an abstract target that will be run before any actual tests. Add your
1109 # target as a dependency to thisif you need &quot;setup&quot; type functionality executed
1110 # before all tests.
1111 pre-run-test:
1112 	$(call LogInfo, RunTest setup done)
1113 
1114 # This is an abstract target that will be run after all actual tests, but before
1115 # the test summary. If you need &quot;teardown&quot; type functionality, add your target
1116 # as a dependency on this, and let the teardown target depend on run-all-tests.
1117 post-run-test: run-all-tests
1118 	$(call LogInfo, RunTest teardown done)
1119 
1120 #
1121 # Create and print a table of the result of all tests run
1122 #
1123 TEST_FAILURE := false
1124 
1125 run-test-report: post-run-test
1126 	$(RM) $(TEST_SUMMARY).old 2&gt; /dev/null
1127 	$(MV) $(TEST_SUMMARY) $(TEST_SUMMARY).old 2&gt; /dev/null || true
1128 	$(RM) $(TEST_LAST_IDS).old 2&gt; /dev/null
1129 	$(MV) $(TEST_LAST_IDS) $(TEST_LAST_IDS).old 2&gt; /dev/null || true
1130 	$(ECHO) &gt;&gt; $(TEST_SUMMARY) ==============================
1131 	$(ECHO) &gt;&gt; $(TEST_SUMMARY) Test summary
1132 	$(ECHO) &gt;&gt; $(TEST_SUMMARY) ==============================
1133 	$(PRINTF) &gt;&gt; $(TEST_SUMMARY) &quot;%2s %-49s %5s %5s %5s %5s %2s\n&quot; &quot;  &quot; \
1134 	    TEST TOTAL PASS FAIL ERROR &quot; &quot;
1135 	$(foreach test, $(TESTS_TO_RUN), \
1136 	  $(eval TEST_ID := $(shell $(ECHO) $(strip $(test)) | \
1137 	      $(TR) -cs &#39;[a-z][A-Z][0-9]\n&#39; &#39;[_*1000]&#39;)) \
1138 	    $(ECHO) &gt;&gt; $(TEST_LAST_IDS) $(TEST_ID) $(NEWLINE) \
1139 	  $(eval NAME_PATTERN := $(shell $(ECHO) $(test) | $(TR) -c &#39;\n&#39; &#39;[_*1000]&#39;)) \
1140 	  $(if $(filter __________________________________________________%, $(NAME_PATTERN)), \
1141 	    $(eval TEST_NAME := ) \
1142 	    $(PRINTF) &gt;&gt; $(TEST_SUMMARY) &quot;%2s %-49s\n&quot; &quot;  &quot; &quot;$(test)&quot;  $(NEWLINE) \
1143 	  , \
1144 	    $(eval TEST_NAME := $(test)) \
1145 	  ) \
1146 	  $(if $(filter $($(TEST_ID)_PASSED), $($(TEST_ID)_TOTAL)), \
1147 	    $(PRINTF) &gt;&gt; $(TEST_SUMMARY) &quot;%2s %-49s %5d %5d %5d %5d %2s\n&quot; \
1148 	        &quot;  &quot; &quot;$(TEST_NAME)&quot; $($(TEST_ID)_TOTAL) $($(TEST_ID)_PASSED) \
1149 	        $($(TEST_ID)_FAILED) $($(TEST_ID)_ERROR) &quot;  &quot; $(NEWLINE) \
1150 	  , \
1151 	    $(PRINTF) &gt;&gt; $(TEST_SUMMARY) &quot;%2s %-49s %5d %5d %5d %5d %2s\n&quot; \
1152 	         &quot;&gt;&gt;&quot; &quot;$(TEST_NAME)&quot; $($(TEST_ID)_TOTAL) $($(TEST_ID)_PASSED) \
1153 	        $($(TEST_ID)_FAILED) $($(TEST_ID)_ERROR) &quot;&lt;&lt;&quot; $(NEWLINE) \
1154 	    $(eval TEST_FAILURE := true) \
1155 	  ) \
1156 	)
1157 	$(ECHO) &gt;&gt; $(TEST_SUMMARY) ==============================
1158 	$(if $(filter true, $(TEST_FAILURE)), \
1159 	  $(ECHO) &gt;&gt; $(TEST_SUMMARY) TEST FAILURE $(NEWLINE) \
1160 	  $(MKDIR) -p $(MAKESUPPORT_OUTPUTDIR) $(NEWLINE) \
1161 	  $(TOUCH) $(MAKESUPPORT_OUTPUTDIR)/exit-with-error \
1162 	, \
1163 	  $(ECHO) &gt;&gt; $(TEST_SUMMARY) TEST SUCCESS \
1164 	)
1165 	$(ECHO)
1166 	$(CAT) $(TEST_SUMMARY)
1167 	$(ECHO)
1168 
1169 # The main run-test target
1170 run-test: run-test-report
1171 
1172 TARGETS += run-all-tests pre-run-test post-run-test run-test-report run-test
1173 
1174 ################################################################################
1175 # Setup JCov
1176 ################################################################################
1177 
1178 ifeq ($(TEST_OPTS_JCOV), true)
1179 
1180   jcov-do-start-grabber:
1181 	$(call MakeDir, $(JCOV_OUTPUT_DIR))
1182 	if $(JAVA) -jar $(JCOV_HOME)/lib/jcov.jar GrabberManager -status 1&gt;/dev/null 2&gt;&amp;1 ; then \
1183 	  $(JAVA) -jar $(JCOV_HOME)/lib/jcov.jar GrabberManager -stop -stoptimeout 3600 ; \
1184 	fi
1185 	$(JAVA) -Xmx4g -jar $(JCOV_HOME)/lib/jcov.jar Grabber -v -t \
1186 	    $(JCOV_IMAGE_DIR)/template.xml -o $(JCOV_RESULT_FILE) \
1187 	    1&gt;$(JCOV_GRABBER_LOG) 2&gt;&amp;1 &amp;
1188 
1189   jcov-start-grabber: jcov-do-start-grabber
1190 	$(call LogWarn, Starting JCov Grabber...)
1191 	$(JAVA) -jar $(JCOV_HOME)/lib/jcov.jar GrabberManager -t 600 -wait
1192 
1193   jcov-stop-grabber:
1194 	$(call LogWarn, Stopping JCov Grabber...)
1195 	$(JAVA) -jar $(JCOV_HOME)/lib/jcov.jar GrabberManager -stop -stoptimeout 3600
1196 
<a name="27" id="anc27"></a>





1197   jcov-gen-report: jcov-stop-grabber
1198 	$(call LogWarn, Generating JCov report ...)
1199 	$(JAVA) -Xmx4g -jar $(JCOV_HOME)/lib/jcov.jar RepGen -sourcepath \
1200 	    `$(ECHO) $(TOPDIR)/src/*/share/classes/ | $(TR) &#39; &#39; &#39;:&#39;` -fmt html \
<a name="28" id="anc28"></a>

1201 	    -o $(JCOV_REPORT) $(JCOV_RESULT_FILE)
1202 
1203   TARGETS += jcov-do-start-grabber jcov-start-grabber jcov-stop-grabber \
1204       jcov-gen-report
1205 
1206   # Hook this into the framework at appropriate places
1207   pre-run-test: jcov-start-grabber
1208 
1209   post-run-test: jcov-gen-report
1210 
1211   jcov-gen-report: run-all-tests
1212 
1213 endif
1214 
1215 ################################################################################
1216 
1217 all: run-test
1218 
1219 .PHONY: default all $(TARGETS)
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
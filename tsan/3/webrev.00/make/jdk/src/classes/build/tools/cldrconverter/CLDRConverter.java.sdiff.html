<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/jdk/src/classes/build/tools/cldrconverter/CLDRConverter.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Bundle.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="LDMLParseHandler.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/jdk/src/classes/build/tools/cldrconverter/CLDRConverter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package build.tools.cldrconverter;
  27 
<span class="line-removed">  28 import static build.tools.cldrconverter.Bundle.jreTimeZoneNames;</span>
  29 import build.tools.cldrconverter.BundleGenerator.BundleType;
  30 import java.io.File;
  31 import java.io.IOException;
  32 import java.io.UncheckedIOException;
  33 import java.nio.file.*;
  34 import java.text.MessageFormat;
  35 import java.time.*;
  36 import java.util.*;
  37 import java.util.ResourceBundle.Control;
  38 import java.util.logging.Level;
  39 import java.util.logging.Logger;
  40 import java.util.stream.Collectors;
  41 import java.util.stream.IntStream;
  42 import java.util.stream.Stream;
  43 import javax.xml.parsers.SAXParser;
  44 import javax.xml.parsers.SAXParserFactory;
  45 import org.xml.sax.SAXNotRecognizedException;
  46 import org.xml.sax.SAXNotSupportedException;
  47 
  48 
</pre>
<hr />
<pre>
  53  */
  54 public class CLDRConverter {
  55 
  56     static final String LDML_DTD_SYSTEM_ID = &quot;http://www.unicode.org/cldr/dtd/2.0/ldml.dtd&quot;;
  57     static final String SPPL_LDML_DTD_SYSTEM_ID = &quot;http://www.unicode.org/cldr/dtd/2.0/ldmlSupplemental.dtd&quot;;
  58     static final String BCP47_LDML_DTD_SYSTEM_ID = &quot;http://www.unicode.org/cldr/dtd/2.0/ldmlBCP47.dtd&quot;;
  59 
  60 
  61     private static String CLDR_BASE;
  62     static String LOCAL_LDML_DTD;
  63     static String LOCAL_SPPL_LDML_DTD;
  64     static String LOCAL_BCP47_LDML_DTD;
  65     private static String SOURCE_FILE_DIR;
  66     private static String SPPL_SOURCE_FILE;
  67     private static String SPPL_META_SOURCE_FILE;
  68     private static String NUMBERING_SOURCE_FILE;
  69     private static String METAZONES_SOURCE_FILE;
  70     private static String LIKELYSUBTAGS_SOURCE_FILE;
  71     private static String TIMEZONE_SOURCE_FILE;
  72     private static String WINZONES_SOURCE_FILE;

  73     static String DESTINATION_DIR = &quot;build/gensrc&quot;;
  74 
  75     static final String LOCALE_NAME_PREFIX = &quot;locale.displayname.&quot;;
  76     static final String LOCALE_SEPARATOR = LOCALE_NAME_PREFIX + &quot;separator&quot;;
  77     static final String LOCALE_KEYTYPE = LOCALE_NAME_PREFIX + &quot;keytype&quot;;
  78     static final String LOCALE_KEY_PREFIX = LOCALE_NAME_PREFIX + &quot;key.&quot;;
  79     static final String LOCALE_TYPE_PREFIX = LOCALE_NAME_PREFIX + &quot;type.&quot;;
  80     static final String LOCALE_TYPE_PREFIX_CA = LOCALE_TYPE_PREFIX + &quot;ca.&quot;;
  81     static final String CURRENCY_SYMBOL_PREFIX = &quot;currency.symbol.&quot;;
  82     static final String CURRENCY_NAME_PREFIX = &quot;currency.displayname.&quot;;
  83     static final String CALENDAR_NAME_PREFIX = &quot;calendarname.&quot;;
  84     static final String CALENDAR_FIRSTDAY_PREFIX = &quot;firstDay.&quot;;
  85     static final String CALENDAR_MINDAYS_PREFIX = &quot;minDays.&quot;;
  86     static final String TIMEZONE_ID_PREFIX = &quot;timezone.id.&quot;;
  87     static final String EXEMPLAR_CITY_PREFIX = &quot;timezone.excity.&quot;;
  88     static final String ZONE_NAME_PREFIX = &quot;timezone.displayname.&quot;;
  89     static final String METAZONE_ID_PREFIX = &quot;metazone.id.&quot;;
  90     static final String PARENT_LOCALE_PREFIX = &quot;parentLocale.&quot;;

  91     static final String[] EMPTY_ZONE = {&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;};

  92 
  93     private static SupplementDataParseHandler handlerSuppl;
  94     private static LikelySubtagsParseHandler handlerLikelySubtags;
  95     private static WinZonesParseHandler handlerWinZones;

  96     static SupplementalMetadataParseHandler handlerSupplMeta;
  97     static NumberingSystemsParseHandler handlerNumbering;
  98     static MetaZonesParseHandler handlerMetaZones;
  99     static TimeZoneParseHandler handlerTimeZone;
 100     private static BundleGenerator bundleGenerator;
 101 
 102     // java.base module related
 103     static boolean isBaseModule = false;
 104     static final Set&lt;Locale&gt; BASE_LOCALES = new HashSet&lt;&gt;();
 105 
 106     // &quot;parentLocales&quot; map
 107     private static final Map&lt;String, SortedSet&lt;String&gt;&gt; parentLocalesMap = new HashMap&lt;&gt;();
 108     private static final ResourceBundle.Control defCon =
 109         ResourceBundle.Control.getControl(ResourceBundle.Control.FORMAT_DEFAULT);
 110 
<span class="line-modified"> 111     private static final String[] AVAILABLE_TZIDS = TimeZone.getAvailableIDs();</span>
 112     private static String zoneNameTempFile;
 113     private static String tzDataDir;
 114     private static final Map&lt;String, String&gt; canonicalTZMap = new HashMap&lt;&gt;();
 115 
 116     static enum DraftType {
 117         UNCONFIRMED,
 118         PROVISIONAL,
 119         CONTRIBUTED,
 120         APPROVED;
 121 
 122         private static final Map&lt;String, DraftType&gt; map = new HashMap&lt;&gt;();
 123         static {
 124             for (DraftType dt : values()) {
 125                 map.put(dt.getKeyword(), dt);
 126             }
 127         }
 128         static private DraftType defaultType = CONTRIBUTED;
 129 
 130         private final String keyword;
 131 
</pre>
<hr />
<pre>
 227                 }
 228             } catch (RuntimeException e) {
 229                 severe(&quot;unknown or imcomplete arg(s): &quot; + currentArg);
 230                 usage();
 231                 System.exit(1);
 232             }
 233         }
 234 
 235         // Set up path names
 236         LOCAL_LDML_DTD = CLDR_BASE + &quot;/dtd/ldml.dtd&quot;;
 237         LOCAL_SPPL_LDML_DTD = CLDR_BASE + &quot;/dtd/ldmlSupplemental.dtd&quot;;
 238         LOCAL_BCP47_LDML_DTD = CLDR_BASE + &quot;/dtd/ldmlBCP47.dtd&quot;;
 239         SOURCE_FILE_DIR = CLDR_BASE + &quot;/main&quot;;
 240         SPPL_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/supplementalData.xml&quot;;
 241         LIKELYSUBTAGS_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/likelySubtags.xml&quot;;
 242         NUMBERING_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/numberingSystems.xml&quot;;
 243         METAZONES_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/metaZones.xml&quot;;
 244         TIMEZONE_SOURCE_FILE = CLDR_BASE + &quot;/bcp47/timezone.xml&quot;;
 245         SPPL_META_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/supplementalMetadata.xml&quot;;
 246         WINZONES_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/windowsZones.xml&quot;;

 247 
 248         if (BASE_LOCALES.isEmpty()) {
 249             setupBaseLocales(&quot;en-US&quot;);
 250         }
 251 
 252         bundleGenerator = new ResourceBundleGenerator();
 253 
 254         // Parse data independent of locales
 255         parseSupplemental();
 256         parseBCP47();
 257 
 258         List&lt;Bundle&gt; bundles = readBundleList();
 259         convertBundles(bundles);
 260 
 261         if (isBaseModule) {
 262             // Generate java.time.format.ZoneName.java
 263             generateZoneName();
 264 
 265             // Generate Windows tzmappings
 266             generateWindowsTZMappings();



 267         }
 268     }
 269 
 270     private static void usage() {
 271         errout(&quot;Usage: java CLDRConverter [options]%n&quot;
 272                 + &quot;\t-help          output this usage message and exit%n&quot;
 273                 + &quot;\t-verbose       output information%n&quot;
 274                 + &quot;\t-draft [contributed | approved | provisional | unconfirmed]%n&quot;
 275                 + &quot;\t\t       draft level for using data (default: contributed)%n&quot;
 276                 + &quot;\t-base dir      base directory for CLDR input files%n&quot;
 277                 + &quot;\t-basemodule    generates bundles that go into java.base module%n&quot;
 278                 + &quot;\t-baselocales loc(,loc)*      locales that go into the base module%n&quot;
 279                 + &quot;\t-o dir         output directory (default: ./build/gensrc)%n&quot;
 280                 + &quot;\t-zntempfile    template file for java.time.format.ZoneName.java%n&quot;
 281                 + &quot;\t-tzdatadir     tzdata directory for java.time.format.ZoneName.java%n&quot;
 282                 + &quot;\t-utf8          use UTF-8 rather than \\uxxxx (for debug)%n&quot;);
 283     }
 284 
 285     static void info(String fmt, Object... args) {
 286         if (verbose) {
</pre>
<hr />
<pre>
 329         try {
 330             parser.setProperty(&quot;http://javax.xml.XMLConstants/property/accessExternalDTD&quot;, &quot;file&quot;);
 331         } catch (SAXNotRecognizedException ignore) {
 332             // property requires &gt;= JAXP 1.5
 333         }
 334     }
 335 
 336     private static List&lt;Bundle&gt; readBundleList() throws Exception {
 337         List&lt;Bundle&gt; retList = new ArrayList&lt;&gt;();
 338         Path path = FileSystems.getDefault().getPath(SOURCE_FILE_DIR);
 339         try (DirectoryStream&lt;Path&gt; dirStr = Files.newDirectoryStream(path)) {
 340             for (Path entry : dirStr) {
 341                 String fileName = entry.getFileName().toString();
 342                 if (fileName.endsWith(&quot;.xml&quot;)) {
 343                     String id = fileName.substring(0, fileName.indexOf(&#39;.&#39;));
 344                     Locale cldrLoc = Locale.forLanguageTag(toLanguageTag(id));
 345                     StringBuilder sb = getCandLocales(cldrLoc);
 346                     if (sb.indexOf(&quot;root&quot;) == -1) {
 347                         sb.append(&quot;root&quot;);
 348                     }
<span class="line-modified"> 349                     Bundle b = new Bundle(id, sb.toString(), null, null);</span>
<span class="line-removed"> 350                     // Insert the bundle for root at the top so that it will get</span>
<span class="line-removed"> 351                     // processed first.</span>
<span class="line-removed"> 352                     if (&quot;root&quot;.equals(id)) {</span>
<span class="line-removed"> 353                         retList.add(0, b);</span>
<span class="line-removed"> 354                     } else {</span>
<span class="line-removed"> 355                         retList.add(b);</span>
<span class="line-removed"> 356                     }</span>
 357                 }
 358             }
 359         }
















 360         return retList;
 361     }
 362 
 363     private static final Map&lt;String, Map&lt;String, Object&gt;&gt; cldrBundles = new HashMap&lt;&gt;();
 364 
 365     private static Map&lt;String, SortedSet&lt;String&gt;&gt; metaInfo = new HashMap&lt;&gt;();
 366 
 367     static {
 368         // For generating information on supported locales.
 369         metaInfo.put(&quot;AvailableLocales&quot;, new TreeSet&lt;&gt;());
 370     }
 371 
 372     static Map&lt;String, Object&gt; getCLDRBundle(String id) throws Exception {
 373         Map&lt;String, Object&gt; bundle = cldrBundles.get(id);
 374         if (bundle != null) {
 375             return bundle;
 376         }
 377         File file = new File(SOURCE_FILE_DIR + File.separator + id + &quot;.xml&quot;);
 378         if (!file.exists()) {
 379             // Skip if the file doesn&#39;t exist.
</pre>
<hr />
<pre>
 425         // Parse numberingSystems to get digit zero character information.
 426         handlerNumbering = new NumberingSystemsParseHandler();
 427         parseLDMLFile(new File(NUMBERING_SOURCE_FILE), handlerNumbering);
 428 
 429         // Parse metaZones to create mappings between Olson tzids and CLDR meta zone names
 430         handlerMetaZones = new MetaZonesParseHandler();
 431         parseLDMLFile(new File(METAZONES_SOURCE_FILE), handlerMetaZones);
 432 
 433         // Parse likelySubtags
 434         handlerLikelySubtags = new LikelySubtagsParseHandler();
 435         parseLDMLFile(new File(LIKELYSUBTAGS_SOURCE_FILE), handlerLikelySubtags);
 436 
 437         // Parse supplementalMetadata
 438         // Currently interested in deprecated time zone ids and language aliases.
 439         handlerSupplMeta = new SupplementalMetadataParseHandler();
 440         parseLDMLFile(new File(SPPL_META_SOURCE_FILE), handlerSupplMeta);
 441 
 442         // Parse windowsZones
 443         handlerWinZones = new WinZonesParseHandler();
 444         parseLDMLFile(new File(WINZONES_SOURCE_FILE), handlerWinZones);




 445     }
 446 
 447     // Parsers for data in &quot;bcp47&quot; directory
 448     //
 449     private static void parseBCP47() throws Exception {
 450         // Parse timezone
 451         handlerTimeZone = new TimeZoneParseHandler();
 452         parseLDMLFile(new File(TIMEZONE_SOURCE_FILE), handlerTimeZone);
 453 
 454         // canonical tz name map
 455         // alias -&gt; primary
 456         handlerTimeZone.getData().forEach((k, v) -&gt; {
 457             String[] ids = ((String)v).split(&quot;\\s&quot;);
 458             for (int i = 1; i &lt; ids.length; i++) {
 459                 canonicalTZMap.put(ids[i], ids[0]);
 460             }
 461         });
 462     }
 463 
 464     private static void parseLDMLFile(File srcfile, AbstractLDMLHandler handler) throws Exception {
</pre>
<hr />
<pre>
 648         }
 649 
 650         return localeNames;
 651     }
 652 
 653     @SuppressWarnings(&quot;AssignmentToForLoopParameter&quot;)
 654     private static Map&lt;String, Object&gt; extractCurrencyNames(Map&lt;String, Object&gt; map, String id, String names)
 655             throws Exception {
 656         Map&lt;String, Object&gt; currencyNames = new TreeMap&lt;&gt;(KeyComparator.INSTANCE);
 657         for (String key : map.keySet()) {
 658             if (key.startsWith(CURRENCY_NAME_PREFIX)) {
 659                 currencyNames.put(key.substring(CURRENCY_NAME_PREFIX.length()), map.get(key));
 660             } else if (key.startsWith(CURRENCY_SYMBOL_PREFIX)) {
 661                 currencyNames.put(key.substring(CURRENCY_SYMBOL_PREFIX.length()), map.get(key));
 662             }
 663         }
 664         return currencyNames;
 665     }
 666 
 667     private static Map&lt;String, Object&gt; extractZoneNames(Map&lt;String, Object&gt; map, String id) {
<span class="line-modified"> 668         Map&lt;String, Object&gt; names = new HashMap&lt;&gt;();</span>
<span class="line-removed"> 669 </span>
<span class="line-removed"> 670         // Copy over missing time zone ids from JRE for English locale</span>
<span class="line-removed"> 671         if (id.equals(&quot;en&quot;)) {</span>
<span class="line-removed"> 672             Map&lt;String[], String&gt; jreMetaMap = new HashMap&lt;&gt;();</span>
<span class="line-removed"> 673             jreTimeZoneNames.stream().forEach(e -&gt; {</span>
<span class="line-removed"> 674                 String tzid = (String)e[0];</span>
<span class="line-removed"> 675                 String[] data = (String[])e[1];</span>
<span class="line-removed"> 676 </span>
<span class="line-removed"> 677                 if (map.get(TIMEZONE_ID_PREFIX + tzid) == null &amp;&amp;</span>
<span class="line-removed"> 678                     handlerMetaZones.get(tzid) == null ||</span>
<span class="line-removed"> 679                     handlerMetaZones.get(tzid) != null &amp;&amp;</span>
<span class="line-removed"> 680                     map.get(METAZONE_ID_PREFIX + handlerMetaZones.get(tzid)) == null) {</span>
<span class="line-removed"> 681 </span>
<span class="line-removed"> 682                     // First, check the alias</span>
<span class="line-removed"> 683                     String canonID = canonicalTZMap.get(tzid);</span>
<span class="line-removed"> 684                     if (canonID != null &amp;&amp; !tzid.equals(canonID)) {</span>
<span class="line-removed"> 685                         Object value = map.get(TIMEZONE_ID_PREFIX + canonID);</span>
<span class="line-removed"> 686                         if (value != null) {</span>
<span class="line-removed"> 687                             names.put(tzid, value);</span>
<span class="line-removed"> 688                             return;</span>
<span class="line-removed"> 689                         } else {</span>
<span class="line-removed"> 690                             String meta = handlerMetaZones.get(canonID);</span>
<span class="line-removed"> 691                             if (meta != null) {</span>
<span class="line-removed"> 692                                 value = map.get(METAZONE_ID_PREFIX + meta);</span>
<span class="line-removed"> 693                                 if (value != null) {</span>
<span class="line-removed"> 694                                     names.put(tzid, meta);</span>
<span class="line-removed"> 695                                     return;</span>
<span class="line-removed"> 696                                 }</span>
<span class="line-removed"> 697                             }</span>
<span class="line-removed"> 698                         }</span>
<span class="line-removed"> 699                     }</span>
 700 
<span class="line-modified"> 701                     // Check the CLDR meta key</span>
<span class="line-removed"> 702                     Optional&lt;Map.Entry&lt;String, String&gt;&gt; cldrMeta =</span>
<span class="line-removed"> 703                         handlerMetaZones.getData().entrySet().stream()</span>
<span class="line-removed"> 704                             .filter(me -&gt;</span>
<span class="line-removed"> 705                                 Arrays.deepEquals(data,</span>
<span class="line-removed"> 706                                     (String[])map.get(METAZONE_ID_PREFIX + me.getValue())))</span>
<span class="line-removed"> 707                             .findAny();</span>
<span class="line-removed"> 708                     cldrMeta.ifPresentOrElse(meta -&gt; names.put(tzid, meta.getValue()), () -&gt; {</span>
<span class="line-removed"> 709                         // Check the JRE meta key, add if there is not.</span>
<span class="line-removed"> 710                         Optional&lt;Map.Entry&lt;String[], String&gt;&gt; jreMeta =</span>
<span class="line-removed"> 711                             jreMetaMap.entrySet().stream()</span>
<span class="line-removed"> 712                                 .filter(jm -&gt; Arrays.deepEquals(data, jm.getKey()))</span>
<span class="line-removed"> 713                                 .findAny();</span>
<span class="line-removed"> 714                         jreMeta.ifPresentOrElse(meta -&gt; names.put(tzid, meta.getValue()), () -&gt; {</span>
<span class="line-removed"> 715                                 String metaName = &quot;JRE_&quot; + tzid.replaceAll(&quot;[/-]&quot;, &quot;_&quot;);</span>
<span class="line-removed"> 716                                 names.put(METAZONE_ID_PREFIX + metaName, data);</span>
<span class="line-removed"> 717                                 names.put(tzid, metaName);</span>
<span class="line-removed"> 718                         });</span>
<span class="line-removed"> 719                     });</span>
<span class="line-removed"> 720                 }</span>
<span class="line-removed"> 721             });</span>
<span class="line-removed"> 722         }</span>
<span class="line-removed"> 723 </span>
<span class="line-removed"> 724         Arrays.stream(AVAILABLE_TZIDS).forEach(tzid -&gt; {</span>
 725             // If the tzid is deprecated, get the data for the replacement id
 726             String tzKey = Optional.ofNullable((String)handlerSupplMeta.get(tzid))
 727                                    .orElse(tzid);
 728             Object data = map.get(TIMEZONE_ID_PREFIX + tzKey);
 729 
 730             if (data instanceof String[]) {
<span class="line-modified"> 731                 names.put(tzid, data);</span>







 732             } else {
 733                 String meta = handlerMetaZones.get(tzKey);
 734                 if (meta != null) {
 735                     String metaKey = METAZONE_ID_PREFIX + meta;
 736                     data = map.get(metaKey);
 737                     if (data instanceof String[]) {
 738                         // Keep the metazone prefix here.
 739                         names.put(metaKey, data);
 740                         names.put(tzid, meta);
 741                     }
 742                 }
 743             }
 744         });
 745 
 746         // exemplar cities.
 747         Map&lt;String, Object&gt; exCities = map.entrySet().stream()
<span class="line-modified"> 748                 .filter(e -&gt; e.getKey().startsWith(CLDRConverter.EXEMPLAR_CITY_PREFIX))</span>
<span class="line-modified"> 749                 .collect(Collectors</span>
<span class="line-removed"> 750                         .toMap(Map.Entry::getKey, Map.Entry::getValue));</span>
 751         names.putAll(exCities);
 752 
<span class="line-modified"> 753         if (!id.equals(&quot;en&quot;) &amp;&amp;</span>
<span class="line-modified"> 754             !names.isEmpty()) {</span>
<span class="line-modified"> 755             // CLDR does not have UTC entry, so add it here.</span>
<span class="line-modified"> 756             names.put(&quot;UTC&quot;, EMPTY_ZONE);</span>
<span class="line-removed"> 757 </span>
<span class="line-removed"> 758             // no metazone zones</span>
<span class="line-removed"> 759             Arrays.asList(handlerMetaZones.get(MetaZonesParseHandler.NO_METAZONE_KEY)</span>
<span class="line-removed"> 760                 .split(&quot;\\s&quot;)).stream()</span>
<span class="line-removed"> 761                 .forEach(tz -&gt; {</span>
<span class="line-removed"> 762                     names.put(tz, EMPTY_ZONE);</span>
<span class="line-removed"> 763                 });</span>
 764         }
 765 







 766         return names;
 767     }
 768 
 769     /**
 770      * Extracts the language independent calendar data. Each of the two keys,
 771      * &quot;firstDayOfWeek&quot; and &quot;minimalDaysInFirstWeek&quot; has a string value consists of
 772      * one or multiple occurrences of:
 773      *  i: rg1 rg2 ... rgn;
 774      * where &quot;i&quot; is the data for the following regions (delimited by a space) after
 775      * &quot;:&quot;, and ends with a &quot;;&quot;.
 776      */
 777     private static Map&lt;String, Object&gt; extractCalendarData(Map&lt;String, Object&gt; map, String id) {
 778         Map&lt;String, Object&gt; calendarData = new LinkedHashMap&lt;&gt;();
 779         if (id.equals(&quot;root&quot;)) {
 780             calendarData.put(&quot;firstDayOfWeek&quot;,
 781                 IntStream.range(1, 8)
 782                     .mapToObj(String::valueOf)
 783                     .filter(d -&gt; map.keySet().contains(CALENDAR_FIRSTDAY_PREFIX + d))
 784                     .map(d -&gt; d + &quot;: &quot; + map.get(CALENDAR_FIRSTDAY_PREFIX + d))
 785                     .collect(Collectors.joining(&quot;;&quot;)));
</pre>
<hr />
<pre>
 838         &quot;DatePatterns&quot;,
 839         &quot;DateTimePatterns&quot;,
 840         &quot;DateTimePatternChars&quot;
 841     };
 842 
 843     private static Map&lt;String, Object&gt; extractFormatData(Map&lt;String, Object&gt; map, String id) {
 844         Map&lt;String, Object&gt; formatData = new LinkedHashMap&lt;&gt;();
 845         for (CalendarType calendarType : CalendarType.values()) {
 846             if (calendarType == CalendarType.GENERIC) {
 847                 continue;
 848             }
 849             String prefix = calendarType.keyElementName();
 850             for (String element : FORMAT_DATA_ELEMENTS) {
 851                 String key = prefix + element;
 852                 copyIfPresent(map, &quot;java.time.&quot; + key, formatData);
 853                 copyIfPresent(map, key, formatData);
 854             }
 855         }
 856 
 857         for (String key : map.keySet()) {
<span class="line-modified"> 858         // Copy available calendar names</span>
 859             if (key.startsWith(CLDRConverter.LOCALE_TYPE_PREFIX_CA)) {
 860                 String type = key.substring(CLDRConverter.LOCALE_TYPE_PREFIX_CA.length());
 861                 for (CalendarType calendarType : CalendarType.values()) {
 862                     if (calendarType == CalendarType.GENERIC) {
 863                         continue;
 864                     }
 865                     if (type.equals(calendarType.lname())) {
 866                         Object value = map.get(key);
 867                         String dataKey = key.replace(LOCALE_TYPE_PREFIX_CA,
 868                                 CALENDAR_NAME_PREFIX);
 869                         formatData.put(dataKey, value);
 870                         String ukey = CALENDAR_NAME_PREFIX + calendarType.uname();
 871                         if (!dataKey.equals(ukey)) {
 872                             formatData.put(ukey, value);
 873                         }
 874                     }
 875                 }
 876             }
 877         }
 878 
 879         copyIfPresent(map, &quot;DefaultNumberingSystem&quot;, formatData);
 880 
 881         @SuppressWarnings(&quot;unchecked&quot;)
 882         List&lt;String&gt; numberingScripts = (List&lt;String&gt;) map.remove(&quot;numberingScripts&quot;);
 883         if (numberingScripts != null) {
 884             for (String script : numberingScripts) {
<span class="line-modified"> 885                 copyIfPresent(map, script + &quot;.&quot; + &quot;NumberElements&quot;, formatData);</span>

 886             }
 887         } else {
 888             copyIfPresent(map, &quot;NumberElements&quot;, formatData);

 889         }
<span class="line-removed"> 890         copyIfPresent(map, &quot;NumberPatterns&quot;, formatData);</span>
 891         copyIfPresent(map, &quot;short.CompactNumberPatterns&quot;, formatData);
 892         copyIfPresent(map, &quot;long.CompactNumberPatterns&quot;, formatData);
 893 
 894         // put extra number elements for available scripts into formatData, if it is &quot;root&quot;
 895         if (id.equals(&quot;root&quot;)) {
 896             handlerNumbering.keySet().stream()
 897                 .filter(k -&gt; !numberingScripts.contains(k))
 898                 .forEach(k -&gt; {
 899                     String[] ne = (String[])map.get(&quot;latn.NumberElements&quot;);
 900                     String[] neNew = Arrays.copyOf(ne, ne.length);
 901                     neNew[4] = handlerNumbering.get(k).substring(0, 1);
 902                     formatData.put(k + &quot;.NumberElements&quot;, neNew);
 903                 });
 904         }
 905         return formatData;
 906     }
 907 
 908     private static void copyIfPresent(Map&lt;String, Object&gt; src, String key, Map&lt;String, Object&gt; dest) {
 909         Object value = src.get(key);
 910         if (value != null) {
</pre>
<hr />
<pre>
1048         Files.createDirectories(Paths.get(DESTINATION_DIR, &quot;java&quot;, &quot;time&quot;, &quot;format&quot;));
1049         Files.write(Paths.get(DESTINATION_DIR, &quot;java&quot;, &quot;time&quot;, &quot;format&quot;, &quot;ZoneName.java&quot;),
1050             Files.lines(Paths.get(zoneNameTempFile))
1051                 .flatMap(l -&gt; {
1052                     if (l.equals(&quot;%%%%ZIDMAP%%%%&quot;)) {
1053                         return zidMapEntry();
1054                     } else if (l.equals(&quot;%%%%MZONEMAP%%%%&quot;)) {
1055                         return handlerMetaZones.mzoneMapEntry();
1056                     } else if (l.equals(&quot;%%%%DEPRECATED%%%%&quot;)) {
1057                         return handlerSupplMeta.deprecatedMap();
1058                     } else if (l.equals(&quot;%%%%TZDATALINK%%%%&quot;)) {
1059                         return tzDataLinkEntry();
1060                     } else {
1061                         return Stream.of(l);
1062                     }
1063                 })
1064                 .collect(Collectors.toList()),
1065             StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
1066     }
1067 












1068     private static Stream&lt;String&gt; zidMapEntry() {
<span class="line-modified">1069         return ZoneId.getAvailableZoneIds().stream()</span>
1070                 .map(id -&gt; {
1071                     String canonId = canonicalTZMap.getOrDefault(id, id);
1072                     String meta = handlerMetaZones.get(canonId);
1073                     String zone001 = handlerMetaZones.zidMap().get(meta);
1074                     return zone001 == null ? &quot;&quot; :
1075                             String.format(&quot;        \&quot;%s\&quot;, \&quot;%s\&quot;, \&quot;%s\&quot;,&quot;,
1076                                             id, meta, zone001);
1077                 })
1078                 .filter(s -&gt; !s.isEmpty())
1079                 .sorted();
1080     }
1081 
1082     private static Stream&lt;String&gt; tzDataLinkEntry() {
1083         try {
1084             return Files.walk(Paths.get(tzDataDir), 1)
1085                 .filter(p -&gt; !Files.isDirectory(p))
1086                 .flatMap(CLDRConverter::extractLinks)
1087                 .sorted();
1088         } catch (IOException e) {
1089             throw new UncheckedIOException(e);
</pre>
<hr />
<pre>
1121                 .sorted(new Comparator&lt;String&gt;() {
1122                     public int compare(String t1, String t2) {
1123                         String[] s1 = t1.split(&quot;:&quot;);
1124                         String[] s2 = t2.split(&quot;:&quot;);
1125                         if (s1[0].equals(s2[0])) {
1126                             if (s1[1].equals(&quot;001&quot;)) {
1127                                 return 1;
1128                             } else if (s2[1].equals(&quot;001&quot;)) {
1129                                 return -1;
1130                             } else {
1131                                 return s1[1].compareTo(s2[1]);
1132                             }
1133                         } else {
1134                             return s1[0].compareTo(s2[0]);
1135                         }
1136                     }
1137                 })
1138                 .collect(Collectors.toList()),
1139             StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
1140     }
































































1141 }

</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package build.tools.cldrconverter;
  27 

  28 import build.tools.cldrconverter.BundleGenerator.BundleType;
  29 import java.io.File;
  30 import java.io.IOException;
  31 import java.io.UncheckedIOException;
  32 import java.nio.file.*;
  33 import java.text.MessageFormat;
  34 import java.time.*;
  35 import java.util.*;
  36 import java.util.ResourceBundle.Control;
  37 import java.util.logging.Level;
  38 import java.util.logging.Logger;
  39 import java.util.stream.Collectors;
  40 import java.util.stream.IntStream;
  41 import java.util.stream.Stream;
  42 import javax.xml.parsers.SAXParser;
  43 import javax.xml.parsers.SAXParserFactory;
  44 import org.xml.sax.SAXNotRecognizedException;
  45 import org.xml.sax.SAXNotSupportedException;
  46 
  47 
</pre>
<hr />
<pre>
  52  */
  53 public class CLDRConverter {
  54 
  55     static final String LDML_DTD_SYSTEM_ID = &quot;http://www.unicode.org/cldr/dtd/2.0/ldml.dtd&quot;;
  56     static final String SPPL_LDML_DTD_SYSTEM_ID = &quot;http://www.unicode.org/cldr/dtd/2.0/ldmlSupplemental.dtd&quot;;
  57     static final String BCP47_LDML_DTD_SYSTEM_ID = &quot;http://www.unicode.org/cldr/dtd/2.0/ldmlBCP47.dtd&quot;;
  58 
  59 
  60     private static String CLDR_BASE;
  61     static String LOCAL_LDML_DTD;
  62     static String LOCAL_SPPL_LDML_DTD;
  63     static String LOCAL_BCP47_LDML_DTD;
  64     private static String SOURCE_FILE_DIR;
  65     private static String SPPL_SOURCE_FILE;
  66     private static String SPPL_META_SOURCE_FILE;
  67     private static String NUMBERING_SOURCE_FILE;
  68     private static String METAZONES_SOURCE_FILE;
  69     private static String LIKELYSUBTAGS_SOURCE_FILE;
  70     private static String TIMEZONE_SOURCE_FILE;
  71     private static String WINZONES_SOURCE_FILE;
<span class="line-added">  72     private static String PLURALS_SOURCE_FILE;</span>
  73     static String DESTINATION_DIR = &quot;build/gensrc&quot;;
  74 
  75     static final String LOCALE_NAME_PREFIX = &quot;locale.displayname.&quot;;
  76     static final String LOCALE_SEPARATOR = LOCALE_NAME_PREFIX + &quot;separator&quot;;
  77     static final String LOCALE_KEYTYPE = LOCALE_NAME_PREFIX + &quot;keytype&quot;;
  78     static final String LOCALE_KEY_PREFIX = LOCALE_NAME_PREFIX + &quot;key.&quot;;
  79     static final String LOCALE_TYPE_PREFIX = LOCALE_NAME_PREFIX + &quot;type.&quot;;
  80     static final String LOCALE_TYPE_PREFIX_CA = LOCALE_TYPE_PREFIX + &quot;ca.&quot;;
  81     static final String CURRENCY_SYMBOL_PREFIX = &quot;currency.symbol.&quot;;
  82     static final String CURRENCY_NAME_PREFIX = &quot;currency.displayname.&quot;;
  83     static final String CALENDAR_NAME_PREFIX = &quot;calendarname.&quot;;
  84     static final String CALENDAR_FIRSTDAY_PREFIX = &quot;firstDay.&quot;;
  85     static final String CALENDAR_MINDAYS_PREFIX = &quot;minDays.&quot;;
  86     static final String TIMEZONE_ID_PREFIX = &quot;timezone.id.&quot;;
  87     static final String EXEMPLAR_CITY_PREFIX = &quot;timezone.excity.&quot;;
  88     static final String ZONE_NAME_PREFIX = &quot;timezone.displayname.&quot;;
  89     static final String METAZONE_ID_PREFIX = &quot;metazone.id.&quot;;
  90     static final String PARENT_LOCALE_PREFIX = &quot;parentLocale.&quot;;
<span class="line-added">  91     static final String META_EMPTY_ZONE_NAME = &quot;EMPTY_ZONE&quot;;</span>
  92     static final String[] EMPTY_ZONE = {&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;};
<span class="line-added">  93     static final String META_ETCUTC_ZONE_NAME = &quot;ETC_UTC&quot;;</span>
  94 
  95     private static SupplementDataParseHandler handlerSuppl;
  96     private static LikelySubtagsParseHandler handlerLikelySubtags;
  97     private static WinZonesParseHandler handlerWinZones;
<span class="line-added">  98     static PluralsParseHandler handlerPlurals;</span>
  99     static SupplementalMetadataParseHandler handlerSupplMeta;
 100     static NumberingSystemsParseHandler handlerNumbering;
 101     static MetaZonesParseHandler handlerMetaZones;
 102     static TimeZoneParseHandler handlerTimeZone;
 103     private static BundleGenerator bundleGenerator;
 104 
 105     // java.base module related
 106     static boolean isBaseModule = false;
 107     static final Set&lt;Locale&gt; BASE_LOCALES = new HashSet&lt;&gt;();
 108 
 109     // &quot;parentLocales&quot; map
 110     private static final Map&lt;String, SortedSet&lt;String&gt;&gt; parentLocalesMap = new HashMap&lt;&gt;();
 111     private static final ResourceBundle.Control defCon =
 112         ResourceBundle.Control.getControl(ResourceBundle.Control.FORMAT_DEFAULT);
 113 
<span class="line-modified"> 114     private static Set&lt;String&gt; AVAILABLE_TZIDS;</span>
 115     private static String zoneNameTempFile;
 116     private static String tzDataDir;
 117     private static final Map&lt;String, String&gt; canonicalTZMap = new HashMap&lt;&gt;();
 118 
 119     static enum DraftType {
 120         UNCONFIRMED,
 121         PROVISIONAL,
 122         CONTRIBUTED,
 123         APPROVED;
 124 
 125         private static final Map&lt;String, DraftType&gt; map = new HashMap&lt;&gt;();
 126         static {
 127             for (DraftType dt : values()) {
 128                 map.put(dt.getKeyword(), dt);
 129             }
 130         }
 131         static private DraftType defaultType = CONTRIBUTED;
 132 
 133         private final String keyword;
 134 
</pre>
<hr />
<pre>
 230                 }
 231             } catch (RuntimeException e) {
 232                 severe(&quot;unknown or imcomplete arg(s): &quot; + currentArg);
 233                 usage();
 234                 System.exit(1);
 235             }
 236         }
 237 
 238         // Set up path names
 239         LOCAL_LDML_DTD = CLDR_BASE + &quot;/dtd/ldml.dtd&quot;;
 240         LOCAL_SPPL_LDML_DTD = CLDR_BASE + &quot;/dtd/ldmlSupplemental.dtd&quot;;
 241         LOCAL_BCP47_LDML_DTD = CLDR_BASE + &quot;/dtd/ldmlBCP47.dtd&quot;;
 242         SOURCE_FILE_DIR = CLDR_BASE + &quot;/main&quot;;
 243         SPPL_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/supplementalData.xml&quot;;
 244         LIKELYSUBTAGS_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/likelySubtags.xml&quot;;
 245         NUMBERING_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/numberingSystems.xml&quot;;
 246         METAZONES_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/metaZones.xml&quot;;
 247         TIMEZONE_SOURCE_FILE = CLDR_BASE + &quot;/bcp47/timezone.xml&quot;;
 248         SPPL_META_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/supplementalMetadata.xml&quot;;
 249         WINZONES_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/windowsZones.xml&quot;;
<span class="line-added"> 250         PLURALS_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/plurals.xml&quot;;</span>
 251 
 252         if (BASE_LOCALES.isEmpty()) {
 253             setupBaseLocales(&quot;en-US&quot;);
 254         }
 255 
 256         bundleGenerator = new ResourceBundleGenerator();
 257 
 258         // Parse data independent of locales
 259         parseSupplemental();
 260         parseBCP47();
 261 
 262         List&lt;Bundle&gt; bundles = readBundleList();
 263         convertBundles(bundles);
 264 
 265         if (isBaseModule) {
 266             // Generate java.time.format.ZoneName.java
 267             generateZoneName();
 268 
 269             // Generate Windows tzmappings
 270             generateWindowsTZMappings();
<span class="line-added"> 271 </span>
<span class="line-added"> 272             // Generate Plural rules</span>
<span class="line-added"> 273             generatePluralRules();</span>
 274         }
 275     }
 276 
 277     private static void usage() {
 278         errout(&quot;Usage: java CLDRConverter [options]%n&quot;
 279                 + &quot;\t-help          output this usage message and exit%n&quot;
 280                 + &quot;\t-verbose       output information%n&quot;
 281                 + &quot;\t-draft [contributed | approved | provisional | unconfirmed]%n&quot;
 282                 + &quot;\t\t       draft level for using data (default: contributed)%n&quot;
 283                 + &quot;\t-base dir      base directory for CLDR input files%n&quot;
 284                 + &quot;\t-basemodule    generates bundles that go into java.base module%n&quot;
 285                 + &quot;\t-baselocales loc(,loc)*      locales that go into the base module%n&quot;
 286                 + &quot;\t-o dir         output directory (default: ./build/gensrc)%n&quot;
 287                 + &quot;\t-zntempfile    template file for java.time.format.ZoneName.java%n&quot;
 288                 + &quot;\t-tzdatadir     tzdata directory for java.time.format.ZoneName.java%n&quot;
 289                 + &quot;\t-utf8          use UTF-8 rather than \\uxxxx (for debug)%n&quot;);
 290     }
 291 
 292     static void info(String fmt, Object... args) {
 293         if (verbose) {
</pre>
<hr />
<pre>
 336         try {
 337             parser.setProperty(&quot;http://javax.xml.XMLConstants/property/accessExternalDTD&quot;, &quot;file&quot;);
 338         } catch (SAXNotRecognizedException ignore) {
 339             // property requires &gt;= JAXP 1.5
 340         }
 341     }
 342 
 343     private static List&lt;Bundle&gt; readBundleList() throws Exception {
 344         List&lt;Bundle&gt; retList = new ArrayList&lt;&gt;();
 345         Path path = FileSystems.getDefault().getPath(SOURCE_FILE_DIR);
 346         try (DirectoryStream&lt;Path&gt; dirStr = Files.newDirectoryStream(path)) {
 347             for (Path entry : dirStr) {
 348                 String fileName = entry.getFileName().toString();
 349                 if (fileName.endsWith(&quot;.xml&quot;)) {
 350                     String id = fileName.substring(0, fileName.indexOf(&#39;.&#39;));
 351                     Locale cldrLoc = Locale.forLanguageTag(toLanguageTag(id));
 352                     StringBuilder sb = getCandLocales(cldrLoc);
 353                     if (sb.indexOf(&quot;root&quot;) == -1) {
 354                         sb.append(&quot;root&quot;);
 355                     }
<span class="line-modified"> 356                     retList.add(new Bundle(id, sb.toString(), null, null));</span>







 357                 }
 358             }
 359         }
<span class="line-added"> 360 </span>
<span class="line-added"> 361         // Sort the bundles based on id. This will make sure all the parent bundles are</span>
<span class="line-added"> 362         // processed first, e.g., for en_GB bundle, en_001, and &quot;root&quot; comes before</span>
<span class="line-added"> 363         // en_GB. In order for &quot;root&quot; to come at the beginning, &quot;root&quot; is replaced with</span>
<span class="line-added"> 364         // empty string on comparison.</span>
<span class="line-added"> 365         retList.sort((o1, o2) -&gt; {</span>
<span class="line-added"> 366             String id1 = o1.getID();</span>
<span class="line-added"> 367             String id2 = o2.getID();</span>
<span class="line-added"> 368             if(id1.equals(&quot;root&quot;)) {</span>
<span class="line-added"> 369                 id1 = &quot;&quot;;</span>
<span class="line-added"> 370             }</span>
<span class="line-added"> 371             if(id2.equals(&quot;root&quot;)) {</span>
<span class="line-added"> 372                 id2 = &quot;&quot;;</span>
<span class="line-added"> 373             }</span>
<span class="line-added"> 374             return id1.compareTo(id2);</span>
<span class="line-added"> 375         });</span>
 376         return retList;
 377     }
 378 
 379     private static final Map&lt;String, Map&lt;String, Object&gt;&gt; cldrBundles = new HashMap&lt;&gt;();
 380 
 381     private static Map&lt;String, SortedSet&lt;String&gt;&gt; metaInfo = new HashMap&lt;&gt;();
 382 
 383     static {
 384         // For generating information on supported locales.
 385         metaInfo.put(&quot;AvailableLocales&quot;, new TreeSet&lt;&gt;());
 386     }
 387 
 388     static Map&lt;String, Object&gt; getCLDRBundle(String id) throws Exception {
 389         Map&lt;String, Object&gt; bundle = cldrBundles.get(id);
 390         if (bundle != null) {
 391             return bundle;
 392         }
 393         File file = new File(SOURCE_FILE_DIR + File.separator + id + &quot;.xml&quot;);
 394         if (!file.exists()) {
 395             // Skip if the file doesn&#39;t exist.
</pre>
<hr />
<pre>
 441         // Parse numberingSystems to get digit zero character information.
 442         handlerNumbering = new NumberingSystemsParseHandler();
 443         parseLDMLFile(new File(NUMBERING_SOURCE_FILE), handlerNumbering);
 444 
 445         // Parse metaZones to create mappings between Olson tzids and CLDR meta zone names
 446         handlerMetaZones = new MetaZonesParseHandler();
 447         parseLDMLFile(new File(METAZONES_SOURCE_FILE), handlerMetaZones);
 448 
 449         // Parse likelySubtags
 450         handlerLikelySubtags = new LikelySubtagsParseHandler();
 451         parseLDMLFile(new File(LIKELYSUBTAGS_SOURCE_FILE), handlerLikelySubtags);
 452 
 453         // Parse supplementalMetadata
 454         // Currently interested in deprecated time zone ids and language aliases.
 455         handlerSupplMeta = new SupplementalMetadataParseHandler();
 456         parseLDMLFile(new File(SPPL_META_SOURCE_FILE), handlerSupplMeta);
 457 
 458         // Parse windowsZones
 459         handlerWinZones = new WinZonesParseHandler();
 460         parseLDMLFile(new File(WINZONES_SOURCE_FILE), handlerWinZones);
<span class="line-added"> 461 </span>
<span class="line-added"> 462         // Parse plurals</span>
<span class="line-added"> 463         handlerPlurals = new PluralsParseHandler();</span>
<span class="line-added"> 464         parseLDMLFile(new File(PLURALS_SOURCE_FILE), handlerPlurals);</span>
 465     }
 466 
 467     // Parsers for data in &quot;bcp47&quot; directory
 468     //
 469     private static void parseBCP47() throws Exception {
 470         // Parse timezone
 471         handlerTimeZone = new TimeZoneParseHandler();
 472         parseLDMLFile(new File(TIMEZONE_SOURCE_FILE), handlerTimeZone);
 473 
 474         // canonical tz name map
 475         // alias -&gt; primary
 476         handlerTimeZone.getData().forEach((k, v) -&gt; {
 477             String[] ids = ((String)v).split(&quot;\\s&quot;);
 478             for (int i = 1; i &lt; ids.length; i++) {
 479                 canonicalTZMap.put(ids[i], ids[0]);
 480             }
 481         });
 482     }
 483 
 484     private static void parseLDMLFile(File srcfile, AbstractLDMLHandler handler) throws Exception {
</pre>
<hr />
<pre>
 668         }
 669 
 670         return localeNames;
 671     }
 672 
 673     @SuppressWarnings(&quot;AssignmentToForLoopParameter&quot;)
 674     private static Map&lt;String, Object&gt; extractCurrencyNames(Map&lt;String, Object&gt; map, String id, String names)
 675             throws Exception {
 676         Map&lt;String, Object&gt; currencyNames = new TreeMap&lt;&gt;(KeyComparator.INSTANCE);
 677         for (String key : map.keySet()) {
 678             if (key.startsWith(CURRENCY_NAME_PREFIX)) {
 679                 currencyNames.put(key.substring(CURRENCY_NAME_PREFIX.length()), map.get(key));
 680             } else if (key.startsWith(CURRENCY_SYMBOL_PREFIX)) {
 681                 currencyNames.put(key.substring(CURRENCY_SYMBOL_PREFIX.length()), map.get(key));
 682             }
 683         }
 684         return currencyNames;
 685     }
 686 
 687     private static Map&lt;String, Object&gt; extractZoneNames(Map&lt;String, Object&gt; map, String id) {
<span class="line-modified"> 688         Map&lt;String, Object&gt; names = new TreeMap&lt;&gt;(KeyComparator.INSTANCE);</span>































 689 
<span class="line-modified"> 690         getAvailableZoneIds().stream().forEach(tzid -&gt; {</span>























 691             // If the tzid is deprecated, get the data for the replacement id
 692             String tzKey = Optional.ofNullable((String)handlerSupplMeta.get(tzid))
 693                                    .orElse(tzid);
 694             Object data = map.get(TIMEZONE_ID_PREFIX + tzKey);
 695 
 696             if (data instanceof String[]) {
<span class="line-modified"> 697                 // Hack for UTC. UTC is an alias to Etc/UTC in CLDR</span>
<span class="line-added"> 698                 if (tzid.equals(&quot;Etc/UTC&quot;) &amp;&amp; !map.containsKey(TIMEZONE_ID_PREFIX + &quot;UTC&quot;)) {</span>
<span class="line-added"> 699                     names.put(METAZONE_ID_PREFIX + META_ETCUTC_ZONE_NAME, data);</span>
<span class="line-added"> 700                     names.put(tzid, META_ETCUTC_ZONE_NAME);</span>
<span class="line-added"> 701                     names.put(&quot;UTC&quot;, META_ETCUTC_ZONE_NAME);</span>
<span class="line-added"> 702                 } else {</span>
<span class="line-added"> 703                     names.put(tzid, data);</span>
<span class="line-added"> 704                 }</span>
 705             } else {
 706                 String meta = handlerMetaZones.get(tzKey);
 707                 if (meta != null) {
 708                     String metaKey = METAZONE_ID_PREFIX + meta;
 709                     data = map.get(metaKey);
 710                     if (data instanceof String[]) {
 711                         // Keep the metazone prefix here.
 712                         names.put(metaKey, data);
 713                         names.put(tzid, meta);
 714                     }
 715                 }
 716             }
 717         });
 718 
 719         // exemplar cities.
 720         Map&lt;String, Object&gt; exCities = map.entrySet().stream()
<span class="line-modified"> 721             .filter(e -&gt; e.getKey().startsWith(CLDRConverter.EXEMPLAR_CITY_PREFIX))</span>
<span class="line-modified"> 722             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span>

 723         names.putAll(exCities);
 724 
<span class="line-modified"> 725         // If there&#39;s no UTC entry at this point, add an empty one</span>
<span class="line-modified"> 726         if (!names.isEmpty() &amp;&amp; !names.containsKey(&quot;UTC&quot;)) {</span>
<span class="line-modified"> 727             names.putIfAbsent(METAZONE_ID_PREFIX + META_EMPTY_ZONE_NAME, EMPTY_ZONE);</span>
<span class="line-modified"> 728             names.put(&quot;UTC&quot;, META_EMPTY_ZONE_NAME);</span>







 729         }
 730 
<span class="line-added"> 731         // Finally some compatibility stuff</span>
<span class="line-added"> 732         ZoneId.SHORT_IDS.entrySet().stream()</span>
<span class="line-added"> 733             .filter(e -&gt; !names.containsKey(e.getKey()) &amp;&amp; names.containsKey(e.getValue()))</span>
<span class="line-added"> 734             .forEach(e -&gt; {</span>
<span class="line-added"> 735                 names.put(e.getKey(), names.get(e.getValue()));</span>
<span class="line-added"> 736             });</span>
<span class="line-added"> 737 </span>
 738         return names;
 739     }
 740 
 741     /**
 742      * Extracts the language independent calendar data. Each of the two keys,
 743      * &quot;firstDayOfWeek&quot; and &quot;minimalDaysInFirstWeek&quot; has a string value consists of
 744      * one or multiple occurrences of:
 745      *  i: rg1 rg2 ... rgn;
 746      * where &quot;i&quot; is the data for the following regions (delimited by a space) after
 747      * &quot;:&quot;, and ends with a &quot;;&quot;.
 748      */
 749     private static Map&lt;String, Object&gt; extractCalendarData(Map&lt;String, Object&gt; map, String id) {
 750         Map&lt;String, Object&gt; calendarData = new LinkedHashMap&lt;&gt;();
 751         if (id.equals(&quot;root&quot;)) {
 752             calendarData.put(&quot;firstDayOfWeek&quot;,
 753                 IntStream.range(1, 8)
 754                     .mapToObj(String::valueOf)
 755                     .filter(d -&gt; map.keySet().contains(CALENDAR_FIRSTDAY_PREFIX + d))
 756                     .map(d -&gt; d + &quot;: &quot; + map.get(CALENDAR_FIRSTDAY_PREFIX + d))
 757                     .collect(Collectors.joining(&quot;;&quot;)));
</pre>
<hr />
<pre>
 810         &quot;DatePatterns&quot;,
 811         &quot;DateTimePatterns&quot;,
 812         &quot;DateTimePatternChars&quot;
 813     };
 814 
 815     private static Map&lt;String, Object&gt; extractFormatData(Map&lt;String, Object&gt; map, String id) {
 816         Map&lt;String, Object&gt; formatData = new LinkedHashMap&lt;&gt;();
 817         for (CalendarType calendarType : CalendarType.values()) {
 818             if (calendarType == CalendarType.GENERIC) {
 819                 continue;
 820             }
 821             String prefix = calendarType.keyElementName();
 822             for (String element : FORMAT_DATA_ELEMENTS) {
 823                 String key = prefix + element;
 824                 copyIfPresent(map, &quot;java.time.&quot; + key, formatData);
 825                 copyIfPresent(map, key, formatData);
 826             }
 827         }
 828 
 829         for (String key : map.keySet()) {
<span class="line-modified"> 830             // Copy available calendar names</span>
 831             if (key.startsWith(CLDRConverter.LOCALE_TYPE_PREFIX_CA)) {
 832                 String type = key.substring(CLDRConverter.LOCALE_TYPE_PREFIX_CA.length());
 833                 for (CalendarType calendarType : CalendarType.values()) {
 834                     if (calendarType == CalendarType.GENERIC) {
 835                         continue;
 836                     }
 837                     if (type.equals(calendarType.lname())) {
 838                         Object value = map.get(key);
 839                         String dataKey = key.replace(LOCALE_TYPE_PREFIX_CA,
 840                                 CALENDAR_NAME_PREFIX);
 841                         formatData.put(dataKey, value);
 842                         String ukey = CALENDAR_NAME_PREFIX + calendarType.uname();
 843                         if (!dataKey.equals(ukey)) {
 844                             formatData.put(ukey, value);
 845                         }
 846                     }
 847                 }
 848             }
 849         }
 850 
 851         copyIfPresent(map, &quot;DefaultNumberingSystem&quot;, formatData);
 852 
 853         @SuppressWarnings(&quot;unchecked&quot;)
 854         List&lt;String&gt; numberingScripts = (List&lt;String&gt;) map.remove(&quot;numberingScripts&quot;);
 855         if (numberingScripts != null) {
 856             for (String script : numberingScripts) {
<span class="line-modified"> 857                 copyIfPresent(map, script + &quot;.NumberElements&quot;, formatData);</span>
<span class="line-added"> 858                 copyIfPresent(map, script + &quot;.NumberPatterns&quot;, formatData);</span>
 859             }
 860         } else {
 861             copyIfPresent(map, &quot;NumberElements&quot;, formatData);
<span class="line-added"> 862             copyIfPresent(map, &quot;NumberPatterns&quot;, formatData);</span>
 863         }

 864         copyIfPresent(map, &quot;short.CompactNumberPatterns&quot;, formatData);
 865         copyIfPresent(map, &quot;long.CompactNumberPatterns&quot;, formatData);
 866 
 867         // put extra number elements for available scripts into formatData, if it is &quot;root&quot;
 868         if (id.equals(&quot;root&quot;)) {
 869             handlerNumbering.keySet().stream()
 870                 .filter(k -&gt; !numberingScripts.contains(k))
 871                 .forEach(k -&gt; {
 872                     String[] ne = (String[])map.get(&quot;latn.NumberElements&quot;);
 873                     String[] neNew = Arrays.copyOf(ne, ne.length);
 874                     neNew[4] = handlerNumbering.get(k).substring(0, 1);
 875                     formatData.put(k + &quot;.NumberElements&quot;, neNew);
 876                 });
 877         }
 878         return formatData;
 879     }
 880 
 881     private static void copyIfPresent(Map&lt;String, Object&gt; src, String key, Map&lt;String, Object&gt; dest) {
 882         Object value = src.get(key);
 883         if (value != null) {
</pre>
<hr />
<pre>
1021         Files.createDirectories(Paths.get(DESTINATION_DIR, &quot;java&quot;, &quot;time&quot;, &quot;format&quot;));
1022         Files.write(Paths.get(DESTINATION_DIR, &quot;java&quot;, &quot;time&quot;, &quot;format&quot;, &quot;ZoneName.java&quot;),
1023             Files.lines(Paths.get(zoneNameTempFile))
1024                 .flatMap(l -&gt; {
1025                     if (l.equals(&quot;%%%%ZIDMAP%%%%&quot;)) {
1026                         return zidMapEntry();
1027                     } else if (l.equals(&quot;%%%%MZONEMAP%%%%&quot;)) {
1028                         return handlerMetaZones.mzoneMapEntry();
1029                     } else if (l.equals(&quot;%%%%DEPRECATED%%%%&quot;)) {
1030                         return handlerSupplMeta.deprecatedMap();
1031                     } else if (l.equals(&quot;%%%%TZDATALINK%%%%&quot;)) {
1032                         return tzDataLinkEntry();
1033                     } else {
1034                         return Stream.of(l);
1035                     }
1036                 })
1037                 .collect(Collectors.toList()),
1038             StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
1039     }
1040 
<span class="line-added">1041     // This method assumes handlerMetaZones is already initialized</span>
<span class="line-added">1042     private static Set&lt;String&gt; getAvailableZoneIds() {</span>
<span class="line-added">1043         assert handlerMetaZones != null;</span>
<span class="line-added">1044         if (AVAILABLE_TZIDS == null) {</span>
<span class="line-added">1045             AVAILABLE_TZIDS = new HashSet&lt;&gt;(ZoneId.getAvailableZoneIds());</span>
<span class="line-added">1046             AVAILABLE_TZIDS.addAll(handlerMetaZones.keySet());</span>
<span class="line-added">1047             AVAILABLE_TZIDS.remove(MetaZonesParseHandler.NO_METAZONE_KEY);</span>
<span class="line-added">1048         }</span>
<span class="line-added">1049 </span>
<span class="line-added">1050         return AVAILABLE_TZIDS;</span>
<span class="line-added">1051     }</span>
<span class="line-added">1052 </span>
1053     private static Stream&lt;String&gt; zidMapEntry() {
<span class="line-modified">1054         return getAvailableZoneIds().stream()</span>
1055                 .map(id -&gt; {
1056                     String canonId = canonicalTZMap.getOrDefault(id, id);
1057                     String meta = handlerMetaZones.get(canonId);
1058                     String zone001 = handlerMetaZones.zidMap().get(meta);
1059                     return zone001 == null ? &quot;&quot; :
1060                             String.format(&quot;        \&quot;%s\&quot;, \&quot;%s\&quot;, \&quot;%s\&quot;,&quot;,
1061                                             id, meta, zone001);
1062                 })
1063                 .filter(s -&gt; !s.isEmpty())
1064                 .sorted();
1065     }
1066 
1067     private static Stream&lt;String&gt; tzDataLinkEntry() {
1068         try {
1069             return Files.walk(Paths.get(tzDataDir), 1)
1070                 .filter(p -&gt; !Files.isDirectory(p))
1071                 .flatMap(CLDRConverter::extractLinks)
1072                 .sorted();
1073         } catch (IOException e) {
1074             throw new UncheckedIOException(e);
</pre>
<hr />
<pre>
1106                 .sorted(new Comparator&lt;String&gt;() {
1107                     public int compare(String t1, String t2) {
1108                         String[] s1 = t1.split(&quot;:&quot;);
1109                         String[] s2 = t2.split(&quot;:&quot;);
1110                         if (s1[0].equals(s2[0])) {
1111                             if (s1[1].equals(&quot;001&quot;)) {
1112                                 return 1;
1113                             } else if (s2[1].equals(&quot;001&quot;)) {
1114                                 return -1;
1115                             } else {
1116                                 return s1[1].compareTo(s2[1]);
1117                             }
1118                         } else {
1119                             return s1[0].compareTo(s2[0]);
1120                         }
1121                     }
1122                 })
1123                 .collect(Collectors.toList()),
1124             StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
1125     }
<span class="line-added">1126 </span>
<span class="line-added">1127     /**</span>
<span class="line-added">1128      * Generate ResourceBundle source file for plural rules. The generated</span>
<span class="line-added">1129      * class is {@code sun.text.resources.PluralRules} which has one public</span>
<span class="line-added">1130      * two dimensional array {@code rulesArray}. Each array element consists</span>
<span class="line-added">1131      * of two elements that designate the locale and the locale&#39;s plural rules</span>
<span class="line-added">1132      * string. The latter has the syntax from Unicode Consortium&#39;s</span>
<span class="line-added">1133      * &lt;a href=&quot;http://unicode.org/reports/tr35/tr35-numbers.html#Plural_rules_syntax&quot;&gt;</span>
<span class="line-added">1134      * Plural rules syntax&lt;/a&gt;. {@code samples} and {@code &quot;other&quot;} are being ommited.</span>
<span class="line-added">1135      *</span>
<span class="line-added">1136      * @throws Exception</span>
<span class="line-added">1137      */</span>
<span class="line-added">1138     private static void generatePluralRules() throws Exception {</span>
<span class="line-added">1139         Files.createDirectories(Paths.get(DESTINATION_DIR, &quot;sun&quot;, &quot;text&quot;, &quot;resources&quot;));</span>
<span class="line-added">1140         Files.write(Paths.get(DESTINATION_DIR, &quot;sun&quot;, &quot;text&quot;, &quot;resources&quot;, &quot;PluralRules.java&quot;),</span>
<span class="line-added">1141             Stream.concat(</span>
<span class="line-added">1142                 Stream.concat(</span>
<span class="line-added">1143                     Stream.of(</span>
<span class="line-added">1144                         &quot;package sun.text.resources;&quot;,</span>
<span class="line-added">1145                         &quot;public final class PluralRules {&quot;,</span>
<span class="line-added">1146                         &quot;    public static final String[][] rulesArray = {&quot;</span>
<span class="line-added">1147                     ),</span>
<span class="line-added">1148                     pluralRulesStream().sorted()</span>
<span class="line-added">1149                 ),</span>
<span class="line-added">1150                 Stream.of(</span>
<span class="line-added">1151                     &quot;    };&quot;,</span>
<span class="line-added">1152                     &quot;}&quot;</span>
<span class="line-added">1153                 )</span>
<span class="line-added">1154             )</span>
<span class="line-added">1155             .collect(Collectors.toList()),</span>
<span class="line-added">1156         StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);</span>
<span class="line-added">1157     }</span>
<span class="line-added">1158 </span>
<span class="line-added">1159     private static Stream&lt;String&gt; pluralRulesStream() {</span>
<span class="line-added">1160         return handlerPlurals.getData().entrySet().stream()</span>
<span class="line-added">1161             .filter(e -&gt; !((Map&lt;String, String&gt;)e.getValue()).isEmpty())</span>
<span class="line-added">1162             .map(e -&gt; {</span>
<span class="line-added">1163                 String loc = e.getKey();</span>
<span class="line-added">1164                 Map&lt;String, String&gt; rules = (Map&lt;String, String&gt;)e.getValue();</span>
<span class="line-added">1165                 return &quot;        {\&quot;&quot; + loc + &quot;\&quot;, \&quot;&quot; +</span>
<span class="line-added">1166                     rules.entrySet().stream()</span>
<span class="line-added">1167                         .map(rule -&gt; rule.getKey() + &quot;:&quot; + rule.getValue().replaceFirst(&quot;@.*&quot;, &quot;&quot;))</span>
<span class="line-added">1168                         .map(String::trim)</span>
<span class="line-added">1169                         .collect(Collectors.joining(&quot;;&quot;)) + &quot;\&quot;},&quot;;</span>
<span class="line-added">1170             });</span>
<span class="line-added">1171     }</span>
<span class="line-added">1172 </span>
<span class="line-added">1173     // for debug</span>
<span class="line-added">1174     static void dumpMap(Map&lt;String, Object&gt; map) {</span>
<span class="line-added">1175         map.entrySet().stream()</span>
<span class="line-added">1176             .sorted(Map.Entry.comparingByKey())</span>
<span class="line-added">1177             .map(e -&gt; {</span>
<span class="line-added">1178                 Object val = e.getValue();</span>
<span class="line-added">1179                 String valStr = null;</span>
<span class="line-added">1180 </span>
<span class="line-added">1181                 if (val instanceof String[]) {</span>
<span class="line-added">1182                     valStr = Arrays.asList((String[])val).toString();</span>
<span class="line-added">1183                 } else if (val != null) {</span>
<span class="line-added">1184                     valStr = val.toString();</span>
<span class="line-added">1185                 }</span>
<span class="line-added">1186                 return e.getKey() + &quot; = &quot; + valStr;</span>
<span class="line-added">1187             })</span>
<span class="line-added">1188             .forEach(System.out::println);</span>
<span class="line-added">1189     }</span>
1190 }
<span class="line-added">1191 </span>
</pre>
</td>
</tr>
</table>
<center><a href="Bundle.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="LDMLParseHandler.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
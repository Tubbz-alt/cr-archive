<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/jdk/src/classes/build/tools/cldrconverter/Bundle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package build.tools.cldrconverter;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 import java.util.EnumSet;
 31 import java.util.HashMap;
 32 import java.util.Iterator;
 33 import java.util.List;
 34 import java.util.Map;
 35 import java.util.Objects;
<a name="2" id="anc2"></a>

 36 
 37 class Bundle {
 38     static enum Type {
 39         LOCALENAMES, CURRENCYNAMES, TIMEZONENAMES, CALENDARDATA, FORMATDATA;
 40 
 41         static EnumSet&lt;Type&gt; ALL_TYPES = EnumSet.of(LOCALENAMES,
 42                                                     CURRENCYNAMES,
 43                                                     TIMEZONENAMES,
 44                                                     CALENDARDATA,
 45                                                     FORMATDATA);
 46     }
 47 
 48     private final static Map&lt;String, Bundle&gt; bundles = new HashMap&lt;&gt;();
 49 
 50     private final static String[] NUMBER_PATTERN_KEYS = {
 51         &quot;NumberPatterns/decimal&quot;,
 52         &quot;NumberPatterns/currency&quot;,
<a name="3" id="anc3"></a><span class="line-modified"> 53         &quot;NumberPatterns/percent&quot;</span>

 54     };
 55 
 56     private final static String[] COMPACT_NUMBER_PATTERN_KEYS = {
 57             &quot;short.CompactNumberPatterns&quot;,
<a name="4" id="anc4"></a><span class="line-modified"> 58             &quot;long.CompactNumberPatterns&quot;};</span>

 59 
 60     private final static String[] NUMBER_ELEMENT_KEYS = {
 61         &quot;NumberElements/decimal&quot;,
 62         &quot;NumberElements/group&quot;,
 63         &quot;NumberElements/list&quot;,
 64         &quot;NumberElements/percent&quot;,
 65         &quot;NumberElements/zero&quot;,
 66         &quot;NumberElements/pattern&quot;,
 67         &quot;NumberElements/minus&quot;,
 68         &quot;NumberElements/exponential&quot;,
 69         &quot;NumberElements/permille&quot;,
 70         &quot;NumberElements/infinity&quot;,
<a name="5" id="anc5"></a><span class="line-modified"> 71         &quot;NumberElements/nan&quot;</span>


 72     };
 73 
 74     private final static String[] TIME_PATTERN_KEYS = {
 75         &quot;DateTimePatterns/full-time&quot;,
 76         &quot;DateTimePatterns/long-time&quot;,
 77         &quot;DateTimePatterns/medium-time&quot;,
 78         &quot;DateTimePatterns/short-time&quot;,
 79     };
 80 
 81     private final static String[] DATE_PATTERN_KEYS = {
 82         &quot;DateTimePatterns/full-date&quot;,
 83         &quot;DateTimePatterns/long-date&quot;,
 84         &quot;DateTimePatterns/medium-date&quot;,
 85         &quot;DateTimePatterns/short-date&quot;,
 86     };
 87 
 88     private final static String[] DATETIME_PATTERN_KEYS = {
 89         &quot;DateTimePatterns/full-dateTime&quot;,
 90         &quot;DateTimePatterns/long-dateTime&quot;,
 91         &quot;DateTimePatterns/medium-dateTime&quot;,
 92         &quot;DateTimePatterns/short-dateTime&quot;,
 93     };
 94 
 95     private final static String[] ERA_KEYS = {
 96         &quot;long.Eras&quot;,
 97         &quot;Eras&quot;,
 98         &quot;narrow.Eras&quot;
 99     };
100 
101     // Keys for individual time zone names
102     private final static String TZ_GEN_LONG_KEY = &quot;timezone.displayname.generic.long&quot;;
103     private final static String TZ_GEN_SHORT_KEY = &quot;timezone.displayname.generic.short&quot;;
104     private final static String TZ_STD_LONG_KEY = &quot;timezone.displayname.standard.long&quot;;
105     private final static String TZ_STD_SHORT_KEY = &quot;timezone.displayname.standard.short&quot;;
106     private final static String TZ_DST_LONG_KEY = &quot;timezone.displayname.daylight.long&quot;;
107     private final static String TZ_DST_SHORT_KEY = &quot;timezone.displayname.daylight.short&quot;;
108     private final static String[] ZONE_NAME_KEYS = {
109         TZ_STD_LONG_KEY,
110         TZ_STD_SHORT_KEY,
111         TZ_DST_LONG_KEY,
112         TZ_DST_SHORT_KEY,
113         TZ_GEN_LONG_KEY,
114         TZ_GEN_SHORT_KEY
115     };
116 
117     private final String id;
118     private final String cldrPath;
119     private final EnumSet&lt;Type&gt; bundleTypes;
120     private final String currencies;
121     private Map&lt;String, Object&gt; targetMap;
122 
123     static Bundle getBundle(String id) {
124         return bundles.get(id);
125     }
126 
127     @SuppressWarnings(&quot;ConvertToStringSwitch&quot;)
128     Bundle(String id, String cldrPath, String bundles, String currencies) {
129         this.id = id;
130         this.cldrPath = cldrPath;
131         if (&quot;localenames&quot;.equals(bundles)) {
132             bundleTypes = EnumSet.of(Type.LOCALENAMES);
133         } else if (&quot;currencynames&quot;.equals(bundles)) {
134             bundleTypes = EnumSet.of(Type.CURRENCYNAMES);
135         } else {
136             bundleTypes = Type.ALL_TYPES;
137         }
138         if (currencies == null) {
139             currencies = &quot;local&quot;;
140         }
141         this.currencies = currencies;
142         addBundle();
143     }
144 
145     private void addBundle() {
146         Bundle.bundles.put(id, this);
147     }
148 
149     String getID() {
150         return id;
151     }
152 
153     String getJavaID() {
154         // Tweak ISO compatibility for bundle generation
155         return id.replaceFirst(&quot;^he&quot;, &quot;iw&quot;)
156             .replaceFirst(&quot;^id&quot;, &quot;in&quot;)
157             .replaceFirst(&quot;^yi&quot;, &quot;ji&quot;);
158     }
159 
160     boolean isRoot() {
161         return &quot;root&quot;.equals(id);
162     }
163 
164     String getCLDRPath() {
165         return cldrPath;
166     }
167 
168     EnumSet&lt;Type&gt; getBundleTypes() {
169         return bundleTypes;
170     }
171 
172     String getCurrencies() {
173         return currencies;
174     }
175 
176     /**
177      * Generate a map that contains all the data that should be
178      * visible for the bundle&#39;s locale
179      */
180     Map&lt;String, Object&gt; getTargetMap() throws Exception {
181         if (targetMap != null) {
182             return targetMap;
183         }
184 
185         String[] cldrBundles = getCLDRPath().split(&quot;,&quot;);
186 
187         // myMap contains resources for id.
188         Map&lt;String, Object&gt; myMap = new HashMap&lt;&gt;();
189         int index;
190         for (index = 0; index &lt; cldrBundles.length; index++) {
191             if (cldrBundles[index].equals(id)) {
192                 myMap.putAll(CLDRConverter.getCLDRBundle(cldrBundles[index]));
<a name="6" id="anc6"></a><span class="line-removed">193                 CLDRConverter.handleAliases(myMap);</span>
194                 break;
195             }
196         }
197 
198         // parentsMap contains resources from id&#39;s parents.
199         Map&lt;String, Object&gt; parentsMap = new HashMap&lt;&gt;();
200         for (int i = cldrBundles.length - 1; i &gt; index; i--) {
201             if (!(&quot;no&quot;.equals(cldrBundles[i]) || cldrBundles[i].startsWith(&quot;no_&quot;))) {
202                 parentsMap.putAll(CLDRConverter.getCLDRBundle(cldrBundles[i]));
<a name="7" id="anc7"></a><span class="line-removed">203                 CLDRConverter.handleAliases(parentsMap);</span>
204             }
205         }
206         // Duplicate myMap as parentsMap for &quot;root&quot; so that the
207         // fallback works. This is a hack, though.
208         if (&quot;root&quot;.equals(cldrBundles[0])) {
209             assert parentsMap.isEmpty();
210             parentsMap.putAll(myMap);
211         }
212 
213         // merge individual strings into arrays
214 
<a name="8" id="anc8"></a><span class="line-modified">215         // if myMap has any of the NumberPatterns members</span>
<span class="line-modified">216         for (String k : NUMBER_PATTERN_KEYS) {</span>
<span class="line-modified">217             if (myMap.containsKey(k)) {</span>
<span class="line-modified">218                 String[] numberPatterns = new String[NUMBER_PATTERN_KEYS.length];</span>
<span class="line-modified">219                 for (int i = 0; i &lt; NUMBER_PATTERN_KEYS.length; i++) {</span>
<span class="line-modified">220                     String key = NUMBER_PATTERN_KEYS[i];</span>
<span class="line-modified">221                     String value = (String) myMap.remove(key);</span>
<span class="line-modified">222                     if (value == null) {</span>
<span class="line-modified">223                         value = (String) parentsMap.remove(key);</span>
<span class="line-modified">224                     }</span>
<span class="line-removed">225                     if (value.length() == 0) {</span>
<span class="line-removed">226                         CLDRConverter.warning(&quot;empty pattern for &quot; + key);</span>
<span class="line-removed">227                     }</span>
<span class="line-removed">228                     numberPatterns[i] = value;</span>
<span class="line-removed">229                 }</span>
<span class="line-removed">230                 myMap.put(&quot;NumberPatterns&quot;, numberPatterns);</span>
<span class="line-removed">231                 break;</span>
232             }
233         }
234 
235         for (String k : COMPACT_NUMBER_PATTERN_KEYS) {
236             List&lt;String&gt; patterns = (List&lt;String&gt;) myMap.remove(k);
237             if (patterns != null) {
<a name="9" id="anc9"></a><span class="line-modified">238                 // Replace any null entry with empty strings.</span>
<span class="line-modified">239                 String[] arrPatterns = patterns.stream()</span>
<span class="line-modified">240                         .map(s -&gt; s == null ? &quot;&quot; : s).toArray(String[]::new);</span>
<span class="line-modified">241                 myMap.put(k, arrPatterns);</span>
<span class="line-modified">242             }</span>
<span class="line-modified">243         }</span>
<span class="line-modified">244 </span>
<span class="line-modified">245         // if myMap has any of NUMBER_ELEMENT_KEYS, create a complete NumberElements.</span>
<span class="line-modified">246         String defaultScript = (String) myMap.get(&quot;DefaultNumberingSystem&quot;);</span>
<span class="line-modified">247         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">248         List&lt;String&gt; scripts = (List&lt;String&gt;) myMap.get(&quot;numberingScripts&quot;);</span>
<span class="line-modified">249         if (defaultScript == null &amp;&amp; scripts != null) {</span>
<span class="line-modified">250             // Some locale data has no default script for numbering even with mutiple scripts.</span>
<span class="line-removed">251             // Take the first one as default in that case.</span>
<span class="line-removed">252             defaultScript = scripts.get(0);</span>
<span class="line-removed">253             myMap.put(&quot;DefaultNumberingSystem&quot;, defaultScript);</span>
<span class="line-removed">254         }</span>
<span class="line-removed">255         if (scripts != null) {</span>
<span class="line-removed">256             for (String script : scripts) {</span>
<span class="line-removed">257                 for (String k : NUMBER_ELEMENT_KEYS) {</span>
<span class="line-removed">258                     String[] numberElements = new String[NUMBER_ELEMENT_KEYS.length];</span>
<span class="line-removed">259                     for (int i = 0; i &lt; NUMBER_ELEMENT_KEYS.length; i++) {</span>
<span class="line-removed">260                         String key = script + &quot;.&quot; + NUMBER_ELEMENT_KEYS[i];</span>
<span class="line-removed">261                         String value = (String) myMap.remove(key);</span>
<span class="line-removed">262                         if (value == null) {</span>
<span class="line-removed">263                             if (key.endsWith(&quot;/pattern&quot;)) {</span>
<span class="line-removed">264                                 value = &quot;#&quot;;</span>
<span class="line-removed">265                             } else {</span>
<span class="line-removed">266                                 value = (String) parentsMap.get(key);</span>
<span class="line-removed">267                                 if (value == null) {</span>
<span class="line-removed">268                                     // the last resort is &quot;latn&quot;</span>
<span class="line-removed">269                                     key = &quot;latn.&quot; + NUMBER_ELEMENT_KEYS[i];</span>
<span class="line-removed">270                                     value = (String) parentsMap.get(key);</span>
<span class="line-removed">271                                     if (value == null) {</span>
<span class="line-removed">272                                         throw new InternalError(&quot;NumberElements: null for &quot; + key);</span>
<span class="line-removed">273                                     }</span>
<span class="line-removed">274                                 }</span>
275                             }
276                         }
<a name="10" id="anc10"></a><span class="line-modified">277                         numberElements[i] = value;</span>
<span class="line-modified">278                     }</span>
<span class="line-modified">279                     myMap.put(script + &quot;.&quot; + &quot;NumberElements&quot;, numberElements);</span>
<span class="line-modified">280                     break;</span>
<span class="line-modified">281                 }</span>







282             }
283         }
284 
<a name="11" id="anc11"></a>


285         // another hack: parentsMap is not used for date-time resources.
286         if (&quot;root&quot;.equals(id)) {
287             parentsMap = null;
288         }
289 
290         for (CalendarType calendarType : CalendarType.values()) {
291             String calendarPrefix = calendarType.keyElementName();
292             // handle multiple inheritance for month and day names
293             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNames&quot;);
294             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthAbbreviations&quot;);
295             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNarrows&quot;);
296             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNames&quot;);
297             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayAbbreviations&quot;);
298             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNarrows&quot;);
299             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;AmPmMarkers&quot;);
300             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;narrow.AmPmMarkers&quot;);
301             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;abbreviated.AmPmMarkers&quot;);
302             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNames&quot;);
303             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterAbbreviations&quot;);
304             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNarrows&quot;);
305 
306             adjustEraNames(myMap, calendarType);
307 
308             handleDateTimeFormatPatterns(TIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;TimePatterns&quot;);
309             handleDateTimeFormatPatterns(DATE_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DatePatterns&quot;);
310             handleDateTimeFormatPatterns(DATETIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DateTimePatterns&quot;);
311         }
312 
313         // First, weed out any empty timezone or metazone names from myMap.
<a name="12" id="anc12"></a><span class="line-removed">314         // Fill in any missing abbreviations if locale is &quot;en&quot;.</span>
315         for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
316             String key = it.next();
317             if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
318                     || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
319                 @SuppressWarnings(&quot;unchecked&quot;)
320                 Map&lt;String, String&gt; nameMap = (Map&lt;String, String&gt;) myMap.get(key);
321                 if (nameMap.isEmpty()) {
322                     // Some zones have only exemplarCity, which become empty.
323                     // Remove those from the map.
324                     it.remove();
325                     continue;
326                 }
<a name="13" id="anc13"></a><span class="line-removed">327 </span>
<span class="line-removed">328                 if (id.equals(&quot;en&quot;)) {</span>
<span class="line-removed">329                     fillInJREs(key, nameMap);</span>
<span class="line-removed">330                 }</span>
331             }
332         }
333         for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
334             String key = it.next();
335                 if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
336                     || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
337                 @SuppressWarnings(&quot;unchecked&quot;)
338                 Map&lt;String, String&gt; nameMap = (Map&lt;String, String&gt;) myMap.get(key);
339 
340                 // Convert key/value pairs to an array.
341                 String[] names = new String[ZONE_NAME_KEYS.length];
342                 int ix = 0;
343                 for (String nameKey : ZONE_NAME_KEYS) {
344                     String name = nameMap.get(nameKey);
345                     if (name == null &amp;&amp; parentsMap != null) {
346                         @SuppressWarnings(&quot;unchecked&quot;)
347                         Map&lt;String, String&gt; parentNames = (Map&lt;String, String&gt;) parentsMap.get(key);
348                         if (parentNames != null) {
349                             name = parentNames.get(nameKey);
350                         }
351                     }
352                     names[ix++] = name;
353                 }
354                 if (hasNulls(names)) {
355                     String metaKey = toMetaZoneKey(key);
356                     if (metaKey != null) {
357                         Object obj = myMap.get(metaKey);
358                         if (obj instanceof String[]) {
359                             String[] metaNames = (String[]) obj;
360                             for (int i = 0; i &lt; names.length; i++) {
361                                 if (names[i] == null) {
362                                     names[i] = metaNames[i];
363                                 }
364                             }
365                         } else if (obj instanceof Map) {
366                             @SuppressWarnings(&quot;unchecked&quot;)
367                             Map&lt;String, String&gt; m = (Map&lt;String, String&gt;) obj;
368                             for (int i = 0; i &lt; names.length; i++) {
369                                 if (names[i] == null) {
370                                     names[i] = m.get(ZONE_NAME_KEYS[i]);
371                                 }
372                             }
373                         }
374                     }
375                 }
376                 // replace the Map with the array
377                 if (names != null) {
378                     myMap.put(key, names);
379                 } else {
380                     it.remove();
381                 }
382             }
383         }
384         // replace empty era names with parentMap era names
385         for (String key : ERA_KEYS) {
386             Object value = myMap.get(key);
387             if (value != null &amp;&amp; value instanceof String[]) {
388                 String[] eraStrings = (String[]) value;
389                 for (String eraString : eraStrings) {
390                     if (eraString == null || eraString.isEmpty()) {
391                         fillInElements(parentsMap, key, value);
392                     }
393                 }
394             }
395         }
396 
397         // Remove all duplicates
398         if (Objects.nonNull(parentsMap)) {
399             for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
400                 String key = it.next();
401                 if (!key.equals(&quot;numberingScripts&quot;) &amp;&amp; // real body &quot;NumberElements&quot; may differ
402                     Objects.deepEquals(parentsMap.get(key), myMap.get(key))) {
403                     it.remove();
404                 }
405             }
406         }
407 
408         targetMap = myMap;
409         return myMap;
410     }
411 
412     private void handleMultipleInheritance(Map&lt;String, Object&gt; map, Map&lt;String, Object&gt; parents, String key) {
<a name="14" id="anc14"></a><span class="line-modified">413         String formatKey = key + &quot;/format&quot;;</span>
<span class="line-modified">414         Object format = map.get(formatKey);</span>
415         if (format != null) {
<a name="15" id="anc15"></a><span class="line-modified">416             map.remove(formatKey);</span>
417             map.put(key, format);
<a name="16" id="anc16"></a><span class="line-modified">418             if (fillInElements(parents, formatKey, format)) {</span>
419                 map.remove(key);
420             }
421         }
<a name="17" id="anc17"></a><span class="line-modified">422         String standaloneKey = key + &quot;/stand-alone&quot;;</span>
<span class="line-modified">423         Object standalone = map.get(standaloneKey);</span>
424         if (standalone != null) {
<a name="18" id="anc18"></a><span class="line-modified">425             map.remove(standaloneKey);</span>
<span class="line-modified">426             String realKey = key;</span>
<span class="line-modified">427             if (format != null) {</span>
<span class="line-modified">428                 realKey = &quot;standalone.&quot; + key;</span>
<span class="line-modified">429             }</span>
<span class="line-removed">430             map.put(realKey, standalone);</span>
<span class="line-removed">431             if (fillInElements(parents, standaloneKey, standalone)) {</span>
<span class="line-removed">432                 map.remove(realKey);</span>
433             }
434         }
435     }
436 
437     /**
438      * Fills in any empty elements with its parent element. Returns true if the resulting array is
439      * identical to its parent array.
440      *
441      * @param parents
442      * @param key
443      * @param value
444      * @return true if the resulting array is identical to its parent array.
445      */
446     private boolean fillInElements(Map&lt;String, Object&gt; parents, String key, Object value) {
447         if (parents == null) {
448             return false;
449         }
450         if (value instanceof String[]) {
451             Object pvalue = parents.get(key);
452             if (pvalue != null &amp;&amp; pvalue instanceof String[]) {
453                 String[] strings = (String[]) value;
454                 String[] pstrings = (String[]) pvalue;
455                 for (int i = 0; i &lt; strings.length; i++) {
456                     if (strings[i] == null || strings[i].length() == 0) {
457                         strings[i] = pstrings[i];
458                     }
459                 }
460                 return Arrays.equals(strings, pstrings);
461             }
462         }
463         return false;
464     }
465 
466     /*
467      * Adjusts String[] for era names because JRE&#39;s Calendars use different
468      * ERA value indexes in the Buddhist, Japanese Imperial, and Islamic calendars.
469      */
470     private void adjustEraNames(Map&lt;String, Object&gt; map, CalendarType type) {
471         String[][] eraNames = new String[ERA_KEYS.length][];
472         String[] realKeys = new String[ERA_KEYS.length];
473         int index = 0;
474         for (String key : ERA_KEYS) {
475             String realKey = type.keyElementName() + key;
476             String[] value = (String[]) map.get(realKey);
477             if (value != null) {
478                 switch (type) {
479                 case GREGORIAN:
480                     break;
481 
482                 case JAPANESE:
483                     {
484                         String[] newValue = new String[value.length + 1];
485                         String[] julianEras = (String[]) map.get(key);
486                         if (julianEras != null &amp;&amp; julianEras.length &gt;= 2) {
487                             newValue[0] = julianEras[1];
488                         } else {
489                             newValue[0] = &quot;&quot;;
490                         }
491                         System.arraycopy(value, 0, newValue, 1, value.length);
492                         value = newValue;
<a name="19" id="anc19"></a>




493                     }
494                     break;
495 
496                 case BUDDHIST:
497                     // Replace the value
498                     value = new String[] {&quot;BC&quot;, value[0]};
499                     break;
500 
501                 case ISLAMIC:
502                     // Replace the value
503                     value = new String[] {&quot;&quot;, value[0]};
504                     break;
505                 }
506                 if (!key.equals(realKey)) {
507                     map.put(realKey, value);
<a name="20" id="anc20"></a>
508                 }
509             }
510             realKeys[index] = realKey;
511             eraNames[index++] = value;
512         }
513         for (int i = 0; i &lt; eraNames.length; i++) {
514             if (eraNames[i] == null) {
515                 map.put(realKeys[i], null);
516             }
517         }
518     }
519 
520     private void handleDateTimeFormatPatterns(String[] patternKeys, Map&lt;String, Object&gt; myMap, Map&lt;String, Object&gt; parentsMap,
521                                               CalendarType calendarType, String name) {
522         String calendarPrefix = calendarType.keyElementName();
523         for (String k : patternKeys) {
524             if (myMap.containsKey(calendarPrefix + k)) {
525                 int len = patternKeys.length;
526                 List&lt;String&gt; dateTimePatterns = new ArrayList&lt;&gt;(len);
527                 List&lt;String&gt; sdfPatterns = new ArrayList&lt;&gt;(len);
528                 for (int i = 0; i &lt; len; i++) {
529                     String key = calendarPrefix + patternKeys[i];
530                     String pattern = (String) myMap.remove(key);
531                     if (pattern == null) {
532                         pattern = (String) parentsMap.remove(key);
533                     }
534                     if (pattern != null) {
535                         // Perform date-time format pattern conversion which is
536                         // applicable to both SimpleDateFormat and j.t.f.DateTimeFormatter.
537                         // For example, character &#39;B&#39; is mapped with &#39;a&#39;, as &#39;B&#39; is not
538                         // supported in either SimpleDateFormat or j.t.f.DateTimeFormatter
539                         String transPattern = translateDateFormatLetters(calendarType, pattern, this::convertDateTimePatternLetter);
540                         dateTimePatterns.add(i, transPattern);
541                         // Additionally, perform SDF specific date-time format pattern conversion
542                         sdfPatterns.add(i, translateDateFormatLetters(calendarType, transPattern, this::convertSDFLetter));
543                     } else {
544                         dateTimePatterns.add(i, null);
545                         sdfPatterns.add(i, null);
546                     }
547                 }
548                 // If empty, discard patterns
549                 if (sdfPatterns.isEmpty()) {
550                     return;
551                 }
552                 String key = calendarPrefix + name;
553 
554                 // If additional changes are made in the SDF specific conversion,
555                 // keep the commonly converted patterns as java.time patterns
556                 if (!dateTimePatterns.equals(sdfPatterns)) {
557                     myMap.put(&quot;java.time.&quot; + key, dateTimePatterns.toArray(String[]::new));
558                 }
559                 myMap.put(key, sdfPatterns.toArray(new String[len]));
560                 break;
561             }
562         }
563     }
564 
565     private String translateDateFormatLetters(CalendarType calendarType, String cldrFormat, ConvertDateTimeLetters converter) {
566         String pattern = cldrFormat;
567         int length = pattern.length();
568         boolean inQuote = false;
569         StringBuilder jrePattern = new StringBuilder(length);
570         int count = 0;
571         char lastLetter = 0;
572 
573         for (int i = 0; i &lt; length; i++) {
574             char c = pattern.charAt(i);
575 
576             if (c == &#39;\&#39;&#39;) {
577                 // &#39;&#39; is treated as a single quote regardless of being
578                 // in a quoted section.
579                 if ((i + 1) &lt; length) {
580                     char nextc = pattern.charAt(i + 1);
581                     if (nextc == &#39;\&#39;&#39;) {
582                         i++;
583                         if (count != 0) {
584                             converter.convert(calendarType, lastLetter, count, jrePattern);
585                             lastLetter = 0;
586                             count = 0;
587                         }
588                         jrePattern.append(&quot;&#39;&#39;&quot;);
589                         continue;
590                     }
591                 }
592                 if (!inQuote) {
593                     if (count != 0) {
594                         converter.convert(calendarType, lastLetter, count, jrePattern);
595                         lastLetter = 0;
596                         count = 0;
597                     }
598                     inQuote = true;
599                 } else {
600                     inQuote = false;
601                 }
602                 jrePattern.append(c);
603                 continue;
604             }
605             if (inQuote) {
606                 jrePattern.append(c);
607                 continue;
608             }
609             if (!(c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39; || c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;)) {
610                 if (count != 0) {
611                     converter.convert(calendarType, lastLetter, count, jrePattern);
612                     lastLetter = 0;
613                     count = 0;
614                 }
615                 jrePattern.append(c);
616                 continue;
617             }
618 
619             if (lastLetter == 0 || lastLetter == c) {
620                 lastLetter = c;
621                 count++;
622                 continue;
623             }
624             converter.convert(calendarType, lastLetter, count, jrePattern);
625             lastLetter = c;
626             count = 1;
627         }
628 
629         if (inQuote) {
630             throw new InternalError(&quot;Unterminated quote in date-time pattern: &quot; + cldrFormat);
631         }
632 
633         if (count != 0) {
634             converter.convert(calendarType, lastLetter, count, jrePattern);
635         }
636         if (cldrFormat.contentEquals(jrePattern)) {
637             return cldrFormat;
638         }
639         return jrePattern.toString();
640     }
641 
642     private String toMetaZoneKey(String tzKey) {
643         if (tzKey.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)) {
644             String tz = tzKey.substring(CLDRConverter.TIMEZONE_ID_PREFIX.length());
645             String meta = CLDRConverter.handlerMetaZones.get(tz);
646             if (meta != null) {
647                 return CLDRConverter.METAZONE_ID_PREFIX + meta;
648             }
649         }
650         return null;
651     }
652 
<a name="21" id="anc21"></a><span class="line-removed">653     static List&lt;Object[]&gt; jreTimeZoneNames = Arrays.asList(TimeZoneNames.getContents());</span>
<span class="line-removed">654     private void fillInJREs(String key, Map&lt;String, String&gt; map) {</span>
<span class="line-removed">655         String tzid = null;</span>
<span class="line-removed">656 </span>
<span class="line-removed">657         if (key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {</span>
<span class="line-removed">658             // Look for tzid</span>
<span class="line-removed">659             String meta = key.substring(CLDRConverter.METAZONE_ID_PREFIX.length());</span>
<span class="line-removed">660             if (meta.equals(&quot;GMT&quot;)) {</span>
<span class="line-removed">661                 tzid = meta;</span>
<span class="line-removed">662             } else {</span>
<span class="line-removed">663                 for (String tz : CLDRConverter.handlerMetaZones.keySet()) {</span>
<span class="line-removed">664                     if (CLDRConverter.handlerMetaZones.get(tz).equals(meta)) {</span>
<span class="line-removed">665                         tzid = tz;</span>
<span class="line-removed">666                         break;</span>
<span class="line-removed">667                     }</span>
<span class="line-removed">668                 }</span>
<span class="line-removed">669             }</span>
<span class="line-removed">670         } else {</span>
<span class="line-removed">671             tzid = key.substring(CLDRConverter.TIMEZONE_ID_PREFIX.length());</span>
<span class="line-removed">672         }</span>
<span class="line-removed">673 </span>
<span class="line-removed">674         if (tzid != null) {</span>
<span class="line-removed">675             for (Object[] jreZone : jreTimeZoneNames) {</span>
<span class="line-removed">676                 if (jreZone[0].equals(tzid)) {</span>
<span class="line-removed">677                     for (int i = 0; i &lt; ZONE_NAME_KEYS.length; i++) {</span>
<span class="line-removed">678                         if (map.get(ZONE_NAME_KEYS[i]) == null) {</span>
<span class="line-removed">679                             String[] jreNames = (String[])jreZone[1];</span>
<span class="line-removed">680                             map.put(ZONE_NAME_KEYS[i], jreNames[i]);</span>
<span class="line-removed">681                         }</span>
<span class="line-removed">682                     }</span>
<span class="line-removed">683                     break;</span>
<span class="line-removed">684                 }</span>
<span class="line-removed">685             }</span>
<span class="line-removed">686         }</span>
<span class="line-removed">687     }</span>
<span class="line-removed">688 </span>
689     /**
690      * Perform a generic conversion of CLDR date-time format pattern letter based
691      * on the support given by the SimpleDateFormat and the j.t.f.DateTimeFormatter
692      * for date-time formatting.
693      */
694     private void convertDateTimePatternLetter(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb) {
695         switch (cldrLetter) {
696             case &#39;u&#39;:
697                 // Change cldr letter &#39;u&#39; to &#39;y&#39;, as &#39;u&#39; is interpreted as
698                 // &quot;Extended year (numeric)&quot; in CLDR/LDML,
699                 // which is not supported in SimpleDateFormat and
700                 // j.t.f.DateTimeFormatter, so it is replaced with &#39;y&#39;
701                 // as the best approximation
702                 appendN(&#39;y&#39;, count, sb);
703                 break;
704             case &#39;B&#39;:
705                 // &#39;B&#39; character (day period) is not supported by
706                 // SimpleDateFormat and j.t.f.DateTimeFormatter,
707                 // this is a workaround in which &#39;B&#39; character
708                 // appearing in CLDR date-time pattern is replaced
709                 // with &#39;a&#39; character and hence resolved with am/pm strings.
710                 // This workaround is based on the the fallback mechanism
711                 // specified in LDML spec for &#39;B&#39; character, when a locale
712                 // does not have data for day period (&#39;B&#39;)
713                 appendN(&#39;a&#39;, count, sb);
714                 break;
715             default:
716                 appendN(cldrLetter, count, sb);
717                 break;
718 
719         }
720     }
721 
722     /**
723      * Perform a conversion of CLDR date-time format pattern letter which is
724      * specific to the SimpleDateFormat.
725      */
726     private void convertSDFLetter(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb) {
727         switch (cldrLetter) {
728             case &#39;G&#39;:
729                 if (calendarType != CalendarType.GREGORIAN) {
730                     // Adjust the number of &#39;G&#39;s for JRE SimpleDateFormat
731                     if (count == 5) {
732                         // CLDR narrow -&gt; JRE short
733                         count = 1;
734                     } else if (count == 1) {
735                         // CLDR abbr -&gt; JRE long
736                         count = 4;
737                     }
738                 }
739                 appendN(cldrLetter, count, sb);
740                 break;
741 
742             // TODO: support &#39;c&#39; and &#39;e&#39; in JRE SimpleDateFormat
743             // Use &#39;u&#39; and &#39;E&#39; for now.
744             case &#39;c&#39;:
745             case &#39;e&#39;:
746                 switch (count) {
747                     case 1:
748                         sb.append(&#39;u&#39;);
749                         break;
750                     case 3:
751                     case 4:
752                         appendN(&#39;E&#39;, count, sb);
753                         break;
754                     case 5:
755                         appendN(&#39;E&#39;, 3, sb);
756                         break;
757                 }
758                 break;
759 
760             case &#39;v&#39;:
761             case &#39;V&#39;:
762                 appendN(&#39;z&#39;, count, sb);
763                 break;
764 
765             case &#39;Z&#39;:
766                 if (count == 4 || count == 5) {
767                     sb.append(&quot;XXX&quot;);
768                 }
769                 break;
770 
771             default:
772                 appendN(cldrLetter, count, sb);
773                 break;
774         }
775     }
776 
777     private void appendN(char c, int n, StringBuilder sb) {
778         for (int i = 0; i &lt; n; i++) {
779             sb.append(c);
780         }
781     }
782 
783     private static boolean hasNulls(Object[] array) {
784         for (int i = 0; i &lt; array.length; i++) {
785             if (array[i] == null) {
786                 return true;
787             }
788         }
789         return false;
790     }
791 
792     @FunctionalInterface
793     private interface ConvertDateTimeLetters {
794         void convert(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb);
795     }
<a name="22" id="anc22"></a>











































796 }
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
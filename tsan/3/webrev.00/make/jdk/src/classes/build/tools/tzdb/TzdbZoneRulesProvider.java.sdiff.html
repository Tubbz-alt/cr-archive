<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/jdk/src/classes/build/tools/tzdb/TzdbZoneRulesProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="TzdbZoneRulesCompiler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../langtools/tools/propertiesparser/resources/templates.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/jdk/src/classes/build/tools/tzdb/TzdbZoneRulesProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 package build.tools.tzdb;
 28 
 29 import java.io.IOException;
 30 import java.nio.charset.StandardCharsets;
 31 import java.nio.file.Files;
 32 import java.nio.file.Path;
 33 import java.nio.file.Paths;
<span class="line-modified"> 34 import java.util.ArrayList;</span>
<span class="line-removed"> 35 import java.util.Collections;</span>
<span class="line-removed"> 36 import java.util.List;</span>
<span class="line-removed"> 37 import java.util.Map;</span>
 38 import java.util.Map.Entry;
<span class="line-removed"> 39 import java.util.NavigableMap;</span>
<span class="line-removed"> 40 import java.util.Objects;</span>
<span class="line-removed"> 41 import java.util.Set;</span>
<span class="line-removed"> 42 import java.util.TreeMap;</span>
<span class="line-removed"> 43 import java.util.TreeSet;</span>
 44 import java.util.concurrent.ConcurrentSkipListMap;
 45 import java.time.*;
 46 import java.time.Year;
 47 import java.time.chrono.IsoChronology;
 48 import java.time.temporal.TemporalAdjusters;
<span class="line-modified"> 49 import java.time.zone.ZoneOffsetTransition;</span>
<span class="line-removed"> 50 import java.time.zone.ZoneOffsetTransitionRule;</span>
<span class="line-removed"> 51 import java.time.zone.ZoneOffsetTransitionRule.TimeDefinition;</span>
 52 import java.time.zone.ZoneRulesException;
 53 
 54 /**
 55  * Compile and build time-zone rules from IANA timezone data
 56  *
 57  * @author Xueming Shen
 58  * @author Stephen Colebourne
 59  * @author Michael Nascimento Santos
 60  *
 61  * @since   9
 62  */
 63 
 64 class TzdbZoneRulesProvider {
 65 
 66     /**
 67      * Creates an instance.
 68      *
 69      * @throws ZoneRulesException if unable to load
 70      */
 71     public TzdbZoneRulesProvider(List&lt;Path&gt; files) {
</pre>
<hr />
<pre>
255      * Class representing a month-day-time in the TZDB file.
256      */
257     private static abstract class MonthDayTime {
258         /** The month of the cutover. */
259         Month month = Month.JANUARY;
260 
261         /** The day-of-month of the cutover. */
262         int dayOfMonth = 1;
263 
264         /** Whether to adjust forwards. */
265         boolean adjustForwards = true;
266 
267         /** The day-of-week of the cutover. */
268         DayOfWeek dayOfWeek;
269 
270         /** The time of the cutover, in second of day */
271         int secsOfDay = 0;
272 
273         /** Whether this is midnight end of day. */
274         boolean endOfDay;
<span class="line-removed">275         /** The time of the cutover. */</span>
276 

277         TimeDefinition timeDefinition = TimeDefinition.WALL;
278 
279         void adjustToForwards(int year) {
280             if (adjustForwards == false &amp;&amp; dayOfMonth &gt; 0) {
281                 // weekDay&lt;=monthDay case, don&#39;t have it in tzdb data for now
282                 LocalDate adjustedDate = LocalDate.of(year, month, dayOfMonth).minusDays(6);
283                 dayOfMonth = adjustedDate.getDayOfMonth();
284                 month = adjustedDate.getMonth();
285                 adjustForwards = true;
286             }
287         }
288 
289         LocalDateTime toDateTime(int year) {
290             LocalDate date;
291             if (dayOfMonth &lt; 0) {
292                 int monthLen = month.length(IsoChronology.INSTANCE.isLeapYear(year));
293                 date = LocalDate.of(year, month, monthLen + 1 + dayOfMonth);
294                 if (dayOfWeek != null) {
295                     date = date.with(TemporalAdjusters.previousOrSame(dayOfWeek));
296                 }
</pre>
<hr />
<pre>
326                         index = dayRule.indexOf(&quot;&lt;=&quot;);
327                         if (index &gt; 0) {
328                             dayOfWeek = parseDayOfWeek(dayRule.substring(0, index));
329                             adjustForwards = false;
330                             dayRule = dayRule.substring(index + 2);
331                         }
332                     }
333                     dayOfMonth = Integer.parseInt(dayRule);
334                     if (dayOfMonth &lt; -28 || dayOfMonth &gt; 31 || dayOfMonth == 0) {
335                        throw new IllegalArgumentException(
336                           &quot;Day of month indicator must be between -28 and 31 inclusive excluding zero&quot;);
337                     }
338                 }
339                 if (off &lt; tokens.length) {
340                     String timeStr = tokens[off++];
341                     secsOfDay = parseSecs(timeStr);
342                     if (secsOfDay == 86400) {
343                         // time must be midnight when end of day flag is true
344                         endOfDay = true;
345                         secsOfDay = 0;














346                     }
347                     timeDefinition = parseTimeDefinition(timeStr.charAt(timeStr.length() - 1));
348                 }
349             }
350         }
351 
352         int parseYear(String year, int defaultYear) {
353             switch (year.toLowerCase()) {
354             case &quot;min&quot;:  return 1900;
355             case &quot;max&quot;:  return Year.MAX_VALUE;
356             case &quot;only&quot;: return defaultYear;
357             }
358             return Integer.parseInt(year);
359         }
360 
361         Month parseMonth(String mon) {
362             switch (mon) {
363             case &quot;Jan&quot;: return Month.JANUARY;
364             case &quot;Feb&quot;: return Month.FEBRUARY;
365             case &quot;Mar&quot;: return Month.MARCH;
</pre>
<hr />
<pre>
480      * Class representing a rule line in the TZDB file.
481      */
482     private static class RuleLine extends MonthDayTime {
483         /** The start year. */
484         int startYear;
485 
486         /** The end year. */
487         int endYear;
488 
489         /** The amount of savings, in seconds. */
490         int savingsAmount;
491 
492         /** The text name of the zone. */
493         String text;
494 
495         /**
496          * Converts this to a transition rule.
497          *
498          * @param standardOffset  the active standard offset, not null
499          * @param savingsBeforeSecs  the active savings before the transition in seconds


500          * @return the transition, not null
501         */
<span class="line-modified">502         ZoneOffsetTransitionRule toTransitionRule(ZoneOffset stdOffset, int savingsBefore) {</span>
503             // rule shared by different zones, so don&#39;t change it
504             Month month = this.month;
505             int dayOfMonth = this.dayOfMonth;
506             DayOfWeek dayOfWeek = this.dayOfWeek;
507             boolean endOfDay = this.endOfDay;
508 
509             // optimize stored format
510             if (dayOfMonth &lt; 0) {
511                 if (month != Month.FEBRUARY) {    // not Month.FEBRUARY
512                     dayOfMonth = month.maxLength() - 6;
513                 }
514             }
515             if (endOfDay &amp;&amp; dayOfMonth &gt; 0 &amp;&amp;
516                 (dayOfMonth == 28 &amp;&amp; month == Month.FEBRUARY) == false) {
517                 LocalDate date = LocalDate.of(2004, month, dayOfMonth).plusDays(1);  // leap-year
518                 month = date.getMonth();
519                 dayOfMonth = date.getDayOfMonth();
520                 if (dayOfWeek != null) {
521                     dayOfWeek = dayOfWeek.plus(1);
522                 }
523                 endOfDay = false;
524             }

525             // build rule
526             return ZoneOffsetTransitionRule.of(
527                     //month, dayOfMonth, dayOfWeek, time, endOfDay, timeDefinition,
528                     month, dayOfMonth, dayOfWeek,
529                     LocalTime.ofSecondOfDay(secsOfDay), endOfDay, timeDefinition,
530                     stdOffset,
531                     ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savingsBefore),
<span class="line-modified">532                     ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savingsAmount));</span>
533         }
534 
535         RuleLine parse(String[] tokens) {
536             startYear = parseYear(tokens[2], 0);
537             endYear = parseYear(tokens[3], startYear);
538             if (startYear &gt; endYear) {
539                 throw new IllegalArgumentException(
540                     &quot;Invalid &lt;Rule&gt; line/Year order invalid:&quot; + startYear + &quot; &gt; &quot; + endYear);
541             }
542             //parseOptional(s.next());  // type is unused
543             super.parse(tokens, 5);     // monthdaytime parsing
544             savingsAmount = parsePeriod(tokens[8]);
545             //rule.text = parseOptional(s.next());
546             return this;
547         }
548     }
549 
550     /**
551      * Class representing a linked set of zone lines in the TZDB file.
552      */
</pre>
<hr />
<pre>
626      * Class representing a rule line in the TZDB file for a particular year.
627      */
628     private static class TransRule implements Comparable&lt;TransRule&gt;
629     {
630         private int year;
631         private RuleLine rule;
632 
633         /** The trans date/time */
634         private LocalDateTime ldt;
635 
636         /** The trans date/time in epoch seconds (assume UTC) */
637         long ldtSecs;
638 
639         TransRule(int year, RuleLine rule) {
640             this.year = year;
641             this.rule = rule;
642             this.ldt = rule.toDateTime(year);
643             this.ldtSecs = ldt.toEpochSecond(ZoneOffset.UTC);
644         }
645 
<span class="line-modified">646         ZoneOffsetTransition toTransition(ZoneOffset standardOffset, int savingsBeforeSecs) {</span>
647             // copy of code in ZoneOffsetTransitionRule to avoid infinite loop
648             ZoneOffset wallOffset = ZoneOffset.ofTotalSeconds(
649                 standardOffset.getTotalSeconds() + savingsBeforeSecs);
650             ZoneOffset offsetAfter = ZoneOffset.ofTotalSeconds(
<span class="line-modified">651                 standardOffset.getTotalSeconds() + rule.savingsAmount);</span>
652             LocalDateTime dt = rule.timeDefinition
653                                    .createDateTime(ldt, standardOffset, wallOffset);
654             return ZoneOffsetTransition.of(dt, wallOffset, offsetAfter);
655         }
656 
657         long toEpochSecond(ZoneOffset stdOffset, int savingsBeforeSecs) {
658             switch(rule.timeDefinition) {
659             case UTC:      return ldtSecs;
660             case STANDARD: return ldtSecs - stdOffset.getTotalSeconds();
661             default:       return ldtSecs - (stdOffset.getTotalSeconds() + savingsBeforeSecs); // WALL
662             }
663         }
664 
665         /**
666          * Tests if this a real transition with the active savings in seconds
667          *
668          * @param savingsBefore the active savings in seconds


669          * @return true, if savings changes
670          */
<span class="line-modified">671         boolean isTransition(int savingsBefore) {</span>
<span class="line-modified">672             return rule.savingsAmount != savingsBefore;</span>
673         }
674 
675         public int compareTo(TransRule other) {
676             return (ldtSecs &lt; other.ldtSecs)? -1 : ((ldtSecs == other.ldtSecs) ? 0 : 1);
677         }
678     }
679 
680     private ZoneRules buildRules(String zoneId, List&lt;ZoneLine&gt; zones) {
681         if (zones.isEmpty()) {
682             throw new IllegalStateException(&quot;No available zone window&quot;);
683         }
684         final List&lt;ZoneOffsetTransition&gt; standardTransitionList = new ArrayList&lt;&gt;(4);
685         final List&lt;ZoneOffsetTransition&gt; transitionList = new ArrayList&lt;&gt;(256);
686         final List&lt;ZoneOffsetTransitionRule&gt; lastTransitionRuleList = new ArrayList&lt;&gt;(2);
687 
688         final ZoneLine zone0 = zones.get(0);
689         // initialize the standard offset, wallOffset and savings for loop
690 
691         //ZoneOffset stdOffset = zone0.standardOffset;
692         ZoneOffset stdOffset = ZoneOffset.ofTotalSeconds(zone0.stdOffsetSecs);
693 
694         int savings = zone0.fixedSavingsSecs;
695         ZoneOffset wallOffset = ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savings);
696 
697         // start ldt of each zone window
698         LocalDateTime zoneStart = LocalDateTime.MIN;
699 
<span class="line-modified">700         // first stanard offset</span>
701         ZoneOffset firstStdOffset = stdOffset;
702         // first wall offset
703         ZoneOffset firstWallOffset = wallOffset;
704 
705         for (ZoneLine zone : zones) {










706             // check if standard offset changed, update it if yes
707             ZoneOffset stdOffsetPrev = stdOffset;  // for effectiveSavings check
708             if (zone.stdOffsetSecs != stdOffset.getTotalSeconds()) {
709                 ZoneOffset stdOffsetNew = ZoneOffset.ofTotalSeconds(zone.stdOffsetSecs);
710                 standardTransitionList.add(
711                     ZoneOffsetTransition.of(
712                         LocalDateTime.ofEpochSecond(zoneStart.toEpochSecond(wallOffset),
713                                                     0,
714                                                     stdOffset),
715                         stdOffset,
716                         stdOffsetNew));
717                 stdOffset = stdOffsetNew;
718             }
719 
720             LocalDateTime zoneEnd;
721             if (zone.year == Year.MAX_VALUE) {
722                 zoneEnd = LocalDateTime.MAX;
723             } else {
724                 zoneEnd = zone.toDateTime();
725             }
</pre>
<hr />
<pre>
774                 // last rules, fill the gap years between different last rules
775                 if (zoneEnd.equals(LocalDateTime.MAX)) {
776                     lastRulesStartYear = Math.max(lastRulesStartYear, zoneStart.getYear()) + 1;
777                     for (TransRule rule : lastRules) {
778                         if (rule.year &lt;= lastRulesStartYear) {
779                             int year = rule.year;
780                             while (year &lt;= lastRulesStartYear) {
781                                 trules.add(new TransRule(year, rule.rule));
782                                 year++;
783                             }
784                             rule.year = lastRulesStartYear;
785                             rule.ldt = rule.rule.toDateTime(year);
786                             rule.ldtSecs = rule.ldt.toEpochSecond(ZoneOffset.UTC);
787                         }
788                     }
789                     Collections.sort(lastRules);
790                 }
791                 // sort the merged rules
792                 Collections.sort(trules);
793 
<span class="line-modified">794                 effectiveSavings = 0;</span>
795                 for (TransRule rule : trules) {
796                     if (rule.toEpochSecond(stdOffsetPrev, savings) &gt;
797                         zoneStart.toEpochSecond(wallOffset)) {
798                         // previous savings amount found, which could be the
799                         // savings amount at the instant that the window starts
800                         // (hence isAfter)
801                         break;
802                     }
<span class="line-modified">803                     effectiveSavings = rule.rule.savingsAmount;</span>
804                 }
805             }
806             // check if the start of the window represents a transition
807             ZoneOffset effectiveWallOffset =
808                 ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + effectiveSavings);
809 
810             if (!wallOffset.equals(effectiveWallOffset)) {
811                 transitionList.add(ZoneOffsetTransition.of(zoneStart,
812                                                            wallOffset,
813                                                            effectiveWallOffset));
814             }
815             savings = effectiveSavings;
816             // apply rules within the window
817             if (trules != null) {
818                 long zoneStartEpochSecs = zoneStart.toEpochSecond(wallOffset);
819                 for (TransRule trule : trules) {
<span class="line-modified">820                     if (trule.isTransition(savings)) {</span>
821                         long epochSecs = trule.toEpochSecond(stdOffset, savings);
822                         if (epochSecs &lt; zoneStartEpochSecs ||
823                             epochSecs &gt;= zone.toDateTimeEpochSecond(savings)) {
824                             continue;
825                         }
<span class="line-modified">826                         transitionList.add(trule.toTransition(stdOffset, savings));</span>
<span class="line-modified">827                         savings = trule.rule.savingsAmount;</span>
828                     }
829                 }
830             }
831             if (lastRules != null) {
832                 for (TransRule trule : lastRules) {
<span class="line-modified">833                     lastTransitionRuleList.add(trule.rule.toTransitionRule(stdOffset, savings));</span>
<span class="line-modified">834                     savings = trule.rule.savingsAmount;</span>
835                 }
836             }
837 
838             // finally we can calculate the true end of the window, passing it to the next window
839             wallOffset = ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savings);
840             zoneStart = LocalDateTime.ofEpochSecond(zone.toDateTimeEpochSecond(savings),
841                                                     0,
842                                                     wallOffset);
843         }
844         return new ZoneRules(firstStdOffset,
845                              firstWallOffset,
846                              standardTransitionList,
847                              transitionList,
848                              lastTransitionRuleList);
849     }
850 


































851 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 package build.tools.tzdb;
 28 
 29 import java.io.IOException;
 30 import java.nio.charset.StandardCharsets;
 31 import java.nio.file.Files;
 32 import java.nio.file.Path;
 33 import java.nio.file.Paths;
<span class="line-modified"> 34 import java.util.*;</span>



 35 import java.util.Map.Entry;





 36 import java.util.concurrent.ConcurrentSkipListMap;
 37 import java.time.*;
 38 import java.time.Year;
 39 import java.time.chrono.IsoChronology;
 40 import java.time.temporal.TemporalAdjusters;
<span class="line-modified"> 41 import build.tools.tzdb.ZoneOffsetTransitionRule.TimeDefinition;</span>


 42 import java.time.zone.ZoneRulesException;
 43 
 44 /**
 45  * Compile and build time-zone rules from IANA timezone data
 46  *
 47  * @author Xueming Shen
 48  * @author Stephen Colebourne
 49  * @author Michael Nascimento Santos
 50  *
 51  * @since   9
 52  */
 53 
 54 class TzdbZoneRulesProvider {
 55 
 56     /**
 57      * Creates an instance.
 58      *
 59      * @throws ZoneRulesException if unable to load
 60      */
 61     public TzdbZoneRulesProvider(List&lt;Path&gt; files) {
</pre>
<hr />
<pre>
245      * Class representing a month-day-time in the TZDB file.
246      */
247     private static abstract class MonthDayTime {
248         /** The month of the cutover. */
249         Month month = Month.JANUARY;
250 
251         /** The day-of-month of the cutover. */
252         int dayOfMonth = 1;
253 
254         /** Whether to adjust forwards. */
255         boolean adjustForwards = true;
256 
257         /** The day-of-week of the cutover. */
258         DayOfWeek dayOfWeek;
259 
260         /** The time of the cutover, in second of day */
261         int secsOfDay = 0;
262 
263         /** Whether this is midnight end of day. */
264         boolean endOfDay;

265 
<span class="line-added">266         /** The time definition of the cutover. */</span>
267         TimeDefinition timeDefinition = TimeDefinition.WALL;
268 
269         void adjustToForwards(int year) {
270             if (adjustForwards == false &amp;&amp; dayOfMonth &gt; 0) {
271                 // weekDay&lt;=monthDay case, don&#39;t have it in tzdb data for now
272                 LocalDate adjustedDate = LocalDate.of(year, month, dayOfMonth).minusDays(6);
273                 dayOfMonth = adjustedDate.getDayOfMonth();
274                 month = adjustedDate.getMonth();
275                 adjustForwards = true;
276             }
277         }
278 
279         LocalDateTime toDateTime(int year) {
280             LocalDate date;
281             if (dayOfMonth &lt; 0) {
282                 int monthLen = month.length(IsoChronology.INSTANCE.isLeapYear(year));
283                 date = LocalDate.of(year, month, monthLen + 1 + dayOfMonth);
284                 if (dayOfWeek != null) {
285                     date = date.with(TemporalAdjusters.previousOrSame(dayOfWeek));
286                 }
</pre>
<hr />
<pre>
316                         index = dayRule.indexOf(&quot;&lt;=&quot;);
317                         if (index &gt; 0) {
318                             dayOfWeek = parseDayOfWeek(dayRule.substring(0, index));
319                             adjustForwards = false;
320                             dayRule = dayRule.substring(index + 2);
321                         }
322                     }
323                     dayOfMonth = Integer.parseInt(dayRule);
324                     if (dayOfMonth &lt; -28 || dayOfMonth &gt; 31 || dayOfMonth == 0) {
325                        throw new IllegalArgumentException(
326                           &quot;Day of month indicator must be between -28 and 31 inclusive excluding zero&quot;);
327                     }
328                 }
329                 if (off &lt; tokens.length) {
330                     String timeStr = tokens[off++];
331                     secsOfDay = parseSecs(timeStr);
332                     if (secsOfDay == 86400) {
333                         // time must be midnight when end of day flag is true
334                         endOfDay = true;
335                         secsOfDay = 0;
<span class="line-added">336                     } else if (secsOfDay &lt; 0 || secsOfDay &gt; 86400) {</span>
<span class="line-added">337                         // beyond 0:00-24:00 range. Adjust the cutover date.</span>
<span class="line-added">338                         int beyondDays = secsOfDay / 86400;</span>
<span class="line-added">339                         secsOfDay %= 86400;</span>
<span class="line-added">340                         if (secsOfDay &lt; 0) {</span>
<span class="line-added">341                             secsOfDay = 86400 + secsOfDay;</span>
<span class="line-added">342                             beyondDays -= 1;</span>
<span class="line-added">343                         }</span>
<span class="line-added">344                         LocalDate date = LocalDate.of(2004, month, dayOfMonth).plusDays(beyondDays);  // leap-year</span>
<span class="line-added">345                         month = date.getMonth();</span>
<span class="line-added">346                         dayOfMonth = date.getDayOfMonth();</span>
<span class="line-added">347                         if (dayOfWeek != null) {</span>
<span class="line-added">348                             dayOfWeek = dayOfWeek.plus(beyondDays);</span>
<span class="line-added">349                         }</span>
350                     }
351                     timeDefinition = parseTimeDefinition(timeStr.charAt(timeStr.length() - 1));
352                 }
353             }
354         }
355 
356         int parseYear(String year, int defaultYear) {
357             switch (year.toLowerCase()) {
358             case &quot;min&quot;:  return 1900;
359             case &quot;max&quot;:  return Year.MAX_VALUE;
360             case &quot;only&quot;: return defaultYear;
361             }
362             return Integer.parseInt(year);
363         }
364 
365         Month parseMonth(String mon) {
366             switch (mon) {
367             case &quot;Jan&quot;: return Month.JANUARY;
368             case &quot;Feb&quot;: return Month.FEBRUARY;
369             case &quot;Mar&quot;: return Month.MARCH;
</pre>
<hr />
<pre>
484      * Class representing a rule line in the TZDB file.
485      */
486     private static class RuleLine extends MonthDayTime {
487         /** The start year. */
488         int startYear;
489 
490         /** The end year. */
491         int endYear;
492 
493         /** The amount of savings, in seconds. */
494         int savingsAmount;
495 
496         /** The text name of the zone. */
497         String text;
498 
499         /**
500          * Converts this to a transition rule.
501          *
502          * @param standardOffset  the active standard offset, not null
503          * @param savingsBeforeSecs  the active savings before the transition in seconds
<span class="line-added">504          * @param negativeSavings minimum savings in the rule, usually zero, but negative if negative DST is</span>
<span class="line-added">505          *                   in effect.</span>
506          * @return the transition, not null
507         */
<span class="line-modified">508         ZoneOffsetTransitionRule toTransitionRule(ZoneOffset stdOffset, int savingsBefore, int negativeSavings) {</span>
509             // rule shared by different zones, so don&#39;t change it
510             Month month = this.month;
511             int dayOfMonth = this.dayOfMonth;
512             DayOfWeek dayOfWeek = this.dayOfWeek;
513             boolean endOfDay = this.endOfDay;
514 
515             // optimize stored format
516             if (dayOfMonth &lt; 0) {
517                 if (month != Month.FEBRUARY) {    // not Month.FEBRUARY
518                     dayOfMonth = month.maxLength() - 6;
519                 }
520             }
521             if (endOfDay &amp;&amp; dayOfMonth &gt; 0 &amp;&amp;
522                 (dayOfMonth == 28 &amp;&amp; month == Month.FEBRUARY) == false) {
523                 LocalDate date = LocalDate.of(2004, month, dayOfMonth).plusDays(1);  // leap-year
524                 month = date.getMonth();
525                 dayOfMonth = date.getDayOfMonth();
526                 if (dayOfWeek != null) {
527                     dayOfWeek = dayOfWeek.plus(1);
528                 }
529                 endOfDay = false;
530             }
<span class="line-added">531 </span>
532             // build rule
533             return ZoneOffsetTransitionRule.of(
534                     //month, dayOfMonth, dayOfWeek, time, endOfDay, timeDefinition,
535                     month, dayOfMonth, dayOfWeek,
536                     LocalTime.ofSecondOfDay(secsOfDay), endOfDay, timeDefinition,
537                     stdOffset,
538                     ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savingsBefore),
<span class="line-modified">539                     ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savingsAmount - negativeSavings));</span>
540         }
541 
542         RuleLine parse(String[] tokens) {
543             startYear = parseYear(tokens[2], 0);
544             endYear = parseYear(tokens[3], startYear);
545             if (startYear &gt; endYear) {
546                 throw new IllegalArgumentException(
547                     &quot;Invalid &lt;Rule&gt; line/Year order invalid:&quot; + startYear + &quot; &gt; &quot; + endYear);
548             }
549             //parseOptional(s.next());  // type is unused
550             super.parse(tokens, 5);     // monthdaytime parsing
551             savingsAmount = parsePeriod(tokens[8]);
552             //rule.text = parseOptional(s.next());
553             return this;
554         }
555     }
556 
557     /**
558      * Class representing a linked set of zone lines in the TZDB file.
559      */
</pre>
<hr />
<pre>
633      * Class representing a rule line in the TZDB file for a particular year.
634      */
635     private static class TransRule implements Comparable&lt;TransRule&gt;
636     {
637         private int year;
638         private RuleLine rule;
639 
640         /** The trans date/time */
641         private LocalDateTime ldt;
642 
643         /** The trans date/time in epoch seconds (assume UTC) */
644         long ldtSecs;
645 
646         TransRule(int year, RuleLine rule) {
647             this.year = year;
648             this.rule = rule;
649             this.ldt = rule.toDateTime(year);
650             this.ldtSecs = ldt.toEpochSecond(ZoneOffset.UTC);
651         }
652 
<span class="line-modified">653         ZoneOffsetTransition toTransition(ZoneOffset standardOffset, int savingsBeforeSecs, int negativeSavings) {</span>
654             // copy of code in ZoneOffsetTransitionRule to avoid infinite loop
655             ZoneOffset wallOffset = ZoneOffset.ofTotalSeconds(
656                 standardOffset.getTotalSeconds() + savingsBeforeSecs);
657             ZoneOffset offsetAfter = ZoneOffset.ofTotalSeconds(
<span class="line-modified">658                 standardOffset.getTotalSeconds() + rule.savingsAmount - negativeSavings);</span>
659             LocalDateTime dt = rule.timeDefinition
660                                    .createDateTime(ldt, standardOffset, wallOffset);
661             return ZoneOffsetTransition.of(dt, wallOffset, offsetAfter);
662         }
663 
664         long toEpochSecond(ZoneOffset stdOffset, int savingsBeforeSecs) {
665             switch(rule.timeDefinition) {
666             case UTC:      return ldtSecs;
667             case STANDARD: return ldtSecs - stdOffset.getTotalSeconds();
668             default:       return ldtSecs - (stdOffset.getTotalSeconds() + savingsBeforeSecs); // WALL
669             }
670         }
671 
672         /**
673          * Tests if this a real transition with the active savings in seconds
674          *
675          * @param savingsBefore the active savings in seconds
<span class="line-added">676          * @param negativeSavings minimum savings in the rule, usually zero, but negative if negative DST is</span>
<span class="line-added">677          *                   in effect.</span>
678          * @return true, if savings changes
679          */
<span class="line-modified">680         boolean isTransition(int savingsBefore, int negativeSavings) {</span>
<span class="line-modified">681             return rule.savingsAmount - negativeSavings != savingsBefore;</span>
682         }
683 
684         public int compareTo(TransRule other) {
685             return (ldtSecs &lt; other.ldtSecs)? -1 : ((ldtSecs == other.ldtSecs) ? 0 : 1);
686         }
687     }
688 
689     private ZoneRules buildRules(String zoneId, List&lt;ZoneLine&gt; zones) {
690         if (zones.isEmpty()) {
691             throw new IllegalStateException(&quot;No available zone window&quot;);
692         }
693         final List&lt;ZoneOffsetTransition&gt; standardTransitionList = new ArrayList&lt;&gt;(4);
694         final List&lt;ZoneOffsetTransition&gt; transitionList = new ArrayList&lt;&gt;(256);
695         final List&lt;ZoneOffsetTransitionRule&gt; lastTransitionRuleList = new ArrayList&lt;&gt;(2);
696 
697         final ZoneLine zone0 = zones.get(0);
698         // initialize the standard offset, wallOffset and savings for loop
699 
700         //ZoneOffset stdOffset = zone0.standardOffset;
701         ZoneOffset stdOffset = ZoneOffset.ofTotalSeconds(zone0.stdOffsetSecs);
702 
703         int savings = zone0.fixedSavingsSecs;
704         ZoneOffset wallOffset = ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savings);
705 
706         // start ldt of each zone window
707         LocalDateTime zoneStart = LocalDateTime.MIN;
708 
<span class="line-modified">709         // first standard offset</span>
710         ZoneOffset firstStdOffset = stdOffset;
711         // first wall offset
712         ZoneOffset firstWallOffset = wallOffset;
713 
714         for (ZoneLine zone : zones) {
<span class="line-added">715             // Adjust stdOffset, if negative DST is observed. It should be either</span>
<span class="line-added">716             // fixed amount, or expressed in the named Rules.</span>
<span class="line-added">717             int negativeSavings = Math.min(zone.fixedSavingsSecs, findNegativeSavings(zoneStart, zone));</span>
<span class="line-added">718             if (negativeSavings &lt; 0) {</span>
<span class="line-added">719                 zone.stdOffsetSecs += negativeSavings;</span>
<span class="line-added">720                 if (zone.fixedSavingsSecs &lt; 0) {</span>
<span class="line-added">721                     zone.fixedSavingsSecs = 0;</span>
<span class="line-added">722                 }</span>
<span class="line-added">723             }</span>
<span class="line-added">724 </span>
725             // check if standard offset changed, update it if yes
726             ZoneOffset stdOffsetPrev = stdOffset;  // for effectiveSavings check
727             if (zone.stdOffsetSecs != stdOffset.getTotalSeconds()) {
728                 ZoneOffset stdOffsetNew = ZoneOffset.ofTotalSeconds(zone.stdOffsetSecs);
729                 standardTransitionList.add(
730                     ZoneOffsetTransition.of(
731                         LocalDateTime.ofEpochSecond(zoneStart.toEpochSecond(wallOffset),
732                                                     0,
733                                                     stdOffset),
734                         stdOffset,
735                         stdOffsetNew));
736                 stdOffset = stdOffsetNew;
737             }
738 
739             LocalDateTime zoneEnd;
740             if (zone.year == Year.MAX_VALUE) {
741                 zoneEnd = LocalDateTime.MAX;
742             } else {
743                 zoneEnd = zone.toDateTime();
744             }
</pre>
<hr />
<pre>
793                 // last rules, fill the gap years between different last rules
794                 if (zoneEnd.equals(LocalDateTime.MAX)) {
795                     lastRulesStartYear = Math.max(lastRulesStartYear, zoneStart.getYear()) + 1;
796                     for (TransRule rule : lastRules) {
797                         if (rule.year &lt;= lastRulesStartYear) {
798                             int year = rule.year;
799                             while (year &lt;= lastRulesStartYear) {
800                                 trules.add(new TransRule(year, rule.rule));
801                                 year++;
802                             }
803                             rule.year = lastRulesStartYear;
804                             rule.ldt = rule.rule.toDateTime(year);
805                             rule.ldtSecs = rule.ldt.toEpochSecond(ZoneOffset.UTC);
806                         }
807                     }
808                     Collections.sort(lastRules);
809                 }
810                 // sort the merged rules
811                 Collections.sort(trules);
812 
<span class="line-modified">813                 effectiveSavings = -negativeSavings;</span>
814                 for (TransRule rule : trules) {
815                     if (rule.toEpochSecond(stdOffsetPrev, savings) &gt;
816                         zoneStart.toEpochSecond(wallOffset)) {
817                         // previous savings amount found, which could be the
818                         // savings amount at the instant that the window starts
819                         // (hence isAfter)
820                         break;
821                     }
<span class="line-modified">822                     effectiveSavings = rule.rule.savingsAmount - negativeSavings;</span>
823                 }
824             }
825             // check if the start of the window represents a transition
826             ZoneOffset effectiveWallOffset =
827                 ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + effectiveSavings);
828 
829             if (!wallOffset.equals(effectiveWallOffset)) {
830                 transitionList.add(ZoneOffsetTransition.of(zoneStart,
831                                                            wallOffset,
832                                                            effectiveWallOffset));
833             }
834             savings = effectiveSavings;
835             // apply rules within the window
836             if (trules != null) {
837                 long zoneStartEpochSecs = zoneStart.toEpochSecond(wallOffset);
838                 for (TransRule trule : trules) {
<span class="line-modified">839                     if (trule.isTransition(savings, negativeSavings)) {</span>
840                         long epochSecs = trule.toEpochSecond(stdOffset, savings);
841                         if (epochSecs &lt; zoneStartEpochSecs ||
842                             epochSecs &gt;= zone.toDateTimeEpochSecond(savings)) {
843                             continue;
844                         }
<span class="line-modified">845                         transitionList.add(trule.toTransition(stdOffset, savings, negativeSavings));</span>
<span class="line-modified">846                         savings = trule.rule.savingsAmount - negativeSavings;</span>
847                     }
848                 }
849             }
850             if (lastRules != null) {
851                 for (TransRule trule : lastRules) {
<span class="line-modified">852                     lastTransitionRuleList.add(trule.rule.toTransitionRule(stdOffset, savings, negativeSavings));</span>
<span class="line-modified">853                     savings = trule.rule.savingsAmount - negativeSavings;</span>
854                 }
855             }
856 
857             // finally we can calculate the true end of the window, passing it to the next window
858             wallOffset = ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savings);
859             zoneStart = LocalDateTime.ofEpochSecond(zone.toDateTimeEpochSecond(savings),
860                                                     0,
861                                                     wallOffset);
862         }
863         return new ZoneRules(firstStdOffset,
864                              firstWallOffset,
865                              standardTransitionList,
866                              transitionList,
867                              lastTransitionRuleList);
868     }
869 
<span class="line-added">870     /**</span>
<span class="line-added">871      * Find the minimum negative savings in named Rules for a Zone. Savings are only</span>
<span class="line-added">872      * looked at for the period of the subject Zone.</span>
<span class="line-added">873      *</span>
<span class="line-added">874      * @param zoneStart start LDT of the zone</span>
<span class="line-added">875      * @param zl ZoneLine to look at</span>
<span class="line-added">876      */</span>
<span class="line-added">877     private int findNegativeSavings(LocalDateTime zoneStart, ZoneLine zl) {</span>
<span class="line-added">878         int negativeSavings = 0;</span>
<span class="line-added">879         LocalDateTime zoneEnd = zl.toDateTime();</span>
<span class="line-added">880 </span>
<span class="line-added">881         if (zl.savingsRule != null) {</span>
<span class="line-added">882             List&lt;RuleLine&gt; rlines = rules.get(zl.savingsRule);</span>
<span class="line-added">883             if (rlines == null) {</span>
<span class="line-added">884                 throw new IllegalArgumentException(&quot;&lt;Rule&gt; not found: &quot; +</span>
<span class="line-added">885                         zl.savingsRule);</span>
<span class="line-added">886             }</span>
<span class="line-added">887 </span>
<span class="line-added">888             negativeSavings = Math.min(0, rlines.stream()</span>
<span class="line-added">889                     .filter(l -&gt; windowOverlap(l, zoneStart.getYear(), zoneEnd.getYear()))</span>
<span class="line-added">890                     .map(l -&gt; l.savingsAmount)</span>
<span class="line-added">891                     .min(Comparator.naturalOrder())</span>
<span class="line-added">892                     .orElse(0));</span>
<span class="line-added">893         }</span>
<span class="line-added">894 </span>
<span class="line-added">895         return negativeSavings;</span>
<span class="line-added">896     }</span>
<span class="line-added">897 </span>
<span class="line-added">898     private boolean windowOverlap(RuleLine ruleLine, int zoneStartYear, int zoneEndYear) {</span>
<span class="line-added">899         boolean overlap = zoneStartYear &lt;= ruleLine.startYear &amp;&amp; zoneEndYear &gt;= ruleLine.startYear ||</span>
<span class="line-added">900                           zoneStartYear &lt;= ruleLine.endYear &amp;&amp; zoneEndYear &gt;= ruleLine.endYear;</span>
<span class="line-added">901 </span>
<span class="line-added">902         return overlap;</span>
<span class="line-added">903     }</span>
904 }
</pre>
</td>
</tr>
</table>
<center><a href="TzdbZoneRulesCompiler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../langtools/tools/propertiesparser/resources/templates.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
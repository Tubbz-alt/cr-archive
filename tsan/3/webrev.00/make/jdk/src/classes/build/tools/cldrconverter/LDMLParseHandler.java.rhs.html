<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/jdk/src/classes/build/tools/cldrconverter/LDMLParseHandler.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package build.tools.cldrconverter;
  27 
  28 import java.io.File;
  29 import java.io.IOException;
  30 import java.text.DateFormatSymbols;
  31 import java.util.ArrayList;
<a name="2" id="anc2"></a><span class="line-added">  32 import java.util.Arrays;</span>
  33 import java.util.HashMap;
  34 import java.util.HashSet;
  35 import java.util.List;
  36 import java.util.Locale;
  37 import java.util.Map;
  38 import java.util.Set;
  39 import org.xml.sax.Attributes;
  40 import org.xml.sax.InputSource;
  41 import org.xml.sax.SAXException;
  42 
  43 /**
  44  * Handles parsing of files in Locale Data Markup Language and produces a map
  45  * that uses the keys and values of JRE locale data.
  46  */
  47 class LDMLParseHandler extends AbstractLDMLHandler&lt;Object&gt; {
  48     private String defaultNumberingSystem;
  49     private String currentNumberingSystem = &quot;&quot;;
  50     private CalendarType currentCalendarType;
  51     private String zoneNameStyle; // &quot;long&quot; or &quot;short&quot; for time zone names
  52     private String zonePrefix;
  53     private final String id;
  54     private String currentContext = &quot;&quot;; // &quot;format&quot;/&quot;stand-alone&quot;
  55     private String currentWidth = &quot;&quot;; // &quot;wide&quot;/&quot;narrow&quot;/&quot;abbreviated&quot;
  56     private String currentStyle = &quot;&quot;; // short, long for decimalFormat
<a name="3" id="anc3"></a>
  57 
  58     LDMLParseHandler(String id) {
  59         this.id = id;
  60     }
  61 
  62     @Override
  63     public InputSource resolveEntity(String publicID, String systemID) throws IOException, SAXException {
  64         // avoid HTTP traffic to unicode.org
  65         if (systemID.startsWith(CLDRConverter.LDML_DTD_SYSTEM_ID)) {
  66             return new InputSource((new File(CLDRConverter.LOCAL_LDML_DTD)).toURI().toString());
  67         }
  68         return null;
  69     }
  70 
  71     @Override
  72     public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
  73         switch (qName) {
  74         //
  75         // Generic information
  76         //
  77         case &quot;identity&quot;:
  78             // ignore this element - it has language and territory elements that aren&#39;t locale data
  79             pushIgnoredContainer(qName);
  80             break;
  81 
  82         // for LocaleNames
  83         // copy string
  84         case &quot;localeSeparator&quot;:
  85             pushStringEntry(qName, attributes,
  86                 CLDRConverter.LOCALE_SEPARATOR);
  87             break;
  88         case &quot;localeKeyTypePattern&quot;:
  89             pushStringEntry(qName, attributes,
  90                 CLDRConverter.LOCALE_KEYTYPE);
  91             break;
  92 
  93         case &quot;language&quot;:
  94         case &quot;script&quot;:
  95         case &quot;territory&quot;:
  96         case &quot;variant&quot;:
  97             // for LocaleNames
  98             // copy string
  99             pushStringEntry(qName, attributes,
 100                 CLDRConverter.LOCALE_NAME_PREFIX +
 101                 (qName.equals(&quot;variant&quot;) ? &quot;%%&quot; : &quot;&quot;) +
 102                 attributes.getValue(&quot;type&quot;));
 103             break;
 104 
 105         case &quot;key&quot;:
 106             // for LocaleNames
 107             // copy string
 108             {
 109                 String key = convertOldKeyName(attributes.getValue(&quot;type&quot;));
 110                 if (key.length() == 2) {
 111                     pushStringEntry(qName, attributes,
 112                         CLDRConverter.LOCALE_KEY_PREFIX + key);
 113                 } else {
 114                     pushIgnoredContainer(qName);
 115                 }
 116             }
 117             break;
 118 
 119         case &quot;type&quot;:
 120             // for LocaleNames/CalendarNames
 121             // copy string
 122             {
 123                 String key = convertOldKeyName(attributes.getValue(&quot;key&quot;));
 124                 if (key.length() == 2) {
 125                     pushStringEntry(qName, attributes,
 126                     CLDRConverter.LOCALE_TYPE_PREFIX + key + &quot;.&quot; +
 127                     attributes.getValue(&quot;type&quot;));
 128                 } else {
 129                     pushIgnoredContainer(qName);
 130                 }
 131             }
 132             break;
 133 
 134         //
 135         // Currency information
 136         //
 137         case &quot;currency&quot;:
 138             // for CurrencyNames
 139             // stash away &quot;type&quot; value for nested &lt;symbol&gt;
 140             pushKeyContainer(qName, attributes, attributes.getValue(&quot;type&quot;));
 141             break;
 142         case &quot;symbol&quot;:
 143             // for CurrencyNames
 144             // need to get the key from the containing &lt;currency&gt; element
 145             pushStringEntry(qName, attributes, CLDRConverter.CURRENCY_SYMBOL_PREFIX
 146                                                + getContainerKey());
 147             break;
 148 
 149         // Calendar or currency
 150         case &quot;displayName&quot;:
 151             {
 152                 if (currentContainer.getqName().equals(&quot;field&quot;)) {
 153                     pushStringEntry(qName, attributes,
 154                             (currentCalendarType != null ? currentCalendarType.keyElementName() : &quot;&quot;)
 155                             + &quot;field.&quot; + getContainerKey());
 156                 } else {
 157                     // for CurrencyNames
 158                     // need to get the key from the containing &lt;currency&gt; element
 159                     // ignore if is has &quot;count&quot; attribute
 160                     String containerKey = getContainerKey();
 161                     if (containerKey != null &amp;&amp; attributes.getValue(&quot;count&quot;) == null) {
 162                         pushStringEntry(qName, attributes,
 163                                         CLDRConverter.CURRENCY_NAME_PREFIX
 164                                         + containerKey.toLowerCase(Locale.ROOT),
 165                                         attributes.getValue(&quot;type&quot;));
 166                     } else {
 167                         pushIgnoredContainer(qName);
 168                     }
 169                 }
 170             }
 171             break;
 172 
 173         //
 174         // Calendar information
 175         //
 176         case &quot;calendar&quot;:
 177             {
 178                 // mostly for FormatData (CalendarData items firstDay and minDays are also nested)
 179                 // use only if it&#39;s supported by java.util.Calendar.
 180                 String calendarName = attributes.getValue(&quot;type&quot;);
 181                 currentCalendarType = CalendarType.forName(calendarName);
 182                 if (currentCalendarType != null) {
 183                     pushContainer(qName, attributes);
 184                 } else {
 185                     pushIgnoredContainer(qName);
 186                 }
 187             }
 188             break;
 189         case &quot;fields&quot;:
 190             {
 191                 pushContainer(qName, attributes);
 192             }
 193             break;
 194         case &quot;field&quot;:
 195             {
 196                 String type = attributes.getValue(&quot;type&quot;);
 197                 switch (type) {
 198                 case &quot;era&quot;:
 199                 case &quot;year&quot;:
 200                 case &quot;month&quot;:
 201                 case &quot;week&quot;:
 202                 case &quot;weekday&quot;:
 203                 case &quot;dayperiod&quot;:
 204                 case &quot;hour&quot;:
 205                 case &quot;minute&quot;:
 206                 case &quot;second&quot;:
 207                 case &quot;zone&quot;:
 208                     pushKeyContainer(qName, attributes, type);
 209                     break;
 210                 default:
 211                     pushIgnoredContainer(qName);
 212                     break;
 213                 }
 214             }
 215             break;
 216         case &quot;monthContext&quot;:
 217             {
 218                 // for FormatData
 219                 // need to keep stand-alone and format, to allow for inheritance in CLDR
 220                 String type = attributes.getValue(&quot;type&quot;);
 221                 if (&quot;stand-alone&quot;.equals(type) || &quot;format&quot;.equals(type)) {
 222                     currentContext = type;
 223                     pushKeyContainer(qName, attributes, type);
 224                 } else {
 225                     pushIgnoredContainer(qName);
 226                 }
 227             }
 228             break;
 229         case &quot;monthWidth&quot;:
 230             {
 231                 // for FormatData
 232                 // create string array for the two types that the JRE knows
 233                 // keep info about the context type so we can sort out inheritance later
 234                 if (currentCalendarType == null) {
 235                     pushIgnoredContainer(qName);
 236                     break;
 237                 }
 238                 String prefix = (currentCalendarType == null) ? &quot;&quot; : currentCalendarType.keyElementName();
 239                 currentWidth = attributes.getValue(&quot;type&quot;);
 240                 switch (currentWidth) {
 241                 case &quot;wide&quot;:
 242                     pushStringArrayEntry(qName, attributes, prefix + &quot;MonthNames/&quot; + getContainerKey(), 13);
 243                     break;
 244                 case &quot;abbreviated&quot;:
 245                     pushStringArrayEntry(qName, attributes, prefix + &quot;MonthAbbreviations/&quot; + getContainerKey(), 13);
 246                     break;
 247                 case &quot;narrow&quot;:
 248                     pushStringArrayEntry(qName, attributes, prefix + &quot;MonthNarrows/&quot; + getContainerKey(), 13);
 249                     break;
 250                 default:
 251                     pushIgnoredContainer(qName);
 252                     break;
 253                 }
 254             }
 255             break;
 256         case &quot;month&quot;:
 257             // for FormatData
 258             // add to string array entry of monthWidth element
 259             pushStringArrayElement(qName, attributes, Integer.parseInt(attributes.getValue(&quot;type&quot;)) - 1);
 260             break;
 261         case &quot;dayContext&quot;:
 262             {
 263                 // for FormatData
 264                 // need to keep stand-alone and format, to allow for multiple inheritance in CLDR
 265                 String type = attributes.getValue(&quot;type&quot;);
 266                 if (&quot;stand-alone&quot;.equals(type) || &quot;format&quot;.equals(type)) {
 267                     currentContext = type;
 268                     pushKeyContainer(qName, attributes, type);
 269                 } else {
 270                     pushIgnoredContainer(qName);
 271                 }
 272             }
 273             break;
 274         case &quot;dayWidth&quot;:
 275             {
 276                 // for FormatData
 277                 // create string array for the two types that the JRE knows
 278                 // keep info about the context type so we can sort out inheritance later
 279                 String prefix = (currentCalendarType == null) ? &quot;&quot; : currentCalendarType.keyElementName();
 280                 currentWidth = attributes.getValue(&quot;type&quot;);
 281                 switch (currentWidth) {
 282                 case &quot;wide&quot;:
 283                     pushStringArrayEntry(qName, attributes, prefix + &quot;DayNames/&quot; + getContainerKey(), 7);
 284                     break;
 285                 case &quot;abbreviated&quot;:
 286                     pushStringArrayEntry(qName, attributes, prefix + &quot;DayAbbreviations/&quot; + getContainerKey(), 7);
 287                     break;
 288                 case &quot;narrow&quot;:
 289                     pushStringArrayEntry(qName, attributes, prefix + &quot;DayNarrows/&quot; + getContainerKey(), 7);
 290                     break;
 291                 default:
 292                     pushIgnoredContainer(qName);
 293                     break;
 294                 }
 295             }
 296             break;
 297         case &quot;day&quot;:
 298             // for FormatData
 299             // add to string array entry of monthWidth element
 300             pushStringArrayElement(qName, attributes, Integer.parseInt(DAY_OF_WEEK_MAP.get(attributes.getValue(&quot;type&quot;))) - 1);
 301             break;
 302         case &quot;dayPeriodContext&quot;:
 303             // for FormatData
 304             // need to keep stand-alone and format, to allow for multiple inheritance in CLDR
 305             // for FormatData
 306             // need to keep stand-alone and format, to allow for multiple inheritance in CLDR
 307             {
 308                 String type = attributes.getValue(&quot;type&quot;);
 309                 if (&quot;stand-alone&quot;.equals(type) || &quot;format&quot;.equals(type)) {
 310                     currentContext = type;
 311                     pushKeyContainer(qName, attributes, type);
 312                 } else {
 313                     pushIgnoredContainer(qName);
 314                 }
 315             }
 316             break;
 317         case &quot;dayPeriodWidth&quot;:
 318             // for FormatData
 319             // create string array entry for am/pm. only keeping wide
 320             currentWidth = attributes.getValue(&quot;type&quot;);
 321             switch (currentWidth) {
 322             case &quot;wide&quot;:
 323                 pushStringArrayEntry(qName, attributes, &quot;AmPmMarkers/&quot; + getContainerKey(), 2);
 324                 break;
 325             case &quot;narrow&quot;:
 326                 pushStringArrayEntry(qName, attributes, &quot;narrow.AmPmMarkers/&quot; + getContainerKey(), 2);
 327                 break;
 328             case &quot;abbreviated&quot;:
 329                 pushStringArrayEntry(qName, attributes, &quot;abbreviated.AmPmMarkers/&quot; + getContainerKey(), 2);
 330                 break;
 331             default:
 332                 pushIgnoredContainer(qName);
 333                 break;
 334             }
 335             break;
 336         case &quot;dayPeriod&quot;:
 337             // for FormatData
 338             // add to string array entry of AmPmMarkers element
 339             if (attributes.getValue(&quot;alt&quot;) == null) {
 340                 switch (attributes.getValue(&quot;type&quot;)) {
 341                 case &quot;am&quot;:
 342                     pushStringArrayElement(qName, attributes, 0);
 343                     break;
 344                 case &quot;pm&quot;:
 345                     pushStringArrayElement(qName, attributes, 1);
 346                     break;
 347                 default:
 348                     pushIgnoredContainer(qName);
 349                     break;
 350                 }
 351             } else {
 352                 // discard alt values
 353                 pushIgnoredContainer(qName);
 354             }
 355             break;
 356         case &quot;eraNames&quot;:
 357             // CLDR era names are inconsistent in terms of their lengths. For example,
 358             // the full names of Japanese imperial eras are eraAbbr, while the full names
 359             // of the Julian eras are eraNames.
 360             if (currentCalendarType == null) {
 361                 assert currentContainer instanceof IgnoredContainer;
 362                 pushIgnoredContainer(qName);
 363             } else {
 364                 String key = currentCalendarType.keyElementName() + &quot;long.Eras&quot;; // for now
 365                 pushStringArrayEntry(qName, attributes, key, currentCalendarType.getEraLength(qName));
 366             }
 367             break;
 368         case &quot;eraAbbr&quot;:
 369             // for FormatData
 370             // create string array entry
 371             if (currentCalendarType == null) {
 372                 assert currentContainer instanceof IgnoredContainer;
 373                 pushIgnoredContainer(qName);
 374             } else {
 375                 String key = currentCalendarType.keyElementName() + &quot;Eras&quot;;
 376                 pushStringArrayEntry(qName, attributes, key, currentCalendarType.getEraLength(qName));
 377             }
 378             break;
 379         case &quot;eraNarrow&quot;:
 380             // mainly used for the Japanese imperial calendar
 381             if (currentCalendarType == null) {
 382                 assert currentContainer instanceof IgnoredContainer;
 383                 pushIgnoredContainer(qName);
 384             } else {
 385                 String key = currentCalendarType.keyElementName() + &quot;narrow.Eras&quot;;
 386                 pushStringArrayEntry(qName, attributes, key, currentCalendarType.getEraLength(qName));
 387             }
 388             break;
 389         case &quot;era&quot;:
 390             // for FormatData
 391             // add to string array entry of eraAbbr element
 392             if (currentCalendarType == null) {
 393                 assert currentContainer instanceof IgnoredContainer;
 394                 pushIgnoredContainer(qName);
 395             } else {
 396                 int index = Integer.parseInt(attributes.getValue(&quot;type&quot;));
 397                 index = currentCalendarType.normalizeEraIndex(index);
 398                 if (index &gt;= 0) {
 399                     pushStringArrayElement(qName, attributes, index);
 400                 } else {
 401                     pushIgnoredContainer(qName);
 402                 }
 403                 if (currentContainer.getParent() == null) {
 404                     throw new InternalError(&quot;currentContainer: null parent&quot;);
 405                 }
 406             }
 407             break;
 408         case &quot;quarterContext&quot;:
 409             {
 410                 // for FormatData
 411                 // need to keep stand-alone and format, to allow for inheritance in CLDR
 412                 String type = attributes.getValue(&quot;type&quot;);
 413                 if (&quot;stand-alone&quot;.equals(type) || &quot;format&quot;.equals(type)) {
 414                     currentContext = type;
 415                     pushKeyContainer(qName, attributes, type);
 416                 } else {
 417                     pushIgnoredContainer(qName);
 418                 }
 419             }
 420             break;
 421         case &quot;quarterWidth&quot;:
 422             {
 423                 // for FormatData
 424                 // keep info about the context type so we can sort out inheritance later
 425                 String prefix = (currentCalendarType == null) ? &quot;&quot; : currentCalendarType.keyElementName();
 426                 currentWidth = attributes.getValue(&quot;type&quot;);
 427                 switch (currentWidth) {
 428                 case &quot;wide&quot;:
 429                     pushStringArrayEntry(qName, attributes, prefix + &quot;QuarterNames/&quot; + getContainerKey(), 4);
 430                     break;
 431                 case &quot;abbreviated&quot;:
 432                     pushStringArrayEntry(qName, attributes, prefix + &quot;QuarterAbbreviations/&quot; + getContainerKey(), 4);
 433                     break;
 434                 case &quot;narrow&quot;:
 435                     pushStringArrayEntry(qName, attributes, prefix + &quot;QuarterNarrows/&quot; + getContainerKey(), 4);
 436                     break;
 437                 default:
 438                     pushIgnoredContainer(qName);
 439                     break;
 440                 }
 441             }
 442             break;
 443         case &quot;quarter&quot;:
 444             // for FormatData
 445             // add to string array entry of quarterWidth element
 446             pushStringArrayElement(qName, attributes, Integer.parseInt(attributes.getValue(&quot;type&quot;)) - 1);
 447             break;
 448 
 449         //
 450         // Time zone names
 451         //
 452         case &quot;timeZoneNames&quot;:
 453             pushContainer(qName, attributes);
 454             break;
 455         case &quot;hourFormat&quot;:
 456             pushStringEntry(qName, attributes, &quot;timezone.hourFormat&quot;);
 457             break;
 458         case &quot;gmtFormat&quot;:
 459             pushStringEntry(qName, attributes, &quot;timezone.gmtFormat&quot;);
 460             break;
 461         case &quot;gmtZeroFormat&quot;:
 462             pushStringEntry(qName, attributes, &quot;timezone.gmtZeroFormat&quot;);
 463             break;
 464         case &quot;regionFormat&quot;:
 465             {
 466                 String type = attributes.getValue(&quot;type&quot;);
 467                 pushStringEntry(qName, attributes, &quot;timezone.regionFormat&quot; +
 468                     (type == null ? &quot;&quot; : &quot;.&quot; + type));
 469             }
 470             break;
 471         case &quot;zone&quot;:
 472             {
 473                 String tzid = attributes.getValue(&quot;type&quot;); // Olson tz id
 474                 zonePrefix = CLDRConverter.TIMEZONE_ID_PREFIX;
 475                 put(zonePrefix + tzid, new HashMap&lt;String, String&gt;());
 476                 pushKeyContainer(qName, attributes, tzid);
 477             }
 478             break;
 479         case &quot;metazone&quot;:
 480             {
 481                 String zone = attributes.getValue(&quot;type&quot;); // LDML meta zone id
 482                 zonePrefix = CLDRConverter.METAZONE_ID_PREFIX;
 483                 put(zonePrefix + zone, new HashMap&lt;String, String&gt;());
 484                 pushKeyContainer(qName, attributes, zone);
 485             }
 486             break;
 487         case &quot;long&quot;:
 488             zoneNameStyle = &quot;long&quot;;
 489             pushContainer(qName, attributes);
 490             break;
 491         case &quot;short&quot;:
 492             zoneNameStyle = &quot;short&quot;;
 493             pushContainer(qName, attributes);
 494             break;
 495         case &quot;generic&quot;:  // generic name
 496         case &quot;standard&quot;: // standard time name
 497         case &quot;daylight&quot;: // daylight saving (summer) time name
 498             pushStringEntry(qName, attributes, CLDRConverter.ZONE_NAME_PREFIX + qName + &quot;.&quot; + zoneNameStyle);
 499             break;
 500         case &quot;exemplarCity&quot;:
 501             pushStringEntry(qName, attributes, CLDRConverter.EXEMPLAR_CITY_PREFIX);
 502             break;
 503 
 504         //
 505         // Number format information
 506         //
 507         case &quot;decimalFormatLength&quot;:
 508             String type = attributes.getValue(&quot;type&quot;);
 509             if (null == type) {
 510                 // format data for decimal number format
<a name="4" id="anc4"></a><span class="line-modified"> 511                 pushStringEntry(qName, attributes,</span>
<span class="line-added"> 512                     currentNumberingSystem + &quot;NumberPatterns/decimal&quot;);</span>
 513                 currentStyle = type;
 514             } else {
 515                 switch (type) {
 516                     case &quot;short&quot;:
 517                     case &quot;long&quot;:
 518                         // considering &quot;short&quot; and long for
 519                         // compact number formatting patterns
 520                         pushKeyContainer(qName, attributes, type);
 521                         currentStyle = type;
 522                         break;
 523                     default:
 524                         pushIgnoredContainer(qName);
 525                         break;
 526                 }
 527             }
 528             break;
 529         case &quot;decimalFormat&quot;:
 530             if(currentStyle == null) {
 531                 pushContainer(qName, attributes);
 532             } else {
 533                 switch (currentStyle) {
 534                     case &quot;short&quot;:
<a name="5" id="anc5"></a>


 535                     case &quot;long&quot;:
 536                         pushStringListEntry(qName, attributes,
 537                                 currentStyle+&quot;.CompactNumberPatterns&quot;);
 538                         break;
 539                     default:
 540                         pushIgnoredContainer(qName);
 541                         break;
 542                 }
 543             }
 544             break;
<a name="6" id="anc6"></a><span class="line-added"> 545         case &quot;currencyFormat&quot;:</span>
<span class="line-added"> 546         case &quot;percentFormat&quot;:</span>
<span class="line-added"> 547             pushKeyContainer(qName, attributes, attributes.getValue(&quot;type&quot;));</span>
<span class="line-added"> 548             break;</span>
<span class="line-added"> 549 </span>
 550         case &quot;pattern&quot;:
 551             String containerName = currentContainer.getqName();
<a name="7" id="anc7"></a><span class="line-modified"> 552             switch (containerName) {</span>
<span class="line-modified"> 553                 case &quot;currencyFormat&quot;:</span>
<span class="line-modified"> 554                 case &quot;percentFormat&quot;:</span>
<span class="line-modified"> 555                 {</span>
<span class="line-modified"> 556                     // for FormatData</span>
<span class="line-modified"> 557                     // copy string for later assembly into NumberPatterns</span>
<span class="line-modified"> 558                     if (currentContainer instanceof KeyContainer) {</span>
<span class="line-modified"> 559                         String fStyle = ((KeyContainer)currentContainer).getKey();</span>
<span class="line-modified"> 560                         if (fStyle.equals(&quot;standard&quot;)) {</span>
<span class="line-modified"> 561                             pushStringEntry(qName, attributes,</span>
<span class="line-modified"> 562                                     currentNumberingSystem + &quot;NumberPatterns/&quot; + containerName.replaceFirst(&quot;Format&quot;, &quot;&quot;));</span>
<span class="line-modified"> 563                         } else if (fStyle.equals(&quot;accounting&quot;) &amp;&amp; containerName.equals(&quot;currencyFormat&quot;)) {</span>
<span class="line-modified"> 564                             pushStringEntry(qName, attributes,</span>
<span class="line-modified"> 565                                     currentNumberingSystem + &quot;NumberPatterns/accounting&quot;);</span>
<span class="line-modified"> 566                         } else {</span>
<span class="line-modified"> 567                             pushIgnoredContainer(qName);</span>
<span class="line-modified"> 568                         }</span>
<span class="line-modified"> 569                     } else {</span>
<span class="line-modified"> 570                         pushIgnoredContainer(qName);</span>
<span class="line-modified"> 571                     }</span>
<span class="line-modified"> 572                 }</span>
<span class="line-modified"> 573                 break;</span>
<span class="line-modified"> 574 </span>
<span class="line-modified"> 575                 case &quot;decimalFormat&quot;:</span>
<span class="line-modified"> 576                     if (currentStyle == null) {</span>
<span class="line-added"> 577                         pushContainer(qName, attributes);</span>
<span class="line-added"> 578                     } else {</span>
<span class="line-added"> 579                         switch (currentStyle) {</span>
<span class="line-added"> 580                             case &quot;short&quot;:</span>
<span class="line-added"> 581                             case &quot;long&quot;:</span>
 582                                 pushStringListElement(qName, attributes,
<a name="8" id="anc8"></a><span class="line-modified"> 583                                     (int) Math.log10(Double.parseDouble(attributes.getValue(&quot;type&quot;))),</span>
<span class="line-modified"> 584                                     attributes.getValue(&quot;count&quot;));</span>
<span class="line-added"> 585                                 break;</span>
<span class="line-added"> 586                             default:</span>
 587                                 pushIgnoredContainer(qName);
<a name="9" id="anc9"></a><span class="line-modified"> 588                                 break;</span>
<span class="line-modified"> 589                         }</span>



 590                     }
<a name="10" id="anc10"></a><span class="line-added"> 591                     break;</span>
<span class="line-added"> 592                 default:</span>
<span class="line-added"> 593                     pushContainer(qName, attributes);</span>
<span class="line-added"> 594                     break;</span>
<span class="line-added"> 595             }</span>
<span class="line-added"> 596             break;</span>
<span class="line-added"> 597         case &quot;currencyFormats&quot;:</span>
<span class="line-added"> 598         case &quot;decimalFormats&quot;:</span>
<span class="line-added"> 599         case &quot;percentFormats&quot;:</span>
<span class="line-added"> 600             {</span>
<span class="line-added"> 601                 String script = attributes.getValue(&quot;numberSystem&quot;);</span>
<span class="line-added"> 602                 if (script != null) {</span>
<span class="line-added"> 603                     addNumberingScript(script);</span>
<span class="line-added"> 604                     currentNumberingSystem = script + &quot;.&quot;;</span>
 605                 }
<a name="11" id="anc11"></a>
 606                 pushContainer(qName, attributes);
 607             }
 608             break;
 609         case &quot;currencyFormatLength&quot;:
 610             if (attributes.getValue(&quot;type&quot;) == null) {
 611                 // skipping type=&quot;short&quot; data
 612                 // for FormatData
 613                 pushContainer(qName, attributes);
 614             } else {
 615                 pushIgnoredContainer(qName);
 616             }
 617             break;
<a name="12" id="anc12"></a>

















 618         case &quot;defaultNumberingSystem&quot;:
 619             // default numbering system if multiple numbering systems are used.
 620             pushStringEntry(qName, attributes, &quot;DefaultNumberingSystem&quot;);
 621             break;
 622         case &quot;symbols&quot;:
 623             // for FormatData
 624             // look up numberingSystems
 625             symbols: {
 626                 String script = attributes.getValue(&quot;numberSystem&quot;);
 627                 if (script == null) {
 628                     // Has no script. Just ignore.
 629                     pushIgnoredContainer(qName);
 630                     break;
 631                 }
 632 
 633                 // Use keys as &lt;script&gt;.&quot;NumberElements/&lt;symbol&gt;&quot;
 634                 currentNumberingSystem = script + &quot;.&quot;;
 635                 String digits = CLDRConverter.handlerNumbering.get(script);
 636                 if (digits == null) {
 637                     pushIgnoredContainer(qName);
 638                     break;
 639                 }
 640 
<a name="13" id="anc13"></a><span class="line-modified"> 641                 addNumberingScript(script);</span>






 642                 put(currentNumberingSystem + &quot;NumberElements/zero&quot;, digits.substring(0, 1));
 643                 pushContainer(qName, attributes);
 644             }
 645             break;
 646         case &quot;decimal&quot;:
<a name="14" id="anc14"></a>







 647         case &quot;group&quot;:
<a name="15" id="anc15"></a><span class="line-added"> 648         case &quot;currencyDecimal&quot;:</span>
<span class="line-added"> 649         case &quot;currencyGroup&quot;:</span>
 650             // for FormatData
 651             // copy string for later assembly into NumberElements
 652             if (currentContainer.getqName().equals(&quot;symbols&quot;)) {
<a name="16" id="anc16"></a><span class="line-modified"> 653                 pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/&quot; + qName);</span>
 654             } else {
 655                 pushIgnoredContainer(qName);
 656             }
 657             break;
 658         case &quot;list&quot;:
 659             // for FormatData
 660             // copy string for later assembly into NumberElements
 661             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/list&quot;);
 662             break;
 663         case &quot;percentSign&quot;:
 664             // for FormatData
 665             // copy string for later assembly into NumberElements
 666             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/percent&quot;);
 667             break;
 668         case &quot;nativeZeroDigit&quot;:
 669             // for FormatData
 670             // copy string for later assembly into NumberElements
 671             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/zero&quot;);
 672             break;
 673         case &quot;patternDigit&quot;:
 674             // for FormatData
 675             // copy string for later assembly into NumberElements
 676             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/pattern&quot;);
 677             break;
 678         case &quot;plusSign&quot;:
 679             // TODO: DecimalFormatSymbols doesn&#39;t support plusSign
 680             pushIgnoredContainer(qName);
 681             break;
 682         case &quot;minusSign&quot;:
 683             // for FormatData
 684             // copy string for later assembly into NumberElements
 685             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/minus&quot;);
 686             break;
 687         case &quot;exponential&quot;:
 688             // for FormatData
 689             // copy string for later assembly into NumberElements
 690             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/exponential&quot;);
 691             break;
 692         case &quot;perMille&quot;:
 693             // for FormatData
 694             // copy string for later assembly into NumberElements
 695             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/permille&quot;);
 696             break;
 697         case &quot;infinity&quot;:
 698             // for FormatData
 699             // copy string for later assembly into NumberElements
 700             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/infinity&quot;);
 701             break;
 702         case &quot;nan&quot;:
 703             // for FormatData
 704             // copy string for later assembly into NumberElements
 705             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/nan&quot;);
 706             break;
 707         case &quot;timeFormatLength&quot;:
 708             {
 709                 // for FormatData
 710                 // copy string for later assembly into DateTimePatterns
 711                 String prefix = (currentCalendarType == null) ? &quot;&quot; : currentCalendarType.keyElementName();
 712                 pushStringEntry(qName, attributes, prefix + &quot;DateTimePatterns/&quot; + attributes.getValue(&quot;type&quot;) + &quot;-time&quot;);
 713             }
 714             break;
 715         case &quot;dateFormatLength&quot;:
 716             {
 717                 // for FormatData
 718                 // copy string for later assembly into DateTimePatterns
 719                 String prefix = (currentCalendarType == null) ? &quot;&quot; : currentCalendarType.keyElementName();
 720                 pushStringEntry(qName, attributes, prefix + &quot;DateTimePatterns/&quot; + attributes.getValue(&quot;type&quot;) + &quot;-date&quot;);
 721             }
 722             break;
 723         case &quot;dateTimeFormatLength&quot;:
 724             {
 725                 // for FormatData
 726                 // copy string for later assembly into DateTimePatterns
 727                 String prefix = (currentCalendarType == null) ? &quot;&quot; : currentCalendarType.keyElementName();
 728                 pushStringEntry(qName, attributes, prefix + &quot;DateTimePatterns/&quot; + attributes.getValue(&quot;type&quot;) + &quot;-dateTime&quot;);
 729             }
 730             break;
 731         case &quot;localizedPatternChars&quot;:
 732             {
 733                 // for FormatData
 734                 // copy string for later adaptation to JRE use
 735                 String prefix = (currentCalendarType == null) ? &quot;&quot; : currentCalendarType.keyElementName();
 736                 pushStringEntry(qName, attributes, prefix + &quot;DateTimePatternChars&quot;);
 737             }
 738             break;
 739 
 740         // &quot;alias&quot; for root
 741         case &quot;alias&quot;:
 742             {
 743                 if (id.equals(&quot;root&quot;) &amp;&amp; !isIgnored(attributes)
 744                         &amp;&amp; ((currentContainer.getqName().equals(&quot;decimalFormatLength&quot;))
<a name="17" id="anc17"></a><span class="line-added"> 745                         || (currentContainer.getqName().equals(&quot;currencyFormat&quot;))</span>
<span class="line-added"> 746                         || (currentContainer.getqName().equals(&quot;percentFormat&quot;))</span>
 747                         || (currentCalendarType != null &amp;&amp; !currentCalendarType.lname().startsWith(&quot;islamic-&quot;)))) { // ignore islamic variants
 748                     pushAliasEntry(qName, attributes, attributes.getValue(&quot;path&quot;));
 749                 } else {
 750                     pushIgnoredContainer(qName);
 751                 }
 752             }
 753             break;
 754 
 755         default:
 756             // treat anything else as a container
 757             pushContainer(qName, attributes);
 758             break;
 759         }
 760     }
 761 
 762     private static final String[] CONTEXTS = {&quot;stand-alone&quot;, &quot;format&quot;};
 763     private static final String[] WIDTHS = {&quot;wide&quot;, &quot;narrow&quot;, &quot;abbreviated&quot;};
 764     private static final String[] LENGTHS = {&quot;full&quot;, &quot;long&quot;, &quot;medium&quot;, &quot;short&quot;};
 765 
 766     private void populateWidthAlias(String type, Set&lt;String&gt; keys) {
 767         for (String context : CONTEXTS) {
 768             for (String width : WIDTHS) {
 769                 String keyName = toJDKKey(type+&quot;Width&quot;, context, width);
 770                 if (keyName.length() &gt; 0) {
 771                     keys.add(keyName + &quot;,&quot; + context + &quot;,&quot; + width);
 772                 }
 773             }
 774         }
 775     }
 776 
 777     private void populateFormatLengthAlias(String type, Set&lt;String&gt; keys) {
 778         for (String length: LENGTHS) {
 779             String keyName = toJDKKey(type+&quot;FormatLength&quot;, currentContext, length);
 780             if (keyName.length() &gt; 0) {
 781                 keys.add(keyName + &quot;,&quot; + currentContext + &quot;,&quot; + length);
 782             }
 783         }
 784     }
 785 
 786     private Set&lt;String&gt; populateAliasKeys(String qName, String context, String width) {
 787         HashSet&lt;String&gt; ret = new HashSet&lt;&gt;();
 788         String keyName = qName;
 789 
 790         switch (qName) {
 791         case &quot;monthWidth&quot;:
 792         case &quot;dayWidth&quot;:
 793         case &quot;quarterWidth&quot;:
 794         case &quot;dayPeriodWidth&quot;:
 795         case &quot;dateFormatLength&quot;:
 796         case &quot;timeFormatLength&quot;:
 797         case &quot;dateTimeFormatLength&quot;:
 798         case &quot;eraNames&quot;:
 799         case &quot;eraAbbr&quot;:
 800         case &quot;eraNarrow&quot;:
 801             ret.add(toJDKKey(qName, context, width) + &quot;,&quot; + context + &quot;,&quot; + width);
 802             break;
 803         case &quot;days&quot;:
 804             populateWidthAlias(&quot;day&quot;, ret);
 805             break;
 806         case &quot;months&quot;:
 807             populateWidthAlias(&quot;month&quot;, ret);
 808             break;
 809         case &quot;quarters&quot;:
 810             populateWidthAlias(&quot;quarter&quot;, ret);
 811             break;
 812         case &quot;dayPeriods&quot;:
 813             populateWidthAlias(&quot;dayPeriod&quot;, ret);
 814             break;
 815         case &quot;eras&quot;:
 816             ret.add(toJDKKey(&quot;eraNames&quot;, context, width) + &quot;,&quot; + context + &quot;,&quot; + width);
 817             ret.add(toJDKKey(&quot;eraAbbr&quot;, context, width) + &quot;,&quot; + context + &quot;,&quot; + width);
 818             ret.add(toJDKKey(&quot;eraNarrow&quot;, context, width) + &quot;,&quot; + context + &quot;,&quot; + width);
 819             break;
 820         case &quot;dateFormats&quot;:
 821             populateFormatLengthAlias(&quot;date&quot;, ret);
 822             break;
 823         case &quot;timeFormats&quot;:
 824             populateFormatLengthAlias(&quot;time&quot;, ret);
 825             break;
 826         default:
 827             break;
 828         }
 829         return ret;
 830     }
 831 
 832     private String translateWidthAlias(String qName, String context, String width) {
 833         String keyName = qName;
 834         String type = Character.toUpperCase(qName.charAt(0)) + qName.substring(1, qName.indexOf(&quot;Width&quot;));
 835 
 836         switch (width) {
 837         case &quot;wide&quot;:
 838             keyName = type + &quot;Names/&quot; + context;
 839             break;
 840         case &quot;abbreviated&quot;:
 841             keyName = type + &quot;Abbreviations/&quot; + context;
 842             break;
 843         case &quot;narrow&quot;:
 844             keyName = type + &quot;Narrows/&quot; + context;
 845             break;
 846         default:
 847             assert false;
 848         }
 849 
 850         return keyName;
 851     }
 852 
 853     private String toJDKKey(String containerqName, String context, String type) {
 854         String keyName = containerqName;
 855 
 856         switch (containerqName) {
 857         case &quot;monthWidth&quot;:
 858         case &quot;dayWidth&quot;:
 859         case &quot;quarterWidth&quot;:
 860             keyName = translateWidthAlias(keyName, context, type);
 861             break;
 862         case &quot;dayPeriodWidth&quot;:
 863             switch (type) {
 864             case &quot;wide&quot;:
 865                 keyName = &quot;AmPmMarkers/&quot; + context;
 866                 break;
 867             case &quot;narrow&quot;:
 868                 keyName = &quot;narrow.AmPmMarkers/&quot; + context;
 869                 break;
 870             case &quot;abbreviated&quot;:
 871                 keyName = &quot;abbreviated.AmPmMarkers/&quot; + context;
 872                 break;
 873             }
 874             break;
 875         case &quot;dateFormatLength&quot;:
 876         case &quot;timeFormatLength&quot;:
 877         case &quot;dateTimeFormatLength&quot;:
 878             keyName = &quot;DateTimePatterns/&quot; +
 879                 type + &quot;-&quot; +
 880                 keyName.substring(0, keyName.indexOf(&quot;FormatLength&quot;));
 881             break;
 882         case &quot;eraNames&quot;:
 883             keyName = &quot;long.Eras&quot;;
 884             break;
 885         case &quot;eraAbbr&quot;:
 886             keyName = &quot;Eras&quot;;
 887             break;
 888         case &quot;eraNarrow&quot;:
 889             keyName = &quot;narrow.Eras&quot;;
 890             break;
 891         case &quot;dateFormats&quot;:
 892         case &quot;timeFormats&quot;:
 893         case &quot;days&quot;:
 894         case &quot;months&quot;:
 895         case &quot;quarters&quot;:
 896         case &quot;dayPeriods&quot;:
 897         case &quot;eras&quot;:
 898             break;
 899         case &quot;decimalFormatLength&quot;: // used for compact number formatting patterns
 900             keyName = type + &quot;.CompactNumberPatterns&quot;;
 901             break;
<a name="18" id="anc18"></a><span class="line-added"> 902         case &quot;currencyFormat&quot;:</span>
<span class="line-added"> 903         case &quot;percentFormat&quot;:</span>
<span class="line-added"> 904             keyName = currentNumberingSystem +</span>
<span class="line-added"> 905                     &quot;NumberPatterns/&quot; +</span>
<span class="line-added"> 906                     (type.equals(&quot;standard&quot;) ? containerqName.replaceFirst(&quot;Format&quot;, &quot;&quot;) : type);</span>
<span class="line-added"> 907             break;</span>
 908         default:
 909             keyName = &quot;&quot;;
 910             break;
 911         }
 912 
 913         return keyName;
 914     }
 915 
 916     private String getTarget(String path, String calType, String context, String width) {
 917         // Target qName
 918         int lastSlash = path.lastIndexOf(&#39;/&#39;);
 919         String qName = path.substring(lastSlash+1);
 920         int bracket = qName.indexOf(&#39;[&#39;);
 921         if (bracket != -1) {
 922             qName = qName.substring(0, bracket);
 923         }
 924 
 925         // calType
 926         String typeKey = &quot;/calendar[@type=&#39;&quot;;
 927         int start = path.indexOf(typeKey);
 928         if (start != -1) {
 929             calType = path.substring(start+typeKey.length(), path.indexOf(&quot;&#39;]&quot;, start));
 930         }
 931 
 932         // context
 933         typeKey = &quot;Context[@type=&#39;&quot;;
 934         start = path.indexOf(typeKey);
 935         if (start != -1) {
 936             context = (path.substring(start+typeKey.length(), path.indexOf(&quot;&#39;]&quot;, start)));
 937         }
 938 
 939         // width
 940         typeKey = &quot;Width[@type=&#39;&quot;;
 941         start = path.indexOf(typeKey);
 942         if (start != -1) {
 943             width = path.substring(start+typeKey.length(), path.indexOf(&quot;&#39;]&quot;, start));
 944         }
 945 
 946         // used for compact number formatting patterns aliases
 947         typeKey = &quot;decimalFormatLength[@type=&#39;&quot;;
 948         start = path.indexOf(typeKey);
 949         if (start != -1) {
 950             String style = path.substring(start + typeKey.length(), path.indexOf(&quot;&#39;]&quot;, start));
 951             return toJDKKey(qName, &quot;&quot;, style);
 952         }
 953 
<a name="19" id="anc19"></a><span class="line-added"> 954         // currencyFormat</span>
<span class="line-added"> 955         typeKey = &quot;currencyFormat[@type=&#39;&quot;;</span>
<span class="line-added"> 956         start = path.indexOf(typeKey);</span>
<span class="line-added"> 957         if (start != -1) {</span>
<span class="line-added"> 958             String style = path.substring(start + typeKey.length(), path.indexOf(&quot;&#39;]&quot;, start));</span>
<span class="line-added"> 959             return toJDKKey(qName, &quot;&quot;, style);</span>
<span class="line-added"> 960         }</span>
<span class="line-added"> 961 </span>
<span class="line-added"> 962         // percentFormat</span>
<span class="line-added"> 963         typeKey = &quot;percentFormat[@type=&#39;&quot;;</span>
<span class="line-added"> 964         start = path.indexOf(typeKey);</span>
<span class="line-added"> 965         if (start != -1) {</span>
<span class="line-added"> 966             String style = path.substring(start + typeKey.length(), path.indexOf(&quot;&#39;]&quot;, start));</span>
<span class="line-added"> 967             return toJDKKey(qName, &quot;&quot;, style);</span>
<span class="line-added"> 968         }</span>
<span class="line-added"> 969 </span>
 970         return calType + &quot;.&quot; + toJDKKey(qName, context, width);
 971     }
 972 
 973     @Override
 974     public void endElement(String uri, String localName, String qName) throws SAXException {
 975         assert qName.equals(currentContainer.getqName()) : &quot;current=&quot; + currentContainer.getqName() + &quot;, param=&quot; + qName;
 976         switch (qName) {
 977         case &quot;calendar&quot;:
 978             assert !(currentContainer instanceof Entry);
 979             currentCalendarType = null;
 980             break;
 981 
 982         case &quot;defaultNumberingSystem&quot;:
 983             if (currentContainer instanceof StringEntry) {
<a name="20" id="anc20"></a><span class="line-modified"> 984                 defaultNumberingSystem = (String) putIfEntry();</span>


 985             } else {
 986                 defaultNumberingSystem = null;
 987             }
 988             break;
 989 
 990         case &quot;timeZoneNames&quot;:
 991             zonePrefix = null;
 992             break;
 993 
 994         case &quot;generic&quot;:
 995         case &quot;standard&quot;:
 996         case &quot;daylight&quot;:
 997         case &quot;exemplarCity&quot;:
 998             if (zonePrefix != null &amp;&amp; (currentContainer instanceof Entry)) {
 999                 @SuppressWarnings(&quot;unchecked&quot;)
1000                 Map&lt;String, String&gt; valmap = (Map&lt;String, String&gt;) get(zonePrefix + getContainerKey());
1001                 Entry&lt;?&gt; entry = (Entry&lt;?&gt;) currentContainer;
1002                 if (qName.equals(&quot;exemplarCity&quot;)) {
1003                     put(CLDRConverter.EXEMPLAR_CITY_PREFIX + getContainerKey(), (String) entry.getValue());
1004                 } else {
1005                     valmap.put(entry.getKey(), (String) entry.getValue());
1006                 }
1007             }
1008             break;
1009 
1010         case &quot;monthWidth&quot;:
1011         case &quot;dayWidth&quot;:
1012         case &quot;dayPeriodWidth&quot;:
1013         case &quot;quarterWidth&quot;:
1014             currentWidth = &quot;&quot;;
1015             putIfEntry();
1016             break;
1017 
1018         case &quot;monthContext&quot;:
1019         case &quot;dayContext&quot;:
1020         case &quot;dayPeriodContext&quot;:
1021         case &quot;quarterContext&quot;:
1022             currentContext = &quot;&quot;;
1023             putIfEntry();
1024             break;
1025         case &quot;decimalFormatLength&quot;:
1026             currentStyle = &quot;&quot;;
<a name="21" id="anc21"></a><span class="line-modified">1027             putIfEntry();</span>
<span class="line-added">1028             break;</span>
<span class="line-added">1029         case &quot;currencyFormats&quot;:</span>
<span class="line-added">1030         case &quot;decimalFormats&quot;:</span>
<span class="line-added">1031         case &quot;percentFormats&quot;:</span>
<span class="line-added">1032         case &quot;symbols&quot;:</span>
<span class="line-added">1033             currentNumberingSystem = &quot;&quot;;</span>
1034             putIfEntry();
1035             break;
1036         default:
1037             putIfEntry();
1038         }
1039         currentContainer = currentContainer.getParent();
1040     }
1041 
<a name="22" id="anc22"></a><span class="line-modified">1042     private Object putIfEntry() {</span>
1043         if (currentContainer instanceof AliasEntry) {
1044             Entry&lt;?&gt; entry = (Entry&lt;?&gt;) currentContainer;
1045             String containerqName = entry.getParent().getqName();
1046             if (containerqName.equals(&quot;decimalFormatLength&quot;)) {
1047                 String srcKey = toJDKKey(containerqName, &quot;&quot;, currentStyle);
1048                 String targetKey = getTarget(entry.getKey(), &quot;&quot;, &quot;&quot;, &quot;&quot;);
1049                 CLDRConverter.aliases.put(srcKey, targetKey);
<a name="23" id="anc23"></a><span class="line-added">1050             } else if (containerqName.equals(&quot;currencyFormat&quot;) ||</span>
<span class="line-added">1051                         containerqName.equals(&quot;percentFormat&quot;)) {</span>
<span class="line-added">1052                 KeyContainer kc = (KeyContainer)entry.getParent();</span>
<span class="line-added">1053                 CLDRConverter.aliases.put(</span>
<span class="line-added">1054                         toJDKKey(containerqName, &quot;&quot;, kc.getKey()),</span>
<span class="line-added">1055                         getTarget(entry.getKey(), &quot;&quot;, &quot;&quot;, &quot;&quot;)</span>
<span class="line-added">1056                 );</span>
1057             } else {
1058                 Set&lt;String&gt; keyNames = populateAliasKeys(containerqName, currentContext, currentWidth);
1059                 if (!keyNames.isEmpty()) {
1060                     for (String keyName : keyNames) {
1061                         String[] tmp = keyName.split(&quot;,&quot;, 3);
1062                         String calType = currentCalendarType.lname();
1063                         String src = calType+&quot;.&quot;+tmp[0];
1064                         String target = getTarget(
1065                                     entry.getKey(),
1066                                     calType,
1067                                     tmp[1].length()&gt;0 ? tmp[1] : currentContext,
1068                                     tmp[2].length()&gt;0 ? tmp[2] : currentWidth);
1069                         if (target.substring(target.lastIndexOf(&#39;.&#39;)+1).equals(containerqName)) {
1070                             target = target.substring(0, target.indexOf(&#39;.&#39;))+&quot;.&quot;+tmp[0];
1071                         }
1072                         CLDRConverter.aliases.put(src.replaceFirst(&quot;^gregorian.&quot;, &quot;&quot;),
1073                                                   target.replaceFirst(&quot;^gregorian.&quot;, &quot;&quot;));
1074                     }
1075                 }
1076             }
1077         } else if (currentContainer instanceof Entry) {
1078             Entry&lt;?&gt; entry = (Entry&lt;?&gt;) currentContainer;
1079             Object value = entry.getValue();
1080             if (value != null) {
1081                 String key = entry.getKey();
1082                 // Tweak for MonthNames for the root locale, Needed for
1083                 // SimpleDateFormat.format()/parse() roundtrip.
1084                 if (id.equals(&quot;root&quot;) &amp;&amp; key.startsWith(&quot;MonthNames&quot;)) {
1085                     value = new DateFormatSymbols(Locale.US).getShortMonths();
1086                 }
<a name="24" id="anc24"></a><span class="line-modified">1087                 return put(entry.getKey(), value);</span>
1088             }
1089         }
<a name="25" id="anc25"></a><span class="line-added">1090         return null;</span>
1091     }
1092 
1093     public String convertOldKeyName(String key) {
1094         // Explicitly obtained from &quot;alias&quot; attribute in each &quot;key&quot; element.
1095         switch (key) {
1096             case &quot;calendar&quot;:
1097                 return &quot;ca&quot;;
1098             case &quot;currency&quot;:
1099                 return &quot;cu&quot;;
1100             case &quot;collation&quot;:
1101                 return &quot;co&quot;;
1102             case &quot;numbers&quot;:
1103                 return &quot;nu&quot;;
1104             case &quot;timezone&quot;:
1105                 return &quot;tz&quot;;
1106             default:
1107                 return key;
1108         }
1109     }
<a name="26" id="anc26"></a><span class="line-added">1110 </span>
<span class="line-added">1111     private void addNumberingScript(String script) {</span>
<span class="line-added">1112         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">1113         List&lt;String&gt; numberingScripts = (List&lt;String&gt;) get(&quot;numberingScripts&quot;);</span>
<span class="line-added">1114         if (numberingScripts == null) {</span>
<span class="line-added">1115             numberingScripts = new ArrayList&lt;&gt;();</span>
<span class="line-added">1116             put(&quot;numberingScripts&quot;, numberingScripts);</span>
<span class="line-added">1117         }</span>
<span class="line-added">1118         if (!numberingScripts.contains(script)) {</span>
<span class="line-added">1119             numberingScripts.add(script);</span>
<span class="line-added">1120         }</span>
<span class="line-added">1121     }</span>
1122 }
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
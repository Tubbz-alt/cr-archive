<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New make/jdk/src/classes/build/tools/fixuppandoc/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package build.tools.fixuppandoc;
 27 
 28 import java.io.BufferedReader;
 29 import java.io.BufferedWriter;
 30 import java.io.IOException;
 31 import java.io.InputStreamReader;
 32 import java.io.OutputStreamWriter;
 33 import java.io.PrintStream;
 34 import java.io.PrintWriter;
 35 import java.io.Reader;
 36 import java.io.Writer;
 37 import java.nio.file.Files;
 38 import java.nio.file.Path;
 39 import java.util.ArrayList;
 40 import java.util.LinkedHashMap;
 41 import java.util.LinkedHashSet;
 42 import java.util.List;
 43 import java.util.Locale;
 44 import java.util.Map;
 45 import java.util.Objects;
 46 import java.util.Set;
 47 import java.util.regex.Matcher;
 48 import java.util.regex.Pattern;
 49 import static java.nio.charset.StandardCharsets.UTF_8;
 50 
 51 /**
 52  * Fixup HTML generated by pandoc.
 53  *
 54  * &lt;h2&gt;{@code &lt;html&gt;}&lt;/h2&gt;
 55  *
 56  * Replace the existing element with {@code &lt;html lang=&quot;en&quot;&gt;}, removing references to XML.
 57  *
 58  * &lt;h2&gt;{@code &lt;main&gt;}&lt;/h2&gt;
 59  *
 60  * {@code &lt;main&gt;} is inserted if palpable content is found that is not with a
 61  * section such as {@code header},  {@code footer},  {@code aside}.
 62  *
 63  * {@code &lt;/main&gt;} is inserted if {@code &lt;main&gt;} was inserted and a section
 64  * is started that should not be included in the main section.
 65  *
 66  * &lt;h2&gt;Tables: row headings&lt;/h2&gt;
 67  *
 68  * For simple tables, as typically generated by _pandoc_, determine the column
 69  * whose contents are unique, and convert the cells in that column to be header
 70  * cells with {@code scope=&quot;row&quot;}. In case of ambiguity, a column containing a
 71  * {@code &lt;th&gt;} whose contents begin with &lt;em&gt;name&lt;/em&gt; is preferred.
 72  * When converting the cell, the {@code style} attribute will be updated to
 73  * specify {@code font-weight: normal}, and if there is not already an explicit
 74  * setting for {@code text-align}, then the style will be updated to include
 75  * {@code text-align:left;}.
 76  *
 77  * These rules do not apply if the table contains any cells that include
 78  * a setting for the {@code scope} attribute, or if the table contains
 79  * spanning cells or nested tables.
 80  *
 81  * &lt;h2&gt;{@code &lt;meta name=&quot;generator&quot;&gt;}&lt;/h2&gt;
 82  *
 83  * Update the content string, to indicate it has been processed by this program.
 84  *
 85  * &lt;h2&gt;{@code &lt;nav id=&quot;TOC&quot;&gt;}&lt;/h2&gt;
 86  *
 87  * Set attribute {@code title=&quot;Table Of Contents&quot;}
 88  *
 89  */
 90 public class Main {
 91     /**
 92      * Runs the program.
 93      *
 94      * &lt;pre&gt;
 95      *     java build.tools.fixuppandoc.Main [-o output-file] [input-file]
 96      * &lt;/pre&gt;
 97      *
 98      * If no input file is specified, the program will read from standard input.
 99      * If no output file is specified, the program will write to standard output.
100      * Any error messages will be written to the standard error stream.
101      *
102      * Consistent with the
103      * &lt;a href=&quot;https://pandoc.org/MANUAL.html#character-encoding&quot;&gt;pandoc tool&lt;/a&gt;,
104      * input and output text is encoded as UTF-8.
105      *
106      * @param args the command-line arguments
107      */
108     public static void main(String... args) {
109         try {
110             new Main().run(args);
111         } catch (IOException | IllegalArgumentException e) {
112             System.err.println(e);
113             System.exit(1);
114         } catch (Throwable t) {
115             t.printStackTrace(System.err);
116             System.exit(1);
117         }
118     }
119 
120     private void run(String... args) throws IOException {
121         Path inFile = null;
122         Path outFile = null;
123 
124         for (int i = 0; i &lt; args.length; i++) {
125             String arg = args[i];
126             if (arg.equals(&quot;-o&quot;) &amp;&amp; i + 1 &lt; args.length) {
127                 outFile = Path.of(args[++i]);
128             } else if (arg.startsWith(&quot;-&quot;)) {
129                 throw new IllegalArgumentException(arg);
130             } else if (inFile == null) {
131                 inFile = Path.of(arg);
132             } else {
133                 throw new IllegalArgumentException(arg);
134             }
135         }
136 
137         new Fixup().run(inFile, outFile);
138     }
139 
140     /**
141      * A class to read HTML, copying input to output, modifying
142      * fragments as needed.
143      */
144     class Fixup extends HtmlParser {
145         /** The output stream. */
146         PrintWriter out;
147 
148         /** A stream for reporting errors. */
149         PrintStream err = System.err;
150 
151         /**
152          * Flag to indicate when {@code &lt;main&gt;} is permitted around palpable content.
153          * Set within {@code &lt;body&gt;}; disabled within elements in which {@code &lt;main&gt;}
154          * is not permitted.
155          */
156         boolean allowMain = false;
157 
158         /**
159          * Flag to indicate that {@code &lt;main&gt;} is required.
160          * Set on {@code &lt;body&gt;}; reset when {@code &lt;main&gt;} is either found or generated.
161          */
162         boolean needMain = false;
163 
164         /**
165          * Flag to indicate that {@code &lt;/main&gt;} is required.
166          * Set if {@code &lt;main&gt;} is generated.
167          * Reset when a start or end element is found that requires that {@code &lt;/main&gt;}
168          * needs to be generated if necessary.
169          */
170         boolean needEndMain = false;
171 
172         /**
173          * Handler for {@code &lt;table&gt;} elements.
174          */
175         Table table;
176 
177         /**
178          * Run the program, copying an input file to an output file.
179          * If the input file is {@code null}, input is read from the standard input.
180          * If the output file is {@code null}, output is written to the standard output.
181          *
182          * @param inFile the input file
183          * @param outFile the output file
184          * @throws IOException if an IO error occurs
185          */
186         void run(Path inFile, Path outFile) throws IOException {
187             try (Writer out = openWriter(outFile)) {
188                 this.out = new PrintWriter(out);
189                 if (inFile != null) {
190                     read(inFile);
191                 } else {
192                     read(new BufferedReader(new InputStreamReader(System.in, UTF_8)));
193                 }
194             }
195         }
196 
197         /**
198          * Returns a writer for a file, or for the standard output if the file is {@code null}.
199          *
200          * @param file the file
201          * @return the writer
202          * @throws IOException if an IO error occurs
203          */
204         private Writer openWriter(Path file) throws IOException {
205             if (file != null) {
206                 return Files.newBufferedWriter(file, UTF_8);
207             } else {
208                 return new BufferedWriter(new OutputStreamWriter(System.out, UTF_8) {
209                     @Override
210                     public void close() throws IOException {
211                         flush();
212                     }
213                 });
214             }
215         }
216 
217         @Override
218         protected void error(Path file, int lineNumber, String message) {
219             err.print(file == null ? &quot;&lt;stdin&gt;&quot; : file);
220             if (lineNumber &gt; 0) {
221                 err.print(&quot;:&quot;);
222                 err.print(lineNumber);
223             }
224             err.print(&quot;: &quot;);
225             err.println(message);
226         }
227 
228         @Override
229         protected void error(Path file, int lineNumber, Throwable t) {
230             error(file, lineNumber, t.toString());
231             t.printStackTrace(err);
232         }
233 
234         /**
235          * The buffer in which input is stored until an appropriate action can be determined.
236          * Using the buffer ensures that the output exactly matches the input, except where
237          * it is intentionally modified.
238          */
239         private StringBuilder buffer = new StringBuilder();
240 
241         @Override
242         public int nextChar() throws IOException {
243             if (ch &gt; 0) {
244                 buffer.append((char) ch);
245             }
246             return super.nextChar();
247         }
248 
249         @Override
250         protected void doctype(String s) {
251             flushBuffer();
252         }
253 
254         @Override
255         protected void startElement(String name, Map&lt;String,String&gt; attrs, boolean selfClosing) {
256             switch (name) {
257                 case &quot;html&quot;:
258                     // replace the existing &lt;html&gt; fragment
259                     out.write(&quot;&lt;html lang=\&quot;en\&quot;&gt;&quot;);
260                     buffer.setLength(0);
261                     break;
262 
263                 case &quot;meta&quot;:
264                     // update the meta-data for the generator
265                     if (Objects.equals(attrs.get(&quot;name&quot;), &quot;generator&quot;)) {
266                         out.write(buffer.toString()
267                                 .replaceAll(&quot;(content=\&quot;[^\&quot;]*)(\&quot;)&quot;, &quot;$1,fixuphtml$2&quot;));
268                         buffer.setLength(0);
269                     }
270                     break;
271 
272                 case &quot;article&quot;:
273                 case &quot;aside&quot;:
274                 case &quot;footer&quot;:
275                 case &quot;header&quot;:
276                 case &quot;nav&quot;:
277                     // starting one of these elements will terminate &lt;main&gt; if one is being
278                     // inserted
279                     if (needEndMain) {
280                         out.write(&quot;&lt;/main&gt;&quot;);
281                         needEndMain = false;
282                     }
283                     // &lt;main&gt; is not permitted within these elements
284                     allowMain = false;
285                     if (name.equals(&quot;nav&quot;) &amp;&amp; Objects.equals(attrs.get(&quot;id&quot;), &quot;TOC&quot;)) {
286                         out.write(buffer.toString()
287                                 .replaceAll(&quot;&gt;$&quot;, &quot; title=\&quot;Table Of Contents\&quot;&gt;&quot;));
288                         buffer.setLength(0);
289                     }
290                     break;
291 
292                 case &quot;body&quot;:
293                     // within &lt;body&gt;, &lt;main&gt; is both permitted and required
294                     allowMain = true;
295                     needMain = true;
296                     break;
297 
298                 case &quot;main&quot;:
299                     // an explicit &lt;main&gt; found in the input; no need to add one
300                     needMain = false;
301                     break;
302 
303                 case &quot;table&quot;:
304                     // The entire content of a &lt;table&gt; is buffered, until it can be
305                     // determined in which column of the table contains the cells
306                     // that can be used to identify the row.
307                     if (table == null) {
308                         table = new Table();
309                     } else {
310                         // tables containing nested tables are not updated
311                         table.simple = false;
312                     }
313                     table.nestDepth++;
314                     break;
315 
316                 case &quot;thead&quot;:
317                 case &quot;tbody&quot;:
318                     if (table != null) {
319                         table.endCell();
320                     }
321                     break;
322 
323                 case &quot;tr&quot;:
324                     if (table != null) {
325                         table.endCell();
326                         table.nextCellColumnIndex = 0;
327                     }
328                     break;
329 
330                 case &quot;td&quot;:
331                 case &quot;th&quot;:
332                     if (table != null) {
333                         if (attrs.containsKey(&quot;rowspan&quot;)
334                                 || attrs.containsKey(&quot;colspan&quot;)
335                                 || attrs.containsKey(&quot;scope&quot;)) {
336                             // tables containing spanning cells and tables that already
337                             // contain scope attributes are not updated
338                             table.simple = false;
339                         }
340                         table.startCell(name);
341                     }
342                     break;
343             }
344 
345             // by default, the content is deemed to be palpable content, and so
346             // insert &lt;main&gt; if it is permitted and one is still required,
347             // while also ensuring that it does not appear before &lt;body&gt;
348             if (allowMain &amp;&amp; needMain &amp;&amp; !name.equals(&quot;body&quot;)) {
349                 out.write(&quot;&lt;main&gt;&quot;);
350                 needMain = false;
351                 needEndMain = true;
352             }
353 
354             flushBuffer();
355         }
356 
357         @Override
358         protected void endElement(String name) {
359             switch (name) {
360                 case &quot;article&quot;:
361                 case &quot;aside&quot;:
362                 case &quot;footer&quot;:
363                 case &quot;header&quot;:
364                 case &quot;nav&quot;:
365                     // The code does not handle nested elements of these kinds, but could.
366                     // So, assuming they are not nested, ending these elements implies
367                     // that &lt;main&gt; is once again permitted.
368                     allowMain = true;
369                     break;
370 
371                 case &quot;body&quot;:
372                     // The document is nearly done; insert &lt;main&gt; if needed
373                     if (needEndMain) {
374                         out.write(&quot;&lt;/main&gt;&quot;);
375                         needEndMain = false;
376                     }
377                     break;
378 
379                 case &quot;table&quot;:
380                     // if the table is finished, analyze it and write it out
381                     if (table != null) {
382                         if (--table.nestDepth == 0) {
383                             table.add(buffer.toString());
384                             table.write(out);
385                             table = null;
386                             buffer.setLength(0);
387                         }
388                     }
389                     break;
390 
391                 case &quot;thead&quot;:
392                 case &quot;tbody&quot;:
393                 case &quot;tr&quot;:
394                 case &quot;td&quot;:
395                 case &quot;th&quot;:
396                     // ending any of these elements implicity or explicitly ends the
397                     // current cell
398                     table.endCell();
399                     break;
400 
401             }
402             flushBuffer();
403         }
404 
405         @Override
406         protected void content(String content) {
407             if (table != null) {
408                 table.content(content);
409             } else if (allowMain &amp;&amp; needMain &amp;&amp; !content.isBlank()) {
410                 // insert &lt;main&gt; if required and if we have palpable content
411                 out.write(&quot;&lt;main&gt;&quot;);
412                 needMain = false;
413                 needEndMain = true;
414             }
415             flushBuffer();
416         }
417 
418         @Override
419         protected void comment(String comment) {
420             flushBuffer();
421         }
422 
423         /**
424          * Flushes the buffer, either by adding it into a table, if one is
425          * in progress, or by writing it out.
426          */
427         private void flushBuffer() {
428             String s = buffer.toString();
429             if (table != null) {
430                 table.add(s);
431             } else {
432                 out.write(s);
433             }
434             buffer.setLength(0);
435 
436         }
437     }
438 
439     /**
440      * Storage for the content of a {@code &lt;table&gt;} element} until we can determine
441      * whether we should add {@code scope=&quot;row&quot;} to the cells in a given column,
442      * and if so, which column.
443      *
444      * The column with the highest number of unique entries is selected;
445      * in case of ambiguity, a column whose heading begins &quot;name&quot; is chosen.
446      *
447      * Only &quot;simple&quot; tables are supported. Tables with any of the following
448      * features are not considered &quot;simple&quot; and will not be modified:
449      * &lt;ul&gt;
450      *     &lt;li&gt;Tables containing nested tables&lt;/li&gt;
451      *     &lt;li&gt;Tables containing cells that use &quot;rowspan&quot; and &quot;colspan&quot; attributes&lt;/li&gt;
452      *     &lt;li&gt;Tables containing cells that already use &quot;scope&quot; attributes&lt;/li&gt;
453      * &lt;/ul&gt;
454      */
455     class Table {
456         /**
457          * A fragment of HTML in this table.
458          */
459         class Entry {
460             /** The fragment. */
461             final String html;
462             /** The column for a {@code &lt;td&gt;} fragment, or -1. */
463             final int column;
464 
465             Entry(String html, int column) {
466                 this.html = html;
467                 this.column = column;
468             }
469         }
470 
471         /** Whether or not this is a &quot;simple&quot; table. */
472         boolean simple = true;
473 
474         /** The nesting depth of the current table, within enclosing tables. */
475         int nestDepth;
476 
477         /** A list of the HTML fragments that make up this table. */
478         List&lt;Entry&gt; entries;
479 
480         /** The plain text contents of each column, used to determine the primary column. */
481         List&lt;Set&lt;String&gt;&gt; columnContents;
482 
483         /** The column index of the next cell to be found. */
484         int nextCellColumnIndex;
485 
486         /** A flag to mark the start of a {@code &lt;td&gt;} cell. */
487         boolean startTDCell;
488 
489         /** The column index of the current cell, or -1 if not in a cell. */
490         int currCellColumnIndex;
491 
492         /** The plain text contents of the current column. */
493         Set&lt;String&gt; currColumnContents;
494 
495         /** The plain text content of the current cell. */
496         StringBuilder currCellContent;
497 
498         /** The kind ({@code th} or {@code td}) of the current cell. */
499         String currCellKind;
500 
501         /**
502          * The index of the column, if any, containing a heading beginning &quot;name&quot;.
503          * This column is given preferential treatment when deciding the primary column.
504          */
505         int nameColumn;
506 
507         Table() {
508             entries = new ArrayList&lt;&gt;();
509             columnContents = new ArrayList&lt;&gt;();
510         }
511 
512         void startCell(String name) {
513             endCell();
514             startTDCell = name.equals(&quot;td&quot;);
515             currCellColumnIndex = nextCellColumnIndex++;
516             currColumnContents = getColumn(currCellColumnIndex);
517             currCellContent = new StringBuilder();
518             currCellKind = name;
519         }
520 
521         void endCell() {
522             if (currCellContent != null) {
523                 String c = currCellContent.toString().trim();
524                 if (Objects.equals(currCellKind, &quot;th&quot;)
525                         &amp;&amp; c.toLowerCase(Locale.US).startsWith(&quot;name&quot;)) {
526                     nameColumn = currCellColumnIndex;
527                 }
528                 currColumnContents.add(c);
529                 currCellContent = null;
530                 currCellColumnIndex = -1;
531                 currColumnContents = null;
532             }
533         }
534 
535         void content(String content) {
536             if (currCellContent != null) {
537                 currCellContent.append(content);
538             }
539         }
540 
541         void add(String html) {
542             int index = startTDCell ? currCellColumnIndex : -1;
543             entries.add(new Entry(html, index));
544             startTDCell = false;
545         }
546 
547         void write(PrintWriter out) {
548             int max = -1;
549             int maxIndex = -1;
550             int index = 0;
551             for (Set&lt;String&gt; c : columnContents) {
552                 if (c.size() &gt; max || c.size() == max &amp;&amp; index == nameColumn) {
553                     max = c.size();
554                     maxIndex = index;
555                 }
556                 index++;
557             }
558             boolean updateEndTd = false;
559             Pattern styleAttr = Pattern.compile(&quot;(?&lt;before&gt;.*style=\&quot;)(?&lt;style&gt;[^\&quot;]*)(?&lt;after&gt;\&quot;.*)&quot;);
560             for (Entry e : entries) {
561                 if (simple &amp;&amp; e.column == maxIndex) {
562                     String attrs = e.html.substring(3, e.html.length() - 1);
563                     out.write(&quot;&lt;th&quot;);
564                     Matcher m = styleAttr.matcher(attrs);
565                     if (m.matches()) {
566                         out.write(m.group(&quot;before&quot;));
567                         out.write(&quot;font-weight: normal; &quot;);
568                         String style = m.group(&quot;style&quot;);
569                         if (!style.contains(&quot;text-align&quot;)) {
570                             out.write(&quot;text-align: left; &quot;);
571                         }
572                         out.write(style);
573                         out.write(m.group(&quot;after&quot;));
574                     } else {
575                         out.write(&quot; style=\&quot;font-weight: normal; text-align:left;\&quot; &quot;);
576                         out.write(attrs);
577                     }
578                     out.write(&quot; scope=\&quot;row\&quot;&quot;);
579                     out.write(&quot;&gt;&quot;);
580                     updateEndTd = true;
581                 } else if (updateEndTd &amp;&amp; e.html.equalsIgnoreCase(&quot;&lt;/td&gt;&quot;)) {
582                     out.write(&quot;&lt;/th&gt;&quot;);
583                     updateEndTd = false;
584                 } else {
585                     out.write(e.html);
586                     if (updateEndTd &amp;&amp; e.html.regionMatches(true, 0, &quot;&lt;td&quot;, 0, 3)) {
587                         // a new cell has been started without explicitly closing the
588                         // cell that was being updated
589                         updateEndTd = false;
590                     }
591                 }
592             }
593         }
594 
595         private Set&lt;String&gt; getColumn(int index) {
596             while (columnContents.size() &lt;= index) {
597                 columnContents.add(new LinkedHashSet&lt;&gt;());
598             }
599 
600             return columnContents.get(index);
601         }
602     }
603 
604     /**
605      * A basic HTML parser.
606      * Override the protected methods as needed to get notified of significant items
607      * in any file that is read.
608      */
609     abstract class HtmlParser {
610 
611         private Path file;
612         private Reader in;
613         protected int ch;
614         private int lineNumber;
615         private boolean inScript;
616         private boolean xml;
617 
618         /**
619          * Read a file.
620          * @param file the file
621          */
622         void read(Path file) {
623             try (Reader r = Files.newBufferedReader(file, UTF_8)) {
624                 this.file = file;
625                 read(r);
626             } catch (IOException e) {
627                 error(file, -1, e);
628             }
629         }
630 
631         HtmlParser() { }
632 
633         /**
634          * Read a stream.
635          * @param r the stream
636          */
637         void read(Reader r) {
638             try {
639                 this.in = r;
640                 StringBuilder content = new StringBuilder();
641 
642                 startFile(file);
643                 try {
644                     lineNumber = 1;
645                     xml = false;
646                     nextChar();
647 
648                     while (ch != -1) {
649                         if (ch == &#39;&lt;&#39;) {
650                             content(content.toString());
651                             content.setLength(0);
652                             html();
653                         } else {
654                             content.append((char) ch);
655                             if (ch == &#39;\n&#39;) {
656                                 content(content.toString());
657                                 content.setLength(0);
658                             }
659                             nextChar();
660                         }
661                     }
662                 } finally {
663                     endFile();
664                 }
665             } catch (IOException e) {
666                 error(file, lineNumber, e);
667             } catch (Throwable t) {
668                 error(file, lineNumber, t);
669                 t.printStackTrace(System.err);
670             }
671         }
672 
673         protected int getLineNumber() {
674             return lineNumber;
675         }
676 
677         /**
678          * Called when a file has been opened, before parsing begins.
679          * This is always the first notification when reading a file.
680          * This implementation does nothing.
681          *
682          * @param file the file
683          */
684         protected void startFile(Path file) { }
685 
686         /**
687          * Called when the parser has finished reading a file.
688          * This is always the last notification when reading a file,
689          * unless any errors occur while closing the file.
690          * This implementation does nothing.
691          */
692         protected void endFile() { }
693 
694         /**
695          * Called when a doctype declaration is found, at the beginning of the file.
696          * This implementation does nothing.
697          * @param s the doctype declaration
698          */
699         protected void doctype(String s) { }
700 
701         /**
702          * Called when the opening tag of an HTML element is encountered.
703          * This implementation does nothing.
704          * @param name the name of the tag
705          * @param attrs the attribute
706          * @param selfClosing whether or not this is a self-closing tag
707          */
708         protected void startElement(String name, Map&lt;String,String&gt; attrs, boolean selfClosing) { }
709 
710         /**
711          * Called when the closing tag of an HTML tag is encountered.
712          * This implementation does nothing.
713          * @param name the name of the tag
714          */
715         protected void endElement(String name) { }
716 
717         /**
718          * Called for sequences of character content.
719          * @param content the character content
720          */
721         protected void content(String content) { }
722 
723         /**
724          * Called for sequences of comment.
725          * @param comment the comment
726          */
727         protected void comment(String comment) { }
728 
729         /**
730          * Called when an error has been encountered.
731          * @param file the file being read
732          * @param lineNumber the line number of line containing the error
733          * @param message a description of the error
734          */
735         protected abstract void error(Path file, int lineNumber, String message);
736 
737         /**
738          * Called when an exception has been encountered.
739          * @param file the file being read
740          * @param lineNumber the line number of the line being read when the exception was found
741          * @param t the exception
742          */
743         protected abstract void error(Path file, int lineNumber, Throwable t);
744 
745         protected int nextChar() throws IOException {
746             ch = in.read();
747             if (ch == &#39;\n&#39;)
748                 lineNumber++;
749             return ch;
750         }
751 
752         /**
753          * Read the start or end of an HTML tag, or an HTML comment
754          * {@literal &lt;identifier attrs&gt; } or {@literal &lt;/identifier&gt; }
755          * @throws java.io.IOException if there is a problem reading the file
756          */
757         protected void html() throws IOException {
758             nextChar();
759             if (isIdentifierStart((char) ch)) {
760                 String name = readIdentifier().toLowerCase(Locale.US);
761                 Map&lt;String,String&gt; attrs = htmlAttrs();
762                 if (attrs != null) {
763                     boolean selfClosing = false;
764                     if (ch == &#39;/&#39;) {
765                         nextChar();
766                         selfClosing = true;
767                     }
768                     if (ch == &#39;&gt;&#39;) {
769                         nextChar();
770                         startElement(name, attrs, selfClosing);
771                         if (name.equals(&quot;script&quot;)) {
772                             inScript = true;
773                         }
774                         return;
775                     }
776                 }
777             } else if (ch == &#39;/&#39;) {
778                 nextChar();
779                 if (isIdentifierStart((char) ch)) {
780                     String name = readIdentifier().toLowerCase(Locale.US);
781                     skipWhitespace();
782                     if (ch == &#39;&gt;&#39;) {
783                         nextChar();
784                         endElement(name);
785                         if (name.equals(&quot;script&quot;)) {
786                             inScript = false;
787                         }
788                         return;
789                     }
790                 }
791             } else if (ch == &#39;!&#39;) {
792                 nextChar();
793                 if (ch == &#39;-&#39;) {
794                     nextChar();
795                     if (ch == &#39;-&#39;) {
796                         nextChar();
797                         StringBuilder comment = new StringBuilder();
798                         while (ch != -1) {
799                             int dash = 0;
800                             while (ch == &#39;-&#39;) {
801                                 dash++;
802                                 comment.append(ch);
803                                 nextChar();
804                             }
805                             // Strictly speaking, a comment should not contain &quot;--&quot;
806                             // so dash &gt; 2 is an error, dash == 2 implies ch == &#39;&gt;&#39;
807                             // See http://www.w3.org/TR/html-markup/syntax.html#syntax-comments
808                             // for more details.
809                             if (dash &gt;= 2 &amp;&amp; ch == &#39;&gt;&#39;) {
810                                 comment.setLength(comment.length() - 2);
811                                 comment(comment.toString());
812                                 nextChar();
813                                 return;
814                             }
815 
816                             comment.append(ch);
817                             nextChar();
818                         }
819                     }
820                 } else if (ch == &#39;[&#39;) {
821                     nextChar();
822                     if (ch == &#39;C&#39;) {
823                         nextChar();
824                         if (ch == &#39;D&#39;) {
825                             nextChar();
826                             if (ch == &#39;A&#39;) {
827                                 nextChar();
828                                 if (ch == &#39;T&#39;) {
829                                     nextChar();
830                                     if (ch == &#39;A&#39;) {
831                                         nextChar();
832                                         if (ch == &#39;[&#39;) {
833                                             while (true) {
834                                                 nextChar();
835                                                 if (ch == &#39;]&#39;) {
836                                                     nextChar();
837                                                     if (ch == &#39;]&#39;) {
838                                                         nextChar();
839                                                         if (ch == &#39;&gt;&#39;) {
840                                                             nextChar();
841                                                             return;
842                                                         }
843                                                     }
844                                                 }
845                                             }
846 
847                                         }
848                                     }
849                                 }
850                             }
851                         }
852                     }
853                 } else {
854                     StringBuilder sb = new StringBuilder();
855                     while (ch != -1 &amp;&amp; ch != &#39;&gt;&#39;) {
856                         sb.append((char) ch);
857                         nextChar();
858                     }
859                     Pattern p = Pattern.compile(&quot;(?is)doctype\\s+html\\s?.*&quot;);
860                     String s = sb.toString();
861                     if (p.matcher(s).matches()) {
862                         doctype(s);
863                         return;
864                     }
865                 }
866             } else if (ch == &#39;?&#39;) {
867                 nextChar();
868                 if (ch == &#39;x&#39;) {
869                     nextChar();
870                     if (ch == &#39;m&#39;) {
871                         nextChar();
872                         if (ch == &#39;l&#39;) {
873                             Map&lt;String,String&gt; attrs = htmlAttrs();
874                             if (ch == &#39;?&#39;) {
875                                 nextChar();
876                                 if (ch == &#39;&gt;&#39;) {
877                                     nextChar();
878                                     xml = true;
879                                     return;
880                                 }
881                             }
882                         }
883                     }
884 
885                 }
886             }
887 
888             if (!inScript) {
889                 error(file, lineNumber, &quot;bad html&quot;);
890             }
891         }
892 
893         /**
894          * Read a series of HTML attributes, terminated by {@literal &gt; }.
895          * Each attribute is of the form {@literal identifier[=value] }.
896          * &quot;value&quot; may be unquoted, single-quoted, or double-quoted.
897          */
898         private Map&lt;String,String&gt; htmlAttrs() throws IOException {
899             Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
900             skipWhitespace();
901 
902             while (isIdentifierStart((char) ch)) {
903                 String name = readAttributeName().toLowerCase(Locale.US);
904                 skipWhitespace();
905                 String value = null;
906                 if (ch == &#39;=&#39;) {
907                     nextChar();
908                     skipWhitespace();
909                     if (ch == &#39;\&#39;&#39; || ch == &#39;&quot;&#39;) {
910                         char quote = (char) ch;
911                         nextChar();
912                         StringBuilder sb = new StringBuilder();
913                         while (ch != -1 &amp;&amp; ch != quote) {
914                             sb.append((char) ch);
915                             nextChar();
916                         }
917                         value = sb.toString() // hack to replace common entities
918                                 .replace(&quot;&amp;lt;&quot;, &quot;&lt;&quot;)
919                                 .replace(&quot;&amp;gt;&quot;, &quot;&gt;&quot;)
920                                 .replace(&quot;&amp;amp;&quot;, &quot;&amp;&quot;);
921                         nextChar();
922                     } else {
923                         StringBuilder sb = new StringBuilder();
924                         while (ch != -1 &amp;&amp; !isUnquotedAttrValueTerminator((char) ch)) {
925                             sb.append((char) ch);
926                             nextChar();
927                         }
928                         value = sb.toString();
929                     }
930                     skipWhitespace();
931                 }
932                 map.put(name, value);
933             }
934 
935             return map;
936         }
937 
938         private boolean isIdentifierStart(char ch) {
939             return Character.isUnicodeIdentifierStart(ch);
940         }
941 
942         private String readIdentifier() throws IOException {
943             StringBuilder sb = new StringBuilder();
944             sb.append((char) ch);
945             nextChar();
946             while (ch != -1 &amp;&amp; Character.isUnicodeIdentifierPart(ch)) {
947                 sb.append((char) ch);
948                 nextChar();
949             }
950             return sb.toString();
951         }
952 
953         private String readAttributeName() throws IOException {
954             StringBuilder sb = new StringBuilder();
955             sb.append((char) ch);
956             nextChar();
957             while (ch != -1 &amp;&amp; Character.isUnicodeIdentifierPart(ch)
958                     || ch == &#39;-&#39;
959                     || (xml || sb.toString().startsWith(&quot;xml&quot;)) &amp;&amp; ch == &#39;:&#39;) {
960                 sb.append((char) ch);
961                 nextChar();
962             }
963             return sb.toString();
964         }
965 
966         private boolean isWhitespace(char ch) {
967             return Character.isWhitespace(ch);
968         }
969 
970         private void skipWhitespace() throws IOException {
971             while (isWhitespace((char) ch)) {
972                 nextChar();
973             }
974         }
975 
976         private boolean isUnquotedAttrValueTerminator(char ch) {
977             switch (ch) {
978                 case &#39;\f&#39;: case &#39;\n&#39;: case &#39;\r&#39;: case &#39;\t&#39;:
979                 case &#39; &#39;:
980                 case &#39;&quot;&#39;: case &#39;\&#39;&#39;: case &#39;`&#39;:
981                 case &#39;=&#39;: case &#39;&lt;&#39;: case &#39;&gt;&#39;:
982                     return true;
983                 default:
984                     return false;
985             }
986         }
987     }
988 
989 }
    </pre>
  </body>
</html>
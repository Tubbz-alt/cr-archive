<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff make/jdk/src/classes/build/tools/cldrconverter/Bundle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractLDMLHandler.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CLDRConverter.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>make/jdk/src/classes/build/tools/cldrconverter/Bundle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,10 ***</span>
<span class="line-new-header">--- 31,12 ---</span>
  import java.util.HashMap;
  import java.util.Iterator;
  import java.util.List;
  import java.util.Map;
  import java.util.Objects;
<span class="line-added">+ import java.util.Optional;</span>
<span class="line-added">+ import java.util.stream.IntStream;</span>
  
  class Bundle {
      static enum Type {
          LOCALENAMES, CURRENCYNAMES, TIMEZONENAMES, CALENDARDATA, FORMATDATA;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,16 ***</span>
      private final static Map&lt;String, Bundle&gt; bundles = new HashMap&lt;&gt;();
  
      private final static String[] NUMBER_PATTERN_KEYS = {
          &quot;NumberPatterns/decimal&quot;,
          &quot;NumberPatterns/currency&quot;,
<span class="line-modified">!         &quot;NumberPatterns/percent&quot;</span>
      };
  
      private final static String[] COMPACT_NUMBER_PATTERN_KEYS = {
              &quot;short.CompactNumberPatterns&quot;,
<span class="line-modified">!             &quot;long.CompactNumberPatterns&quot;};</span>
  
      private final static String[] NUMBER_ELEMENT_KEYS = {
          &quot;NumberElements/decimal&quot;,
          &quot;NumberElements/group&quot;,
          &quot;NumberElements/list&quot;,
<span class="line-new-header">--- 50,18 ---</span>
      private final static Map&lt;String, Bundle&gt; bundles = new HashMap&lt;&gt;();
  
      private final static String[] NUMBER_PATTERN_KEYS = {
          &quot;NumberPatterns/decimal&quot;,
          &quot;NumberPatterns/currency&quot;,
<span class="line-modified">!         &quot;NumberPatterns/percent&quot;,</span>
<span class="line-added">+         &quot;NumberPatterns/accounting&quot;</span>
      };
  
      private final static String[] COMPACT_NUMBER_PATTERN_KEYS = {
              &quot;short.CompactNumberPatterns&quot;,
<span class="line-modified">!             &quot;long.CompactNumberPatterns&quot;</span>
<span class="line-added">+     };</span>
  
      private final static String[] NUMBER_ELEMENT_KEYS = {
          &quot;NumberElements/decimal&quot;,
          &quot;NumberElements/group&quot;,
          &quot;NumberElements/list&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,11 ***</span>
          &quot;NumberElements/pattern&quot;,
          &quot;NumberElements/minus&quot;,
          &quot;NumberElements/exponential&quot;,
          &quot;NumberElements/permille&quot;,
          &quot;NumberElements/infinity&quot;,
<span class="line-modified">!         &quot;NumberElements/nan&quot;</span>
      };
  
      private final static String[] TIME_PATTERN_KEYS = {
          &quot;DateTimePatterns/full-time&quot;,
          &quot;DateTimePatterns/long-time&quot;,
<span class="line-new-header">--- 70,13 ---</span>
          &quot;NumberElements/pattern&quot;,
          &quot;NumberElements/minus&quot;,
          &quot;NumberElements/exponential&quot;,
          &quot;NumberElements/permille&quot;,
          &quot;NumberElements/infinity&quot;,
<span class="line-modified">!         &quot;NumberElements/nan&quot;,</span>
<span class="line-added">+         &quot;NumberElements/currencyDecimal&quot;,</span>
<span class="line-added">+         &quot;NumberElements/currencyGroup&quot;,</span>
      };
  
      private final static String[] TIME_PATTERN_KEYS = {
          &quot;DateTimePatterns/full-time&quot;,
          &quot;DateTimePatterns/long-time&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,21 ***</span>
          Map&lt;String, Object&gt; myMap = new HashMap&lt;&gt;();
          int index;
          for (index = 0; index &lt; cldrBundles.length; index++) {
              if (cldrBundles[index].equals(id)) {
                  myMap.putAll(CLDRConverter.getCLDRBundle(cldrBundles[index]));
<span class="line-removed">-                 CLDRConverter.handleAliases(myMap);</span>
                  break;
              }
          }
  
          // parentsMap contains resources from id&#39;s parents.
          Map&lt;String, Object&gt; parentsMap = new HashMap&lt;&gt;();
          for (int i = cldrBundles.length - 1; i &gt; index; i--) {
              if (!(&quot;no&quot;.equals(cldrBundles[i]) || cldrBundles[i].startsWith(&quot;no_&quot;))) {
                  parentsMap.putAll(CLDRConverter.getCLDRBundle(cldrBundles[i]));
<span class="line-removed">-                 CLDRConverter.handleAliases(parentsMap);</span>
              }
          }
          // Duplicate myMap as parentsMap for &quot;root&quot; so that the
          // fallback works. This is a hack, though.
          if (&quot;root&quot;.equals(cldrBundles[0])) {
<span class="line-new-header">--- 194,19 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 210,80 ***</span>
              parentsMap.putAll(myMap);
          }
  
          // merge individual strings into arrays
  
<span class="line-modified">!         // if myMap has any of the NumberPatterns members</span>
<span class="line-modified">!         for (String k : NUMBER_PATTERN_KEYS) {</span>
<span class="line-modified">!             if (myMap.containsKey(k)) {</span>
<span class="line-modified">!                 String[] numberPatterns = new String[NUMBER_PATTERN_KEYS.length];</span>
<span class="line-modified">!                 for (int i = 0; i &lt; NUMBER_PATTERN_KEYS.length; i++) {</span>
<span class="line-modified">!                     String key = NUMBER_PATTERN_KEYS[i];</span>
<span class="line-modified">!                     String value = (String) myMap.remove(key);</span>
<span class="line-modified">!                     if (value == null) {</span>
<span class="line-modified">!                         value = (String) parentsMap.remove(key);</span>
<span class="line-modified">!                     }</span>
<span class="line-removed">-                     if (value.length() == 0) {</span>
<span class="line-removed">-                         CLDRConverter.warning(&quot;empty pattern for &quot; + key);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     numberPatterns[i] = value;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 myMap.put(&quot;NumberPatterns&quot;, numberPatterns);</span>
<span class="line-removed">-                 break;</span>
              }
          }
  
          for (String k : COMPACT_NUMBER_PATTERN_KEYS) {
              List&lt;String&gt; patterns = (List&lt;String&gt;) myMap.remove(k);
              if (patterns != null) {
<span class="line-modified">!                 // Replace any null entry with empty strings.</span>
<span class="line-modified">!                 String[] arrPatterns = patterns.stream()</span>
<span class="line-modified">!                         .map(s -&gt; s == null ? &quot;&quot; : s).toArray(String[]::new);</span>
<span class="line-modified">!                 myMap.put(k, arrPatterns);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // if myMap has any of NUMBER_ELEMENT_KEYS, create a complete NumberElements.</span>
<span class="line-modified">!         String defaultScript = (String) myMap.get(&quot;DefaultNumberingSystem&quot;);</span>
<span class="line-modified">!         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">!         List&lt;String&gt; scripts = (List&lt;String&gt;) myMap.get(&quot;numberingScripts&quot;);</span>
<span class="line-modified">!         if (defaultScript == null &amp;&amp; scripts != null) {</span>
<span class="line-modified">!             // Some locale data has no default script for numbering even with mutiple scripts.</span>
<span class="line-removed">-             // Take the first one as default in that case.</span>
<span class="line-removed">-             defaultScript = scripts.get(0);</span>
<span class="line-removed">-             myMap.put(&quot;DefaultNumberingSystem&quot;, defaultScript);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (scripts != null) {</span>
<span class="line-removed">-             for (String script : scripts) {</span>
<span class="line-removed">-                 for (String k : NUMBER_ELEMENT_KEYS) {</span>
<span class="line-removed">-                     String[] numberElements = new String[NUMBER_ELEMENT_KEYS.length];</span>
<span class="line-removed">-                     for (int i = 0; i &lt; NUMBER_ELEMENT_KEYS.length; i++) {</span>
<span class="line-removed">-                         String key = script + &quot;.&quot; + NUMBER_ELEMENT_KEYS[i];</span>
<span class="line-removed">-                         String value = (String) myMap.remove(key);</span>
<span class="line-removed">-                         if (value == null) {</span>
<span class="line-removed">-                             if (key.endsWith(&quot;/pattern&quot;)) {</span>
<span class="line-removed">-                                 value = &quot;#&quot;;</span>
<span class="line-removed">-                             } else {</span>
<span class="line-removed">-                                 value = (String) parentsMap.get(key);</span>
<span class="line-removed">-                                 if (value == null) {</span>
<span class="line-removed">-                                     // the last resort is &quot;latn&quot;</span>
<span class="line-removed">-                                     key = &quot;latn.&quot; + NUMBER_ELEMENT_KEYS[i];</span>
<span class="line-removed">-                                     value = (String) parentsMap.get(key);</span>
<span class="line-removed">-                                     if (value == null) {</span>
<span class="line-removed">-                                         throw new InternalError(&quot;NumberElements: null for &quot; + key);</span>
<span class="line-removed">-                                     }</span>
<span class="line-removed">-                                 }</span>
                              }
                          }
<span class="line-modified">!                         numberElements[i] = value;</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     myMap.put(script + &quot;.&quot; + &quot;NumberElements&quot;, numberElements);</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
              }
          }
  
          // another hack: parentsMap is not used for date-time resources.
          if (&quot;root&quot;.equals(id)) {
              parentsMap = null;
          }
  
<span class="line-new-header">--- 214,59 ---</span>
              parentsMap.putAll(myMap);
          }
  
          // merge individual strings into arrays
  
<span class="line-modified">!         // if myMap has any of the NumberPatterns/NumberElements members, create a</span>
<span class="line-modified">!         // complete array of patterns/elements.</span>
<span class="line-modified">!         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">!         List&lt;String&gt; scripts = (List&lt;String&gt;) myMap.get(&quot;numberingScripts&quot;);</span>
<span class="line-modified">!         if (scripts != null) {</span>
<span class="line-modified">!             for (String script : scripts) {</span>
<span class="line-modified">!                 myMap.put(script + &quot;.NumberPatterns&quot;,</span>
<span class="line-modified">!                         createNumberArray(myMap, parentsMap, NUMBER_PATTERN_KEYS, script));</span>
<span class="line-modified">!                 myMap.put(script + &quot;.NumberElements&quot;,</span>
<span class="line-modified">!                         createNumberArray(myMap, parentsMap, NUMBER_ELEMENT_KEYS, script));</span>
              }
          }
  
          for (String k : COMPACT_NUMBER_PATTERN_KEYS) {
              List&lt;String&gt; patterns = (List&lt;String&gt;) myMap.remove(k);
              if (patterns != null) {
<span class="line-modified">!                 // Convert the map value from List&lt;String&gt; to String[], replacing any missing</span>
<span class="line-modified">!                 // entry from the parents map, if any.</span>
<span class="line-modified">!                 final List&lt;String&gt; pList = (List&lt;String&gt;)parentsMap.get(k);</span>
<span class="line-modified">!                 int size = patterns.size();</span>
<span class="line-modified">!                 int psize = pList != null ? pList.size() : 0;</span>
<span class="line-modified">!                 String[] arrPatterns = IntStream.range(0, Math.max(size, psize))</span>
<span class="line-modified">!                     .mapToObj(i -&gt; {</span>
<span class="line-modified">!                         String pattern;</span>
<span class="line-modified">!                         // first try itself.</span>
<span class="line-modified">!                         if (i &lt; size) {</span>
<span class="line-modified">!                             pattern = patterns.get(i);</span>
<span class="line-modified">!                             if (!pattern.isEmpty()) {</span>
<span class="line-modified">!                                 return &quot;{&quot; + pattern + &quot;}&quot;;</span>
                              }
                          }
<span class="line-modified">!                         // if not found, try parent</span>
<span class="line-modified">!                         if (i &lt; psize) {</span>
<span class="line-modified">!                             pattern = pList.get(i);</span>
<span class="line-modified">!                             if (!pattern.isEmpty()) {</span>
<span class="line-modified">!                                 return &quot;{&quot; + pattern + &quot;}&quot;;</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         // bail out with empty string</span>
<span class="line-added">+                         return &quot;&quot;;</span>
<span class="line-added">+                     })</span>
<span class="line-added">+                     .toArray(String[]::new);</span>
<span class="line-added">+                 myMap.put(k, arrPatterns);</span>
              }
          }
  
<span class="line-added">+         // Processes aliases here</span>
<span class="line-added">+         CLDRConverter.handleAliases(myMap);</span>
<span class="line-added">+ </span>
          // another hack: parentsMap is not used for date-time resources.
          if (&quot;root&quot;.equals(id)) {
              parentsMap = null;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 309,11 ***</span>
              handleDateTimeFormatPatterns(DATE_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DatePatterns&quot;);
              handleDateTimeFormatPatterns(DATETIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DateTimePatterns&quot;);
          }
  
          // First, weed out any empty timezone or metazone names from myMap.
<span class="line-removed">-         // Fill in any missing abbreviations if locale is &quot;en&quot;.</span>
          for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
              String key = it.next();
              if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
                      || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
                  @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-new-header">--- 292,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 322,14 ***</span>
                      // Some zones have only exemplarCity, which become empty.
                      // Remove those from the map.
                      it.remove();
                      continue;
                  }
<span class="line-removed">- </span>
<span class="line-removed">-                 if (id.equals(&quot;en&quot;)) {</span>
<span class="line-removed">-                     fillInJREs(key, nameMap);</span>
<span class="line-removed">-                 }</span>
              }
          }
          for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
              String key = it.next();
                  if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
<span class="line-new-header">--- 304,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 408,30 ***</span>
          targetMap = myMap;
          return myMap;
      }
  
      private void handleMultipleInheritance(Map&lt;String, Object&gt; map, Map&lt;String, Object&gt; parents, String key) {
<span class="line-modified">!         String formatKey = key + &quot;/format&quot;;</span>
<span class="line-modified">!         Object format = map.get(formatKey);</span>
          if (format != null) {
<span class="line-modified">!             map.remove(formatKey);</span>
              map.put(key, format);
<span class="line-modified">!             if (fillInElements(parents, formatKey, format)) {</span>
                  map.remove(key);
              }
          }
<span class="line-modified">!         String standaloneKey = key + &quot;/stand-alone&quot;;</span>
<span class="line-modified">!         Object standalone = map.get(standaloneKey);</span>
          if (standalone != null) {
<span class="line-modified">!             map.remove(standaloneKey);</span>
<span class="line-modified">!             String realKey = key;</span>
<span class="line-modified">!             if (format != null) {</span>
<span class="line-modified">!                 realKey = &quot;standalone.&quot; + key;</span>
<span class="line-modified">!             }</span>
<span class="line-removed">-             map.put(realKey, standalone);</span>
<span class="line-removed">-             if (fillInElements(parents, standaloneKey, standalone)) {</span>
<span class="line-removed">-                 map.remove(realKey);</span>
              }
          }
      }
  
      /**
<span class="line-new-header">--- 386,27 ---</span>
          targetMap = myMap;
          return myMap;
      }
  
      private void handleMultipleInheritance(Map&lt;String, Object&gt; map, Map&lt;String, Object&gt; parents, String key) {
<span class="line-modified">!         String formatMapKey = key + &quot;/format&quot;;</span>
<span class="line-modified">!         Object format = map.get(formatMapKey);</span>
          if (format != null) {
<span class="line-modified">!             map.remove(formatMapKey);</span>
              map.put(key, format);
<span class="line-modified">!             if (fillInElements(parents, formatMapKey, format)) {</span>
                  map.remove(key);
              }
          }
<span class="line-modified">!         String standaloneMapKey = key + &quot;/stand-alone&quot;;</span>
<span class="line-modified">!         Object standalone = map.get(standaloneMapKey);</span>
          if (standalone != null) {
<span class="line-modified">!             map.remove(standaloneMapKey);</span>
<span class="line-modified">!             String standaloneResourceKey = &quot;standalone.&quot; + key;</span>
<span class="line-modified">!             map.put(standaloneResourceKey, standalone);</span>
<span class="line-modified">!             if (fillInElements(parents, standaloneMapKey, standalone)) {</span>
<span class="line-modified">!                 map.remove(standaloneResourceKey);</span>
              }
          }
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 488,10 ***</span>
<span class="line-new-header">--- 463,15 ---</span>
                          } else {
                              newValue[0] = &quot;&quot;;
                          }
                          System.arraycopy(value, 0, newValue, 1, value.length);
                          value = newValue;
<span class="line-added">+ </span>
<span class="line-added">+                         // fix up &#39;Reiwa&#39; era, which can be missing in some locales</span>
<span class="line-added">+                         if (value[value.length - 1] == null) {</span>
<span class="line-added">+                             value[value.length - 1] = (key.startsWith(&quot;narrow.&quot;) ? &quot;R&quot; : &quot;Reiwa&quot;);</span>
<span class="line-added">+                         }</span>
                      }
                      break;
  
                  case BUDDHIST:
                      // Replace the value
</pre>
<hr />
<pre>
<span class="line-old-header">*** 503,10 ***</span>
<span class="line-new-header">--- 483,11 ---</span>
                      value = new String[] {&quot;&quot;, value[0]};
                      break;
                  }
                  if (!key.equals(realKey)) {
                      map.put(realKey, value);
<span class="line-added">+                     map.put(&quot;java.time.&quot; + realKey, value);</span>
                  }
              }
              realKeys[index] = realKey;
              eraNames[index++] = value;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 648,46 ***</span>
              }
          }
          return null;
      }
  
<span class="line-removed">-     static List&lt;Object[]&gt; jreTimeZoneNames = Arrays.asList(TimeZoneNames.getContents());</span>
<span class="line-removed">-     private void fillInJREs(String key, Map&lt;String, String&gt; map) {</span>
<span class="line-removed">-         String tzid = null;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {</span>
<span class="line-removed">-             // Look for tzid</span>
<span class="line-removed">-             String meta = key.substring(CLDRConverter.METAZONE_ID_PREFIX.length());</span>
<span class="line-removed">-             if (meta.equals(&quot;GMT&quot;)) {</span>
<span class="line-removed">-                 tzid = meta;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 for (String tz : CLDRConverter.handlerMetaZones.keySet()) {</span>
<span class="line-removed">-                     if (CLDRConverter.handlerMetaZones.get(tz).equals(meta)) {</span>
<span class="line-removed">-                         tzid = tz;</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             tzid = key.substring(CLDRConverter.TIMEZONE_ID_PREFIX.length());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (tzid != null) {</span>
<span class="line-removed">-             for (Object[] jreZone : jreTimeZoneNames) {</span>
<span class="line-removed">-                 if (jreZone[0].equals(tzid)) {</span>
<span class="line-removed">-                     for (int i = 0; i &lt; ZONE_NAME_KEYS.length; i++) {</span>
<span class="line-removed">-                         if (map.get(ZONE_NAME_KEYS[i]) == null) {</span>
<span class="line-removed">-                             String[] jreNames = (String[])jreZone[1];</span>
<span class="line-removed">-                             map.put(ZONE_NAME_KEYS[i], jreNames[i]);</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Perform a generic conversion of CLDR date-time format pattern letter based
       * on the support given by the SimpleDateFormat and the j.t.f.DateTimeFormatter
       * for date-time formatting.
       */
<span class="line-new-header">--- 629,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 791,6 ***</span>
<span class="line-new-header">--- 736,50 ---</span>
  
      @FunctionalInterface
      private interface ConvertDateTimeLetters {
          void convert(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb);
      }
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns a complete string array for NumberElements or NumberPatterns. If any</span>
<span class="line-added">+      * array element is missing, it will fall back to parents map, as well as</span>
<span class="line-added">+      * numbering script fallback.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private String[] createNumberArray(Map&lt;String, Object&gt; myMap, Map&lt;String, Object&gt;parentsMap,</span>
<span class="line-added">+                                         String[] keys, String script) {</span>
<span class="line-added">+         String[] numArray = new String[keys.length];</span>
<span class="line-added">+         for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="line-added">+             String key = script + &quot;.&quot; + keys[i];</span>
<span class="line-added">+             final int idx = i;</span>
<span class="line-added">+             Optional.ofNullable(</span>
<span class="line-added">+                 myMap.getOrDefault(key,</span>
<span class="line-added">+                     // if value not found in myMap, search for parentsMap</span>
<span class="line-added">+                     parentsMap.getOrDefault(key,</span>
<span class="line-added">+                         parentsMap.getOrDefault(keys[i],</span>
<span class="line-added">+                             // the last resort is &quot;latn&quot;</span>
<span class="line-added">+                             parentsMap.get(&quot;latn.&quot; + keys[i])))))</span>
<span class="line-added">+                 .ifPresentOrElse(v -&gt; numArray[idx] = (String)v, () -&gt; {</span>
<span class="line-added">+                     if (keys == NUMBER_PATTERN_KEYS) {</span>
<span class="line-added">+                         // NumberPatterns</span>
<span class="line-added">+                         if (!key.endsWith(&quot;accounting&quot;)) {</span>
<span class="line-added">+                             // throw error unless it is for &quot;accounting&quot;,</span>
<span class="line-added">+                             // which may be missing.</span>
<span class="line-added">+                             throw new InternalError(&quot;NumberPatterns: null for &quot; +</span>
<span class="line-added">+                                                     key + &quot;, id: &quot; + id);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     } else {</span>
<span class="line-added">+                         // NumberElements</span>
<span class="line-added">+                         assert keys == NUMBER_ELEMENT_KEYS;</span>
<span class="line-added">+                         if (key.endsWith(&quot;/pattern&quot;)) {</span>
<span class="line-added">+                             numArray[idx] = &quot;#&quot;;</span>
<span class="line-added">+                         } else if (!key.endsWith(&quot;currencyDecimal&quot;) &amp;&amp;</span>
<span class="line-added">+                                    !key.endsWith(&quot;currencyGroup&quot;)) {</span>
<span class="line-added">+                             // throw error unless it is for &quot;currencyDecimal/Group&quot;,</span>
<span class="line-added">+                             // which may be missing.</span>
<span class="line-added">+                             throw new InternalError(&quot;NumberElements: null for &quot; +</span>
<span class="line-added">+                                                     key + &quot;, id: &quot; + id);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }});</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return numArray;</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="AbstractLDMLHandler.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CLDRConverter.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
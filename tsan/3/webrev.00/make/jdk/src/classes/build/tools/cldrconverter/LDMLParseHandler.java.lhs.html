<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/jdk/src/classes/build/tools/cldrconverter/LDMLParseHandler.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package build.tools.cldrconverter;
  27 
  28 import java.io.File;
  29 import java.io.IOException;
  30 import java.text.DateFormatSymbols;
  31 import java.util.ArrayList;
<a name="2" id="anc2"></a>
  32 import java.util.HashMap;
  33 import java.util.HashSet;
  34 import java.util.List;
  35 import java.util.Locale;
  36 import java.util.Map;
  37 import java.util.Set;
  38 import org.xml.sax.Attributes;
  39 import org.xml.sax.InputSource;
  40 import org.xml.sax.SAXException;
  41 
  42 /**
  43  * Handles parsing of files in Locale Data Markup Language and produces a map
  44  * that uses the keys and values of JRE locale data.
  45  */
  46 class LDMLParseHandler extends AbstractLDMLHandler&lt;Object&gt; {
  47     private String defaultNumberingSystem;
  48     private String currentNumberingSystem = &quot;&quot;;
  49     private CalendarType currentCalendarType;
  50     private String zoneNameStyle; // &quot;long&quot; or &quot;short&quot; for time zone names
  51     private String zonePrefix;
  52     private final String id;
  53     private String currentContext = &quot;&quot;; // &quot;format&quot;/&quot;stand-alone&quot;
  54     private String currentWidth = &quot;&quot;; // &quot;wide&quot;/&quot;narrow&quot;/&quot;abbreviated&quot;
  55     private String currentStyle = &quot;&quot;; // short, long for decimalFormat
<a name="3" id="anc3"></a><span class="line-removed">  56     private String compactCount = &quot;&quot;; // one or other for decimalFormat</span>
  57 
  58     LDMLParseHandler(String id) {
  59         this.id = id;
  60     }
  61 
  62     @Override
  63     public InputSource resolveEntity(String publicID, String systemID) throws IOException, SAXException {
  64         // avoid HTTP traffic to unicode.org
  65         if (systemID.startsWith(CLDRConverter.LDML_DTD_SYSTEM_ID)) {
  66             return new InputSource((new File(CLDRConverter.LOCAL_LDML_DTD)).toURI().toString());
  67         }
  68         return null;
  69     }
  70 
  71     @Override
  72     public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
  73         switch (qName) {
  74         //
  75         // Generic information
  76         //
  77         case &quot;identity&quot;:
  78             // ignore this element - it has language and territory elements that aren&#39;t locale data
  79             pushIgnoredContainer(qName);
  80             break;
  81 
  82         // for LocaleNames
  83         // copy string
  84         case &quot;localeSeparator&quot;:
  85             pushStringEntry(qName, attributes,
  86                 CLDRConverter.LOCALE_SEPARATOR);
  87             break;
  88         case &quot;localeKeyTypePattern&quot;:
  89             pushStringEntry(qName, attributes,
  90                 CLDRConverter.LOCALE_KEYTYPE);
  91             break;
  92 
  93         case &quot;language&quot;:
  94         case &quot;script&quot;:
  95         case &quot;territory&quot;:
  96         case &quot;variant&quot;:
  97             // for LocaleNames
  98             // copy string
  99             pushStringEntry(qName, attributes,
 100                 CLDRConverter.LOCALE_NAME_PREFIX +
 101                 (qName.equals(&quot;variant&quot;) ? &quot;%%&quot; : &quot;&quot;) +
 102                 attributes.getValue(&quot;type&quot;));
 103             break;
 104 
 105         case &quot;key&quot;:
 106             // for LocaleNames
 107             // copy string
 108             {
 109                 String key = convertOldKeyName(attributes.getValue(&quot;type&quot;));
 110                 if (key.length() == 2) {
 111                     pushStringEntry(qName, attributes,
 112                         CLDRConverter.LOCALE_KEY_PREFIX + key);
 113                 } else {
 114                     pushIgnoredContainer(qName);
 115                 }
 116             }
 117             break;
 118 
 119         case &quot;type&quot;:
 120             // for LocaleNames/CalendarNames
 121             // copy string
 122             {
 123                 String key = convertOldKeyName(attributes.getValue(&quot;key&quot;));
 124                 if (key.length() == 2) {
 125                     pushStringEntry(qName, attributes,
 126                     CLDRConverter.LOCALE_TYPE_PREFIX + key + &quot;.&quot; +
 127                     attributes.getValue(&quot;type&quot;));
 128                 } else {
 129                     pushIgnoredContainer(qName);
 130                 }
 131             }
 132             break;
 133 
 134         //
 135         // Currency information
 136         //
 137         case &quot;currency&quot;:
 138             // for CurrencyNames
 139             // stash away &quot;type&quot; value for nested &lt;symbol&gt;
 140             pushKeyContainer(qName, attributes, attributes.getValue(&quot;type&quot;));
 141             break;
 142         case &quot;symbol&quot;:
 143             // for CurrencyNames
 144             // need to get the key from the containing &lt;currency&gt; element
 145             pushStringEntry(qName, attributes, CLDRConverter.CURRENCY_SYMBOL_PREFIX
 146                                                + getContainerKey());
 147             break;
 148 
 149         // Calendar or currency
 150         case &quot;displayName&quot;:
 151             {
 152                 if (currentContainer.getqName().equals(&quot;field&quot;)) {
 153                     pushStringEntry(qName, attributes,
 154                             (currentCalendarType != null ? currentCalendarType.keyElementName() : &quot;&quot;)
 155                             + &quot;field.&quot; + getContainerKey());
 156                 } else {
 157                     // for CurrencyNames
 158                     // need to get the key from the containing &lt;currency&gt; element
 159                     // ignore if is has &quot;count&quot; attribute
 160                     String containerKey = getContainerKey();
 161                     if (containerKey != null &amp;&amp; attributes.getValue(&quot;count&quot;) == null) {
 162                         pushStringEntry(qName, attributes,
 163                                         CLDRConverter.CURRENCY_NAME_PREFIX
 164                                         + containerKey.toLowerCase(Locale.ROOT),
 165                                         attributes.getValue(&quot;type&quot;));
 166                     } else {
 167                         pushIgnoredContainer(qName);
 168                     }
 169                 }
 170             }
 171             break;
 172 
 173         //
 174         // Calendar information
 175         //
 176         case &quot;calendar&quot;:
 177             {
 178                 // mostly for FormatData (CalendarData items firstDay and minDays are also nested)
 179                 // use only if it&#39;s supported by java.util.Calendar.
 180                 String calendarName = attributes.getValue(&quot;type&quot;);
 181                 currentCalendarType = CalendarType.forName(calendarName);
 182                 if (currentCalendarType != null) {
 183                     pushContainer(qName, attributes);
 184                 } else {
 185                     pushIgnoredContainer(qName);
 186                 }
 187             }
 188             break;
 189         case &quot;fields&quot;:
 190             {
 191                 pushContainer(qName, attributes);
 192             }
 193             break;
 194         case &quot;field&quot;:
 195             {
 196                 String type = attributes.getValue(&quot;type&quot;);
 197                 switch (type) {
 198                 case &quot;era&quot;:
 199                 case &quot;year&quot;:
 200                 case &quot;month&quot;:
 201                 case &quot;week&quot;:
 202                 case &quot;weekday&quot;:
 203                 case &quot;dayperiod&quot;:
 204                 case &quot;hour&quot;:
 205                 case &quot;minute&quot;:
 206                 case &quot;second&quot;:
 207                 case &quot;zone&quot;:
 208                     pushKeyContainer(qName, attributes, type);
 209                     break;
 210                 default:
 211                     pushIgnoredContainer(qName);
 212                     break;
 213                 }
 214             }
 215             break;
 216         case &quot;monthContext&quot;:
 217             {
 218                 // for FormatData
 219                 // need to keep stand-alone and format, to allow for inheritance in CLDR
 220                 String type = attributes.getValue(&quot;type&quot;);
 221                 if (&quot;stand-alone&quot;.equals(type) || &quot;format&quot;.equals(type)) {
 222                     currentContext = type;
 223                     pushKeyContainer(qName, attributes, type);
 224                 } else {
 225                     pushIgnoredContainer(qName);
 226                 }
 227             }
 228             break;
 229         case &quot;monthWidth&quot;:
 230             {
 231                 // for FormatData
 232                 // create string array for the two types that the JRE knows
 233                 // keep info about the context type so we can sort out inheritance later
 234                 if (currentCalendarType == null) {
 235                     pushIgnoredContainer(qName);
 236                     break;
 237                 }
 238                 String prefix = (currentCalendarType == null) ? &quot;&quot; : currentCalendarType.keyElementName();
 239                 currentWidth = attributes.getValue(&quot;type&quot;);
 240                 switch (currentWidth) {
 241                 case &quot;wide&quot;:
 242                     pushStringArrayEntry(qName, attributes, prefix + &quot;MonthNames/&quot; + getContainerKey(), 13);
 243                     break;
 244                 case &quot;abbreviated&quot;:
 245                     pushStringArrayEntry(qName, attributes, prefix + &quot;MonthAbbreviations/&quot; + getContainerKey(), 13);
 246                     break;
 247                 case &quot;narrow&quot;:
 248                     pushStringArrayEntry(qName, attributes, prefix + &quot;MonthNarrows/&quot; + getContainerKey(), 13);
 249                     break;
 250                 default:
 251                     pushIgnoredContainer(qName);
 252                     break;
 253                 }
 254             }
 255             break;
 256         case &quot;month&quot;:
 257             // for FormatData
 258             // add to string array entry of monthWidth element
 259             pushStringArrayElement(qName, attributes, Integer.parseInt(attributes.getValue(&quot;type&quot;)) - 1);
 260             break;
 261         case &quot;dayContext&quot;:
 262             {
 263                 // for FormatData
 264                 // need to keep stand-alone and format, to allow for multiple inheritance in CLDR
 265                 String type = attributes.getValue(&quot;type&quot;);
 266                 if (&quot;stand-alone&quot;.equals(type) || &quot;format&quot;.equals(type)) {
 267                     currentContext = type;
 268                     pushKeyContainer(qName, attributes, type);
 269                 } else {
 270                     pushIgnoredContainer(qName);
 271                 }
 272             }
 273             break;
 274         case &quot;dayWidth&quot;:
 275             {
 276                 // for FormatData
 277                 // create string array for the two types that the JRE knows
 278                 // keep info about the context type so we can sort out inheritance later
 279                 String prefix = (currentCalendarType == null) ? &quot;&quot; : currentCalendarType.keyElementName();
 280                 currentWidth = attributes.getValue(&quot;type&quot;);
 281                 switch (currentWidth) {
 282                 case &quot;wide&quot;:
 283                     pushStringArrayEntry(qName, attributes, prefix + &quot;DayNames/&quot; + getContainerKey(), 7);
 284                     break;
 285                 case &quot;abbreviated&quot;:
 286                     pushStringArrayEntry(qName, attributes, prefix + &quot;DayAbbreviations/&quot; + getContainerKey(), 7);
 287                     break;
 288                 case &quot;narrow&quot;:
 289                     pushStringArrayEntry(qName, attributes, prefix + &quot;DayNarrows/&quot; + getContainerKey(), 7);
 290                     break;
 291                 default:
 292                     pushIgnoredContainer(qName);
 293                     break;
 294                 }
 295             }
 296             break;
 297         case &quot;day&quot;:
 298             // for FormatData
 299             // add to string array entry of monthWidth element
 300             pushStringArrayElement(qName, attributes, Integer.parseInt(DAY_OF_WEEK_MAP.get(attributes.getValue(&quot;type&quot;))) - 1);
 301             break;
 302         case &quot;dayPeriodContext&quot;:
 303             // for FormatData
 304             // need to keep stand-alone and format, to allow for multiple inheritance in CLDR
 305             // for FormatData
 306             // need to keep stand-alone and format, to allow for multiple inheritance in CLDR
 307             {
 308                 String type = attributes.getValue(&quot;type&quot;);
 309                 if (&quot;stand-alone&quot;.equals(type) || &quot;format&quot;.equals(type)) {
 310                     currentContext = type;
 311                     pushKeyContainer(qName, attributes, type);
 312                 } else {
 313                     pushIgnoredContainer(qName);
 314                 }
 315             }
 316             break;
 317         case &quot;dayPeriodWidth&quot;:
 318             // for FormatData
 319             // create string array entry for am/pm. only keeping wide
 320             currentWidth = attributes.getValue(&quot;type&quot;);
 321             switch (currentWidth) {
 322             case &quot;wide&quot;:
 323                 pushStringArrayEntry(qName, attributes, &quot;AmPmMarkers/&quot; + getContainerKey(), 2);
 324                 break;
 325             case &quot;narrow&quot;:
 326                 pushStringArrayEntry(qName, attributes, &quot;narrow.AmPmMarkers/&quot; + getContainerKey(), 2);
 327                 break;
 328             case &quot;abbreviated&quot;:
 329                 pushStringArrayEntry(qName, attributes, &quot;abbreviated.AmPmMarkers/&quot; + getContainerKey(), 2);
 330                 break;
 331             default:
 332                 pushIgnoredContainer(qName);
 333                 break;
 334             }
 335             break;
 336         case &quot;dayPeriod&quot;:
 337             // for FormatData
 338             // add to string array entry of AmPmMarkers element
 339             if (attributes.getValue(&quot;alt&quot;) == null) {
 340                 switch (attributes.getValue(&quot;type&quot;)) {
 341                 case &quot;am&quot;:
 342                     pushStringArrayElement(qName, attributes, 0);
 343                     break;
 344                 case &quot;pm&quot;:
 345                     pushStringArrayElement(qName, attributes, 1);
 346                     break;
 347                 default:
 348                     pushIgnoredContainer(qName);
 349                     break;
 350                 }
 351             } else {
 352                 // discard alt values
 353                 pushIgnoredContainer(qName);
 354             }
 355             break;
 356         case &quot;eraNames&quot;:
 357             // CLDR era names are inconsistent in terms of their lengths. For example,
 358             // the full names of Japanese imperial eras are eraAbbr, while the full names
 359             // of the Julian eras are eraNames.
 360             if (currentCalendarType == null) {
 361                 assert currentContainer instanceof IgnoredContainer;
 362                 pushIgnoredContainer(qName);
 363             } else {
 364                 String key = currentCalendarType.keyElementName() + &quot;long.Eras&quot;; // for now
 365                 pushStringArrayEntry(qName, attributes, key, currentCalendarType.getEraLength(qName));
 366             }
 367             break;
 368         case &quot;eraAbbr&quot;:
 369             // for FormatData
 370             // create string array entry
 371             if (currentCalendarType == null) {
 372                 assert currentContainer instanceof IgnoredContainer;
 373                 pushIgnoredContainer(qName);
 374             } else {
 375                 String key = currentCalendarType.keyElementName() + &quot;Eras&quot;;
 376                 pushStringArrayEntry(qName, attributes, key, currentCalendarType.getEraLength(qName));
 377             }
 378             break;
 379         case &quot;eraNarrow&quot;:
 380             // mainly used for the Japanese imperial calendar
 381             if (currentCalendarType == null) {
 382                 assert currentContainer instanceof IgnoredContainer;
 383                 pushIgnoredContainer(qName);
 384             } else {
 385                 String key = currentCalendarType.keyElementName() + &quot;narrow.Eras&quot;;
 386                 pushStringArrayEntry(qName, attributes, key, currentCalendarType.getEraLength(qName));
 387             }
 388             break;
 389         case &quot;era&quot;:
 390             // for FormatData
 391             // add to string array entry of eraAbbr element
 392             if (currentCalendarType == null) {
 393                 assert currentContainer instanceof IgnoredContainer;
 394                 pushIgnoredContainer(qName);
 395             } else {
 396                 int index = Integer.parseInt(attributes.getValue(&quot;type&quot;));
 397                 index = currentCalendarType.normalizeEraIndex(index);
 398                 if (index &gt;= 0) {
 399                     pushStringArrayElement(qName, attributes, index);
 400                 } else {
 401                     pushIgnoredContainer(qName);
 402                 }
 403                 if (currentContainer.getParent() == null) {
 404                     throw new InternalError(&quot;currentContainer: null parent&quot;);
 405                 }
 406             }
 407             break;
 408         case &quot;quarterContext&quot;:
 409             {
 410                 // for FormatData
 411                 // need to keep stand-alone and format, to allow for inheritance in CLDR
 412                 String type = attributes.getValue(&quot;type&quot;);
 413                 if (&quot;stand-alone&quot;.equals(type) || &quot;format&quot;.equals(type)) {
 414                     currentContext = type;
 415                     pushKeyContainer(qName, attributes, type);
 416                 } else {
 417                     pushIgnoredContainer(qName);
 418                 }
 419             }
 420             break;
 421         case &quot;quarterWidth&quot;:
 422             {
 423                 // for FormatData
 424                 // keep info about the context type so we can sort out inheritance later
 425                 String prefix = (currentCalendarType == null) ? &quot;&quot; : currentCalendarType.keyElementName();
 426                 currentWidth = attributes.getValue(&quot;type&quot;);
 427                 switch (currentWidth) {
 428                 case &quot;wide&quot;:
 429                     pushStringArrayEntry(qName, attributes, prefix + &quot;QuarterNames/&quot; + getContainerKey(), 4);
 430                     break;
 431                 case &quot;abbreviated&quot;:
 432                     pushStringArrayEntry(qName, attributes, prefix + &quot;QuarterAbbreviations/&quot; + getContainerKey(), 4);
 433                     break;
 434                 case &quot;narrow&quot;:
 435                     pushStringArrayEntry(qName, attributes, prefix + &quot;QuarterNarrows/&quot; + getContainerKey(), 4);
 436                     break;
 437                 default:
 438                     pushIgnoredContainer(qName);
 439                     break;
 440                 }
 441             }
 442             break;
 443         case &quot;quarter&quot;:
 444             // for FormatData
 445             // add to string array entry of quarterWidth element
 446             pushStringArrayElement(qName, attributes, Integer.parseInt(attributes.getValue(&quot;type&quot;)) - 1);
 447             break;
 448 
 449         //
 450         // Time zone names
 451         //
 452         case &quot;timeZoneNames&quot;:
 453             pushContainer(qName, attributes);
 454             break;
 455         case &quot;hourFormat&quot;:
 456             pushStringEntry(qName, attributes, &quot;timezone.hourFormat&quot;);
 457             break;
 458         case &quot;gmtFormat&quot;:
 459             pushStringEntry(qName, attributes, &quot;timezone.gmtFormat&quot;);
 460             break;
 461         case &quot;gmtZeroFormat&quot;:
 462             pushStringEntry(qName, attributes, &quot;timezone.gmtZeroFormat&quot;);
 463             break;
 464         case &quot;regionFormat&quot;:
 465             {
 466                 String type = attributes.getValue(&quot;type&quot;);
 467                 pushStringEntry(qName, attributes, &quot;timezone.regionFormat&quot; +
 468                     (type == null ? &quot;&quot; : &quot;.&quot; + type));
 469             }
 470             break;
 471         case &quot;zone&quot;:
 472             {
 473                 String tzid = attributes.getValue(&quot;type&quot;); // Olson tz id
 474                 zonePrefix = CLDRConverter.TIMEZONE_ID_PREFIX;
 475                 put(zonePrefix + tzid, new HashMap&lt;String, String&gt;());
 476                 pushKeyContainer(qName, attributes, tzid);
 477             }
 478             break;
 479         case &quot;metazone&quot;:
 480             {
 481                 String zone = attributes.getValue(&quot;type&quot;); // LDML meta zone id
 482                 zonePrefix = CLDRConverter.METAZONE_ID_PREFIX;
 483                 put(zonePrefix + zone, new HashMap&lt;String, String&gt;());
 484                 pushKeyContainer(qName, attributes, zone);
 485             }
 486             break;
 487         case &quot;long&quot;:
 488             zoneNameStyle = &quot;long&quot;;
 489             pushContainer(qName, attributes);
 490             break;
 491         case &quot;short&quot;:
 492             zoneNameStyle = &quot;short&quot;;
 493             pushContainer(qName, attributes);
 494             break;
 495         case &quot;generic&quot;:  // generic name
 496         case &quot;standard&quot;: // standard time name
 497         case &quot;daylight&quot;: // daylight saving (summer) time name
 498             pushStringEntry(qName, attributes, CLDRConverter.ZONE_NAME_PREFIX + qName + &quot;.&quot; + zoneNameStyle);
 499             break;
 500         case &quot;exemplarCity&quot;:
 501             pushStringEntry(qName, attributes, CLDRConverter.EXEMPLAR_CITY_PREFIX);
 502             break;
 503 
 504         //
 505         // Number format information
 506         //
 507         case &quot;decimalFormatLength&quot;:
 508             String type = attributes.getValue(&quot;type&quot;);
 509             if (null == type) {
 510                 // format data for decimal number format
<a name="4" id="anc4"></a><span class="line-modified"> 511                 pushStringEntry(qName, attributes, &quot;NumberPatterns/decimal&quot;);</span>

 512                 currentStyle = type;
 513             } else {
 514                 switch (type) {
 515                     case &quot;short&quot;:
 516                     case &quot;long&quot;:
 517                         // considering &quot;short&quot; and long for
 518                         // compact number formatting patterns
 519                         pushKeyContainer(qName, attributes, type);
 520                         currentStyle = type;
 521                         break;
 522                     default:
 523                         pushIgnoredContainer(qName);
 524                         break;
 525                 }
 526             }
 527             break;
 528         case &quot;decimalFormat&quot;:
 529             if(currentStyle == null) {
 530                 pushContainer(qName, attributes);
 531             } else {
 532                 switch (currentStyle) {
 533                     case &quot;short&quot;:
<a name="5" id="anc5"></a><span class="line-removed"> 534                         pushStringListEntry(qName, attributes,</span>
<span class="line-removed"> 535                                 currentStyle+&quot;.CompactNumberPatterns&quot;);</span>
<span class="line-removed"> 536                         break;</span>
 537                     case &quot;long&quot;:
 538                         pushStringListEntry(qName, attributes,
 539                                 currentStyle+&quot;.CompactNumberPatterns&quot;);
 540                         break;
 541                     default:
 542                         pushIgnoredContainer(qName);
 543                         break;
 544                 }
 545             }
 546             break;
<a name="6" id="anc6"></a>




 547         case &quot;pattern&quot;:
 548             String containerName = currentContainer.getqName();
<a name="7" id="anc7"></a><span class="line-modified"> 549             if (containerName.equals(&quot;decimalFormat&quot;)) {</span>
<span class="line-modified"> 550                 if (currentStyle == null) {</span>
<span class="line-modified"> 551                     pushContainer(qName, attributes);</span>
<span class="line-modified"> 552                 } else {</span>
<span class="line-modified"> 553                     // The compact number patterns parsing assumes that the order</span>
<span class="line-modified"> 554                     // of patterns are always in the increasing order of their</span>
<span class="line-modified"> 555                     // type attribute i.e. type = 1000...</span>
<span class="line-modified"> 556                     // Between the inflectional forms for a type (e.g.</span>
<span class="line-modified"> 557                     // count = &quot;one&quot; and count = &quot;other&quot; for type = 1000), it is</span>
<span class="line-modified"> 558                     // assumed that the count = &quot;one&quot; always appears before</span>
<span class="line-modified"> 559                     // count = &quot;other&quot;</span>
<span class="line-modified"> 560                     switch (currentStyle) {</span>
<span class="line-modified"> 561                         case &quot;short&quot;:</span>
<span class="line-modified"> 562                         case &quot;long&quot;:</span>
<span class="line-modified"> 563                             String count = attributes.getValue(&quot;count&quot;);</span>
<span class="line-modified"> 564                             // first pattern of count = &quot;one&quot; or count = &quot;other&quot;</span>
<span class="line-modified"> 565                             if ((count.equals(&quot;one&quot;) || count.equals(&quot;other&quot;))</span>
<span class="line-modified"> 566                                     &amp;&amp; compactCount.equals(&quot;&quot;)) {</span>
<span class="line-modified"> 567                                 compactCount = count;</span>
<span class="line-modified"> 568                                 pushStringListElement(qName, attributes,</span>
<span class="line-modified"> 569                                         (int) Math.log10(Double.parseDouble(attributes.getValue(&quot;type&quot;))));</span>
<span class="line-modified"> 570                             } else if ((count.equals(&quot;one&quot;) || count.equals(&quot;other&quot;))</span>
<span class="line-modified"> 571                                     &amp;&amp; compactCount.equals(count)) {</span>
<span class="line-modified"> 572                                 // extract patterns with similar &quot;count&quot;</span>
<span class="line-modified"> 573                                 // attribute value</span>





 574                                 pushStringListElement(qName, attributes,
<a name="8" id="anc8"></a><span class="line-modified"> 575                                         (int) Math.log10(Double.parseDouble(attributes.getValue(&quot;type&quot;))));</span>
<span class="line-modified"> 576                             } else {</span>


 577                                 pushIgnoredContainer(qName);
<a name="9" id="anc9"></a><span class="line-modified"> 578                             }</span>
<span class="line-modified"> 579                             break;</span>
<span class="line-removed"> 580                         default:</span>
<span class="line-removed"> 581                             pushIgnoredContainer(qName);</span>
<span class="line-removed"> 582                             break;</span>
 583                     }
<a name="10" id="anc10"></a>













 584                 }
<a name="11" id="anc11"></a><span class="line-removed"> 585             } else {</span>
 586                 pushContainer(qName, attributes);
 587             }
 588             break;
 589         case &quot;currencyFormatLength&quot;:
 590             if (attributes.getValue(&quot;type&quot;) == null) {
 591                 // skipping type=&quot;short&quot; data
 592                 // for FormatData
 593                 pushContainer(qName, attributes);
 594             } else {
 595                 pushIgnoredContainer(qName);
 596             }
 597             break;
<a name="12" id="anc12"></a><span class="line-removed"> 598         case &quot;currencyFormat&quot;:</span>
<span class="line-removed"> 599             // for FormatData</span>
<span class="line-removed"> 600             // copy string for later assembly into NumberPatterns</span>
<span class="line-removed"> 601             if (attributes.getValue(&quot;type&quot;).equals(&quot;standard&quot;)) {</span>
<span class="line-removed"> 602             pushStringEntry(qName, attributes, &quot;NumberPatterns/currency&quot;);</span>
<span class="line-removed"> 603             } else {</span>
<span class="line-removed"> 604                 pushIgnoredContainer(qName);</span>
<span class="line-removed"> 605             }</span>
<span class="line-removed"> 606             break;</span>
<span class="line-removed"> 607         case &quot;percentFormat&quot;:</span>
<span class="line-removed"> 608             // for FormatData</span>
<span class="line-removed"> 609             // copy string for later assembly into NumberPatterns</span>
<span class="line-removed"> 610             if (attributes.getValue(&quot;type&quot;).equals(&quot;standard&quot;)) {</span>
<span class="line-removed"> 611             pushStringEntry(qName, attributes, &quot;NumberPatterns/percent&quot;);</span>
<span class="line-removed"> 612             } else {</span>
<span class="line-removed"> 613                 pushIgnoredContainer(qName);</span>
<span class="line-removed"> 614             }</span>
<span class="line-removed"> 615             break;</span>
 616         case &quot;defaultNumberingSystem&quot;:
 617             // default numbering system if multiple numbering systems are used.
 618             pushStringEntry(qName, attributes, &quot;DefaultNumberingSystem&quot;);
 619             break;
 620         case &quot;symbols&quot;:
 621             // for FormatData
 622             // look up numberingSystems
 623             symbols: {
 624                 String script = attributes.getValue(&quot;numberSystem&quot;);
 625                 if (script == null) {
 626                     // Has no script. Just ignore.
 627                     pushIgnoredContainer(qName);
 628                     break;
 629                 }
 630 
 631                 // Use keys as &lt;script&gt;.&quot;NumberElements/&lt;symbol&gt;&quot;
 632                 currentNumberingSystem = script + &quot;.&quot;;
 633                 String digits = CLDRConverter.handlerNumbering.get(script);
 634                 if (digits == null) {
 635                     pushIgnoredContainer(qName);
 636                     break;
 637                 }
 638 
<a name="13" id="anc13"></a><span class="line-modified"> 639                 @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed"> 640                 List&lt;String&gt; numberingScripts = (List&lt;String&gt;) get(&quot;numberingScripts&quot;);</span>
<span class="line-removed"> 641                 if (numberingScripts == null) {</span>
<span class="line-removed"> 642                     numberingScripts = new ArrayList&lt;&gt;();</span>
<span class="line-removed"> 643                     put(&quot;numberingScripts&quot;, numberingScripts);</span>
<span class="line-removed"> 644                 }</span>
<span class="line-removed"> 645                 numberingScripts.add(script);</span>
 646                 put(currentNumberingSystem + &quot;NumberElements/zero&quot;, digits.substring(0, 1));
 647                 pushContainer(qName, attributes);
 648             }
 649             break;
 650         case &quot;decimal&quot;:
<a name="14" id="anc14"></a><span class="line-removed"> 651             // for FormatData</span>
<span class="line-removed"> 652             // copy string for later assembly into NumberElements</span>
<span class="line-removed"> 653             if (currentContainer.getqName().equals(&quot;symbols&quot;)) {</span>
<span class="line-removed"> 654                 pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/decimal&quot;);</span>
<span class="line-removed"> 655             } else {</span>
<span class="line-removed"> 656                 pushIgnoredContainer(qName);</span>
<span class="line-removed"> 657             }</span>
<span class="line-removed"> 658             break;</span>
 659         case &quot;group&quot;:
<a name="15" id="anc15"></a>

 660             // for FormatData
 661             // copy string for later assembly into NumberElements
 662             if (currentContainer.getqName().equals(&quot;symbols&quot;)) {
<a name="16" id="anc16"></a><span class="line-modified"> 663                 pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/group&quot;);</span>
 664             } else {
 665                 pushIgnoredContainer(qName);
 666             }
 667             break;
 668         case &quot;list&quot;:
 669             // for FormatData
 670             // copy string for later assembly into NumberElements
 671             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/list&quot;);
 672             break;
 673         case &quot;percentSign&quot;:
 674             // for FormatData
 675             // copy string for later assembly into NumberElements
 676             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/percent&quot;);
 677             break;
 678         case &quot;nativeZeroDigit&quot;:
 679             // for FormatData
 680             // copy string for later assembly into NumberElements
 681             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/zero&quot;);
 682             break;
 683         case &quot;patternDigit&quot;:
 684             // for FormatData
 685             // copy string for later assembly into NumberElements
 686             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/pattern&quot;);
 687             break;
 688         case &quot;plusSign&quot;:
 689             // TODO: DecimalFormatSymbols doesn&#39;t support plusSign
 690             pushIgnoredContainer(qName);
 691             break;
 692         case &quot;minusSign&quot;:
 693             // for FormatData
 694             // copy string for later assembly into NumberElements
 695             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/minus&quot;);
 696             break;
 697         case &quot;exponential&quot;:
 698             // for FormatData
 699             // copy string for later assembly into NumberElements
 700             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/exponential&quot;);
 701             break;
 702         case &quot;perMille&quot;:
 703             // for FormatData
 704             // copy string for later assembly into NumberElements
 705             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/permille&quot;);
 706             break;
 707         case &quot;infinity&quot;:
 708             // for FormatData
 709             // copy string for later assembly into NumberElements
 710             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/infinity&quot;);
 711             break;
 712         case &quot;nan&quot;:
 713             // for FormatData
 714             // copy string for later assembly into NumberElements
 715             pushStringEntry(qName, attributes, currentNumberingSystem + &quot;NumberElements/nan&quot;);
 716             break;
 717         case &quot;timeFormatLength&quot;:
 718             {
 719                 // for FormatData
 720                 // copy string for later assembly into DateTimePatterns
 721                 String prefix = (currentCalendarType == null) ? &quot;&quot; : currentCalendarType.keyElementName();
 722                 pushStringEntry(qName, attributes, prefix + &quot;DateTimePatterns/&quot; + attributes.getValue(&quot;type&quot;) + &quot;-time&quot;);
 723             }
 724             break;
 725         case &quot;dateFormatLength&quot;:
 726             {
 727                 // for FormatData
 728                 // copy string for later assembly into DateTimePatterns
 729                 String prefix = (currentCalendarType == null) ? &quot;&quot; : currentCalendarType.keyElementName();
 730                 pushStringEntry(qName, attributes, prefix + &quot;DateTimePatterns/&quot; + attributes.getValue(&quot;type&quot;) + &quot;-date&quot;);
 731             }
 732             break;
 733         case &quot;dateTimeFormatLength&quot;:
 734             {
 735                 // for FormatData
 736                 // copy string for later assembly into DateTimePatterns
 737                 String prefix = (currentCalendarType == null) ? &quot;&quot; : currentCalendarType.keyElementName();
 738                 pushStringEntry(qName, attributes, prefix + &quot;DateTimePatterns/&quot; + attributes.getValue(&quot;type&quot;) + &quot;-dateTime&quot;);
 739             }
 740             break;
 741         case &quot;localizedPatternChars&quot;:
 742             {
 743                 // for FormatData
 744                 // copy string for later adaptation to JRE use
 745                 String prefix = (currentCalendarType == null) ? &quot;&quot; : currentCalendarType.keyElementName();
 746                 pushStringEntry(qName, attributes, prefix + &quot;DateTimePatternChars&quot;);
 747             }
 748             break;
 749 
 750         // &quot;alias&quot; for root
 751         case &quot;alias&quot;:
 752             {
 753                 if (id.equals(&quot;root&quot;) &amp;&amp; !isIgnored(attributes)
 754                         &amp;&amp; ((currentContainer.getqName().equals(&quot;decimalFormatLength&quot;))
<a name="17" id="anc17"></a>

 755                         || (currentCalendarType != null &amp;&amp; !currentCalendarType.lname().startsWith(&quot;islamic-&quot;)))) { // ignore islamic variants
 756                     pushAliasEntry(qName, attributes, attributes.getValue(&quot;path&quot;));
 757                 } else {
 758                     pushIgnoredContainer(qName);
 759                 }
 760             }
 761             break;
 762 
 763         default:
 764             // treat anything else as a container
 765             pushContainer(qName, attributes);
 766             break;
 767         }
 768     }
 769 
 770     private static final String[] CONTEXTS = {&quot;stand-alone&quot;, &quot;format&quot;};
 771     private static final String[] WIDTHS = {&quot;wide&quot;, &quot;narrow&quot;, &quot;abbreviated&quot;};
 772     private static final String[] LENGTHS = {&quot;full&quot;, &quot;long&quot;, &quot;medium&quot;, &quot;short&quot;};
 773 
 774     private void populateWidthAlias(String type, Set&lt;String&gt; keys) {
 775         for (String context : CONTEXTS) {
 776             for (String width : WIDTHS) {
 777                 String keyName = toJDKKey(type+&quot;Width&quot;, context, width);
 778                 if (keyName.length() &gt; 0) {
 779                     keys.add(keyName + &quot;,&quot; + context + &quot;,&quot; + width);
 780                 }
 781             }
 782         }
 783     }
 784 
 785     private void populateFormatLengthAlias(String type, Set&lt;String&gt; keys) {
 786         for (String length: LENGTHS) {
 787             String keyName = toJDKKey(type+&quot;FormatLength&quot;, currentContext, length);
 788             if (keyName.length() &gt; 0) {
 789                 keys.add(keyName + &quot;,&quot; + currentContext + &quot;,&quot; + length);
 790             }
 791         }
 792     }
 793 
 794     private Set&lt;String&gt; populateAliasKeys(String qName, String context, String width) {
 795         HashSet&lt;String&gt; ret = new HashSet&lt;&gt;();
 796         String keyName = qName;
 797 
 798         switch (qName) {
 799         case &quot;monthWidth&quot;:
 800         case &quot;dayWidth&quot;:
 801         case &quot;quarterWidth&quot;:
 802         case &quot;dayPeriodWidth&quot;:
 803         case &quot;dateFormatLength&quot;:
 804         case &quot;timeFormatLength&quot;:
 805         case &quot;dateTimeFormatLength&quot;:
 806         case &quot;eraNames&quot;:
 807         case &quot;eraAbbr&quot;:
 808         case &quot;eraNarrow&quot;:
 809             ret.add(toJDKKey(qName, context, width) + &quot;,&quot; + context + &quot;,&quot; + width);
 810             break;
 811         case &quot;days&quot;:
 812             populateWidthAlias(&quot;day&quot;, ret);
 813             break;
 814         case &quot;months&quot;:
 815             populateWidthAlias(&quot;month&quot;, ret);
 816             break;
 817         case &quot;quarters&quot;:
 818             populateWidthAlias(&quot;quarter&quot;, ret);
 819             break;
 820         case &quot;dayPeriods&quot;:
 821             populateWidthAlias(&quot;dayPeriod&quot;, ret);
 822             break;
 823         case &quot;eras&quot;:
 824             ret.add(toJDKKey(&quot;eraNames&quot;, context, width) + &quot;,&quot; + context + &quot;,&quot; + width);
 825             ret.add(toJDKKey(&quot;eraAbbr&quot;, context, width) + &quot;,&quot; + context + &quot;,&quot; + width);
 826             ret.add(toJDKKey(&quot;eraNarrow&quot;, context, width) + &quot;,&quot; + context + &quot;,&quot; + width);
 827             break;
 828         case &quot;dateFormats&quot;:
 829             populateFormatLengthAlias(&quot;date&quot;, ret);
 830             break;
 831         case &quot;timeFormats&quot;:
 832             populateFormatLengthAlias(&quot;time&quot;, ret);
 833             break;
 834         default:
 835             break;
 836         }
 837         return ret;
 838     }
 839 
 840     private String translateWidthAlias(String qName, String context, String width) {
 841         String keyName = qName;
 842         String type = Character.toUpperCase(qName.charAt(0)) + qName.substring(1, qName.indexOf(&quot;Width&quot;));
 843 
 844         switch (width) {
 845         case &quot;wide&quot;:
 846             keyName = type + &quot;Names/&quot; + context;
 847             break;
 848         case &quot;abbreviated&quot;:
 849             keyName = type + &quot;Abbreviations/&quot; + context;
 850             break;
 851         case &quot;narrow&quot;:
 852             keyName = type + &quot;Narrows/&quot; + context;
 853             break;
 854         default:
 855             assert false;
 856         }
 857 
 858         return keyName;
 859     }
 860 
 861     private String toJDKKey(String containerqName, String context, String type) {
 862         String keyName = containerqName;
 863 
 864         switch (containerqName) {
 865         case &quot;monthWidth&quot;:
 866         case &quot;dayWidth&quot;:
 867         case &quot;quarterWidth&quot;:
 868             keyName = translateWidthAlias(keyName, context, type);
 869             break;
 870         case &quot;dayPeriodWidth&quot;:
 871             switch (type) {
 872             case &quot;wide&quot;:
 873                 keyName = &quot;AmPmMarkers/&quot; + context;
 874                 break;
 875             case &quot;narrow&quot;:
 876                 keyName = &quot;narrow.AmPmMarkers/&quot; + context;
 877                 break;
 878             case &quot;abbreviated&quot;:
 879                 keyName = &quot;abbreviated.AmPmMarkers/&quot; + context;
 880                 break;
 881             }
 882             break;
 883         case &quot;dateFormatLength&quot;:
 884         case &quot;timeFormatLength&quot;:
 885         case &quot;dateTimeFormatLength&quot;:
 886             keyName = &quot;DateTimePatterns/&quot; +
 887                 type + &quot;-&quot; +
 888                 keyName.substring(0, keyName.indexOf(&quot;FormatLength&quot;));
 889             break;
 890         case &quot;eraNames&quot;:
 891             keyName = &quot;long.Eras&quot;;
 892             break;
 893         case &quot;eraAbbr&quot;:
 894             keyName = &quot;Eras&quot;;
 895             break;
 896         case &quot;eraNarrow&quot;:
 897             keyName = &quot;narrow.Eras&quot;;
 898             break;
 899         case &quot;dateFormats&quot;:
 900         case &quot;timeFormats&quot;:
 901         case &quot;days&quot;:
 902         case &quot;months&quot;:
 903         case &quot;quarters&quot;:
 904         case &quot;dayPeriods&quot;:
 905         case &quot;eras&quot;:
 906             break;
 907         case &quot;decimalFormatLength&quot;: // used for compact number formatting patterns
 908             keyName = type + &quot;.CompactNumberPatterns&quot;;
 909             break;
<a name="18" id="anc18"></a>





 910         default:
 911             keyName = &quot;&quot;;
 912             break;
 913         }
 914 
 915         return keyName;
 916     }
 917 
 918     private String getTarget(String path, String calType, String context, String width) {
 919         // Target qName
 920         int lastSlash = path.lastIndexOf(&#39;/&#39;);
 921         String qName = path.substring(lastSlash+1);
 922         int bracket = qName.indexOf(&#39;[&#39;);
 923         if (bracket != -1) {
 924             qName = qName.substring(0, bracket);
 925         }
 926 
 927         // calType
 928         String typeKey = &quot;/calendar[@type=&#39;&quot;;
 929         int start = path.indexOf(typeKey);
 930         if (start != -1) {
 931             calType = path.substring(start+typeKey.length(), path.indexOf(&quot;&#39;]&quot;, start));
 932         }
 933 
 934         // context
 935         typeKey = &quot;Context[@type=&#39;&quot;;
 936         start = path.indexOf(typeKey);
 937         if (start != -1) {
 938             context = (path.substring(start+typeKey.length(), path.indexOf(&quot;&#39;]&quot;, start)));
 939         }
 940 
 941         // width
 942         typeKey = &quot;Width[@type=&#39;&quot;;
 943         start = path.indexOf(typeKey);
 944         if (start != -1) {
 945             width = path.substring(start+typeKey.length(), path.indexOf(&quot;&#39;]&quot;, start));
 946         }
 947 
 948         // used for compact number formatting patterns aliases
 949         typeKey = &quot;decimalFormatLength[@type=&#39;&quot;;
 950         start = path.indexOf(typeKey);
 951         if (start != -1) {
 952             String style = path.substring(start + typeKey.length(), path.indexOf(&quot;&#39;]&quot;, start));
 953             return toJDKKey(qName, &quot;&quot;, style);
 954         }
 955 
<a name="19" id="anc19"></a>















 956         return calType + &quot;.&quot; + toJDKKey(qName, context, width);
 957     }
 958 
 959     @Override
 960     public void endElement(String uri, String localName, String qName) throws SAXException {
 961         assert qName.equals(currentContainer.getqName()) : &quot;current=&quot; + currentContainer.getqName() + &quot;, param=&quot; + qName;
 962         switch (qName) {
 963         case &quot;calendar&quot;:
 964             assert !(currentContainer instanceof Entry);
 965             currentCalendarType = null;
 966             break;
 967 
 968         case &quot;defaultNumberingSystem&quot;:
 969             if (currentContainer instanceof StringEntry) {
<a name="20" id="anc20"></a><span class="line-modified"> 970                 defaultNumberingSystem = ((StringEntry) currentContainer).getValue();</span>
<span class="line-removed"> 971                 assert defaultNumberingSystem != null;</span>
<span class="line-removed"> 972                 put(((StringEntry) currentContainer).getKey(), defaultNumberingSystem);</span>
 973             } else {
 974                 defaultNumberingSystem = null;
 975             }
 976             break;
 977 
 978         case &quot;timeZoneNames&quot;:
 979             zonePrefix = null;
 980             break;
 981 
 982         case &quot;generic&quot;:
 983         case &quot;standard&quot;:
 984         case &quot;daylight&quot;:
 985         case &quot;exemplarCity&quot;:
 986             if (zonePrefix != null &amp;&amp; (currentContainer instanceof Entry)) {
 987                 @SuppressWarnings(&quot;unchecked&quot;)
 988                 Map&lt;String, String&gt; valmap = (Map&lt;String, String&gt;) get(zonePrefix + getContainerKey());
 989                 Entry&lt;?&gt; entry = (Entry&lt;?&gt;) currentContainer;
 990                 if (qName.equals(&quot;exemplarCity&quot;)) {
 991                     put(CLDRConverter.EXEMPLAR_CITY_PREFIX + getContainerKey(), (String) entry.getValue());
 992                 } else {
 993                     valmap.put(entry.getKey(), (String) entry.getValue());
 994                 }
 995             }
 996             break;
 997 
 998         case &quot;monthWidth&quot;:
 999         case &quot;dayWidth&quot;:
1000         case &quot;dayPeriodWidth&quot;:
1001         case &quot;quarterWidth&quot;:
1002             currentWidth = &quot;&quot;;
1003             putIfEntry();
1004             break;
1005 
1006         case &quot;monthContext&quot;:
1007         case &quot;dayContext&quot;:
1008         case &quot;dayPeriodContext&quot;:
1009         case &quot;quarterContext&quot;:
1010             currentContext = &quot;&quot;;
1011             putIfEntry();
1012             break;
1013         case &quot;decimalFormatLength&quot;:
1014             currentStyle = &quot;&quot;;
<a name="21" id="anc21"></a><span class="line-modified">1015             compactCount = &quot;&quot;;</span>






1016             putIfEntry();
1017             break;
1018         default:
1019             putIfEntry();
1020         }
1021         currentContainer = currentContainer.getParent();
1022     }
1023 
<a name="22" id="anc22"></a><span class="line-modified">1024     private void putIfEntry() {</span>
1025         if (currentContainer instanceof AliasEntry) {
1026             Entry&lt;?&gt; entry = (Entry&lt;?&gt;) currentContainer;
1027             String containerqName = entry.getParent().getqName();
1028             if (containerqName.equals(&quot;decimalFormatLength&quot;)) {
1029                 String srcKey = toJDKKey(containerqName, &quot;&quot;, currentStyle);
1030                 String targetKey = getTarget(entry.getKey(), &quot;&quot;, &quot;&quot;, &quot;&quot;);
1031                 CLDRConverter.aliases.put(srcKey, targetKey);
<a name="23" id="anc23"></a>






1032             } else {
1033                 Set&lt;String&gt; keyNames = populateAliasKeys(containerqName, currentContext, currentWidth);
1034                 if (!keyNames.isEmpty()) {
1035                     for (String keyName : keyNames) {
1036                         String[] tmp = keyName.split(&quot;,&quot;, 3);
1037                         String calType = currentCalendarType.lname();
1038                         String src = calType+&quot;.&quot;+tmp[0];
1039                         String target = getTarget(
1040                                     entry.getKey(),
1041                                     calType,
1042                                     tmp[1].length()&gt;0 ? tmp[1] : currentContext,
1043                                     tmp[2].length()&gt;0 ? tmp[2] : currentWidth);
1044                         if (target.substring(target.lastIndexOf(&#39;.&#39;)+1).equals(containerqName)) {
1045                             target = target.substring(0, target.indexOf(&#39;.&#39;))+&quot;.&quot;+tmp[0];
1046                         }
1047                         CLDRConverter.aliases.put(src.replaceFirst(&quot;^gregorian.&quot;, &quot;&quot;),
1048                                                   target.replaceFirst(&quot;^gregorian.&quot;, &quot;&quot;));
1049                     }
1050                 }
1051             }
1052         } else if (currentContainer instanceof Entry) {
1053             Entry&lt;?&gt; entry = (Entry&lt;?&gt;) currentContainer;
1054             Object value = entry.getValue();
1055             if (value != null) {
1056                 String key = entry.getKey();
1057                 // Tweak for MonthNames for the root locale, Needed for
1058                 // SimpleDateFormat.format()/parse() roundtrip.
1059                 if (id.equals(&quot;root&quot;) &amp;&amp; key.startsWith(&quot;MonthNames&quot;)) {
1060                     value = new DateFormatSymbols(Locale.US).getShortMonths();
1061                 }
<a name="24" id="anc24"></a><span class="line-modified">1062                 put(entry.getKey(), value);</span>
1063             }
1064         }
<a name="25" id="anc25"></a>
1065     }
1066 
1067     public String convertOldKeyName(String key) {
1068         // Explicitly obtained from &quot;alias&quot; attribute in each &quot;key&quot; element.
1069         switch (key) {
1070             case &quot;calendar&quot;:
1071                 return &quot;ca&quot;;
1072             case &quot;currency&quot;:
1073                 return &quot;cu&quot;;
1074             case &quot;collation&quot;:
1075                 return &quot;co&quot;;
1076             case &quot;numbers&quot;:
1077                 return &quot;nu&quot;;
1078             case &quot;timezone&quot;:
1079                 return &quot;tz&quot;;
1080             default:
1081                 return key;
1082         }
1083     }
<a name="26" id="anc26"></a>











1084 }
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
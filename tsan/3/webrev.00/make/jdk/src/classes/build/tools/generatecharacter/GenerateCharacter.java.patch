diff a/make/jdk/src/classes/build/tools/generatecharacter/GenerateCharacter.java b/make/jdk/src/classes/build/tools/generatecharacter/GenerateCharacter.java
--- a/make/jdk/src/classes/build/tools/generatecharacter/GenerateCharacter.java
+++ b/make/jdk/src/classes/build/tools/generatecharacter/GenerateCharacter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2002, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -71,10 +71,11 @@
     final static String commandMarker = "$$";
     static String ROOT                        = "";
     static String DefaultUnicodeSpecFileName  = ROOT + "UnicodeData.txt";
     static String DefaultSpecialCasingFileName = ROOT + "SpecialCasing.txt";
     static String DefaultPropListFileName     = ROOT + "PropList.txt";
+    static String DefaultDerivedPropsFileName = ROOT + "DerivedCoreProperties.txt";
     static String DefaultJavaTemplateFileName = ROOT + "Character.java.template";
     static String DefaultJavaOutputFileName   = ROOT + "Character.java";
     static String DefaultCTemplateFileName    = ROOT + "Character.c.template";
     static String DefaultCOutputFileName      = ROOT + "Character.c";
 
@@ -157,10 +158,12 @@
     1 bit Other_Uppercase property
     1 bit Other_Alphabetic property
     1 bit Other_Math property
     1 bit Ideographic property
     1 bit Noncharacter codepoint property
+    1 bit ID_Start property
+    1 bit ID_Continue property
     */
 
 
     // bit masks identify each component of a 32-bit property field described
     // above.
@@ -188,19 +191,21 @@
         shiftPlane          = 16,       maskPlane = 0xFF0000;
 
     // maskMirrored needs to be long, if up 16-bit
     private static final long maskMirrored          = 0x80000000L;
 
-    // bit masks identify the 16-bit priperty field described above, in B
+    // bit masks identify the 16-bit property field described above, in B
     // table
     private static final long
         maskOtherLowercase  = 0x100000000L,
         maskOtherUppercase  = 0x200000000L,
         maskOtherAlphabetic = 0x400000000L,
         maskOtherMath       = 0x800000000L,
         maskIdeographic     = 0x1000000000L,
-        maskNoncharacterCP  = 0x2000000000L;
+        maskNoncharacterCP  = 0x2000000000L,
+        maskIDStart         = 0x4000000000L,
+        maskIDContinue      = 0x8000000000L;
 
     // Can compare masked values with these to determine
     // numeric or lexical types.
     public static int
         valueNotNumeric             = 0x0000,
@@ -365,10 +370,12 @@
         addExProp(result, propList, "Other_Uppercase", maskOtherUppercase);
         addExProp(result, propList, "Other_Alphabetic", maskOtherAlphabetic);
         addExProp(result, propList, "Ideographic", maskIdeographic);
         //addExProp(result, propList, "Other_Math", maskOtherMath);
         //addExProp(result, propList, "Noncharacter_CodePoint", maskNoncharacterCP);
+        addExProp(result, propList, "ID_Start", maskIDStart);
+        addExProp(result, propList, "ID_Continue", maskIDContinue);
 
         return result;
     }
 
     // The maximum and minimum offsets found while scanning the database
@@ -778,10 +785,12 @@
         if (x.equals("maskTitleCase")) return "0x" + hex8(maskTitleCase);
         if (x.equals("maskOtherLowercase")) return "0x" + hex4(maskOtherLowercase >> 32);
         if (x.equals("maskOtherUppercase")) return "0x" + hex4(maskOtherUppercase >> 32);
         if (x.equals("maskOtherAlphabetic")) return "0x" + hex4(maskOtherAlphabetic >> 32);
         if (x.equals("maskIdeographic")) return "0x" + hex4(maskIdeographic >> 32);
+        if (x.equals("maskIDStart")) return "0x" + hex4(maskIDStart >> 32);
+        if (x.equals("maskIDContinue")) return "0x" + hex4(maskIDContinue >> 32);
         if (x.equals("valueIgnorable")) return "0x" + hex8(valueIgnorable);
         if (x.equals("valueJavaUnicodeStart")) return "0x" + hex8(valueJavaUnicodeStart);
         if (x.equals("valueJavaOnlyStart")) return "0x" + hex8(valueJavaOnlyStart);
         if (x.equals("valueJavaUnicodePart")) return "0x" + hex8(valueJavaUnicodePart);
         if (x.equals("valueJavaOnlyPart")) return "0x" + hex8(valueJavaOnlyPart);
@@ -1610,10 +1619,11 @@
     static String TemplateFileName = null;
     static String OutputFileName = null;
     static String UnicodeSpecFileName = null; // liu
     static String SpecialCasingFileName = null;
     static String PropListFileName = null;
+    static String DerivedPropsFileName = null;
     static boolean useCharForByte = false;
     static int[] sizes;
     static int bins = 0; // liu; if > 0, then perform search
     static boolean tableAsString = false;
     static boolean bLatin1 = false;
@@ -1737,10 +1747,18 @@
                 }
                 else {
                     PropListFileName = args[++j];
                 }
             }
+            else if (args[j].equals("-derivedprops")) {
+                if (j == args.length -1) {
+                    FAIL("File name missing after -derivedprops");
+                }
+                else {
+                    DerivedPropsFileName = args[++j];
+                }
+            }
             else if (args[j].equals("-plane")) {
                 if (j == args.length -1) {
                     FAIL("Plane number missing after -plane");
                 }
                 else {
@@ -1801,10 +1819,14 @@
         }
         if (PropListFileName == null) {
             PropListFileName = DefaultPropListFileName;
             desc.append(" [-proplist " + PropListFileName + ']');
         }
+        if (DerivedPropsFileName == null) {
+            DerivedPropsFileName = DefaultDerivedPropsFileName;
+            desc.append(" [-derivedprops " + DerivedPropsFileName + ']');
+        }
         if (TemplateFileName == null) {
             TemplateFileName = (Csyntax ? DefaultCTemplateFileName
                   : DefaultJavaTemplateFileName);
             desc.append(" [-template " + TemplateFileName + ']');
         }
@@ -1952,10 +1974,11 @@
         try {
 
             UnicodeSpec[] data = UnicodeSpec.readSpecFile(new File(UnicodeSpecFileName), plane);
             specialCaseMaps = SpecialCaseMap.readSpecFile(new File(SpecialCasingFileName), plane);
             PropList propList = PropList.readSpecFile(new File(PropListFileName), plane);
+            propList.putAll(PropList.readSpecFile(new File(DerivedPropsFileName), plane));
 
             if (verbose) {
                 System.out.println(data.length + " items read from Unicode spec file " + UnicodeSpecFileName); // liu
             }
             long[] map = buildMap(data, specialCaseMaps, propList);

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/jdk/src/classes/build/tools/cldrconverter/ResourceBundleGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="LDMLParseHandler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="StringListElement.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/jdk/src/classes/build/tools/cldrconverter/ResourceBundleGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
141             newMap.putAll(map);
142             map = newMap;
143         } else {
144             // generic reduction of duplicated values
145             Map&lt;String, Object&gt; newMap = null;
146             for (String key : map.keySet()) {
147                 Object val = map.get(key);
148                 String metaVal = null;
149 
150                 for (Map.Entry&lt;String, ?&gt; entry : map.entrySet()) {
151                     String k = entry.getKey();
152                     if (!k.equals(key) &amp;&amp;
153                         Objects.deepEquals(val, entry.getValue()) &amp;&amp;
154                         !(Objects.nonNull(newMap) &amp;&amp; newMap.containsKey(k))) {
155                         if (Objects.isNull(newMap)) {
156                             newMap = new HashMap&lt;&gt;();
157                             fmt = new Formatter();
158                         }
159 
160                         if (Objects.isNull(metaVal)) {
<span class="line-modified">161                             metaVal = META_VALUE_PREFIX + key.replaceAll(&quot;\\.&quot;, &quot;_&quot;);</span>
162 
163                             if (val instanceof String[]) {
164                                 fmt.format(&quot;        final String[] %s = new String[] {\n&quot;, metaVal);
165                                 for (String s : (String[])val) {
166                                     fmt.format(&quot;               \&quot;%s\&quot;,\n&quot;, CLDRConverter.saveConvert(s, useJava));
167                                 }
168                                 fmt.format(&quot;            };\n&quot;);
169                             } else {
170                                 fmt.format(&quot;        final String %s = \&quot;%s\&quot;;\n&quot;, metaVal, CLDRConverter.saveConvert((String)val, useJava));
171                             }
172                         }
173 
174                         newMap.put(k, metaVal);
175                     }
176                 }
177 
178                 if (Objects.nonNull(metaVal)) {
179                     newMap.put(key, metaVal);
180                 }
181             }
</pre>
<hr />
<pre>
292                     for (int i = 0; i &lt; children.length; i++) {
293                         String child = children[i];
294                         out.printf(&quot;\&quot;%s\&quot;, &quot;, child);
295                         count += child.length() + 4;
296                         if (i != children.length - 1 &amp;&amp; count &gt; 64) {
297                             out.printf(&quot;\n                 &quot;);
298                             count = 0;
299                         }
300                     }
301                     out.printf(&quot;\n             });\n&quot;);
302                 } else {
303                     if (&quot;AvailableLocales&quot;.equals(key)) {
304                         out.printf(&quot;        resourceNameToLocales.put(\&quot;%s\&quot;,\n&quot;, key);
305                         out.printf(&quot;              \&quot;%s\&quot;);\n&quot;, toLocaleList(applyLanguageAliases(metaInfo.get(key)), false));
306                     }
307                 }
308             }
309             // for languageAliasMap
310             if (CLDRConverter.isBaseModule) {
311                 CLDRConverter.handlerSupplMeta.getLanguageAliasData().forEach((key, value) -&gt; {
<span class="line-modified">312                     out.printf(&quot;                languageAliasMap.put(\&quot;%s\&quot;, \&quot;%s\&quot;);\n&quot;, key, value);</span>
313                 });
314             }
315 
316             out.printf(&quot;    }\n\n&quot;);
317 
318             // end of static initializer block.
319 
320             // Canonical TZ names for delayed initialization
321             if (CLDRConverter.isBaseModule) {
322                 out.printf(&quot;    private static class TZCanonicalIDMapHolder {\n&quot;);
323                 out.printf(&quot;        static final Map&lt;String, String&gt; tzCanonicalIDMap = new HashMap&lt;&gt;(600);\n&quot;);
324                 out.printf(&quot;        static {\n&quot;);
325                 CLDRConverter.handlerTimeZone.getData().entrySet().stream()
326                     .forEach(e -&gt; {
327                         String[] ids = ((String)e.getValue()).split(&quot;\\s&quot;);
328                         out.printf(&quot;            tzCanonicalIDMap.put(\&quot;%s\&quot;, \&quot;%s\&quot;);\n&quot;, e.getKey(),
329                                 ids[0]);
330                         for (int i = 1; i &lt; ids.length; i++) {
331                             out.printf(&quot;            tzCanonicalIDMap.put(\&quot;%s\&quot;, \&quot;%s\&quot;);\n&quot;, ids[i],
332                                 ids[0]);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
141             newMap.putAll(map);
142             map = newMap;
143         } else {
144             // generic reduction of duplicated values
145             Map&lt;String, Object&gt; newMap = null;
146             for (String key : map.keySet()) {
147                 Object val = map.get(key);
148                 String metaVal = null;
149 
150                 for (Map.Entry&lt;String, ?&gt; entry : map.entrySet()) {
151                     String k = entry.getKey();
152                     if (!k.equals(key) &amp;&amp;
153                         Objects.deepEquals(val, entry.getValue()) &amp;&amp;
154                         !(Objects.nonNull(newMap) &amp;&amp; newMap.containsKey(k))) {
155                         if (Objects.isNull(newMap)) {
156                             newMap = new HashMap&lt;&gt;();
157                             fmt = new Formatter();
158                         }
159 
160                         if (Objects.isNull(metaVal)) {
<span class="line-modified">161                             metaVal = META_VALUE_PREFIX + key.replaceAll(&quot;[\\.-]&quot;, &quot;_&quot;);</span>
162 
163                             if (val instanceof String[]) {
164                                 fmt.format(&quot;        final String[] %s = new String[] {\n&quot;, metaVal);
165                                 for (String s : (String[])val) {
166                                     fmt.format(&quot;               \&quot;%s\&quot;,\n&quot;, CLDRConverter.saveConvert(s, useJava));
167                                 }
168                                 fmt.format(&quot;            };\n&quot;);
169                             } else {
170                                 fmt.format(&quot;        final String %s = \&quot;%s\&quot;;\n&quot;, metaVal, CLDRConverter.saveConvert((String)val, useJava));
171                             }
172                         }
173 
174                         newMap.put(k, metaVal);
175                     }
176                 }
177 
178                 if (Objects.nonNull(metaVal)) {
179                     newMap.put(key, metaVal);
180                 }
181             }
</pre>
<hr />
<pre>
292                     for (int i = 0; i &lt; children.length; i++) {
293                         String child = children[i];
294                         out.printf(&quot;\&quot;%s\&quot;, &quot;, child);
295                         count += child.length() + 4;
296                         if (i != children.length - 1 &amp;&amp; count &gt; 64) {
297                             out.printf(&quot;\n                 &quot;);
298                             count = 0;
299                         }
300                     }
301                     out.printf(&quot;\n             });\n&quot;);
302                 } else {
303                     if (&quot;AvailableLocales&quot;.equals(key)) {
304                         out.printf(&quot;        resourceNameToLocales.put(\&quot;%s\&quot;,\n&quot;, key);
305                         out.printf(&quot;              \&quot;%s\&quot;);\n&quot;, toLocaleList(applyLanguageAliases(metaInfo.get(key)), false));
306                     }
307                 }
308             }
309             // for languageAliasMap
310             if (CLDRConverter.isBaseModule) {
311                 CLDRConverter.handlerSupplMeta.getLanguageAliasData().forEach((key, value) -&gt; {
<span class="line-modified">312                     out.printf(&quot;        languageAliasMap.put(\&quot;%s\&quot;, \&quot;%s\&quot;);\n&quot;, key, value);</span>
313                 });
314             }
315 
316             out.printf(&quot;    }\n\n&quot;);
317 
318             // end of static initializer block.
319 
320             // Canonical TZ names for delayed initialization
321             if (CLDRConverter.isBaseModule) {
322                 out.printf(&quot;    private static class TZCanonicalIDMapHolder {\n&quot;);
323                 out.printf(&quot;        static final Map&lt;String, String&gt; tzCanonicalIDMap = new HashMap&lt;&gt;(600);\n&quot;);
324                 out.printf(&quot;        static {\n&quot;);
325                 CLDRConverter.handlerTimeZone.getData().entrySet().stream()
326                     .forEach(e -&gt; {
327                         String[] ids = ((String)e.getValue()).split(&quot;\\s&quot;);
328                         out.printf(&quot;            tzCanonicalIDMap.put(\&quot;%s\&quot;, \&quot;%s\&quot;);\n&quot;, e.getKey(),
329                                 ids[0]);
330                         for (int i = 1; i &lt; ids.length; i++) {
331                             out.printf(&quot;            tzCanonicalIDMap.put(\&quot;%s\&quot;, \&quot;%s\&quot;);\n&quot;, ids[i],
332                                 ids[0]);
</pre>
</td>
</tr>
</table>
<center><a href="LDMLParseHandler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="StringListElement.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
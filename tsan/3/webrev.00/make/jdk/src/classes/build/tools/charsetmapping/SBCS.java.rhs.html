<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/jdk/src/classes/build/tools/charsetmapping/SBCS.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package build.tools.charsetmapping;
 27 
 28 import java.io.*;
 29 import java.util.Arrays;
 30 import java.util.ArrayList;
 31 import java.util.Scanner;
 32 import java.util.Formatter;
 33 import java.util.regex.Pattern;
 34 import static build.tools.charsetmapping.Utils.*;
 35 
 36 public class SBCS {
 37 
 38     static Pattern sbmap = Pattern.compile(&quot;0x(\\p{XDigit}++)\\s++(?:U\\+|0x)?(\\p{XDigit}++)(?:\\s++#.*)?&quot;);
 39 
 40     public static void genClass(Charset cs,
 41                                 String srcDir, String dstDir, String template)
 42         throws Exception
 43     {
 44         String clzName = cs.clzName;
 45         String csName  = cs.csName;
 46         String hisName = cs.hisName;
 47         String pkgName = cs.pkgName;
 48         boolean isASCII = cs.isASCII;
<a name="2" id="anc2"></a><span class="line-added"> 49         boolean isLatin1Decodable = true;</span>
 50 
 51         StringBuilder b2cSB = new StringBuilder();
 52         StringBuilder b2cNRSB = new StringBuilder();
 53         StringBuilder c2bNRSB = new StringBuilder();
 54 
 55         char[] sb = new char[0x100];
 56         char[] c2bIndex = new char[0x100];
 57         int    c2bOff = 0;
 58         Arrays.fill(sb, UNMAPPABLE_DECODING);
 59         Arrays.fill(c2bIndex, UNMAPPABLE_DECODING);
 60 
 61         // (1)read in .map to parse all b-&gt;c entries
 62         FileInputStream in = new FileInputStream(
 63                                  new File(srcDir, clzName + &quot;.map&quot;));
 64         Parser p = new Parser(in, sbmap);
 65         Entry  e = null;
 66 
 67         while ((e = p.next()) != null) {
 68             sb[e.bs] = (char)e.cp;
 69             if (c2bIndex[e.cp&gt;&gt;8] == UNMAPPABLE_DECODING) {
 70                 c2bOff += 0x100;
 71                 c2bIndex[e.cp&gt;&gt;8] = 1;
 72             }
<a name="3" id="anc3"></a><span class="line-added"> 73             if (e.cp &gt; 0xFF) {</span>
<span class="line-added"> 74                 isLatin1Decodable = false;</span>
<span class="line-added"> 75             }</span>
 76         }
 77 
 78         Formatter fm = new Formatter(b2cSB);
 79         fm.format(&quot;%n&quot;);
 80 
 81         // vm -server shows cc[byte + 128] access is much faster than
 82         // cc[byte&amp;0xff] so we output the upper segment first
 83         toString(sb, 0x80, 0x100, fm, &quot;+&quot;, true);
 84         toString(sb, 0x00, 0x80,  fm, &quot;;&quot;, true);
 85         fm.close();
 86 
 87         // (2)now the .nr file which includes &quot;b-&gt;c&quot; non-roundtrip entries
 88         File f = new File(srcDir, clzName + &quot;.nr&quot;);
 89         if (f.exists()) {
 90             in = new FileInputStream(f);
 91             fm = new Formatter(b2cNRSB);
 92             p = new Parser(in, sbmap);
 93             e = null;
 94 
 95             fm.format(&quot;// remove non-roundtrip entries%n&quot;);
 96             fm.format(&quot;        b2cMap = b2cTable.toCharArray();%n&quot;);
 97             while ((e = p.next()) != null) {
 98                 fm.format(&quot;        b2cMap[%d] = UNMAPPABLE_DECODING;%n&quot;,
 99                           (e.bs&gt;=0x80)?(e.bs-0x80):(e.bs+0x80));
100             }
101             fm.close();
102         }
103 
104         // (3)finally the .c2b file which includes c-&gt;b non-roundtrip entries
105         f = new File(srcDir, clzName + &quot;.c2b&quot;);
106         if (f.exists()) {
107             in = new FileInputStream(f);
108             fm = new Formatter(c2bNRSB);
109             p = new Parser(in, sbmap);
110             e = null;
111             ArrayList&lt;Entry&gt; es = new ArrayList&lt;Entry&gt;();
112             while ((e = p.next()) != null) {
113                 if (c2bIndex[e.cp&gt;&gt;8] == UNMAPPABLE_DECODING) {
114                     c2bOff += 0x100;
115                     c2bIndex[e.cp&gt;&gt;8] = 1;
116                 }
117                 es.add(e);
118             }
119             fm.format(&quot;// non-roundtrip c2b only entries%n&quot;);
120             if (es.size() &lt; 100) {
121                 fm.format(&quot;        c2bNR = new char[%d];%n&quot;, es.size() * 2);
122                 int i = 0;
123                 for (Entry entry: es) {
124                     fm.format(&quot;        c2bNR[%d] = 0x%x; c2bNR[%d] = 0x%x;%n&quot;,
125                               i++, entry.bs, i++, entry.cp);
126                 }
127             } else {
128                 char[] cc = new char[es.size() * 2];
129                 int i = 0;
130                 for (Entry entry: es) {
131                     cc[i++] = (char)entry.bs;
132                     cc[i++] = (char)entry.cp;
133                 }
134                 fm.format(&quot;        c2bNR = (%n&quot;);
135                 toString(cc, 0, i,  fm, &quot;).toCharArray();&quot;, false);
136             }
137             fm.close();
138         }
139 
140         // (4)it&#39;s time to generate the source file
141         String b2c = b2cSB.toString();
142         String b2cNR = b2cNRSB.toString();
143         String c2bNR = c2bNRSB.toString();
144 
145         Scanner s = new Scanner(new File(srcDir, template));
146         PrintStream out = new PrintStream(new FileOutputStream(
147                               new File(dstDir, clzName + &quot;.java&quot;)));
148 
149         while (s.hasNextLine()) {
150             String line = s.nextLine();
151             int i = line.indexOf(&quot;$&quot;);
152             if (i == -1) {
153                 out.println(line);
154                 continue;
155             }
156             if (line.indexOf(&quot;$PACKAGE$&quot;, i) != -1) {
157                 line = line.replace(&quot;$PACKAGE$&quot;, pkgName);
158             }
159             if (line.indexOf(&quot;$NAME_CLZ$&quot;, i) != -1) {
160                 line = line.replace(&quot;$NAME_CLZ$&quot;, clzName);
161             }
162             if (line.indexOf(&quot;$NAME_CS$&quot;, i) != -1) {
163                 line = line.replace(&quot;$NAME_CS$&quot;, csName);
164             }
165             if (line.indexOf(&quot;$NAME_ALIASES$&quot;, i) != -1) {
166                 if (&quot;sun.nio.cs&quot;.equals(pkgName))
167                     line = line.replace(&quot;$NAME_ALIASES$&quot;,
168                                         &quot;StandardCharsets.aliases_&quot; + clzName + &quot;()&quot;);
169                 else
170                     line = line.replace(&quot;$NAME_ALIASES$&quot;,
171                                         &quot;ExtendedCharsets.aliasesFor(\&quot;&quot; + csName + &quot;\&quot;)&quot;);
172             }
173             if (line.indexOf(&quot;$NAME_HIS$&quot;, i) != -1) {
174                 line = line.replace(&quot;$NAME_HIS$&quot;, hisName);
175             }
176             if (line.indexOf(&quot;$CONTAINS$&quot;, i) != -1) {
177                 if (isASCII)
178                     line = &quot;        return ((cs.name().equals(\&quot;US-ASCII\&quot;)) || (cs instanceof &quot; + clzName + &quot;));&quot;;
179                 else
180                     line = &quot;        return (cs instanceof &quot; + clzName + &quot;);&quot;;
181             }
182             if (line.indexOf(&quot;$ASCIICOMPATIBLE$&quot;) != -1) {
183                 line = line.replace(&quot;$ASCIICOMPATIBLE$&quot;, isASCII ? &quot;true&quot; : &quot;false&quot;);
184             }
<a name="4" id="anc4"></a><span class="line-added">185             if (line.indexOf(&quot;$LATIN1DECODABLE$&quot;) != -1) {</span>
<span class="line-added">186                 line = line.replace(&quot;$LATIN1DECODABLE$&quot;, isLatin1Decodable ? &quot;true&quot; : &quot;false&quot;);</span>
<span class="line-added">187             }</span>
188             if (line.indexOf(&quot;$B2CTABLE$&quot;) != -1) {
189                 line = line.replace(&quot;$B2CTABLE$&quot;, b2c);
190             }
191             if (line.indexOf(&quot;$C2BLENGTH$&quot;) != -1) {
192                 line = line.replace(&quot;$C2BLENGTH$&quot;, &quot;0x&quot; + Integer.toString(c2bOff, 16));
193             }
194             if (line.indexOf(&quot;$NONROUNDTRIP_B2C$&quot;) != -1) {
195                 if (b2cNR.length() == 0)
196                     continue;
197                 line = line.replace(&quot;$NONROUNDTRIP_B2C$&quot;, b2cNR);
198             }
199 
200             if (line.indexOf(&quot;$NONROUNDTRIP_C2B$&quot;) != -1) {
201                 if (c2bNR.length() == 0)
202                     continue;
203                 line = line.replace(&quot;$NONROUNDTRIP_C2B$&quot;, c2bNR);
204             }
205             out.println(line);
206         }
207         out.close();
208     }
209 
210     private static void toString(char[] sb, int off, int end,
211                                  Formatter out, String closure, boolean comment)
212     {
213         while (off &lt; end) {
214             out.format(&quot;        \&quot;&quot;);
215             for (int j = 0; j &lt; 8; j++) {
216                 if (off == end)
217                     break;
218                 char c = sb[off++];
219                 switch (c) {
220                 case &#39;\b&#39;:
221                     out.format(&quot;\\b&quot;); break;
222                 case &#39;\t&#39;:
223                     out.format(&quot;\\t&quot;); break;
224                 case &#39;\n&#39;:
225                     out.format(&quot;\\n&quot;); break;
226                 case &#39;\f&#39;:
227                     out.format(&quot;\\f&quot;); break;
228                 case &#39;\r&#39;:
229                     out.format(&quot;\\r&quot;); break;
230                 case &#39;\&quot;&#39;:
231                     out.format(&quot;\\\&quot;&quot;); break;
232                 case &#39;\&#39;&#39;:
233                     out.format(&quot;\\&#39;&quot;); break;
234                 case &#39;\\&#39;:
235                     out.format(&quot;\\\\&quot;); break;
236                 default:
237                     out.format(&quot;\\u%04X&quot;, c &amp; 0xffff);
238                 }
239             }
240             if (comment) {
241                 if (off == end)
242                     out.format(&quot;\&quot; %s      // 0x%02x - 0x%02x%n&quot;,
243                                closure, off-8, off-1);
244                 else
245                     out.format(&quot;\&quot; +      // 0x%02x - 0x%02x%n&quot;,
246                                off-8, off-1);
247             } else {
248                 if (off == end)
249                     out.format(&quot;\&quot;%s%n&quot;, closure);
250                 else
251                     out.format(&quot;\&quot; +%n&quot;);
252             }
253         }
254     }
255 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/jdk/src/classes/build/tools/cldrconverter/Bundle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractLDMLHandler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CLDRConverter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/jdk/src/classes/build/tools/cldrconverter/Bundle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package build.tools.cldrconverter;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 import java.util.EnumSet;
 31 import java.util.HashMap;
 32 import java.util.Iterator;
 33 import java.util.List;
 34 import java.util.Map;
 35 import java.util.Objects;


 36 
 37 class Bundle {
 38     static enum Type {
 39         LOCALENAMES, CURRENCYNAMES, TIMEZONENAMES, CALENDARDATA, FORMATDATA;
 40 
 41         static EnumSet&lt;Type&gt; ALL_TYPES = EnumSet.of(LOCALENAMES,
 42                                                     CURRENCYNAMES,
 43                                                     TIMEZONENAMES,
 44                                                     CALENDARDATA,
 45                                                     FORMATDATA);
 46     }
 47 
 48     private final static Map&lt;String, Bundle&gt; bundles = new HashMap&lt;&gt;();
 49 
 50     private final static String[] NUMBER_PATTERN_KEYS = {
 51         &quot;NumberPatterns/decimal&quot;,
 52         &quot;NumberPatterns/currency&quot;,
<span class="line-modified"> 53         &quot;NumberPatterns/percent&quot;</span>

 54     };
 55 
 56     private final static String[] COMPACT_NUMBER_PATTERN_KEYS = {
 57             &quot;short.CompactNumberPatterns&quot;,
<span class="line-modified"> 58             &quot;long.CompactNumberPatterns&quot;};</span>

 59 
 60     private final static String[] NUMBER_ELEMENT_KEYS = {
 61         &quot;NumberElements/decimal&quot;,
 62         &quot;NumberElements/group&quot;,
 63         &quot;NumberElements/list&quot;,
 64         &quot;NumberElements/percent&quot;,
 65         &quot;NumberElements/zero&quot;,
 66         &quot;NumberElements/pattern&quot;,
 67         &quot;NumberElements/minus&quot;,
 68         &quot;NumberElements/exponential&quot;,
 69         &quot;NumberElements/permille&quot;,
 70         &quot;NumberElements/infinity&quot;,
<span class="line-modified"> 71         &quot;NumberElements/nan&quot;</span>


 72     };
 73 
 74     private final static String[] TIME_PATTERN_KEYS = {
 75         &quot;DateTimePatterns/full-time&quot;,
 76         &quot;DateTimePatterns/long-time&quot;,
 77         &quot;DateTimePatterns/medium-time&quot;,
 78         &quot;DateTimePatterns/short-time&quot;,
 79     };
 80 
 81     private final static String[] DATE_PATTERN_KEYS = {
 82         &quot;DateTimePatterns/full-date&quot;,
 83         &quot;DateTimePatterns/long-date&quot;,
 84         &quot;DateTimePatterns/medium-date&quot;,
 85         &quot;DateTimePatterns/short-date&quot;,
 86     };
 87 
 88     private final static String[] DATETIME_PATTERN_KEYS = {
 89         &quot;DateTimePatterns/full-dateTime&quot;,
 90         &quot;DateTimePatterns/long-dateTime&quot;,
 91         &quot;DateTimePatterns/medium-dateTime&quot;,
</pre>
<hr />
<pre>
173         return currencies;
174     }
175 
176     /**
177      * Generate a map that contains all the data that should be
178      * visible for the bundle&#39;s locale
179      */
180     Map&lt;String, Object&gt; getTargetMap() throws Exception {
181         if (targetMap != null) {
182             return targetMap;
183         }
184 
185         String[] cldrBundles = getCLDRPath().split(&quot;,&quot;);
186 
187         // myMap contains resources for id.
188         Map&lt;String, Object&gt; myMap = new HashMap&lt;&gt;();
189         int index;
190         for (index = 0; index &lt; cldrBundles.length; index++) {
191             if (cldrBundles[index].equals(id)) {
192                 myMap.putAll(CLDRConverter.getCLDRBundle(cldrBundles[index]));
<span class="line-removed">193                 CLDRConverter.handleAliases(myMap);</span>
194                 break;
195             }
196         }
197 
198         // parentsMap contains resources from id&#39;s parents.
199         Map&lt;String, Object&gt; parentsMap = new HashMap&lt;&gt;();
200         for (int i = cldrBundles.length - 1; i &gt; index; i--) {
201             if (!(&quot;no&quot;.equals(cldrBundles[i]) || cldrBundles[i].startsWith(&quot;no_&quot;))) {
202                 parentsMap.putAll(CLDRConverter.getCLDRBundle(cldrBundles[i]));
<span class="line-removed">203                 CLDRConverter.handleAliases(parentsMap);</span>
204             }
205         }
206         // Duplicate myMap as parentsMap for &quot;root&quot; so that the
207         // fallback works. This is a hack, though.
208         if (&quot;root&quot;.equals(cldrBundles[0])) {
209             assert parentsMap.isEmpty();
210             parentsMap.putAll(myMap);
211         }
212 
213         // merge individual strings into arrays
214 
<span class="line-modified">215         // if myMap has any of the NumberPatterns members</span>
<span class="line-modified">216         for (String k : NUMBER_PATTERN_KEYS) {</span>
<span class="line-modified">217             if (myMap.containsKey(k)) {</span>
<span class="line-modified">218                 String[] numberPatterns = new String[NUMBER_PATTERN_KEYS.length];</span>
<span class="line-modified">219                 for (int i = 0; i &lt; NUMBER_PATTERN_KEYS.length; i++) {</span>
<span class="line-modified">220                     String key = NUMBER_PATTERN_KEYS[i];</span>
<span class="line-modified">221                     String value = (String) myMap.remove(key);</span>
<span class="line-modified">222                     if (value == null) {</span>
<span class="line-modified">223                         value = (String) parentsMap.remove(key);</span>
<span class="line-modified">224                     }</span>
<span class="line-removed">225                     if (value.length() == 0) {</span>
<span class="line-removed">226                         CLDRConverter.warning(&quot;empty pattern for &quot; + key);</span>
<span class="line-removed">227                     }</span>
<span class="line-removed">228                     numberPatterns[i] = value;</span>
<span class="line-removed">229                 }</span>
<span class="line-removed">230                 myMap.put(&quot;NumberPatterns&quot;, numberPatterns);</span>
<span class="line-removed">231                 break;</span>
232             }
233         }
234 
235         for (String k : COMPACT_NUMBER_PATTERN_KEYS) {
236             List&lt;String&gt; patterns = (List&lt;String&gt;) myMap.remove(k);
237             if (patterns != null) {
<span class="line-modified">238                 // Replace any null entry with empty strings.</span>
<span class="line-modified">239                 String[] arrPatterns = patterns.stream()</span>
<span class="line-modified">240                         .map(s -&gt; s == null ? &quot;&quot; : s).toArray(String[]::new);</span>
<span class="line-modified">241                 myMap.put(k, arrPatterns);</span>
<span class="line-modified">242             }</span>
<span class="line-modified">243         }</span>
<span class="line-modified">244 </span>
<span class="line-modified">245         // if myMap has any of NUMBER_ELEMENT_KEYS, create a complete NumberElements.</span>
<span class="line-modified">246         String defaultScript = (String) myMap.get(&quot;DefaultNumberingSystem&quot;);</span>
<span class="line-modified">247         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">248         List&lt;String&gt; scripts = (List&lt;String&gt;) myMap.get(&quot;numberingScripts&quot;);</span>
<span class="line-modified">249         if (defaultScript == null &amp;&amp; scripts != null) {</span>
<span class="line-modified">250             // Some locale data has no default script for numbering even with mutiple scripts.</span>
<span class="line-removed">251             // Take the first one as default in that case.</span>
<span class="line-removed">252             defaultScript = scripts.get(0);</span>
<span class="line-removed">253             myMap.put(&quot;DefaultNumberingSystem&quot;, defaultScript);</span>
<span class="line-removed">254         }</span>
<span class="line-removed">255         if (scripts != null) {</span>
<span class="line-removed">256             for (String script : scripts) {</span>
<span class="line-removed">257                 for (String k : NUMBER_ELEMENT_KEYS) {</span>
<span class="line-removed">258                     String[] numberElements = new String[NUMBER_ELEMENT_KEYS.length];</span>
<span class="line-removed">259                     for (int i = 0; i &lt; NUMBER_ELEMENT_KEYS.length; i++) {</span>
<span class="line-removed">260                         String key = script + &quot;.&quot; + NUMBER_ELEMENT_KEYS[i];</span>
<span class="line-removed">261                         String value = (String) myMap.remove(key);</span>
<span class="line-removed">262                         if (value == null) {</span>
<span class="line-removed">263                             if (key.endsWith(&quot;/pattern&quot;)) {</span>
<span class="line-removed">264                                 value = &quot;#&quot;;</span>
<span class="line-removed">265                             } else {</span>
<span class="line-removed">266                                 value = (String) parentsMap.get(key);</span>
<span class="line-removed">267                                 if (value == null) {</span>
<span class="line-removed">268                                     // the last resort is &quot;latn&quot;</span>
<span class="line-removed">269                                     key = &quot;latn.&quot; + NUMBER_ELEMENT_KEYS[i];</span>
<span class="line-removed">270                                     value = (String) parentsMap.get(key);</span>
<span class="line-removed">271                                     if (value == null) {</span>
<span class="line-removed">272                                         throw new InternalError(&quot;NumberElements: null for &quot; + key);</span>
<span class="line-removed">273                                     }</span>
<span class="line-removed">274                                 }</span>
275                             }
276                         }
<span class="line-modified">277                         numberElements[i] = value;</span>
<span class="line-modified">278                     }</span>
<span class="line-modified">279                     myMap.put(script + &quot;.&quot; + &quot;NumberElements&quot;, numberElements);</span>
<span class="line-modified">280                     break;</span>
<span class="line-modified">281                 }</span>







282             }
283         }
284 



285         // another hack: parentsMap is not used for date-time resources.
286         if (&quot;root&quot;.equals(id)) {
287             parentsMap = null;
288         }
289 
290         for (CalendarType calendarType : CalendarType.values()) {
291             String calendarPrefix = calendarType.keyElementName();
292             // handle multiple inheritance for month and day names
293             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNames&quot;);
294             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthAbbreviations&quot;);
295             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNarrows&quot;);
296             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNames&quot;);
297             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayAbbreviations&quot;);
298             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNarrows&quot;);
299             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;AmPmMarkers&quot;);
300             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;narrow.AmPmMarkers&quot;);
301             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;abbreviated.AmPmMarkers&quot;);
302             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNames&quot;);
303             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterAbbreviations&quot;);
304             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNarrows&quot;);
305 
306             adjustEraNames(myMap, calendarType);
307 
308             handleDateTimeFormatPatterns(TIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;TimePatterns&quot;);
309             handleDateTimeFormatPatterns(DATE_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DatePatterns&quot;);
310             handleDateTimeFormatPatterns(DATETIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DateTimePatterns&quot;);
311         }
312 
313         // First, weed out any empty timezone or metazone names from myMap.
<span class="line-removed">314         // Fill in any missing abbreviations if locale is &quot;en&quot;.</span>
315         for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
316             String key = it.next();
317             if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
318                     || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
319                 @SuppressWarnings(&quot;unchecked&quot;)
320                 Map&lt;String, String&gt; nameMap = (Map&lt;String, String&gt;) myMap.get(key);
321                 if (nameMap.isEmpty()) {
322                     // Some zones have only exemplarCity, which become empty.
323                     // Remove those from the map.
324                     it.remove();
325                     continue;
326                 }
<span class="line-removed">327 </span>
<span class="line-removed">328                 if (id.equals(&quot;en&quot;)) {</span>
<span class="line-removed">329                     fillInJREs(key, nameMap);</span>
<span class="line-removed">330                 }</span>
331             }
332         }
333         for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
334             String key = it.next();
335                 if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
336                     || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
337                 @SuppressWarnings(&quot;unchecked&quot;)
338                 Map&lt;String, String&gt; nameMap = (Map&lt;String, String&gt;) myMap.get(key);
339 
340                 // Convert key/value pairs to an array.
341                 String[] names = new String[ZONE_NAME_KEYS.length];
342                 int ix = 0;
343                 for (String nameKey : ZONE_NAME_KEYS) {
344                     String name = nameMap.get(nameKey);
345                     if (name == null &amp;&amp; parentsMap != null) {
346                         @SuppressWarnings(&quot;unchecked&quot;)
347                         Map&lt;String, String&gt; parentNames = (Map&lt;String, String&gt;) parentsMap.get(key);
348                         if (parentNames != null) {
349                             name = parentNames.get(nameKey);
350                         }
</pre>
<hr />
<pre>
393                 }
394             }
395         }
396 
397         // Remove all duplicates
398         if (Objects.nonNull(parentsMap)) {
399             for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
400                 String key = it.next();
401                 if (!key.equals(&quot;numberingScripts&quot;) &amp;&amp; // real body &quot;NumberElements&quot; may differ
402                     Objects.deepEquals(parentsMap.get(key), myMap.get(key))) {
403                     it.remove();
404                 }
405             }
406         }
407 
408         targetMap = myMap;
409         return myMap;
410     }
411 
412     private void handleMultipleInheritance(Map&lt;String, Object&gt; map, Map&lt;String, Object&gt; parents, String key) {
<span class="line-modified">413         String formatKey = key + &quot;/format&quot;;</span>
<span class="line-modified">414         Object format = map.get(formatKey);</span>
415         if (format != null) {
<span class="line-modified">416             map.remove(formatKey);</span>
417             map.put(key, format);
<span class="line-modified">418             if (fillInElements(parents, formatKey, format)) {</span>
419                 map.remove(key);
420             }
421         }
<span class="line-modified">422         String standaloneKey = key + &quot;/stand-alone&quot;;</span>
<span class="line-modified">423         Object standalone = map.get(standaloneKey);</span>
424         if (standalone != null) {
<span class="line-modified">425             map.remove(standaloneKey);</span>
<span class="line-modified">426             String realKey = key;</span>
<span class="line-modified">427             if (format != null) {</span>
<span class="line-modified">428                 realKey = &quot;standalone.&quot; + key;</span>
<span class="line-modified">429             }</span>
<span class="line-removed">430             map.put(realKey, standalone);</span>
<span class="line-removed">431             if (fillInElements(parents, standaloneKey, standalone)) {</span>
<span class="line-removed">432                 map.remove(realKey);</span>
433             }
434         }
435     }
436 
437     /**
438      * Fills in any empty elements with its parent element. Returns true if the resulting array is
439      * identical to its parent array.
440      *
441      * @param parents
442      * @param key
443      * @param value
444      * @return true if the resulting array is identical to its parent array.
445      */
446     private boolean fillInElements(Map&lt;String, Object&gt; parents, String key, Object value) {
447         if (parents == null) {
448             return false;
449         }
450         if (value instanceof String[]) {
451             Object pvalue = parents.get(key);
452             if (pvalue != null &amp;&amp; pvalue instanceof String[]) {
</pre>
<hr />
<pre>
473         int index = 0;
474         for (String key : ERA_KEYS) {
475             String realKey = type.keyElementName() + key;
476             String[] value = (String[]) map.get(realKey);
477             if (value != null) {
478                 switch (type) {
479                 case GREGORIAN:
480                     break;
481 
482                 case JAPANESE:
483                     {
484                         String[] newValue = new String[value.length + 1];
485                         String[] julianEras = (String[]) map.get(key);
486                         if (julianEras != null &amp;&amp; julianEras.length &gt;= 2) {
487                             newValue[0] = julianEras[1];
488                         } else {
489                             newValue[0] = &quot;&quot;;
490                         }
491                         System.arraycopy(value, 0, newValue, 1, value.length);
492                         value = newValue;





493                     }
494                     break;
495 
496                 case BUDDHIST:
497                     // Replace the value
498                     value = new String[] {&quot;BC&quot;, value[0]};
499                     break;
500 
501                 case ISLAMIC:
502                     // Replace the value
503                     value = new String[] {&quot;&quot;, value[0]};
504                     break;
505                 }
506                 if (!key.equals(realKey)) {
507                     map.put(realKey, value);

508                 }
509             }
510             realKeys[index] = realKey;
511             eraNames[index++] = value;
512         }
513         for (int i = 0; i &lt; eraNames.length; i++) {
514             if (eraNames[i] == null) {
515                 map.put(realKeys[i], null);
516             }
517         }
518     }
519 
520     private void handleDateTimeFormatPatterns(String[] patternKeys, Map&lt;String, Object&gt; myMap, Map&lt;String, Object&gt; parentsMap,
521                                               CalendarType calendarType, String name) {
522         String calendarPrefix = calendarType.keyElementName();
523         for (String k : patternKeys) {
524             if (myMap.containsKey(calendarPrefix + k)) {
525                 int len = patternKeys.length;
526                 List&lt;String&gt; dateTimePatterns = new ArrayList&lt;&gt;(len);
527                 List&lt;String&gt; sdfPatterns = new ArrayList&lt;&gt;(len);
</pre>
<hr />
<pre>
633         if (count != 0) {
634             converter.convert(calendarType, lastLetter, count, jrePattern);
635         }
636         if (cldrFormat.contentEquals(jrePattern)) {
637             return cldrFormat;
638         }
639         return jrePattern.toString();
640     }
641 
642     private String toMetaZoneKey(String tzKey) {
643         if (tzKey.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)) {
644             String tz = tzKey.substring(CLDRConverter.TIMEZONE_ID_PREFIX.length());
645             String meta = CLDRConverter.handlerMetaZones.get(tz);
646             if (meta != null) {
647                 return CLDRConverter.METAZONE_ID_PREFIX + meta;
648             }
649         }
650         return null;
651     }
652 
<span class="line-removed">653     static List&lt;Object[]&gt; jreTimeZoneNames = Arrays.asList(TimeZoneNames.getContents());</span>
<span class="line-removed">654     private void fillInJREs(String key, Map&lt;String, String&gt; map) {</span>
<span class="line-removed">655         String tzid = null;</span>
<span class="line-removed">656 </span>
<span class="line-removed">657         if (key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {</span>
<span class="line-removed">658             // Look for tzid</span>
<span class="line-removed">659             String meta = key.substring(CLDRConverter.METAZONE_ID_PREFIX.length());</span>
<span class="line-removed">660             if (meta.equals(&quot;GMT&quot;)) {</span>
<span class="line-removed">661                 tzid = meta;</span>
<span class="line-removed">662             } else {</span>
<span class="line-removed">663                 for (String tz : CLDRConverter.handlerMetaZones.keySet()) {</span>
<span class="line-removed">664                     if (CLDRConverter.handlerMetaZones.get(tz).equals(meta)) {</span>
<span class="line-removed">665                         tzid = tz;</span>
<span class="line-removed">666                         break;</span>
<span class="line-removed">667                     }</span>
<span class="line-removed">668                 }</span>
<span class="line-removed">669             }</span>
<span class="line-removed">670         } else {</span>
<span class="line-removed">671             tzid = key.substring(CLDRConverter.TIMEZONE_ID_PREFIX.length());</span>
<span class="line-removed">672         }</span>
<span class="line-removed">673 </span>
<span class="line-removed">674         if (tzid != null) {</span>
<span class="line-removed">675             for (Object[] jreZone : jreTimeZoneNames) {</span>
<span class="line-removed">676                 if (jreZone[0].equals(tzid)) {</span>
<span class="line-removed">677                     for (int i = 0; i &lt; ZONE_NAME_KEYS.length; i++) {</span>
<span class="line-removed">678                         if (map.get(ZONE_NAME_KEYS[i]) == null) {</span>
<span class="line-removed">679                             String[] jreNames = (String[])jreZone[1];</span>
<span class="line-removed">680                             map.put(ZONE_NAME_KEYS[i], jreNames[i]);</span>
<span class="line-removed">681                         }</span>
<span class="line-removed">682                     }</span>
<span class="line-removed">683                     break;</span>
<span class="line-removed">684                 }</span>
<span class="line-removed">685             }</span>
<span class="line-removed">686         }</span>
<span class="line-removed">687     }</span>
<span class="line-removed">688 </span>
689     /**
690      * Perform a generic conversion of CLDR date-time format pattern letter based
691      * on the support given by the SimpleDateFormat and the j.t.f.DateTimeFormatter
692      * for date-time formatting.
693      */
694     private void convertDateTimePatternLetter(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb) {
695         switch (cldrLetter) {
696             case &#39;u&#39;:
697                 // Change cldr letter &#39;u&#39; to &#39;y&#39;, as &#39;u&#39; is interpreted as
698                 // &quot;Extended year (numeric)&quot; in CLDR/LDML,
699                 // which is not supported in SimpleDateFormat and
700                 // j.t.f.DateTimeFormatter, so it is replaced with &#39;y&#39;
701                 // as the best approximation
702                 appendN(&#39;y&#39;, count, sb);
703                 break;
704             case &#39;B&#39;:
705                 // &#39;B&#39; character (day period) is not supported by
706                 // SimpleDateFormat and j.t.f.DateTimeFormatter,
707                 // this is a workaround in which &#39;B&#39; character
708                 // appearing in CLDR date-time pattern is replaced
</pre>
<hr />
<pre>
776 
777     private void appendN(char c, int n, StringBuilder sb) {
778         for (int i = 0; i &lt; n; i++) {
779             sb.append(c);
780         }
781     }
782 
783     private static boolean hasNulls(Object[] array) {
784         for (int i = 0; i &lt; array.length; i++) {
785             if (array[i] == null) {
786                 return true;
787             }
788         }
789         return false;
790     }
791 
792     @FunctionalInterface
793     private interface ConvertDateTimeLetters {
794         void convert(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb);
795     }












































796 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package build.tools.cldrconverter;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 import java.util.EnumSet;
 31 import java.util.HashMap;
 32 import java.util.Iterator;
 33 import java.util.List;
 34 import java.util.Map;
 35 import java.util.Objects;
<span class="line-added"> 36 import java.util.Optional;</span>
<span class="line-added"> 37 import java.util.stream.IntStream;</span>
 38 
 39 class Bundle {
 40     static enum Type {
 41         LOCALENAMES, CURRENCYNAMES, TIMEZONENAMES, CALENDARDATA, FORMATDATA;
 42 
 43         static EnumSet&lt;Type&gt; ALL_TYPES = EnumSet.of(LOCALENAMES,
 44                                                     CURRENCYNAMES,
 45                                                     TIMEZONENAMES,
 46                                                     CALENDARDATA,
 47                                                     FORMATDATA);
 48     }
 49 
 50     private final static Map&lt;String, Bundle&gt; bundles = new HashMap&lt;&gt;();
 51 
 52     private final static String[] NUMBER_PATTERN_KEYS = {
 53         &quot;NumberPatterns/decimal&quot;,
 54         &quot;NumberPatterns/currency&quot;,
<span class="line-modified"> 55         &quot;NumberPatterns/percent&quot;,</span>
<span class="line-added"> 56         &quot;NumberPatterns/accounting&quot;</span>
 57     };
 58 
 59     private final static String[] COMPACT_NUMBER_PATTERN_KEYS = {
 60             &quot;short.CompactNumberPatterns&quot;,
<span class="line-modified"> 61             &quot;long.CompactNumberPatterns&quot;</span>
<span class="line-added"> 62     };</span>
 63 
 64     private final static String[] NUMBER_ELEMENT_KEYS = {
 65         &quot;NumberElements/decimal&quot;,
 66         &quot;NumberElements/group&quot;,
 67         &quot;NumberElements/list&quot;,
 68         &quot;NumberElements/percent&quot;,
 69         &quot;NumberElements/zero&quot;,
 70         &quot;NumberElements/pattern&quot;,
 71         &quot;NumberElements/minus&quot;,
 72         &quot;NumberElements/exponential&quot;,
 73         &quot;NumberElements/permille&quot;,
 74         &quot;NumberElements/infinity&quot;,
<span class="line-modified"> 75         &quot;NumberElements/nan&quot;,</span>
<span class="line-added"> 76         &quot;NumberElements/currencyDecimal&quot;,</span>
<span class="line-added"> 77         &quot;NumberElements/currencyGroup&quot;,</span>
 78     };
 79 
 80     private final static String[] TIME_PATTERN_KEYS = {
 81         &quot;DateTimePatterns/full-time&quot;,
 82         &quot;DateTimePatterns/long-time&quot;,
 83         &quot;DateTimePatterns/medium-time&quot;,
 84         &quot;DateTimePatterns/short-time&quot;,
 85     };
 86 
 87     private final static String[] DATE_PATTERN_KEYS = {
 88         &quot;DateTimePatterns/full-date&quot;,
 89         &quot;DateTimePatterns/long-date&quot;,
 90         &quot;DateTimePatterns/medium-date&quot;,
 91         &quot;DateTimePatterns/short-date&quot;,
 92     };
 93 
 94     private final static String[] DATETIME_PATTERN_KEYS = {
 95         &quot;DateTimePatterns/full-dateTime&quot;,
 96         &quot;DateTimePatterns/long-dateTime&quot;,
 97         &quot;DateTimePatterns/medium-dateTime&quot;,
</pre>
<hr />
<pre>
179         return currencies;
180     }
181 
182     /**
183      * Generate a map that contains all the data that should be
184      * visible for the bundle&#39;s locale
185      */
186     Map&lt;String, Object&gt; getTargetMap() throws Exception {
187         if (targetMap != null) {
188             return targetMap;
189         }
190 
191         String[] cldrBundles = getCLDRPath().split(&quot;,&quot;);
192 
193         // myMap contains resources for id.
194         Map&lt;String, Object&gt; myMap = new HashMap&lt;&gt;();
195         int index;
196         for (index = 0; index &lt; cldrBundles.length; index++) {
197             if (cldrBundles[index].equals(id)) {
198                 myMap.putAll(CLDRConverter.getCLDRBundle(cldrBundles[index]));

199                 break;
200             }
201         }
202 
203         // parentsMap contains resources from id&#39;s parents.
204         Map&lt;String, Object&gt; parentsMap = new HashMap&lt;&gt;();
205         for (int i = cldrBundles.length - 1; i &gt; index; i--) {
206             if (!(&quot;no&quot;.equals(cldrBundles[i]) || cldrBundles[i].startsWith(&quot;no_&quot;))) {
207                 parentsMap.putAll(CLDRConverter.getCLDRBundle(cldrBundles[i]));

208             }
209         }
210         // Duplicate myMap as parentsMap for &quot;root&quot; so that the
211         // fallback works. This is a hack, though.
212         if (&quot;root&quot;.equals(cldrBundles[0])) {
213             assert parentsMap.isEmpty();
214             parentsMap.putAll(myMap);
215         }
216 
217         // merge individual strings into arrays
218 
<span class="line-modified">219         // if myMap has any of the NumberPatterns/NumberElements members, create a</span>
<span class="line-modified">220         // complete array of patterns/elements.</span>
<span class="line-modified">221         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">222         List&lt;String&gt; scripts = (List&lt;String&gt;) myMap.get(&quot;numberingScripts&quot;);</span>
<span class="line-modified">223         if (scripts != null) {</span>
<span class="line-modified">224             for (String script : scripts) {</span>
<span class="line-modified">225                 myMap.put(script + &quot;.NumberPatterns&quot;,</span>
<span class="line-modified">226                         createNumberArray(myMap, parentsMap, NUMBER_PATTERN_KEYS, script));</span>
<span class="line-modified">227                 myMap.put(script + &quot;.NumberElements&quot;,</span>
<span class="line-modified">228                         createNumberArray(myMap, parentsMap, NUMBER_ELEMENT_KEYS, script));</span>







229             }
230         }
231 
232         for (String k : COMPACT_NUMBER_PATTERN_KEYS) {
233             List&lt;String&gt; patterns = (List&lt;String&gt;) myMap.remove(k);
234             if (patterns != null) {
<span class="line-modified">235                 // Convert the map value from List&lt;String&gt; to String[], replacing any missing</span>
<span class="line-modified">236                 // entry from the parents map, if any.</span>
<span class="line-modified">237                 final List&lt;String&gt; pList = (List&lt;String&gt;)parentsMap.get(k);</span>
<span class="line-modified">238                 int size = patterns.size();</span>
<span class="line-modified">239                 int psize = pList != null ? pList.size() : 0;</span>
<span class="line-modified">240                 String[] arrPatterns = IntStream.range(0, Math.max(size, psize))</span>
<span class="line-modified">241                     .mapToObj(i -&gt; {</span>
<span class="line-modified">242                         String pattern;</span>
<span class="line-modified">243                         // first try itself.</span>
<span class="line-modified">244                         if (i &lt; size) {</span>
<span class="line-modified">245                             pattern = patterns.get(i);</span>
<span class="line-modified">246                             if (!pattern.isEmpty()) {</span>
<span class="line-modified">247                                 return &quot;{&quot; + pattern + &quot;}&quot;;</span>
























248                             }
249                         }
<span class="line-modified">250                         // if not found, try parent</span>
<span class="line-modified">251                         if (i &lt; psize) {</span>
<span class="line-modified">252                             pattern = pList.get(i);</span>
<span class="line-modified">253                             if (!pattern.isEmpty()) {</span>
<span class="line-modified">254                                 return &quot;{&quot; + pattern + &quot;}&quot;;</span>
<span class="line-added">255                             }</span>
<span class="line-added">256                         }</span>
<span class="line-added">257                         // bail out with empty string</span>
<span class="line-added">258                         return &quot;&quot;;</span>
<span class="line-added">259                     })</span>
<span class="line-added">260                     .toArray(String[]::new);</span>
<span class="line-added">261                 myMap.put(k, arrPatterns);</span>
262             }
263         }
264 
<span class="line-added">265         // Processes aliases here</span>
<span class="line-added">266         CLDRConverter.handleAliases(myMap);</span>
<span class="line-added">267 </span>
268         // another hack: parentsMap is not used for date-time resources.
269         if (&quot;root&quot;.equals(id)) {
270             parentsMap = null;
271         }
272 
273         for (CalendarType calendarType : CalendarType.values()) {
274             String calendarPrefix = calendarType.keyElementName();
275             // handle multiple inheritance for month and day names
276             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNames&quot;);
277             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthAbbreviations&quot;);
278             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNarrows&quot;);
279             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNames&quot;);
280             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayAbbreviations&quot;);
281             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNarrows&quot;);
282             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;AmPmMarkers&quot;);
283             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;narrow.AmPmMarkers&quot;);
284             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;abbreviated.AmPmMarkers&quot;);
285             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNames&quot;);
286             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterAbbreviations&quot;);
287             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNarrows&quot;);
288 
289             adjustEraNames(myMap, calendarType);
290 
291             handleDateTimeFormatPatterns(TIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;TimePatterns&quot;);
292             handleDateTimeFormatPatterns(DATE_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DatePatterns&quot;);
293             handleDateTimeFormatPatterns(DATETIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DateTimePatterns&quot;);
294         }
295 
296         // First, weed out any empty timezone or metazone names from myMap.

297         for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
298             String key = it.next();
299             if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
300                     || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
301                 @SuppressWarnings(&quot;unchecked&quot;)
302                 Map&lt;String, String&gt; nameMap = (Map&lt;String, String&gt;) myMap.get(key);
303                 if (nameMap.isEmpty()) {
304                     // Some zones have only exemplarCity, which become empty.
305                     // Remove those from the map.
306                     it.remove();
307                     continue;
308                 }




309             }
310         }
311         for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
312             String key = it.next();
313                 if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
314                     || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
315                 @SuppressWarnings(&quot;unchecked&quot;)
316                 Map&lt;String, String&gt; nameMap = (Map&lt;String, String&gt;) myMap.get(key);
317 
318                 // Convert key/value pairs to an array.
319                 String[] names = new String[ZONE_NAME_KEYS.length];
320                 int ix = 0;
321                 for (String nameKey : ZONE_NAME_KEYS) {
322                     String name = nameMap.get(nameKey);
323                     if (name == null &amp;&amp; parentsMap != null) {
324                         @SuppressWarnings(&quot;unchecked&quot;)
325                         Map&lt;String, String&gt; parentNames = (Map&lt;String, String&gt;) parentsMap.get(key);
326                         if (parentNames != null) {
327                             name = parentNames.get(nameKey);
328                         }
</pre>
<hr />
<pre>
371                 }
372             }
373         }
374 
375         // Remove all duplicates
376         if (Objects.nonNull(parentsMap)) {
377             for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
378                 String key = it.next();
379                 if (!key.equals(&quot;numberingScripts&quot;) &amp;&amp; // real body &quot;NumberElements&quot; may differ
380                     Objects.deepEquals(parentsMap.get(key), myMap.get(key))) {
381                     it.remove();
382                 }
383             }
384         }
385 
386         targetMap = myMap;
387         return myMap;
388     }
389 
390     private void handleMultipleInheritance(Map&lt;String, Object&gt; map, Map&lt;String, Object&gt; parents, String key) {
<span class="line-modified">391         String formatMapKey = key + &quot;/format&quot;;</span>
<span class="line-modified">392         Object format = map.get(formatMapKey);</span>
393         if (format != null) {
<span class="line-modified">394             map.remove(formatMapKey);</span>
395             map.put(key, format);
<span class="line-modified">396             if (fillInElements(parents, formatMapKey, format)) {</span>
397                 map.remove(key);
398             }
399         }
<span class="line-modified">400         String standaloneMapKey = key + &quot;/stand-alone&quot;;</span>
<span class="line-modified">401         Object standalone = map.get(standaloneMapKey);</span>
402         if (standalone != null) {
<span class="line-modified">403             map.remove(standaloneMapKey);</span>
<span class="line-modified">404             String standaloneResourceKey = &quot;standalone.&quot; + key;</span>
<span class="line-modified">405             map.put(standaloneResourceKey, standalone);</span>
<span class="line-modified">406             if (fillInElements(parents, standaloneMapKey, standalone)) {</span>
<span class="line-modified">407                 map.remove(standaloneResourceKey);</span>



408             }
409         }
410     }
411 
412     /**
413      * Fills in any empty elements with its parent element. Returns true if the resulting array is
414      * identical to its parent array.
415      *
416      * @param parents
417      * @param key
418      * @param value
419      * @return true if the resulting array is identical to its parent array.
420      */
421     private boolean fillInElements(Map&lt;String, Object&gt; parents, String key, Object value) {
422         if (parents == null) {
423             return false;
424         }
425         if (value instanceof String[]) {
426             Object pvalue = parents.get(key);
427             if (pvalue != null &amp;&amp; pvalue instanceof String[]) {
</pre>
<hr />
<pre>
448         int index = 0;
449         for (String key : ERA_KEYS) {
450             String realKey = type.keyElementName() + key;
451             String[] value = (String[]) map.get(realKey);
452             if (value != null) {
453                 switch (type) {
454                 case GREGORIAN:
455                     break;
456 
457                 case JAPANESE:
458                     {
459                         String[] newValue = new String[value.length + 1];
460                         String[] julianEras = (String[]) map.get(key);
461                         if (julianEras != null &amp;&amp; julianEras.length &gt;= 2) {
462                             newValue[0] = julianEras[1];
463                         } else {
464                             newValue[0] = &quot;&quot;;
465                         }
466                         System.arraycopy(value, 0, newValue, 1, value.length);
467                         value = newValue;
<span class="line-added">468 </span>
<span class="line-added">469                         // fix up &#39;Reiwa&#39; era, which can be missing in some locales</span>
<span class="line-added">470                         if (value[value.length - 1] == null) {</span>
<span class="line-added">471                             value[value.length - 1] = (key.startsWith(&quot;narrow.&quot;) ? &quot;R&quot; : &quot;Reiwa&quot;);</span>
<span class="line-added">472                         }</span>
473                     }
474                     break;
475 
476                 case BUDDHIST:
477                     // Replace the value
478                     value = new String[] {&quot;BC&quot;, value[0]};
479                     break;
480 
481                 case ISLAMIC:
482                     // Replace the value
483                     value = new String[] {&quot;&quot;, value[0]};
484                     break;
485                 }
486                 if (!key.equals(realKey)) {
487                     map.put(realKey, value);
<span class="line-added">488                     map.put(&quot;java.time.&quot; + realKey, value);</span>
489                 }
490             }
491             realKeys[index] = realKey;
492             eraNames[index++] = value;
493         }
494         for (int i = 0; i &lt; eraNames.length; i++) {
495             if (eraNames[i] == null) {
496                 map.put(realKeys[i], null);
497             }
498         }
499     }
500 
501     private void handleDateTimeFormatPatterns(String[] patternKeys, Map&lt;String, Object&gt; myMap, Map&lt;String, Object&gt; parentsMap,
502                                               CalendarType calendarType, String name) {
503         String calendarPrefix = calendarType.keyElementName();
504         for (String k : patternKeys) {
505             if (myMap.containsKey(calendarPrefix + k)) {
506                 int len = patternKeys.length;
507                 List&lt;String&gt; dateTimePatterns = new ArrayList&lt;&gt;(len);
508                 List&lt;String&gt; sdfPatterns = new ArrayList&lt;&gt;(len);
</pre>
<hr />
<pre>
614         if (count != 0) {
615             converter.convert(calendarType, lastLetter, count, jrePattern);
616         }
617         if (cldrFormat.contentEquals(jrePattern)) {
618             return cldrFormat;
619         }
620         return jrePattern.toString();
621     }
622 
623     private String toMetaZoneKey(String tzKey) {
624         if (tzKey.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)) {
625             String tz = tzKey.substring(CLDRConverter.TIMEZONE_ID_PREFIX.length());
626             String meta = CLDRConverter.handlerMetaZones.get(tz);
627             if (meta != null) {
628                 return CLDRConverter.METAZONE_ID_PREFIX + meta;
629             }
630         }
631         return null;
632     }
633 




































634     /**
635      * Perform a generic conversion of CLDR date-time format pattern letter based
636      * on the support given by the SimpleDateFormat and the j.t.f.DateTimeFormatter
637      * for date-time formatting.
638      */
639     private void convertDateTimePatternLetter(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb) {
640         switch (cldrLetter) {
641             case &#39;u&#39;:
642                 // Change cldr letter &#39;u&#39; to &#39;y&#39;, as &#39;u&#39; is interpreted as
643                 // &quot;Extended year (numeric)&quot; in CLDR/LDML,
644                 // which is not supported in SimpleDateFormat and
645                 // j.t.f.DateTimeFormatter, so it is replaced with &#39;y&#39;
646                 // as the best approximation
647                 appendN(&#39;y&#39;, count, sb);
648                 break;
649             case &#39;B&#39;:
650                 // &#39;B&#39; character (day period) is not supported by
651                 // SimpleDateFormat and j.t.f.DateTimeFormatter,
652                 // this is a workaround in which &#39;B&#39; character
653                 // appearing in CLDR date-time pattern is replaced
</pre>
<hr />
<pre>
721 
722     private void appendN(char c, int n, StringBuilder sb) {
723         for (int i = 0; i &lt; n; i++) {
724             sb.append(c);
725         }
726     }
727 
728     private static boolean hasNulls(Object[] array) {
729         for (int i = 0; i &lt; array.length; i++) {
730             if (array[i] == null) {
731                 return true;
732             }
733         }
734         return false;
735     }
736 
737     @FunctionalInterface
738     private interface ConvertDateTimeLetters {
739         void convert(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb);
740     }
<span class="line-added">741 </span>
<span class="line-added">742     /**</span>
<span class="line-added">743      * Returns a complete string array for NumberElements or NumberPatterns. If any</span>
<span class="line-added">744      * array element is missing, it will fall back to parents map, as well as</span>
<span class="line-added">745      * numbering script fallback.</span>
<span class="line-added">746      */</span>
<span class="line-added">747     private String[] createNumberArray(Map&lt;String, Object&gt; myMap, Map&lt;String, Object&gt;parentsMap,</span>
<span class="line-added">748                                         String[] keys, String script) {</span>
<span class="line-added">749         String[] numArray = new String[keys.length];</span>
<span class="line-added">750         for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="line-added">751             String key = script + &quot;.&quot; + keys[i];</span>
<span class="line-added">752             final int idx = i;</span>
<span class="line-added">753             Optional.ofNullable(</span>
<span class="line-added">754                 myMap.getOrDefault(key,</span>
<span class="line-added">755                     // if value not found in myMap, search for parentsMap</span>
<span class="line-added">756                     parentsMap.getOrDefault(key,</span>
<span class="line-added">757                         parentsMap.getOrDefault(keys[i],</span>
<span class="line-added">758                             // the last resort is &quot;latn&quot;</span>
<span class="line-added">759                             parentsMap.get(&quot;latn.&quot; + keys[i])))))</span>
<span class="line-added">760                 .ifPresentOrElse(v -&gt; numArray[idx] = (String)v, () -&gt; {</span>
<span class="line-added">761                     if (keys == NUMBER_PATTERN_KEYS) {</span>
<span class="line-added">762                         // NumberPatterns</span>
<span class="line-added">763                         if (!key.endsWith(&quot;accounting&quot;)) {</span>
<span class="line-added">764                             // throw error unless it is for &quot;accounting&quot;,</span>
<span class="line-added">765                             // which may be missing.</span>
<span class="line-added">766                             throw new InternalError(&quot;NumberPatterns: null for &quot; +</span>
<span class="line-added">767                                                     key + &quot;, id: &quot; + id);</span>
<span class="line-added">768                         }</span>
<span class="line-added">769                     } else {</span>
<span class="line-added">770                         // NumberElements</span>
<span class="line-added">771                         assert keys == NUMBER_ELEMENT_KEYS;</span>
<span class="line-added">772                         if (key.endsWith(&quot;/pattern&quot;)) {</span>
<span class="line-added">773                             numArray[idx] = &quot;#&quot;;</span>
<span class="line-added">774                         } else if (!key.endsWith(&quot;currencyDecimal&quot;) &amp;&amp;</span>
<span class="line-added">775                                    !key.endsWith(&quot;currencyGroup&quot;)) {</span>
<span class="line-added">776                             // throw error unless it is for &quot;currencyDecimal/Group&quot;,</span>
<span class="line-added">777                             // which may be missing.</span>
<span class="line-added">778                             throw new InternalError(&quot;NumberElements: null for &quot; +</span>
<span class="line-added">779                                                     key + &quot;, id: &quot; + id);</span>
<span class="line-added">780                         }</span>
<span class="line-added">781                     }});</span>
<span class="line-added">782         }</span>
<span class="line-added">783         return numArray;</span>
<span class="line-added">784     }</span>
785 }
</pre>
</td>
</tr>
</table>
<center><a href="AbstractLDMLHandler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CLDRConverter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/jdk/src/classes/build/tools/charsetmapping/SBCS.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../idea/template/vcs.xml.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../classlist/HelloClasslist.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/jdk/src/classes/build/tools/charsetmapping/SBCS.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 29 import java.util.Arrays;
 30 import java.util.ArrayList;
 31 import java.util.Scanner;
 32 import java.util.Formatter;
 33 import java.util.regex.Pattern;
 34 import static build.tools.charsetmapping.Utils.*;
 35 
 36 public class SBCS {
 37 
 38     static Pattern sbmap = Pattern.compile(&quot;0x(\\p{XDigit}++)\\s++(?:U\\+|0x)?(\\p{XDigit}++)(?:\\s++#.*)?&quot;);
 39 
 40     public static void genClass(Charset cs,
 41                                 String srcDir, String dstDir, String template)
 42         throws Exception
 43     {
 44         String clzName = cs.clzName;
 45         String csName  = cs.csName;
 46         String hisName = cs.hisName;
 47         String pkgName = cs.pkgName;
 48         boolean isASCII = cs.isASCII;

 49 
 50         StringBuilder b2cSB = new StringBuilder();
 51         StringBuilder b2cNRSB = new StringBuilder();
 52         StringBuilder c2bNRSB = new StringBuilder();
 53 
 54         char[] sb = new char[0x100];
 55         char[] c2bIndex = new char[0x100];
 56         int    c2bOff = 0;
 57         Arrays.fill(sb, UNMAPPABLE_DECODING);
 58         Arrays.fill(c2bIndex, UNMAPPABLE_DECODING);
 59 
 60         // (1)read in .map to parse all b-&gt;c entries
 61         FileInputStream in = new FileInputStream(
 62                                  new File(srcDir, clzName + &quot;.map&quot;));
 63         Parser p = new Parser(in, sbmap);
 64         Entry  e = null;
 65 
 66         while ((e = p.next()) != null) {
 67             sb[e.bs] = (char)e.cp;
 68             if (c2bIndex[e.cp&gt;&gt;8] == UNMAPPABLE_DECODING) {
 69                 c2bOff += 0x100;
 70                 c2bIndex[e.cp&gt;&gt;8] = 1;
 71             }



 72         }
 73 
 74         Formatter fm = new Formatter(b2cSB);
 75         fm.format(&quot;%n&quot;);
 76 
 77         // vm -server shows cc[byte + 128] access is much faster than
 78         // cc[byte&amp;0xff] so we output the upper segment first
 79         toString(sb, 0x80, 0x100, fm, &quot;+&quot;, true);
 80         toString(sb, 0x00, 0x80,  fm, &quot;;&quot;, true);
 81         fm.close();
 82 
 83         // (2)now the .nr file which includes &quot;b-&gt;c&quot; non-roundtrip entries
 84         File f = new File(srcDir, clzName + &quot;.nr&quot;);
 85         if (f.exists()) {
 86             in = new FileInputStream(f);
 87             fm = new Formatter(b2cNRSB);
 88             p = new Parser(in, sbmap);
 89             e = null;
 90 
 91             fm.format(&quot;// remove non-roundtrip entries%n&quot;);
</pre>
<hr />
<pre>
161             if (line.indexOf(&quot;$NAME_ALIASES$&quot;, i) != -1) {
162                 if (&quot;sun.nio.cs&quot;.equals(pkgName))
163                     line = line.replace(&quot;$NAME_ALIASES$&quot;,
164                                         &quot;StandardCharsets.aliases_&quot; + clzName + &quot;()&quot;);
165                 else
166                     line = line.replace(&quot;$NAME_ALIASES$&quot;,
167                                         &quot;ExtendedCharsets.aliasesFor(\&quot;&quot; + csName + &quot;\&quot;)&quot;);
168             }
169             if (line.indexOf(&quot;$NAME_HIS$&quot;, i) != -1) {
170                 line = line.replace(&quot;$NAME_HIS$&quot;, hisName);
171             }
172             if (line.indexOf(&quot;$CONTAINS$&quot;, i) != -1) {
173                 if (isASCII)
174                     line = &quot;        return ((cs.name().equals(\&quot;US-ASCII\&quot;)) || (cs instanceof &quot; + clzName + &quot;));&quot;;
175                 else
176                     line = &quot;        return (cs instanceof &quot; + clzName + &quot;);&quot;;
177             }
178             if (line.indexOf(&quot;$ASCIICOMPATIBLE$&quot;) != -1) {
179                 line = line.replace(&quot;$ASCIICOMPATIBLE$&quot;, isASCII ? &quot;true&quot; : &quot;false&quot;);
180             }



181             if (line.indexOf(&quot;$B2CTABLE$&quot;) != -1) {
182                 line = line.replace(&quot;$B2CTABLE$&quot;, b2c);
183             }
184             if (line.indexOf(&quot;$C2BLENGTH$&quot;) != -1) {
185                 line = line.replace(&quot;$C2BLENGTH$&quot;, &quot;0x&quot; + Integer.toString(c2bOff, 16));
186             }
187             if (line.indexOf(&quot;$NONROUNDTRIP_B2C$&quot;) != -1) {
188                 if (b2cNR.length() == 0)
189                     continue;
190                 line = line.replace(&quot;$NONROUNDTRIP_B2C$&quot;, b2cNR);
191             }
192 
193             if (line.indexOf(&quot;$NONROUNDTRIP_C2B$&quot;) != -1) {
194                 if (c2bNR.length() == 0)
195                     continue;
196                 line = line.replace(&quot;$NONROUNDTRIP_C2B$&quot;, c2bNR);
197             }
198             out.println(line);
199         }
200         out.close();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 29 import java.util.Arrays;
 30 import java.util.ArrayList;
 31 import java.util.Scanner;
 32 import java.util.Formatter;
 33 import java.util.regex.Pattern;
 34 import static build.tools.charsetmapping.Utils.*;
 35 
 36 public class SBCS {
 37 
 38     static Pattern sbmap = Pattern.compile(&quot;0x(\\p{XDigit}++)\\s++(?:U\\+|0x)?(\\p{XDigit}++)(?:\\s++#.*)?&quot;);
 39 
 40     public static void genClass(Charset cs,
 41                                 String srcDir, String dstDir, String template)
 42         throws Exception
 43     {
 44         String clzName = cs.clzName;
 45         String csName  = cs.csName;
 46         String hisName = cs.hisName;
 47         String pkgName = cs.pkgName;
 48         boolean isASCII = cs.isASCII;
<span class="line-added"> 49         boolean isLatin1Decodable = true;</span>
 50 
 51         StringBuilder b2cSB = new StringBuilder();
 52         StringBuilder b2cNRSB = new StringBuilder();
 53         StringBuilder c2bNRSB = new StringBuilder();
 54 
 55         char[] sb = new char[0x100];
 56         char[] c2bIndex = new char[0x100];
 57         int    c2bOff = 0;
 58         Arrays.fill(sb, UNMAPPABLE_DECODING);
 59         Arrays.fill(c2bIndex, UNMAPPABLE_DECODING);
 60 
 61         // (1)read in .map to parse all b-&gt;c entries
 62         FileInputStream in = new FileInputStream(
 63                                  new File(srcDir, clzName + &quot;.map&quot;));
 64         Parser p = new Parser(in, sbmap);
 65         Entry  e = null;
 66 
 67         while ((e = p.next()) != null) {
 68             sb[e.bs] = (char)e.cp;
 69             if (c2bIndex[e.cp&gt;&gt;8] == UNMAPPABLE_DECODING) {
 70                 c2bOff += 0x100;
 71                 c2bIndex[e.cp&gt;&gt;8] = 1;
 72             }
<span class="line-added"> 73             if (e.cp &gt; 0xFF) {</span>
<span class="line-added"> 74                 isLatin1Decodable = false;</span>
<span class="line-added"> 75             }</span>
 76         }
 77 
 78         Formatter fm = new Formatter(b2cSB);
 79         fm.format(&quot;%n&quot;);
 80 
 81         // vm -server shows cc[byte + 128] access is much faster than
 82         // cc[byte&amp;0xff] so we output the upper segment first
 83         toString(sb, 0x80, 0x100, fm, &quot;+&quot;, true);
 84         toString(sb, 0x00, 0x80,  fm, &quot;;&quot;, true);
 85         fm.close();
 86 
 87         // (2)now the .nr file which includes &quot;b-&gt;c&quot; non-roundtrip entries
 88         File f = new File(srcDir, clzName + &quot;.nr&quot;);
 89         if (f.exists()) {
 90             in = new FileInputStream(f);
 91             fm = new Formatter(b2cNRSB);
 92             p = new Parser(in, sbmap);
 93             e = null;
 94 
 95             fm.format(&quot;// remove non-roundtrip entries%n&quot;);
</pre>
<hr />
<pre>
165             if (line.indexOf(&quot;$NAME_ALIASES$&quot;, i) != -1) {
166                 if (&quot;sun.nio.cs&quot;.equals(pkgName))
167                     line = line.replace(&quot;$NAME_ALIASES$&quot;,
168                                         &quot;StandardCharsets.aliases_&quot; + clzName + &quot;()&quot;);
169                 else
170                     line = line.replace(&quot;$NAME_ALIASES$&quot;,
171                                         &quot;ExtendedCharsets.aliasesFor(\&quot;&quot; + csName + &quot;\&quot;)&quot;);
172             }
173             if (line.indexOf(&quot;$NAME_HIS$&quot;, i) != -1) {
174                 line = line.replace(&quot;$NAME_HIS$&quot;, hisName);
175             }
176             if (line.indexOf(&quot;$CONTAINS$&quot;, i) != -1) {
177                 if (isASCII)
178                     line = &quot;        return ((cs.name().equals(\&quot;US-ASCII\&quot;)) || (cs instanceof &quot; + clzName + &quot;));&quot;;
179                 else
180                     line = &quot;        return (cs instanceof &quot; + clzName + &quot;);&quot;;
181             }
182             if (line.indexOf(&quot;$ASCIICOMPATIBLE$&quot;) != -1) {
183                 line = line.replace(&quot;$ASCIICOMPATIBLE$&quot;, isASCII ? &quot;true&quot; : &quot;false&quot;);
184             }
<span class="line-added">185             if (line.indexOf(&quot;$LATIN1DECODABLE$&quot;) != -1) {</span>
<span class="line-added">186                 line = line.replace(&quot;$LATIN1DECODABLE$&quot;, isLatin1Decodable ? &quot;true&quot; : &quot;false&quot;);</span>
<span class="line-added">187             }</span>
188             if (line.indexOf(&quot;$B2CTABLE$&quot;) != -1) {
189                 line = line.replace(&quot;$B2CTABLE$&quot;, b2c);
190             }
191             if (line.indexOf(&quot;$C2BLENGTH$&quot;) != -1) {
192                 line = line.replace(&quot;$C2BLENGTH$&quot;, &quot;0x&quot; + Integer.toString(c2bOff, 16));
193             }
194             if (line.indexOf(&quot;$NONROUNDTRIP_B2C$&quot;) != -1) {
195                 if (b2cNR.length() == 0)
196                     continue;
197                 line = line.replace(&quot;$NONROUNDTRIP_B2C$&quot;, b2cNR);
198             }
199 
200             if (line.indexOf(&quot;$NONROUNDTRIP_C2B$&quot;) != -1) {
201                 if (c2bNR.length() == 0)
202                     continue;
203                 line = line.replace(&quot;$NONROUNDTRIP_C2B$&quot;, c2bNR);
204             }
205             out.println(line);
206         }
207         out.close();
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../idea/template/vcs.xml.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../classlist/HelloClasslist.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
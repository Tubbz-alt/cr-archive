<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old make/jdk/src/classes/build/tools/jdwpgen/Node.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package build.tools.jdwpgen;
 27 
 28 
 29 import java.util.*;
 30 import java.io.*;
 31 
 32 abstract class Node {
 33 
 34     String kind;
 35     List&lt;Node&gt; components;
 36     int lineno;
 37     List&lt;String&gt; commentList = new ArrayList&lt;&gt;();
 38     Node parent = null;
 39     Context context = null;
 40 
 41     static final int maxStructIndent = 5;
 42     static int structIndent = 0; // horrible hack
 43 
 44     abstract void document(PrintWriter writer);
 45 
 46     void set(String kind, List&lt;Node&gt; components, int lineno) {
 47         this.kind = kind;
 48         this.components = components;
 49         this.lineno = lineno;
 50     }
 51 
 52     void parentAndExtractComments() {
 53         for (Iterator&lt;Node&gt; it = components.iterator(); it.hasNext();) {
 54             Node node = it.next();
 55             if (node instanceof CommentNode) {
 56                 it.remove();
 57                 commentList.add(((CommentNode)node).text());
 58             } else {
 59                 node.parent = this;
 60                 node.parentAndExtractComments();
 61             }
 62         }
 63     }
 64 
 65     void prune() {
 66         for (Node node : components) {
 67             node.prune();
 68         }
 69     }
 70 
 71     void constrain(Context ctx) {
 72         context = ctx;
 73         for (Node node : components) {
 74             constrainComponent(ctx, node);
 75         }
 76     }
 77 
 78     void constrainComponent(Context ctx, Node node) {
 79         node.constrain(ctx);
 80     }
 81 
 82     void indent(PrintWriter writer, int depth) {
 83         for (int i = 0; i &lt; depth; i++) {
 84             writer.print(&quot;    &quot;);
 85         }
 86     }
 87 
 88     void documentIndex(PrintWriter writer) {
 89     }
 90 
 91     void docRowStart(PrintWriter writer) {
 92         writer.println(&quot;&lt;tr&gt;&quot;);
 93         if (structIndent &gt; 0) {
 94             writer.println(&quot;&lt;td colspan=&quot; + structIndent + &quot;&gt;&quot;);
 95         }
 96     }
 97 
 98     String comment() {
 99         StringBuffer comment = new StringBuffer();
100         for (String st : commentList) {
101             comment.append(st);
102         }
103         return comment.toString();
104     }
105 
106     void genJavaComment(PrintWriter writer, int depth) {
107         if (commentList.size() &gt; 0) {
108             indent(writer, depth);
109             writer.println(&quot;/**&quot;);
110             for (String comment : commentList) {
111                 indent(writer, depth);
112                 writer.println(&quot; * &quot; + comment);
113             }
114             indent(writer, depth);
115             writer.println(&quot; */&quot;);
116         }
117     }
118 
119     String javaType() {
120         return &quot;-- WRONG ---&quot;;
121     }
122 
123     void genJava(PrintWriter writer, int depth) {
124         for (Node node : components) {
125             node.genJava(writer, depth);
126         }
127     }
128 
129     void genCInclude(PrintWriter writer) {
130         for (Node node : components) {
131             node.genCInclude(writer);
132         }
133     }
134 
135     String debugValue(String label) {
136         return label;
137     }
138 
139     void genJavaDebugWrite(PrintWriter writer, int depth,
140                            String writeLabel) {
141         genJavaDebugWrite(writer, depth, writeLabel, debugValue(writeLabel));
142     }
143 
144     void genJavaDebugWrite(PrintWriter writer, int depth,
145                            String writeLabel, String displayValue) {
146         if (!Main.genDebug) {
147             return;
148         }
149         indent(writer, depth);
150         writer.println(
151           &quot;if ((ps.vm.traceFlags &amp; VirtualMachineImpl.TRACE_SENDS) != 0) {&quot;);
152         indent(writer, depth+1);
153         writer.print(&quot;ps.vm.printTrace(\&quot;Sending: &quot;);
154         indent(writer, depth);  // this is inside the quotes
155         writer.print(writeLabel + &quot;(&quot; + javaType() + &quot;): \&quot; + &quot;);
156         writer.println(displayValue + &quot;);&quot;);
157         indent(writer, depth);
158         writer.println(&quot;}&quot;);
159     }
160 
161     public void genJavaRead(PrintWriter writer, int depth,
162                             String readLabel) {
163         error(&quot;Internal - Should not call Node.genJavaRead()&quot;);
164     }
165 
166     void genJavaDebugRead(PrintWriter writer, int depth,
167                           String readLabel, String displayValue) {
168         if (!Main.genDebug) {
169             return;
170         }
171         indent(writer, depth);
172         writer.println(
173           &quot;if (vm.traceReceives) {&quot;);
174         indent(writer, depth+1);
175         writer.print(&quot;vm.printReceiveTrace(&quot; + depth + &quot;, \&quot;&quot;);
176         writer.print(readLabel + &quot;(&quot; + javaType() + &quot;): \&quot; + &quot;);
177         writer.println(displayValue + &quot;);&quot;);
178         indent(writer, depth);
179         writer.println(&quot;}&quot;);
180     }
181 
182     void genJavaPreDef(PrintWriter writer, int depth) {
183         for (Node node : components) {
184             node.genJavaPreDef(writer, depth);
185         }
186     }
187 
188     void error(String errmsg) {
189         System.err.println();
190         System.err.println(Main.specSource + &quot;:&quot; + lineno + &quot;: &quot; +
191                            kind + &quot; - &quot; + errmsg);
192         System.err.println();
193         throw new RuntimeException(&quot;Error: &quot; + errmsg);
194     }
195 }
    </pre>
  </body>
</html>
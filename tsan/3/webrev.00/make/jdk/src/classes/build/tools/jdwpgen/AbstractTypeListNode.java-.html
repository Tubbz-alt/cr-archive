<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old make/jdk/src/classes/build/tools/jdwpgen/AbstractTypeListNode.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package build.tools.jdwpgen;
 27 
 28 import java.util.*;
 29 import java.io.*;
 30 
 31 abstract class AbstractTypeListNode extends AbstractNamedNode {
 32 
 33     void constrainComponent(Context ctx, Node node) {
 34         if (node instanceof TypeNode) {
 35             node.constrain(ctx);
 36         } else {
 37             error(&quot;Expected type descriptor item, got: &quot; + node);
 38         }
 39     }
 40 
 41     void document(PrintWriter writer) {
 42         writer.println(&quot;&lt;dt&gt;&quot; + name() + &quot; Data&quot;);
 43         if (components.isEmpty()) {
 44             writer.println(&quot;&lt;dd&gt;(None)&quot;);
 45         } else {
 46             writer.println(&quot;&lt;dd&gt;&lt;table&gt;&lt;tr&gt;&quot;);
 47             for (int i = maxStructIndent; i &gt; 0; --i) {
 48                 writer.print(&quot;&lt;th style=\&quot;width: 4%\&quot;&gt;&quot;);
 49             }
 50             writer.println(&quot;&lt;th style=\&quot;width: 15%\&quot;&gt;&lt;th style=\&quot;width: 65%\&quot;&gt;&quot;);
 51             writer.println(&quot;&quot;);
 52             for (Node node : components) {
 53                 node.document(writer);
 54             }
 55             writer.println(&quot;&lt;/table&gt;&quot;);
 56         }
 57     }
 58 
 59     void genJavaClassBodyComponents(PrintWriter writer, int depth) {
 60         for (Node node : components) {
 61             TypeNode tn = (TypeNode)node;
 62 
 63             tn.genJavaDeclaration(writer, depth);
 64         }
 65     }
 66 
 67     void genJavaReads(PrintWriter writer, int depth) {
 68         for (Node node : components) {
 69             TypeNode tn = (TypeNode)node;
 70             tn.genJavaRead(writer, depth, tn.name());
 71         }
 72     }
 73 
 74     void genJavaReadingClassBody(PrintWriter writer, int depth,
 75                                  String className) {
 76         genJavaClassBodyComponents(writer, depth);
 77         writer.println();
 78         indent(writer, depth);
 79         if (!context.inEvent()) {
 80             writer.print(&quot;private &quot;);
 81         }
 82         writer.println(className +
 83                        &quot;(VirtualMachineImpl vm, PacketStream ps) {&quot;);
 84         genJavaReads(writer, depth+1);
 85         indent(writer, depth);
 86         writer.println(&quot;}&quot;);
 87     }
 88 
 89     String javaParams() {
 90         StringBuffer sb = new StringBuffer();
 91         for (Iterator&lt;Node&gt; it = components.iterator(); it.hasNext();) {
 92             TypeNode tn = (TypeNode)it.next();
 93             sb.append(tn.javaParam());
 94             if (it.hasNext()) {
 95                 sb.append(&quot;, &quot;);
 96             }
 97         }
 98         return sb.toString();
 99     }
100 
101     void genJavaWrites(PrintWriter writer, int depth) {
102         for (Node node : components) {
103             TypeNode tn = (TypeNode)node;
104             tn.genJavaWrite(writer, depth, tn.name());
105         }
106     }
107 
108     void genJavaWritingClassBody(PrintWriter writer, int depth,
109                                  String className) {
110         genJavaClassBodyComponents(writer, depth);
111         writer.println();
112         indent(writer, depth);
113         writer.println(className + &quot;(&quot; + javaParams() + &quot;) {&quot;);
114         for (Node node : components) {
115             TypeNode tn = (TypeNode)node;
116             indent(writer, depth+1);
117             writer.println(&quot;this.&quot; + tn.name() + &quot; = &quot; + tn.name() + &quot;;&quot;);
118         }
119         indent(writer, depth);
120         writer.println(&quot;}&quot;);
121     }
122 }
    </pre>
  </body>
</html>
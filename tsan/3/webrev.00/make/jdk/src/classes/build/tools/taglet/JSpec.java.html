<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New make/jdk/src/classes/build/tools/taglet/JSpec.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package build.tools.taglet;
 27 
 28 import java.util.EnumSet;
 29 import java.util.List;
 30 import java.util.Set;
 31 import java.util.regex.Matcher;
 32 import java.util.regex.Pattern;
 33 import javax.lang.model.element.Element;
 34 
 35 import com.sun.source.doctree.DocTree;
 36 import com.sun.source.doctree.LiteralTree;
 37 import com.sun.source.doctree.UnknownBlockTagTree;
 38 import com.sun.source.doctree.UnknownInlineTagTree;
 39 import com.sun.source.util.SimpleDocTreeVisitor;
 40 import jdk.javadoc.doclet.Taglet;
 41 
 42 import static com.sun.source.doctree.DocTree.Kind.*;
 43 
 44 /**
 45  * A base class for block tags to insert a link to an external copy of JLS or JVMS.
 46  * The tags can be used as follows:
 47  *
 48  * &lt;pre&gt;
 49  * &amp;commat;jls section-number description
 50  * &lt;/pre&gt;
 51  *
 52  * For example:
 53  *
 54  * &lt;pre&gt;
 55  * &amp;commat;jls 3.4 Line Terminators
 56  * &lt;/pre&gt;
 57  *
 58  * will produce the following HTML for a docs build configured for Java SE 12.
 59  *
 60  * &lt;pre&gt;{@code
 61  * &lt;dt&gt;See &lt;i&gt;Java Language Specification&lt;/i&gt;:
 62  * &lt;dd&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se12/html/jls-3.html#jls-3.4&quot;&gt;3.4 Line terminators&lt;/a&gt;
 63  * }&lt;/pre&gt;
 64  *
 65  * The version of the spec must be set in the jspec.version system property.
 66  */
 67 public class JSpec implements Taglet  {
 68     static final String SPEC_VERSION;
 69 
 70     static {
 71         SPEC_VERSION = System.getProperty(&quot;jspec.version&quot;);
 72         if (SPEC_VERSION == null) {
 73             throw new RuntimeException(&quot;jspec.version property not set&quot;);
 74         }
 75     }
 76 
 77     public static class JLS extends JSpec {
 78         public JLS() {
 79             super(&quot;jls&quot;,
 80                 &quot;Java Language Specification&quot;,
 81                 &quot;https://docs.oracle.com/javase/specs/jls/se&quot; + SPEC_VERSION + &quot;/html&quot;,
 82                 &quot;jls&quot;);
 83         }
 84     }
 85 
 86     public static class JVMS extends JSpec {
 87         public JVMS() {
 88             super(&quot;jvms&quot;,
 89                 &quot;Java Virtual Machine Specification&quot;,
 90                 &quot;https://docs.oracle.com/javase/specs/jvms/se&quot; + SPEC_VERSION + &quot;/html&quot;,
 91                 &quot;jvms&quot;);
 92         }
 93     }
 94 
 95     private String tagName;
 96     private String specTitle;
 97     private String baseURL;
 98     private String idPrefix;
 99 
100     JSpec(String tagName, String specTitle, String baseURL, String idPrefix) {
101         this.tagName = tagName;
102         this.specTitle = specTitle;
103         this.baseURL = baseURL;
104         this.idPrefix = idPrefix;
105     }
106 
107     private static final Pattern TAG_PATTERN = Pattern.compile(&quot;(?s)(.+ )?(?&lt;chapter&gt;[1-9][0-9]*)(?&lt;section&gt;[0-9.]*)( .*)?$&quot;);
108 
109     /**
110      * Returns the set of locations in which the tag may be used.
111      */
112     @Override
113     public Set&lt;Location&gt; getAllowedLocations() {
114         return EnumSet.allOf(jdk.javadoc.doclet.Taglet.Location.class);
115     }
116 
117     //@Override // uncomment when JDK 15 is the boot JDK
118     public boolean isBlockTag() {
119         return true;
120     }
121 
122     @Override
123     public boolean isInlineTag() {
124         return true;
125     }
126 
127     @Override
128     public String getName() {
129         return tagName;
130     }
131 
132     @Override
133     public String toString(List&lt;? extends DocTree&gt; tags, Element elem) {
134 
135         if (tags.isEmpty())
136             return &quot;&quot;;
137 
138         StringBuilder sb = new StringBuilder();
139         boolean in_dd = false;
140 
141         for (DocTree tag : tags) {
142             if (sb.length() == 0 &amp;&amp; tag.getKind() == DocTree.Kind.UNKNOWN_BLOCK_TAG) {
143                 sb.append(&quot;&lt;dt&gt;See &lt;i&gt;&quot;).append(specTitle).append(&quot;&lt;/i&gt;:&lt;/dt&gt;\n&quot;)
144                         .append(&quot;&lt;dd&gt;\n&quot;);
145                 in_dd = true;
146             }
147 
148             List&lt;? extends DocTree&gt; contents;
149             switch (tag.getKind()) {
150                 case UNKNOWN_BLOCK_TAG:
151                     contents = ((UnknownBlockTagTree) tag).getContent();
152                     break;
153                 case UNKNOWN_INLINE_TAG:
154                     contents = ((UnknownInlineTagTree) tag).getContent();
155                     break;
156                 default:
157                     continue;
158             }
159 
160             String tagText = contents.toString().trim();
161             Matcher m = TAG_PATTERN.matcher(tagText);
162             if (m.find()) {
163                 String chapter = m.group(&quot;chapter&quot;);
164                 String section = m.group(&quot;section&quot;);
165 
166                 String url = String.format(&quot;%1$s/%2$s-%3$s.html#jls-%3$s%4$s&quot;,
167                         baseURL, idPrefix, chapter, section);
168 
169                 sb.append(&quot;&lt;a href=\&quot;&quot;)
170                         .append(url)
171                         .append(&quot;\&quot;&gt;&quot;)
172                         .append(expand(contents))
173                         .append(&quot;&lt;/a&gt;&quot;);
174 
175                 if (tag.getKind() == DocTree.Kind.UNKNOWN_BLOCK_TAG) {
176                     sb.append(&quot;&lt;br&gt;&quot;);
177                 }
178             }
179         }
180 
181         if (in_dd) {
182             sb.append(&quot;&lt;/dd&gt;&quot;);
183         }
184 
185         return sb.toString();
186     }
187 
188 
189     private String expand(List&lt;? extends DocTree&gt; trees) {
190         return (new SimpleDocTreeVisitor&lt;StringBuilder, StringBuilder&gt;() {
191             public StringBuilder defaultAction(DocTree tree, StringBuilder sb) {
192                 return sb.append(tree.toString());
193             }
194 
195             public StringBuilder visitLiteral(LiteralTree tree, StringBuilder sb) {
196                 if (tree.getKind() == CODE) {
197                     sb.append(&quot;&lt;code&gt;&quot;);
198                 }
199                 sb.append(escape(tree.getBody().toString()));
200                 if (tree.getKind() == CODE) {
201                     sb.append(&quot;&lt;/code&gt;&quot;);
202                 }
203                 return sb;
204             }
205 
206             private String escape(String s) {
207                 return s.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)
208                         .replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
209                         .replace(&quot;&gt;&quot;, &quot;&amp;gt&quot;);
210             }
211         }).visit(trees, new StringBuilder()).toString();
212     }
213 }
    </pre>
  </body>
</html>
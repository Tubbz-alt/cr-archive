<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old make/jdk/src/classes/build/tools/charsetmapping/SBCS.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2008, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package build.tools.charsetmapping;
 27 
 28 import java.io.*;
 29 import java.util.Arrays;
 30 import java.util.ArrayList;
 31 import java.util.Scanner;
 32 import java.util.Formatter;
 33 import java.util.regex.Pattern;
 34 import static build.tools.charsetmapping.Utils.*;
 35 
 36 public class SBCS {
 37 
 38     static Pattern sbmap = Pattern.compile(&quot;0x(\\p{XDigit}++)\\s++(?:U\\+|0x)?(\\p{XDigit}++)(?:\\s++#.*)?&quot;);
 39 
 40     public static void genClass(Charset cs,
 41                                 String srcDir, String dstDir, String template)
 42         throws Exception
 43     {
 44         String clzName = cs.clzName;
 45         String csName  = cs.csName;
 46         String hisName = cs.hisName;
 47         String pkgName = cs.pkgName;
 48         boolean isASCII = cs.isASCII;
 49 
 50         StringBuilder b2cSB = new StringBuilder();
 51         StringBuilder b2cNRSB = new StringBuilder();
 52         StringBuilder c2bNRSB = new StringBuilder();
 53 
 54         char[] sb = new char[0x100];
 55         char[] c2bIndex = new char[0x100];
 56         int    c2bOff = 0;
 57         Arrays.fill(sb, UNMAPPABLE_DECODING);
 58         Arrays.fill(c2bIndex, UNMAPPABLE_DECODING);
 59 
 60         // (1)read in .map to parse all b-&gt;c entries
 61         FileInputStream in = new FileInputStream(
 62                                  new File(srcDir, clzName + &quot;.map&quot;));
 63         Parser p = new Parser(in, sbmap);
 64         Entry  e = null;
 65 
 66         while ((e = p.next()) != null) {
 67             sb[e.bs] = (char)e.cp;
 68             if (c2bIndex[e.cp&gt;&gt;8] == UNMAPPABLE_DECODING) {
 69                 c2bOff += 0x100;
 70                 c2bIndex[e.cp&gt;&gt;8] = 1;
 71             }
 72         }
 73 
 74         Formatter fm = new Formatter(b2cSB);
 75         fm.format(&quot;%n&quot;);
 76 
 77         // vm -server shows cc[byte + 128] access is much faster than
 78         // cc[byte&amp;0xff] so we output the upper segment first
 79         toString(sb, 0x80, 0x100, fm, &quot;+&quot;, true);
 80         toString(sb, 0x00, 0x80,  fm, &quot;;&quot;, true);
 81         fm.close();
 82 
 83         // (2)now the .nr file which includes &quot;b-&gt;c&quot; non-roundtrip entries
 84         File f = new File(srcDir, clzName + &quot;.nr&quot;);
 85         if (f.exists()) {
 86             in = new FileInputStream(f);
 87             fm = new Formatter(b2cNRSB);
 88             p = new Parser(in, sbmap);
 89             e = null;
 90 
 91             fm.format(&quot;// remove non-roundtrip entries%n&quot;);
 92             fm.format(&quot;        b2cMap = b2cTable.toCharArray();%n&quot;);
 93             while ((e = p.next()) != null) {
 94                 fm.format(&quot;        b2cMap[%d] = UNMAPPABLE_DECODING;%n&quot;,
 95                           (e.bs&gt;=0x80)?(e.bs-0x80):(e.bs+0x80));
 96             }
 97             fm.close();
 98         }
 99 
100         // (3)finally the .c2b file which includes c-&gt;b non-roundtrip entries
101         f = new File(srcDir, clzName + &quot;.c2b&quot;);
102         if (f.exists()) {
103             in = new FileInputStream(f);
104             fm = new Formatter(c2bNRSB);
105             p = new Parser(in, sbmap);
106             e = null;
107             ArrayList&lt;Entry&gt; es = new ArrayList&lt;Entry&gt;();
108             while ((e = p.next()) != null) {
109                 if (c2bIndex[e.cp&gt;&gt;8] == UNMAPPABLE_DECODING) {
110                     c2bOff += 0x100;
111                     c2bIndex[e.cp&gt;&gt;8] = 1;
112                 }
113                 es.add(e);
114             }
115             fm.format(&quot;// non-roundtrip c2b only entries%n&quot;);
116             if (es.size() &lt; 100) {
117                 fm.format(&quot;        c2bNR = new char[%d];%n&quot;, es.size() * 2);
118                 int i = 0;
119                 for (Entry entry: es) {
120                     fm.format(&quot;        c2bNR[%d] = 0x%x; c2bNR[%d] = 0x%x;%n&quot;,
121                               i++, entry.bs, i++, entry.cp);
122                 }
123             } else {
124                 char[] cc = new char[es.size() * 2];
125                 int i = 0;
126                 for (Entry entry: es) {
127                     cc[i++] = (char)entry.bs;
128                     cc[i++] = (char)entry.cp;
129                 }
130                 fm.format(&quot;        c2bNR = (%n&quot;);
131                 toString(cc, 0, i,  fm, &quot;).toCharArray();&quot;, false);
132             }
133             fm.close();
134         }
135 
136         // (4)it&#39;s time to generate the source file
137         String b2c = b2cSB.toString();
138         String b2cNR = b2cNRSB.toString();
139         String c2bNR = c2bNRSB.toString();
140 
141         Scanner s = new Scanner(new File(srcDir, template));
142         PrintStream out = new PrintStream(new FileOutputStream(
143                               new File(dstDir, clzName + &quot;.java&quot;)));
144 
145         while (s.hasNextLine()) {
146             String line = s.nextLine();
147             int i = line.indexOf(&quot;$&quot;);
148             if (i == -1) {
149                 out.println(line);
150                 continue;
151             }
152             if (line.indexOf(&quot;$PACKAGE$&quot;, i) != -1) {
153                 line = line.replace(&quot;$PACKAGE$&quot;, pkgName);
154             }
155             if (line.indexOf(&quot;$NAME_CLZ$&quot;, i) != -1) {
156                 line = line.replace(&quot;$NAME_CLZ$&quot;, clzName);
157             }
158             if (line.indexOf(&quot;$NAME_CS$&quot;, i) != -1) {
159                 line = line.replace(&quot;$NAME_CS$&quot;, csName);
160             }
161             if (line.indexOf(&quot;$NAME_ALIASES$&quot;, i) != -1) {
162                 if (&quot;sun.nio.cs&quot;.equals(pkgName))
163                     line = line.replace(&quot;$NAME_ALIASES$&quot;,
164                                         &quot;StandardCharsets.aliases_&quot; + clzName + &quot;()&quot;);
165                 else
166                     line = line.replace(&quot;$NAME_ALIASES$&quot;,
167                                         &quot;ExtendedCharsets.aliasesFor(\&quot;&quot; + csName + &quot;\&quot;)&quot;);
168             }
169             if (line.indexOf(&quot;$NAME_HIS$&quot;, i) != -1) {
170                 line = line.replace(&quot;$NAME_HIS$&quot;, hisName);
171             }
172             if (line.indexOf(&quot;$CONTAINS$&quot;, i) != -1) {
173                 if (isASCII)
174                     line = &quot;        return ((cs.name().equals(\&quot;US-ASCII\&quot;)) || (cs instanceof &quot; + clzName + &quot;));&quot;;
175                 else
176                     line = &quot;        return (cs instanceof &quot; + clzName + &quot;);&quot;;
177             }
178             if (line.indexOf(&quot;$ASCIICOMPATIBLE$&quot;) != -1) {
179                 line = line.replace(&quot;$ASCIICOMPATIBLE$&quot;, isASCII ? &quot;true&quot; : &quot;false&quot;);
180             }
181             if (line.indexOf(&quot;$B2CTABLE$&quot;) != -1) {
182                 line = line.replace(&quot;$B2CTABLE$&quot;, b2c);
183             }
184             if (line.indexOf(&quot;$C2BLENGTH$&quot;) != -1) {
185                 line = line.replace(&quot;$C2BLENGTH$&quot;, &quot;0x&quot; + Integer.toString(c2bOff, 16));
186             }
187             if (line.indexOf(&quot;$NONROUNDTRIP_B2C$&quot;) != -1) {
188                 if (b2cNR.length() == 0)
189                     continue;
190                 line = line.replace(&quot;$NONROUNDTRIP_B2C$&quot;, b2cNR);
191             }
192 
193             if (line.indexOf(&quot;$NONROUNDTRIP_C2B$&quot;) != -1) {
194                 if (c2bNR.length() == 0)
195                     continue;
196                 line = line.replace(&quot;$NONROUNDTRIP_C2B$&quot;, c2bNR);
197             }
198             out.println(line);
199         }
200         out.close();
201     }
202 
203     private static void toString(char[] sb, int off, int end,
204                                  Formatter out, String closure, boolean comment)
205     {
206         while (off &lt; end) {
207             out.format(&quot;        \&quot;&quot;);
208             for (int j = 0; j &lt; 8; j++) {
209                 if (off == end)
210                     break;
211                 char c = sb[off++];
212                 switch (c) {
213                 case &#39;\b&#39;:
214                     out.format(&quot;\\b&quot;); break;
215                 case &#39;\t&#39;:
216                     out.format(&quot;\\t&quot;); break;
217                 case &#39;\n&#39;:
218                     out.format(&quot;\\n&quot;); break;
219                 case &#39;\f&#39;:
220                     out.format(&quot;\\f&quot;); break;
221                 case &#39;\r&#39;:
222                     out.format(&quot;\\r&quot;); break;
223                 case &#39;\&quot;&#39;:
224                     out.format(&quot;\\\&quot;&quot;); break;
225                 case &#39;\&#39;&#39;:
226                     out.format(&quot;\\&#39;&quot;); break;
227                 case &#39;\\&#39;:
228                     out.format(&quot;\\\\&quot;); break;
229                 default:
230                     out.format(&quot;\\u%04X&quot;, c &amp; 0xffff);
231                 }
232             }
233             if (comment) {
234                 if (off == end)
235                     out.format(&quot;\&quot; %s      // 0x%02x - 0x%02x%n&quot;,
236                                closure, off-8, off-1);
237                 else
238                     out.format(&quot;\&quot; +      // 0x%02x - 0x%02x%n&quot;,
239                                off-8, off-1);
240             } else {
241                 if (off == end)
242                     out.format(&quot;\&quot;%s%n&quot;, closure);
243                 else
244                     out.format(&quot;\&quot; +%n&quot;);
245             }
246         }
247     }
248 }
    </pre>
  </body>
</html>
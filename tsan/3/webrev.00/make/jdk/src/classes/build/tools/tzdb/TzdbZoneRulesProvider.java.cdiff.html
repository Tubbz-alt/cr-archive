<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff make/jdk/src/classes/build/tools/tzdb/TzdbZoneRulesProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="TzdbZoneRulesCompiler.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../langtools/tools/propertiesparser/resources/templates.properties.cdiff.html" target="_top">next &gt;</a></center>    <h2>make/jdk/src/classes/build/tools/tzdb/TzdbZoneRulesProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 29,28 ***</span>
  import java.io.IOException;
  import java.nio.charset.StandardCharsets;
  import java.nio.file.Files;
  import java.nio.file.Path;
  import java.nio.file.Paths;
<span class="line-modified">! import java.util.ArrayList;</span>
<span class="line-removed">- import java.util.Collections;</span>
<span class="line-removed">- import java.util.List;</span>
<span class="line-removed">- import java.util.Map;</span>
  import java.util.Map.Entry;
<span class="line-removed">- import java.util.NavigableMap;</span>
<span class="line-removed">- import java.util.Objects;</span>
<span class="line-removed">- import java.util.Set;</span>
<span class="line-removed">- import java.util.TreeMap;</span>
<span class="line-removed">- import java.util.TreeSet;</span>
  import java.util.concurrent.ConcurrentSkipListMap;
  import java.time.*;
  import java.time.Year;
  import java.time.chrono.IsoChronology;
  import java.time.temporal.TemporalAdjusters;
<span class="line-modified">! import java.time.zone.ZoneOffsetTransition;</span>
<span class="line-removed">- import java.time.zone.ZoneOffsetTransitionRule;</span>
<span class="line-removed">- import java.time.zone.ZoneOffsetTransitionRule.TimeDefinition;</span>
  import java.time.zone.ZoneRulesException;
  
  /**
   * Compile and build time-zone rules from IANA timezone data
   *
<span class="line-new-header">--- 29,18 ---</span>
  import java.io.IOException;
  import java.nio.charset.StandardCharsets;
  import java.nio.file.Files;
  import java.nio.file.Path;
  import java.nio.file.Paths;
<span class="line-modified">! import java.util.*;</span>
  import java.util.Map.Entry;
  import java.util.concurrent.ConcurrentSkipListMap;
  import java.time.*;
  import java.time.Year;
  import java.time.chrono.IsoChronology;
  import java.time.temporal.TemporalAdjusters;
<span class="line-modified">! import build.tools.tzdb.ZoneOffsetTransitionRule.TimeDefinition;</span>
  import java.time.zone.ZoneRulesException;
  
  /**
   * Compile and build time-zone rules from IANA timezone data
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,12 ***</span>
          /** The time of the cutover, in second of day */
          int secsOfDay = 0;
  
          /** Whether this is midnight end of day. */
          boolean endOfDay;
<span class="line-removed">-         /** The time of the cutover. */</span>
  
          TimeDefinition timeDefinition = TimeDefinition.WALL;
  
          void adjustToForwards(int year) {
              if (adjustForwards == false &amp;&amp; dayOfMonth &gt; 0) {
                  // weekDay&lt;=monthDay case, don&#39;t have it in tzdb data for now
<span class="line-new-header">--- 260,12 ---</span>
          /** The time of the cutover, in second of day */
          int secsOfDay = 0;
  
          /** Whether this is midnight end of day. */
          boolean endOfDay;
  
<span class="line-added">+         /** The time definition of the cutover. */</span>
          TimeDefinition timeDefinition = TimeDefinition.WALL;
  
          void adjustToForwards(int year) {
              if (adjustForwards == false &amp;&amp; dayOfMonth &gt; 0) {
                  // weekDay&lt;=monthDay case, don&#39;t have it in tzdb data for now
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,10 ***</span>
<span class="line-new-header">--- 331,24 ---</span>
                      secsOfDay = parseSecs(timeStr);
                      if (secsOfDay == 86400) {
                          // time must be midnight when end of day flag is true
                          endOfDay = true;
                          secsOfDay = 0;
<span class="line-added">+                     } else if (secsOfDay &lt; 0 || secsOfDay &gt; 86400) {</span>
<span class="line-added">+                         // beyond 0:00-24:00 range. Adjust the cutover date.</span>
<span class="line-added">+                         int beyondDays = secsOfDay / 86400;</span>
<span class="line-added">+                         secsOfDay %= 86400;</span>
<span class="line-added">+                         if (secsOfDay &lt; 0) {</span>
<span class="line-added">+                             secsOfDay = 86400 + secsOfDay;</span>
<span class="line-added">+                             beyondDays -= 1;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         LocalDate date = LocalDate.of(2004, month, dayOfMonth).plusDays(beyondDays);  // leap-year</span>
<span class="line-added">+                         month = date.getMonth();</span>
<span class="line-added">+                         dayOfMonth = date.getDayOfMonth();</span>
<span class="line-added">+                         if (dayOfWeek != null) {</span>
<span class="line-added">+                             dayOfWeek = dayOfWeek.plus(beyondDays);</span>
<span class="line-added">+                         }</span>
                      }
                      timeDefinition = parseTimeDefinition(timeStr.charAt(timeStr.length() - 1));
                  }
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 495,13 ***</span>
          /**
           * Converts this to a transition rule.
           *
           * @param standardOffset  the active standard offset, not null
           * @param savingsBeforeSecs  the active savings before the transition in seconds
           * @return the transition, not null
          */
<span class="line-modified">!         ZoneOffsetTransitionRule toTransitionRule(ZoneOffset stdOffset, int savingsBefore) {</span>
              // rule shared by different zones, so don&#39;t change it
              Month month = this.month;
              int dayOfMonth = this.dayOfMonth;
              DayOfWeek dayOfWeek = this.dayOfWeek;
              boolean endOfDay = this.endOfDay;
<span class="line-new-header">--- 499,15 ---</span>
          /**
           * Converts this to a transition rule.
           *
           * @param standardOffset  the active standard offset, not null
           * @param savingsBeforeSecs  the active savings before the transition in seconds
<span class="line-added">+          * @param negativeSavings minimum savings in the rule, usually zero, but negative if negative DST is</span>
<span class="line-added">+          *                   in effect.</span>
           * @return the transition, not null
          */
<span class="line-modified">!         ZoneOffsetTransitionRule toTransitionRule(ZoneOffset stdOffset, int savingsBefore, int negativeSavings) {</span>
              // rule shared by different zones, so don&#39;t change it
              Month month = this.month;
              int dayOfMonth = this.dayOfMonth;
              DayOfWeek dayOfWeek = this.dayOfWeek;
              boolean endOfDay = this.endOfDay;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 520,18 ***</span>
                  if (dayOfWeek != null) {
                      dayOfWeek = dayOfWeek.plus(1);
                  }
                  endOfDay = false;
              }
              // build rule
              return ZoneOffsetTransitionRule.of(
                      //month, dayOfMonth, dayOfWeek, time, endOfDay, timeDefinition,
                      month, dayOfMonth, dayOfWeek,
                      LocalTime.ofSecondOfDay(secsOfDay), endOfDay, timeDefinition,
                      stdOffset,
                      ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savingsBefore),
<span class="line-modified">!                     ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savingsAmount));</span>
          }
  
          RuleLine parse(String[] tokens) {
              startYear = parseYear(tokens[2], 0);
              endYear = parseYear(tokens[3], startYear);
<span class="line-new-header">--- 526,19 ---</span>
                  if (dayOfWeek != null) {
                      dayOfWeek = dayOfWeek.plus(1);
                  }
                  endOfDay = false;
              }
<span class="line-added">+ </span>
              // build rule
              return ZoneOffsetTransitionRule.of(
                      //month, dayOfMonth, dayOfWeek, time, endOfDay, timeDefinition,
                      month, dayOfMonth, dayOfWeek,
                      LocalTime.ofSecondOfDay(secsOfDay), endOfDay, timeDefinition,
                      stdOffset,
                      ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savingsBefore),
<span class="line-modified">!                     ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savingsAmount - negativeSavings));</span>
          }
  
          RuleLine parse(String[] tokens) {
              startYear = parseYear(tokens[2], 0);
              endYear = parseYear(tokens[3], startYear);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 641,16 ***</span>
              this.rule = rule;
              this.ldt = rule.toDateTime(year);
              this.ldtSecs = ldt.toEpochSecond(ZoneOffset.UTC);
          }
  
<span class="line-modified">!         ZoneOffsetTransition toTransition(ZoneOffset standardOffset, int savingsBeforeSecs) {</span>
              // copy of code in ZoneOffsetTransitionRule to avoid infinite loop
              ZoneOffset wallOffset = ZoneOffset.ofTotalSeconds(
                  standardOffset.getTotalSeconds() + savingsBeforeSecs);
              ZoneOffset offsetAfter = ZoneOffset.ofTotalSeconds(
<span class="line-modified">!                 standardOffset.getTotalSeconds() + rule.savingsAmount);</span>
              LocalDateTime dt = rule.timeDefinition
                                     .createDateTime(ldt, standardOffset, wallOffset);
              return ZoneOffsetTransition.of(dt, wallOffset, offsetAfter);
          }
  
<span class="line-new-header">--- 648,16 ---</span>
              this.rule = rule;
              this.ldt = rule.toDateTime(year);
              this.ldtSecs = ldt.toEpochSecond(ZoneOffset.UTC);
          }
  
<span class="line-modified">!         ZoneOffsetTransition toTransition(ZoneOffset standardOffset, int savingsBeforeSecs, int negativeSavings) {</span>
              // copy of code in ZoneOffsetTransitionRule to avoid infinite loop
              ZoneOffset wallOffset = ZoneOffset.ofTotalSeconds(
                  standardOffset.getTotalSeconds() + savingsBeforeSecs);
              ZoneOffset offsetAfter = ZoneOffset.ofTotalSeconds(
<span class="line-modified">!                 standardOffset.getTotalSeconds() + rule.savingsAmount - negativeSavings);</span>
              LocalDateTime dt = rule.timeDefinition
                                     .createDateTime(ldt, standardOffset, wallOffset);
              return ZoneOffsetTransition.of(dt, wallOffset, offsetAfter);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 664,14 ***</span>
  
          /**
           * Tests if this a real transition with the active savings in seconds
           *
           * @param savingsBefore the active savings in seconds
           * @return true, if savings changes
           */
<span class="line-modified">!         boolean isTransition(int savingsBefore) {</span>
<span class="line-modified">!             return rule.savingsAmount != savingsBefore;</span>
          }
  
          public int compareTo(TransRule other) {
              return (ldtSecs &lt; other.ldtSecs)? -1 : ((ldtSecs == other.ldtSecs) ? 0 : 1);
          }
<span class="line-new-header">--- 671,16 ---</span>
  
          /**
           * Tests if this a real transition with the active savings in seconds
           *
           * @param savingsBefore the active savings in seconds
<span class="line-added">+          * @param negativeSavings minimum savings in the rule, usually zero, but negative if negative DST is</span>
<span class="line-added">+          *                   in effect.</span>
           * @return true, if savings changes
           */
<span class="line-modified">!         boolean isTransition(int savingsBefore, int negativeSavings) {</span>
<span class="line-modified">!             return rule.savingsAmount - negativeSavings != savingsBefore;</span>
          }
  
          public int compareTo(TransRule other) {
              return (ldtSecs &lt; other.ldtSecs)? -1 : ((ldtSecs == other.ldtSecs) ? 0 : 1);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 695,16 ***</span>
          ZoneOffset wallOffset = ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savings);
  
          // start ldt of each zone window
          LocalDateTime zoneStart = LocalDateTime.MIN;
  
<span class="line-modified">!         // first stanard offset</span>
          ZoneOffset firstStdOffset = stdOffset;
          // first wall offset
          ZoneOffset firstWallOffset = wallOffset;
  
          for (ZoneLine zone : zones) {
              // check if standard offset changed, update it if yes
              ZoneOffset stdOffsetPrev = stdOffset;  // for effectiveSavings check
              if (zone.stdOffsetSecs != stdOffset.getTotalSeconds()) {
                  ZoneOffset stdOffsetNew = ZoneOffset.ofTotalSeconds(zone.stdOffsetSecs);
                  standardTransitionList.add(
<span class="line-new-header">--- 704,26 ---</span>
          ZoneOffset wallOffset = ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savings);
  
          // start ldt of each zone window
          LocalDateTime zoneStart = LocalDateTime.MIN;
  
<span class="line-modified">!         // first standard offset</span>
          ZoneOffset firstStdOffset = stdOffset;
          // first wall offset
          ZoneOffset firstWallOffset = wallOffset;
  
          for (ZoneLine zone : zones) {
<span class="line-added">+             // Adjust stdOffset, if negative DST is observed. It should be either</span>
<span class="line-added">+             // fixed amount, or expressed in the named Rules.</span>
<span class="line-added">+             int negativeSavings = Math.min(zone.fixedSavingsSecs, findNegativeSavings(zoneStart, zone));</span>
<span class="line-added">+             if (negativeSavings &lt; 0) {</span>
<span class="line-added">+                 zone.stdOffsetSecs += negativeSavings;</span>
<span class="line-added">+                 if (zone.fixedSavingsSecs &lt; 0) {</span>
<span class="line-added">+                     zone.fixedSavingsSecs = 0;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              // check if standard offset changed, update it if yes
              ZoneOffset stdOffsetPrev = stdOffset;  // for effectiveSavings check
              if (zone.stdOffsetSecs != stdOffset.getTotalSeconds()) {
                  ZoneOffset stdOffsetNew = ZoneOffset.ofTotalSeconds(zone.stdOffsetSecs);
                  standardTransitionList.add(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 789,20 ***</span>
                      Collections.sort(lastRules);
                  }
                  // sort the merged rules
                  Collections.sort(trules);
  
<span class="line-modified">!                 effectiveSavings = 0;</span>
                  for (TransRule rule : trules) {
                      if (rule.toEpochSecond(stdOffsetPrev, savings) &gt;
                          zoneStart.toEpochSecond(wallOffset)) {
                          // previous savings amount found, which could be the
                          // savings amount at the instant that the window starts
                          // (hence isAfter)
                          break;
                      }
<span class="line-modified">!                     effectiveSavings = rule.rule.savingsAmount;</span>
                  }
              }
              // check if the start of the window represents a transition
              ZoneOffset effectiveWallOffset =
                  ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + effectiveSavings);
<span class="line-new-header">--- 808,20 ---</span>
                      Collections.sort(lastRules);
                  }
                  // sort the merged rules
                  Collections.sort(trules);
  
<span class="line-modified">!                 effectiveSavings = -negativeSavings;</span>
                  for (TransRule rule : trules) {
                      if (rule.toEpochSecond(stdOffsetPrev, savings) &gt;
                          zoneStart.toEpochSecond(wallOffset)) {
                          // previous savings amount found, which could be the
                          // savings amount at the instant that the window starts
                          // (hence isAfter)
                          break;
                      }
<span class="line-modified">!                     effectiveSavings = rule.rule.savingsAmount - negativeSavings;</span>
                  }
              }
              // check if the start of the window represents a transition
              ZoneOffset effectiveWallOffset =
                  ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + effectiveSavings);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 815,25 ***</span>
              savings = effectiveSavings;
              // apply rules within the window
              if (trules != null) {
                  long zoneStartEpochSecs = zoneStart.toEpochSecond(wallOffset);
                  for (TransRule trule : trules) {
<span class="line-modified">!                     if (trule.isTransition(savings)) {</span>
                          long epochSecs = trule.toEpochSecond(stdOffset, savings);
                          if (epochSecs &lt; zoneStartEpochSecs ||
                              epochSecs &gt;= zone.toDateTimeEpochSecond(savings)) {
                              continue;
                          }
<span class="line-modified">!                         transitionList.add(trule.toTransition(stdOffset, savings));</span>
<span class="line-modified">!                         savings = trule.rule.savingsAmount;</span>
                      }
                  }
              }
              if (lastRules != null) {
                  for (TransRule trule : lastRules) {
<span class="line-modified">!                     lastTransitionRuleList.add(trule.rule.toTransitionRule(stdOffset, savings));</span>
<span class="line-modified">!                     savings = trule.rule.savingsAmount;</span>
                  }
              }
  
              // finally we can calculate the true end of the window, passing it to the next window
              wallOffset = ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savings);
<span class="line-new-header">--- 834,25 ---</span>
              savings = effectiveSavings;
              // apply rules within the window
              if (trules != null) {
                  long zoneStartEpochSecs = zoneStart.toEpochSecond(wallOffset);
                  for (TransRule trule : trules) {
<span class="line-modified">!                     if (trule.isTransition(savings, negativeSavings)) {</span>
                          long epochSecs = trule.toEpochSecond(stdOffset, savings);
                          if (epochSecs &lt; zoneStartEpochSecs ||
                              epochSecs &gt;= zone.toDateTimeEpochSecond(savings)) {
                              continue;
                          }
<span class="line-modified">!                         transitionList.add(trule.toTransition(stdOffset, savings, negativeSavings));</span>
<span class="line-modified">!                         savings = trule.rule.savingsAmount - negativeSavings;</span>
                      }
                  }
              }
              if (lastRules != null) {
                  for (TransRule trule : lastRules) {
<span class="line-modified">!                     lastTransitionRuleList.add(trule.rule.toTransitionRule(stdOffset, savings, negativeSavings));</span>
<span class="line-modified">!                     savings = trule.rule.savingsAmount - negativeSavings;</span>
                  }
              }
  
              // finally we can calculate the true end of the window, passing it to the next window
              wallOffset = ZoneOffset.ofTotalSeconds(stdOffset.getTotalSeconds() + savings);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 846,6 ***</span>
<span class="line-new-header">--- 865,40 ---</span>
                               standardTransitionList,
                               transitionList,
                               lastTransitionRuleList);
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Find the minimum negative savings in named Rules for a Zone. Savings are only</span>
<span class="line-added">+      * looked at for the period of the subject Zone.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param zoneStart start LDT of the zone</span>
<span class="line-added">+      * @param zl ZoneLine to look at</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private int findNegativeSavings(LocalDateTime zoneStart, ZoneLine zl) {</span>
<span class="line-added">+         int negativeSavings = 0;</span>
<span class="line-added">+         LocalDateTime zoneEnd = zl.toDateTime();</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (zl.savingsRule != null) {</span>
<span class="line-added">+             List&lt;RuleLine&gt; rlines = rules.get(zl.savingsRule);</span>
<span class="line-added">+             if (rlines == null) {</span>
<span class="line-added">+                 throw new IllegalArgumentException(&quot;&lt;Rule&gt; not found: &quot; +</span>
<span class="line-added">+                         zl.savingsRule);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             negativeSavings = Math.min(0, rlines.stream()</span>
<span class="line-added">+                     .filter(l -&gt; windowOverlap(l, zoneStart.getYear(), zoneEnd.getYear()))</span>
<span class="line-added">+                     .map(l -&gt; l.savingsAmount)</span>
<span class="line-added">+                     .min(Comparator.naturalOrder())</span>
<span class="line-added">+                     .orElse(0));</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return negativeSavings;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private boolean windowOverlap(RuleLine ruleLine, int zoneStartYear, int zoneEndYear) {</span>
<span class="line-added">+         boolean overlap = zoneStartYear &lt;= ruleLine.startYear &amp;&amp; zoneEndYear &gt;= ruleLine.startYear ||</span>
<span class="line-added">+                           zoneStartYear &lt;= ruleLine.endYear &amp;&amp; zoneEndYear &gt;= ruleLine.endYear;</span>
<span class="line-added">+ </span>
<span class="line-added">+         return overlap;</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="TzdbZoneRulesCompiler.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../langtools/tools/propertiesparser/resources/templates.properties.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
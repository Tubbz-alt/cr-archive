<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.net.http/share/classes/jdk/internal/net/http/AuthenticationFilter.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../java/net/http/HttpResponse.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ConnectionPool.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.net.http/share/classes/jdk/internal/net/http/AuthenticationFilter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 26 package jdk.internal.net.http;
 27 
 28 import java.io.IOException;
 29 import java.net.MalformedURLException;
 30 import java.net.PasswordAuthentication;
 31 import java.net.URI;
 32 import java.net.InetSocketAddress;
 33 import java.net.URISyntaxException;
 34 import java.net.URL;
 35 import java.util.Base64;
 36 import java.util.LinkedList;
 37 import java.util.List;
 38 import java.util.Objects;
 39 import java.util.WeakHashMap;
 40 import java.net.http.HttpHeaders;
 41 import jdk.internal.net.http.common.Log;
 42 import jdk.internal.net.http.common.Utils;
 43 import static java.net.Authenticator.RequestorType.PROXY;
 44 import static java.net.Authenticator.RequestorType.SERVER;
 45 import static java.nio.charset.StandardCharsets.ISO_8859_1;

 46 
 47 /**
 48  * Implementation of Http Basic authentication.
 49  */
 50 class AuthenticationFilter implements HeaderFilter {
 51     volatile MultiExchange&lt;?&gt; exchange;
 52     private static final Base64.Encoder encoder = Base64.getEncoder();
 53 
 54     static final int DEFAULT_RETRY_LIMIT = 3;
 55 
 56     static final int retry_limit = Utils.getIntegerNetProperty(
 57             &quot;jdk.httpclient.auth.retrylimit&quot;, DEFAULT_RETRY_LIMIT);
 58 
 59     static final int UNAUTHORIZED = 401;
 60     static final int PROXY_UNAUTHORIZED = 407;
 61 
 62     private static final String BASIC_DUMMY =
 63             &quot;Basic &quot; + Base64.getEncoder()
 64                     .encodeToString(&quot;o:o&quot;.getBytes(ISO_8859_1));
 65 
</pre>
<hr />
<pre>
138                            &quot;/&quot;,
139                            null,
140                            null);
141         } catch (URISyntaxException e) {
142             throw new InternalError(e);
143         }
144     }
145 
146     @Override
147     public void request(HttpRequestImpl r, MultiExchange&lt;?&gt; e) throws IOException {
148         // use preemptive authentication if an entry exists.
149         Cache cache = getCache(e);
150         this.exchange = e;
151 
152         // Proxy
153         if (exchange.proxyauth == null) {
154             URI proxyURI = getProxyURI(r);
155             if (proxyURI != null) {
156                 CacheEntry ca = cache.get(proxyURI, true);
157                 if (ca != null) {
<span class="line-modified">158                     exchange.proxyauth = new AuthInfo(true, ca.scheme, null, ca);</span>
<span class="line-modified">159                     addBasicCredentials(r, true, ca.value);</span>
160                 }
161             }
162         }
163 
164         // Server
165         if (exchange.serverauth == null) {
166             CacheEntry ca = cache.get(r.uri(), false);
167             if (ca != null) {
<span class="line-modified">168                 exchange.serverauth = new AuthInfo(true, ca.scheme, null, ca);</span>
<span class="line-modified">169                 addBasicCredentials(r, false, ca.value);</span>
170             }
171         }
172     }
173 
174     // TODO: refactor into per auth scheme class
175     private static void addBasicCredentials(HttpRequestImpl r,
176                                             boolean proxy,
<span class="line-modified">177                                             PasswordAuthentication pw) {</span>

178         String hdrname = proxy ? &quot;Proxy-Authorization&quot; : &quot;Authorization&quot;;
179         StringBuilder sb = new StringBuilder(128);
180         sb.append(pw.getUserName()).append(&#39;:&#39;).append(pw.getPassword());
<span class="line-modified">181         String s = encoder.encodeToString(sb.toString().getBytes(ISO_8859_1));</span>

182         String value = &quot;Basic &quot; + s;
183         if (proxy) {
184             if (r.isConnect()) {
185                 if (!Utils.PROXY_TUNNEL_FILTER.test(hdrname, value)) {
186                     Log.logError(&quot;{0} disabled&quot;, hdrname);
187                     return;
188                 }
189             } else if (r.proxy() != null) {
190                 if (!Utils.PROXY_FILTER.test(hdrname, value)) {
191                     Log.logError(&quot;{0} disabled&quot;, hdrname);
192                     return;
193                 }
194             }
195         }
196         r.setSystemHeader(hdrname, value);
197     }
198 
199     // Information attached to a HttpRequestImpl relating to authentication
200     static class AuthInfo {
201         final boolean fromcache;
202         final String scheme;
203         int retries;
204         PasswordAuthentication credentials; // used in request
205         CacheEntry cacheEntry; // if used

206 
207         AuthInfo(boolean fromcache,
208                  String scheme,
<span class="line-modified">209                  PasswordAuthentication credentials) {</span>
210             this.fromcache = fromcache;
211             this.scheme = scheme;
212             this.credentials = credentials;
213             this.retries = 1;

214         }
215 
216         AuthInfo(boolean fromcache,
217                  String scheme,
218                  PasswordAuthentication credentials,
<span class="line-modified">219                  CacheEntry ca) {</span>
<span class="line-modified">220             this(fromcache, scheme, credentials);</span>
221             assert credentials == null || (ca != null &amp;&amp; ca.value == null);
222             cacheEntry = ca;
223         }
224 
<span class="line-modified">225         AuthInfo retryWithCredentials(PasswordAuthentication pw) {</span>
226             // If the info was already in the cache we need to create a new
227             // instance with fromCache==false so that it&#39;s put back in the
228             // cache if authentication succeeds
<span class="line-modified">229             AuthInfo res = fromcache ? new AuthInfo(false, scheme, pw) : this;</span>
230             res.credentials = Objects.requireNonNull(pw);
231             res.retries = retries;
232             return res;
233         }
<span class="line-removed">234 </span>
235     }
236 
237     @Override
238     public HttpRequestImpl response(Response r) throws IOException {
239         Cache cache = getCache(exchange);
240         int status = r.statusCode();
241         HttpHeaders hdrs = r.headers();
242         HttpRequestImpl req = r.request();
243 
<span class="line-modified">244         if (status != UNAUTHORIZED &amp;&amp; status != PROXY_UNAUTHORIZED) {</span>
<span class="line-removed">245             // check if any authentication succeeded for first time</span>
<span class="line-removed">246             if (exchange.serverauth != null &amp;&amp; !exchange.serverauth.fromcache) {</span>
<span class="line-removed">247                 AuthInfo au = exchange.serverauth;</span>
<span class="line-removed">248                 cache.store(au.scheme, req.uri(), false, au.credentials);</span>
<span class="line-removed">249             }</span>
250             if (exchange.proxyauth != null &amp;&amp; !exchange.proxyauth.fromcache) {
251                 AuthInfo au = exchange.proxyauth;
252                 URI proxyURI = getProxyURI(req);
253                 if (proxyURI != null) {
<span class="line-modified">254                     cache.store(au.scheme, proxyURI, true, au.credentials);</span>

255                 }
256             }
<span class="line-modified">257             return null;</span>







258         }
259 
260         boolean proxy = status == PROXY_UNAUTHORIZED;
261         String authname = proxy ? &quot;Proxy-Authenticate&quot; : &quot;WWW-Authenticate&quot;;
262         List&lt;String&gt; authvals = hdrs.allValues(authname);
263         if (authvals.isEmpty() &amp;&amp; exchange.client().authenticator().isPresent()) {
264             throw new IOException(authname + &quot; header missing for response code &quot; + status);
265         }
266         String authval = null;

267         for (String aval : authvals) {
268             HeaderParser parser = new HeaderParser(aval);
269             String scheme = parser.findKey(0);
270             if (scheme.equalsIgnoreCase(&quot;Basic&quot;)) {
271                 authval = aval;


272                 break;
273             }
274         }
275         if (authval == null) {
276             return null;
277         }
278 
279         if (proxy) {
280             if (r.isConnectResponse) {
281                 if (!Utils.PROXY_TUNNEL_FILTER
282                         .test(&quot;Proxy-Authorization&quot;, BASIC_DUMMY)) {
283                     Log.logError(&quot;{0} disabled&quot;, &quot;Proxy-Authorization&quot;);
284                     return null;
285                 }
286             } else if (req.proxy() != null) {
287                 if (!Utils.PROXY_FILTER
288                         .test(&quot;Proxy-Authorization&quot;, BASIC_DUMMY)) {
289                     Log.logError(&quot;{0} disabled&quot;, &quot;Proxy-Authorization&quot;);
290                     return null;
291                 }
292             }
293         }
294 
295         AuthInfo au = proxy ? exchange.proxyauth : exchange.serverauth;
296         if (au == null) {
297             // if no authenticator, let the user deal with 407/401
298             if (!exchange.client().authenticator().isPresent()) return null;
299 
300             PasswordAuthentication pw = getCredentials(authval, proxy, req);
301             if (pw == null) {
302                 throw new IOException(&quot;No credentials provided&quot;);
303             }
304             // No authentication in request. Get credentials from user
<span class="line-modified">305             au = new AuthInfo(false, &quot;Basic&quot;, pw);</span>
306             if (proxy) {
307                 exchange.proxyauth = au;
308             } else {
309                 exchange.serverauth = au;
310             }
311             req = HttpRequestImpl.newInstanceForAuthentication(req);
<span class="line-modified">312             addBasicCredentials(req, proxy, pw);</span>
313             return req;
314         } else if (au.retries &gt; retry_limit) {
315             throw new IOException(&quot;too many authentication attempts. Limit: &quot; +
316                     Integer.toString(retry_limit));
317         } else {
318             // we sent credentials, but they were rejected
319             if (au.fromcache) {
320                 cache.remove(au.cacheEntry);
321             }
322 
323             // if no authenticator, let the user deal with 407/401
324             if (!exchange.client().authenticator().isPresent()) return null;
325 
326             // try again
327             PasswordAuthentication pw = getCredentials(authval, proxy, req);
328             if (pw == null) {
329                 throw new IOException(&quot;No credentials provided&quot;);
330             }
<span class="line-modified">331             au = au.retryWithCredentials(pw);</span>
332             if (proxy) {
333                 exchange.proxyauth = au;
334             } else {
335                 exchange.serverauth = au;
336             }
337             req = HttpRequestImpl.newInstanceForAuthentication(req);
<span class="line-modified">338             addBasicCredentials(req, proxy, au.credentials);</span>
339             au.retries++;
340             return req;
341         }
342     }
343 
344     // Use a WeakHashMap to make it possible for the HttpClient to
345     // be garbage collected when no longer referenced.
346     static final WeakHashMap&lt;HttpClientImpl,Cache&gt; caches = new WeakHashMap&lt;&gt;();
347 
348     static synchronized Cache getCache(MultiExchange&lt;?&gt; exchange) {
349         HttpClientImpl client = exchange.client();
350         Cache c = caches.get(client);
351         if (c == null) {
352             c = new Cache();
353             caches.put(client, c);
354         }
355         return c;
356     }
357 
358     // Note: Make sure that Cache and CacheEntry do not keep any strong
359     //       reference to the HttpClient: it would prevent the client being
360     //       GC&#39;ed when no longer referenced.
361     static final class Cache {
362         final LinkedList&lt;CacheEntry&gt; entries = new LinkedList&lt;&gt;();
363 
364         Cache() {}
365 
366         synchronized CacheEntry get(URI uri, boolean proxy) {
367             for (CacheEntry entry : entries) {
368                 if (entry.equalsKey(uri, proxy)) {
369                     return entry;
370                 }
371             }
372             return null;
373         }
374 




375         synchronized void remove(String authscheme, URI domain, boolean proxy) {
<span class="line-modified">376             for (CacheEntry entry : entries) {</span>
<span class="line-modified">377                 if (entry.equalsKey(domain, proxy)) {</span>
<span class="line-modified">378                     entries.remove(entry);</span>




379                 }
380             }
381         }
382 
383         synchronized void remove(CacheEntry entry) {
384             entries.remove(entry);
385         }
386 
387         synchronized void store(String authscheme,
388                                 URI domain,
389                                 boolean proxy,
<span class="line-modified">390                                 PasswordAuthentication value) {</span>
391             remove(authscheme, domain, proxy);
<span class="line-modified">392             entries.add(new CacheEntry(authscheme, domain, proxy, value));</span>
393         }
394     }
395 
396     static URI normalize(URI uri, boolean isPrimaryKey) {
397         String path = uri.getPath();
398         if (path == null || path.isEmpty()) {
399             // make sure the URI has a path, ignore query and fragment
400             try {
401                 return new URI(uri.getScheme(), uri.getAuthority(), &quot;/&quot;, null, null);
402             } catch (URISyntaxException e) {
403                 throw new InternalError(e);
404             }
405         } else if (isPrimaryKey || !&quot;/&quot;.equals(path)) {
406             // remove extraneous components and normalize path
407             return uri.resolve(&quot;.&quot;);
408         } else {
409             // path == &quot;/&quot; and the URI is not used to store
410             // the primary key in the cache: nothing to do.
411             return uri;
412         }
413     }
414 
415     static final class CacheEntry {
416         final String root;
417         final String scheme;
418         final boolean proxy;
419         final PasswordAuthentication value;

420 
421         CacheEntry(String authscheme,
422                    URI uri,
423                    boolean proxy,
<span class="line-modified">424                    PasswordAuthentication value) {</span>
425             this.scheme = authscheme;
426             this.root = normalize(uri, true).toString(); // remove extraneous components
427             this.proxy = proxy;
428             this.value = value;

429         }
430 
431         public PasswordAuthentication value() {
432             return value;
433         }
434 
435         public boolean equalsKey(URI uri, boolean proxy) {
436             if (this.proxy != proxy) {
437                 return false;
438             }
439             String other = String.valueOf(normalize(uri, false));
440             return other.startsWith(root);
441         }
442     }
443 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 26 package jdk.internal.net.http;
 27 
 28 import java.io.IOException;
 29 import java.net.MalformedURLException;
 30 import java.net.PasswordAuthentication;
 31 import java.net.URI;
 32 import java.net.InetSocketAddress;
 33 import java.net.URISyntaxException;
 34 import java.net.URL;
 35 import java.util.Base64;
 36 import java.util.LinkedList;
 37 import java.util.List;
 38 import java.util.Objects;
 39 import java.util.WeakHashMap;
 40 import java.net.http.HttpHeaders;
 41 import jdk.internal.net.http.common.Log;
 42 import jdk.internal.net.http.common.Utils;
 43 import static java.net.Authenticator.RequestorType.PROXY;
 44 import static java.net.Authenticator.RequestorType.SERVER;
 45 import static java.nio.charset.StandardCharsets.ISO_8859_1;
<span class="line-added"> 46 import static java.nio.charset.StandardCharsets.UTF_8;</span>
 47 
 48 /**
 49  * Implementation of Http Basic authentication.
 50  */
 51 class AuthenticationFilter implements HeaderFilter {
 52     volatile MultiExchange&lt;?&gt; exchange;
 53     private static final Base64.Encoder encoder = Base64.getEncoder();
 54 
 55     static final int DEFAULT_RETRY_LIMIT = 3;
 56 
 57     static final int retry_limit = Utils.getIntegerNetProperty(
 58             &quot;jdk.httpclient.auth.retrylimit&quot;, DEFAULT_RETRY_LIMIT);
 59 
 60     static final int UNAUTHORIZED = 401;
 61     static final int PROXY_UNAUTHORIZED = 407;
 62 
 63     private static final String BASIC_DUMMY =
 64             &quot;Basic &quot; + Base64.getEncoder()
 65                     .encodeToString(&quot;o:o&quot;.getBytes(ISO_8859_1));
 66 
</pre>
<hr />
<pre>
139                            &quot;/&quot;,
140                            null,
141                            null);
142         } catch (URISyntaxException e) {
143             throw new InternalError(e);
144         }
145     }
146 
147     @Override
148     public void request(HttpRequestImpl r, MultiExchange&lt;?&gt; e) throws IOException {
149         // use preemptive authentication if an entry exists.
150         Cache cache = getCache(e);
151         this.exchange = e;
152 
153         // Proxy
154         if (exchange.proxyauth == null) {
155             URI proxyURI = getProxyURI(r);
156             if (proxyURI != null) {
157                 CacheEntry ca = cache.get(proxyURI, true);
158                 if (ca != null) {
<span class="line-modified">159                     exchange.proxyauth = new AuthInfo(true, ca.scheme, null, ca, ca.isUTF8);</span>
<span class="line-modified">160                     addBasicCredentials(r, true, ca.value, ca.isUTF8);</span>
161                 }
162             }
163         }
164 
165         // Server
166         if (exchange.serverauth == null) {
167             CacheEntry ca = cache.get(r.uri(), false);
168             if (ca != null) {
<span class="line-modified">169                 exchange.serverauth = new AuthInfo(true, ca.scheme, null, ca, ca.isUTF8);</span>
<span class="line-modified">170                 addBasicCredentials(r, false, ca.value, ca.isUTF8);</span>
171             }
172         }
173     }
174 
175     // TODO: refactor into per auth scheme class
176     private static void addBasicCredentials(HttpRequestImpl r,
177                                             boolean proxy,
<span class="line-modified">178                                             PasswordAuthentication pw,</span>
<span class="line-added">179                                             boolean isUTF8) {</span>
180         String hdrname = proxy ? &quot;Proxy-Authorization&quot; : &quot;Authorization&quot;;
181         StringBuilder sb = new StringBuilder(128);
182         sb.append(pw.getUserName()).append(&#39;:&#39;).append(pw.getPassword());
<span class="line-modified">183         var charset = isUTF8 ? UTF_8 : ISO_8859_1;</span>
<span class="line-added">184         String s = encoder.encodeToString(sb.toString().getBytes(charset));</span>
185         String value = &quot;Basic &quot; + s;
186         if (proxy) {
187             if (r.isConnect()) {
188                 if (!Utils.PROXY_TUNNEL_FILTER.test(hdrname, value)) {
189                     Log.logError(&quot;{0} disabled&quot;, hdrname);
190                     return;
191                 }
192             } else if (r.proxy() != null) {
193                 if (!Utils.PROXY_FILTER.test(hdrname, value)) {
194                     Log.logError(&quot;{0} disabled&quot;, hdrname);
195                     return;
196                 }
197             }
198         }
199         r.setSystemHeader(hdrname, value);
200     }
201 
202     // Information attached to a HttpRequestImpl relating to authentication
203     static class AuthInfo {
204         final boolean fromcache;
205         final String scheme;
206         int retries;
207         PasswordAuthentication credentials; // used in request
208         CacheEntry cacheEntry; // if used
<span class="line-added">209         final boolean isUTF8; //</span>
210 
211         AuthInfo(boolean fromcache,
212                  String scheme,
<span class="line-modified">213                  PasswordAuthentication credentials, boolean isUTF8) {</span>
214             this.fromcache = fromcache;
215             this.scheme = scheme;
216             this.credentials = credentials;
217             this.retries = 1;
<span class="line-added">218             this.isUTF8 = isUTF8;</span>
219         }
220 
221         AuthInfo(boolean fromcache,
222                  String scheme,
223                  PasswordAuthentication credentials,
<span class="line-modified">224                  CacheEntry ca, boolean isUTF8) {</span>
<span class="line-modified">225             this(fromcache, scheme, credentials, isUTF8);</span>
226             assert credentials == null || (ca != null &amp;&amp; ca.value == null);
227             cacheEntry = ca;
228         }
229 
<span class="line-modified">230         AuthInfo retryWithCredentials(PasswordAuthentication pw, boolean isUTF8) {</span>
231             // If the info was already in the cache we need to create a new
232             // instance with fromCache==false so that it&#39;s put back in the
233             // cache if authentication succeeds
<span class="line-modified">234             AuthInfo res = fromcache ? new AuthInfo(false, scheme, pw, isUTF8) : this;</span>
235             res.credentials = Objects.requireNonNull(pw);
236             res.retries = retries;
237             return res;
238         }

239     }
240 
241     @Override
242     public HttpRequestImpl response(Response r) throws IOException {
243         Cache cache = getCache(exchange);
244         int status = r.statusCode();
245         HttpHeaders hdrs = r.headers();
246         HttpRequestImpl req = r.request();
247 
<span class="line-modified">248         if (status != PROXY_UNAUTHORIZED) {</span>





249             if (exchange.proxyauth != null &amp;&amp; !exchange.proxyauth.fromcache) {
250                 AuthInfo au = exchange.proxyauth;
251                 URI proxyURI = getProxyURI(req);
252                 if (proxyURI != null) {
<span class="line-modified">253                     exchange.proxyauth = null;</span>
<span class="line-added">254                     cache.store(au.scheme, proxyURI, true, au.credentials, au.isUTF8);</span>
255                 }
256             }
<span class="line-modified">257             if (status != UNAUTHORIZED) {</span>
<span class="line-added">258                 // check if any authentication succeeded for first time</span>
<span class="line-added">259                 if (exchange.serverauth != null &amp;&amp; !exchange.serverauth.fromcache) {</span>
<span class="line-added">260                     AuthInfo au = exchange.serverauth;</span>
<span class="line-added">261                     cache.store(au.scheme, req.uri(), false, au.credentials, au.isUTF8);</span>
<span class="line-added">262                 }</span>
<span class="line-added">263                 return null;</span>
<span class="line-added">264             }</span>
265         }
266 
267         boolean proxy = status == PROXY_UNAUTHORIZED;
268         String authname = proxy ? &quot;Proxy-Authenticate&quot; : &quot;WWW-Authenticate&quot;;
269         List&lt;String&gt; authvals = hdrs.allValues(authname);
270         if (authvals.isEmpty() &amp;&amp; exchange.client().authenticator().isPresent()) {
271             throw new IOException(authname + &quot; header missing for response code &quot; + status);
272         }
273         String authval = null;
<span class="line-added">274         boolean isUTF8 = false;</span>
275         for (String aval : authvals) {
276             HeaderParser parser = new HeaderParser(aval);
277             String scheme = parser.findKey(0);
278             if (scheme.equalsIgnoreCase(&quot;Basic&quot;)) {
279                 authval = aval;
<span class="line-added">280                 var charset = parser.findValue(&quot;charset&quot;);</span>
<span class="line-added">281                 isUTF8 = (charset != null &amp;&amp; charset.equalsIgnoreCase(&quot;UTF-8&quot;));</span>
282                 break;
283             }
284         }
285         if (authval == null) {
286             return null;
287         }
288 
289         if (proxy) {
290             if (r.isConnectResponse) {
291                 if (!Utils.PROXY_TUNNEL_FILTER
292                         .test(&quot;Proxy-Authorization&quot;, BASIC_DUMMY)) {
293                     Log.logError(&quot;{0} disabled&quot;, &quot;Proxy-Authorization&quot;);
294                     return null;
295                 }
296             } else if (req.proxy() != null) {
297                 if (!Utils.PROXY_FILTER
298                         .test(&quot;Proxy-Authorization&quot;, BASIC_DUMMY)) {
299                     Log.logError(&quot;{0} disabled&quot;, &quot;Proxy-Authorization&quot;);
300                     return null;
301                 }
302             }
303         }
304 
305         AuthInfo au = proxy ? exchange.proxyauth : exchange.serverauth;
306         if (au == null) {
307             // if no authenticator, let the user deal with 407/401
308             if (!exchange.client().authenticator().isPresent()) return null;
309 
310             PasswordAuthentication pw = getCredentials(authval, proxy, req);
311             if (pw == null) {
312                 throw new IOException(&quot;No credentials provided&quot;);
313             }
314             // No authentication in request. Get credentials from user
<span class="line-modified">315             au = new AuthInfo(false, &quot;Basic&quot;, pw, isUTF8);</span>
316             if (proxy) {
317                 exchange.proxyauth = au;
318             } else {
319                 exchange.serverauth = au;
320             }
321             req = HttpRequestImpl.newInstanceForAuthentication(req);
<span class="line-modified">322             addBasicCredentials(req, proxy, pw, isUTF8);</span>
323             return req;
324         } else if (au.retries &gt; retry_limit) {
325             throw new IOException(&quot;too many authentication attempts. Limit: &quot; +
326                     Integer.toString(retry_limit));
327         } else {
328             // we sent credentials, but they were rejected
329             if (au.fromcache) {
330                 cache.remove(au.cacheEntry);
331             }
332 
333             // if no authenticator, let the user deal with 407/401
334             if (!exchange.client().authenticator().isPresent()) return null;
335 
336             // try again
337             PasswordAuthentication pw = getCredentials(authval, proxy, req);
338             if (pw == null) {
339                 throw new IOException(&quot;No credentials provided&quot;);
340             }
<span class="line-modified">341             au = au.retryWithCredentials(pw, isUTF8);</span>
342             if (proxy) {
343                 exchange.proxyauth = au;
344             } else {
345                 exchange.serverauth = au;
346             }
347             req = HttpRequestImpl.newInstanceForAuthentication(req);
<span class="line-modified">348             addBasicCredentials(req, proxy, au.credentials, isUTF8);</span>
349             au.retries++;
350             return req;
351         }
352     }
353 
354     // Use a WeakHashMap to make it possible for the HttpClient to
355     // be garbage collected when no longer referenced.
356     static final WeakHashMap&lt;HttpClientImpl,Cache&gt; caches = new WeakHashMap&lt;&gt;();
357 
358     static synchronized Cache getCache(MultiExchange&lt;?&gt; exchange) {
359         HttpClientImpl client = exchange.client();
360         Cache c = caches.get(client);
361         if (c == null) {
362             c = new Cache();
363             caches.put(client, c);
364         }
365         return c;
366     }
367 
368     // Note: Make sure that Cache and CacheEntry do not keep any strong
369     //       reference to the HttpClient: it would prevent the client being
370     //       GC&#39;ed when no longer referenced.
371     static final class Cache {
372         final LinkedList&lt;CacheEntry&gt; entries = new LinkedList&lt;&gt;();
373 
374         Cache() {}
375 
376         synchronized CacheEntry get(URI uri, boolean proxy) {
377             for (CacheEntry entry : entries) {
378                 if (entry.equalsKey(uri, proxy)) {
379                     return entry;
380                 }
381             }
382             return null;
383         }
384 
<span class="line-added">385         private static boolean equalsIgnoreCase(String s1, String s2) {</span>
<span class="line-added">386             return s1 == s2 || (s1 != null &amp;&amp; s1.equalsIgnoreCase(s2));</span>
<span class="line-added">387         }</span>
<span class="line-added">388 </span>
389         synchronized void remove(String authscheme, URI domain, boolean proxy) {
<span class="line-modified">390             var iterator = entries.iterator();</span>
<span class="line-modified">391             while (iterator.hasNext()) {</span>
<span class="line-modified">392                 var entry = iterator.next();</span>
<span class="line-added">393                 if (equalsIgnoreCase(entry.scheme, authscheme)) {</span>
<span class="line-added">394                     if (entry.equalsKey(domain, proxy)) {</span>
<span class="line-added">395                         iterator.remove();</span>
<span class="line-added">396                     }</span>
397                 }
398             }
399         }
400 
401         synchronized void remove(CacheEntry entry) {
402             entries.remove(entry);
403         }
404 
405         synchronized void store(String authscheme,
406                                 URI domain,
407                                 boolean proxy,
<span class="line-modified">408                                 PasswordAuthentication value, boolean isUTF8) {</span>
409             remove(authscheme, domain, proxy);
<span class="line-modified">410             entries.add(new CacheEntry(authscheme, domain, proxy, value, isUTF8));</span>
411         }
412     }
413 
414     static URI normalize(URI uri, boolean isPrimaryKey) {
415         String path = uri.getPath();
416         if (path == null || path.isEmpty()) {
417             // make sure the URI has a path, ignore query and fragment
418             try {
419                 return new URI(uri.getScheme(), uri.getAuthority(), &quot;/&quot;, null, null);
420             } catch (URISyntaxException e) {
421                 throw new InternalError(e);
422             }
423         } else if (isPrimaryKey || !&quot;/&quot;.equals(path)) {
424             // remove extraneous components and normalize path
425             return uri.resolve(&quot;.&quot;);
426         } else {
427             // path == &quot;/&quot; and the URI is not used to store
428             // the primary key in the cache: nothing to do.
429             return uri;
430         }
431     }
432 
433     static final class CacheEntry {
434         final String root;
435         final String scheme;
436         final boolean proxy;
437         final PasswordAuthentication value;
<span class="line-added">438         final boolean isUTF8;</span>
439 
440         CacheEntry(String authscheme,
441                    URI uri,
442                    boolean proxy,
<span class="line-modified">443                    PasswordAuthentication value, boolean isUTF8) {</span>
444             this.scheme = authscheme;
445             this.root = normalize(uri, true).toString(); // remove extraneous components
446             this.proxy = proxy;
447             this.value = value;
<span class="line-added">448             this.isUTF8 = isUTF8;</span>
449         }
450 
451         public PasswordAuthentication value() {
452             return value;
453         }
454 
455         public boolean equalsKey(URI uri, boolean proxy) {
456             if (this.proxy != proxy) {
457                 return false;
458             }
459             String other = String.valueOf(normalize(uri, false));
460             return other.startsWith(root);
461         }
462     }
463 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../java/net/http/HttpResponse.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ConnectionPool.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
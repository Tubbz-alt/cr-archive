<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.net.http/share/classes/jdk/internal/net/http/common/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SubscriberWrapper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../websocket/OpeningHandshake.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.net.http/share/classes/jdk/internal/net/http/common/Utils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.net.http.common;
  27 
  28 import sun.net.NetProperties;
  29 import sun.net.util.IPAddressUtil;
  30 import sun.net.www.HeaderParser;
  31 
  32 import javax.net.ssl.ExtendedSSLSession;
  33 import javax.net.ssl.SSLException;
  34 import javax.net.ssl.SSLHandshakeException;
  35 import javax.net.ssl.SSLParameters;
  36 import javax.net.ssl.SSLSession;
  37 import java.io.ByteArrayOutputStream;
  38 import java.io.Closeable;
  39 import java.io.IOException;
  40 import java.io.PrintStream;
  41 import java.io.UncheckedIOException;
<span class="line-removed">  42 import java.io.UnsupportedEncodingException;</span>
  43 import java.lang.System.Logger.Level;
  44 import java.net.ConnectException;
  45 import java.net.InetSocketAddress;
  46 import java.net.URI;
  47 import java.net.URLPermission;
  48 import java.net.http.HttpClient;
  49 import java.net.http.HttpHeaders;
  50 import java.net.http.HttpTimeoutException;
  51 import java.nio.ByteBuffer;
  52 import java.nio.CharBuffer;
  53 import java.nio.charset.CharacterCodingException;
  54 import java.nio.charset.Charset;
  55 import java.nio.charset.CodingErrorAction;
  56 import java.nio.charset.StandardCharsets;
  57 import java.security.AccessController;
  58 import java.security.PrivilegedAction;
  59 import java.text.Normalizer;
  60 import java.util.Arrays;
  61 import java.util.Collection;
  62 import java.util.Collections;
  63 import java.util.List;
  64 import java.util.Set;
  65 import java.util.TreeSet;
  66 import java.util.concurrent.CompletableFuture;
  67 import java.util.concurrent.CompletionException;
  68 import java.util.concurrent.ExecutionException;
  69 import java.util.function.BiPredicate;
  70 import java.util.function.Function;
  71 import java.util.function.Predicate;
  72 import java.util.function.Supplier;
  73 import java.util.stream.Collectors;
  74 import java.util.stream.Stream;
  75 
  76 import static java.lang.String.format;

  77 import static java.util.stream.Collectors.joining;
  78 import jdk.internal.net.http.HttpRequestImpl;
  79 
  80 /**
  81  * Miscellaneous utilities
  82  */
  83 public final class Utils {
  84 
  85     public static final boolean ASSERTIONSENABLED;
  86 
  87     static {
  88         boolean enabled = false;
  89         assert enabled = true;
  90         ASSERTIONSENABLED = enabled;
  91     }
  92 
  93 //    public static final boolean TESTING;
  94 //    static {
  95 //        if (ASSERTIONSENABLED) {
  96 //            PrivilegedAction&lt;String&gt; action = () -&gt; System.getProperty(&quot;test.src&quot;);
</pre>
<hr />
<pre>
 161                     throw newIAE(&quot;restricted header name: \&quot;%s\&quot;&quot;, name);
 162                 }
 163                 if (!isValidValue(value)) {
 164                     throw newIAE(&quot;invalid header value for %s: \&quot;%s\&quot;&quot;, name, value);
 165                 }
 166                 return true;
 167             };
 168 
 169     // Headers that are not generally restricted, and can therefore be set by users,
 170     // but can in some contexts be overridden by the implementation.
 171     // Currently, only contains &quot;Authorization&quot; which will
 172     // be overridden, when an Authenticator is set on the HttpClient.
 173     // Needs to be BiPred&lt;String,String&gt; to fit with general form of predicates
 174     // used by caller.
 175 
 176     public static final BiPredicate&lt;String, String&gt; CONTEXT_RESTRICTED(HttpClient client) {
 177         return (k, v) -&gt; client.authenticator() == null ||
 178                 ! (k.equalsIgnoreCase(&quot;Authorization&quot;)
 179                         &amp;&amp; k.equalsIgnoreCase(&quot;Proxy-Authorization&quot;));
 180     }




 181 

 182     private static final Predicate&lt;String&gt; IS_PROXY_HEADER = (k) -&gt;
 183             k != null &amp;&amp; k.length() &gt; 6 &amp;&amp; &quot;proxy-&quot;.equalsIgnoreCase(k.substring(0,6));
 184     private static final Predicate&lt;String&gt; NO_PROXY_HEADER =
 185             IS_PROXY_HEADER.negate();
 186     private static final Predicate&lt;String&gt; ALL_HEADERS = (s) -&gt; true;
 187 
 188     private static final Set&lt;String&gt; PROXY_AUTH_DISABLED_SCHEMES;
 189     private static final Set&lt;String&gt; PROXY_AUTH_TUNNEL_DISABLED_SCHEMES;
 190     static {
 191         String proxyAuthDisabled =
 192                 getNetProperty(&quot;jdk.http.auth.proxying.disabledSchemes&quot;);
 193         String proxyAuthTunnelDisabled =
 194                 getNetProperty(&quot;jdk.http.auth.tunneling.disabledSchemes&quot;);
 195         PROXY_AUTH_DISABLED_SCHEMES =
 196                 proxyAuthDisabled == null ? Set.of() :
 197                         Stream.of(proxyAuthDisabled.split(&quot;,&quot;))
 198                                 .map(String::trim)
 199                                 .filter((s) -&gt; !s.isEmpty())
 200                                 .collect(Collectors.toUnmodifiableSet());
 201         PROXY_AUTH_TUNNEL_DISABLED_SCHEMES =
</pre>
<hr />
<pre>
 233                     if (value.equalsIgnoreCase(scheme)) {
 234                         return false;
 235                     }
 236                 } else if (vlen &gt; slen) {
 237                     if (value.substring(0,slen).equalsIgnoreCase(scheme)) {
 238                         int c = value.codePointAt(slen);
 239                         if (WSPACES.indexOf(c) &gt; -1
 240                                 || Character.isSpaceChar(c)
 241                                 || Character.isWhitespace(c)) {
 242                             return false;
 243                         }
 244                     }
 245                 }
 246             }
 247         }
 248         return true;
 249     }
 250 
 251     public static final BiPredicate&lt;String, String&gt; PROXY_TUNNEL_FILTER =
 252             (s,v) -&gt; isAllowedForProxy(s, v, PROXY_AUTH_TUNNEL_DISABLED_SCHEMES,
<span class="line-modified"> 253                     IS_PROXY_HEADER);</span>

 254     public static final BiPredicate&lt;String, String&gt; PROXY_FILTER =
 255             (s,v) -&gt; isAllowedForProxy(s, v, PROXY_AUTH_DISABLED_SCHEMES,
 256                     ALL_HEADERS);
 257     public static final BiPredicate&lt;String, String&gt; NO_PROXY_HEADERS_FILTER =
 258             (n,v) -&gt; Utils.NO_PROXY_HEADER.test(n);
 259 
 260 
 261     public static boolean proxyHasDisabledSchemes(boolean tunnel) {
 262         return tunnel ? ! PROXY_AUTH_TUNNEL_DISABLED_SCHEMES.isEmpty()
 263                       : ! PROXY_AUTH_DISABLED_SCHEMES.isEmpty();
 264     }
 265 
 266     // WebSocket connection Upgrade headers
 267     private static final String HEADER_CONNECTION = &quot;Connection&quot;;
 268     private static final String HEADER_UPGRADE    = &quot;Upgrade&quot;;
 269 
 270     public static final void setWebSocketUpgradeHeaders(HttpRequestImpl request) {
 271         request.setSystemHeader(HEADER_UPGRADE, &quot;websocket&quot;);
 272         request.setSystemHeader(HEADER_CONNECTION, &quot;Upgrade&quot;);
 273     }
</pre>
<hr />
<pre>
 515         if (protocols != null) {
 516             p1.setProtocols(protocols.clone());
 517         }
 518         p1.setSNIMatchers(p.getSNIMatchers());
 519         p1.setServerNames(p.getServerNames());
 520         p1.setUseCipherSuitesOrder(p.getUseCipherSuitesOrder());
 521         p1.setWantClientAuth(p.getWantClientAuth());
 522         return p1;
 523     }
 524 
 525     /**
 526      * Set limit to position, and position to mark.
 527      */
 528     public static void flipToMark(ByteBuffer buffer, int mark) {
 529         buffer.limit(buffer.position());
 530         buffer.position(mark);
 531     }
 532 
 533     public static String stackTrace(Throwable t) {
 534         ByteArrayOutputStream bos = new ByteArrayOutputStream();
<span class="line-modified"> 535         String s = null;</span>
<span class="line-modified"> 536         try {</span>
<span class="line-modified"> 537             PrintStream p = new PrintStream(bos, true, &quot;US-ASCII&quot;);</span>
<span class="line-removed"> 538             t.printStackTrace(p);</span>
<span class="line-removed"> 539             s = bos.toString(&quot;US-ASCII&quot;);</span>
<span class="line-removed"> 540         } catch (UnsupportedEncodingException ex) {</span>
<span class="line-removed"> 541             throw new InternalError(ex); // Can&#39;t happen</span>
<span class="line-removed"> 542         }</span>
<span class="line-removed"> 543         return s;</span>
 544     }
 545 
 546     /**
 547      * Copies as much of src to dst as possible.
 548      * Return number of bytes copied
 549      */
 550     public static int copy(ByteBuffer src, ByteBuffer dst) {
 551         int srcLen = src.remaining();
 552         int dstLen = dst.remaining();
 553         if (srcLen &gt; dstLen) {
 554             int diff = srcLen - dstLen;
 555             int limit = src.limit();
 556             src.limit(limit - diff);
 557             dst.put(src);
 558             src.limit(limit);
 559         } else {
 560             dst.put(src);
 561         }
 562         return srcLen - src.remaining();
 563     }
</pre>
</td>
<td>
<hr />
<pre>
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.net.http.common;
  27 
  28 import sun.net.NetProperties;
  29 import sun.net.util.IPAddressUtil;
  30 import sun.net.www.HeaderParser;
  31 
  32 import javax.net.ssl.ExtendedSSLSession;
  33 import javax.net.ssl.SSLException;
  34 import javax.net.ssl.SSLHandshakeException;
  35 import javax.net.ssl.SSLParameters;
  36 import javax.net.ssl.SSLSession;
  37 import java.io.ByteArrayOutputStream;
  38 import java.io.Closeable;
  39 import java.io.IOException;
  40 import java.io.PrintStream;
  41 import java.io.UncheckedIOException;

  42 import java.lang.System.Logger.Level;
  43 import java.net.ConnectException;
  44 import java.net.InetSocketAddress;
  45 import java.net.URI;
  46 import java.net.URLPermission;
  47 import java.net.http.HttpClient;
  48 import java.net.http.HttpHeaders;
  49 import java.net.http.HttpTimeoutException;
  50 import java.nio.ByteBuffer;
  51 import java.nio.CharBuffer;
  52 import java.nio.charset.CharacterCodingException;
  53 import java.nio.charset.Charset;
  54 import java.nio.charset.CodingErrorAction;
  55 import java.nio.charset.StandardCharsets;
  56 import java.security.AccessController;
  57 import java.security.PrivilegedAction;
  58 import java.text.Normalizer;
  59 import java.util.Arrays;
  60 import java.util.Collection;
  61 import java.util.Collections;
  62 import java.util.List;
  63 import java.util.Set;
  64 import java.util.TreeSet;
  65 import java.util.concurrent.CompletableFuture;
  66 import java.util.concurrent.CompletionException;
  67 import java.util.concurrent.ExecutionException;
  68 import java.util.function.BiPredicate;
  69 import java.util.function.Function;
  70 import java.util.function.Predicate;
  71 import java.util.function.Supplier;
  72 import java.util.stream.Collectors;
  73 import java.util.stream.Stream;
  74 
  75 import static java.lang.String.format;
<span class="line-added">  76 import static java.nio.charset.StandardCharsets.US_ASCII;</span>
  77 import static java.util.stream.Collectors.joining;
  78 import jdk.internal.net.http.HttpRequestImpl;
  79 
  80 /**
  81  * Miscellaneous utilities
  82  */
  83 public final class Utils {
  84 
  85     public static final boolean ASSERTIONSENABLED;
  86 
  87     static {
  88         boolean enabled = false;
  89         assert enabled = true;
  90         ASSERTIONSENABLED = enabled;
  91     }
  92 
  93 //    public static final boolean TESTING;
  94 //    static {
  95 //        if (ASSERTIONSENABLED) {
  96 //            PrivilegedAction&lt;String&gt; action = () -&gt; System.getProperty(&quot;test.src&quot;);
</pre>
<hr />
<pre>
 161                     throw newIAE(&quot;restricted header name: \&quot;%s\&quot;&quot;, name);
 162                 }
 163                 if (!isValidValue(value)) {
 164                     throw newIAE(&quot;invalid header value for %s: \&quot;%s\&quot;&quot;, name, value);
 165                 }
 166                 return true;
 167             };
 168 
 169     // Headers that are not generally restricted, and can therefore be set by users,
 170     // but can in some contexts be overridden by the implementation.
 171     // Currently, only contains &quot;Authorization&quot; which will
 172     // be overridden, when an Authenticator is set on the HttpClient.
 173     // Needs to be BiPred&lt;String,String&gt; to fit with general form of predicates
 174     // used by caller.
 175 
 176     public static final BiPredicate&lt;String, String&gt; CONTEXT_RESTRICTED(HttpClient client) {
 177         return (k, v) -&gt; client.authenticator() == null ||
 178                 ! (k.equalsIgnoreCase(&quot;Authorization&quot;)
 179                         &amp;&amp; k.equalsIgnoreCase(&quot;Proxy-Authorization&quot;));
 180     }
<span class="line-added"> 181     private static final BiPredicate&lt;String, String&gt; HOST_RESTRICTED = (k,v) -&gt; !&quot;host&quot;.equalsIgnoreCase(k);</span>
<span class="line-added"> 182     public static final BiPredicate&lt;String, String&gt; PROXY_TUNNEL_RESTRICTED(HttpClient client)  {</span>
<span class="line-added"> 183         return CONTEXT_RESTRICTED(client).and(HOST_RESTRICTED);</span>
<span class="line-added"> 184     }</span>
 185 
<span class="line-added"> 186     private static final Predicate&lt;String&gt; IS_HOST = &quot;host&quot;::equalsIgnoreCase;</span>
 187     private static final Predicate&lt;String&gt; IS_PROXY_HEADER = (k) -&gt;
 188             k != null &amp;&amp; k.length() &gt; 6 &amp;&amp; &quot;proxy-&quot;.equalsIgnoreCase(k.substring(0,6));
 189     private static final Predicate&lt;String&gt; NO_PROXY_HEADER =
 190             IS_PROXY_HEADER.negate();
 191     private static final Predicate&lt;String&gt; ALL_HEADERS = (s) -&gt; true;
 192 
 193     private static final Set&lt;String&gt; PROXY_AUTH_DISABLED_SCHEMES;
 194     private static final Set&lt;String&gt; PROXY_AUTH_TUNNEL_DISABLED_SCHEMES;
 195     static {
 196         String proxyAuthDisabled =
 197                 getNetProperty(&quot;jdk.http.auth.proxying.disabledSchemes&quot;);
 198         String proxyAuthTunnelDisabled =
 199                 getNetProperty(&quot;jdk.http.auth.tunneling.disabledSchemes&quot;);
 200         PROXY_AUTH_DISABLED_SCHEMES =
 201                 proxyAuthDisabled == null ? Set.of() :
 202                         Stream.of(proxyAuthDisabled.split(&quot;,&quot;))
 203                                 .map(String::trim)
 204                                 .filter((s) -&gt; !s.isEmpty())
 205                                 .collect(Collectors.toUnmodifiableSet());
 206         PROXY_AUTH_TUNNEL_DISABLED_SCHEMES =
</pre>
<hr />
<pre>
 238                     if (value.equalsIgnoreCase(scheme)) {
 239                         return false;
 240                     }
 241                 } else if (vlen &gt; slen) {
 242                     if (value.substring(0,slen).equalsIgnoreCase(scheme)) {
 243                         int c = value.codePointAt(slen);
 244                         if (WSPACES.indexOf(c) &gt; -1
 245                                 || Character.isSpaceChar(c)
 246                                 || Character.isWhitespace(c)) {
 247                             return false;
 248                         }
 249                     }
 250                 }
 251             }
 252         }
 253         return true;
 254     }
 255 
 256     public static final BiPredicate&lt;String, String&gt; PROXY_TUNNEL_FILTER =
 257             (s,v) -&gt; isAllowedForProxy(s, v, PROXY_AUTH_TUNNEL_DISABLED_SCHEMES,
<span class="line-modified"> 258                     // Allows Proxy-* and Host headers when establishing the tunnel.</span>
<span class="line-added"> 259                     IS_PROXY_HEADER.or(IS_HOST));</span>
 260     public static final BiPredicate&lt;String, String&gt; PROXY_FILTER =
 261             (s,v) -&gt; isAllowedForProxy(s, v, PROXY_AUTH_DISABLED_SCHEMES,
 262                     ALL_HEADERS);
 263     public static final BiPredicate&lt;String, String&gt; NO_PROXY_HEADERS_FILTER =
 264             (n,v) -&gt; Utils.NO_PROXY_HEADER.test(n);
 265 
 266 
 267     public static boolean proxyHasDisabledSchemes(boolean tunnel) {
 268         return tunnel ? ! PROXY_AUTH_TUNNEL_DISABLED_SCHEMES.isEmpty()
 269                       : ! PROXY_AUTH_DISABLED_SCHEMES.isEmpty();
 270     }
 271 
 272     // WebSocket connection Upgrade headers
 273     private static final String HEADER_CONNECTION = &quot;Connection&quot;;
 274     private static final String HEADER_UPGRADE    = &quot;Upgrade&quot;;
 275 
 276     public static final void setWebSocketUpgradeHeaders(HttpRequestImpl request) {
 277         request.setSystemHeader(HEADER_UPGRADE, &quot;websocket&quot;);
 278         request.setSystemHeader(HEADER_CONNECTION, &quot;Upgrade&quot;);
 279     }
</pre>
<hr />
<pre>
 521         if (protocols != null) {
 522             p1.setProtocols(protocols.clone());
 523         }
 524         p1.setSNIMatchers(p.getSNIMatchers());
 525         p1.setServerNames(p.getServerNames());
 526         p1.setUseCipherSuitesOrder(p.getUseCipherSuitesOrder());
 527         p1.setWantClientAuth(p.getWantClientAuth());
 528         return p1;
 529     }
 530 
 531     /**
 532      * Set limit to position, and position to mark.
 533      */
 534     public static void flipToMark(ByteBuffer buffer, int mark) {
 535         buffer.limit(buffer.position());
 536         buffer.position(mark);
 537     }
 538 
 539     public static String stackTrace(Throwable t) {
 540         ByteArrayOutputStream bos = new ByteArrayOutputStream();
<span class="line-modified"> 541         PrintStream p = new PrintStream(bos, true, US_ASCII);</span>
<span class="line-modified"> 542         t.printStackTrace(p);</span>
<span class="line-modified"> 543         return bos.toString(US_ASCII);</span>






 544     }
 545 
 546     /**
 547      * Copies as much of src to dst as possible.
 548      * Return number of bytes copied
 549      */
 550     public static int copy(ByteBuffer src, ByteBuffer dst) {
 551         int srcLen = src.remaining();
 552         int dstLen = dst.remaining();
 553         if (srcLen &gt; dstLen) {
 554             int diff = srcLen - dstLen;
 555             int limit = src.limit();
 556             src.limit(limit - diff);
 557             dst.put(src);
 558             src.limit(limit);
 559         } else {
 560             dst.put(src);
 561         }
 562         return srcLen - src.remaining();
 563     }
</pre>
</td>
</tr>
</table>
<center><a href="SubscriberWrapper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../websocket/OpeningHandshake.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
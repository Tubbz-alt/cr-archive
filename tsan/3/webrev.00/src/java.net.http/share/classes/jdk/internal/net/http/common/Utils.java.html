<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.net.http/share/classes/jdk/internal/net/http/common/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.net.http.common;
  27 
  28 import sun.net.NetProperties;
  29 import sun.net.util.IPAddressUtil;
  30 import sun.net.www.HeaderParser;
  31 
  32 import javax.net.ssl.ExtendedSSLSession;
  33 import javax.net.ssl.SSLException;
  34 import javax.net.ssl.SSLHandshakeException;
  35 import javax.net.ssl.SSLParameters;
  36 import javax.net.ssl.SSLSession;
  37 import java.io.ByteArrayOutputStream;
  38 import java.io.Closeable;
  39 import java.io.IOException;
  40 import java.io.PrintStream;
  41 import java.io.UncheckedIOException;
  42 import java.lang.System.Logger.Level;
  43 import java.net.ConnectException;
  44 import java.net.InetSocketAddress;
  45 import java.net.URI;
  46 import java.net.URLPermission;
  47 import java.net.http.HttpClient;
  48 import java.net.http.HttpHeaders;
  49 import java.net.http.HttpTimeoutException;
  50 import java.nio.ByteBuffer;
  51 import java.nio.CharBuffer;
  52 import java.nio.charset.CharacterCodingException;
  53 import java.nio.charset.Charset;
  54 import java.nio.charset.CodingErrorAction;
  55 import java.nio.charset.StandardCharsets;
  56 import java.security.AccessController;
  57 import java.security.PrivilegedAction;
  58 import java.text.Normalizer;
  59 import java.util.Arrays;
  60 import java.util.Collection;
  61 import java.util.Collections;
  62 import java.util.List;
  63 import java.util.Set;
  64 import java.util.TreeSet;
  65 import java.util.concurrent.CompletableFuture;
  66 import java.util.concurrent.CompletionException;
  67 import java.util.concurrent.ExecutionException;
  68 import java.util.function.BiPredicate;
  69 import java.util.function.Function;
  70 import java.util.function.Predicate;
  71 import java.util.function.Supplier;
  72 import java.util.stream.Collectors;
  73 import java.util.stream.Stream;
  74 
  75 import static java.lang.String.format;
  76 import static java.nio.charset.StandardCharsets.US_ASCII;
  77 import static java.util.stream.Collectors.joining;
  78 import jdk.internal.net.http.HttpRequestImpl;
  79 
  80 /**
  81  * Miscellaneous utilities
  82  */
  83 public final class Utils {
  84 
  85     public static final boolean ASSERTIONSENABLED;
  86 
  87     static {
  88         boolean enabled = false;
  89         assert enabled = true;
  90         ASSERTIONSENABLED = enabled;
  91     }
  92 
  93 //    public static final boolean TESTING;
  94 //    static {
  95 //        if (ASSERTIONSENABLED) {
  96 //            PrivilegedAction&lt;String&gt; action = () -&gt; System.getProperty(&quot;test.src&quot;);
  97 //            TESTING = AccessController.doPrivileged(action) != null;
  98 //        } else TESTING = false;
  99 //    }
 100     public static final boolean DEBUG = // Revisit: temporary dev flag.
 101             getBooleanProperty(DebugLogger.HTTP_NAME, false);
 102     public static final boolean DEBUG_WS = // Revisit: temporary dev flag.
 103             getBooleanProperty(DebugLogger.WS_NAME, false);
 104     public static final boolean DEBUG_HPACK = // Revisit: temporary dev flag.
 105             getBooleanProperty(DebugLogger.HPACK_NAME, false);
 106     public static final boolean TESTING = DEBUG;
 107 
 108     public static final boolean isHostnameVerificationDisabled = // enabled by default
 109             hostnameVerificationDisabledValue();
 110 
 111     private static boolean hostnameVerificationDisabledValue() {
 112         String prop = getProperty(&quot;jdk.internal.httpclient.disableHostnameVerification&quot;);
 113         if (prop == null)
 114             return false;
 115         return prop.isEmpty() ? true : Boolean.parseBoolean(prop);
 116     }
 117 
 118     /**
 119      * Allocated buffer size. Must never be higher than 16K. But can be lower
 120      * if smaller allocation units preferred. HTTP/2 mandates that all
 121      * implementations support frame payloads of at least 16K.
 122      */
 123     private static final int DEFAULT_BUFSIZE = 16 * 1024;
 124 
 125     public static final int BUFSIZE = getIntegerNetProperty(
 126             &quot;jdk.httpclient.bufsize&quot;, DEFAULT_BUFSIZE
 127     );
 128 
 129     public static final BiPredicate&lt;String,String&gt; ACCEPT_ALL = (x,y) -&gt; true;
 130 
 131     private static final Set&lt;String&gt; DISALLOWED_HEADERS_SET = getDisallowedHeaders();
 132 
 133     private static Set&lt;String&gt; getDisallowedHeaders() {
 134         Set&lt;String&gt; headers = new TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);
 135         headers.addAll(Set.of(&quot;connection&quot;, &quot;content-length&quot;, &quot;expect&quot;, &quot;host&quot;, &quot;upgrade&quot;));
 136 
 137         String v = getNetProperty(&quot;jdk.httpclient.allowRestrictedHeaders&quot;);
 138         if (v != null) {
 139             // any headers found are removed from set.
 140             String[] tokens = v.trim().split(&quot;,&quot;);
 141             for (String token : tokens) {
 142                 headers.remove(token);
 143             }
 144             return Collections.unmodifiableSet(headers);
 145         } else {
 146             return Collections.unmodifiableSet(headers);
 147         }
 148     }
 149 
 150     public static final BiPredicate&lt;String, String&gt;
 151             ALLOWED_HEADERS = (header, unused) -&gt; !DISALLOWED_HEADERS_SET.contains(header);
 152 
 153     public static final BiPredicate&lt;String, String&gt; VALIDATE_USER_HEADER =
 154             (name, value) -&gt; {
 155                 assert name != null : &quot;null header name&quot;;
 156                 assert value != null : &quot;null header value&quot;;
 157                 if (!isValidName(name)) {
 158                     throw newIAE(&quot;invalid header name: \&quot;%s\&quot;&quot;, name);
 159                 }
 160                 if (!Utils.ALLOWED_HEADERS.test(name, null)) {
 161                     throw newIAE(&quot;restricted header name: \&quot;%s\&quot;&quot;, name);
 162                 }
 163                 if (!isValidValue(value)) {
 164                     throw newIAE(&quot;invalid header value for %s: \&quot;%s\&quot;&quot;, name, value);
 165                 }
 166                 return true;
 167             };
 168 
 169     // Headers that are not generally restricted, and can therefore be set by users,
 170     // but can in some contexts be overridden by the implementation.
 171     // Currently, only contains &quot;Authorization&quot; which will
 172     // be overridden, when an Authenticator is set on the HttpClient.
 173     // Needs to be BiPred&lt;String,String&gt; to fit with general form of predicates
 174     // used by caller.
 175 
 176     public static final BiPredicate&lt;String, String&gt; CONTEXT_RESTRICTED(HttpClient client) {
 177         return (k, v) -&gt; client.authenticator() == null ||
 178                 ! (k.equalsIgnoreCase(&quot;Authorization&quot;)
 179                         &amp;&amp; k.equalsIgnoreCase(&quot;Proxy-Authorization&quot;));
 180     }
 181     private static final BiPredicate&lt;String, String&gt; HOST_RESTRICTED = (k,v) -&gt; !&quot;host&quot;.equalsIgnoreCase(k);
 182     public static final BiPredicate&lt;String, String&gt; PROXY_TUNNEL_RESTRICTED(HttpClient client)  {
 183         return CONTEXT_RESTRICTED(client).and(HOST_RESTRICTED);
 184     }
 185 
 186     private static final Predicate&lt;String&gt; IS_HOST = &quot;host&quot;::equalsIgnoreCase;
 187     private static final Predicate&lt;String&gt; IS_PROXY_HEADER = (k) -&gt;
 188             k != null &amp;&amp; k.length() &gt; 6 &amp;&amp; &quot;proxy-&quot;.equalsIgnoreCase(k.substring(0,6));
 189     private static final Predicate&lt;String&gt; NO_PROXY_HEADER =
 190             IS_PROXY_HEADER.negate();
 191     private static final Predicate&lt;String&gt; ALL_HEADERS = (s) -&gt; true;
 192 
 193     private static final Set&lt;String&gt; PROXY_AUTH_DISABLED_SCHEMES;
 194     private static final Set&lt;String&gt; PROXY_AUTH_TUNNEL_DISABLED_SCHEMES;
 195     static {
 196         String proxyAuthDisabled =
 197                 getNetProperty(&quot;jdk.http.auth.proxying.disabledSchemes&quot;);
 198         String proxyAuthTunnelDisabled =
 199                 getNetProperty(&quot;jdk.http.auth.tunneling.disabledSchemes&quot;);
 200         PROXY_AUTH_DISABLED_SCHEMES =
 201                 proxyAuthDisabled == null ? Set.of() :
 202                         Stream.of(proxyAuthDisabled.split(&quot;,&quot;))
 203                                 .map(String::trim)
 204                                 .filter((s) -&gt; !s.isEmpty())
 205                                 .collect(Collectors.toUnmodifiableSet());
 206         PROXY_AUTH_TUNNEL_DISABLED_SCHEMES =
 207                 proxyAuthTunnelDisabled == null ? Set.of() :
 208                         Stream.of(proxyAuthTunnelDisabled.split(&quot;,&quot;))
 209                                 .map(String::trim)
 210                                 .filter((s) -&gt; !s.isEmpty())
 211                                 .collect(Collectors.toUnmodifiableSet());
 212     }
 213 
 214     public static &lt;T&gt; CompletableFuture&lt;T&gt; wrapForDebug(Logger logger, String name, CompletableFuture&lt;T&gt; cf) {
 215         if (logger.on()) {
 216             return cf.handle((r,t) -&gt; {
 217                 logger.log(&quot;%s completed %s&quot;, name, t == null ? &quot;successfully&quot; : t );
 218                 return cf;
 219             }).thenCompose(Function.identity());
 220         } else {
 221             return cf;
 222         }
 223     }
 224 
 225     private static final String WSPACES = &quot; \t\r\n&quot;;
 226     private static final boolean isAllowedForProxy(String name,
 227                                                    String value,
 228                                                    Set&lt;String&gt; disabledSchemes,
 229                                                    Predicate&lt;String&gt; allowedKeys) {
 230         if (!allowedKeys.test(name)) return false;
 231         if (disabledSchemes.isEmpty()) return true;
 232         if (name.equalsIgnoreCase(&quot;proxy-authorization&quot;)) {
 233             if (value.isEmpty()) return false;
 234             for (String scheme : disabledSchemes) {
 235                 int slen = scheme.length();
 236                 int vlen = value.length();
 237                 if (vlen == slen) {
 238                     if (value.equalsIgnoreCase(scheme)) {
 239                         return false;
 240                     }
 241                 } else if (vlen &gt; slen) {
 242                     if (value.substring(0,slen).equalsIgnoreCase(scheme)) {
 243                         int c = value.codePointAt(slen);
 244                         if (WSPACES.indexOf(c) &gt; -1
 245                                 || Character.isSpaceChar(c)
 246                                 || Character.isWhitespace(c)) {
 247                             return false;
 248                         }
 249                     }
 250                 }
 251             }
 252         }
 253         return true;
 254     }
 255 
 256     public static final BiPredicate&lt;String, String&gt; PROXY_TUNNEL_FILTER =
 257             (s,v) -&gt; isAllowedForProxy(s, v, PROXY_AUTH_TUNNEL_DISABLED_SCHEMES,
 258                     // Allows Proxy-* and Host headers when establishing the tunnel.
 259                     IS_PROXY_HEADER.or(IS_HOST));
 260     public static final BiPredicate&lt;String, String&gt; PROXY_FILTER =
 261             (s,v) -&gt; isAllowedForProxy(s, v, PROXY_AUTH_DISABLED_SCHEMES,
 262                     ALL_HEADERS);
 263     public static final BiPredicate&lt;String, String&gt; NO_PROXY_HEADERS_FILTER =
 264             (n,v) -&gt; Utils.NO_PROXY_HEADER.test(n);
 265 
 266 
 267     public static boolean proxyHasDisabledSchemes(boolean tunnel) {
 268         return tunnel ? ! PROXY_AUTH_TUNNEL_DISABLED_SCHEMES.isEmpty()
 269                       : ! PROXY_AUTH_DISABLED_SCHEMES.isEmpty();
 270     }
 271 
 272     // WebSocket connection Upgrade headers
 273     private static final String HEADER_CONNECTION = &quot;Connection&quot;;
 274     private static final String HEADER_UPGRADE    = &quot;Upgrade&quot;;
 275 
 276     public static final void setWebSocketUpgradeHeaders(HttpRequestImpl request) {
 277         request.setSystemHeader(HEADER_UPGRADE, &quot;websocket&quot;);
 278         request.setSystemHeader(HEADER_CONNECTION, &quot;Upgrade&quot;);
 279     }
 280 
 281     public static IllegalArgumentException newIAE(String message, Object... args) {
 282         return new IllegalArgumentException(format(message, args));
 283     }
 284     public static ByteBuffer getBuffer() {
 285         return ByteBuffer.allocate(BUFSIZE);
 286     }
 287 
 288     public static Throwable getCompletionCause(Throwable x) {
 289         if (!(x instanceof CompletionException)
 290                 &amp;&amp; !(x instanceof ExecutionException)) return x;
 291         final Throwable cause = x.getCause();
 292         if (cause == null) {
 293             throw new InternalError(&quot;Unexpected null cause&quot;, x);
 294         }
 295         return cause;
 296     }
 297 
 298     public static IOException getIOException(Throwable t) {
 299         if (t instanceof IOException) {
 300             return (IOException) t;
 301         }
 302         Throwable cause = t.getCause();
 303         if (cause != null) {
 304             return getIOException(cause);
 305         }
 306         return new IOException(t);
 307     }
 308 
 309     /**
 310      * Adds a more specific exception detail message, based on the given
 311      * exception type and the message supplier. This is primarily to present
 312      * more descriptive messages in IOExceptions that may be visible to calling
 313      * code.
 314      *
 315      * @return a possibly new exception that has as its detail message, the
 316      *         message from the messageSupplier, and the given throwable as its
 317      *         cause. Otherwise returns the given throwable
 318      */
 319     public static Throwable wrapWithExtraDetail(Throwable t,
 320                                                 Supplier&lt;String&gt; messageSupplier) {
 321         if (!(t instanceof IOException))
 322             return t;
 323 
 324         if (t instanceof SSLHandshakeException)
 325             return t;  // no need to decorate
 326 
 327         String msg = messageSupplier.get();
 328         if (msg == null)
 329             return t;
 330 
 331         if (t instanceof ConnectionExpiredException) {
 332             if (t.getCause() instanceof SSLHandshakeException)
 333                 return t;  // no need to decorate
 334             IOException ioe = new IOException(msg, t.getCause());
 335             t = new ConnectionExpiredException(ioe);
 336         } else {
 337             IOException ioe = new IOException(msg, t);
 338             t = ioe;
 339         }
 340         return t;
 341     }
 342 
 343     private Utils() { }
 344 
 345     /**
 346      * Returns the security permissions required to connect to the proxy, or
 347      * {@code null} if none is required or applicable.
 348      */
 349     public static URLPermission permissionForProxy(InetSocketAddress proxyAddress) {
 350         if (proxyAddress == null)
 351             return null;
 352 
 353         StringBuilder sb = new StringBuilder();
 354         sb.append(&quot;socket://&quot;)
 355           .append(proxyAddress.getHostString()).append(&quot;:&quot;)
 356           .append(proxyAddress.getPort());
 357         String urlString = sb.toString();
 358         return new URLPermission(urlString, &quot;CONNECT&quot;);
 359     }
 360 
 361     /**
 362      * Returns the security permission required for the given details.
 363      */
 364     public static URLPermission permissionForServer(URI uri,
 365                                                     String method,
 366                                                     Stream&lt;String&gt; headers) {
 367         String urlString = new StringBuilder()
 368                 .append(uri.getScheme()).append(&quot;://&quot;)
 369                 .append(uri.getRawAuthority())
 370                 .append(uri.getRawPath()).toString();
 371 
 372         StringBuilder actionStringBuilder = new StringBuilder(method);
 373         String collected = headers.collect(joining(&quot;,&quot;));
 374         if (!collected.isEmpty()) {
 375             actionStringBuilder.append(&quot;:&quot;).append(collected);
 376         }
 377         return new URLPermission(urlString, actionStringBuilder.toString());
 378     }
 379 
 380 
 381     // ABNF primitives defined in RFC 7230
 382     private static final boolean[] tchar      = new boolean[256];
 383     private static final boolean[] fieldvchar = new boolean[256];
 384 
 385     static {
 386         char[] allowedTokenChars =
 387                 (&quot;!#$%&amp;&#39;*+-.^_`|~0123456789&quot; +
 388                  &quot;abcdefghijklmnopqrstuvwxyz&quot; +
 389                  &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;).toCharArray();
 390         for (char c : allowedTokenChars) {
 391             tchar[c] = true;
 392         }
 393         for (char c = 0x21; c &lt; 0xFF; c++) {
 394             fieldvchar[c] = true;
 395         }
 396         fieldvchar[0x7F] = false; // a little hole (DEL) in the range
 397     }
 398 
 399     /*
 400      * Validates a RFC 7230 field-name.
 401      */
 402     public static boolean isValidName(String token) {
 403         for (int i = 0; i &lt; token.length(); i++) {
 404             char c = token.charAt(i);
 405             if (c &gt; 255 || !tchar[c]) {
 406                 return false;
 407             }
 408         }
 409         return !token.isEmpty();
 410     }
 411 
 412     public static class ServerName {
 413         ServerName(String name, boolean isLiteral) {
 414             this.name = name;
 415             this.isLiteral = isLiteral;
 416         }
 417 
 418         final String name;
 419         final boolean isLiteral;
 420 
 421         public String getName() {
 422             return name;
 423         }
 424 
 425         public boolean isLiteral() {
 426             return isLiteral;
 427         }
 428     }
 429 
 430     /**
 431      * Analyse the given address and determine if it is literal or not,
 432      * returning the address in String form.
 433      */
 434     public static ServerName getServerName(InetSocketAddress addr) {
 435         String host = addr.getHostString();
 436         byte[] literal = IPAddressUtil.textToNumericFormatV4(host);
 437         if (literal == null) {
 438             // not IPv4 literal. Check IPv6
 439             literal = IPAddressUtil.textToNumericFormatV6(host);
 440             return new ServerName(host, literal != null);
 441         } else {
 442             return new ServerName(host, true);
 443         }
 444     }
 445 
 446     private static boolean isLoopbackLiteral(byte[] bytes) {
 447         if (bytes.length == 4) {
 448             return bytes[0] == 127;
 449         } else if (bytes.length == 16) {
 450             for (int i=0; i&lt;14; i++)
 451                 if (bytes[i] != 0)
 452                     return false;
 453             if (bytes[15] != 1)
 454                 return false;
 455             return true;
 456         } else
 457             throw new InternalError();
 458     }
 459 
 460     /*
 461      * Validates a RFC 7230 field-value.
 462      *
 463      * &quot;Obsolete line folding&quot; rule
 464      *
 465      *     obs-fold = CRLF 1*( SP / HTAB )
 466      *
 467      * is not permitted!
 468      */
 469     public static boolean isValidValue(String token) {
 470         for (int i = 0; i &lt; token.length(); i++) {
 471             char c = token.charAt(i);
 472             if (c &gt; 255) {
 473                 return false;
 474             }
 475             if (c == &#39; &#39; || c == &#39;\t&#39;) {
 476                 continue;
 477             } else if (!fieldvchar[c]) {
 478                 return false; // forbidden byte
 479             }
 480         }
 481         return true;
 482     }
 483 
 484 
 485     public static int getIntegerNetProperty(String name, int defaultValue) {
 486         return AccessController.doPrivileged((PrivilegedAction&lt;Integer&gt;) () -&gt;
 487                 NetProperties.getInteger(name, defaultValue));
 488     }
 489 
 490     public static String getNetProperty(String name) {
 491         return AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
 492                 NetProperties.get(name));
 493     }
 494 
 495     public static boolean getBooleanProperty(String name, boolean def) {
 496         return AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt;
 497                 Boolean.parseBoolean(System.getProperty(name, String.valueOf(def))));
 498     }
 499 
 500     public static String getProperty(String name) {
 501         return AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
 502                 System.getProperty(name));
 503     }
 504 
 505     public static int getIntegerProperty(String name, int defaultValue) {
 506         return AccessController.doPrivileged((PrivilegedAction&lt;Integer&gt;) () -&gt;
 507                 Integer.parseInt(System.getProperty(name, String.valueOf(defaultValue))));
 508     }
 509 
 510     public static SSLParameters copySSLParameters(SSLParameters p) {
 511         SSLParameters p1 = new SSLParameters();
 512         p1.setAlgorithmConstraints(p.getAlgorithmConstraints());
 513         p1.setCipherSuites(p.getCipherSuites());
 514         // JDK 8 EXCL START
 515         p1.setEnableRetransmissions(p.getEnableRetransmissions());
 516         p1.setMaximumPacketSize(p.getMaximumPacketSize());
 517         // JDK 8 EXCL END
 518         p1.setEndpointIdentificationAlgorithm(p.getEndpointIdentificationAlgorithm());
 519         p1.setNeedClientAuth(p.getNeedClientAuth());
 520         String[] protocols = p.getProtocols();
 521         if (protocols != null) {
 522             p1.setProtocols(protocols.clone());
 523         }
 524         p1.setSNIMatchers(p.getSNIMatchers());
 525         p1.setServerNames(p.getServerNames());
 526         p1.setUseCipherSuitesOrder(p.getUseCipherSuitesOrder());
 527         p1.setWantClientAuth(p.getWantClientAuth());
 528         return p1;
 529     }
 530 
 531     /**
 532      * Set limit to position, and position to mark.
 533      */
 534     public static void flipToMark(ByteBuffer buffer, int mark) {
 535         buffer.limit(buffer.position());
 536         buffer.position(mark);
 537     }
 538 
 539     public static String stackTrace(Throwable t) {
 540         ByteArrayOutputStream bos = new ByteArrayOutputStream();
 541         PrintStream p = new PrintStream(bos, true, US_ASCII);
 542         t.printStackTrace(p);
 543         return bos.toString(US_ASCII);
 544     }
 545 
 546     /**
 547      * Copies as much of src to dst as possible.
 548      * Return number of bytes copied
 549      */
 550     public static int copy(ByteBuffer src, ByteBuffer dst) {
 551         int srcLen = src.remaining();
 552         int dstLen = dst.remaining();
 553         if (srcLen &gt; dstLen) {
 554             int diff = srcLen - dstLen;
 555             int limit = src.limit();
 556             src.limit(limit - diff);
 557             dst.put(src);
 558             src.limit(limit);
 559         } else {
 560             dst.put(src);
 561         }
 562         return srcLen - src.remaining();
 563     }
 564 
 565     /** Threshold beyond which data is no longer copied into the current
 566      * buffer, if that buffer has enough unused space. */
 567     private static final int COPY_THRESHOLD = 8192;
 568 
 569     /**
 570      * Adds the data from buffersToAdd to currentList. Either 1) appends the
 571      * data from a particular buffer to the last buffer in the list ( if
 572      * there is enough unused space ), or 2) adds it to the list.
 573      *
 574      * @return the number of bytes added
 575      */
 576     public static long accumulateBuffers(List&lt;ByteBuffer&gt; currentList,
 577                                          List&lt;ByteBuffer&gt; buffersToAdd) {
 578         long accumulatedBytes = 0;
 579         for (ByteBuffer bufferToAdd : buffersToAdd) {
 580             int remaining = bufferToAdd.remaining();
 581             if (remaining &lt;= 0)
 582                 continue;
 583             int listSize = currentList.size();
 584             if (listSize == 0) {
 585                 currentList.add(bufferToAdd);
 586                 accumulatedBytes = remaining;
 587                 continue;
 588             }
 589 
 590             ByteBuffer lastBuffer = currentList.get(listSize - 1);
 591             int freeSpace = lastBuffer.capacity() - lastBuffer.limit();
 592             if (remaining &lt;= COPY_THRESHOLD &amp;&amp; freeSpace &gt;= remaining) {
 593                 // append the new data to the unused space in the last buffer
 594                 int position = lastBuffer.position();
 595                 int limit = lastBuffer.limit();
 596                 lastBuffer.position(limit);
 597                 lastBuffer.limit(limit + remaining);
 598                 lastBuffer.put(bufferToAdd);
 599                 lastBuffer.position(position);
 600             } else {
 601                 currentList.add(bufferToAdd);
 602             }
 603             accumulatedBytes += remaining;
 604         }
 605         return accumulatedBytes;
 606     }
 607 
 608     public static ByteBuffer copy(ByteBuffer src) {
 609         ByteBuffer dst = ByteBuffer.allocate(src.remaining());
 610         dst.put(src);
 611         dst.flip();
 612         return dst;
 613     }
 614 
 615     public static ByteBuffer copyAligned(ByteBuffer src) {
 616         int len = src.remaining();
 617         int size = ((len + 7) &gt;&gt; 3) &lt;&lt; 3;
 618         assert size &gt;= len;
 619         ByteBuffer dst = ByteBuffer.allocate(size);
 620         dst.put(src);
 621         dst.flip();
 622         return dst;
 623     }
 624 
 625     public static String dump(Object... objects) {
 626         return Arrays.toString(objects);
 627     }
 628 
 629     public static String stringOf(Collection&lt;?&gt; source) {
 630         // We don&#39;t know anything about toString implementation of this
 631         // collection, so let&#39;s create an array
 632         return Arrays.toString(source.toArray());
 633     }
 634 
 635     public static long remaining(ByteBuffer[] bufs) {
 636         long remain = 0;
 637         for (ByteBuffer buf : bufs) {
 638             remain += buf.remaining();
 639         }
 640         return remain;
 641     }
 642 
 643     public static boolean hasRemaining(List&lt;ByteBuffer&gt; bufs) {
 644         synchronized (bufs) {
 645             for (ByteBuffer buf : bufs) {
 646                 if (buf.hasRemaining())
 647                     return true;
 648             }
 649         }
 650         return false;
 651     }
 652 
 653     public static long remaining(List&lt;ByteBuffer&gt; bufs) {
 654         long remain = 0;
 655         synchronized (bufs) {
 656             for (ByteBuffer buf : bufs) {
 657                 remain += buf.remaining();
 658             }
 659         }
 660         return remain;
 661     }
 662 
 663     public static int remaining(List&lt;ByteBuffer&gt; bufs, int max) {
 664         long remain = 0;
 665         synchronized (bufs) {
 666             for (ByteBuffer buf : bufs) {
 667                 remain += buf.remaining();
 668                 if (remain &gt; max) {
 669                     throw new IllegalArgumentException(&quot;too many bytes&quot;);
 670                 }
 671             }
 672         }
 673         return (int) remain;
 674     }
 675 
 676     public static int remaining(ByteBuffer[] refs, int max) {
 677         long remain = 0;
 678         for (ByteBuffer b : refs) {
 679             remain += b.remaining();
 680             if (remain &gt; max) {
 681                 throw new IllegalArgumentException(&quot;too many bytes&quot;);
 682             }
 683         }
 684         return (int) remain;
 685     }
 686 
 687     public static void close(Closeable... closeables) {
 688         for (Closeable c : closeables) {
 689             try {
 690                 c.close();
 691             } catch (IOException ignored) { }
 692         }
 693     }
 694 
 695     // Put all these static &#39;empty&#39; singletons here
 696     public static final ByteBuffer EMPTY_BYTEBUFFER = ByteBuffer.allocate(0);
 697     public static final ByteBuffer[] EMPTY_BB_ARRAY = new ByteBuffer[0];
 698     public static final List&lt;ByteBuffer&gt; EMPTY_BB_LIST = List.of();
 699 
 700     /**
 701      * Returns a slice of size {@code amount} from the given buffer. If the
 702      * buffer contains more data than {@code amount}, then the slice&#39;s capacity
 703      * ( and, but not just, its limit ) is set to {@code amount}. If the buffer
 704      * does not contain more data than {@code amount}, then the slice&#39;s capacity
 705      * will be the same as the given buffer&#39;s capacity.
 706      */
 707     public static ByteBuffer sliceWithLimitedCapacity(ByteBuffer buffer, int amount) {
 708         final int index = buffer.position() + amount;
 709         final int limit = buffer.limit();
 710         if (index != limit) {
 711             // additional data in the buffer
 712             buffer.limit(index);  // ensures that the slice does not go beyond
 713         } else {
 714             // no additional data in the buffer
 715             buffer.limit(buffer.capacity());  // allows the slice full capacity
 716         }
 717 
 718         ByteBuffer newb = buffer.slice();
 719         buffer.position(index);
 720         buffer.limit(limit);    // restore the original buffer&#39;s limit
 721         newb.limit(amount);     // slices limit to amount (capacity may be greater)
 722         return newb;
 723     }
 724 
 725     /**
 726      * Get the Charset from the Content-encoding header. Defaults to
 727      * UTF_8
 728      */
 729     public static Charset charsetFrom(HttpHeaders headers) {
 730         String type = headers.firstValue(&quot;Content-type&quot;)
 731                 .orElse(&quot;text/html; charset=utf-8&quot;);
 732         int i = type.indexOf(&quot;;&quot;);
 733         if (i &gt;= 0) type = type.substring(i+1);
 734         try {
 735             HeaderParser parser = new HeaderParser(type);
 736             String value = parser.findValue(&quot;charset&quot;);
 737             if (value == null) return StandardCharsets.UTF_8;
 738             return Charset.forName(value);
 739         } catch (Throwable x) {
 740             Log.logTrace(&quot;Can&#39;t find charset in \&quot;{0}\&quot; ({1})&quot;, type, x);
 741             return StandardCharsets.UTF_8;
 742         }
 743     }
 744 
 745     public static UncheckedIOException unchecked(IOException e) {
 746         return new UncheckedIOException(e);
 747     }
 748 
 749     /**
 750      * Get a logger for debug HTTP traces.
 751      *
 752      * The logger should only be used with levels whose severity is
 753      * {@code &lt;= DEBUG}. By default, this logger will forward all messages
 754      * logged to an internal logger named &quot;jdk.internal.httpclient.debug&quot;.
 755      * In addition, if the property -Djdk.internal.httpclient.debug=true is set,
 756      * it will print the messages on stderr.
 757      * The logger will add some decoration to the printed message, in the form of
 758      * {@code &lt;Level&gt;:[&lt;thread-name&gt;] [&lt;elapsed-time&gt;] &lt;dbgTag&gt;: &lt;formatted message&gt;}
 759      *
 760      * @param dbgTag A lambda that returns a string that identifies the caller
 761      *               (e.g: &quot;SocketTube(3)&quot;, or &quot;Http2Connection(SocketTube(3))&quot;)
 762      *
 763      * @return A logger for HTTP internal debug traces
 764      */
 765     public static Logger getDebugLogger(Supplier&lt;String&gt; dbgTag) {
 766         return getDebugLogger(dbgTag, DEBUG);
 767     }
 768 
 769     /**
 770      * Get a logger for debug HTTP traces.The logger should only be used
 771      * with levels whose severity is {@code &lt;= DEBUG}.
 772      *
 773      * By default, this logger will forward all messages logged to an internal
 774      * logger named &quot;jdk.internal.httpclient.debug&quot;.
 775      * In addition, if the message severity level is &gt;= to
 776      * the provided {@code errLevel} it will print the messages on stderr.
 777      * The logger will add some decoration to the printed message, in the form of
 778      * {@code &lt;Level&gt;:[&lt;thread-name&gt;] [&lt;elapsed-time&gt;] &lt;dbgTag&gt;: &lt;formatted message&gt;}
 779      *
 780      * @apiNote To obtain a logger that will always print things on stderr in
 781      *          addition to forwarding to the internal logger, use
 782      *          {@code getDebugLogger(this::dbgTag, Level.ALL);}.
 783      *          This is also equivalent to calling
 784      *          {@code getDebugLogger(this::dbgTag, true);}.
 785      *          To obtain a logger that will only forward to the internal logger,
 786      *          use {@code getDebugLogger(this::dbgTag, Level.OFF);}.
 787      *          This is also equivalent to calling
 788      *          {@code getDebugLogger(this::dbgTag, false);}.
 789      *
 790      * @param dbgTag A lambda that returns a string that identifies the caller
 791      *               (e.g: &quot;SocketTube(3)&quot;, or &quot;Http2Connection(SocketTube(3))&quot;)
 792      * @param errLevel The level above which messages will be also printed on
 793      *               stderr (in addition to be forwarded to the internal logger).
 794      *
 795      * @return A logger for HTTP internal debug traces
 796      */
 797     static Logger getDebugLogger(Supplier&lt;String&gt; dbgTag, Level errLevel) {
 798         return DebugLogger.createHttpLogger(dbgTag, Level.OFF, errLevel);
 799     }
 800 
 801     /**
 802      * Get a logger for debug HTTP traces.The logger should only be used
 803      * with levels whose severity is {@code &lt;= DEBUG}.
 804      *
 805      * By default, this logger will forward all messages logged to an internal
 806      * logger named &quot;jdk.internal.httpclient.debug&quot;.
 807      * In addition, the provided boolean {@code on==true}, it will print the
 808      * messages on stderr.
 809      * The logger will add some decoration to the printed message, in the form of
 810      * {@code &lt;Level&gt;:[&lt;thread-name&gt;] [&lt;elapsed-time&gt;] &lt;dbgTag&gt;: &lt;formatted message&gt;}
 811      *
 812      * @apiNote To obtain a logger that will always print things on stderr in
 813      *          addition to forwarding to the internal logger, use
 814      *          {@code getDebugLogger(this::dbgTag, true);}.
 815      *          This is also equivalent to calling
 816      *          {@code getDebugLogger(this::dbgTag, Level.ALL);}.
 817      *          To obtain a logger that will only forward to the internal logger,
 818      *          use {@code getDebugLogger(this::dbgTag, false);}.
 819      *          This is also equivalent to calling
 820      *          {@code getDebugLogger(this::dbgTag, Level.OFF);}.
 821      *
 822      * @param dbgTag A lambda that returns a string that identifies the caller
 823      *               (e.g: &quot;SocketTube(3)&quot;, or &quot;Http2Connection(SocketTube(3))&quot;)
 824      * @param on  Whether messages should also be printed on
 825      *               stderr (in addition to be forwarded to the internal logger).
 826      *
 827      * @return A logger for HTTP internal debug traces
 828      */
 829     public static Logger getDebugLogger(Supplier&lt;String&gt; dbgTag, boolean on) {
 830         Level errLevel = on ? Level.ALL : Level.OFF;
 831         return getDebugLogger(dbgTag, errLevel);
 832     }
 833 
 834     /**
 835      * Return the host string from a HttpRequestImpl
 836      *
 837      * @param request
 838      * @return
 839      */
 840     public static String hostString(HttpRequestImpl request) {
 841         URI uri = request.uri();
 842         int port = uri.getPort();
 843         String host = uri.getHost();
 844 
 845         boolean defaultPort;
 846         if (port == -1) {
 847             defaultPort = true;
 848         } else if (uri.getScheme().equalsIgnoreCase(&quot;https&quot;)) {
 849             defaultPort = port == 443;
 850         } else {
 851             defaultPort = port == 80;
 852         }
 853 
 854         if (defaultPort) {
 855             return host;
 856         } else {
 857             return host + &quot;:&quot; + Integer.toString(port);
 858         }
 859     }
 860 
 861     /**
 862      * Get a logger for debug HPACK traces.The logger should only be used
 863      * with levels whose severity is {@code &lt;= DEBUG}.
 864      *
 865      * By default, this logger will forward all messages logged to an internal
 866      * logger named &quot;jdk.internal.httpclient.hpack.debug&quot;.
 867      * In addition, if the message severity level is &gt;= to
 868      * the provided {@code errLevel} it will print the messages on stderr.
 869      * The logger will add some decoration to the printed message, in the form of
 870      * {@code &lt;Level&gt;:[&lt;thread-name&gt;] [&lt;elapsed-time&gt;] &lt;dbgTag&gt;: &lt;formatted message&gt;}
 871      *
 872      * @apiNote To obtain a logger that will always print things on stderr in
 873      *          addition to forwarding to the internal logger, use
 874      *          {@code getHpackLogger(this::dbgTag, Level.ALL);}.
 875      *          This is also equivalent to calling
 876      *          {@code getHpackLogger(this::dbgTag, true);}.
 877      *          To obtain a logger that will only forward to the internal logger,
 878      *          use {@code getHpackLogger(this::dbgTag, Level.OFF);}.
 879      *          This is also equivalent to calling
 880      *          {@code getHpackLogger(this::dbgTag, false);}.
 881      *
 882      * @param dbgTag A lambda that returns a string that identifies the caller
 883      *               (e.g: &quot;Http2Connection(SocketTube(3))/hpack.Decoder(3)&quot;)
 884      * @param errLevel The level above which messages will be also printed on
 885      *               stderr (in addition to be forwarded to the internal logger).
 886      *
 887      * @return A logger for HPACK internal debug traces
 888      */
 889     public static Logger getHpackLogger(Supplier&lt;String&gt; dbgTag, Level errLevel) {
 890         Level outLevel = Level.OFF;
 891         return DebugLogger.createHpackLogger(dbgTag, outLevel, errLevel);
 892     }
 893 
 894     /**
 895      * Get a logger for debug HPACK traces.The logger should only be used
 896      * with levels whose severity is {@code &lt;= DEBUG}.
 897      *
 898      * By default, this logger will forward all messages logged to an internal
 899      * logger named &quot;jdk.internal.httpclient.hpack.debug&quot;.
 900      * In addition, the provided boolean {@code on==true}, it will print the
 901      * messages on stderr.
 902      * The logger will add some decoration to the printed message, in the form of
 903      * {@code &lt;Level&gt;:[&lt;thread-name&gt;] [&lt;elapsed-time&gt;] &lt;dbgTag&gt;: &lt;formatted message&gt;}
 904      *
 905      * @apiNote To obtain a logger that will always print things on stderr in
 906      *          addition to forwarding to the internal logger, use
 907      *          {@code getHpackLogger(this::dbgTag, true);}.
 908      *          This is also equivalent to calling
 909      *          {@code getHpackLogger(this::dbgTag, Level.ALL);}.
 910      *          To obtain a logger that will only forward to the internal logger,
 911      *          use {@code getHpackLogger(this::dbgTag, false);}.
 912      *          This is also equivalent to calling
 913      *          {@code getHpackLogger(this::dbgTag, Level.OFF);}.
 914      *
 915      * @param dbgTag A lambda that returns a string that identifies the caller
 916      *               (e.g: &quot;Http2Connection(SocketTube(3))/hpack.Decoder(3)&quot;)
 917      * @param on  Whether messages should also be printed on
 918      *            stderr (in addition to be forwarded to the internal logger).
 919      *
 920      * @return A logger for HPACK internal debug traces
 921      */
 922     public static Logger getHpackLogger(Supplier&lt;String&gt; dbgTag, boolean on) {
 923         Level errLevel = on ? Level.ALL : Level.OFF;
 924         return getHpackLogger(dbgTag, errLevel);
 925     }
 926 
 927     /**
 928      * Get a logger for debug WebSocket traces.The logger should only be used
 929      * with levels whose severity is {@code &lt;= DEBUG}.
 930      *
 931      * By default, this logger will forward all messages logged to an internal
 932      * logger named &quot;jdk.internal.httpclient.websocket.debug&quot;.
 933      * In addition, if the message severity level is &gt;= to
 934      * the provided {@code errLevel} it will print the messages on stderr.
 935      * The logger will add some decoration to the printed message, in the form of
 936      * {@code &lt;Level&gt;:[&lt;thread-name&gt;] [&lt;elapsed-time&gt;] &lt;dbgTag&gt;: &lt;formatted message&gt;}
 937      *
 938      * @apiNote To obtain a logger that will always print things on stderr in
 939      *          addition to forwarding to the internal logger, use
 940      *          {@code getWebSocketLogger(this::dbgTag, Level.ALL);}.
 941      *          This is also equivalent to calling
 942      *          {@code getWSLogger(this::dbgTag, true);}.
 943      *          To obtain a logger that will only forward to the internal logger,
 944      *          use {@code getWebSocketLogger(this::dbgTag, Level.OFF);}.
 945      *          This is also equivalent to calling
 946      *          {@code getWSLogger(this::dbgTag, false);}.
 947      *
 948      * @param dbgTag A lambda that returns a string that identifies the caller
 949      *               (e.g: &quot;WebSocket(3)&quot;)
 950      * @param errLevel The level above which messages will be also printed on
 951      *               stderr (in addition to be forwarded to the internal logger).
 952      *
 953      * @return A logger for HPACK internal debug traces
 954      */
 955     public static Logger getWebSocketLogger(Supplier&lt;String&gt; dbgTag, Level errLevel) {
 956         Level outLevel = Level.OFF;
 957         return DebugLogger.createWebSocketLogger(dbgTag, outLevel, errLevel);
 958     }
 959 
 960     /**
 961      * Get a logger for debug WebSocket traces.The logger should only be used
 962      * with levels whose severity is {@code &lt;= DEBUG}.
 963      *
 964      * By default, this logger will forward all messages logged to an internal
 965      * logger named &quot;jdk.internal.httpclient.websocket.debug&quot;.
 966      * In addition, the provided boolean {@code on==true}, it will print the
 967      * messages on stderr.
 968      * The logger will add some decoration to the printed message, in the form of
 969      * {@code &lt;Level&gt;:[&lt;thread-name&gt;] [&lt;elapsed-time&gt;] &lt;dbgTag&gt;: &lt;formatted message&gt;}
 970      *
 971      * @apiNote To obtain a logger that will always print things on stderr in
 972      *          addition to forwarding to the internal logger, use
 973      *          {@code getWebSocketLogger(this::dbgTag, true);}.
 974      *          This is also equivalent to calling
 975      *          {@code getWebSocketLogger(this::dbgTag, Level.ALL);}.
 976      *          To obtain a logger that will only forward to the internal logger,
 977      *          use {@code getWebSocketLogger(this::dbgTag, false);}.
 978      *          This is also equivalent to calling
 979      *          {@code getHpackLogger(this::dbgTag, Level.OFF);}.
 980      *
 981      * @param dbgTag A lambda that returns a string that identifies the caller
 982      *               (e.g: &quot;WebSocket(3)&quot;)
 983      * @param on  Whether messages should also be printed on
 984      *            stderr (in addition to be forwarded to the internal logger).
 985      *
 986      * @return A logger for WebSocket internal debug traces
 987      */
 988     public static Logger getWebSocketLogger(Supplier&lt;String&gt; dbgTag, boolean on) {
 989         Level errLevel = on ? Level.ALL : Level.OFF;
 990         return getWebSocketLogger(dbgTag, errLevel);
 991     }
 992 
 993     /**
 994      * SSLSessions returned to user are wrapped in an immutable object
 995      */
 996     public static SSLSession immutableSession(SSLSession session) {
 997         if (session instanceof ExtendedSSLSession)
 998             return new ImmutableExtendedSSLSession((ExtendedSSLSession)session);
 999         else
1000             return new ImmutableSSLSession(session);
1001     }
1002 
1003     /**
1004      * Enabled by default. May be disabled for testing. Use with care
1005      */
1006     public static boolean isHostnameVerificationDisabled() {
1007         return isHostnameVerificationDisabled;
1008     }
1009 
1010     public static InetSocketAddress resolveAddress(InetSocketAddress address) {
1011         if (address != null &amp;&amp; address.isUnresolved()) {
1012             // The default proxy selector may select a proxy whose  address is
1013             // unresolved. We must resolve the address before connecting to it.
1014             address = new InetSocketAddress(address.getHostString(), address.getPort());
1015         }
1016         return address;
1017     }
1018 
1019     public static Throwable toConnectException(Throwable e) {
1020         if (e == null) return null;
1021         e = getCompletionCause(e);
1022         if (e instanceof ConnectException) return e;
1023         if (e instanceof SecurityException) return e;
1024         if (e instanceof SSLException) return e;
1025         if (e instanceof Error) return e;
1026         if (e instanceof HttpTimeoutException) return e;
1027         Throwable cause = e;
1028         e = new ConnectException(e.getMessage());
1029         e.initCause(cause);
1030         return e;
1031     }
1032 
1033     /**
1034      * Returns the smallest (closest to zero) positive number {@code m} (which
1035      * is also a power of 2) such that {@code n &lt;= m}.
1036      * &lt;pre&gt;{@code
1037      *          n  pow2Size(n)
1038      * -----------------------
1039      *          0           1
1040      *          1           1
1041      *          2           2
1042      *          3           4
1043      *          4           4
1044      *          5           8
1045      *          6           8
1046      *          7           8
1047      *          8           8
1048      *          9          16
1049      *         10          16
1050      *        ...         ...
1051      * 2147483647  1073741824
1052      * } &lt;/pre&gt;
1053      *
1054      * The result is capped at {@code 1 &lt;&lt; 30} as beyond that int wraps.
1055      *
1056      * @param n
1057      *         capacity
1058      *
1059      * @return the size of the array
1060      * @apiNote Used to size arrays in circular buffers (rings), usually in
1061      * order to squeeze extra performance substituting {@code %} operation for
1062      * {@code &amp;}, which is up to 2 times faster.
1063      */
1064     public static int pow2Size(int n) {
1065         if (n &lt; 0) {
1066             throw new IllegalArgumentException();
1067         } else if (n == 0) {
1068             return 1;
1069         } else if (n &gt;= (1 &lt;&lt; 30)) { // 2^31 is a negative int
1070             return 1 &lt;&lt; 30;
1071         } else {
1072             return 1 &lt;&lt; (32 - Integer.numberOfLeadingZeros(n - 1));
1073         }
1074     }
1075 
1076     // -- toAsciiString-like support to encode path and query URI segments
1077 
1078     private static final char[] hexDigits = {
1079             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;,
1080             &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;
1081     };
1082 
1083     private static void appendEscape(StringBuilder sb, byte b) {
1084         sb.append(&#39;%&#39;);
1085         sb.append(hexDigits[(b &gt;&gt; 4) &amp; 0x0f]);
1086         sb.append(hexDigits[(b &gt;&gt; 0) &amp; 0x0f]);
1087     }
1088 
1089     // Encodes all characters &gt;= \u0080 into escaped, normalized UTF-8 octets,
1090     // assuming that s is otherwise legal
1091     //
1092     public static String encode(String s) {
1093         int n = s.length();
1094         if (n == 0)
1095             return s;
1096 
1097         // First check whether we actually need to encode
1098         for (int i = 0;;) {
1099             if (s.charAt(i) &gt;= &#39;\u0080&#39;)
1100                 break;
1101             if (++i &gt;= n)
1102                 return s;
1103         }
1104 
1105         String ns = Normalizer.normalize(s, Normalizer.Form.NFC);
1106         ByteBuffer bb = null;
1107         try {
1108             bb = StandardCharsets.UTF_8.newEncoder()
1109                     .onMalformedInput(CodingErrorAction.REPORT)
1110                     .onUnmappableCharacter(CodingErrorAction.REPORT)
1111                     .encode(CharBuffer.wrap(ns));
1112         } catch (CharacterCodingException x) {
1113             assert false : x;
1114         }
1115 
1116         StringBuilder sb = new StringBuilder();
1117         while (bb.hasRemaining()) {
1118             int b = bb.get() &amp; 0xff;
1119             if (b &gt;= 0x80)
1120                 appendEscape(sb, (byte)b);
1121             else
1122                 sb.append((char)b);
1123         }
1124         return sb.toString();
1125     }
1126 }
    </pre>
  </body>
</html>
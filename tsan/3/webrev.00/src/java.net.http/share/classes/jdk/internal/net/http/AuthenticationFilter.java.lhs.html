<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.net.http/share/classes/jdk/internal/net/http/AuthenticationFilter.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.net.http;
 27 
 28 import java.io.IOException;
 29 import java.net.MalformedURLException;
 30 import java.net.PasswordAuthentication;
 31 import java.net.URI;
 32 import java.net.InetSocketAddress;
 33 import java.net.URISyntaxException;
 34 import java.net.URL;
 35 import java.util.Base64;
 36 import java.util.LinkedList;
 37 import java.util.List;
 38 import java.util.Objects;
 39 import java.util.WeakHashMap;
 40 import java.net.http.HttpHeaders;
 41 import jdk.internal.net.http.common.Log;
 42 import jdk.internal.net.http.common.Utils;
 43 import static java.net.Authenticator.RequestorType.PROXY;
 44 import static java.net.Authenticator.RequestorType.SERVER;
 45 import static java.nio.charset.StandardCharsets.ISO_8859_1;
<a name="2" id="anc2"></a>
 46 
 47 /**
 48  * Implementation of Http Basic authentication.
 49  */
 50 class AuthenticationFilter implements HeaderFilter {
 51     volatile MultiExchange&lt;?&gt; exchange;
 52     private static final Base64.Encoder encoder = Base64.getEncoder();
 53 
 54     static final int DEFAULT_RETRY_LIMIT = 3;
 55 
 56     static final int retry_limit = Utils.getIntegerNetProperty(
 57             &quot;jdk.httpclient.auth.retrylimit&quot;, DEFAULT_RETRY_LIMIT);
 58 
 59     static final int UNAUTHORIZED = 401;
 60     static final int PROXY_UNAUTHORIZED = 407;
 61 
 62     private static final String BASIC_DUMMY =
 63             &quot;Basic &quot; + Base64.getEncoder()
 64                     .encodeToString(&quot;o:o&quot;.getBytes(ISO_8859_1));
 65 
 66     // A public no-arg constructor is required by FilterFactory
 67     public AuthenticationFilter() {}
 68 
 69     private PasswordAuthentication getCredentials(String header,
 70                                                   boolean proxy,
 71                                                   HttpRequestImpl req)
 72         throws IOException
 73     {
 74         HttpClientImpl client = exchange.client();
 75         java.net.Authenticator auth =
 76                 client.authenticator()
 77                       .orElseThrow(() -&gt; new IOException(&quot;No authenticator set&quot;));
 78         URI uri = req.uri();
 79         HeaderParser parser = new HeaderParser(header);
 80         String authscheme = parser.findKey(0);
 81 
 82         String realm = parser.findValue(&quot;realm&quot;);
 83         java.net.Authenticator.RequestorType rtype = proxy ? PROXY : SERVER;
 84         URL url = toURL(uri, req.method(), proxy);
 85         String host;
 86         int port;
 87         String protocol;
 88         InetSocketAddress proxyAddress;
 89         if (proxy &amp;&amp; (proxyAddress = req.proxy()) != null) {
 90             // request sent to server through proxy
 91             proxyAddress = req.proxy();
 92             host = proxyAddress.getHostString();
 93             port = proxyAddress.getPort();
 94             protocol = &quot;http&quot;; // we don&#39;t support https connection to proxy
 95         } else {
 96             // direct connection to server or proxy
 97             host = uri.getHost();
 98             port = uri.getPort();
 99             protocol = uri.getScheme();
100         }
101 
102         // needs to be instance method in Authenticator
103         return auth.requestPasswordAuthenticationInstance(host,
104                                                           null,
105                                                           port,
106                                                           protocol,
107                                                           realm,
108                                                           authscheme,
109                                                           url,
110                                                           rtype
111         );
112     }
113 
114     private URL toURL(URI uri, String method, boolean proxy)
115             throws MalformedURLException
116     {
117         if (proxy &amp;&amp; &quot;CONNECT&quot;.equalsIgnoreCase(method)
118                 &amp;&amp; &quot;socket&quot;.equalsIgnoreCase(uri.getScheme())) {
119             return null; // proxy tunneling
120         }
121         return uri.toURL();
122     }
123 
124     private URI getProxyURI(HttpRequestImpl r) {
125         InetSocketAddress proxy = r.proxy();
126         if (proxy == null) {
127             return null;
128         }
129 
130         // our own private scheme for proxy URLs
131         // e.g. proxy.http://host:port/
132         String scheme = &quot;proxy.&quot; + r.uri().getScheme();
133         try {
134             return new URI(scheme,
135                            null,
136                            proxy.getHostString(),
137                            proxy.getPort(),
138                            &quot;/&quot;,
139                            null,
140                            null);
141         } catch (URISyntaxException e) {
142             throw new InternalError(e);
143         }
144     }
145 
146     @Override
147     public void request(HttpRequestImpl r, MultiExchange&lt;?&gt; e) throws IOException {
148         // use preemptive authentication if an entry exists.
149         Cache cache = getCache(e);
150         this.exchange = e;
151 
152         // Proxy
153         if (exchange.proxyauth == null) {
154             URI proxyURI = getProxyURI(r);
155             if (proxyURI != null) {
156                 CacheEntry ca = cache.get(proxyURI, true);
157                 if (ca != null) {
<a name="3" id="anc3"></a><span class="line-modified">158                     exchange.proxyauth = new AuthInfo(true, ca.scheme, null, ca);</span>
<span class="line-modified">159                     addBasicCredentials(r, true, ca.value);</span>
160                 }
161             }
162         }
163 
164         // Server
165         if (exchange.serverauth == null) {
166             CacheEntry ca = cache.get(r.uri(), false);
167             if (ca != null) {
<a name="4" id="anc4"></a><span class="line-modified">168                 exchange.serverauth = new AuthInfo(true, ca.scheme, null, ca);</span>
<span class="line-modified">169                 addBasicCredentials(r, false, ca.value);</span>
170             }
171         }
172     }
173 
174     // TODO: refactor into per auth scheme class
175     private static void addBasicCredentials(HttpRequestImpl r,
176                                             boolean proxy,
<a name="5" id="anc5"></a><span class="line-modified">177                                             PasswordAuthentication pw) {</span>

178         String hdrname = proxy ? &quot;Proxy-Authorization&quot; : &quot;Authorization&quot;;
179         StringBuilder sb = new StringBuilder(128);
180         sb.append(pw.getUserName()).append(&#39;:&#39;).append(pw.getPassword());
<a name="6" id="anc6"></a><span class="line-modified">181         String s = encoder.encodeToString(sb.toString().getBytes(ISO_8859_1));</span>

182         String value = &quot;Basic &quot; + s;
183         if (proxy) {
184             if (r.isConnect()) {
185                 if (!Utils.PROXY_TUNNEL_FILTER.test(hdrname, value)) {
186                     Log.logError(&quot;{0} disabled&quot;, hdrname);
187                     return;
188                 }
189             } else if (r.proxy() != null) {
190                 if (!Utils.PROXY_FILTER.test(hdrname, value)) {
191                     Log.logError(&quot;{0} disabled&quot;, hdrname);
192                     return;
193                 }
194             }
195         }
196         r.setSystemHeader(hdrname, value);
197     }
198 
199     // Information attached to a HttpRequestImpl relating to authentication
200     static class AuthInfo {
201         final boolean fromcache;
202         final String scheme;
203         int retries;
204         PasswordAuthentication credentials; // used in request
205         CacheEntry cacheEntry; // if used
<a name="7" id="anc7"></a>
206 
207         AuthInfo(boolean fromcache,
208                  String scheme,
<a name="8" id="anc8"></a><span class="line-modified">209                  PasswordAuthentication credentials) {</span>
210             this.fromcache = fromcache;
211             this.scheme = scheme;
212             this.credentials = credentials;
213             this.retries = 1;
<a name="9" id="anc9"></a>
214         }
215 
216         AuthInfo(boolean fromcache,
217                  String scheme,
218                  PasswordAuthentication credentials,
<a name="10" id="anc10"></a><span class="line-modified">219                  CacheEntry ca) {</span>
<span class="line-modified">220             this(fromcache, scheme, credentials);</span>
221             assert credentials == null || (ca != null &amp;&amp; ca.value == null);
222             cacheEntry = ca;
223         }
224 
<a name="11" id="anc11"></a><span class="line-modified">225         AuthInfo retryWithCredentials(PasswordAuthentication pw) {</span>
226             // If the info was already in the cache we need to create a new
227             // instance with fromCache==false so that it&#39;s put back in the
228             // cache if authentication succeeds
<a name="12" id="anc12"></a><span class="line-modified">229             AuthInfo res = fromcache ? new AuthInfo(false, scheme, pw) : this;</span>
230             res.credentials = Objects.requireNonNull(pw);
231             res.retries = retries;
232             return res;
233         }
<a name="13" id="anc13"></a><span class="line-removed">234 </span>
235     }
236 
237     @Override
238     public HttpRequestImpl response(Response r) throws IOException {
239         Cache cache = getCache(exchange);
240         int status = r.statusCode();
241         HttpHeaders hdrs = r.headers();
242         HttpRequestImpl req = r.request();
243 
<a name="14" id="anc14"></a><span class="line-modified">244         if (status != UNAUTHORIZED &amp;&amp; status != PROXY_UNAUTHORIZED) {</span>
<span class="line-removed">245             // check if any authentication succeeded for first time</span>
<span class="line-removed">246             if (exchange.serverauth != null &amp;&amp; !exchange.serverauth.fromcache) {</span>
<span class="line-removed">247                 AuthInfo au = exchange.serverauth;</span>
<span class="line-removed">248                 cache.store(au.scheme, req.uri(), false, au.credentials);</span>
<span class="line-removed">249             }</span>
250             if (exchange.proxyauth != null &amp;&amp; !exchange.proxyauth.fromcache) {
251                 AuthInfo au = exchange.proxyauth;
252                 URI proxyURI = getProxyURI(req);
253                 if (proxyURI != null) {
<a name="15" id="anc15"></a><span class="line-modified">254                     cache.store(au.scheme, proxyURI, true, au.credentials);</span>

255                 }
256             }
<a name="16" id="anc16"></a><span class="line-modified">257             return null;</span>







258         }
259 
260         boolean proxy = status == PROXY_UNAUTHORIZED;
261         String authname = proxy ? &quot;Proxy-Authenticate&quot; : &quot;WWW-Authenticate&quot;;
262         List&lt;String&gt; authvals = hdrs.allValues(authname);
263         if (authvals.isEmpty() &amp;&amp; exchange.client().authenticator().isPresent()) {
264             throw new IOException(authname + &quot; header missing for response code &quot; + status);
265         }
266         String authval = null;
<a name="17" id="anc17"></a>
267         for (String aval : authvals) {
268             HeaderParser parser = new HeaderParser(aval);
269             String scheme = parser.findKey(0);
270             if (scheme.equalsIgnoreCase(&quot;Basic&quot;)) {
271                 authval = aval;
<a name="18" id="anc18"></a>

272                 break;
273             }
274         }
275         if (authval == null) {
276             return null;
277         }
278 
279         if (proxy) {
280             if (r.isConnectResponse) {
281                 if (!Utils.PROXY_TUNNEL_FILTER
282                         .test(&quot;Proxy-Authorization&quot;, BASIC_DUMMY)) {
283                     Log.logError(&quot;{0} disabled&quot;, &quot;Proxy-Authorization&quot;);
284                     return null;
285                 }
286             } else if (req.proxy() != null) {
287                 if (!Utils.PROXY_FILTER
288                         .test(&quot;Proxy-Authorization&quot;, BASIC_DUMMY)) {
289                     Log.logError(&quot;{0} disabled&quot;, &quot;Proxy-Authorization&quot;);
290                     return null;
291                 }
292             }
293         }
294 
295         AuthInfo au = proxy ? exchange.proxyauth : exchange.serverauth;
296         if (au == null) {
297             // if no authenticator, let the user deal with 407/401
298             if (!exchange.client().authenticator().isPresent()) return null;
299 
300             PasswordAuthentication pw = getCredentials(authval, proxy, req);
301             if (pw == null) {
302                 throw new IOException(&quot;No credentials provided&quot;);
303             }
304             // No authentication in request. Get credentials from user
<a name="19" id="anc19"></a><span class="line-modified">305             au = new AuthInfo(false, &quot;Basic&quot;, pw);</span>
306             if (proxy) {
307                 exchange.proxyauth = au;
308             } else {
309                 exchange.serverauth = au;
310             }
311             req = HttpRequestImpl.newInstanceForAuthentication(req);
<a name="20" id="anc20"></a><span class="line-modified">312             addBasicCredentials(req, proxy, pw);</span>
313             return req;
314         } else if (au.retries &gt; retry_limit) {
315             throw new IOException(&quot;too many authentication attempts. Limit: &quot; +
316                     Integer.toString(retry_limit));
317         } else {
318             // we sent credentials, but they were rejected
319             if (au.fromcache) {
320                 cache.remove(au.cacheEntry);
321             }
322 
323             // if no authenticator, let the user deal with 407/401
324             if (!exchange.client().authenticator().isPresent()) return null;
325 
326             // try again
327             PasswordAuthentication pw = getCredentials(authval, proxy, req);
328             if (pw == null) {
329                 throw new IOException(&quot;No credentials provided&quot;);
330             }
<a name="21" id="anc21"></a><span class="line-modified">331             au = au.retryWithCredentials(pw);</span>
332             if (proxy) {
333                 exchange.proxyauth = au;
334             } else {
335                 exchange.serverauth = au;
336             }
337             req = HttpRequestImpl.newInstanceForAuthentication(req);
<a name="22" id="anc22"></a><span class="line-modified">338             addBasicCredentials(req, proxy, au.credentials);</span>
339             au.retries++;
340             return req;
341         }
342     }
343 
344     // Use a WeakHashMap to make it possible for the HttpClient to
345     // be garbage collected when no longer referenced.
346     static final WeakHashMap&lt;HttpClientImpl,Cache&gt; caches = new WeakHashMap&lt;&gt;();
347 
348     static synchronized Cache getCache(MultiExchange&lt;?&gt; exchange) {
349         HttpClientImpl client = exchange.client();
350         Cache c = caches.get(client);
351         if (c == null) {
352             c = new Cache();
353             caches.put(client, c);
354         }
355         return c;
356     }
357 
358     // Note: Make sure that Cache and CacheEntry do not keep any strong
359     //       reference to the HttpClient: it would prevent the client being
360     //       GC&#39;ed when no longer referenced.
361     static final class Cache {
362         final LinkedList&lt;CacheEntry&gt; entries = new LinkedList&lt;&gt;();
363 
364         Cache() {}
365 
366         synchronized CacheEntry get(URI uri, boolean proxy) {
367             for (CacheEntry entry : entries) {
368                 if (entry.equalsKey(uri, proxy)) {
369                     return entry;
370                 }
371             }
372             return null;
373         }
374 
<a name="23" id="anc23"></a>



375         synchronized void remove(String authscheme, URI domain, boolean proxy) {
<a name="24" id="anc24"></a><span class="line-modified">376             for (CacheEntry entry : entries) {</span>
<span class="line-modified">377                 if (entry.equalsKey(domain, proxy)) {</span>
<span class="line-modified">378                     entries.remove(entry);</span>




379                 }
380             }
381         }
382 
383         synchronized void remove(CacheEntry entry) {
384             entries.remove(entry);
385         }
386 
387         synchronized void store(String authscheme,
388                                 URI domain,
389                                 boolean proxy,
<a name="25" id="anc25"></a><span class="line-modified">390                                 PasswordAuthentication value) {</span>
391             remove(authscheme, domain, proxy);
<a name="26" id="anc26"></a><span class="line-modified">392             entries.add(new CacheEntry(authscheme, domain, proxy, value));</span>
393         }
394     }
395 
396     static URI normalize(URI uri, boolean isPrimaryKey) {
397         String path = uri.getPath();
398         if (path == null || path.isEmpty()) {
399             // make sure the URI has a path, ignore query and fragment
400             try {
401                 return new URI(uri.getScheme(), uri.getAuthority(), &quot;/&quot;, null, null);
402             } catch (URISyntaxException e) {
403                 throw new InternalError(e);
404             }
405         } else if (isPrimaryKey || !&quot;/&quot;.equals(path)) {
406             // remove extraneous components and normalize path
407             return uri.resolve(&quot;.&quot;);
408         } else {
409             // path == &quot;/&quot; and the URI is not used to store
410             // the primary key in the cache: nothing to do.
411             return uri;
412         }
413     }
414 
415     static final class CacheEntry {
416         final String root;
417         final String scheme;
418         final boolean proxy;
419         final PasswordAuthentication value;
<a name="27" id="anc27"></a>
420 
421         CacheEntry(String authscheme,
422                    URI uri,
423                    boolean proxy,
<a name="28" id="anc28"></a><span class="line-modified">424                    PasswordAuthentication value) {</span>
425             this.scheme = authscheme;
426             this.root = normalize(uri, true).toString(); // remove extraneous components
427             this.proxy = proxy;
428             this.value = value;
<a name="29" id="anc29"></a>
429         }
430 
431         public PasswordAuthentication value() {
432             return value;
433         }
434 
435         public boolean equalsKey(URI uri, boolean proxy) {
436             if (this.proxy != proxy) {
437                 return false;
438             }
439             String other = String.valueOf(normalize(uri, false));
440             return other.startsWith(root);
441         }
442     }
443 }
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
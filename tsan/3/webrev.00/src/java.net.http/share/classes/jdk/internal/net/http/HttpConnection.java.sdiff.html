<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.net.http/share/classes/jdk/internal/net/http/HttpConnection.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Http2ClientImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HttpRequestImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.net.http/share/classes/jdk/internal/net/http/HttpConnection.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
268             return Utils.NO_PROXY_HEADERS_FILTER;
269         } else if (request.isConnect()) {
270             // establishing a proxy tunnel
271             // check for proxy tunnel disabled schemes
272             // assert !this.isTunnel();
273             assert request.proxy() == null;
274             return Utils.PROXY_TUNNEL_FILTER;
275         } else if (request.proxy() != null) {
276             // talking to a server through a proxy (no tunnel)
277             // check for proxy disabled schemes
278             // assert !isTunnel() &amp;&amp; !request.isConnect();
279             return Utils.PROXY_FILTER;
280         } else {
281             // talking to a server directly (no tunnel, no proxy)
282             // don&#39;t send proxy-* headers to a plain server
283             // assert request.proxy() == null &amp;&amp; !request.isConnect();
284             return Utils.NO_PROXY_HEADERS_FILTER;
285         }
286     }
287 










288     // Composes a new immutable HttpHeaders that combines the
289     // user and system header but only keeps those headers that
290     // start with &quot;proxy-&quot;
291     private static HttpHeaders proxyTunnelHeaders(HttpRequestImpl request) {
292         Map&lt;String, List&lt;String&gt;&gt; combined = new TreeMap&lt;&gt;(String.CASE_INSENSITIVE_ORDER);
293         combined.putAll(request.getSystemHeadersBuilder().map());
294         combined.putAll(request.headers().map()); // let user override system
295 
296         // keep only proxy-* - and also strip authorization headers
297         // for disabled schemes
298         return HttpHeaders.of(combined, Utils.PROXY_TUNNEL_FILTER);
299     }
300 
301     /* Returns either a plain HTTP connection or a plain tunnelling connection
302      * for proxied WebSocket */
303     private static HttpConnection getPlainConnection(InetSocketAddress addr,
304                                                      InetSocketAddress proxy,
305                                                      HttpRequestImpl request,
306                                                      HttpClientImpl client) {
307         if (request.isWebSocket() &amp;&amp; proxy != null)
308             return new PlainTunnelingConnection(addr, proxy, client,
309                                                 proxyTunnelHeaders(request));
310 
311         if (proxy == null)
312             return new PlainHttpConnection(addr, client);
313         else
314             return new PlainProxyConnection(proxy, client);
315     }
316 
317     void closeOrReturnToCache(HttpHeaders hdrs) {
318         if (hdrs == null) {
319             // the connection was closed by server, eof

320             close();
321             return;
322         }
<span class="line-removed">323         if (!isOpen()) {</span>
<span class="line-removed">324             return;</span>
<span class="line-removed">325         }</span>
326         HttpClientImpl client = client();
327         if (client == null) {

328             close();
329             return;
330         }
331         ConnectionPool pool = client.connectionPool();
332         boolean keepAlive = hdrs.firstValue(&quot;Connection&quot;)
333                 .map((s) -&gt; !s.equalsIgnoreCase(&quot;close&quot;))
334                 .orElse(true);
335 
<span class="line-modified">336         if (keepAlive) {</span>
337             Log.logTrace(&quot;Returning connection to the pool: {0}&quot;, this);
338             pool.returnToPool(this);
339         } else {


340             close();
341         }
342     }
343 
344     /* Tells whether or not this connection is a tunnel through a proxy */
345     boolean isTunnel() { return false; }
346 
347     abstract SocketChannel channel();
348 
349     final InetSocketAddress address() {
350         return address;
351     }
352 
353     abstract ConnectionPool.CacheKey cacheKey();
354 
355     /**
356      * Closes this connection, by returning the socket to its connection pool.
357      */
358     @Override
359     public abstract void close();
</pre>
</td>
<td>
<hr />
<pre>
268             return Utils.NO_PROXY_HEADERS_FILTER;
269         } else if (request.isConnect()) {
270             // establishing a proxy tunnel
271             // check for proxy tunnel disabled schemes
272             // assert !this.isTunnel();
273             assert request.proxy() == null;
274             return Utils.PROXY_TUNNEL_FILTER;
275         } else if (request.proxy() != null) {
276             // talking to a server through a proxy (no tunnel)
277             // check for proxy disabled schemes
278             // assert !isTunnel() &amp;&amp; !request.isConnect();
279             return Utils.PROXY_FILTER;
280         } else {
281             // talking to a server directly (no tunnel, no proxy)
282             // don&#39;t send proxy-* headers to a plain server
283             // assert request.proxy() == null &amp;&amp; !request.isConnect();
284             return Utils.NO_PROXY_HEADERS_FILTER;
285         }
286     }
287 
<span class="line-added">288     BiPredicate&lt;String,String&gt; contextRestricted(HttpRequestImpl request, HttpClient client) {</span>
<span class="line-added">289         if (!isTunnel() &amp;&amp; request.isConnect()) {</span>
<span class="line-added">290             // establishing a proxy tunnel</span>
<span class="line-added">291             assert request.proxy() == null;</span>
<span class="line-added">292             return Utils.PROXY_TUNNEL_RESTRICTED(client);</span>
<span class="line-added">293         } else {</span>
<span class="line-added">294             return Utils.CONTEXT_RESTRICTED(client);</span>
<span class="line-added">295         }</span>
<span class="line-added">296     }</span>
<span class="line-added">297 </span>
298     // Composes a new immutable HttpHeaders that combines the
299     // user and system header but only keeps those headers that
300     // start with &quot;proxy-&quot;
301     private static HttpHeaders proxyTunnelHeaders(HttpRequestImpl request) {
302         Map&lt;String, List&lt;String&gt;&gt; combined = new TreeMap&lt;&gt;(String.CASE_INSENSITIVE_ORDER);
303         combined.putAll(request.getSystemHeadersBuilder().map());
304         combined.putAll(request.headers().map()); // let user override system
305 
306         // keep only proxy-* - and also strip authorization headers
307         // for disabled schemes
308         return HttpHeaders.of(combined, Utils.PROXY_TUNNEL_FILTER);
309     }
310 
311     /* Returns either a plain HTTP connection or a plain tunnelling connection
312      * for proxied WebSocket */
313     private static HttpConnection getPlainConnection(InetSocketAddress addr,
314                                                      InetSocketAddress proxy,
315                                                      HttpRequestImpl request,
316                                                      HttpClientImpl client) {
317         if (request.isWebSocket() &amp;&amp; proxy != null)
318             return new PlainTunnelingConnection(addr, proxy, client,
319                                                 proxyTunnelHeaders(request));
320 
321         if (proxy == null)
322             return new PlainHttpConnection(addr, client);
323         else
324             return new PlainProxyConnection(proxy, client);
325     }
326 
327     void closeOrReturnToCache(HttpHeaders hdrs) {
328         if (hdrs == null) {
329             // the connection was closed by server, eof
<span class="line-added">330             Log.logTrace(&quot;Cannot return connection to pool: closing {0}&quot;, this);</span>
331             close();
332             return;
333         }



334         HttpClientImpl client = client();
335         if (client == null) {
<span class="line-added">336             Log.logTrace(&quot;Client released: closing {0}&quot;, this);</span>
337             close();
338             return;
339         }
340         ConnectionPool pool = client.connectionPool();
341         boolean keepAlive = hdrs.firstValue(&quot;Connection&quot;)
342                 .map((s) -&gt; !s.equalsIgnoreCase(&quot;close&quot;))
343                 .orElse(true);
344 
<span class="line-modified">345         if (keepAlive &amp;&amp; isOpen()) {</span>
346             Log.logTrace(&quot;Returning connection to the pool: {0}&quot;, this);
347             pool.returnToPool(this);
348         } else {
<span class="line-added">349             Log.logTrace(&quot;Closing connection (keepAlive={0}, isOpen={1}): {2}&quot;,</span>
<span class="line-added">350                     keepAlive, isOpen(), this);</span>
351             close();
352         }
353     }
354 
355     /* Tells whether or not this connection is a tunnel through a proxy */
356     boolean isTunnel() { return false; }
357 
358     abstract SocketChannel channel();
359 
360     final InetSocketAddress address() {
361         return address;
362     }
363 
364     abstract ConnectionPool.CacheKey cacheKey();
365 
366     /**
367      * Closes this connection, by returning the socket to its connection pool.
368      */
369     @Override
370     public abstract void close();
</pre>
</td>
</tr>
</table>
<center><a href="Http2ClientImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HttpRequestImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
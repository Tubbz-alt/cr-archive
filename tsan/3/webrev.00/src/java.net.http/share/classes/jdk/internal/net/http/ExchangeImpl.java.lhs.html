<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.net.http/share/classes/jdk/internal/net/http/ExchangeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.net.http;
 27 
 28 import java.io.IOException;
<a name="1" id="anc1"></a><span class="line-removed"> 29 import java.util.concurrent.CompletableFuture;</span>
<span class="line-removed"> 30 import java.util.concurrent.Executor;</span>
<span class="line-removed"> 31 import java.util.function.Function;</span>
 32 import java.net.http.HttpClient;
 33 import java.net.http.HttpResponse;
<a name="2" id="anc2"></a>


 34 import jdk.internal.net.http.common.Logger;
 35 import jdk.internal.net.http.common.MinimalFuture;
 36 import jdk.internal.net.http.common.Utils;
<a name="3" id="anc3"></a>
 37 import static java.net.http.HttpClient.Version.HTTP_1_1;
 38 
 39 /**
 40  * Splits request so that headers and body can be sent separately with optional
 41  * (multiple) responses in between (e.g. 100 Continue). Also request and
 42  * response always sent/received in different calls.
 43  *
 44  * Synchronous and asynchronous versions of each method are provided.
 45  *
 46  * Separate implementations of this class exist for HTTP/1.1 and HTTP/2
 47  *      Http1Exchange   (HTTP/1.1)
 48  *      Stream          (HTTP/2)
 49  *
 50  * These implementation classes are where work is allocated to threads.
 51  */
 52 abstract class ExchangeImpl&lt;T&gt; {
 53 
 54     private static final Logger debug =
 55             Utils.getDebugLogger(&quot;ExchangeImpl&quot;::toString, Utils.DEBUG);
 56 
 57     final Exchange&lt;T&gt; exchange;
 58 
 59     ExchangeImpl(Exchange&lt;T&gt; e) {
 60         // e == null means a http/2 pushed stream
 61         this.exchange = e;
 62     }
 63 
 64     final Exchange&lt;T&gt; getExchange() {
 65         return exchange;
 66     }
 67 
 68     HttpClient client() {
 69         return exchange.client();
 70     }
 71 
 72     /**
 73      * Returns the {@link HttpConnection} instance to which this exchange is
 74      * assigned.
 75      */
 76     abstract HttpConnection connection();
 77 
 78     /**
 79      * Initiates a new exchange and assigns it to a connection if one exists
 80      * already. connection usually null.
 81      */
 82     static &lt;U&gt; CompletableFuture&lt;? extends ExchangeImpl&lt;U&gt;&gt;
 83     get(Exchange&lt;U&gt; exchange, HttpConnection connection)
 84     {
 85         if (exchange.version() == HTTP_1_1) {
 86             if (debug.on())
 87                 debug.log(&quot;get: HTTP/1.1: new Http1Exchange&quot;);
 88             return createHttp1Exchange(exchange, connection);
 89         } else {
 90             Http2ClientImpl c2 = exchange.client().client2(); // #### improve
 91             HttpRequestImpl request = exchange.request();
 92             CompletableFuture&lt;Http2Connection&gt; c2f = c2.getConnectionFor(request, exchange);
 93             if (debug.on())
 94                 debug.log(&quot;get: Trying to get HTTP/2 connection&quot;);
<a name="4" id="anc4"></a><span class="line-modified"> 95             return c2f.handle((h2c, t) -&gt; createExchangeImpl(h2c, t, exchange, connection))</span>
<span class="line-modified"> 96                     .thenCompose(Function.identity());</span>


 97         }
 98     }
 99 
100     private static &lt;U&gt; CompletableFuture&lt;? extends ExchangeImpl&lt;U&gt;&gt;
101     createExchangeImpl(Http2Connection c,
102                        Throwable t,
103                        Exchange&lt;U&gt; exchange,
104                        HttpConnection connection)
105     {
106         if (debug.on())
107             debug.log(&quot;handling HTTP/2 connection creation result&quot;);
108         boolean secure = exchange.request().secure();
109         if (t != null) {
110             if (debug.on())
111                 debug.log(&quot;handling HTTP/2 connection creation failed: %s&quot;,
112                                  (Object)t);
113             t = Utils.getCompletionCause(t);
114             if (t instanceof Http2Connection.ALPNException) {
115                 Http2Connection.ALPNException ee = (Http2Connection.ALPNException)t;
116                 AbstractAsyncSSLConnection as = ee.getConnection();
117                 if (debug.on())
118                     debug.log(&quot;downgrading to HTTP/1.1 with: %s&quot;, as);
119                 CompletableFuture&lt;? extends ExchangeImpl&lt;U&gt;&gt; ex =
120                         createHttp1Exchange(exchange, as);
121                 return ex;
122             } else {
123                 if (debug.on())
124                     debug.log(&quot;HTTP/2 connection creation failed &quot;
125                                      + &quot;with unexpected exception: %s&quot;, (Object)t);
126                 return MinimalFuture.failedFuture(t);
127             }
128         }
129         if (secure &amp;&amp; c== null) {
130             if (debug.on())
131                 debug.log(&quot;downgrading to HTTP/1.1 &quot;);
132             CompletableFuture&lt;? extends ExchangeImpl&lt;U&gt;&gt; ex =
133                     createHttp1Exchange(exchange, null);
134             return ex;
135         }
136         if (c == null) {
137             // no existing connection. Send request with HTTP 1 and then
138             // upgrade if successful
139             if (debug.on())
140                 debug.log(&quot;new Http1Exchange, try to upgrade&quot;);
141             return createHttp1Exchange(exchange, connection)
142                     .thenApply((e) -&gt; {
143                         exchange.h2Upgrade();
144                         return e;
145                     });
146         } else {
147             if (debug.on()) debug.log(&quot;creating HTTP/2 streams&quot;);
148             Stream&lt;U&gt; s = c.createStream(exchange);
149             CompletableFuture&lt;? extends ExchangeImpl&lt;U&gt;&gt; ex = MinimalFuture.completedFuture(s);
150             return ex;
151         }
152     }
153 
154     private static &lt;T&gt; CompletableFuture&lt;Http1Exchange&lt;T&gt;&gt;
155     createHttp1Exchange(Exchange&lt;T&gt; ex, HttpConnection as)
156     {
157         try {
158             return MinimalFuture.completedFuture(new Http1Exchange&lt;&gt;(ex, as));
159         } catch (Throwable e) {
160             return MinimalFuture.failedFuture(e);
161         }
162     }
163 
164     // Called for 204 response - when no body is permitted
165     void nullBody(HttpResponse&lt;T&gt; resp, Throwable t) {
166         // only needed for HTTP/1.1 to close the connection
167         // or return it to the pool
168     }
169 
170     /* The following methods have separate HTTP/1.1 and HTTP/2 implementations */
171 
172     abstract CompletableFuture&lt;ExchangeImpl&lt;T&gt;&gt; sendHeadersAsync();
173 
174     /** Sends a request body, after request headers have been sent. */
175     abstract CompletableFuture&lt;ExchangeImpl&lt;T&gt;&gt; sendBodyAsync();
176 
177     abstract CompletableFuture&lt;T&gt; readBodyAsync(HttpResponse.BodyHandler&lt;T&gt; handler,
178                                                 boolean returnConnectionToPool,
179                                                 Executor executor);
180 
181     /**
182      * Ignore/consume the body.
183      */
184     abstract CompletableFuture&lt;Void&gt; ignoreBody();
185 
186 
187     /** Gets the response headers. Completes before body is read. */
188     abstract CompletableFuture&lt;Response&gt; getResponseAsync(Executor executor);
189 
190 
191     /** Cancels a request.  Not currently exposed through API. */
192     abstract void cancel();
193 
194     /**
195      * Cancels a request with a cause.  Not currently exposed through API.
196      */
197     abstract void cancel(IOException cause);
198 
199     /**
200      * Called when the exchange is released, so that cleanup actions may be
201      * performed - such as deregistering callbacks.
202      * Typically released is called during upgrade, when an HTTP/2 stream
203      * takes over from an Http1Exchange, or when a new exchange is created
204      * during a multi exchange before the final response body was received.
205      */
206     abstract void released();
207 
208     /**
209      * Called when the exchange is completed, so that cleanup actions may be
210      * performed - such as deregistering callbacks.
211      * Typically, completed is called at the end of the exchange, when the
212      * final response body has been received (or an error has caused the
213      * completion of the exchange).
214      */
215     abstract void completed();
216 
217     /**
218      * Returns true if this exchange was canceled.
219      * @return true if this exchange was canceled.
220      */
221     abstract boolean isCanceled();
222 
223     /**
224      * Returns the cause for which this exchange was canceled, if available.
225      * @return the cause for which this exchange was canceled, if available.
226      */
227     abstract Throwable getCancelCause();
228 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
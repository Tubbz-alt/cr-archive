<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.net.http/share/classes/jdk/internal/net/http/common/SSLFlowDelegate.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Log.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SubscriberWrapper.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.net.http/share/classes/jdk/internal/net/http/common/SSLFlowDelegate.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 301         @Override
 302         public String toString() {
 303             return &quot;READER: &quot; + super.toString() + &quot;, readBuf: &quot; + readBuf.toString()
 304                     + &quot;, count: &quot; + count.toString() + &quot;, scheduler: &quot;
 305                     + (scheduler.isStopped() ? &quot;stopped&quot; : &quot;running&quot;)
 306                     + &quot;, status: &quot; + lastUnwrapStatus
 307                     + &quot;, handshakeState: &quot; + handshakeState.get()
 308                     + &quot;, engine: &quot; + engine.getHandshakeStatus();
 309         }
 310 
 311         private void reallocReadBuf() {
 312             int sz = readBuf.capacity();
 313             ByteBuffer newb = ByteBuffer.allocate(sz * 2);
 314             readBuf.flip();
 315             Utils.copy(readBuf, newb);
 316             readBuf = newb;
 317         }
 318 
 319         @Override
 320         protected long upstreamWindowUpdate(long currentWindow, long downstreamQsize) {
<span class="line-modified"> 321             if (readBuf.remaining() &gt; TARGET_BUFSIZE) {</span>
<span class="line-modified"> 322                 if (debugr.on())</span>
<span class="line-modified"> 323                     debugr.log(&quot;readBuf has more than TARGET_BUFSIZE: %d&quot;,</span>
<span class="line-modified"> 324                             readBuf.remaining());</span>
<span class="line-modified"> 325                 return 0;</span>
<span class="line-modified"> 326             } else {</span>
<span class="line-modified"> 327                 return super.upstreamWindowUpdate(currentWindow, downstreamQsize);</span>




 328             }

 329         }
 330 
 331         // readBuf is kept ready for reading outside of this method
 332         private void addToReadBuf(List&lt;ByteBuffer&gt; buffers, boolean complete) {
 333             assert Utils.remaining(buffers) &gt; 0 || buffers.isEmpty();
 334             synchronized (readBufferLock) {
 335                 for (ByteBuffer buf : buffers) {
 336                     readBuf.compact();
 337                     while (readBuf.remaining() &lt; buf.remaining())
 338                         reallocReadBuf();
 339                     readBuf.put(buf);
 340                     readBuf.flip();
 341                     // should be safe to call inside lock
 342                     // since the only implementation
 343                     // offers the buffer to an unbounded queue.
 344                     // WARNING: do not touch buf after this point!
 345                     if (recycler != null) recycler.accept(buf);
 346                 }
 347                 if (complete) {
 348                     this.completing = complete;
</pre>
<hr />
<pre>
 351             }
 352         }
 353 
 354         void schedule() {
 355             scheduler.runOrSchedule(exec);
 356         }
 357 
 358         void stop() {
 359             if (debugr.on()) debugr.log(&quot;stop&quot;);
 360             scheduler.stop();
 361         }
 362 
 363         AtomicInteger count = new AtomicInteger(0);
 364 
 365         // minimum number of bytes required to call unwrap.
 366         // Usually this is 0, unless there was a buffer underflow.
 367         // In this case we need to wait for more bytes than what
 368         // we had before calling unwrap() again.
 369         volatile int minBytesRequired;
 370 


























 371         // work function where it all happens
 372         final void processData() {
 373             try {
 374                 if (debugr.on())
 375                     debugr.log(&quot;processData:&quot;
 376                             + &quot; readBuf remaining:&quot; + readBuf.remaining()
 377                             + &quot;, state:&quot; + states(handshakeState)
 378                             + &quot;, engine handshake status:&quot; + engine.getHandshakeStatus());
 379                 int len;
 380                 boolean complete = false;
 381                 while (readBuf.remaining() &gt; (len = minBytesRequired)) {
 382                     boolean handshaking = false;
 383                     try {
 384                         EngineResult result;
 385                         synchronized (readBufferLock) {
 386                             complete = this.completing;
 387                             if (debugr.on()) debugr.log(&quot;Unwrapping: %s&quot;, readBuf.remaining());
 388                             // Unless there is a BUFFER_UNDERFLOW, we should try to
 389                             // unwrap any number of bytes. Set minBytesRequired to 0:
 390                             // we only need to do that if minBytesRequired is not already 0.
</pre>
<hr />
<pre>
 417                                 else if (this.completing) {
 418                                     if (debug.on()) {
 419                                         debugr.log(&quot;BUFFER_UNDERFLOW with EOF,&quot; +
 420                                                 &quot; %d bytes non decrypted.&quot;, len);
 421                                     }
 422                                     // The channel won&#39;t send us any more data, and
 423                                     // we are in underflow: we need to fail.
 424                                     throw new IOException(&quot;BUFFER_UNDERFLOW with EOF, &quot;
 425                                             + len + &quot; bytes non decrypted.&quot;);
 426                                 }
 427                             }
 428                             // request more data and return.
 429                             requestMore();
 430                             return;
 431                         }
 432                         if (complete &amp;&amp; result.status() == Status.CLOSED) {
 433                             if (debugr.on()) debugr.log(&quot;Closed: completing&quot;);
 434                             outgoing(Utils.EMPTY_BB_LIST, true);
 435                             // complete ALPN if not yet completed
 436                             setALPN();

 437                             return;
 438                         }
 439                         if (result.handshaking()) {
 440                             handshaking = true;
 441                             if (debugr.on()) debugr.log(&quot;handshaking&quot;);
 442                             if (doHandshake(result, READER)) continue; // need unwrap
 443                             else break; // doHandshake will have triggered the write scheduler if necessary
 444                         } else {
 445                             if (trySetALPN()) {
 446                                 resumeActivity();
 447                             }
 448                         }
 449                     } catch (IOException ex) {
 450                         errorCommon(ex);
 451                         handleError(ex);
 452                         return;
 453                     }
<span class="line-modified"> 454                     if (handshaking &amp;&amp; !complete)</span>

 455                         return;

 456                 }
 457                 if (!complete) {
 458                     synchronized (readBufferLock) {
 459                         complete = this.completing &amp;&amp; !readBuf.hasRemaining();
 460                     }
 461                 }
 462                 if (complete) {
 463                     if (debugr.on()) debugr.log(&quot;completing&quot;);
 464                     // Complete the alpnCF, if not already complete, regardless of
 465                     // whether or not the ALPN is available, there will be no more
 466                     // activity.
 467                     setALPN();
 468                     outgoing(Utils.EMPTY_BB_LIST, true);


 469                 }
 470             } catch (Throwable ex) {
 471                 errorCommon(ex);
 472                 handleError(ex);
 473             }
 474         }
 475 
 476         private volatile Status lastUnwrapStatus;
 477         EngineResult unwrapBuffer(ByteBuffer src) throws IOException {
 478             ByteBuffer dst = getAppBuffer();
 479             int len = src.remaining();
 480             while (true) {
 481                 SSLEngineResult sslResult = engine.unwrap(src, dst);
 482                 switch (lastUnwrapStatus = sslResult.getStatus()) {
 483                     case BUFFER_OVERFLOW:
 484                         // may happen if app size buffer was changed, or if
 485                         // our &#39;adaptiveBufferSize&#39; guess was too small for
 486                         // the current payload. In that case, update the
 487                         // value of applicationBufferSize, and allocate a
 488                         // buffer of that size, which we are sure will be
</pre>
</td>
<td>
<hr />
<pre>
 301         @Override
 302         public String toString() {
 303             return &quot;READER: &quot; + super.toString() + &quot;, readBuf: &quot; + readBuf.toString()
 304                     + &quot;, count: &quot; + count.toString() + &quot;, scheduler: &quot;
 305                     + (scheduler.isStopped() ? &quot;stopped&quot; : &quot;running&quot;)
 306                     + &quot;, status: &quot; + lastUnwrapStatus
 307                     + &quot;, handshakeState: &quot; + handshakeState.get()
 308                     + &quot;, engine: &quot; + engine.getHandshakeStatus();
 309         }
 310 
 311         private void reallocReadBuf() {
 312             int sz = readBuf.capacity();
 313             ByteBuffer newb = ByteBuffer.allocate(sz * 2);
 314             readBuf.flip();
 315             Utils.copy(readBuf, newb);
 316             readBuf = newb;
 317         }
 318 
 319         @Override
 320         protected long upstreamWindowUpdate(long currentWindow, long downstreamQsize) {
<span class="line-modified"> 321             if (needsMoreData()) {</span>
<span class="line-modified"> 322                 // run the scheduler to see if more data should be requested</span>
<span class="line-modified"> 323                 if (debugr.on()) {</span>
<span class="line-modified"> 324                     int remaining = readBuf.remaining();</span>
<span class="line-modified"> 325                     if (remaining &gt; TARGET_BUFSIZE) {</span>
<span class="line-modified"> 326                         // just some logging to check how much we have in the read buffer</span>
<span class="line-modified"> 327                         debugr.log(&quot;readBuf has more than TARGET_BUFSIZE: %d&quot;,</span>
<span class="line-added"> 328                                 remaining);</span>
<span class="line-added"> 329                     }</span>
<span class="line-added"> 330                 }</span>
<span class="line-added"> 331                 scheduler.runOrSchedule();</span>
 332             }
<span class="line-added"> 333             return 0; // we will request more from the scheduler loop (processData).</span>
 334         }
 335 
 336         // readBuf is kept ready for reading outside of this method
 337         private void addToReadBuf(List&lt;ByteBuffer&gt; buffers, boolean complete) {
 338             assert Utils.remaining(buffers) &gt; 0 || buffers.isEmpty();
 339             synchronized (readBufferLock) {
 340                 for (ByteBuffer buf : buffers) {
 341                     readBuf.compact();
 342                     while (readBuf.remaining() &lt; buf.remaining())
 343                         reallocReadBuf();
 344                     readBuf.put(buf);
 345                     readBuf.flip();
 346                     // should be safe to call inside lock
 347                     // since the only implementation
 348                     // offers the buffer to an unbounded queue.
 349                     // WARNING: do not touch buf after this point!
 350                     if (recycler != null) recycler.accept(buf);
 351                 }
 352                 if (complete) {
 353                     this.completing = complete;
</pre>
<hr />
<pre>
 356             }
 357         }
 358 
 359         void schedule() {
 360             scheduler.runOrSchedule(exec);
 361         }
 362 
 363         void stop() {
 364             if (debugr.on()) debugr.log(&quot;stop&quot;);
 365             scheduler.stop();
 366         }
 367 
 368         AtomicInteger count = new AtomicInteger(0);
 369 
 370         // minimum number of bytes required to call unwrap.
 371         // Usually this is 0, unless there was a buffer underflow.
 372         // In this case we need to wait for more bytes than what
 373         // we had before calling unwrap() again.
 374         volatile int minBytesRequired;
 375 
<span class="line-added"> 376         // We might need to request more data if:</span>
<span class="line-added"> 377         //  - we have a subscription from upstream</span>
<span class="line-added"> 378         //  - and we don&#39;t have enough data to decrypt in the read buffer</span>
<span class="line-added"> 379         //  - *and* - either we&#39;re handshaking, and more data is required (NEED_UNWRAP),</span>
<span class="line-added"> 380         //          - or we have demand from downstream, but we have nothing decrypted</span>
<span class="line-added"> 381         //            to forward downstream.</span>
<span class="line-added"> 382         boolean needsMoreData() {</span>
<span class="line-added"> 383             if (upstreamSubscription != null &amp;&amp; readBuf.remaining() &lt;= minBytesRequired &amp;&amp;</span>
<span class="line-added"> 384                     (engine.getHandshakeStatus() == HandshakeStatus.NEED_UNWRAP</span>
<span class="line-added"> 385                             || !downstreamSubscription.demand.isFulfilled() &amp;&amp; hasNoOutputData())) {</span>
<span class="line-added"> 386                 return true;</span>
<span class="line-added"> 387             }</span>
<span class="line-added"> 388             return false;</span>
<span class="line-added"> 389         }</span>
<span class="line-added"> 390 </span>
<span class="line-added"> 391         // If the readBuf has not enough data, and we either need to</span>
<span class="line-added"> 392         // unwrap (handshaking) or we have demand from downstream,</span>
<span class="line-added"> 393         // then request more data</span>
<span class="line-added"> 394         void requestMoreDataIfNeeded() {</span>
<span class="line-added"> 395             if (needsMoreData()) {</span>
<span class="line-added"> 396                 // request more will only request more if our</span>
<span class="line-added"> 397                 // demand from upstream is fulfilled</span>
<span class="line-added"> 398                 requestMore();</span>
<span class="line-added"> 399             }</span>
<span class="line-added"> 400         }</span>
<span class="line-added"> 401 </span>
 402         // work function where it all happens
 403         final void processData() {
 404             try {
 405                 if (debugr.on())
 406                     debugr.log(&quot;processData:&quot;
 407                             + &quot; readBuf remaining:&quot; + readBuf.remaining()
 408                             + &quot;, state:&quot; + states(handshakeState)
 409                             + &quot;, engine handshake status:&quot; + engine.getHandshakeStatus());
 410                 int len;
 411                 boolean complete = false;
 412                 while (readBuf.remaining() &gt; (len = minBytesRequired)) {
 413                     boolean handshaking = false;
 414                     try {
 415                         EngineResult result;
 416                         synchronized (readBufferLock) {
 417                             complete = this.completing;
 418                             if (debugr.on()) debugr.log(&quot;Unwrapping: %s&quot;, readBuf.remaining());
 419                             // Unless there is a BUFFER_UNDERFLOW, we should try to
 420                             // unwrap any number of bytes. Set minBytesRequired to 0:
 421                             // we only need to do that if minBytesRequired is not already 0.
</pre>
<hr />
<pre>
 448                                 else if (this.completing) {
 449                                     if (debug.on()) {
 450                                         debugr.log(&quot;BUFFER_UNDERFLOW with EOF,&quot; +
 451                                                 &quot; %d bytes non decrypted.&quot;, len);
 452                                     }
 453                                     // The channel won&#39;t send us any more data, and
 454                                     // we are in underflow: we need to fail.
 455                                     throw new IOException(&quot;BUFFER_UNDERFLOW with EOF, &quot;
 456                                             + len + &quot; bytes non decrypted.&quot;);
 457                                 }
 458                             }
 459                             // request more data and return.
 460                             requestMore();
 461                             return;
 462                         }
 463                         if (complete &amp;&amp; result.status() == Status.CLOSED) {
 464                             if (debugr.on()) debugr.log(&quot;Closed: completing&quot;);
 465                             outgoing(Utils.EMPTY_BB_LIST, true);
 466                             // complete ALPN if not yet completed
 467                             setALPN();
<span class="line-added"> 468                             requestMoreDataIfNeeded();</span>
 469                             return;
 470                         }
 471                         if (result.handshaking()) {
 472                             handshaking = true;
 473                             if (debugr.on()) debugr.log(&quot;handshaking&quot;);
 474                             if (doHandshake(result, READER)) continue; // need unwrap
 475                             else break; // doHandshake will have triggered the write scheduler if necessary
 476                         } else {
 477                             if (trySetALPN()) {
 478                                 resumeActivity();
 479                             }
 480                         }
 481                     } catch (IOException ex) {
 482                         errorCommon(ex);
 483                         handleError(ex);
 484                         return;
 485                     }
<span class="line-modified"> 486                     if (handshaking &amp;&amp; !complete) {</span>
<span class="line-added"> 487                         requestMoreDataIfNeeded();</span>
 488                         return;
<span class="line-added"> 489                     }</span>
 490                 }
 491                 if (!complete) {
 492                     synchronized (readBufferLock) {
 493                         complete = this.completing &amp;&amp; !readBuf.hasRemaining();
 494                     }
 495                 }
 496                 if (complete) {
 497                     if (debugr.on()) debugr.log(&quot;completing&quot;);
 498                     // Complete the alpnCF, if not already complete, regardless of
 499                     // whether or not the ALPN is available, there will be no more
 500                     // activity.
 501                     setALPN();
 502                     outgoing(Utils.EMPTY_BB_LIST, true);
<span class="line-added"> 503                 } else {</span>
<span class="line-added"> 504                     requestMoreDataIfNeeded();</span>
 505                 }
 506             } catch (Throwable ex) {
 507                 errorCommon(ex);
 508                 handleError(ex);
 509             }
 510         }
 511 
 512         private volatile Status lastUnwrapStatus;
 513         EngineResult unwrapBuffer(ByteBuffer src) throws IOException {
 514             ByteBuffer dst = getAppBuffer();
 515             int len = src.remaining();
 516             while (true) {
 517                 SSLEngineResult sslResult = engine.unwrap(src, dst);
 518                 switch (lastUnwrapStatus = sslResult.getStatus()) {
 519                     case BUFFER_OVERFLOW:
 520                         // may happen if app size buffer was changed, or if
 521                         // our &#39;adaptiveBufferSize&#39; guess was too small for
 522                         // the current payload. In that case, update the
 523                         // value of applicationBufferSize, and allocate a
 524                         // buffer of that size, which we are sure will be
</pre>
</td>
</tr>
</table>
<center><a href="Log.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SubscriberWrapper.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
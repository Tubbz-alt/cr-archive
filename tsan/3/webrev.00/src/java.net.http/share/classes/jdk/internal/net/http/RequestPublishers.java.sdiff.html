<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.net.http/share/classes/jdk/internal/net/http/RequestPublishers.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RedirectFilter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ResponseSubscribers.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.net.http/share/classes/jdk/internal/net/http/RequestPublishers.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 42 import java.security.PrivilegedActionException;
 43 import java.security.PrivilegedExceptionAction;
 44 import java.util.ArrayList;
 45 import java.util.Collections;
 46 import java.util.Iterator;
 47 import java.util.List;
 48 import java.util.NoSuchElementException;
 49 import java.util.Objects;
 50 import java.util.concurrent.ConcurrentLinkedQueue;
 51 import java.util.concurrent.Flow;
 52 import java.util.concurrent.Flow.Publisher;
 53 import java.util.function.Supplier;
 54 import java.net.http.HttpRequest.BodyPublisher;
 55 import jdk.internal.net.http.common.Utils;
 56 
 57 public final class RequestPublishers {
 58 
 59     private RequestPublishers() { }
 60 
 61     public static class ByteArrayPublisher implements BodyPublisher {
<span class="line-removed"> 62         private volatile Flow.Publisher&lt;ByteBuffer&gt; delegate;</span>
 63         private final int length;
 64         private final byte[] content;
 65         private final int offset;
 66         private final int bufSize;
 67 
 68         public ByteArrayPublisher(byte[] content) {
 69             this(content, 0, content.length);
 70         }
 71 
 72         public ByteArrayPublisher(byte[] content, int offset, int length) {
 73             this(content, offset, length, Utils.BUFSIZE);
 74         }
 75 
 76         /* bufSize exposed for testing purposes */
 77         ByteArrayPublisher(byte[] content, int offset, int length, int bufSize) {
 78             this.content = content;
 79             this.offset = offset;
 80             this.length = length;
 81             this.bufSize = bufSize;
 82         }
 83 
 84         List&lt;ByteBuffer&gt; copy(byte[] content, int offset, int length) {
 85             List&lt;ByteBuffer&gt; bufs = new ArrayList&lt;&gt;();
 86             while (length &gt; 0) {
 87                 ByteBuffer b = ByteBuffer.allocate(Math.min(bufSize, length));
 88                 int max = b.capacity();
 89                 int tocopy = Math.min(max, length);
 90                 b.put(content, offset, tocopy);
 91                 offset += tocopy;
 92                 length -= tocopy;
 93                 b.flip();
 94                 bufs.add(b);
 95             }
 96             return bufs;
 97         }
 98 
 99         @Override
100         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
101             List&lt;ByteBuffer&gt; copy = copy(content, offset, length);
<span class="line-modified">102             this.delegate = new PullPublisher&lt;&gt;(copy);</span>
103             delegate.subscribe(subscriber);
104         }
105 
106         @Override
107         public long contentLength() {
108             return length;
109         }
110     }
111 
112     // This implementation has lots of room for improvement.
113     public static class IterablePublisher implements BodyPublisher {
<span class="line-removed">114         private volatile Flow.Publisher&lt;ByteBuffer&gt; delegate;</span>
115         private final Iterable&lt;byte[]&gt; content;
116         private volatile long contentLength;
117 
118         public IterablePublisher(Iterable&lt;byte[]&gt; content) {
119             this.content = Objects.requireNonNull(content);
120         }
121 
122         // The ByteBufferIterator will iterate over the byte[] arrays in
123         // the content one at the time.
124         //
125         class ByteBufferIterator implements Iterator&lt;ByteBuffer&gt; {
126             final ConcurrentLinkedQueue&lt;ByteBuffer&gt; buffers = new ConcurrentLinkedQueue&lt;&gt;();
127             final Iterator&lt;byte[]&gt; iterator = content.iterator();
128             @Override
129             public boolean hasNext() {
130                 return !buffers.isEmpty() || iterator.hasNext();
131             }
132 
133             @Override
134             public ByteBuffer next() {
</pre>
<hr />
<pre>
157                     ByteBuffer b = getBuffer();
158                     int max = b.capacity();
159 
160                     int tocopy = Math.min(max, length);
161                     b.put(bytes, offset, tocopy);
162                     offset += tocopy;
163                     length -= tocopy;
164                     b.flip();
165                     buffers.add(b);
166                 } while (length &gt; 0);
167             }
168         }
169 
170         public Iterator&lt;ByteBuffer&gt; iterator() {
171             return new ByteBufferIterator();
172         }
173 
174         @Override
175         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
176             Iterable&lt;ByteBuffer&gt; iterable = this::iterator;
<span class="line-modified">177             this.delegate = new PullPublisher&lt;&gt;(iterable);</span>
178             delegate.subscribe(subscriber);
179         }
180 
181         static long computeLength(Iterable&lt;byte[]&gt; bytes) {
182             long len = 0;
183             for (byte[] b : bytes) {
184                 len = Math.addExact(len, (long)b.length);
185             }
186             return len;
187         }
188 
189         @Override
190         public long contentLength() {
191             if (contentLength == 0) {
192                 synchronized(this) {
193                     if (contentLength == 0) {
194                         contentLength = computeLength(content);
195                     }
196                 }
197             }
</pre>
<hr />
<pre>
254                 sm.checkPermission(readPermission);
255                 filePermission = readPermission;
256             }
257 
258             // existence check must be after permission checks
259             if (Files.notExists(path))
260                 throw new FileNotFoundException(path + &quot; not found&quot;);
261 
262             return new FilePublisher(path, filePermission);
263         }
264 
265         private FilePublisher(Path name, FilePermission filePermission) {
266             assert filePermission != null ? filePermission.getActions().equals(&quot;read&quot;) : true;
267             file = name.toFile();
268             this.filePermissions = filePermission == null ? EMPTY_FILE_PERMISSIONS
269                     : new FilePermission[] { filePermission };
270         }
271 
272         @Override
273         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
<span class="line-modified">274             InputStream is;</span>

275             if (System.getSecurityManager() == null) {
276                 try {
277                     is = new FileInputStream(file);
278                 } catch (IOException ioe) {
<span class="line-modified">279                     throw new UncheckedIOException(ioe);</span>
280                 }
281             } else {
282                 try {
283                     PrivilegedExceptionAction&lt;FileInputStream&gt; pa =
284                             () -&gt; new FileInputStream(file);
285                     is = AccessController.doPrivileged(pa, null, filePermissions);
286                 } catch (PrivilegedActionException pae) {
<span class="line-modified">287                     throw new UncheckedIOException((IOException) pae.getCause());</span>
288                 }
289             }
<span class="line-modified">290             PullPublisher&lt;ByteBuffer&gt; publisher =</span>
<span class="line-modified">291                     new PullPublisher&lt;&gt;(() -&gt; new StreamIterator(is));</span>





292             publisher.subscribe(subscriber);
293         }
294 
295         @Override
296         public long contentLength() {
297             if (System.getSecurityManager() == null) {
298                 return file.length();
299             } else {
300                 PrivilegedAction&lt;Long&gt; pa = () -&gt; file.length();
301                 return AccessController.doPrivileged(pa, null, filePermissions);
302             }
303         }
304     }
305 
306     /**
307      * Reads one buffer ahead all the time, blocking in hasNext()
308      */
309     public static class StreamIterator implements Iterator&lt;ByteBuffer&gt; {
310         final InputStream is;
311         final Supplier&lt;? extends ByteBuffer&gt; bufSupplier;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 42 import java.security.PrivilegedActionException;
 43 import java.security.PrivilegedExceptionAction;
 44 import java.util.ArrayList;
 45 import java.util.Collections;
 46 import java.util.Iterator;
 47 import java.util.List;
 48 import java.util.NoSuchElementException;
 49 import java.util.Objects;
 50 import java.util.concurrent.ConcurrentLinkedQueue;
 51 import java.util.concurrent.Flow;
 52 import java.util.concurrent.Flow.Publisher;
 53 import java.util.function.Supplier;
 54 import java.net.http.HttpRequest.BodyPublisher;
 55 import jdk.internal.net.http.common.Utils;
 56 
 57 public final class RequestPublishers {
 58 
 59     private RequestPublishers() { }
 60 
 61     public static class ByteArrayPublisher implements BodyPublisher {

 62         private final int length;
 63         private final byte[] content;
 64         private final int offset;
 65         private final int bufSize;
 66 
 67         public ByteArrayPublisher(byte[] content) {
 68             this(content, 0, content.length);
 69         }
 70 
 71         public ByteArrayPublisher(byte[] content, int offset, int length) {
 72             this(content, offset, length, Utils.BUFSIZE);
 73         }
 74 
 75         /* bufSize exposed for testing purposes */
 76         ByteArrayPublisher(byte[] content, int offset, int length, int bufSize) {
 77             this.content = content;
 78             this.offset = offset;
 79             this.length = length;
 80             this.bufSize = bufSize;
 81         }
 82 
 83         List&lt;ByteBuffer&gt; copy(byte[] content, int offset, int length) {
 84             List&lt;ByteBuffer&gt; bufs = new ArrayList&lt;&gt;();
 85             while (length &gt; 0) {
 86                 ByteBuffer b = ByteBuffer.allocate(Math.min(bufSize, length));
 87                 int max = b.capacity();
 88                 int tocopy = Math.min(max, length);
 89                 b.put(content, offset, tocopy);
 90                 offset += tocopy;
 91                 length -= tocopy;
 92                 b.flip();
 93                 bufs.add(b);
 94             }
 95             return bufs;
 96         }
 97 
 98         @Override
 99         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
100             List&lt;ByteBuffer&gt; copy = copy(content, offset, length);
<span class="line-modified">101             var delegate = new PullPublisher&lt;&gt;(copy);</span>
102             delegate.subscribe(subscriber);
103         }
104 
105         @Override
106         public long contentLength() {
107             return length;
108         }
109     }
110 
111     // This implementation has lots of room for improvement.
112     public static class IterablePublisher implements BodyPublisher {

113         private final Iterable&lt;byte[]&gt; content;
114         private volatile long contentLength;
115 
116         public IterablePublisher(Iterable&lt;byte[]&gt; content) {
117             this.content = Objects.requireNonNull(content);
118         }
119 
120         // The ByteBufferIterator will iterate over the byte[] arrays in
121         // the content one at the time.
122         //
123         class ByteBufferIterator implements Iterator&lt;ByteBuffer&gt; {
124             final ConcurrentLinkedQueue&lt;ByteBuffer&gt; buffers = new ConcurrentLinkedQueue&lt;&gt;();
125             final Iterator&lt;byte[]&gt; iterator = content.iterator();
126             @Override
127             public boolean hasNext() {
128                 return !buffers.isEmpty() || iterator.hasNext();
129             }
130 
131             @Override
132             public ByteBuffer next() {
</pre>
<hr />
<pre>
155                     ByteBuffer b = getBuffer();
156                     int max = b.capacity();
157 
158                     int tocopy = Math.min(max, length);
159                     b.put(bytes, offset, tocopy);
160                     offset += tocopy;
161                     length -= tocopy;
162                     b.flip();
163                     buffers.add(b);
164                 } while (length &gt; 0);
165             }
166         }
167 
168         public Iterator&lt;ByteBuffer&gt; iterator() {
169             return new ByteBufferIterator();
170         }
171 
172         @Override
173         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
174             Iterable&lt;ByteBuffer&gt; iterable = this::iterator;
<span class="line-modified">175             var delegate = new PullPublisher&lt;&gt;(iterable);</span>
176             delegate.subscribe(subscriber);
177         }
178 
179         static long computeLength(Iterable&lt;byte[]&gt; bytes) {
180             long len = 0;
181             for (byte[] b : bytes) {
182                 len = Math.addExact(len, (long)b.length);
183             }
184             return len;
185         }
186 
187         @Override
188         public long contentLength() {
189             if (contentLength == 0) {
190                 synchronized(this) {
191                     if (contentLength == 0) {
192                         contentLength = computeLength(content);
193                     }
194                 }
195             }
</pre>
<hr />
<pre>
252                 sm.checkPermission(readPermission);
253                 filePermission = readPermission;
254             }
255 
256             // existence check must be after permission checks
257             if (Files.notExists(path))
258                 throw new FileNotFoundException(path + &quot; not found&quot;);
259 
260             return new FilePublisher(path, filePermission);
261         }
262 
263         private FilePublisher(Path name, FilePermission filePermission) {
264             assert filePermission != null ? filePermission.getActions().equals(&quot;read&quot;) : true;
265             file = name.toFile();
266             this.filePermissions = filePermission == null ? EMPTY_FILE_PERMISSIONS
267                     : new FilePermission[] { filePermission };
268         }
269 
270         @Override
271         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
<span class="line-modified">272             InputStream is = null;</span>
<span class="line-added">273             Throwable t = null;</span>
274             if (System.getSecurityManager() == null) {
275                 try {
276                     is = new FileInputStream(file);
277                 } catch (IOException ioe) {
<span class="line-modified">278                     t = ioe;</span>
279                 }
280             } else {
281                 try {
282                     PrivilegedExceptionAction&lt;FileInputStream&gt; pa =
283                             () -&gt; new FileInputStream(file);
284                     is = AccessController.doPrivileged(pa, null, filePermissions);
285                 } catch (PrivilegedActionException pae) {
<span class="line-modified">286                     t = pae.getCause();</span>
287                 }
288             }
<span class="line-modified">289             final InputStream fis = is;</span>
<span class="line-modified">290             PullPublisher&lt;ByteBuffer&gt; publisher;</span>
<span class="line-added">291             if (t == null) {</span>
<span class="line-added">292                 publisher = new PullPublisher&lt;&gt;(() -&gt; new StreamIterator(fis));</span>
<span class="line-added">293             } else {</span>
<span class="line-added">294                 publisher = new PullPublisher&lt;&gt;(null, t);</span>
<span class="line-added">295             }</span>
296             publisher.subscribe(subscriber);
297         }
298 
299         @Override
300         public long contentLength() {
301             if (System.getSecurityManager() == null) {
302                 return file.length();
303             } else {
304                 PrivilegedAction&lt;Long&gt; pa = () -&gt; file.length();
305                 return AccessController.doPrivileged(pa, null, filePermissions);
306             }
307         }
308     }
309 
310     /**
311      * Reads one buffer ahead all the time, blocking in hasNext()
312      */
313     public static class StreamIterator implements Iterator&lt;ByteBuffer&gt; {
314         final InputStream is;
315         final Supplier&lt;? extends ByteBuffer&gt; bufSupplier;
</pre>
</td>
</tr>
</table>
<center><a href="RedirectFilter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ResponseSubscribers.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.net.http/share/classes/jdk/internal/net/http/HttpRequestImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.net.http;
 27 
 28 import java.io.IOException;
 29 import java.net.InetSocketAddress;
 30 import java.net.Proxy;
 31 import java.net.ProxySelector;
 32 import java.net.URI;
 33 import java.security.AccessControlContext;
 34 import java.security.AccessController;
 35 import java.security.PrivilegedAction;
 36 import java.time.Duration;
 37 import java.util.List;
 38 import java.util.Locale;
 39 import java.util.Objects;
 40 import java.util.Optional;
 41 import java.net.http.HttpClient;
 42 import java.net.http.HttpHeaders;
 43 import java.net.http.HttpRequest;
<a name="1" id="anc1"></a><span class="line-added"> 44 </span>
 45 import jdk.internal.net.http.common.HttpHeadersBuilder;
 46 import jdk.internal.net.http.common.Utils;
 47 import jdk.internal.net.http.websocket.OpeningHandshake;
 48 import jdk.internal.net.http.websocket.WebSocketRequest;
 49 
 50 import static jdk.internal.net.http.common.Utils.ALLOWED_HEADERS;
 51 
 52 public class HttpRequestImpl extends HttpRequest implements WebSocketRequest {
 53 
 54     private final HttpHeaders userHeaders;
 55     private final HttpHeadersBuilder systemHeadersBuilder;
 56     private final URI uri;
 57     private volatile Proxy proxy; // ensure safe publishing
 58     private final InetSocketAddress authority; // only used when URI not specified
 59     private final String method;
 60     final BodyPublisher requestPublisher;
 61     final boolean secure;
 62     final boolean expectContinue;
 63     private volatile boolean isWebSocket;
 64     private volatile AccessControlContext acc;
 65     private final Duration timeout;  // may be null
 66     private final Optional&lt;HttpClient.Version&gt; version;
 67 
 68     private static String userAgent() {
 69         PrivilegedAction&lt;String&gt; pa = () -&gt; System.getProperty(&quot;java.version&quot;);
 70         String version = AccessController.doPrivileged(pa);
 71         return &quot;Java-http-client/&quot; + version;
 72     }
 73 
 74     /** The value of the User-Agent header for all requests sent by the client. */
 75     public static final String USER_AGENT = userAgent();
 76 
 77     /**
 78      * Creates an HttpRequestImpl from the given builder.
 79      */
 80     public HttpRequestImpl(HttpRequestBuilderImpl builder) {
 81         String method = builder.method();
 82         this.method = method == null ? &quot;GET&quot; : method;
 83         this.userHeaders = HttpHeaders.of(builder.headersBuilder().map(), ALLOWED_HEADERS);
 84         this.systemHeadersBuilder = new HttpHeadersBuilder();
 85         this.uri = builder.uri();
 86         assert uri != null;
 87         this.proxy = null;
 88         this.expectContinue = builder.expectContinue();
 89         this.secure = uri.getScheme().toLowerCase(Locale.US).equals(&quot;https&quot;);
 90         this.requestPublisher = builder.bodyPublisher();  // may be null
 91         this.timeout = builder.timeout();
 92         this.version = builder.version();
 93         this.authority = null;
 94     }
 95 
 96     /**
 97      * Creates an HttpRequestImpl from the given request.
 98      */
 99     public HttpRequestImpl(HttpRequest request, ProxySelector ps) {
100         String method = request.method();
101         if (method != null &amp;&amp; !Utils.isValidName(method))
102             throw new IllegalArgumentException(&quot;illegal method \&quot;&quot;
103                     + method.replace(&quot;\n&quot;,&quot;\\n&quot;)
104                     .replace(&quot;\r&quot;, &quot;\\r&quot;)
105                     .replace(&quot;\t&quot;, &quot;\\t&quot;)
106                     + &quot;\&quot;&quot;);
107         URI requestURI = Objects.requireNonNull(request.uri(),
108                 &quot;uri must be non null&quot;);
109         Duration timeout = request.timeout().orElse(null);
110         this.method = method == null ? &quot;GET&quot; : method;
111         this.userHeaders = HttpHeaders.of(request.headers().map(), Utils.VALIDATE_USER_HEADER);
112         if (request instanceof HttpRequestImpl) {
113             // all cases exception WebSocket should have a new system headers
114             this.isWebSocket = ((HttpRequestImpl) request).isWebSocket;
115             if (isWebSocket) {
116                 this.systemHeadersBuilder = ((HttpRequestImpl)request).systemHeadersBuilder;
117             } else {
118                 this.systemHeadersBuilder = new HttpHeadersBuilder();
119             }
120         } else {
121             HttpRequestBuilderImpl.checkURI(requestURI);
122             checkTimeout(timeout);
123             this.systemHeadersBuilder = new HttpHeadersBuilder();
124         }
125         if (!userHeaders.firstValue(&quot;User-Agent&quot;).isPresent()) {
126             this.systemHeadersBuilder.setHeader(&quot;User-Agent&quot;, USER_AGENT);
127         }
128         this.uri = requestURI;
129         if (isWebSocket) {
130             // WebSocket determines and sets the proxy itself
131             this.proxy = ((HttpRequestImpl) request).proxy;
132         } else {
133             if (ps != null)
134                 this.proxy = retrieveProxy(ps, uri);
135             else
136                 this.proxy = null;
137         }
138         this.expectContinue = request.expectContinue();
139         this.secure = uri.getScheme().toLowerCase(Locale.US).equals(&quot;https&quot;);
140         this.requestPublisher = request.bodyPublisher().orElse(null);
141         this.timeout = timeout;
142         this.version = request.version();
143         this.authority = null;
144     }
145 
146     private static void checkTimeout(Duration duration) {
147         if (duration != null) {
148             if (duration.isNegative() || Duration.ZERO.equals(duration))
149                 throw new IllegalArgumentException(&quot;Invalid duration: &quot; + duration);
150         }
151     }
152 
153     /** Returns a new instance suitable for redirection. */
154     public static HttpRequestImpl newInstanceForRedirection(URI uri,
155                                                             String method,
<a name="2" id="anc2"></a><span class="line-modified">156                                                             HttpRequestImpl other,</span>
<span class="line-modified">157                                                             boolean mayHaveBody) {</span>
<span class="line-added">158         return new HttpRequestImpl(uri, method, other, mayHaveBody);</span>
159     }
160 
161     /** Returns a new instance suitable for authentication. */
162     public static HttpRequestImpl newInstanceForAuthentication(HttpRequestImpl other) {
<a name="3" id="anc3"></a><span class="line-modified">163         HttpRequestImpl request = new HttpRequestImpl(other.uri(), other.method(), other, true);</span>
164         if (request.isWebSocket()) {
165             Utils.setWebSocketUpgradeHeaders(request);
166         }
167         return request;
168     }
169 
170     /**
171      * Creates a HttpRequestImpl using fields of an existing request impl.
172      * The newly created HttpRequestImpl does not copy the system headers.
173      */
174     private HttpRequestImpl(URI uri,
175                             String method,
<a name="4" id="anc4"></a><span class="line-modified">176                             HttpRequestImpl other,</span>
<span class="line-added">177                             boolean mayHaveBody) {</span>
178         assert method == null || Utils.isValidName(method);
179         this.method = method == null? &quot;GET&quot; : method;
180         this.userHeaders = other.userHeaders;
181         this.isWebSocket = other.isWebSocket;
182         this.systemHeadersBuilder = new HttpHeadersBuilder();
183         if (!userHeaders.firstValue(&quot;User-Agent&quot;).isPresent()) {
184             this.systemHeadersBuilder.setHeader(&quot;User-Agent&quot;, USER_AGENT);
185         }
186         this.uri = uri;
187         this.proxy = other.proxy;
188         this.expectContinue = other.expectContinue;
189         this.secure = uri.getScheme().toLowerCase(Locale.US).equals(&quot;https&quot;);
<a name="5" id="anc5"></a><span class="line-modified">190         this.requestPublisher = mayHaveBody ? publisher(other) : null; // may be null</span>
191         this.acc = other.acc;
192         this.timeout = other.timeout;
193         this.version = other.version();
194         this.authority = null;
195     }
196 
<a name="6" id="anc6"></a><span class="line-added">197     private BodyPublisher publisher(HttpRequestImpl other) {</span>
<span class="line-added">198         BodyPublisher res = other.requestPublisher;</span>
<span class="line-added">199         if (!Objects.equals(method, other.method)) {</span>
<span class="line-added">200             res = null;</span>
<span class="line-added">201         }</span>
<span class="line-added">202         return res;</span>
<span class="line-added">203     }</span>
<span class="line-added">204 </span>
205     /* used for creating CONNECT requests  */
206     HttpRequestImpl(String method, InetSocketAddress authority, HttpHeaders headers) {
207         // TODO: isWebSocket flag is not specified, but the assumption is that
208         // such a request will never be made on a connection that will be returned
209         // to the connection pool (we might need to revisit this constructor later)
210         assert &quot;CONNECT&quot;.equalsIgnoreCase(method);
211         this.method = method;
212         this.systemHeadersBuilder = new HttpHeadersBuilder();
213         this.userHeaders = headers;
214         this.uri = URI.create(&quot;socket://&quot; + authority.getHostString() + &quot;:&quot;
215                               + Integer.toString(authority.getPort()) + &quot;/&quot;);
216         this.proxy = null;
217         this.requestPublisher = null;
218         this.authority = authority;
219         this.secure = false;
220         this.expectContinue = false;
221         this.timeout = null;
222         // The CONNECT request sent for tunneling is only used in two cases:
223         //   1. websocket, which only supports HTTP/1.1
224         //   2. SSL tunneling through a HTTP/1.1 proxy
225         // In either case we do not want to upgrade the connection to the proxy.
226         // What we want to possibly upgrade is the tunneled connection to the
227         // target server (so not the CONNECT request itself)
228         this.version = Optional.of(HttpClient.Version.HTTP_1_1);
229     }
230 
231     final boolean isConnect() {
232         return &quot;CONNECT&quot;.equalsIgnoreCase(method);
233     }
234 
235     /**
236      * Creates a HttpRequestImpl from the given set of Headers and the associated
237      * &quot;parent&quot; request. Fields not taken from the headers are taken from the
238      * parent.
239      */
240     static HttpRequestImpl createPushRequest(HttpRequestImpl parent,
241                                              HttpHeaders headers)
242         throws IOException
243     {
244         return new HttpRequestImpl(parent, headers);
245     }
246 
247     // only used for push requests
248     private HttpRequestImpl(HttpRequestImpl parent, HttpHeaders headers)
249         throws IOException
250     {
251         this.method = headers.firstValue(&quot;:method&quot;)
252                 .orElseThrow(() -&gt; new IOException(&quot;No method in Push Promise&quot;));
253         String path = headers.firstValue(&quot;:path&quot;)
254                 .orElseThrow(() -&gt; new IOException(&quot;No path in Push Promise&quot;));
255         String scheme = headers.firstValue(&quot;:scheme&quot;)
256                 .orElseThrow(() -&gt; new IOException(&quot;No scheme in Push Promise&quot;));
257         String authority = headers.firstValue(&quot;:authority&quot;)
258                 .orElseThrow(() -&gt; new IOException(&quot;No authority in Push Promise&quot;));
259         StringBuilder sb = new StringBuilder();
260         sb.append(scheme).append(&quot;://&quot;).append(authority).append(path);
261         this.uri = URI.create(sb.toString());
262         this.proxy = null;
263         this.userHeaders = HttpHeaders.of(headers.map(), ALLOWED_HEADERS);
264         this.systemHeadersBuilder = parent.systemHeadersBuilder;
265         this.expectContinue = parent.expectContinue;
266         this.secure = parent.secure;
267         this.requestPublisher = parent.requestPublisher;
268         this.acc = parent.acc;
269         this.timeout = parent.timeout;
270         this.version = parent.version;
271         this.authority = null;
272     }
273 
274     @Override
275     public String toString() {
276         return (uri == null ? &quot;&quot; : uri.toString()) + &quot; &quot; + method;
277     }
278 
279     @Override
280     public HttpHeaders headers() {
281         return userHeaders;
282     }
283 
284     InetSocketAddress authority() { return authority; }
285 
286     void setH2Upgrade(Http2ClientImpl h2client) {
287         systemHeadersBuilder.setHeader(&quot;Connection&quot;, &quot;Upgrade, HTTP2-Settings&quot;);
288         systemHeadersBuilder.setHeader(&quot;Upgrade&quot;, &quot;h2c&quot;);
289         systemHeadersBuilder.setHeader(&quot;HTTP2-Settings&quot;, h2client.getSettingsString());
290     }
291 
292     @Override
293     public boolean expectContinue() { return expectContinue; }
294 
295     /** Retrieves the proxy, from the given ProxySelector, if there is one. */
296     private static Proxy retrieveProxy(ProxySelector ps, URI uri) {
297         Proxy proxy = null;
298         List&lt;Proxy&gt; pl = ps.select(uri);
299         if (!pl.isEmpty()) {
300             Proxy p = pl.get(0);
301             if (p.type() == Proxy.Type.HTTP)
302                 proxy = p;
303         }
304         return proxy;
305     }
306 
307     InetSocketAddress proxy() {
308         if (proxy == null || proxy.type() != Proxy.Type.HTTP
309                 || method.equalsIgnoreCase(&quot;CONNECT&quot;)) {
310             return null;
311         }
312         return (InetSocketAddress)proxy.address();
313     }
314 
315     boolean secure() { return secure; }
316 
317     @Override
318     public void setProxy(Proxy proxy) {
319         assert isWebSocket;
320         this.proxy = proxy;
321     }
322 
323     @Override
324     public void isWebSocket(boolean is) {
325         isWebSocket = is;
326     }
327 
328     boolean isWebSocket() {
329         return isWebSocket;
330     }
331 
332     @Override
333     public Optional&lt;BodyPublisher&gt; bodyPublisher() {
334         return requestPublisher == null ? Optional.empty()
335                                         : Optional.of(requestPublisher);
336     }
337 
338     /**
339      * Returns the request method for this request. If not set explicitly,
340      * the default method for any request is &quot;GET&quot;.
341      */
342     @Override
343     public String method() { return method; }
344 
345     @Override
346     public URI uri() { return uri; }
347 
348     @Override
349     public Optional&lt;Duration&gt; timeout() {
350         return timeout == null ? Optional.empty() : Optional.of(timeout);
351     }
352 
353     HttpHeaders getUserHeaders() { return userHeaders; }
354 
355     HttpHeadersBuilder getSystemHeadersBuilder() { return systemHeadersBuilder; }
356 
357     @Override
358     public Optional&lt;HttpClient.Version&gt; version() { return version; }
359 
360     void addSystemHeader(String name, String value) {
361         systemHeadersBuilder.addHeader(name, value);
362     }
363 
364     @Override
365     public void setSystemHeader(String name, String value) {
366         systemHeadersBuilder.setHeader(name, value);
367     }
368 
369     InetSocketAddress getAddress() {
370         URI uri = uri();
371         if (uri == null) {
372             return authority();
373         }
374         int p = uri.getPort();
375         if (p == -1) {
376             if (uri.getScheme().equalsIgnoreCase(&quot;https&quot;)) {
377                 p = 443;
378             } else {
379                 p = 80;
380             }
381         }
382         final String host = uri.getHost();
383         final int port = p;
384         if (proxy() == null) {
385             PrivilegedAction&lt;InetSocketAddress&gt; pa = () -&gt; new InetSocketAddress(host, port);
386             return AccessController.doPrivileged(pa);
387         } else {
388             return InetSocketAddress.createUnresolved(host, port);
389         }
390     }
391 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
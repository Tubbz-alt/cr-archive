diff a/src/java.net.http/share/classes/jdk/internal/net/http/ResponseSubscribers.java b/src/java.net.http/share/classes/jdk/internal/net/http/ResponseSubscribers.java
--- a/src/java.net.http/share/classes/jdk/internal/net/http/ResponseSubscribers.java
+++ b/src/java.net.http/share/classes/jdk/internal/net/http/ResponseSubscribers.java
@@ -123,30 +123,33 @@
             return result;
         }
 
         @Override
         public void onSubscribe(Flow.Subscription subscription) {
+            Objects.requireNonNull(subscription);
             if (!subscribed.compareAndSet(false, true)) {
                 subscription.cancel();
             } else {
                 this.subscription = subscription;
                 subscription.request(1);
             }
         }
 
         @Override
         public void onNext(List<ByteBuffer> items) {
+            Objects.requireNonNull(items);
             for (ByteBuffer item : items) {
                 byte[] buf = new byte[item.remaining()];
                 item.get(buf);
                 consumer.accept(Optional.of(buf));
             }
             subscription.request(1);
         }
 
         @Override
         public void onError(Throwable throwable) {
+            Objects.requireNonNull(throwable);
             result.completeExceptionally(throwable);
         }
 
         @Override
         public void onComplete() {
@@ -170,10 +173,11 @@
         private final Path file;
         private final OpenOption[] options;
         private final FilePermission[] filePermissions;
         private final CompletableFuture<Path> result = new MinimalFuture<>();
 
+        private final AtomicBoolean subscribed = new AtomicBoolean();
         private volatile Flow.Subscription subscription;
         private volatile FileChannel out;
 
         private static final String pathForSecurityCheck(Path path) {
             return path.toFile().getPath();
@@ -209,10 +213,16 @@
                     filePermissions == null ? EMPTY_FILE_PERMISSIONS : filePermissions;
         }
 
         @Override
         public void onSubscribe(Flow.Subscription subscription) {
+            Objects.requireNonNull(subscription);
+            if (!subscribed.compareAndSet(false, true)) {
+                subscription.cancel();
+                return;
+            }
+
             this.subscription = subscription;
             if (System.getSecurityManager() == null) {
                 try {
                     out = FileChannel.open(file, options);
                 } catch (IOException ioe) {
@@ -426,10 +436,14 @@
             return currentBuffer;
         }
 
         @Override
         public int read(byte[] bytes, int off, int len) throws IOException {
+            Objects.checkFromIndexSize(off, len, bytes.length);
+            if (len == 0) {
+                return 0;
+            }
             // get the buffer to read from, possibly blocking if
             // none is available
             ByteBuffer buffer;
             if ((buffer = current()) == LAST_BUFFER) return -1;
 
@@ -468,10 +482,11 @@
             return 1;
         }
 
         @Override
         public void onSubscribe(Flow.Subscription s) {
+            Objects.requireNonNull(s);
             try {
                 if (!subscribed.compareAndSet(false, true)) {
                     s.cancel();
                 } else {
                     // check whether the stream is already closed.
@@ -598,10 +613,11 @@
             this.result = result;
         }
 
         @Override
         public void onSubscribe(Flow.Subscription subscription) {
+            Objects.requireNonNull(subscription);
             if (!subscribed.compareAndSet(false, true)) {
                 subscription.cancel();
             } else {
                 subscription.request(Long.MAX_VALUE);
             }
@@ -612,10 +628,11 @@
             Objects.requireNonNull(items);
         }
 
         @Override
         public void onError(Throwable throwable) {
+            Objects.requireNonNull(throwable);
             cf.completeExceptionally(throwable);
         }
 
         @Override
         public void onComplete() {
@@ -905,17 +922,25 @@
                 subscriber.onError(new IllegalStateException(
                         "This publisher has already one subscriber"));
             }
         }
 
+        private final AtomicBoolean subscribed = new AtomicBoolean();
+
         @Override
         public void onSubscribe(Flow.Subscription subscription) {
-            subscriptionCF.complete(subscription);
+            Objects.requireNonNull(subscription);
+            if (!subscribed.compareAndSet(false, true)) {
+                subscription.cancel();
+            } else {
+                subscriptionCF.complete(subscription);
+            }
         }
 
         @Override
         public void onNext(List<ByteBuffer> item) {
+            Objects.requireNonNull(item);
             try {
                 // cannot be called before onSubscribe()
                 assert subscriptionCF.isDone();
                 SubscriberRef ref = subscriberRef.get();
                 // cannot be called before subscriber calls request(1)
@@ -939,10 +964,11 @@
                     "onError called before onSubscribe",
                     throwable);
             // onError can be called before request(1), and therefore can
             // be called before subscriberRef is set.
             signalError(throwable);
+            Objects.requireNonNull(throwable);
         }
 
         @Override
         public void onComplete() {
             // cannot be called before onSubscribe()

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.net.http/share/classes/jdk/internal/net/http/HttpRequestImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HttpConnection.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HttpResponseImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.net.http/share/classes/jdk/internal/net/http/HttpRequestImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24  */
 25 
 26 package jdk.internal.net.http;
 27 
 28 import java.io.IOException;
 29 import java.net.InetSocketAddress;
 30 import java.net.Proxy;
 31 import java.net.ProxySelector;
 32 import java.net.URI;
 33 import java.security.AccessControlContext;
 34 import java.security.AccessController;
 35 import java.security.PrivilegedAction;
 36 import java.time.Duration;
 37 import java.util.List;
 38 import java.util.Locale;
 39 import java.util.Objects;
 40 import java.util.Optional;
 41 import java.net.http.HttpClient;
 42 import java.net.http.HttpHeaders;
 43 import java.net.http.HttpRequest;

 44 import jdk.internal.net.http.common.HttpHeadersBuilder;
 45 import jdk.internal.net.http.common.Utils;
 46 import jdk.internal.net.http.websocket.OpeningHandshake;
 47 import jdk.internal.net.http.websocket.WebSocketRequest;
 48 
 49 import static jdk.internal.net.http.common.Utils.ALLOWED_HEADERS;
 50 
 51 public class HttpRequestImpl extends HttpRequest implements WebSocketRequest {
 52 
 53     private final HttpHeaders userHeaders;
 54     private final HttpHeadersBuilder systemHeadersBuilder;
 55     private final URI uri;
 56     private volatile Proxy proxy; // ensure safe publishing
 57     private final InetSocketAddress authority; // only used when URI not specified
 58     private final String method;
 59     final BodyPublisher requestPublisher;
 60     final boolean secure;
 61     final boolean expectContinue;
 62     private volatile boolean isWebSocket;
 63     private volatile AccessControlContext acc;
</pre>
<hr />
<pre>
135                 this.proxy = null;
136         }
137         this.expectContinue = request.expectContinue();
138         this.secure = uri.getScheme().toLowerCase(Locale.US).equals(&quot;https&quot;);
139         this.requestPublisher = request.bodyPublisher().orElse(null);
140         this.timeout = timeout;
141         this.version = request.version();
142         this.authority = null;
143     }
144 
145     private static void checkTimeout(Duration duration) {
146         if (duration != null) {
147             if (duration.isNegative() || Duration.ZERO.equals(duration))
148                 throw new IllegalArgumentException(&quot;Invalid duration: &quot; + duration);
149         }
150     }
151 
152     /** Returns a new instance suitable for redirection. */
153     public static HttpRequestImpl newInstanceForRedirection(URI uri,
154                                                             String method,
<span class="line-modified">155                                                             HttpRequestImpl other) {</span>
<span class="line-modified">156         return new HttpRequestImpl(uri, method, other);</span>

157     }
158 
159     /** Returns a new instance suitable for authentication. */
160     public static HttpRequestImpl newInstanceForAuthentication(HttpRequestImpl other) {
<span class="line-modified">161         HttpRequestImpl request = new HttpRequestImpl(other.uri(), other.method(), other);</span>
162         if (request.isWebSocket()) {
163             Utils.setWebSocketUpgradeHeaders(request);
164         }
165         return request;
166     }
167 
168     /**
169      * Creates a HttpRequestImpl using fields of an existing request impl.
170      * The newly created HttpRequestImpl does not copy the system headers.
171      */
172     private HttpRequestImpl(URI uri,
173                             String method,
<span class="line-modified">174                             HttpRequestImpl other) {</span>

175         assert method == null || Utils.isValidName(method);
176         this.method = method == null? &quot;GET&quot; : method;
177         this.userHeaders = other.userHeaders;
178         this.isWebSocket = other.isWebSocket;
179         this.systemHeadersBuilder = new HttpHeadersBuilder();
180         if (!userHeaders.firstValue(&quot;User-Agent&quot;).isPresent()) {
181             this.systemHeadersBuilder.setHeader(&quot;User-Agent&quot;, USER_AGENT);
182         }
183         this.uri = uri;
184         this.proxy = other.proxy;
185         this.expectContinue = other.expectContinue;
186         this.secure = uri.getScheme().toLowerCase(Locale.US).equals(&quot;https&quot;);
<span class="line-modified">187         this.requestPublisher = other.requestPublisher;  // may be null</span>
188         this.acc = other.acc;
189         this.timeout = other.timeout;
190         this.version = other.version();
191         this.authority = null;
192     }
193 








194     /* used for creating CONNECT requests  */
195     HttpRequestImpl(String method, InetSocketAddress authority, HttpHeaders headers) {
196         // TODO: isWebSocket flag is not specified, but the assumption is that
197         // such a request will never be made on a connection that will be returned
198         // to the connection pool (we might need to revisit this constructor later)
199         assert &quot;CONNECT&quot;.equalsIgnoreCase(method);
200         this.method = method;
201         this.systemHeadersBuilder = new HttpHeadersBuilder();
202         this.userHeaders = headers;
203         this.uri = URI.create(&quot;socket://&quot; + authority.getHostString() + &quot;:&quot;
204                               + Integer.toString(authority.getPort()) + &quot;/&quot;);
205         this.proxy = null;
206         this.requestPublisher = null;
207         this.authority = authority;
208         this.secure = false;
209         this.expectContinue = false;
210         this.timeout = null;
211         // The CONNECT request sent for tunneling is only used in two cases:
212         //   1. websocket, which only supports HTTP/1.1
213         //   2. SSL tunneling through a HTTP/1.1 proxy
</pre>
</td>
<td>
<hr />
<pre>
 24  */
 25 
 26 package jdk.internal.net.http;
 27 
 28 import java.io.IOException;
 29 import java.net.InetSocketAddress;
 30 import java.net.Proxy;
 31 import java.net.ProxySelector;
 32 import java.net.URI;
 33 import java.security.AccessControlContext;
 34 import java.security.AccessController;
 35 import java.security.PrivilegedAction;
 36 import java.time.Duration;
 37 import java.util.List;
 38 import java.util.Locale;
 39 import java.util.Objects;
 40 import java.util.Optional;
 41 import java.net.http.HttpClient;
 42 import java.net.http.HttpHeaders;
 43 import java.net.http.HttpRequest;
<span class="line-added"> 44 </span>
 45 import jdk.internal.net.http.common.HttpHeadersBuilder;
 46 import jdk.internal.net.http.common.Utils;
 47 import jdk.internal.net.http.websocket.OpeningHandshake;
 48 import jdk.internal.net.http.websocket.WebSocketRequest;
 49 
 50 import static jdk.internal.net.http.common.Utils.ALLOWED_HEADERS;
 51 
 52 public class HttpRequestImpl extends HttpRequest implements WebSocketRequest {
 53 
 54     private final HttpHeaders userHeaders;
 55     private final HttpHeadersBuilder systemHeadersBuilder;
 56     private final URI uri;
 57     private volatile Proxy proxy; // ensure safe publishing
 58     private final InetSocketAddress authority; // only used when URI not specified
 59     private final String method;
 60     final BodyPublisher requestPublisher;
 61     final boolean secure;
 62     final boolean expectContinue;
 63     private volatile boolean isWebSocket;
 64     private volatile AccessControlContext acc;
</pre>
<hr />
<pre>
136                 this.proxy = null;
137         }
138         this.expectContinue = request.expectContinue();
139         this.secure = uri.getScheme().toLowerCase(Locale.US).equals(&quot;https&quot;);
140         this.requestPublisher = request.bodyPublisher().orElse(null);
141         this.timeout = timeout;
142         this.version = request.version();
143         this.authority = null;
144     }
145 
146     private static void checkTimeout(Duration duration) {
147         if (duration != null) {
148             if (duration.isNegative() || Duration.ZERO.equals(duration))
149                 throw new IllegalArgumentException(&quot;Invalid duration: &quot; + duration);
150         }
151     }
152 
153     /** Returns a new instance suitable for redirection. */
154     public static HttpRequestImpl newInstanceForRedirection(URI uri,
155                                                             String method,
<span class="line-modified">156                                                             HttpRequestImpl other,</span>
<span class="line-modified">157                                                             boolean mayHaveBody) {</span>
<span class="line-added">158         return new HttpRequestImpl(uri, method, other, mayHaveBody);</span>
159     }
160 
161     /** Returns a new instance suitable for authentication. */
162     public static HttpRequestImpl newInstanceForAuthentication(HttpRequestImpl other) {
<span class="line-modified">163         HttpRequestImpl request = new HttpRequestImpl(other.uri(), other.method(), other, true);</span>
164         if (request.isWebSocket()) {
165             Utils.setWebSocketUpgradeHeaders(request);
166         }
167         return request;
168     }
169 
170     /**
171      * Creates a HttpRequestImpl using fields of an existing request impl.
172      * The newly created HttpRequestImpl does not copy the system headers.
173      */
174     private HttpRequestImpl(URI uri,
175                             String method,
<span class="line-modified">176                             HttpRequestImpl other,</span>
<span class="line-added">177                             boolean mayHaveBody) {</span>
178         assert method == null || Utils.isValidName(method);
179         this.method = method == null? &quot;GET&quot; : method;
180         this.userHeaders = other.userHeaders;
181         this.isWebSocket = other.isWebSocket;
182         this.systemHeadersBuilder = new HttpHeadersBuilder();
183         if (!userHeaders.firstValue(&quot;User-Agent&quot;).isPresent()) {
184             this.systemHeadersBuilder.setHeader(&quot;User-Agent&quot;, USER_AGENT);
185         }
186         this.uri = uri;
187         this.proxy = other.proxy;
188         this.expectContinue = other.expectContinue;
189         this.secure = uri.getScheme().toLowerCase(Locale.US).equals(&quot;https&quot;);
<span class="line-modified">190         this.requestPublisher = mayHaveBody ? publisher(other) : null; // may be null</span>
191         this.acc = other.acc;
192         this.timeout = other.timeout;
193         this.version = other.version();
194         this.authority = null;
195     }
196 
<span class="line-added">197     private BodyPublisher publisher(HttpRequestImpl other) {</span>
<span class="line-added">198         BodyPublisher res = other.requestPublisher;</span>
<span class="line-added">199         if (!Objects.equals(method, other.method)) {</span>
<span class="line-added">200             res = null;</span>
<span class="line-added">201         }</span>
<span class="line-added">202         return res;</span>
<span class="line-added">203     }</span>
<span class="line-added">204 </span>
205     /* used for creating CONNECT requests  */
206     HttpRequestImpl(String method, InetSocketAddress authority, HttpHeaders headers) {
207         // TODO: isWebSocket flag is not specified, but the assumption is that
208         // such a request will never be made on a connection that will be returned
209         // to the connection pool (we might need to revisit this constructor later)
210         assert &quot;CONNECT&quot;.equalsIgnoreCase(method);
211         this.method = method;
212         this.systemHeadersBuilder = new HttpHeadersBuilder();
213         this.userHeaders = headers;
214         this.uri = URI.create(&quot;socket://&quot; + authority.getHostString() + &quot;:&quot;
215                               + Integer.toString(authority.getPort()) + &quot;/&quot;);
216         this.proxy = null;
217         this.requestPublisher = null;
218         this.authority = authority;
219         this.secure = false;
220         this.expectContinue = false;
221         this.timeout = null;
222         // The CONNECT request sent for tunneling is only used in two cases:
223         //   1. websocket, which only supports HTTP/1.1
224         //   2. SSL tunneling through a HTTP/1.1 proxy
</pre>
</td>
</tr>
</table>
<center><a href="HttpConnection.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HttpResponseImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
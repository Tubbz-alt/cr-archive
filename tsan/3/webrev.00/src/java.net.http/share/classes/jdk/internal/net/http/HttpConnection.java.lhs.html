<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.net.http/share/classes/jdk/internal/net/http/HttpConnection.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.net.http;
 27 
 28 import java.io.Closeable;
 29 import java.io.IOException;
 30 import java.net.InetSocketAddress;
 31 import java.nio.ByteBuffer;
 32 import java.nio.channels.SocketChannel;
 33 import java.util.Arrays;
 34 import java.util.IdentityHashMap;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.TreeMap;
 38 import java.util.concurrent.CompletableFuture;
 39 import java.util.concurrent.CompletionStage;
 40 import java.util.concurrent.ConcurrentLinkedDeque;
 41 import java.util.concurrent.Flow;
 42 import java.util.function.BiPredicate;
 43 import java.util.function.Predicate;
 44 import java.net.http.HttpClient;
 45 import java.net.http.HttpClient.Version;
 46 import java.net.http.HttpHeaders;
 47 import jdk.internal.net.http.common.Demand;
 48 import jdk.internal.net.http.common.FlowTube;
 49 import jdk.internal.net.http.common.Logger;
 50 import jdk.internal.net.http.common.SequentialScheduler;
 51 import jdk.internal.net.http.common.SequentialScheduler.DeferredCompleter;
 52 import jdk.internal.net.http.common.Log;
 53 import jdk.internal.net.http.common.Utils;
 54 import static java.net.http.HttpClient.Version.HTTP_2;
 55 
 56 /**
 57  * Wraps socket channel layer and takes care of SSL also.
 58  *
 59  * Subtypes are:
 60  *      PlainHttpConnection: regular direct TCP connection to server
 61  *      PlainProxyConnection: plain text proxy connection
 62  *      PlainTunnelingConnection: opens plain text (CONNECT) tunnel to server
 63  *      AsyncSSLConnection: TLS channel direct to server
 64  *      AsyncSSLTunnelConnection: TLS channel via (CONNECT) proxy tunnel
 65  */
 66 abstract class HttpConnection implements Closeable {
 67 
 68     final Logger debug = Utils.getDebugLogger(this::dbgString, Utils.DEBUG);
 69     final static Logger DEBUG_LOGGER = Utils.getDebugLogger(
 70             () -&gt; &quot;HttpConnection(SocketTube(?))&quot;, Utils.DEBUG);
 71 
 72     /** The address this connection is connected to. Could be a server or a proxy. */
 73     final InetSocketAddress address;
 74     private final HttpClientImpl client;
 75     private final TrailingOperations trailingOperations;
 76 
 77     HttpConnection(InetSocketAddress address, HttpClientImpl client) {
 78         this.address = address;
 79         this.client = client;
 80         trailingOperations = new TrailingOperations();
 81     }
 82 
 83     private static final class TrailingOperations {
 84         private final Map&lt;CompletionStage&lt;?&gt;, Boolean&gt; operations =
 85                 new IdentityHashMap&lt;&gt;();
 86         void add(CompletionStage&lt;?&gt; cf) {
 87             synchronized(operations) {
 88                 operations.put(cf, Boolean.TRUE);
 89                 cf.whenComplete((r,t)-&gt; remove(cf));
 90             }
 91         }
 92         boolean remove(CompletionStage&lt;?&gt; cf) {
 93             synchronized(operations) {
 94                 return operations.remove(cf);
 95             }
 96         }
 97     }
 98 
 99     final void addTrailingOperation(CompletionStage&lt;?&gt; cf) {
100         trailingOperations.add(cf);
101     }
102 
103 //    final void removeTrailingOperation(CompletableFuture&lt;?&gt; cf) {
104 //        trailingOperations.remove(cf);
105 //    }
106 
107     final HttpClientImpl client() {
108         return client;
109     }
110 
111     /**
112      * Initiates the connect phase.
113      *
114      * Returns a CompletableFuture that completes when the underlying
115      * TCP connection has been established or an error occurs.
116      */
117     public abstract CompletableFuture&lt;Void&gt; connectAsync(Exchange&lt;?&gt; exchange);
118 
119     /**
120      * Finishes the connection phase.
121      *
122      * Returns a CompletableFuture that completes when any additional,
123      * type specific, setup has been done. Must be called after connectAsync. */
124     public abstract CompletableFuture&lt;Void&gt; finishConnect();
125 
126     /** Tells whether, or not, this connection is connected to its destination. */
127     abstract boolean connected();
128 
129     /** Tells whether, or not, this connection is secure ( over SSL ) */
130     abstract boolean isSecure();
131 
132     /**
133      * Tells whether, or not, this connection is proxied.
134      * Returns true for tunnel connections, or clear connection to
135      * any host through proxy.
136      */
137     abstract boolean isProxied();
138 
139     /** Tells whether, or not, this connection is open. */
140     final boolean isOpen() {
141         return channel().isOpen() &amp;&amp;
142                 (connected() ? !getConnectionFlow().isFinished() : true);
143     }
144 
145     interface HttpPublisher extends FlowTube.TubePublisher {
146         void enqueue(List&lt;ByteBuffer&gt; buffers) throws IOException;
147         void enqueueUnordered(List&lt;ByteBuffer&gt; buffers) throws IOException;
148         void signalEnqueued() throws IOException;
149     }
150 
151     /**
152      * Returns the HTTP publisher associated with this connection.  May be null
153      * if invoked before connecting.
154      */
155     abstract HttpPublisher publisher();
156 
157     // HTTP/2 MUST use TLS version 1.2 or higher for HTTP/2 over TLS
158     private static final Predicate&lt;String&gt; testRequiredHTTP2TLSVersion = proto -&gt;
159             proto.equals(&quot;TLSv1.2&quot;) || proto.equals(&quot;TLSv1.3&quot;);
160 
161    /**
162     * Returns true if the given client&#39;s SSL parameter protocols contains at
163     * least one TLS version that HTTP/2 requires.
164     */
165    private static final boolean hasRequiredHTTP2TLSVersion(HttpClient client) {
166        String[] protos = client.sslParameters().getProtocols();
167        if (protos != null) {
168            return Arrays.stream(protos).filter(testRequiredHTTP2TLSVersion).findAny().isPresent();
169        } else {
170            return false;
171        }
172    }
173 
174     /**
175      * Factory for retrieving HttpConnections. A connection can be retrieved
176      * from the connection pool, or a new one created if none available.
177      *
178      * The given {@code addr} is the ultimate destination. Any proxies,
179      * etc, are determined from the request. Returns a concrete instance which
180      * is one of the following:
181      *      {@link PlainHttpConnection}
182      *      {@link PlainTunnelingConnection}
183      *
184      * The returned connection, if not from the connection pool, must have its,
185      * connect() or connectAsync() method invoked, which ( when it completes
186      * successfully ) renders the connection usable for requests.
187      */
188     public static HttpConnection getConnection(InetSocketAddress addr,
189                                                HttpClientImpl client,
190                                                HttpRequestImpl request,
191                                                Version version) {
192         // The default proxy selector may select a proxy whose  address is
193         // unresolved. We must resolve the address before connecting to it.
194         InetSocketAddress proxy = Utils.resolveAddress(request.proxy());
195         HttpConnection c = null;
196         boolean secure = request.secure();
197         ConnectionPool pool = client.connectionPool();
198 
199         if (!secure) {
200             c = pool.getConnection(false, addr, proxy);
201             if (c != null &amp;&amp; c.isOpen() /* may have been eof/closed when in the pool */) {
202                 final HttpConnection conn = c;
203                 if (DEBUG_LOGGER.on())
204                     DEBUG_LOGGER.log(conn.getConnectionFlow()
205                                      + &quot;: plain connection retrieved from HTTP/1.1 pool&quot;);
206                 return c;
207             } else {
208                 return getPlainConnection(addr, proxy, request, client);
209             }
210         } else {  // secure
211             if (version != HTTP_2) { // only HTTP/1.1 connections are in the pool
212                 c = pool.getConnection(true, addr, proxy);
213             }
214             if (c != null &amp;&amp; c.isOpen()) {
215                 final HttpConnection conn = c;
216                 if (DEBUG_LOGGER.on())
217                     DEBUG_LOGGER.log(conn.getConnectionFlow()
218                                      + &quot;: SSL connection retrieved from HTTP/1.1 pool&quot;);
219                 return c;
220             } else {
221                 String[] alpn = null;
222                 if (version == HTTP_2 &amp;&amp; hasRequiredHTTP2TLSVersion(client)) {
223                     alpn = new String[] { &quot;h2&quot;, &quot;http/1.1&quot; };
224                 }
225                 return getSSLConnection(addr, proxy, alpn, request, client);
226             }
227         }
228     }
229 
230     private static HttpConnection getSSLConnection(InetSocketAddress addr,
231                                                    InetSocketAddress proxy,
232                                                    String[] alpn,
233                                                    HttpRequestImpl request,
234                                                    HttpClientImpl client) {
235         if (proxy != null)
236             return new AsyncSSLTunnelConnection(addr, client, alpn, proxy,
237                                                 proxyTunnelHeaders(request));
238         else
239             return new AsyncSSLConnection(addr, client, alpn);
240     }
241 
242     /**
243      * This method is used to build a filter that will accept or
244      * veto (header-name, value) tuple for transmission on the
245      * wire.
246      * The filter is applied to the headers when sending the headers
247      * to the remote party.
248      * Which tuple is accepted/vetoed depends on:
249      * &lt;pre&gt;
250      *    - whether the connection is a tunnel connection
251      *      [talking to a server through a proxy tunnel]
252      *    - whether the method is CONNECT
253      *      [establishing a CONNECT tunnel through a proxy]
254      *    - whether the request is using a proxy
255      *      (and the connection is not a tunnel)
256      *      [talking to a server through a proxy]
257      *    - whether the request is a direct connection to
258      *      a server (no tunnel, no proxy).
259      * &lt;/pre&gt;
260      * @param request
261      * @return
262      */
263     BiPredicate&lt;String,String&gt; headerFilter(HttpRequestImpl request) {
264         if (isTunnel()) {
265             // talking to a server through a proxy tunnel
266             // don&#39;t send proxy-* headers to a plain server
267             assert !request.isConnect();
268             return Utils.NO_PROXY_HEADERS_FILTER;
269         } else if (request.isConnect()) {
270             // establishing a proxy tunnel
271             // check for proxy tunnel disabled schemes
272             // assert !this.isTunnel();
273             assert request.proxy() == null;
274             return Utils.PROXY_TUNNEL_FILTER;
275         } else if (request.proxy() != null) {
276             // talking to a server through a proxy (no tunnel)
277             // check for proxy disabled schemes
278             // assert !isTunnel() &amp;&amp; !request.isConnect();
279             return Utils.PROXY_FILTER;
280         } else {
281             // talking to a server directly (no tunnel, no proxy)
282             // don&#39;t send proxy-* headers to a plain server
283             // assert request.proxy() == null &amp;&amp; !request.isConnect();
284             return Utils.NO_PROXY_HEADERS_FILTER;
285         }
286     }
287 
<a name="1" id="anc1"></a>









288     // Composes a new immutable HttpHeaders that combines the
289     // user and system header but only keeps those headers that
290     // start with &quot;proxy-&quot;
291     private static HttpHeaders proxyTunnelHeaders(HttpRequestImpl request) {
292         Map&lt;String, List&lt;String&gt;&gt; combined = new TreeMap&lt;&gt;(String.CASE_INSENSITIVE_ORDER);
293         combined.putAll(request.getSystemHeadersBuilder().map());
294         combined.putAll(request.headers().map()); // let user override system
295 
296         // keep only proxy-* - and also strip authorization headers
297         // for disabled schemes
298         return HttpHeaders.of(combined, Utils.PROXY_TUNNEL_FILTER);
299     }
300 
301     /* Returns either a plain HTTP connection or a plain tunnelling connection
302      * for proxied WebSocket */
303     private static HttpConnection getPlainConnection(InetSocketAddress addr,
304                                                      InetSocketAddress proxy,
305                                                      HttpRequestImpl request,
306                                                      HttpClientImpl client) {
307         if (request.isWebSocket() &amp;&amp; proxy != null)
308             return new PlainTunnelingConnection(addr, proxy, client,
309                                                 proxyTunnelHeaders(request));
310 
311         if (proxy == null)
312             return new PlainHttpConnection(addr, client);
313         else
314             return new PlainProxyConnection(proxy, client);
315     }
316 
317     void closeOrReturnToCache(HttpHeaders hdrs) {
318         if (hdrs == null) {
319             // the connection was closed by server, eof
<a name="2" id="anc2"></a>
320             close();
321             return;
322         }
<a name="3" id="anc3"></a><span class="line-removed">323         if (!isOpen()) {</span>
<span class="line-removed">324             return;</span>
<span class="line-removed">325         }</span>
326         HttpClientImpl client = client();
327         if (client == null) {
<a name="4" id="anc4"></a>
328             close();
329             return;
330         }
331         ConnectionPool pool = client.connectionPool();
332         boolean keepAlive = hdrs.firstValue(&quot;Connection&quot;)
333                 .map((s) -&gt; !s.equalsIgnoreCase(&quot;close&quot;))
334                 .orElse(true);
335 
<a name="5" id="anc5"></a><span class="line-modified">336         if (keepAlive) {</span>
337             Log.logTrace(&quot;Returning connection to the pool: {0}&quot;, this);
338             pool.returnToPool(this);
339         } else {
<a name="6" id="anc6"></a>

340             close();
341         }
342     }
343 
344     /* Tells whether or not this connection is a tunnel through a proxy */
345     boolean isTunnel() { return false; }
346 
347     abstract SocketChannel channel();
348 
349     final InetSocketAddress address() {
350         return address;
351     }
352 
353     abstract ConnectionPool.CacheKey cacheKey();
354 
355     /**
356      * Closes this connection, by returning the socket to its connection pool.
357      */
358     @Override
359     public abstract void close();
360 
361     abstract FlowTube getConnectionFlow();
362 
363     /**
364      * A publisher that makes it possible to publish (write) ordered (normal
365      * priority) and unordered (high priority) buffers downstream.
366      */
367     final class PlainHttpPublisher implements HttpPublisher {
368         final Object reading;
369         PlainHttpPublisher() {
370             this(new Object());
371         }
372         PlainHttpPublisher(Object readingLock) {
373             this.reading = readingLock;
374         }
375         final ConcurrentLinkedDeque&lt;List&lt;ByteBuffer&gt;&gt; queue = new ConcurrentLinkedDeque&lt;&gt;();
376         final ConcurrentLinkedDeque&lt;List&lt;ByteBuffer&gt;&gt; priority = new ConcurrentLinkedDeque&lt;&gt;();
377         volatile Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; subscriber;
378         volatile HttpWriteSubscription subscription;
379         final SequentialScheduler writeScheduler =
380                     new SequentialScheduler(this::flushTask);
381         @Override
382         public void subscribe(Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; subscriber) {
383             synchronized (reading) {
384                 //assert this.subscription == null;
385                 //assert this.subscriber == null;
386                 if (subscription == null) {
387                     subscription = new HttpWriteSubscription();
388                 }
389                 this.subscriber = subscriber;
390             }
391             // TODO: should we do this in the flow?
392             subscriber.onSubscribe(subscription);
393             signal();
394         }
395 
396         void flushTask(DeferredCompleter completer) {
397             try {
398                 HttpWriteSubscription sub = subscription;
399                 if (sub != null) sub.flush();
400             } finally {
401                 completer.complete();
402             }
403         }
404 
405         void signal() {
406             writeScheduler.runOrSchedule();
407         }
408 
409         final class HttpWriteSubscription implements Flow.Subscription {
410             final Demand demand = new Demand();
411 
412             @Override
413             public void request(long n) {
414                 if (n &lt;= 0) throw new IllegalArgumentException(&quot;non-positive request&quot;);
415                 demand.increase(n);
416                 if (debug.on())
417                     debug.log(&quot;HttpPublisher: got request of &quot;  + n + &quot; from &quot;
418                                + getConnectionFlow());
419                 writeScheduler.runOrSchedule();
420             }
421 
422             @Override
423             public void cancel() {
424                 if (debug.on())
425                     debug.log(&quot;HttpPublisher: cancelled by &quot; + getConnectionFlow());
426             }
427 
428             private boolean isEmpty() {
429                 return queue.isEmpty() &amp;&amp; priority.isEmpty();
430             }
431 
432             private List&lt;ByteBuffer&gt; poll() {
433                 List&lt;ByteBuffer&gt; elem = priority.poll();
434                 return elem == null ? queue.poll() : elem;
435             }
436 
437             void flush() {
438                 while (!isEmpty() &amp;&amp; demand.tryDecrement()) {
439                     List&lt;ByteBuffer&gt; elem = poll();
440                     if (debug.on())
441                         debug.log(&quot;HttpPublisher: sending &quot;
442                                     + Utils.remaining(elem) + &quot; bytes (&quot;
443                                     + elem.size() + &quot; buffers) to &quot;
444                                     + getConnectionFlow());
445                     subscriber.onNext(elem);
446                 }
447             }
448         }
449 
450         @Override
451         public void enqueue(List&lt;ByteBuffer&gt; buffers) throws IOException {
452             queue.add(buffers);
453             int bytes = buffers.stream().mapToInt(ByteBuffer::remaining).sum();
454             debug.log(&quot;added %d bytes to the write queue&quot;, bytes);
455         }
456 
457         @Override
458         public void enqueueUnordered(List&lt;ByteBuffer&gt; buffers) throws IOException {
459             // Unordered frames are sent before existing frames.
460             int bytes = buffers.stream().mapToInt(ByteBuffer::remaining).sum();
461             priority.add(buffers);
462             debug.log(&quot;added %d bytes in the priority write queue&quot;, bytes);
463         }
464 
465         @Override
466         public void signalEnqueued() throws IOException {
467             debug.log(&quot;signalling the publisher of the write queue&quot;);
468             signal();
469         }
470     }
471 
472     String dbgTag;
473     final String dbgString() {
474         FlowTube flow = getConnectionFlow();
475         String tag = dbgTag;
476         if (tag == null &amp;&amp; flow != null) {
477             dbgTag = tag = this.getClass().getSimpleName() + &quot;(&quot; + flow + &quot;)&quot;;
478         } else if (tag == null) {
479             tag = this.getClass().getSimpleName() + &quot;(?)&quot;;
480         }
481         return tag;
482     }
483 
484     @Override
485     public String toString() {
486         return &quot;HttpConnection: &quot; + channel().toString();
487     }
488 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
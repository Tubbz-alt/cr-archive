<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.net.http/share/classes/jdk/internal/net/http/common/SubscriberWrapper.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLFlowDelegate.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Utils.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.net.http/share/classes/jdk/internal/net/http/common/SubscriberWrapper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.net.http.common;
 27 
 28 import java.io.Closeable;
<span class="line-removed"> 29 import java.lang.System.Logger.Level;</span>
 30 import java.nio.ByteBuffer;
<span class="line-removed"> 31 import java.util.ArrayList;</span>
 32 import java.util.List;
 33 import java.util.Objects;
 34 import java.util.concurrent.CompletableFuture;
 35 import java.util.concurrent.ConcurrentLinkedQueue;
 36 import java.util.concurrent.Flow;
 37 import java.util.concurrent.Flow.Subscriber;
 38 import java.util.concurrent.atomic.AtomicLong;
 39 import java.util.concurrent.atomic.AtomicReference;
 40 
 41 /**
 42  * A wrapper for a Flow.Subscriber. This wrapper delivers data to the wrapped
 43  * Subscriber which is supplied to the constructor. This class takes care of
 44  * downstream flow control automatically and upstream flow control automatically
 45  * by default.
 46  * &lt;p&gt;
 47  * Processing is done by implementing the {@link #incoming(List, boolean)} method
 48  * which supplies buffers from upstream. This method (or any other method)
 49  * can then call the outgoing() method to deliver processed buffers downstream.
 50  * &lt;p&gt;
 51  * Upstream error signals are delivered downstream directly. Cancellation from
</pre>
<hr />
<pre>
301             // OK - no error, let&#39;s proceed
302             if (!outputQ.isEmpty()) {
303                 if (debug.on())
304                     debug.log(&quot;DownstreamPusher: queue not empty, downstreamSubscription: %s&quot;,
305                               downstreamSubscription);
306             } else {
307                 if (debug.on())
308                     debug.log(&quot;DownstreamPusher: queue empty, downstreamSubscription: %s&quot;,
309                                downstreamSubscription);
310             }
311 
312             boolean datasent = false;
313             while (!outputQ.isEmpty() &amp;&amp; downstreamSubscription.tryDecrement()) {
314                 List&lt;ByteBuffer&gt; b = outputQ.poll();
315                 if (debug.on())
316                     debug.log(&quot;DownstreamPusher: Pushing %d bytes downstream&quot;,
317                               Utils.remaining(b));
318                 downstreamSubscriber.onNext(b);
319                 datasent = true;
320             }
<span class="line-modified">321             if (datasent) upstreamWindowUpdate();</span>














322             checkCompletion();
323         }
324     }
325 








326     void upstreamWindowUpdate() {
327         long downstreamQueueSize = outputQ.size();
328         long upstreamWindowSize = upstreamWindow.get();
329         long n = upstreamWindowUpdate(upstreamWindowSize, downstreamQueueSize);
330         if (debug.on())
331             debug.log(&quot;upstreamWindowUpdate, &quot;
332                       + &quot;downstreamQueueSize:%d, upstreamWindow:%d&quot;,
333                       downstreamQueueSize, upstreamWindowSize);
334         if (n &gt; 0)
335             upstreamRequest(n);
336     }
337 
338     @Override
339     public void onSubscribe(Flow.Subscription subscription) {
340         if (upstreamSubscription != null) {
341             throw new IllegalStateException(&quot;Single shot publisher&quot;);
342         }
343         this.upstreamSubscription = subscription;
<span class="line-modified">344         upstreamRequest(upstreamWindowUpdate(0, 0));</span>
345         if (debug.on())
346             debug.log(&quot;calling downstreamSubscriber::onSubscribe on %s&quot;,
347                       downstreamSubscriber);
348         downstreamSubscriber.onSubscribe(downstreamSubscription);
349         onSubscribe();
350     }
351 
352     @Override
353     public void onNext(List&lt;ByteBuffer&gt; item) {
354         if (debug.on()) debug.log(&quot;onNext&quot;);
355         long prev = upstreamWindow.getAndDecrement();
356         if (prev &lt;= 0)
357             throw new IllegalStateException(&quot;invalid onNext call&quot;);
358         incomingCaller(item, false);
<span class="line-removed">359         upstreamWindowUpdate();</span>
360     }
361 
362     private void upstreamRequest(long n) {
363         if (debug.on()) debug.log(&quot;requesting %d&quot;, n);
364         upstreamWindow.getAndAdd(n);
365         upstreamSubscription.request(n);
366     }
367 










368     protected void requestMore() {
369         if (upstreamWindow.get() == 0) {
370             upstreamRequest(1);
371         }
372     }
373 
374     public long upstreamWindow() {
375         return upstreamWindow.get();
376     }
377 
378     @Override
379     public void onError(Throwable throwable) {
380         if (debug.on()) debug.log(&quot;onError: &quot; + throwable);
381         errorCommon(Objects.requireNonNull(throwable));
382     }
383 
384     protected boolean errorCommon(Throwable throwable) {
385         assert throwable != null ||
386                 (throwable = new AssertionError(&quot;null throwable&quot;)) != null;
387         if (errorRef.compareAndSet(null, throwable)) {
</pre>
</td>
<td>
<hr />
<pre>
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.net.http.common;
 27 
 28 import java.io.Closeable;

 29 import java.nio.ByteBuffer;

 30 import java.util.List;
 31 import java.util.Objects;
 32 import java.util.concurrent.CompletableFuture;
 33 import java.util.concurrent.ConcurrentLinkedQueue;
 34 import java.util.concurrent.Flow;
 35 import java.util.concurrent.Flow.Subscriber;
 36 import java.util.concurrent.atomic.AtomicLong;
 37 import java.util.concurrent.atomic.AtomicReference;
 38 
 39 /**
 40  * A wrapper for a Flow.Subscriber. This wrapper delivers data to the wrapped
 41  * Subscriber which is supplied to the constructor. This class takes care of
 42  * downstream flow control automatically and upstream flow control automatically
 43  * by default.
 44  * &lt;p&gt;
 45  * Processing is done by implementing the {@link #incoming(List, boolean)} method
 46  * which supplies buffers from upstream. This method (or any other method)
 47  * can then call the outgoing() method to deliver processed buffers downstream.
 48  * &lt;p&gt;
 49  * Upstream error signals are delivered downstream directly. Cancellation from
</pre>
<hr />
<pre>
299             // OK - no error, let&#39;s proceed
300             if (!outputQ.isEmpty()) {
301                 if (debug.on())
302                     debug.log(&quot;DownstreamPusher: queue not empty, downstreamSubscription: %s&quot;,
303                               downstreamSubscription);
304             } else {
305                 if (debug.on())
306                     debug.log(&quot;DownstreamPusher: queue empty, downstreamSubscription: %s&quot;,
307                                downstreamSubscription);
308             }
309 
310             boolean datasent = false;
311             while (!outputQ.isEmpty() &amp;&amp; downstreamSubscription.tryDecrement()) {
312                 List&lt;ByteBuffer&gt; b = outputQ.poll();
313                 if (debug.on())
314                     debug.log(&quot;DownstreamPusher: Pushing %d bytes downstream&quot;,
315                               Utils.remaining(b));
316                 downstreamSubscriber.onNext(b);
317                 datasent = true;
318             }
<span class="line-modified">319 </span>
<span class="line-added">320             // If we have sent some decrypted data downstream,</span>
<span class="line-added">321             // or if:</span>
<span class="line-added">322             //    - there&#39;s nothing more available to send downstream</span>
<span class="line-added">323             //    - and we still have some demand from downstream</span>
<span class="line-added">324             //    - and upstream is not completed yet</span>
<span class="line-added">325             //    - and our demand from upstream has reached 0,</span>
<span class="line-added">326             // then check whether we should request more data from</span>
<span class="line-added">327             // upstream</span>
<span class="line-added">328             if (datasent || outputQ.isEmpty()</span>
<span class="line-added">329                     &amp;&amp; !downstreamSubscription.demand.isFulfilled()</span>
<span class="line-added">330                     &amp;&amp; !upstreamCompleted</span>
<span class="line-added">331                     &amp;&amp; upstreamWindow.get() == 0) {</span>
<span class="line-added">332                 upstreamWindowUpdate();</span>
<span class="line-added">333             }</span>
334             checkCompletion();
335         }
336     }
337 
<span class="line-added">338     final int outputQueueSize() {</span>
<span class="line-added">339         return outputQ.size();</span>
<span class="line-added">340     }</span>
<span class="line-added">341 </span>
<span class="line-added">342     final boolean hasNoOutputData() {</span>
<span class="line-added">343         return outputQ.isEmpty();</span>
<span class="line-added">344     }</span>
<span class="line-added">345 </span>
346     void upstreamWindowUpdate() {
347         long downstreamQueueSize = outputQ.size();
348         long upstreamWindowSize = upstreamWindow.get();
349         long n = upstreamWindowUpdate(upstreamWindowSize, downstreamQueueSize);
350         if (debug.on())
351             debug.log(&quot;upstreamWindowUpdate, &quot;
352                       + &quot;downstreamQueueSize:%d, upstreamWindow:%d&quot;,
353                       downstreamQueueSize, upstreamWindowSize);
354         if (n &gt; 0)
355             upstreamRequest(n);
356     }
357 
358     @Override
359     public void onSubscribe(Flow.Subscription subscription) {
360         if (upstreamSubscription != null) {
361             throw new IllegalStateException(&quot;Single shot publisher&quot;);
362         }
363         this.upstreamSubscription = subscription;
<span class="line-modified">364         upstreamRequest(initialUpstreamDemand());</span>
365         if (debug.on())
366             debug.log(&quot;calling downstreamSubscriber::onSubscribe on %s&quot;,
367                       downstreamSubscriber);
368         downstreamSubscriber.onSubscribe(downstreamSubscription);
369         onSubscribe();
370     }
371 
372     @Override
373     public void onNext(List&lt;ByteBuffer&gt; item) {
374         if (debug.on()) debug.log(&quot;onNext&quot;);
375         long prev = upstreamWindow.getAndDecrement();
376         if (prev &lt;= 0)
377             throw new IllegalStateException(&quot;invalid onNext call&quot;);
378         incomingCaller(item, false);

379     }
380 
381     private void upstreamRequest(long n) {
382         if (debug.on()) debug.log(&quot;requesting %d&quot;, n);
383         upstreamWindow.getAndAdd(n);
384         upstreamSubscription.request(n);
385     }
386 
<span class="line-added">387     /**</span>
<span class="line-added">388      * Initial demand that should be requested</span>
<span class="line-added">389      * from upstream when we get the upstream subscription</span>
<span class="line-added">390      * from {@link #onSubscribe(Flow.Subscription)}.</span>
<span class="line-added">391      * @return The initial demand to request from upstream.</span>
<span class="line-added">392      */</span>
<span class="line-added">393     protected long initialUpstreamDemand() {</span>
<span class="line-added">394         return 1;</span>
<span class="line-added">395     }</span>
<span class="line-added">396 </span>
397     protected void requestMore() {
398         if (upstreamWindow.get() == 0) {
399             upstreamRequest(1);
400         }
401     }
402 
403     public long upstreamWindow() {
404         return upstreamWindow.get();
405     }
406 
407     @Override
408     public void onError(Throwable throwable) {
409         if (debug.on()) debug.log(&quot;onError: &quot; + throwable);
410         errorCommon(Objects.requireNonNull(throwable));
411     }
412 
413     protected boolean errorCommon(Throwable throwable) {
414         assert throwable != null ||
415                 (throwable = new AssertionError(&quot;null throwable&quot;)) != null;
416         if (errorRef.compareAndSet(null, throwable)) {
</pre>
</td>
</tr>
</table>
<center><a href="SSLFlowDelegate.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Utils.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
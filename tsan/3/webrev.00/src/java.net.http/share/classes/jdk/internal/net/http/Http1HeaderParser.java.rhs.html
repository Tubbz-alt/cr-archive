<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.net.http/share/classes/jdk/internal/net/http/Http1HeaderParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.net.http;
 27 
 28 import java.net.ProtocolException;
 29 import java.nio.ByteBuffer;
 30 import java.util.ArrayList;
 31 import java.util.HashMap;
 32 import java.util.List;
 33 import java.util.Locale;
 34 import java.util.Map;
 35 import java.net.http.HttpHeaders;
 36 import static java.lang.String.format;
 37 import static java.util.Objects.requireNonNull;
 38 import static jdk.internal.net.http.common.Utils.ACCEPT_ALL;
 39 
 40 class Http1HeaderParser {
 41 
 42     private static final char CR = &#39;\r&#39;;
 43     private static final char LF = &#39;\n&#39;;
 44     private static final char HT = &#39;\t&#39;;
 45     private static final char SP = &#39; &#39;;
 46 
 47     private StringBuilder sb = new StringBuilder();
 48     private String statusLine;
 49     private int responseCode;
 50     private HttpHeaders headers;
 51     private Map&lt;String,List&lt;String&gt;&gt; privateMap = new HashMap&lt;&gt;();
 52 
 53     enum State { INITIAL,
 54                  STATUS_LINE,
 55                  STATUS_LINE_FOUND_CR,
 56                  STATUS_LINE_FOUND_LF,
 57                  STATUS_LINE_END,
 58                  STATUS_LINE_END_CR,
 59                  STATUS_LINE_END_LF,
 60                  HEADER,
 61                  HEADER_FOUND_CR,
 62                  HEADER_FOUND_LF,
 63                  HEADER_FOUND_CR_LF,
 64                  HEADER_FOUND_CR_LF_CR,
 65                  FINISHED }
 66 
 67     private State state = State.INITIAL;
 68 
 69     /** Returns the status-line. */
 70     String statusLine() { return statusLine; }
 71 
 72     /** Returns the response code. */
 73     int responseCode() { return responseCode; }
 74 
 75     /** Returns the headers, possibly empty. */
 76     HttpHeaders headers() {
 77         assert state == State.FINISHED : &quot;Unexpected state &quot; + state;
 78         return headers;
 79     }
 80 
 81     /** A current-state message suitable for inclusion in an exception detail message. */
 82     public String currentStateMessage() {
 83         String stateName = state.name();
 84         String msg;
 85         if (stateName.contains(&quot;INITIAL&quot;)) {
 86             return format(&quot;HTTP/1.1 header parser received no bytes&quot;);
 87         } else if (stateName.contains(&quot;STATUS&quot;)) {
 88             msg = format(&quot;parsing HTTP/1.1 status line, receiving [%s]&quot;, sb.toString());
 89         } else if (stateName.contains(&quot;HEADER&quot;)) {
 90             String headerName = sb.toString();
 91             if (headerName.indexOf(&#39;:&#39;) != -1)
 92                 headerName = headerName.substring(0, headerName.indexOf(&#39;:&#39;)+1) + &quot;...&quot;;
 93             msg = format(&quot;parsing HTTP/1.1 header, receiving [%s]&quot;, headerName);
 94         } else {
 95             msg =format(&quot;HTTP/1.1 parser receiving [%s]&quot;, state, sb.toString());
 96         }
 97         return format(&quot;%s, parser state [%s]&quot;, msg , state);
 98     }
 99 
100     /**
101      * Parses HTTP/1.X status-line and headers from the given bytes. Must be
102      * called successive times, with additional data, until returns true.
103      *
104      * All given ByteBuffers will be consumed, until ( possibly ) the last one
105      * ( when true is returned ), which may not be fully consumed.
106      *
107      * @param input the ( partial ) header data
108      * @return true iff the end of the headers block has been reached
109      */
110     boolean parse(ByteBuffer input) throws ProtocolException {
111         requireNonNull(input, &quot;null input&quot;);
112 
113         while (canContinueParsing(input)) {
114             switch (state) {
115                 case INITIAL:
116                     state = State.STATUS_LINE;
117                     break;
118                 case STATUS_LINE:
119                     readResumeStatusLine(input);
120                     break;
121                 // fallthrough
122                 case STATUS_LINE_FOUND_CR:
123                 case STATUS_LINE_FOUND_LF:
124                     readStatusLineFeed(input);
125                     break;
126                 case STATUS_LINE_END:
127                     maybeStartHeaders(input);
128                     break;
129                 // fallthrough
130                 case STATUS_LINE_END_CR:
131                 case STATUS_LINE_END_LF:
132                     maybeEndHeaders(input);
133                     break;
134                 case HEADER:
135                     readResumeHeader(input);
136                     break;
137                 // fallthrough
138                 case HEADER_FOUND_CR:
139                 case HEADER_FOUND_LF:
140                     resumeOrLF(input);
141                     break;
142                 case HEADER_FOUND_CR_LF:
143                     resumeOrSecondCR(input);
144                     break;
145                 case HEADER_FOUND_CR_LF_CR:
146                     resumeOrEndHeaders(input);
147                     break;
148                 default:
149                     throw new InternalError(
150                             &quot;Unexpected state: &quot; + String.valueOf(state));
151             }
152         }
153 
154         return state == State.FINISHED;
155     }
156 
157     private boolean canContinueParsing(ByteBuffer buffer) {
158         // some states don&#39;t require any input to transition
159         // to the next state.
160         switch (state) {
161             case FINISHED: return false;
162             case STATUS_LINE_FOUND_LF: return true;
163             case STATUS_LINE_END_LF: return true;
164             case HEADER_FOUND_LF: return true;
165             default: return buffer.hasRemaining();
166         }
167     }
168 
169     private void readResumeStatusLine(ByteBuffer input) {
170         char c = 0;
171         while (input.hasRemaining() &amp;&amp; (c =(char)input.get()) != CR) {
172             if (c == LF) break;
173             sb.append(c);
174         }
175         if (c == CR) {
176             state = State.STATUS_LINE_FOUND_CR;
177         } else if (c == LF) {
178             state = State.STATUS_LINE_FOUND_LF;
179         }
180     }
181 
182     private void readStatusLineFeed(ByteBuffer input) throws ProtocolException {
183         char c = state == State.STATUS_LINE_FOUND_LF ? LF : (char)input.get();
184         if (c != LF) {
185             throw protocolException(&quot;Bad trailing char, \&quot;%s\&quot;, when parsing status line, \&quot;%s\&quot;&quot;,
186                                     c, sb.toString());
187         }
188 
189         statusLine = sb.toString();
190         sb = new StringBuilder();
191         if (!statusLine.startsWith(&quot;HTTP/1.&quot;)) {
192             throw protocolException(&quot;Invalid status line: \&quot;%s\&quot;&quot;, statusLine);
193         }
194         if (statusLine.length() &lt; 12) {
195             throw protocolException(&quot;Invalid status line: \&quot;%s\&quot;&quot;, statusLine);
196         }
<a name="1" id="anc1"></a><span class="line-modified">197         try {</span>
<span class="line-added">198             responseCode = Integer.parseInt(statusLine.substring(9, 12));</span>
<span class="line-added">199         } catch (NumberFormatException nfe) {</span>
<span class="line-added">200             throw protocolException(&quot;Invalid status line: \&quot;%s\&quot;&quot;, statusLine);</span>
<span class="line-added">201         }</span>
<span class="line-added">202         // response code expected to be a 3-digit integer (RFC-2616, section 6.1.1)</span>
<span class="line-added">203         if (responseCode &lt; 100) {</span>
<span class="line-added">204             throw protocolException(&quot;Invalid status line: \&quot;%s\&quot;&quot;, statusLine);</span>
<span class="line-added">205         }</span>
206 
207         state = State.STATUS_LINE_END;
208     }
209 
210     private void maybeStartHeaders(ByteBuffer input) {
211         assert state == State.STATUS_LINE_END;
212         assert sb.length() == 0;
213         char c = (char)input.get();
214         if (c == CR) {
215             state = State.STATUS_LINE_END_CR;
216         } else if (c == LF) {
217             state = State.STATUS_LINE_END_LF;
218         } else {
219             sb.append(c);
220             state = State.HEADER;
221         }
222     }
223 
224     private void maybeEndHeaders(ByteBuffer input) throws ProtocolException {
225         assert state == State.STATUS_LINE_END_CR || state == State.STATUS_LINE_END_LF;
226         assert sb.length() == 0;
227         char c = state == State.STATUS_LINE_END_LF ? LF : (char)input.get();
228         if (c == LF) {
229             headers = HttpHeaders.of(privateMap, ACCEPT_ALL);
230             privateMap = null;
231             state = State.FINISHED;  // no headers
232         } else {
233             throw protocolException(&quot;Unexpected \&quot;%s\&quot;, after status line CR&quot;, c);
234         }
235     }
236 
237     private void readResumeHeader(ByteBuffer input) {
238         assert state == State.HEADER;
239         assert input.hasRemaining();
240         while (input.hasRemaining()) {
241             char c = (char)input.get();
242             if (c == CR) {
243                 state = State.HEADER_FOUND_CR;
244                 break;
245             } else if (c == LF) {
246                 state = State.HEADER_FOUND_LF;
247                 break;
248             }
249 
250             if (c == HT)
251                 c = SP;
252             sb.append(c);
253         }
254     }
255 
256     private void addHeaderFromString(String headerString) {
257         assert sb.length() == 0;
258         int idx = headerString.indexOf(&#39;:&#39;);
259         if (idx == -1)
260             return;
261         String name = headerString.substring(0, idx).trim();
262         if (name.isEmpty())
263             return;
264         String value = headerString.substring(idx + 1, headerString.length()).trim();
265 
266         privateMap.computeIfAbsent(name.toLowerCase(Locale.US),
267                                    k -&gt; new ArrayList&lt;&gt;()).add(value);
268     }
269 
270     private void resumeOrLF(ByteBuffer input) {
271         assert state == State.HEADER_FOUND_CR || state == State.HEADER_FOUND_LF;
272         char c = state == State.HEADER_FOUND_LF ? LF : (char)input.get();
273         if (c == LF) {
274             // header value will be flushed by
275             // resumeOrSecondCR if next line does not
276             // begin by SP or HT
277             state = State.HEADER_FOUND_CR_LF;
278         } else if (c == SP || c == HT) {
279             sb.append(SP); // parity with MessageHeaders
280             state = State.HEADER;
281         } else {
282             sb = new StringBuilder();
283             sb.append(c);
284             state = State.HEADER;
285         }
286     }
287 
288     private void resumeOrSecondCR(ByteBuffer input) {
289         assert state == State.HEADER_FOUND_CR_LF;
290         char c = (char)input.get();
291         if (c == CR || c == LF) {
292             if (sb.length() &gt; 0) {
293                 // no continuation line - flush
294                 // previous header value.
295                 String headerString = sb.toString();
296                 sb = new StringBuilder();
297                 addHeaderFromString(headerString);
298             }
299             if (c == CR) {
300                 state = State.HEADER_FOUND_CR_LF_CR;
301             } else {
302                 state = State.FINISHED;
303                 headers = HttpHeaders.of(privateMap, ACCEPT_ALL);
304                 privateMap = null;
305             }
306         } else if (c == SP || c == HT) {
307             assert sb.length() != 0;
308             sb.append(SP); // continuation line
309             state = State.HEADER;
310         } else {
311             if (sb.length() &gt; 0) {
312                 // no continuation line - flush
313                 // previous header value.
314                 String headerString = sb.toString();
315                 sb = new StringBuilder();
316                 addHeaderFromString(headerString);
317             }
318             sb.append(c);
319             state = State.HEADER;
320         }
321     }
322 
323     private void resumeOrEndHeaders(ByteBuffer input) throws ProtocolException {
324         assert state == State.HEADER_FOUND_CR_LF_CR;
325         char c = (char)input.get();
326         if (c == LF) {
327             state = State.FINISHED;
328             headers = HttpHeaders.of(privateMap, ACCEPT_ALL);
329             privateMap = null;
330         } else {
331             throw protocolException(&quot;Unexpected \&quot;%s\&quot;, after CR LF CR&quot;, c);
332         }
333     }
334 
335     private ProtocolException protocolException(String format, Object... args) {
336         return new ProtocolException(format(format, args));
337     }
338 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
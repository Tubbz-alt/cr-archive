<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.net.http/share/classes/jdk/internal/net/http/ExchangeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.net.http;
 27 
 28 import java.io.IOException;
<a name="1" id="anc1"></a>


 29 import java.net.http.HttpClient;
 30 import java.net.http.HttpResponse;
<a name="2" id="anc2"></a><span class="line-added"> 31 import java.util.concurrent.CompletableFuture;</span>
<span class="line-added"> 32 import java.util.concurrent.Executor;</span>
<span class="line-added"> 33 </span>
 34 import jdk.internal.net.http.common.Logger;
 35 import jdk.internal.net.http.common.MinimalFuture;
 36 import jdk.internal.net.http.common.Utils;
<a name="3" id="anc3"></a><span class="line-added"> 37 </span>
 38 import static java.net.http.HttpClient.Version.HTTP_1_1;
 39 
 40 /**
 41  * Splits request so that headers and body can be sent separately with optional
 42  * (multiple) responses in between (e.g. 100 Continue). Also request and
 43  * response always sent/received in different calls.
 44  *
 45  * Synchronous and asynchronous versions of each method are provided.
 46  *
 47  * Separate implementations of this class exist for HTTP/1.1 and HTTP/2
 48  *      Http1Exchange   (HTTP/1.1)
 49  *      Stream          (HTTP/2)
 50  *
 51  * These implementation classes are where work is allocated to threads.
 52  */
 53 abstract class ExchangeImpl&lt;T&gt; {
 54 
 55     private static final Logger debug =
 56             Utils.getDebugLogger(&quot;ExchangeImpl&quot;::toString, Utils.DEBUG);
 57 
 58     final Exchange&lt;T&gt; exchange;
 59 
 60     ExchangeImpl(Exchange&lt;T&gt; e) {
 61         // e == null means a http/2 pushed stream
 62         this.exchange = e;
 63     }
 64 
 65     final Exchange&lt;T&gt; getExchange() {
 66         return exchange;
 67     }
 68 
 69     HttpClient client() {
 70         return exchange.client();
 71     }
 72 
 73     /**
 74      * Returns the {@link HttpConnection} instance to which this exchange is
 75      * assigned.
 76      */
 77     abstract HttpConnection connection();
 78 
 79     /**
 80      * Initiates a new exchange and assigns it to a connection if one exists
 81      * already. connection usually null.
 82      */
 83     static &lt;U&gt; CompletableFuture&lt;? extends ExchangeImpl&lt;U&gt;&gt;
 84     get(Exchange&lt;U&gt; exchange, HttpConnection connection)
 85     {
 86         if (exchange.version() == HTTP_1_1) {
 87             if (debug.on())
 88                 debug.log(&quot;get: HTTP/1.1: new Http1Exchange&quot;);
 89             return createHttp1Exchange(exchange, connection);
 90         } else {
 91             Http2ClientImpl c2 = exchange.client().client2(); // #### improve
 92             HttpRequestImpl request = exchange.request();
 93             CompletableFuture&lt;Http2Connection&gt; c2f = c2.getConnectionFor(request, exchange);
 94             if (debug.on())
 95                 debug.log(&quot;get: Trying to get HTTP/2 connection&quot;);
<a name="4" id="anc4"></a><span class="line-modified"> 96             // local variable required here; see JDK-8223553</span>
<span class="line-modified"> 97             CompletableFuture&lt;CompletableFuture&lt;? extends ExchangeImpl&lt;U&gt;&gt;&gt; fxi =</span>
<span class="line-added"> 98                 c2f.handle((h2c, t) -&gt; createExchangeImpl(h2c, t, exchange, connection));</span>
<span class="line-added"> 99             return fxi.thenCompose(x-&gt;x);</span>
100         }
101     }
102 
103     private static &lt;U&gt; CompletableFuture&lt;? extends ExchangeImpl&lt;U&gt;&gt;
104     createExchangeImpl(Http2Connection c,
105                        Throwable t,
106                        Exchange&lt;U&gt; exchange,
107                        HttpConnection connection)
108     {
109         if (debug.on())
110             debug.log(&quot;handling HTTP/2 connection creation result&quot;);
111         boolean secure = exchange.request().secure();
112         if (t != null) {
113             if (debug.on())
114                 debug.log(&quot;handling HTTP/2 connection creation failed: %s&quot;,
115                                  (Object)t);
116             t = Utils.getCompletionCause(t);
117             if (t instanceof Http2Connection.ALPNException) {
118                 Http2Connection.ALPNException ee = (Http2Connection.ALPNException)t;
119                 AbstractAsyncSSLConnection as = ee.getConnection();
120                 if (debug.on())
121                     debug.log(&quot;downgrading to HTTP/1.1 with: %s&quot;, as);
122                 CompletableFuture&lt;? extends ExchangeImpl&lt;U&gt;&gt; ex =
123                         createHttp1Exchange(exchange, as);
124                 return ex;
125             } else {
126                 if (debug.on())
127                     debug.log(&quot;HTTP/2 connection creation failed &quot;
128                                      + &quot;with unexpected exception: %s&quot;, (Object)t);
129                 return MinimalFuture.failedFuture(t);
130             }
131         }
132         if (secure &amp;&amp; c== null) {
133             if (debug.on())
134                 debug.log(&quot;downgrading to HTTP/1.1 &quot;);
135             CompletableFuture&lt;? extends ExchangeImpl&lt;U&gt;&gt; ex =
136                     createHttp1Exchange(exchange, null);
137             return ex;
138         }
139         if (c == null) {
140             // no existing connection. Send request with HTTP 1 and then
141             // upgrade if successful
142             if (debug.on())
143                 debug.log(&quot;new Http1Exchange, try to upgrade&quot;);
144             return createHttp1Exchange(exchange, connection)
145                     .thenApply((e) -&gt; {
146                         exchange.h2Upgrade();
147                         return e;
148                     });
149         } else {
150             if (debug.on()) debug.log(&quot;creating HTTP/2 streams&quot;);
151             Stream&lt;U&gt; s = c.createStream(exchange);
152             CompletableFuture&lt;? extends ExchangeImpl&lt;U&gt;&gt; ex = MinimalFuture.completedFuture(s);
153             return ex;
154         }
155     }
156 
157     private static &lt;T&gt; CompletableFuture&lt;Http1Exchange&lt;T&gt;&gt;
158     createHttp1Exchange(Exchange&lt;T&gt; ex, HttpConnection as)
159     {
160         try {
161             return MinimalFuture.completedFuture(new Http1Exchange&lt;&gt;(ex, as));
162         } catch (Throwable e) {
163             return MinimalFuture.failedFuture(e);
164         }
165     }
166 
167     // Called for 204 response - when no body is permitted
168     void nullBody(HttpResponse&lt;T&gt; resp, Throwable t) {
169         // only needed for HTTP/1.1 to close the connection
170         // or return it to the pool
171     }
172 
173     /* The following methods have separate HTTP/1.1 and HTTP/2 implementations */
174 
175     abstract CompletableFuture&lt;ExchangeImpl&lt;T&gt;&gt; sendHeadersAsync();
176 
177     /** Sends a request body, after request headers have been sent. */
178     abstract CompletableFuture&lt;ExchangeImpl&lt;T&gt;&gt; sendBodyAsync();
179 
180     abstract CompletableFuture&lt;T&gt; readBodyAsync(HttpResponse.BodyHandler&lt;T&gt; handler,
181                                                 boolean returnConnectionToPool,
182                                                 Executor executor);
183 
184     /**
185      * Ignore/consume the body.
186      */
187     abstract CompletableFuture&lt;Void&gt; ignoreBody();
188 
189 
190     /** Gets the response headers. Completes before body is read. */
191     abstract CompletableFuture&lt;Response&gt; getResponseAsync(Executor executor);
192 
193 
194     /** Cancels a request.  Not currently exposed through API. */
195     abstract void cancel();
196 
197     /**
198      * Cancels a request with a cause.  Not currently exposed through API.
199      */
200     abstract void cancel(IOException cause);
201 
202     /**
203      * Called when the exchange is released, so that cleanup actions may be
204      * performed - such as deregistering callbacks.
205      * Typically released is called during upgrade, when an HTTP/2 stream
206      * takes over from an Http1Exchange, or when a new exchange is created
207      * during a multi exchange before the final response body was received.
208      */
209     abstract void released();
210 
211     /**
212      * Called when the exchange is completed, so that cleanup actions may be
213      * performed - such as deregistering callbacks.
214      * Typically, completed is called at the end of the exchange, when the
215      * final response body has been received (or an error has caused the
216      * completion of the exchange).
217      */
218     abstract void completed();
219 
220     /**
221      * Returns true if this exchange was canceled.
222      * @return true if this exchange was canceled.
223      */
224     abstract boolean isCanceled();
225 
226     /**
227      * Returns the cause for which this exchange was canceled, if available.
228      * @return the cause for which this exchange was canceled, if available.
229      */
230     abstract Throwable getCancelCause();
231 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
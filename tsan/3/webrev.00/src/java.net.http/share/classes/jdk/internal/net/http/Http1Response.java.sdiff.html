<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.net.http/share/classes/jdk/internal/net/http/Http1Response.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Http1Request.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Http2ClientImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.net.http/share/classes/jdk/internal/net/http/Http1Response.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
247                 return -1L;
248             }
249             if (responseCode == 101) {
250                 // this is a h2c or websocket upgrade, contentlength must be zero
251                 return 0L;
252             }
253             return -2L;
254         }
255         return clen;
256     }
257 
258     /**
259      * Read up to MAX_IGNORE bytes discarding
260      */
261     public CompletableFuture&lt;Void&gt; ignoreBody(Executor executor) {
262         int clen = (int)headers.firstValueAsLong(&quot;Content-Length&quot;).orElse(-1);
263         if (clen == -1 || clen &gt; MAX_IGNORE) {
264             connection.close();
265             return MinimalFuture.completedFuture(null); // not treating as error
266         } else {
<span class="line-modified">267             return readBody(discarding(), true, executor);</span>
268         }
269     }
270 
271     // Used for those response codes that have no body associated
272     public void nullBody(HttpResponse&lt;T&gt; resp, Throwable t) {
273         if (t != null) connection.close();
274         else {
275             return2Cache = !request.isWebSocket();
276             onFinished();
277         }
278     }
279 
280     static final Flow.Subscription NOP = new Flow.Subscription() {
281         @Override
282         public void request(long n) { }
283         public void cancel() { }
284     };
285 
286     /**
287      * The Http1AsyncReceiver ensures that all calls to
</pre>
<hr />
<pre>
377             }
378         }
379         @Override
380         public void onNext(List&lt;ByteBuffer&gt; item) {
381             assert !completed.get();
382             userSubscriber.onNext(item);
383         }
384         @Override
385         public void onError(Throwable throwable) {
386             complete(throwable);
387         }
388         @Override
389         public void onComplete() {
390             complete(null);
391         }
392     }
393 
394     public &lt;U&gt; CompletableFuture&lt;U&gt; readBody(HttpResponse.BodySubscriber&lt;U&gt; p,
395                                          boolean return2Cache,
396                                          Executor executor) {








397         this.return2Cache = return2Cache;
398         final Http1BodySubscriber&lt;U&gt; subscriber = new Http1BodySubscriber&lt;&gt;(p);
399 
400         final CompletableFuture&lt;U&gt; cf = new MinimalFuture&lt;&gt;();
401 
402         long clen0 = headers.firstValueAsLong(&quot;Content-Length&quot;).orElse(-1L);
403         final long clen = fixupContentLen(clen0);
404 
405         // expect-continue reads headers and body twice.
406         // if we reach here, we must reset the headersReader state.
407         asyncReceiver.unsubscribe(headersReader);
408         headersReader.reset();
409         ClientRefCountTracker refCountTracker = new ClientRefCountTracker();
410 
411         // We need to keep hold on the client facade until the
412         // tracker has been incremented.
413         connection.client().reference();
414         executor.execute(() -&gt; {
415             try {
416                 content = new ResponseContent(
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
247                 return -1L;
248             }
249             if (responseCode == 101) {
250                 // this is a h2c or websocket upgrade, contentlength must be zero
251                 return 0L;
252             }
253             return -2L;
254         }
255         return clen;
256     }
257 
258     /**
259      * Read up to MAX_IGNORE bytes discarding
260      */
261     public CompletableFuture&lt;Void&gt; ignoreBody(Executor executor) {
262         int clen = (int)headers.firstValueAsLong(&quot;Content-Length&quot;).orElse(-1);
263         if (clen == -1 || clen &gt; MAX_IGNORE) {
264             connection.close();
265             return MinimalFuture.completedFuture(null); // not treating as error
266         } else {
<span class="line-modified">267             return readBody(discarding(), !request.isWebSocket(), executor);</span>
268         }
269     }
270 
271     // Used for those response codes that have no body associated
272     public void nullBody(HttpResponse&lt;T&gt; resp, Throwable t) {
273         if (t != null) connection.close();
274         else {
275             return2Cache = !request.isWebSocket();
276             onFinished();
277         }
278     }
279 
280     static final Flow.Subscription NOP = new Flow.Subscription() {
281         @Override
282         public void request(long n) { }
283         public void cancel() { }
284     };
285 
286     /**
287      * The Http1AsyncReceiver ensures that all calls to
</pre>
<hr />
<pre>
377             }
378         }
379         @Override
380         public void onNext(List&lt;ByteBuffer&gt; item) {
381             assert !completed.get();
382             userSubscriber.onNext(item);
383         }
384         @Override
385         public void onError(Throwable throwable) {
386             complete(throwable);
387         }
388         @Override
389         public void onComplete() {
390             complete(null);
391         }
392     }
393 
394     public &lt;U&gt; CompletableFuture&lt;U&gt; readBody(HttpResponse.BodySubscriber&lt;U&gt; p,
395                                          boolean return2Cache,
396                                          Executor executor) {
<span class="line-added">397         if (debug.on()) {</span>
<span class="line-added">398             debug.log(&quot;readBody: return2Cache: &quot; + return2Cache);</span>
<span class="line-added">399             if (request.isWebSocket() &amp;&amp; return2Cache &amp;&amp; connection != null) {</span>
<span class="line-added">400                 debug.log(&quot;websocket connection will be returned to cache: &quot;</span>
<span class="line-added">401                         + connection.getClass() + &quot;/&quot; + connection );</span>
<span class="line-added">402             }</span>
<span class="line-added">403         }</span>
<span class="line-added">404         assert !return2Cache || !request.isWebSocket();</span>
405         this.return2Cache = return2Cache;
406         final Http1BodySubscriber&lt;U&gt; subscriber = new Http1BodySubscriber&lt;&gt;(p);
407 
408         final CompletableFuture&lt;U&gt; cf = new MinimalFuture&lt;&gt;();
409 
410         long clen0 = headers.firstValueAsLong(&quot;Content-Length&quot;).orElse(-1L);
411         final long clen = fixupContentLen(clen0);
412 
413         // expect-continue reads headers and body twice.
414         // if we reach here, we must reset the headersReader state.
415         asyncReceiver.unsubscribe(headersReader);
416         headersReader.reset();
417         ClientRefCountTracker refCountTracker = new ClientRefCountTracker();
418 
419         // We need to keep hold on the client facade until the
420         // tracker has been incremented.
421         connection.client().reference();
422         executor.execute(() -&gt; {
423             try {
424                 content = new ResponseContent(
</pre>
</td>
</tr>
</table>
<center><a href="Http1Request.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Http2ClientImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
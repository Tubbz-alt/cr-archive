<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.net.http/share/classes/jdk/internal/net/http/ResponseSubscribers.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RequestPublishers.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="common/Log.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.net.http/share/classes/jdk/internal/net/http/ResponseSubscribers.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 108         }
 109     }
 110 
 111     public static class ConsumerSubscriber implements TrustedSubscriber&lt;Void&gt; {
 112         private final Consumer&lt;Optional&lt;byte[]&gt;&gt; consumer;
 113         private Flow.Subscription subscription;
 114         private final CompletableFuture&lt;Void&gt; result = new MinimalFuture&lt;&gt;();
 115         private final AtomicBoolean subscribed = new AtomicBoolean();
 116 
 117         public ConsumerSubscriber(Consumer&lt;Optional&lt;byte[]&gt;&gt; consumer) {
 118             this.consumer = Objects.requireNonNull(consumer);
 119         }
 120 
 121         @Override
 122         public CompletionStage&lt;Void&gt; getBody() {
 123             return result;
 124         }
 125 
 126         @Override
 127         public void onSubscribe(Flow.Subscription subscription) {

 128             if (!subscribed.compareAndSet(false, true)) {
 129                 subscription.cancel();
 130             } else {
 131                 this.subscription = subscription;
 132                 subscription.request(1);
 133             }
 134         }
 135 
 136         @Override
 137         public void onNext(List&lt;ByteBuffer&gt; items) {

 138             for (ByteBuffer item : items) {
 139                 byte[] buf = new byte[item.remaining()];
 140                 item.get(buf);
 141                 consumer.accept(Optional.of(buf));
 142             }
 143             subscription.request(1);
 144         }
 145 
 146         @Override
 147         public void onError(Throwable throwable) {

 148             result.completeExceptionally(throwable);
 149         }
 150 
 151         @Override
 152         public void onComplete() {
 153             consumer.accept(Optional.empty());
 154             result.complete(null);
 155         }
 156 
 157     }
 158 
 159     /**
 160      * A Subscriber that writes the flow of data to a given file.
 161      *
 162      * Privileged actions are performed within a limited doPrivileged that only
 163      * asserts the specific, write, file permissions that were checked during
 164      * the construction of this PathSubscriber.
 165      */
 166     public static class PathSubscriber implements TrustedSubscriber&lt;Path&gt; {
 167 
 168         private static final FilePermission[] EMPTY_FILE_PERMISSIONS = new FilePermission[0];
 169 
 170         private final Path file;
 171         private final OpenOption[] options;
 172         private final FilePermission[] filePermissions;
 173         private final CompletableFuture&lt;Path&gt; result = new MinimalFuture&lt;&gt;();
 174 

 175         private volatile Flow.Subscription subscription;
 176         private volatile FileChannel out;
 177 
 178         private static final String pathForSecurityCheck(Path path) {
 179             return path.toFile().getPath();
 180         }
 181 
 182         /**
 183          * Factory for creating PathSubscriber.
 184          *
 185          * Permission checks are performed here before construction of the
 186          * PathSubscriber. Permission checking and construction are deliberately
 187          * and tightly co-located.
 188          */
 189         public static PathSubscriber create(Path file,
 190                                             List&lt;OpenOption&gt; options) {
 191             FilePermission filePermission = null;
 192             SecurityManager sm = System.getSecurityManager();
 193             if (sm != null) {
 194                 String fn = pathForSecurityCheck(file);
 195                 FilePermission writePermission = new FilePermission(fn, &quot;write&quot;);
 196                 sm.checkPermission(writePermission);
 197                 filePermission = writePermission;
 198             }
 199             return new PathSubscriber(file, options, filePermission);
 200         }
 201 
 202         // pp so handler implementations in the same package can construct
 203         /*package-private*/ PathSubscriber(Path file,
 204                                            List&lt;OpenOption&gt; options,
 205                                            FilePermission... filePermissions) {
 206             this.file = file;
 207             this.options = options.stream().toArray(OpenOption[]::new);
 208             this.filePermissions =
 209                     filePermissions == null ? EMPTY_FILE_PERMISSIONS : filePermissions;
 210         }
 211 
 212         @Override
 213         public void onSubscribe(Flow.Subscription subscription) {






 214             this.subscription = subscription;
 215             if (System.getSecurityManager() == null) {
 216                 try {
 217                     out = FileChannel.open(file, options);
 218                 } catch (IOException ioe) {
 219                     result.completeExceptionally(ioe);
 220                     return;
 221                 }
 222             } else {
 223                 try {
 224                     PrivilegedExceptionAction&lt;FileChannel&gt; pa =
 225                             () -&gt; FileChannel.open(file, options);
 226                     out = AccessController.doPrivileged(pa, null, filePermissions);
 227                 } catch (PrivilegedActionException pae) {
 228                     Throwable t = pae.getCause() != null ? pae.getCause() : pae;
 229                     result.completeExceptionally(t);
 230                     subscription.cancel();
 231                     return;
 232                 }
 233             }
</pre>
<hr />
<pre>
 411                             if (debug.on()) debug.log(&quot;Increased demand by 1&quot;);
 412                             s.request(1);
 413                         }
 414                         assert currentListItr != null;
 415                         if (lb.isEmpty()) continue;
 416                     }
 417                     assert currentListItr != null;
 418                     assert currentListItr.hasNext();
 419                     if (debug.on()) debug.log(&quot;Next Buffer&quot;);
 420                     currentBuffer = currentListItr.next();
 421                 } catch (InterruptedException ex) {
 422                     // continue
 423                 }
 424             }
 425             assert currentBuffer == LAST_BUFFER || currentBuffer.hasRemaining();
 426             return currentBuffer;
 427         }
 428 
 429         @Override
 430         public int read(byte[] bytes, int off, int len) throws IOException {




 431             // get the buffer to read from, possibly blocking if
 432             // none is available
 433             ByteBuffer buffer;
 434             if ((buffer = current()) == LAST_BUFFER) return -1;
 435 
 436             // don&#39;t attempt to read more than what is available
 437             // in the current buffer.
 438             int read = Math.min(buffer.remaining(), len);
 439             assert read &gt; 0 &amp;&amp; read &lt;= buffer.remaining();
 440 
 441             // buffer.get() will do the boundary check for us.
 442             buffer.get(bytes, off, read);
 443             return read;
 444         }
 445 
 446         @Override
 447         public int read() throws IOException {
 448             ByteBuffer buffer;
 449             if ((buffer = current()) == LAST_BUFFER) return -1;
 450             return buffer.get() &amp; 0xFF;
</pre>
<hr />
<pre>
 453         @Override
 454         public int available() throws IOException {
 455             // best effort: returns the number of remaining bytes in
 456             // the current buffer if any, or 1 if the current buffer
 457             // is null or empty but the queue or current buffer list
 458             // are not empty. Returns 0 otherwise.
 459             if (closed) return 0;
 460             int available = 0;
 461             ByteBuffer current = currentBuffer;
 462             if (current == LAST_BUFFER) return 0;
 463             if (current != null) available = current.remaining();
 464             if (available != 0) return available;
 465             Iterator&lt;?&gt; iterator = currentListItr;
 466             if (iterator != null &amp;&amp; iterator.hasNext()) return 1;
 467             if (buffers.isEmpty()) return 0;
 468             return 1;
 469         }
 470 
 471         @Override
 472         public void onSubscribe(Flow.Subscription s) {

 473             try {
 474                 if (!subscribed.compareAndSet(false, true)) {
 475                     s.cancel();
 476                 } else {
 477                     // check whether the stream is already closed.
 478                     // if so, we should cancel the subscription
 479                     // immediately.
 480                     boolean closed;
 481                     synchronized (this) {
 482                         closed = this.closed;
 483                         if (!closed) {
 484                             this.subscription = s;
 485                         }
 486                     }
 487                     if (closed) {
 488                         s.cancel();
 489                         return;
 490                     }
 491                     assert buffers.remainingCapacity() &gt; 1; // should contain at least 2
 492                     if (debug.on())
</pre>
<hr />
<pre>
 583                 return new BufferedReader(new InputStreamReader(stream, charset))
 584                             .lines().onClose(() -&gt; Utils.close(stream));
 585             }, true);
 586     }
 587 
 588     /**
 589      * Currently this consumes all of the data and ignores it
 590      */
 591     public static class NullSubscriber&lt;T&gt; implements TrustedSubscriber&lt;T&gt; {
 592 
 593         private final CompletableFuture&lt;T&gt; cf = new MinimalFuture&lt;&gt;();
 594         private final Optional&lt;T&gt; result;
 595         private final AtomicBoolean subscribed = new AtomicBoolean();
 596 
 597         public NullSubscriber(Optional&lt;T&gt; result) {
 598             this.result = result;
 599         }
 600 
 601         @Override
 602         public void onSubscribe(Flow.Subscription subscription) {

 603             if (!subscribed.compareAndSet(false, true)) {
 604                 subscription.cancel();
 605             } else {
 606                 subscription.request(Long.MAX_VALUE);
 607             }
 608         }
 609 
 610         @Override
 611         public void onNext(List&lt;ByteBuffer&gt; items) {
 612             Objects.requireNonNull(items);
 613         }
 614 
 615         @Override
 616         public void onError(Throwable throwable) {

 617             cf.completeExceptionally(throwable);
 618         }
 619 
 620         @Override
 621         public void onComplete() {
 622             if (result.isPresent()) {
 623                 cf.complete(result.get());
 624             } else {
 625                 cf.complete(null);
 626             }
 627         }
 628 
 629         @Override
 630         public CompletionStage&lt;T&gt; getBody() {
 631             return cf;
 632         }
 633     }
 634 
 635     /** An adapter between {@code BodySubscriber} and {@code Flow.Subscriber}. */
 636     public static final class SubscriberAdapter&lt;S extends Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt;,R&gt;
</pre>
<hr />
<pre>
 890                         subscribedCF.complete(ref);
 891                     } catch (Throwable t) {
 892                         if (Log.errors()) {
 893                             Log.logError(&quot;Failed to call onSubscribe: &quot; +
 894                                     &quot;cancelling subscription: &quot; + t);
 895                             Log.logError(t);
 896                         }
 897                         subscription.cancel();
 898                     }
 899                 });
 900             } else {
 901                 subscriber.onSubscribe(new Flow.Subscription() {
 902                     @Override public void request(long n) { }
 903                     @Override public void cancel() { }
 904                 });
 905                 subscriber.onError(new IllegalStateException(
 906                         &quot;This publisher has already one subscriber&quot;));
 907             }
 908         }
 909 


 910         @Override
 911         public void onSubscribe(Flow.Subscription subscription) {
<span class="line-modified"> 912             subscriptionCF.complete(subscription);</span>





 913         }
 914 
 915         @Override
 916         public void onNext(List&lt;ByteBuffer&gt; item) {

 917             try {
 918                 // cannot be called before onSubscribe()
 919                 assert subscriptionCF.isDone();
 920                 SubscriberRef ref = subscriberRef.get();
 921                 // cannot be called before subscriber calls request(1)
 922                 assert ref != null;
 923                 Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt;
 924                         subscriber = ref.get();
 925                 if (subscriber != null) {
 926                     // may be null if subscription was cancelled.
 927                     subscriber.onNext(item);
 928                 }
 929             } catch (Throwable err) {
 930                 signalError(err);
 931                 subscriptionCF.thenAccept(s -&gt; s.cancel());
 932             }
 933         }
 934 
 935         @Override
 936         public void onError(Throwable throwable) {
 937             // cannot be called before onSubscribe();
 938             assert suppress(subscriptionCF.isDone(),
 939                     &quot;onError called before onSubscribe&quot;,
 940                     throwable);
 941             // onError can be called before request(1), and therefore can
 942             // be called before subscriberRef is set.
 943             signalError(throwable);

 944         }
 945 
 946         @Override
 947         public void onComplete() {
 948             // cannot be called before onSubscribe()
 949             if (!subscriptionCF.isDone()) {
 950                 signalError(new InternalError(
 951                         &quot;onComplete called before onSubscribed&quot;));
 952             } else {
 953                 // onComplete can be called before request(1),
 954                 // and therefore can be called before subscriberRef
 955                 // is set.
 956                 signalComplete();
 957             }
 958         }
 959 
 960         @Override
 961         public CompletionStage&lt;Flow.Publisher&lt;List&lt;ByteBuffer&gt;&gt;&gt; getBody() {
 962             return body;
 963         }
</pre>
</td>
<td>
<hr />
<pre>
 108         }
 109     }
 110 
 111     public static class ConsumerSubscriber implements TrustedSubscriber&lt;Void&gt; {
 112         private final Consumer&lt;Optional&lt;byte[]&gt;&gt; consumer;
 113         private Flow.Subscription subscription;
 114         private final CompletableFuture&lt;Void&gt; result = new MinimalFuture&lt;&gt;();
 115         private final AtomicBoolean subscribed = new AtomicBoolean();
 116 
 117         public ConsumerSubscriber(Consumer&lt;Optional&lt;byte[]&gt;&gt; consumer) {
 118             this.consumer = Objects.requireNonNull(consumer);
 119         }
 120 
 121         @Override
 122         public CompletionStage&lt;Void&gt; getBody() {
 123             return result;
 124         }
 125 
 126         @Override
 127         public void onSubscribe(Flow.Subscription subscription) {
<span class="line-added"> 128             Objects.requireNonNull(subscription);</span>
 129             if (!subscribed.compareAndSet(false, true)) {
 130                 subscription.cancel();
 131             } else {
 132                 this.subscription = subscription;
 133                 subscription.request(1);
 134             }
 135         }
 136 
 137         @Override
 138         public void onNext(List&lt;ByteBuffer&gt; items) {
<span class="line-added"> 139             Objects.requireNonNull(items);</span>
 140             for (ByteBuffer item : items) {
 141                 byte[] buf = new byte[item.remaining()];
 142                 item.get(buf);
 143                 consumer.accept(Optional.of(buf));
 144             }
 145             subscription.request(1);
 146         }
 147 
 148         @Override
 149         public void onError(Throwable throwable) {
<span class="line-added"> 150             Objects.requireNonNull(throwable);</span>
 151             result.completeExceptionally(throwable);
 152         }
 153 
 154         @Override
 155         public void onComplete() {
 156             consumer.accept(Optional.empty());
 157             result.complete(null);
 158         }
 159 
 160     }
 161 
 162     /**
 163      * A Subscriber that writes the flow of data to a given file.
 164      *
 165      * Privileged actions are performed within a limited doPrivileged that only
 166      * asserts the specific, write, file permissions that were checked during
 167      * the construction of this PathSubscriber.
 168      */
 169     public static class PathSubscriber implements TrustedSubscriber&lt;Path&gt; {
 170 
 171         private static final FilePermission[] EMPTY_FILE_PERMISSIONS = new FilePermission[0];
 172 
 173         private final Path file;
 174         private final OpenOption[] options;
 175         private final FilePermission[] filePermissions;
 176         private final CompletableFuture&lt;Path&gt; result = new MinimalFuture&lt;&gt;();
 177 
<span class="line-added"> 178         private final AtomicBoolean subscribed = new AtomicBoolean();</span>
 179         private volatile Flow.Subscription subscription;
 180         private volatile FileChannel out;
 181 
 182         private static final String pathForSecurityCheck(Path path) {
 183             return path.toFile().getPath();
 184         }
 185 
 186         /**
 187          * Factory for creating PathSubscriber.
 188          *
 189          * Permission checks are performed here before construction of the
 190          * PathSubscriber. Permission checking and construction are deliberately
 191          * and tightly co-located.
 192          */
 193         public static PathSubscriber create(Path file,
 194                                             List&lt;OpenOption&gt; options) {
 195             FilePermission filePermission = null;
 196             SecurityManager sm = System.getSecurityManager();
 197             if (sm != null) {
 198                 String fn = pathForSecurityCheck(file);
 199                 FilePermission writePermission = new FilePermission(fn, &quot;write&quot;);
 200                 sm.checkPermission(writePermission);
 201                 filePermission = writePermission;
 202             }
 203             return new PathSubscriber(file, options, filePermission);
 204         }
 205 
 206         // pp so handler implementations in the same package can construct
 207         /*package-private*/ PathSubscriber(Path file,
 208                                            List&lt;OpenOption&gt; options,
 209                                            FilePermission... filePermissions) {
 210             this.file = file;
 211             this.options = options.stream().toArray(OpenOption[]::new);
 212             this.filePermissions =
 213                     filePermissions == null ? EMPTY_FILE_PERMISSIONS : filePermissions;
 214         }
 215 
 216         @Override
 217         public void onSubscribe(Flow.Subscription subscription) {
<span class="line-added"> 218             Objects.requireNonNull(subscription);</span>
<span class="line-added"> 219             if (!subscribed.compareAndSet(false, true)) {</span>
<span class="line-added"> 220                 subscription.cancel();</span>
<span class="line-added"> 221                 return;</span>
<span class="line-added"> 222             }</span>
<span class="line-added"> 223 </span>
 224             this.subscription = subscription;
 225             if (System.getSecurityManager() == null) {
 226                 try {
 227                     out = FileChannel.open(file, options);
 228                 } catch (IOException ioe) {
 229                     result.completeExceptionally(ioe);
 230                     return;
 231                 }
 232             } else {
 233                 try {
 234                     PrivilegedExceptionAction&lt;FileChannel&gt; pa =
 235                             () -&gt; FileChannel.open(file, options);
 236                     out = AccessController.doPrivileged(pa, null, filePermissions);
 237                 } catch (PrivilegedActionException pae) {
 238                     Throwable t = pae.getCause() != null ? pae.getCause() : pae;
 239                     result.completeExceptionally(t);
 240                     subscription.cancel();
 241                     return;
 242                 }
 243             }
</pre>
<hr />
<pre>
 421                             if (debug.on()) debug.log(&quot;Increased demand by 1&quot;);
 422                             s.request(1);
 423                         }
 424                         assert currentListItr != null;
 425                         if (lb.isEmpty()) continue;
 426                     }
 427                     assert currentListItr != null;
 428                     assert currentListItr.hasNext();
 429                     if (debug.on()) debug.log(&quot;Next Buffer&quot;);
 430                     currentBuffer = currentListItr.next();
 431                 } catch (InterruptedException ex) {
 432                     // continue
 433                 }
 434             }
 435             assert currentBuffer == LAST_BUFFER || currentBuffer.hasRemaining();
 436             return currentBuffer;
 437         }
 438 
 439         @Override
 440         public int read(byte[] bytes, int off, int len) throws IOException {
<span class="line-added"> 441             Objects.checkFromIndexSize(off, len, bytes.length);</span>
<span class="line-added"> 442             if (len == 0) {</span>
<span class="line-added"> 443                 return 0;</span>
<span class="line-added"> 444             }</span>
 445             // get the buffer to read from, possibly blocking if
 446             // none is available
 447             ByteBuffer buffer;
 448             if ((buffer = current()) == LAST_BUFFER) return -1;
 449 
 450             // don&#39;t attempt to read more than what is available
 451             // in the current buffer.
 452             int read = Math.min(buffer.remaining(), len);
 453             assert read &gt; 0 &amp;&amp; read &lt;= buffer.remaining();
 454 
 455             // buffer.get() will do the boundary check for us.
 456             buffer.get(bytes, off, read);
 457             return read;
 458         }
 459 
 460         @Override
 461         public int read() throws IOException {
 462             ByteBuffer buffer;
 463             if ((buffer = current()) == LAST_BUFFER) return -1;
 464             return buffer.get() &amp; 0xFF;
</pre>
<hr />
<pre>
 467         @Override
 468         public int available() throws IOException {
 469             // best effort: returns the number of remaining bytes in
 470             // the current buffer if any, or 1 if the current buffer
 471             // is null or empty but the queue or current buffer list
 472             // are not empty. Returns 0 otherwise.
 473             if (closed) return 0;
 474             int available = 0;
 475             ByteBuffer current = currentBuffer;
 476             if (current == LAST_BUFFER) return 0;
 477             if (current != null) available = current.remaining();
 478             if (available != 0) return available;
 479             Iterator&lt;?&gt; iterator = currentListItr;
 480             if (iterator != null &amp;&amp; iterator.hasNext()) return 1;
 481             if (buffers.isEmpty()) return 0;
 482             return 1;
 483         }
 484 
 485         @Override
 486         public void onSubscribe(Flow.Subscription s) {
<span class="line-added"> 487             Objects.requireNonNull(s);</span>
 488             try {
 489                 if (!subscribed.compareAndSet(false, true)) {
 490                     s.cancel();
 491                 } else {
 492                     // check whether the stream is already closed.
 493                     // if so, we should cancel the subscription
 494                     // immediately.
 495                     boolean closed;
 496                     synchronized (this) {
 497                         closed = this.closed;
 498                         if (!closed) {
 499                             this.subscription = s;
 500                         }
 501                     }
 502                     if (closed) {
 503                         s.cancel();
 504                         return;
 505                     }
 506                     assert buffers.remainingCapacity() &gt; 1; // should contain at least 2
 507                     if (debug.on())
</pre>
<hr />
<pre>
 598                 return new BufferedReader(new InputStreamReader(stream, charset))
 599                             .lines().onClose(() -&gt; Utils.close(stream));
 600             }, true);
 601     }
 602 
 603     /**
 604      * Currently this consumes all of the data and ignores it
 605      */
 606     public static class NullSubscriber&lt;T&gt; implements TrustedSubscriber&lt;T&gt; {
 607 
 608         private final CompletableFuture&lt;T&gt; cf = new MinimalFuture&lt;&gt;();
 609         private final Optional&lt;T&gt; result;
 610         private final AtomicBoolean subscribed = new AtomicBoolean();
 611 
 612         public NullSubscriber(Optional&lt;T&gt; result) {
 613             this.result = result;
 614         }
 615 
 616         @Override
 617         public void onSubscribe(Flow.Subscription subscription) {
<span class="line-added"> 618             Objects.requireNonNull(subscription);</span>
 619             if (!subscribed.compareAndSet(false, true)) {
 620                 subscription.cancel();
 621             } else {
 622                 subscription.request(Long.MAX_VALUE);
 623             }
 624         }
 625 
 626         @Override
 627         public void onNext(List&lt;ByteBuffer&gt; items) {
 628             Objects.requireNonNull(items);
 629         }
 630 
 631         @Override
 632         public void onError(Throwable throwable) {
<span class="line-added"> 633             Objects.requireNonNull(throwable);</span>
 634             cf.completeExceptionally(throwable);
 635         }
 636 
 637         @Override
 638         public void onComplete() {
 639             if (result.isPresent()) {
 640                 cf.complete(result.get());
 641             } else {
 642                 cf.complete(null);
 643             }
 644         }
 645 
 646         @Override
 647         public CompletionStage&lt;T&gt; getBody() {
 648             return cf;
 649         }
 650     }
 651 
 652     /** An adapter between {@code BodySubscriber} and {@code Flow.Subscriber}. */
 653     public static final class SubscriberAdapter&lt;S extends Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt;,R&gt;
</pre>
<hr />
<pre>
 907                         subscribedCF.complete(ref);
 908                     } catch (Throwable t) {
 909                         if (Log.errors()) {
 910                             Log.logError(&quot;Failed to call onSubscribe: &quot; +
 911                                     &quot;cancelling subscription: &quot; + t);
 912                             Log.logError(t);
 913                         }
 914                         subscription.cancel();
 915                     }
 916                 });
 917             } else {
 918                 subscriber.onSubscribe(new Flow.Subscription() {
 919                     @Override public void request(long n) { }
 920                     @Override public void cancel() { }
 921                 });
 922                 subscriber.onError(new IllegalStateException(
 923                         &quot;This publisher has already one subscriber&quot;));
 924             }
 925         }
 926 
<span class="line-added"> 927         private final AtomicBoolean subscribed = new AtomicBoolean();</span>
<span class="line-added"> 928 </span>
 929         @Override
 930         public void onSubscribe(Flow.Subscription subscription) {
<span class="line-modified"> 931             Objects.requireNonNull(subscription);</span>
<span class="line-added"> 932             if (!subscribed.compareAndSet(false, true)) {</span>
<span class="line-added"> 933                 subscription.cancel();</span>
<span class="line-added"> 934             } else {</span>
<span class="line-added"> 935                 subscriptionCF.complete(subscription);</span>
<span class="line-added"> 936             }</span>
 937         }
 938 
 939         @Override
 940         public void onNext(List&lt;ByteBuffer&gt; item) {
<span class="line-added"> 941             Objects.requireNonNull(item);</span>
 942             try {
 943                 // cannot be called before onSubscribe()
 944                 assert subscriptionCF.isDone();
 945                 SubscriberRef ref = subscriberRef.get();
 946                 // cannot be called before subscriber calls request(1)
 947                 assert ref != null;
 948                 Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt;
 949                         subscriber = ref.get();
 950                 if (subscriber != null) {
 951                     // may be null if subscription was cancelled.
 952                     subscriber.onNext(item);
 953                 }
 954             } catch (Throwable err) {
 955                 signalError(err);
 956                 subscriptionCF.thenAccept(s -&gt; s.cancel());
 957             }
 958         }
 959 
 960         @Override
 961         public void onError(Throwable throwable) {
 962             // cannot be called before onSubscribe();
 963             assert suppress(subscriptionCF.isDone(),
 964                     &quot;onError called before onSubscribe&quot;,
 965                     throwable);
 966             // onError can be called before request(1), and therefore can
 967             // be called before subscriberRef is set.
 968             signalError(throwable);
<span class="line-added"> 969             Objects.requireNonNull(throwable);</span>
 970         }
 971 
 972         @Override
 973         public void onComplete() {
 974             // cannot be called before onSubscribe()
 975             if (!subscriptionCF.isDone()) {
 976                 signalError(new InternalError(
 977                         &quot;onComplete called before onSubscribed&quot;));
 978             } else {
 979                 // onComplete can be called before request(1),
 980                 // and therefore can be called before subscriberRef
 981                 // is set.
 982                 signalComplete();
 983             }
 984         }
 985 
 986         @Override
 987         public CompletionStage&lt;Flow.Publisher&lt;List&lt;ByteBuffer&gt;&gt;&gt; getBody() {
 988             return body;
 989         }
</pre>
</td>
</tr>
</table>
<center><a href="RequestPublishers.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="common/Log.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
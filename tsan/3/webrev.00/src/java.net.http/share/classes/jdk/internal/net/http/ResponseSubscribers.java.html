<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.net.http/share/classes/jdk/internal/net/http/ResponseSubscribers.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.net.http;
  27 
  28 import java.io.BufferedReader;
  29 import java.io.FilePermission;
  30 import java.io.IOException;
  31 import java.io.InputStream;
  32 import java.io.InputStreamReader;
  33 import java.nio.ByteBuffer;
  34 import java.nio.channels.FileChannel;
  35 import java.nio.charset.Charset;
  36 import java.nio.file.OpenOption;
  37 import java.nio.file.Path;
  38 import java.security.AccessController;
  39 import java.security.PrivilegedActionException;
  40 import java.security.PrivilegedExceptionAction;
  41 import java.util.ArrayList;
  42 import java.util.Iterator;
  43 import java.util.List;
  44 import java.util.Objects;
  45 import java.util.Optional;
  46 import java.util.concurrent.ArrayBlockingQueue;
  47 import java.util.concurrent.BlockingQueue;
  48 import java.util.concurrent.CompletableFuture;
  49 import java.util.concurrent.CompletionStage;
  50 import java.util.concurrent.Executor;
  51 import java.util.concurrent.Flow;
  52 import java.util.concurrent.Flow.Subscriber;
  53 import java.util.concurrent.Flow.Subscription;
  54 import java.util.concurrent.atomic.AtomicBoolean;
  55 import java.util.concurrent.atomic.AtomicReference;
  56 import java.util.function.Consumer;
  57 import java.util.function.Function;
  58 import java.util.stream.Stream;
  59 import java.net.http.HttpResponse.BodySubscriber;
  60 import jdk.internal.net.http.common.Log;
  61 import jdk.internal.net.http.common.Logger;
  62 import jdk.internal.net.http.common.MinimalFuture;
  63 import jdk.internal.net.http.common.Utils;
  64 import static java.nio.charset.StandardCharsets.UTF_8;
  65 
  66 public class ResponseSubscribers {
  67 
  68     /**
  69      * This interface is used by our BodySubscriber implementations to
  70      * declare whether calling getBody() inline is safe, or whether
  71      * it needs to be called asynchronously in an executor thread.
  72      * Calling getBody() inline is usually safe except when it
  73      * might block - which can be the case if the BodySubscriber
  74      * is provided by custom code, or if it uses a finisher that
  75      * might be called and might block before the last bit is
  76      * received (for instance, if a mapping subscriber is used with
  77      * a mapper function that maps an InputStream to a GZIPInputStream,
  78      * as the the constructor of GZIPInputStream calls read()).
  79      * @param &lt;T&gt; The response type.
  80      */
  81     public interface TrustedSubscriber&lt;T&gt; extends BodySubscriber&lt;T&gt; {
  82         /**
  83          * Returns true if getBody() should be called asynchronously.
  84          * @implSpec The default implementation of this method returns
  85          *           false.
  86          * @return true if getBody() should be called asynchronously.
  87          */
  88         default boolean needsExecutor() { return false;}
  89 
  90         /**
  91          * Returns true if calling {@code bs::getBody} might block
  92          * and requires an executor.
  93          *
  94          * @implNote
  95          * In particular this method returns
  96          * true if {@code bs} is not a {@code TrustedSubscriber}.
  97          * If it is a {@code TrustedSubscriber}, it returns
  98          * {@code ((TrustedSubscriber) bs).needsExecutor()}.
  99          *
 100          * @param bs A BodySubscriber.
 101          * @return true if calling {@code bs::getBody} requires using
 102          *         an executor.
 103          */
 104         static boolean needsExecutor(BodySubscriber&lt;?&gt; bs) {
 105             if (bs instanceof TrustedSubscriber) {
 106                 return ((TrustedSubscriber) bs).needsExecutor();
 107             } else return true;
 108         }
 109     }
 110 
 111     public static class ConsumerSubscriber implements TrustedSubscriber&lt;Void&gt; {
 112         private final Consumer&lt;Optional&lt;byte[]&gt;&gt; consumer;
 113         private Flow.Subscription subscription;
 114         private final CompletableFuture&lt;Void&gt; result = new MinimalFuture&lt;&gt;();
 115         private final AtomicBoolean subscribed = new AtomicBoolean();
 116 
 117         public ConsumerSubscriber(Consumer&lt;Optional&lt;byte[]&gt;&gt; consumer) {
 118             this.consumer = Objects.requireNonNull(consumer);
 119         }
 120 
 121         @Override
 122         public CompletionStage&lt;Void&gt; getBody() {
 123             return result;
 124         }
 125 
 126         @Override
 127         public void onSubscribe(Flow.Subscription subscription) {
 128             Objects.requireNonNull(subscription);
 129             if (!subscribed.compareAndSet(false, true)) {
 130                 subscription.cancel();
 131             } else {
 132                 this.subscription = subscription;
 133                 subscription.request(1);
 134             }
 135         }
 136 
 137         @Override
 138         public void onNext(List&lt;ByteBuffer&gt; items) {
 139             Objects.requireNonNull(items);
 140             for (ByteBuffer item : items) {
 141                 byte[] buf = new byte[item.remaining()];
 142                 item.get(buf);
 143                 consumer.accept(Optional.of(buf));
 144             }
 145             subscription.request(1);
 146         }
 147 
 148         @Override
 149         public void onError(Throwable throwable) {
 150             Objects.requireNonNull(throwable);
 151             result.completeExceptionally(throwable);
 152         }
 153 
 154         @Override
 155         public void onComplete() {
 156             consumer.accept(Optional.empty());
 157             result.complete(null);
 158         }
 159 
 160     }
 161 
 162     /**
 163      * A Subscriber that writes the flow of data to a given file.
 164      *
 165      * Privileged actions are performed within a limited doPrivileged that only
 166      * asserts the specific, write, file permissions that were checked during
 167      * the construction of this PathSubscriber.
 168      */
 169     public static class PathSubscriber implements TrustedSubscriber&lt;Path&gt; {
 170 
 171         private static final FilePermission[] EMPTY_FILE_PERMISSIONS = new FilePermission[0];
 172 
 173         private final Path file;
 174         private final OpenOption[] options;
 175         private final FilePermission[] filePermissions;
 176         private final CompletableFuture&lt;Path&gt; result = new MinimalFuture&lt;&gt;();
 177 
 178         private final AtomicBoolean subscribed = new AtomicBoolean();
 179         private volatile Flow.Subscription subscription;
 180         private volatile FileChannel out;
 181 
 182         private static final String pathForSecurityCheck(Path path) {
 183             return path.toFile().getPath();
 184         }
 185 
 186         /**
 187          * Factory for creating PathSubscriber.
 188          *
 189          * Permission checks are performed here before construction of the
 190          * PathSubscriber. Permission checking and construction are deliberately
 191          * and tightly co-located.
 192          */
 193         public static PathSubscriber create(Path file,
 194                                             List&lt;OpenOption&gt; options) {
 195             FilePermission filePermission = null;
 196             SecurityManager sm = System.getSecurityManager();
 197             if (sm != null) {
 198                 String fn = pathForSecurityCheck(file);
 199                 FilePermission writePermission = new FilePermission(fn, &quot;write&quot;);
 200                 sm.checkPermission(writePermission);
 201                 filePermission = writePermission;
 202             }
 203             return new PathSubscriber(file, options, filePermission);
 204         }
 205 
 206         // pp so handler implementations in the same package can construct
 207         /*package-private*/ PathSubscriber(Path file,
 208                                            List&lt;OpenOption&gt; options,
 209                                            FilePermission... filePermissions) {
 210             this.file = file;
 211             this.options = options.stream().toArray(OpenOption[]::new);
 212             this.filePermissions =
 213                     filePermissions == null ? EMPTY_FILE_PERMISSIONS : filePermissions;
 214         }
 215 
 216         @Override
 217         public void onSubscribe(Flow.Subscription subscription) {
 218             Objects.requireNonNull(subscription);
 219             if (!subscribed.compareAndSet(false, true)) {
 220                 subscription.cancel();
 221                 return;
 222             }
 223 
 224             this.subscription = subscription;
 225             if (System.getSecurityManager() == null) {
 226                 try {
 227                     out = FileChannel.open(file, options);
 228                 } catch (IOException ioe) {
 229                     result.completeExceptionally(ioe);
 230                     return;
 231                 }
 232             } else {
 233                 try {
 234                     PrivilegedExceptionAction&lt;FileChannel&gt; pa =
 235                             () -&gt; FileChannel.open(file, options);
 236                     out = AccessController.doPrivileged(pa, null, filePermissions);
 237                 } catch (PrivilegedActionException pae) {
 238                     Throwable t = pae.getCause() != null ? pae.getCause() : pae;
 239                     result.completeExceptionally(t);
 240                     subscription.cancel();
 241                     return;
 242                 }
 243             }
 244             subscription.request(1);
 245         }
 246 
 247         @Override
 248         public void onNext(List&lt;ByteBuffer&gt; items) {
 249             try {
 250                 out.write(items.toArray(Utils.EMPTY_BB_ARRAY));
 251             } catch (IOException ex) {
 252                 Utils.close(out);
 253                 subscription.cancel();
 254                 result.completeExceptionally(ex);
 255             }
 256             subscription.request(1);
 257         }
 258 
 259         @Override
 260         public void onError(Throwable e) {
 261             result.completeExceptionally(e);
 262             Utils.close(out);
 263         }
 264 
 265         @Override
 266         public void onComplete() {
 267             Utils.close(out);
 268             result.complete(file);
 269         }
 270 
 271         @Override
 272         public CompletionStage&lt;Path&gt; getBody() {
 273             return result;
 274         }
 275     }
 276 
 277     public static class ByteArraySubscriber&lt;T&gt; implements TrustedSubscriber&lt;T&gt; {
 278         private final Function&lt;byte[], T&gt; finisher;
 279         private final CompletableFuture&lt;T&gt; result = new MinimalFuture&lt;&gt;();
 280         private final List&lt;ByteBuffer&gt; received = new ArrayList&lt;&gt;();
 281 
 282         private volatile Flow.Subscription subscription;
 283 
 284         public ByteArraySubscriber(Function&lt;byte[],T&gt; finisher) {
 285             this.finisher = finisher;
 286         }
 287 
 288         @Override
 289         public void onSubscribe(Flow.Subscription subscription) {
 290             if (this.subscription != null) {
 291                 subscription.cancel();
 292                 return;
 293             }
 294             this.subscription = subscription;
 295             // We can handle whatever you&#39;ve got
 296             subscription.request(Long.MAX_VALUE);
 297         }
 298 
 299         @Override
 300         public void onNext(List&lt;ByteBuffer&gt; items) {
 301             // incoming buffers are allocated by http client internally,
 302             // and won&#39;t be used anywhere except this place.
 303             // So it&#39;s free simply to store them for further processing.
 304             assert Utils.hasRemaining(items);
 305             received.addAll(items);
 306         }
 307 
 308         @Override
 309         public void onError(Throwable throwable) {
 310             received.clear();
 311             result.completeExceptionally(throwable);
 312         }
 313 
 314         static private byte[] join(List&lt;ByteBuffer&gt; bytes) {
 315             int size = Utils.remaining(bytes, Integer.MAX_VALUE);
 316             byte[] res = new byte[size];
 317             int from = 0;
 318             for (ByteBuffer b : bytes) {
 319                 int l = b.remaining();
 320                 b.get(res, from, l);
 321                 from += l;
 322             }
 323             return res;
 324         }
 325 
 326         @Override
 327         public void onComplete() {
 328             try {
 329                 result.complete(finisher.apply(join(received)));
 330                 received.clear();
 331             } catch (IllegalArgumentException e) {
 332                 result.completeExceptionally(e);
 333             }
 334         }
 335 
 336         @Override
 337         public CompletionStage&lt;T&gt; getBody() {
 338             return result;
 339         }
 340     }
 341 
 342     /**
 343      * An InputStream built on top of the Flow API.
 344      */
 345     public static class HttpResponseInputStream extends InputStream
 346         implements TrustedSubscriber&lt;InputStream&gt;
 347     {
 348         final static int MAX_BUFFERS_IN_QUEUE = 1;  // lock-step with the producer
 349 
 350         // An immutable ByteBuffer sentinel to mark that the last byte was received.
 351         private static final ByteBuffer LAST_BUFFER = ByteBuffer.wrap(new byte[0]);
 352         private static final List&lt;ByteBuffer&gt; LAST_LIST = List.of(LAST_BUFFER);
 353         private static final Logger debug =
 354                 Utils.getDebugLogger(&quot;HttpResponseInputStream&quot;::toString, Utils.DEBUG);
 355 
 356         // A queue of yet unprocessed ByteBuffers received from the flow API.
 357         private final BlockingQueue&lt;List&lt;ByteBuffer&gt;&gt; buffers;
 358         private volatile Flow.Subscription subscription;
 359         private volatile boolean closed;
 360         private volatile Throwable failed;
 361         private volatile Iterator&lt;ByteBuffer&gt; currentListItr;
 362         private volatile ByteBuffer currentBuffer;
 363         private final AtomicBoolean subscribed = new AtomicBoolean();
 364 
 365         public HttpResponseInputStream() {
 366             this(MAX_BUFFERS_IN_QUEUE);
 367         }
 368 
 369         HttpResponseInputStream(int maxBuffers) {
 370             int capacity = (maxBuffers &lt;= 0 ? MAX_BUFFERS_IN_QUEUE : maxBuffers);
 371             // 1 additional slot needed for LAST_LIST added by onComplete
 372             this.buffers = new ArrayBlockingQueue&lt;&gt;(capacity + 1);
 373         }
 374 
 375         @Override
 376         public CompletionStage&lt;InputStream&gt; getBody() {
 377             // Returns the stream immediately, before the
 378             // response body is received.
 379             // This makes it possible for sendAsync().get().body()
 380             // to complete before the response body is received.
 381             return CompletableFuture.completedStage(this);
 382         }
 383 
 384         // Returns the current byte buffer to read from.
 385         // If the current buffer has no remaining data, this method will take the
 386         // next buffer from the buffers queue, possibly blocking until
 387         // a new buffer is made available through the Flow API, or the
 388         // end of the flow has been reached.
 389         private ByteBuffer current() throws IOException {
 390             while (currentBuffer == null || !currentBuffer.hasRemaining()) {
 391                 // Check whether the stream is closed or exhausted
 392                 if (closed || failed != null) {
 393                     throw new IOException(&quot;closed&quot;, failed);
 394                 }
 395                 if (currentBuffer == LAST_BUFFER) break;
 396 
 397                 try {
 398                     if (currentListItr == null || !currentListItr.hasNext()) {
 399                         // Take a new list of buffers from the queue, blocking
 400                         // if none is available yet...
 401 
 402                         if (debug.on()) debug.log(&quot;Taking list of Buffers&quot;);
 403                         List&lt;ByteBuffer&gt; lb = buffers.take();
 404                         currentListItr = lb.iterator();
 405                         if (debug.on()) debug.log(&quot;List of Buffers Taken&quot;);
 406 
 407                         // Check whether an exception was encountered upstream
 408                         if (closed || failed != null)
 409                             throw new IOException(&quot;closed&quot;, failed);
 410 
 411                         // Check whether we&#39;re done.
 412                         if (lb == LAST_LIST) {
 413                             currentListItr = null;
 414                             currentBuffer = LAST_BUFFER;
 415                             break;
 416                         }
 417 
 418                         // Request another upstream item ( list of buffers )
 419                         Flow.Subscription s = subscription;
 420                         if (s != null) {
 421                             if (debug.on()) debug.log(&quot;Increased demand by 1&quot;);
 422                             s.request(1);
 423                         }
 424                         assert currentListItr != null;
 425                         if (lb.isEmpty()) continue;
 426                     }
 427                     assert currentListItr != null;
 428                     assert currentListItr.hasNext();
 429                     if (debug.on()) debug.log(&quot;Next Buffer&quot;);
 430                     currentBuffer = currentListItr.next();
 431                 } catch (InterruptedException ex) {
 432                     // continue
 433                 }
 434             }
 435             assert currentBuffer == LAST_BUFFER || currentBuffer.hasRemaining();
 436             return currentBuffer;
 437         }
 438 
 439         @Override
 440         public int read(byte[] bytes, int off, int len) throws IOException {
 441             Objects.checkFromIndexSize(off, len, bytes.length);
 442             if (len == 0) {
 443                 return 0;
 444             }
 445             // get the buffer to read from, possibly blocking if
 446             // none is available
 447             ByteBuffer buffer;
 448             if ((buffer = current()) == LAST_BUFFER) return -1;
 449 
 450             // don&#39;t attempt to read more than what is available
 451             // in the current buffer.
 452             int read = Math.min(buffer.remaining(), len);
 453             assert read &gt; 0 &amp;&amp; read &lt;= buffer.remaining();
 454 
 455             // buffer.get() will do the boundary check for us.
 456             buffer.get(bytes, off, read);
 457             return read;
 458         }
 459 
 460         @Override
 461         public int read() throws IOException {
 462             ByteBuffer buffer;
 463             if ((buffer = current()) == LAST_BUFFER) return -1;
 464             return buffer.get() &amp; 0xFF;
 465         }
 466 
 467         @Override
 468         public int available() throws IOException {
 469             // best effort: returns the number of remaining bytes in
 470             // the current buffer if any, or 1 if the current buffer
 471             // is null or empty but the queue or current buffer list
 472             // are not empty. Returns 0 otherwise.
 473             if (closed) return 0;
 474             int available = 0;
 475             ByteBuffer current = currentBuffer;
 476             if (current == LAST_BUFFER) return 0;
 477             if (current != null) available = current.remaining();
 478             if (available != 0) return available;
 479             Iterator&lt;?&gt; iterator = currentListItr;
 480             if (iterator != null &amp;&amp; iterator.hasNext()) return 1;
 481             if (buffers.isEmpty()) return 0;
 482             return 1;
 483         }
 484 
 485         @Override
 486         public void onSubscribe(Flow.Subscription s) {
 487             Objects.requireNonNull(s);
 488             try {
 489                 if (!subscribed.compareAndSet(false, true)) {
 490                     s.cancel();
 491                 } else {
 492                     // check whether the stream is already closed.
 493                     // if so, we should cancel the subscription
 494                     // immediately.
 495                     boolean closed;
 496                     synchronized (this) {
 497                         closed = this.closed;
 498                         if (!closed) {
 499                             this.subscription = s;
 500                         }
 501                     }
 502                     if (closed) {
 503                         s.cancel();
 504                         return;
 505                     }
 506                     assert buffers.remainingCapacity() &gt; 1; // should contain at least 2
 507                     if (debug.on())
 508                         debug.log(&quot;onSubscribe: requesting &quot;
 509                                   + Math.max(1, buffers.remainingCapacity() - 1));
 510                     s.request(Math.max(1, buffers.remainingCapacity() - 1));
 511                 }
 512             } catch (Throwable t) {
 513                 failed = t;
 514                 try {
 515                     close();
 516                 } catch (IOException x) {
 517                     // OK
 518                 } finally {
 519                     onError(t);
 520                 }
 521             }
 522         }
 523 
 524         @Override
 525         public void onNext(List&lt;ByteBuffer&gt; t) {
 526             Objects.requireNonNull(t);
 527             try {
 528                 if (debug.on()) debug.log(&quot;next item received&quot;);
 529                 if (!buffers.offer(t)) {
 530                     throw new IllegalStateException(&quot;queue is full&quot;);
 531                 }
 532                 if (debug.on()) debug.log(&quot;item offered&quot;);
 533             } catch (Throwable ex) {
 534                 failed = ex;
 535                 try {
 536                     close();
 537                 } catch (IOException ex1) {
 538                     // OK
 539                 } finally {
 540                     onError(ex);
 541                 }
 542             }
 543         }
 544 
 545         @Override
 546         public void onError(Throwable thrwbl) {
 547             subscription = null;
 548             failed = Objects.requireNonNull(thrwbl);
 549             // The client process that reads the input stream might
 550             // be blocked in queue.take().
 551             // Tries to offer LAST_LIST to the queue. If the queue is
 552             // full we don&#39;t care if we can&#39;t insert this buffer, as
 553             // the client can&#39;t be blocked in queue.take() in that case.
 554             // Adding LAST_LIST to the queue is harmless, as the client
 555             // should find failed != null before handling LAST_LIST.
 556             buffers.offer(LAST_LIST);
 557         }
 558 
 559         @Override
 560         public void onComplete() {
 561             subscription = null;
 562             onNext(LAST_LIST);
 563         }
 564 
 565         @Override
 566         public void close() throws IOException {
 567             Flow.Subscription s;
 568             synchronized (this) {
 569                 if (closed) return;
 570                 closed = true;
 571                 s = subscription;
 572                 subscription = null;
 573             }
 574             // s will be null if already completed
 575             try {
 576                 if (s != null) {
 577                     s.cancel();
 578                 }
 579             } finally {
 580                 buffers.offer(LAST_LIST);
 581                 super.close();
 582             }
 583         }
 584 
 585     }
 586 
 587     public static BodySubscriber&lt;Stream&lt;String&gt;&gt; createLineStream() {
 588         return createLineStream(UTF_8);
 589     }
 590 
 591     public static BodySubscriber&lt;Stream&lt;String&gt;&gt; createLineStream(Charset charset) {
 592         Objects.requireNonNull(charset);
 593         BodySubscriber&lt;InputStream&gt; s = new HttpResponseInputStream();
 594         // Creates a MappingSubscriber with a trusted finisher that is
 595         // trusted not to block.
 596         return new MappingSubscriber&lt;InputStream,Stream&lt;String&gt;&gt;(s,
 597             (InputStream stream) -&gt; {
 598                 return new BufferedReader(new InputStreamReader(stream, charset))
 599                             .lines().onClose(() -&gt; Utils.close(stream));
 600             }, true);
 601     }
 602 
 603     /**
 604      * Currently this consumes all of the data and ignores it
 605      */
 606     public static class NullSubscriber&lt;T&gt; implements TrustedSubscriber&lt;T&gt; {
 607 
 608         private final CompletableFuture&lt;T&gt; cf = new MinimalFuture&lt;&gt;();
 609         private final Optional&lt;T&gt; result;
 610         private final AtomicBoolean subscribed = new AtomicBoolean();
 611 
 612         public NullSubscriber(Optional&lt;T&gt; result) {
 613             this.result = result;
 614         }
 615 
 616         @Override
 617         public void onSubscribe(Flow.Subscription subscription) {
 618             Objects.requireNonNull(subscription);
 619             if (!subscribed.compareAndSet(false, true)) {
 620                 subscription.cancel();
 621             } else {
 622                 subscription.request(Long.MAX_VALUE);
 623             }
 624         }
 625 
 626         @Override
 627         public void onNext(List&lt;ByteBuffer&gt; items) {
 628             Objects.requireNonNull(items);
 629         }
 630 
 631         @Override
 632         public void onError(Throwable throwable) {
 633             Objects.requireNonNull(throwable);
 634             cf.completeExceptionally(throwable);
 635         }
 636 
 637         @Override
 638         public void onComplete() {
 639             if (result.isPresent()) {
 640                 cf.complete(result.get());
 641             } else {
 642                 cf.complete(null);
 643             }
 644         }
 645 
 646         @Override
 647         public CompletionStage&lt;T&gt; getBody() {
 648             return cf;
 649         }
 650     }
 651 
 652     /** An adapter between {@code BodySubscriber} and {@code Flow.Subscriber}. */
 653     public static final class SubscriberAdapter&lt;S extends Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt;,R&gt;
 654         implements TrustedSubscriber&lt;R&gt;
 655     {
 656         private final CompletableFuture&lt;R&gt; cf = new MinimalFuture&lt;&gt;();
 657         private final S subscriber;
 658         private final Function&lt;? super S,? extends R&gt; finisher;
 659         private volatile Subscription subscription;
 660 
 661         // The finisher isn&#39;t called until all bytes have been received,
 662         // and so shouldn&#39;t need an executor. No need to override
 663         // TrustedSubscriber::needsExecutor
 664         public SubscriberAdapter(S subscriber, Function&lt;? super S,? extends R&gt; finisher) {
 665             this.subscriber = Objects.requireNonNull(subscriber);
 666             this.finisher = Objects.requireNonNull(finisher);
 667         }
 668 
 669         @Override
 670         public void onSubscribe(Subscription subscription) {
 671             Objects.requireNonNull(subscription);
 672             if (this.subscription != null) {
 673                 subscription.cancel();
 674             } else {
 675                 this.subscription = subscription;
 676                 subscriber.onSubscribe(subscription);
 677             }
 678         }
 679 
 680         @Override
 681         public void onNext(List&lt;ByteBuffer&gt; item) {
 682             Objects.requireNonNull(item);
 683             try {
 684                 subscriber.onNext(item);
 685             } catch (Throwable throwable) {
 686                 subscription.cancel();
 687                 onError(throwable);
 688             }
 689         }
 690 
 691         @Override
 692         public void onError(Throwable throwable) {
 693             Objects.requireNonNull(throwable);
 694             try {
 695                 subscriber.onError(throwable);
 696             } finally {
 697                 cf.completeExceptionally(throwable);
 698             }
 699         }
 700 
 701         @Override
 702         public void onComplete() {
 703             try {
 704                 subscriber.onComplete();
 705             } finally {
 706                 try {
 707                     cf.complete(finisher.apply(subscriber));
 708                 } catch (Throwable throwable) {
 709                     cf.completeExceptionally(throwable);
 710                 }
 711             }
 712         }
 713 
 714         @Override
 715         public CompletionStage&lt;R&gt; getBody() {
 716             return cf;
 717         }
 718     }
 719 
 720     /**
 721      * A body subscriber which receives input from an upstream subscriber
 722      * and maps that subscriber&#39;s body type to a new type. The upstream subscriber
 723      * delegates all flow operations directly to this object. The
 724      * {@link CompletionStage} returned by {@link #getBody()}} takes the output
 725      * of the upstream {@code getBody()} and applies the mapper function to
 726      * obtain the new {@code CompletionStage} type.
 727      *
 728      * @param &lt;T&gt; the upstream body type
 729      * @param &lt;U&gt; this subscriber&#39;s body type
 730      */
 731     public static class MappingSubscriber&lt;T,U&gt; implements TrustedSubscriber&lt;U&gt; {
 732         private final BodySubscriber&lt;T&gt; upstream;
 733         private final Function&lt;? super T,? extends U&gt; mapper;
 734         private final boolean trusted;
 735 
 736         public MappingSubscriber(BodySubscriber&lt;T&gt; upstream,
 737                                  Function&lt;? super T,? extends U&gt; mapper) {
 738             this(upstream, mapper, false);
 739         }
 740 
 741         // creates a MappingSubscriber with a mapper that is trusted
 742         // to not block when called.
 743         MappingSubscriber(BodySubscriber&lt;T&gt; upstream,
 744                           Function&lt;? super T,? extends U&gt; mapper,
 745                           boolean trusted) {
 746             this.upstream = Objects.requireNonNull(upstream);
 747             this.mapper = Objects.requireNonNull(mapper);
 748             this.trusted = trusted;
 749         }
 750 
 751         // There is no way to know whether a custom mapper function
 752         // might block or not - so we should return true unless the
 753         // mapper is implemented and trusted by our own code not to
 754         // block.
 755         @Override
 756         public boolean needsExecutor() {
 757             return !trusted || TrustedSubscriber.needsExecutor(upstream);
 758         }
 759 
 760         // If upstream.getBody() is already completed (case of InputStream),
 761         // then calling upstream.getBody().thenApply(mapper) might block
 762         // if the mapper blocks. We should probably add a variant of
 763         // MappingSubscriber that calls thenApplyAsync instead, but this
 764         // needs a new public API point. See needsExecutor() above.
 765         @Override
 766         public CompletionStage&lt;U&gt; getBody() {
 767             return upstream.getBody().thenApply(mapper);
 768         }
 769 
 770         @Override
 771         public void onSubscribe(Flow.Subscription subscription) {
 772             upstream.onSubscribe(subscription);
 773         }
 774 
 775         @Override
 776         public void onNext(List&lt;ByteBuffer&gt; item) {
 777             upstream.onNext(item);
 778         }
 779 
 780         @Override
 781         public void onError(Throwable throwable) {
 782             upstream.onError(throwable);
 783         }
 784 
 785         @Override
 786         public void onComplete() {
 787             upstream.onComplete();
 788         }
 789     }
 790 
 791     // A BodySubscriber that returns a Publisher&lt;List&lt;ByteBuffer&gt;&gt;
 792     static class PublishingBodySubscriber
 793             implements TrustedSubscriber&lt;Flow.Publisher&lt;List&lt;ByteBuffer&gt;&gt;&gt; {
 794         private final MinimalFuture&lt;Flow.Subscription&gt;
 795                 subscriptionCF = new MinimalFuture&lt;&gt;();
 796         private final MinimalFuture&lt;SubscriberRef&gt;
 797                 subscribedCF = new MinimalFuture&lt;&gt;();
 798         private AtomicReference&lt;SubscriberRef&gt;
 799                 subscriberRef = new AtomicReference&lt;&gt;();
 800         private final CompletionStage&lt;Flow.Publisher&lt;List&lt;ByteBuffer&gt;&gt;&gt; body =
 801                 subscriptionCF.thenCompose(
 802                         (s) -&gt; MinimalFuture.completedFuture(this::subscribe));
 803 
 804         // We use the completionCF to ensure that only one of
 805         // onError or onComplete is ever called.
 806         private final MinimalFuture&lt;Void&gt; completionCF;
 807         private PublishingBodySubscriber() {
 808             completionCF = new MinimalFuture&lt;&gt;();
 809             completionCF.whenComplete(
 810                     (r,t) -&gt; subscribedCF.thenAccept( s -&gt; complete(s, t)));
 811         }
 812 
 813         // An object that holds a reference to a Flow.Subscriber.
 814         // The reference is cleared when the subscriber is completed - either
 815         // normally or exceptionally, or when the subscription is cancelled.
 816         static final class SubscriberRef {
 817             volatile Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; ref;
 818             SubscriberRef(Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; subscriber) {
 819                 ref = subscriber;
 820             }
 821             Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; get() {
 822                 return ref;
 823             }
 824             Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; clear() {
 825                 Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; res = ref;
 826                 ref = null;
 827                 return res;
 828             }
 829         }
 830 
 831         // A subscription that wraps an upstream subscription and
 832         // holds a reference to a subscriber. The subscriber reference
 833         // is cleared when the subscription is cancelled
 834         final static class SubscriptionRef implements Flow.Subscription {
 835             final Flow.Subscription subscription;
 836             final SubscriberRef subscriberRef;
 837             SubscriptionRef(Flow.Subscription subscription,
 838                             SubscriberRef subscriberRef) {
 839                 this.subscription = subscription;
 840                 this.subscriberRef = subscriberRef;
 841             }
 842             @Override
 843             public void request(long n) {
 844                 if (subscriberRef.get() != null) {
 845                     subscription.request(n);
 846                 }
 847             }
 848             @Override
 849             public void cancel() {
 850                 subscription.cancel();
 851                 subscriberRef.clear();
 852             }
 853 
 854             void subscribe() {
 855                 Subscriber&lt;?&gt; subscriber = subscriberRef.get();
 856                 if (subscriber != null) {
 857                     subscriber.onSubscribe(this);
 858                 }
 859             }
 860 
 861             @Override
 862             public String toString() {
 863                 return &quot;SubscriptionRef/&quot;
 864                         + subscription.getClass().getName()
 865                         + &quot;@&quot;
 866                         + System.identityHashCode(subscription);
 867             }
 868         }
 869 
 870         // This is a callback for the subscribedCF.
 871         // Do not call directly!
 872         private void complete(SubscriberRef ref, Throwable t) {
 873             assert ref != null;
 874             Subscriber&lt;?&gt; s = ref.clear();
 875             // maybe null if subscription was cancelled
 876             if (s == null) return;
 877             if (t == null) {
 878                 try {
 879                     s.onComplete();
 880                 } catch (Throwable x) {
 881                     s.onError(x);
 882                 }
 883             } else {
 884                 s.onError(t);
 885             }
 886         }
 887 
 888         private void signalError(Throwable err) {
 889             if (err == null) {
 890                 err = new NullPointerException(&quot;null throwable&quot;);
 891             }
 892             completionCF.completeExceptionally(err);
 893         }
 894 
 895         private void signalComplete() {
 896             completionCF.complete(null);
 897         }
 898 
 899         private void subscribe(Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; subscriber) {
 900             Objects.requireNonNull(subscriber, &quot;subscriber must not be null&quot;);
 901             SubscriberRef ref = new SubscriberRef(subscriber);
 902             if (subscriberRef.compareAndSet(null, ref)) {
 903                 subscriptionCF.thenAccept((s) -&gt; {
 904                     SubscriptionRef subscription = new SubscriptionRef(s,ref);
 905                     try {
 906                         subscription.subscribe();
 907                         subscribedCF.complete(ref);
 908                     } catch (Throwable t) {
 909                         if (Log.errors()) {
 910                             Log.logError(&quot;Failed to call onSubscribe: &quot; +
 911                                     &quot;cancelling subscription: &quot; + t);
 912                             Log.logError(t);
 913                         }
 914                         subscription.cancel();
 915                     }
 916                 });
 917             } else {
 918                 subscriber.onSubscribe(new Flow.Subscription() {
 919                     @Override public void request(long n) { }
 920                     @Override public void cancel() { }
 921                 });
 922                 subscriber.onError(new IllegalStateException(
 923                         &quot;This publisher has already one subscriber&quot;));
 924             }
 925         }
 926 
 927         private final AtomicBoolean subscribed = new AtomicBoolean();
 928 
 929         @Override
 930         public void onSubscribe(Flow.Subscription subscription) {
 931             Objects.requireNonNull(subscription);
 932             if (!subscribed.compareAndSet(false, true)) {
 933                 subscription.cancel();
 934             } else {
 935                 subscriptionCF.complete(subscription);
 936             }
 937         }
 938 
 939         @Override
 940         public void onNext(List&lt;ByteBuffer&gt; item) {
 941             Objects.requireNonNull(item);
 942             try {
 943                 // cannot be called before onSubscribe()
 944                 assert subscriptionCF.isDone();
 945                 SubscriberRef ref = subscriberRef.get();
 946                 // cannot be called before subscriber calls request(1)
 947                 assert ref != null;
 948                 Flow.Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt;
 949                         subscriber = ref.get();
 950                 if (subscriber != null) {
 951                     // may be null if subscription was cancelled.
 952                     subscriber.onNext(item);
 953                 }
 954             } catch (Throwable err) {
 955                 signalError(err);
 956                 subscriptionCF.thenAccept(s -&gt; s.cancel());
 957             }
 958         }
 959 
 960         @Override
 961         public void onError(Throwable throwable) {
 962             // cannot be called before onSubscribe();
 963             assert suppress(subscriptionCF.isDone(),
 964                     &quot;onError called before onSubscribe&quot;,
 965                     throwable);
 966             // onError can be called before request(1), and therefore can
 967             // be called before subscriberRef is set.
 968             signalError(throwable);
 969             Objects.requireNonNull(throwable);
 970         }
 971 
 972         @Override
 973         public void onComplete() {
 974             // cannot be called before onSubscribe()
 975             if (!subscriptionCF.isDone()) {
 976                 signalError(new InternalError(
 977                         &quot;onComplete called before onSubscribed&quot;));
 978             } else {
 979                 // onComplete can be called before request(1),
 980                 // and therefore can be called before subscriberRef
 981                 // is set.
 982                 signalComplete();
 983             }
 984         }
 985 
 986         @Override
 987         public CompletionStage&lt;Flow.Publisher&lt;List&lt;ByteBuffer&gt;&gt;&gt; getBody() {
 988             return body;
 989         }
 990 
 991         private boolean suppress(boolean condition,
 992                                  String assertion,
 993                                  Throwable carrier) {
 994             if (!condition) {
 995                 if (carrier != null) {
 996                     carrier.addSuppressed(new AssertionError(assertion));
 997                 } else if (Log.errors()) {
 998                     Log.logError(new AssertionError(assertion));
 999                 }
1000             }
1001             return true;
1002         }
1003 
1004     }
1005 
1006     public static BodySubscriber&lt;Flow.Publisher&lt;List&lt;ByteBuffer&gt;&gt;&gt;
1007     createPublisher() {
1008         return new PublishingBodySubscriber();
1009     }
1010 
1011 
1012     /**
1013      * Tries to determine whether bs::getBody must be invoked asynchronously,
1014      * and if so, uses the provided executor to do it.
1015      * If the executor is a {@link HttpClientImpl.DelegatingExecutor},
1016      * uses the executor&#39;s delegate.
1017      * @param e    The executor to use if an executor is required.
1018      * @param bs   The BodySubscriber (trusted or not)
1019      * @param &lt;T&gt;  The type of the response.
1020      * @return A completion stage that completes when the completion
1021      *         stage returned by bs::getBody completes. This may, or
1022      *         may not, be the same completion stage.
1023      */
1024     public static &lt;T&gt; CompletionStage&lt;T&gt; getBodyAsync(Executor e, BodySubscriber&lt;T&gt; bs) {
1025         if (TrustedSubscriber.needsExecutor(bs)) {
1026             // getBody must be called in the executor
1027             return getBodyAsync(e, bs, new MinimalFuture&lt;&gt;());
1028         } else {
1029             // No executor needed
1030             return bs.getBody();
1031         }
1032     }
1033 
1034     /**
1035      * Invokes bs::getBody using the provided executor.
1036      * If invoking bs::getBody requires an executor, and the given executor
1037      * is a {@link HttpClientImpl.DelegatingExecutor}, then the executor&#39;s
1038      * delegate is used. If an error occurs anywhere then the given {code cf}
1039      * is completed exceptionally (this method does not throw).
1040      * @param e   The executor that should be used to call bs::getBody
1041      * @param bs  The BodySubscriber
1042      * @param cf  A completable future that this function will set up
1043      *            to complete when the completion stage returned by
1044      *            bs::getBody completes.
1045      *            In case of any error while trying to set up the
1046      *            completion chain, {@code cf} will be completed
1047      *            exceptionally with that error.
1048      * @param &lt;T&gt; The response type.
1049      * @return The provided {@code cf}.
1050      */
1051     public static &lt;T&gt; CompletableFuture&lt;T&gt; getBodyAsync(Executor e,
1052                                                       BodySubscriber&lt;T&gt; bs,
1053                                                       CompletableFuture&lt;T&gt; cf) {
1054         return getBodyAsync(e, bs, cf, cf::completeExceptionally);
1055     }
1056 
1057     /**
1058      * Invokes bs::getBody using the provided executor.
1059      * If invoking bs::getBody requires an executor, and the given executor
1060      * is a {@link HttpClientImpl.DelegatingExecutor}, then the executor&#39;s
1061      * delegate is used.
1062      * The provided {@code cf} is completed with the result (exceptional
1063      * or not) of the completion stage returned by bs::getBody.
1064      * If an error occurs when trying to set up the
1065      * completion chain, the provided {@code errorHandler} is invoked,
1066      * but {@code cf} is not necessarily affected.
1067      * This method does not throw.
1068      * @param e   The executor that should be used to call bs::getBody
1069      * @param bs  The BodySubscriber
1070      * @param cf  A completable future that this function will set up
1071      *            to complete when the completion stage returned by
1072      *            bs::getBody completes.
1073      *            In case of any error while trying to set up the
1074      *            completion chain, {@code cf} will be completed
1075      *            exceptionally with that error.
1076      * @param errorHandler The handler to invoke if an error is raised
1077      *                     while trying to set up the completion chain.
1078      * @param &lt;T&gt; The response type.
1079      * @return The provide {@code cf}. If the {@code errorHandler} is
1080      * invoked, it is the responsibility of the {@code errorHandler} to
1081      * complete the {@code cf}, if needed.
1082      */
1083     public static &lt;T&gt; CompletableFuture&lt;T&gt; getBodyAsync(Executor e,
1084                                                       BodySubscriber&lt;T&gt; bs,
1085                                                       CompletableFuture&lt;T&gt; cf,
1086                                                       Consumer&lt;Throwable&gt; errorHandler) {
1087         assert errorHandler != null;
1088         try {
1089             assert e != null;
1090             assert cf != null;
1091 
1092             if (TrustedSubscriber.needsExecutor(bs)) {
1093                 e = (e instanceof HttpClientImpl.DelegatingExecutor)
1094                         ? ((HttpClientImpl.DelegatingExecutor) e).delegate() : e;
1095             }
1096 
1097             e.execute(() -&gt; {
1098                 try {
1099                     bs.getBody().whenComplete((r, t) -&gt; {
1100                         if (t != null) {
1101                             cf.completeExceptionally(t);
1102                         } else {
1103                             cf.complete(r);
1104                         }
1105                     });
1106                 } catch (Throwable t) {
1107                     errorHandler.accept(t);
1108                 }
1109             });
1110             return cf;
1111 
1112         } catch (Throwable t) {
1113             errorHandler.accept(t);
1114         }
1115         return cf;
1116     }
1117 }
    </pre>
  </body>
</html>
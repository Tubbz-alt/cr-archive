<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.net.http/share/classes/jdk/internal/net/http/common/SubscriberWrapper.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.net.http.common;
 27 
 28 import java.io.Closeable;
<a name="1" id="anc1"></a><span class="line-removed"> 29 import java.lang.System.Logger.Level;</span>
 30 import java.nio.ByteBuffer;
<a name="2" id="anc2"></a><span class="line-removed"> 31 import java.util.ArrayList;</span>
 32 import java.util.List;
 33 import java.util.Objects;
 34 import java.util.concurrent.CompletableFuture;
 35 import java.util.concurrent.ConcurrentLinkedQueue;
 36 import java.util.concurrent.Flow;
 37 import java.util.concurrent.Flow.Subscriber;
 38 import java.util.concurrent.atomic.AtomicLong;
 39 import java.util.concurrent.atomic.AtomicReference;
 40 
 41 /**
 42  * A wrapper for a Flow.Subscriber. This wrapper delivers data to the wrapped
 43  * Subscriber which is supplied to the constructor. This class takes care of
 44  * downstream flow control automatically and upstream flow control automatically
 45  * by default.
 46  * &lt;p&gt;
 47  * Processing is done by implementing the {@link #incoming(List, boolean)} method
 48  * which supplies buffers from upstream. This method (or any other method)
 49  * can then call the outgoing() method to deliver processed buffers downstream.
 50  * &lt;p&gt;
 51  * Upstream error signals are delivered downstream directly. Cancellation from
 52  * downstream is also propagated upstream immediately.
 53  * &lt;p&gt;
 54  * Each SubscriberWrapper has a {@link java.util.concurrent.CompletableFuture}{@code &lt;Void&gt;}
 55  * which propagates completion/errors from downstream to upstream. Normal completion
 56  * can only occur after onComplete() is called, but errors can be propagated upwards
 57  * at any time.
 58  */
 59 public abstract class SubscriberWrapper
 60     implements FlowTube.TubeSubscriber, Closeable, Flow.Processor&lt;List&lt;ByteBuffer&gt;,List&lt;ByteBuffer&gt;&gt;
 61                 // TODO: SSLTube Subscriber will never change? Does this really need to be a TS?
 62 {
 63     final Logger debug =
 64             Utils.getDebugLogger(this::dbgString, Utils.DEBUG);
 65 
 66     public enum SchedulingAction { CONTINUE, RETURN, RESCHEDULE }
 67 
 68     volatile Flow.Subscription upstreamSubscription;
 69     final SubscriptionBase downstreamSubscription;
 70     volatile boolean upstreamCompleted;
 71     volatile boolean downstreamCompleted;
 72     volatile boolean completionAcknowledged;
 73     private volatile Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; downstreamSubscriber;
 74     // processed byte to send to the downstream subscriber.
 75     private final ConcurrentLinkedQueue&lt;List&lt;ByteBuffer&gt;&gt; outputQ;
 76     private final CompletableFuture&lt;Void&gt; cf;
 77     private final SequentialScheduler pushScheduler;
 78     private final AtomicReference&lt;Throwable&gt; errorRef = new AtomicReference&lt;&gt;();
 79     final AtomicLong upstreamWindow = new AtomicLong(0);
 80 
 81     /**
 82      * Wraps the given downstream subscriber. For each call to {@link
 83      * #onNext(List&lt;ByteBuffer&gt;) } the given filter function is invoked
 84      * and the list (if not empty) returned is passed downstream.
 85      *
 86      * A {@code CompletableFuture} is supplied which can be used to signal an
 87      * error from downstream and which terminates the wrapper or which signals
 88      * completion of downstream activity which can be propagated upstream. Error
 89      * completion can be signaled at any time, but normal completion must not be
 90      * signaled before onComplete() is called.
 91      */
 92     public SubscriberWrapper()
 93     {
 94         this.outputQ = new ConcurrentLinkedQueue&lt;&gt;();
 95         this.cf = new MinimalFuture&lt;Void&gt;();
 96         cf.whenComplete((v,t) -&gt; {
 97             if (t != null)
 98                 errorCommon(t);
 99         });
100         this.pushScheduler =
101                 SequentialScheduler.synchronizedScheduler(new DownstreamPusher());
102         this.downstreamSubscription = new SubscriptionBase(pushScheduler,
103                                                            this::downstreamCompletion);
104     }
105 
106     @Override
107     public final void subscribe(Subscriber&lt;?  super List&lt;ByteBuffer&gt;&gt; downstreamSubscriber) {
108         Objects.requireNonNull(downstreamSubscriber);
109         this.downstreamSubscriber = downstreamSubscriber;
110     }
111 
112     /**
113      * Wraps the given downstream wrapper in this. For each call to
114      * {@link #onNext(List&lt;ByteBuffer&gt;) } the incoming() method is called.
115      *
116      * The {@code downstreamCF} from the downstream wrapper is linked to this
117      * wrappers notifier.
118      *
119      * @param downstreamWrapper downstream destination
120      */
121     public SubscriberWrapper(Subscriber&lt;? super List&lt;ByteBuffer&gt;&gt; downstreamWrapper)
122     {
123         this();
124         subscribe(downstreamWrapper);
125     }
126 
127     /**
128      * Delivers data to be processed by this wrapper. Generated data to be sent
129      * downstream, must be provided to the {@link #outgoing(List, boolean)}}
130      * method.
131      *
132      * @param buffers a List of ByteBuffers.
133      * @param complete if true then no more data will be added to the list
134      */
135     protected abstract void incoming(List&lt;ByteBuffer&gt; buffers, boolean complete);
136 
137     /**
138      * This method is called to determine the window size to use at any time. The
139      * current window is supplied together with the current downstream queue size.
140      * {@code 0} should be returned if no change is
141      * required or a positive integer which will be added to the current window.
142      * The default implementation maintains a downstream queue size of no greater
143      * than 5. The method can be overridden if required.
144      *
145      * @param currentWindow the current upstream subscription window
146      * @param downstreamQsize the current number of buffers waiting to be sent
147      *                        downstream
148      *
149      * @return value to add to currentWindow
150      */
151     protected long upstreamWindowUpdate(long currentWindow, long downstreamQsize) {
152         if (downstreamQsize &gt; 5) {
153             return 0;
154         }
155 
156         if (currentWindow == 0) {
157             return 1;
158         } else {
159             return 0;
160         }
161     }
162 
163     /**
164      * Override this if anything needs to be done after the upstream subscriber
165      * has subscribed
166      */
167     protected void onSubscribe() {
168     }
169 
170     /**
171      * Override this if anything needs to be done before checking for error
172      * and processing the input queue.
173      * @return
174      */
175     protected SchedulingAction enterScheduling() {
176         return SchedulingAction.CONTINUE;
177     }
178 
179     protected boolean signalScheduling() {
180         if (downstreamCompleted || pushScheduler.isStopped()) {
181             return false;
182         }
183         pushScheduler.runOrSchedule();
184         return true;
185     }
186 
187     /**
188      * Delivers buffers of data downstream. After incoming()
189      * has been called complete == true signifying completion of the upstream
190      * subscription, data may continue to be delivered, up to when outgoing() is
191      * called complete == true, after which, the downstream subscription is
192      * completed.
193      *
194      * It&#39;s an error to call outgoing() with complete = true if incoming() has
195      * not previously been called with it.
196      */
197     public void outgoing(ByteBuffer buffer, boolean complete) {
198         Objects.requireNonNull(buffer);
199         assert !complete || !buffer.hasRemaining();
200         outgoing(List.of(buffer), complete);
201     }
202 
203     /**
204      * Sometime it might be necessary to complete the downstream subscriber
205      * before the upstream completes. For instance, when an SSL server
206      * sends a notify_close. In that case we should let the outgoing
207      * complete before upstream is completed.
208      * @return true, may be overridden by subclasses.
209      */
210     public boolean closing() {
211         return false;
212     }
213 
214     public void outgoing(List&lt;ByteBuffer&gt; buffers, boolean complete) {
215         Objects.requireNonNull(buffers);
216         if (complete) {
217             assert Utils.remaining(buffers) == 0;
218             boolean closing = closing();
219             if (debug.on())
220                 debug.log(&quot;completionAcknowledged upstreamCompleted:%s,&quot;
221                           + &quot; downstreamCompleted:%s, closing:%s&quot;,
222                           upstreamCompleted, downstreamCompleted, closing);
223             if (!upstreamCompleted &amp;&amp; !closing) {
224                 throw new IllegalStateException(&quot;upstream not completed&quot;);
225             }
226             completionAcknowledged = true;
227         } else {
228             if (debug.on())
229                 debug.log(&quot;Adding %d to outputQ queue&quot;, Utils.remaining(buffers));
230             outputQ.add(buffers);
231         }
232         if (debug.on())
233             debug.log(&quot;pushScheduler&quot; +(pushScheduler.isStopped() ? &quot; is stopped!&quot; : &quot; is alive&quot;));
234         pushScheduler.runOrSchedule();
235     }
236 
237     /**
238      * Returns a CompletableFuture which completes when this wrapper completes.
239      * Normal completion happens with the following steps (in order):
240      *   1. onComplete() is called
241      *   2. incoming() called with complete = true
242      *   3. outgoing() may continue to be called normally
243      *   4. outgoing called with complete = true
244      *   5. downstream subscriber is called onComplete()
245      *
246      * If the subscription is canceled or onComplete() is invoked the
247      * CompletableFuture completes exceptionally. Exceptional completion
248      * also occurs if downstreamCF completes exceptionally.
249      */
250     public CompletableFuture&lt;Void&gt; completion() {
251         return cf;
252     }
253 
254     /**
255      * Invoked whenever it &#39;may&#39; be possible to push buffers downstream.
256      */
257     class DownstreamPusher implements Runnable {
258         @Override
259         public void run() {
260             try {
261                 run1();
262             } catch (Throwable t) {
263                 if (debug.on())
264                     debug.log(&quot;DownstreamPusher threw: &quot; + t);
265                 errorCommon(t);
266             }
267         }
268 
269         private void run1() {
270             if (downstreamCompleted) {
271                 if (debug.on())
272                     debug.log(&quot;DownstreamPusher: downstream is already completed&quot;);
273                 return;
274             }
275             switch (enterScheduling()) {
276                 case CONTINUE: break;
277                 case RESCHEDULE: pushScheduler.runOrSchedule(); return;
278                 case RETURN: return;
279                 default:
280                     errorRef.compareAndSet(null,
281                             new InternalError(&quot;unknown scheduling command&quot;));
282                     break;
283             }
284             // If there was an error, send it downstream.
285             Throwable error = errorRef.get();
286             if (error != null &amp;&amp; outputQ.isEmpty()) {
287                 synchronized(this) {
288                     if (downstreamCompleted)
289                         return;
290                     downstreamCompleted = true;
291                 }
292                 if (debug.on())
293                     debug.log(&quot;DownstreamPusher: forwarding error downstream: &quot; + error);
294                 pushScheduler.stop();
295                 outputQ.clear();
296                 downstreamSubscriber.onError(error);
297                 cf.completeExceptionally(error);
298                 return;
299             }
300 
301             // OK - no error, let&#39;s proceed
302             if (!outputQ.isEmpty()) {
303                 if (debug.on())
304                     debug.log(&quot;DownstreamPusher: queue not empty, downstreamSubscription: %s&quot;,
305                               downstreamSubscription);
306             } else {
307                 if (debug.on())
308                     debug.log(&quot;DownstreamPusher: queue empty, downstreamSubscription: %s&quot;,
309                                downstreamSubscription);
310             }
311 
312             boolean datasent = false;
313             while (!outputQ.isEmpty() &amp;&amp; downstreamSubscription.tryDecrement()) {
314                 List&lt;ByteBuffer&gt; b = outputQ.poll();
315                 if (debug.on())
316                     debug.log(&quot;DownstreamPusher: Pushing %d bytes downstream&quot;,
317                               Utils.remaining(b));
318                 downstreamSubscriber.onNext(b);
319                 datasent = true;
320             }
<a name="3" id="anc3"></a><span class="line-modified">321             if (datasent) upstreamWindowUpdate();</span>














322             checkCompletion();
323         }
324     }
325 
<a name="4" id="anc4"></a>







326     void upstreamWindowUpdate() {
327         long downstreamQueueSize = outputQ.size();
328         long upstreamWindowSize = upstreamWindow.get();
329         long n = upstreamWindowUpdate(upstreamWindowSize, downstreamQueueSize);
330         if (debug.on())
331             debug.log(&quot;upstreamWindowUpdate, &quot;
332                       + &quot;downstreamQueueSize:%d, upstreamWindow:%d&quot;,
333                       downstreamQueueSize, upstreamWindowSize);
334         if (n &gt; 0)
335             upstreamRequest(n);
336     }
337 
338     @Override
339     public void onSubscribe(Flow.Subscription subscription) {
340         if (upstreamSubscription != null) {
341             throw new IllegalStateException(&quot;Single shot publisher&quot;);
342         }
343         this.upstreamSubscription = subscription;
<a name="5" id="anc5"></a><span class="line-modified">344         upstreamRequest(upstreamWindowUpdate(0, 0));</span>
345         if (debug.on())
346             debug.log(&quot;calling downstreamSubscriber::onSubscribe on %s&quot;,
347                       downstreamSubscriber);
348         downstreamSubscriber.onSubscribe(downstreamSubscription);
349         onSubscribe();
350     }
351 
352     @Override
353     public void onNext(List&lt;ByteBuffer&gt; item) {
354         if (debug.on()) debug.log(&quot;onNext&quot;);
355         long prev = upstreamWindow.getAndDecrement();
356         if (prev &lt;= 0)
357             throw new IllegalStateException(&quot;invalid onNext call&quot;);
358         incomingCaller(item, false);
<a name="6" id="anc6"></a><span class="line-removed">359         upstreamWindowUpdate();</span>
360     }
361 
362     private void upstreamRequest(long n) {
363         if (debug.on()) debug.log(&quot;requesting %d&quot;, n);
364         upstreamWindow.getAndAdd(n);
365         upstreamSubscription.request(n);
366     }
367 
<a name="7" id="anc7"></a>









368     protected void requestMore() {
369         if (upstreamWindow.get() == 0) {
370             upstreamRequest(1);
371         }
372     }
373 
374     public long upstreamWindow() {
375         return upstreamWindow.get();
376     }
377 
378     @Override
379     public void onError(Throwable throwable) {
380         if (debug.on()) debug.log(&quot;onError: &quot; + throwable);
381         errorCommon(Objects.requireNonNull(throwable));
382     }
383 
384     protected boolean errorCommon(Throwable throwable) {
385         assert throwable != null ||
386                 (throwable = new AssertionError(&quot;null throwable&quot;)) != null;
387         if (errorRef.compareAndSet(null, throwable)) {
388             if (debug.on()) debug.log(&quot;error&quot;, throwable);
389             upstreamCompleted = true;
390             pushScheduler.runOrSchedule();
391             return true;
392         }
393         return false;
394     }
395 
396     @Override
397     public void close() {
398         errorCommon(new RuntimeException(&quot;wrapper closed&quot;));
399     }
400 
401     public void close(Throwable t) {
402         errorCommon(t);
403     }
404 
405     private void incomingCaller(List&lt;ByteBuffer&gt; l, boolean complete) {
406         try {
407             incoming(l, complete);
408         } catch(Throwable t) {
409             errorCommon(t);
410         }
411     }
412 
413     @Override
414     public void onComplete() {
415         if (debug.on()) debug.log(&quot;upstream completed: &quot; + toString());
416         upstreamCompleted = true;
417         incomingCaller(Utils.EMPTY_BB_LIST, true);
418         // pushScheduler will call checkCompletion()
419         pushScheduler.runOrSchedule();
420     }
421 
422     /** Adds the given data to the input queue. */
423     public void addData(ByteBuffer l) {
424         if (upstreamSubscription == null) {
425             throw new IllegalStateException(&quot;can&#39;t add data before upstream subscriber subscribes&quot;);
426         }
427         incomingCaller(List.of(l), false);
428     }
429 
430     void checkCompletion() {
431         if (downstreamCompleted || !upstreamCompleted) {
432             return;
433         }
434         if (!outputQ.isEmpty()) {
435             return;
436         }
437         if (errorRef.get() != null) {
438             pushScheduler.runOrSchedule();
439             return;
440         }
441         if (completionAcknowledged) {
442             if (debug.on()) debug.log(&quot;calling downstreamSubscriber.onComplete()&quot;);
443             downstreamSubscriber.onComplete();
444             // Fix me subscriber.onComplete.run();
445             downstreamCompleted = true;
446             cf.complete(null);
447         }
448     }
449 
450     // called from the downstream Subscription.cancel()
451     void downstreamCompletion() {
452         upstreamSubscription.cancel();
453         cf.complete(null);
454     }
455 
456     public void resetDownstreamDemand() {
457         downstreamSubscription.demand.reset();
458     }
459 
460     @Override
461     public String toString() {
462         StringBuilder sb = new StringBuilder();
463         sb.append(&quot;SubscriberWrapper:&quot;)
464           .append(&quot; upstreamCompleted: &quot;).append(Boolean.toString(upstreamCompleted))
465           .append(&quot; upstreamWindow: &quot;).append(upstreamWindow.toString())
466           .append(&quot; downstreamCompleted: &quot;).append(Boolean.toString(downstreamCompleted))
467           .append(&quot; completionAcknowledged: &quot;).append(Boolean.toString(completionAcknowledged))
468           .append(&quot; outputQ size: &quot;).append(Integer.toString(outputQ.size()))
469           //.append(&quot; outputQ: &quot;).append(outputQ.toString())
470           .append(&quot; cf: &quot;).append(cf.toString())
471           .append(&quot; downstreamSubscription: &quot;).append(downstreamSubscription)
472           .append(&quot; downstreamSubscriber: &quot;).append(downstreamSubscriber);
473 
474         return sb.toString();
475     }
476 
477     public String dbgString() {
478         return &quot;SubscriberWrapper&quot;;
479     }
480 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.naming/share/classes/com/sun/jndi/ldap/Connection.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.jndi.ldap;
  27 
  28 import java.io.BufferedInputStream;
  29 import java.io.BufferedOutputStream;
  30 import java.io.InterruptedIOException;
  31 import java.io.IOException;
  32 import java.io.OutputStream;
  33 import java.io.InputStream;
  34 import java.net.InetSocketAddress;
  35 import java.net.Socket;
  36 import javax.net.ssl.SSLSocket;
  37 
  38 import javax.naming.CommunicationException;
  39 import javax.naming.ServiceUnavailableException;
  40 import javax.naming.NamingException;
  41 import javax.naming.InterruptedNamingException;
  42 
  43 import javax.naming.ldap.Control;
  44 
  45 import java.lang.reflect.Method;
  46 import java.lang.reflect.InvocationTargetException;
  47 import java.security.AccessController;
  48 import java.security.PrivilegedAction;
  49 import java.util.Arrays;
  50 import javax.net.SocketFactory;
  51 import javax.net.ssl.SSLParameters;
  52 
  53 /**
  54   * A thread that creates a connection to an LDAP server.
  55   * After the connection, the thread reads from the connection.
  56   * A caller can invoke methods on the instance to read LDAP responses
  57   * and to send LDAP requests.
  58   * &lt;p&gt;
  59   * There is a one-to-one correspondence between an LdapClient and
  60   * a Connection. Access to Connection and its methods is only via
  61   * LdapClient with two exceptions: SASL authentication and StartTLS.
  62   * SASL needs to access Connection&#39;s socket IO streams (in order to do encryption
  63   * of the security layer). StartTLS needs to do replace IO streams
  64   * and close the IO  streams on nonfatal close. The code for SASL
  65   * authentication can be treated as being the same as from LdapClient
  66   * because the SASL code is only ever called from LdapClient, from
  67   * inside LdapClient&#39;s synchronized authenticate() method. StartTLS is called
  68   * directly by the application but should only occur when the underlying
  69   * connection is quiet.
  70   * &lt;p&gt;
  71   * In terms of synchronization, worry about data structures
  72   * used by the Connection thread because that usage might contend
  73   * with calls by the main threads (i.e., those that call LdapClient).
  74   * Main threads need to worry about contention with each other.
  75   * Fields that Connection thread uses:
  76   *     inStream - synced access and update; initialized in constructor;
  77   *           referenced outside class unsync&#39;ed (by LdapSasl) only
  78   *           when connection is quiet
  79   *     traceFile, traceTagIn, traceTagOut - no sync; debugging only
  80   *     parent - no sync; initialized in constructor; no updates
  81   *     pendingRequests - sync
  82   *     pauseLock - per-instance lock;
  83   *     paused - sync via pauseLock (pauseReader())
  84   * Members used by main threads (LdapClient):
  85   *     host, port - unsync; read-only access for StartTLS and debug messages
  86   *     setBound(), setV3() - no sync; called only by LdapClient.authenticate(),
  87   *             which is a sync method called only when connection is &quot;quiet&quot;
  88   *     getMsgId() - sync
  89   *     writeRequest(), removeRequest(),findRequest(), abandonOutstandingReqs() -
  90   *             access to shared pendingRequests is sync
  91   *     writeRequest(),  abandonRequest(), ldapUnbind() - access to outStream sync
  92   *     cleanup() - sync
  93   *     readReply() - access to sock sync
  94   *     unpauseReader() - (indirectly via writeRequest) sync on pauseLock
  95   * Members used by SASL auth (main thread):
  96   *     inStream, outStream - no sync; used to construct new stream; accessed
  97   *             only when conn is &quot;quiet&quot; and not shared
  98   *     replaceStreams() - sync method
  99   * Members used by StartTLS:
 100   *     inStream, outStream - no sync; used to record the existing streams;
 101   *             accessed only when conn is &quot;quiet&quot; and not shared
 102   *     replaceStreams() - sync method
 103   * &lt;p&gt;
 104   * Handles anonymous, simple, and SASL bind for v3; anonymous and simple
 105   * for v2.
 106   * %%% made public for access by LdapSasl %%%
 107   *
 108   * @author Vincent Ryan
 109   * @author Rosanna Lee
 110   * @author Jagane Sundar
 111   */
 112 public final class Connection implements Runnable {
 113 
 114     private static final boolean debug = false;
 115     private static final int dump = 0; // &gt; 0 r, &gt; 1 rw
 116 
 117 
 118     final private Thread worker;    // Initialized in constructor
 119 
 120     private boolean v3 = true;       // Set in setV3()
 121 
 122     final public String host;  // used by LdapClient for generating exception messages
 123                          // used by StartTlsResponse when creating an SSL socket
 124     final public int port;     // used by LdapClient for generating exception messages
 125                          // used by StartTlsResponse when creating an SSL socket
 126 
 127     private boolean bound = false;   // Set in setBound()
 128 
 129     // All three are initialized in constructor and read-only afterwards
 130     private OutputStream traceFile = null;
 131     private String traceTagIn = null;
 132     private String traceTagOut = null;
 133 
 134     // Initialized in constructor; read and used externally (LdapSasl);
 135     // Updated in replaceStreams() during &quot;quiet&quot;, unshared, period
 136     public InputStream inStream;   // must be public; used by LdapSasl
 137 
 138     // Initialized in constructor; read and used externally (LdapSasl);
 139     // Updated in replaceOutputStream() during &quot;quiet&quot;, unshared, period
 140     public OutputStream outStream; // must be public; used by LdapSasl
 141 
 142     // Initialized in constructor; read and used externally (TLS) to
 143     // get new IO streams; closed during cleanup
 144     public Socket sock;            // for TLS
 145 
 146     // For processing &quot;disconnect&quot; unsolicited notification
 147     // Initialized in constructor
 148     final private LdapClient parent;
 149 
 150     // Incremented and returned in sync getMsgId()
 151     private int outMsgId = 0;
 152 
 153     //
 154     // The list of ldapRequests pending on this binding
 155     //
 156     // Accessed only within sync methods
 157     private LdapRequest pendingRequests = null;
 158 
 159     volatile IOException closureReason = null;
 160     volatile boolean useable = true;  // is Connection still useable
 161 
 162     int readTimeout;
 163     int connectTimeout;
 164     private static final boolean IS_HOSTNAME_VERIFICATION_DISABLED
 165             = hostnameVerificationDisabledValue();
 166 
 167     private static boolean hostnameVerificationDisabledValue() {
 168         PrivilegedAction&lt;String&gt; act = () -&gt; System.getProperty(
 169                 &quot;com.sun.jndi.ldap.object.disableEndpointIdentification&quot;);
 170         String prop = AccessController.doPrivileged(act);
 171         if (prop == null) {
 172             return false;
 173         }
 174         return prop.isEmpty() ? true : Boolean.parseBoolean(prop);
 175     }
 176     // true means v3; false means v2
 177     // Called in LdapClient.authenticate() (which is synchronized)
 178     // when connection is &quot;quiet&quot; and not shared; no need to synchronize
 179     void setV3(boolean v) {
 180         v3 = v;
 181     }
 182 
 183     // A BIND request has been successfully made on this connection
 184     // When cleaning up, remember to do an UNBIND
 185     // Called in LdapClient.authenticate() (which is synchronized)
 186     // when connection is &quot;quiet&quot; and not shared; no need to synchronize
 187     void setBound() {
 188         bound = true;
 189     }
 190 
 191     ////////////////////////////////////////////////////////////////////////////
 192     //
 193     // Create an LDAP Binding object and bind to a particular server
 194     //
 195     ////////////////////////////////////////////////////////////////////////////
 196 
 197     Connection(LdapClient parent, String host, int port, String socketFactory,
 198         int connectTimeout, int readTimeout, OutputStream trace) throws NamingException {
 199 
 200         this.host = host;
 201         this.port = port;
 202         this.parent = parent;
 203         this.readTimeout = readTimeout;
 204         this.connectTimeout = connectTimeout;
 205 
 206         if (trace != null) {
 207             traceFile = trace;
 208             traceTagIn = &quot;&lt;- &quot; + host + &quot;:&quot; + port + &quot;\n\n&quot;;
 209             traceTagOut = &quot;-&gt; &quot; + host + &quot;:&quot; + port + &quot;\n\n&quot;;
 210         }
 211 
 212         //
 213         // Connect to server
 214         //
 215         try {
 216             sock = createSocket(host, port, socketFactory, connectTimeout);
 217 
 218             if (debug) {
 219                 System.err.println(&quot;Connection: opening socket: &quot; + host + &quot;,&quot; + port);
 220             }
 221 
 222             inStream = new BufferedInputStream(sock.getInputStream());
 223             outStream = new BufferedOutputStream(sock.getOutputStream());
 224 
 225         } catch (InvocationTargetException e) {
 226             Throwable realException = e.getTargetException();
 227             // realException.printStackTrace();
 228 
 229             CommunicationException ce =
 230                 new CommunicationException(host + &quot;:&quot; + port);
 231             ce.setRootCause(realException);
 232             throw ce;
 233         } catch (Exception e) {
 234             // We need to have a catch all here and
 235             // ignore generic exceptions.
 236             // Also catches all IO errors generated by socket creation.
 237             CommunicationException ce =
 238                 new CommunicationException(host + &quot;:&quot; + port);
 239             ce.setRootCause(e);
 240             throw ce;
 241         }
 242 
 243         worker = Obj.helper.createThread(this);
 244         worker.setDaemon(true);
 245         worker.start();
 246     }
 247 
 248     /*
 249      * Create an InetSocketAddress using the specified hostname and port number.
 250      */
 251     private InetSocketAddress createInetSocketAddress(String host, int port) {
 252             return new InetSocketAddress(host, port);
 253     }
 254 
 255     /*
 256      * Create a Socket object using the specified socket factory and time limit.
 257      *
 258      * If a timeout is supplied and unconnected sockets are supported then
 259      * an unconnected socket is created and the timeout is applied when
 260      * connecting the socket. If a timeout is supplied but unconnected sockets
 261      * are not supported then the timeout is ignored and a connected socket
 262      * is created.
 263      */
 264     private Socket createSocket(String host, int port, String socketFactory,
 265             int connectTimeout) throws Exception {
 266 
 267         Socket socket = null;
 268 
 269         if (socketFactory != null) {
 270 
 271             // create the factory
 272 
 273             @SuppressWarnings(&quot;unchecked&quot;)
 274             Class&lt;? extends SocketFactory&gt; socketFactoryClass =
 275                 (Class&lt;? extends SocketFactory&gt;)Obj.helper.loadClass(socketFactory);
 276             Method getDefault =
 277                 socketFactoryClass.getMethod(&quot;getDefault&quot;, new Class&lt;?&gt;[]{});
 278             SocketFactory factory = (SocketFactory) getDefault.invoke(null, new Object[]{});
 279 
 280             // create the socket
 281 
 282             if (connectTimeout &gt; 0) {
 283 
 284                 InetSocketAddress endpoint =
 285                         createInetSocketAddress(host, port);
 286 
 287                 // unconnected socket
 288                 socket = factory.createSocket();
 289 
 290                 if (debug) {
 291                     System.err.println(&quot;Connection: creating socket with &quot; +
 292                             &quot;a timeout using supplied socket factory&quot;);
 293                 }
 294 
 295                 // connected socket
 296                 socket.connect(endpoint, connectTimeout);
 297             }
 298 
 299             // continue (but ignore connectTimeout)
 300             if (socket == null) {
 301                 if (debug) {
 302                     System.err.println(&quot;Connection: creating socket using &quot; +
 303                         &quot;supplied socket factory&quot;);
 304                 }
 305                 // connected socket
 306                 socket = factory.createSocket(host, port);
 307             }
 308         } else {
 309 
 310             if (connectTimeout &gt; 0) {
 311 
 312                     InetSocketAddress endpoint = createInetSocketAddress(host, port);
 313 
 314                     socket = new Socket();
 315 
 316                     if (debug) {
 317                         System.err.println(&quot;Connection: creating socket with &quot; +
 318                             &quot;a timeout&quot;);
 319                     }
 320                     socket.connect(endpoint, connectTimeout);
 321             }
 322 
 323             // continue (but ignore connectTimeout)
 324 
 325             if (socket == null) {
 326                 if (debug) {
 327                     System.err.println(&quot;Connection: creating socket&quot;);
 328                 }
 329                 // connected socket
 330                 socket = new Socket(host, port);
 331             }
 332         }
 333 
 334         // For LDAP connect timeouts on LDAP over SSL connections must treat
 335         // the SSL handshake following socket connection as part of the timeout.
 336         // So explicitly set a socket read timeout, trigger the SSL handshake,
 337         // then reset the timeout.
 338         if (socket instanceof SSLSocket) {
 339             SSLSocket sslSocket = (SSLSocket) socket;
 340             if (!IS_HOSTNAME_VERIFICATION_DISABLED) {
 341                 SSLParameters param = sslSocket.getSSLParameters();
 342                 param.setEndpointIdentificationAlgorithm(&quot;LDAPS&quot;);
 343                 sslSocket.setSSLParameters(param);
 344             }
 345             if (connectTimeout &gt; 0) {
 346                 int socketTimeout = sslSocket.getSoTimeout();
 347                 sslSocket.setSoTimeout(connectTimeout); // reuse full timeout value
 348                 sslSocket.startHandshake();
 349                 sslSocket.setSoTimeout(socketTimeout);
 350             }
 351         }
 352         return socket;
 353     }
 354 
 355     ////////////////////////////////////////////////////////////////////////////
 356     //
 357     // Methods to IO to the LDAP server
 358     //
 359     ////////////////////////////////////////////////////////////////////////////
 360 
 361     synchronized int getMsgId() {
 362         return ++outMsgId;
 363     }
 364 
 365     LdapRequest writeRequest(BerEncoder ber, int msgId) throws IOException {
 366         return writeRequest(ber, msgId, false /* pauseAfterReceipt */, -1);
 367     }
 368 
 369     LdapRequest writeRequest(BerEncoder ber, int msgId,
 370         boolean pauseAfterReceipt) throws IOException {
 371         return writeRequest(ber, msgId, pauseAfterReceipt, -1);
 372     }
 373 
 374     LdapRequest writeRequest(BerEncoder ber, int msgId,
 375         boolean pauseAfterReceipt, int replyQueueCapacity) throws IOException {
 376 
 377         LdapRequest req =
 378             new LdapRequest(msgId, pauseAfterReceipt, replyQueueCapacity);
 379         addRequest(req);
 380 
 381         if (traceFile != null) {
 382             Ber.dumpBER(traceFile, traceTagOut, ber.getBuf(), 0, ber.getDataLen());
 383         }
 384 
 385 
 386         // unpause reader so that it can get response
 387         // NOTE: Must do this before writing request, otherwise might
 388         // create a race condition where the writer unblocks its own response
 389         unpauseReader();
 390 
 391         if (debug) {
 392             System.err.println(&quot;Writing request to: &quot; + outStream);
 393         }
 394 
 395         try {
 396             synchronized (this) {
 397                 outStream.write(ber.getBuf(), 0, ber.getDataLen());
 398                 outStream.flush();
 399             }
 400         } catch (IOException e) {
 401             cleanup(null, true);
 402             throw (closureReason = e); // rethrow
 403         }
 404 
 405         return req;
 406     }
 407 
 408     /**
 409      * Reads a reply; waits until one is ready.
 410      */
<a name="1" id="anc1"></a><span class="line-modified"> 411     BerDecoder readReply(LdapRequest ldr) throws IOException, NamingException {</span>

 412         BerDecoder rber;
 413 
<a name="2" id="anc2"></a><span class="line-modified"> 414         // If socket closed, don&#39;t even try</span>
<span class="line-modified"> 415         synchronized (this) {</span>
<span class="line-modified"> 416             if (sock == null) {</span>
<span class="line-modified"> 417                 throw new ServiceUnavailableException(host + &quot;:&quot; + port +</span>
<span class="line-modified"> 418                     &quot;; socket closed&quot;);</span>





































 419             }
 420         }
 421 
<a name="3" id="anc3"></a><span class="line-modified"> 422         try {</span>
<span class="line-added"> 423             // if no timeout is set so we wait infinitely until</span>
<span class="line-added"> 424             // a response is received</span>
<span class="line-added"> 425             // http://docs.oracle.com/javase/8/docs/technotes/guides/jndi/jndi-ldap.html#PROP</span>
<span class="line-added"> 426             rber = ldr.getReplyBer(readTimeout);</span>
<span class="line-added"> 427         } catch (InterruptedException ex) {</span>
<span class="line-added"> 428             throw new InterruptedNamingException(</span>
<span class="line-added"> 429                 &quot;Interrupted during LDAP operation&quot;);</span>
<span class="line-added"> 430         }</span>
<span class="line-added"> 431 </span>
<span class="line-added"> 432         if (rber == null) {</span>
 433             abandonRequest(ldr, null);
<a name="4" id="anc4"></a><span class="line-modified"> 434             throw new NamingException(</span>
<span class="line-added"> 435                     &quot;LDAP response read timed out, timeout used:&quot;</span>
 436                             + readTimeout + &quot;ms.&quot; );
 437 
 438         }
 439         return rber;
 440     }
 441 
<a name="5" id="anc5"></a>
 442     ////////////////////////////////////////////////////////////////////////////
 443     //
 444     // Methods to add, find, delete, and abandon requests made to server
 445     //
 446     ////////////////////////////////////////////////////////////////////////////
 447 
 448     private synchronized void addRequest(LdapRequest ldapRequest) {
 449 
 450         LdapRequest ldr = pendingRequests;
 451         if (ldr == null) {
 452             pendingRequests = ldapRequest;
 453             ldapRequest.next = null;
 454         } else {
 455             ldapRequest.next = pendingRequests;
 456             pendingRequests = ldapRequest;
 457         }
 458     }
 459 
 460     synchronized LdapRequest findRequest(int msgId) {
 461 
 462         LdapRequest ldr = pendingRequests;
 463         while (ldr != null) {
 464             if (ldr.msgId == msgId) {
 465                 return ldr;
 466             }
 467             ldr = ldr.next;
 468         }
 469         return null;
 470 
 471     }
 472 
 473     synchronized void removeRequest(LdapRequest req) {
 474         LdapRequest ldr = pendingRequests;
 475         LdapRequest ldrprev = null;
 476 
 477         while (ldr != null) {
 478             if (ldr == req) {
 479                 ldr.cancel();
 480 
 481                 if (ldrprev != null) {
 482                     ldrprev.next = ldr.next;
 483                 } else {
 484                     pendingRequests = ldr.next;
 485                 }
 486                 ldr.next = null;
 487             }
 488             ldrprev = ldr;
 489             ldr = ldr.next;
 490         }
 491     }
 492 
 493     void abandonRequest(LdapRequest ldr, Control[] reqCtls) {
 494         // Remove from queue
 495         removeRequest(ldr);
 496 
 497         BerEncoder ber = new BerEncoder(256);
 498         int abandonMsgId = getMsgId();
 499 
 500         //
 501         // build the abandon request.
 502         //
 503         try {
 504             ber.beginSeq(Ber.ASN_SEQUENCE | Ber.ASN_CONSTRUCTOR);
 505                 ber.encodeInt(abandonMsgId);
 506                 ber.encodeInt(ldr.msgId, LdapClient.LDAP_REQ_ABANDON);
 507 
 508                 if (v3) {
 509                     LdapClient.encodeControls(ber, reqCtls);
 510                 }
 511             ber.endSeq();
 512 
 513             if (traceFile != null) {
 514                 Ber.dumpBER(traceFile, traceTagOut, ber.getBuf(), 0,
 515                     ber.getDataLen());
 516             }
 517 
 518             synchronized (this) {
 519                 outStream.write(ber.getBuf(), 0, ber.getDataLen());
 520                 outStream.flush();
 521             }
 522 
 523         } catch (IOException ex) {
 524             //System.err.println(&quot;ldap.abandon: &quot; + ex);
 525         }
 526 
 527         // Don&#39;t expect any response for the abandon request.
 528     }
 529 
 530     synchronized void abandonOutstandingReqs(Control[] reqCtls) {
 531         LdapRequest ldr = pendingRequests;
 532 
 533         while (ldr != null) {
 534             abandonRequest(ldr, reqCtls);
 535             pendingRequests = ldr = ldr.next;
 536         }
 537     }
 538 
 539     ////////////////////////////////////////////////////////////////////////////
 540     //
 541     // Methods to unbind from server and clear up resources when object is
 542     // destroyed.
 543     //
 544     ////////////////////////////////////////////////////////////////////////////
 545 
 546     private void ldapUnbind(Control[] reqCtls) {
 547 
 548         BerEncoder ber = new BerEncoder(256);
 549         int unbindMsgId = getMsgId();
 550 
 551         //
 552         // build the unbind request.
 553         //
 554 
 555         try {
 556 
 557             ber.beginSeq(Ber.ASN_SEQUENCE | Ber.ASN_CONSTRUCTOR);
 558                 ber.encodeInt(unbindMsgId);
 559                 // IMPLICIT TAGS
 560                 ber.encodeByte(LdapClient.LDAP_REQ_UNBIND);
 561                 ber.encodeByte(0);
 562 
 563                 if (v3) {
 564                     LdapClient.encodeControls(ber, reqCtls);
 565                 }
 566             ber.endSeq();
 567 
 568             if (traceFile != null) {
 569                 Ber.dumpBER(traceFile, traceTagOut, ber.getBuf(),
 570                     0, ber.getDataLen());
 571             }
 572 
 573             synchronized (this) {
 574                 outStream.write(ber.getBuf(), 0, ber.getDataLen());
 575                 outStream.flush();
 576             }
 577 
 578         } catch (IOException ex) {
 579             //System.err.println(&quot;ldap.unbind: &quot; + ex);
 580         }
 581 
 582         // Don&#39;t expect any response for the unbind request.
 583     }
 584 
 585     /**
 586      * @param reqCtls Possibly null request controls that accompanies the
 587      *    abandon and unbind LDAP request.
 588      * @param notifyParent true means to call parent LdapClient back, notifying
 589      *    it that the connection has been closed; false means not to notify
 590      *    parent. If LdapClient invokes cleanup(), notifyParent should be set to
 591      *    false because LdapClient already knows that it is closing
 592      *    the connection. If Connection invokes cleanup(), notifyParent should be
 593      *    set to true because LdapClient needs to know about the closure.
 594      */
 595     void cleanup(Control[] reqCtls, boolean notifyParent) {
 596         boolean nparent = false;
 597 
 598         synchronized (this) {
 599             useable = false;
 600 
 601             if (sock != null) {
 602                 if (debug) {
 603                     System.err.println(&quot;Connection: closing socket: &quot; + host + &quot;,&quot; + port);
 604                 }
 605                 try {
 606                     if (!notifyParent) {
 607                         abandonOutstandingReqs(reqCtls);
 608                     }
 609                     if (bound) {
 610                         ldapUnbind(reqCtls);
 611                     }
 612                 } finally {
 613                     try {
 614                         outStream.flush();
 615                         sock.close();
 616                         unpauseReader();
 617                     } catch (IOException ie) {
 618                         if (debug)
 619                             System.err.println(&quot;Connection: problem closing socket: &quot; + ie);
 620                     }
 621                     if (!notifyParent) {
 622                         LdapRequest ldr = pendingRequests;
 623                         while (ldr != null) {
 624                             ldr.cancel();
 625                             ldr = ldr.next;
 626                         }
 627                     }
 628                     sock = null;
 629                 }
 630                 nparent = notifyParent;
 631             }
 632             if (nparent) {
 633                 LdapRequest ldr = pendingRequests;
 634                 while (ldr != null) {
<a name="6" id="anc6"></a><span class="line-modified"> 635                     ldr.close();</span>


 636                         ldr = ldr.next;
 637                     }
 638                 }
 639             }
<a name="7" id="anc7"></a>
 640         if (nparent) {
 641             parent.processConnectionClosure();
 642         }
 643     }
 644 
 645 
 646     // Assume everything is &quot;quiet&quot;
 647     // &quot;synchronize&quot; might lead to deadlock so don&#39;t synchronize method
 648     // Use streamLock instead for synchronizing update to stream
 649 
 650     synchronized public void replaceStreams(InputStream newIn, OutputStream newOut) {
 651         if (debug) {
 652             System.err.println(&quot;Replacing &quot; + inStream + &quot; with: &quot; + newIn);
 653             System.err.println(&quot;Replacing &quot; + outStream + &quot; with: &quot; + newOut);
 654         }
 655 
 656         inStream = newIn;
 657 
 658         // Cleanup old stream
 659         try {
 660             outStream.flush();
 661         } catch (IOException ie) {
 662             if (debug)
 663                 System.err.println(&quot;Connection: cannot flush outstream: &quot; + ie);
 664         }
 665 
 666         // Replace stream
 667         outStream = newOut;
 668     }
 669 
 670     /**
 671      * Used by Connection thread to read inStream into a local variable.
 672      * This ensures that there is no contention between the main thread
 673      * and the Connection thread when the main thread updates inStream.
 674      */
 675     synchronized private InputStream getInputStream() {
 676         return inStream;
 677     }
 678 
 679 
 680     ////////////////////////////////////////////////////////////////////////////
 681     //
 682     // Code for pausing/unpausing the reader thread (&#39;worker&#39;)
 683     //
 684     ////////////////////////////////////////////////////////////////////////////
 685 
 686     /*
 687      * The main idea is to mark requests that need the reader thread to
 688      * pause after getting the response. When the reader thread gets the response,
 689      * it waits on a lock instead of returning to the read(). The next time a
 690      * request is sent, the reader is automatically unblocked if necessary.
 691      * Note that the reader must be unblocked BEFORE the request is sent.
 692      * Otherwise, there is a race condition where the request is sent and
 693      * the reader thread might read the response and be unblocked
 694      * by writeRequest().
 695      *
 696      * This pause gives the main thread (StartTLS or SASL) an opportunity to
 697      * update the reader&#39;s state (e.g., its streams) if necessary.
 698      * The assumption is that the connection will remain quiet during this pause
 699      * (i.e., no intervening requests being sent).
 700      *&lt;p&gt;
 701      * For dealing with StartTLS close,
 702      * when the read() exits either due to EOF or an exception,
 703      * the reader thread checks whether there is a new stream to read from.
 704      * If so, then it reattempts the read. Otherwise, the EOF or exception
 705      * is processed and the reader thread terminates.
 706      * In a StartTLS close, the client first replaces the SSL IO streams with
 707      * plain ones and then closes the SSL socket.
 708      * If the reader thread attempts to read, or was reading, from
 709      * the SSL socket (that is, it got to the read BEFORE replaceStreams()),
 710      * the SSL socket close will cause the reader thread to
 711      * get an EOF/exception and reexamine the input stream.
 712      * If the reader thread sees a new stream, it reattempts the read.
 713      * If the underlying socket is still alive, then the new read will succeed.
 714      * If the underlying socket has been closed also, then the new read will
 715      * fail and the reader thread exits.
 716      * If the reader thread attempts to read, or was reading, from the plain
 717      * socket (that is, it got to the read AFTER replaceStreams()), the
 718      * SSL socket close will have no effect on the reader thread.
 719      *
 720      * The check for new stream is made only
 721      * in the first attempt at reading a BER buffer; the reader should
 722      * never be in midst of reading a buffer when a nonfatal close occurs.
 723      * If this occurs, then the connection is in an inconsistent state and
 724      * the safest thing to do is to shut it down.
 725      */
 726 
<a name="8" id="anc8"></a><span class="line-modified"> 727     private final Object pauseLock = new Object();  // lock for reader to wait on while paused</span>
 728     private boolean paused = false;           // paused state of reader
 729 
 730     /*
 731      * Unpauses reader thread if it was paused
 732      */
 733     private void unpauseReader() throws IOException {
 734         synchronized (pauseLock) {
 735             if (paused) {
 736                 if (debug) {
 737                     System.err.println(&quot;Unpausing reader; read from: &quot; +
 738                                         inStream);
 739                 }
 740                 paused = false;
 741                 pauseLock.notify();
 742             }
 743         }
 744     }
 745 
 746      /*
 747      * Pauses reader so that it stops reading from the input stream.
 748      * Reader blocks on pauseLock instead of read().
 749      * MUST be called from within synchronized (pauseLock) clause.
 750      */
 751     private void pauseReader() throws IOException {
 752         if (debug) {
 753             System.err.println(&quot;Pausing reader;  was reading from: &quot; +
 754                                 inStream);
 755         }
 756         paused = true;
 757         try {
 758             while (paused) {
 759                 pauseLock.wait(); // notified by unpauseReader
 760             }
 761         } catch (InterruptedException e) {
 762             throw new InterruptedIOException(
 763                     &quot;Pause/unpause reader has problems.&quot;);
 764         }
 765     }
 766 
 767 
 768     ////////////////////////////////////////////////////////////////////////////
 769     //
 770     // The LDAP Binding thread. It does the mux/demux of multiple requests
 771     // on the same TCP connection.
 772     //
 773     ////////////////////////////////////////////////////////////////////////////
 774 
 775 
 776     public void run() {
 777         byte inbuf[];   // Buffer for reading incoming bytes
 778         int inMsgId;    // Message id of incoming response
 779         int bytesread;  // Number of bytes in inbuf
 780         int br;         // Temp; number of bytes read from stream
 781         int offset;     // Offset of where to store bytes in inbuf
 782         int seqlen;     // Length of ASN sequence
 783         int seqlenlen;  // Number of sequence length bytes
 784         boolean eos;    // End of stream
 785         BerDecoder retBer;    // Decoder for ASN.1 BER data from inbuf
 786         InputStream in = null;
 787 
 788         try {
 789             while (true) {
 790                 try {
 791                     // type and length (at most 128 octets for long form)
 792                     inbuf = new byte[129];
 793 
 794                     offset = 0;
 795                     seqlen = 0;
 796                     seqlenlen = 0;
 797 
 798                     in = getInputStream();
 799 
 800                     // check that it is the beginning of a sequence
 801                     bytesread = in.read(inbuf, offset, 1);
 802                     if (bytesread &lt; 0) {
 803                         if (in != getInputStream()) {
 804                             continue;   // a new stream to try
 805                         } else {
 806                             break; // EOF
 807                         }
 808                     }
 809 
 810                     if (inbuf[offset++] != (Ber.ASN_SEQUENCE | Ber.ASN_CONSTRUCTOR))
 811                         continue;
 812 
 813                     // get length of sequence
 814                     bytesread = in.read(inbuf, offset, 1);
 815                     if (bytesread &lt; 0)
 816                         break; // EOF
 817                     seqlen = inbuf[offset++];
 818 
 819                     // if high bit is on, length is encoded in the
 820                     // subsequent length bytes and the number of length bytes
 821                     // is equal to &amp; 0x80 (i.e. length byte with high bit off).
 822                     if ((seqlen &amp; 0x80) == 0x80) {
 823                         seqlenlen = seqlen &amp; 0x7f;  // number of length bytes
 824 
 825                         bytesread = 0;
 826                         eos = false;
 827 
 828                         // Read all length bytes
 829                         while (bytesread &lt; seqlenlen) {
 830                             br = in.read(inbuf, offset+bytesread,
 831                                 seqlenlen-bytesread);
 832                             if (br &lt; 0) {
 833                                 eos = true;
 834                                 break; // EOF
 835                             }
 836                             bytesread += br;
 837                         }
 838 
 839                         // end-of-stream reached before length bytes are read
 840                         if (eos)
 841                             break;  // EOF
 842 
 843                         // Add contents of length bytes to determine length
 844                         seqlen = 0;
 845                         for( int i = 0; i &lt; seqlenlen; i++) {
 846                             seqlen = (seqlen &lt;&lt; 8) + (inbuf[offset+i] &amp; 0xff);
 847                         }
 848                         offset += bytesread;
 849                     }
 850 
 851                     // read in seqlen bytes
 852                     byte[] left = readFully(in, seqlen);
 853                     inbuf = Arrays.copyOf(inbuf, offset + left.length);
 854                     System.arraycopy(left, 0, inbuf, offset, left.length);
 855                     offset += left.length;
 856 /*
 857 if (dump &gt; 0) {
 858 System.err.println(&quot;seqlen: &quot; + seqlen);
 859 System.err.println(&quot;bufsize: &quot; + offset);
 860 System.err.println(&quot;bytesleft: &quot; + bytesleft);
 861 System.err.println(&quot;bytesread: &quot; + bytesread);
 862 }
 863 */
 864 
 865 
 866                     try {
 867                         retBer = new BerDecoder(inbuf, 0, offset);
 868 
 869                         if (traceFile != null) {
 870                             Ber.dumpBER(traceFile, traceTagIn, inbuf, 0, offset);
 871                         }
 872 
 873                         retBer.parseSeq(null);
 874                         inMsgId = retBer.parseInt();
 875                         retBer.reset(); // reset offset
 876 
 877                         boolean needPause = false;
 878 
 879                         if (inMsgId == 0) {
 880                             // Unsolicited Notification
 881                             parent.processUnsolicited(retBer);
 882                         } else {
 883                             LdapRequest ldr = findRequest(inMsgId);
 884 
 885                             if (ldr != null) {
 886 
 887                                 /**
 888                                  * Grab pauseLock before making reply available
 889                                  * to ensure that reader goes into paused state
 890                                  * before writer can attempt to unpause reader
 891                                  */
 892                                 synchronized (pauseLock) {
 893                                     needPause = ldr.addReplyBer(retBer);
 894                                     if (needPause) {
 895                                         /*
 896                                          * Go into paused state; release
 897                                          * pauseLock
 898                                          */
 899                                         pauseReader();
 900                                     }
 901 
 902                                     // else release pauseLock
 903                                 }
 904                             } else {
 905                                 // System.err.println(&quot;Cannot find&quot; +
 906                                 //              &quot;LdapRequest for &quot; + inMsgId);
 907                             }
 908                         }
 909                     } catch (Ber.DecodeException e) {
 910                         //System.err.println(&quot;Cannot parse Ber&quot;);
 911                     }
 912                 } catch (IOException ie) {
 913                     if (debug) {
 914                         System.err.println(&quot;Connection: Inside Caught &quot; + ie);
 915                         ie.printStackTrace();
 916                     }
 917 
 918                     if (in != getInputStream()) {
 919                         // A new stream to try
 920                         // Go to top of loop and continue
 921                     } else {
 922                         if (debug) {
 923                             System.err.println(&quot;Connection: rethrowing &quot; + ie);
 924                         }
 925                         throw ie;  // rethrow exception
 926                     }
 927                 }
 928             }
 929 
 930             if (debug) {
 931                 System.err.println(&quot;Connection: end-of-stream detected: &quot;
 932                     + in);
 933             }
 934         } catch (IOException ex) {
 935             if (debug) {
 936                 System.err.println(&quot;Connection: Caught &quot; + ex);
 937             }
 938             closureReason = ex;
 939         } finally {
 940             cleanup(null, true); // cleanup
 941         }
 942         if (debug) {
 943             System.err.println(&quot;Connection: Thread Exiting&quot;);
 944         }
 945     }
 946 
 947     private static byte[] readFully(InputStream is, int length)
 948         throws IOException
 949     {
 950         byte[] buf = new byte[Math.min(length, 8192)];
 951         int nread = 0;
 952         while (nread &lt; length) {
 953             int bytesToRead;
 954             if (nread &gt;= buf.length) {  // need to allocate a larger buffer
 955                 bytesToRead = Math.min(length - nread, buf.length + 8192);
 956                 if (buf.length &lt; nread + bytesToRead) {
 957                     buf = Arrays.copyOf(buf, nread + bytesToRead);
 958                 }
 959             } else {
 960                 bytesToRead = buf.length - nread;
 961             }
 962             int count = is.read(buf, nread, bytesToRead);
 963             if (count &lt; 0) {
 964                 if (buf.length != nread)
 965                     buf = Arrays.copyOf(buf, nread);
 966                 break;
 967             }
 968             nread += count;
 969         }
 970         return buf;
 971     }
 972 
 973     // This code must be uncommented to run the LdapAbandonTest.
 974     /*public void sendSearchReqs(String dn, int numReqs) {
 975         int i;
 976         String attrs[] = null;
 977         for(i = 1; i &lt;= numReqs; i++) {
 978             BerEncoder ber = new BerEncoder(2048);
 979 
 980             try {
 981             ber.beginSeq(Ber.ASN_SEQUENCE | Ber.ASN_CONSTRUCTOR);
 982                 ber.encodeInt(i);
 983                 ber.beginSeq(LdapClient.LDAP_REQ_SEARCH);
 984                     ber.encodeString(dn == null ? &quot;&quot; : dn);
 985                     ber.encodeInt(0, LdapClient.LBER_ENUMERATED);
 986                     ber.encodeInt(3, LdapClient.LBER_ENUMERATED);
 987                     ber.encodeInt(0);
 988                     ber.encodeInt(0);
 989                     ber.encodeBoolean(true);
 990                     LdapClient.encodeFilter(ber, &quot;&quot;);
 991                     ber.beginSeq(Ber.ASN_SEQUENCE | Ber.ASN_CONSTRUCTOR);
 992                         ber.encodeStringArray(attrs);
 993                     ber.endSeq();
 994                 ber.endSeq();
 995             ber.endSeq();
 996             writeRequest(ber, i);
 997             //System.err.println(&quot;wrote request &quot; + i);
 998             } catch (Exception ex) {
 999             //System.err.println(&quot;ldap.search: Caught &quot; + ex + &quot; building req&quot;);
1000             }
1001 
1002         }
1003     } */
1004 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
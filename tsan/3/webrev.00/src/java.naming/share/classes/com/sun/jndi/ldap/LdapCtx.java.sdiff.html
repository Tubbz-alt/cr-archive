<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.naming/share/classes/com/sun/jndi/ldap/LdapCtx.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DefaultLdapDnsProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LdapDnsProviderService.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.naming/share/classes/com/sun/jndi/ldap/LdapCtx.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 207     private static final ControlFactory myResponseControlFactory =
 208         new DefaultResponseControlFactory();
 209     private static final Control manageReferralControl =
 210         new ManageReferralControl(false);
 211 
 212     private static final HierMemDirCtx EMPTY_SCHEMA = new HierMemDirCtx();
 213     static {
 214         EMPTY_SCHEMA.setReadOnly(
 215             new SchemaViolationException(&quot;Cannot update schema object&quot;));
 216     }
 217 
 218     // ------------ Package private instance variables ----------------
 219     // Cannot be private; used by enums
 220 
 221         // ------- Inherited by derived context instances
 222 
 223     int port_number;                    // port number of server
 224     String hostname = null;             // host name of server (no brackets
 225                                         //   for IPv6 literals)
 226     LdapClient clnt = null;             // connection handle
<span class="line-removed"> 227     private boolean reconnect = false;  // indicates that re-connect requested</span>
 228     Hashtable&lt;String, java.lang.Object&gt; envprops = null; // environment properties of context
 229     int handleReferrals = DEFAULT_REFERRAL_MODE; // how referral is handled
 230     boolean hasLdapsScheme = false;     // true if the context was created
 231                                         //  using an LDAPS URL.
 232 
 233         // ------- Not inherited by derived context instances
 234 
 235     String currentDN;                   // DN of this context
 236     Name currentParsedDN;               // DN of this context
 237     Vector&lt;Control&gt; respCtls = null;    // Response controls read
 238     Control[] reqCtls = null;           // Controls to be sent with each request
 239 
 240 
 241     // ------------- Private instance variables ------------------------
 242 
 243         // ------- Inherited by derived context instances
 244 
 245     private OutputStream trace = null;  // output stream for BER debug output
 246     private boolean netscapeSchemaBug = false;       // workaround
 247     private Control[] bindCtls = null;  // Controls to be sent with LDAP &quot;bind&quot;
</pre>
<hr />
<pre>
2651         schemaTrees = null;
2652         envprops = null;
2653 */
2654     }
2655 
2656     @SuppressWarnings(&quot;unchecked&quot;) // clone()
2657     public void reconnect(Control[] connCtls) throws NamingException {
2658         // Update environment
2659         envprops = (envprops == null
2660                 ? new Hashtable&lt;String, Object&gt;(5, 0.75f)
2661                 : (Hashtable&lt;String, Object&gt;)envprops.clone());
2662 
2663         if (connCtls == null) {
2664             envprops.remove(BIND_CONTROLS);
2665             bindCtls = null;
2666         } else {
2667             envprops.put(BIND_CONTROLS, bindCtls = cloneControls(connCtls));
2668         }
2669 
2670         sharable = false;  // can&#39;t share with existing contexts
<span class="line-removed">2671         reconnect = true;</span>
2672         ensureOpen();      // open or reauthenticated
2673     }
2674 
2675     private void ensureOpen() throws NamingException {
2676         ensureOpen(false);
2677     }
2678 
2679     private void ensureOpen(boolean startTLS) throws NamingException {
2680 
2681         try {
2682             if (clnt == null) {
2683                 if (debug) {
2684                     System.err.println(&quot;LdapCtx: Reconnecting &quot; + this);
2685                 }
2686 
2687                 // reset the cache before a new connection is established
2688                 schemaTrees = new Hashtable&lt;&gt;(11, 0.75f);
2689                 connect(startTLS);
2690 
2691             } else if (!sharable || startTLS) {
2692 
2693                 synchronized (clnt) {
2694                     if (!clnt.isLdapv3
2695                         || clnt.referenceCount &gt; 1
<span class="line-modified">2696                         || clnt.usingSaslStreams()) {</span>

2697                         closeConnection(SOFT_CLOSE);
2698                     }
2699                 }
2700                 // reset the cache before a new connection is established
2701                 schemaTrees = new Hashtable&lt;&gt;(11, 0.75f);
2702                 connect(startTLS);
2703             }
2704 
2705         } finally {
2706             sharable = true;   // connection is now either new or single-use
2707                                // OK for others to start sharing again
2708         }
2709     }
2710 
2711     private void connect(boolean startTLS) throws NamingException {
2712         if (debug) { System.err.println(&quot;LdapCtx: Connecting &quot; + this); }
2713 
2714         String user = null;             // authenticating user
2715         Object passwd = null;           // password for authenticating user
2716         String secProtocol = null;      // security protocol (e.g. &quot;ssl&quot;)
</pre>
<hr />
<pre>
2728                useSsl ? &quot;ssl&quot; : (String)envprops.get(Context.SECURITY_PROTOCOL);
2729             socketFactory = (String)envprops.get(SOCKET_FACTORY);
2730             authMechanism =
2731                 (String)envprops.get(Context.SECURITY_AUTHENTICATION);
2732 
2733             usePool = &quot;true&quot;.equalsIgnoreCase((String)envprops.get(ENABLE_POOL));
2734         }
2735 
2736         if (socketFactory == null) {
2737             socketFactory =
2738                 &quot;ssl&quot;.equals(secProtocol) ? DEFAULT_SSL_FACTORY : null;
2739         }
2740 
2741         if (authMechanism == null) {
2742             authMechanism = (user == null) ? &quot;none&quot; : &quot;simple&quot;;
2743         }
2744 
2745         try {
2746             boolean initial = (clnt == null);
2747 
<span class="line-modified">2748             if (initial || reconnect) {</span>
2749                 ldapVersion = (ver != null) ? Integer.parseInt(ver) :
2750                     DEFAULT_LDAP_VERSION;
2751 
2752                 clnt = LdapClient.getInstance(
2753                     usePool, // Whether to use connection pooling
2754 
2755                     // Required for LdapClient constructor
2756                     hostname,
2757                     port_number,
2758                     socketFactory,
2759                     connectTimeout,
2760                     readTimeout,
2761                     trace,
2762 
2763                     // Required for basic client identity
2764                     ldapVersion,
2765                     authMechanism,
2766                     bindCtls,
2767                     secProtocol,
2768 
2769                     // Required for simple client identity
2770                     user,
2771                     passwd,
2772 
2773                     // Required for SASL client identity
2774                     envprops);
2775 
<span class="line-removed">2776                 reconnect = false;</span>
<span class="line-removed">2777 </span>
2778                 /**
2779                  * Pooled connections are preauthenticated;
2780                  * newly created ones are not.
2781                  */
2782                 if (clnt.authenticateCalled()) {
2783                     return;
2784                 }
2785 
2786             } else if (sharable &amp;&amp; startTLS) {
2787                 return; // no authentication required
2788 
2789             } else {
2790                 // reauthenticating over existing connection;
2791                 // only v3 supports this
2792                 ldapVersion = LdapClient.LDAP_VERSION3;
2793             }
2794 
2795             LdapResult answer = clnt.authenticate(initial,
2796                 user, passwd, ldapVersion, authMechanism, bindCtls, envprops);
2797 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 207     private static final ControlFactory myResponseControlFactory =
 208         new DefaultResponseControlFactory();
 209     private static final Control manageReferralControl =
 210         new ManageReferralControl(false);
 211 
 212     private static final HierMemDirCtx EMPTY_SCHEMA = new HierMemDirCtx();
 213     static {
 214         EMPTY_SCHEMA.setReadOnly(
 215             new SchemaViolationException(&quot;Cannot update schema object&quot;));
 216     }
 217 
 218     // ------------ Package private instance variables ----------------
 219     // Cannot be private; used by enums
 220 
 221         // ------- Inherited by derived context instances
 222 
 223     int port_number;                    // port number of server
 224     String hostname = null;             // host name of server (no brackets
 225                                         //   for IPv6 literals)
 226     LdapClient clnt = null;             // connection handle

 227     Hashtable&lt;String, java.lang.Object&gt; envprops = null; // environment properties of context
 228     int handleReferrals = DEFAULT_REFERRAL_MODE; // how referral is handled
 229     boolean hasLdapsScheme = false;     // true if the context was created
 230                                         //  using an LDAPS URL.
 231 
 232         // ------- Not inherited by derived context instances
 233 
 234     String currentDN;                   // DN of this context
 235     Name currentParsedDN;               // DN of this context
 236     Vector&lt;Control&gt; respCtls = null;    // Response controls read
 237     Control[] reqCtls = null;           // Controls to be sent with each request
 238 
 239 
 240     // ------------- Private instance variables ------------------------
 241 
 242         // ------- Inherited by derived context instances
 243 
 244     private OutputStream trace = null;  // output stream for BER debug output
 245     private boolean netscapeSchemaBug = false;       // workaround
 246     private Control[] bindCtls = null;  // Controls to be sent with LDAP &quot;bind&quot;
</pre>
<hr />
<pre>
2650         schemaTrees = null;
2651         envprops = null;
2652 */
2653     }
2654 
2655     @SuppressWarnings(&quot;unchecked&quot;) // clone()
2656     public void reconnect(Control[] connCtls) throws NamingException {
2657         // Update environment
2658         envprops = (envprops == null
2659                 ? new Hashtable&lt;String, Object&gt;(5, 0.75f)
2660                 : (Hashtable&lt;String, Object&gt;)envprops.clone());
2661 
2662         if (connCtls == null) {
2663             envprops.remove(BIND_CONTROLS);
2664             bindCtls = null;
2665         } else {
2666             envprops.put(BIND_CONTROLS, bindCtls = cloneControls(connCtls));
2667         }
2668 
2669         sharable = false;  // can&#39;t share with existing contexts

2670         ensureOpen();      // open or reauthenticated
2671     }
2672 
2673     private void ensureOpen() throws NamingException {
2674         ensureOpen(false);
2675     }
2676 
2677     private void ensureOpen(boolean startTLS) throws NamingException {
2678 
2679         try {
2680             if (clnt == null) {
2681                 if (debug) {
2682                     System.err.println(&quot;LdapCtx: Reconnecting &quot; + this);
2683                 }
2684 
2685                 // reset the cache before a new connection is established
2686                 schemaTrees = new Hashtable&lt;&gt;(11, 0.75f);
2687                 connect(startTLS);
2688 
2689             } else if (!sharable || startTLS) {
2690 
2691                 synchronized (clnt) {
2692                     if (!clnt.isLdapv3
2693                         || clnt.referenceCount &gt; 1
<span class="line-modified">2694                         || clnt.usingSaslStreams()</span>
<span class="line-added">2695                         || !clnt.conn.useable) {</span>
2696                         closeConnection(SOFT_CLOSE);
2697                     }
2698                 }
2699                 // reset the cache before a new connection is established
2700                 schemaTrees = new Hashtable&lt;&gt;(11, 0.75f);
2701                 connect(startTLS);
2702             }
2703 
2704         } finally {
2705             sharable = true;   // connection is now either new or single-use
2706                                // OK for others to start sharing again
2707         }
2708     }
2709 
2710     private void connect(boolean startTLS) throws NamingException {
2711         if (debug) { System.err.println(&quot;LdapCtx: Connecting &quot; + this); }
2712 
2713         String user = null;             // authenticating user
2714         Object passwd = null;           // password for authenticating user
2715         String secProtocol = null;      // security protocol (e.g. &quot;ssl&quot;)
</pre>
<hr />
<pre>
2727                useSsl ? &quot;ssl&quot; : (String)envprops.get(Context.SECURITY_PROTOCOL);
2728             socketFactory = (String)envprops.get(SOCKET_FACTORY);
2729             authMechanism =
2730                 (String)envprops.get(Context.SECURITY_AUTHENTICATION);
2731 
2732             usePool = &quot;true&quot;.equalsIgnoreCase((String)envprops.get(ENABLE_POOL));
2733         }
2734 
2735         if (socketFactory == null) {
2736             socketFactory =
2737                 &quot;ssl&quot;.equals(secProtocol) ? DEFAULT_SSL_FACTORY : null;
2738         }
2739 
2740         if (authMechanism == null) {
2741             authMechanism = (user == null) ? &quot;none&quot; : &quot;simple&quot;;
2742         }
2743 
2744         try {
2745             boolean initial = (clnt == null);
2746 
<span class="line-modified">2747             if (initial) {</span>
2748                 ldapVersion = (ver != null) ? Integer.parseInt(ver) :
2749                     DEFAULT_LDAP_VERSION;
2750 
2751                 clnt = LdapClient.getInstance(
2752                     usePool, // Whether to use connection pooling
2753 
2754                     // Required for LdapClient constructor
2755                     hostname,
2756                     port_number,
2757                     socketFactory,
2758                     connectTimeout,
2759                     readTimeout,
2760                     trace,
2761 
2762                     // Required for basic client identity
2763                     ldapVersion,
2764                     authMechanism,
2765                     bindCtls,
2766                     secProtocol,
2767 
2768                     // Required for simple client identity
2769                     user,
2770                     passwd,
2771 
2772                     // Required for SASL client identity
2773                     envprops);
2774 


2775                 /**
2776                  * Pooled connections are preauthenticated;
2777                  * newly created ones are not.
2778                  */
2779                 if (clnt.authenticateCalled()) {
2780                     return;
2781                 }
2782 
2783             } else if (sharable &amp;&amp; startTLS) {
2784                 return; // no authentication required
2785 
2786             } else {
2787                 // reauthenticating over existing connection;
2788                 // only v3 supports this
2789                 ldapVersion = LdapClient.LDAP_VERSION3;
2790             }
2791 
2792             LdapResult answer = clnt.authenticate(initial,
2793                 user, passwd, ldapVersion, authMechanism, bindCtls, envprops);
2794 
</pre>
</td>
</tr>
</table>
<center><a href="DefaultLdapDnsProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LdapDnsProviderService.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
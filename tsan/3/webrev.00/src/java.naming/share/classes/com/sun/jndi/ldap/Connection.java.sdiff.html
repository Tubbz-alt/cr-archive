<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.naming/share/classes/com/sun/jndi/ldap/Connection.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BerDecoder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DefaultLdapDnsProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.naming/share/classes/com/sun/jndi/ldap/Connection.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 391         if (debug) {
 392             System.err.println(&quot;Writing request to: &quot; + outStream);
 393         }
 394 
 395         try {
 396             synchronized (this) {
 397                 outStream.write(ber.getBuf(), 0, ber.getDataLen());
 398                 outStream.flush();
 399             }
 400         } catch (IOException e) {
 401             cleanup(null, true);
 402             throw (closureReason = e); // rethrow
 403         }
 404 
 405         return req;
 406     }
 407 
 408     /**
 409      * Reads a reply; waits until one is ready.
 410      */
<span class="line-modified"> 411     BerDecoder readReply(LdapRequest ldr)</span>
<span class="line-removed"> 412             throws IOException, NamingException {</span>
 413         BerDecoder rber;
 414 
<span class="line-modified"> 415         // Track down elapsed time to workaround spurious wakeups</span>
<span class="line-modified"> 416         long elapsedMilli = 0;</span>
<span class="line-modified"> 417         long elapsedNano = 0;</span>
<span class="line-modified"> 418 </span>
<span class="line-modified"> 419         while (((rber = ldr.getReplyBer()) == null) &amp;&amp;</span>
<span class="line-removed"> 420                 (readTimeout &lt;= 0 || elapsedMilli &lt; readTimeout))</span>
<span class="line-removed"> 421         {</span>
<span class="line-removed"> 422             try {</span>
<span class="line-removed"> 423                 // If socket closed, don&#39;t even try</span>
<span class="line-removed"> 424                 synchronized (this) {</span>
<span class="line-removed"> 425                     if (sock == null) {</span>
<span class="line-removed"> 426                         throw new ServiceUnavailableException(host + &quot;:&quot; + port +</span>
<span class="line-removed"> 427                             &quot;; socket closed&quot;);</span>
<span class="line-removed"> 428                     }</span>
<span class="line-removed"> 429                 }</span>
<span class="line-removed"> 430                 synchronized (ldr) {</span>
<span class="line-removed"> 431                     // check if condition has changed since our last check</span>
<span class="line-removed"> 432                     rber = ldr.getReplyBer();</span>
<span class="line-removed"> 433                     if (rber == null) {</span>
<span class="line-removed"> 434                         if (readTimeout &gt; 0) {  // Socket read timeout is specified</span>
<span class="line-removed"> 435                             long beginNano = System.nanoTime();</span>
<span class="line-removed"> 436 </span>
<span class="line-removed"> 437                             // will be woken up before readTimeout if reply is</span>
<span class="line-removed"> 438                             // available</span>
<span class="line-removed"> 439                             ldr.wait(readTimeout - elapsedMilli);</span>
<span class="line-removed"> 440                             elapsedNano += (System.nanoTime() - beginNano);</span>
<span class="line-removed"> 441                             elapsedMilli += elapsedNano / 1000_000;</span>
<span class="line-removed"> 442                             elapsedNano %= 1000_000;</span>
<span class="line-removed"> 443 </span>
<span class="line-removed"> 444                         } else {</span>
<span class="line-removed"> 445                             // no timeout is set so we wait infinitely until</span>
<span class="line-removed"> 446                             // a response is received</span>
<span class="line-removed"> 447                             // http://docs.oracle.com/javase/8/docs/technotes/guides/jndi/jndi-ldap.html#PROP</span>
<span class="line-removed"> 448                             ldr.wait();</span>
<span class="line-removed"> 449                         }</span>
<span class="line-removed"> 450                     } else {</span>
<span class="line-removed"> 451                         break;</span>
<span class="line-removed"> 452                     }</span>
<span class="line-removed"> 453                 }</span>
<span class="line-removed"> 454             } catch (InterruptedException ex) {</span>
<span class="line-removed"> 455                 throw new InterruptedNamingException(</span>
<span class="line-removed"> 456                     &quot;Interrupted during LDAP operation&quot;);</span>
 457             }
 458         }
 459 
<span class="line-modified"> 460         if ((rber == null) &amp;&amp; (elapsedMilli &gt;= readTimeout)) {</span>










 461             abandonRequest(ldr, null);
<span class="line-modified"> 462             throw new NamingException(&quot;LDAP response read timed out, timeout used:&quot;</span>

 463                             + readTimeout + &quot;ms.&quot; );
 464 
 465         }
 466         return rber;
 467     }
 468 
<span class="line-removed"> 469 </span>
 470     ////////////////////////////////////////////////////////////////////////////
 471     //
 472     // Methods to add, find, delete, and abandon requests made to server
 473     //
 474     ////////////////////////////////////////////////////////////////////////////
 475 
 476     private synchronized void addRequest(LdapRequest ldapRequest) {
 477 
 478         LdapRequest ldr = pendingRequests;
 479         if (ldr == null) {
 480             pendingRequests = ldapRequest;
 481             ldapRequest.next = null;
 482         } else {
 483             ldapRequest.next = pendingRequests;
 484             pendingRequests = ldapRequest;
 485         }
 486     }
 487 
 488     synchronized LdapRequest findRequest(int msgId) {
 489 
</pre>
<hr />
<pre>
 643                         sock.close();
 644                         unpauseReader();
 645                     } catch (IOException ie) {
 646                         if (debug)
 647                             System.err.println(&quot;Connection: problem closing socket: &quot; + ie);
 648                     }
 649                     if (!notifyParent) {
 650                         LdapRequest ldr = pendingRequests;
 651                         while (ldr != null) {
 652                             ldr.cancel();
 653                             ldr = ldr.next;
 654                         }
 655                     }
 656                     sock = null;
 657                 }
 658                 nparent = notifyParent;
 659             }
 660             if (nparent) {
 661                 LdapRequest ldr = pendingRequests;
 662                 while (ldr != null) {
<span class="line-modified"> 663 </span>
<span class="line-removed"> 664                     synchronized (ldr) {</span>
<span class="line-removed"> 665                         ldr.notify();</span>
 666                         ldr = ldr.next;
 667                     }
 668                 }
 669             }
<span class="line-removed"> 670         }</span>
 671         if (nparent) {
 672             parent.processConnectionClosure();
 673         }
 674     }
 675 
 676 
 677     // Assume everything is &quot;quiet&quot;
 678     // &quot;synchronize&quot; might lead to deadlock so don&#39;t synchronize method
 679     // Use streamLock instead for synchronizing update to stream
 680 
 681     synchronized public void replaceStreams(InputStream newIn, OutputStream newOut) {
 682         if (debug) {
 683             System.err.println(&quot;Replacing &quot; + inStream + &quot; with: &quot; + newIn);
 684             System.err.println(&quot;Replacing &quot; + outStream + &quot; with: &quot; + newOut);
 685         }
 686 
 687         inStream = newIn;
 688 
 689         // Cleanup old stream
 690         try {
</pre>
<hr />
<pre>
 738      * plain ones and then closes the SSL socket.
 739      * If the reader thread attempts to read, or was reading, from
 740      * the SSL socket (that is, it got to the read BEFORE replaceStreams()),
 741      * the SSL socket close will cause the reader thread to
 742      * get an EOF/exception and reexamine the input stream.
 743      * If the reader thread sees a new stream, it reattempts the read.
 744      * If the underlying socket is still alive, then the new read will succeed.
 745      * If the underlying socket has been closed also, then the new read will
 746      * fail and the reader thread exits.
 747      * If the reader thread attempts to read, or was reading, from the plain
 748      * socket (that is, it got to the read AFTER replaceStreams()), the
 749      * SSL socket close will have no effect on the reader thread.
 750      *
 751      * The check for new stream is made only
 752      * in the first attempt at reading a BER buffer; the reader should
 753      * never be in midst of reading a buffer when a nonfatal close occurs.
 754      * If this occurs, then the connection is in an inconsistent state and
 755      * the safest thing to do is to shut it down.
 756      */
 757 
<span class="line-modified"> 758     private Object pauseLock = new Object();  // lock for reader to wait on while paused</span>
 759     private boolean paused = false;           // paused state of reader
 760 
 761     /*
 762      * Unpauses reader thread if it was paused
 763      */
 764     private void unpauseReader() throws IOException {
 765         synchronized (pauseLock) {
 766             if (paused) {
 767                 if (debug) {
 768                     System.err.println(&quot;Unpausing reader; read from: &quot; +
 769                                         inStream);
 770                 }
 771                 paused = false;
 772                 pauseLock.notify();
 773             }
 774         }
 775     }
 776 
 777      /*
 778      * Pauses reader so that it stops reading from the input stream.
</pre>
</td>
<td>
<hr />
<pre>
 391         if (debug) {
 392             System.err.println(&quot;Writing request to: &quot; + outStream);
 393         }
 394 
 395         try {
 396             synchronized (this) {
 397                 outStream.write(ber.getBuf(), 0, ber.getDataLen());
 398                 outStream.flush();
 399             }
 400         } catch (IOException e) {
 401             cleanup(null, true);
 402             throw (closureReason = e); // rethrow
 403         }
 404 
 405         return req;
 406     }
 407 
 408     /**
 409      * Reads a reply; waits until one is ready.
 410      */
<span class="line-modified"> 411     BerDecoder readReply(LdapRequest ldr) throws IOException, NamingException {</span>

 412         BerDecoder rber;
 413 
<span class="line-modified"> 414         // If socket closed, don&#39;t even try</span>
<span class="line-modified"> 415         synchronized (this) {</span>
<span class="line-modified"> 416             if (sock == null) {</span>
<span class="line-modified"> 417                 throw new ServiceUnavailableException(host + &quot;:&quot; + port +</span>
<span class="line-modified"> 418                     &quot;; socket closed&quot;);</span>





































 419             }
 420         }
 421 
<span class="line-modified"> 422         try {</span>
<span class="line-added"> 423             // if no timeout is set so we wait infinitely until</span>
<span class="line-added"> 424             // a response is received</span>
<span class="line-added"> 425             // http://docs.oracle.com/javase/8/docs/technotes/guides/jndi/jndi-ldap.html#PROP</span>
<span class="line-added"> 426             rber = ldr.getReplyBer(readTimeout);</span>
<span class="line-added"> 427         } catch (InterruptedException ex) {</span>
<span class="line-added"> 428             throw new InterruptedNamingException(</span>
<span class="line-added"> 429                 &quot;Interrupted during LDAP operation&quot;);</span>
<span class="line-added"> 430         }</span>
<span class="line-added"> 431 </span>
<span class="line-added"> 432         if (rber == null) {</span>
 433             abandonRequest(ldr, null);
<span class="line-modified"> 434             throw new NamingException(</span>
<span class="line-added"> 435                     &quot;LDAP response read timed out, timeout used:&quot;</span>
 436                             + readTimeout + &quot;ms.&quot; );
 437 
 438         }
 439         return rber;
 440     }
 441 

 442     ////////////////////////////////////////////////////////////////////////////
 443     //
 444     // Methods to add, find, delete, and abandon requests made to server
 445     //
 446     ////////////////////////////////////////////////////////////////////////////
 447 
 448     private synchronized void addRequest(LdapRequest ldapRequest) {
 449 
 450         LdapRequest ldr = pendingRequests;
 451         if (ldr == null) {
 452             pendingRequests = ldapRequest;
 453             ldapRequest.next = null;
 454         } else {
 455             ldapRequest.next = pendingRequests;
 456             pendingRequests = ldapRequest;
 457         }
 458     }
 459 
 460     synchronized LdapRequest findRequest(int msgId) {
 461 
</pre>
<hr />
<pre>
 615                         sock.close();
 616                         unpauseReader();
 617                     } catch (IOException ie) {
 618                         if (debug)
 619                             System.err.println(&quot;Connection: problem closing socket: &quot; + ie);
 620                     }
 621                     if (!notifyParent) {
 622                         LdapRequest ldr = pendingRequests;
 623                         while (ldr != null) {
 624                             ldr.cancel();
 625                             ldr = ldr.next;
 626                         }
 627                     }
 628                     sock = null;
 629                 }
 630                 nparent = notifyParent;
 631             }
 632             if (nparent) {
 633                 LdapRequest ldr = pendingRequests;
 634                 while (ldr != null) {
<span class="line-modified"> 635                     ldr.close();</span>


 636                         ldr = ldr.next;
 637                     }
 638                 }
 639             }

 640         if (nparent) {
 641             parent.processConnectionClosure();
 642         }
 643     }
 644 
 645 
 646     // Assume everything is &quot;quiet&quot;
 647     // &quot;synchronize&quot; might lead to deadlock so don&#39;t synchronize method
 648     // Use streamLock instead for synchronizing update to stream
 649 
 650     synchronized public void replaceStreams(InputStream newIn, OutputStream newOut) {
 651         if (debug) {
 652             System.err.println(&quot;Replacing &quot; + inStream + &quot; with: &quot; + newIn);
 653             System.err.println(&quot;Replacing &quot; + outStream + &quot; with: &quot; + newOut);
 654         }
 655 
 656         inStream = newIn;
 657 
 658         // Cleanup old stream
 659         try {
</pre>
<hr />
<pre>
 707      * plain ones and then closes the SSL socket.
 708      * If the reader thread attempts to read, or was reading, from
 709      * the SSL socket (that is, it got to the read BEFORE replaceStreams()),
 710      * the SSL socket close will cause the reader thread to
 711      * get an EOF/exception and reexamine the input stream.
 712      * If the reader thread sees a new stream, it reattempts the read.
 713      * If the underlying socket is still alive, then the new read will succeed.
 714      * If the underlying socket has been closed also, then the new read will
 715      * fail and the reader thread exits.
 716      * If the reader thread attempts to read, or was reading, from the plain
 717      * socket (that is, it got to the read AFTER replaceStreams()), the
 718      * SSL socket close will have no effect on the reader thread.
 719      *
 720      * The check for new stream is made only
 721      * in the first attempt at reading a BER buffer; the reader should
 722      * never be in midst of reading a buffer when a nonfatal close occurs.
 723      * If this occurs, then the connection is in an inconsistent state and
 724      * the safest thing to do is to shut it down.
 725      */
 726 
<span class="line-modified"> 727     private final Object pauseLock = new Object();  // lock for reader to wait on while paused</span>
 728     private boolean paused = false;           // paused state of reader
 729 
 730     /*
 731      * Unpauses reader thread if it was paused
 732      */
 733     private void unpauseReader() throws IOException {
 734         synchronized (pauseLock) {
 735             if (paused) {
 736                 if (debug) {
 737                     System.err.println(&quot;Unpausing reader; read from: &quot; +
 738                                         inStream);
 739                 }
 740                 paused = false;
 741                 pauseLock.notify();
 742             }
 743         }
 744     }
 745 
 746      /*
 747      * Pauses reader so that it stops reading from the input stream.
</pre>
</td>
</tr>
</table>
<center><a href="BerDecoder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DefaultLdapDnsProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
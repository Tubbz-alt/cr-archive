diff a/src/java.naming/share/classes/com/sun/jndi/ldap/LdapDnsProviderService.java b/src/java.naming/share/classes/com/sun/jndi/ldap/LdapDnsProviderService.java
--- a/src/java.naming/share/classes/com/sun/jndi/ldap/LdapDnsProviderService.java
+++ b/src/java.naming/share/classes/com/sun/jndi/ldap/LdapDnsProviderService.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -35,10 +35,12 @@
 
 /**
  * The {@code LdapDnsProviderService} is responsible for creating and providing
  * access to the registered {@code LdapDnsProvider}s. The {@link ServiceLoader}
  * is used to find and register any implementations of {@link LdapDnsProvider}.
+ *
+ * <p> Instances of this class are safe for use by multiple threads.
  */
 final class LdapDnsProviderService {
 
     private static volatile LdapDnsProviderService service;
     private static final Object LOCK = new int[0];
@@ -66,41 +68,42 @@
                 SecurityConstants.GET_CLASSLOADER_PERMISSION);
         }
     }
 
     /**
-     * Retrieve the singleton static instance of LdapDnsProviderService.
+     * Retrieves the singleton instance of LdapDnsProviderService.
      */
     static LdapDnsProviderService getInstance() {
         if (service != null) return service;
-        synchronized(LOCK) {
+        synchronized (LOCK) {
             if (service != null) return service;
             service = new LdapDnsProviderService();
         }
         return service;
     }
 
     /**
-     * Retrieve result from the first provider that successfully resolves
+     * Retrieves result from the first provider that successfully resolves
      * the endpoints. If no results are found when calling installed
      * subclasses of {@code LdapDnsProvider} then this method will fall back
      * to the {@code DefaultLdapDnsProvider}.
      *
      * @throws NamingException if the {@code url} in not valid or an error
      *                         occurred while performing the lookup.
      */
     LdapDnsProviderResult lookupEndpoints(String url, Hashtable<?,?> env)
         throws NamingException
     {
-        Iterator<LdapDnsProvider> iterator = providers.iterator();
-        Hashtable<?, ?> envCopy = new Hashtable<>(env);
         LdapDnsProviderResult result = null;
-
-        while (result == null && iterator.hasNext()) {
-            result = iterator.next().lookupEndpoints(url, envCopy)
-                    .filter(r -> r.getEndpoints().size() > 0)
-                    .orElse(null);
+        Hashtable<?, ?> envCopy = new Hashtable<>(env);
+        synchronized (LOCK) {
+            Iterator<LdapDnsProvider> iterator = providers.iterator();
+            while (result == null && iterator.hasNext()) {
+                result = iterator.next().lookupEndpoints(url, envCopy)
+                        .filter(r -> !r.getEndpoints().isEmpty())
+                        .orElse(null);
+            }
         }
 
         if (result == null) {
             return new DefaultLdapDnsProvider().lookupEndpoints(url, env)
                 .orElse(new LdapDnsProviderResult("", List.of()));

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.naming/share/classes/sun/security/provider/certpath/ldap/LDAPCertStoreImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../javax/naming/spi/package.html.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../java.net.http/share/classes/java/net/http/HttpResponse.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.naming/share/classes/sun/security/provider/certpath/ldap/LDAPCertStoreImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 45 import javax.naming.ldap.InitialLdapContext;
 46 import javax.naming.ldap.LdapContext;
 47 import javax.security.auth.x500.X500Principal;
 48 
 49 import com.sun.jndi.ldap.LdapReferralException;
 50 import sun.security.util.HexDumpEncoder;
 51 import sun.security.provider.certpath.X509CertificatePair;
 52 import sun.security.util.Cache;
 53 import sun.security.util.Debug;
 54 
 55 /**
 56  * Core implementation of a LDAP Cert Store.
 57  * @see java.security.cert.CertStore
 58  *
 59  * @since       9
 60  */
 61 final class LDAPCertStoreImpl {
 62 
 63     private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);
 64 
<span class="line-removed"> 65     private final static boolean DEBUG = false;</span>
<span class="line-removed"> 66 </span>
 67     /**
 68      * LDAP attribute identifiers.
 69      */
 70     private static final String USER_CERT = &quot;userCertificate;binary&quot;;
 71     private static final String CA_CERT = &quot;cACertificate;binary&quot;;
 72     private static final String CROSS_CERT = &quot;crossCertificatePair;binary&quot;;
 73     private static final String CRL = &quot;certificateRevocationList;binary&quot;;
 74     private static final String ARL = &quot;authorityRevocationList;binary&quot;;
<span class="line-removed"> 75     private static final String DELTA_CRL = &quot;deltaRevocationList;binary&quot;;</span>
 76 
 77     // Constants for various empty values
 78     private final static String[] STRING0 = new String[0];
 79 
 80     private final static byte[][] BB0 = new byte[0][];
 81 
 82     private final static Attributes EMPTY_ATTRIBUTES = new BasicAttributes();
 83 
 84     // cache related constants
 85     private final static int DEFAULT_CACHE_SIZE = 750;
 86     private final static int DEFAULT_CACHE_LIFETIME = 30;
 87 
 88     private final static int LIFETIME;
 89 
 90     private final static String PROP_LIFETIME =
 91                             &quot;sun.security.certpath.ldap.cache.lifetime&quot;;
 92 
 93     /*
 94      * Internal system property, that when set to &quot;true&quot;, disables the
 95      * JNDI application resource files lookup to prevent recursion issues
 96      * when validating signed JARs with LDAP URLs in certificates.
 97      */
 98     private final static String PROP_DISABLE_APP_RESOURCE_FILES =
 99         &quot;sun.security.certpath.ldap.disable.app.resource.files&quot;;
100 
101     static {
102         String s = AccessController.doPrivileged(
103             (PrivilegedAction&lt;String&gt;) () -&gt; System.getProperty(PROP_LIFETIME));
104         if (s != null) {
105             LIFETIME = Integer.parseInt(s); // throws NumberFormatException
106         } else {
107             LIFETIME = DEFAULT_CACHE_LIFETIME;
108         }
109     }
110 
111     /**
112      * The CertificateFactory used to decode certificates from
113      * their binary stored form.
114      */
115     private CertificateFactory cf;

116     /**
117      * The JNDI directory context.
118      */
119     private LdapContext ctx;
120 
121     /**
122      * Flag indicating that communication error occurred.
123      */
124     private boolean communicationError = false;
125 
126     /**
127      * Flag indicating whether we should prefetch CRLs.
128      */
129     private boolean prefetchCRLs = false;
130 
131     private final Cache&lt;String, byte[][]&gt; valueCache;
132 
133     private int cacheHits = 0;
134     private int cacheMisses = 0;
135     private int requests = 0;
</pre>
<hr />
<pre>
224 
225         LDAPRequest(String name) throws CertStoreException {
226             this.name = checkName(name);
227             requestedAttributes = new ArrayList&lt;&gt;(5);
228         }
229 
230         private String checkName(String name) throws CertStoreException {
231             if (name == null) {
232                 throw new CertStoreException(&quot;Name absent&quot;);
233             }
234             try {
235                 if (new CompositeName(name).size() &gt; 1) {
236                     throw new CertStoreException(&quot;Invalid name: &quot; + name);
237                 }
238             } catch (InvalidNameException ine) {
239                 throw new CertStoreException(&quot;Invalid name: &quot; + name, ine);
240             }
241             return name;
242         }
243 
<span class="line-removed">244         String getName() {</span>
<span class="line-removed">245             return name;</span>
<span class="line-removed">246         }</span>
<span class="line-removed">247 </span>
248         void addRequestedAttribute(String attrId) {
249             if (valueMap != null) {
250                 throw new IllegalStateException(&quot;Request already sent&quot;);
251             }
252             requestedAttributes.add(attrId);
253         }
254 
255         /**
256          * Gets one or more binary values from an attribute.
257          *
258          * @param attrId                the attribute identifier
259          * @return                      an array of binary values (byte arrays)
260          * @throws NamingException      if a naming exception occurs
261          */
262         byte[][] getValues(String attrId) throws NamingException {
<span class="line-modified">263             if (DEBUG &amp;&amp; ((cacheHits + cacheMisses) % 50 == 0)) {</span>
<span class="line-modified">264                 System.out.println(&quot;Cache hits: &quot; + cacheHits + &quot;; misses: &quot;</span>
<span class="line-modified">265                         + cacheMisses);</span>
266             }
267             String cacheKey = name + &quot;|&quot; + attrId;
268             byte[][] values = valueCache.get(cacheKey);
269             if (values != null) {
270                 cacheHits++;
271                 return values;
272             }
273             cacheMisses++;
274             Map&lt;String, byte[][]&gt; attrs = getValueMap();
275             values = attrs.get(attrId);
276             return values;
277         }
278 
279         /**
280          * Get a map containing the values for this request. The first time
281          * this method is called on an object, the LDAP request is sent,
282          * the results parsed and added to a private map and also to the
283          * cache of this LDAPCertStore. Subsequent calls return the private
284          * map immediately.
285          *
286          * The map contains an entry for each requested attribute. The
287          * attribute name is the key, values are byte[][]. If there are no
288          * values for that attribute, values are byte[0][].
289          *
290          * @return                      the value Map
291          * @throws NamingException      if a naming exception occurs
292          */
293         private Map&lt;String, byte[][]&gt; getValueMap() throws NamingException {
294             if (valueMap != null) {
295                 return valueMap;
296             }
<span class="line-modified">297             if (DEBUG) {</span>
<span class="line-modified">298                 System.out.println(&quot;Request: &quot; + name + &quot;:&quot; + requestedAttributes);</span>
299                 requests++;
300                 if (requests % 5 == 0) {
<span class="line-modified">301                     System.out.println(&quot;LDAP requests: &quot; + requests);</span>
302                 }
303             }
304             valueMap = new HashMap&lt;&gt;(8);
305             String[] attrIds = requestedAttributes.toArray(STRING0);
306             Attributes attrs;
307 
308             if (communicationError) {
309                 ctx.reconnect(null);
310                 communicationError = false;
311             }
312 
313             try {
314                 attrs = ctx.getAttributes(name, attrIds);
315             } catch (LdapReferralException lre) {
316                 // LdapCtx has a hopCount field to avoid infinite loop
317                 while (true) {
318                     try {
319                         String newName = (String) lre.getReferralInfo();
320                         URI newUri = new URI(newName);
321                         if (!newUri.getScheme().equalsIgnoreCase(&quot;ldap&quot;)) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 45 import javax.naming.ldap.InitialLdapContext;
 46 import javax.naming.ldap.LdapContext;
 47 import javax.security.auth.x500.X500Principal;
 48 
 49 import com.sun.jndi.ldap.LdapReferralException;
 50 import sun.security.util.HexDumpEncoder;
 51 import sun.security.provider.certpath.X509CertificatePair;
 52 import sun.security.util.Cache;
 53 import sun.security.util.Debug;
 54 
 55 /**
 56  * Core implementation of a LDAP Cert Store.
 57  * @see java.security.cert.CertStore
 58  *
 59  * @since       9
 60  */
 61 final class LDAPCertStoreImpl {
 62 
 63     private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);
 64 


 65     /**
 66      * LDAP attribute identifiers.
 67      */
 68     private static final String USER_CERT = &quot;userCertificate;binary&quot;;
 69     private static final String CA_CERT = &quot;cACertificate;binary&quot;;
 70     private static final String CROSS_CERT = &quot;crossCertificatePair;binary&quot;;
 71     private static final String CRL = &quot;certificateRevocationList;binary&quot;;
 72     private static final String ARL = &quot;authorityRevocationList;binary&quot;;

 73 
 74     // Constants for various empty values
 75     private final static String[] STRING0 = new String[0];
 76 
 77     private final static byte[][] BB0 = new byte[0][];
 78 
 79     private final static Attributes EMPTY_ATTRIBUTES = new BasicAttributes();
 80 
 81     // cache related constants
 82     private final static int DEFAULT_CACHE_SIZE = 750;
 83     private final static int DEFAULT_CACHE_LIFETIME = 30;
 84 
 85     private final static int LIFETIME;
 86 
 87     private final static String PROP_LIFETIME =
 88                             &quot;sun.security.certpath.ldap.cache.lifetime&quot;;
 89 
 90     /*
 91      * Internal system property, that when set to &quot;true&quot;, disables the
 92      * JNDI application resource files lookup to prevent recursion issues
 93      * when validating signed JARs with LDAP URLs in certificates.
 94      */
 95     private final static String PROP_DISABLE_APP_RESOURCE_FILES =
 96         &quot;sun.security.certpath.ldap.disable.app.resource.files&quot;;
 97 
 98     static {
 99         String s = AccessController.doPrivileged(
100             (PrivilegedAction&lt;String&gt;) () -&gt; System.getProperty(PROP_LIFETIME));
101         if (s != null) {
102             LIFETIME = Integer.parseInt(s); // throws NumberFormatException
103         } else {
104             LIFETIME = DEFAULT_CACHE_LIFETIME;
105         }
106     }
107 
108     /**
109      * The CertificateFactory used to decode certificates from
110      * their binary stored form.
111      */
112     private CertificateFactory cf;
<span class="line-added">113 </span>
114     /**
115      * The JNDI directory context.
116      */
117     private LdapContext ctx;
118 
119     /**
120      * Flag indicating that communication error occurred.
121      */
122     private boolean communicationError = false;
123 
124     /**
125      * Flag indicating whether we should prefetch CRLs.
126      */
127     private boolean prefetchCRLs = false;
128 
129     private final Cache&lt;String, byte[][]&gt; valueCache;
130 
131     private int cacheHits = 0;
132     private int cacheMisses = 0;
133     private int requests = 0;
</pre>
<hr />
<pre>
222 
223         LDAPRequest(String name) throws CertStoreException {
224             this.name = checkName(name);
225             requestedAttributes = new ArrayList&lt;&gt;(5);
226         }
227 
228         private String checkName(String name) throws CertStoreException {
229             if (name == null) {
230                 throw new CertStoreException(&quot;Name absent&quot;);
231             }
232             try {
233                 if (new CompositeName(name).size() &gt; 1) {
234                     throw new CertStoreException(&quot;Invalid name: &quot; + name);
235                 }
236             } catch (InvalidNameException ine) {
237                 throw new CertStoreException(&quot;Invalid name: &quot; + name, ine);
238             }
239             return name;
240         }
241 




242         void addRequestedAttribute(String attrId) {
243             if (valueMap != null) {
244                 throw new IllegalStateException(&quot;Request already sent&quot;);
245             }
246             requestedAttributes.add(attrId);
247         }
248 
249         /**
250          * Gets one or more binary values from an attribute.
251          *
252          * @param attrId                the attribute identifier
253          * @return                      an array of binary values (byte arrays)
254          * @throws NamingException      if a naming exception occurs
255          */
256         byte[][] getValues(String attrId) throws NamingException {
<span class="line-modified">257             if (debug != null &amp;&amp; Debug.isVerbose() &amp;&amp; ((cacheHits + cacheMisses) % 50 == 0)) {</span>
<span class="line-modified">258                 debug.println(&quot;LDAPRequest Cache hits: &quot; + cacheHits +</span>
<span class="line-modified">259                     &quot;; misses: &quot; + cacheMisses);</span>
260             }
261             String cacheKey = name + &quot;|&quot; + attrId;
262             byte[][] values = valueCache.get(cacheKey);
263             if (values != null) {
264                 cacheHits++;
265                 return values;
266             }
267             cacheMisses++;
268             Map&lt;String, byte[][]&gt; attrs = getValueMap();
269             values = attrs.get(attrId);
270             return values;
271         }
272 
273         /**
274          * Get a map containing the values for this request. The first time
275          * this method is called on an object, the LDAP request is sent,
276          * the results parsed and added to a private map and also to the
277          * cache of this LDAPCertStore. Subsequent calls return the private
278          * map immediately.
279          *
280          * The map contains an entry for each requested attribute. The
281          * attribute name is the key, values are byte[][]. If there are no
282          * values for that attribute, values are byte[0][].
283          *
284          * @return                      the value Map
285          * @throws NamingException      if a naming exception occurs
286          */
287         private Map&lt;String, byte[][]&gt; getValueMap() throws NamingException {
288             if (valueMap != null) {
289                 return valueMap;
290             }
<span class="line-modified">291             if (debug != null &amp;&amp; Debug.isVerbose()) {</span>
<span class="line-modified">292                 debug.println(&quot;LDAPRequest: &quot; + name + &quot;:&quot; + requestedAttributes);</span>
293                 requests++;
294                 if (requests % 5 == 0) {
<span class="line-modified">295                     debug.println(&quot;LDAP requests: &quot; + requests);</span>
296                 }
297             }
298             valueMap = new HashMap&lt;&gt;(8);
299             String[] attrIds = requestedAttributes.toArray(STRING0);
300             Attributes attrs;
301 
302             if (communicationError) {
303                 ctx.reconnect(null);
304                 communicationError = false;
305             }
306 
307             try {
308                 attrs = ctx.getAttributes(name, attrIds);
309             } catch (LdapReferralException lre) {
310                 // LdapCtx has a hopCount field to avoid infinite loop
311                 while (true) {
312                     try {
313                         String newName = (String) lre.getReferralInfo();
314                         URI newUri = new URI(newName);
315                         if (!newUri.getScheme().equalsIgnoreCase(&quot;ldap&quot;)) {
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../javax/naming/spi/package.html.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../java.net.http/share/classes/java/net/http/HttpResponse.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.naming/share/classes/javax/naming/NamingException.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.naming;
 27 
 28 /**
 29   * This is the superclass of all exceptions thrown by
 30   * operations in the Context and DirContext interfaces.
 31   * The nature of the failure is described by the name of the subclass.
 32   * This exception captures the information pinpointing where the operation
 33   * failed, such as where resolution last proceeded to.
 34   * &lt;ul&gt;
 35   * &lt;li&gt; Resolved Name. Portion of name that has been resolved.
 36   * &lt;li&gt; Resolved Object. Object to which resolution of name proceeded.
 37   * &lt;li&gt; Remaining Name. Portion of name that has not been resolved.
 38   * &lt;li&gt; Explanation. Detail explaining why name resolution failed.
 39   * &lt;li&gt; Root Exception. The exception that caused this naming exception
 40   *                     to be thrown.
 41   *&lt;/ul&gt;
 42   * null is an acceptable value for any of these fields. When null,
 43   * it means that no such information has been recorded for that field.
 44   *&lt;p&gt;
 45   * A NamingException instance is not synchronized against concurrent
 46   * multithreaded access. Multiple threads trying to access and modify
 47   * a single NamingException instance should lock the object.
 48   *&lt;p&gt;
 49   * This exception has been retrofitted to conform to
 50   * the general purpose exception-chaining mechanism.  The
 51   * &lt;i&gt;root exception&lt;/i&gt; (or &lt;i&gt;root cause&lt;/i&gt;) is the same object as the
 52   * &lt;i&gt;cause&lt;/i&gt; returned by the {@link Throwable#getCause()} method.
 53   *
 54   * @author Rosanna Lee
 55   * @author Scott Seligman
 56   * @since 1.3
 57   */
 58 
 59 
 60 public class NamingException extends Exception {
 61     /**
 62      * Contains the part of the name that has been successfully resolved.
 63      * It is a composite name and can be null.
 64      * This field is initialized by the constructors.
 65      * You should access and manipulate this field
 66      * through its get and set methods.
 67      * @serial
 68      * @see #getResolvedName
 69      * @see #setResolvedName
 70      */
 71     protected Name resolvedName;
 72     /**
 73       * Contains the object to which resolution of the part of the name was
 74       * successful. Can be null.
 75       * This field is initialized by the constructors.
 76       * You should access and manipulate this field
 77       * through its get and set methods.
 78       * @serial
 79       * @see #getResolvedObj
 80       * @see #setResolvedObj
 81       */
 82     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
 83     protected Object resolvedObj;
 84     /**
 85      * Contains the remaining name that has not been resolved yet.
 86      * It is a composite name and can be null.
 87      * This field is initialized by the constructors.
 88      * You should access and manipulate this field
 89      * through its get, set, &quot;append&quot; methods.
 90      * @serial
 91      * @see #getRemainingName
 92      * @see #setRemainingName
 93      * @see #appendRemainingName
 94      * @see #appendRemainingComponent
 95      */
 96     protected Name remainingName;
 97 
 98     /**
 99      * Contains the original exception that caused this NamingException to
100      * be thrown. This field is set if there is additional
101      * information that could be obtained from the original
102      * exception, or if the original exception could not be
103      * mapped to a subclass of NamingException.
104      * Can be null.
105      *&lt;p&gt;
106      * This field predates the general-purpose exception chaining facility.
107      * The {@link #initCause(Throwable)} and {@link #getCause()} methods
108      * are now the preferred means of accessing this information.
109      *
110      * @serial
111      * @see #getRootCause
112      * @see #setRootCause(Throwable)
113      * @see #initCause(Throwable)
114      * @see #getCause
115      */
116     protected Throwable rootException = null;
117 
118     /**
119      * Constructs a new NamingException with an explanation.
120      * All unspecified fields are set to null.
121      *
122      * @param   explanation     A possibly null string containing
123      *                          additional detail about this exception.
124      * @see java.lang.Throwable#getMessage
125      */
126     public NamingException(String explanation) {
127         super(explanation);
128         resolvedName = remainingName = null;
129         resolvedObj = null;
130     }
131 
132     /**
133       * Constructs a new NamingException.
134       * All fields are set to null.
135       */
136     public NamingException() {
137         super();
138         resolvedName = remainingName = null;
139         resolvedObj = null;
140     }
141 
142     /**
143      * Retrieves the leading portion of the name that was resolved
144      * successfully.
145      *
146      * @return The part of the name that was resolved successfully.
147      *          It is a composite name. It can be null, which means
148      *          the resolved name field has not been set.
149      * @see #getResolvedObj
150      * @see #setResolvedName
151      */
152     public Name getResolvedName() {
153         return resolvedName;
154     }
155 
156     /**
157      * Retrieves the remaining unresolved portion of the name.
158      * @return The part of the name that has not been resolved.
159      *          It is a composite name. It can be null, which means
160      *          the remaining name field has not been set.
161      * @see #setRemainingName
162      * @see #appendRemainingName
163      * @see #appendRemainingComponent
164      */
165     public Name getRemainingName() {
166         return remainingName;
167     }
168 
169     /**
170      * Retrieves the object to which resolution was successful.
171      * This is the object to which the resolved name is bound.
172      *
173      * @return The possibly null object that was resolved so far.
174      *  null means that the resolved object field has not been set.
175      * @see #getResolvedName
176      * @see #setResolvedObj
177      */
178     public Object getResolvedObj() {
179         return resolvedObj;
180     }
181 
182     /**
183       * Retrieves the explanation associated with this exception.
184       *
185       * @return The possibly null detail string explaining more
186       *         about this exception. If null, it means there is no
187       *         detail message for this exception.
188       *
189       * @see java.lang.Throwable#getMessage
190       */
191     public String getExplanation() {
192         return getMessage();
193     }
194 
195     /**
196      * Sets the resolved name field of this exception.
197      *&lt;p&gt;
198      * {@code name} is a composite name. If the intent is to set
199      * this field using a compound name or string, you must
200      * &quot;stringify&quot; the compound name, and create a composite
201      * name with a single component using the string. You can then
202      * invoke this method using the resulting composite name.
203      *&lt;p&gt;
204      * A copy of {@code name} is made and stored.
205      * Subsequent changes to {@code name} do not
206      * affect the copy in this NamingException and vice versa.
207      *
208      * @param name The possibly null name to set resolved name to.
209      *          If null, it sets the resolved name field to null.
210      * @see #getResolvedName
211      */
212     public void setResolvedName(Name name) {
213         if (name != null)
214             resolvedName = (Name)(name.clone());
215         else
216             resolvedName = null;
217     }
218 
219     /**
220      * Sets the remaining name field of this exception.
221      *&lt;p&gt;
222      * {@code name} is a composite name. If the intent is to set
223      * this field using a compound name or string, you must
224      * &quot;stringify&quot; the compound name, and create a composite
225      * name with a single component using the string. You can then
226      * invoke this method using the resulting composite name.
227      *&lt;p&gt;
228      * A copy of {@code name} is made and stored.
229      * Subsequent changes to {@code name} do not
230      * affect the copy in this NamingException and vice versa.
231      * @param name The possibly null name to set remaining name to.
232      *          If null, it sets the remaining name field to null.
233      * @see #getRemainingName
234      * @see #appendRemainingName
235      * @see #appendRemainingComponent
236      */
237     public void setRemainingName(Name name) {
238         if (name != null)
239             remainingName = (Name)(name.clone());
240         else
241             remainingName = null;
242     }
243 
244     /**
245      * Sets the resolved object field of this exception.
246      * @param obj The possibly null object to set resolved object to.
247      *            If null, the resolved object field is set to null.
248      * @see #getResolvedObj
249      */
250     public void setResolvedObj(Object obj) {
251         resolvedObj = obj;
252     }
253 
254     /**
255       * Add name as the last component in remaining name.
256       * @param name The component to add.
257       *         If name is null, this method does not do anything.
258       * @see #setRemainingName
259       * @see #getRemainingName
260       * @see #appendRemainingName
261       */
262     public void appendRemainingComponent(String name) {
263         if (name != null) {
264             try {
265                 if (remainingName == null) {
266                     remainingName = new CompositeName();
267                 }
268                 remainingName.add(name);
269             } catch (NamingException e) {
270                 throw new IllegalArgumentException(e.toString());
271             }
272         }
273     }
274 
275     /**
276       * Add components from &#39;name&#39; as the last components in
277       * remaining name.
278       *&lt;p&gt;
279       * {@code name} is a composite name. If the intent is to append
280       * a compound name, you should &quot;stringify&quot; the compound name
281       * then invoke the overloaded form that accepts a String parameter.
282       *&lt;p&gt;
283       * Subsequent changes to {@code name} do not
284       * affect the remaining name field in this NamingException and vice versa.
285       * @param name The possibly null name containing ordered components to add.
286       *                 If name is null, this method does not do anything.
287       * @see #setRemainingName
288       * @see #getRemainingName
289       * @see #appendRemainingComponent
290       */
291     public void appendRemainingName(Name name) {
292         if (name == null) {
293             return;
294         }
295         if (remainingName != null) {
296             try {
297                 remainingName.addAll(name);
298             } catch (NamingException e) {
299                 throw new IllegalArgumentException(e.toString());
300             }
301         } else {
302             remainingName = (Name)(name.clone());
303         }
304     }
305 
306     /**
307       * Retrieves the root cause of this NamingException, if any.
308       * The root cause of a naming exception is used when the service provider
309       * wants to indicate to the caller a non-naming related exception
310       * but at the same time wants to use the NamingException structure
311       * to indicate how far the naming operation proceeded.
312       *&lt;p&gt;
313       * This method predates the general-purpose exception chaining facility.
314       * The {@link #getCause()} method is now the preferred means of obtaining
315       * this information.
316       *
317       * @return The possibly null exception that caused this naming
318       *    exception. If null, it means no root cause has been
319       *    set for this naming exception.
320       * @see #setRootCause
321       * @see #rootException
322       * @see #getCause
323       */
324     public Throwable getRootCause() {
325         return rootException;
326     }
327 
328     /**
329       * Records the root cause of this NamingException.
330       * If {@code e} is {@code this}, this method does not do anything.
331       *&lt;p&gt;
332       * This method predates the general-purpose exception chaining facility.
333       * The {@link #initCause(Throwable)} method is now the preferred means
334       * of recording this information.
335       *
336       * @param e The possibly null exception that caused the naming
337       *          operation to fail. If null, it means this naming
338       *          exception has no root cause.
339       * @see #getRootCause
340       * @see #rootException
341       * @see #initCause
342       */
343     public void setRootCause(Throwable e) {
344         if (e != this) {
345             rootException = e;
346         }
347     }
348 
349     /**
350       * Returns the cause of this exception.  The cause is the
351       * throwable that caused this naming exception to be thrown.
352       * Returns {@code null} if the cause is nonexistent or
353       * unknown.
354       *
355       * @return  the cause of this exception, or {@code null} if the
356       *          cause is nonexistent or unknown.
357       * @see #initCause(Throwable)
358       * @since 1.4
359       */
360     public Throwable getCause() {
361         return getRootCause();
362     }
363 
364     /**
365       * Initializes the cause of this exception to the specified value.
366       * The cause is the throwable that caused this naming exception to be
367       * thrown.
368       *&lt;p&gt;
369       * This method may be called at most once.
370       *
371       * @param  cause   the cause, which is saved for later retrieval by
372       *         the {@link #getCause()} method.  A {@code null} value
373       *         indicates that the cause is nonexistent or unknown.
374       * @return a reference to this {@code NamingException} instance.
375       * @throws IllegalArgumentException if {@code cause} is this
376       *         exception.  (A throwable cannot be its own cause.)
377       * @throws IllegalStateException if this method has already
378       *         been called on this exception.
379       * @see #getCause
380       * @since 1.4
381       */
382     public Throwable initCause(Throwable cause) {
383         super.initCause(cause);
384         setRootCause(cause);
385         return this;
386     }
387 
388     /**
389      * Generates the string representation of this exception.
390      * The string representation consists of this exception&#39;s class name,
391      * its detailed message, and if it has a root cause, the string
392      * representation of the root cause exception, followed by
393      * the remaining name (if it is not null).
394      * This string is used for debugging and not meant to be interpreted
395      * programmatically.
396      *
397      * @return The non-null string containing the string representation
398      * of this exception.
399      */
400     public String toString() {
401         String answer = super.toString();
402 
403         if (rootException != null) {
404             answer += &quot; [Root exception is &quot; + rootException + &quot;]&quot;;
405         }
406         if (remainingName != null) {
407             answer += &quot;; remaining name &#39;&quot; + remainingName + &quot;&#39;&quot;;
408         }
409         return answer;
410     }
411 
412     /**
413       * Generates the string representation in more detail.
414       * This string representation consists of the information returned
415       * by the toString() that takes no parameters, plus the string
416       * representation of the resolved object (if it is not null).
417       * This string is used for debugging and not meant to be interpreted
418       * programmatically.
419       *
420       * @param detail If true, include details about the resolved object
421       *                 in addition to the other information.
422       * @return The non-null string containing the string representation.
423       */
424     public String toString(boolean detail) {
425         if (!detail || resolvedObj == null) {
426             return toString();
427         } else {
428             return (toString() + &quot;; resolved object &quot; + resolvedObj);
429         }
430     }
431 
432     /**
433      * Use serialVersionUID from JNDI 1.1.1 for interoperability
434      */
435     private static final long serialVersionUID = -1299181962103167177L;
436 };
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.naming/share/classes/javax/naming/spi/NamingManager.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../package.html.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ResolveResult.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.naming/share/classes/javax/naming/spi/NamingManager.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.naming.spi;
 27 
 28 import java.net.MalformedURLException;


 29 import java.util.*;
 30 
<span class="line-removed"> 31 </span>
 32 import javax.naming.*;
 33 import com.sun.naming.internal.VersionHelper;
 34 import com.sun.naming.internal.ResourceManager;
 35 import com.sun.naming.internal.FactoryEnumeration;

 36 
 37 /**
 38  * This class contains methods for creating context objects
 39  * and objects referred to by location information in the naming
 40  * or directory service.
 41  *&lt;p&gt;
 42  * This class cannot be instantiated.  It has only static methods.
 43  *&lt;p&gt;
 44  * The mention of URL in the documentation for this class refers to
 45  * a URL string as defined by RFC 1738 and its related RFCs. It is
 46  * any string that conforms to the syntax described therein, and
 47  * may not always have corresponding support in the java.net.URL
 48  * class or Web browsers.
 49  *&lt;p&gt;
 50  * NamingManager is safe for concurrent access by multiple threads.
 51  *&lt;p&gt;
 52  * Except as otherwise noted,
 53  * a {@code Name} or environment parameter
 54  * passed to any method is owned by the caller.
 55  * The implementation will not modify the object or keep a reference
</pre>
<hr />
<pre>
 62 
 63 public class NamingManager {
 64 
 65     /*
 66      * Disallow anyone from creating one of these.
 67      * Made package private so that DirectoryManager can subclass.
 68      */
 69 
 70     NamingManager() {}
 71 
 72     // should be protected and package private
 73     static final VersionHelper helper = VersionHelper.getVersionHelper();
 74 
 75 // --------- object factory stuff
 76 
 77     /**
 78      * Package-private; used by DirectoryManager and NamingManager.
 79      */
 80     private static ObjectFactoryBuilder object_factory_builder = null;
 81 



 82     /**
 83      * The ObjectFactoryBuilder determines the policy used when
 84      * trying to load object factories.
 85      * See getObjectInstance() and class ObjectFactory for a description
 86      * of the default policy.
 87      * setObjectFactoryBuilder() overrides this default policy by installing
 88      * an ObjectFactoryBuilder. Subsequent object factories will
 89      * be loaded and created using the installed builder.
 90      *&lt;p&gt;
 91      * The builder can only be installed if the executing thread is allowed
 92      * (by the security manager&#39;s checkSetFactory() method) to do so.
 93      * Once installed, the builder cannot be replaced.
 94      *
 95      * @param builder The factory builder to install. If null, no builder
 96      *                  is installed.
 97      * @exception SecurityException builder cannot be installed
 98      *          for security reasons.
 99      * @exception NamingException builder cannot be installed for
100      *         a non-security-related reason.
101      * @exception IllegalStateException If a factory has already been installed.
</pre>
<hr />
<pre>
655      *         be in a package which is exported by that module to the
656      *         {@code java.naming} module.)&lt;/li&gt;
657      *     &lt;/ul&gt;
658      * &lt;/li&gt;
659      * &lt;/ul&gt;
660      * @param env The possibly null environment properties used when
661      *                  creating the context.
662      * @return A non-null initial context.
663      * @exception NoInitialContextException If the
664      *          {@code Context.INITIAL_CONTEXT_FACTORY} property
665      *         is not found or names a nonexistent
666      *         class or a class that cannot be instantiated,
667      *          or if the initial context could not be created for some other
668      *          reason.
669      * @exception NamingException If some other naming exception was encountered.
670      * @see javax.naming.InitialContext
671      * @see javax.naming.directory.InitialDirContext
672      */
673     public static Context getInitialContext(Hashtable&lt;?,?&gt; env)
674         throws NamingException {

675         InitialContextFactory factory = null;
676 
677         InitialContextFactoryBuilder builder = getInitialContextFactoryBuilder();
678         if (builder == null) {
679             // No builder installed, use property
680             // Get initial context factory class name
681 
682             String className = env != null ?
683                 (String)env.get(Context.INITIAL_CONTEXT_FACTORY) : null;
684             if (className == null) {
685                 NoInitialContextException ne = new NoInitialContextException(
686                     &quot;Need to specify class name in environment or system &quot; +
687                     &quot;property, or in an application resource file: &quot; +
688                     Context.INITIAL_CONTEXT_FACTORY);
689                 throw ne;
690             }
691 



























692             ServiceLoader&lt;InitialContextFactory&gt; loader =
693                     ServiceLoader.load(InitialContextFactory.class);
694 
<span class="line-modified">695             Iterator&lt;InitialContextFactory&gt; iterator = loader.iterator();</span>















696             try {
<span class="line-modified">697                 while (iterator.hasNext()) {</span>
<span class="line-modified">698                     InitialContextFactory f = iterator.next();</span>
<span class="line-modified">699                     if (f.getClass().getName().equals(className)) {</span>
<span class="line-modified">700                         factory = f;</span>
<span class="line-removed">701                         break;</span>
<span class="line-removed">702                     }</span>
<span class="line-removed">703                 }</span>
<span class="line-removed">704             } catch (ServiceConfigurationError e) {</span>
705                 NoInitialContextException ne =
706                         new NoInitialContextException(
<span class="line-modified">707                                 &quot;Cannot load initial context factory &quot;</span>
<span class="line-removed">708                                         + &quot;&#39;&quot; + className + &quot;&#39;&quot;);</span>
709                 ne.setRootCause(e);
<span class="line-modified">710                 throw ne;</span>
<span class="line-removed">711             }</span>
<span class="line-removed">712 </span>
<span class="line-removed">713             if (factory == null) {</span>
<span class="line-removed">714                 try {</span>
<span class="line-removed">715                     @SuppressWarnings(&quot;deprecation&quot;)</span>
<span class="line-removed">716                     Object o = helper.loadClass(className).newInstance();</span>
<span class="line-removed">717                     factory = (InitialContextFactory) o;</span>
<span class="line-removed">718                 } catch (Exception e) {</span>
<span class="line-removed">719                     NoInitialContextException ne =</span>
<span class="line-removed">720                             new NoInitialContextException(</span>
<span class="line-removed">721                                     &quot;Cannot instantiate class: &quot; + className);</span>
<span class="line-removed">722                     ne.setRootCause(e);</span>
<span class="line-removed">723                     throw ne;</span>
<span class="line-removed">724                 }</span>
725             }
<span class="line-removed">726         } else {</span>
<span class="line-removed">727             factory = builder.createInitialContextFactory(env);</span>
728         }
<span class="line-modified">729 </span>
<span class="line-removed">730         return factory.getInitialContext(env);</span>
731     }
732 
733 
734     /**
735      * Sets the InitialContextFactory builder to be builder.
736      *
737      *&lt;p&gt;
738      * The builder can only be installed if the executing thread is allowed by
739      * the security manager to do so. Once installed, the builder cannot
740      * be replaced.
741      * @param builder The initial context factory builder to install. If null,
742      *                no builder is set.
743      * @exception SecurityException builder cannot be installed for security
744      *                  reasons.
745      * @exception NamingException builder cannot be installed for
746      *         a non-security-related reason.
747      * @exception IllegalStateException If a builder was previous installed.
748      * @see #hasInitialContextFactoryBuilder
749      * @see java.lang.SecurityManager#checkSetFactory
750      */
</pre>
<hr />
<pre>
904         throws NamingException
905     {
906 
907         FactoryEnumeration factories = ResourceManager.getFactories(
908             Context.STATE_FACTORIES, environment, nameCtx);
909 
910         if (factories == null) {
911             return obj;
912         }
913 
914         // Try each factory until one succeeds
915         StateFactory factory;
916         Object answer = null;
917         while (answer == null &amp;&amp; factories.hasMore()) {
918             factory = (StateFactory)factories.next();
919             answer = factory.getStateToBind(obj, name, nameCtx, environment);
920         }
921 
922         return (answer != null) ? answer : obj;
923     }














924 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.naming.spi;
 27 
 28 import java.net.MalformedURLException;
<span class="line-added"> 29 import java.security.AccessController;</span>
<span class="line-added"> 30 import java.security.PrivilegedAction;</span>
 31 import java.util.*;
 32 

 33 import javax.naming.*;
 34 import com.sun.naming.internal.VersionHelper;
 35 import com.sun.naming.internal.ResourceManager;
 36 import com.sun.naming.internal.FactoryEnumeration;
<span class="line-added"> 37 import jdk.internal.loader.ClassLoaderValue;</span>
 38 
 39 /**
 40  * This class contains methods for creating context objects
 41  * and objects referred to by location information in the naming
 42  * or directory service.
 43  *&lt;p&gt;
 44  * This class cannot be instantiated.  It has only static methods.
 45  *&lt;p&gt;
 46  * The mention of URL in the documentation for this class refers to
 47  * a URL string as defined by RFC 1738 and its related RFCs. It is
 48  * any string that conforms to the syntax described therein, and
 49  * may not always have corresponding support in the java.net.URL
 50  * class or Web browsers.
 51  *&lt;p&gt;
 52  * NamingManager is safe for concurrent access by multiple threads.
 53  *&lt;p&gt;
 54  * Except as otherwise noted,
 55  * a {@code Name} or environment parameter
 56  * passed to any method is owned by the caller.
 57  * The implementation will not modify the object or keep a reference
</pre>
<hr />
<pre>
 64 
 65 public class NamingManager {
 66 
 67     /*
 68      * Disallow anyone from creating one of these.
 69      * Made package private so that DirectoryManager can subclass.
 70      */
 71 
 72     NamingManager() {}
 73 
 74     // should be protected and package private
 75     static final VersionHelper helper = VersionHelper.getVersionHelper();
 76 
 77 // --------- object factory stuff
 78 
 79     /**
 80      * Package-private; used by DirectoryManager and NamingManager.
 81      */
 82     private static ObjectFactoryBuilder object_factory_builder = null;
 83 
<span class="line-added"> 84     private static final ClassLoaderValue&lt;InitialContextFactory&gt; FACTORIES_CACHE =</span>
<span class="line-added"> 85             new ClassLoaderValue&lt;&gt;();</span>
<span class="line-added"> 86 </span>
 87     /**
 88      * The ObjectFactoryBuilder determines the policy used when
 89      * trying to load object factories.
 90      * See getObjectInstance() and class ObjectFactory for a description
 91      * of the default policy.
 92      * setObjectFactoryBuilder() overrides this default policy by installing
 93      * an ObjectFactoryBuilder. Subsequent object factories will
 94      * be loaded and created using the installed builder.
 95      *&lt;p&gt;
 96      * The builder can only be installed if the executing thread is allowed
 97      * (by the security manager&#39;s checkSetFactory() method) to do so.
 98      * Once installed, the builder cannot be replaced.
 99      *
100      * @param builder The factory builder to install. If null, no builder
101      *                  is installed.
102      * @exception SecurityException builder cannot be installed
103      *          for security reasons.
104      * @exception NamingException builder cannot be installed for
105      *         a non-security-related reason.
106      * @exception IllegalStateException If a factory has already been installed.
</pre>
<hr />
<pre>
660      *         be in a package which is exported by that module to the
661      *         {@code java.naming} module.)&lt;/li&gt;
662      *     &lt;/ul&gt;
663      * &lt;/li&gt;
664      * &lt;/ul&gt;
665      * @param env The possibly null environment properties used when
666      *                  creating the context.
667      * @return A non-null initial context.
668      * @exception NoInitialContextException If the
669      *          {@code Context.INITIAL_CONTEXT_FACTORY} property
670      *         is not found or names a nonexistent
671      *         class or a class that cannot be instantiated,
672      *          or if the initial context could not be created for some other
673      *          reason.
674      * @exception NamingException If some other naming exception was encountered.
675      * @see javax.naming.InitialContext
676      * @see javax.naming.directory.InitialDirContext
677      */
678     public static Context getInitialContext(Hashtable&lt;?,?&gt; env)
679         throws NamingException {
<span class="line-added">680         ClassLoader loader;</span>
681         InitialContextFactory factory = null;
682 
683         InitialContextFactoryBuilder builder = getInitialContextFactoryBuilder();
684         if (builder == null) {
685             // No builder installed, use property
686             // Get initial context factory class name
687 
688             String className = env != null ?
689                 (String)env.get(Context.INITIAL_CONTEXT_FACTORY) : null;
690             if (className == null) {
691                 NoInitialContextException ne = new NoInitialContextException(
692                     &quot;Need to specify class name in environment or system &quot; +
693                     &quot;property, or in an application resource file: &quot; +
694                     Context.INITIAL_CONTEXT_FACTORY);
695                 throw ne;
696             }
697 
<span class="line-added">698             if (System.getSecurityManager() == null) {</span>
<span class="line-added">699                 loader = Thread.currentThread().getContextClassLoader();</span>
<span class="line-added">700                 if (loader == null) loader = ClassLoader.getSystemClassLoader();</span>
<span class="line-added">701             } else {</span>
<span class="line-added">702                 PrivilegedAction&lt;ClassLoader&gt; pa = () -&gt; {</span>
<span class="line-added">703                     ClassLoader cl = Thread.currentThread().getContextClassLoader();</span>
<span class="line-added">704                     return (cl == null) ? ClassLoader.getSystemClassLoader() : cl;</span>
<span class="line-added">705                 };</span>
<span class="line-added">706                 loader = AccessController.doPrivileged(pa);</span>
<span class="line-added">707             }</span>
<span class="line-added">708 </span>
<span class="line-added">709             var key = FACTORIES_CACHE.sub(className);</span>
<span class="line-added">710             try {</span>
<span class="line-added">711                 factory = key.computeIfAbsent(loader, (ld, ky) -&gt; getFactory(ky.key()));</span>
<span class="line-added">712             } catch (FactoryInitializationError e) {</span>
<span class="line-added">713                 throw e.getCause();</span>
<span class="line-added">714             }</span>
<span class="line-added">715         } else {</span>
<span class="line-added">716             factory = builder.createInitialContextFactory(env);</span>
<span class="line-added">717         }</span>
<span class="line-added">718 </span>
<span class="line-added">719         return factory.getInitialContext(env);</span>
<span class="line-added">720     }</span>
<span class="line-added">721 </span>
<span class="line-added">722     private static InitialContextFactory getFactory(String className) {</span>
<span class="line-added">723         InitialContextFactory factory;</span>
<span class="line-added">724         try {</span>
725             ServiceLoader&lt;InitialContextFactory&gt; loader =
726                     ServiceLoader.load(InitialContextFactory.class);
727 
<span class="line-modified">728             factory = loader</span>
<span class="line-added">729                     .stream()</span>
<span class="line-added">730                     .filter(p -&gt; p.type().getName().equals(className))</span>
<span class="line-added">731                     .findFirst()</span>
<span class="line-added">732                     .map(ServiceLoader.Provider::get)</span>
<span class="line-added">733                     .orElse(null);</span>
<span class="line-added">734         } catch (ServiceConfigurationError e) {</span>
<span class="line-added">735             NoInitialContextException ne =</span>
<span class="line-added">736                     new NoInitialContextException(</span>
<span class="line-added">737                             &quot;Cannot load initial context factory &quot;</span>
<span class="line-added">738                                     + &quot;&#39;&quot; + className + &quot;&#39;&quot;);</span>
<span class="line-added">739             ne.setRootCause(e);</span>
<span class="line-added">740             throw new FactoryInitializationError(ne);</span>
<span class="line-added">741         }</span>
<span class="line-added">742 </span>
<span class="line-added">743         if (factory == null) {</span>
744             try {
<span class="line-modified">745                 @SuppressWarnings(&quot;deprecation&quot;)</span>
<span class="line-modified">746                 Object o = helper.loadClass(className).newInstance();</span>
<span class="line-modified">747                 factory = (InitialContextFactory) o;</span>
<span class="line-modified">748             } catch (Exception e) {</span>




749                 NoInitialContextException ne =
750                         new NoInitialContextException(
<span class="line-modified">751                                 &quot;Cannot instantiate class: &quot; + className);</span>

752                 ne.setRootCause(e);
<span class="line-modified">753                 throw new FactoryInitializationError(ne);</span>














754             }


755         }
<span class="line-modified">756         return factory;</span>

757     }
758 
759 
760     /**
761      * Sets the InitialContextFactory builder to be builder.
762      *
763      *&lt;p&gt;
764      * The builder can only be installed if the executing thread is allowed by
765      * the security manager to do so. Once installed, the builder cannot
766      * be replaced.
767      * @param builder The initial context factory builder to install. If null,
768      *                no builder is set.
769      * @exception SecurityException builder cannot be installed for security
770      *                  reasons.
771      * @exception NamingException builder cannot be installed for
772      *         a non-security-related reason.
773      * @exception IllegalStateException If a builder was previous installed.
774      * @see #hasInitialContextFactoryBuilder
775      * @see java.lang.SecurityManager#checkSetFactory
776      */
</pre>
<hr />
<pre>
930         throws NamingException
931     {
932 
933         FactoryEnumeration factories = ResourceManager.getFactories(
934             Context.STATE_FACTORIES, environment, nameCtx);
935 
936         if (factories == null) {
937             return obj;
938         }
939 
940         // Try each factory until one succeeds
941         StateFactory factory;
942         Object answer = null;
943         while (answer == null &amp;&amp; factories.hasMore()) {
944             factory = (StateFactory)factories.next();
945             answer = factory.getStateToBind(obj, name, nameCtx, environment);
946         }
947 
948         return (answer != null) ? answer : obj;
949     }
<span class="line-added">950 </span>
<span class="line-added">951     private static class FactoryInitializationError extends Error {</span>
<span class="line-added">952         @java.io.Serial</span>
<span class="line-added">953         static final long serialVersionUID = -5805552256848841560L;</span>
<span class="line-added">954 </span>
<span class="line-added">955         private FactoryInitializationError(NoInitialContextException cause) {</span>
<span class="line-added">956             super(cause);</span>
<span class="line-added">957         }</span>
<span class="line-added">958 </span>
<span class="line-added">959         @Override</span>
<span class="line-added">960         public NoInitialContextException getCause() {</span>
<span class="line-added">961             return (NoInitialContextException) super.getCause();</span>
<span class="line-added">962         }</span>
<span class="line-added">963     }</span>
964 }
</pre>
</td>
</tr>
</table>
<center><a href="../package.html.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ResolveResult.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
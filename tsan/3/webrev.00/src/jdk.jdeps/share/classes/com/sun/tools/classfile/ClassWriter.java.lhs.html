<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jdeps/share/classes/com/sun/tools/classfile/ClassWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 package com.sun.tools.classfile;
 28 
 29 import java.io.ByteArrayOutputStream;
 30 import java.io.DataOutputStream;
 31 import java.io.File;
 32 import java.io.FileOutputStream;
 33 import java.io.IOException;
 34 import java.io.OutputStream;
 35 
 36 import static com.sun.tools.classfile.Annotation.*;
 37 import static com.sun.tools.classfile.ConstantPool.*;
 38 import static com.sun.tools.classfile.StackMapTable_attribute.*;
 39 import static com.sun.tools.classfile.StackMapTable_attribute.verification_type_info.*;
 40 
 41 /**
 42  * Write a ClassFile data structure to a file or stream.
 43  *
 44  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 45  *  If you write code that depends on this, you do so at your own risk.
 46  *  This code and its internal interfaces are subject to change or
 47  *  deletion without notice.&lt;/b&gt;
 48  */
 49 public class ClassWriter {
 50     public ClassWriter() {
 51         attributeWriter = new AttributeWriter();
 52         constantPoolWriter = new ConstantPoolWriter();
 53         out = new ClassOutputStream();
 54     }
 55 
 56     /**
 57      * Write a ClassFile data structure to a file.
 58      * @param classFile the classfile object to be written
 59      * @param f the file
 60      * @throws IOException if an error occurs while writing the file
 61      */
 62     public void write(ClassFile classFile, File f) throws IOException {
 63         try (FileOutputStream f_out = new FileOutputStream(f)) {
 64             write(classFile, f_out);
 65         }
 66     }
 67 
 68     /**
 69      * Write a ClassFile data structure to a stream.
 70      * @param classFile the classfile object to be written
 71      * @param s the stream
 72      * @throws IOException if an error occurs while writing the file
 73      */
 74     public void write(ClassFile classFile, OutputStream s) throws IOException {
 75         this.classFile = classFile;
 76         out.reset();
 77         write();
 78         out.writeTo(s);
 79     }
 80 
 81     protected void write() throws IOException {
 82         writeHeader();
 83         writeConstantPool();
 84         writeAccessFlags(classFile.access_flags);
 85         writeClassInfo();
 86         writeFields();
 87         writeMethods();
 88         writeAttributes(classFile.attributes);
 89     }
 90 
 91     protected void writeHeader() {
 92         out.writeInt(classFile.magic);
 93         out.writeShort(classFile.minor_version);
 94         out.writeShort(classFile.major_version);
 95     }
 96 
 97     protected void writeAccessFlags(AccessFlags flags) {
 98         out.writeShort(flags.flags);
 99     }
100 
101     protected void writeAttributes(Attributes attributes) {
102         int size = attributes.size();
103         out.writeShort(size);
104         for (Attribute attr: attributes)
105             attributeWriter.write(attr, out);
106     }
107 
108     protected void writeClassInfo() {
109         out.writeShort(classFile.this_class);
110         out.writeShort(classFile.super_class);
111         int[] interfaces = classFile.interfaces;
112         out.writeShort(interfaces.length);
113         for (int i: interfaces)
114             out.writeShort(i);
115     }
116 
117     protected void writeDescriptor(Descriptor d) {
118         out.writeShort(d.index);
119     }
120 
121     protected void writeConstantPool() {
122         ConstantPool pool = classFile.constant_pool;
123         int size = pool.size();
124         out.writeShort(size);
125         for (CPInfo cpInfo: pool.entries())
126             constantPoolWriter.write(cpInfo, out);
127     }
128 
129     protected void writeFields() throws IOException {
130         Field[] fields = classFile.fields;
131         out.writeShort(fields.length);
132         for (Field f: fields)
133             writeField(f);
134     }
135 
136     protected void writeField(Field f) throws IOException {
137         writeAccessFlags(f.access_flags);
138         out.writeShort(f.name_index);
139         writeDescriptor(f.descriptor);
140         writeAttributes(f.attributes);
141     }
142 
143     protected void writeMethods() throws IOException {
144         Method[] methods = classFile.methods;
145         out.writeShort(methods.length);
146         for (Method m: methods) {
147             writeMethod(m);
148         }
149     }
150 
151     protected void writeMethod(Method m) throws IOException {
152         writeAccessFlags(m.access_flags);
153         out.writeShort(m.name_index);
154         writeDescriptor(m.descriptor);
155         writeAttributes(m.attributes);
156     }
157 
158     protected ClassFile classFile;
159     protected ClassOutputStream out;
160     protected AttributeWriter attributeWriter;
161     protected ConstantPoolWriter constantPoolWriter;
162 
163     /**
164      * Subtype of ByteArrayOutputStream with the convenience methods of
165      * a DataOutputStream. Since ByteArrayOutputStream does not throw
166      * IOException, there are no exceptions from the additional
167      * convenience methods either,
168      */
169     protected static class ClassOutputStream extends ByteArrayOutputStream {
170         public ClassOutputStream() {
171             d = new DataOutputStream(this);
172         }
173 
174         public void writeByte(int value) {
175             try {
176                 d.writeByte(value);
177             } catch (IOException ignore) {
178             }
179         }
180 
181         public void writeShort(int value) {
182             try {
183                 d.writeShort(value);
184             } catch (IOException ignore) {
185             }
186         }
187 
188         public void writeInt(int value) {
189             try {
190                 d.writeInt(value);
191             } catch (IOException ignore) {
192             }
193         }
194 
195         public void writeLong(long value) {
196             try {
197                 d.writeLong(value);
198             } catch (IOException ignore) {
199             }
200         }
201 
202         public void writeFloat(float value) {
203             try {
204                 d.writeFloat(value);
205             } catch (IOException ignore) {
206             }
207         }
208 
209         public void writeDouble(double value) {
210             try {
211                 d.writeDouble(value);
212             } catch (IOException ignore) {
213             }
214         }
215 
216         public void writeUTF(String value) {
217             try {
218                 d.writeUTF(value);
219             } catch (IOException ignore) {
220             }
221         }
222 
223         public void writeTo(ClassOutputStream s) {
224             try {
225                 super.writeTo(s);
226             } catch (IOException ignore) {
227             }
228         }
229 
230         private final DataOutputStream d;
231     }
232 
233     /**
234      * Writer for the entries in the constant pool.
235      */
236     protected static class ConstantPoolWriter
237            implements ConstantPool.Visitor&lt;Integer,ClassOutputStream&gt; {
238         protected int write(CPInfo info, ClassOutputStream out) {
239             out.writeByte(info.getTag());
240             return info.accept(this, out);
241         }
242 
243         @Override
244         public Integer visitClass(CONSTANT_Class_info info, ClassOutputStream out) {
245             out.writeShort(info.name_index);
246             return 1;
247         }
248 
249         @Override
250         public Integer visitDouble(CONSTANT_Double_info info, ClassOutputStream out) {
251             out.writeDouble(info.value);
252             return 2;
253         }
254 
255         @Override
256         public Integer visitFieldref(CONSTANT_Fieldref_info info, ClassOutputStream out) {
257             writeRef(info, out);
258             return 1;
259         }
260 
261         @Override
262         public Integer visitFloat(CONSTANT_Float_info info, ClassOutputStream out) {
263             out.writeFloat(info.value);
264             return 1;
265         }
266 
267         @Override
268         public Integer visitInteger(CONSTANT_Integer_info info, ClassOutputStream out) {
269             out.writeInt(info.value);
270             return 1;
271         }
272 
273         @Override
274         public Integer visitInterfaceMethodref(CONSTANT_InterfaceMethodref_info info, ClassOutputStream out) {
275             writeRef(info, out);
276             return 1;
277         }
278 
279         @Override
280         public Integer visitInvokeDynamic(CONSTANT_InvokeDynamic_info info, ClassOutputStream out) {
281             out.writeShort(info.bootstrap_method_attr_index);
282             out.writeShort(info.name_and_type_index);
283             return 1;
284         }
285 
286         public Integer visitDynamicConstant(CONSTANT_Dynamic_info info, ClassOutputStream out) {
287             out.writeShort(info.bootstrap_method_attr_index);
288             out.writeShort(info.name_and_type_index);
289             return 1;
290         }
291 
292         @Override
293         public Integer visitLong(CONSTANT_Long_info info, ClassOutputStream out) {
294             out.writeLong(info.value);
295             return 2;
296         }
297 
298         @Override
299         public Integer visitMethodHandle(CONSTANT_MethodHandle_info info, ClassOutputStream out) {
300             out.writeByte(info.reference_kind.tag);
301             out.writeShort(info.reference_index);
302             return 1;
303         }
304 
305         @Override
306         public Integer visitMethodType(CONSTANT_MethodType_info info, ClassOutputStream out) {
307             out.writeShort(info.descriptor_index);
308             return 1;
309         }
310 
311         @Override
312         public Integer visitMethodref(CONSTANT_Methodref_info info, ClassOutputStream out) {
313             return writeRef(info, out);
314         }
315 
316         @Override
317         public Integer visitModule(CONSTANT_Module_info info, ClassOutputStream out) {
318             out.writeShort(info.name_index);
319             return 1;
320         }
321 
322         @Override
323         public Integer visitNameAndType(CONSTANT_NameAndType_info info, ClassOutputStream out) {
324             out.writeShort(info.name_index);
325             out.writeShort(info.type_index);
326             return 1;
327         }
328 
329         @Override
330         public Integer visitPackage(CONSTANT_Package_info info, ClassOutputStream out) {
331             out.writeShort(info.name_index);
332             return 1;
333         }
334 
335         @Override
336         public Integer visitString(CONSTANT_String_info info, ClassOutputStream out) {
337             out.writeShort(info.string_index);
338             return 1;
339         }
340 
341         @Override
342         public Integer visitUtf8(CONSTANT_Utf8_info info, ClassOutputStream out) {
343             out.writeUTF(info.value);
344             return 1;
345         }
346 
347         protected Integer writeRef(CPRefInfo info, ClassOutputStream out) {
348             out.writeShort(info.class_index);
349             out.writeShort(info.name_and_type_index);
350             return 1;
351         }
352     }
353 
354     /**
355      * Writer for the different types of attribute.
356      */
357     protected static class AttributeWriter implements Attribute.Visitor&lt;Void,ClassOutputStream&gt; {
358         public void write(Attributes attributes, ClassOutputStream out) {
359             int size = attributes.size();
360             out.writeShort(size);
361             for (Attribute a: attributes)
362                 write(a, out);
363         }
364 
365         // Note: due to the use of shared resources, this method is not reentrant.
366         public void write(Attribute attr, ClassOutputStream out) {
367             out.writeShort(attr.attribute_name_index);
368             sharedOut.reset();
369             attr.accept(this, sharedOut);
370             out.writeInt(sharedOut.size());
371             sharedOut.writeTo(out);
372         }
373 
374         protected ClassOutputStream sharedOut = new ClassOutputStream();
375         protected AnnotationWriter annotationWriter = new AnnotationWriter();
376 
377         @Override
378         public Void visitDefault(DefaultAttribute attr, ClassOutputStream out) {
379             out.write(attr.info, 0, attr.info.length);
380             return null;
381         }
382 
383         @Override
384         public Void visitAnnotationDefault(AnnotationDefault_attribute attr, ClassOutputStream out) {
385             annotationWriter.write(attr.default_value, out);
386             return null;
387         }
388 
389         @Override
390         public Void visitBootstrapMethods(BootstrapMethods_attribute attr, ClassOutputStream out) {
391             out.writeShort(attr.bootstrap_method_specifiers.length);
392             for (BootstrapMethods_attribute.BootstrapMethodSpecifier bsm : attr.bootstrap_method_specifiers) {
393                 out.writeShort(bsm.bootstrap_method_ref);
394                 int bsm_args_count = bsm.bootstrap_arguments.length;
395                 out.writeShort(bsm_args_count);
396                 for (int i : bsm.bootstrap_arguments) {
397                     out.writeShort(i);
398                 }
399             }
400             return null;
401         }
402 
403         @Override
404         public Void visitCharacterRangeTable(CharacterRangeTable_attribute attr, ClassOutputStream out) {
405             out.writeShort(attr.character_range_table.length);
406             for (CharacterRangeTable_attribute.Entry e: attr.character_range_table)
407                 writeCharacterRangeTableEntry(e, out);
408             return null;
409         }
410 
411         protected void writeCharacterRangeTableEntry(CharacterRangeTable_attribute.Entry entry, ClassOutputStream out) {
412             out.writeShort(entry.start_pc);
413             out.writeShort(entry.end_pc);
414             out.writeInt(entry.character_range_start);
415             out.writeInt(entry.character_range_end);
416             out.writeShort(entry.flags);
417         }
418 
419         @Override
420         public Void visitCode(Code_attribute attr, ClassOutputStream out) {
421             out.writeShort(attr.max_stack);
422             out.writeShort(attr.max_locals);
423             out.writeInt(attr.code.length);
424             out.write(attr.code, 0, attr.code.length);
425             out.writeShort(attr.exception_table.length);
426             for (Code_attribute.Exception_data e: attr.exception_table)
427                 writeExceptionTableEntry(e, out);
428             new AttributeWriter().write(attr.attributes, out);
429             return null;
430         }
431 
432         protected void writeExceptionTableEntry(Code_attribute.Exception_data exception_data, ClassOutputStream out) {
433             out.writeShort(exception_data.start_pc);
434             out.writeShort(exception_data.end_pc);
435             out.writeShort(exception_data.handler_pc);
436             out.writeShort(exception_data.catch_type);
437         }
438 
439         @Override
440         public Void visitCompilationID(CompilationID_attribute attr, ClassOutputStream out) {
441             out.writeShort(attr.compilationID_index);
442             return null;
443         }
444 
445         @Override
446         public Void visitConstantValue(ConstantValue_attribute attr, ClassOutputStream out) {
447             out.writeShort(attr.constantvalue_index);
448             return null;
449         }
450 
451         @Override
452         public Void visitDeprecated(Deprecated_attribute attr, ClassOutputStream out) {
453             return null;
454         }
455 
456         @Override
457         public Void visitEnclosingMethod(EnclosingMethod_attribute attr, ClassOutputStream out) {
458             out.writeShort(attr.class_index);
459             out.writeShort(attr.method_index);
460             return null;
461         }
462 
463         @Override
464         public Void visitExceptions(Exceptions_attribute attr, ClassOutputStream out) {
465             out.writeShort(attr.exception_index_table.length);
466             for (int i: attr.exception_index_table)
467                 out.writeShort(i);
468             return null;
469         }
470 
471         @Override
472         public Void visitInnerClasses(InnerClasses_attribute attr, ClassOutputStream out) {
473             out.writeShort(attr.classes.length);
474             for (InnerClasses_attribute.Info info: attr.classes)
475                 writeInnerClassesInfo(info, out);
476             return null;
477         }
478 
479         protected void writeInnerClassesInfo(InnerClasses_attribute.Info info, ClassOutputStream out) {
480             out.writeShort(info.inner_class_info_index);
481             out.writeShort(info.outer_class_info_index);
482             out.writeShort(info.inner_name_index);
483             writeAccessFlags(info.inner_class_access_flags, out);
484         }
485 
486         @Override
487         public Void visitLineNumberTable(LineNumberTable_attribute attr, ClassOutputStream out) {
488             out.writeShort(attr.line_number_table.length);
489             for (LineNumberTable_attribute.Entry e: attr.line_number_table)
490                 writeLineNumberTableEntry(e, out);
491             return null;
492         }
493 
494         protected void writeLineNumberTableEntry(LineNumberTable_attribute.Entry entry, ClassOutputStream out) {
495             out.writeShort(entry.start_pc);
496             out.writeShort(entry.line_number);
497         }
498 
499         @Override
500         public Void visitLocalVariableTable(LocalVariableTable_attribute attr, ClassOutputStream out) {
501             out.writeShort(attr.local_variable_table.length);
502             for (LocalVariableTable_attribute.Entry e: attr.local_variable_table)
503                 writeLocalVariableTableEntry(e, out);
504             return null;
505         }
506 
507         protected void writeLocalVariableTableEntry(LocalVariableTable_attribute.Entry entry, ClassOutputStream out) {
508             out.writeShort(entry.start_pc);
509             out.writeShort(entry.length);
510             out.writeShort(entry.name_index);
511             out.writeShort(entry.descriptor_index);
512             out.writeShort(entry.index);
513         }
514 
515         @Override
516         public Void visitLocalVariableTypeTable(LocalVariableTypeTable_attribute attr, ClassOutputStream out) {
517             out.writeShort(attr.local_variable_table.length);
518             for (LocalVariableTypeTable_attribute.Entry e: attr.local_variable_table)
519                 writeLocalVariableTypeTableEntry(e, out);
520             return null;
521         }
522 
523         protected void writeLocalVariableTypeTableEntry(LocalVariableTypeTable_attribute.Entry entry, ClassOutputStream out) {
524             out.writeShort(entry.start_pc);
525             out.writeShort(entry.length);
526             out.writeShort(entry.name_index);
527             out.writeShort(entry.signature_index);
528             out.writeShort(entry.index);
529         }
530 
531         @Override
532         public Void visitNestHost(NestHost_attribute attr, ClassOutputStream out) {
533             out.writeShort(attr.top_index);
534             return null;
535         }
536 
537         @Override
538         public Void visitMethodParameters(MethodParameters_attribute attr, ClassOutputStream out) {
539             out.writeByte(attr.method_parameter_table.length);
540             for (MethodParameters_attribute.Entry e : attr.method_parameter_table) {
541                 out.writeShort(e.name_index);
542                 out.writeShort(e.flags);
543             }
544             return null;
545         }
546 
547         @Override
548         public Void visitModule(Module_attribute attr, ClassOutputStream out) {
549             out.writeShort(attr.module_name);
550             out.writeShort(attr.module_flags);
551             out.writeShort(attr.module_version_index);
552 
553             out.writeShort(attr.requires.length);
554             for (Module_attribute.RequiresEntry e: attr.requires) {
555                 out.writeShort(e.requires_index);
556                 out.writeShort(e.requires_flags);
557                 out.writeShort(e.requires_version_index);
558             }
559 
560             out.writeShort(attr.exports.length);
561             for (Module_attribute.ExportsEntry e: attr.exports) {
562                 out.writeShort(e.exports_index);
563                 out.writeShort(e.exports_flags);
564                 out.writeShort(e.exports_to_index.length);
565                 for (int index: e.exports_to_index)
566                     out.writeShort(index);
567             }
568 
569             out.writeShort(attr.opens.length);
570             for (Module_attribute.OpensEntry e: attr.opens) {
571                 out.writeShort(e.opens_index);
572                 out.writeShort(e.opens_flags);
573                 out.writeShort(e.opens_to_index.length);
574                 for (int index: e.opens_to_index)
575                     out.writeShort(index);
576             }
577 
578             out.writeShort(attr.uses_index.length);
579             for (int index: attr.uses_index) {
580                 out.writeShort(index);
581             }
582 
583             out.writeShort(attr.provides.length);
584             for (Module_attribute.ProvidesEntry e: attr.provides) {
585                 out.writeShort(e.provides_index);
586                 out.writeShort(e.with_count);
587                 for (int with : e.with_index) {
588                     out.writeShort(with);
589                 }
590             }
591 
592             return null;
593         }
594 
595         @Override
596         public Void visitModuleHashes(ModuleHashes_attribute attr, ClassOutputStream out) {
597             out.writeShort(attr.algorithm_index);
598             out.writeShort(attr.hashes_table.length);
599             for (ModuleHashes_attribute.Entry e: attr.hashes_table) {
600                 out.writeShort(e.module_name_index);
601                 out.writeShort(e.hash.length);
602                 for (byte b: e.hash) {
603                     out.writeByte(b);
604                 }
605             }
606             return null;
607         }
608 
609         @Override
610         public Void visitModuleMainClass(ModuleMainClass_attribute attr, ClassOutputStream out) {
611             out.writeShort(attr.main_class_index);
612             return null;
613         }
614 
615         @Override
616         public Void visitModulePackages(ModulePackages_attribute attr, ClassOutputStream out) {
617             out.writeShort(attr.packages_count);
618             for (int i: attr.packages_index)
619                 out.writeShort(i);
620             return null;
621         }
622 
623         @Override
624         public Void visitModuleResolution(ModuleResolution_attribute attr, ClassOutputStream out) {
625             out.writeShort(attr.resolution_flags);
626             return null;
627         }
628 
629         @Override
630         public Void visitModuleTarget(ModuleTarget_attribute attr, ClassOutputStream out) {
631             out.writeShort(attr.target_platform_index);
632             return null;
633         }
634 
635         @Override
636         public Void visitNestMembers(NestMembers_attribute attr, ClassOutputStream out) {
637             out.writeShort(attr.members_indexes.length);
638             for (int i : attr.members_indexes) {
639                 out.writeShort(i);
640             }
641             return null;
642         }
643 
<a name="2" id="anc2"></a>













644         @Override
645         public Void visitRuntimeInvisibleAnnotations(RuntimeInvisibleAnnotations_attribute attr, ClassOutputStream out) {
646             annotationWriter.write(attr.annotations, out);
647             return null;
648         }
649 
650         @Override
651         public Void visitRuntimeInvisibleParameterAnnotations(RuntimeInvisibleParameterAnnotations_attribute attr, ClassOutputStream out) {
652             out.writeByte(attr.parameter_annotations.length);
653             for (Annotation[] annos: attr.parameter_annotations)
654                 annotationWriter.write(annos, out);
655             return null;
656         }
657 
658         @Override
659         public Void visitRuntimeInvisibleTypeAnnotations(RuntimeInvisibleTypeAnnotations_attribute attr, ClassOutputStream out) {
660             annotationWriter.write(attr.annotations, out);
661             return null;
662         }
663 
664         @Override
665         public Void visitRuntimeVisibleAnnotations(RuntimeVisibleAnnotations_attribute attr, ClassOutputStream out) {
666             annotationWriter.write(attr.annotations, out);
667             return null;
668         }
669 
670         @Override
671         public Void visitRuntimeVisibleParameterAnnotations(RuntimeVisibleParameterAnnotations_attribute attr, ClassOutputStream out) {
672             out.writeByte(attr.parameter_annotations.length);
673             for (Annotation[] annos: attr.parameter_annotations)
674                 annotationWriter.write(annos, out);
675             return null;
676         }
677 
678         @Override
679         public Void visitRuntimeVisibleTypeAnnotations(RuntimeVisibleTypeAnnotations_attribute attr, ClassOutputStream out) {
680             annotationWriter.write(attr.annotations, out);
681             return null;
682         }
683 
684         @Override
685         public Void visitSignature(Signature_attribute attr, ClassOutputStream out) {
686             out.writeShort(attr.signature_index);
687             return null;
688         }
689 
690         @Override
691         public Void visitSourceDebugExtension(SourceDebugExtension_attribute attr, ClassOutputStream out) {
692             out.write(attr.debug_extension, 0, attr.debug_extension.length);
693             return null;
694         }
695 
696         @Override
697         public Void visitSourceFile(SourceFile_attribute attr, ClassOutputStream out) {
698             out.writeShort(attr.sourcefile_index);
699             return null;
700         }
701 
702         @Override
703         public Void visitSourceID(SourceID_attribute attr, ClassOutputStream out) {
704             out.writeShort(attr.sourceID_index);
705             return null;
706         }
707 
708         @Override
709         public Void visitStackMap(StackMap_attribute attr, ClassOutputStream out) {
710             if (stackMapWriter == null)
711                 stackMapWriter = new StackMapTableWriter();
712 
713             out.writeShort(attr.entries.length);
714             for (stack_map_frame f: attr.entries)
715                 stackMapWriter.write(f, out);
716             return null;
717         }
718 
719         @Override
720         public Void visitStackMapTable(StackMapTable_attribute attr, ClassOutputStream out) {
721             if (stackMapWriter == null)
722                 stackMapWriter = new StackMapTableWriter();
723 
724             out.writeShort(attr.entries.length);
725             for (stack_map_frame f: attr.entries)
726                 stackMapWriter.write(f, out);
727             return null;
728         }
729 
730         @Override
731         public Void visitSynthetic(Synthetic_attribute attr, ClassOutputStream out) {
732             return null;
733         }
734 
735         protected void writeAccessFlags(AccessFlags flags, ClassOutputStream p) {
736             sharedOut.writeShort(flags.flags);
737         }
738 
739         protected StackMapTableWriter stackMapWriter;
740     }
741 
742     /**
743      * Writer for the frames of StackMap and StackMapTable attributes.
744      */
745     protected static class StackMapTableWriter
746             implements stack_map_frame.Visitor&lt;Void,ClassOutputStream&gt; {
747 
748         public void write(stack_map_frame frame, ClassOutputStream out) {
749             out.write(frame.frame_type);
750             frame.accept(this, out);
751         }
752 
753         @Override
754         public Void visit_same_frame(same_frame frame, ClassOutputStream p) {
755             return null;
756         }
757 
758         @Override
759         public Void visit_same_locals_1_stack_item_frame(same_locals_1_stack_item_frame frame, ClassOutputStream out) {
760             writeVerificationTypeInfo(frame.stack[0], out);
761             return null;
762         }
763 
764         @Override
765         public Void visit_same_locals_1_stack_item_frame_extended(same_locals_1_stack_item_frame_extended frame, ClassOutputStream out) {
766             out.writeShort(frame.offset_delta);
767             writeVerificationTypeInfo(frame.stack[0], out);
768             return null;
769         }
770 
771         @Override
772         public Void visit_chop_frame(chop_frame frame, ClassOutputStream out) {
773             out.writeShort(frame.offset_delta);
774             return null;
775         }
776 
777         @Override
778         public Void visit_same_frame_extended(same_frame_extended frame, ClassOutputStream out) {
779             out.writeShort(frame.offset_delta);
780             return null;
781         }
782 
783         @Override
784         public Void visit_append_frame(append_frame frame, ClassOutputStream out) {
785             out.writeShort(frame.offset_delta);
786             for (verification_type_info l: frame.locals)
787                 writeVerificationTypeInfo(l, out);
788             return null;
789         }
790 
791         @Override
792         public Void visit_full_frame(full_frame frame, ClassOutputStream out) {
793             out.writeShort(frame.offset_delta);
794             out.writeShort(frame.locals.length);
795             for (verification_type_info l: frame.locals)
796                 writeVerificationTypeInfo(l, out);
797             out.writeShort(frame.stack.length);
798             for (verification_type_info s: frame.stack)
799                 writeVerificationTypeInfo(s, out);
800             return null;
801         }
802 
803         protected void writeVerificationTypeInfo(verification_type_info info,
804                 ClassOutputStream out)  {
805             out.write(info.tag);
806             switch (info.tag) {
807             case ITEM_Top:
808             case ITEM_Integer:
809             case ITEM_Float:
810             case ITEM_Long:
811             case ITEM_Double:
812             case ITEM_Null:
813             case ITEM_UninitializedThis:
814                 break;
815 
816             case ITEM_Object:
817                 Object_variable_info o = (Object_variable_info) info;
818                 out.writeShort(o.cpool_index);
819                 break;
820 
821             case ITEM_Uninitialized:
822                 Uninitialized_variable_info u = (Uninitialized_variable_info) info;
823                 out.writeShort(u.offset);
824                 break;
825 
826             default:
827                 throw new Error();
828             }
829         }
830     }
831 
832     /**
833      * Writer for annotations and the values they contain.
834      */
835     protected static class AnnotationWriter
836             implements Annotation.element_value.Visitor&lt;Void,ClassOutputStream&gt; {
837         public void write(Annotation[] annos, ClassOutputStream out) {
838             out.writeShort(annos.length);
839             for (Annotation anno: annos)
840                 write(anno, out);
841         }
842 
843         public void write(TypeAnnotation[] annos, ClassOutputStream out) {
844             out.writeShort(annos.length);
845             for (TypeAnnotation anno: annos)
846                 write(anno, out);
847         }
848 
849         public void write(Annotation anno, ClassOutputStream out) {
850             out.writeShort(anno.type_index);
851             out.writeShort(anno.element_value_pairs.length);
852             for (element_value_pair p: anno.element_value_pairs)
853                 write(p, out);
854         }
855 
856         public void write(TypeAnnotation anno, ClassOutputStream out) {
857             write(anno.position, out);
858             write(anno.annotation, out);
859         }
860 
861         public void write(element_value_pair pair, ClassOutputStream out) {
862             out.writeShort(pair.element_name_index);
863             write(pair.value, out);
864         }
865 
866         public void write(element_value ev, ClassOutputStream out) {
867             out.writeByte(ev.tag);
868             ev.accept(this, out);
869         }
870 
871         @Override
872         public Void visitPrimitive(Primitive_element_value ev, ClassOutputStream out) {
873             out.writeShort(ev.const_value_index);
874             return null;
875         }
876 
877         @Override
878         public Void visitEnum(Enum_element_value ev, ClassOutputStream out) {
879             out.writeShort(ev.type_name_index);
880             out.writeShort(ev.const_name_index);
881             return null;
882         }
883 
884         @Override
885         public Void visitClass(Class_element_value ev, ClassOutputStream out) {
886             out.writeShort(ev.class_info_index);
887             return null;
888         }
889 
890         @Override
891         public Void visitAnnotation(Annotation_element_value ev, ClassOutputStream out) {
892             write(ev.annotation_value, out);
893             return null;
894         }
895 
896         @Override
897         public Void visitArray(Array_element_value ev, ClassOutputStream out) {
898             out.writeShort(ev.num_values);
899             for (element_value v: ev.values)
900                 write(v, out);
901             return null;
902         }
903 
904         // TODO: Move this to TypeAnnotation to be closer with similar logic?
905         private void write(TypeAnnotation.Position p, ClassOutputStream out) {
906             out.writeByte(p.type.targetTypeValue());
907             switch (p.type) {
908             // instanceof
909             case INSTANCEOF:
910             // new expression
911             case NEW:
912             // constructor/method reference receiver
913             case CONSTRUCTOR_REFERENCE:
914             case METHOD_REFERENCE:
915                 out.writeShort(p.offset);
916                 break;
917             // local variable
918             case LOCAL_VARIABLE:
919             // resource variable
920             case RESOURCE_VARIABLE:
921                 int table_length = p.lvarOffset.length;
922                 out.writeShort(table_length);
923                 for (int i = 0; i &lt; table_length; ++i) {
924                     out.writeShort(1);  // for table length
925                     out.writeShort(p.lvarOffset[i]);
926                     out.writeShort(p.lvarLength[i]);
927                     out.writeShort(p.lvarIndex[i]);
928                 }
929                 break;
930             // exception parameter
931             case EXCEPTION_PARAMETER:
932                 out.writeShort(p.exception_index);
933                 break;
934             // method receiver
935             case METHOD_RECEIVER:
936                 // Do nothing
937                 break;
938             // type parameters
939             case CLASS_TYPE_PARAMETER:
940             case METHOD_TYPE_PARAMETER:
941                 out.writeByte(p.parameter_index);
942                 break;
943             // type parameters bounds
944             case CLASS_TYPE_PARAMETER_BOUND:
945             case METHOD_TYPE_PARAMETER_BOUND:
946                 out.writeByte(p.parameter_index);
947                 out.writeByte(p.bound_index);
948                 break;
949             // class extends or implements clause
950             case CLASS_EXTENDS:
951                 out.writeShort(p.type_index);
952                 break;
953             // throws
954             case THROWS:
955                 out.writeShort(p.type_index);
956                 break;
957             // method parameter
958             case METHOD_FORMAL_PARAMETER:
959                 out.writeByte(p.parameter_index);
960                 break;
961             // type cast
962             case CAST:
963             // method/constructor/reference type argument
964             case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
965             case METHOD_INVOCATION_TYPE_ARGUMENT:
966             case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
967             case METHOD_REFERENCE_TYPE_ARGUMENT:
968                 out.writeShort(p.offset);
969                 out.writeByte(p.type_index);
970                 break;
971             // We don&#39;t need to worry about these
972             case METHOD_RETURN:
973             case FIELD:
974                 break;
975             case UNKNOWN:
976                 throw new AssertionError(&quot;ClassWriter: UNKNOWN target type should never occur!&quot;);
977             default:
978                 throw new AssertionError(&quot;ClassWriter: Unknown target type for position: &quot; + p);
979             }
980 
981             { // Append location data for generics/arrays.
982                 // TODO: check for overrun?
983                 out.writeByte((byte)p.location.size());
984                 for (int i : TypeAnnotation.Position.getBinaryFromTypePath(p.location))
985                     out.writeByte((byte)i);
986             }
987         }
988     }
989 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
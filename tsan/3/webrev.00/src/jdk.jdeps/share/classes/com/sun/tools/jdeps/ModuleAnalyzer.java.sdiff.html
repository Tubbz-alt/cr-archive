<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jdeps/share/classes/com/sun/tools/jdeps/ModuleAnalyzer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JdepsTask.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ModuleInfoBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdeps/share/classes/com/sun/tools/jdeps/ModuleAnalyzer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package com.sun.tools.jdeps;
 26 
<span class="line-removed"> 27 import static com.sun.tools.jdeps.Graph.*;</span>
 28 import static com.sun.tools.jdeps.JdepsFilter.DEFAULT_FILTER;
 29 import static com.sun.tools.jdeps.Module.*;
 30 import static java.lang.module.ModuleDescriptor.Requires.Modifier.*;
 31 import static java.util.stream.Collectors.*;
 32 
 33 import com.sun.tools.classfile.Dependency;
<span class="line-removed"> 34 import com.sun.tools.jdeps.JdepsTask.BadArgs;</span>
 35 
 36 import java.io.IOException;
<span class="line-removed"> 37 import java.io.OutputStream;</span>
 38 import java.io.PrintWriter;
 39 import java.lang.module.ModuleDescriptor;
<span class="line-removed"> 40 import java.nio.file.Files;</span>
<span class="line-removed"> 41 import java.nio.file.Path;</span>
<span class="line-removed"> 42 import java.util.Collections;</span>
 43 import java.util.Comparator;
 44 import java.util.HashMap;
 45 import java.util.HashSet;
 46 import java.util.Map;
 47 import java.util.Optional;
 48 import java.util.Set;
 49 import java.util.function.Function;
 50 import java.util.stream.Collectors;
 51 import java.util.stream.Stream;
 52 
 53 /**
 54  * Analyze module dependences and compare with module descriptor.
 55  * Also identify any qualified exports not used by the target module.
 56  */
 57 public class ModuleAnalyzer {
 58     private static final String JAVA_BASE = &quot;java.base&quot;;
 59 
 60     private final JdepsConfiguration configuration;
 61     private final PrintWriter log;
 62     private final DependencyFinder dependencyFinder;
 63     private final Map&lt;Module, ModuleDeps&gt; modules;
 64 
 65     public ModuleAnalyzer(JdepsConfiguration config,
 66                           PrintWriter log,
 67                           Set&lt;String&gt; names) {
 68         this.configuration = config;
 69         this.log = log;
 70 
 71         this.dependencyFinder = new DependencyFinder(config, DEFAULT_FILTER);
 72         if (names.isEmpty()) {
 73             this.modules = configuration.rootModules().stream()
 74                 .collect(toMap(Function.identity(), ModuleDeps::new));
 75         } else {
 76             this.modules = names.stream()
 77                 .map(configuration::findModule)
 78                 .flatMap(Optional::stream)
 79                 .collect(toMap(Function.identity(), ModuleDeps::new));
 80         }
 81     }
 82 
<span class="line-modified"> 83     public boolean run() throws IOException {</span>
 84         try {
<span class="line-modified"> 85             // compute &quot;requires transitive&quot; dependences</span>
<span class="line-modified"> 86             modules.values().forEach(ModuleDeps::computeRequiresTransitive);</span>
<span class="line-modified"> 87 </span>
<span class="line-removed"> 88             modules.values().forEach(md -&gt; {</span>
 89                 // compute &quot;requires&quot; dependences
<span class="line-modified"> 90                 md.computeRequires();</span>



 91                 // apply transitive reduction and reports recommended requires.
<span class="line-modified"> 92                 md.analyzeDeps();</span>
<span class="line-modified"> 93             });</span>






 94         } finally {
 95             dependencyFinder.shutdown();
 96         }
 97         return true;
 98     }
 99 

100     class ModuleDeps {
101         final Module root;
102         Set&lt;Module&gt; requiresTransitive;
103         Set&lt;Module&gt; requires;
104         Map&lt;String, Set&lt;String&gt;&gt; unusedQualifiedExports;
105 
106         ModuleDeps(Module root) {
107             this.root = root;
108         }
109 
110         /**
111          * Compute &#39;requires transitive&#39; dependences by analyzing API dependencies
112          */
<span class="line-modified">113         private void computeRequiresTransitive() {</span>
114             // record requires transitive
<span class="line-modified">115             this.requiresTransitive = computeRequires(true)</span>
116                 .filter(m -&gt; !m.name().equals(JAVA_BASE))
117                 .collect(toSet());
118 
119             trace(&quot;requires transitive: %s%n&quot;, requiresTransitive);
120         }
121 
<span class="line-modified">122         private void computeRequires() {</span>
<span class="line-modified">123             this.requires = computeRequires(false).collect(toSet());</span>
124             trace(&quot;requires: %s%n&quot;, requires);
125         }
126 
<span class="line-modified">127         private Stream&lt;Module&gt; computeRequires(boolean apionly) {</span>
128             // analyze all classes
<span class="line-removed">129 </span>
130             if (apionly) {
131                 dependencyFinder.parseExportedAPIs(Stream.of(root));
132             } else {
133                 dependencyFinder.parse(Stream.of(root));
134             }
135 
136             // find the modules of all the dependencies found
137             return dependencyFinder.getDependences(root)

138                         .map(Archive::getModule);
139         }
140 




141         ModuleDescriptor descriptor() {
142             return descriptor(requiresTransitive, requires);
143         }
144 
145         private ModuleDescriptor descriptor(Set&lt;Module&gt; requiresTransitive,
146                                             Set&lt;Module&gt; requires) {
147 
148             ModuleDescriptor.Builder builder = ModuleDescriptor.newModule(root.name());
149 
150             if (!root.name().equals(JAVA_BASE))
151                 builder.requires(Set.of(MANDATED), JAVA_BASE);
152 
153             requiresTransitive.stream()
154                 .filter(m -&gt; !m.name().equals(JAVA_BASE))
155                 .map(Module::name)
156                 .forEach(mn -&gt; builder.requires(Set.of(TRANSITIVE), mn));
157 
158             requires.stream()
159                 .filter(m -&gt; !requiresTransitive.contains(m))
160                 .filter(m -&gt; !m.name().equals(JAVA_BASE))
</pre>
<hr />
<pre>
179                     .forEach(m -&gt; gb.addEdge(root, m));
180 
181             // transitive reduction
182             Graph&lt;Module&gt; newGraph = gb.buildGraph().reduce(rbg);
183             if (DEBUG) {
184                 System.err.println(&quot;after transitive reduction: &quot;);
185                 newGraph.printGraph(log);
186             }
187             return newGraph;
188         }
189 
190         /**
191          * Apply the transitive reduction on the module graph
192          * and returns the corresponding ModuleDescriptor
193          */
194         ModuleDescriptor reduced() {
195             Graph&lt;Module&gt; g = buildReducedGraph();
196             return descriptor(requiresTransitive, g.adjacentNodes(root));
197         }
198 















199         /**
200          * Apply transitive reduction on the resulting graph and reports
201          * recommended requires.
202          */
<span class="line-modified">203         private void analyzeDeps() {</span>
<span class="line-modified">204             printModuleDescriptor(log, root);</span>



205 
206             ModuleDescriptor analyzedDescriptor = descriptor();
207             if (!matches(root.descriptor(), analyzedDescriptor)) {
208                 log.format(&quot;  [Suggested module descriptor for %s]%n&quot;, root.name());
209                 analyzedDescriptor.requires()
210                     .stream()
211                     .sorted(Comparator.comparing(ModuleDescriptor.Requires::name))
212                     .forEach(req -&gt; log.format(&quot;    requires %s;%n&quot;, req));
213             }
214 
215             ModuleDescriptor reduced = reduced();
216             if (!matches(root.descriptor(), reduced)) {
217                 log.format(&quot;  [Transitive reduced graph for %s]%n&quot;, root.name());
218                 reduced.requires()
219                     .stream()
220                     .sorted(Comparator.comparing(ModuleDescriptor.Requires::name))
221                     .forEach(req -&gt; log.format(&quot;    requires %s;%n&quot;, req));
222             }
223 
224             checkQualifiedExports();
225             log.println();

226         }
227 
228         private void checkQualifiedExports() {
229             // detect any qualified exports not used by the target module
230             unusedQualifiedExports = unusedQualifiedExports();
231             if (!unusedQualifiedExports.isEmpty())
232                 log.format(&quot;  [Unused qualified exports in %s]%n&quot;, root.name());
233 
234             unusedQualifiedExports.keySet().stream()
235                 .sorted()
236                 .forEach(pn -&gt; log.format(&quot;    exports %s to %s%n&quot;, pn,
237                     unusedQualifiedExports.get(pn).stream()
238                         .sorted()
239                         .collect(joining(&quot;,&quot;))));
240         }
241 




242         private void printModuleDescriptor(PrintWriter out, Module module) {
243             ModuleDescriptor descriptor = module.descriptor();
244             out.format(&quot;%s (%s)%n&quot;, descriptor.name(), module.location());
245 
246             if (descriptor.name().equals(JAVA_BASE))
247                 return;
248 
249             out.println(&quot;  [Module descriptor]&quot;);
250             descriptor.requires()
251                 .stream()
252                 .sorted(Comparator.comparing(ModuleDescriptor.Requires::name))
253                 .forEach(req -&gt; out.format(&quot;    requires %s;%n&quot;, req));
254         }
255 
256 
257         /**
258          * Detects any qualified exports not used by the target module.
259          */
260         private Map&lt;String, Set&lt;String&gt;&gt; unusedQualifiedExports() {
261             Map&lt;String, Set&lt;String&gt;&gt; unused = new HashMap&lt;&gt;();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package com.sun.tools.jdeps;
 26 

 27 import static com.sun.tools.jdeps.JdepsFilter.DEFAULT_FILTER;
 28 import static com.sun.tools.jdeps.Module.*;
 29 import static java.lang.module.ModuleDescriptor.Requires.Modifier.*;
 30 import static java.util.stream.Collectors.*;
 31 
 32 import com.sun.tools.classfile.Dependency;

 33 
 34 import java.io.IOException;

 35 import java.io.PrintWriter;
 36 import java.lang.module.ModuleDescriptor;



 37 import java.util.Comparator;
 38 import java.util.HashMap;
 39 import java.util.HashSet;
 40 import java.util.Map;
 41 import java.util.Optional;
 42 import java.util.Set;
 43 import java.util.function.Function;
 44 import java.util.stream.Collectors;
 45 import java.util.stream.Stream;
 46 
 47 /**
 48  * Analyze module dependences and compare with module descriptor.
 49  * Also identify any qualified exports not used by the target module.
 50  */
 51 public class ModuleAnalyzer {
 52     private static final String JAVA_BASE = &quot;java.base&quot;;
 53 
 54     private final JdepsConfiguration configuration;
 55     private final PrintWriter log;
 56     private final DependencyFinder dependencyFinder;
 57     private final Map&lt;Module, ModuleDeps&gt; modules;
 58 
 59     public ModuleAnalyzer(JdepsConfiguration config,
 60                           PrintWriter log,
 61                           Set&lt;String&gt; names) {
 62         this.configuration = config;
 63         this.log = log;
 64 
 65         this.dependencyFinder = new DependencyFinder(config, DEFAULT_FILTER);
 66         if (names.isEmpty()) {
 67             this.modules = configuration.rootModules().stream()
 68                 .collect(toMap(Function.identity(), ModuleDeps::new));
 69         } else {
 70             this.modules = names.stream()
 71                 .map(configuration::findModule)
 72                 .flatMap(Optional::stream)
 73                 .collect(toMap(Function.identity(), ModuleDeps::new));
 74         }
 75     }
 76 
<span class="line-modified"> 77     public boolean run(boolean ignoreMissingDeps) throws IOException {</span>
 78         try {
<span class="line-modified"> 79             for (ModuleDeps md: modules.values()) {</span>
<span class="line-modified"> 80                 // compute &quot;requires transitive&quot; dependences</span>
<span class="line-modified"> 81                 md.computeRequiresTransitive(ignoreMissingDeps);</span>

 82                 // compute &quot;requires&quot; dependences
<span class="line-modified"> 83                 md.computeRequires(ignoreMissingDeps);</span>
<span class="line-added"> 84                 // print module descriptor</span>
<span class="line-added"> 85                 md.printModuleDescriptor();</span>
<span class="line-added"> 86 </span>
 87                 // apply transitive reduction and reports recommended requires.
<span class="line-modified"> 88                 boolean ok = md.analyzeDeps();</span>
<span class="line-modified"> 89                 if (!ok) return false;</span>
<span class="line-added"> 90 </span>
<span class="line-added"> 91                 if (ignoreMissingDeps &amp;&amp; md.hasMissingDependencies()) {</span>
<span class="line-added"> 92                     log.format(&quot;Warning: --ignore-missing-deps specified. Missing dependencies from %s are ignored%n&quot;,</span>
<span class="line-added"> 93                                md.root.name());</span>
<span class="line-added"> 94                 }</span>
<span class="line-added"> 95             }</span>
 96         } finally {
 97             dependencyFinder.shutdown();
 98         }
 99         return true;
100     }
101 
<span class="line-added">102 </span>
103     class ModuleDeps {
104         final Module root;
105         Set&lt;Module&gt; requiresTransitive;
106         Set&lt;Module&gt; requires;
107         Map&lt;String, Set&lt;String&gt;&gt; unusedQualifiedExports;
108 
109         ModuleDeps(Module root) {
110             this.root = root;
111         }
112 
113         /**
114          * Compute &#39;requires transitive&#39; dependences by analyzing API dependencies
115          */
<span class="line-modified">116         private void computeRequiresTransitive(boolean ignoreMissingDeps) {</span>
117             // record requires transitive
<span class="line-modified">118             this.requiresTransitive = computeRequires(true, ignoreMissingDeps)</span>
119                 .filter(m -&gt; !m.name().equals(JAVA_BASE))
120                 .collect(toSet());
121 
122             trace(&quot;requires transitive: %s%n&quot;, requiresTransitive);
123         }
124 
<span class="line-modified">125         private void computeRequires(boolean ignoreMissingDeps) {</span>
<span class="line-modified">126             this.requires = computeRequires(false, ignoreMissingDeps).collect(toSet());</span>
127             trace(&quot;requires: %s%n&quot;, requires);
128         }
129 
<span class="line-modified">130         private Stream&lt;Module&gt; computeRequires(boolean apionly, boolean ignoreMissingDeps) {</span>
131             // analyze all classes

132             if (apionly) {
133                 dependencyFinder.parseExportedAPIs(Stream.of(root));
134             } else {
135                 dependencyFinder.parse(Stream.of(root));
136             }
137 
138             // find the modules of all the dependencies found
139             return dependencyFinder.getDependences(root)
<span class="line-added">140                         .filter(a -&gt; !(ignoreMissingDeps &amp;&amp; Analyzer.notFound(a)))</span>
141                         .map(Archive::getModule);
142         }
143 
<span class="line-added">144         boolean hasMissingDependencies() {</span>
<span class="line-added">145             return dependencyFinder.getDependences(root).anyMatch(Analyzer::notFound);</span>
<span class="line-added">146         }</span>
<span class="line-added">147 </span>
148         ModuleDescriptor descriptor() {
149             return descriptor(requiresTransitive, requires);
150         }
151 
152         private ModuleDescriptor descriptor(Set&lt;Module&gt; requiresTransitive,
153                                             Set&lt;Module&gt; requires) {
154 
155             ModuleDescriptor.Builder builder = ModuleDescriptor.newModule(root.name());
156 
157             if (!root.name().equals(JAVA_BASE))
158                 builder.requires(Set.of(MANDATED), JAVA_BASE);
159 
160             requiresTransitive.stream()
161                 .filter(m -&gt; !m.name().equals(JAVA_BASE))
162                 .map(Module::name)
163                 .forEach(mn -&gt; builder.requires(Set.of(TRANSITIVE), mn));
164 
165             requires.stream()
166                 .filter(m -&gt; !requiresTransitive.contains(m))
167                 .filter(m -&gt; !m.name().equals(JAVA_BASE))
</pre>
<hr />
<pre>
186                     .forEach(m -&gt; gb.addEdge(root, m));
187 
188             // transitive reduction
189             Graph&lt;Module&gt; newGraph = gb.buildGraph().reduce(rbg);
190             if (DEBUG) {
191                 System.err.println(&quot;after transitive reduction: &quot;);
192                 newGraph.printGraph(log);
193             }
194             return newGraph;
195         }
196 
197         /**
198          * Apply the transitive reduction on the module graph
199          * and returns the corresponding ModuleDescriptor
200          */
201         ModuleDescriptor reduced() {
202             Graph&lt;Module&gt; g = buildReducedGraph();
203             return descriptor(requiresTransitive, g.adjacentNodes(root));
204         }
205 
<span class="line-added">206         private void showMissingDeps() {</span>
<span class="line-added">207             // build the analyzer if there are missing dependences</span>
<span class="line-added">208             Analyzer analyzer = new Analyzer(configuration, Analyzer.Type.CLASS, DEFAULT_FILTER);</span>
<span class="line-added">209             analyzer.run(Set.of(root), dependencyFinder.locationToArchive());</span>
<span class="line-added">210             log.println(&quot;Error: Missing dependencies: classes not found from the module path.&quot;);</span>
<span class="line-added">211             Analyzer.Visitor visitor = new Analyzer.Visitor() {</span>
<span class="line-added">212                 @Override</span>
<span class="line-added">213                 public void visitDependence(String origin, Archive originArchive, String target, Archive targetArchive) {</span>
<span class="line-added">214                     log.format(&quot;   %-50s -&gt; %-50s %s%n&quot;, origin, target, targetArchive.getName());</span>
<span class="line-added">215                 }</span>
<span class="line-added">216             };</span>
<span class="line-added">217             analyzer.visitDependences(root, visitor, Analyzer.Type.VERBOSE, Analyzer::notFound);</span>
<span class="line-added">218             log.println();</span>
<span class="line-added">219         }</span>
<span class="line-added">220 </span>
221         /**
222          * Apply transitive reduction on the resulting graph and reports
223          * recommended requires.
224          */
<span class="line-modified">225         private boolean analyzeDeps() {</span>
<span class="line-modified">226             if (requires.stream().anyMatch(m -&gt; m == UNNAMED_MODULE)) {</span>
<span class="line-added">227                 showMissingDeps();</span>
<span class="line-added">228                 return false;</span>
<span class="line-added">229             }</span>
230 
231             ModuleDescriptor analyzedDescriptor = descriptor();
232             if (!matches(root.descriptor(), analyzedDescriptor)) {
233                 log.format(&quot;  [Suggested module descriptor for %s]%n&quot;, root.name());
234                 analyzedDescriptor.requires()
235                     .stream()
236                     .sorted(Comparator.comparing(ModuleDescriptor.Requires::name))
237                     .forEach(req -&gt; log.format(&quot;    requires %s;%n&quot;, req));
238             }
239 
240             ModuleDescriptor reduced = reduced();
241             if (!matches(root.descriptor(), reduced)) {
242                 log.format(&quot;  [Transitive reduced graph for %s]%n&quot;, root.name());
243                 reduced.requires()
244                     .stream()
245                     .sorted(Comparator.comparing(ModuleDescriptor.Requires::name))
246                     .forEach(req -&gt; log.format(&quot;    requires %s;%n&quot;, req));
247             }
248 
249             checkQualifiedExports();
250             log.println();
<span class="line-added">251             return true;</span>
252         }
253 
254         private void checkQualifiedExports() {
255             // detect any qualified exports not used by the target module
256             unusedQualifiedExports = unusedQualifiedExports();
257             if (!unusedQualifiedExports.isEmpty())
258                 log.format(&quot;  [Unused qualified exports in %s]%n&quot;, root.name());
259 
260             unusedQualifiedExports.keySet().stream()
261                 .sorted()
262                 .forEach(pn -&gt; log.format(&quot;    exports %s to %s%n&quot;, pn,
263                     unusedQualifiedExports.get(pn).stream()
264                         .sorted()
265                         .collect(joining(&quot;,&quot;))));
266         }
267 
<span class="line-added">268         void printModuleDescriptor() {</span>
<span class="line-added">269             printModuleDescriptor(log, root);</span>
<span class="line-added">270         }</span>
<span class="line-added">271 </span>
272         private void printModuleDescriptor(PrintWriter out, Module module) {
273             ModuleDescriptor descriptor = module.descriptor();
274             out.format(&quot;%s (%s)%n&quot;, descriptor.name(), module.location());
275 
276             if (descriptor.name().equals(JAVA_BASE))
277                 return;
278 
279             out.println(&quot;  [Module descriptor]&quot;);
280             descriptor.requires()
281                 .stream()
282                 .sorted(Comparator.comparing(ModuleDescriptor.Requires::name))
283                 .forEach(req -&gt; out.format(&quot;    requires %s;%n&quot;, req));
284         }
285 
286 
287         /**
288          * Detects any qualified exports not used by the target module.
289          */
290         private Map&lt;String, Set&lt;String&gt;&gt; unusedQualifiedExports() {
291             Map&lt;String, Set&lt;String&gt;&gt; unused = new HashMap&lt;&gt;();
</pre>
</td>
</tr>
</table>
<center><a href="JdepsTask.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ModuleInfoBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
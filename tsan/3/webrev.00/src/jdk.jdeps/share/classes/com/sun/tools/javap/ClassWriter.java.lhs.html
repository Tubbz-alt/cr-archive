<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jdeps/share/classes/com/sun/tools/javap/ClassWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javap;
 27 
 28 import java.net.URI;
 29 import java.text.DateFormat;
 30 import java.util.Collection;
 31 import java.util.Date;
 32 import java.util.List;
<a name="2" id="anc2"></a>
 33 
 34 import com.sun.tools.classfile.AccessFlags;
 35 import com.sun.tools.classfile.Attribute;
 36 import com.sun.tools.classfile.Attributes;
 37 import com.sun.tools.classfile.ClassFile;
 38 import com.sun.tools.classfile.Code_attribute;
 39 import com.sun.tools.classfile.ConstantPool;
 40 import com.sun.tools.classfile.ConstantPoolException;
 41 import com.sun.tools.classfile.ConstantValue_attribute;
 42 import com.sun.tools.classfile.Descriptor;
 43 import com.sun.tools.classfile.Descriptor.InvalidDescriptor;
 44 import com.sun.tools.classfile.Exceptions_attribute;
 45 import com.sun.tools.classfile.Field;
 46 import com.sun.tools.classfile.Method;
 47 import com.sun.tools.classfile.Module_attribute;
 48 import com.sun.tools.classfile.Signature;
 49 import com.sun.tools.classfile.Signature_attribute;
 50 import com.sun.tools.classfile.SourceFile_attribute;
 51 import com.sun.tools.classfile.Type;
 52 import com.sun.tools.classfile.Type.ArrayType;
 53 import com.sun.tools.classfile.Type.ClassSigType;
 54 import com.sun.tools.classfile.Type.ClassType;
 55 import com.sun.tools.classfile.Type.MethodType;
 56 import com.sun.tools.classfile.Type.SimpleType;
 57 import com.sun.tools.classfile.Type.TypeParamType;
 58 import com.sun.tools.classfile.Type.WildcardType;
 59 
 60 import static com.sun.tools.classfile.AccessFlags.*;
 61 import static com.sun.tools.classfile.ConstantPool.CONSTANT_Module;
 62 import static com.sun.tools.classfile.ConstantPool.CONSTANT_Package;
 63 
 64 /*
 65  *  The main javap class to write the contents of a class file as text.
 66  *
 67  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 68  *  If you write code that depends on this, you do so at your own risk.
 69  *  This code and its internal interfaces are subject to change or
 70  *  deletion without notice.&lt;/b&gt;
 71  */
 72 public class ClassWriter extends BasicWriter {
 73     static ClassWriter instance(Context context) {
 74         ClassWriter instance = context.get(ClassWriter.class);
 75         if (instance == null)
 76             instance = new ClassWriter(context);
 77         return instance;
 78     }
 79 
 80     protected ClassWriter(Context context) {
 81         super(context);
 82         context.put(ClassWriter.class, this);
 83         options = Options.instance(context);
 84         attrWriter = AttributeWriter.instance(context);
 85         codeWriter = CodeWriter.instance(context);
 86         constantWriter = ConstantWriter.instance(context);
 87     }
 88 
 89     void setDigest(String name, byte[] digest) {
 90         this.digestName = name;
 91         this.digest = digest;
 92     }
 93 
 94     void setFile(URI uri) {
 95         this.uri = uri;
 96     }
 97 
 98     void setFileSize(int size) {
 99         this.size = size;
100     }
101 
102     void setLastModified(long lastModified) {
103         this.lastModified = lastModified;
104     }
105 
106     protected ClassFile getClassFile() {
107         return classFile;
108     }
109 
110     protected void setClassFile(ClassFile cf) {
111         classFile = cf;
112         constant_pool = classFile.constant_pool;
113     }
114 
115     protected Method getMethod() {
116         return method;
117     }
118 
119     protected void setMethod(Method m) {
120         method = m;
121     }
122 
123     public void write(ClassFile cf) {
124         setClassFile(cf);
125 
126         if (options.sysInfo || options.verbose) {
127             if (uri != null) {
128                 if (uri.getScheme().equals(&quot;file&quot;))
129                     println(&quot;Classfile &quot; + uri.getPath());
130                 else
131                     println(&quot;Classfile &quot; + uri);
132             }
133             indent(+1);
134             if (lastModified != -1) {
135                 Date lm = new Date(lastModified);
136                 DateFormat df = DateFormat.getDateInstance();
137                 if (size &gt; 0) {
138                     println(&quot;Last modified &quot; + df.format(lm) + &quot;; size &quot; + size + &quot; bytes&quot;);
139                 } else {
140                     println(&quot;Last modified &quot; + df.format(lm));
141                 }
142             } else if (size &gt; 0) {
143                 println(&quot;Size &quot; + size + &quot; bytes&quot;);
144             }
145             if (digestName != null &amp;&amp; digest != null) {
146                 StringBuilder sb = new StringBuilder();
147                 for (byte b: digest)
148                     sb.append(String.format(&quot;%02x&quot;, b));
149                 println(digestName + &quot; checksum &quot; + sb);
150             }
151         }
152 
153         Attribute sfa = cf.getAttribute(Attribute.SourceFile);
154         if (sfa instanceof SourceFile_attribute) {
155             println(&quot;Compiled from \&quot;&quot; + getSourceFile((SourceFile_attribute) sfa) + &quot;\&quot;&quot;);
156         }
157 
158         if (options.sysInfo || options.verbose) {
159             indent(-1);
160         }
161 
162         AccessFlags flags = cf.access_flags;
163         writeModifiers(flags.getClassModifiers());
164 
165         if (classFile.access_flags.is(AccessFlags.ACC_MODULE)) {
166             Attribute attr = classFile.attributes.get(Attribute.Module);
167             if (attr instanceof Module_attribute) {
168                 Module_attribute modAttr = (Module_attribute) attr;
169                 String name;
170                 try {
171                     // FIXME: compatibility code
172                     if (constant_pool.get(modAttr.module_name).getTag() == CONSTANT_Module) {
173                         name = getJavaName(constant_pool.getModuleInfo(modAttr.module_name).getName());
174                     } else {
175                         name = getJavaName(constant_pool.getUTF8Value(modAttr.module_name));
176                     }
177                 } catch (ConstantPoolException e) {
178                     name = report(e);
179                 }
180                 if ((modAttr.module_flags &amp; Module_attribute.ACC_OPEN) != 0) {
181                     print(&quot;open &quot;);
182                 }
183                 print(&quot;module &quot;);
184                 print(name);
185                 if (modAttr.module_version_index != 0) {
186                     print(&quot;@&quot;);
187                     print(getUTF8Value(modAttr.module_version_index));
188                 }
189             } else {
190                 // fallback for malformed class files
191                 print(&quot;class &quot;);
192                 print(getJavaName(classFile));
193             }
194         } else {
195             if (classFile.isClass())
196                 print(&quot;class &quot;);
197             else if (classFile.isInterface())
198                 print(&quot;interface &quot;);
199 
200             print(getJavaName(classFile));
201         }
202 
203         Signature_attribute sigAttr = getSignature(cf.attributes);
204         if (sigAttr == null) {
205             // use info from class file header
206             if (classFile.isClass() &amp;&amp; classFile.super_class != 0 ) {
207                 String sn = getJavaSuperclassName(cf);
208                 if (!sn.equals(&quot;java.lang.Object&quot;)) {
209                     print(&quot; extends &quot;);
210                     print(sn);
211                 }
212             }
213             for (int i = 0; i &lt; classFile.interfaces.length; i++) {
214                 print(i == 0 ? (classFile.isClass() ? &quot; implements &quot; : &quot; extends &quot;) : &quot;,&quot;);
215                 print(getJavaInterfaceName(classFile, i));
216             }
217         } else {
218             try {
219                 Type t = sigAttr.getParsedSignature().getType(constant_pool);
220                 JavaTypePrinter p = new JavaTypePrinter(classFile.isInterface());
221                 // The signature parser cannot disambiguate between a
222                 // FieldType and a ClassSignatureType that only contains a superclass type.
223                 if (t instanceof Type.ClassSigType) {
224                     print(p.print(t));
225                 } else if (options.verbose || !t.isObject()) {
226                     print(&quot; extends &quot;);
227                     print(p.print(t));
228                 }
229             } catch (ConstantPoolException e) {
230                 print(report(e));
231             }
232         }
233 
234         if (options.verbose) {
235             println();
236             indent(+1);
237             println(&quot;minor version: &quot; + cf.minor_version);
238             println(&quot;major version: &quot; + cf.major_version);
239             writeList(String.format(&quot;flags: (0x%04x) &quot;, flags.flags), flags.getClassFlags(), &quot;\n&quot;);
240             print(&quot;this_class: #&quot; + cf.this_class);
241             if (cf.this_class != 0) {
242                 tab();
243                 print(&quot;// &quot; + constantWriter.stringValue(cf.this_class));
244             }
245             println();
246             print(&quot;super_class: #&quot; + cf.super_class);
247             if (cf.super_class != 0) {
248                 tab();
249                 print(&quot;// &quot; + constantWriter.stringValue(cf.super_class));
250             }
251             println();
252             print(&quot;interfaces: &quot; + cf.interfaces.length);
253             print(&quot;, fields: &quot; + cf.fields.length);
254             print(&quot;, methods: &quot; + cf.methods.length);
255             println(&quot;, attributes: &quot; + cf.attributes.attrs.length);
256             indent(-1);
257             constantWriter.writeConstantPool();
258         } else {
259             print(&quot; &quot;);
260         }
261 
262         println(&quot;{&quot;);
263         indent(+1);
264         if (flags.is(AccessFlags.ACC_MODULE) &amp;&amp; !options.verbose) {
265             writeDirectives();
266         }
267         writeFields();
268         writeMethods();
269         indent(-1);
270         println(&quot;}&quot;);
271 
272         if (options.verbose) {
273             attrWriter.write(cf, cf.attributes, constant_pool);
274         }
275     }
276     // where
277         class JavaTypePrinter implements Type.Visitor&lt;StringBuilder,StringBuilder&gt; {
278             boolean isInterface;
279 
280             JavaTypePrinter(boolean isInterface) {
281                 this.isInterface = isInterface;
282             }
283 
284             String print(Type t) {
285                 return t.accept(this, new StringBuilder()).toString();
286             }
287 
288             String printTypeArgs(List&lt;? extends TypeParamType&gt; typeParamTypes) {
289                 StringBuilder builder = new StringBuilder();
290                 appendIfNotEmpty(builder, &quot;&lt;&quot;, typeParamTypes, &quot;&gt; &quot;);
291                 return builder.toString();
292             }
293 
294             @Override
295             public StringBuilder visitSimpleType(SimpleType type, StringBuilder sb) {
296                 sb.append(getJavaName(type.name));
297                 return sb;
298             }
299 
300             @Override
301             public StringBuilder visitArrayType(ArrayType type, StringBuilder sb) {
302                 append(sb, type.elemType);
303                 sb.append(&quot;[]&quot;);
304                 return sb;
305             }
306 
307             @Override
308             public StringBuilder visitMethodType(MethodType type, StringBuilder sb) {
309                 appendIfNotEmpty(sb, &quot;&lt;&quot;, type.typeParamTypes, &quot;&gt; &quot;);
310                 append(sb, type.returnType);
311                 append(sb, &quot; (&quot;, type.paramTypes, &quot;)&quot;);
312                 appendIfNotEmpty(sb, &quot; throws &quot;, type.throwsTypes, &quot;&quot;);
313                 return sb;
314             }
315 
316             @Override
317             public StringBuilder visitClassSigType(ClassSigType type, StringBuilder sb) {
318                 appendIfNotEmpty(sb, &quot;&lt;&quot;, type.typeParamTypes, &quot;&gt;&quot;);
319                 if (isInterface) {
320                     appendIfNotEmpty(sb, &quot; extends &quot;, type.superinterfaceTypes, &quot;&quot;);
321                 } else {
322                     if (type.superclassType != null
323                             &amp;&amp; (options.verbose || !type.superclassType.isObject())) {
324                         sb.append(&quot; extends &quot;);
325                         append(sb, type.superclassType);
326                     }
327                     appendIfNotEmpty(sb, &quot; implements &quot;, type.superinterfaceTypes, &quot;&quot;);
328                 }
329                 return sb;
330             }
331 
332             @Override
333             public StringBuilder visitClassType(ClassType type, StringBuilder sb) {
334                 if (type.outerType != null) {
335                     append(sb, type.outerType);
336                     sb.append(&quot;.&quot;);
337                 }
338                 sb.append(getJavaName(type.name));
339                 appendIfNotEmpty(sb, &quot;&lt;&quot;, type.typeArgs, &quot;&gt;&quot;);
340                 return sb;
341             }
342 
343             @Override
344             public StringBuilder visitTypeParamType(TypeParamType type, StringBuilder sb) {
345                 sb.append(type.name);
346                 String sep = &quot; extends &quot;;
347                 if (type.classBound != null
348                         &amp;&amp; (options.verbose || !type.classBound.isObject())) {
349                     sb.append(sep);
350                     append(sb, type.classBound);
351                     sep = &quot; &amp; &quot;;
352                 }
353                 if (type.interfaceBounds != null) {
354                     for (Type bound: type.interfaceBounds) {
355                         sb.append(sep);
356                         append(sb, bound);
357                         sep = &quot; &amp; &quot;;
358                     }
359                 }
360                 return sb;
361             }
362 
363             @Override
364             public StringBuilder visitWildcardType(WildcardType type, StringBuilder sb) {
365                 switch (type.kind) {
366                     case UNBOUNDED:
367                         sb.append(&quot;?&quot;);
368                         break;
369                     case EXTENDS:
370                         sb.append(&quot;? extends &quot;);
371                         append(sb, type.boundType);
372                         break;
373                     case SUPER:
374                         sb.append(&quot;? super &quot;);
375                         append(sb, type.boundType);
376                         break;
377                     default:
378                         throw new AssertionError();
379                 }
380                 return sb;
381             }
382 
383             private void append(StringBuilder sb, Type t) {
384                 t.accept(this, sb);
385             }
386 
387             private void append(StringBuilder sb, String prefix, List&lt;? extends Type&gt; list, String suffix) {
388                 sb.append(prefix);
389                 String sep = &quot;&quot;;
390                 for (Type t: list) {
391                     sb.append(sep);
392                     append(sb, t);
393                     sep = &quot;, &quot;;
394                 }
395                 sb.append(suffix);
396             }
397 
398             private void appendIfNotEmpty(StringBuilder sb, String prefix, List&lt;? extends Type&gt; list, String suffix) {
399                 if (!isEmpty(list))
400                     append(sb, prefix, list, suffix);
401             }
402 
403             private boolean isEmpty(List&lt;? extends Type&gt; list) {
404                 return (list == null || list.isEmpty());
405             }
406         }
407 
408     protected void writeFields() {
409         for (Field f: classFile.fields) {
410             writeField(f);
411         }
412     }
413 
414     protected void writeField(Field f) {
415         if (!options.checkAccess(f.access_flags))
416             return;
417 
418         AccessFlags flags = f.access_flags;
419         writeModifiers(flags.getFieldModifiers());
420         Signature_attribute sigAttr = getSignature(f.attributes);
421         if (sigAttr == null)
422             print(getJavaFieldType(f.descriptor));
423         else {
424             try {
425                 Type t = sigAttr.getParsedSignature().getType(constant_pool);
426                 print(getJavaName(t.toString()));
427             } catch (ConstantPoolException e) {
428                 // report error?
429                 // fall back on non-generic descriptor
430                 print(getJavaFieldType(f.descriptor));
431             }
432         }
433         print(&quot; &quot;);
434         print(getFieldName(f));
435         if (options.showConstants) {
436             Attribute a = f.attributes.get(Attribute.ConstantValue);
437             if (a instanceof ConstantValue_attribute) {
438                 print(&quot; = &quot;);
439                 ConstantValue_attribute cv = (ConstantValue_attribute) a;
440                 print(getConstantValue(f.descriptor, cv.constantvalue_index));
441             }
442         }
443         print(&quot;;&quot;);
444         println();
445 
446         indent(+1);
447 
448         boolean showBlank = false;
449 
450         if (options.showDescriptors)
451             println(&quot;descriptor: &quot; + getValue(f.descriptor));
452 
453         if (options.verbose)
454             writeList(String.format(&quot;flags: (0x%04x) &quot;, flags.flags), flags.getFieldFlags(), &quot;\n&quot;);
455 
456         if (options.showAllAttrs) {
457             for (Attribute attr: f.attributes)
458                 attrWriter.write(f, attr, constant_pool);
459             showBlank = true;
460         }
461 
462         indent(-1);
463 
464         if (showBlank || options.showDisassembled || options.showLineAndLocalVariableTables)
465             println();
466     }
467 
468     protected void writeMethods() {
469         for (Method m: classFile.methods)
470             writeMethod(m);
471         setPendingNewline(false);
472     }
473 
<a name="3" id="anc3"></a>


474     protected void writeMethod(Method m) {
475         if (!options.checkAccess(m.access_flags))
476             return;
477 
478         method = m;
479 
480         AccessFlags flags = m.access_flags;
481 
482         Descriptor d;
483         Type.MethodType methodType;
484         List&lt;? extends Type&gt; methodExceptions;
485 
486         Signature_attribute sigAttr = getSignature(m.attributes);
487         if (sigAttr == null) {
488             d = m.descriptor;
489             methodType = null;
490             methodExceptions = null;
491         } else {
492             Signature methodSig = sigAttr.getParsedSignature();
493             d = methodSig;
494             try {
495                 methodType = (Type.MethodType) methodSig.getType(constant_pool);
496                 methodExceptions = methodType.throwsTypes;
497                 if (methodExceptions != null &amp;&amp; methodExceptions.isEmpty())
498                     methodExceptions = null;
499             } catch (ConstantPoolException e) {
500                 // report error?
501                 // fall back on standard descriptor
502                 methodType = null;
503                 methodExceptions = null;
504             }
505         }
506 
<a name="4" id="anc4"></a><span class="line-modified">507         writeModifiers(flags.getMethodModifiers());</span>













508         if (methodType != null) {
509             print(new JavaTypePrinter(false).printTypeArgs(methodType.typeParamTypes));
510         }
<a name="5" id="anc5"></a><span class="line-modified">511         switch (getName(m)) {</span>
512             case &quot;&lt;init&gt;&quot;:
513                 print(getJavaName(classFile));
514                 print(getJavaParameterTypes(d, flags));
515                 break;
516             case &quot;&lt;clinit&gt;&quot;:
517                 print(&quot;{}&quot;);
518                 break;
519             default:
520                 print(getJavaReturnType(d));
521                 print(&quot; &quot;);
<a name="6" id="anc6"></a><span class="line-modified">522                 print(getName(m));</span>
523                 print(getJavaParameterTypes(d, flags));
524                 break;
525         }
526 
527         Attribute e_attr = m.attributes.get(Attribute.Exceptions);
528         if (e_attr != null) { // if there are generic exceptions, there must be erased exceptions
529             if (e_attr instanceof Exceptions_attribute) {
530                 Exceptions_attribute exceptions = (Exceptions_attribute) e_attr;
531                 print(&quot; throws &quot;);
532                 if (methodExceptions != null) { // use generic list if available
533                     writeList(&quot;&quot;, methodExceptions, &quot;&quot;);
534                 } else {
535                     for (int i = 0; i &lt; exceptions.number_of_exceptions; i++) {
536                         if (i &gt; 0)
537                             print(&quot;, &quot;);
538                         print(getJavaException(exceptions, i));
539                     }
540                 }
541             } else {
542                 report(&quot;Unexpected or invalid value for Exceptions attribute&quot;);
543             }
544         }
545 
546         println(&quot;;&quot;);
547 
548         indent(+1);
549 
550         if (options.showDescriptors) {
551             println(&quot;descriptor: &quot; + getValue(m.descriptor));
552         }
553 
554         if (options.verbose) {
555             writeList(String.format(&quot;flags: (0x%04x) &quot;, flags.flags), flags.getMethodFlags(), &quot;\n&quot;);
556         }
557 
558         Code_attribute code = null;
559         Attribute c_attr = m.attributes.get(Attribute.Code);
560         if (c_attr != null) {
561             if (c_attr instanceof Code_attribute)
562                 code = (Code_attribute) c_attr;
563             else
564                 report(&quot;Unexpected or invalid value for Code attribute&quot;);
565         }
566 
567         if (options.showAllAttrs) {
568             Attribute[] attrs = m.attributes.attrs;
569             for (Attribute attr: attrs)
570                 attrWriter.write(m, attr, constant_pool);
571         } else if (code != null) {
572             if (options.showDisassembled) {
573                 println(&quot;Code:&quot;);
574                 codeWriter.writeInstrs(code);
575                 codeWriter.writeExceptionTable(code);
576             }
577 
578             if (options.showLineAndLocalVariableTables) {
579                 attrWriter.write(code, code.attributes.get(Attribute.LineNumberTable), constant_pool);
580                 attrWriter.write(code, code.attributes.get(Attribute.LocalVariableTable), constant_pool);
581             }
582         }
583 
584         indent(-1);
585 
586         // set pendingNewline to write a newline before the next method (if any)
587         // if a separator is desired
588         setPendingNewline(
589                 options.showDisassembled ||
590                 options.showAllAttrs ||
591                 options.showDescriptors ||
592                 options.showLineAndLocalVariableTables ||
593                 options.verbose);
594     }
595 
596     void writeModifiers(Collection&lt;String&gt; items) {
597         for (Object item: items) {
598             print(item);
599             print(&quot; &quot;);
600         }
601     }
602 
603     void writeDirectives() {
604         Attribute attr = classFile.attributes.get(Attribute.Module);
605         if (!(attr instanceof Module_attribute))
606             return;
607 
608         Module_attribute m = (Module_attribute) attr;
609         for (Module_attribute.RequiresEntry entry: m.requires) {
610             print(&quot;requires&quot;);
611             if ((entry.requires_flags &amp; Module_attribute.ACC_STATIC_PHASE) != 0)
612                 print(&quot; static&quot;);
613             if ((entry.requires_flags &amp; Module_attribute.ACC_TRANSITIVE) != 0)
614                 print(&quot; transitive&quot;);
615             print(&quot; &quot;);
616             String mname;
617             try {
618                 mname = getModuleName(entry.requires_index);
619             } catch (ConstantPoolException e) {
620                 mname = report(e);
621             }
622             print(mname);
623             println(&quot;;&quot;);
624         }
625 
626         for (Module_attribute.ExportsEntry entry: m.exports) {
627             print(&quot;exports&quot;);
628             print(&quot; &quot;);
629             String pname;
630             try {
631                 pname = getPackageName(entry.exports_index).replace(&#39;/&#39;, &#39;.&#39;);
632             } catch (ConstantPoolException e) {
633                 pname = report(e);
634             }
635             print(pname);
636             boolean first = true;
637             for (int i: entry.exports_to_index) {
638                 String mname;
639                 try {
640                     mname = getModuleName(i);
641                 } catch (ConstantPoolException e) {
642                     mname = report(e);
643                 }
644                 if (first) {
645                     println(&quot; to&quot;);
646                     indent(+1);
647                     first = false;
648                 } else {
649                     println(&quot;,&quot;);
650                 }
651                 print(mname);
652             }
653             println(&quot;;&quot;);
654             if (!first)
655                 indent(-1);
656         }
657 
658         for (Module_attribute.OpensEntry entry: m.opens) {
659             print(&quot;opens&quot;);
660             print(&quot; &quot;);
661             String pname;
662             try {
663                 pname = getPackageName(entry.opens_index).replace(&#39;/&#39;, &#39;.&#39;);
664             } catch (ConstantPoolException e) {
665                 pname = report(e);
666             }
667             print(pname);
668             boolean first = true;
669             for (int i: entry.opens_to_index) {
670                 String mname;
671                 try {
672                     mname = getModuleName(i);
673                 } catch (ConstantPoolException e) {
674                     mname = report(e);
675                 }
676                 if (first) {
677                     println(&quot; to&quot;);
678                     indent(+1);
679                     first = false;
680                 } else {
681                     println(&quot;,&quot;);
682                 }
683                 print(mname);
684             }
685             println(&quot;;&quot;);
686             if (!first)
687                 indent(-1);
688         }
689 
690         for (int entry: m.uses_index) {
691             print(&quot;uses &quot;);
692             print(getClassName(entry).replace(&#39;/&#39;, &#39;.&#39;));
693             println(&quot;;&quot;);
694         }
695 
696         for (Module_attribute.ProvidesEntry entry: m.provides) {
697             print(&quot;provides  &quot;);
698             print(getClassName(entry.provides_index).replace(&#39;/&#39;, &#39;.&#39;));
699             boolean first = true;
700             for (int i: entry.with_index) {
701                 if (first) {
702                     println(&quot; with&quot;);
703                     indent(+1);
704                     first = false;
705                 } else {
706                     println(&quot;,&quot;);
707                 }
708                 print(getClassName(i).replace(&#39;/&#39;, &#39;.&#39;));
709             }
710             println(&quot;;&quot;);
711             if (!first)
712                 indent(-1);
713         }
714     }
715 
716     String getModuleName(int index) throws ConstantPoolException {
717         if (constant_pool.get(index).getTag() == CONSTANT_Module) {
718             return constant_pool.getModuleInfo(index).getName();
719         } else {
720             return constant_pool.getUTF8Value(index);
721         }
722     }
723 
724     String getPackageName(int index) throws ConstantPoolException {
725         if (constant_pool.get(index).getTag() == CONSTANT_Package) {
726             return constant_pool.getPackageInfo(index).getName();
727         } else {
728             return constant_pool.getUTF8Value(index);
729         }
730     }
731 
732     String getUTF8Value(int index) {
733         try {
734             return classFile.constant_pool.getUTF8Value(index);
735         } catch (ConstantPoolException e) {
736             return report(e);
737         }
738     }
739 
740     String getClassName(int index) {
741         try {
742             return classFile.constant_pool.getClassInfo(index).getName();
743         } catch (ConstantPoolException e) {
744             return report(e);
745         }
746     }
747 
748     void writeList(String prefix, Collection&lt;?&gt; items, String suffix) {
749         print(prefix);
750         String sep = &quot;&quot;;
751         for (Object item: items) {
752             print(sep);
753             print(item);
754             sep = &quot;, &quot;;
755         }
756         print(suffix);
757     }
758 
759     void writeListIfNotEmpty(String prefix, List&lt;?&gt; items, String suffix) {
760         if (items != null &amp;&amp; items.size() &gt; 0)
761             writeList(prefix, items, suffix);
762     }
763 
764     Signature_attribute getSignature(Attributes attributes) {
765         return (Signature_attribute) attributes.get(Attribute.Signature);
766     }
767 
768     String adjustVarargs(AccessFlags flags, String params) {
769         if (flags.is(ACC_VARARGS)) {
770             int i = params.lastIndexOf(&quot;[]&quot;);
771             if (i &gt; 0)
772                 return params.substring(0, i) + &quot;...&quot; + params.substring(i+2);
773         }
774 
775         return params;
776     }
777 
778     String getJavaName(ClassFile cf) {
779         try {
780             return getJavaName(cf.getName());
781         } catch (ConstantPoolException e) {
782             return report(e);
783         }
784     }
785 
786     String getJavaSuperclassName(ClassFile cf) {
787         try {
788             return getJavaName(cf.getSuperclassName());
789         } catch (ConstantPoolException e) {
790             return report(e);
791         }
792     }
793 
794     String getJavaInterfaceName(ClassFile cf, int index) {
795         try {
796             return getJavaName(cf.getInterfaceName(index));
797         } catch (ConstantPoolException e) {
798             return report(e);
799         }
800     }
801 
802     String getJavaFieldType(Descriptor d) {
803         try {
804             return getJavaName(d.getFieldType(constant_pool));
805         } catch (ConstantPoolException e) {
806             return report(e);
807         } catch (InvalidDescriptor e) {
808             return report(e);
809         }
810     }
811 
812     String getJavaReturnType(Descriptor d) {
813         try {
814             return getJavaName(d.getReturnType(constant_pool));
815         } catch (ConstantPoolException e) {
816             return report(e);
817         } catch (InvalidDescriptor e) {
818             return report(e);
819         }
820     }
821 
822     String getJavaParameterTypes(Descriptor d, AccessFlags flags) {
823         try {
824             return getJavaName(adjustVarargs(flags, d.getParameterTypes(constant_pool)));
825         } catch (ConstantPoolException e) {
826             return report(e);
827         } catch (InvalidDescriptor e) {
828             return report(e);
829         }
830     }
831 
832     String getJavaException(Exceptions_attribute attr, int index) {
833         try {
834             return getJavaName(attr.getException(index, constant_pool));
835         } catch (ConstantPoolException e) {
836             return report(e);
837         }
838     }
839 
840     String getValue(Descriptor d) {
841         try {
842             return d.getValue(constant_pool);
843         } catch (ConstantPoolException e) {
844             return report(e);
845         }
846     }
847 
848     String getFieldName(Field f) {
849         try {
850             return f.getName(constant_pool);
851         } catch (ConstantPoolException e) {
852             return report(e);
853         }
854     }
855 
856     String getName(Method m) {
857         try {
858             return m.getName(constant_pool);
859         } catch (ConstantPoolException e) {
860             return report(e);
861         }
862     }
863 
864     static String getJavaName(String name) {
865         return name.replace(&#39;/&#39;, &#39;.&#39;);
866     }
867 
868     String getSourceFile(SourceFile_attribute attr) {
869         try {
870             return attr.getSourceFile(constant_pool);
871         } catch (ConstantPoolException e) {
872             return report(e);
873         }
874     }
875 
876     /**
877      * Get the value of an entry in the constant pool as a Java constant.
878      * Characters and booleans are represented by CONSTANT_Intgere entries.
879      * Character and string values are processed to escape characters outside
880      * the basic printable ASCII set.
881      * @param d the descriptor, giving the expected type of the constant
882      * @param index the index of the value in the constant pool
883      * @return a printable string containing the value of the constant.
884      */
885     String getConstantValue(Descriptor d, int index) {
886         try {
887             ConstantPool.CPInfo cpInfo = constant_pool.get(index);
888 
889             switch (cpInfo.getTag()) {
890                 case ConstantPool.CONSTANT_Integer: {
891                     ConstantPool.CONSTANT_Integer_info info =
892                             (ConstantPool.CONSTANT_Integer_info) cpInfo;
893                     String t = d.getValue(constant_pool);
894                     switch (t) {
895                         case &quot;C&quot;:
896                             // character
897                             return getConstantCharValue((char) info.value);
898                         case &quot;Z&quot;:
899                             // boolean
900                             return String.valueOf(info.value == 1);
901                         default:
902                             // other: assume integer
903                             return String.valueOf(info.value);
904                     }
905                 }
906 
907                 case ConstantPool.CONSTANT_String: {
908                     ConstantPool.CONSTANT_String_info info =
909                             (ConstantPool.CONSTANT_String_info) cpInfo;
910                     return getConstantStringValue(info.getString());
911                 }
912 
913                 default:
914                     return constantWriter.stringValue(cpInfo);
915             }
916         } catch (ConstantPoolException e) {
917             return &quot;#&quot; + index;
918         }
919     }
920 
921     private String getConstantCharValue(char c) {
922         StringBuilder sb = new StringBuilder();
923         sb.append(&#39;\&#39;&#39;);
924         sb.append(esc(c, &#39;\&#39;&#39;));
925         sb.append(&#39;\&#39;&#39;);
926         return sb.toString();
927     }
928 
929     private String getConstantStringValue(String s) {
930         StringBuilder sb = new StringBuilder();
931         sb.append(&quot;\&quot;&quot;);
932         for (int i = 0; i &lt; s.length(); i++) {
933             sb.append(esc(s.charAt(i), &#39;&quot;&#39;));
934         }
935         sb.append(&quot;\&quot;&quot;);
936         return sb.toString();
937     }
938 
939     private String esc(char c, char quote) {
940         if (32 &lt;= c &amp;&amp; c &lt;= 126 &amp;&amp; c != quote &amp;&amp; c != &#39;\\&#39;)
941             return String.valueOf(c);
942         else switch (c) {
943             case &#39;\b&#39;: return &quot;\\b&quot;;
944             case &#39;\n&#39;: return &quot;\\n&quot;;
945             case &#39;\t&#39;: return &quot;\\t&quot;;
946             case &#39;\f&#39;: return &quot;\\f&quot;;
947             case &#39;\r&#39;: return &quot;\\r&quot;;
948             case &#39;\\&#39;: return &quot;\\\\&quot;;
949             case &#39;\&#39;&#39;: return &quot;\\&#39;&quot;;
950             case &#39;\&quot;&#39;: return &quot;\\\&quot;&quot;;
951             default:   return String.format(&quot;\\u%04x&quot;, (int) c);
952         }
953     }
954 
955     private final Options options;
956     private final AttributeWriter attrWriter;
957     private final CodeWriter codeWriter;
958     private final ConstantWriter constantWriter;
959     private ClassFile classFile;
960     private URI uri;
961     private long lastModified;
962     private String digestName;
963     private byte[] digest;
964     private int size;
965     private ConstantPool constant_pool;
966     private Method method;
967 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
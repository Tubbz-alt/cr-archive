diff a/src/jdk.jdeps/share/classes/com/sun/tools/javap/AttributeWriter.java b/src/jdk.jdeps/share/classes/com/sun/tools/javap/AttributeWriter.java
--- a/src/jdk.jdeps/share/classes/com/sun/tools/javap/AttributeWriter.java
+++ b/src/jdk.jdeps/share/classes/com/sun/tools/javap/AttributeWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,10 +23,12 @@
  * questions.
  */
 
 package com.sun.tools.javap;
 
+import java.util.Collection;
+
 import com.sun.tools.classfile.AccessFlags;
 import com.sun.tools.classfile.AnnotationDefault_attribute;
 import com.sun.tools.classfile.Attribute;
 import com.sun.tools.classfile.Attributes;
 import com.sun.tools.classfile.BootstrapMethods_attribute;
@@ -38,10 +40,12 @@
 import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;
 import com.sun.tools.classfile.ConstantPoolException;
 import com.sun.tools.classfile.ConstantValue_attribute;
 import com.sun.tools.classfile.DefaultAttribute;
 import com.sun.tools.classfile.Deprecated_attribute;
+import com.sun.tools.classfile.Descriptor;
+import com.sun.tools.classfile.Descriptor.InvalidDescriptor;
 import com.sun.tools.classfile.EnclosingMethod_attribute;
 import com.sun.tools.classfile.Exceptions_attribute;
 import com.sun.tools.classfile.InnerClasses_attribute;
 import com.sun.tools.classfile.InnerClasses_attribute.Info;
 import com.sun.tools.classfile.LineNumberTable_attribute;
@@ -54,30 +58,37 @@
 import com.sun.tools.classfile.ModulePackages_attribute;
 import com.sun.tools.classfile.ModuleResolution_attribute;
 import com.sun.tools.classfile.ModuleTarget_attribute;
 import com.sun.tools.classfile.NestHost_attribute;
 import com.sun.tools.classfile.NestMembers_attribute;
+import com.sun.tools.classfile.Record_attribute;
 import com.sun.tools.classfile.RuntimeInvisibleAnnotations_attribute;
 import com.sun.tools.classfile.RuntimeInvisibleParameterAnnotations_attribute;
 import com.sun.tools.classfile.RuntimeInvisibleTypeAnnotations_attribute;
 import com.sun.tools.classfile.RuntimeParameterAnnotations_attribute;
 import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;
 import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;
 import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;
+import com.sun.tools.classfile.Signature;
 import com.sun.tools.classfile.Signature_attribute;
 import com.sun.tools.classfile.SourceDebugExtension_attribute;
 import com.sun.tools.classfile.SourceFile_attribute;
 import com.sun.tools.classfile.SourceID_attribute;
 import com.sun.tools.classfile.StackMapTable_attribute;
 import com.sun.tools.classfile.StackMap_attribute;
 import com.sun.tools.classfile.Synthetic_attribute;
+import com.sun.tools.classfile.Type;
 
 import static com.sun.tools.classfile.AccessFlags.*;
 
 import com.sun.tools.javac.util.Assert;
 import com.sun.tools.javac.util.StringUtils;
 
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+
 /*
  *  A writer for writing Attributes as text.
  *
  *  <p><b>This is NOT part of any supported API.
  *  If you write code that depends on this, you do so at your own risk.
@@ -124,13 +135,10 @@
         }
     }
 
     @Override
     public Void visitDefault(DefaultAttribute attr, Void ignore) {
-        if (attr.reason != null) {
-            report(attr.reason);
-        }
         byte[] data = attr.info;
         int i = 0;
         int j = 0;
         print("  ");
         try {
@@ -138,11 +146,15 @@
         } catch (ConstantPoolException e) {
             report(e);
             print("attribute name = #" + attr.attribute_name_index);
         }
         print(": ");
-        println("length = 0x" + toHex(attr.info.length));
+        print("length = 0x" + toHex(attr.info.length));
+        if (attr.reason != null) {
+            print(" (" + attr.reason + ")");
+        }
+        println();
 
         print("   ");
 
         while (i < data.length) {
             print(toHex(data[i], 2));
@@ -711,10 +723,90 @@
             throw new AssertionError(ex);
         }
         return null;
     }
 
+    @Override
+    public Void visitRecord(Record_attribute attr, Void p) {
+        println("Record:");
+        indent(+1);
+        for (Record_attribute.ComponentInfo componentInfo : attr.component_info_arr) {
+            Signature_attribute sigAttr = (Signature_attribute) componentInfo.attributes.get(Attribute.Signature);
+
+            if (sigAttr == null)
+                print(getJavaFieldType(componentInfo.descriptor));
+            else {
+                try {
+                    Type t = sigAttr.getParsedSignature().getType(constant_pool);
+                    print(getJavaName(t.toString()));
+                } catch (ConstantPoolException e) {
+                    // report error?
+                    // fall back on non-generic descriptor
+                    print(getJavaFieldType(componentInfo.descriptor));
+                }
+            }
+
+            print(" ");
+            try {
+                print(componentInfo.getName(constant_pool));
+            } catch (ConstantPoolException e) {
+                report(e);
+                return null;
+            }
+            print(";");
+            println();
+            indent(+1);
+            if (options.showDescriptors) {
+                println("descriptor: " + getValue(componentInfo.descriptor));
+            }
+            if (options.showAllAttrs) {
+                for (Attribute componentAttr: componentInfo.attributes)
+                    write(componentInfo, componentAttr, constant_pool);
+                println();
+            }
+            indent(-1);
+        }
+        indent(-1);
+        return null;
+    }
+
+    String getValue(Descriptor d) {
+        try {
+            return d.getValue(constant_pool);
+        } catch (ConstantPoolException e) {
+            return report(e);
+        }
+    }
+
+    void writeList(String prefix, Collection<?> items, String suffix) {
+        print(prefix);
+        String sep = "";
+        for (Object item: items) {
+            print(sep);
+            print(item);
+            sep = ", ";
+        }
+        print(suffix);
+    }
+
+    String getJavaFieldType(Descriptor d) {
+        try {
+            return getJavaName(d.getFieldType(constant_pool));
+        } catch (ConstantPoolException e) {
+            return report(e);
+        } catch (InvalidDescriptor e) {
+            return report(e);
+        }
+    }
+
+    void writeModifiers(Collection<String> items) {
+        for (Object item: items) {
+            print(item);
+            print(" ");
+        }
+    }
+
     @Override
     public Void visitRuntimeVisibleAnnotations(RuntimeVisibleAnnotations_attribute attr, Void ignore) {
         println("RuntimeVisibleAnnotations:");
         indent(+1);
         for (int i = 0; i < attr.annotations.length; i++) {

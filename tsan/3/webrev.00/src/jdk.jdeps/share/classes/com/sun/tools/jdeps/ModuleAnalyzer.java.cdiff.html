<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.jdeps/share/classes/com/sun/tools/jdeps/ModuleAnalyzer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JdepsTask.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ModuleInfoBuilder.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdeps/share/classes/com/sun/tools/jdeps/ModuleAnalyzer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,26 ***</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  package com.sun.tools.jdeps;
  
<span class="line-removed">- import static com.sun.tools.jdeps.Graph.*;</span>
  import static com.sun.tools.jdeps.JdepsFilter.DEFAULT_FILTER;
  import static com.sun.tools.jdeps.Module.*;
  import static java.lang.module.ModuleDescriptor.Requires.Modifier.*;
  import static java.util.stream.Collectors.*;
  
  import com.sun.tools.classfile.Dependency;
<span class="line-removed">- import com.sun.tools.jdeps.JdepsTask.BadArgs;</span>
  
  import java.io.IOException;
<span class="line-removed">- import java.io.OutputStream;</span>
  import java.io.PrintWriter;
  import java.lang.module.ModuleDescriptor;
<span class="line-removed">- import java.nio.file.Files;</span>
<span class="line-removed">- import java.nio.file.Path;</span>
<span class="line-removed">- import java.util.Collections;</span>
  import java.util.Comparator;
  import java.util.HashMap;
  import java.util.HashSet;
  import java.util.Map;
  import java.util.Optional;
<span class="line-new-header">--- 22,20 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,27 ***</span>
                  .flatMap(Optional::stream)
                  .collect(toMap(Function.identity(), ModuleDeps::new));
          }
      }
  
<span class="line-modified">!     public boolean run() throws IOException {</span>
          try {
<span class="line-modified">!             // compute &quot;requires transitive&quot; dependences</span>
<span class="line-modified">!             modules.values().forEach(ModuleDeps::computeRequiresTransitive);</span>
<span class="line-modified">! </span>
<span class="line-removed">-             modules.values().forEach(md -&gt; {</span>
                  // compute &quot;requires&quot; dependences
<span class="line-modified">!                 md.computeRequires();</span>
                  // apply transitive reduction and reports recommended requires.
<span class="line-modified">!                 md.analyzeDeps();</span>
<span class="line-modified">!             });</span>
          } finally {
              dependencyFinder.shutdown();
          }
          return true;
      }
  
      class ModuleDeps {
          final Module root;
          Set&lt;Module&gt; requiresTransitive;
          Set&lt;Module&gt; requires;
          Map&lt;String, Set&lt;String&gt;&gt; unusedQualifiedExports;
<span class="line-new-header">--- 72,36 ---</span>
                  .flatMap(Optional::stream)
                  .collect(toMap(Function.identity(), ModuleDeps::new));
          }
      }
  
<span class="line-modified">!     public boolean run(boolean ignoreMissingDeps) throws IOException {</span>
          try {
<span class="line-modified">!             for (ModuleDeps md: modules.values()) {</span>
<span class="line-modified">!                 // compute &quot;requires transitive&quot; dependences</span>
<span class="line-modified">!                 md.computeRequiresTransitive(ignoreMissingDeps);</span>
                  // compute &quot;requires&quot; dependences
<span class="line-modified">!                 md.computeRequires(ignoreMissingDeps);</span>
<span class="line-added">+                 // print module descriptor</span>
<span class="line-added">+                 md.printModuleDescriptor();</span>
<span class="line-added">+ </span>
                  // apply transitive reduction and reports recommended requires.
<span class="line-modified">!                 boolean ok = md.analyzeDeps();</span>
<span class="line-modified">!                 if (!ok) return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (ignoreMissingDeps &amp;&amp; md.hasMissingDependencies()) {</span>
<span class="line-added">+                     log.format(&quot;Warning: --ignore-missing-deps specified. Missing dependencies from %s are ignored%n&quot;,</span>
<span class="line-added">+                                md.root.name());</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
          } finally {
              dependencyFinder.shutdown();
          }
          return true;
      }
  
<span class="line-added">+ </span>
      class ModuleDeps {
          final Module root;
          Set&lt;Module&gt; requiresTransitive;
          Set&lt;Module&gt; requires;
          Map&lt;String, Set&lt;String&gt;&gt; unusedQualifiedExports;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,38 ***</span>
          }
  
          /**
           * Compute &#39;requires transitive&#39; dependences by analyzing API dependencies
           */
<span class="line-modified">!         private void computeRequiresTransitive() {</span>
              // record requires transitive
<span class="line-modified">!             this.requiresTransitive = computeRequires(true)</span>
                  .filter(m -&gt; !m.name().equals(JAVA_BASE))
                  .collect(toSet());
  
              trace(&quot;requires transitive: %s%n&quot;, requiresTransitive);
          }
  
<span class="line-modified">!         private void computeRequires() {</span>
<span class="line-modified">!             this.requires = computeRequires(false).collect(toSet());</span>
              trace(&quot;requires: %s%n&quot;, requires);
          }
  
<span class="line-modified">!         private Stream&lt;Module&gt; computeRequires(boolean apionly) {</span>
              // analyze all classes
<span class="line-removed">- </span>
              if (apionly) {
                  dependencyFinder.parseExportedAPIs(Stream.of(root));
              } else {
                  dependencyFinder.parse(Stream.of(root));
              }
  
              // find the modules of all the dependencies found
              return dependencyFinder.getDependences(root)
                          .map(Archive::getModule);
          }
  
          ModuleDescriptor descriptor() {
              return descriptor(requiresTransitive, requires);
          }
  
          private ModuleDescriptor descriptor(Set&lt;Module&gt; requiresTransitive,
<span class="line-new-header">--- 111,42 ---</span>
          }
  
          /**
           * Compute &#39;requires transitive&#39; dependences by analyzing API dependencies
           */
<span class="line-modified">!         private void computeRequiresTransitive(boolean ignoreMissingDeps) {</span>
              // record requires transitive
<span class="line-modified">!             this.requiresTransitive = computeRequires(true, ignoreMissingDeps)</span>
                  .filter(m -&gt; !m.name().equals(JAVA_BASE))
                  .collect(toSet());
  
              trace(&quot;requires transitive: %s%n&quot;, requiresTransitive);
          }
  
<span class="line-modified">!         private void computeRequires(boolean ignoreMissingDeps) {</span>
<span class="line-modified">!             this.requires = computeRequires(false, ignoreMissingDeps).collect(toSet());</span>
              trace(&quot;requires: %s%n&quot;, requires);
          }
  
<span class="line-modified">!         private Stream&lt;Module&gt; computeRequires(boolean apionly, boolean ignoreMissingDeps) {</span>
              // analyze all classes
              if (apionly) {
                  dependencyFinder.parseExportedAPIs(Stream.of(root));
              } else {
                  dependencyFinder.parse(Stream.of(root));
              }
  
              // find the modules of all the dependencies found
              return dependencyFinder.getDependences(root)
<span class="line-added">+                         .filter(a -&gt; !(ignoreMissingDeps &amp;&amp; Analyzer.notFound(a)))</span>
                          .map(Archive::getModule);
          }
  
<span class="line-added">+         boolean hasMissingDependencies() {</span>
<span class="line-added">+             return dependencyFinder.getDependences(root).anyMatch(Analyzer::notFound);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          ModuleDescriptor descriptor() {
              return descriptor(requiresTransitive, requires);
          }
  
          private ModuleDescriptor descriptor(Set&lt;Module&gt; requiresTransitive,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 194,16 ***</span>
          ModuleDescriptor reduced() {
              Graph&lt;Module&gt; g = buildReducedGraph();
              return descriptor(requiresTransitive, g.adjacentNodes(root));
          }
  
          /**
           * Apply transitive reduction on the resulting graph and reports
           * recommended requires.
           */
<span class="line-modified">!         private void analyzeDeps() {</span>
<span class="line-modified">!             printModuleDescriptor(log, root);</span>
  
              ModuleDescriptor analyzedDescriptor = descriptor();
              if (!matches(root.descriptor(), analyzedDescriptor)) {
                  log.format(&quot;  [Suggested module descriptor for %s]%n&quot;, root.name());
                  analyzedDescriptor.requires()
<span class="line-new-header">--- 201,34 ---</span>
          ModuleDescriptor reduced() {
              Graph&lt;Module&gt; g = buildReducedGraph();
              return descriptor(requiresTransitive, g.adjacentNodes(root));
          }
  
<span class="line-added">+         private void showMissingDeps() {</span>
<span class="line-added">+             // build the analyzer if there are missing dependences</span>
<span class="line-added">+             Analyzer analyzer = new Analyzer(configuration, Analyzer.Type.CLASS, DEFAULT_FILTER);</span>
<span class="line-added">+             analyzer.run(Set.of(root), dependencyFinder.locationToArchive());</span>
<span class="line-added">+             log.println(&quot;Error: Missing dependencies: classes not found from the module path.&quot;);</span>
<span class="line-added">+             Analyzer.Visitor visitor = new Analyzer.Visitor() {</span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public void visitDependence(String origin, Archive originArchive, String target, Archive targetArchive) {</span>
<span class="line-added">+                     log.format(&quot;   %-50s -&gt; %-50s %s%n&quot;, origin, target, targetArchive.getName());</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             };</span>
<span class="line-added">+             analyzer.visitDependences(root, visitor, Analyzer.Type.VERBOSE, Analyzer::notFound);</span>
<span class="line-added">+             log.println();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          /**
           * Apply transitive reduction on the resulting graph and reports
           * recommended requires.
           */
<span class="line-modified">!         private boolean analyzeDeps() {</span>
<span class="line-modified">!             if (requires.stream().anyMatch(m -&gt; m == UNNAMED_MODULE)) {</span>
<span class="line-added">+                 showMissingDeps();</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             }</span>
  
              ModuleDescriptor analyzedDescriptor = descriptor();
              if (!matches(root.descriptor(), analyzedDescriptor)) {
                  log.format(&quot;  [Suggested module descriptor for %s]%n&quot;, root.name());
                  analyzedDescriptor.requires()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 221,10 ***</span>
<span class="line-new-header">--- 246,11 ---</span>
                      .forEach(req -&gt; log.format(&quot;    requires %s;%n&quot;, req));
              }
  
              checkQualifiedExports();
              log.println();
<span class="line-added">+             return true;</span>
          }
  
          private void checkQualifiedExports() {
              // detect any qualified exports not used by the target module
              unusedQualifiedExports = unusedQualifiedExports();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 237,10 ***</span>
<span class="line-new-header">--- 263,14 ---</span>
                      unusedQualifiedExports.get(pn).stream()
                          .sorted()
                          .collect(joining(&quot;,&quot;))));
          }
  
<span class="line-added">+         void printModuleDescriptor() {</span>
<span class="line-added">+             printModuleDescriptor(log, root);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          private void printModuleDescriptor(PrintWriter out, Module module) {
              ModuleDescriptor descriptor = module.descriptor();
              out.format(&quot;%s (%s)%n&quot;, descriptor.name(), module.location());
  
              if (descriptor.name().equals(JAVA_BASE))
</pre>
<center><a href="JdepsTask.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ModuleInfoBuilder.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
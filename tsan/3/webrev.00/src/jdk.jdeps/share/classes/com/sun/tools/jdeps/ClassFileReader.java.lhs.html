<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jdeps/share/classes/com/sun/tools/jdeps/ClassFileReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.jdeps;
 27 
 28 import com.sun.tools.classfile.AccessFlags;
 29 import com.sun.tools.classfile.ClassFile;
 30 import com.sun.tools.classfile.ConstantPoolException;
 31 import com.sun.tools.classfile.Dependencies.ClassFileError;
 32 
 33 import java.io.Closeable;
 34 import java.io.File;
 35 import java.io.FileNotFoundException;
 36 import java.io.IOException;
 37 import java.io.InputStream;
 38 import java.io.UncheckedIOException;
 39 import java.nio.file.FileSystem;
 40 import java.nio.file.FileSystems;
 41 import java.nio.file.Files;
 42 import java.nio.file.Path;
 43 import java.util.ArrayList;
 44 import java.util.Collections;
 45 import java.util.Enumeration;
 46 import java.util.Iterator;
 47 import java.util.List;
 48 import java.util.NoSuchElementException;
 49 import java.util.Set;
 50 import java.util.jar.JarEntry;
 51 import java.util.jar.JarFile;
 52 import java.util.stream.Collectors;
 53 import java.util.stream.Stream;
 54 import java.util.zip.ZipFile;
 55 
 56 /**
 57  * ClassFileReader reads ClassFile(s) of a given path that can be
 58  * a .class file, a directory, or a JAR file.
 59  */
 60 public class ClassFileReader implements Closeable {
<a name="2" id="anc2"></a><span class="line-removed"> 61     /**</span>
<span class="line-removed"> 62      * Returns a ClassFileReader instance of a given path.</span>
<span class="line-removed"> 63      */</span>
<span class="line-removed"> 64     public static ClassFileReader newInstance(Path path) throws IOException {</span>
<span class="line-removed"> 65         return newInstance(path, null);</span>
<span class="line-removed"> 66     }</span>
<span class="line-removed"> 67 </span>
 68     /**
 69      * Returns a ClassFileReader instance of a given path.
 70      */
 71     public static ClassFileReader newInstance(Path path, Runtime.Version version) throws IOException {
 72         if (Files.notExists(path)) {
 73             throw new FileNotFoundException(path.toString());
 74         }
 75 
 76         if (Files.isDirectory(path)) {
 77             return new DirectoryReader(path);
 78         } else if (path.getFileName().toString().endsWith(&quot;.jar&quot;)) {
 79             return new JarFileReader(path, version);
 80         } else {
 81             return new ClassFileReader(path);
 82         }
 83     }
 84 
 85     /**
 86      * Returns a ClassFileReader instance of a given FileSystem and path.
 87      *
 88      * This method is used for reading classes from jrtfs.
 89      */
 90     public static ClassFileReader newInstance(FileSystem fs, Path path) throws IOException {
 91         return new DirectoryReader(fs, path);
 92     }
 93 
 94     protected final Path path;
 95     protected final String baseFileName;
 96     protected Set&lt;String&gt; entries; // binary names
 97 
 98     protected final List&lt;String&gt; skippedEntries = new ArrayList&lt;&gt;();
 99     protected ClassFileReader(Path path) {
100         this.path = path;
101         this.baseFileName = path.getFileName() != null
102                                 ? path.getFileName().toString()
103                                 : path.toString();
104     }
105 
106     public String getFileName() {
107         return baseFileName;
108     }
109 
110     public List&lt;String&gt; skippedEntries() {
111         return skippedEntries;
112     }
113 
114     /**
115      * Returns all entries in this archive.
116      */
117     public Set&lt;String&gt; entries() {
118         Set&lt;String&gt; es = this.entries;
119         if (es == null) {
120             // lazily scan the entries
121             this.entries = scan();
122         }
123         return this.entries;
124     }
125 
126     /**
127      * Returns the ClassFile matching the given binary name
128      * or a fully-qualified class name.
129      */
130     public ClassFile getClassFile(String name) throws IOException {
131         if (name.indexOf(&#39;.&#39;) &gt; 0) {
132             int i = name.lastIndexOf(&#39;.&#39;);
133             String pathname = name.replace(&#39;.&#39;, File.separatorChar) + &quot;.class&quot;;
134             if (baseFileName.equals(pathname) ||
135                     baseFileName.equals(pathname.substring(0, i) + &quot;$&quot; +
136                                         pathname.substring(i+1, pathname.length()))) {
137                 return readClassFile(path);
138             }
139         } else {
140             if (baseFileName.equals(name.replace(&#39;/&#39;, File.separatorChar) + &quot;.class&quot;)) {
141                 return readClassFile(path);
142             }
143         }
144         return null;
145     }
146 
147     public Iterable&lt;ClassFile&gt; getClassFiles() throws IOException {
148         return FileIterator::new;
149     }
150 
151     protected ClassFile readClassFile(Path p) throws IOException {
152         InputStream is = null;
153         try {
154             is = Files.newInputStream(p);
155             return ClassFile.read(is);
156         } catch (ConstantPoolException e) {
157             throw new ClassFileError(e);
158         } finally {
159             if (is != null) {
160                 is.close();
161             }
162         }
163     }
164 
165     protected Set&lt;String&gt; scan() {
166         try {
167             ClassFile cf = ClassFile.read(path);
168             String name = cf.access_flags.is(AccessFlags.ACC_MODULE)
169                 ? &quot;module-info&quot; : cf.getName();
170             return Collections.singleton(name);
171         } catch (ConstantPoolException|IOException e) {
172             throw new ClassFileError(e);
173         }
174     }
175 
176     static boolean isClass(Path file) {
177         String fn = file.getFileName().toString();
178         return fn.endsWith(&quot;.class&quot;);
179     }
180 
181     @Override
182     public void close() throws IOException {
183     }
184 
185     class FileIterator implements Iterator&lt;ClassFile&gt; {
186         int count;
187         FileIterator() {
188             this.count = 0;
189         }
190         public boolean hasNext() {
191             return count == 0 &amp;&amp; baseFileName.endsWith(&quot;.class&quot;);
192         }
193 
194         public ClassFile next() {
195             if (!hasNext()) {
196                 throw new NoSuchElementException();
197             }
198             try {
199                 ClassFile cf = readClassFile(path);
200                 count++;
201                 return cf;
202             } catch (IOException e) {
203                 throw new ClassFileError(e);
204             }
205         }
206 
207         public void remove() {
208             throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
209         }
210     }
211 
212     public String toString() {
213         return path.toString();
214     }
215 
216     private static class DirectoryReader extends ClassFileReader {
217         protected final String fsSep;
218         DirectoryReader(Path path) throws IOException {
219             this(FileSystems.getDefault(), path);
220         }
221         DirectoryReader(FileSystem fs, Path path) throws IOException {
222             super(path);
223             this.fsSep = fs.getSeparator();
224         }
225 
226         protected Set&lt;String&gt; scan() {
227             try (Stream&lt;Path&gt; stream = Files.walk(path, Integer.MAX_VALUE)) {
228                 return stream.filter(ClassFileReader::isClass)
229                              .map(path::relativize)
230                              .map(Path::toString)
231                              .map(p -&gt; p.replace(File.separatorChar, &#39;/&#39;))
232                              .collect(Collectors.toSet());
233             } catch (IOException e) {
234                 throw new UncheckedIOException(e);
235             }
236         }
237 
238         public ClassFile getClassFile(String name) throws IOException {
239             if (name.indexOf(&#39;.&#39;) &gt; 0) {
240                 int i = name.lastIndexOf(&#39;.&#39;);
241                 String pathname = name.replace(&quot;.&quot;, fsSep) + &quot;.class&quot;;
242                 Path p = path.resolve(pathname);
243                 if (Files.notExists(p)) {
244                     p = path.resolve(pathname.substring(0, i) + &quot;$&quot; +
245                             pathname.substring(i+1, pathname.length()));
246                 }
247                 if (Files.exists(p)) {
248                     return readClassFile(p);
249                 }
250             } else {
251                 Path p = path.resolve(name + &quot;.class&quot;);
252                 if (Files.exists(p)) {
253                     return readClassFile(p);
254                 }
255             }
256             return null;
257         }
258 
259         public Iterable&lt;ClassFile&gt; getClassFiles() throws IOException {
260             final Iterator&lt;ClassFile&gt; iter = new DirectoryIterator();
261             return () -&gt; iter;
262         }
263 
264         class DirectoryIterator implements Iterator&lt;ClassFile&gt; {
265             private final List&lt;Path&gt; entries;
266             private int index = 0;
267             DirectoryIterator() throws IOException {
268                 List&lt;Path&gt; paths = null;
269                 try (Stream&lt;Path&gt; stream = Files.walk(path, Integer.MAX_VALUE)) {
270                     paths = stream.filter(ClassFileReader::isClass)
271                                   .collect(Collectors.toList());
272                 }
273                 this.entries = paths;
274                 this.index = 0;
275             }
276 
277             public boolean hasNext() {
278                 return index != entries.size();
279             }
280 
281             public ClassFile next() {
282                 if (!hasNext()) {
283                     throw new NoSuchElementException();
284                 }
285                 Path path = entries.get(index++);
286                 try {
287                     return readClassFile(path);
288                 } catch (IOException e) {
289                     throw new ClassFileError(e);
290                 }
291             }
292 
293             public void remove() {
294                 throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
295             }
296         }
297     }
298 
299     static class JarFileReader extends ClassFileReader {
300         private final JarFile jarfile;
301         private final Runtime.Version version;
302 
303         JarFileReader(Path path, Runtime.Version version) throws IOException {
304             this(path, openJarFile(path.toFile(), version), version);
305         }
306 
307         JarFileReader(Path path, JarFile jf, Runtime.Version version) throws IOException {
308             super(path);
309             this.jarfile = jf;
310             this.version = version;
311         }
312 
313         @Override
314         public void close() throws IOException {
315             jarfile.close();
316         }
317 
318         private static JarFile openJarFile(File f, Runtime.Version version)
319                 throws IOException {
320             JarFile jf;
321             if (version == null) {
322                 jf = new JarFile(f, false);
323                 if (jf.isMultiRelease()) {
324                     throw new MultiReleaseException(&quot;err.multirelease.option.notfound&quot;, f.getName());
325                 }
326             } else {
327                 jf = new JarFile(f, false, ZipFile.OPEN_READ, version);
328             }
329             return jf;
330         }
331 
332         protected Set&lt;String&gt; scan() {
333             try (JarFile jf = openJarFile(path.toFile(), version)) {
334                 return jf.versionedStream().map(JarEntry::getName)
335                          .filter(n -&gt; n.endsWith(&quot;.class&quot;))
336                          .collect(Collectors.toSet());
337             } catch (IOException e) {
338                 throw new UncheckedIOException(e);
339             }
340         }
341 
342         public ClassFile getClassFile(String name) throws IOException {
343             if (name.indexOf(&#39;.&#39;) &gt; 0) {
344                 int i = name.lastIndexOf(&#39;.&#39;);
345                 String entryName = name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;;
346                 JarEntry e = jarfile.getJarEntry(entryName);
347                 if (e == null) {
348                     e = jarfile.getJarEntry(entryName.substring(0, i) + &quot;$&quot;
349                             + entryName.substring(i + 1, entryName.length()));
350                 }
351                 if (e != null) {
352                     return readClassFile(jarfile, e);
353                 }
354             } else {
355                 JarEntry e = jarfile.getJarEntry(name + &quot;.class&quot;);
356                 if (e != null) {
357                     return readClassFile(jarfile, e);
358                 }
359             }
360             return null;
361         }
362 
363         protected ClassFile readClassFile(JarFile jarfile, JarEntry e) throws IOException {
364             try (InputStream is = jarfile.getInputStream(e)) {
365                 ClassFile cf = ClassFile.read(is);
366                 if (jarfile.isMultiRelease()) {
367                     VersionHelper.add(jarfile, e, cf);
368                 }
369                 return cf;
370             } catch (ConstantPoolException ex) {
371                 throw new ClassFileError(ex);
372             }
373         }
374 
375         public Iterable&lt;ClassFile&gt; getClassFiles() throws IOException {
376             final Iterator&lt;ClassFile&gt; iter = new JarFileIterator(this, jarfile);
377             return () -&gt; iter;
378         }
379     }
380 
381     class JarFileIterator implements Iterator&lt;ClassFile&gt; {
382         protected final JarFileReader reader;
383         protected Iterator&lt;JarEntry&gt; entries;
384         protected JarFile jf;
385         protected JarEntry nextEntry;
386         protected ClassFile cf;
387         JarFileIterator(JarFileReader reader) {
388             this(reader, null);
389         }
390         JarFileIterator(JarFileReader reader, JarFile jarfile) {
391             this.reader = reader;
392             setJarFile(jarfile);
393         }
394 
395         void setJarFile(JarFile jarfile) {
396             if (jarfile == null) return;
397 
398             this.jf = jarfile;
399             this.entries = jarfile.versionedStream().iterator();
400             this.nextEntry = nextEntry();
401         }
402 
403         public boolean hasNext() {
404             if (nextEntry != null &amp;&amp; cf != null) {
405                 return true;
406             }
407             while (nextEntry != null) {
408                 try {
409                     cf = reader.readClassFile(jf, nextEntry);
410                     return true;
411                 } catch (ClassFileError | IOException ex) {
412                     skippedEntries.add(String.format(&quot;%s: %s (%s)&quot;,
413                                                      ex.getMessage(),
414                                                      nextEntry.getName(),
415                                                      jf.getName()));
416                 }
417                 nextEntry = nextEntry();
418             }
419             return false;
420         }
421 
422         public ClassFile next() {
423             if (!hasNext()) {
424                 throw new NoSuchElementException();
425             }
426             ClassFile classFile = cf;
427             cf = null;
428             nextEntry = nextEntry();
429             return classFile;
430         }
431 
432         protected JarEntry nextEntry() {
433             while (entries.hasNext()) {
434                 JarEntry e = entries.next();
435                 String name = e.getName();
436                 if (name.endsWith(&quot;.class&quot;)) {
437                     return e;
438                 }
439             }
440             return null;
441         }
442 
443         public void remove() {
444             throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
445         }
446     }
447     private static final String MODULE_INFO = &quot;module-info.class&quot;;
448 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
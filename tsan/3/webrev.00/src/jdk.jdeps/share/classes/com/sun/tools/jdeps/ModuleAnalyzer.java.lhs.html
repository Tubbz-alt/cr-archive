<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jdeps/share/classes/com/sun/tools/jdeps/ModuleAnalyzer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package com.sun.tools.jdeps;
 26 
<a name="2" id="anc2"></a><span class="line-removed"> 27 import static com.sun.tools.jdeps.Graph.*;</span>
 28 import static com.sun.tools.jdeps.JdepsFilter.DEFAULT_FILTER;
 29 import static com.sun.tools.jdeps.Module.*;
 30 import static java.lang.module.ModuleDescriptor.Requires.Modifier.*;
 31 import static java.util.stream.Collectors.*;
 32 
 33 import com.sun.tools.classfile.Dependency;
<a name="3" id="anc3"></a><span class="line-removed"> 34 import com.sun.tools.jdeps.JdepsTask.BadArgs;</span>
 35 
 36 import java.io.IOException;
<a name="4" id="anc4"></a><span class="line-removed"> 37 import java.io.OutputStream;</span>
 38 import java.io.PrintWriter;
 39 import java.lang.module.ModuleDescriptor;
<a name="5" id="anc5"></a><span class="line-removed"> 40 import java.nio.file.Files;</span>
<span class="line-removed"> 41 import java.nio.file.Path;</span>
<span class="line-removed"> 42 import java.util.Collections;</span>
 43 import java.util.Comparator;
 44 import java.util.HashMap;
 45 import java.util.HashSet;
 46 import java.util.Map;
 47 import java.util.Optional;
 48 import java.util.Set;
 49 import java.util.function.Function;
 50 import java.util.stream.Collectors;
 51 import java.util.stream.Stream;
 52 
 53 /**
 54  * Analyze module dependences and compare with module descriptor.
 55  * Also identify any qualified exports not used by the target module.
 56  */
 57 public class ModuleAnalyzer {
 58     private static final String JAVA_BASE = &quot;java.base&quot;;
 59 
 60     private final JdepsConfiguration configuration;
 61     private final PrintWriter log;
 62     private final DependencyFinder dependencyFinder;
 63     private final Map&lt;Module, ModuleDeps&gt; modules;
 64 
 65     public ModuleAnalyzer(JdepsConfiguration config,
 66                           PrintWriter log,
 67                           Set&lt;String&gt; names) {
 68         this.configuration = config;
 69         this.log = log;
 70 
 71         this.dependencyFinder = new DependencyFinder(config, DEFAULT_FILTER);
 72         if (names.isEmpty()) {
 73             this.modules = configuration.rootModules().stream()
 74                 .collect(toMap(Function.identity(), ModuleDeps::new));
 75         } else {
 76             this.modules = names.stream()
 77                 .map(configuration::findModule)
 78                 .flatMap(Optional::stream)
 79                 .collect(toMap(Function.identity(), ModuleDeps::new));
 80         }
 81     }
 82 
<a name="6" id="anc6"></a><span class="line-modified"> 83     public boolean run() throws IOException {</span>
 84         try {
<a name="7" id="anc7"></a><span class="line-modified"> 85             // compute &quot;requires transitive&quot; dependences</span>
<span class="line-modified"> 86             modules.values().forEach(ModuleDeps::computeRequiresTransitive);</span>
<span class="line-modified"> 87 </span>
<span class="line-removed"> 88             modules.values().forEach(md -&gt; {</span>
 89                 // compute &quot;requires&quot; dependences
<a name="8" id="anc8"></a><span class="line-modified"> 90                 md.computeRequires();</span>



 91                 // apply transitive reduction and reports recommended requires.
<a name="9" id="anc9"></a><span class="line-modified"> 92                 md.analyzeDeps();</span>
<span class="line-modified"> 93             });</span>






 94         } finally {
 95             dependencyFinder.shutdown();
 96         }
 97         return true;
 98     }
 99 
<a name="10" id="anc10"></a>
100     class ModuleDeps {
101         final Module root;
102         Set&lt;Module&gt; requiresTransitive;
103         Set&lt;Module&gt; requires;
104         Map&lt;String, Set&lt;String&gt;&gt; unusedQualifiedExports;
105 
106         ModuleDeps(Module root) {
107             this.root = root;
108         }
109 
110         /**
111          * Compute &#39;requires transitive&#39; dependences by analyzing API dependencies
112          */
<a name="11" id="anc11"></a><span class="line-modified">113         private void computeRequiresTransitive() {</span>
114             // record requires transitive
<a name="12" id="anc12"></a><span class="line-modified">115             this.requiresTransitive = computeRequires(true)</span>
116                 .filter(m -&gt; !m.name().equals(JAVA_BASE))
117                 .collect(toSet());
118 
119             trace(&quot;requires transitive: %s%n&quot;, requiresTransitive);
120         }
121 
<a name="13" id="anc13"></a><span class="line-modified">122         private void computeRequires() {</span>
<span class="line-modified">123             this.requires = computeRequires(false).collect(toSet());</span>
124             trace(&quot;requires: %s%n&quot;, requires);
125         }
126 
<a name="14" id="anc14"></a><span class="line-modified">127         private Stream&lt;Module&gt; computeRequires(boolean apionly) {</span>
128             // analyze all classes
<a name="15" id="anc15"></a><span class="line-removed">129 </span>
130             if (apionly) {
131                 dependencyFinder.parseExportedAPIs(Stream.of(root));
132             } else {
133                 dependencyFinder.parse(Stream.of(root));
134             }
135 
136             // find the modules of all the dependencies found
137             return dependencyFinder.getDependences(root)
<a name="16" id="anc16"></a>
138                         .map(Archive::getModule);
139         }
140 
<a name="17" id="anc17"></a>



141         ModuleDescriptor descriptor() {
142             return descriptor(requiresTransitive, requires);
143         }
144 
145         private ModuleDescriptor descriptor(Set&lt;Module&gt; requiresTransitive,
146                                             Set&lt;Module&gt; requires) {
147 
148             ModuleDescriptor.Builder builder = ModuleDescriptor.newModule(root.name());
149 
150             if (!root.name().equals(JAVA_BASE))
151                 builder.requires(Set.of(MANDATED), JAVA_BASE);
152 
153             requiresTransitive.stream()
154                 .filter(m -&gt; !m.name().equals(JAVA_BASE))
155                 .map(Module::name)
156                 .forEach(mn -&gt; builder.requires(Set.of(TRANSITIVE), mn));
157 
158             requires.stream()
159                 .filter(m -&gt; !requiresTransitive.contains(m))
160                 .filter(m -&gt; !m.name().equals(JAVA_BASE))
161                 .map(Module::name)
162                 .forEach(mn -&gt; builder.requires(mn));
163 
164             return builder.build();
165         }
166 
167         private Graph&lt;Module&gt; buildReducedGraph() {
168             ModuleGraphBuilder rpBuilder = new ModuleGraphBuilder(configuration);
169             rpBuilder.addModule(root);
170             requiresTransitive.stream()
171                           .forEach(m -&gt; rpBuilder.addEdge(root, m));
172 
173             // requires transitive graph
174             Graph&lt;Module&gt; rbg = rpBuilder.build().reduce();
175 
176             ModuleGraphBuilder gb = new ModuleGraphBuilder(configuration);
177             gb.addModule(root);
178             requires.stream()
179                     .forEach(m -&gt; gb.addEdge(root, m));
180 
181             // transitive reduction
182             Graph&lt;Module&gt; newGraph = gb.buildGraph().reduce(rbg);
183             if (DEBUG) {
184                 System.err.println(&quot;after transitive reduction: &quot;);
185                 newGraph.printGraph(log);
186             }
187             return newGraph;
188         }
189 
190         /**
191          * Apply the transitive reduction on the module graph
192          * and returns the corresponding ModuleDescriptor
193          */
194         ModuleDescriptor reduced() {
195             Graph&lt;Module&gt; g = buildReducedGraph();
196             return descriptor(requiresTransitive, g.adjacentNodes(root));
197         }
198 
<a name="18" id="anc18"></a>














199         /**
200          * Apply transitive reduction on the resulting graph and reports
201          * recommended requires.
202          */
<a name="19" id="anc19"></a><span class="line-modified">203         private void analyzeDeps() {</span>
<span class="line-modified">204             printModuleDescriptor(log, root);</span>



205 
206             ModuleDescriptor analyzedDescriptor = descriptor();
207             if (!matches(root.descriptor(), analyzedDescriptor)) {
208                 log.format(&quot;  [Suggested module descriptor for %s]%n&quot;, root.name());
209                 analyzedDescriptor.requires()
210                     .stream()
211                     .sorted(Comparator.comparing(ModuleDescriptor.Requires::name))
212                     .forEach(req -&gt; log.format(&quot;    requires %s;%n&quot;, req));
213             }
214 
215             ModuleDescriptor reduced = reduced();
216             if (!matches(root.descriptor(), reduced)) {
217                 log.format(&quot;  [Transitive reduced graph for %s]%n&quot;, root.name());
218                 reduced.requires()
219                     .stream()
220                     .sorted(Comparator.comparing(ModuleDescriptor.Requires::name))
221                     .forEach(req -&gt; log.format(&quot;    requires %s;%n&quot;, req));
222             }
223 
224             checkQualifiedExports();
225             log.println();
<a name="20" id="anc20"></a>
226         }
227 
228         private void checkQualifiedExports() {
229             // detect any qualified exports not used by the target module
230             unusedQualifiedExports = unusedQualifiedExports();
231             if (!unusedQualifiedExports.isEmpty())
232                 log.format(&quot;  [Unused qualified exports in %s]%n&quot;, root.name());
233 
234             unusedQualifiedExports.keySet().stream()
235                 .sorted()
236                 .forEach(pn -&gt; log.format(&quot;    exports %s to %s%n&quot;, pn,
237                     unusedQualifiedExports.get(pn).stream()
238                         .sorted()
239                         .collect(joining(&quot;,&quot;))));
240         }
241 
<a name="21" id="anc21"></a>



242         private void printModuleDescriptor(PrintWriter out, Module module) {
243             ModuleDescriptor descriptor = module.descriptor();
244             out.format(&quot;%s (%s)%n&quot;, descriptor.name(), module.location());
245 
246             if (descriptor.name().equals(JAVA_BASE))
247                 return;
248 
249             out.println(&quot;  [Module descriptor]&quot;);
250             descriptor.requires()
251                 .stream()
252                 .sorted(Comparator.comparing(ModuleDescriptor.Requires::name))
253                 .forEach(req -&gt; out.format(&quot;    requires %s;%n&quot;, req));
254         }
255 
256 
257         /**
258          * Detects any qualified exports not used by the target module.
259          */
260         private Map&lt;String, Set&lt;String&gt;&gt; unusedQualifiedExports() {
261             Map&lt;String, Set&lt;String&gt;&gt; unused = new HashMap&lt;&gt;();
262 
263             // build the qualified exports map
264             Map&lt;String, Set&lt;String&gt;&gt; qualifiedExports =
265                 root.exports().entrySet().stream()
266                     .filter(e -&gt; !e.getValue().isEmpty())
267                     .map(Map.Entry::getKey)
268                     .collect(toMap(Function.identity(), _k -&gt; new HashSet&lt;&gt;()));
269 
270             Set&lt;Module&gt; mods = new HashSet&lt;&gt;();
271             root.exports().values()
272                 .stream()
273                 .flatMap(Set::stream)
274                 .forEach(target -&gt; configuration.findModule(target)
275                     .ifPresentOrElse(mods::add,
276                         () -&gt; log.format(&quot;Warning: %s not found%n&quot;, target))
277                 );
278 
279             // parse all target modules
280             dependencyFinder.parse(mods.stream());
281 
282             // adds to the qualified exports map if a module references it
283             mods.stream().forEach(m -&gt;
284                 m.getDependencies()
285                     .map(Dependency.Location::getPackageName)
286                     .filter(qualifiedExports::containsKey)
287                     .forEach(pn -&gt; qualifiedExports.get(pn).add(m.name())));
288 
289             // compare with the exports from ModuleDescriptor
290             Set&lt;String&gt; staleQualifiedExports =
291                 qualifiedExports.keySet().stream()
292                     .filter(pn -&gt; !qualifiedExports.get(pn).equals(root.exports().get(pn)))
293                     .collect(toSet());
294 
295             if (!staleQualifiedExports.isEmpty()) {
296                 for (String pn : staleQualifiedExports) {
297                     Set&lt;String&gt; targets = new HashSet&lt;&gt;(root.exports().get(pn));
298                     targets.removeAll(qualifiedExports.get(pn));
299                     unused.put(pn, targets);
300                 }
301             }
302             return unused;
303         }
304     }
305 
306     private boolean matches(ModuleDescriptor md, ModuleDescriptor other) {
307         // build requires transitive from ModuleDescriptor
308         Set&lt;ModuleDescriptor.Requires&gt; reqTransitive = md.requires().stream()
309             .filter(req -&gt; req.modifiers().contains(TRANSITIVE))
310             .collect(toSet());
311         Set&lt;ModuleDescriptor.Requires&gt; otherReqTransitive = other.requires().stream()
312             .filter(req -&gt; req.modifiers().contains(TRANSITIVE))
313             .collect(toSet());
314 
315         if (!reqTransitive.equals(otherReqTransitive)) {
316             trace(&quot;mismatch requires transitive: %s%n&quot;, reqTransitive);
317             return false;
318         }
319 
320         Set&lt;ModuleDescriptor.Requires&gt; unused = md.requires().stream()
321             .filter(req -&gt; !other.requires().contains(req))
322             .collect(Collectors.toSet());
323 
324         if (!unused.isEmpty()) {
325             trace(&quot;mismatch requires: %s%n&quot;, unused);
326             return false;
327         }
328         return true;
329     }
330 
331     // ---- for testing purpose
332     public ModuleDescriptor[] descriptors(String name) {
333         ModuleDeps moduleDeps = modules.keySet().stream()
334             .filter(m -&gt; m.name().equals(name))
335             .map(modules::get)
336             .findFirst().get();
337 
338         ModuleDescriptor[] descriptors = new ModuleDescriptor[3];
339         descriptors[0] = moduleDeps.root.descriptor();
340         descriptors[1] = moduleDeps.descriptor();
341         descriptors[2] = moduleDeps.reduced();
342         return descriptors;
343     }
344 
345     public Map&lt;String, Set&lt;String&gt;&gt; unusedQualifiedExports(String name) {
346         ModuleDeps moduleDeps = modules.keySet().stream()
347             .filter(m -&gt; m.name().equals(name))
348             .map(modules::get)
349             .findFirst().get();
350         return moduleDeps.unusedQualifiedExports;
351     }
352 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jdeps/share/classes/com/sun/tools/jdeps/ModuleInfoBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ModuleAnalyzer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="resources/jdeps.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdeps/share/classes/com/sun/tools/jdeps/ModuleInfoBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 81             .collect(toList());
 82 
 83         // automatic module to convert to normal module
 84         this.automaticToNormalModule = ModuleFinder.of(paths.toArray(new Path[0]))
 85                 .findAll().stream()
 86                 .map(configuration::toModule)
 87                 .collect(toMap(Function.identity(), Function.identity()));
 88 
 89         Optional&lt;Module&gt; om = automaticToNormalModule.keySet().stream()
 90                                     .filter(m -&gt; !m.descriptor().isAutomatic())
 91                                     .findAny();
 92         if (om.isPresent()) {
 93             throw new UncheckedBadArgs(new BadArgs(&quot;err.genmoduleinfo.not.jarfile&quot;,
 94                                                    om.get().getPathName()));
 95         }
 96         if (automaticToNormalModule.isEmpty()) {
 97             throw new UncheckedBadArgs(new BadArgs(&quot;err.invalid.path&quot;, args));
 98         }
 99     }
100 
<span class="line-modified">101     public boolean run() throws IOException {</span>
102         try {
103             // pass 1: find API dependencies
104             Map&lt;Archive, Set&lt;Archive&gt;&gt; requiresTransitive = computeRequiresTransitive();
105 
106             // pass 2: analyze all class dependences
107             dependencyFinder.parse(automaticModules().stream());
108 
109             analyzer.run(automaticModules(), dependencyFinder.locationToArchive());
110 
<span class="line-removed">111             boolean missingDeps = false;</span>
112             for (Module m : automaticModules()) {
113                 Set&lt;Archive&gt; apiDeps = requiresTransitive.containsKey(m)
114                                             ? requiresTransitive.get(m)
115                                             : Collections.emptySet();
116 
<span class="line-modified">117                 Path file = outputdir.resolve(m.name()).resolve(&quot;module-info.java&quot;);</span>







118 
119                 // computes requires and requires transitive
<span class="line-modified">120                 Module normalModule = toNormalModule(m, apiDeps);</span>
121                 if (normalModule != null) {
122                     automaticToNormalModule.put(m, normalModule);
123 
124                     // generate module-info.java
<span class="line-modified">125                     System.out.format(&quot;writing to %s%n&quot;, file);</span>






126                     writeModuleInfo(file,  normalModule.descriptor());
127                 } else {
128                     // find missing dependences
<span class="line-modified">129                     System.out.format(&quot;Missing dependence: %s not generated%n&quot;, file);</span>
<span class="line-removed">130                     missingDeps = true;</span>
131                 }
132             }
133 
<span class="line-removed">134             return !missingDeps;</span>
135         } finally {
136             dependencyFinder.shutdown();
137         }

138     }
139 
<span class="line-modified">140     private Module toNormalModule(Module module, Set&lt;Archive&gt; requiresTransitive)</span>
141         throws IOException
142     {
143         // done analysis
144         module.close();
145 
<span class="line-modified">146         if (analyzer.requires(module).anyMatch(Analyzer::notFound)) {</span>
147             // missing dependencies
148             return null;
149         }
150 
151         Map&lt;String, Boolean&gt; requires = new HashMap&lt;&gt;();
152         requiresTransitive.stream()

153             .map(Archive::getModule)
154             .forEach(m -&gt; requires.put(m.name(), Boolean.TRUE));
155 
156         analyzer.requires(module)

157             .map(Archive::getModule)
158             .forEach(d -&gt; requires.putIfAbsent(d.name(), Boolean.FALSE));
159 
160         return module.toNormalModule(requires);
161     }
162 
163     /**
164      * Returns the stream of resulting modules
165      */
166     Stream&lt;Module&gt; modules() {
167         return automaticToNormalModule.values().stream();
168     }
169 
170     /**
171      * Returns the stream of resulting ModuleDescriptors
172      */
173     public Stream&lt;ModuleDescriptor&gt; descriptors() {
174         return automaticToNormalModule.entrySet().stream()
175                     .map(Map.Entry::getValue)
176                     .map(Module::descriptor);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 81             .collect(toList());
 82 
 83         // automatic module to convert to normal module
 84         this.automaticToNormalModule = ModuleFinder.of(paths.toArray(new Path[0]))
 85                 .findAll().stream()
 86                 .map(configuration::toModule)
 87                 .collect(toMap(Function.identity(), Function.identity()));
 88 
 89         Optional&lt;Module&gt; om = automaticToNormalModule.keySet().stream()
 90                                     .filter(m -&gt; !m.descriptor().isAutomatic())
 91                                     .findAny();
 92         if (om.isPresent()) {
 93             throw new UncheckedBadArgs(new BadArgs(&quot;err.genmoduleinfo.not.jarfile&quot;,
 94                                                    om.get().getPathName()));
 95         }
 96         if (automaticToNormalModule.isEmpty()) {
 97             throw new UncheckedBadArgs(new BadArgs(&quot;err.invalid.path&quot;, args));
 98         }
 99     }
100 
<span class="line-modified">101     public boolean run(boolean ignoreMissingDeps, PrintWriter log, boolean quiet) throws IOException {</span>
102         try {
103             // pass 1: find API dependencies
104             Map&lt;Archive, Set&lt;Archive&gt;&gt; requiresTransitive = computeRequiresTransitive();
105 
106             // pass 2: analyze all class dependences
107             dependencyFinder.parse(automaticModules().stream());
108 
109             analyzer.run(automaticModules(), dependencyFinder.locationToArchive());
110 

111             for (Module m : automaticModules()) {
112                 Set&lt;Archive&gt; apiDeps = requiresTransitive.containsKey(m)
113                                             ? requiresTransitive.get(m)
114                                             : Collections.emptySet();
115 
<span class="line-modified">116                 // if this is a multi-release JAR, write to versions/$VERSION/module-info.java</span>
<span class="line-added">117                 Runtime.Version version = configuration.getVersion();</span>
<span class="line-added">118                 Path dir = version != null</span>
<span class="line-added">119                             ? outputdir.resolve(m.name())</span>
<span class="line-added">120                                        .resolve(&quot;versions&quot;)</span>
<span class="line-added">121                                        .resolve(String.valueOf(version.feature()))</span>
<span class="line-added">122                             : outputdir.resolve(m.name());</span>
<span class="line-added">123                 Path file = dir.resolve(&quot;module-info.java&quot;);</span>
124 
125                 // computes requires and requires transitive
<span class="line-modified">126                 Module normalModule = toNormalModule(m, apiDeps, ignoreMissingDeps);</span>
127                 if (normalModule != null) {
128                     automaticToNormalModule.put(m, normalModule);
129 
130                     // generate module-info.java
<span class="line-modified">131                     if (!quiet) {</span>
<span class="line-added">132                         if (ignoreMissingDeps &amp;&amp; analyzer.requires(m).anyMatch(Analyzer::notFound)) {</span>
<span class="line-added">133                             log.format(&quot;Warning: --ignore-missing-deps specified. Missing dependencies from %s are ignored%n&quot;,</span>
<span class="line-added">134                                        m.name());</span>
<span class="line-added">135                         }</span>
<span class="line-added">136                         log.format(&quot;writing to %s%n&quot;, file);</span>
<span class="line-added">137                     }</span>
138                     writeModuleInfo(file,  normalModule.descriptor());
139                 } else {
140                     // find missing dependences
<span class="line-modified">141                     return false;</span>

142                 }
143             }
144 

145         } finally {
146             dependencyFinder.shutdown();
147         }
<span class="line-added">148         return true;</span>
149     }
150 
<span class="line-modified">151     private Module toNormalModule(Module module, Set&lt;Archive&gt; requiresTransitive, boolean ignoreMissingDeps)</span>
152         throws IOException
153     {
154         // done analysis
155         module.close();
156 
<span class="line-modified">157         if (!ignoreMissingDeps &amp;&amp; analyzer.requires(module).anyMatch(Analyzer::notFound)) {</span>
158             // missing dependencies
159             return null;
160         }
161 
162         Map&lt;String, Boolean&gt; requires = new HashMap&lt;&gt;();
163         requiresTransitive.stream()
<span class="line-added">164             .filter(a -&gt; !(ignoreMissingDeps &amp;&amp; Analyzer.notFound(a)))</span>
165             .map(Archive::getModule)
166             .forEach(m -&gt; requires.put(m.name(), Boolean.TRUE));
167 
168         analyzer.requires(module)
<span class="line-added">169             .filter(a -&gt; !(ignoreMissingDeps &amp;&amp; Analyzer.notFound(a)))</span>
170             .map(Archive::getModule)
171             .forEach(d -&gt; requires.putIfAbsent(d.name(), Boolean.FALSE));
172 
173         return module.toNormalModule(requires);
174     }
175 
176     /**
177      * Returns the stream of resulting modules
178      */
179     Stream&lt;Module&gt; modules() {
180         return automaticToNormalModule.values().stream();
181     }
182 
183     /**
184      * Returns the stream of resulting ModuleDescriptors
185      */
186     public Stream&lt;ModuleDescriptor&gt; descriptors() {
187         return automaticToNormalModule.entrySet().stream()
188                     .map(Map.Entry::getValue)
189                     .map(Module::descriptor);
</pre>
</td>
</tr>
</table>
<center><a href="ModuleAnalyzer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="resources/jdeps.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
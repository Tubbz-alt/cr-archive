<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jdeps/share/classes/com/sun/tools/jdeps/JdepsTask.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.jdeps;
  27 
  28 import com.sun.tools.jdeps.Analyzer.Type;
  29 import static com.sun.tools.jdeps.Analyzer.Type.*;
  30 import static com.sun.tools.jdeps.JdepsWriter.*;
  31 import static java.util.stream.Collectors.*;
  32 
  33 import java.io.IOException;
  34 import java.io.PrintWriter;
  35 import java.lang.module.ResolutionException;
  36 import java.nio.file.Files;
  37 import java.nio.file.Path;
  38 import java.nio.file.Paths;
  39 import java.text.MessageFormat;
  40 import java.util.*;
  41 import java.util.jar.JarFile;
  42 import java.util.regex.Pattern;
  43 
  44 /**
  45  * Implementation for the jdeps tool for static class dependency analysis.
  46  */
  47 class JdepsTask {
  48     static interface BadArguments {
  49         String getKey();
  50         Object[] getArgs();
  51         boolean showUsage();
  52     }
  53     static class BadArgs extends Exception implements BadArguments {
  54         static final long serialVersionUID = 8765093759964640721L;
  55         BadArgs(String key, Object... args) {
  56             super(JdepsTask.getMessage(key, args));
  57             this.key = key;
  58             this.args = args;
  59         }
  60 
  61         BadArgs showUsage(boolean b) {
  62             showUsage = b;
  63             return this;
  64         }
  65         final String key;
  66         final Object[] args;
  67         boolean showUsage;
  68 
  69         @Override
  70         public String getKey() {
  71             return key;
  72         }
  73 
  74         @Override
  75         public Object[] getArgs() {
  76             return args;
  77         }
  78 
  79         @Override
  80         public boolean showUsage() {
  81             return showUsage;
  82         }
  83     }
  84 
  85     static class UncheckedBadArgs extends RuntimeException implements BadArguments {
  86         static final long serialVersionUID = -1L;
  87         final BadArgs cause;
  88         UncheckedBadArgs(BadArgs cause) {
  89             super(cause);
  90             this.cause = cause;
  91         }
  92         @Override
  93         public String getKey() {
  94             return cause.key;
  95         }
  96 
  97         @Override
  98         public Object[] getArgs() {
  99             return cause.args;
 100         }
 101 
 102         @Override
 103         public boolean showUsage() {
 104             return cause.showUsage;
 105         }
 106     }
 107 
 108     static abstract class Option {
 109         Option(boolean hasArg, String... aliases) {
 110             this.hasArg = hasArg;
 111             this.aliases = aliases;
 112         }
 113 
 114         Option(boolean hasArg, CommandOption cmd) {
 115             this(hasArg, cmd.names());
 116         }
 117 
 118         boolean isHidden() {
 119             return false;
 120         }
 121 
 122         boolean matches(String opt) {
 123             for (String a : aliases) {
 124                 if (a.equals(opt))
 125                     return true;
 126                 if (hasArg &amp;&amp; opt.startsWith(a + &quot;=&quot;))
 127                     return true;
 128             }
 129             return false;
 130         }
 131 
 132         boolean ignoreRest() {
 133             return false;
 134         }
 135 
 136         abstract void process(JdepsTask task, String opt, String arg) throws BadArgs;
 137         final boolean hasArg;
 138         final String[] aliases;
 139     }
 140 
 141     static abstract class HiddenOption extends Option {
 142         HiddenOption(boolean hasArg, String... aliases) {
 143             super(hasArg, aliases);
 144         }
 145 
 146         boolean isHidden() {
 147             return true;
 148         }
 149     }
 150 
 151     enum CommandOption {
 152         ANALYZE_DEPS(&quot;&quot;),
 153         GENERATE_DOT_FILE(&quot;-dotoutput&quot;, &quot;--dot-output&quot;),
 154         GENERATE_MODULE_INFO(&quot;--generate-module-info&quot;),
 155         GENERATE_OPEN_MODULE(&quot;--generate-open-module&quot;),
 156         LIST_DEPS(&quot;--list-deps&quot;),
 157         LIST_REDUCED_DEPS(&quot;--list-reduced-deps&quot;),
 158         PRINT_MODULE_DEPS(&quot;--print-module-deps&quot;),
 159         CHECK_MODULES(&quot;--check&quot;);
 160 
 161         private final String[] names;
 162         CommandOption(String... names) {
 163             this.names = names;
 164         }
 165 
 166         String[] names() {
 167             return names;
 168         }
 169 
 170         @Override
 171         public String toString() {
 172             return names[0];
 173         }
 174     }
 175 
 176     static Option[] recognizedOptions = {
 177         new Option(false, &quot;-h&quot;, &quot;-?&quot;, &quot;-help&quot;, &quot;--help&quot;) {
 178             void process(JdepsTask task, String opt, String arg) {
 179                 task.options.help = true;
 180             }
 181         },
 182         new Option(true, CommandOption.GENERATE_DOT_FILE) {
 183             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 184                 if (task.command != null) {
 185                     throw new BadArgs(&quot;err.command.set&quot;, task.command, opt);
 186                 }
 187                 task.command = task.genDotFile(Paths.get(arg));
 188             }
 189         },
 190         new Option(false, &quot;-s&quot;, &quot;-summary&quot;) {
 191             void process(JdepsTask task, String opt, String arg) {
 192                 task.options.showSummary = true;
 193             }
 194         },
 195         new Option(false, &quot;-v&quot;, &quot;-verbose&quot;,
 196                                 &quot;-verbose:module&quot;,
 197                                 &quot;-verbose:package&quot;,
 198                                 &quot;-verbose:class&quot;) {
 199             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 200                 switch (opt) {
 201                     case &quot;-v&quot;:
 202                     case &quot;-verbose&quot;:
 203                         task.options.verbose = VERBOSE;
 204                         task.options.filterSameArchive = false;
 205                         task.options.filterSamePackage = false;
 206                         break;
 207                     case &quot;-verbose:module&quot;:
 208                         task.options.verbose = MODULE;
 209                         break;
 210                     case &quot;-verbose:package&quot;:
 211                         task.options.verbose = PACKAGE;
 212                         break;
 213                     case &quot;-verbose:class&quot;:
 214                         task.options.verbose = CLASS;
 215                         break;
 216                     default:
 217                         throw new BadArgs(&quot;err.invalid.arg.for.option&quot;, opt);
 218                 }
 219             }
 220         },
 221         new Option(false, &quot;-apionly&quot;, &quot;--api-only&quot;) {
 222             void process(JdepsTask task, String opt, String arg) {
 223                 task.options.apiOnly = true;
 224             }
 225         },
 226 
 227         new Option(false, &quot;-jdkinternals&quot;, &quot;--jdk-internals&quot;) {
 228             void process(JdepsTask task, String opt, String arg) {
 229                 task.options.findJDKInternals = true;
 230                 if (task.options.includePattern == null) {
 231                     task.options.includePattern = Pattern.compile(&quot;.*&quot;);
 232                 }
 233             }
 234         },
 235 
 236         // ---- paths option ----
 237         new Option(true, &quot;-cp&quot;, &quot;-classpath&quot;, &quot;--class-path&quot;) {
 238             void process(JdepsTask task, String opt, String arg) {
 239                 task.options.classpath = arg;
 240             }
 241         },
 242         new Option(true, &quot;--module-path&quot;) {
 243             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 244                 task.options.modulePath = arg;
 245             }
 246         },
 247         new Option(true, &quot;--upgrade-module-path&quot;) {
 248             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 249                 task.options.upgradeModulePath = arg;
 250             }
 251         },
 252         new Option(true, &quot;--system&quot;) {
 253             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 254                 if (arg.equals(&quot;none&quot;)) {
 255                     task.options.systemModulePath = null;
 256                 } else {
 257                     Path path = Paths.get(arg);
 258                     if (Files.isRegularFile(path.resolve(&quot;lib&quot;).resolve(&quot;modules&quot;)))
 259                         task.options.systemModulePath = arg;
 260                     else
 261                         throw new BadArgs(&quot;err.invalid.path&quot;, arg);
 262                 }
 263             }
 264         },
 265         new Option(true, &quot;--add-modules&quot;) {
 266             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 267                 Set&lt;String&gt; mods = Set.of(arg.split(&quot;,&quot;));
 268                 task.options.addmods.addAll(mods);
 269             }
 270         },
 271         new Option(true, &quot;--multi-release&quot;) {
 272             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 273                 if (arg.equalsIgnoreCase(&quot;base&quot;)) {
 274                     task.options.multiRelease = JarFile.baseVersion();
 275                 } else {
 276                     try {
 277                         int v = Integer.parseInt(arg);
 278                         if (v &lt; 9) {
 279                             throw new BadArgs(&quot;err.invalid.arg.for.option&quot;, arg);
 280                         }
 281                     } catch (NumberFormatException x) {
 282                         throw new BadArgs(&quot;err.invalid.arg.for.option&quot;, arg);
 283                     }
 284                     task.options.multiRelease = Runtime.Version.parse(arg);
 285                 }
 286             }
 287         },
 288         new Option(false, &quot;-q&quot;, &quot;-quiet&quot;) {
 289             void process(JdepsTask task, String opt, String arg) {
 290                 task.options.nowarning = true;
 291             }
 292         },
 293         new Option(false, &quot;-version&quot;, &quot;--version&quot;) {
 294             void process(JdepsTask task, String opt, String arg) {
 295                 task.options.version = true;
 296             }
 297         },
 298 
 299         // ---- module-specific options ----
 300 
 301         new Option(true, &quot;-m&quot;, &quot;--module&quot;) {
 302             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 303                 if (!task.options.rootModules.isEmpty()) {
 304                     throw new BadArgs(&quot;err.option.already.specified&quot;, opt);
 305                 }
 306                 task.options.rootModules.add(arg);
 307                 task.options.addmods.add(arg);
 308             }
 309         },
 310         new Option(true, CommandOption.GENERATE_MODULE_INFO) {
 311             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 312                 if (task.command != null) {
 313                     throw new BadArgs(&quot;err.command.set&quot;, task.command, opt);
 314                 }
 315                 task.command = task.genModuleInfo(Paths.get(arg), false);
 316             }
 317         },
 318         new Option(true, CommandOption.GENERATE_OPEN_MODULE) {
 319             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 320                 if (task.command != null) {
 321                     throw new BadArgs(&quot;err.command.set&quot;, task.command, opt);
 322                 }
 323                 task.command = task.genModuleInfo(Paths.get(arg), true);
 324             }
 325         },
 326         new Option(true, CommandOption.CHECK_MODULES) {
 327             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 328                 if (task.command != null) {
 329                     throw new BadArgs(&quot;err.command.set&quot;, task.command, opt);
 330                 }
 331                 Set&lt;String&gt; mods =  Set.of(arg.split(&quot;,&quot;));
 332                 task.options.addmods.addAll(mods);
 333                 task.command = task.checkModuleDeps(mods);
 334             }
 335         },
 336         new Option(false, CommandOption.LIST_DEPS) {
 337             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 338                 if (task.command != null) {
 339                     throw new BadArgs(&quot;err.command.set&quot;, task.command, opt);
 340                 }
 341                 task.command = task.listModuleDeps(CommandOption.LIST_DEPS);
 342             }
 343         },
 344         new Option(false, CommandOption.LIST_REDUCED_DEPS) {
 345             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 346                 if (task.command != null) {
 347                     throw new BadArgs(&quot;err.command.set&quot;, task.command, opt);
 348                 }
 349                 task.command = task.listModuleDeps(CommandOption.LIST_REDUCED_DEPS);
 350             }
 351         },
 352         new Option(false, CommandOption.PRINT_MODULE_DEPS) {
 353             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 354                 if (task.command != null) {
 355                     throw new BadArgs(&quot;err.command.set&quot;, task.command, opt);
 356                 }
 357                 task.command = task.listModuleDeps(CommandOption.PRINT_MODULE_DEPS);
 358             }
 359         },
 360         new Option(false, &quot;--ignore-missing-deps&quot;) {
 361             void process(JdepsTask task, String opt, String arg) {
 362                 task.options.ignoreMissingDeps = true;
 363             }
 364         },
 365 
 366         // ---- Target filtering options ----
 367         new Option(true, &quot;-p&quot;, &quot;-package&quot;, &quot;--package&quot;) {
 368             void process(JdepsTask task, String opt, String arg) {
 369                 task.options.packageNames.add(arg);
 370             }
 371         },
 372         new Option(true, &quot;-e&quot;, &quot;-regex&quot;, &quot;--regex&quot;) {
 373             void process(JdepsTask task, String opt, String arg) {
 374                 task.options.regex = Pattern.compile(arg);
 375             }
 376         },
 377         new Option(true, &quot;--require&quot;) {
 378             void process(JdepsTask task, String opt, String arg) {
 379                 task.options.requires.add(arg);
 380                 task.options.addmods.add(arg);
 381             }
 382         },
 383         new Option(true, &quot;-f&quot;, &quot;-filter&quot;) {
 384             void process(JdepsTask task, String opt, String arg) {
 385                 task.options.filterRegex = Pattern.compile(arg);
 386             }
 387         },
 388         new Option(false, &quot;-filter:package&quot;,
 389                           &quot;-filter:archive&quot;, &quot;-filter:module&quot;,
 390                           &quot;-filter:none&quot;) {
 391             void process(JdepsTask task, String opt, String arg) {
 392                 switch (opt) {
 393                     case &quot;-filter:package&quot;:
 394                         task.options.filterSamePackage = true;
 395                         task.options.filterSameArchive = false;
 396                         break;
 397                     case &quot;-filter:archive&quot;:
 398                     case &quot;-filter:module&quot;:
 399                         task.options.filterSameArchive = true;
 400                         task.options.filterSamePackage = false;
 401                         break;
 402                     case &quot;-filter:none&quot;:
 403                         task.options.filterSameArchive = false;
 404                         task.options.filterSamePackage = false;
 405                         break;
 406                 }
 407             }
 408         },
 409         new Option(false, &quot;--missing-deps&quot;) {
 410             void process(JdepsTask task, String opt, String arg) {
 411                 task.options.findMissingDeps = true;
 412             }
 413         },
 414 
 415         // ---- Source filtering options ----
 416         new Option(true, &quot;-include&quot;) {
 417             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 418                 task.options.includePattern = Pattern.compile(arg);
 419             }
 420         },
 421 
 422         new Option(false, &quot;-P&quot;, &quot;-profile&quot;) {
 423             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 424                 task.options.showProfile = true;
 425             }
 426         },
 427 
 428         new Option(false, &quot;-R&quot;, &quot;-recursive&quot;, &quot;--recursive&quot;) {
 429             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 430                 task.options.recursive = Options.RECURSIVE;
 431                 // turn off filtering
 432                 task.options.filterSameArchive = false;
 433                 task.options.filterSamePackage = false;
 434             }
 435         },
 436         new Option(false, &quot;--no-recursive&quot;) {
 437             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 438                 task.options.recursive = Options.NO_RECURSIVE;
 439             }
 440         },
 441         new Option(false, &quot;-I&quot;, &quot;--inverse&quot;) {
 442             void process(JdepsTask task, String opt, String arg) {
 443                 task.options.inverse = true;
 444                 // equivalent to the inverse of compile-time view analysis
 445                 task.options.compileTimeView = true;
 446                 task.options.filterSamePackage = true;
 447                 task.options.filterSameArchive = true;
 448             }
 449         },
 450 
 451         new Option(false, &quot;--compile-time&quot;) {
 452             void process(JdepsTask task, String opt, String arg) {
 453                 task.options.compileTimeView = true;
 454                 task.options.recursive = Options.RECURSIVE;
 455                 task.options.filterSamePackage = true;
 456                 task.options.filterSameArchive = true;
 457             }
 458         },
 459 
 460         new HiddenOption(false, &quot;-fullversion&quot;) {
 461             void process(JdepsTask task, String opt, String arg) {
 462                 task.options.fullVersion = true;
 463             }
 464         },
 465         new HiddenOption(false, &quot;-showlabel&quot;) {
 466             void process(JdepsTask task, String opt, String arg) {
 467                 task.options.showLabel = true;
 468             }
 469         },
 470         new HiddenOption(false, &quot;--hide-show-module&quot;) {
 471             void process(JdepsTask task, String opt, String arg) {
 472                 task.options.showModule = false;
 473             }
 474         },
 475         new HiddenOption(true, &quot;-depth&quot;) {
 476             void process(JdepsTask task, String opt, String arg) throws BadArgs {
 477                 try {
 478                     task.options.depth = Integer.parseInt(arg);
 479                 } catch (NumberFormatException e) {
 480                     throw new BadArgs(&quot;err.invalid.arg.for.option&quot;, opt);
 481                 }
 482             }
 483         },
 484     };
 485 
 486     private static final String PROGNAME = &quot;jdeps&quot;;
 487     private final Options options = new Options();
 488     private final List&lt;String&gt; inputArgs = new ArrayList&lt;&gt;();
 489 
 490     private Command command;
 491     private PrintWriter log;
 492     void setLog(PrintWriter out) {
 493         log = out;
 494     }
 495 
 496     /**
 497      * Result codes.
 498      */
 499     static final int EXIT_OK = 0,       // Completed with no errors.
 500                      EXIT_ERROR = 1,    // Completed but reported errors.
 501                      EXIT_CMDERR = 2,   // Bad command-line arguments
 502                      EXIT_SYSERR = 3,   // System error or resource exhaustion.
 503                      EXIT_ABNORMAL = 4; // terminated abnormally
 504 
 505     int run(String... args) {
 506         if (log == null) {
 507             log = new PrintWriter(System.out);
 508         }
 509         try {
 510             handleOptions(args);
 511             if (options.help) {
 512                 showHelp();
 513             }
 514             if (options.version || options.fullVersion) {
 515                 showVersion(options.fullVersion);
 516             }
 517             if (options.help || options.version || options.fullVersion) {
 518                 return EXIT_OK;
 519             }
 520             if (options.numFilters() &gt; 1) {
 521                 reportError(&quot;err.invalid.filters&quot;);
 522                 return EXIT_CMDERR;
 523             }
 524 
 525             // default command to analyze dependences
 526             if (command == null) {
 527                 command = analyzeDeps();
 528             }
 529             if (!command.checkOptions()) {
 530                 return EXIT_CMDERR;
 531             }
 532 
 533             boolean ok = run();
 534             return ok ? EXIT_OK : EXIT_ERROR;
 535 
 536         } catch (BadArgs|UncheckedBadArgs e) {
 537             reportError(e.getKey(), e.getArgs());
 538             if (e.showUsage()) {
 539                 log.println(getMessage(&quot;main.usage.summary&quot;, PROGNAME));
 540             }
 541             return EXIT_CMDERR;
 542         } catch (ResolutionException e) {
 543             reportError(&quot;err.exception.message&quot;, e.getMessage());
 544             return EXIT_CMDERR;
 545         } catch (IOException e) {
 546             e.printStackTrace();
 547             return EXIT_CMDERR;
 548         } catch (MultiReleaseException e) {
 549             reportError(e.getKey(), e.getParams());
 550             return EXIT_CMDERR;  // could be EXIT_ABNORMAL sometimes
 551         } finally {
 552             log.flush();
 553         }
 554     }
 555 
 556     boolean run() throws IOException {
 557         try (JdepsConfiguration config = buildConfig()) {
 558             if (!options.nowarning) {
 559                 // detect split packages
 560                 config.splitPackages().entrySet()
 561                       .stream()
 562                       .sorted(Map.Entry.comparingByKey())
 563                       .forEach(e -&gt; warning(&quot;warn.split.package&quot;,
 564                                             e.getKey(),
 565                                             e.getValue().stream().collect(joining(&quot; &quot;))));
 566             }
 567 
 568             // check if any module specified in --add-modules, --require, and -m is missing
 569             options.addmods.stream()
 570                 .filter(mn -&gt; !JdepsConfiguration.isToken(mn))
 571                 .forEach(mn -&gt; config.findModule(mn).orElseThrow(() -&gt;
 572                     new UncheckedBadArgs(new BadArgs(&quot;err.module.not.found&quot;, mn))));
 573 
 574             return command.run(config);
 575         }
 576     }
 577 
 578     private JdepsConfiguration buildConfig() throws IOException {
 579         JdepsConfiguration.Builder builder =
 580             new JdepsConfiguration.Builder(options.systemModulePath);
 581 
 582         builder.upgradeModulePath(options.upgradeModulePath)
 583                .appModulePath(options.modulePath)
 584                .addmods(options.addmods)
 585                .addmods(command.addModules());
 586 
 587         if (options.classpath != null)
 588             builder.addClassPath(options.classpath);
 589 
 590         if (options.multiRelease != null)
 591             builder.multiRelease(options.multiRelease);
 592 
 593         // build the root set of archives to be analyzed
 594         for (String s : inputArgs) {
 595             Path p = Paths.get(s);
 596             if (Files.exists(p)) {
 597                 builder.addRoot(p);
 598             } else {
 599                 warning(&quot;warn.invalid.arg&quot;, s);
 600             }
 601         }
 602 
 603         return builder.build();
 604     }
 605 
 606     // ---- factory methods to create a Command
 607 
 608     private AnalyzeDeps analyzeDeps() throws BadArgs {
 609         return options.inverse ? new InverseAnalyzeDeps()
 610                                : new AnalyzeDeps();
 611     }
 612 
 613     private GenDotFile genDotFile(Path dir) throws BadArgs {
 614         if (Files.exists(dir) &amp;&amp; (!Files.isDirectory(dir) || !Files.isWritable(dir))) {
 615             throw new BadArgs(&quot;err.invalid.path&quot;, dir.toString());
 616         }
 617         return new GenDotFile(dir);
 618     }
 619 
 620     private GenModuleInfo genModuleInfo(Path dir, boolean openModule) throws BadArgs {
 621         if (Files.exists(dir) &amp;&amp; (!Files.isDirectory(dir) || !Files.isWritable(dir))) {
 622             throw new BadArgs(&quot;err.invalid.path&quot;, dir.toString());
 623         }
 624         return new GenModuleInfo(dir, openModule);
 625     }
 626 
 627     private ListModuleDeps listModuleDeps(CommandOption option) throws BadArgs {
 628         // do transitive dependence analysis unless --no-recursive is set
 629         if (options.recursive != Options.NO_RECURSIVE) {
 630             options.recursive = Options.RECURSIVE;
 631         }
 632         // no need to record the dependences on the same archive or same package
 633         options.filterSameArchive = true;
 634         options.filterSamePackage = true;
 635         switch (option) {
 636             case LIST_DEPS:
 637                 return new ListModuleDeps(option, true, false);
 638             case LIST_REDUCED_DEPS:
 639                 return new ListModuleDeps(option, true, true);
 640             case PRINT_MODULE_DEPS:
 641                 return new ListModuleDeps(option, false, true, &quot;,&quot;);
 642             default:
 643                 throw new IllegalArgumentException(option.toString());
 644         }
 645     }
 646 
 647     private CheckModuleDeps checkModuleDeps(Set&lt;String&gt; mods) throws BadArgs {
 648         return new CheckModuleDeps(mods);
 649     }
 650 
 651     abstract class Command {
 652         final CommandOption option;
 653         protected Command(CommandOption option) {
 654             this.option = option;
 655         }
 656 
 657         /**
 658          * Returns true if the command-line options are all valid;
 659          * otherwise, returns false.
 660          */
 661         abstract boolean checkOptions();
 662 
 663         /**
 664          * Do analysis
 665          */
 666         abstract boolean run(JdepsConfiguration config) throws IOException;
 667 
 668         /**
 669          * Includes all modules on system module path and application module path
 670          *
 671          * When a named module is analyzed, it will analyze the dependences
 672          * only.  The method should be overridden when this command should
 673          * analyze all modules instead.
 674          */
 675         Set&lt;String&gt; addModules() {
 676             return Set.of();
 677         }
 678 
 679         @Override
 680         public String toString() {
 681             return option.toString();
 682         }
 683     }
 684 
 685 
 686     /**
 687      * Analyze dependences
 688      */
 689     class AnalyzeDeps extends Command {
 690         JdepsWriter writer;
 691         AnalyzeDeps() {
 692             this(CommandOption.ANALYZE_DEPS);
 693         }
 694 
 695         AnalyzeDeps(CommandOption option) {
 696             super(option);
 697         }
 698 
 699         @Override
 700         boolean checkOptions() {
 701             if (options.findJDKInternals || options.findMissingDeps) {
 702                 // cannot set any filter, -verbose and -summary option
 703                 if (options.showSummary || options.verbose != null) {
 704                     reportError(&quot;err.invalid.options&quot;, &quot;-summary or -verbose&quot;,
 705                         options.findJDKInternals ? &quot;-jdkinternals&quot; : &quot;--missing-deps&quot;);
 706                     return false;
 707                 }
 708                 if (options.hasFilter()) {
 709                     reportError(&quot;err.invalid.options&quot;, &quot;--package, --regex, --require&quot;,
 710                         options.findJDKInternals ? &quot;-jdkinternals&quot; : &quot;--missing-deps&quot;);
 711                     return false;
 712                 }
 713             }
 714             if (options.showSummary) {
 715                 // -summary cannot use with -verbose option
 716                 if (options.verbose != null) {
 717                     reportError(&quot;err.invalid.options&quot;, &quot;-v, -verbose&quot;, &quot;-s, -summary&quot;);
 718                     return false;
 719                 }
 720             }
 721 
 722             if (!inputArgs.isEmpty() &amp;&amp; !options.rootModules.isEmpty()) {
 723                 reportError(&quot;err.invalid.arg.for.option&quot;, &quot;-m&quot;);
 724             }
 725             if (inputArgs.isEmpty() &amp;&amp; !options.hasSourcePath()) {
 726                 showHelp();
 727                 return false;
 728             }
 729             return true;
 730         }
 731 
 732         /*
 733          * Default is to show package-level dependencies
 734          */
 735         Type getAnalyzerType() {
 736             if (options.showSummary)
 737                 return Type.SUMMARY;
 738 
 739             if (options.findJDKInternals || options.findMissingDeps)
 740                 return Type.CLASS;
 741 
 742             // default to package-level verbose
 743            return options.verbose != null ? options.verbose : PACKAGE;
 744         }
 745 
 746         @Override
 747         boolean run(JdepsConfiguration config) throws IOException {
 748             Type type = getAnalyzerType();
 749             // default to package-level verbose
 750             JdepsWriter writer = new SimpleWriter(log,
 751                                                   type,
 752                                                   options.showProfile,
 753                                                   options.showModule);
 754 
 755             return run(config, writer, type);
 756         }
 757 
 758         boolean run(JdepsConfiguration config, JdepsWriter writer, Type type)
 759             throws IOException
 760         {
 761             // analyze the dependencies
 762             DepsAnalyzer analyzer = new DepsAnalyzer(config,
 763                                                      dependencyFilter(config),
 764                                                      writer,
 765                                                      type,
 766                                                      options.apiOnly);
 767 
 768             boolean ok = analyzer.run(options.compileTimeView, options.depth());
 769 
 770             // print skipped entries, if any
 771             if (!options.nowarning) {
 772                 analyzer.archives()
 773                     .forEach(archive -&gt; archive.reader()
 774                         .skippedEntries().stream()
 775                         .forEach(name -&gt; warning(&quot;warn.skipped.entry&quot;, name)));
 776             }
 777 
 778             if (options.findJDKInternals &amp;&amp; !options.nowarning) {
 779                 Map&lt;String, String&gt; jdkInternals = new TreeMap&lt;&gt;();
 780                 Set&lt;String&gt; deps = analyzer.dependences();
 781                 // find the ones with replacement
 782                 deps.forEach(cn -&gt; replacementFor(cn).ifPresent(
 783                     repl -&gt; jdkInternals.put(cn, repl))
 784                 );
 785 
 786                 if (!deps.isEmpty()) {
 787                     log.println();
 788                     warning(&quot;warn.replace.useJDKInternals&quot;, getMessage(&quot;jdeps.wiki.url&quot;));
 789                 }
 790 
 791                 if (!jdkInternals.isEmpty()) {
 792                     log.println();
 793                     String internalApiTitle = getMessage(&quot;internal.api.column.header&quot;);
 794                     String replacementApiTitle = getMessage(&quot;public.api.replacement.column.header&quot;);
 795                     log.format(&quot;%-40s %s%n&quot;, internalApiTitle, replacementApiTitle);
 796                     log.format(&quot;%-40s %s%n&quot;,
 797                                internalApiTitle.replaceAll(&quot;.&quot;, &quot;-&quot;),
 798                                replacementApiTitle.replaceAll(&quot;.&quot;, &quot;-&quot;));
 799                     jdkInternals.entrySet().stream()
 800                         .forEach(e -&gt; {
 801                             String key = e.getKey();
 802                             String[] lines = e.getValue().split(&quot;\\n&quot;);
 803                             for (String s : lines) {
 804                                 log.format(&quot;%-40s %s%n&quot;, key, s);
 805                                 key = &quot;&quot;;
 806                             }
 807                         });
 808                 }
 809             }
 810             return ok;
 811         }
 812     }
 813 
 814 
 815     class InverseAnalyzeDeps extends AnalyzeDeps {
 816         InverseAnalyzeDeps() {
 817         }
 818 
 819         @Override
 820         boolean checkOptions() {
 821             if (options.recursive != -1 || options.depth != -1) {
 822                 reportError(&quot;err.invalid.options&quot;, &quot;--recursive and --no-recursive&quot;, &quot;--inverse&quot;);
 823                 return false;
 824             }
 825 
 826             if (options.numFilters() == 0) {
 827                 reportError(&quot;err.filter.not.specified&quot;);
 828                 return false;
 829             }
 830 
 831             if (!super.checkOptions()) {
 832                 return false;
 833             }
 834 
 835             return true;
 836         }
 837 
 838         @Override
 839         boolean run(JdepsConfiguration config) throws IOException {
 840             Type type = getAnalyzerType();
 841 
 842             InverseDepsAnalyzer analyzer =
 843                 new InverseDepsAnalyzer(config,
 844                                         dependencyFilter(config),
 845                                         writer,
 846                                         type,
 847                                         options.apiOnly);
 848             boolean ok = analyzer.run();
 849 
 850             log.println();
 851             if (!options.requires.isEmpty())
 852                 log.println(getMessage(&quot;inverse.transitive.dependencies.on&quot;,
 853                                        options.requires));
 854             else
 855                 log.println(getMessage(&quot;inverse.transitive.dependencies.matching&quot;,
 856                                        options.regex != null
 857                                            ? options.regex.toString()
 858                                            : &quot;packages &quot; + options.packageNames));
 859 
 860             analyzer.inverseDependences()
 861                     .stream()
 862                     .sorted(comparator())
 863                     .map(this::toInversePath)
 864                     .forEach(log::println);
 865             return ok;
 866         }
 867 
 868         private String toInversePath(Deque&lt;Archive&gt; path) {
 869             return path.stream()
 870                        .map(Archive::getName)
 871                        .collect(joining(&quot; &lt;- &quot;));
 872         }
 873 
 874         /*
 875          * Returns a comparator for sorting the inversed path, grouped by
 876          * the first module name, then the shortest path and then sort by
 877          * the module names of each path
 878          */
 879         private Comparator&lt;Deque&lt;Archive&gt;&gt; comparator() {
 880             return Comparator.&lt;Deque&lt;Archive&gt;, String&gt;
 881                 comparing(deque -&gt; deque.peekFirst().getName())
 882                     .thenComparingInt(Deque::size)
 883                     .thenComparing(this::toInversePath);
 884         }
 885 
 886         /*
 887          * Returns true if --require is specified so that all modules are
 888          * analyzed to find all modules that depend on the modules specified in the
 889          * --require option directly and indirectly
 890          */
 891         Set&lt;String&gt; addModules() {
 892             return options.requires.size() &gt; 0 ? Set.of(&quot;ALL-SYSTEM&quot;) : Set.of();
 893         }
 894     }
 895 
 896 
 897     class GenModuleInfo extends Command {
 898         final Path dir;
 899         final boolean openModule;
 900         GenModuleInfo(Path dir, boolean openModule) {
 901             super(CommandOption.GENERATE_MODULE_INFO);
 902             this.dir = dir;
 903             this.openModule = openModule;
 904         }
 905 
 906         @Override
 907         boolean checkOptions() {
 908             if (options.classpath != null) {
 909                 reportError(&quot;err.invalid.options&quot;, &quot;-classpath&quot;,
 910                             option);
 911                 return false;
 912             }
 913             if (options.hasFilter()) {
 914                 reportError(&quot;err.invalid.options&quot;, &quot;--package, --regex, --require&quot;,
 915                             option);
 916                 return false;
 917             }
 918             return true;
 919         }
 920 
 921         @Override
 922         boolean run(JdepsConfiguration config) throws IOException {
 923             // check if any JAR file contains unnamed package
 924             for (String arg : inputArgs) {
 925                 try (ClassFileReader reader = ClassFileReader.newInstance(Paths.get(arg))) {
 926                     Optional&lt;String&gt; classInUnnamedPackage =
 927                         reader.entries().stream()
 928                              .filter(n -&gt; n.endsWith(&quot;.class&quot;))
 929                              .filter(cn -&gt; toPackageName(cn).isEmpty())
 930                              .findFirst();
 931 
 932                     if (classInUnnamedPackage.isPresent()) {
 933                         if (classInUnnamedPackage.get().equals(&quot;module-info.class&quot;)) {
 934                             reportError(&quot;err.genmoduleinfo.not.jarfile&quot;, arg);
 935                         } else {
 936                             reportError(&quot;err.genmoduleinfo.unnamed.package&quot;, arg);
 937                         }
 938                         return false;
 939                     }
 940                 }
 941             }
 942 
 943             ModuleInfoBuilder builder
 944                  = new ModuleInfoBuilder(config, inputArgs, dir, openModule);
 945             boolean ok = builder.run();
 946 
 947             if (!ok &amp;&amp; !options.nowarning) {
 948                 reportError(&quot;err.missing.dependences&quot;);
 949                 builder.visitMissingDeps(new SimpleDepVisitor());
 950             }
 951             return ok;
 952         }
 953 
 954         private String toPackageName(String name) {
 955             int i = name.lastIndexOf(&#39;/&#39;);
 956             return i &gt; 0 ? name.replace(&#39;/&#39;, &#39;.&#39;).substring(0, i) : &quot;&quot;;
 957         }
 958     }
 959 
 960     class CheckModuleDeps extends Command {
 961         final Set&lt;String&gt; modules;
 962         CheckModuleDeps(Set&lt;String&gt; mods) {
 963             super(CommandOption.CHECK_MODULES);
 964             this.modules = mods;
 965         }
 966 
 967         @Override
 968         boolean checkOptions() {
 969             if (!inputArgs.isEmpty()) {
 970                 reportError(&quot;err.invalid.options&quot;, inputArgs, &quot;--check&quot;);
 971                 return false;
 972             }
 973             return true;
 974         }
 975 
 976         @Override
 977         boolean run(JdepsConfiguration config) throws IOException {
 978             if (!config.initialArchives().isEmpty()) {
 979                 String list = config.initialArchives().stream()
 980                                     .map(Archive::getPathName).collect(joining(&quot; &quot;));
 981                 throw new UncheckedBadArgs(new BadArgs(&quot;err.invalid.options&quot;,
 982                                                        list, &quot;--check&quot;));
 983             }
 984             return new ModuleAnalyzer(config, log, modules).run();
 985         }
 986 
 987         /*
 988          * Returns true to analyze all modules
 989          */
 990         Set&lt;String&gt; addModules() {
 991             return Set.of(&quot;ALL-SYSTEM&quot;, &quot;ALL-MODULE-PATH&quot;);
 992         }
 993     }
 994 
 995     class ListModuleDeps extends Command {
 996         final boolean jdkinternals;
 997         final boolean reduced;
 998         final String separator;
 999         ListModuleDeps(CommandOption option, boolean jdkinternals, boolean reduced) {
1000             this(option, jdkinternals, reduced, System.getProperty(&quot;line.separator&quot;));
1001         }
1002         ListModuleDeps(CommandOption option, boolean jdkinternals, boolean reduced, String sep) {
1003             super(option);
1004             this.jdkinternals = jdkinternals;
1005             this.reduced = reduced;
1006             this.separator = sep;
1007         }
1008 
1009         @Override
1010         boolean checkOptions() {
1011             if (options.showSummary || options.verbose != null) {
1012                 reportError(&quot;err.invalid.options&quot;, &quot;-summary or -verbose&quot;, option);
1013                 return false;
1014             }
1015             if (options.findJDKInternals) {
1016                 reportError(&quot;err.invalid.options&quot;, &quot;-jdkinternals&quot;, option);
1017                 return false;
1018             }
1019             if (options.findMissingDeps) {
1020                 reportError(&quot;err.invalid.options&quot;, &quot;--missing-deps&quot;, option);
1021                 return false;
1022             }
1023 
1024             if (!inputArgs.isEmpty() &amp;&amp; !options.rootModules.isEmpty()) {
1025                 reportError(&quot;err.invalid.arg.for.option&quot;, &quot;-m&quot;);
1026             }
1027             if (inputArgs.isEmpty() &amp;&amp; !options.hasSourcePath()) {
1028                 showHelp();
1029                 return false;
1030             }
1031             return true;
1032         }
1033 
1034         @Override
1035         boolean run(JdepsConfiguration config) throws IOException {
1036             ModuleExportsAnalyzer analyzer = new ModuleExportsAnalyzer(config,
1037                                                                        dependencyFilter(config),
1038                                                                        jdkinternals,
1039                                                                        reduced,
1040                                                                        log,
1041                                                                        separator);
1042             boolean ok = analyzer.run(options.depth(), options.ignoreMissingDeps);
1043             if (!ok) {
1044                 reportError(&quot;err.cant.list.module.deps&quot;);
1045                 log.println();
1046                 analyzer.visitMissingDeps(new SimpleDepVisitor());
1047             }
1048             return ok;
1049         }
1050     }
1051 
1052     class GenDotFile extends AnalyzeDeps {
1053         final Path dotOutputDir;
1054         GenDotFile(Path dotOutputDir) {
1055             super(CommandOption.GENERATE_DOT_FILE);
1056 
1057             this.dotOutputDir = dotOutputDir;
1058         }
1059 
1060         @Override
1061         boolean run(JdepsConfiguration config) throws IOException {
1062             if ((options.showSummary || options.verbose == MODULE) &amp;&amp;
1063                 !options.addmods.isEmpty() &amp;&amp; inputArgs.isEmpty()) {
1064                 // generate dot graph from the resolved graph from module
1065                 // resolution.  No class dependency analysis is performed.
1066                 return new ModuleDotGraph(config, options.apiOnly)
1067                         .genDotFiles(dotOutputDir);
1068             }
1069 
1070             Type type = getAnalyzerType();
1071             JdepsWriter writer = new DotFileWriter(dotOutputDir,
1072                                                    type,
1073                                                    options.showProfile,
1074                                                    options.showModule,
1075                                                    options.showLabel);
1076             return run(config, writer, type);
1077         }
1078     }
1079 
1080     class SimpleDepVisitor implements Analyzer.Visitor {
1081         private Archive source;
1082         @Override
1083         public void visitDependence(String origin, Archive originArchive, String target, Archive targetArchive) {
1084             if (source != originArchive) {
1085                 source = originArchive;
1086                 log.format(&quot;%s%n&quot;, originArchive);
1087             }
1088             log.format(&quot;   %-50s -&gt; %-50s %s%n&quot;, origin, target, targetArchive.getName());
1089         }
1090     }
1091 
1092     /**
1093      * Returns a filter used during dependency analysis
1094      */
1095     private JdepsFilter dependencyFilter(JdepsConfiguration config) {
1096         // Filter specified by -filter, -package, -regex, and --require options
1097         JdepsFilter.Builder builder = new JdepsFilter.Builder();
1098 
1099         // source filters
1100         builder.includePattern(options.includePattern);
1101 
1102         // target filters
1103         builder.filter(options.filterSamePackage, options.filterSameArchive);
1104         builder.findJDKInternals(options.findJDKInternals);
1105         builder.findMissingDeps(options.findMissingDeps);
1106 
1107         // --require
1108         if (!options.requires.isEmpty()) {
1109             options.requires.stream()
1110                 .forEach(mn -&gt; {
1111                     Module m = config.findModule(mn).get();
1112                     builder.requires(mn, m.packages());
1113                 });
1114         }
1115         // -regex
1116         if (options.regex != null)
1117             builder.regex(options.regex);
1118         // -package
1119         if (!options.packageNames.isEmpty())
1120             builder.packages(options.packageNames);
1121         // -filter
1122         if (options.filterRegex != null)
1123             builder.filter(options.filterRegex);
1124 
1125         return builder.build();
1126     }
1127 
1128     public void handleOptions(String[] args) throws BadArgs {
1129         // process options
1130         for (int i=0; i &lt; args.length; i++) {
1131             if (args[i].charAt(0) == &#39;-&#39;) {
1132                 String name = args[i];
1133                 Option option = getOption(name);
1134                 String param = null;
1135                 if (option.hasArg) {
1136                     if (name.startsWith(&quot;-&quot;) &amp;&amp; name.indexOf(&#39;=&#39;) &gt; 0) {
1137                         param = name.substring(name.indexOf(&#39;=&#39;) + 1, name.length());
1138                     } else if (i + 1 &lt; args.length) {
1139                         param = args[++i];
1140                     }
1141                     if (param == null || param.isEmpty() || param.charAt(0) == &#39;-&#39;) {
1142                         throw new BadArgs(&quot;err.missing.arg&quot;, name).showUsage(true);
1143                     }
1144                 }
1145                 option.process(this, name, param);
1146                 if (option.ignoreRest()) {
1147                     i = args.length;
1148                 }
1149             } else {
1150                 // process rest of the input arguments
1151                 for (; i &lt; args.length; i++) {
1152                     String name = args[i];
1153                     if (name.charAt(0) == &#39;-&#39;) {
1154                         throw new BadArgs(&quot;err.option.after.class&quot;, name).showUsage(true);
1155                     }
1156                     inputArgs.add(name);
1157                 }
1158             }
1159         }
1160     }
1161 
1162     private Option getOption(String name) throws BadArgs {
1163         for (Option o : recognizedOptions) {
1164             if (o.matches(name)) {
1165                 return o;
1166             }
1167         }
1168         throw new BadArgs(&quot;err.unknown.option&quot;, name).showUsage(true);
1169     }
1170 
1171     private void reportError(String key, Object... args) {
1172         log.println(getMessage(&quot;error.prefix&quot;) + &quot; &quot; + getMessage(key, args));
1173     }
1174 
1175     void warning(String key, Object... args) {
1176         log.println(getMessage(&quot;warn.prefix&quot;) + &quot; &quot; + getMessage(key, args));
1177     }
1178 
1179     private void showHelp() {
1180         log.println(getMessage(&quot;main.usage&quot;, PROGNAME));
1181         for (Option o : recognizedOptions) {
1182             String name = o.aliases[0].substring(1); // there must always be at least one name
1183             name = name.charAt(0) == &#39;-&#39; ? name.substring(1) : name;
1184             if (o.isHidden() || name.startsWith(&quot;filter:&quot;)) {
1185                 continue;
1186             }
1187             log.println(getMessage(&quot;main.opt.&quot; + name));
1188         }
1189     }
1190 
1191     private void showVersion(boolean full) {
1192         log.println(version(full ? &quot;full&quot; : &quot;release&quot;));
1193     }
1194 
1195     private String version(String key) {
1196         // key=version:  mm.nn.oo[-milestone]
1197         // key=full:     mm.mm.oo[-milestone]-build
1198         try {
1199             return ResourceBundleHelper.getVersion(key);
1200         } catch (MissingResourceException e) {
1201             return getMessage(&quot;version.unknown&quot;, System.getProperty(&quot;java.version&quot;));
1202         }
1203     }
1204 
1205     static String getMessage(String key, Object... args) {
1206         try {
1207             return MessageFormat.format(ResourceBundleHelper.getMessage(key), args);
1208         } catch (MissingResourceException e) {
1209             throw new InternalError(&quot;Missing message: &quot; + key);
1210         }
1211     }
1212 
1213     private static class Options {
1214         static final int NO_RECURSIVE = 0;
1215         static final int RECURSIVE = 1;
1216         boolean help;
1217         boolean version;
1218         boolean fullVersion;
1219         boolean showProfile;
1220         boolean showModule = true;
1221         boolean showSummary;
1222         boolean apiOnly;
1223         boolean showLabel;
1224         boolean findJDKInternals;
1225         boolean findMissingDeps;
1226         boolean ignoreMissingDeps;
1227         boolean nowarning = false;
1228         Analyzer.Type verbose;
1229         // default filter references from same package
1230         boolean filterSamePackage = true;
1231         boolean filterSameArchive = false;
1232         Pattern filterRegex;
1233         String classpath;
1234         int recursive = -1;     // 0: --no-recursive, 1: --recursive
1235         int depth = -1;
1236         Set&lt;String&gt; requires = new HashSet&lt;&gt;();
1237         Set&lt;String&gt; packageNames = new HashSet&lt;&gt;();
1238         Pattern regex;             // apply to the dependences
1239         Pattern includePattern;
1240         boolean inverse = false;
1241         boolean compileTimeView = false;
1242         String systemModulePath = System.getProperty(&quot;java.home&quot;);
1243         String upgradeModulePath;
1244         String modulePath;
1245         Set&lt;String&gt; rootModules = new HashSet&lt;&gt;();
1246         Set&lt;String&gt; addmods = new HashSet&lt;&gt;();
1247         Runtime.Version multiRelease;
1248 
1249         boolean hasSourcePath() {
1250             return !addmods.isEmpty() || includePattern != null;
1251         }
1252 
1253         boolean hasFilter() {
1254             return numFilters() &gt; 0;
1255         }
1256 
1257         int numFilters() {
1258             int count = 0;
1259             if (requires.size() &gt; 0) count++;
1260             if (regex != null) count++;
1261             if (packageNames.size() &gt; 0) count++;
1262             return count;
1263         }
1264 
1265         int depth() {
1266             // ignore -depth if --no-recursive is set
1267             if (recursive == NO_RECURSIVE)
1268                 return 1;
1269 
1270             // depth == 0 if recursive
1271             if (recursive == RECURSIVE &amp;&amp; depth == -1)
1272                 return 0;
1273 
1274             // default depth is 1 unless specified via -depth option
1275             return depth == -1 ? 1 : depth;
1276         }
1277     }
1278 
1279     private static class ResourceBundleHelper {
1280         static final String LS = System.lineSeparator();
1281         static final ResourceBundle versionRB;
1282         static final ResourceBundle bundle;
1283         static final ResourceBundle jdkinternals;
1284 
1285         static {
1286             Locale locale = Locale.getDefault();
1287             try {
1288                 bundle = ResourceBundle.getBundle(&quot;com.sun.tools.jdeps.resources.jdeps&quot;, locale);
1289             } catch (MissingResourceException e) {
1290                 throw new InternalError(&quot;Cannot find jdeps resource bundle for locale &quot; + locale);
1291             }
1292             try {
1293                 versionRB = ResourceBundle.getBundle(&quot;com.sun.tools.jdeps.resources.version&quot;);
1294             } catch (MissingResourceException e) {
1295                 throw new InternalError(&quot;version.resource.missing&quot;);
1296             }
1297             try {
1298                 jdkinternals = ResourceBundle.getBundle(&quot;com.sun.tools.jdeps.resources.jdkinternals&quot;);
1299             } catch (MissingResourceException e) {
1300                 throw new InternalError(&quot;Cannot find jdkinternals resource bundle&quot;);
1301             }
1302         }
1303 
1304         static String getMessage(String key) {
1305             return bundle.getString(key).replace(&quot;\n&quot;, LS);
1306         }
1307 
1308         static String getVersion(String key) {
1309             if (ResourceBundleHelper.versionRB == null) {
1310                 return System.getProperty(&quot;java.version&quot;);
1311             }
1312             return versionRB.getString(key).replace(&quot;\n&quot;, LS);
1313         }
1314 
1315         static String getSuggestedReplacement(String key) {
1316             return ResourceBundleHelper.jdkinternals.getString(key).replace(&quot;\n&quot;, LS);
1317         }
1318     }
1319 
1320     /**
1321      * Returns the recommended replacement API for the given classname;
1322      * or return null if replacement API is not known.
1323      */
1324     private Optional&lt;String&gt; replacementFor(String cn) {
1325         String name = cn;
1326         String value = null;
1327         while (value == null &amp;&amp; name != null) {
1328             try {
1329                 value = ResourceBundleHelper.getSuggestedReplacement(name);
1330             } catch (MissingResourceException e) {
1331                 // go up one subpackage level
1332                 int i = name.lastIndexOf(&#39;.&#39;);
1333                 name = i &gt; 0 ? name.substring(0, i) : null;
1334             }
1335         }
1336         return Optional.ofNullable(value);
1337     }
1338 }
    </pre>
  </body>
</html>
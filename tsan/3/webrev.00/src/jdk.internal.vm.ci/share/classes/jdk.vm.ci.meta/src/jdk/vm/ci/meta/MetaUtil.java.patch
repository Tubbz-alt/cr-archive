diff a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.meta/src/jdk/vm/ci/meta/MetaUtil.java b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.meta/src/jdk/vm/ci/meta/MetaUtil.java
--- a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.meta/src/jdk/vm/ci/meta/MetaUtil.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.meta/src/jdk/vm/ci/meta/MetaUtil.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -36,17 +36,17 @@
      *            of the enclosing class/classes of {@code clazz} (if any). This option is ignored
      *            if {@code clazz} denotes an anonymous or local class.
      * @return the simple name
      */
     public static String getSimpleName(Class<?> clazz, boolean withEnclosingClass) {
-        final String simpleName = clazz.getSimpleName();
+        final String simpleName = safeSimpleName(clazz);
         if (simpleName.length() != 0) {
             if (withEnclosingClass) {
                 String prefix = "";
                 Class<?> enclosingClass = clazz;
                 while ((enclosingClass = enclosingClass.getEnclosingClass()) != null) {
-                    prefix = enclosingClass.getSimpleName() + "." + prefix;
+                    prefix = safeSimpleName(enclosingClass) + "." + prefix;
                 }
                 return prefix + simpleName;
             }
             return simpleName;
         }
@@ -61,10 +61,56 @@
             return name;
         }
         return name.substring(index + 1);
     }
 
+    private static String safeSimpleName(Class<?> clazz) {
+        try {
+            return clazz.getSimpleName();
+        } catch (InternalError e) {
+            // Scala inner class names do not always start with '$',
+            // causing Class.getSimpleName to throw an InternalError
+            Class<?> enclosingClass = clazz.getEnclosingClass();
+            String fqn = clazz.getName();
+            if (enclosingClass == null) {
+                // Should never happen given logic in
+                // Class.getSimpleName but best be safe
+                return fqn;
+            }
+            String enclosingFQN = enclosingClass.getName();
+            int length = fqn.length();
+            if (enclosingFQN.length() >= length) {
+                // Should also never happen
+                return fqn;
+            }
+            return fqn.substring(enclosingFQN.length());
+        }
+    }
+
+    /**
+     * Classes for lambdas can have {@code /} characters that are not package separators. These are
+     * distinguished by being followed by a character that is not a
+     * {@link Character#isJavaIdentifierStart(char)} (e.g.,
+     * "jdk.vm.ci.runtime.test.TypeUniverse$$Lambda$1/869601985").
+     */
+    private static String replacePackageSeparatorsWithDot(String name) {
+        int length = name.length();
+        int i = 0;
+        StringBuilder buf = new StringBuilder(length);
+        while (i < length - 1) {
+            char ch = name.charAt(i);
+            if (ch == '/' && Character.isJavaIdentifierStart(name.charAt(i + 1))) {
+                buf.append('.');
+            } else {
+                buf.append(ch);
+            }
+            i++;
+        }
+        buf.append(name.charAt(length - 1));
+        return buf.toString();
+    }
+
     /**
      * Converts a type name in internal form to an external form.
      *
      * @param name the internal name to convert
      * @param qualified whether the returned name should be qualified with the package name
@@ -74,21 +120,21 @@
      *            {@code "int[][]"} ).
      */
     public static String internalNameToJava(String name, boolean qualified, boolean classForNameCompatible) {
         switch (name.charAt(0)) {
             case 'L': {
-                String result = name.substring(1, name.length() - 1).replace('/', '.');
+                String result = replacePackageSeparatorsWithDot(name.substring(1, name.length() - 1));
                 if (!qualified) {
                     final int lastDot = result.lastIndexOf('.');
                     if (lastDot != -1) {
                         result = result.substring(lastDot + 1);
                     }
                 }
                 return result;
             }
             case '[':
-                return classForNameCompatible ? name.replace('/', '.') : internalNameToJava(name.substring(1), qualified, classForNameCompatible) + "[]";
+                return classForNameCompatible ? replacePackageSeparatorsWithDot(name) : internalNameToJava(name.substring(1), qualified, classForNameCompatible) + "[]";
             default:
                 if (name.length() != 1) {
                     throw new IllegalArgumentException("Illegal internal name: " + name);
                 }
                 return JavaKind.fromPrimitiveOrVoidTypeChar(name.charAt(0)).getJavaName();

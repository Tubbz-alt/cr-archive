diff a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.runtime/src/jdk/vm/ci/runtime/JVMCI.java b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.runtime/src/jdk/vm/ci/runtime/JVMCI.java
--- a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.runtime/src/jdk/vm/ci/runtime/JVMCI.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.runtime/src/jdk/vm/ci/runtime/JVMCI.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,42 +22,61 @@
  */
 package jdk.vm.ci.runtime;
 
 import java.util.Formatter;
 
+import jdk.vm.ci.common.NativeImageReinitialize;
+import jdk.vm.ci.services.Services;
+
 public class JVMCI {
 
-    private static final JVMCIRuntime runtime;
+    /**
+     * Singleton instance lazily initialized via double-checked locking.
+     */
+    @NativeImageReinitialize private static volatile JVMCIRuntime runtime;
 
-    private static native JVMCIRuntime initializeRuntime();
+    @NativeImageReinitialize private static boolean initializing;
 
     public static void initialize() {
         // force static initializer
     }
 
+    private static native JVMCIRuntime initializeRuntime();
+
     /**
      * Gets the singleton {@link JVMCIRuntime} instance available to the application.
      *
      * @throws UnsupportedOperationException if JVMCI is not supported
      */
     public static JVMCIRuntime getRuntime() {
-        if (runtime == null) {
-            String javaHome = System.getProperty("java.home");
-            String vmName = System.getProperty("java.vm.name");
-            Formatter errorMessage = new Formatter();
-            errorMessage.format("The VM does not support the JVMCI API.%n");
-            errorMessage.format("Currently used Java home directory is %s.%n", javaHome);
-            errorMessage.format("Currently used VM configuration is: %s", vmName);
-            throw new UnsupportedOperationException(errorMessage.toString());
-        }
-        return runtime;
-    }
-
-    static {
-        JVMCIRuntime rt = null;
-        try {
-            rt = initializeRuntime();
-        } catch (UnsatisfiedLinkError e) {
+        JVMCIRuntime result = runtime;
+        if (result == null) {
+            synchronized (JVMCI.class) {
+                result = runtime;
+                if (result == null) {
+                    if (initializing) {
+                        // In recursive call from HotSpotJVMCIRuntime.runtime
+                        // so no need to re-enter initializeRuntime below. This
+                        // path is only entered if JVMCI initialization starts
+                        // with JVMCI.getRuntime().
+                        return null;
+                    }
+                    initializing = true;
+                    try {
+                        runtime = result = initializeRuntime();
+                    } catch (UnsatisfiedLinkError e) {
+                        String javaHome = Services.getSavedProperty("java.home");
+                        String vmName = Services.getSavedProperty("java.vm.name");
+                        Formatter errorMessage = new Formatter();
+                        errorMessage.format("The VM does not support the JVMCI API.%n");
+                        errorMessage.format("Currently used Java home directory is %s.%n", javaHome);
+                        errorMessage.format("Currently used VM configuration is: %s", vmName);
+                        throw new UnsupportedOperationException(errorMessage.toString());
+                    } finally {
+                        initializing = false;
+                    }
+                }
+            }
         }
-        runtime = rt;
+        return result;
     }
 }

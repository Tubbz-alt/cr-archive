<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot.aarch64/src/jdk/vm/ci/hotspot/aarch64/AArch64HotSpotRegisterConfig.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot.aarch64;
 24 
 25 import static jdk.vm.ci.aarch64.AArch64.lr;
 26 import static jdk.vm.ci.aarch64.AArch64.r0;
 27 import static jdk.vm.ci.aarch64.AArch64.r1;
 28 import static jdk.vm.ci.aarch64.AArch64.r2;
 29 import static jdk.vm.ci.aarch64.AArch64.r3;
 30 import static jdk.vm.ci.aarch64.AArch64.r4;
 31 import static jdk.vm.ci.aarch64.AArch64.r5;
 32 import static jdk.vm.ci.aarch64.AArch64.r6;
 33 import static jdk.vm.ci.aarch64.AArch64.r7;
 34 import static jdk.vm.ci.aarch64.AArch64.rscratch1;
 35 import static jdk.vm.ci.aarch64.AArch64.rscratch2;
 36 import static jdk.vm.ci.aarch64.AArch64.r12;
 37 import static jdk.vm.ci.aarch64.AArch64.r27;
 38 import static jdk.vm.ci.aarch64.AArch64.r28;
 39 import static jdk.vm.ci.aarch64.AArch64.r29;
 40 import static jdk.vm.ci.aarch64.AArch64.r31;
 41 import static jdk.vm.ci.aarch64.AArch64.sp;
 42 import static jdk.vm.ci.aarch64.AArch64.v0;
 43 import static jdk.vm.ci.aarch64.AArch64.v1;
 44 import static jdk.vm.ci.aarch64.AArch64.v2;
 45 import static jdk.vm.ci.aarch64.AArch64.v3;
 46 import static jdk.vm.ci.aarch64.AArch64.v4;
 47 import static jdk.vm.ci.aarch64.AArch64.v5;
 48 import static jdk.vm.ci.aarch64.AArch64.v6;
 49 import static jdk.vm.ci.aarch64.AArch64.v7;
 50 import static jdk.vm.ci.aarch64.AArch64.zr;
 51 
 52 import java.util.ArrayList;
 53 import java.util.HashSet;
 54 import java.util.List;
 55 import java.util.Set;
 56 
 57 import jdk.vm.ci.aarch64.AArch64;
 58 import jdk.vm.ci.code.Architecture;
 59 import jdk.vm.ci.code.CallingConvention;
 60 import jdk.vm.ci.code.CallingConvention.Type;
 61 import jdk.vm.ci.code.Register;
 62 import jdk.vm.ci.code.RegisterArray;
 63 import jdk.vm.ci.code.RegisterAttributes;
 64 import jdk.vm.ci.code.RegisterConfig;
 65 import jdk.vm.ci.code.StackSlot;
 66 import jdk.vm.ci.code.TargetDescription;
 67 import jdk.vm.ci.code.ValueKindFactory;
 68 import jdk.vm.ci.common.JVMCIError;
 69 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
 70 import jdk.vm.ci.meta.AllocatableValue;
 71 import jdk.vm.ci.meta.JavaKind;
 72 import jdk.vm.ci.meta.JavaType;
 73 import jdk.vm.ci.meta.PlatformKind;
 74 import jdk.vm.ci.meta.Value;
 75 import jdk.vm.ci.meta.ValueKind;
 76 
 77 public class AArch64HotSpotRegisterConfig implements RegisterConfig {
 78 
 79     private final TargetDescription target;
 80 
 81     private final RegisterArray allocatable;
 82 
 83     /**
 84      * The caller saved registers always include all parameter registers.
 85      */
 86     private final RegisterArray callerSaved;
 87 
 88     private final boolean allAllocatableAreCallerSaved;
 89 
 90     private final RegisterAttributes[] attributesMap;
 91 
 92     @Override
 93     public RegisterArray getAllocatableRegisters() {
 94         return allocatable;
 95     }
 96 
 97     @Override
 98     public RegisterArray filterAllocatableRegisters(PlatformKind kind, RegisterArray registers) {
 99         ArrayList&lt;Register&gt; list = new ArrayList&lt;&gt;();
100         for (Register reg : registers) {
101             if (target.arch.canStoreValue(reg.getRegisterCategory(), kind)) {
102                 list.add(reg);
103             }
104         }
105 
106         return new RegisterArray(list);
107     }
108 
109     @Override
110     public RegisterAttributes[] getAttributesMap() {
111         return attributesMap.clone();
112     }
113 
114     private final RegisterArray javaGeneralParameterRegisters = new RegisterArray(r1, r2, r3, r4, r5, r6, r7, r0);
115     private final RegisterArray nativeGeneralParameterRegisters = new RegisterArray(r0, r1, r2, r3, r4, r5, r6, r7);
116     private final RegisterArray simdParameterRegisters = new RegisterArray(v0, v1, v2, v3, v4, v5, v6, v7);
117 
118     public static final Register inlineCacheRegister = rscratch2;
119 
120     /**
121      * Vtable stubs expect the metaspace Method in r12.
122      */
123     public static final Register metaspaceMethodRegister = r12;
124 
125     public static final Register heapBaseRegister = r27;
126     public static final Register threadRegister = r28;
127     public static final Register fp = r29;
128 
129     private static final RegisterArray reservedRegisters = new RegisterArray(rscratch1, rscratch2, threadRegister, fp, lr, r31, zr, sp);
130 
131     private static RegisterArray initAllocatable(Architecture arch, boolean reserveForHeapBase) {
132         RegisterArray allRegisters = arch.getAvailableValueRegisters();
133         Register[] registers = new Register[allRegisters.size() - reservedRegisters.size() - (reserveForHeapBase ? 1 : 0)];
134         List&lt;Register&gt; reservedRegistersList = reservedRegisters.asList();
135 
136         int idx = 0;
137         for (Register reg : allRegisters) {
138             if (reservedRegistersList.contains(reg)) {
139                 // skip reserved registers
140                 continue;
141             }
142             assert !(reg.equals(threadRegister) || reg.equals(fp) || reg.equals(lr) || reg.equals(r31) || reg.equals(zr) || reg.equals(sp));
143             if (reserveForHeapBase &amp;&amp; reg.equals(heapBaseRegister)) {
144                 // skip heap base register
145                 continue;
146             }
147 
148             registers[idx++] = reg;
149         }
150 
151         assert idx == registers.length;
152         return new RegisterArray(registers);
153     }
154 
155     public AArch64HotSpotRegisterConfig(TargetDescription target, boolean useCompressedOops) {
156         this(target, initAllocatable(target.arch, useCompressedOops));
157         assert callerSaved.size() &gt;= allocatable.size();
158     }
159 
160     public AArch64HotSpotRegisterConfig(TargetDescription target, RegisterArray allocatable) {
161         this.target = target;
162 
163         this.allocatable = allocatable;
164         Set&lt;Register&gt; callerSaveSet = new HashSet&lt;&gt;();
165         allocatable.addTo(callerSaveSet);
166         simdParameterRegisters.addTo(callerSaveSet);
167         javaGeneralParameterRegisters.addTo(callerSaveSet);
168         nativeGeneralParameterRegisters.addTo(callerSaveSet);
169         callerSaved = new RegisterArray(callerSaveSet);
170 
171         allAllocatableAreCallerSaved = true;
172         attributesMap = RegisterAttributes.createMap(this, AArch64.allRegisters);
173     }
174 
175     @Override
176     public RegisterArray getCallerSaveRegisters() {
177         return callerSaved;
178     }
179 
180     @Override
181     public RegisterArray getCalleeSaveRegisters() {
182         return null;
183     }
184 
185     @Override
186     public boolean areAllAllocatableRegistersCallerSaved() {
187         return allAllocatableAreCallerSaved;
188     }
189 
190     @Override
191     public CallingConvention getCallingConvention(Type type, JavaType returnType, JavaType[] parameterTypes, ValueKindFactory&lt;?&gt; valueKindFactory) {
192         HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;
193         if (type == HotSpotCallingConventionType.NativeCall) {
194             return callingConvention(nativeGeneralParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);
195         }
196         // On x64, parameter locations are the same whether viewed
197         // from the caller or callee perspective
198         return callingConvention(javaGeneralParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);
199     }
200 
201     @Override
202     public RegisterArray getCallingConventionRegisters(Type type, JavaKind kind) {
203         HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;
204         switch (kind) {
205             case Boolean:
206             case Byte:
207             case Short:
208             case Char:
209             case Int:
210             case Long:
211             case Object:
212                 return hotspotType == HotSpotCallingConventionType.NativeCall ? nativeGeneralParameterRegisters : javaGeneralParameterRegisters;
213             case Float:
214             case Double:
215                 return simdParameterRegisters;
216             default:
217                 throw JVMCIError.shouldNotReachHere();
218         }
219     }
220 
221     private CallingConvention callingConvention(RegisterArray generalParameterRegisters, JavaType returnType, JavaType[] parameterTypes, HotSpotCallingConventionType type,
222                     ValueKindFactory&lt;?&gt; valueKindFactory) {
223         AllocatableValue[] locations = new AllocatableValue[parameterTypes.length];
224 
225         int currentGeneral = 0;
226         int currentSIMD = 0;
227         int currentStackOffset = 0;
228 
229         for (int i = 0; i &lt; parameterTypes.length; i++) {
230             final JavaKind kind = parameterTypes[i].getJavaKind().getStackKind();
231 
232             switch (kind) {
233                 case Byte:
234                 case Boolean:
235                 case Short:
236                 case Char:
237                 case Int:
238                 case Long:
239                 case Object:
240                     if (currentGeneral &lt; generalParameterRegisters.size()) {
241                         Register register = generalParameterRegisters.get(currentGeneral++);
242                         locations[i] = register.asValue(valueKindFactory.getValueKind(kind));
243                     }
244                     break;
245                 case Float:
246                 case Double:
247                     if (currentSIMD &lt; simdParameterRegisters.size()) {
248                         Register register = simdParameterRegisters.get(currentSIMD++);
249                         locations[i] = register.asValue(valueKindFactory.getValueKind(kind));
250                     }
251                     break;
252                 default:
253                     throw JVMCIError.shouldNotReachHere();
254             }
255 
256             if (locations[i] == null) {
257                 ValueKind&lt;?&gt; valueKind = valueKindFactory.getValueKind(kind);
258                 locations[i] = StackSlot.get(valueKind, currentStackOffset, !type.out);
259                 currentStackOffset += Math.max(valueKind.getPlatformKind().getSizeInBytes(), target.wordSize);
260             }
261         }
262 
263         JavaKind returnKind = returnType == null ? JavaKind.Void : returnType.getJavaKind();
264         AllocatableValue returnLocation = returnKind == JavaKind.Void ? Value.ILLEGAL : getReturnRegister(returnKind).asValue(valueKindFactory.getValueKind(returnKind.getStackKind()));
265         return new CallingConvention(currentStackOffset, returnLocation, locations);
266     }
267 
268     @Override
269     public Register getReturnRegister(JavaKind kind) {
270         switch (kind) {
271             case Boolean:
272             case Byte:
273             case Char:
274             case Short:
275             case Int:
276             case Long:
277             case Object:
278                 return r0;
279             case Float:
280             case Double:
281                 return v0;
282             case Void:
283             case Illegal:
284                 return null;
285             default:
286                 throw new UnsupportedOperationException(&quot;no return register for type &quot; + kind);
287         }
288     }
289 
290     @Override
291     public Register getFrameRegister() {
292         return sp;
293     }
294 
295     @Override
296     public String toString() {
297         return String.format(&quot;Allocatable: &quot; + getAllocatableRegisters() + &quot;%n&quot; + &quot;CallerSave:  &quot; + getCallerSaveRegisters() + &quot;%n&quot;);
298     }
299 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
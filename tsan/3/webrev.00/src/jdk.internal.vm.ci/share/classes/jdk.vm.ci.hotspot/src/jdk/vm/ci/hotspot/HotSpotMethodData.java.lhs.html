<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodData.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static java.lang.String.format;
 26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
 27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
 29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 30 
 31 import java.util.Arrays;
 32 
<a name="2" id="anc2"></a>
 33 import jdk.internal.misc.Unsafe;
 34 import jdk.vm.ci.meta.DeoptimizationReason;
 35 import jdk.vm.ci.meta.JavaMethodProfile;
 36 import jdk.vm.ci.meta.JavaMethodProfile.ProfiledMethod;
 37 import jdk.vm.ci.meta.JavaTypeProfile;
 38 import jdk.vm.ci.meta.JavaTypeProfile.ProfiledType;
 39 import jdk.vm.ci.meta.ResolvedJavaMethod;
 40 import jdk.vm.ci.meta.ResolvedJavaType;
 41 import jdk.vm.ci.meta.TriState;
 42 
 43 /**
 44  * Access to a HotSpot {@code MethodData} structure (defined in methodData.hpp).
 45  */
 46 final class HotSpotMethodData {
 47 
<a name="3" id="anc3"></a><span class="line-modified"> 48     static final HotSpotVMConfig config = config();</span>
<span class="line-modified"> 49     static final HotSpotMethodDataAccessor NO_DATA_NO_EXCEPTION_ACCESSOR = new NoMethodData(config, config.dataLayoutNoTag, TriState.FALSE);</span>
<span class="line-modified"> 50     static final HotSpotMethodDataAccessor NO_DATA_EXCEPTION_POSSIBLY_NOT_RECORDED_ACCESSOR = new NoMethodData(config, config.dataLayoutNoTag, TriState.UNKNOWN);</span>















































































































 51 
 52     /**
 53      * Reference to the C++ MethodData object.
 54      */
 55     final long metaspaceMethodData;
 56     private final HotSpotResolvedJavaMethodImpl method;
<a name="4" id="anc4"></a>
 57 
 58     HotSpotMethodData(long metaspaceMethodData, HotSpotResolvedJavaMethodImpl method) {
 59         this.metaspaceMethodData = metaspaceMethodData;
 60         this.method = method;
<a name="5" id="anc5"></a>
 61     }
 62 
 63     /**
 64      * @return value of the MethodData::_data_size field
 65      */
 66     private int normalDataSize() {
<a name="6" id="anc6"></a><span class="line-modified"> 67         return UNSAFE.getInt(metaspaceMethodData + config.methodDataDataSize);</span>
 68     }
 69 
 70     /**
 71      * Returns the size of the extra data records. This method does the same calculation as
 72      * MethodData::extra_data_size().
 73      *
 74      * @return size of extra data records
 75      */
 76     private int extraDataSize() {
<a name="7" id="anc7"></a><span class="line-modified"> 77         final int extraDataBase = config.methodDataOopDataOffset + normalDataSize();</span>
<span class="line-modified"> 78         final int extraDataLimit = UNSAFE.getInt(metaspaceMethodData + config.methodDataSize);</span>
 79         return extraDataLimit - extraDataBase;
 80     }
 81 
 82     public boolean hasNormalData() {
 83         return normalDataSize() &gt; 0;
 84     }
 85 
 86     public boolean hasExtraData() {
 87         return extraDataSize() &gt; 0;
 88     }
 89 
 90     public int getExtraDataBeginOffset() {
 91         return normalDataSize();
 92     }
 93 
 94     public boolean isWithin(int position) {
 95         return position &gt;= 0 &amp;&amp; position &lt; normalDataSize() + extraDataSize();
 96     }
 97 
 98     public int getDeoptimizationCount(DeoptimizationReason reason) {
 99         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
100         int reasonIndex = metaAccess.convertDeoptReason(reason);
<a name="8" id="anc8"></a><span class="line-modified">101         return UNSAFE.getByte(metaspaceMethodData + config.methodDataOopTrapHistoryOffset + reasonIndex) &amp; 0xFF;</span>
102     }
103 
104     public int getOSRDeoptimizationCount(DeoptimizationReason reason) {
105         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
106         int reasonIndex = metaAccess.convertDeoptReason(reason);
<a name="9" id="anc9"></a><span class="line-modified">107         return UNSAFE.getByte(metaspaceMethodData + config.methodDataOopTrapHistoryOffset + config.deoptReasonOSROffset + reasonIndex) &amp; 0xFF;</span>
108     }
109 
110     public int getDecompileCount() {
<a name="10" id="anc10"></a><span class="line-modified">111         return UNSAFE.getInt(metaspaceMethodData + config.methodDataDecompiles);</span>
112     }
113 
114     public int getOverflowRecompileCount() {
<a name="11" id="anc11"></a><span class="line-modified">115         return UNSAFE.getInt(metaspaceMethodData + config.methodDataOverflowRecompiles);</span>
116     }
117 
118     public int getOverflowTrapCount() {
<a name="12" id="anc12"></a><span class="line-modified">119         return UNSAFE.getInt(metaspaceMethodData + config.methodDataOverflowTraps);</span>
120     }
121 
122     public HotSpotMethodDataAccessor getNormalData(int position) {
123         if (position &gt;= normalDataSize()) {
124             return null;
125         }
126 
127         return getData(position);
128     }
129 
130     public HotSpotMethodDataAccessor getExtraData(int position) {
131         if (position &gt;= normalDataSize() + extraDataSize()) {
132             return null;
133         }
134         HotSpotMethodDataAccessor data = getData(position);
135         if (data != null) {
136             return data;
137         }
138         return data;
139     }
140 
141     public static HotSpotMethodDataAccessor getNoDataAccessor(boolean exceptionPossiblyNotRecorded) {
142         if (exceptionPossiblyNotRecorded) {
<a name="13" id="anc13"></a><span class="line-modified">143             return NO_DATA_EXCEPTION_POSSIBLY_NOT_RECORDED_ACCESSOR;</span>
144         } else {
<a name="14" id="anc14"></a><span class="line-modified">145             return NO_DATA_NO_EXCEPTION_ACCESSOR;</span>
146         }
147     }
148 
149     private HotSpotMethodDataAccessor getData(int position) {
150         assert position &gt;= 0 : &quot;out of bounds&quot;;
<a name="15" id="anc15"></a><span class="line-modified">151         final int tag = HotSpotMethodDataAccessor.readTag(config, this, position);</span>
<span class="line-modified">152         HotSpotMethodDataAccessor accessor = PROFILE_DATA_ACCESSORS[tag];</span>
153         assert accessor == null || accessor.getTag() == tag : &quot;wrong data accessor &quot; + accessor + &quot; for tag &quot; + tag;
154         return accessor;
155     }
156 
157     int readUnsignedByte(int position, int offsetInBytes) {
<a name="16" id="anc16"></a><span class="line-modified">158         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);</span>
159         return UNSAFE.getByte(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFF;
160     }
161 
162     int readUnsignedShort(int position, int offsetInBytes) {
<a name="17" id="anc17"></a><span class="line-modified">163         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);</span>
164         return UNSAFE.getShort(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFF;
165     }
166 
167     /**
168      * Since the values are stored in cells (platform words) this method uses
169      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
170      */
171     private long readUnsignedInt(int position, int offsetInBytes) {
<a name="18" id="anc18"></a><span class="line-modified">172         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);</span>
173         return UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFFFFFFL;
174     }
175 
176     private int readUnsignedIntAsSignedInt(int position, int offsetInBytes) {
177         long value = readUnsignedInt(position, offsetInBytes);
<a name="19" id="anc19"></a><span class="line-modified">178         return truncateLongToInt(value);</span>
179     }
180 
181     /**
182      * Since the values are stored in cells (platform words) this method uses
183      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
184      */
185     private int readInt(int position, int offsetInBytes) {
<a name="20" id="anc20"></a><span class="line-modified">186         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);</span>
187         return (int) UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes);
188     }
189 
190     private HotSpotResolvedJavaMethod readMethod(int position, int offsetInBytes) {
<a name="21" id="anc21"></a><span class="line-modified">191         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);</span>
192         return compilerToVM().getResolvedJavaMethod(null, metaspaceMethodData + fullOffsetInBytes);
193     }
194 
195     private HotSpotResolvedObjectTypeImpl readKlass(int position, int offsetInBytes) {
<a name="22" id="anc22"></a><span class="line-modified">196         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);</span>
<span class="line-modified">197         return compilerToVM().getResolvedJavaType(null, metaspaceMethodData + fullOffsetInBytes, false);</span>
<span class="line-removed">198     }</span>
<span class="line-removed">199 </span>
<span class="line-removed">200     private static int truncateLongToInt(long value) {</span>
<span class="line-removed">201         return value &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) value;</span>
<span class="line-removed">202     }</span>
<span class="line-removed">203 </span>
<span class="line-removed">204     private static int computeFullOffset(int position, int offsetInBytes) {</span>
<span class="line-removed">205         return config.methodDataOopDataOffset + position + offsetInBytes;</span>
<span class="line-removed">206     }</span>
<span class="line-removed">207 </span>
<span class="line-removed">208     private static int cellIndexToOffset(int cells) {</span>
<span class="line-removed">209         return config.dataLayoutHeaderSize + cellsToBytes(cells);</span>
<span class="line-removed">210     }</span>
<span class="line-removed">211 </span>
<span class="line-removed">212     private static int cellsToBytes(int cells) {</span>
<span class="line-removed">213         return cells * config.dataLayoutCellSize;</span>
214     }
215 
216     /**
217      * Returns whether profiling ran long enough that the profile information is mature. Other
218      * informational data will still be valid even if the profile isn&#39;t mature.
219      */
220     public boolean isProfileMature() {
221         return runtime().getCompilerToVM().isMature(metaspaceMethodData);
222     }
223 
224     @Override
225     public String toString() {
226         StringBuilder sb = new StringBuilder();
227         String nl = String.format(&quot;%n&quot;);
228         String nlIndent = String.format(&quot;%n%38s&quot;, &quot;&quot;);
229         sb.append(&quot;Raw method data for &quot;);
230         sb.append(method.format(&quot;%H.%n(%p)&quot;));
231         sb.append(&quot;:&quot;);
232         sb.append(nl);
233         sb.append(String.format(&quot;nof_decompiles(%d) nof_overflow_recompiles(%d) nof_overflow_traps(%d)%n&quot;,
234                         getDecompileCount(), getOverflowRecompileCount(), getOverflowTrapCount()));
235         if (hasNormalData()) {
236             int pos = 0;
237             HotSpotMethodDataAccessor data;
238             while ((data = getNormalData(pos)) != null) {
239                 if (pos != 0) {
240                     sb.append(nl);
241                 }
242                 int bci = data.getBCI(this, pos);
243                 sb.append(String.format(&quot;%-6d bci: %-6d%-20s&quot;, pos, bci, data.getClass().getSimpleName()));
244                 sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));
245                 pos = pos + data.getSize(this, pos);
246             }
247         }
248 
249         if (hasExtraData()) {
250             int pos = getExtraDataBeginOffset();
251             HotSpotMethodDataAccessor data;
252             while ((data = getExtraData(pos)) != null) {
253                 if (pos == getExtraDataBeginOffset()) {
254                     sb.append(nl).append(&quot;--- Extra data:&quot;);
255                 }
256                 int bci = data.getBCI(this, pos);
257                 sb.append(String.format(&quot;%n%-6d bci: %-6d%-20s&quot;, pos, bci, data.getClass().getSimpleName()));
258                 sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));
259                 pos = pos + data.getSize(this, pos);
260             }
261 
262         }
263         return sb.toString();
264     }
265 
<a name="23" id="anc23"></a><span class="line-removed">266     static final int NO_DATA_SIZE = cellIndexToOffset(0);</span>
<span class="line-removed">267 </span>
268     static class NoMethodData extends HotSpotMethodDataAccessor {
269 
270         private final TriState exceptionSeen;
271 
<a name="24" id="anc24"></a><span class="line-modified">272         protected NoMethodData(HotSpotVMConfig config, int tag, TriState exceptionSeen) {</span>
<span class="line-modified">273             super(config, tag, NO_DATA_SIZE);</span>
274             this.exceptionSeen = exceptionSeen;
275         }
276 
277         @Override
278         public int getBCI(HotSpotMethodData data, int position) {
279             return -1;
280         }
281 
282         @Override
283         public TriState getExceptionSeen(HotSpotMethodData data, int position) {
284             return exceptionSeen;
285         }
286 
287         @Override
288         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
289             return sb;
290         }
291     }
292 
<a name="25" id="anc25"></a><span class="line-removed">293     static final int BIT_DATA_SIZE = cellIndexToOffset(0);</span>
<span class="line-removed">294     static final int BIT_DATA_NULL_SEEN_FLAG = 1 &lt;&lt; config.bitDataNullSeenFlag;</span>
<span class="line-removed">295 </span>
296     static class BitData extends HotSpotMethodDataAccessor {
297 
<a name="26" id="anc26"></a><span class="line-modified">298         private BitData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">299             super(config, tag, BIT_DATA_SIZE);</span>
300         }
301 
<a name="27" id="anc27"></a><span class="line-modified">302         protected BitData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="line-modified">303             super(config, tag, staticSize);</span>
304         }
305 
306         @Override
307         public TriState getNullSeen(HotSpotMethodData data, int position) {
<a name="28" id="anc28"></a><span class="line-modified">308             return TriState.get((getFlags(data, position) &amp; BIT_DATA_NULL_SEEN_FLAG) != 0);</span>
309         }
310 
311         @Override
312         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
313             return sb.append(format(&quot;exception_seen(%s)&quot;, getExceptionSeen(data, pos)));
314         }
315     }
316 
<a name="29" id="anc29"></a><span class="line-removed">317     static final int COUNTER_DATA_SIZE = cellIndexToOffset(1);</span>
<span class="line-removed">318     static final int COUNTER_DATA_COUNT_OFFSET = cellIndexToOffset(config.methodDataCountOffset);</span>
<span class="line-removed">319 </span>
320     static class CounterData extends BitData {
321 
<a name="30" id="anc30"></a><span class="line-modified">322         CounterData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">323             super(config, tag, COUNTER_DATA_SIZE);</span>
324         }
325 
<a name="31" id="anc31"></a><span class="line-modified">326         protected CounterData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="line-modified">327             super(config, tag, staticSize);</span>
328         }
329 
330         @Override
331         public int getExecutionCount(HotSpotMethodData data, int position) {
332             return getCounterValue(data, position);
333         }
334 
335         protected int getCounterValue(HotSpotMethodData data, int position) {
<a name="32" id="anc32"></a><span class="line-modified">336             return data.readUnsignedIntAsSignedInt(position, COUNTER_DATA_COUNT_OFFSET);</span>
337         }
338 
339         @Override
340         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
341             return sb.append(format(&quot;count(%d) null_seen(%s) exception_seen(%s)&quot;, getCounterValue(data, pos), getNullSeen(data, pos), getExceptionSeen(data, pos)));
342         }
343     }
344 
<a name="33" id="anc33"></a><span class="line-removed">345     static final int JUMP_DATA_SIZE = cellIndexToOffset(2);</span>
<span class="line-removed">346     static final int TAKEN_COUNT_OFFSET = cellIndexToOffset(config.jumpDataTakenOffset);</span>
<span class="line-removed">347     static final int TAKEN_DISPLACEMENT_OFFSET = cellIndexToOffset(config.jumpDataDisplacementOffset);</span>
<span class="line-removed">348 </span>
349     static class JumpData extends HotSpotMethodDataAccessor {
350 
<a name="34" id="anc34"></a><span class="line-modified">351         JumpData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">352             super(config, tag, JUMP_DATA_SIZE);</span>
353         }
354 
<a name="35" id="anc35"></a><span class="line-modified">355         protected JumpData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="line-modified">356             super(config, tag, staticSize);</span>
357         }
358 
359         @Override
360         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
361             return getExecutionCount(data, position) != 0 ? 1 : 0;
362         }
363 
364         @Override
365         public int getExecutionCount(HotSpotMethodData data, int position) {
<a name="36" id="anc36"></a><span class="line-modified">366             return data.readUnsignedIntAsSignedInt(position, TAKEN_COUNT_OFFSET);</span>
367         }
368 
369         public int getTakenDisplacement(HotSpotMethodData data, int position) {
<a name="37" id="anc37"></a><span class="line-modified">370             return data.readInt(position, TAKEN_DISPLACEMENT_OFFSET);</span>
371         }
372 
373         @Override
374         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
375             return sb.append(format(&quot;taken(%d) displacement(%d)&quot;, getExecutionCount(data, pos), getTakenDisplacement(data, pos)));
376         }
377     }
378 
379     static class RawItemProfile&lt;T&gt; {
380         final int entries;
381         final T[] items;
382         final long[] counts;
383         final long totalCount;
384 
385         RawItemProfile(int entries, T[] items, long[] counts, long totalCount) {
386             this.entries = entries;
387             this.items = items;
388             this.counts = counts;
389             this.totalCount = totalCount;
390         }
391     }
392 
<a name="38" id="anc38"></a><span class="line-removed">393     static final int TYPE_DATA_ROW_SIZE = cellsToBytes(config.receiverTypeDataReceiverTypeRowCellCount);</span>
<span class="line-removed">394 </span>
<span class="line-removed">395     static final int NONPROFILED_COUNT_OFFSET = cellIndexToOffset(config.receiverTypeDataNonprofiledCountOffset);</span>
<span class="line-removed">396     static final int TYPE_DATA_FIRST_TYPE_OFFSET = cellIndexToOffset(config.receiverTypeDataReceiver0Offset);</span>
<span class="line-removed">397     static final int TYPE_DATA_FIRST_TYPE_COUNT_OFFSET = cellIndexToOffset(config.receiverTypeDataCount0Offset);</span>
<span class="line-removed">398 </span>
399     abstract static class AbstractTypeData extends CounterData {
400 
<a name="39" id="anc39"></a><span class="line-modified">401         protected AbstractTypeData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="line-modified">402             super(config, tag, staticSize);</span>
403         }
404 
405         @Override
406         public JavaTypeProfile getTypeProfile(HotSpotMethodData data, int position) {
407             return createTypeProfile(getNullSeen(data, position), getRawTypeProfile(data, position));
408         }
409 
410         private RawItemProfile&lt;ResolvedJavaType&gt; getRawTypeProfile(HotSpotMethodData data, int position) {
411             int typeProfileWidth = config.typeProfileWidth;
412 
413             ResolvedJavaType[] types = new ResolvedJavaType[typeProfileWidth];
414             long[] counts = new long[typeProfileWidth];
415             long totalCount = 0;
416             int entries = 0;
417 
418             outer: for (int i = 0; i &lt; typeProfileWidth; i++) {
419                 HotSpotResolvedObjectTypeImpl receiverKlass = data.readKlass(position, getTypeOffset(i));
420                 if (receiverKlass != null) {
421                     HotSpotResolvedObjectTypeImpl klass = receiverKlass;
422                     long count = data.readUnsignedInt(position, getTypeCountOffset(i));
423                     /*
424                      * Because of races in the profile collection machinery it&#39;s possible for a
425                      * class to appear multiple times so merge them to make the profile look
426                      * rational.
427                      */
428                     for (int j = 0; j &lt; entries; j++) {
429                         if (types[j].equals(klass)) {
430                             totalCount += count;
431                             counts[j] += count;
432                             continue outer;
433                         }
434                     }
435                     types[entries] = klass;
436                     totalCount += count;
437                     counts[entries] = count;
438                     entries++;
439                 }
440             }
441 
442             totalCount += getTypesNotRecordedExecutionCount(data, position);
443             return new RawItemProfile&lt;&gt;(entries, types, counts, totalCount);
444         }
445 
446         protected abstract long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position);
447 
448         public int getNonprofiledCount(HotSpotMethodData data, int position) {
<a name="40" id="anc40"></a><span class="line-modified">449             return data.readUnsignedIntAsSignedInt(position, NONPROFILED_COUNT_OFFSET);</span>
450         }
451 
452         private JavaTypeProfile createTypeProfile(TriState nullSeen, RawItemProfile&lt;ResolvedJavaType&gt; profile) {
453             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
454                 return null;
455             }
456 
457             ProfiledType[] ptypes = new ProfiledType[profile.entries];
458             double totalProbability = 0.0;
459             for (int i = 0; i &lt; profile.entries; i++) {
460                 double p = profile.counts[i];
461                 p = p / profile.totalCount;
462                 totalProbability += p;
463                 ptypes[i] = new ProfiledType(profile.items[i], p);
464             }
465 
466             Arrays.sort(ptypes);
467 
468             double notRecordedTypeProbability = profile.entries &lt; config.typeProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
469             assert notRecordedTypeProbability == 0 || profile.entries == config.typeProfileWidth;
470             return new JavaTypeProfile(nullSeen, notRecordedTypeProbability, ptypes);
471         }
472 
<a name="41" id="anc41"></a><span class="line-modified">473         private static int getTypeOffset(int row) {</span>
<span class="line-modified">474             return TYPE_DATA_FIRST_TYPE_OFFSET + row * TYPE_DATA_ROW_SIZE;</span>
475         }
476 
<a name="42" id="anc42"></a><span class="line-modified">477         protected static int getTypeCountOffset(int row) {</span>
<span class="line-modified">478             return TYPE_DATA_FIRST_TYPE_COUNT_OFFSET + row * TYPE_DATA_ROW_SIZE;</span>
479         }
480 
481         @Override
482         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
483             RawItemProfile&lt;ResolvedJavaType&gt; profile = getRawTypeProfile(data, pos);
484             TriState nullSeen = getNullSeen(data, pos);
485             TriState exceptionSeen = getExceptionSeen(data, pos);
486             sb.append(format(&quot;count(%d) null_seen(%s) exception_seen(%s) nonprofiled_count(%d) entries(%d)&quot;, getCounterValue(data, pos), nullSeen, exceptionSeen,
487                             getNonprofiledCount(data, pos), profile.entries));
488             for (int i = 0; i &lt; profile.entries; i++) {
489                 long count = profile.counts[i];
490                 sb.append(format(&quot;%n  %s (%d, %4.2f)&quot;, profile.items[i].toJavaName(), count, (double) count / profile.totalCount));
491             }
492             return sb;
493         }
494     }
495 
<a name="43" id="anc43"></a><span class="line-removed">496     static final int TYPE_CHECK_DATA_SIZE = cellIndexToOffset(2) + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
<span class="line-removed">497 </span>
498     static class ReceiverTypeData extends AbstractTypeData {
499 
<a name="44" id="anc44"></a><span class="line-modified">500         ReceiverTypeData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">501             super(config, tag, TYPE_CHECK_DATA_SIZE);</span>
502         }
503 
<a name="45" id="anc45"></a><span class="line-modified">504         protected ReceiverTypeData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="line-modified">505             super(config, tag, staticSize);</span>
506         }
507 
508         @Override
509         public int getExecutionCount(HotSpotMethodData data, int position) {
510             return -1;
511         }
512 
513         @Override
514         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
515             return getNonprofiledCount(data, position);
516         }
517     }
518 
<a name="46" id="anc46"></a><span class="line-removed">519     static final int VIRTUAL_CALL_DATA_SIZE = cellIndexToOffset(2) + TYPE_DATA_ROW_SIZE * (config.typeProfileWidth + config.methodProfileWidth);</span>
<span class="line-removed">520     static final int VIRTUAL_CALL_DATA_FIRST_METHOD_OFFSET = TYPE_DATA_FIRST_TYPE_OFFSET + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
<span class="line-removed">521     static final int VIRTUAL_CALL_DATA_FIRST_METHOD_COUNT_OFFSET = TYPE_DATA_FIRST_TYPE_COUNT_OFFSET + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
<span class="line-removed">522 </span>
523     static class VirtualCallData extends ReceiverTypeData {
524 
<a name="47" id="anc47"></a><span class="line-modified">525         VirtualCallData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">526             super(config, tag, VIRTUAL_CALL_DATA_SIZE);</span>
527         }
528 
<a name="48" id="anc48"></a><span class="line-modified">529         protected VirtualCallData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="line-modified">530             super(config, tag, staticSize);</span>
531         }
532 
533         @Override
534         public int getExecutionCount(HotSpotMethodData data, int position) {
535             final int typeProfileWidth = config.typeProfileWidth;
536 
537             long total = 0;
538             for (int i = 0; i &lt; typeProfileWidth; i++) {
539                 total += data.readUnsignedInt(position, getTypeCountOffset(i));
540             }
541 
542             total += getCounterValue(data, position);
<a name="49" id="anc49"></a><span class="line-modified">543             return truncateLongToInt(total);</span>
544         }
545 
546         @Override
547         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
548             return getCounterValue(data, position);
549         }
550 
<a name="50" id="anc50"></a><span class="line-modified">551         private static long getMethodsNotRecordedExecutionCount(HotSpotMethodData data, int position) {</span>
<span class="line-modified">552             return data.readUnsignedIntAsSignedInt(position, NONPROFILED_COUNT_OFFSET);</span>
553         }
554 
555         @Override
556         public JavaMethodProfile getMethodProfile(HotSpotMethodData data, int position) {
557             return createMethodProfile(getRawMethodProfile(data, position));
558         }
559 
560         private RawItemProfile&lt;ResolvedJavaMethod&gt; getRawMethodProfile(HotSpotMethodData data, int position) {
561             int profileWidth = config.methodProfileWidth;
562 
563             ResolvedJavaMethod[] methods = new ResolvedJavaMethod[profileWidth];
564             long[] counts = new long[profileWidth];
565             long totalCount = 0;
566             int entries = 0;
567 
568             for (int i = 0; i &lt; profileWidth; i++) {
569                 HotSpotResolvedJavaMethod method = data.readMethod(position, getMethodOffset(i));
570                 if (method != null) {
571                     methods[entries] = method;
572                     long count = data.readUnsignedInt(position, getMethodCountOffset(i));
573                     totalCount += count;
574                     counts[entries] = count;
575 
576                     entries++;
577                 }
578             }
579 
580             totalCount += getMethodsNotRecordedExecutionCount(data, position);
581 
582             // Fixup the case of C1&#39;s inability to optimize profiling of a statically bindable call
583             // site. If it&#39;s a monomorphic call site, attribute all the counts to the first type (if
584             // any is recorded).
585             if (entries == 1) {
586                 counts[0] = totalCount;
587             }
588 
589             return new RawItemProfile&lt;&gt;(entries, methods, counts, totalCount);
590         }
591 
592         private JavaMethodProfile createMethodProfile(RawItemProfile&lt;ResolvedJavaMethod&gt; profile) {
593             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
594                 return null;
595             }
596 
597             ProfiledMethod[] pmethods = new ProfiledMethod[profile.entries];
598             double totalProbability = 0.0;
599             for (int i = 0; i &lt; profile.entries; i++) {
600                 double p = profile.counts[i];
601                 p = p / profile.totalCount;
602                 totalProbability += p;
603                 pmethods[i] = new ProfiledMethod(profile.items[i], p);
604             }
605 
606             Arrays.sort(pmethods);
607 
608             double notRecordedMethodProbability = profile.entries &lt; config.methodProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
609             assert notRecordedMethodProbability == 0 || profile.entries == config.methodProfileWidth;
610             return new JavaMethodProfile(notRecordedMethodProbability, pmethods);
611         }
612 
<a name="51" id="anc51"></a><span class="line-modified">613         private static int getMethodOffset(int row) {</span>
<span class="line-modified">614             return VIRTUAL_CALL_DATA_FIRST_METHOD_OFFSET + row * TYPE_DATA_ROW_SIZE;</span>
615         }
616 
<a name="52" id="anc52"></a><span class="line-modified">617         private static int getMethodCountOffset(int row) {</span>
<span class="line-modified">618             return VIRTUAL_CALL_DATA_FIRST_METHOD_COUNT_OFFSET + row * TYPE_DATA_ROW_SIZE;</span>
619         }
620 
621         @Override
622         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
623             RawItemProfile&lt;ResolvedJavaMethod&gt; profile = getRawMethodProfile(data, pos);
624             super.appendTo(sb.append(format(&quot;exception_seen(%s) &quot;, getExceptionSeen(data, pos))), data, pos).append(format(&quot;%nmethod_entries(%d)&quot;, profile.entries));
625             for (int i = 0; i &lt; profile.entries; i++) {
626                 long count = profile.counts[i];
627                 sb.append(format(&quot;%n  %s (%d, %4.2f)&quot;, profile.items[i].format(&quot;%H.%n(%p)&quot;), count, (double) count / profile.totalCount));
628             }
629             return sb;
630         }
631     }
632 
633     static class VirtualCallTypeData extends VirtualCallData {
634 
<a name="53" id="anc53"></a><span class="line-modified">635         VirtualCallTypeData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">636             super(config, tag, 0);</span>
637         }
638 
639         @Override
640         protected int getDynamicSize(HotSpotMethodData data, int position) {
641             assert staticSize == 0;
642             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
643         }
644     }
645 
<a name="54" id="anc54"></a><span class="line-removed">646     static final int RET_DATA_ROW_SIZE = cellsToBytes(3);</span>
<span class="line-removed">647     static final int RET_DATA_SIZE = cellIndexToOffset(1) + RET_DATA_ROW_SIZE * config.bciProfileWidth;</span>
<span class="line-removed">648 </span>
649     static class RetData extends CounterData {
650 
<a name="55" id="anc55"></a><span class="line-modified">651         RetData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">652             super(config, tag, RET_DATA_SIZE);</span>
653         }
654     }
655 
<a name="56" id="anc56"></a><span class="line-removed">656     static final int BRANCH_DATA_SIZE = cellIndexToOffset(3);</span>
<span class="line-removed">657     static final int NOT_TAKEN_COUNT_OFFSET = cellIndexToOffset(config.branchDataNotTakenOffset);</span>
<span class="line-removed">658 </span>
659     static class BranchData extends JumpData {
660 
<a name="57" id="anc57"></a><span class="line-modified">661         BranchData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">662             super(config, tag, BRANCH_DATA_SIZE);</span>
663         }
664 
665         @Override
666         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
<a name="58" id="anc58"></a><span class="line-modified">667             long takenCount = data.readUnsignedInt(position, TAKEN_COUNT_OFFSET);</span>
<span class="line-modified">668             long notTakenCount = data.readUnsignedInt(position, NOT_TAKEN_COUNT_OFFSET);</span>
669             long total = takenCount + notTakenCount;
670 
671             return total &lt;= 0 ? -1 : takenCount / (double) total;
672         }
673 
674         @Override
675         public int getExecutionCount(HotSpotMethodData data, int position) {
<a name="59" id="anc59"></a><span class="line-modified">676             long count = data.readUnsignedInt(position, TAKEN_COUNT_OFFSET) + data.readUnsignedInt(position, NOT_TAKEN_COUNT_OFFSET);</span>
<span class="line-modified">677             return truncateLongToInt(count);</span>
678         }
679 
680         @Override
681         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
<a name="60" id="anc60"></a><span class="line-modified">682             long taken = data.readUnsignedInt(pos, TAKEN_COUNT_OFFSET);</span>
<span class="line-modified">683             long notTaken = data.readUnsignedInt(pos, NOT_TAKEN_COUNT_OFFSET);</span>
684             double takenProbability = getBranchTakenProbability(data, pos);
685             return sb.append(format(&quot;taken(%d, %4.2f) not_taken(%d, %4.2f) displacement(%d)&quot;, taken, takenProbability, notTaken, 1.0D - takenProbability, getTakenDisplacement(data, pos)));
686         }
687     }
688 
<a name="61" id="anc61"></a><span class="line-removed">689     static final int ARRAY_DATA_LENGTH_OFFSET = cellIndexToOffset(config.arrayDataArrayLenOffset);</span>
<span class="line-removed">690     static final int ARRAY_DATA_START_OFFSET = cellIndexToOffset(config.arrayDataArrayStartOffset);</span>
<span class="line-removed">691 </span>
692     static class ArrayData extends HotSpotMethodDataAccessor {
693 
<a name="62" id="anc62"></a><span class="line-modified">694         ArrayData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="line-modified">695             super(config, tag, staticSize);</span>
696         }
697 
698         @Override
699         protected int getDynamicSize(HotSpotMethodData data, int position) {
<a name="63" id="anc63"></a><span class="line-modified">700             return cellsToBytes(getLength(data, position));</span>
701         }
702 
<a name="64" id="anc64"></a><span class="line-modified">703         protected static int getLength(HotSpotMethodData data, int position) {</span>
<span class="line-modified">704             return data.readInt(position, ARRAY_DATA_LENGTH_OFFSET);</span>
705         }
706 
707         @Override
708         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
709             return sb.append(format(&quot;length(%d)&quot;, getLength(data, pos)));
710         }
711     }
712 
<a name="65" id="anc65"></a><span class="line-removed">713     static final int MULTI_BRANCH_DATA_SIZE = cellIndexToOffset(1);</span>
<span class="line-removed">714     static final int MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS = config.multiBranchDataPerCaseCellCount;</span>
<span class="line-removed">715     static final int MULTI_BRANCH_DATA_ROW_SIZE = cellsToBytes(MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS);</span>
<span class="line-removed">716     static final int MULTI_BRANCH_DATA_FIRST_COUNT_OFFSET = ARRAY_DATA_START_OFFSET + cellsToBytes(0);</span>
<span class="line-removed">717     static final int MULTI_BRANCH_DATA_FIRST_DISPLACEMENT_OFFSET = ARRAY_DATA_START_OFFSET + cellsToBytes(1);</span>
<span class="line-removed">718 </span>
719     static class MultiBranchData extends ArrayData {
720 
<a name="66" id="anc66"></a><span class="line-modified">721         MultiBranchData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">722             super(config, tag, MULTI_BRANCH_DATA_SIZE);</span>
723         }
724 
725         @Override
726         public double[] getSwitchProbabilities(HotSpotMethodData data, int position) {
727             int arrayLength = getLength(data, position);
728             assert arrayLength &gt; 0 : &quot;switch must have at least the default case&quot;;
<a name="67" id="anc67"></a><span class="line-modified">729             assert arrayLength % MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS == 0 : &quot;array must have full rows&quot;;</span>
730 
<a name="68" id="anc68"></a><span class="line-modified">731             int length = arrayLength / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;</span>
732             long totalCount = 0;
733             double[] result = new double[length];
734 
735             // default case is first in HotSpot but last for the compiler
736             long count = readCount(data, position, 0);
737             totalCount += count;
738             result[length - 1] = count;
739 
740             for (int i = 1; i &lt; length; i++) {
741                 count = readCount(data, position, i);
742                 totalCount += count;
743                 result[i - 1] = count;
744             }
745 
746             if (totalCount &lt;= 0) {
747                 return null;
748             } else {
749                 for (int i = 0; i &lt; length; i++) {
750                     result[i] = result[i] / totalCount;
751                 }
752                 return result;
753             }
754         }
755 
<a name="69" id="anc69"></a><span class="line-modified">756         private static long readCount(HotSpotMethodData data, int position, int i) {</span>
757             int offset;
758             long count;
759             offset = getCountOffset(i);
760             count = data.readUnsignedInt(position, offset);
761             return count;
762         }
763 
764         @Override
765         public int getExecutionCount(HotSpotMethodData data, int position) {
766             int arrayLength = getLength(data, position);
767             assert arrayLength &gt; 0 : &quot;switch must have at least the default case&quot;;
<a name="70" id="anc70"></a><span class="line-modified">768             assert arrayLength % MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS == 0 : &quot;array must have full rows&quot;;</span>
769 
<a name="71" id="anc71"></a><span class="line-modified">770             int length = arrayLength / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;</span>
771             long totalCount = 0;
772             for (int i = 0; i &lt; length; i++) {
773                 int offset = getCountOffset(i);
774                 totalCount += data.readUnsignedInt(position, offset);
775             }
776 
<a name="72" id="anc72"></a><span class="line-modified">777             return truncateLongToInt(totalCount);</span>
778         }
779 
<a name="73" id="anc73"></a><span class="line-modified">780         private static int getCountOffset(int index) {</span>
<span class="line-modified">781             return MULTI_BRANCH_DATA_FIRST_COUNT_OFFSET + index * MULTI_BRANCH_DATA_ROW_SIZE;</span>
782         }
783 
<a name="74" id="anc74"></a><span class="line-modified">784         private static int getDisplacementOffset(int index) {</span>
<span class="line-modified">785             return MULTI_BRANCH_DATA_FIRST_DISPLACEMENT_OFFSET + index * MULTI_BRANCH_DATA_ROW_SIZE;</span>
786         }
787 
788         @Override
789         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
<a name="75" id="anc75"></a><span class="line-modified">790             int entries = getLength(data, pos) / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;</span>
791             sb.append(format(&quot;entries(%d)&quot;, entries));
792             for (int i = 0; i &lt; entries; i++) {
793                 sb.append(format(&quot;%n  %d: count(%d) displacement(%d)&quot;, i, data.readUnsignedInt(pos, getCountOffset(i)), data.readUnsignedInt(pos, getDisplacementOffset(i))));
794             }
795             return sb;
796         }
797     }
798 
<a name="76" id="anc76"></a><span class="line-removed">799     static final int ARG_INFO_DATA_SIZE = cellIndexToOffset(1);</span>
<span class="line-removed">800 </span>
801     static class ArgInfoData extends ArrayData {
802 
<a name="77" id="anc77"></a><span class="line-modified">803         ArgInfoData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">804             super(config, tag, ARG_INFO_DATA_SIZE);</span>
805         }
806     }
807 
808     static class UnknownProfileData extends HotSpotMethodDataAccessor {
<a name="78" id="anc78"></a><span class="line-modified">809         UnknownProfileData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">810             super(config, tag, 0);</span>
811         }
812 
813         @Override
814         protected int getDynamicSize(HotSpotMethodData data, int position) {
815             assert staticSize == 0;
816             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
817         }
818 
819         @Override
820         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
821             sb.append(&quot;unknown profile data with tag: &quot; + tag);
822             return sb;
823         }
824     }
825 
826     public void setCompiledIRSize(int size) {
<a name="79" id="anc79"></a><span class="line-modified">827         UNSAFE.putInt(metaspaceMethodData + config.methodDataIRSizeOffset, size);</span>
828     }
829 
830     public int getCompiledIRSize() {
<a name="80" id="anc80"></a><span class="line-modified">831         return UNSAFE.getInt(metaspaceMethodData + config.methodDataIRSizeOffset);</span>
<span class="line-removed">832     }</span>
<span class="line-removed">833 </span>
<span class="line-removed">834     // sorted by tag</span>
<span class="line-removed">835     // @formatter:off</span>
<span class="line-removed">836     static final HotSpotMethodDataAccessor[] PROFILE_DATA_ACCESSORS = {</span>
<span class="line-removed">837         null,</span>
<span class="line-removed">838         new BitData(config, config.dataLayoutBitDataTag),</span>
<span class="line-removed">839         new CounterData(config, config.dataLayoutCounterDataTag),</span>
<span class="line-removed">840         new JumpData(config, config.dataLayoutJumpDataTag),</span>
<span class="line-removed">841         new ReceiverTypeData(config, config.dataLayoutReceiverTypeDataTag),</span>
<span class="line-removed">842         new VirtualCallData(config, config.dataLayoutVirtualCallDataTag),</span>
<span class="line-removed">843         new RetData(config, config.dataLayoutRetDataTag),</span>
<span class="line-removed">844         new BranchData(config, config.dataLayoutBranchDataTag),</span>
<span class="line-removed">845         new MultiBranchData(config, config.dataLayoutMultiBranchDataTag),</span>
<span class="line-removed">846         new ArgInfoData(config, config.dataLayoutArgInfoDataTag),</span>
<span class="line-removed">847         new UnknownProfileData(config, config.dataLayoutCallTypeDataTag),</span>
<span class="line-removed">848         new VirtualCallTypeData(config, config.dataLayoutVirtualCallTypeDataTag),</span>
<span class="line-removed">849         new UnknownProfileData(config, config.dataLayoutParametersTypeDataTag),</span>
<span class="line-removed">850         new UnknownProfileData(config, config.dataLayoutSpeculativeTrapDataTag),</span>
<span class="line-removed">851     };</span>
<span class="line-removed">852 </span>
<span class="line-removed">853     private static boolean checkAccessorTags() {</span>
<span class="line-removed">854         int expectedTag = 0;</span>
<span class="line-removed">855         for (HotSpotMethodDataAccessor accessor : PROFILE_DATA_ACCESSORS) {</span>
<span class="line-removed">856             if (expectedTag == 0) {</span>
<span class="line-removed">857                 assert accessor == null;</span>
<span class="line-removed">858             } else {</span>
<span class="line-removed">859                 assert accessor.tag == expectedTag : expectedTag + &quot; != &quot; + accessor.tag + &quot; &quot; + accessor;</span>
<span class="line-removed">860             }</span>
<span class="line-removed">861             expectedTag++;</span>
<span class="line-removed">862         }</span>
<span class="line-removed">863         return true;</span>
<span class="line-removed">864     }</span>
<span class="line-removed">865 </span>
<span class="line-removed">866     static {</span>
<span class="line-removed">867         assert checkAccessorTags();</span>
868     }
<a name="81" id="anc81"></a><span class="line-removed">869     // @formatter:on</span>
870 }
<a name="82" id="anc82"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="82" type="hidden" />
</body>
</html>
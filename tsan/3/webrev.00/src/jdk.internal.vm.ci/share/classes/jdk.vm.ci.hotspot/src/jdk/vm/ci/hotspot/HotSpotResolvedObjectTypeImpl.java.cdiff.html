<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotResolvedJavaType.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotResolvedPrimitiveType.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 29,16 ***</span>
  import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmClassModifiers;
  import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  
  import java.lang.annotation.Annotation;
<span class="line-removed">- import java.lang.reflect.Array;</span>
<span class="line-removed">- import java.lang.reflect.Constructor;</span>
  import java.lang.reflect.Field;
<span class="line-removed">- import java.lang.reflect.Method;</span>
  import java.lang.reflect.Modifier;
  import java.nio.ByteOrder;
  import java.util.HashMap;
  
  import jdk.vm.ci.common.JVMCIError;
  import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
<span class="line-new-header">--- 29,15 ---</span>
  import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmClassModifiers;
  import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  
  import java.lang.annotation.Annotation;
  import java.lang.reflect.Field;
  import java.lang.reflect.Modifier;
  import java.nio.ByteOrder;
<span class="line-added">+ import java.util.Arrays;</span>
<span class="line-added">+ import java.util.Comparator;</span>
  import java.util.HashMap;
  
  import jdk.vm.ci.common.JVMCIError;
  import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,108 ***</span>
  import jdk.vm.ci.meta.ResolvedJavaType;
  import jdk.vm.ci.meta.UnresolvedJavaField;
  import jdk.vm.ci.meta.UnresolvedJavaType;
  
  /**
<span class="line-modified">!  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes.</span>
   */
<span class="line-modified">! final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceWrapperObject {</span>
  
      private static final HotSpotResolvedJavaField[] NO_FIELDS = new HotSpotResolvedJavaField[0];
      private static final int METHOD_CACHE_ARRAY_CAPACITY = 8;
  
      /**
       * The Java class this type represents.
       */
<span class="line-modified">!     private final Class&lt;?&gt; javaClass;</span>
      private HotSpotResolvedJavaMethodImpl[] methodCacheArray;
      private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCacheHashMap;
<span class="line-modified">!     private HotSpotResolvedJavaField[] instanceFields;</span>
<span class="line-modified">!     private HotSpotResolvedObjectTypeImpl[] interfaces;</span>
      private HotSpotConstantPool constantPool;
<span class="line-modified">!     final HotSpotJVMCIMetaAccessContext context;</span>
<span class="line-modified">!     private HotSpotResolvedObjectType arrayOfType;</span>
  
      /**
<span class="line-modified">!      * Managed exclusively by {@link HotSpotResolvedJavaFieldImpl#toJava}.</span>
       */
      HashMap&lt;HotSpotResolvedJavaFieldImpl, Field&gt; reflectionFieldCache;
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Gets the JVMCI mirror for a {@link Class} object.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @return the {@link HotSpotResolvedJavaType} corresponding to {@code javaClass}</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     static HotSpotResolvedObjectTypeImpl fromObjectClass(Class&lt;?&gt; javaClass) {</span>
<span class="line-removed">-         return (HotSpotResolvedObjectTypeImpl) runtime().fromClass(javaClass);</span>
      }
  
      /**
<span class="line-modified">!      * Gets the JVMCI mirror from a HotSpot type. Since {@link Class} is already a proxy for the</span>
<span class="line-removed">-      * underlying Klass*, it is used instead of the raw Klass*.</span>
       *
       * Called from the VM.
       *
<span class="line-modified">!      * @param javaClass a {@link Class} object</span>
       * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
       */
      @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">!     private static HotSpotResolvedObjectTypeImpl fromMetaspace(Class&lt;?&gt; javaClass) {</span>
<span class="line-modified">!         return fromObjectClass(javaClass);</span>
      }
  
      /**
       * Creates the JVMCI mirror for a {@link Class} object.
       *
<span class="line-removed">-      * &lt;p&gt;</span>
       * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
<span class="line-modified">!      * {@link Class} type. Use {@link #fromObjectClass(Class)} or {@link #fromMetaspace(Class)}</span>
<span class="line-removed">-      * instead.</span>
       * &lt;/p&gt;
       *
<span class="line-modified">!      * @param javaClass the Class to create the mirror for</span>
<span class="line-removed">-      * @param context</span>
       */
<span class="line-modified">!     HotSpotResolvedObjectTypeImpl(Class&lt;?&gt; javaClass, HotSpotJVMCIMetaAccessContext context) {</span>
<span class="line-modified">!         super(getSignatureName(javaClass));</span>
<span class="line-modified">!         this.javaClass = javaClass;</span>
<span class="line-modified">!         this.context = context;</span>
<span class="line-modified">!         assert getName().charAt(0) != &#39;[&#39; || isArray() : getName();</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Returns the name of this type as it would appear in a signature.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private static String getSignatureName(Class&lt;?&gt; javaClass) {</span>
<span class="line-modified">!         if (javaClass.isArray()) {</span>
<span class="line-modified">!             return javaClass.getName().replace(&#39;.&#39;, &#39;/&#39;);</span>
          }
<span class="line-removed">-         return &quot;L&quot; + javaClass.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
      }
  
      /**
       * Gets the metaspace Klass for this type.
       */
      long getMetaspaceKlass() {
<span class="line-modified">!         if (HotSpotJVMCIRuntime.getHostWordKind() == JavaKind.Long) {</span>
<span class="line-modified">!             return UNSAFE.getLong(javaClass, config().klassOffset);</span>
          }
<span class="line-modified">!         return UNSAFE.getInt(javaClass, config().klassOffset) &amp; 0xFFFFFFFFL;</span>
      }
  
      @Override
      public long getMetaspacePointer() {
<span class="line-modified">!         return getMetaspaceKlass();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * The Klass* for this object is kept alive by the direct reference to {@link #javaClass} so no</span>
<span class="line-removed">-      * extra work is required.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     @Override</span>
<span class="line-removed">-     public boolean isRegistered() {</span>
<span class="line-removed">-         return true;</span>
      }
  
      @Override
      public int getModifiers() {
          if (isArray()) {
<span class="line-new-header">--- 53,94 ---</span>
  import jdk.vm.ci.meta.ResolvedJavaType;
  import jdk.vm.ci.meta.UnresolvedJavaField;
  import jdk.vm.ci.meta.UnresolvedJavaType;
  
  /**
<span class="line-modified">!  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes. This class is not</span>
<span class="line-added">+  * an {@link MetaspaceHandleObject} because it doesn&#39;t have to be scanned for GC. It&#39;s liveness is</span>
<span class="line-added">+  * maintained by a reference to the {@link Class} instance.</span>
   */
<span class="line-modified">! final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceObject {</span>
  
      private static final HotSpotResolvedJavaField[] NO_FIELDS = new HotSpotResolvedJavaField[0];
      private static final int METHOD_CACHE_ARRAY_CAPACITY = 8;
<span class="line-added">+     private static final SortByOffset fieldSortingMethod = new SortByOffset();</span>
  
      /**
       * The Java class this type represents.
       */
<span class="line-modified">!     private final long metadataPointer;</span>
<span class="line-added">+ </span>
      private HotSpotResolvedJavaMethodImpl[] methodCacheArray;
      private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCacheHashMap;
<span class="line-modified">!     private volatile HotSpotResolvedJavaField[] instanceFields;</span>
<span class="line-modified">!     private volatile HotSpotResolvedObjectTypeImpl[] interfaces;</span>
      private HotSpotConstantPool constantPool;
<span class="line-modified">!     private final JavaConstant mirror;</span>
<span class="line-modified">!     private HotSpotResolvedObjectTypeImpl superClass;</span>
  
      /**
<span class="line-modified">!      * Managed exclusively by {@link HotSpotJDKReflection#getField}.</span>
       */
      HashMap&lt;HotSpotResolvedJavaFieldImpl, Field&gt; reflectionFieldCache;
  
<span class="line-modified">!     static HotSpotResolvedObjectTypeImpl getJavaLangObject() {</span>
<span class="line-modified">!         return runtime().getJavaLangObject();</span>
      }
  
      /**
<span class="line-modified">!      * Gets the JVMCI mirror from a HotSpot type.</span>
       *
       * Called from the VM.
       *
<span class="line-modified">!      * @param klassPointer a native pointer to the Klass*</span>
       * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
       */
      @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">!     @VMEntryPoint</span>
<span class="line-modified">!     private static HotSpotResolvedObjectTypeImpl fromMetaspace(long klassPointer, String signature) {</span>
<span class="line-added">+         return runtime().fromMetaspace(klassPointer, signature);</span>
      }
  
      /**
       * Creates the JVMCI mirror for a {@link Class} object.
       *
       * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
<span class="line-modified">!      * {@link Class} type.</span>
       * &lt;/p&gt;
       *
<span class="line-modified">!      * @param metadataPointer the Klass* to create the mirror for</span>
       */
<span class="line-modified">!     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-modified">!     HotSpotResolvedObjectTypeImpl(long metadataPointer, String name) {</span>
<span class="line-modified">!         super(name);</span>
<span class="line-modified">!         assert metadataPointer != 0;</span>
<span class="line-modified">!         this.metadataPointer = metadataPointer;</span>
  
<span class="line-modified">!         // The mirror object must be in the global scope since</span>
<span class="line-modified">!         // this object will be cached in HotSpotJVMCIRuntime.resolvedJavaTypes</span>
<span class="line-modified">!         // and live across more than one compilation.</span>
<span class="line-modified">!         try (HotSpotObjectConstantScope global = HotSpotObjectConstantScope.enterGlobalScope()) {</span>
<span class="line-modified">!             this.mirror = runtime().compilerToVm.getJavaMirror(this);</span>
<span class="line-modified">!             assert getName().charAt(0) != &#39;[&#39; || isArray() : getName();</span>
          }
      }
  
      /**
       * Gets the metaspace Klass for this type.
       */
      long getMetaspaceKlass() {
<span class="line-modified">!         long metaspacePointer = getMetaspacePointer();</span>
<span class="line-modified">!         if (metaspacePointer == 0) {</span>
<span class="line-added">+             throw new NullPointerException(&quot;Klass* is null&quot;);</span>
          }
<span class="line-modified">!         return metaspacePointer;</span>
      }
  
      @Override
      public long getMetaspacePointer() {
<span class="line-modified">!         return metadataPointer;</span>
      }
  
      @Override
      public int getModifiers() {
          if (isArray()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,22 ***</span>
      public int getAccessFlags() {
          HotSpotVMConfig config = config();
          return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
      }
  
<span class="line-removed">-     @Override</span>
<span class="line-removed">-     public HotSpotResolvedObjectType getArrayClass() {</span>
<span class="line-removed">-         if (arrayOfType == null) {</span>
<span class="line-removed">-             arrayOfType = fromObjectClass(Array.newInstance(mirror(), 0).getClass());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return arrayOfType;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      @Override
      public ResolvedJavaType getComponentType() {
<span class="line-modified">!         Class&lt;?&gt; javaComponentType = mirror().getComponentType();</span>
<span class="line-removed">-         return javaComponentType == null ? null : runtime().fromClass(javaComponentType);</span>
      }
  
      @Override
      public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
          if (isLeaf()) {
<span class="line-new-header">--- 153,13 ---</span>
      public int getAccessFlags() {
          HotSpotVMConfig config = config();
          return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
      }
  
      @Override
      public ResolvedJavaType getComponentType() {
<span class="line-modified">!         return runtime().compilerToVm.getComponentType(this);</span>
      }
  
      @Override
      public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
          if (isLeaf()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 277,23 ***</span>
          return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
      }
  
      @Override
      public HotSpotResolvedObjectTypeImpl getSuperclass() {
<span class="line-modified">!         Class&lt;?&gt; javaSuperclass = mirror().getSuperclass();</span>
<span class="line-modified">!         return javaSuperclass == null ? null : fromObjectClass(javaSuperclass);</span>
      }
  
      @Override
      public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
          if (interfaces == null) {
<span class="line-modified">!             Class&lt;?&gt;[] javaInterfaces = mirror().getInterfaces();</span>
<span class="line-modified">!             HotSpotResolvedObjectTypeImpl[] result = new HotSpotResolvedObjectTypeImpl[javaInterfaces.length];</span>
<span class="line-modified">!             for (int i = 0; i &lt; javaInterfaces.length; i++) {</span>
<span class="line-modified">!                 result[i] = fromObjectClass(javaInterfaces[i]);</span>
              }
<span class="line-removed">-             interfaces = result;</span>
          }
          return interfaces;
      }
  
      @Override
<span class="line-new-header">--- 253,39 ---</span>
          return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
      }
  
      @Override
      public HotSpotResolvedObjectTypeImpl getSuperclass() {
<span class="line-modified">!         if (isInterface()) {</span>
<span class="line-modified">!             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         HotSpotResolvedObjectTypeImpl javaLangObject = runtime().getJavaLangObject();</span>
<span class="line-added">+         if (this.equals(javaLangObject)) {</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (isArray()) {</span>
<span class="line-added">+             return javaLangObject;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Cache result of native call</span>
<span class="line-added">+         if (superClass == null) {</span>
<span class="line-added">+             superClass = compilerToVM().getResolvedJavaType(this, config().superOffset, false);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return superClass;</span>
      }
  
      @Override
      public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
          if (interfaces == null) {
<span class="line-modified">!             if (isArray()) {</span>
<span class="line-modified">!                 HotSpotResolvedObjectTypeImpl[] types = new HotSpotResolvedObjectTypeImpl[2];</span>
<span class="line-modified">!                 types[0] = runtime().getJavaLangCloneable();</span>
<span class="line-modified">!                 types[1] = runtime().getJavaLangSerializable();</span>
<span class="line-added">+                 this.interfaces = types;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 interfaces = runtime().compilerToVm.getInterfaces(this);</span>
              }
          }
          return interfaces;
      }
  
      @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 306,17 ***</span>
  
      @Override
      public HotSpotResolvedObjectTypeImpl getSupertype() {
          if (isArray()) {
              ResolvedJavaType componentType = getComponentType();
<span class="line-modified">!             if (mirror() == Object[].class || componentType.isPrimitive()) {</span>
<span class="line-modified">!                 return fromObjectClass(Object.class);</span>
              }
<span class="line-modified">!             return (HotSpotResolvedObjectTypeImpl) ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype().getArrayClass();</span>
          }
          if (isInterface()) {
<span class="line-modified">!             return fromObjectClass(Object.class);</span>
          }
          return getSuperclass();
      }
  
      @Override
<span class="line-new-header">--- 298,18 ---</span>
  
      @Override
      public HotSpotResolvedObjectTypeImpl getSupertype() {
          if (isArray()) {
              ResolvedJavaType componentType = getComponentType();
<span class="line-modified">!             if (componentType.equals(getJavaLangObject()) || componentType.isPrimitive()) {</span>
<span class="line-modified">!                 return getJavaLangObject();</span>
              }
<span class="line-modified">!             HotSpotResolvedObjectTypeImpl supertype = ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype();</span>
<span class="line-added">+             return (HotSpotResolvedObjectTypeImpl) supertype.getArrayClass();</span>
          }
          if (isInterface()) {
<span class="line-modified">!             return getJavaLangObject();</span>
          }
          return getSuperclass();
      }
  
      @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 351,30 ***</span>
      @Override
      public boolean hasFinalizer() {
          return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
      }
  
<span class="line-removed">-     @Override</span>
<span class="line-removed">-     public boolean isPrimitive() {</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      @Override
      public boolean isArray() {
<span class="line-modified">!         return mirror().isArray();</span>
      }
  
      @Override
      public boolean isEnum() {
<span class="line-modified">!         return mirror().isEnum();</span>
      }
  
      @Override
      public boolean isInitialized() {
          return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
      }
  
      @Override
      public boolean isLinked() {
          return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
      }
  
<span class="line-new-header">--- 344,31 ---</span>
      @Override
      public boolean hasFinalizer() {
          return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
      }
  
      @Override
      public boolean isArray() {
<span class="line-modified">!         return layoutHelper() &lt; config().klassLayoutHelperNeutralValue;</span>
      }
  
      @Override
      public boolean isEnum() {
<span class="line-modified">!         HotSpotResolvedObjectTypeImpl superclass = getSuperclass();</span>
<span class="line-added">+         return superclass != null &amp;&amp; superclass.equals(runtime().getJavaLangEnum());</span>
      }
  
      @Override
      public boolean isInitialized() {
          return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
      }
  
<span class="line-added">+     @Override</span>
<span class="line-added">+     public boolean isBeingInitialized() {</span>
<span class="line-added">+         return isArray() ? false : getInitState() == config().instanceKlassStateBeingInitialized;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public boolean isLinked() {
          return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,19 ***</span>
      }
  
      @Override
      public void initialize() {
          if (!isInitialized()) {
<span class="line-modified">!             UNSAFE.ensureClassInitialized(mirror());</span>
<span class="line-modified">!             assert isInitialized();</span>
          }
      }
  
      @Override
      public boolean isInstance(JavaConstant obj) {
          if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
<span class="line-modified">!             return mirror().isInstance(((HotSpotObjectConstantImpl) obj).object());</span>
          }
          return false;
      }
  
      @Override
<span class="line-new-header">--- 384,19 ---</span>
      }
  
      @Override
      public void initialize() {
          if (!isInitialized()) {
<span class="line-modified">!             runtime().compilerToVm.ensureInitialized(this);</span>
<span class="line-modified">!             assert isInitialized() || isBeingInitialized();</span>
          }
      }
  
      @Override
      public boolean isInstance(JavaConstant obj) {
          if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
<span class="line-modified">!             return runtime().reflection.isInstance(this, (HotSpotObjectConstantImpl) obj);</span>
          }
          return false;
      }
  
      @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 410,19 ***</span>
          return !isArray() &amp;&amp; !isInterface();
      }
  
      @Override
      public boolean isInterface() {
<span class="line-modified">!         return mirror().isInterface();</span>
      }
  
      @Override
      public boolean isAssignableFrom(ResolvedJavaType other) {
          assert other != null;
          if (other instanceof HotSpotResolvedObjectTypeImpl) {
              HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
<span class="line-modified">!             return mirror().isAssignableFrom(otherType.mirror());</span>
          }
          return false;
      }
  
      @Override
<span class="line-new-header">--- 404,19 ---</span>
          return !isArray() &amp;&amp; !isInterface();
      }
  
      @Override
      public boolean isInterface() {
<span class="line-modified">!         return (getAccessFlags() &amp; config().jvmAccInterface) != 0;</span>
      }
  
      @Override
      public boolean isAssignableFrom(ResolvedJavaType other) {
          assert other != null;
          if (other instanceof HotSpotResolvedObjectTypeImpl) {
              HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
<span class="line-modified">!             return runtime().reflection.isAssignableFrom(this, otherType);</span>
          }
          return false;
      }
  
      @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 433,11 ***</span>
          return compilerToVM().getHostClass(this);
      }
  
      @Override
      public boolean isJavaLangObject() {
<span class="line-modified">!         return javaClass.equals(Object.class);</span>
      }
  
      @Override
      public JavaKind getJavaKind() {
          return JavaKind.Object;
<span class="line-new-header">--- 427,11 ---</span>
          return compilerToVM().getHostClass(this);
      }
  
      @Override
      public boolean isJavaLangObject() {
<span class="line-modified">!         return getName().equals(&quot;Ljava/lang/Object;&quot;);</span>
      }
  
      @Override
      public JavaKind getJavaKind() {
          return JavaKind.Object;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 499,33 ***</span>
      }
  
      @Override
      public int layoutHelper() {
          HotSpotVMConfig config = config();
          return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
      }
  
      @Override
      public long getFingerprint() {
          return compilerToVM().getFingerprint(getMetaspaceKlass());
      }
  
<span class="line-modified">!     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceMethod) {</span>
          // Maintain cache as array.
          if (methodCacheArray == null) {
              methodCacheArray = new HotSpotResolvedJavaMethodImpl[METHOD_CACHE_ARRAY_CAPACITY];
          }
  
          int i = 0;
          for (; i &lt; methodCacheArray.length; ++i) {
              HotSpotResolvedJavaMethodImpl curMethod = methodCacheArray[i];
              if (curMethod == null) {
<span class="line-modified">!                 HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);</span>
                  methodCacheArray[i] = newMethod;
<span class="line-removed">-                 context.add(newMethod);</span>
                  return newMethod;
<span class="line-modified">!             } else if (curMethod.getMetaspacePointer() == metaspaceMethod) {</span>
                  return curMethod;
              }
          }
  
          // Fall-back to hash table.
<span class="line-new-header">--- 493,34 ---</span>
      }
  
      @Override
      public int layoutHelper() {
          HotSpotVMConfig config = config();
<span class="line-added">+         assert getMetaspaceKlass() != 0 : getName();</span>
          return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
      }
  
      @Override
      public long getFingerprint() {
          return compilerToVM().getFingerprint(getMetaspaceKlass());
      }
  
<span class="line-modified">!     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceHandle) {</span>
<span class="line-added">+         long metaspaceMethod = UNSAFE.getLong(metaspaceHandle);</span>
          // Maintain cache as array.
          if (methodCacheArray == null) {
              methodCacheArray = new HotSpotResolvedJavaMethodImpl[METHOD_CACHE_ARRAY_CAPACITY];
          }
  
          int i = 0;
          for (; i &lt; methodCacheArray.length; ++i) {
              HotSpotResolvedJavaMethodImpl curMethod = methodCacheArray[i];
              if (curMethod == null) {
<span class="line-modified">!                 HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceHandle);</span>
                  methodCacheArray[i] = newMethod;
                  return newMethod;
<span class="line-modified">!             } else if (curMethod.getMetaspaceMethod() == metaspaceMethod) {</span>
                  return curMethod;
              }
          }
  
          // Fall-back to hash table.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 533,13 ***</span>
              methodCacheHashMap = new HashMap&lt;&gt;();
          }
  
          HotSpotResolvedJavaMethodImpl lookupResult = methodCacheHashMap.get(metaspaceMethod);
          if (lookupResult == null) {
<span class="line-modified">!             HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);</span>
              methodCacheHashMap.put(metaspaceMethod, newMethod);
<span class="line-removed">-             context.add(lookupResult);</span>
              return newMethod;
          } else {
              return lookupResult;
          }
      }
<span class="line-new-header">--- 528,12 ---</span>
              methodCacheHashMap = new HashMap&lt;&gt;();
          }
  
          HotSpotResolvedJavaMethodImpl lookupResult = methodCacheHashMap.get(metaspaceMethod);
          if (lookupResult == null) {
<span class="line-modified">!             HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceHandle);</span>
              methodCacheHashMap.put(metaspaceMethod, newMethod);
              return newMethod;
          } else {
              return lookupResult;
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 570,10 ***</span>
<span class="line-new-header">--- 564,14 ---</span>
           * type before using it for lookup. Unlinked types should also be ignored because we can&#39;t
           * resolve the proper method to invoke. Generally unlinked types in invokes should result in
           * a deopt instead since they can&#39;t really be used if they aren&#39;t linked yet.
           */
          if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
<span class="line-added">+             if (hmethod.canBeStaticallyBound()) {</span>
<span class="line-added">+                 // No assumptions are required.</span>
<span class="line-added">+                 return new AssumptionResult&lt;&gt;(hmethod);</span>
<span class="line-added">+             }</span>
              ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
              if (result != null) {
                  return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
              }
              return null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,10 ***</span>
<span class="line-new-header">--- 583,14 ---</span>
          HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
          if (resolvedMethod == null) {
              // The type isn&#39;t known to implement the method.
              return null;
          }
<span class="line-added">+         if (resolvedMethod.canBeStaticallyBound()) {</span>
<span class="line-added">+             // No assumptions are required.</span>
<span class="line-added">+             return new AssumptionResult&lt;&gt;(resolvedMethod);</span>
<span class="line-added">+         }</span>
  
          ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
          if (result != null) {
              return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 597,10 ***</span>
<span class="line-new-header">--- 599,31 ---</span>
  
      FieldInfo createFieldInfo(int index) {
          return new FieldInfo(index);
      }
  
<span class="line-added">+     public void ensureInitialized() {</span>
<span class="line-added">+         runtime().compilerToVm.ensureInitialized(this);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public boolean equals(Object obj) {</span>
<span class="line-added">+         if (obj == this) {</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (!(obj instanceof HotSpotResolvedObjectTypeImpl)) {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         HotSpotResolvedObjectTypeImpl that = (HotSpotResolvedObjectTypeImpl) obj;</span>
<span class="line-added">+         return getMetaspaceKlass() == that.getMetaspaceKlass();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     JavaConstant getJavaMirror() {</span>
<span class="line-added">+         return mirror;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * This class represents the field information for one field contained in the fields array of an
       * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
       */
      class FieldInfo {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 686,10 ***</span>
<span class="line-new-header">--- 709,16 ---</span>
          public boolean hasGenericSignature() {
              return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
          }
      }
  
<span class="line-added">+     static class SortByOffset implements Comparator&lt;ResolvedJavaField&gt; {</span>
<span class="line-added">+         public int compare(ResolvedJavaField a, ResolvedJavaField b) {</span>
<span class="line-added">+             return a.getOffset() - b.getOffset();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
          if (instanceFields == null) {
              if (isArray() || isInterface()) {
                  instanceFields = NO_FIELDS;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 705,12 ***</span>
              int superClassFieldCount = getSuperclass().getInstanceFields(true).length;
              if (superClassFieldCount == instanceFields.length) {
                  // This class does not have any instance fields of its own.
                  return NO_FIELDS;
              } else if (superClassFieldCount != 0) {
                  HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[instanceFields.length - superClassFieldCount];
<span class="line-modified">!                 System.arraycopy(instanceFields, superClassFieldCount, result, 0, result.length);</span>
                  return result;
              } else {
                  // The super classes of this class do not have any instance fields.
              }
          }
<span class="line-new-header">--- 734,21 ---</span>
              int superClassFieldCount = getSuperclass().getInstanceFields(true).length;
              if (superClassFieldCount == instanceFields.length) {
                  // This class does not have any instance fields of its own.
                  return NO_FIELDS;
              } else if (superClassFieldCount != 0) {
<span class="line-added">+                 // Fields of the current class can be interleaved with fields of its super-classes</span>
<span class="line-added">+                 // but the array of fields to be returned must be sorted by increasing offset</span>
<span class="line-added">+                 // This code populates the array, then applies the sorting function</span>
                  HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[instanceFields.length - superClassFieldCount];
<span class="line-modified">!                 int i = 0;</span>
<span class="line-added">+                 for (HotSpotResolvedJavaField f : instanceFields) {</span>
<span class="line-added">+                     if (f.getDeclaringClass() == this) {</span>
<span class="line-added">+                         result[i++] = f;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 Arrays.sort(result, fieldSortingMethod);</span>
                  return result;
              } else {
                  // The super classes of this class do not have any instance fields.
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 759,35 ***</span>
          HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[resultCount];
          if (prependLength != 0) {
              System.arraycopy(prepend, 0, result, 0, prependLength);
          }
  
          int resultIndex = prependLength;
          for (int i = 0; i &lt; index; ++i) {
              FieldInfo field = new FieldInfo(i);
              if (field.isStatic() == retrieveStaticFields) {
                  int offset = field.getOffset();
                  HotSpotResolvedJavaField resolvedJavaField = createField(field.getType(), offset, field.getAccessFlags(), i);
<span class="line-modified">! </span>
<span class="line-removed">-                 // Make sure the result is sorted by offset.</span>
<span class="line-removed">-                 int j;</span>
<span class="line-removed">-                 for (j = resultIndex - 1; j &gt;= prependLength &amp;&amp; result[j].getOffset() &gt; offset; j--) {</span>
<span class="line-removed">-                     result[j + 1] = result[j];</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 result[j + 1] = resolvedJavaField;</span>
<span class="line-removed">-                 resultIndex++;</span>
              }
          }
<span class="line-modified">! </span>
          return result;
      }
  
<span class="line-removed">-     @Override</span>
<span class="line-removed">-     public Class&lt;?&gt; mirror() {</span>
<span class="line-removed">-         return javaClass;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      @Override
      public String getSourceFileName() {
          HotSpotVMConfig config = config();
          final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassSourceFileNameIndexOffset);
          if (sourceFileNameIndex == 0) {
<span class="line-new-header">--- 797,26 ---</span>
          HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[resultCount];
          if (prependLength != 0) {
              System.arraycopy(prepend, 0, result, 0, prependLength);
          }
  
<span class="line-added">+         // Fields of the current class can be interleaved with fields of its super-classes</span>
<span class="line-added">+         // but the array of fields to be returned must be sorted by increasing offset</span>
<span class="line-added">+         // This code populates the array, then applies the sorting function</span>
          int resultIndex = prependLength;
          for (int i = 0; i &lt; index; ++i) {
              FieldInfo field = new FieldInfo(i);
              if (field.isStatic() == retrieveStaticFields) {
                  int offset = field.getOffset();
                  HotSpotResolvedJavaField resolvedJavaField = createField(field.getType(), offset, field.getAccessFlags(), i);
<span class="line-modified">!                 result[resultIndex++] = resolvedJavaField;</span>
              }
          }
<span class="line-modified">!         Arrays.sort(result, fieldSortingMethod);</span>
          return result;
      }
  
      @Override
      public String getSourceFileName() {
          HotSpotVMConfig config = config();
          final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassSourceFileNameIndexOffset);
          if (sourceFileNameIndex == 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 796,21 ***</span>
          return getConstantPool().lookupUtf8(sourceFileNameIndex);
      }
  
      @Override
      public Annotation[] getAnnotations() {
<span class="line-modified">!         return mirror().getAnnotations();</span>
      }
  
      @Override
      public Annotation[] getDeclaredAnnotations() {
<span class="line-modified">!         return mirror().getDeclaredAnnotations();</span>
      }
  
      @Override
      public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="line-modified">!         return mirror().getAnnotation(annotationClass);</span>
      }
  
      /**
       * Performs a fast-path check that this type is resolved in the context of a given accessing
       * class. A negative result does not mean this type is not resolved with respect to
<span class="line-new-header">--- 825,21 ---</span>
          return getConstantPool().lookupUtf8(sourceFileNameIndex);
      }
  
      @Override
      public Annotation[] getAnnotations() {
<span class="line-modified">!         return runtime().reflection.getAnnotations(this);</span>
      }
  
      @Override
      public Annotation[] getDeclaredAnnotations() {
<span class="line-modified">!         return runtime().reflection.getDeclaredAnnotations(this);</span>
      }
  
      @Override
      public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="line-modified">!         return runtime().reflection.getAnnotation(this, annotationClass);</span>
      }
  
      /**
       * Performs a fast-path check that this type is resolved in the context of a given accessing
       * class. A negative result does not mean this type is not resolved with respect to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 824,18 ***</span>
          ResolvedJavaType elementType = getElementalType();
          if (elementType.isPrimitive()) {
              // Primitive type resolution is context free.
              return true;
          }
<span class="line-modified">!         if (elementType.getName().startsWith(&quot;Ljava/&quot;)) {</span>
<span class="line-modified">!             // Classes in a java.* package can only be defined by the</span>
<span class="line-removed">-             // boot or platform class loader.</span>
              return true;
          }
<span class="line-modified">!         ClassLoader thisCl = mirror().getClassLoader();</span>
<span class="line-modified">!         ClassLoader accessingClassCl = ((HotSpotResolvedObjectTypeImpl) accessingClass).mirror().getClassLoader();</span>
<span class="line-modified">!         return thisCl == accessingClassCl;</span>
      }
  
      @Override
      public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
          if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
<span class="line-new-header">--- 853,21 ---</span>
          ResolvedJavaType elementType = getElementalType();
          if (elementType.isPrimitive()) {
              // Primitive type resolution is context free.
              return true;
          }
<span class="line-modified">!         if (elementType.getName().startsWith(&quot;Ljava/&quot;) &amp;&amp; hasSameClassLoader(runtime().getJavaLangObject())) {</span>
<span class="line-modified">!             // Classes in a java.* package defined by the boot class loader are always resolved.</span>
              return true;
          }
<span class="line-modified">!         HotSpotResolvedObjectTypeImpl otherMirror = ((HotSpotResolvedObjectTypeImpl) accessingClass);</span>
<span class="line-modified">!         return hasSameClassLoader(otherMirror);</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private boolean hasSameClassLoader(HotSpotResolvedObjectTypeImpl otherMirror) {</span>
<span class="line-added">+         return UnsafeAccess.UNSAFE.getAddress(getMetaspaceKlass() + config().classLoaderDataOffset) == UnsafeAccess.UNSAFE.getAddress(</span>
<span class="line-added">+                         otherMirror.getMetaspaceKlass() + config().classLoaderDataOffset);</span>
      }
  
      @Override
      public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
          if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 885,20 ***</span>
          return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
      }
  
      private static ResolvedJavaField findFieldWithOffset(long offset, JavaKind expectedEntryKind, ResolvedJavaField[] declaredFields) {
          for (ResolvedJavaField field : declaredFields) {
<span class="line-modified">!             HotSpotResolvedJavaField resolvedField = (HotSpotResolvedJavaField) field;</span>
<span class="line-removed">-             long resolvedFieldOffset = resolvedField.getOffset();</span>
              // @formatter:off
<span class="line-modified">!             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN  &amp;&amp;</span>
<span class="line-modified">!                             expectedEntryKind.isPrimitive() &amp;&amp;</span>
<span class="line-modified">!                             !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;</span>
<span class="line-modified">!                             resolvedField.getJavaKind().isPrimitive()) {</span>
                  resolvedFieldOffset +=
<span class="line-modified">!                                 resolvedField.getJavaKind().getByteCount() -</span>
<span class="line-modified">!                                 Math.min(resolvedField.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());</span>
              }
              if (resolvedFieldOffset == offset) {
                  return field;
              }
              // @formatter:on
<span class="line-new-header">--- 917,19 ---</span>
          return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
      }
  
      private static ResolvedJavaField findFieldWithOffset(long offset, JavaKind expectedEntryKind, ResolvedJavaField[] declaredFields) {
          for (ResolvedJavaField field : declaredFields) {
<span class="line-modified">!             long resolvedFieldOffset = field.getOffset();</span>
              // @formatter:off
<span class="line-modified">!             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN &amp;&amp;</span>
<span class="line-modified">!                     expectedEntryKind.isPrimitive() &amp;&amp;</span>
<span class="line-modified">!                     !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;</span>
<span class="line-modified">!                     field.getJavaKind().isPrimitive()) {</span>
                  resolvedFieldOffset +=
<span class="line-modified">!                         field.getJavaKind().getByteCount() -</span>
<span class="line-modified">!                                 Math.min(field.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());</span>
              }
              if (resolvedFieldOffset == offset) {
                  return field;
              }
              // @formatter:on
</pre>
<hr />
<pre>
<span class="line-old-header">*** 906,44 ***</span>
          return null;
      }
  
      @Override
      public boolean isLocal() {
<span class="line-modified">!         return mirror().isLocalClass();</span>
      }
  
      @Override
      public boolean isMember() {
<span class="line-modified">!         return mirror().isMemberClass();</span>
      }
  
      @Override
<span class="line-modified">!     public HotSpotResolvedObjectTypeImpl getEnclosingType() {</span>
<span class="line-modified">!         final Class&lt;?&gt; encl = mirror().getEnclosingClass();</span>
<span class="line-removed">-         return encl == null ? null : fromObjectClass(encl);</span>
      }
  
      @Override
      public ResolvedJavaMethod[] getDeclaredConstructors() {
<span class="line-modified">!         Constructor&lt;?&gt;[] constructors = mirror().getDeclaredConstructors();</span>
<span class="line-removed">-         ResolvedJavaMethod[] result = new ResolvedJavaMethod[constructors.length];</span>
<span class="line-removed">-         for (int i = 0; i &lt; constructors.length; i++) {</span>
<span class="line-removed">-             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(constructors[i]);</span>
<span class="line-removed">-             assert result[i].isConstructor();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return result;</span>
      }
  
      @Override
      public ResolvedJavaMethod[] getDeclaredMethods() {
<span class="line-modified">!         Method[] methods = mirror().getDeclaredMethods();</span>
<span class="line-removed">-         ResolvedJavaMethod[] result = new ResolvedJavaMethod[methods.length];</span>
<span class="line-removed">-         for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="line-removed">-             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(methods[i]);</span>
<span class="line-removed">-             assert !result[i].isConstructor();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return result;</span>
      }
  
      @Override
      public ResolvedJavaMethod getClassInitializer() {
          if (!isArray()) {
<span class="line-new-header">--- 937,31 ---</span>
          return null;
      }
  
      @Override
      public boolean isLocal() {
<span class="line-modified">!         return runtime().reflection.isLocalClass(this);</span>
      }
  
      @Override
      public boolean isMember() {
<span class="line-modified">!         return runtime().reflection.isMemberClass(this);</span>
      }
  
      @Override
<span class="line-modified">!     public HotSpotResolvedObjectType getEnclosingType() {</span>
<span class="line-modified">!         return runtime().reflection.getEnclosingClass(this);</span>
      }
  
      @Override
      public ResolvedJavaMethod[] getDeclaredConstructors() {
<span class="line-modified">!         return runtime().compilerToVm.getDeclaredConstructors(this);</span>
      }
  
      @Override
      public ResolvedJavaMethod[] getDeclaredMethods() {
<span class="line-modified">!         return runtime().compilerToVm.getDeclaredMethods(this);</span>
      }
  
      @Override
      public ResolvedJavaMethod getClassInitializer() {
          if (!isArray()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 984,10 ***</span>
<span class="line-new-header">--- 1002,14 ---</span>
      @Override
      public boolean isCloneableWithAllocation() {
          return (getAccessFlags() &amp; config().jvmAccIsCloneableFast) != 0;
      }
  
<span class="line-added">+     JavaConstant readFieldValue(HotSpotResolvedJavaField field, boolean isVolatile) {</span>
<span class="line-added">+         return runtime().reflection.readFieldValue(this, field, isVolatile);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private int getMiscFlags() {
          return UNSAFE.getInt(getMetaspaceKlass() + config().instanceKlassMiscFlagsOffset);
      }
  
      @Override
</pre>
<center><a href="HotSpotResolvedJavaType.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotResolvedPrimitiveType.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
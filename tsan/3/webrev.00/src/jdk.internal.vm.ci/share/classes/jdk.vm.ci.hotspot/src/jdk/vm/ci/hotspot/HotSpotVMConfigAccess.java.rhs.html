<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfigAccess.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
<a name="2" id="anc2"></a><span class="line-added"> 25 import java.util.Set;</span>
<span class="line-added"> 26 import java.util.stream.Collectors;</span>
<span class="line-added"> 27 </span>
 28 import jdk.vm.ci.common.JVMCIError;
 29 
 30 /**
 31  * Access to VM configuration data.
 32  */
 33 public class HotSpotVMConfigAccess {
 34 
 35     /**
 36      * Gets the available configuration data.
 37      */
 38     public HotSpotVMConfigStore getStore() {
 39         return store;
 40     }
 41 
 42     /**
 43      * Gets the address of a C++ symbol.
 44      *
 45      * @param name name of C++ symbol
 46      * @param notPresent if non-null and the symbol is not present then this value is returned
 47      * @return the address of the symbol
 48      * @throws JVMCIError if the symbol is not present and {@code notPresent == null}
 49      */
 50     public long getAddress(String name, Long notPresent) {
 51         Long entry = store.vmAddresses.get(name);
 52         if (entry == null) {
 53             if (notPresent != null) {
 54                 return notPresent;
 55             }
<a name="3" id="anc3"></a><span class="line-modified"> 56             throw missingEntry(&quot;address&quot;, name, store.vmFlags.keySet());</span>
<span class="line-modified"> 57 </span>
 58         }
 59         return entry;
 60     }
 61 
 62     /**
 63      * Gets the address of a C++ symbol.
 64      *
 65      * @param name name of C++ symbol
 66      * @return the address of the symbol
 67      * @throws JVMCIError if the symbol is not present
 68      */
 69     public long getAddress(String name) {
 70         return getAddress(name, null);
 71     }
 72 
 73     /**
 74      * Gets the value of a C++ constant.
 75      *
 76      * @param name name of the constant (e.g., {@code &quot;frame::arg_reg_save_area_bytes&quot;})
 77      * @param type the boxed type to which the constant value will be converted
 78      * @param notPresent if non-null and the constant is not present then this value is returned
 79      * @return the constant value converted to {@code type}
 80      * @throws JVMCIError if the constant is not present and {@code notPresent == null}
 81      */
 82     public &lt;T&gt; T getConstant(String name, Class&lt;T&gt; type, T notPresent) {
 83         Long c = store.vmConstants.get(name);
 84         if (c == null) {
 85             if (notPresent != null) {
 86                 return notPresent;
 87             }
<a name="4" id="anc4"></a><span class="line-modified"> 88             throw missingEntry(&quot;constant&quot;, name, store.vmConstants.keySet());</span>

 89         }
 90         return type.cast(convertValue(name, type, c, null));
 91     }
 92 
 93     /**
 94      * Gets the value of a C++ constant.
 95      *
 96      * @param name name of the constant (e.g., {@code &quot;frame::arg_reg_save_area_bytes&quot;})
 97      * @param type the boxed type to which the constant value will be converted
 98      * @return the constant value converted to {@code type}
 99      * @throws JVMCIError if the constant is not present
100      */
101     public &lt;T&gt; T getConstant(String name, Class&lt;T&gt; type) {
102         return getConstant(name, type, null);
103     }
104 
105     /**
106      * Gets the offset of a non-static C++ field.
107      *
108      * @param name fully qualified name of the field
109      * @param type the boxed type to which the offset value will be converted (must be
110      *            {@link Integer} or {@link Long})
111      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
112      * @param notPresent if non-null and the field is not present then this value is returned
113      * @return the offset in bytes of the requested field
114      * @throws JVMCIError if the field is static or not present and {@code notPresent} is null
115      */
116     public &lt;T&gt; T getFieldOffset(String name, Class&lt;T&gt; type, String cppType, T notPresent) {
<a name="5" id="anc5"></a><span class="line-modified">117         return getFieldOffset0(name, type, notPresent, cppType, null);</span>
<span class="line-modified">118     }</span>
<span class="line-modified">119 </span>
<span class="line-modified">120     /**</span>
<span class="line-modified">121      * Gets the offset of a non-static C++ field.</span>
<span class="line-modified">122      *</span>
<span class="line-modified">123      * @param name fully qualified name of the field</span>
<span class="line-modified">124      * @param type the boxed type to which the offset value will be converted (must be</span>
<span class="line-modified">125      *            {@link Integer} or {@link Long})</span>
<span class="line-added">126      * @param notPresent if non-null and the field is not present then this value is returned</span>
<span class="line-added">127      * @param outCppType if non-null, the C++ type of the field (e.g., {@code &quot;HeapWord*&quot;}) is</span>
<span class="line-added">128      *            returned in element 0 of this array</span>
<span class="line-added">129      * @return the offset in bytes of the requested field</span>
<span class="line-added">130      * @throws JVMCIError if the field is static or not present and {@code notPresent} is null</span>
<span class="line-added">131      */</span>
<span class="line-added">132     public &lt;T&gt; T getFieldOffset(String name, Class&lt;T&gt; type, T notPresent, String[] outCppType) {</span>
<span class="line-added">133         return getFieldOffset0(name, type, notPresent, null, outCppType);</span>
134     }
135 
136     /**
137      * Gets the offset of a non-static C++ field.
138      *
139      * @param name fully qualified name of the field
140      * @param type the boxed type to which the offset value will be converted (must be
141      *            {@link Integer} or {@link Long})
142      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
143      * @return the offset in bytes of the requested field
144      * @throws JVMCIError if the field is static or not present
145      */
146     public &lt;T&gt; T getFieldOffset(String name, Class&lt;T&gt; type, String cppType) {
<a name="6" id="anc6"></a><span class="line-modified">147         return getFieldOffset0(name, type, null, cppType, null);</span>
148     }
149 
150     /**
151      * Gets the offset of a non-static C++ field.
152      *
153      * @param name fully qualified name of the field
154      * @param type the boxed type to which the offset value will be converted (must be
155      *            {@link Integer} or {@link Long})
156      * @return the offset in bytes of the requested field
157      * @throws JVMCIError if the field is static or not present
158      */
159     public &lt;T&gt; T getFieldOffset(String name, Class&lt;T&gt; type) {
<a name="7" id="anc7"></a><span class="line-modified">160         return getFieldOffset0(name, type, null, null, null);</span>
<span class="line-added">161     }</span>
<span class="line-added">162 </span>
<span class="line-added">163     private &lt;T&gt; T getFieldOffset0(String name, Class&lt;T&gt; type, T notPresent, String inCppType, String[] outCppType) {</span>
<span class="line-added">164         assert type == Integer.class || type == Long.class;</span>
<span class="line-added">165         VMField entry = getField(name, inCppType, notPresent == null);</span>
<span class="line-added">166         if (entry == null) {</span>
<span class="line-added">167             return notPresent;</span>
<span class="line-added">168         }</span>
<span class="line-added">169         if (entry.address != 0) {</span>
<span class="line-added">170             throw new JVMCIError(&quot;cannot get offset of static field &quot; + name);</span>
<span class="line-added">171         }</span>
<span class="line-added">172         if (outCppType != null) {</span>
<span class="line-added">173             outCppType[0] = entry.type;</span>
<span class="line-added">174         }</span>
<span class="line-added">175         return type.cast(convertValue(name, type, entry.offset, inCppType));</span>
176     }
177 
178     /**
179      * Gets the address of a static C++ field.
180      *
181      * @param name fully qualified name of the field
182      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
183      * @param notPresent if non-null and the field is not present then this value is returned
184      * @return the address of the requested field
185      * @throws JVMCIError if the field is not static or not present and {@code notPresent} is null
186      */
187     public long getFieldAddress(String name, String cppType, Long notPresent) {
<a name="8" id="anc8"></a><span class="line-modified">188         return getFieldAddress0(name, notPresent, cppType, null);</span>
<span class="line-modified">189     }</span>
<span class="line-modified">190 </span>
<span class="line-modified">191     /**</span>
<span class="line-modified">192      * Gets the address of a static C++ field.</span>
<span class="line-modified">193      *</span>
<span class="line-modified">194      * @param name fully qualified name of the field</span>
<span class="line-modified">195      * @param notPresent if non-null and the field is not present then this value is returned</span>
<span class="line-added">196      * @param outCppType if non-null, the C++ type of the field (e.g., {@code &quot;HeapWord*&quot;}) is</span>
<span class="line-added">197      *            returned in element 0 of this array</span>
<span class="line-added">198      * @return the address of the requested field</span>
<span class="line-added">199      * @throws JVMCIError if the field is not static or not present and {@code notPresent} is null</span>
<span class="line-added">200      */</span>
<span class="line-added">201     public long getFieldAddress(String name, Long notPresent, String[] outCppType) {</span>
<span class="line-added">202         return getFieldAddress0(name, notPresent, null, outCppType);</span>
203     }
204 
205     /**
206      * Gets the address of a static C++ field.
207      *
208      * @param name fully qualified name of the field
209      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
210      * @return the address of the requested field
211      * @throws JVMCIError if the field is not static or not present
212      */
213     public long getFieldAddress(String name, String cppType) {
<a name="9" id="anc9"></a><span class="line-modified">214         return getFieldAddress0(name, null, cppType, null);</span>
<span class="line-added">215     }</span>
<span class="line-added">216 </span>
<span class="line-added">217     private long getFieldAddress0(String name, Long notPresent, String inCppType, String[] outCppType) {</span>
<span class="line-added">218         VMField entry = getField(name, inCppType, notPresent == null);</span>
<span class="line-added">219         if (entry == null) {</span>
<span class="line-added">220             return notPresent;</span>
<span class="line-added">221         }</span>
<span class="line-added">222         if (entry.address == 0) {</span>
<span class="line-added">223             throw new JVMCIError(name + &quot; is not a static field&quot;);</span>
<span class="line-added">224         }</span>
<span class="line-added">225         if (outCppType != null) {</span>
<span class="line-added">226             outCppType[0] = entry.type;</span>
<span class="line-added">227         }</span>
<span class="line-added">228         return entry.address;</span>
229     }
230 
231     /**
232      * Gets the value of a static C++ field.
233      *
234      * @param name fully qualified name of the field
235      * @param type the boxed type to which the constant value will be converted
236      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
237      * @param notPresent if non-null and the field is not present then this value is returned
238      * @return the value of the requested field
239      * @throws JVMCIError if the field is not static or not present and {@code notPresent} is null
240      */
241     public &lt;T&gt; T getFieldValue(String name, Class&lt;T&gt; type, String cppType, T notPresent) {
<a name="10" id="anc10"></a><span class="line-modified">242         return getFieldValue0(name, type, notPresent, cppType, null);</span>







243     }
244 
245     /**
246      * Gets the value of a static C++ field.
247      *
248      * @param name fully qualified name of the field
249      * @param type the boxed type to which the constant value will be converted
250      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
251      * @return the value of the requested field
252      * @throws JVMCIError if the field is not static or not present
253      */
254     public &lt;T&gt; T getFieldValue(String name, Class&lt;T&gt; type, String cppType) {
<a name="11" id="anc11"></a><span class="line-modified">255         return getFieldValue0(name, type, null, cppType, null);</span>
<span class="line-added">256     }</span>
<span class="line-added">257 </span>
<span class="line-added">258     /**</span>
<span class="line-added">259      * Gets the value of a static C++ field.</span>
<span class="line-added">260      *</span>
<span class="line-added">261      * @param name fully qualified name of the field</span>
<span class="line-added">262      * @param type the boxed type to which the constant value will be converted</span>
<span class="line-added">263      * @param notPresent if non-null and the field is not present then this value is returned</span>
<span class="line-added">264      * @param outCppType if non-null, the C++ type of the field (e.g., {@code &quot;HeapWord*&quot;}) is</span>
<span class="line-added">265      *            returned in element 0 of this array</span>
<span class="line-added">266      * @return the value of the requested field</span>
<span class="line-added">267      * @throws JVMCIError if the field is not static or not present and {@code notPresent} is null</span>
<span class="line-added">268      */</span>
<span class="line-added">269     public &lt;T&gt; T getFieldValue(String name, Class&lt;T&gt; type, T notPresent, String[] outCppType) {</span>
<span class="line-added">270         return getFieldValue0(name, type, notPresent, null, outCppType);</span>
271     }
272 
273     /**
274      * Gets the value of a static C++ field.
275      *
276      * @param name fully qualified name of the field
277      * @param type the boxed type to which the constant value will be converted
278      * @return the value of the requested field
279      * @throws JVMCIError if the field is not static or not present
280      */
281     public &lt;T&gt; T getFieldValue(String name, Class&lt;T&gt; type) {
<a name="12" id="anc12"></a><span class="line-modified">282         return getFieldValue0(name, type, null, null, null);</span>
<span class="line-added">283     }</span>
<span class="line-added">284 </span>
<span class="line-added">285     private &lt;T&gt; T getFieldValue0(String name, Class&lt;T&gt; type, T notPresent, String inCppType, String[] outCppType) {</span>
<span class="line-added">286         VMField entry = getField(name, inCppType, notPresent == null);</span>
<span class="line-added">287         if (entry == null) {</span>
<span class="line-added">288             return notPresent;</span>
<span class="line-added">289         }</span>
<span class="line-added">290         if (entry.value == null) {</span>
<span class="line-added">291             throw new JVMCIError(name + &quot; is not a static field &quot;);</span>
<span class="line-added">292         }</span>
<span class="line-added">293         if (outCppType != null) {</span>
<span class="line-added">294             outCppType[0] = entry.type;</span>
<span class="line-added">295         }</span>
<span class="line-added">296         return type.cast(convertValue(name, type, entry.value, inCppType));</span>
297     }
298 
299     /**
300      * Gets a C++ field.
301      *
302      * @param name fully qualified name of the field
303      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
304      * @param required specifies if the field must be present
305      * @return the field
306      * @throws JVMCIError if the field is not present and {@code required == true}
307      */
308     private VMField getField(String name, String cppType, boolean required) {
309         VMField entry = store.vmFields.get(name);
310         if (entry == null) {
311             if (!required) {
312                 return null;
313             }
<a name="13" id="anc13"></a><span class="line-modified">314             throw missingEntry(&quot;field&quot;, name, store.vmFields.keySet());</span>

315         }
316 
317         // Make sure the native type is still the type we expect.
318         if (cppType != null &amp;&amp; !cppType.equals(entry.type)) {
319             throw new JVMCIError(&quot;expected type &quot; + cppType + &quot; but VM field &quot; + name + &quot; is of type &quot; + entry.type);
320         }
321         return entry;
322     }
323 
324     /**
325      * Gets a VM flag value.
326      *
327      * @param name name of the flag (e.g., {@code &quot;CompileTheWorldStartAt&quot;})
328      * @param type the boxed type to which the flag&#39;s value will be converted
329      * @return the flag&#39;s value converted to {@code type} or {@code notPresent} if the flag is not
330      *         present
331      * @throws JVMCIError if the flag is not present
332      */
333     public &lt;T&gt; T getFlag(String name, Class&lt;T&gt; type) {
334         return getFlag(name, type, null);
335     }
336 
337     /**
338      * Gets a VM flag value.
339      *
340      * @param name name of the flag (e.g., {@code &quot;CompileTheWorldStartAt&quot;})
341      * @param type the boxed type to which the flag&#39;s value will be converted
342      * @param notPresent if non-null and the flag is not present then this value is returned
343      * @return the flag&#39;s value converted to {@code type} or {@code notPresent} if the flag is not
344      *         present
345      * @throws JVMCIError if the flag is not present and {@code notPresent == null}
346      */
347     public &lt;T&gt; T getFlag(String name, Class&lt;T&gt; type, T notPresent) {
348         VMFlag entry = store.vmFlags.get(name);
349         Object value;
350         String cppType;
351         if (entry == null) {
352             // Fall back to VM call
353             value = store.compilerToVm.getFlagValue(name);
354             if (value == store.compilerToVm) {
355                 if (notPresent != null) {
356                     return notPresent;
357                 }
<a name="14" id="anc14"></a><span class="line-modified">358                 throw missingEntry(&quot;flag&quot;, name, store.vmFlags.keySet());</span>

359             } else {
360                 cppType = null;
361             }
362         } else {
363             value = entry.value;
364             cppType = entry.type;
365         }
366         return type.cast(convertValue(name, type, value, cppType));
367     }
368 
<a name="15" id="anc15"></a><span class="line-added">369     private JVMCIError missingEntry(String category, String name, Set&lt;String&gt; keys) {</span>
<span class="line-added">370         throw new JVMCIError(&quot;expected VM %s not found in %s: %s%nAvailable values:%n    %s&quot;, category, store, name,</span>
<span class="line-added">371                         keys.stream().sorted().collect(Collectors.joining(System.lineSeparator() + &quot;    &quot;)));</span>
<span class="line-added">372     }</span>
<span class="line-added">373 </span>
374     private static &lt;T&gt; Object convertValue(String name, Class&lt;T&gt; toType, Object value, String cppType) throws JVMCIError {
375         if (toType == Boolean.class) {
376             if (value instanceof String) {
377                 return Boolean.valueOf((String) value);
378             } else if (value instanceof Boolean) {
379                 return value;
380             } else if (value instanceof Long) {
381                 return ((long) value) != 0;
382             }
383         } else if (toType == Byte.class) {
384             if (value instanceof Long) {
385                 return (byte) (long) value;
386             }
387         } else if (toType == Integer.class) {
388             if (value instanceof Integer) {
389                 return value;
390             } else if (value instanceof Long) {
391                 return (int) (long) value;
392             }
393         } else if (toType == String.class) {
394             if (value == null || value instanceof String) {
395                 return value;
396             }
397         } else if (toType == Long.class) {
398             return value;
399         }
400 
401         throw new JVMCIError(&quot;cannot convert &quot; + name + &quot; of type &quot; + value.getClass().getSimpleName() + (cppType == null ? &quot;&quot; : &quot; [&quot; + cppType + &quot;]&quot;) + &quot; to &quot; + toType.getSimpleName());
402     }
403 
404     private final HotSpotVMConfigStore store;
405 
406     public HotSpotVMConfigAccess(HotSpotVMConfigStore store) {
407         this.store = store;
408     }
409 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
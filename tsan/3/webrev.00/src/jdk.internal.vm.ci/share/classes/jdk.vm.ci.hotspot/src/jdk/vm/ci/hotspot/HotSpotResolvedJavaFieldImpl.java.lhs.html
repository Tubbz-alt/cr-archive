<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaFieldImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
<a name="2" id="anc2"></a><span class="line-modified"> 25 import static jdk.internal.misc.Unsafe.ADDRESS_SIZE;</span>
<span class="line-removed"> 26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;</span>
<span class="line-removed"> 27 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmFieldModifiers;</span>
 28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
 29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
<a name="3" id="anc3"></a>
 30 
 31 import java.lang.annotation.Annotation;
<a name="4" id="anc4"></a><span class="line-modified"> 32 import java.lang.reflect.Field;</span>
<span class="line-modified"> 33 import java.util.HashMap;</span>
 34 
 35 import jdk.vm.ci.meta.JavaConstant;
 36 import jdk.vm.ci.meta.JavaType;
 37 import jdk.vm.ci.meta.ResolvedJavaType;
 38 import jdk.vm.ci.meta.UnresolvedJavaType;
 39 
 40 /**
 41  * Represents a field in a HotSpot type.
 42  */
 43 class HotSpotResolvedJavaFieldImpl implements HotSpotResolvedJavaField {
 44 
 45     private final HotSpotResolvedObjectTypeImpl holder;
 46     private JavaType type;
<a name="5" id="anc5"></a>



 47     private final int offset;
<a name="6" id="anc6"></a>



 48     private final short index;
 49 
 50     /**
 51      * This value contains all flags as stored in the VM including internal ones.
 52      */
 53     private final int modifiers;
 54 
 55     HotSpotResolvedJavaFieldImpl(HotSpotResolvedObjectTypeImpl holder, JavaType type, long offset, int modifiers, int index) {
 56         this.holder = holder;
 57         this.type = type;
 58         this.index = (short) index;
 59         assert this.index == index;
 60         assert offset != -1;
 61         assert offset == (int) offset : &quot;offset larger than int&quot;;
 62         this.offset = (int) offset;
 63         this.modifiers = modifiers;
 64     }
 65 
 66     @Override
 67     public boolean equals(Object obj) {
 68         if (this == obj) {
 69             return true;
 70         }
<a name="7" id="anc7"></a><span class="line-modified"> 71         if (obj instanceof HotSpotResolvedJavaField) {</span>
 72             HotSpotResolvedJavaFieldImpl that = (HotSpotResolvedJavaFieldImpl) obj;
 73             if (that.offset != this.offset || that.isStatic() != this.isStatic()) {
 74                 return false;
 75             } else if (this.holder.equals(that.holder)) {
 76                 return true;
 77             }
 78         }
 79         return false;
 80     }
 81 
 82     @Override
 83     public int hashCode() {
 84         return holder.hashCode() ^ offset;
 85     }
 86 
 87     @Override
 88     public int getModifiers() {
<a name="8" id="anc8"></a><span class="line-modified"> 89         return modifiers &amp; jvmFieldModifiers();</span>
 90     }
 91 
 92     @Override
 93     public boolean isInternal() {
 94         return (modifiers &amp; config().jvmAccFieldInternal) != 0;
 95     }
 96 
 97     /**
 98      * Determines if a given object contains this field.
 99      *
100      * @return true iff this is a non-static field and its declaring class is assignable from
101      *         {@code object}&#39;s class
102      */
103     @Override
<a name="9" id="anc9"></a><span class="line-modified">104     public boolean isInObject(JavaConstant constant) {</span>
105         if (isStatic()) {
106             return false;
107         }
<a name="10" id="anc10"></a><span class="line-modified">108         Object object = ((HotSpotObjectConstantImpl) constant).object();</span>
<span class="line-modified">109         return getDeclaringClass().isAssignableFrom(HotSpotResolvedObjectTypeImpl.fromObjectClass(object.getClass()));</span>
110     }
111 
112     @Override
113     public HotSpotResolvedObjectTypeImpl getDeclaringClass() {
114         return holder;
115     }
116 
117     @Override
118     public String getName() {
119         return holder.createFieldInfo(index).getName();
120     }
121 
122     @Override
123     public JavaType getType() {
124         // Pull field into local variable to prevent a race causing
125         // a ClassCastException below
126         JavaType currentType = type;
127         if (currentType instanceof UnresolvedJavaType) {
128             // Don&#39;t allow unresolved types to hang around forever
129             UnresolvedJavaType unresolvedType = (UnresolvedJavaType) currentType;
<a name="11" id="anc11"></a><span class="line-modified">130             ResolvedJavaType resolved = holder.lookupType(unresolvedType, false);</span>
<span class="line-modified">131             if (resolved != null) {</span>
132                 type = resolved;
133             }
134         }
135         return type;
<a name="12" id="anc12"></a>
136     }
137 
138     @Override
139     public int getOffset() {
140         return offset;
141     }
142 
<a name="13" id="anc13"></a>







143     @Override
144     public String toString() {
<a name="14" id="anc14"></a><span class="line-modified">145         return format(&quot;HotSpotField&lt;%H.%n %t:&quot;) + offset + &quot;&gt;&quot;;</span>
146     }
147 
148     @Override
149     public boolean isSynthetic() {
150         return (config().jvmAccSynthetic &amp; modifiers) != 0;
151     }
152 
153     /**
<a name="15" id="anc15"></a><span class="line-modified">154      * Checks if this field has the {@code Stable} annotation.</span>
155      *
<a name="16" id="anc16"></a><span class="line-modified">156      * @return true if field has {@code Stable} annotation, false otherwise</span>
157      */
158     @Override
159     public boolean isStable() {
160         return (config().jvmAccFieldStable &amp; modifiers) != 0;
161     }
162 
163     private boolean hasAnnotations() {
164         if (!isInternal()) {
165             HotSpotVMConfig config = config();
166             final long metaspaceAnnotations = UNSAFE.getAddress(holder.getMetaspaceKlass() + config.instanceKlassAnnotationsOffset);
167             if (metaspaceAnnotations != 0) {
168                 long fieldsAnnotations = UNSAFE.getAddress(metaspaceAnnotations + config.annotationsFieldAnnotationsOffset);
169                 if (fieldsAnnotations != 0) {
170                     long fieldAnnotations = UNSAFE.getAddress(fieldsAnnotations + config.fieldsAnnotationsBaseOffset + (ADDRESS_SIZE * index));
171                     return fieldAnnotations != 0;
172                 }
173             }
174         }
175         return false;
176     }
177 
178     @Override
179     public Annotation[] getAnnotations() {
180         if (!hasAnnotations()) {
181             return new Annotation[0];
182         }
<a name="17" id="anc17"></a><span class="line-modified">183         return toJava().getAnnotations();</span>
184     }
185 
186     @Override
187     public Annotation[] getDeclaredAnnotations() {
188         if (!hasAnnotations()) {
189             return new Annotation[0];
190         }
<a name="18" id="anc18"></a><span class="line-modified">191         return toJava().getDeclaredAnnotations();</span>
192     }
193 
194     @Override
195     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
196         if (!hasAnnotations()) {
197             return null;
198         }
<a name="19" id="anc19"></a><span class="line-modified">199         return toJava().getAnnotation(annotationClass);</span>
<span class="line-removed">200     }</span>
<span class="line-removed">201 </span>
<span class="line-removed">202     /**</span>
<span class="line-removed">203      * Gets a {@link Field} object corresponding to this object. This method always returns the same</span>
<span class="line-removed">204      * {@link Field} object for a given {@link HotSpotResolvedJavaFieldImpl}. This ensures</span>
<span class="line-removed">205      * {@link #getDeclaredAnnotations()}, {@link #getAnnotations()} and</span>
<span class="line-removed">206      * {@link #getAnnotation(Class)} are stable with respect to the identity of the</span>
<span class="line-removed">207      * {@link Annotation} objects they return.</span>
<span class="line-removed">208      */</span>
<span class="line-removed">209     private Field toJava() {</span>
<span class="line-removed">210         synchronized (holder) {</span>
<span class="line-removed">211             HashMap&lt;HotSpotResolvedJavaFieldImpl, Field&gt; cache = holder.reflectionFieldCache;</span>
<span class="line-removed">212             if (cache == null) {</span>
<span class="line-removed">213                 cache = new HashMap&lt;&gt;();</span>
<span class="line-removed">214                 holder.reflectionFieldCache = cache;</span>
<span class="line-removed">215             }</span>
<span class="line-removed">216             Field reflect = cache.get(this);</span>
<span class="line-removed">217             if (reflect == null) {</span>
<span class="line-removed">218                 reflect = compilerToVM().asReflectionField(holder, index);</span>
<span class="line-removed">219                 cache.put(this, reflect);</span>
<span class="line-removed">220             }</span>
<span class="line-removed">221             return reflect;</span>
<span class="line-removed">222         }</span>
223     }
224 }
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
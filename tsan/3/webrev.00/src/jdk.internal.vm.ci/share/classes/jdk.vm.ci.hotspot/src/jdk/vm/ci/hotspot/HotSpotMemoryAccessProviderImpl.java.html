<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMemoryAccessProviderImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 26 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 27 
 28 import jdk.vm.ci.meta.Constant;
 29 import jdk.vm.ci.meta.JavaConstant;
 30 import jdk.vm.ci.meta.JavaKind;
 31 import jdk.vm.ci.meta.MemoryAccessProvider;
 32 import jdk.vm.ci.meta.PrimitiveConstant;
 33 
 34 /**
 35  * HotSpot implementation of {@link MemoryAccessProvider}.
 36  */
 37 class HotSpotMemoryAccessProviderImpl implements HotSpotMemoryAccessProvider {
 38 
 39     protected final HotSpotJVMCIRuntime runtime;
 40 
 41     HotSpotMemoryAccessProviderImpl(HotSpotJVMCIRuntime runtime) {
 42         this.runtime = runtime;
 43     }
 44 
 45     /**
 46      * Gets the object boxed by {@code base} that is about to have a value of kind {@code kind} read
 47      * from it at the offset {@code displacement}.
 48      *
 49      * @param base constant value containing the base address for a pending read
 50      * @return {@code null} if {@code base} does not box an object otherwise the object boxed in
 51      *         {@code base}
 52      */
 53     private static HotSpotObjectConstantImpl asObject(Constant base, JavaKind kind, long displacement) {
 54         if (base instanceof HotSpotObjectConstantImpl) {
 55             HotSpotObjectConstantImpl constant = (HotSpotObjectConstantImpl) base;
 56             HotSpotResolvedObjectType type = constant.getType();
 57             runtime().reflection.checkRead(constant, kind, displacement, type);
 58             return constant;
 59         }
 60         return null;
 61     }
 62 
 63     private boolean isValidObjectFieldDisplacement(Constant base, long displacement) {
 64         if (base instanceof HotSpotMetaspaceConstant) {
 65             MetaspaceObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);
 66             if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {
 67                 if (displacement == runtime.getConfig().javaMirrorOffset) {
 68                     // Klass::_java_mirror is valid for all Klass* values
 69                     return true;
 70                 }
 71             } else {
 72                 throw new IllegalArgumentException(String.valueOf(metaspaceObject));
 73             }
 74         }
 75         return false;
 76     }
 77 
 78     private static long asRawPointer(Constant base) {
 79         if (base instanceof HotSpotMetaspaceConstantImpl) {
 80             MetaspaceObject meta = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);
 81             return meta.getMetaspacePointer();
 82         } else if (base instanceof PrimitiveConstant) {
 83             PrimitiveConstant prim = (PrimitiveConstant) base;
 84             if (prim.getJavaKind().isNumericInteger()) {
 85                 return prim.asLong();
 86             }
 87         }
 88         throw new IllegalArgumentException(String.valueOf(base));
 89     }
 90 
 91     private static long readRawValue(Constant baseConstant, long displacement, JavaKind kind, int bits) {
 92         HotSpotObjectConstantImpl base = asObject(baseConstant, kind, displacement);
 93         if (base != null) {
 94             switch (bits) {
 95                 case Byte.SIZE:
 96                     return runtime().reflection.getByte(base, displacement);
 97                 case Short.SIZE:
 98                     return runtime().reflection.getShort(base, displacement);
 99                 case Integer.SIZE:
100                     return runtime().reflection.getInt(base, displacement);
101                 case Long.SIZE:
102                     return runtime().reflection.getLong(base, displacement);
103                 default:
104                     throw new IllegalArgumentException(String.valueOf(bits));
105             }
106         } else {
107             long pointer = asRawPointer(baseConstant);
108             switch (bits) {
109                 case Byte.SIZE:
110                     return UNSAFE.getByte(pointer + displacement);
111                 case Short.SIZE:
112                     return UNSAFE.getShort(pointer + displacement);
113                 case Integer.SIZE:
114                     return UNSAFE.getInt(pointer + displacement);
115                 case Long.SIZE:
116                     return UNSAFE.getLong(pointer + displacement);
117                 default:
118                     throw new IllegalArgumentException(String.valueOf(bits));
119             }
120         }
121     }
122 
123     private boolean verifyReadRawObject(JavaConstant expected, Constant base, long displacement) {
124         if (base instanceof HotSpotMetaspaceConstant) {
125             MetaspaceObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);
126             if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {
127                 if (displacement == runtime.getConfig().javaMirrorOffset) {
128                     HotSpotResolvedObjectTypeImpl type = (HotSpotResolvedObjectTypeImpl) metaspaceObject;
129                     assert expected.equals(type.getJavaMirror());
130                 }
131             }
132         }
133         return true;
134     }
135 
136     private JavaConstant readRawObject(Constant baseConstant, long initialDisplacement, boolean compressed) {
137         long displacement = initialDisplacement;
138         JavaConstant ret;
139         HotSpotObjectConstantImpl base = asObject(baseConstant, JavaKind.Object, displacement);
140         if (base == null) {
141             assert !compressed;
142             displacement += asRawPointer(baseConstant);
143             ret = runtime.getCompilerToVM().readUncompressedOop(displacement);
144             assert verifyReadRawObject(ret, baseConstant, initialDisplacement);
145         } else {
146             assert runtime.getConfig().useCompressedOops == compressed;
147             ret = runtime.getCompilerToVM().getObject(base, displacement);
148         }
149         return ret == null ? JavaConstant.NULL_POINTER : ret;
150     }
151 
152     @Override
153     public JavaConstant readPrimitiveConstant(JavaKind kind, Constant baseConstant, long initialDisplacement, int bits) {
154         try {
155             long rawValue = readRawValue(baseConstant, initialDisplacement, kind, bits);
156             switch (kind) {
157                 case Boolean:
158                     return JavaConstant.forBoolean(rawValue != 0);
159                 case Byte:
160                     return JavaConstant.forByte((byte) rawValue);
161                 case Char:
162                     return JavaConstant.forChar((char) rawValue);
163                 case Short:
164                     return JavaConstant.forShort((short) rawValue);
165                 case Int:
166                     return JavaConstant.forInt((int) rawValue);
167                 case Long:
168                     return JavaConstant.forLong(rawValue);
169                 case Float:
170                     return JavaConstant.forFloat(Float.intBitsToFloat((int) rawValue));
171                 case Double:
172                     return JavaConstant.forDouble(Double.longBitsToDouble(rawValue));
173                 default:
174                     throw new IllegalArgumentException(&quot;Unsupported kind: &quot; + kind);
175             }
176         } catch (NullPointerException e) {
177             return null;
178         }
179     }
180 
181     @Override
182     public JavaConstant readObjectConstant(Constant base, long displacement) {
183         if (base instanceof HotSpotObjectConstantImpl) {
184             return readRawObject(base, displacement, runtime.getConfig().useCompressedOops);
185         }
186         if (!isValidObjectFieldDisplacement(base, displacement)) {
187             return null;
188         }
189         if (base instanceof HotSpotMetaspaceConstant &amp;&amp;
190             displacement == runtime.getConfig().javaMirrorOffset) {
191             MetaspaceObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);
192             return ((HotSpotResolvedObjectTypeImpl) metaspaceObject).getJavaMirror();
193         }
194         return readRawObject(base, displacement, false);
195     }
196 
197     @Override
198     public JavaConstant readNarrowOopConstant(Constant base, long displacement) {
199         JavaConstant res = readRawObject(base, displacement, true);
200         return JavaConstant.NULL_POINTER.equals(res) ? HotSpotCompressedNullConstant.COMPRESSED_NULL : ((HotSpotObjectConstant) res).compress();
201     }
202 
203     private HotSpotResolvedObjectTypeImpl readKlass(Constant base, long displacement, boolean compressed) {
204         assert (base instanceof HotSpotMetaspaceConstantImpl) || (base instanceof HotSpotObjectConstantImpl) : base.getClass();
205         if (base instanceof HotSpotMetaspaceConstantImpl) {
206             return runtime.getCompilerToVM().getResolvedJavaType((HotSpotResolvedObjectTypeImpl) ((HotSpotMetaspaceConstantImpl) base).asResolvedJavaType(), displacement, compressed);
207         } else {
208             return runtime.getCompilerToVM().getResolvedJavaType(((HotSpotObjectConstantImpl) base), displacement, compressed);
209         }
210     }
211 
212 
213     @Override
214     public Constant readKlassPointerConstant(Constant base, long displacement) {
215         HotSpotResolvedObjectTypeImpl klass = readKlass(base, displacement, false);
216         if (klass == null) {
217             return JavaConstant.NULL_POINTER;
218         }
219         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(klass, false);
220     }
221 
222     @Override
223     public Constant readNarrowKlassPointerConstant(Constant base, long displacement) {
224         HotSpotResolvedObjectTypeImpl klass = readKlass(base, displacement, true);
225         if (klass == null) {
226             return HotSpotCompressedNullConstant.COMPRESSED_NULL;
227         }
228         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(klass, true);
229     }
230 
231     @Override
232     public Constant readMethodPointerConstant(Constant base, long displacement) {
233         assert (base instanceof HotSpotObjectConstantImpl);
234         HotSpotResolvedJavaMethodImpl method = runtime.getCompilerToVM().getResolvedJavaMethod((HotSpotObjectConstantImpl) base, displacement);
235         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(method, false);
236     }
237 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotResolvedJavaFieldImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotResolvedJavaType.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 33,12 ***</span>
  
  import java.lang.annotation.Annotation;
  import java.lang.reflect.Executable;
  import java.lang.reflect.Modifier;
  import java.lang.reflect.Type;
<span class="line-removed">- import java.util.HashMap;</span>
<span class="line-removed">- import java.util.Map;</span>
  
  import jdk.vm.ci.common.JVMCIError;
  import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.Option;
  import jdk.vm.ci.meta.Constant;
  import jdk.vm.ci.meta.ConstantPool;
<span class="line-new-header">--- 33,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 56,66 ***</span>
  import jdk.vm.ci.meta.TriState;
  
  /**
   * Implementation of {@link JavaMethod} for resolved HotSpot methods.
   */
<span class="line-modified">! final class HotSpotResolvedJavaMethodImpl extends HotSpotMethod implements HotSpotResolvedJavaMethod, MetaspaceWrapperObject {</span>
  
      /**
<span class="line-modified">!      * Reference to metaspace Method object.</span>
       */
<span class="line-modified">!     private final long metaspaceMethod;</span>
  
      private final HotSpotResolvedObjectTypeImpl holder;
      private final HotSpotConstantPool constantPool;
<span class="line-modified">!     private final HotSpotSignature signature;</span>
      private HotSpotMethodData methodData;
      private byte[] code;
  
      /**
<span class="line-modified">!      * Cache for {@link #toJava()}.</span>
       */
<span class="line-modified">!     private volatile Executable toJavaCache;</span>
  
      /**
       * Only 30% of {@link HotSpotResolvedJavaMethodImpl}s have their name accessed so compute it
       * lazily and cache it.
       */
      private String nameCache;
  
      /**
       * Gets the holder of a HotSpot metaspace method native object.
       *
<span class="line-modified">!      * @param metaspaceMethod a metaspace Method object</span>
       * @return the {@link ResolvedJavaType} corresponding to the holder of the
       *         {@code metaspaceMethod}
       */
<span class="line-modified">!     private static HotSpotResolvedObjectTypeImpl getHolder(long metaspaceMethod) {</span>
          HotSpotVMConfig config = config();
          final long metaspaceConstMethod = UNSAFE.getAddress(metaspaceMethod + config.methodConstMethodOffset);
          final long metaspaceConstantPool = UNSAFE.getAddress(metaspaceConstMethod + config.constMethodConstantsOffset);
<span class="line-modified">!         return compilerToVM().getResolvedJavaType(null, metaspaceConstantPool + config.constantPoolHolderOffset, false);</span>
      }
  
      /**
       * Gets the JVMCI mirror from a HotSpot method. The VM is responsible for ensuring that the
<span class="line-modified">!      * Method* is kept alive for the duration of this call and the</span>
<span class="line-modified">!      * {@link HotSpotJVMCIMetaAccessContext} keeps it alive after that.</span>
<span class="line-modified">!      *</span>
       * Called from the VM.
       *
<span class="line-modified">!      * @param metaspaceMethod a metaspace Method object</span>
       * @return the {@link ResolvedJavaMethod} corresponding to {@code metaspaceMethod}
       */
      @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">!     private static HotSpotResolvedJavaMethod fromMetaspace(long metaspaceMethod) {</span>
<span class="line-modified">!         HotSpotResolvedObjectTypeImpl holder = getHolder(metaspaceMethod);</span>
<span class="line-modified">!         return holder.createMethod(metaspaceMethod);</span>
      }
  
<span class="line-modified">!     HotSpotResolvedJavaMethodImpl(HotSpotResolvedObjectTypeImpl holder, long metaspaceMethod) {</span>
<span class="line-modified">!         this.metaspaceMethod = metaspaceMethod;</span>
          this.holder = holder;
  
          HotSpotVMConfig config = config();
          final long constMethod = getConstMethod();
  
<span class="line-new-header">--- 54,72 ---</span>
  import jdk.vm.ci.meta.TriState;
  
  /**
   * Implementation of {@link JavaMethod} for resolved HotSpot methods.
   */
<span class="line-modified">! final class HotSpotResolvedJavaMethodImpl extends HotSpotMethod implements HotSpotResolvedJavaMethod, MetaspaceHandleObject {</span>
  
      /**
<span class="line-modified">!      * Handle to the metaspace {@code Method} object. The handle is in</span>
<span class="line-added">+      * {@code JVMCI::_metadata_handles}.</span>
       */
<span class="line-modified">!     private final long metadataHandle;</span>
  
      private final HotSpotResolvedObjectTypeImpl holder;
      private final HotSpotConstantPool constantPool;
<span class="line-modified">!     final HotSpotSignature signature;</span>
      private HotSpotMethodData methodData;
      private byte[] code;
  
      /**
<span class="line-modified">!      * Cache for {@link HotSpotJDKReflection#getMethod}.</span>
       */
<span class="line-modified">!     volatile Executable toJavaCache;</span>
  
      /**
       * Only 30% of {@link HotSpotResolvedJavaMethodImpl}s have their name accessed so compute it
       * lazily and cache it.
       */
      private String nameCache;
  
      /**
       * Gets the holder of a HotSpot metaspace method native object.
       *
<span class="line-modified">!      * @param metaspaceHandle a handle to a metaspace Method object</span>
       * @return the {@link ResolvedJavaType} corresponding to the holder of the
       *         {@code metaspaceMethod}
       */
<span class="line-modified">!     private static HotSpotResolvedObjectTypeImpl getHolder(long metaspaceHandle) {</span>
          HotSpotVMConfig config = config();
<span class="line-added">+         long metaspaceMethod = UNSAFE.getLong(metaspaceHandle);</span>
<span class="line-added">+         assert metaspaceMethod != 0 : metaspaceHandle;</span>
          final long metaspaceConstMethod = UNSAFE.getAddress(metaspaceMethod + config.methodConstMethodOffset);
          final long metaspaceConstantPool = UNSAFE.getAddress(metaspaceConstMethod + config.constMethodConstantsOffset);
<span class="line-modified">!         HotSpotResolvedObjectTypeImpl result = compilerToVM().getResolvedJavaType(metaspaceConstantPool + config.constantPoolHolderOffset, false);</span>
<span class="line-added">+         assert result != null;</span>
<span class="line-added">+         return result;</span>
      }
  
      /**
       * Gets the JVMCI mirror from a HotSpot method. The VM is responsible for ensuring that the
<span class="line-modified">!      * Method* is kept alive for the duration of this call and the {@link HotSpotJVMCIRuntime} keeps</span>
<span class="line-modified">!      * it alive after that.</span>
<span class="line-modified">!      * &lt;p&gt;</span>
       * Called from the VM.
       *
<span class="line-modified">!      * @param metaspaceHandle a handle to metaspace Method object</span>
       * @return the {@link ResolvedJavaMethod} corresponding to {@code metaspaceMethod}
       */
      @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">!     @VMEntryPoint</span>
<span class="line-modified">!     private static HotSpotResolvedJavaMethod fromMetaspace(long metaspaceHandle) {</span>
<span class="line-modified">!         HotSpotResolvedObjectTypeImpl holder = getHolder(metaspaceHandle);</span>
<span class="line-added">+         return holder.createMethod(metaspaceHandle);</span>
      }
  
<span class="line-modified">!     HotSpotResolvedJavaMethodImpl(HotSpotResolvedObjectTypeImpl holder, long metaspaceHandle) {</span>
<span class="line-modified">!         this.metadataHandle = metaspaceHandle;</span>
          this.holder = holder;
  
          HotSpotVMConfig config = config();
          final long constMethod = getConstMethod();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 131,10 ***</span>
<span class="line-new-header">--- 135,11 ---</span>
              this.constantPool = compilerToVM().getConstantPool(this);
          }
  
          final int signatureIndex = UNSAFE.getChar(constMethod + config.constMethodSignatureIndexOffset);
          this.signature = (HotSpotSignature) constantPool.lookupSignature(signatureIndex);
<span class="line-added">+         HandleCleaner.create(this, metaspaceHandle);</span>
      }
  
      /**
       * Returns a pointer to this method&#39;s constant method data structure (
       * {@code Method::_constMethod}). This pointer isn&#39;t wrapped since it should be safe to use it
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,12 ***</span>
       * are kept alive as a pair.
       *
       * @return pointer to this method&#39;s ConstMethod
       */
      private long getConstMethod() {
<span class="line-modified">!         assert metaspaceMethod != 0;</span>
<span class="line-removed">-         return UNSAFE.getAddress(metaspaceMethod + config().methodConstMethodOffset);</span>
      }
  
      @Override
      public String getName() {
          if (nameCache == null) {
<span class="line-new-header">--- 147,11 ---</span>
       * are kept alive as a pair.
       *
       * @return pointer to this method&#39;s ConstMethod
       */
      private long getConstMethod() {
<span class="line-modified">!         return UNSAFE.getAddress(getMetaspaceMethod() + config().methodConstMethodOffset);</span>
      }
  
      @Override
      public String getName() {
          if (nameCache == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 162,27 ***</span>
          if (this == obj) {
              return true;
          }
          if (obj instanceof HotSpotResolvedJavaMethodImpl) {
              HotSpotResolvedJavaMethodImpl that = (HotSpotResolvedJavaMethodImpl) obj;
<span class="line-modified">!             return that.metaspaceMethod == metaspaceMethod;</span>
          }
          return false;
      }
  
      @Override
      public int hashCode() {
<span class="line-modified">!         return (int) metaspaceMethod;</span>
      }
  
      /**
       * Returns this method&#39;s flags ({@code Method::_flags}).
       *
       * @return flags of this method
       */
      private int getFlags() {
<span class="line-modified">!         return UNSAFE.getShort(metaspaceMethod + config().methodFlagsOffset);</span>
      }
  
      /**
       * Returns this method&#39;s constant method flags ({@code ConstMethod::_flags}).
       *
<span class="line-new-header">--- 166,27 ---</span>
          if (this == obj) {
              return true;
          }
          if (obj instanceof HotSpotResolvedJavaMethodImpl) {
              HotSpotResolvedJavaMethodImpl that = (HotSpotResolvedJavaMethodImpl) obj;
<span class="line-modified">!             return that.getMetaspaceMethod() == getMetaspaceMethod();</span>
          }
          return false;
      }
  
      @Override
      public int hashCode() {
<span class="line-modified">!         return (int) getMetaspaceMethod();</span>
      }
  
      /**
       * Returns this method&#39;s flags ({@code Method::_flags}).
       *
       * @return flags of this method
       */
      private int getFlags() {
<span class="line-modified">!         return UNSAFE.getShort(getMetaspaceMethod() + config().methodFlagsOffset);</span>
      }
  
      /**
       * Returns this method&#39;s constant method flags ({@code ConstMethod::_flags}).
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 202,13 ***</span>
       */
      public Constant getMetaspaceMethodConstant() {
          return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
      }
  
      @Override
<span class="line-modified">!     public long getMetaspacePointer() {</span>
<span class="line-modified">!         return metaspaceMethod;</span>
      }
  
      @Override
      public Constant getEncoding() {
          return getMetaspaceMethodConstant();
<span class="line-new-header">--- 206,21 ---</span>
       */
      public Constant getMetaspaceMethodConstant() {
          return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
      }
  
<span class="line-added">+     long getMetaspaceMethod() {</span>
<span class="line-added">+         long metaspacePointer = getMetaspacePointer();</span>
<span class="line-added">+         if (metaspacePointer == 0) {</span>
<span class="line-added">+             throw new NullPointerException(&quot;Method* is null&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return metaspacePointer;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
<span class="line-modified">!     public long getMetadataHandle() {</span>
<span class="line-modified">!         return metadataHandle;</span>
      }
  
      @Override
      public Constant getEncoding() {
          return getMetaspaceMethodConstant();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 217,21 ***</span>
      /**
       * Gets the complete set of modifiers for this method which includes the JVM specification
       * modifiers as well as the HotSpot internal modifiers.
       */
      public int getAllModifiers() {
<span class="line-modified">!         return UNSAFE.getInt(metaspaceMethod + config().methodAccessFlagsOffset);</span>
      }
  
      @Override
      public int getModifiers() {
          return getAllModifiers() &amp; jvmMethodModifiers();
      }
  
      @Override
      public boolean canBeStaticallyBound() {
<span class="line-modified">!         return (isFinal() || isPrivate() || isStatic() || holder.isLeaf()) &amp;&amp; isConcrete();</span>
      }
  
      @Override
      public byte[] getCode() {
          if (getCodeSize() == 0) {
<span class="line-new-header">--- 229,21 ---</span>
      /**
       * Gets the complete set of modifiers for this method which includes the JVM specification
       * modifiers as well as the HotSpot internal modifiers.
       */
      public int getAllModifiers() {
<span class="line-modified">!         return UNSAFE.getInt(getMetaspaceMethod() + config().methodAccessFlagsOffset);</span>
      }
  
      @Override
      public int getModifiers() {
          return getAllModifiers() &amp; jvmMethodModifiers();
      }
  
      @Override
      public boolean canBeStaticallyBound() {
<span class="line-modified">!         return (isFinal() || isPrivate() || isStatic() || holder.isLeaf() || isConstructor()) &amp;&amp; isConcrete();</span>
      }
  
      @Override
      public byte[] getCode() {
          if (getCodeSize() == 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,11 ***</span>
                  catchType = constantPool.lookupType(catchTypeIndex, opcode);
  
                  // Check for Throwable which catches everything.
                  if (catchType instanceof HotSpotResolvedObjectTypeImpl) {
                      HotSpotResolvedObjectTypeImpl resolvedType = (HotSpotResolvedObjectTypeImpl) catchType;
<span class="line-modified">!                     if (resolvedType.mirror() == Throwable.class) {</span>
                          catchTypeIndex = 0;
                          catchType = null;
                      }
                  }
              }
<span class="line-new-header">--- 287,11 ---</span>
                  catchType = constantPool.lookupType(catchTypeIndex, opcode);
  
                  // Check for Throwable which catches everything.
                  if (catchType instanceof HotSpotResolvedObjectTypeImpl) {
                      HotSpotResolvedObjectTypeImpl resolvedType = (HotSpotResolvedObjectTypeImpl) catchType;
<span class="line-modified">!                     if (resolvedType.equals(runtime().getJavaLangThrowable())) {</span>
                          catchTypeIndex = 0;
                          catchType = null;
                      }
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 392,10 ***</span>
<span class="line-new-header">--- 404,12 ---</span>
          return compilerToVM().getStackTraceElement(this, bci);
      }
  
      @Override
      public ResolvedJavaMethod uniqueConcreteMethod(HotSpotResolvedObjectType receiver) {
<span class="line-added">+         assert !canBeStaticallyBound() : this;</span>
<span class="line-added">+ </span>
          if (receiver.isInterface()) {
              // Cannot trust interfaces. Because of:
              // interface I { void foo(); }
              // class A { public void foo() {} }
              // class B extends A implements I { }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 403,10 ***</span>
<span class="line-new-header">--- 417,11 ---</span>
              // class D extends B { }
              // Would lead to identify C.foo() as the unique concrete method for I.foo() without
              // seeing A.foo().
              return null;
          }
<span class="line-added">+         assert !receiver.isLinked() || isInVirtualMethodTable(receiver);</span>
          if (this.isDefault()) {
              // CHA for default methods doesn&#39;t work and may crash the VM
              return null;
          }
          return compilerToVM().findUniqueConcreteMethod(((HotSpotResolvedObjectTypeImpl) receiver), this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 422,11 ***</span>
       *
       * @return the value of {@code Method::_code}
       */
      private long getCompiledCode() {
          HotSpotVMConfig config = config();
<span class="line-modified">!         return UNSAFE.getAddress(metaspaceMethod + config.methodCodeOffset);</span>
      }
  
      /**
       * Returns whether this method has compiled code.
       *
<span class="line-new-header">--- 437,11 ---</span>
       *
       * @return the value of {@code Method::_code}
       */
      private long getCompiledCode() {
          HotSpotVMConfig config = config();
<span class="line-modified">!         return UNSAFE.getAddress(getMetaspaceMethod() + config.methodCodeOffset);</span>
      }
  
      /**
       * Returns whether this method has compiled code.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 453,16 ***</span>
      @Override
      public ProfilingInfo getProfilingInfo(boolean includeNormal, boolean includeOSR) {
          ProfilingInfo info;
  
          if (Option.UseProfilingInformation.getBoolean() &amp;&amp; methodData == null) {
<span class="line-modified">!             long metaspaceMethodData = UNSAFE.getAddress(metaspaceMethod + config().methodDataOffset);</span>
              if (metaspaceMethodData != 0) {
                  methodData = new HotSpotMethodData(metaspaceMethodData, this);
                  String methodDataFilter = Option.TraceMethodDataFilter.getString();
                  if (methodDataFilter != null &amp;&amp; this.format(&quot;%H.%n&quot;).contains(methodDataFilter)) {
<span class="line-modified">!                     System.out.println(methodData.toString());</span>
                  }
              }
          }
  
          if (methodData == null || (!methodData.hasNormalData() &amp;&amp; !methodData.hasExtraData())) {
<span class="line-new-header">--- 468,18 ---</span>
      @Override
      public ProfilingInfo getProfilingInfo(boolean includeNormal, boolean includeOSR) {
          ProfilingInfo info;
  
          if (Option.UseProfilingInformation.getBoolean() &amp;&amp; methodData == null) {
<span class="line-modified">!             long metaspaceMethodData = UNSAFE.getAddress(getMetaspaceMethod() + config().methodDataOffset);</span>
              if (metaspaceMethodData != 0) {
                  methodData = new HotSpotMethodData(metaspaceMethodData, this);
                  String methodDataFilter = Option.TraceMethodDataFilter.getString();
                  if (methodDataFilter != null &amp;&amp; this.format(&quot;%H.%n&quot;).contains(methodDataFilter)) {
<span class="line-modified">!                     String line = methodData.toString() + System.lineSeparator();</span>
<span class="line-added">+                     byte[] lineBytes = line.getBytes();</span>
<span class="line-added">+                     CompilerToVM.compilerToVM().writeDebugOutput(lineBytes, 0, lineBytes.length, true, true);</span>
                  }
              }
          }
  
          if (methodData == null || (!methodData.hasNormalData() &amp;&amp; !methodData.hasExtraData())) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 488,50 ***</span>
      @Override
      public Parameter[] getParameters() {
          if (signature.getParameterCount(false) == 0) {
              return new ResolvedJavaMethod.Parameter[0];
          }
<span class="line-modified">!         java.lang.reflect.Parameter[] javaParameters = toJava().getParameters();</span>
<span class="line-removed">-         Parameter[] res = new Parameter[javaParameters.length];</span>
<span class="line-removed">-         for (int i = 0; i &lt; res.length; i++) {</span>
<span class="line-removed">-             java.lang.reflect.Parameter src = javaParameters[i];</span>
<span class="line-removed">-             String paramName = src.isNamePresent() ? src.getName() : null;</span>
<span class="line-removed">-             res[i] = new Parameter(paramName, src.getModifiers(), this, i);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return res;</span>
      }
  
      @Override
      public Annotation[][] getParameterAnnotations() {
<span class="line-modified">!         if ((getConstMethodFlags() &amp; config().constMethodHasParameterAnnotations) == 0) {</span>
              return new Annotation[signature.getParameterCount(false)][0];
          }
<span class="line-modified">!         return toJava().getParameterAnnotations();</span>
      }
  
      @Override
      public Annotation[] getAnnotations() {
<span class="line-modified">!         if ((getConstMethodFlags() &amp; config().constMethodHasMethodAnnotations) == 0) {</span>
              return new Annotation[0];
          }
<span class="line-modified">!         return toJava().getAnnotations();</span>
      }
  
      @Override
      public Annotation[] getDeclaredAnnotations() {
<span class="line-modified">!         if ((getConstMethodFlags() &amp; config().constMethodHasMethodAnnotations) == 0) {</span>
              return new Annotation[0];
          }
<span class="line-modified">!         return toJava().getDeclaredAnnotations();</span>
      }
  
      @Override
      public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="line-modified">!         if ((getConstMethodFlags() &amp; config().constMethodHasMethodAnnotations) == 0) {</span>
              return null;
          }
<span class="line-modified">!         return toJava().getAnnotation(annotationClass);</span>
      }
  
      @Override
      public boolean isBridge() {
          return (BRIDGE &amp; getModifiers()) != 0;
<span class="line-new-header">--- 505,43 ---</span>
      @Override
      public Parameter[] getParameters() {
          if (signature.getParameterCount(false) == 0) {
              return new ResolvedJavaMethod.Parameter[0];
          }
<span class="line-modified">!         return runtime().reflection.getParameters(this);</span>
      }
  
      @Override
      public Annotation[][] getParameterAnnotations() {
<span class="line-modified">!         if ((getConstMethodFlags() &amp; config().constMethodHasParameterAnnotations) == 0 || isClassInitializer()) {</span>
              return new Annotation[signature.getParameterCount(false)][0];
          }
<span class="line-modified">!         return runtime().reflection.getParameterAnnotations(this);</span>
      }
  
      @Override
      public Annotation[] getAnnotations() {
<span class="line-modified">!         if ((getConstMethodFlags() &amp; config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {</span>
              return new Annotation[0];
          }
<span class="line-modified">!         return runtime().reflection.getMethodAnnotations(this);</span>
      }
  
      @Override
      public Annotation[] getDeclaredAnnotations() {
<span class="line-modified">!         if ((getConstMethodFlags() &amp; config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {</span>
              return new Annotation[0];
          }
<span class="line-modified">!         return runtime().reflection.getMethodDeclaredAnnotations(this);</span>
      }
  
      @Override
      public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="line-modified">!         if ((getConstMethodFlags() &amp; config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {</span>
              return null;
          }
<span class="line-modified">!         return runtime().reflection.getMethodAnnotation(this, annotationClass);</span>
      }
  
      @Override
      public boolean isBridge() {
          return (BRIDGE &amp; getModifiers()) != 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 557,23 ***</span>
      @Override
      public Type[] getGenericParameterTypes() {
          if (isClassInitializer()) {
              return new Type[0];
          }
<span class="line-modified">!         return toJava().getGenericParameterTypes();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private Executable toJava() {</span>
<span class="line-removed">-         if (toJavaCache == null) {</span>
<span class="line-removed">-             assert !isClassInitializer() : this;</span>
<span class="line-removed">-             synchronized (this) {</span>
<span class="line-removed">-                 if (toJavaCache == null) {</span>
<span class="line-removed">-                     toJavaCache = compilerToVM().asReflectionExecutable(this);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return toJavaCache;</span>
      }
  
      @Override
      public boolean canBeInlined() {
          if (hasNeverInlineDirective()) {
<span class="line-new-header">--- 567,11 ---</span>
      @Override
      public Type[] getGenericParameterTypes() {
          if (isClassInitializer()) {
              return new Type[0];
          }
<span class="line-modified">!         return runtime().reflection.getGenericParameterTypes(this);</span>
      }
  
      @Override
      public boolean canBeInlined() {
          if (hasNeverInlineDirective()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 696,54 ***</span>
       * @return virtual table index
       */
      private int getVtableIndex() {
          assert !holder.isInterface();
          HotSpotVMConfig config = config();
<span class="line-modified">!         int result = UNSAFE.getInt(metaspaceMethod + config.methodVtableIndexOffset);</span>
          assert result &gt;= config.nonvirtualVtableIndex : &quot;must be linked&quot;;
          return result;
      }
  
      private int getVtableIndexForInterfaceMethod(ResolvedJavaType resolved) {
          HotSpotResolvedObjectTypeImpl hotspotType = (HotSpotResolvedObjectTypeImpl) resolved;
          return compilerToVM().getVtableIndexForInterfaceMethod(hotspotType, this);
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * The {@link SpeculationLog} for methods compiled by JVMCI hang off this per-declaring-type</span>
<span class="line-removed">-      * {@link ClassValue}. The raw Method* value is safe to use as a key in the map as a) it is</span>
<span class="line-removed">-      * never moves and b) we never read from it.</span>
<span class="line-removed">-      * &lt;p&gt;</span>
<span class="line-removed">-      * One implication is that we will preserve {@link SpeculationLog}s for methods that have been</span>
<span class="line-removed">-      * redefined via class redefinition. It&#39;s tempting to periodically flush such logs but we cannot</span>
<span class="line-removed">-      * read the JVM_ACC_IS_OBSOLETE bit (or anything else) via the raw pointer as obsoleted methods</span>
<span class="line-removed">-      * are subject to clean up and deletion (see InstanceKlass::purge_previous_versions_internal).</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static final ClassValue&lt;Map&lt;Long, SpeculationLog&gt;&gt; SpeculationLogs = new ClassValue&lt;&gt;() {</span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         protected Map&lt;Long, SpeculationLog&gt; computeValue(java.lang.Class&lt;?&gt; type) {</span>
<span class="line-removed">-             return new HashMap&lt;&gt;(4);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
      @Override
      public SpeculationLog getSpeculationLog() {
<span class="line-modified">!         Map&lt;Long, SpeculationLog&gt; map = SpeculationLogs.get(holder.mirror());</span>
<span class="line-modified">!         synchronized (map) {</span>
<span class="line-removed">-             SpeculationLog log = map.get(this.metaspaceMethod);</span>
<span class="line-removed">-             if (log == null) {</span>
<span class="line-removed">-                 log = new HotSpotSpeculationLog();</span>
<span class="line-removed">-                 map.put(metaspaceMethod, log);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return log;</span>
<span class="line-removed">-         }</span>
      }
  
      @Override
      public int intrinsicId() {
          HotSpotVMConfig config = config();
<span class="line-modified">!         return UNSAFE.getChar(metaspaceMethod + config.methodIntrinsicIdOffset);</span>
      }
  
      @Override
      public boolean isIntrinsicCandidate() {
          return (getFlags() &amp; config().methodFlagsIntrinsicCandidate) != 0;
<span class="line-new-header">--- 694,30 ---</span>
       * @return virtual table index
       */
      private int getVtableIndex() {
          assert !holder.isInterface();
          HotSpotVMConfig config = config();
<span class="line-modified">!         int result = UNSAFE.getInt(getMetaspaceMethod() + config.methodVtableIndexOffset);</span>
          assert result &gt;= config.nonvirtualVtableIndex : &quot;must be linked&quot;;
          return result;
      }
  
      private int getVtableIndexForInterfaceMethod(ResolvedJavaType resolved) {
          HotSpotResolvedObjectTypeImpl hotspotType = (HotSpotResolvedObjectTypeImpl) resolved;
          return compilerToVM().getVtableIndexForInterfaceMethod(hotspotType, this);
      }
  
      @Override
      public SpeculationLog getSpeculationLog() {
<span class="line-modified">!         long address = compilerToVM().getFailedSpeculationsAddress(this);</span>
<span class="line-modified">!         return new HotSpotSpeculationLog(address);</span>
      }
  
      @Override
      public int intrinsicId() {
          HotSpotVMConfig config = config();
<span class="line-modified">!         return UNSAFE.getChar(getMetaspaceMethod() + config.methodIntrinsicIdOffset);</span>
      }
  
      @Override
      public boolean isIntrinsicCandidate() {
          return (getFlags() &amp; config().methodFlagsIntrinsicCandidate) != 0;
</pre>
<center><a href="HotSpotResolvedJavaFieldImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotResolvedJavaType.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
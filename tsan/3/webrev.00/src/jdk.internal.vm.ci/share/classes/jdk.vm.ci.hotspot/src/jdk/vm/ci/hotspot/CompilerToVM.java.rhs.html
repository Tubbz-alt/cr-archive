<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.vm.ci.hotspot;
 25 
 26 import static jdk.vm.ci.common.InitTimer.timer;
 27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 28 
 29 import java.lang.reflect.Executable;
 30 import java.lang.reflect.Field;
 31 
 32 import jdk.vm.ci.code.BytecodeFrame;
 33 import jdk.vm.ci.code.InstalledCode;
 34 import jdk.vm.ci.code.InvalidInstalledCodeException;
 35 import jdk.vm.ci.code.TargetDescription;
 36 import jdk.vm.ci.code.stack.InspectedFrameVisitor;
 37 import jdk.vm.ci.common.InitTimer;
 38 import jdk.vm.ci.common.JVMCIError;
<a name="2" id="anc2"></a><span class="line-added"> 39 import jdk.vm.ci.meta.Constant;</span>
<span class="line-added"> 40 import jdk.vm.ci.meta.ConstantReflectionProvider;</span>
<span class="line-added"> 41 import jdk.vm.ci.meta.JavaConstant;</span>
<span class="line-added"> 42 import jdk.vm.ci.meta.JavaKind;</span>
 43 import jdk.vm.ci.meta.JavaType;
 44 import jdk.vm.ci.meta.ResolvedJavaMethod;
 45 import jdk.vm.ci.meta.ResolvedJavaType;
 46 
 47 /**
 48  * Calls from Java into HotSpot. The behavior of all the methods in this class that take a native
 49  * pointer as an argument (e.g., {@link #getSymbol(long)}) is undefined if the argument does not
 50  * denote a valid native object.
 51  */
 52 final class CompilerToVM {
 53     /**
 54      * Initializes the native part of the JVMCI runtime.
 55      */
 56     private static native void registerNatives();
 57 
<a name="3" id="anc3"></a><span class="line-modified"> 58     /**</span>
<span class="line-modified"> 59      * These values mirror the equivalent values from {@code Unsafe} but are appropriate for the JVM</span>
<span class="line-modified"> 60      * being compiled against.</span>
<span class="line-added"> 61      */</span>
<span class="line-added"> 62     // Checkstyle: stop</span>
<span class="line-added"> 63     final int ARRAY_BOOLEAN_BASE_OFFSET;</span>
<span class="line-added"> 64     final int ARRAY_BYTE_BASE_OFFSET;</span>
<span class="line-added"> 65     final int ARRAY_SHORT_BASE_OFFSET;</span>
<span class="line-added"> 66     final int ARRAY_CHAR_BASE_OFFSET;</span>
<span class="line-added"> 67     final int ARRAY_INT_BASE_OFFSET;</span>
<span class="line-added"> 68     final int ARRAY_LONG_BASE_OFFSET;</span>
<span class="line-added"> 69     final int ARRAY_FLOAT_BASE_OFFSET;</span>
<span class="line-added"> 70     final int ARRAY_DOUBLE_BASE_OFFSET;</span>
<span class="line-added"> 71     final int ARRAY_OBJECT_BASE_OFFSET;</span>
<span class="line-added"> 72     final int ARRAY_BOOLEAN_INDEX_SCALE;</span>
<span class="line-added"> 73     final int ARRAY_BYTE_INDEX_SCALE;</span>
<span class="line-added"> 74     final int ARRAY_SHORT_INDEX_SCALE;</span>
<span class="line-added"> 75     final int ARRAY_CHAR_INDEX_SCALE;</span>
<span class="line-added"> 76     final int ARRAY_INT_INDEX_SCALE;</span>
<span class="line-added"> 77     final int ARRAY_LONG_INDEX_SCALE;</span>
<span class="line-added"> 78     final int ARRAY_FLOAT_INDEX_SCALE;</span>
<span class="line-added"> 79     final int ARRAY_DOUBLE_INDEX_SCALE;</span>
<span class="line-added"> 80     final int ARRAY_OBJECT_INDEX_SCALE;</span>
<span class="line-added"> 81     // Checkstyle: resume</span>
 82 
 83     @SuppressWarnings(&quot;try&quot;)
<a name="4" id="anc4"></a><span class="line-modified"> 84     CompilerToVM() {</span>
 85         try (InitTimer t = timer(&quot;CompilerToVM.registerNatives&quot;)) {
 86             registerNatives();
<a name="5" id="anc5"></a><span class="line-added"> 87             ARRAY_BOOLEAN_BASE_OFFSET = arrayBaseOffset(JavaKind.Boolean);</span>
<span class="line-added"> 88             ARRAY_BYTE_BASE_OFFSET = arrayBaseOffset(JavaKind.Byte);</span>
<span class="line-added"> 89             ARRAY_SHORT_BASE_OFFSET = arrayBaseOffset(JavaKind.Short);</span>
<span class="line-added"> 90             ARRAY_CHAR_BASE_OFFSET = arrayBaseOffset(JavaKind.Char);</span>
<span class="line-added"> 91             ARRAY_INT_BASE_OFFSET = arrayBaseOffset(JavaKind.Int);</span>
<span class="line-added"> 92             ARRAY_LONG_BASE_OFFSET = arrayBaseOffset(JavaKind.Long);</span>
<span class="line-added"> 93             ARRAY_FLOAT_BASE_OFFSET = arrayBaseOffset(JavaKind.Float);</span>
<span class="line-added"> 94             ARRAY_DOUBLE_BASE_OFFSET = arrayBaseOffset(JavaKind.Double);</span>
<span class="line-added"> 95             ARRAY_OBJECT_BASE_OFFSET = arrayBaseOffset(JavaKind.Object);</span>
<span class="line-added"> 96             ARRAY_BOOLEAN_INDEX_SCALE = arrayIndexScale(JavaKind.Boolean);</span>
<span class="line-added"> 97             ARRAY_BYTE_INDEX_SCALE = arrayIndexScale(JavaKind.Byte);</span>
<span class="line-added"> 98             ARRAY_SHORT_INDEX_SCALE = arrayIndexScale(JavaKind.Short);</span>
<span class="line-added"> 99             ARRAY_CHAR_INDEX_SCALE = arrayIndexScale(JavaKind.Char);</span>
<span class="line-added">100             ARRAY_INT_INDEX_SCALE = arrayIndexScale(JavaKind.Int);</span>
<span class="line-added">101             ARRAY_LONG_INDEX_SCALE = arrayIndexScale(JavaKind.Long);</span>
<span class="line-added">102             ARRAY_FLOAT_INDEX_SCALE = arrayIndexScale(JavaKind.Float);</span>
<span class="line-added">103             ARRAY_DOUBLE_INDEX_SCALE = arrayIndexScale(JavaKind.Double);</span>
<span class="line-added">104             ARRAY_OBJECT_INDEX_SCALE = arrayIndexScale(JavaKind.Object);</span>
105         }
106     }
107 
<a name="6" id="anc6"></a><span class="line-added">108     native int arrayBaseOffset(JavaKind kind);</span>
<span class="line-added">109 </span>
<span class="line-added">110     native int arrayIndexScale(JavaKind kind);</span>
<span class="line-added">111 </span>
112     /**
113      * Gets the {@link CompilerToVM} instance associated with the singleton
114      * {@link HotSpotJVMCIRuntime} instance.
115      */
116     public static CompilerToVM compilerToVM() {
117         return runtime().getCompilerToVM();
118     }
119 
120     /**
121      * Copies the original bytecode of {@code method} into a new byte array and returns it.
122      *
123      * @return a new byte array containing the original bytecode of {@code method}
124      */
125     native byte[] getBytecode(HotSpotResolvedJavaMethodImpl method);
126 
127     /**
128      * Gets the number of entries in {@code method}&#39;s exception handler table or 0 if it has no
129      * exception handler table.
130      */
131     native int getExceptionTableLength(HotSpotResolvedJavaMethodImpl method);
132 
133     /**
134      * Gets the address of the first entry in {@code method}&#39;s exception handler table.
135      *
136      * Each entry is a native object described by these fields:
137      *
138      * &lt;ul&gt;
139      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementSize}&lt;/li&gt;
140      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementStartPcOffset}&lt;/li&gt;
141      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementEndPcOffset}&lt;/li&gt;
142      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementHandlerPcOffset}&lt;/li&gt;
143      * &lt;li&gt;{@link HotSpotVMConfig#exceptionTableElementCatchTypeIndexOffset}
144      * &lt;/ul&gt;
145      *
146      * @return 0 if {@code method} has no exception handlers (i.e.
147      *         {@code getExceptionTableLength(method) == 0})
148      */
149     native long getExceptionTableStart(HotSpotResolvedJavaMethodImpl method);
150 
151     /**
152      * Determines whether {@code method} is currently compilable by the JVMCI compiler being used by
153      * the VM. This can return false if JVMCI compilation failed earlier for {@code method}, a
154      * breakpoint is currently set in {@code method} or {@code method} contains other bytecode
155      * features that require special handling by the VM.
156      */
157     native boolean isCompilable(HotSpotResolvedJavaMethodImpl method);
158 
159     /**
160      * Determines if {@code method} is targeted by a VM directive (e.g.,
161      * {@code -XX:CompileCommand=dontinline,&lt;pattern&gt;}) or annotation (e.g.,
162      * {@code jdk.internal.vm.annotation.DontInline}) that specifies it should not be inlined.
163      */
164     native boolean hasNeverInlineDirective(HotSpotResolvedJavaMethodImpl method);
165 
166     /**
167      * Determines if {@code method} should be inlined at any cost. This could be because:
168      * &lt;ul&gt;
169      * &lt;li&gt;a CompileOracle directive may forces inlining of this methods&lt;/li&gt;
170      * &lt;li&gt;an annotation forces inlining of this method&lt;/li&gt;
171      * &lt;/ul&gt;
172      */
173     native boolean shouldInlineMethod(HotSpotResolvedJavaMethodImpl method);
174 
175     /**
176      * Used to implement {@link ResolvedJavaType#findUniqueConcreteMethod(ResolvedJavaMethod)}.
177      *
178      * @param method the method on which to base the search
179      * @param actualHolderType the best known type of receiver
180      * @return the method result or 0 is there is no unique concrete method for {@code method}
181      */
182     native HotSpotResolvedJavaMethodImpl findUniqueConcreteMethod(HotSpotResolvedObjectTypeImpl actualHolderType, HotSpotResolvedJavaMethodImpl method);
183 
184     /**
185      * Gets the implementor for the interface class {@code type}.
186      *
187      * @return the implementor if there is a single implementor, {@code null} if there is no
188      *         implementor, or {@code type} itself if there is more than one implementor
189      * @throws IllegalArgumentException if type is not an interface type
190      */
191     native HotSpotResolvedObjectTypeImpl getImplementor(HotSpotResolvedObjectTypeImpl type);
192 
193     /**
194      * Determines if {@code method} is ignored by security stack walks.
195      */
196     native boolean methodIsIgnoredBySecurityStackWalk(HotSpotResolvedJavaMethodImpl method);
197 
198     /**
199      * Converts a name to a type.
200      *
201      * @param name a well formed Java type in {@linkplain JavaType#getName() internal} format
<a name="7" id="anc7"></a><span class="line-modified">202      * @param accessingClass the context of resolution. A value of {@code null} implies that the</span>
<span class="line-added">203      *            class should be resolved with the class loader.</span>
204      * @param resolve force resolution to a {@link ResolvedJavaType}. If true, this method will
205      *            either return a {@link ResolvedJavaType} or throw an exception
206      * @return the type for {@code name} or 0 if resolution failed and {@code resolve == false}
207      * @throws ClassNotFoundException if {@code resolve == true} and the resolution failed
208      */
<a name="8" id="anc8"></a><span class="line-modified">209     native HotSpotResolvedJavaType lookupType(String name, HotSpotResolvedObjectTypeImpl accessingClass, boolean resolve) throws ClassNotFoundException;</span>
210 
<a name="9" id="anc9"></a><span class="line-modified">211     native HotSpotResolvedJavaType lookupClass(Class&lt;?&gt; javaClass);</span>







212 
213     /**
214      * Resolves the entry at index {@code cpi} in {@code constantPool} to an object, looking in the
215      * constant pool cache first.
216      *
<a name="10" id="anc10"></a><span class="line-modified">217      * The behavior of this method is undefined if {@code cpi} does not denote one of the following</span>
<span class="line-modified">218      * entry types: {@code JVM_CONSTANT_String}, {@code JVM_CONSTANT_MethodHandle},</span>
<span class="line-added">219      * {@code JVM_CONSTANT_MethodHandleInError}, {@code JVM_CONSTANT_MethodType} and</span>
<span class="line-added">220      * {@code JVM_CONSTANT_MethodTypeInError}.</span>
221      */
<a name="11" id="anc11"></a><span class="line-modified">222     native HotSpotObjectConstantImpl resolvePossiblyCachedConstantInPool(HotSpotConstantPool constantPool, int cpi);</span>
223 
224     /**
225      * Gets the {@code JVM_CONSTANT_NameAndType} index from the entry at index {@code cpi} in
226      * {@code constantPool}.
227      *
228      * The behavior of this method is undefined if {@code cpi} does not denote an entry containing a
229      * {@code JVM_CONSTANT_NameAndType} index.
230      */
231     native int lookupNameAndTypeRefIndexInPool(HotSpotConstantPool constantPool, int cpi);
232 
233     /**
234      * Gets the name of the {@code JVM_CONSTANT_NameAndType} entry referenced by another entry
235      * denoted by {@code which} in {@code constantPool}.
236      *
237      * The behavior of this method is undefined if {@code which} does not denote a entry that
238      * references a {@code JVM_CONSTANT_NameAndType} entry.
239      */
240     native String lookupNameInPool(HotSpotConstantPool constantPool, int which);
241 
242     /**
243      * Gets the signature of the {@code JVM_CONSTANT_NameAndType} entry referenced by another entry
244      * denoted by {@code which} in {@code constantPool}.
245      *
246      * The behavior of this method is undefined if {@code which} does not denote a entry that
247      * references a {@code JVM_CONSTANT_NameAndType} entry.
248      */
249     native String lookupSignatureInPool(HotSpotConstantPool constantPool, int which);
250 
251     /**
252      * Gets the {@code JVM_CONSTANT_Class} index from the entry at index {@code cpi} in
253      * {@code constantPool}.
254      *
255      * The behavior of this method is undefined if {@code cpi} does not denote an entry containing a
256      * {@code JVM_CONSTANT_Class} index.
257      */
258     native int lookupKlassRefIndexInPool(HotSpotConstantPool constantPool, int cpi);
259 
260     /**
261      * Looks up a class denoted by the {@code JVM_CONSTANT_Class} entry at index {@code cpi} in
262      * {@code constantPool}. This method does not perform any resolution.
263      *
264      * The behavior of this method is undefined if {@code cpi} does not denote a
265      * {@code JVM_CONSTANT_Class} entry.
266      *
267      * @return the resolved class entry or a String otherwise
268      */
269     native Object lookupKlassInPool(HotSpotConstantPool constantPool, int cpi);
270 
271     /**
272      * Looks up a method denoted by the entry at index {@code cpi} in {@code constantPool}. This
273      * method does not perform any resolution.
274      *
275      * The behavior of this method is undefined if {@code cpi} does not denote an entry representing
276      * a method.
277      *
278      * @param opcode the opcode of the instruction for which the lookup is being performed or
279      *            {@code -1}. If non-negative, then resolution checks specific to the bytecode it
280      *            denotes are performed if the method is already resolved. Should any of these
281      *            checks fail, 0 is returned.
282      * @return the resolved method entry, 0 otherwise
283      */
284     native HotSpotResolvedJavaMethodImpl lookupMethodInPool(HotSpotConstantPool constantPool, int cpi, byte opcode);
285 
286     // TODO resolving JVM_CONSTANT_Dynamic
287 
288     /**
289      * Ensures that the type referenced by the specified {@code JVM_CONSTANT_InvokeDynamic} entry at
290      * index {@code cpi} in {@code constantPool} is loaded and initialized.
291      *
292      * The behavior of this method is undefined if {@code cpi} does not denote a
293      * {@code JVM_CONSTANT_InvokeDynamic} entry.
294      */
295     native void resolveInvokeDynamicInPool(HotSpotConstantPool constantPool, int cpi);
296 
297     /**
298      * If {@code cpi} denotes an entry representing a
299      * &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9&quot;&gt;signature
300      * polymorphic&lt;/a&gt; method, this method ensures that the type referenced by the entry is loaded
301      * and initialized. It {@code cpi} does not denote a signature polymorphic method, this method
302      * does nothing.
303      */
304     native void resolveInvokeHandleInPool(HotSpotConstantPool constantPool, int cpi);
305 
306     /**
307      * If {@code cpi} denotes an entry representing a resolved dynamic adapter (see
308      * {@link #resolveInvokeDynamicInPool} and {@link #resolveInvokeHandleInPool}), return the
309      * opcode of the instruction for which the resolution was performed ({@code invokedynamic} or
310      * {@code invokevirtual}), or {@code -1} otherwise.
311      */
312     native int isResolvedInvokeHandleInPool(HotSpotConstantPool constantPool, int cpi);
313 
314     /**
315      * Gets the list of type names (in the format of {@link JavaType#getName()}) denoting the
316      * classes that define signature polymorphic methods.
317      */
318     native String[] getSignaturePolymorphicHolders();
319 
320     /**
321      * Gets the resolved type denoted by the entry at index {@code cpi} in {@code constantPool}.
322      *
323      * The behavior of this method is undefined if {@code cpi} does not denote an entry representing
324      * a class.
325      *
326      * @throws LinkageError if resolution failed
327      */
328     native HotSpotResolvedObjectTypeImpl resolveTypeInPool(HotSpotConstantPool constantPool, int cpi) throws LinkageError;
329 
330     /**
331      * Looks up and attempts to resolve the {@code JVM_CONSTANT_Field} entry for at index
332      * {@code cpi} in {@code constantPool}. For some opcodes, checks are performed that require the
333      * {@code method} that contains {@code opcode} to be specified. The values returned in
334      * {@code info} are:
335      *
336      * &lt;pre&gt;
337      *     [ flags,  // fieldDescriptor::access_flags()
338      *       offset, // fieldDescriptor::offset()
339      *       index   // fieldDescriptor::index()
340      *     ]
341      * &lt;/pre&gt;
342      *
343      * The behavior of this method is undefined if {@code cpi} does not denote a
344      * {@code JVM_CONSTANT_Field} entry.
345      *
346      * @param info an array in which the details of the field are returned
347      * @return the type defining the field if resolution is successful, 0 otherwise
348      */
349     native HotSpotResolvedObjectTypeImpl resolveFieldInPool(HotSpotConstantPool constantPool, int cpi, HotSpotResolvedJavaMethodImpl method, byte opcode, int[] info);
350 
351     /**
352      * Converts {@code cpci} from an index into the cache for {@code constantPool} to an index
353      * directly into {@code constantPool}.
354      *
355      * The behavior of this method is undefined if {@code ccpi} is an invalid constant pool cache
356      * index.
357      */
358     native int constantPoolRemapInstructionOperandFromCache(HotSpotConstantPool constantPool, int cpci);
359 
360     /**
361      * Gets the appendix object (if any) associated with the entry at index {@code cpi} in
362      * {@code constantPool}.
363      */
<a name="12" id="anc12"></a><span class="line-modified">364     native HotSpotObjectConstantImpl lookupAppendixInPool(HotSpotConstantPool constantPool, int cpi);</span>
365 
366     /**
367      * Installs the result of a compilation into the code cache.
368      *
369      * @param target the target where this code should be installed
370      * @param compiledCode the result of a compilation
371      * @param code the details of the installed CodeBlob are written to this object
372      * @return the outcome of the installation which will be one of
373      *         {@link HotSpotVMConfig#codeInstallResultOk},
374      *         {@link HotSpotVMConfig#codeInstallResultCacheFull},
<a name="13" id="anc13"></a><span class="line-modified">375      *         {@link HotSpotVMConfig#codeInstallResultCodeTooLarge} or</span>
<span class="line-modified">376      *         {@link HotSpotVMConfig#codeInstallResultDependenciesFailed}.</span>

377      * @throws JVMCIError if there is something wrong with the compiled code or the associated
378      *             metadata.
379      */
<a name="14" id="anc14"></a><span class="line-modified">380     native int installCode(TargetDescription target, HotSpotCompiledCode compiledCode, InstalledCode code, long failedSpeculationsAddress, byte[] speculations);</span>
381 
382     /**
383      * Generates the VM metadata for some compiled code and copies them into {@code metaData}. This
384      * method does not install anything into the code cache.
385      *
386      * @param target the target where this code would be installed
387      * @param compiledCode the result of a compilation
388      * @param metaData the metadata is written to this object
389      * @return the outcome of the installation which will be one of
390      *         {@link HotSpotVMConfig#codeInstallResultOk},
391      *         {@link HotSpotVMConfig#codeInstallResultCacheFull},
<a name="15" id="anc15"></a><span class="line-modified">392      *         {@link HotSpotVMConfig#codeInstallResultCodeTooLarge} or</span>
<span class="line-modified">393      *         {@link HotSpotVMConfig#codeInstallResultDependenciesFailed}.</span>

394      * @throws JVMCIError if there is something wrong with the compiled code or the metadata
395      */
396     native int getMetadata(TargetDescription target, HotSpotCompiledCode compiledCode, HotSpotMetaData metaData);
397 
398     /**
399      * Resets all compilation statistics.
400      */
401     native void resetCompilationStatistics();
402 
403     /**
404      * Reads the database of VM info. The return value encodes the info in a nested object array
405      * that is described by the pseudo Java object {@code info} below:
406      *
407      * &lt;pre&gt;
408      *     info = [
409      *         VMField[] vmFields,
410      *         [String name, Long size, ...] vmTypeSizes,
411      *         [String name, Long value, ...] vmConstants,
412      *         [String name, Long value, ...] vmAddresses,
413      *         VMFlag[] vmFlags
414      *         VMIntrinsicMethod[] vmIntrinsics
415      *     ]
416      * &lt;/pre&gt;
417      *
418      * @return VM info as encoded above
419      */
420     native Object[] readConfiguration();
421 
422     /**
423      * Resolves the implementation of {@code method} for virtual dispatches on objects of dynamic
424      * type {@code exactReceiver}. This resolution process only searches &quot;up&quot; the class hierarchy of
425      * {@code exactReceiver}.
426      *
427      * @param caller the caller or context type used to perform access checks
428      * @return the link-time resolved method (might be abstract) or {@code null} if it is either a
429      *         signature polymorphic method or can not be linked.
430      */
431     native HotSpotResolvedJavaMethodImpl resolveMethod(HotSpotResolvedObjectTypeImpl exactReceiver, HotSpotResolvedJavaMethodImpl method, HotSpotResolvedObjectTypeImpl caller);
432 
433     /**
434      * Gets the static initializer of {@code type}.
435      *
436      * @return {@code null} if {@code type} has no static initializer
437      */
438     native HotSpotResolvedJavaMethodImpl getClassInitializer(HotSpotResolvedObjectTypeImpl type);
439 
440     /**
441      * Determines if {@code type} or any of its currently loaded subclasses overrides
442      * {@code Object.finalize()}.
443      */
444     native boolean hasFinalizableSubclass(HotSpotResolvedObjectTypeImpl type);
445 
446     /**
447      * Gets the method corresponding to {@code executable}.
448      */
449     native HotSpotResolvedJavaMethodImpl asResolvedJavaMethod(Executable executable);
450 
451     /**
452      * Gets the maximum absolute offset of a PC relative call to {@code address} from any position
453      * in the code cache.
454      *
455      * @param address an address that may be called from any code in the code cache
456      * @return -1 if {@code address == 0}
457      */
458     native long getMaxCallTargetOffset(long address);
459 
460     /**
461      * Gets a textual disassembly of {@code codeBlob}.
462      *
463      * @return a non-zero length string containing a disassembly of {@code codeBlob} or null if
464      *         {@code codeBlob} could not be disassembled for some reason
465      */
466     // The HotSpot disassembler seems not to be thread safe so it&#39;s better to synchronize its usage
467     synchronized native String disassembleCodeBlob(InstalledCode installedCode);
468 
469     /**
470      * Gets a stack trace element for {@code method} at bytecode index {@code bci}.
471      */
472     native StackTraceElement getStackTraceElement(HotSpotResolvedJavaMethodImpl method, int bci);
473 
474     /**
475      * Executes some {@code installedCode} with arguments {@code args}.
476      *
<a name="16" id="anc16"></a><span class="line-modified">477      * @return the result of executing {@code nmethodMirror}</span>
<span class="line-modified">478      * @throws InvalidInstalledCodeException if {@code nmethodMirror} has been invalidated</span>
479      */
<a name="17" id="anc17"></a><span class="line-modified">480     native Object executeHotSpotNmethod(Object[] args, HotSpotNmethod nmethodMirror) throws InvalidInstalledCodeException;</span>
481 
482     /**
483      * Gets the line number table for {@code method}. The line number table is encoded as (bci,
484      * source line number) pairs.
485      *
486      * @return the line number table for {@code method} or null if it doesn&#39;t have one
487      */
488     native long[] getLineNumberTable(HotSpotResolvedJavaMethodImpl method);
489 
490     /**
491      * Gets the number of entries in the local variable table for {@code method}.
492      *
493      * @return the number of entries in the local variable table for {@code method}
494      */
495     native int getLocalVariableTableLength(HotSpotResolvedJavaMethodImpl method);
496 
497     /**
498      * Gets the address of the first entry in the local variable table for {@code method}.
499      *
500      * Each entry is a native object described by these fields:
501      *
502      * &lt;ul&gt;
503      * &lt;li&gt;{@link HotSpotVMConfig#localVariableTableElementSize}&lt;/li&gt;
504      * &lt;li&gt;{@link HotSpotVMConfig#localVariableTableElementLengthOffset}&lt;/li&gt;
505      * &lt;li&gt;{@link HotSpotVMConfig#localVariableTableElementNameCpIndexOffset}&lt;/li&gt;
506      * &lt;li&gt;{@link HotSpotVMConfig#localVariableTableElementDescriptorCpIndexOffset}&lt;/li&gt;
507      * &lt;li&gt;{@link HotSpotVMConfig#localVariableTableElementSlotOffset}
508      * &lt;li&gt;{@link HotSpotVMConfig#localVariableTableElementStartBciOffset}
509      * &lt;/ul&gt;
510      *
511      * @return 0 if {@code method} does not have a local variable table
512      */
513     native long getLocalVariableTableStart(HotSpotResolvedJavaMethodImpl method);
514 
<a name="18" id="anc18"></a><span class="line-added">515     /**</span>
<span class="line-added">516      * Reads an object pointer within a VM data structure. That is, any {@link VMField} whose</span>
<span class="line-added">517      * {@link VMField#type type} is {@code &quot;oop&quot;} (e.g., {@code Klass::_java_mirror},</span>
<span class="line-added">518      * {@code JavaThread::_threadObj}).</span>
<span class="line-added">519      *</span>
<span class="line-added">520      * Note that {@code Unsafe.getObject(Object, long)} cannot be used for this since it does a</span>
<span class="line-added">521      * {@code narrowOop} read if the VM is using compressed oops whereas oops within VM data</span>
<span class="line-added">522      * structures are (currently) always uncompressed.</span>
<span class="line-added">523      *</span>
<span class="line-added">524      * @param address address of an oop field within a VM data structure</span>
<span class="line-added">525      */</span>
<span class="line-added">526     native HotSpotObjectConstantImpl readUncompressedOop(long address);</span>
<span class="line-added">527 </span>
528     /**
529      * Sets flags on {@code method} indicating that it should never be inlined or compiled by the
530      * VM.
531      */
532     native void setNotInlinableOrCompilable(HotSpotResolvedJavaMethodImpl method);
533 
534     /**
535      * Invalidates the profiling information for {@code method} and (re)initializes it such that
536      * profiling restarts upon its next invocation.
537      */
538     native void reprofile(HotSpotResolvedJavaMethodImpl method);
539 
540     /**
<a name="19" id="anc19"></a><span class="line-modified">541      * Invalidates {@code nmethodMirror} such that {@link InvalidInstalledCodeException} will be</span>
<span class="line-modified">542      * raised the next time {@code nmethodMirror} is {@linkplain #executeHotSpotNmethod executed}.</span>
<span class="line-added">543      * The {@code nmethod} associated with {@code nmethodMirror} is also made non-entrant and any</span>
<span class="line-added">544      * current activations of the {@code nmethod} are deoptimized.</span>
545      */
<a name="20" id="anc20"></a><span class="line-modified">546     native void invalidateHotSpotNmethod(HotSpotNmethod nmethodMirror);</span>
547 
548     /**
549      * Collects the current values of all JVMCI benchmark counters, summed up over all threads.
550      */
551     native long[] collectCounters();
552 
<a name="21" id="anc21"></a><span class="line-added">553     /**</span>
<span class="line-added">554      * Get the current number of counters allocated for use by JVMCI. Should be the same value as</span>
<span class="line-added">555      * the flag {@code JVMCICounterSize}.</span>
<span class="line-added">556      */</span>
<span class="line-added">557     native int getCountersSize();</span>
<span class="line-added">558 </span>
<span class="line-added">559     /**</span>
<span class="line-added">560      * Change the size of the counters allocated for JVMCI. This requires a safepoint to</span>
<span class="line-added">561      * safely reallocate the storage but it&#39;s advisable to increase the size in reasonable chunks.</span>
<span class="line-added">562      */</span>
<span class="line-added">563     native void setCountersSize(int newSize);</span>
<span class="line-added">564 </span>
565     /**
566      * Determines if {@code metaspaceMethodData} is mature.
567      */
568     native boolean isMature(long metaspaceMethodData);
569 
570     /**
571      * Generate a unique id to identify the result of the compile.
572      */
573     native int allocateCompileId(HotSpotResolvedJavaMethodImpl method, int entryBCI);
574 
575     /**
576      * Determines if {@code method} has OSR compiled code identified by {@code entryBCI} for
577      * compilation level {@code level}.
578      */
579     native boolean hasCompiledCodeForOSR(HotSpotResolvedJavaMethodImpl method, int entryBCI, int level);
580 
581     /**
582      * Gets the value of {@code metaspaceSymbol} as a String.
583      */
584     native String getSymbol(long metaspaceSymbol);
585 
586     /**
587      * @see jdk.vm.ci.code.stack.StackIntrospection#iterateFrames
588      */
589     native &lt;T&gt; T iterateFrames(ResolvedJavaMethod[] initialMethods, ResolvedJavaMethod[] matchingMethods, int initialSkip, InspectedFrameVisitor&lt;T&gt; visitor);
590 
591     /**
592      * Materializes all virtual objects within {@code stackFrame} and updates its locals.
593      *
594      * @param invalidate if {@code true}, the compiled method for the stack frame will be
595      *            invalidated
596      */
597     native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
598 
599     /**
600      * Gets the v-table index for interface method {@code method} in the receiver {@code type} or
601      * {@link HotSpotVMConfig#invalidVtableIndex} if {@code method} is not in {@code type}&#39;s
602      * v-table.
603      *
604      * @throws InternalError if {@code type} is an interface or {@code method} is not held by an
605      *             interface or class represented by {@code type} is not initialized
606      */
607     native int getVtableIndexForInterfaceMethod(HotSpotResolvedObjectTypeImpl type, HotSpotResolvedJavaMethodImpl method);
608 
609     /**
610      * Determines if debug info should also be emitted at non-safepoint locations.
611      */
612     native boolean shouldDebugNonSafepoints();
613 
614     /**
615      * Writes {@code length} bytes from {@code bytes} starting at offset {@code offset} to HotSpot&#39;s
616      * log stream.
617      *
<a name="22" id="anc22"></a><span class="line-added">618      * @param flush specifies if the log stream should be flushed after writing</span>
<span class="line-added">619      * @param canThrow specifies if an error in the {@code bytes}, {@code offset} or {@code length}</span>
<span class="line-added">620      *            arguments should result in an exception or a negative return value</span>
<span class="line-added">621      * @return 0 on success, -1 if {@code bytes == null &amp;&amp; !canThrow}, -2 if {@code !canThrow} and</span>
<span class="line-added">622      *         copying would cause access of data outside array bounds</span>
623      * @throws NullPointerException if {@code bytes == null}
624      * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
625      */
<a name="23" id="anc23"></a><span class="line-modified">626     native int writeDebugOutput(byte[] bytes, int offset, int length, boolean flush, boolean canThrow);</span>
627 
628     /**
629      * Flush HotSpot&#39;s log stream.
630      */
631     native void flushDebugOutput();
632 
633     /**
634      * Read a HotSpot Method* value from the memory location described by {@code base} plus
635      * {@code displacement} and return the {@link HotSpotResolvedJavaMethodImpl} wrapping it. This
636      * method does no checking that the memory location actually contains a valid pointer and may
637      * crash the VM if an invalid location is provided. If the {@code base} is null then
638      * {@code displacement} is used by itself. If {@code base} is a
639      * {@link HotSpotResolvedJavaMethodImpl}, {@link HotSpotConstantPool} or
640      * {@link HotSpotResolvedObjectTypeImpl} then the metaspace pointer is fetched from that object
641      * and added to {@code displacement}. Any other non-null object type causes an
642      * {@link IllegalArgumentException} to be thrown.
643      *
644      * @param base an object to read from or null
645      * @param displacement
646      * @return null or the resolved method for this location
647      */
<a name="24" id="anc24"></a><span class="line-modified">648     native HotSpotResolvedJavaMethodImpl getResolvedJavaMethod(HotSpotObjectConstantImpl base, long displacement);</span>
649 
650     /**
651      * Gets the {@code ConstantPool*} associated with {@code object} and returns a
652      * {@link HotSpotConstantPool} wrapping it.
653      *
654      * @param object a {@link HotSpotResolvedJavaMethodImpl} or
655      *            {@link HotSpotResolvedObjectTypeImpl} object
656      * @return a {@link HotSpotConstantPool} wrapping the {@code ConstantPool*} associated with
657      *         {@code object}
658      * @throws NullPointerException if {@code object == null}
659      * @throws IllegalArgumentException if {@code object} is neither a
660      *             {@link HotSpotResolvedJavaMethodImpl} nor a {@link HotSpotResolvedObjectTypeImpl}
661      */
<a name="25" id="anc25"></a><span class="line-modified">662     native HotSpotConstantPool getConstantPool(MetaspaceObject object);</span>
663 
664     /**
665      * Read a HotSpot Klass* value from the memory location described by {@code base} plus
666      * {@code displacement} and return the {@link HotSpotResolvedObjectTypeImpl} wrapping it. This
667      * method does no checking that the memory location actually contains a valid pointer and may
668      * crash the VM if an invalid location is provided. If the {@code base} is null then
669      * {@code displacement} is used by itself. If {@code base} is a
670      * {@link HotSpotResolvedJavaMethodImpl}, {@link HotSpotConstantPool} or
671      * {@link HotSpotResolvedObjectTypeImpl} then the metaspace pointer is fetched from that object
672      * and added to {@code displacement}. Any other non-null object type causes an
673      * {@link IllegalArgumentException} to be thrown.
674      *
675      * @param base an object to read from or null
676      * @param displacement
677      * @param compressed true if the location contains a compressed Klass*
678      * @return null or the resolved method for this location
679      */
<a name="26" id="anc26"></a><span class="line-modified">680     private native HotSpotResolvedObjectTypeImpl getResolvedJavaType0(Object base, long displacement, boolean compressed);</span>
<span class="line-added">681 </span>
<span class="line-added">682     HotSpotResolvedObjectTypeImpl getResolvedJavaType(MetaspaceObject base, long displacement, boolean compressed) {</span>
<span class="line-added">683         return getResolvedJavaType0(base, displacement, compressed);</span>
<span class="line-added">684     }</span>
<span class="line-added">685 </span>
<span class="line-added">686     HotSpotResolvedObjectTypeImpl getResolvedJavaType(HotSpotObjectConstantImpl base, long displacement, boolean compressed) {</span>
<span class="line-added">687         return getResolvedJavaType0(base, displacement, compressed);</span>
<span class="line-added">688     }</span>
<span class="line-added">689 </span>
<span class="line-added">690     HotSpotResolvedObjectTypeImpl getResolvedJavaType(long displacement, boolean compressed) {</span>
<span class="line-added">691         return getResolvedJavaType0(null, displacement, compressed);</span>
<span class="line-added">692     }</span>
693 
694     /**
695      * Return the size of the HotSpot ProfileData* pointed at by {@code position}. If
696      * {@code position} is outside the space of the MethodData then an
697      * {@link IllegalArgumentException} is thrown. A {@code position} inside the MethodData but that
698      * isn&#39;t pointing at a valid ProfileData will crash the VM.
699      *
700      * @param metaspaceMethodData
701      * @param position
702      * @return the size of the ProfileData item pointed at by {@code position}
703      * @throws IllegalArgumentException if an out of range position is given
704      */
705     native int methodDataProfileDataSize(long metaspaceMethodData, int position);
706 
707     /**
708      * Gets the fingerprint for a given Klass*.
709      *
710      * @param metaspaceKlass
711      * @return the value of the fingerprint (zero for arrays and synthetic classes).
712      */
713     native long getFingerprint(long metaspaceKlass);
714 
715     /**
716      * Return the amount of native stack required for the interpreter frames represented by
717      * {@code frame}. This is used when emitting the stack banging code to ensure that there is
718      * enough space for the frames during deoptimization.
719      *
720      * @param frame
721      * @return the number of bytes required for deoptimization of this frame state
722      */
723     native int interpreterFrameSize(BytecodeFrame frame);
724 
725     /**
726      * Invokes non-public method {@code java.lang.invoke.LambdaForm.compileToBytecode()} on
727      * {@code lambdaForm} (which must be a {@code java.lang.invoke.LambdaForm} instance).
728      */
<a name="27" id="anc27"></a><span class="line-modified">729     native void compileToBytecode(HotSpotObjectConstantImpl lambdaForm);</span>
730 
731     /**
732      * Gets the value of the VM flag named {@code name}.
733      *
734      * @param name name of a VM option
735      * @return {@code this} if the named VM option doesn&#39;t exist, a {@link String} or {@code null}
736      *         if its type is {@code ccstr} or {@code ccstrlist}, a {@link Double} if its type is
737      *         {@code double}, a {@link Boolean} if its type is {@code bool} otherwise a
738      *         {@link Long}
739      */
740     native Object getFlagValue(String name);
741 
742     /**
743      * Gets the host class for {@code type}.
744      */
745     native HotSpotResolvedObjectTypeImpl getHostClass(HotSpotResolvedObjectTypeImpl type);
746 
<a name="28" id="anc28"></a><span class="line-added">747     /**</span>
<span class="line-added">748      * Gets the object at the address {@code oopAddress}.</span>
<span class="line-added">749      *</span>
<span class="line-added">750      * @param oopAddress a valid {@code oopDesc**} value</span>
<span class="line-added">751      */</span>
<span class="line-added">752     native Object getObjectAtAddress(long oopAddress);</span>
<span class="line-added">753 </span>
<span class="line-added">754     /**</span>
<span class="line-added">755      * @see ResolvedJavaType#getInterfaces()</span>
<span class="line-added">756      */</span>
<span class="line-added">757     native HotSpotResolvedObjectTypeImpl[] getInterfaces(HotSpotResolvedObjectTypeImpl type);</span>
<span class="line-added">758 </span>
<span class="line-added">759     /**</span>
<span class="line-added">760      * @see ResolvedJavaType#getComponentType()</span>
<span class="line-added">761      */</span>
<span class="line-added">762     native HotSpotResolvedJavaType getComponentType(HotSpotResolvedObjectTypeImpl type);</span>
<span class="line-added">763 </span>
<span class="line-added">764     /**</span>
<span class="line-added">765      * Get the array class for {@code type}. This can&#39;t be done symbolically since anonymous types</span>
<span class="line-added">766      * can&#39;t be looked up by name.</span>
<span class="line-added">767      */</span>
<span class="line-added">768     native HotSpotResolvedObjectTypeImpl getArrayType(HotSpotResolvedJavaType type);</span>
<span class="line-added">769 </span>
<span class="line-added">770     /**</span>
<span class="line-added">771      * Forces initialization of {@code type}.</span>
<span class="line-added">772      */</span>
<span class="line-added">773     native void ensureInitialized(HotSpotResolvedObjectTypeImpl type);</span>
<span class="line-added">774 </span>
<span class="line-added">775     /**</span>
<span class="line-added">776      * Checks if {@code object} is a String and is an interned string value.</span>
<span class="line-added">777      */</span>
<span class="line-added">778     native boolean isInternedString(HotSpotObjectConstantImpl object);</span>
<span class="line-added">779 </span>
<span class="line-added">780     /**</span>
<span class="line-added">781      * Gets the {@linkplain System#identityHashCode(Object) identity} has code for the object</span>
<span class="line-added">782      * represented by this constant.</span>
<span class="line-added">783      */</span>
<span class="line-added">784     native int getIdentityHashCode(HotSpotObjectConstantImpl object);</span>
<span class="line-added">785 </span>
<span class="line-added">786     /**</span>
<span class="line-added">787      * Converts a constant object representing a boxed primitive into a boxed primitive.</span>
<span class="line-added">788      */</span>
<span class="line-added">789     native Object unboxPrimitive(HotSpotObjectConstantImpl object);</span>
<span class="line-added">790 </span>
<span class="line-added">791     /**</span>
<span class="line-added">792      * Converts a boxed primitive into a JavaConstant representing the same value.</span>
<span class="line-added">793      */</span>
<span class="line-added">794     native HotSpotObjectConstantImpl boxPrimitive(Object source);</span>
<span class="line-added">795 </span>
<span class="line-added">796     /**</span>
<span class="line-added">797      * Gets the {@link ResolvedJavaMethod}s for all the constructors of the type {@code holder}.</span>
<span class="line-added">798      */</span>
<span class="line-added">799     native ResolvedJavaMethod[] getDeclaredConstructors(HotSpotResolvedObjectTypeImpl holder);</span>
<span class="line-added">800 </span>
<span class="line-added">801     /**</span>
<span class="line-added">802      * Gets the {@link ResolvedJavaMethod}s for all the non-constructor methods of the type</span>
<span class="line-added">803      * {@code holder}.</span>
<span class="line-added">804      */</span>
<span class="line-added">805     native ResolvedJavaMethod[] getDeclaredMethods(HotSpotResolvedObjectTypeImpl holder);</span>
<span class="line-added">806 </span>
<span class="line-added">807     /**</span>
<span class="line-added">808      * Reads the current value of a static field.</span>
<span class="line-added">809      */</span>
<span class="line-added">810     native JavaConstant readFieldValue(HotSpotResolvedObjectTypeImpl resolvedObjectType, HotSpotResolvedJavaField field, boolean isVolatile);</span>
<span class="line-added">811 </span>
<span class="line-added">812     /**</span>
<span class="line-added">813      * Reads the current value of an instance field.</span>
<span class="line-added">814      */</span>
<span class="line-added">815     native JavaConstant readFieldValue(HotSpotObjectConstantImpl object, HotSpotResolvedJavaField field, boolean isVolatile);</span>
<span class="line-added">816 </span>
<span class="line-added">817     /**</span>
<span class="line-added">818      * @see ResolvedJavaType#isInstance(JavaConstant)</span>
<span class="line-added">819      */</span>
<span class="line-added">820     native boolean isInstance(HotSpotResolvedObjectTypeImpl holder, HotSpotObjectConstantImpl object);</span>
<span class="line-added">821 </span>
<span class="line-added">822     /**</span>
<span class="line-added">823      * @see ResolvedJavaType#isAssignableFrom(ResolvedJavaType)</span>
<span class="line-added">824      */</span>
<span class="line-added">825     native boolean isAssignableFrom(HotSpotResolvedObjectTypeImpl holder, HotSpotResolvedObjectTypeImpl otherType);</span>
<span class="line-added">826 </span>
<span class="line-added">827     /**</span>
<span class="line-added">828      * @see ConstantReflectionProvider#asJavaType(Constant)</span>
<span class="line-added">829      */</span>
<span class="line-added">830     native HotSpotResolvedJavaType asJavaType(HotSpotObjectConstantImpl object);</span>
<span class="line-added">831 </span>
<span class="line-added">832     /**</span>
<span class="line-added">833      * Converts a String constant into a String.</span>
<span class="line-added">834      */</span>
<span class="line-added">835     native String asString(HotSpotObjectConstantImpl object);</span>
<span class="line-added">836 </span>
<span class="line-added">837     /**</span>
<span class="line-added">838      * Compares the contents of {@code xHandle} and {@code yHandle} for pointer equality.</span>
<span class="line-added">839      */</span>
<span class="line-added">840     native boolean equals(HotSpotObjectConstantImpl x, long xHandle, HotSpotObjectConstantImpl y, long yHandle);</span>
<span class="line-added">841 </span>
<span class="line-added">842     /**</span>
<span class="line-added">843      * Gets a {@link JavaConstant} wrapping the {@link java.lang.Class} mirror for {@code type}.</span>
<span class="line-added">844      */</span>
<span class="line-added">845     native HotSpotObjectConstantImpl getJavaMirror(HotSpotResolvedJavaType type);</span>
<span class="line-added">846 </span>
<span class="line-added">847     /**</span>
<span class="line-added">848      * Returns the length of the array if {@code object} represents an array or -1 otherwise.</span>
<span class="line-added">849      */</span>
<span class="line-added">850     native int getArrayLength(HotSpotObjectConstantImpl object);</span>
<span class="line-added">851 </span>
<span class="line-added">852     /**</span>
<span class="line-added">853      * Reads the element at {@code index} if {@code object} is an array. Elements of an object array</span>
<span class="line-added">854      * are returned as {@link JavaConstant}s and primitives are returned as boxed values. The value</span>
<span class="line-added">855      * {@code null} is returned if the {@code index} is out of range or object is not an array.</span>
<span class="line-added">856      */</span>
<span class="line-added">857     native Object readArrayElement(HotSpotObjectConstantImpl object, int index);</span>
<span class="line-added">858 </span>
<span class="line-added">859     /**</span>
<span class="line-added">860      * Reads a byte sized value from {@code displacement} in {@code object}.</span>
<span class="line-added">861      */</span>
<span class="line-added">862     native byte getByte(HotSpotObjectConstantImpl object, long displacement);</span>
<span class="line-added">863 </span>
<span class="line-added">864     /**</span>
<span class="line-added">865      * Reads a short sized value from {@code displacement} in {@code object}.</span>
<span class="line-added">866      */</span>
<span class="line-added">867     native short getShort(HotSpotObjectConstantImpl object, long displacement);</span>
<span class="line-added">868 </span>
<span class="line-added">869     /**</span>
<span class="line-added">870      * Reads an int sized value from {@code displacement} in {@code object}.</span>
<span class="line-added">871      */</span>
<span class="line-added">872     native int getInt(HotSpotObjectConstantImpl object, long displacement);</span>
<span class="line-added">873 </span>
<span class="line-added">874     /**</span>
<span class="line-added">875      * Reads a long sized value from {@code displacement} in {@code object}.</span>
<span class="line-added">876      */</span>
<span class="line-added">877     native long getLong(HotSpotObjectConstantImpl object, long displacement);</span>
<span class="line-added">878 </span>
<span class="line-added">879     /**</span>
<span class="line-added">880      * Reads a Java object from {@code displacement} in {@code object}.</span>
<span class="line-added">881      */</span>
<span class="line-added">882     native HotSpotObjectConstantImpl getObject(HotSpotObjectConstantImpl object, long displacement);</span>
<span class="line-added">883 </span>
<span class="line-added">884     /**</span>
<span class="line-added">885      * @see HotSpotJVMCIRuntime#registerNativeMethods</span>
<span class="line-added">886      */</span>
<span class="line-added">887     native long[] registerNativeMethods(Class&lt;?&gt; clazz);</span>
<span class="line-added">888 </span>
<span class="line-added">889     /**</span>
<span class="line-added">890      * @see HotSpotJVMCIRuntime#translate(Object)</span>
<span class="line-added">891      */</span>
<span class="line-added">892     native long translate(Object obj);</span>
<span class="line-added">893 </span>
<span class="line-added">894     /**</span>
<span class="line-added">895      * @see HotSpotJVMCIRuntime#unhand(Class, long)</span>
<span class="line-added">896      */</span>
<span class="line-added">897     native Object unhand(long handle);</span>
<span class="line-added">898 </span>
<span class="line-added">899     /**</span>
<span class="line-added">900      * Updates {@code address} and {@code entryPoint} fields of {@code nmethodMirror} based on the</span>
<span class="line-added">901      * current state of the {@code nmethod} identified by {@code address} and</span>
<span class="line-added">902      * {@code nmethodMirror.compileId} in the code cache.</span>
<span class="line-added">903      */</span>
<span class="line-added">904     native void updateHotSpotNmethod(HotSpotNmethod nmethodMirror);</span>
<span class="line-added">905 </span>
<span class="line-added">906     /**</span>
<span class="line-added">907      * @see InstalledCode#getCode()</span>
<span class="line-added">908      */</span>
<span class="line-added">909     native byte[] getCode(HotSpotInstalledCode code);</span>
<span class="line-added">910 </span>
911     /**
912      * Gets a {@link Executable} corresponding to {@code method}.
913      */
914     native Executable asReflectionExecutable(HotSpotResolvedJavaMethodImpl method);
915 
916     /**
917      * Gets a {@link Field} denoted by {@code holder} and {@code index}.
918      *
919      * @param holder the class in which the requested field is declared
920      * @param fieldIndex the {@code fieldDescriptor::index()} denoting the field
921      */
922     native Field asReflectionField(HotSpotResolvedObjectTypeImpl holder, int fieldIndex);
<a name="29" id="anc29"></a><span class="line-added">923 </span>
<span class="line-added">924     /**</span>
<span class="line-added">925      * @see HotSpotJVMCIRuntime#getIntrinsificationTrustPredicate(Class...)</span>
<span class="line-added">926      */</span>
<span class="line-added">927     native boolean isTrustedForIntrinsics(HotSpotResolvedObjectTypeImpl type);</span>
<span class="line-added">928 </span>
<span class="line-added">929     /**</span>
<span class="line-added">930      * Releases the resources backing the global JNI {@code handle}. This is equivalent to the</span>
<span class="line-added">931      * {@code DeleteGlobalRef} JNI function.</span>
<span class="line-added">932      */</span>
<span class="line-added">933     native void deleteGlobalHandle(long handle);</span>
<span class="line-added">934 </span>
<span class="line-added">935     /**</span>
<span class="line-added">936      * Gets the failed speculations pointed to by {@code *failedSpeculationsAddress}.</span>
<span class="line-added">937      *</span>
<span class="line-added">938      * @param currentFailures the known failures at {@code failedSpeculationsAddress}</span>
<span class="line-added">939      * @return the list of failed speculations with each entry being a single speculation in the</span>
<span class="line-added">940      *         format emitted by {@link HotSpotSpeculationEncoding#toByteArray()}</span>
<span class="line-added">941      */</span>
<span class="line-added">942     native byte[][] getFailedSpeculations(long failedSpeculationsAddress, byte[][] currentFailures);</span>
<span class="line-added">943 </span>
<span class="line-added">944     /**</span>
<span class="line-added">945      * Gets the address of the {@code MethodData::_failed_speculations} field in the</span>
<span class="line-added">946      * {@code MethodData} associated with {@code method}. This will create and install the</span>
<span class="line-added">947      * {@code MethodData} if it didn&#39;t already exist.</span>
<span class="line-added">948      */</span>
<span class="line-added">949     native long getFailedSpeculationsAddress(HotSpotResolvedJavaMethodImpl method);</span>
<span class="line-added">950 </span>
<span class="line-added">951     /**</span>
<span class="line-added">952      * Frees the failed speculations pointed to by {@code *failedSpeculationsAddress}.</span>
<span class="line-added">953      */</span>
<span class="line-added">954     native void releaseFailedSpeculations(long failedSpeculationsAddress);</span>
<span class="line-added">955 </span>
<span class="line-added">956     /**</span>
<span class="line-added">957      * Adds a speculation to the failed speculations pointed to by</span>
<span class="line-added">958      * {@code *failedSpeculationsAddress}.</span>
<span class="line-added">959      *</span>
<span class="line-added">960      * @return {@code false} if the speculation could not be appended to the list</span>
<span class="line-added">961      */</span>
<span class="line-added">962     native boolean addFailedSpeculation(long failedSpeculationsAddress, byte[] speculation);</span>
<span class="line-added">963 </span>
<span class="line-added">964     /**</span>
<span class="line-added">965      * @see HotSpotJVMCIRuntime#isCurrentThreadAttached()</span>
<span class="line-added">966      */</span>
<span class="line-added">967     native boolean isCurrentThreadAttached();</span>
<span class="line-added">968 </span>
<span class="line-added">969     /**</span>
<span class="line-added">970      * @see HotSpotJVMCIRuntime#getCurrentJavaThread()</span>
<span class="line-added">971      */</span>
<span class="line-added">972     native long getCurrentJavaThread();</span>
<span class="line-added">973 </span>
<span class="line-added">974     /**</span>
<span class="line-added">975      * @see HotSpotJVMCIRuntime#attachCurrentThread</span>
<span class="line-added">976      */</span>
<span class="line-added">977     native boolean attachCurrentThread(boolean asDaemon);</span>
<span class="line-added">978 </span>
<span class="line-added">979     /**</span>
<span class="line-added">980      * @see HotSpotJVMCIRuntime#detachCurrentThread()</span>
<span class="line-added">981      */</span>
<span class="line-added">982     native void detachCurrentThread();</span>
<span class="line-added">983 </span>
<span class="line-added">984     /**</span>
<span class="line-added">985      * @see HotSpotJVMCIRuntime#exitHotSpot(int)</span>
<span class="line-added">986      */</span>
<span class="line-added">987     native void callSystemExit(int status);</span>
988 }
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
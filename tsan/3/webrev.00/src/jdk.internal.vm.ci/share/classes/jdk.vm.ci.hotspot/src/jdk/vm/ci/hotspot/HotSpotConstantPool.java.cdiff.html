<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotConstantPool.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotCompiledNmethod.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotConstantPoolObject.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotConstantPool.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,13 ***</span>
  import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  
<span class="line-removed">- import java.lang.invoke.MethodHandle;</span>
<span class="line-removed">- </span>
  import jdk.vm.ci.common.JVMCIError;
  import jdk.vm.ci.meta.ConstantPool;
  import jdk.vm.ci.meta.JavaConstant;
  import jdk.vm.ci.meta.JavaField;
  import jdk.vm.ci.meta.JavaMethod;
  import jdk.vm.ci.meta.JavaType;
<span class="line-new-header">--- 25,12 ---</span>
  import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  
  import jdk.vm.ci.common.JVMCIError;
<span class="line-added">+ import jdk.vm.ci.common.NativeImageReinitialize;</span>
  import jdk.vm.ci.meta.ConstantPool;
  import jdk.vm.ci.meta.JavaConstant;
  import jdk.vm.ci.meta.JavaField;
  import jdk.vm.ci.meta.JavaMethod;
  import jdk.vm.ci.meta.JavaType;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,11 ***</span>
  import jdk.vm.ci.meta.UnresolvedJavaType;
  
  /**
   * Implementation of {@link ConstantPool} for HotSpot.
   */
<span class="line-modified">! public final class HotSpotConstantPool implements ConstantPool, MetaspaceWrapperObject {</span>
  
      /**
       * Subset of JVM bytecode opcodes used by {@link HotSpotConstantPool}.
       */
      public static class Bytecodes {
<span class="line-new-header">--- 42,11 ---</span>
  import jdk.vm.ci.meta.UnresolvedJavaType;
  
  /**
   * Implementation of {@link ConstantPool} for HotSpot.
   */
<span class="line-modified">! public final class HotSpotConstantPool implements ConstantPool, MetaspaceHandleObject {</span>
  
      /**
       * Subset of JVM bytecode opcodes used by {@link HotSpotConstantPool}.
       */
      public static class Bytecodes {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,80 ***</span>
                      return false;
              }
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-removed">-      * Enum of all {@code JVM_CONSTANT} constants used in the VM. This includes the public and</span>
<span class="line-removed">-      * internal ones.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private enum JVM_CONSTANT {</span>
<span class="line-removed">-         // @formatter:off</span>
<span class="line-removed">-         Utf8(config().jvmConstantUtf8),</span>
<span class="line-removed">-         Integer(config().jvmConstantInteger),</span>
<span class="line-removed">-         Long(config().jvmConstantLong),</span>
<span class="line-removed">-         Float(config().jvmConstantFloat),</span>
<span class="line-removed">-         Double(config().jvmConstantDouble),</span>
<span class="line-removed">-         Class(config().jvmConstantClass),</span>
<span class="line-removed">-         UnresolvedClass(config().jvmConstantUnresolvedClass),</span>
<span class="line-removed">-         UnresolvedClassInError(config().jvmConstantUnresolvedClassInError),</span>
<span class="line-removed">-         String(config().jvmConstantString),</span>
<span class="line-removed">-         Fieldref(config().jvmConstantFieldref),</span>
<span class="line-removed">-         MethodRef(config().jvmConstantMethodref),</span>
<span class="line-removed">-         InterfaceMethodref(config().jvmConstantInterfaceMethodref),</span>
<span class="line-removed">-         NameAndType(config().jvmConstantNameAndType),</span>
<span class="line-removed">-         MethodHandle(config().jvmConstantMethodHandle),</span>
<span class="line-removed">-         MethodHandleInError(config().jvmConstantMethodHandleInError),</span>
<span class="line-removed">-         MethodType(config().jvmConstantMethodType),</span>
<span class="line-removed">-         MethodTypeInError(config().jvmConstantMethodTypeInError),</span>
<span class="line-removed">-         InvokeDynamic(config().jvmConstantInvokeDynamic);</span>
<span class="line-removed">-         // @formatter:on</span>
<span class="line-removed">- </span>
          private final int tag;
  
<span class="line-modified">!         private static final int ExternalMax = config().jvmConstantExternalMax;</span>
<span class="line-removed">-         private static final int InternalMin = config().jvmConstantInternalMin;</span>
<span class="line-removed">-         private static final int InternalMax = config().jvmConstantInternalMax;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         JVM_CONSTANT(int tag) {</span>
              this.tag = tag;
          }
  
<span class="line-modified">!         /**</span>
<span class="line-modified">!          * Maps JVM_CONSTANT tags to {@link JVM_CONSTANT} values. Using a separate class for lazy</span>
<span class="line-modified">!          * initialization.</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         static class TagValueMap {</span>
<span class="line-removed">-             private static final JVM_CONSTANT[] table = new JVM_CONSTANT[ExternalMax + 1 + (InternalMax - InternalMin) + 1];</span>
  
<span class="line-modified">!             static {</span>
<span class="line-modified">!                 assert InternalMin &gt; ExternalMax;</span>
<span class="line-modified">!                 for (JVM_CONSTANT e : values()) {</span>
<span class="line-modified">!                     table[indexOf(e.tag)] = e;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             private static int indexOf(int tag) {</span>
<span class="line-modified">!                 if (tag &gt;= InternalMin) {</span>
<span class="line-modified">!                     return tag - InternalMin + ExternalMax + 1;</span>
<span class="line-modified">!                 } else {</span>
<span class="line-modified">!                     assert tag &lt;= ExternalMax;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 return tag;</span>
              }
  
<span class="line-modified">!             static JVM_CONSTANT get(int tag) {</span>
<span class="line-modified">!                 JVM_CONSTANT res = table[indexOf(tag)];</span>
<span class="line-modified">!                 if (res != null) {</span>
<span class="line-modified">!                     return res;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 throw new JVMCIError(&quot;Unknown JVM_CONSTANT tag %s&quot;, tag);</span>
              }
          }
  
<span class="line-modified">!         public static JVM_CONSTANT getEnum(int tag) {</span>
<span class="line-modified">!             return TagValueMap.get(tag);</span>
          }
      }
  
      private static class LookupTypeCacheElement {
          int lastCpi = Integer.MIN_VALUE;
<span class="line-new-header">--- 94,90 ---</span>
                      return false;
              }
          }
      }
  
<span class="line-modified">!     static final class JvmConstant {</span>
          private final int tag;
<span class="line-added">+         private final String name;</span>
  
<span class="line-modified">!         JvmConstant(int tag, String name) {</span>
              this.tag = tag;
<span class="line-added">+             this.name = name;</span>
          }
  
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public String toString() {</span>
<span class="line-modified">!             return name;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * {@code JVM_CONSTANT} constants used in the VM including both public and internal ones.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     static final class JvmConstants {</span>
<span class="line-modified">! </span>
<span class="line-modified">!         private final HotSpotVMConfig c = config();</span>
<span class="line-added">+         private final int externalMax = c.jvmConstantExternalMax;</span>
<span class="line-added">+         private final int internalMax = c.jvmConstantInternalMax;</span>
<span class="line-added">+         private final int internalMin = c.jvmConstantInternalMin;</span>
<span class="line-added">+         private final JvmConstant[] table = new JvmConstant[externalMax + 1 + (internalMax - internalMin) + 1];</span>
<span class="line-added">+ </span>
<span class="line-added">+         final JvmConstant jvmUtf8 = add(new JvmConstant(c.jvmConstantUtf8, &quot;Utf8&quot;));</span>
<span class="line-added">+         final JvmConstant jvmInteger = add(new JvmConstant(c.jvmConstantInteger, &quot;Integer&quot;));</span>
<span class="line-added">+         final JvmConstant jvmLong = add(new JvmConstant(c.jvmConstantLong, &quot;Long&quot;));</span>
<span class="line-added">+         final JvmConstant jvmFloat = add(new JvmConstant(c.jvmConstantFloat, &quot;Float&quot;));</span>
<span class="line-added">+         final JvmConstant jvmDouble = add(new JvmConstant(c.jvmConstantDouble, &quot;Double&quot;));</span>
<span class="line-added">+         final JvmConstant jvmClass = add(new JvmConstant(c.jvmConstantClass, &quot;Class&quot;));</span>
<span class="line-added">+         final JvmConstant jvmUnresolvedClass = add(new JvmConstant(c.jvmConstantUnresolvedClass, &quot;UnresolvedClass&quot;));</span>
<span class="line-added">+         final JvmConstant jvmUnresolvedClassInError = add(new JvmConstant(c.jvmConstantUnresolvedClassInError, &quot;UnresolvedClassInError&quot;));</span>
<span class="line-added">+         final JvmConstant jvmString = add(new JvmConstant(c.jvmConstantString, &quot;String&quot;));</span>
<span class="line-added">+         final JvmConstant jvmFieldref = add(new JvmConstant(c.jvmConstantFieldref, &quot;Fieldref&quot;));</span>
<span class="line-added">+         final JvmConstant jvmMethodref = add(new JvmConstant(c.jvmConstantMethodref, &quot;Methodref&quot;));</span>
<span class="line-added">+         final JvmConstant jvmInterfaceMethodref = add(new JvmConstant(c.jvmConstantInterfaceMethodref, &quot;InterfaceMethodref&quot;));</span>
<span class="line-added">+         final JvmConstant jvmNameAndType = add(new JvmConstant(c.jvmConstantNameAndType, &quot;NameAndType&quot;));</span>
<span class="line-added">+         final JvmConstant jvmMethodHandle = add(new JvmConstant(c.jvmConstantMethodHandle, &quot;MethodHandle&quot;));</span>
<span class="line-added">+         final JvmConstant jvmMethodHandleInError = add(new JvmConstant(c.jvmConstantMethodHandleInError, &quot;MethodHandleInError&quot;));</span>
<span class="line-added">+         final JvmConstant jvmMethodType = add(new JvmConstant(c.jvmConstantMethodType, &quot;MethodType&quot;));</span>
<span class="line-added">+         final JvmConstant jvmMethodTypeInError = add(new JvmConstant(c.jvmConstantMethodTypeInError, &quot;MethodTypeInError&quot;));</span>
<span class="line-added">+         final JvmConstant jvmInvokeDynamic = add(new JvmConstant(c.jvmConstantInvokeDynamic, &quot;InvokeDynamic&quot;));</span>
<span class="line-added">+ </span>
<span class="line-added">+         private JvmConstant add(JvmConstant constant) {</span>
<span class="line-added">+             table[indexOf(constant.tag)] = constant;</span>
<span class="line-added">+             return constant;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         private int indexOf(int tag) {</span>
<span class="line-modified">!             if (tag &gt;= internalMin) {</span>
<span class="line-modified">!                 return tag - internalMin + externalMax + 1;</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 assert tag &lt;= externalMax;</span>
              }
<span class="line-added">+             return tag;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         JvmConstant get(int tag) {</span>
<span class="line-modified">!             JvmConstant res = table[indexOf(tag)];</span>
<span class="line-modified">!             if (res != null) {</span>
<span class="line-modified">!                 return res;</span>
              }
<span class="line-added">+             throw new JVMCIError(&quot;Unknown JvmConstant tag %s&quot;, tag);</span>
          }
  
<span class="line-modified">!         @NativeImageReinitialize private static volatile JvmConstants instance;</span>
<span class="line-modified">! </span>
<span class="line-added">+         static JvmConstants instance() {</span>
<span class="line-added">+             JvmConstants result = instance;</span>
<span class="line-added">+             if (result == null) {</span>
<span class="line-added">+                 synchronized (JvmConstants.class) {</span>
<span class="line-added">+                     result = instance;</span>
<span class="line-added">+                     if (result == null) {</span>
<span class="line-added">+                         instance = result = new JvmConstants();</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return result;</span>
          }
      }
  
      private static class LookupTypeCacheElement {
          int lastCpi = Integer.MIN_VALUE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,34 ***</span>
              this.javaType = javaType;
          }
      }
  
      /**
<span class="line-modified">!      * Reference to the C++ ConstantPool object.</span>
       */
<span class="line-modified">!     private final long metaspaceConstantPool;</span>
      private volatile LookupTypeCacheElement lastLookupType;
  
      /**
       * Gets the JVMCI mirror from a HotSpot constant pool.The VM is responsible for ensuring that
       * the ConstantPool is kept alive for the duration of this call and the
<span class="line-modified">!      * {@link HotSpotJVMCIMetaAccessContext} keeps it alive after that.</span>
       *
       * Called from the VM.
       *
       * @param metaspaceConstantPool a metaspace ConstantPool object
       * @return the {@link HotSpotConstantPool} corresponding to {@code metaspaceConstantPool}
       */
      @SuppressWarnings(&quot;unused&quot;)
      private static HotSpotConstantPool fromMetaspace(long metaspaceConstantPool) {
<span class="line-modified">!         HotSpotConstantPool cp = new HotSpotConstantPool(metaspaceConstantPool);</span>
<span class="line-removed">-         runtime().metaAccessContext.add(cp);</span>
<span class="line-removed">-         return cp;</span>
      }
  
<span class="line-modified">!     private HotSpotConstantPool(long metaspaceConstantPool) {</span>
<span class="line-modified">!         this.metaspaceConstantPool = metaspaceConstantPool;</span>
      }
  
      /**
       * Gets the holder for this constant pool as {@link HotSpotResolvedObjectTypeImpl}.
       *
<span class="line-new-header">--- 189,38 ---</span>
              this.javaType = javaType;
          }
      }
  
      /**
<span class="line-modified">!      * Handle to the {@code ConstantPool} VM object. The handle is in</span>
<span class="line-added">+      * {@code JVMCI::_metadata_handles}.</span>
       */
<span class="line-modified">!     private final long metadataHandle;</span>
<span class="line-added">+ </span>
      private volatile LookupTypeCacheElement lastLookupType;
<span class="line-added">+     private final JvmConstants constants;</span>
  
      /**
       * Gets the JVMCI mirror from a HotSpot constant pool.The VM is responsible for ensuring that
       * the ConstantPool is kept alive for the duration of this call and the
<span class="line-modified">!      * {@link HotSpotJVMCIRuntime} keeps it alive after that.</span>
       *
       * Called from the VM.
       *
       * @param metaspaceConstantPool a metaspace ConstantPool object
       * @return the {@link HotSpotConstantPool} corresponding to {@code metaspaceConstantPool}
       */
      @SuppressWarnings(&quot;unused&quot;)
<span class="line-added">+     @VMEntryPoint</span>
      private static HotSpotConstantPool fromMetaspace(long metaspaceConstantPool) {
<span class="line-modified">!         return new HotSpotConstantPool(metaspaceConstantPool);</span>
      }
  
<span class="line-modified">!     private HotSpotConstantPool(long metadataHandle) {</span>
<span class="line-modified">!         this.metadataHandle = metadataHandle;</span>
<span class="line-added">+         this.constants = JvmConstants.instance();</span>
<span class="line-added">+         HandleCleaner.create(this, metadataHandle);</span>
      }
  
      /**
       * Gets the holder for this constant pool as {@link HotSpotResolvedObjectTypeImpl}.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,33 ***</span>
          assert isInvokedynamicIndex(i) : i;
          return ~i;
      }
  
      long getMetaspaceConstantPool() {
<span class="line-modified">!         return metaspaceConstantPool;</span>
      }
  
      @Override
<span class="line-modified">!     public long getMetaspacePointer() {</span>
<span class="line-modified">!         return getMetaspaceConstantPool();</span>
      }
  
      /**
       * Gets the constant pool tag at index {@code index}.
       *
       * @param index constant pool index
       * @return constant pool tag
       */
<span class="line-modified">!     private JVM_CONSTANT getTagAt(int index) {</span>
          assert checkBounds(index);
          HotSpotVMConfig config = config();
          final long metaspaceConstantPoolTags = UNSAFE.getAddress(getMetaspaceConstantPool() + config.constantPoolTagsOffset);
          final int tag = UNSAFE.getByteVolatile(null, metaspaceConstantPoolTags + config.arrayU1DataOffset + index);
          if (tag == 0) {
              return null;
          }
<span class="line-modified">!         return JVM_CONSTANT.getEnum(tag);</span>
      }
  
      /**
       * Gets the constant pool entry at index {@code index}.
       *
<span class="line-new-header">--- 282,33 ---</span>
          assert isInvokedynamicIndex(i) : i;
          return ~i;
      }
  
      long getMetaspaceConstantPool() {
<span class="line-modified">!         return getMetaspacePointer();</span>
      }
  
      @Override
<span class="line-modified">!     public long getMetadataHandle() {</span>
<span class="line-modified">!         return metadataHandle;</span>
      }
  
      /**
       * Gets the constant pool tag at index {@code index}.
       *
       * @param index constant pool index
       * @return constant pool tag
       */
<span class="line-modified">!     private JvmConstant getTagAt(int index) {</span>
          assert checkBounds(index);
          HotSpotVMConfig config = config();
          final long metaspaceConstantPoolTags = UNSAFE.getAddress(getMetaspaceConstantPool() + config.constantPoolTagsOffset);
          final int tag = UNSAFE.getByteVolatile(null, metaspaceConstantPoolTags + config.arrayU1DataOffset + index);
          if (tag == 0) {
              return null;
          }
<span class="line-modified">!         return constants.get(tag);</span>
      }
  
      /**
       * Gets the constant pool entry at index {@code index}.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 313,11 ***</span>
       *
       * @param index constant pool index
       * @return integer constant pool entry at index
       */
      private int getIntAt(int index) {
<span class="line-modified">!         assert checkTag(index, JVM_CONSTANT.Integer);</span>
          int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
          return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);
      }
  
      /**
<span class="line-new-header">--- 326,11 ---</span>
       *
       * @param index constant pool index
       * @return integer constant pool entry at index
       */
      private int getIntAt(int index) {
<span class="line-modified">!         assert checkTag(index, constants.jvmInteger);</span>
          int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
          return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 325,11 ***</span>
       *
       * @param index constant pool index
       * @return long constant pool entry
       */
      private long getLongAt(int index) {
<span class="line-modified">!         assert checkTag(index, JVM_CONSTANT.Long);</span>
          int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
          return UNSAFE.getLong(getMetaspaceConstantPool() + config().constantPoolSize + offset);
      }
  
      /**
<span class="line-new-header">--- 338,11 ---</span>
       *
       * @param index constant pool index
       * @return long constant pool entry
       */
      private long getLongAt(int index) {
<span class="line-modified">!         assert checkTag(index, constants.jvmLong);</span>
          int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
          return UNSAFE.getLong(getMetaspaceConstantPool() + config().constantPoolSize + offset);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 337,11 ***</span>
       *
       * @param index constant pool index
       * @return float constant pool entry
       */
      private float getFloatAt(int index) {
<span class="line-modified">!         assert checkTag(index, JVM_CONSTANT.Float);</span>
          int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
          return UNSAFE.getFloat(getMetaspaceConstantPool() + config().constantPoolSize + offset);
      }
  
      /**
<span class="line-new-header">--- 350,11 ---</span>
       *
       * @param index constant pool index
       * @return float constant pool entry
       */
      private float getFloatAt(int index) {
<span class="line-modified">!         assert checkTag(index, constants.jvmFloat);</span>
          int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
          return UNSAFE.getFloat(getMetaspaceConstantPool() + config().constantPoolSize + offset);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 349,11 ***</span>
       *
       * @param index constant pool index
       * @return float constant pool entry
       */
      private double getDoubleAt(int index) {
<span class="line-modified">!         assert checkTag(index, JVM_CONSTANT.Double);</span>
          int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
          return UNSAFE.getDouble(getMetaspaceConstantPool() + config().constantPoolSize + offset);
      }
  
      /**
<span class="line-new-header">--- 362,11 ---</span>
       *
       * @param index constant pool index
       * @return float constant pool entry
       */
      private double getDoubleAt(int index) {
<span class="line-modified">!         assert checkTag(index, constants.jvmDouble);</span>
          int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
          return UNSAFE.getDouble(getMetaspaceConstantPool() + config().constantPoolSize + offset);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 361,11 ***</span>
       *
       * @param index constant pool index
       * @return {@code JVM_CONSTANT_NameAndType} constant pool entry
       */
      private int getNameAndTypeAt(int index) {
<span class="line-modified">!         assert checkTag(index, JVM_CONSTANT.NameAndType);</span>
          int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
          return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);
      }
  
      /**
<span class="line-new-header">--- 374,11 ---</span>
       *
       * @param index constant pool index
       * @return {@code JVM_CONSTANT_NameAndType} constant pool entry
       */
      private int getNameAndTypeAt(int index) {
<span class="line-modified">!         assert checkTag(index, constants.jvmNameAndType);</span>
          int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
          return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 468,26 ***</span>
       *
       * @param index constant pool index
       * @param tag expected tag
       * @throws AssertionError if the check fails
       */
<span class="line-modified">!     private boolean checkTag(int index, JVM_CONSTANT tag) {</span>
<span class="line-modified">!         final JVM_CONSTANT tagAt = getTagAt(index);</span>
          assert tagAt == tag : &quot;constant pool tag at index &quot; + index + &quot; is &quot; + tagAt + &quot; but expected &quot; + tag;
          return true;
      }
  
      /**
<span class="line-modified">!      * Asserts that the constant pool tag at index {@code index} is a {@link JVM_CONSTANT#Fieldref},</span>
<span class="line-modified">!      * or a {@link JVM_CONSTANT#MethodRef}, or a {@link JVM_CONSTANT#InterfaceMethodref}.</span>
       *
       * @param index constant pool index
       * @throws AssertionError if the check fails
       */
      private boolean checkTagIsFieldOrMethod(int index) {
<span class="line-modified">!         final JVM_CONSTANT tagAt = getTagAt(index);</span>
<span class="line-modified">!         assert tagAt == JVM_CONSTANT.Fieldref || tagAt == JVM_CONSTANT.MethodRef || tagAt == JVM_CONSTANT.InterfaceMethodref : tagAt;</span>
          return true;
      }
  
      @Override
      public int length() {
<span class="line-new-header">--- 481,27 ---</span>
       *
       * @param index constant pool index
       * @param tag expected tag
       * @throws AssertionError if the check fails
       */
<span class="line-modified">!     private boolean checkTag(int index, JvmConstant tag) {</span>
<span class="line-modified">!         final JvmConstant tagAt = getTagAt(index);</span>
          assert tagAt == tag : &quot;constant pool tag at index &quot; + index + &quot; is &quot; + tagAt + &quot; but expected &quot; + tag;
          return true;
      }
  
      /**
<span class="line-modified">!      * Asserts that the constant pool tag at index {@code index} is a</span>
<span class="line-modified">!      * {@link JvmConstants#jvmFieldref}, or a {@link JvmConstants#jvmMethodref}, or a</span>
<span class="line-added">+      * {@link JvmConstants#jvmInterfaceMethodref}.</span>
       *
       * @param index constant pool index
       * @throws AssertionError if the check fails
       */
      private boolean checkTagIsFieldOrMethod(int index) {
<span class="line-modified">!         final JvmConstant tagAt = getTagAt(index);</span>
<span class="line-modified">!         assert tagAt == constants.jvmFieldref || tagAt == constants.jvmMethodref || tagAt == constants.jvmInterfaceMethodref : tagAt;</span>
          return true;
      }
  
      @Override
      public int length() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 503,47 ***</span>
      }
  
      @Override
      public Object lookupConstant(int cpi) {
          assert cpi != 0;
<span class="line-modified">!         final JVM_CONSTANT tag = getTagAt(cpi);</span>
<span class="line-modified">!         switch (tag) {</span>
<span class="line-modified">!             case Integer:</span>
                  return JavaConstant.forInt(getIntAt(cpi));
<span class="line-modified">!             case Long:</span>
                  return JavaConstant.forLong(getLongAt(cpi));
<span class="line-modified">!             case Float:</span>
                  return JavaConstant.forFloat(getFloatAt(cpi));
<span class="line-modified">!             case Double:</span>
                  return JavaConstant.forDouble(getDoubleAt(cpi));
<span class="line-modified">!             case Class:</span>
<span class="line-modified">!             case UnresolvedClass:</span>
<span class="line-modified">!             case UnresolvedClassInError:</span>
                  final int opcode = -1;  // opcode is not used
                  return lookupType(cpi, opcode);
<span class="line-modified">!             case String:</span>
                  /*
                   * Normally, we would expect a String here, but unsafe anonymous classes can have
                   * &quot;pseudo strings&quot; (arbitrary live objects) patched into a String entry. Such
                   * entries do not have a symbol in the constant pool slot.
                   */
<span class="line-modified">!                 Object string = compilerToVM().resolvePossiblyCachedConstantInPool(this, cpi);</span>
<span class="line-modified">!                 return HotSpotObjectConstantImpl.forObject(string);</span>
<span class="line-modified">!             case MethodHandle:</span>
<span class="line-modified">!             case MethodHandleInError:</span>
<span class="line-modified">!             case MethodType:</span>
<span class="line-modified">!             case MethodTypeInError:</span>
<span class="line-removed">-                 Object obj = compilerToVM().resolveConstantInPool(this, cpi);</span>
<span class="line-removed">-                 return HotSpotObjectConstantImpl.forObject(obj);</span>
              default:
                  throw new JVMCIError(&quot;Unknown constant pool tag %s&quot;, tag);
          }
      }
  
      @Override
      public String lookupUtf8(int cpi) {
<span class="line-modified">!         assert checkTag(cpi, JVM_CONSTANT.Utf8);</span>
          return compilerToVM().getSymbol(getEntryAt(cpi));
      }
  
      @Override
      public Signature lookupSignature(int cpi) {
<span class="line-new-header">--- 517,45 ---</span>
      }
  
      @Override
      public Object lookupConstant(int cpi) {
          assert cpi != 0;
<span class="line-modified">!         final JvmConstant tag = getTagAt(cpi);</span>
<span class="line-modified">!         switch (tag.name) {</span>
<span class="line-modified">!             case &quot;Integer&quot;:</span>
                  return JavaConstant.forInt(getIntAt(cpi));
<span class="line-modified">!             case &quot;Long&quot;:</span>
                  return JavaConstant.forLong(getLongAt(cpi));
<span class="line-modified">!             case &quot;Float&quot;:</span>
                  return JavaConstant.forFloat(getFloatAt(cpi));
<span class="line-modified">!             case &quot;Double&quot;:</span>
                  return JavaConstant.forDouble(getDoubleAt(cpi));
<span class="line-modified">!             case &quot;Class&quot;:</span>
<span class="line-modified">!             case &quot;UnresolvedClass&quot;:</span>
<span class="line-modified">!             case &quot;UnresolvedClassInError&quot;:</span>
                  final int opcode = -1;  // opcode is not used
                  return lookupType(cpi, opcode);
<span class="line-modified">!             case &quot;String&quot;:</span>
                  /*
                   * Normally, we would expect a String here, but unsafe anonymous classes can have
                   * &quot;pseudo strings&quot; (arbitrary live objects) patched into a String entry. Such
                   * entries do not have a symbol in the constant pool slot.
                   */
<span class="line-modified">!                 return compilerToVM().resolvePossiblyCachedConstantInPool(this, cpi);</span>
<span class="line-modified">!             case &quot;MethodHandle&quot;:</span>
<span class="line-modified">!             case &quot;MethodHandleInError&quot;:</span>
<span class="line-modified">!             case &quot;MethodType&quot;:</span>
<span class="line-modified">!             case &quot;MethodTypeInError&quot;:</span>
<span class="line-modified">!                 return compilerToVM().resolvePossiblyCachedConstantInPool(this, cpi);</span>
              default:
                  throw new JVMCIError(&quot;Unknown constant pool tag %s&quot;, tag);
          }
      }
  
      @Override
      public String lookupUtf8(int cpi) {
<span class="line-modified">!         assert checkTag(cpi, constants.jvmUtf8);</span>
          return compilerToVM().getSymbol(getEntryAt(cpi));
      }
  
      @Override
      public Signature lookupSignature(int cpi) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 552,16 ***</span>
  
      @Override
      public JavaConstant lookupAppendix(int cpi, int opcode) {
          assert Bytecodes.isInvoke(opcode);
          final int index = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<span class="line-modified">!         Object appendix = compilerToVM().lookupAppendixInPool(this, index);</span>
<span class="line-removed">-         if (appendix == null) {</span>
<span class="line-removed">-             return null;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             return HotSpotObjectConstantImpl.forObject(appendix);</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Gets a {@link JavaType} corresponding a given resolved or unresolved type.
       *
<span class="line-new-header">--- 564,11 ---</span>
  
      @Override
      public JavaConstant lookupAppendix(int cpi, int opcode) {
          assert Bytecodes.isInvoke(opcode);
          final int index = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<span class="line-modified">!         return compilerToVM().lookupAppendixInPool(this, index);</span>
      }
  
      /**
       * Gets a {@link JavaType} corresponding a given resolved or unresolved type.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,11 ***</span>
          } else {
              // Get the method&#39;s name and signature.
              String name = getNameOf(index);
              HotSpotSignature signature = new HotSpotSignature(runtime(), getSignatureOf(index));
              if (opcode == Bytecodes.INVOKEDYNAMIC) {
<span class="line-modified">!                 HotSpotResolvedObjectType holder = HotSpotResolvedObjectTypeImpl.fromObjectClass(MethodHandle.class);</span>
                  return new UnresolvedJavaMethod(name, signature, holder);
              } else {
                  final int klassIndex = getKlassRefIndexAt(index);
                  final Object type = compilerToVM().lookupKlassInPool(this, klassIndex);
                  JavaType holder = getJavaType(type);
<span class="line-new-header">--- 592,11 ---</span>
          } else {
              // Get the method&#39;s name and signature.
              String name = getNameOf(index);
              HotSpotSignature signature = new HotSpotSignature(runtime(), getSignatureOf(index));
              if (opcode == Bytecodes.INVOKEDYNAMIC) {
<span class="line-modified">!                 HotSpotResolvedObjectType holder = runtime().getMethodHandleClass();</span>
                  return new UnresolvedJavaMethod(name, signature, holder);
              } else {
                  final int klassIndex = getKlassRefIndexAt(index);
                  final Object type = compilerToVM().lookupKlassInPool(this, klassIndex);
                  JavaType holder = getJavaType(type);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,44 ***</span>
              }
              default:
                  throw JVMCIError.shouldNotReachHere(&quot;Unexpected opcode &quot; + opcode);
          }
  
<span class="line-modified">!         final JVM_CONSTANT tag = getTagAt(index);</span>
          if (tag == null) {
<span class="line-modified">!             assert getTagAt(index - 1) == JVM_CONSTANT.Double || getTagAt(index - 1) == JVM_CONSTANT.Long;</span>
              return;
          }
<span class="line-modified">!         switch (tag) {</span>
<span class="line-modified">!             case MethodRef:</span>
<span class="line-modified">!             case Fieldref:</span>
<span class="line-modified">!             case InterfaceMethodref:</span>
                  index = getUncachedKlassRefIndexAt(index);
                  // Read the tag only once because it could change between multiple reads.
<span class="line-modified">!                 final JVM_CONSTANT klassTag = getTagAt(index);</span>
<span class="line-modified">!                 assert klassTag == JVM_CONSTANT.Class || klassTag == JVM_CONSTANT.UnresolvedClass || klassTag == JVM_CONSTANT.UnresolvedClassInError : klassTag;</span>
                  // fall through
<span class="line-modified">!             case Class:</span>
<span class="line-modified">!             case UnresolvedClass:</span>
<span class="line-modified">!             case UnresolvedClassInError:</span>
                  final HotSpotResolvedObjectTypeImpl type = compilerToVM().resolveTypeInPool(this, index);
<span class="line-modified">!                 if (initialize) {</span>
<span class="line-modified">!                     Class&lt;?&gt; klass = type.mirror();</span>
<span class="line-removed">-                     if (!klass.isPrimitive() &amp;&amp; !klass.isArray()) {</span>
<span class="line-removed">-                         UNSAFE.ensureClassInitialized(klass);</span>
<span class="line-removed">-                     }</span>
                  }
<span class="line-modified">!                 if (tag == JVM_CONSTANT.MethodRef) {</span>
                      if (Bytecodes.isInvokeHandleAlias(opcode) &amp;&amp; isSignaturePolymorphicHolder(type)) {
                          final int methodRefCacheIndex = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<span class="line-modified">!                         assert checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), JVM_CONSTANT.MethodRef);</span>
                          compilerToVM().resolveInvokeHandleInPool(this, methodRefCacheIndex);
                      }
                  }
  
                  break;
<span class="line-modified">!             case InvokeDynamic:</span>
                  if (isInvokedynamicIndex(cpi)) {
                      compilerToVM().resolveInvokeDynamicInPool(this, cpi);
                  }
                  break;
              default:
<span class="line-new-header">--- 714,41 ---</span>
              }
              default:
                  throw JVMCIError.shouldNotReachHere(&quot;Unexpected opcode &quot; + opcode);
          }
  
<span class="line-modified">!         final JvmConstant tag = getTagAt(index);</span>
          if (tag == null) {
<span class="line-modified">!             assert getTagAt(index - 1) == constants.jvmDouble || getTagAt(index - 1) == constants.jvmLong;</span>
              return;
          }
<span class="line-modified">!         switch (tag.name) {</span>
<span class="line-modified">!             case &quot;Methodref&quot;:</span>
<span class="line-modified">!             case &quot;Fieldref&quot;:</span>
<span class="line-modified">!             case &quot;InterfaceMethodref&quot;:</span>
                  index = getUncachedKlassRefIndexAt(index);
                  // Read the tag only once because it could change between multiple reads.
<span class="line-modified">!                 final JvmConstant klassTag = getTagAt(index);</span>
<span class="line-modified">!                 assert klassTag == constants.jvmClass || klassTag == constants.jvmUnresolvedClass || klassTag == constants.jvmUnresolvedClassInError : klassTag;</span>
                  // fall through
<span class="line-modified">!             case &quot;Class&quot;:</span>
<span class="line-modified">!             case &quot;UnresolvedClass&quot;:</span>
<span class="line-modified">!             case &quot;UnresolvedClassInError&quot;:</span>
                  final HotSpotResolvedObjectTypeImpl type = compilerToVM().resolveTypeInPool(this, index);
<span class="line-modified">!                 if (initialize &amp;&amp; !type.isPrimitive() &amp;&amp; !type.isArray()) {</span>
<span class="line-modified">!                     type.ensureInitialized();</span>
                  }
<span class="line-modified">!                 if (tag == constants.jvmMethodref) {</span>
                      if (Bytecodes.isInvokeHandleAlias(opcode) &amp;&amp; isSignaturePolymorphicHolder(type)) {
                          final int methodRefCacheIndex = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<span class="line-modified">!                         assert checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), constants.jvmMethodref);</span>
                          compilerToVM().resolveInvokeHandleInPool(this, methodRefCacheIndex);
                      }
                  }
  
                  break;
<span class="line-modified">!             case &quot;InvokeDynamic&quot;:</span>
                  if (isInvokedynamicIndex(cpi)) {
                      compilerToVM().resolveInvokeDynamicInPool(this, cpi);
                  }
                  break;
              default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 786,11 ***</span>
       *         {@code false}
       */
      public boolean isResolvedDynamicInvoke(int cpi, int opcode) {
          if (Bytecodes.isInvokeHandleAlias(opcode)) {
              final int methodRefCacheIndex = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<span class="line-modified">!             assert checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), JVM_CONSTANT.MethodRef);</span>
              int op = compilerToVM().isResolvedInvokeHandleInPool(this, methodRefCacheIndex);
              return op == opcode;
          }
          return false;
      }
<span class="line-new-header">--- 790,11 ---</span>
       *         {@code false}
       */
      public boolean isResolvedDynamicInvoke(int cpi, int opcode) {
          if (Bytecodes.isInvokeHandleAlias(opcode)) {
              final int methodRefCacheIndex = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<span class="line-modified">!             assert checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), constants.jvmMethodref);</span>
              int op = compilerToVM().isResolvedInvokeHandleInPool(this, methodRefCacheIndex);
              return op == opcode;
          }
          return false;
      }
</pre>
<center><a href="HotSpotCompiledNmethod.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotConstantPoolObject.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
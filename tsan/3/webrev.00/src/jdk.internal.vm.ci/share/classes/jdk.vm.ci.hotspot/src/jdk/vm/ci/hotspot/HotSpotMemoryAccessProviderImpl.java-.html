<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMemoryAccessProviderImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 26 
 27 import java.lang.reflect.Array;
 28 
 29 import jdk.vm.ci.common.JVMCIError;
 30 import jdk.vm.ci.meta.Constant;
 31 import jdk.vm.ci.meta.JavaConstant;
 32 import jdk.vm.ci.meta.JavaKind;
 33 import jdk.vm.ci.meta.MemoryAccessProvider;
 34 import jdk.vm.ci.meta.MetaAccessProvider;
 35 import jdk.vm.ci.meta.PrimitiveConstant;
 36 import jdk.vm.ci.meta.ResolvedJavaField;
 37 import jdk.vm.ci.meta.ResolvedJavaType;
 38 
 39 /**
 40  * HotSpot implementation of {@link MemoryAccessProvider}.
 41  */
 42 class HotSpotMemoryAccessProviderImpl implements HotSpotMemoryAccessProvider {
 43 
 44     protected final HotSpotJVMCIRuntime runtime;
 45 
 46     HotSpotMemoryAccessProviderImpl(HotSpotJVMCIRuntime runtime) {
 47         this.runtime = runtime;
 48     }
 49 
 50     /**
 51      * Gets the object boxed by {@code base} that is about to have a value of kind {@code kind} read
 52      * from it at the offset {@code displacement}.
 53      *
 54      * @param base constant value containing the base address for a pending read
 55      * @return {@code null} if {@code base} does not box an object otherwise the object boxed in
 56      *         {@code base}
 57      */
 58     private Object asObject(Constant base, JavaKind kind, long displacement) {
 59         if (base instanceof HotSpotObjectConstantImpl) {
 60             HotSpotObjectConstantImpl constant = (HotSpotObjectConstantImpl) base;
 61             HotSpotResolvedObjectType type = constant.getType();
 62             Object object = constant.object();
 63             checkRead(kind, displacement, type, object, runtime.getHostJVMCIBackend().getMetaAccess());
 64             return object;
 65         }
 66         return null;
 67     }
 68 
 69     /**
 70      * Offset of injected {@code java.lang.Class::oop_size} field. No need to make {@code volatile}
 71      * as initialization is idempotent.
 72      */
 73     private long oopSizeOffset;
 74 
 75     private static int computeOopSizeOffset(HotSpotJVMCIRuntime runtime) {
 76         MetaAccessProvider metaAccess = runtime.getHostJVMCIBackend().getMetaAccess();
 77         ResolvedJavaType staticType = metaAccess.lookupJavaType(Class.class);
 78         for (ResolvedJavaField f : staticType.getInstanceFields(false)) {
 79             if (f.getName().equals(&quot;oop_size&quot;)) {
 80                 int offset = ((HotSpotResolvedJavaField) f).getOffset();
 81                 assert offset != 0 : &quot;not expecting offset of java.lang.Class::oop_size to be 0&quot;;
 82                 return offset;
 83             }
 84         }
 85         throw new JVMCIError(&quot;Could not find injected java.lang.Class::oop_size field&quot;);
 86     }
 87 
 88     private boolean checkRead(JavaKind kind, long displacement, HotSpotResolvedObjectType type, Object object, MetaAccessProvider metaAccess) {
 89         if (type.isArray()) {
 90             ResolvedJavaType componentType = type.getComponentType();
 91             JavaKind componentKind = componentType.getJavaKind();
 92             final int headerSize = metaAccess.getArrayBaseOffset(componentKind);
 93             int sizeOfElement = metaAccess.getArrayIndexScale(componentKind);
 94             int length = Array.getLength(object);
 95             long arrayEnd = headerSize + (sizeOfElement * length);
 96             boolean aligned = ((displacement - headerSize) % sizeOfElement) == 0;
 97             if (displacement &lt; 0 || displacement &gt; (arrayEnd - sizeOfElement) || (kind == JavaKind.Object &amp;&amp; !aligned)) {
 98                 int index = (int) ((displacement - headerSize) / sizeOfElement);
 99                 throw new IllegalArgumentException(&quot;Unsafe array access: reading element of kind &quot; + kind +
100                                 &quot; at offset &quot; + displacement + &quot; (index ~ &quot; + index + &quot;) in &quot; +
101                                 type.toJavaName() + &quot; object of length &quot; + length);
102             }
103         } else if (kind != JavaKind.Object) {
104             long size;
105             if (object instanceof Class) {
106                 if (oopSizeOffset == 0) {
107                     oopSizeOffset = computeOopSizeOffset(runtime);
108                 }
109                 int wordSize = runtime.getHostJVMCIBackend().getCodeCache().getTarget().wordSize;
110                 size = UNSAFE.getInt(object, oopSizeOffset) * wordSize;
111             } else {
112                 size = Math.abs(type.instanceSize());
113             }
114             int bytesToRead = kind.getByteCount();
115             if (displacement + bytesToRead &gt; size || displacement &lt; 0) {
116                 throw new IllegalArgumentException(&quot;Unsafe access: reading &quot; + bytesToRead + &quot; bytes at offset &quot; + displacement + &quot; in &quot; +
117                                 type.toJavaName() + &quot; object of size &quot; + size);
118             }
119         } else {
120             ResolvedJavaField field = type.findInstanceFieldWithOffset(displacement, JavaKind.Object);
121             if (field == null &amp;&amp; object instanceof Class) {
122                 // Read of a static field
123                 HotSpotResolvedObjectTypeImpl staticFieldsHolder = (HotSpotResolvedObjectTypeImpl) metaAccess.lookupJavaType((Class&lt;?&gt;) object);
124                 field = staticFieldsHolder.findStaticFieldWithOffset(displacement, JavaKind.Object);
125             }
126             if (field == null) {
127                 throw new IllegalArgumentException(&quot;Unsafe object access: field not found for read of kind Object&quot; +
128                                 &quot; at offset &quot; + displacement + &quot; in &quot; + type.toJavaName() + &quot; object&quot;);
129             }
130             if (field.getJavaKind() != JavaKind.Object) {
131                 throw new IllegalArgumentException(&quot;Unsafe object access: field &quot; + field.format(&quot;%H.%n:%T&quot;) + &quot; not of expected kind Object&quot; +
132                                 &quot; at offset &quot; + displacement + &quot; in &quot; + type.toJavaName() + &quot; object&quot;);
133             }
134         }
135         return true;
136     }
137 
138     private static long asRawPointer(Constant base) {
139         if (base instanceof HotSpotMetaspaceConstantImpl) {
140             MetaspaceWrapperObject meta = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);
141             return meta.getMetaspacePointer();
142         } else if (base instanceof PrimitiveConstant) {
143             PrimitiveConstant prim = (PrimitiveConstant) base;
144             if (prim.getJavaKind().isNumericInteger()) {
145                 return prim.asLong();
146             }
147         }
148         throw new IllegalArgumentException(String.valueOf(base));
149     }
150 
151     private long readRawValue(Constant baseConstant, long displacement, JavaKind kind, int bits) {
152         Object base = asObject(baseConstant, kind, displacement);
153         if (base != null) {
154             switch (bits) {
155                 case Byte.SIZE:
156                     return UNSAFE.getByte(base, displacement);
157                 case Short.SIZE:
158                     return UNSAFE.getShort(base, displacement);
159                 case Integer.SIZE:
160                     return UNSAFE.getInt(base, displacement);
161                 case Long.SIZE:
162                     return UNSAFE.getLong(base, displacement);
163                 default:
164                     throw new IllegalArgumentException(String.valueOf(bits));
165             }
166         } else {
167             long pointer = asRawPointer(baseConstant);
168             switch (bits) {
169                 case Byte.SIZE:
170                     return UNSAFE.getByte(pointer + displacement);
171                 case Short.SIZE:
172                     return UNSAFE.getShort(pointer + displacement);
173                 case Integer.SIZE:
174                     return UNSAFE.getInt(pointer + displacement);
175                 case Long.SIZE:
176                     return UNSAFE.getLong(pointer + displacement);
177                 default:
178                     throw new IllegalArgumentException(String.valueOf(bits));
179             }
180         }
181     }
182 
183     private boolean verifyReadRawObject(Object expected, Constant base, long displacement) {
184         if (base instanceof HotSpotMetaspaceConstant) {
185             MetaspaceWrapperObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);
186             if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {
187                 if (displacement == runtime.getConfig().classMirrorHandleOffset) {
188                     assert expected == ((HotSpotResolvedObjectTypeImpl) metaspaceObject).mirror();
189                 }
190             }
191         }
192         return true;
193     }
194 
195     private Object readRawObject(Constant baseConstant, long initialDisplacement, boolean compressed) {
196         long displacement = initialDisplacement;
197         Object ret;
198         Object base = asObject(baseConstant, JavaKind.Object, displacement);
199         if (base == null) {
200             assert !compressed;
201             displacement += asRawPointer(baseConstant);
202             ret = UNSAFE.getUncompressedObject(displacement);
203             assert verifyReadRawObject(ret, baseConstant, initialDisplacement);
204         } else {
205             assert runtime.getConfig().useCompressedOops == compressed;
206             ret = UNSAFE.getReference(base, displacement);
207         }
208         return ret;
209     }
210 
211     JavaConstant readFieldValue(HotSpotResolvedJavaField field, Object obj, boolean isVolatile) {
212         assert obj != null;
213         assert !field.isStatic() || obj instanceof Class;
214         long displacement = field.getOffset();
215         assert checkRead(field.getJavaKind(), displacement, (HotSpotResolvedObjectType) runtime.getHostJVMCIBackend().getMetaAccess().lookupJavaType(obj.getClass()), obj,
216                         runtime.getHostJVMCIBackend().getMetaAccess());
217         JavaKind kind = field.getJavaKind();
218         switch (kind) {
219             case Boolean:
220                 return JavaConstant.forBoolean(isVolatile ? UNSAFE.getBooleanVolatile(obj, displacement) : UNSAFE.getBoolean(obj, displacement));
221             case Byte:
222                 return JavaConstant.forByte(isVolatile ? UNSAFE.getByteVolatile(obj, displacement) : UNSAFE.getByte(obj, displacement));
223             case Char:
224                 return JavaConstant.forChar(isVolatile ? UNSAFE.getCharVolatile(obj, displacement) : UNSAFE.getChar(obj, displacement));
225             case Short:
226                 return JavaConstant.forShort(isVolatile ? UNSAFE.getShortVolatile(obj, displacement) : UNSAFE.getShort(obj, displacement));
227             case Int:
228                 return JavaConstant.forInt(isVolatile ? UNSAFE.getIntVolatile(obj, displacement) : UNSAFE.getInt(obj, displacement));
229             case Long:
230                 return JavaConstant.forLong(isVolatile ? UNSAFE.getLongVolatile(obj, displacement) : UNSAFE.getLong(obj, displacement));
231             case Float:
232                 return JavaConstant.forFloat(isVolatile ? UNSAFE.getFloatVolatile(obj, displacement) : UNSAFE.getFloat(obj, displacement));
233             case Double:
234                 return JavaConstant.forDouble(isVolatile ? UNSAFE.getDoubleVolatile(obj, displacement) : UNSAFE.getDouble(obj, displacement));
235             case Object:
236                 return HotSpotObjectConstantImpl.forObject(isVolatile ? UNSAFE.getReferenceVolatile(obj, displacement) : UNSAFE.getReference(obj, displacement));
237             default:
238                 throw new IllegalArgumentException(&quot;Unsupported kind: &quot; + kind);
239         }
240     }
241 
242     @Override
243     public JavaConstant readPrimitiveConstant(JavaKind kind, Constant baseConstant, long initialDisplacement, int bits) {
244         try {
245             long rawValue = readRawValue(baseConstant, initialDisplacement, kind, bits);
246             switch (kind) {
247                 case Boolean:
248                     return JavaConstant.forBoolean(rawValue != 0);
249                 case Byte:
250                     return JavaConstant.forByte((byte) rawValue);
251                 case Char:
252                     return JavaConstant.forChar((char) rawValue);
253                 case Short:
254                     return JavaConstant.forShort((short) rawValue);
255                 case Int:
256                     return JavaConstant.forInt((int) rawValue);
257                 case Long:
258                     return JavaConstant.forLong(rawValue);
259                 case Float:
260                     return JavaConstant.forFloat(Float.intBitsToFloat((int) rawValue));
261                 case Double:
262                     return JavaConstant.forDouble(Double.longBitsToDouble(rawValue));
263                 default:
264                     throw new IllegalArgumentException(&quot;Unsupported kind: &quot; + kind);
265             }
266         } catch (NullPointerException e) {
267             return null;
268         }
269     }
270 
271     @Override
272     public JavaConstant readObjectConstant(Constant base, long displacement) {
273         if (base instanceof HotSpotObjectConstantImpl) {
274             Object o = readRawObject(base, displacement, runtime.getConfig().useCompressedOops);
275             return HotSpotObjectConstantImpl.forObject(o);
276         }
277         if (base instanceof HotSpotMetaspaceConstant) {
278             MetaspaceWrapperObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);
279             if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {
280                  if (displacement == runtime.getConfig().classMirrorHandleOffset) {
281                     // Klass::_java_mirror is valid for all Klass* values
282                     return HotSpotObjectConstantImpl.forObject(((HotSpotResolvedObjectTypeImpl) metaspaceObject).mirror());
283                  }
284              } else {
285                  throw new IllegalArgumentException(String.valueOf(metaspaceObject));
286              }
287         }
288         return null;
289     }
290 
291     @Override
292     public JavaConstant readNarrowOopConstant(Constant base, long displacement) {
293         return HotSpotObjectConstantImpl.forObject(readRawObject(base, displacement, true), true);
294     }
295 
296     private HotSpotResolvedObjectTypeImpl readKlass(Constant base, long displacement, boolean compressed) {
297         assert (base instanceof HotSpotMetaspaceConstantImpl) || (base instanceof HotSpotObjectConstantImpl) : base.getClass();
298         Object baseObject = (base instanceof HotSpotMetaspaceConstantImpl) ? ((HotSpotMetaspaceConstantImpl) base).asResolvedJavaType() : ((HotSpotObjectConstantImpl) base).object();
299         return runtime.getCompilerToVM().getResolvedJavaType(baseObject, displacement, compressed);
300     }
301 
302     @Override
303     public Constant readKlassPointerConstant(Constant base, long displacement) {
304         HotSpotResolvedObjectTypeImpl klass = readKlass(base, displacement, false);
305         if (klass == null) {
306             return JavaConstant.NULL_POINTER;
307         }
308         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(klass, false);
309     }
310 
311     @Override
312     public Constant readNarrowKlassPointerConstant(Constant base, long displacement) {
313         HotSpotResolvedObjectTypeImpl klass = readKlass(base, displacement, true);
314         if (klass == null) {
315             return HotSpotCompressedNullConstant.COMPRESSED_NULL;
316         }
317         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(klass, true);
318     }
319 
320     @Override
321     public Constant readMethodPointerConstant(Constant base, long displacement) {
322         assert (base instanceof HotSpotObjectConstantImpl);
323         Object baseObject = ((HotSpotObjectConstantImpl) base).object();
324         HotSpotResolvedJavaMethodImpl method = runtime.getCompilerToVM().getResolvedJavaMethod(baseObject, displacement);
325         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(method, false);
326     }
327 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMemoryAccessProviderImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotJVMCIRuntime.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotMetaAccessProvider.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMemoryAccessProviderImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 20,23 ***</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  package jdk.vm.ci.hotspot;
  
  import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  
<span class="line-removed">- import java.lang.reflect.Array;</span>
<span class="line-removed">- </span>
<span class="line-removed">- import jdk.vm.ci.common.JVMCIError;</span>
  import jdk.vm.ci.meta.Constant;
  import jdk.vm.ci.meta.JavaConstant;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.MemoryAccessProvider;
<span class="line-removed">- import jdk.vm.ci.meta.MetaAccessProvider;</span>
  import jdk.vm.ci.meta.PrimitiveConstant;
<span class="line-removed">- import jdk.vm.ci.meta.ResolvedJavaField;</span>
<span class="line-removed">- import jdk.vm.ci.meta.ResolvedJavaType;</span>
  
  /**
   * HotSpot implementation of {@link MemoryAccessProvider}.
   */
  class HotSpotMemoryAccessProviderImpl implements HotSpotMemoryAccessProvider {
<span class="line-new-header">--- 20,18 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  package jdk.vm.ci.hotspot;
  
<span class="line-added">+ import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;</span>
  import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  
  import jdk.vm.ci.meta.Constant;
  import jdk.vm.ci.meta.JavaConstant;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.MemoryAccessProvider;
  import jdk.vm.ci.meta.PrimitiveConstant;
  
  /**
   * HotSpot implementation of {@link MemoryAccessProvider}.
   */
  class HotSpotMemoryAccessProviderImpl implements HotSpotMemoryAccessProvider {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 53,115 ***</span>
       *
       * @param base constant value containing the base address for a pending read
       * @return {@code null} if {@code base} does not box an object otherwise the object boxed in
       *         {@code base}
       */
<span class="line-modified">!     private Object asObject(Constant base, JavaKind kind, long displacement) {</span>
          if (base instanceof HotSpotObjectConstantImpl) {
              HotSpotObjectConstantImpl constant = (HotSpotObjectConstantImpl) base;
              HotSpotResolvedObjectType type = constant.getType();
<span class="line-modified">!             Object object = constant.object();</span>
<span class="line-modified">!             checkRead(kind, displacement, type, object, runtime.getHostJVMCIBackend().getMetaAccess());</span>
<span class="line-removed">-             return object;</span>
          }
          return null;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Offset of injected {@code java.lang.Class::oop_size} field. No need to make {@code volatile}</span>
<span class="line-modified">!      * as initialization is idempotent.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private long oopSizeOffset;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private static int computeOopSizeOffset(HotSpotJVMCIRuntime runtime) {</span>
<span class="line-removed">-         MetaAccessProvider metaAccess = runtime.getHostJVMCIBackend().getMetaAccess();</span>
<span class="line-removed">-         ResolvedJavaType staticType = metaAccess.lookupJavaType(Class.class);</span>
<span class="line-removed">-         for (ResolvedJavaField f : staticType.getInstanceFields(false)) {</span>
<span class="line-removed">-             if (f.getName().equals(&quot;oop_size&quot;)) {</span>
<span class="line-removed">-                 int offset = ((HotSpotResolvedJavaField) f).getOffset();</span>
<span class="line-removed">-                 assert offset != 0 : &quot;not expecting offset of java.lang.Class::oop_size to be 0&quot;;</span>
<span class="line-removed">-                 return offset;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         throw new JVMCIError(&quot;Could not find injected java.lang.Class::oop_size field&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private boolean checkRead(JavaKind kind, long displacement, HotSpotResolvedObjectType type, Object object, MetaAccessProvider metaAccess) {</span>
<span class="line-removed">-         if (type.isArray()) {</span>
<span class="line-removed">-             ResolvedJavaType componentType = type.getComponentType();</span>
<span class="line-removed">-             JavaKind componentKind = componentType.getJavaKind();</span>
<span class="line-removed">-             final int headerSize = metaAccess.getArrayBaseOffset(componentKind);</span>
<span class="line-removed">-             int sizeOfElement = metaAccess.getArrayIndexScale(componentKind);</span>
<span class="line-removed">-             int length = Array.getLength(object);</span>
<span class="line-removed">-             long arrayEnd = headerSize + (sizeOfElement * length);</span>
<span class="line-removed">-             boolean aligned = ((displacement - headerSize) % sizeOfElement) == 0;</span>
<span class="line-removed">-             if (displacement &lt; 0 || displacement &gt; (arrayEnd - sizeOfElement) || (kind == JavaKind.Object &amp;&amp; !aligned)) {</span>
<span class="line-removed">-                 int index = (int) ((displacement - headerSize) / sizeOfElement);</span>
<span class="line-removed">-                 throw new IllegalArgumentException(&quot;Unsafe array access: reading element of kind &quot; + kind +</span>
<span class="line-removed">-                                 &quot; at offset &quot; + displacement + &quot; (index ~ &quot; + index + &quot;) in &quot; +</span>
<span class="line-removed">-                                 type.toJavaName() + &quot; object of length &quot; + length);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else if (kind != JavaKind.Object) {</span>
<span class="line-removed">-             long size;</span>
<span class="line-removed">-             if (object instanceof Class) {</span>
<span class="line-removed">-                 if (oopSizeOffset == 0) {</span>
<span class="line-removed">-                     oopSizeOffset = computeOopSizeOffset(runtime);</span>
                  }
<span class="line-removed">-                 int wordSize = runtime.getHostJVMCIBackend().getCodeCache().getTarget().wordSize;</span>
<span class="line-removed">-                 size = UNSAFE.getInt(object, oopSizeOffset) * wordSize;</span>
              } else {
<span class="line-modified">!                 size = Math.abs(type.instanceSize());</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             int bytesToRead = kind.getByteCount();</span>
<span class="line-removed">-             if (displacement + bytesToRead &gt; size || displacement &lt; 0) {</span>
<span class="line-removed">-                 throw new IllegalArgumentException(&quot;Unsafe access: reading &quot; + bytesToRead + &quot; bytes at offset &quot; + displacement + &quot; in &quot; +</span>
<span class="line-removed">-                                 type.toJavaName() + &quot; object of size &quot; + size);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             ResolvedJavaField field = type.findInstanceFieldWithOffset(displacement, JavaKind.Object);</span>
<span class="line-removed">-             if (field == null &amp;&amp; object instanceof Class) {</span>
<span class="line-removed">-                 // Read of a static field</span>
<span class="line-removed">-                 HotSpotResolvedObjectTypeImpl staticFieldsHolder = (HotSpotResolvedObjectTypeImpl) metaAccess.lookupJavaType((Class&lt;?&gt;) object);</span>
<span class="line-removed">-                 field = staticFieldsHolder.findStaticFieldWithOffset(displacement, JavaKind.Object);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (field == null) {</span>
<span class="line-removed">-                 throw new IllegalArgumentException(&quot;Unsafe object access: field not found for read of kind Object&quot; +</span>
<span class="line-removed">-                                 &quot; at offset &quot; + displacement + &quot; in &quot; + type.toJavaName() + &quot; object&quot;);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (field.getJavaKind() != JavaKind.Object) {</span>
<span class="line-removed">-                 throw new IllegalArgumentException(&quot;Unsafe object access: field &quot; + field.format(&quot;%H.%n:%T&quot;) + &quot; not of expected kind Object&quot; +</span>
<span class="line-removed">-                                 &quot; at offset &quot; + displacement + &quot; in &quot; + type.toJavaName() + &quot; object&quot;);</span>
              }
          }
<span class="line-modified">!         return true;</span>
      }
  
      private static long asRawPointer(Constant base) {
          if (base instanceof HotSpotMetaspaceConstantImpl) {
<span class="line-modified">!             MetaspaceWrapperObject meta = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
              return meta.getMetaspacePointer();
          } else if (base instanceof PrimitiveConstant) {
              PrimitiveConstant prim = (PrimitiveConstant) base;
              if (prim.getJavaKind().isNumericInteger()) {
                  return prim.asLong();
              }
          }
          throw new IllegalArgumentException(String.valueOf(base));
      }
  
<span class="line-modified">!     private long readRawValue(Constant baseConstant, long displacement, JavaKind kind, int bits) {</span>
<span class="line-modified">!         Object base = asObject(baseConstant, kind, displacement);</span>
          if (base != null) {
              switch (bits) {
                  case Byte.SIZE:
<span class="line-modified">!                     return UNSAFE.getByte(base, displacement);</span>
                  case Short.SIZE:
<span class="line-modified">!                     return UNSAFE.getShort(base, displacement);</span>
                  case Integer.SIZE:
<span class="line-modified">!                     return UNSAFE.getInt(base, displacement);</span>
                  case Long.SIZE:
<span class="line-modified">!                     return UNSAFE.getLong(base, displacement);</span>
                  default:
                      throw new IllegalArgumentException(String.valueOf(bits));
              }
          } else {
              long pointer = asRawPointer(baseConstant);
<span class="line-new-header">--- 48,60 ---</span>
       *
       * @param base constant value containing the base address for a pending read
       * @return {@code null} if {@code base} does not box an object otherwise the object boxed in
       *         {@code base}
       */
<span class="line-modified">!     private static HotSpotObjectConstantImpl asObject(Constant base, JavaKind kind, long displacement) {</span>
          if (base instanceof HotSpotObjectConstantImpl) {
              HotSpotObjectConstantImpl constant = (HotSpotObjectConstantImpl) base;
              HotSpotResolvedObjectType type = constant.getType();
<span class="line-modified">!             runtime().reflection.checkRead(constant, kind, displacement, type);</span>
<span class="line-modified">!             return constant;</span>
          }
          return null;
      }
  
<span class="line-modified">!     private boolean isValidObjectFieldDisplacement(Constant base, long displacement) {</span>
<span class="line-modified">!         if (base instanceof HotSpotMetaspaceConstant) {</span>
<span class="line-modified">!             MetaspaceObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
<span class="line-modified">!             if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {</span>
<span class="line-modified">!                 if (displacement == runtime.getConfig().javaMirrorOffset) {</span>
<span class="line-modified">!                     // Klass::_java_mirror is valid for all Klass* values</span>
<span class="line-modified">!                     return true;</span>
                  }
              } else {
<span class="line-modified">!                 throw new IllegalArgumentException(String.valueOf(metaspaceObject));</span>
              }
          }
<span class="line-modified">!         return false;</span>
      }
  
      private static long asRawPointer(Constant base) {
          if (base instanceof HotSpotMetaspaceConstantImpl) {
<span class="line-modified">!             MetaspaceObject meta = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
              return meta.getMetaspacePointer();
          } else if (base instanceof PrimitiveConstant) {
              PrimitiveConstant prim = (PrimitiveConstant) base;
              if (prim.getJavaKind().isNumericInteger()) {
                  return prim.asLong();
              }
          }
          throw new IllegalArgumentException(String.valueOf(base));
      }
  
<span class="line-modified">!     private static long readRawValue(Constant baseConstant, long displacement, JavaKind kind, int bits) {</span>
<span class="line-modified">!         HotSpotObjectConstantImpl base = asObject(baseConstant, kind, displacement);</span>
          if (base != null) {
              switch (bits) {
                  case Byte.SIZE:
<span class="line-modified">!                     return runtime().reflection.getByte(base, displacement);</span>
                  case Short.SIZE:
<span class="line-modified">!                     return runtime().reflection.getShort(base, displacement);</span>
                  case Integer.SIZE:
<span class="line-modified">!                     return runtime().reflection.getInt(base, displacement);</span>
                  case Long.SIZE:
<span class="line-modified">!                     return runtime().reflection.getLong(base, displacement);</span>
                  default:
                      throw new IllegalArgumentException(String.valueOf(bits));
              }
          } else {
              long pointer = asRawPointer(baseConstant);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 178,67 ***</span>
                      throw new IllegalArgumentException(String.valueOf(bits));
              }
          }
      }
  
<span class="line-modified">!     private boolean verifyReadRawObject(Object expected, Constant base, long displacement) {</span>
          if (base instanceof HotSpotMetaspaceConstant) {
<span class="line-modified">!             MetaspaceWrapperObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
              if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {
<span class="line-modified">!                 if (displacement == runtime.getConfig().classMirrorHandleOffset) {</span>
<span class="line-modified">!                     assert expected == ((HotSpotResolvedObjectTypeImpl) metaspaceObject).mirror();</span>
                  }
              }
          }
          return true;
      }
  
<span class="line-modified">!     private Object readRawObject(Constant baseConstant, long initialDisplacement, boolean compressed) {</span>
          long displacement = initialDisplacement;
<span class="line-modified">!         Object ret;</span>
<span class="line-modified">!         Object base = asObject(baseConstant, JavaKind.Object, displacement);</span>
          if (base == null) {
              assert !compressed;
              displacement += asRawPointer(baseConstant);
<span class="line-modified">!             ret = UNSAFE.getUncompressedObject(displacement);</span>
              assert verifyReadRawObject(ret, baseConstant, initialDisplacement);
          } else {
              assert runtime.getConfig().useCompressedOops == compressed;
<span class="line-modified">!             ret = UNSAFE.getReference(base, displacement);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return ret;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JavaConstant readFieldValue(HotSpotResolvedJavaField field, Object obj, boolean isVolatile) {</span>
<span class="line-removed">-         assert obj != null;</span>
<span class="line-removed">-         assert !field.isStatic() || obj instanceof Class;</span>
<span class="line-removed">-         long displacement = field.getOffset();</span>
<span class="line-removed">-         assert checkRead(field.getJavaKind(), displacement, (HotSpotResolvedObjectType) runtime.getHostJVMCIBackend().getMetaAccess().lookupJavaType(obj.getClass()), obj,</span>
<span class="line-removed">-                         runtime.getHostJVMCIBackend().getMetaAccess());</span>
<span class="line-removed">-         JavaKind kind = field.getJavaKind();</span>
<span class="line-removed">-         switch (kind) {</span>
<span class="line-removed">-             case Boolean:</span>
<span class="line-removed">-                 return JavaConstant.forBoolean(isVolatile ? UNSAFE.getBooleanVolatile(obj, displacement) : UNSAFE.getBoolean(obj, displacement));</span>
<span class="line-removed">-             case Byte:</span>
<span class="line-removed">-                 return JavaConstant.forByte(isVolatile ? UNSAFE.getByteVolatile(obj, displacement) : UNSAFE.getByte(obj, displacement));</span>
<span class="line-removed">-             case Char:</span>
<span class="line-removed">-                 return JavaConstant.forChar(isVolatile ? UNSAFE.getCharVolatile(obj, displacement) : UNSAFE.getChar(obj, displacement));</span>
<span class="line-removed">-             case Short:</span>
<span class="line-removed">-                 return JavaConstant.forShort(isVolatile ? UNSAFE.getShortVolatile(obj, displacement) : UNSAFE.getShort(obj, displacement));</span>
<span class="line-removed">-             case Int:</span>
<span class="line-removed">-                 return JavaConstant.forInt(isVolatile ? UNSAFE.getIntVolatile(obj, displacement) : UNSAFE.getInt(obj, displacement));</span>
<span class="line-removed">-             case Long:</span>
<span class="line-removed">-                 return JavaConstant.forLong(isVolatile ? UNSAFE.getLongVolatile(obj, displacement) : UNSAFE.getLong(obj, displacement));</span>
<span class="line-removed">-             case Float:</span>
<span class="line-removed">-                 return JavaConstant.forFloat(isVolatile ? UNSAFE.getFloatVolatile(obj, displacement) : UNSAFE.getFloat(obj, displacement));</span>
<span class="line-removed">-             case Double:</span>
<span class="line-removed">-                 return JavaConstant.forDouble(isVolatile ? UNSAFE.getDoubleVolatile(obj, displacement) : UNSAFE.getDouble(obj, displacement));</span>
<span class="line-removed">-             case Object:</span>
<span class="line-removed">-                 return HotSpotObjectConstantImpl.forObject(isVolatile ? UNSAFE.getReferenceVolatile(obj, displacement) : UNSAFE.getReference(obj, displacement));</span>
<span class="line-removed">-             default:</span>
<span class="line-removed">-                 throw new IllegalArgumentException(&quot;Unsupported kind: &quot; + kind);</span>
          }
      }
  
      @Override
      public JavaConstant readPrimitiveConstant(JavaKind kind, Constant baseConstant, long initialDisplacement, int bits) {
          try {
<span class="line-new-header">--- 118,37 ---</span>
                      throw new IllegalArgumentException(String.valueOf(bits));
              }
          }
      }
  
<span class="line-modified">!     private boolean verifyReadRawObject(JavaConstant expected, Constant base, long displacement) {</span>
          if (base instanceof HotSpotMetaspaceConstant) {
<span class="line-modified">!             MetaspaceObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
              if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {
<span class="line-modified">!                 if (displacement == runtime.getConfig().javaMirrorOffset) {</span>
<span class="line-modified">!                     HotSpotResolvedObjectTypeImpl type = (HotSpotResolvedObjectTypeImpl) metaspaceObject;</span>
<span class="line-added">+                     assert expected.equals(type.getJavaMirror());</span>
                  }
              }
          }
          return true;
      }
  
<span class="line-modified">!     private JavaConstant readRawObject(Constant baseConstant, long initialDisplacement, boolean compressed) {</span>
          long displacement = initialDisplacement;
<span class="line-modified">!         JavaConstant ret;</span>
<span class="line-modified">!         HotSpotObjectConstantImpl base = asObject(baseConstant, JavaKind.Object, displacement);</span>
          if (base == null) {
              assert !compressed;
              displacement += asRawPointer(baseConstant);
<span class="line-modified">!             ret = runtime.getCompilerToVM().readUncompressedOop(displacement);</span>
              assert verifyReadRawObject(ret, baseConstant, initialDisplacement);
          } else {
              assert runtime.getConfig().useCompressedOops == compressed;
<span class="line-modified">!             ret = runtime.getCompilerToVM().getObject(base, displacement);</span>
          }
<span class="line-added">+         return ret == null ? JavaConstant.NULL_POINTER : ret;</span>
      }
  
      @Override
      public JavaConstant readPrimitiveConstant(JavaKind kind, Constant baseConstant, long initialDisplacement, int bits) {
          try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,38 ***</span>
      }
  
      @Override
      public JavaConstant readObjectConstant(Constant base, long displacement) {
          if (base instanceof HotSpotObjectConstantImpl) {
<span class="line-modified">!             Object o = readRawObject(base, displacement, runtime.getConfig().useCompressedOops);</span>
<span class="line-removed">-             return HotSpotObjectConstantImpl.forObject(o);</span>
          }
<span class="line-modified">!         if (base instanceof HotSpotMetaspaceConstant) {</span>
<span class="line-modified">!             MetaspaceWrapperObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
<span class="line-removed">-             if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {</span>
<span class="line-removed">-                  if (displacement == runtime.getConfig().classMirrorHandleOffset) {</span>
<span class="line-removed">-                     // Klass::_java_mirror is valid for all Klass* values</span>
<span class="line-removed">-                     return HotSpotObjectConstantImpl.forObject(((HotSpotResolvedObjectTypeImpl) metaspaceObject).mirror());</span>
<span class="line-removed">-                  }</span>
<span class="line-removed">-              } else {</span>
<span class="line-removed">-                  throw new IllegalArgumentException(String.valueOf(metaspaceObject));</span>
<span class="line-removed">-              }</span>
          }
<span class="line-modified">!         return null;</span>
      }
  
      @Override
      public JavaConstant readNarrowOopConstant(Constant base, long displacement) {
<span class="line-modified">!         return HotSpotObjectConstantImpl.forObject(readRawObject(base, displacement, true), true);</span>
      }
  
      private HotSpotResolvedObjectTypeImpl readKlass(Constant base, long displacement, boolean compressed) {
          assert (base instanceof HotSpotMetaspaceConstantImpl) || (base instanceof HotSpotObjectConstantImpl) : base.getClass();
<span class="line-modified">!         Object baseObject = (base instanceof HotSpotMetaspaceConstantImpl) ? ((HotSpotMetaspaceConstantImpl) base).asResolvedJavaType() : ((HotSpotObjectConstantImpl) base).object();</span>
<span class="line-modified">!         return runtime.getCompilerToVM().getResolvedJavaType(baseObject, displacement, compressed);</span>
      }
  
      @Override
      public Constant readKlassPointerConstant(Constant base, long displacement) {
          HotSpotResolvedObjectTypeImpl klass = readKlass(base, displacement, false);
          if (klass == null) {
              return JavaConstant.NULL_POINTER;
<span class="line-new-header">--- 179,39 ---</span>
      }
  
      @Override
      public JavaConstant readObjectConstant(Constant base, long displacement) {
          if (base instanceof HotSpotObjectConstantImpl) {
<span class="line-modified">!             return readRawObject(base, displacement, runtime.getConfig().useCompressedOops);</span>
          }
<span class="line-modified">!         if (!isValidObjectFieldDisplacement(base, displacement)) {</span>
<span class="line-modified">!             return null;</span>
          }
<span class="line-modified">!         if (base instanceof HotSpotMetaspaceConstant &amp;&amp;</span>
<span class="line-added">+             displacement == runtime.getConfig().javaMirrorOffset) {</span>
<span class="line-added">+             MetaspaceObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
<span class="line-added">+             return ((HotSpotResolvedObjectTypeImpl) metaspaceObject).getJavaMirror();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return readRawObject(base, displacement, false);</span>
      }
  
      @Override
      public JavaConstant readNarrowOopConstant(Constant base, long displacement) {
<span class="line-modified">!         JavaConstant res = readRawObject(base, displacement, true);</span>
<span class="line-added">+         return JavaConstant.NULL_POINTER.equals(res) ? HotSpotCompressedNullConstant.COMPRESSED_NULL : ((HotSpotObjectConstant) res).compress();</span>
      }
  
      private HotSpotResolvedObjectTypeImpl readKlass(Constant base, long displacement, boolean compressed) {
          assert (base instanceof HotSpotMetaspaceConstantImpl) || (base instanceof HotSpotObjectConstantImpl) : base.getClass();
<span class="line-modified">!         if (base instanceof HotSpotMetaspaceConstantImpl) {</span>
<span class="line-modified">!             return runtime.getCompilerToVM().getResolvedJavaType((HotSpotResolvedObjectTypeImpl) ((HotSpotMetaspaceConstantImpl) base).asResolvedJavaType(), displacement, compressed);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             return runtime.getCompilerToVM().getResolvedJavaType(((HotSpotObjectConstantImpl) base), displacement, compressed);</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-added">+ </span>
      @Override
      public Constant readKlassPointerConstant(Constant base, long displacement) {
          HotSpotResolvedObjectTypeImpl klass = readKlass(base, displacement, false);
          if (klass == null) {
              return JavaConstant.NULL_POINTER;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 318,10 ***</span>
      }
  
      @Override
      public Constant readMethodPointerConstant(Constant base, long displacement) {
          assert (base instanceof HotSpotObjectConstantImpl);
<span class="line-modified">!         Object baseObject = ((HotSpotObjectConstantImpl) base).object();</span>
<span class="line-removed">-         HotSpotResolvedJavaMethodImpl method = runtime.getCompilerToVM().getResolvedJavaMethod(baseObject, displacement);</span>
          return HotSpotMetaspaceConstantImpl.forMetaspaceObject(method, false);
      }
  }
<span class="line-new-header">--- 229,9 ---</span>
      }
  
      @Override
      public Constant readMethodPointerConstant(Constant base, long displacement) {
          assert (base instanceof HotSpotObjectConstantImpl);
<span class="line-modified">!         HotSpotResolvedJavaMethodImpl method = runtime.getCompilerToVM().getResolvedJavaMethod((HotSpotObjectConstantImpl) base, displacement);</span>
          return HotSpotMetaspaceConstantImpl.forMetaspaceObject(method, false);
      }
  }
</pre>
<center><a href="HotSpotJVMCIRuntime.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotMetaAccessProvider.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
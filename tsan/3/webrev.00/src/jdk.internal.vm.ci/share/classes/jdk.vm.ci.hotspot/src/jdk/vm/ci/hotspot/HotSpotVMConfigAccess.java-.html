<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfigAccess.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import jdk.vm.ci.common.JVMCIError;
 26 
 27 /**
 28  * Access to VM configuration data.
 29  */
 30 public class HotSpotVMConfigAccess {
 31 
 32     /**
 33      * Gets the available configuration data.
 34      */
 35     public HotSpotVMConfigStore getStore() {
 36         return store;
 37     }
 38 
 39     /**
 40      * Gets the address of a C++ symbol.
 41      *
 42      * @param name name of C++ symbol
 43      * @param notPresent if non-null and the symbol is not present then this value is returned
 44      * @return the address of the symbol
 45      * @throws JVMCIError if the symbol is not present and {@code notPresent == null}
 46      */
 47     public long getAddress(String name, Long notPresent) {
 48         Long entry = store.vmAddresses.get(name);
 49         if (entry == null) {
 50             if (notPresent != null) {
 51                 return notPresent;
 52             }
 53             store.printConfig();
 54             throw new JVMCIError(&quot;expected VM symbol not found in &quot; + store + &quot;: &quot; + name);
 55         }
 56         return entry;
 57     }
 58 
 59     /**
 60      * Gets the address of a C++ symbol.
 61      *
 62      * @param name name of C++ symbol
 63      * @return the address of the symbol
 64      * @throws JVMCIError if the symbol is not present
 65      */
 66     public long getAddress(String name) {
 67         return getAddress(name, null);
 68     }
 69 
 70     /**
 71      * Gets the value of a C++ constant.
 72      *
 73      * @param name name of the constant (e.g., {@code &quot;frame::arg_reg_save_area_bytes&quot;})
 74      * @param type the boxed type to which the constant value will be converted
 75      * @param notPresent if non-null and the constant is not present then this value is returned
 76      * @return the constant value converted to {@code type}
 77      * @throws JVMCIError if the constant is not present and {@code notPresent == null}
 78      */
 79     public &lt;T&gt; T getConstant(String name, Class&lt;T&gt; type, T notPresent) {
 80         Long c = store.vmConstants.get(name);
 81         if (c == null) {
 82             if (notPresent != null) {
 83                 return notPresent;
 84             }
 85             store.printConfig();
 86             throw new JVMCIError(&quot;expected VM constant not found in &quot; + store + &quot;: &quot; + name);
 87         }
 88         return type.cast(convertValue(name, type, c, null));
 89     }
 90 
 91     /**
 92      * Gets the value of a C++ constant.
 93      *
 94      * @param name name of the constant (e.g., {@code &quot;frame::arg_reg_save_area_bytes&quot;})
 95      * @param type the boxed type to which the constant value will be converted
 96      * @return the constant value converted to {@code type}
 97      * @throws JVMCIError if the constant is not present
 98      */
 99     public &lt;T&gt; T getConstant(String name, Class&lt;T&gt; type) {
100         return getConstant(name, type, null);
101     }
102 
103     /**
104      * Gets the offset of a non-static C++ field.
105      *
106      * @param name fully qualified name of the field
107      * @param type the boxed type to which the offset value will be converted (must be
108      *            {@link Integer} or {@link Long})
109      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
110      * @param notPresent if non-null and the field is not present then this value is returned
111      * @return the offset in bytes of the requested field
112      * @throws JVMCIError if the field is static or not present and {@code notPresent} is null
113      */
114     public &lt;T&gt; T getFieldOffset(String name, Class&lt;T&gt; type, String cppType, T notPresent) {
115         assert type == Integer.class || type == Long.class;
116         VMField entry = getField(name, cppType, notPresent == null);
117         if (entry == null) {
118             return notPresent;
119         }
120         if (entry.address != 0) {
121             throw new JVMCIError(&quot;cannot get offset of static field &quot; + name);
122         }
123         return type.cast(convertValue(name, type, entry.offset, cppType));
124     }
125 
126     /**
127      * Gets the offset of a non-static C++ field.
128      *
129      * @param name fully qualified name of the field
130      * @param type the boxed type to which the offset value will be converted (must be
131      *            {@link Integer} or {@link Long})
132      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
133      * @return the offset in bytes of the requested field
134      * @throws JVMCIError if the field is static or not present
135      */
136     public &lt;T&gt; T getFieldOffset(String name, Class&lt;T&gt; type, String cppType) {
137         return getFieldOffset(name, type, cppType, null);
138     }
139 
140     /**
141      * Gets the offset of a non-static C++ field.
142      *
143      * @param name fully qualified name of the field
144      * @param type the boxed type to which the offset value will be converted (must be
145      *            {@link Integer} or {@link Long})
146      * @return the offset in bytes of the requested field
147      * @throws JVMCIError if the field is static or not present
148      */
149     public &lt;T&gt; T getFieldOffset(String name, Class&lt;T&gt; type) {
150         return getFieldOffset(name, type, null, null);
151     }
152 
153     /**
154      * Gets the address of a static C++ field.
155      *
156      * @param name fully qualified name of the field
157      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
158      * @param notPresent if non-null and the field is not present then this value is returned
159      * @return the address of the requested field
160      * @throws JVMCIError if the field is not static or not present and {@code notPresent} is null
161      */
162     public long getFieldAddress(String name, String cppType, Long notPresent) {
163         VMField entry = getField(name, cppType, notPresent == null);
164         if (entry == null) {
165             return notPresent;
166         }
167         if (entry.address == 0) {
168             throw new JVMCIError(name + &quot; is not a static field&quot;);
169         }
170         return entry.address;
171     }
172 
173     /**
174      * Gets the address of a static C++ field.
175      *
176      * @param name fully qualified name of the field
177      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
178      * @return the address of the requested field
179      * @throws JVMCIError if the field is not static or not present
180      */
181     public long getFieldAddress(String name, String cppType) {
182         return getFieldAddress(name, cppType, null);
183     }
184 
185     /**
186      * Gets the value of a static C++ field.
187      *
188      * @param name fully qualified name of the field
189      * @param type the boxed type to which the constant value will be converted
190      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
191      * @param notPresent if non-null and the field is not present then this value is returned
192      * @return the value of the requested field
193      * @throws JVMCIError if the field is not static or not present and {@code notPresent} is null
194      */
195     public &lt;T&gt; T getFieldValue(String name, Class&lt;T&gt; type, String cppType, T notPresent) {
196         VMField entry = getField(name, cppType, notPresent == null);
197         if (entry == null) {
198             return notPresent;
199         }
200         if (entry.value == null) {
201             throw new JVMCIError(name + &quot; is not a static field&quot;);
202         }
203         return type.cast(convertValue(name, type, entry.value, cppType));
204     }
205 
206     /**
207      * Gets the value of a static C++ field.
208      *
209      * @param name fully qualified name of the field
210      * @param type the boxed type to which the constant value will be converted
211      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
212      * @return the value of the requested field
213      * @throws JVMCIError if the field is not static or not present
214      */
215     public &lt;T&gt; T getFieldValue(String name, Class&lt;T&gt; type, String cppType) {
216         return getFieldValue(name, type, cppType, null);
217     }
218 
219     /**
220      * Gets the value of a static C++ field.
221      *
222      * @param name fully qualified name of the field
223      * @param type the boxed type to which the constant value will be converted
224      * @return the value of the requested field
225      * @throws JVMCIError if the field is not static or not present
226      */
227     public &lt;T&gt; T getFieldValue(String name, Class&lt;T&gt; type) {
228         return getFieldValue(name, type, null, null);
229     }
230 
231     /**
232      * Gets a C++ field.
233      *
234      * @param name fully qualified name of the field
235      * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
236      * @param required specifies if the field must be present
237      * @return the field
238      * @throws JVMCIError if the field is not present and {@code required == true}
239      */
240     private VMField getField(String name, String cppType, boolean required) {
241         VMField entry = store.vmFields.get(name);
242         if (entry == null) {
243             if (!required) {
244                 return null;
245             }
246             store.printConfig();
247             throw new JVMCIError(&quot;expected VM field not found in &quot; + store + &quot;: &quot; + name);
248         }
249 
250         // Make sure the native type is still the type we expect.
251         if (cppType != null &amp;&amp; !cppType.equals(entry.type)) {
252             throw new JVMCIError(&quot;expected type &quot; + cppType + &quot; but VM field &quot; + name + &quot; is of type &quot; + entry.type);
253         }
254         return entry;
255     }
256 
257     /**
258      * Gets a VM flag value.
259      *
260      * @param name name of the flag (e.g., {@code &quot;CompileTheWorldStartAt&quot;})
261      * @param type the boxed type to which the flag&#39;s value will be converted
262      * @return the flag&#39;s value converted to {@code type} or {@code notPresent} if the flag is not
263      *         present
264      * @throws JVMCIError if the flag is not present
265      */
266     public &lt;T&gt; T getFlag(String name, Class&lt;T&gt; type) {
267         return getFlag(name, type, null);
268     }
269 
270     /**
271      * Gets a VM flag value.
272      *
273      * @param name name of the flag (e.g., {@code &quot;CompileTheWorldStartAt&quot;})
274      * @param type the boxed type to which the flag&#39;s value will be converted
275      * @param notPresent if non-null and the flag is not present then this value is returned
276      * @return the flag&#39;s value converted to {@code type} or {@code notPresent} if the flag is not
277      *         present
278      * @throws JVMCIError if the flag is not present and {@code notPresent == null}
279      */
280     public &lt;T&gt; T getFlag(String name, Class&lt;T&gt; type, T notPresent) {
281         VMFlag entry = store.vmFlags.get(name);
282         Object value;
283         String cppType;
284         if (entry == null) {
285             // Fall back to VM call
286             value = store.compilerToVm.getFlagValue(name);
287             if (value == store.compilerToVm) {
288                 if (notPresent != null) {
289                     return notPresent;
290                 }
291                 store.printConfig();
292                 throw new JVMCIError(&quot;expected VM flag not found in &quot; + store + &quot;: &quot; + name);
293             } else {
294                 cppType = null;
295             }
296         } else {
297             value = entry.value;
298             cppType = entry.type;
299         }
300         return type.cast(convertValue(name, type, value, cppType));
301     }
302 
303     private static &lt;T&gt; Object convertValue(String name, Class&lt;T&gt; toType, Object value, String cppType) throws JVMCIError {
304         if (toType == Boolean.class) {
305             if (value instanceof String) {
306                 return Boolean.valueOf((String) value);
307             } else if (value instanceof Boolean) {
308                 return value;
309             } else if (value instanceof Long) {
310                 return ((long) value) != 0;
311             }
312         } else if (toType == Byte.class) {
313             if (value instanceof Long) {
314                 return (byte) (long) value;
315             }
316         } else if (toType == Integer.class) {
317             if (value instanceof Integer) {
318                 return value;
319             } else if (value instanceof Long) {
320                 return (int) (long) value;
321             }
322         } else if (toType == String.class) {
323             if (value == null || value instanceof String) {
324                 return value;
325             }
326         } else if (toType == Long.class) {
327             return value;
328         }
329 
330         throw new JVMCIError(&quot;cannot convert &quot; + name + &quot; of type &quot; + value.getClass().getSimpleName() + (cppType == null ? &quot;&quot; : &quot; [&quot; + cppType + &quot;]&quot;) + &quot; to &quot; + toType.getSimpleName());
331     }
332 
333     private final HotSpotVMConfigStore store;
334 
335     public HotSpotVMConfigAccess(HotSpotVMConfigStore store) {
336         this.store = store;
337     }
338 }
    </pre>
  </body>
</html>
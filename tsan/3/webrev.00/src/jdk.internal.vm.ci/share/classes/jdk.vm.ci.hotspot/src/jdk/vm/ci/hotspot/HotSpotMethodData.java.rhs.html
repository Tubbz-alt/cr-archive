<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodData.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static java.lang.String.format;
 26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
 27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
 29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 30 
 31 import java.util.Arrays;
 32 
<a name="2" id="anc2"></a><span class="line-added"> 33 import jdk.vm.ci.common.NativeImageReinitialize;</span>
 34 import jdk.internal.misc.Unsafe;
 35 import jdk.vm.ci.meta.DeoptimizationReason;
 36 import jdk.vm.ci.meta.JavaMethodProfile;
 37 import jdk.vm.ci.meta.JavaMethodProfile.ProfiledMethod;
 38 import jdk.vm.ci.meta.JavaTypeProfile;
 39 import jdk.vm.ci.meta.JavaTypeProfile.ProfiledType;
 40 import jdk.vm.ci.meta.ResolvedJavaMethod;
 41 import jdk.vm.ci.meta.ResolvedJavaType;
 42 import jdk.vm.ci.meta.TriState;
 43 
 44 /**
 45  * Access to a HotSpot {@code MethodData} structure (defined in methodData.hpp).
 46  */
 47 final class HotSpotMethodData {
 48 
<a name="3" id="anc3"></a><span class="line-modified"> 49     /**</span>
<span class="line-modified"> 50      * VM state that can be reset when building an AOT image.</span>
<span class="line-modified"> 51      */</span>
<span class="line-added"> 52     static final class VMState {</span>
<span class="line-added"> 53         final HotSpotVMConfig config = config();</span>
<span class="line-added"> 54         final HotSpotMethodDataAccessor noDataNoExceptionAccessor = new NoMethodData(this, config.dataLayoutNoTag, TriState.FALSE);</span>
<span class="line-added"> 55         final HotSpotMethodDataAccessor noDataExceptionPossiblyNotRecordedAccessor = new NoMethodData(this, config.dataLayoutNoTag, TriState.UNKNOWN);</span>
<span class="line-added"> 56         final int noDataSize = cellIndexToOffset(0);</span>
<span class="line-added"> 57         final int bitDataSize = cellIndexToOffset(0);</span>
<span class="line-added"> 58         final int bitDataNullSeenFlag = 1 &lt;&lt; config.bitDataNullSeenFlag;</span>
<span class="line-added"> 59         final int counterDataSize = cellIndexToOffset(1);</span>
<span class="line-added"> 60         final int counterDataCountOffset = cellIndexToOffset(config.methodDataCountOffset);</span>
<span class="line-added"> 61         final int jumpDataSize = cellIndexToOffset(2);</span>
<span class="line-added"> 62         final int takenCountOffset = cellIndexToOffset(config.jumpDataTakenOffset);</span>
<span class="line-added"> 63         final int takenDisplacementOffset = cellIndexToOffset(config.jumpDataDisplacementOffset);</span>
<span class="line-added"> 64         final int typeDataRowSize = cellsToBytes(config.receiverTypeDataReceiverTypeRowCellCount);</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66         final int nonprofiledCountOffset = cellIndexToOffset(config.receiverTypeDataNonprofiledCountOffset);</span>
<span class="line-added"> 67         final int typeDataFirstTypeOffset = cellIndexToOffset(config.receiverTypeDataReceiver0Offset);</span>
<span class="line-added"> 68         final int typeDataFirstTypeCountOffset = cellIndexToOffset(config.receiverTypeDataCount0Offset);</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70         final int typeCheckDataSize = cellIndexToOffset(2) + typeDataRowSize * config.typeProfileWidth;</span>
<span class="line-added"> 71         final int virtualCallDataSize = cellIndexToOffset(2) + typeDataRowSize * (config.typeProfileWidth + config.methodProfileWidth);</span>
<span class="line-added"> 72         final int virtualCallDataFirstMethodOffset = typeDataFirstTypeOffset + typeDataRowSize * config.typeProfileWidth;</span>
<span class="line-added"> 73         final int virtualCallDataFirstMethodCountOffset = typeDataFirstTypeCountOffset + typeDataRowSize * config.typeProfileWidth;</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75         final int retDataRowSize = cellsToBytes(3);</span>
<span class="line-added"> 76         final int retDataSize = cellIndexToOffset(1) + retDataRowSize * config.bciProfileWidth;</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78         final int branchDataSize = cellIndexToOffset(3);</span>
<span class="line-added"> 79         final int notTakenCountOffset = cellIndexToOffset(config.branchDataNotTakenOffset);</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81         final int arrayDataLengthOffset = cellIndexToOffset(config.arrayDataArrayLenOffset);</span>
<span class="line-added"> 82         final int arrayDataStartOffset = cellIndexToOffset(config.arrayDataArrayStartOffset);</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84         final int multiBranchDataSize = cellIndexToOffset(1);</span>
<span class="line-added"> 85         final int multiBranchDataRowSizeInCells = config.multiBranchDataPerCaseCellCount;</span>
<span class="line-added"> 86         final int multiBranchDataRowSize = cellsToBytes(multiBranchDataRowSizeInCells);</span>
<span class="line-added"> 87         final int multiBranchDataFirstCountOffset = arrayDataStartOffset + cellsToBytes(0);</span>
<span class="line-added"> 88         final int multiBranchDataFirstDisplacementOffset = arrayDataStartOffset + cellsToBytes(1);</span>
<span class="line-added"> 89 </span>
<span class="line-added"> 90         final int argInfoDataSize = cellIndexToOffset(1);</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92         // sorted by tag</span>
<span class="line-added"> 93         // @formatter:off</span>
<span class="line-added"> 94         final HotSpotMethodDataAccessor[] profileDataAccessors = {</span>
<span class="line-added"> 95             null,</span>
<span class="line-added"> 96             new BitData(this, config.dataLayoutBitDataTag),</span>
<span class="line-added"> 97             new CounterData(this, config.dataLayoutCounterDataTag),</span>
<span class="line-added"> 98             new JumpData(this, config.dataLayoutJumpDataTag),</span>
<span class="line-added"> 99             new ReceiverTypeData(this, config.dataLayoutReceiverTypeDataTag),</span>
<span class="line-added">100             new VirtualCallData(this, config.dataLayoutVirtualCallDataTag),</span>
<span class="line-added">101             new RetData(this, config.dataLayoutRetDataTag),</span>
<span class="line-added">102             new BranchData(this, config.dataLayoutBranchDataTag),</span>
<span class="line-added">103             new MultiBranchData(this, config.dataLayoutMultiBranchDataTag),</span>
<span class="line-added">104             new ArgInfoData(this, config.dataLayoutArgInfoDataTag),</span>
<span class="line-added">105             new UnknownProfileData(this, config.dataLayoutCallTypeDataTag),</span>
<span class="line-added">106             new VirtualCallTypeData(this, config.dataLayoutVirtualCallTypeDataTag),</span>
<span class="line-added">107             new UnknownProfileData(this, config.dataLayoutParametersTypeDataTag),</span>
<span class="line-added">108             new UnknownProfileData(this, config.dataLayoutSpeculativeTrapDataTag),</span>
<span class="line-added">109         };</span>
<span class="line-added">110         // @formatter:on</span>
<span class="line-added">111 </span>
<span class="line-added">112         private boolean checkAccessorTags() {</span>
<span class="line-added">113             int expectedTag = 0;</span>
<span class="line-added">114             for (HotSpotMethodDataAccessor accessor : profileDataAccessors) {</span>
<span class="line-added">115                 if (expectedTag == 0) {</span>
<span class="line-added">116                     assert accessor == null;</span>
<span class="line-added">117                 } else {</span>
<span class="line-added">118                     assert accessor.tag == expectedTag : expectedTag + &quot; != &quot; + accessor.tag + &quot; &quot; + accessor;</span>
<span class="line-added">119                 }</span>
<span class="line-added">120                 expectedTag++;</span>
<span class="line-added">121             }</span>
<span class="line-added">122             return true;</span>
<span class="line-added">123         }</span>
<span class="line-added">124 </span>
<span class="line-added">125         private VMState() {</span>
<span class="line-added">126             assert checkAccessorTags();</span>
<span class="line-added">127         }</span>
<span class="line-added">128 </span>
<span class="line-added">129         private static int truncateLongToInt(long value) {</span>
<span class="line-added">130             return value &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) value;</span>
<span class="line-added">131         }</span>
<span class="line-added">132 </span>
<span class="line-added">133         private int computeFullOffset(int position, int offsetInBytes) {</span>
<span class="line-added">134             return config.methodDataOopDataOffset + position + offsetInBytes;</span>
<span class="line-added">135         }</span>
<span class="line-added">136 </span>
<span class="line-added">137         private int cellIndexToOffset(int cells) {</span>
<span class="line-added">138             return config.dataLayoutHeaderSize + cellsToBytes(cells);</span>
<span class="line-added">139         }</span>
<span class="line-added">140 </span>
<span class="line-added">141         private int cellsToBytes(int cells) {</span>
<span class="line-added">142             return cells * config.dataLayoutCellSize;</span>
<span class="line-added">143         }</span>
<span class="line-added">144 </span>
<span class="line-added">145         /**</span>
<span class="line-added">146          * Singleton instance lazily initialized via double-checked locking.</span>
<span class="line-added">147          */</span>
<span class="line-added">148         @NativeImageReinitialize private static volatile VMState instance;</span>
<span class="line-added">149 </span>
<span class="line-added">150         static VMState instance() {</span>
<span class="line-added">151             VMState result = instance;</span>
<span class="line-added">152             if (result == null) {</span>
<span class="line-added">153                 synchronized (VMState.class) {</span>
<span class="line-added">154                     result = instance;</span>
<span class="line-added">155                     if (result == null) {</span>
<span class="line-added">156                         instance = result = new VMState();</span>
<span class="line-added">157                     }</span>
<span class="line-added">158                 }</span>
<span class="line-added">159             }</span>
<span class="line-added">160             return result;</span>
<span class="line-added">161         }</span>
<span class="line-added">162     }</span>
163 
164     /**
165      * Reference to the C++ MethodData object.
166      */
167     final long metaspaceMethodData;
168     private final HotSpotResolvedJavaMethodImpl method;
<a name="4" id="anc4"></a><span class="line-added">169     private final VMState state;</span>
170 
171     HotSpotMethodData(long metaspaceMethodData, HotSpotResolvedJavaMethodImpl method) {
172         this.metaspaceMethodData = metaspaceMethodData;
173         this.method = method;
<a name="5" id="anc5"></a><span class="line-added">174         this.state = VMState.instance();</span>
175     }
176 
177     /**
178      * @return value of the MethodData::_data_size field
179      */
180     private int normalDataSize() {
<a name="6" id="anc6"></a><span class="line-modified">181         return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataDataSize);</span>
182     }
183 
184     /**
185      * Returns the size of the extra data records. This method does the same calculation as
186      * MethodData::extra_data_size().
187      *
188      * @return size of extra data records
189      */
190     private int extraDataSize() {
<a name="7" id="anc7"></a><span class="line-modified">191         final int extraDataBase = state.config.methodDataOopDataOffset + normalDataSize();</span>
<span class="line-modified">192         final int extraDataLimit = UNSAFE.getInt(metaspaceMethodData + state.config.methodDataSize);</span>
193         return extraDataLimit - extraDataBase;
194     }
195 
196     public boolean hasNormalData() {
197         return normalDataSize() &gt; 0;
198     }
199 
200     public boolean hasExtraData() {
201         return extraDataSize() &gt; 0;
202     }
203 
204     public int getExtraDataBeginOffset() {
205         return normalDataSize();
206     }
207 
208     public boolean isWithin(int position) {
209         return position &gt;= 0 &amp;&amp; position &lt; normalDataSize() + extraDataSize();
210     }
211 
212     public int getDeoptimizationCount(DeoptimizationReason reason) {
213         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
214         int reasonIndex = metaAccess.convertDeoptReason(reason);
<a name="8" id="anc8"></a><span class="line-modified">215         return UNSAFE.getByte(metaspaceMethodData + state.config.methodDataOopTrapHistoryOffset + reasonIndex) &amp; 0xFF;</span>
216     }
217 
218     public int getOSRDeoptimizationCount(DeoptimizationReason reason) {
219         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
220         int reasonIndex = metaAccess.convertDeoptReason(reason);
<a name="9" id="anc9"></a><span class="line-modified">221         return UNSAFE.getByte(metaspaceMethodData + state.config.methodDataOopTrapHistoryOffset + state.config.deoptReasonOSROffset + reasonIndex) &amp; 0xFF;</span>
222     }
223 
224     public int getDecompileCount() {
<a name="10" id="anc10"></a><span class="line-modified">225         return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataDecompiles);</span>
226     }
227 
228     public int getOverflowRecompileCount() {
<a name="11" id="anc11"></a><span class="line-modified">229         return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataOverflowRecompiles);</span>
230     }
231 
232     public int getOverflowTrapCount() {
<a name="12" id="anc12"></a><span class="line-modified">233         return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataOverflowTraps);</span>
234     }
235 
236     public HotSpotMethodDataAccessor getNormalData(int position) {
237         if (position &gt;= normalDataSize()) {
238             return null;
239         }
240 
241         return getData(position);
242     }
243 
244     public HotSpotMethodDataAccessor getExtraData(int position) {
245         if (position &gt;= normalDataSize() + extraDataSize()) {
246             return null;
247         }
248         HotSpotMethodDataAccessor data = getData(position);
249         if (data != null) {
250             return data;
251         }
252         return data;
253     }
254 
255     public static HotSpotMethodDataAccessor getNoDataAccessor(boolean exceptionPossiblyNotRecorded) {
256         if (exceptionPossiblyNotRecorded) {
<a name="13" id="anc13"></a><span class="line-modified">257             return VMState.instance().noDataExceptionPossiblyNotRecordedAccessor;</span>
258         } else {
<a name="14" id="anc14"></a><span class="line-modified">259             return VMState.instance().noDataNoExceptionAccessor;</span>
260         }
261     }
262 
263     private HotSpotMethodDataAccessor getData(int position) {
264         assert position &gt;= 0 : &quot;out of bounds&quot;;
<a name="15" id="anc15"></a><span class="line-modified">265         final int tag = HotSpotMethodDataAccessor.readTag(state.config, this, position);</span>
<span class="line-modified">266         HotSpotMethodDataAccessor accessor = state.profileDataAccessors[tag];</span>
267         assert accessor == null || accessor.getTag() == tag : &quot;wrong data accessor &quot; + accessor + &quot; for tag &quot; + tag;
268         return accessor;
269     }
270 
271     int readUnsignedByte(int position, int offsetInBytes) {
<a name="16" id="anc16"></a><span class="line-modified">272         long fullOffsetInBytes = state.computeFullOffset(position, offsetInBytes);</span>
273         return UNSAFE.getByte(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFF;
274     }
275 
276     int readUnsignedShort(int position, int offsetInBytes) {
<a name="17" id="anc17"></a><span class="line-modified">277         long fullOffsetInBytes = state.computeFullOffset(position, offsetInBytes);</span>
278         return UNSAFE.getShort(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFF;
279     }
280 
281     /**
282      * Since the values are stored in cells (platform words) this method uses
283      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
284      */
285     private long readUnsignedInt(int position, int offsetInBytes) {
<a name="18" id="anc18"></a><span class="line-modified">286         long fullOffsetInBytes = state.computeFullOffset(position, offsetInBytes);</span>
287         return UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFFFFFFL;
288     }
289 
290     private int readUnsignedIntAsSignedInt(int position, int offsetInBytes) {
291         long value = readUnsignedInt(position, offsetInBytes);
<a name="19" id="anc19"></a><span class="line-modified">292         return VMState.truncateLongToInt(value);</span>
293     }
294 
295     /**
296      * Since the values are stored in cells (platform words) this method uses
297      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
298      */
299     private int readInt(int position, int offsetInBytes) {
<a name="20" id="anc20"></a><span class="line-modified">300         long fullOffsetInBytes = state.computeFullOffset(position, offsetInBytes);</span>
301         return (int) UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes);
302     }
303 
304     private HotSpotResolvedJavaMethod readMethod(int position, int offsetInBytes) {
<a name="21" id="anc21"></a><span class="line-modified">305         long fullOffsetInBytes = state.computeFullOffset(position, offsetInBytes);</span>
306         return compilerToVM().getResolvedJavaMethod(null, metaspaceMethodData + fullOffsetInBytes);
307     }
308 
309     private HotSpotResolvedObjectTypeImpl readKlass(int position, int offsetInBytes) {
<a name="22" id="anc22"></a><span class="line-modified">310         long fullOffsetInBytes = state.computeFullOffset(position, offsetInBytes);</span>
<span class="line-modified">311         return compilerToVM().getResolvedJavaType(metaspaceMethodData + fullOffsetInBytes, false);</span>
















312     }
313 
314     /**
315      * Returns whether profiling ran long enough that the profile information is mature. Other
316      * informational data will still be valid even if the profile isn&#39;t mature.
317      */
318     public boolean isProfileMature() {
319         return runtime().getCompilerToVM().isMature(metaspaceMethodData);
320     }
321 
322     @Override
323     public String toString() {
324         StringBuilder sb = new StringBuilder();
325         String nl = String.format(&quot;%n&quot;);
326         String nlIndent = String.format(&quot;%n%38s&quot;, &quot;&quot;);
327         sb.append(&quot;Raw method data for &quot;);
328         sb.append(method.format(&quot;%H.%n(%p)&quot;));
329         sb.append(&quot;:&quot;);
330         sb.append(nl);
331         sb.append(String.format(&quot;nof_decompiles(%d) nof_overflow_recompiles(%d) nof_overflow_traps(%d)%n&quot;,
332                         getDecompileCount(), getOverflowRecompileCount(), getOverflowTrapCount()));
333         if (hasNormalData()) {
334             int pos = 0;
335             HotSpotMethodDataAccessor data;
336             while ((data = getNormalData(pos)) != null) {
337                 if (pos != 0) {
338                     sb.append(nl);
339                 }
340                 int bci = data.getBCI(this, pos);
341                 sb.append(String.format(&quot;%-6d bci: %-6d%-20s&quot;, pos, bci, data.getClass().getSimpleName()));
342                 sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));
343                 pos = pos + data.getSize(this, pos);
344             }
345         }
346 
347         if (hasExtraData()) {
348             int pos = getExtraDataBeginOffset();
349             HotSpotMethodDataAccessor data;
350             while ((data = getExtraData(pos)) != null) {
351                 if (pos == getExtraDataBeginOffset()) {
352                     sb.append(nl).append(&quot;--- Extra data:&quot;);
353                 }
354                 int bci = data.getBCI(this, pos);
355                 sb.append(String.format(&quot;%n%-6d bci: %-6d%-20s&quot;, pos, bci, data.getClass().getSimpleName()));
356                 sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));
357                 pos = pos + data.getSize(this, pos);
358             }
359 
360         }
361         return sb.toString();
362     }
363 
<a name="23" id="anc23"></a>

364     static class NoMethodData extends HotSpotMethodDataAccessor {
365 
366         private final TriState exceptionSeen;
367 
<a name="24" id="anc24"></a><span class="line-modified">368         protected NoMethodData(VMState state, int tag, TriState exceptionSeen) {</span>
<span class="line-modified">369             super(state, tag, state.noDataSize);</span>
370             this.exceptionSeen = exceptionSeen;
371         }
372 
373         @Override
374         public int getBCI(HotSpotMethodData data, int position) {
375             return -1;
376         }
377 
378         @Override
379         public TriState getExceptionSeen(HotSpotMethodData data, int position) {
380             return exceptionSeen;
381         }
382 
383         @Override
384         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
385             return sb;
386         }
387     }
388 
<a name="25" id="anc25"></a>


389     static class BitData extends HotSpotMethodDataAccessor {
390 
<a name="26" id="anc26"></a><span class="line-modified">391         private BitData(VMState state, int tag) {</span>
<span class="line-modified">392             super(state, tag, state.bitDataSize);</span>
393         }
394 
<a name="27" id="anc27"></a><span class="line-modified">395         protected BitData(VMState state, int tag, int staticSize) {</span>
<span class="line-modified">396             super(state, tag, staticSize);</span>
397         }
398 
399         @Override
400         public TriState getNullSeen(HotSpotMethodData data, int position) {
<a name="28" id="anc28"></a><span class="line-modified">401             return TriState.get((getFlags(data, position) &amp; state.bitDataNullSeenFlag) != 0);</span>
402         }
403 
404         @Override
405         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
406             return sb.append(format(&quot;exception_seen(%s)&quot;, getExceptionSeen(data, pos)));
407         }
408     }
409 
<a name="29" id="anc29"></a>


410     static class CounterData extends BitData {
411 
<a name="30" id="anc30"></a><span class="line-modified">412         CounterData(VMState state, int tag) {</span>
<span class="line-modified">413             super(state, tag, state.counterDataSize);</span>
414         }
415 
<a name="31" id="anc31"></a><span class="line-modified">416         protected CounterData(VMState state, int tag, int staticSize) {</span>
<span class="line-modified">417             super(state, tag, staticSize);</span>
418         }
419 
420         @Override
421         public int getExecutionCount(HotSpotMethodData data, int position) {
422             return getCounterValue(data, position);
423         }
424 
425         protected int getCounterValue(HotSpotMethodData data, int position) {
<a name="32" id="anc32"></a><span class="line-modified">426             return data.readUnsignedIntAsSignedInt(position, state.counterDataCountOffset);</span>
427         }
428 
429         @Override
430         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
431             return sb.append(format(&quot;count(%d) null_seen(%s) exception_seen(%s)&quot;, getCounterValue(data, pos), getNullSeen(data, pos), getExceptionSeen(data, pos)));
432         }
433     }
434 
<a name="33" id="anc33"></a>



435     static class JumpData extends HotSpotMethodDataAccessor {
436 
<a name="34" id="anc34"></a><span class="line-modified">437         JumpData(VMState state, int tag) {</span>
<span class="line-modified">438             super(state, tag, state.jumpDataSize);</span>
439         }
440 
<a name="35" id="anc35"></a><span class="line-modified">441         protected JumpData(VMState state, int tag, int staticSize) {</span>
<span class="line-modified">442             super(state, tag, staticSize);</span>
443         }
444 
445         @Override
446         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
447             return getExecutionCount(data, position) != 0 ? 1 : 0;
448         }
449 
450         @Override
451         public int getExecutionCount(HotSpotMethodData data, int position) {
<a name="36" id="anc36"></a><span class="line-modified">452             return data.readUnsignedIntAsSignedInt(position, state.takenCountOffset);</span>
453         }
454 
455         public int getTakenDisplacement(HotSpotMethodData data, int position) {
<a name="37" id="anc37"></a><span class="line-modified">456             return data.readInt(position, state.takenDisplacementOffset);</span>
457         }
458 
459         @Override
460         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
461             return sb.append(format(&quot;taken(%d) displacement(%d)&quot;, getExecutionCount(data, pos), getTakenDisplacement(data, pos)));
462         }
463     }
464 
465     static class RawItemProfile&lt;T&gt; {
466         final int entries;
467         final T[] items;
468         final long[] counts;
469         final long totalCount;
470 
471         RawItemProfile(int entries, T[] items, long[] counts, long totalCount) {
472             this.entries = entries;
473             this.items = items;
474             this.counts = counts;
475             this.totalCount = totalCount;
476         }
477     }
478 
<a name="38" id="anc38"></a>





479     abstract static class AbstractTypeData extends CounterData {
480 
<a name="39" id="anc39"></a><span class="line-modified">481         protected AbstractTypeData(VMState state, int tag, int staticSize) {</span>
<span class="line-modified">482             super(state, tag, staticSize);</span>
483         }
484 
485         @Override
486         public JavaTypeProfile getTypeProfile(HotSpotMethodData data, int position) {
487             return createTypeProfile(getNullSeen(data, position), getRawTypeProfile(data, position));
488         }
489 
490         private RawItemProfile&lt;ResolvedJavaType&gt; getRawTypeProfile(HotSpotMethodData data, int position) {
491             int typeProfileWidth = config.typeProfileWidth;
492 
493             ResolvedJavaType[] types = new ResolvedJavaType[typeProfileWidth];
494             long[] counts = new long[typeProfileWidth];
495             long totalCount = 0;
496             int entries = 0;
497 
498             outer: for (int i = 0; i &lt; typeProfileWidth; i++) {
499                 HotSpotResolvedObjectTypeImpl receiverKlass = data.readKlass(position, getTypeOffset(i));
500                 if (receiverKlass != null) {
501                     HotSpotResolvedObjectTypeImpl klass = receiverKlass;
502                     long count = data.readUnsignedInt(position, getTypeCountOffset(i));
503                     /*
504                      * Because of races in the profile collection machinery it&#39;s possible for a
505                      * class to appear multiple times so merge them to make the profile look
506                      * rational.
507                      */
508                     for (int j = 0; j &lt; entries; j++) {
509                         if (types[j].equals(klass)) {
510                             totalCount += count;
511                             counts[j] += count;
512                             continue outer;
513                         }
514                     }
515                     types[entries] = klass;
516                     totalCount += count;
517                     counts[entries] = count;
518                     entries++;
519                 }
520             }
521 
522             totalCount += getTypesNotRecordedExecutionCount(data, position);
523             return new RawItemProfile&lt;&gt;(entries, types, counts, totalCount);
524         }
525 
526         protected abstract long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position);
527 
528         public int getNonprofiledCount(HotSpotMethodData data, int position) {
<a name="40" id="anc40"></a><span class="line-modified">529             return data.readUnsignedIntAsSignedInt(position, state.nonprofiledCountOffset);</span>
530         }
531 
532         private JavaTypeProfile createTypeProfile(TriState nullSeen, RawItemProfile&lt;ResolvedJavaType&gt; profile) {
533             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
534                 return null;
535             }
536 
537             ProfiledType[] ptypes = new ProfiledType[profile.entries];
538             double totalProbability = 0.0;
539             for (int i = 0; i &lt; profile.entries; i++) {
540                 double p = profile.counts[i];
541                 p = p / profile.totalCount;
542                 totalProbability += p;
543                 ptypes[i] = new ProfiledType(profile.items[i], p);
544             }
545 
546             Arrays.sort(ptypes);
547 
548             double notRecordedTypeProbability = profile.entries &lt; config.typeProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
549             assert notRecordedTypeProbability == 0 || profile.entries == config.typeProfileWidth;
550             return new JavaTypeProfile(nullSeen, notRecordedTypeProbability, ptypes);
551         }
552 
<a name="41" id="anc41"></a><span class="line-modified">553         private int getTypeOffset(int row) {</span>
<span class="line-modified">554             return state.typeDataFirstTypeOffset + row * state.typeDataRowSize;</span>
555         }
556 
<a name="42" id="anc42"></a><span class="line-modified">557         protected int getTypeCountOffset(int row) {</span>
<span class="line-modified">558             return state.typeDataFirstTypeCountOffset + row * state.typeDataRowSize;</span>
559         }
560 
561         @Override
562         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
563             RawItemProfile&lt;ResolvedJavaType&gt; profile = getRawTypeProfile(data, pos);
564             TriState nullSeen = getNullSeen(data, pos);
565             TriState exceptionSeen = getExceptionSeen(data, pos);
566             sb.append(format(&quot;count(%d) null_seen(%s) exception_seen(%s) nonprofiled_count(%d) entries(%d)&quot;, getCounterValue(data, pos), nullSeen, exceptionSeen,
567                             getNonprofiledCount(data, pos), profile.entries));
568             for (int i = 0; i &lt; profile.entries; i++) {
569                 long count = profile.counts[i];
570                 sb.append(format(&quot;%n  %s (%d, %4.2f)&quot;, profile.items[i].toJavaName(), count, (double) count / profile.totalCount));
571             }
572             return sb;
573         }
574     }
575 
<a name="43" id="anc43"></a>

576     static class ReceiverTypeData extends AbstractTypeData {
577 
<a name="44" id="anc44"></a><span class="line-modified">578         ReceiverTypeData(VMState state, int tag) {</span>
<span class="line-modified">579             super(state, tag, state.typeCheckDataSize);</span>
580         }
581 
<a name="45" id="anc45"></a><span class="line-modified">582         protected ReceiverTypeData(VMState state, int tag, int staticSize) {</span>
<span class="line-modified">583             super(state, tag, staticSize);</span>
584         }
585 
586         @Override
587         public int getExecutionCount(HotSpotMethodData data, int position) {
588             return -1;
589         }
590 
591         @Override
592         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
593             return getNonprofiledCount(data, position);
594         }
595     }
596 
<a name="46" id="anc46"></a>



597     static class VirtualCallData extends ReceiverTypeData {
598 
<a name="47" id="anc47"></a><span class="line-modified">599         VirtualCallData(VMState state, int tag) {</span>
<span class="line-modified">600             super(state, tag, state.virtualCallDataSize);</span>
601         }
602 
<a name="48" id="anc48"></a><span class="line-modified">603         protected VirtualCallData(VMState state, int tag, int staticSize) {</span>
<span class="line-modified">604             super(state, tag, staticSize);</span>
605         }
606 
607         @Override
608         public int getExecutionCount(HotSpotMethodData data, int position) {
609             final int typeProfileWidth = config.typeProfileWidth;
610 
611             long total = 0;
612             for (int i = 0; i &lt; typeProfileWidth; i++) {
613                 total += data.readUnsignedInt(position, getTypeCountOffset(i));
614             }
615 
616             total += getCounterValue(data, position);
<a name="49" id="anc49"></a><span class="line-modified">617             return VMState.truncateLongToInt(total);</span>
618         }
619 
620         @Override
621         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
622             return getCounterValue(data, position);
623         }
624 
<a name="50" id="anc50"></a><span class="line-modified">625         private long getMethodsNotRecordedExecutionCount(HotSpotMethodData data, int position) {</span>
<span class="line-modified">626             return data.readUnsignedIntAsSignedInt(position, state.nonprofiledCountOffset);</span>
627         }
628 
629         @Override
630         public JavaMethodProfile getMethodProfile(HotSpotMethodData data, int position) {
631             return createMethodProfile(getRawMethodProfile(data, position));
632         }
633 
634         private RawItemProfile&lt;ResolvedJavaMethod&gt; getRawMethodProfile(HotSpotMethodData data, int position) {
635             int profileWidth = config.methodProfileWidth;
636 
637             ResolvedJavaMethod[] methods = new ResolvedJavaMethod[profileWidth];
638             long[] counts = new long[profileWidth];
639             long totalCount = 0;
640             int entries = 0;
641 
642             for (int i = 0; i &lt; profileWidth; i++) {
643                 HotSpotResolvedJavaMethod method = data.readMethod(position, getMethodOffset(i));
644                 if (method != null) {
645                     methods[entries] = method;
646                     long count = data.readUnsignedInt(position, getMethodCountOffset(i));
647                     totalCount += count;
648                     counts[entries] = count;
649 
650                     entries++;
651                 }
652             }
653 
654             totalCount += getMethodsNotRecordedExecutionCount(data, position);
655 
656             // Fixup the case of C1&#39;s inability to optimize profiling of a statically bindable call
657             // site. If it&#39;s a monomorphic call site, attribute all the counts to the first type (if
658             // any is recorded).
659             if (entries == 1) {
660                 counts[0] = totalCount;
661             }
662 
663             return new RawItemProfile&lt;&gt;(entries, methods, counts, totalCount);
664         }
665 
666         private JavaMethodProfile createMethodProfile(RawItemProfile&lt;ResolvedJavaMethod&gt; profile) {
667             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
668                 return null;
669             }
670 
671             ProfiledMethod[] pmethods = new ProfiledMethod[profile.entries];
672             double totalProbability = 0.0;
673             for (int i = 0; i &lt; profile.entries; i++) {
674                 double p = profile.counts[i];
675                 p = p / profile.totalCount;
676                 totalProbability += p;
677                 pmethods[i] = new ProfiledMethod(profile.items[i], p);
678             }
679 
680             Arrays.sort(pmethods);
681 
682             double notRecordedMethodProbability = profile.entries &lt; config.methodProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
683             assert notRecordedMethodProbability == 0 || profile.entries == config.methodProfileWidth;
684             return new JavaMethodProfile(notRecordedMethodProbability, pmethods);
685         }
686 
<a name="51" id="anc51"></a><span class="line-modified">687         private int getMethodOffset(int row) {</span>
<span class="line-modified">688             return state.virtualCallDataFirstMethodOffset + row * state.typeDataRowSize;</span>
689         }
690 
<a name="52" id="anc52"></a><span class="line-modified">691         private int getMethodCountOffset(int row) {</span>
<span class="line-modified">692             return state.virtualCallDataFirstMethodCountOffset + row * state.typeDataRowSize;</span>
693         }
694 
695         @Override
696         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
697             RawItemProfile&lt;ResolvedJavaMethod&gt; profile = getRawMethodProfile(data, pos);
698             super.appendTo(sb.append(format(&quot;exception_seen(%s) &quot;, getExceptionSeen(data, pos))), data, pos).append(format(&quot;%nmethod_entries(%d)&quot;, profile.entries));
699             for (int i = 0; i &lt; profile.entries; i++) {
700                 long count = profile.counts[i];
701                 sb.append(format(&quot;%n  %s (%d, %4.2f)&quot;, profile.items[i].format(&quot;%H.%n(%p)&quot;), count, (double) count / profile.totalCount));
702             }
703             return sb;
704         }
705     }
706 
707     static class VirtualCallTypeData extends VirtualCallData {
708 
<a name="53" id="anc53"></a><span class="line-modified">709         VirtualCallTypeData(VMState state, int tag) {</span>
<span class="line-modified">710             super(state, tag, 0);</span>
711         }
712 
713         @Override
714         protected int getDynamicSize(HotSpotMethodData data, int position) {
715             assert staticSize == 0;
716             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
717         }
718     }
719 
<a name="54" id="anc54"></a>


720     static class RetData extends CounterData {
721 
<a name="55" id="anc55"></a><span class="line-modified">722         RetData(VMState state, int tag) {</span>
<span class="line-modified">723             super(state, tag, state.retDataSize);</span>
724         }
725     }
726 
<a name="56" id="anc56"></a>


727     static class BranchData extends JumpData {
728 
<a name="57" id="anc57"></a><span class="line-modified">729         BranchData(VMState state, int tag) {</span>
<span class="line-modified">730             super(state, tag, state.branchDataSize);</span>
731         }
732 
733         @Override
734         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
<a name="58" id="anc58"></a><span class="line-modified">735             long takenCount = data.readUnsignedInt(position, state.takenCountOffset);</span>
<span class="line-modified">736             long notTakenCount = data.readUnsignedInt(position, state.notTakenCountOffset);</span>
737             long total = takenCount + notTakenCount;
738 
739             return total &lt;= 0 ? -1 : takenCount / (double) total;
740         }
741 
742         @Override
743         public int getExecutionCount(HotSpotMethodData data, int position) {
<a name="59" id="anc59"></a><span class="line-modified">744             long count = data.readUnsignedInt(position, state.takenCountOffset) + data.readUnsignedInt(position, state.notTakenCountOffset);</span>
<span class="line-modified">745             return VMState.truncateLongToInt(count);</span>
746         }
747 
748         @Override
749         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
<a name="60" id="anc60"></a><span class="line-modified">750             long taken = data.readUnsignedInt(pos, state.takenCountOffset);</span>
<span class="line-modified">751             long notTaken = data.readUnsignedInt(pos, state.notTakenCountOffset);</span>
752             double takenProbability = getBranchTakenProbability(data, pos);
753             return sb.append(format(&quot;taken(%d, %4.2f) not_taken(%d, %4.2f) displacement(%d)&quot;, taken, takenProbability, notTaken, 1.0D - takenProbability, getTakenDisplacement(data, pos)));
754         }
755     }
756 
<a name="61" id="anc61"></a>


757     static class ArrayData extends HotSpotMethodDataAccessor {
758 
<a name="62" id="anc62"></a><span class="line-modified">759         ArrayData(VMState state, int tag, int staticSize) {</span>
<span class="line-modified">760             super(state, tag, staticSize);</span>
761         }
762 
763         @Override
764         protected int getDynamicSize(HotSpotMethodData data, int position) {
<a name="63" id="anc63"></a><span class="line-modified">765             return state.cellsToBytes(getLength(data, position));</span>
766         }
767 
<a name="64" id="anc64"></a><span class="line-modified">768         protected int getLength(HotSpotMethodData data, int position) {</span>
<span class="line-modified">769             return data.readInt(position, state.arrayDataLengthOffset);</span>
770         }
771 
772         @Override
773         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
774             return sb.append(format(&quot;length(%d)&quot;, getLength(data, pos)));
775         }
776     }
777 
<a name="65" id="anc65"></a>





778     static class MultiBranchData extends ArrayData {
779 
<a name="66" id="anc66"></a><span class="line-modified">780         MultiBranchData(VMState state, int tag) {</span>
<span class="line-modified">781             super(state, tag, state.multiBranchDataSize);</span>
782         }
783 
784         @Override
785         public double[] getSwitchProbabilities(HotSpotMethodData data, int position) {
786             int arrayLength = getLength(data, position);
787             assert arrayLength &gt; 0 : &quot;switch must have at least the default case&quot;;
<a name="67" id="anc67"></a><span class="line-modified">788             assert arrayLength % state.multiBranchDataRowSizeInCells == 0 : &quot;array must have full rows&quot;;</span>
789 
<a name="68" id="anc68"></a><span class="line-modified">790             int length = arrayLength / state.multiBranchDataRowSizeInCells;</span>
791             long totalCount = 0;
792             double[] result = new double[length];
793 
794             // default case is first in HotSpot but last for the compiler
795             long count = readCount(data, position, 0);
796             totalCount += count;
797             result[length - 1] = count;
798 
799             for (int i = 1; i &lt; length; i++) {
800                 count = readCount(data, position, i);
801                 totalCount += count;
802                 result[i - 1] = count;
803             }
804 
805             if (totalCount &lt;= 0) {
806                 return null;
807             } else {
808                 for (int i = 0; i &lt; length; i++) {
809                     result[i] = result[i] / totalCount;
810                 }
811                 return result;
812             }
813         }
814 
<a name="69" id="anc69"></a><span class="line-modified">815         private long readCount(HotSpotMethodData data, int position, int i) {</span>
816             int offset;
817             long count;
818             offset = getCountOffset(i);
819             count = data.readUnsignedInt(position, offset);
820             return count;
821         }
822 
823         @Override
824         public int getExecutionCount(HotSpotMethodData data, int position) {
825             int arrayLength = getLength(data, position);
826             assert arrayLength &gt; 0 : &quot;switch must have at least the default case&quot;;
<a name="70" id="anc70"></a><span class="line-modified">827             assert arrayLength % state.multiBranchDataRowSizeInCells == 0 : &quot;array must have full rows&quot;;</span>
828 
<a name="71" id="anc71"></a><span class="line-modified">829             int length = arrayLength / state.multiBranchDataRowSizeInCells;</span>
830             long totalCount = 0;
831             for (int i = 0; i &lt; length; i++) {
832                 int offset = getCountOffset(i);
833                 totalCount += data.readUnsignedInt(position, offset);
834             }
835 
<a name="72" id="anc72"></a><span class="line-modified">836             return VMState.truncateLongToInt(totalCount);</span>
837         }
838 
<a name="73" id="anc73"></a><span class="line-modified">839         private int getCountOffset(int index) {</span>
<span class="line-modified">840             return state.multiBranchDataFirstCountOffset + index * state.multiBranchDataRowSize;</span>
841         }
842 
<a name="74" id="anc74"></a><span class="line-modified">843         private int getDisplacementOffset(int index) {</span>
<span class="line-modified">844             return state.multiBranchDataFirstDisplacementOffset + index * state.multiBranchDataRowSize;</span>
845         }
846 
847         @Override
848         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
<a name="75" id="anc75"></a><span class="line-modified">849             int entries = getLength(data, pos) / state.multiBranchDataRowSizeInCells;</span>
850             sb.append(format(&quot;entries(%d)&quot;, entries));
851             for (int i = 0; i &lt; entries; i++) {
852                 sb.append(format(&quot;%n  %d: count(%d) displacement(%d)&quot;, i, data.readUnsignedInt(pos, getCountOffset(i)), data.readUnsignedInt(pos, getDisplacementOffset(i))));
853             }
854             return sb;
855         }
856     }
857 
<a name="76" id="anc76"></a>

858     static class ArgInfoData extends ArrayData {
859 
<a name="77" id="anc77"></a><span class="line-modified">860         ArgInfoData(VMState state, int tag) {</span>
<span class="line-modified">861             super(state, tag, state.argInfoDataSize);</span>
862         }
863     }
864 
865     static class UnknownProfileData extends HotSpotMethodDataAccessor {
<a name="78" id="anc78"></a><span class="line-modified">866         UnknownProfileData(VMState state, int tag) {</span>
<span class="line-modified">867             super(state, tag, 0);</span>
868         }
869 
870         @Override
871         protected int getDynamicSize(HotSpotMethodData data, int position) {
872             assert staticSize == 0;
873             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
874         }
875 
876         @Override
877         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
878             sb.append(&quot;unknown profile data with tag: &quot; + tag);
879             return sb;
880         }
881     }
882 
883     public void setCompiledIRSize(int size) {
<a name="79" id="anc79"></a><span class="line-modified">884         UNSAFE.putInt(metaspaceMethodData + state.config.methodDataIRSizeOffset, size);</span>
885     }
886 
887     public int getCompiledIRSize() {
<a name="80" id="anc80"></a><span class="line-modified">888         return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataIRSizeOffset);</span>




































889     }
<a name="81" id="anc81"></a>
890 }
<a name="82" id="anc82"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="82" type="hidden" />
</body>
</html>
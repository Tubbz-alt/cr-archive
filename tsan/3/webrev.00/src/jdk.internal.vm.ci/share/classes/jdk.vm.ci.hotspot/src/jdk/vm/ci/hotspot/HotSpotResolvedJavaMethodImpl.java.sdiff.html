<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotResolvedJavaFieldImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotResolvedJavaType.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
 26 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 27 import static jdk.vm.ci.hotspot.HotSpotModifiers.BRIDGE;
 28 import static jdk.vm.ci.hotspot.HotSpotModifiers.SYNTHETIC;
 29 import static jdk.vm.ci.hotspot.HotSpotModifiers.VARARGS;
 30 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmMethodModifiers;
 31 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
 32 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 33 
 34 import java.lang.annotation.Annotation;
 35 import java.lang.reflect.Executable;
 36 import java.lang.reflect.Modifier;
 37 import java.lang.reflect.Type;
<span class="line-removed"> 38 import java.util.HashMap;</span>
<span class="line-removed"> 39 import java.util.Map;</span>
 40 
 41 import jdk.vm.ci.common.JVMCIError;
 42 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.Option;
 43 import jdk.vm.ci.meta.Constant;
 44 import jdk.vm.ci.meta.ConstantPool;
 45 import jdk.vm.ci.meta.DefaultProfilingInfo;
 46 import jdk.vm.ci.meta.ExceptionHandler;
 47 import jdk.vm.ci.meta.JavaMethod;
 48 import jdk.vm.ci.meta.JavaType;
 49 import jdk.vm.ci.meta.LineNumberTable;
 50 import jdk.vm.ci.meta.Local;
 51 import jdk.vm.ci.meta.LocalVariableTable;
 52 import jdk.vm.ci.meta.ProfilingInfo;
 53 import jdk.vm.ci.meta.ResolvedJavaMethod;
 54 import jdk.vm.ci.meta.ResolvedJavaType;
 55 import jdk.vm.ci.meta.SpeculationLog;
 56 import jdk.vm.ci.meta.TriState;
 57 
 58 /**
 59  * Implementation of {@link JavaMethod} for resolved HotSpot methods.
 60  */
<span class="line-modified"> 61 final class HotSpotResolvedJavaMethodImpl extends HotSpotMethod implements HotSpotResolvedJavaMethod, MetaspaceWrapperObject {</span>
 62 
 63     /**
<span class="line-modified"> 64      * Reference to metaspace Method object.</span>

 65      */
<span class="line-modified"> 66     private final long metaspaceMethod;</span>
 67 
 68     private final HotSpotResolvedObjectTypeImpl holder;
 69     private final HotSpotConstantPool constantPool;
<span class="line-modified"> 70     private final HotSpotSignature signature;</span>
 71     private HotSpotMethodData methodData;
 72     private byte[] code;
 73 
 74     /**
<span class="line-modified"> 75      * Cache for {@link #toJava()}.</span>
 76      */
<span class="line-modified"> 77     private volatile Executable toJavaCache;</span>
 78 
 79     /**
 80      * Only 30% of {@link HotSpotResolvedJavaMethodImpl}s have their name accessed so compute it
 81      * lazily and cache it.
 82      */
 83     private String nameCache;
 84 
 85     /**
 86      * Gets the holder of a HotSpot metaspace method native object.
 87      *
<span class="line-modified"> 88      * @param metaspaceMethod a metaspace Method object</span>
 89      * @return the {@link ResolvedJavaType} corresponding to the holder of the
 90      *         {@code metaspaceMethod}
 91      */
<span class="line-modified"> 92     private static HotSpotResolvedObjectTypeImpl getHolder(long metaspaceMethod) {</span>
 93         HotSpotVMConfig config = config();


 94         final long metaspaceConstMethod = UNSAFE.getAddress(metaspaceMethod + config.methodConstMethodOffset);
 95         final long metaspaceConstantPool = UNSAFE.getAddress(metaspaceConstMethod + config.constMethodConstantsOffset);
<span class="line-modified"> 96         return compilerToVM().getResolvedJavaType(null, metaspaceConstantPool + config.constantPoolHolderOffset, false);</span>


 97     }
 98 
 99     /**
100      * Gets the JVMCI mirror from a HotSpot method. The VM is responsible for ensuring that the
<span class="line-modified">101      * Method* is kept alive for the duration of this call and the</span>
<span class="line-modified">102      * {@link HotSpotJVMCIMetaAccessContext} keeps it alive after that.</span>
<span class="line-modified">103      *</span>
104      * Called from the VM.
105      *
<span class="line-modified">106      * @param metaspaceMethod a metaspace Method object</span>
107      * @return the {@link ResolvedJavaMethod} corresponding to {@code metaspaceMethod}
108      */
109     @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">110     private static HotSpotResolvedJavaMethod fromMetaspace(long metaspaceMethod) {</span>
<span class="line-modified">111         HotSpotResolvedObjectTypeImpl holder = getHolder(metaspaceMethod);</span>
<span class="line-modified">112         return holder.createMethod(metaspaceMethod);</span>

113     }
114 
<span class="line-modified">115     HotSpotResolvedJavaMethodImpl(HotSpotResolvedObjectTypeImpl holder, long metaspaceMethod) {</span>
<span class="line-modified">116         this.metaspaceMethod = metaspaceMethod;</span>
117         this.holder = holder;
118 
119         HotSpotVMConfig config = config();
120         final long constMethod = getConstMethod();
121 
122         /*
123          * Get the constant pool from the metaspace method. Some methods (e.g. intrinsics for
124          * signature-polymorphic method handle methods) have their own constant pool instead of the
125          * one from their holder.
126          */
127         final long metaspaceConstantPool = UNSAFE.getAddress(constMethod + config.constMethodConstantsOffset);
128         if (metaspaceConstantPool == holder.getConstantPool().getMetaspaceConstantPool()) {
129             this.constantPool = holder.getConstantPool();
130         } else {
131             this.constantPool = compilerToVM().getConstantPool(this);
132         }
133 
134         final int signatureIndex = UNSAFE.getChar(constMethod + config.constMethodSignatureIndexOffset);
135         this.signature = (HotSpotSignature) constantPool.lookupSignature(signatureIndex);

136     }
137 
138     /**
139      * Returns a pointer to this method&#39;s constant method data structure (
140      * {@code Method::_constMethod}). This pointer isn&#39;t wrapped since it should be safe to use it
141      * within the context of this HotSpotResolvedJavaMethodImpl since the Method* and ConstMethod*
142      * are kept alive as a pair.
143      *
144      * @return pointer to this method&#39;s ConstMethod
145      */
146     private long getConstMethod() {
<span class="line-modified">147         assert metaspaceMethod != 0;</span>
<span class="line-removed">148         return UNSAFE.getAddress(metaspaceMethod + config().methodConstMethodOffset);</span>
149     }
150 
151     @Override
152     public String getName() {
153         if (nameCache == null) {
154             final int nameIndex = UNSAFE.getChar(getConstMethod() + config().constMethodNameIndexOffset);
155             nameCache = constantPool.lookupUtf8(nameIndex);
156         }
157         return nameCache;
158     }
159 
160     @Override
161     public boolean equals(Object obj) {
162         if (this == obj) {
163             return true;
164         }
165         if (obj instanceof HotSpotResolvedJavaMethodImpl) {
166             HotSpotResolvedJavaMethodImpl that = (HotSpotResolvedJavaMethodImpl) obj;
<span class="line-modified">167             return that.metaspaceMethod == metaspaceMethod;</span>
168         }
169         return false;
170     }
171 
172     @Override
173     public int hashCode() {
<span class="line-modified">174         return (int) metaspaceMethod;</span>
175     }
176 
177     /**
178      * Returns this method&#39;s flags ({@code Method::_flags}).
179      *
180      * @return flags of this method
181      */
182     private int getFlags() {
<span class="line-modified">183         return UNSAFE.getShort(metaspaceMethod + config().methodFlagsOffset);</span>
184     }
185 
186     /**
187      * Returns this method&#39;s constant method flags ({@code ConstMethod::_flags}).
188      *
189      * @return flags of this method&#39;s ConstMethod
190      */
191     private int getConstMethodFlags() {
192         return UNSAFE.getChar(getConstMethod() + config().constMethodFlagsOffset);
193     }
194 
195     @Override
196     public HotSpotResolvedObjectTypeImpl getDeclaringClass() {
197         return holder;
198     }
199 
200     /**
201      * Gets the address of the C++ Method object for this method.
202      */
203     public Constant getMetaspaceMethodConstant() {
204         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
205     }
206 








207     @Override
<span class="line-modified">208     public long getMetaspacePointer() {</span>
<span class="line-modified">209         return metaspaceMethod;</span>
210     }
211 
212     @Override
213     public Constant getEncoding() {
214         return getMetaspaceMethodConstant();
215     }
216 
217     /**
218      * Gets the complete set of modifiers for this method which includes the JVM specification
219      * modifiers as well as the HotSpot internal modifiers.
220      */
221     public int getAllModifiers() {
<span class="line-modified">222         return UNSAFE.getInt(metaspaceMethod + config().methodAccessFlagsOffset);</span>
223     }
224 
225     @Override
226     public int getModifiers() {
227         return getAllModifiers() &amp; jvmMethodModifiers();
228     }
229 
230     @Override
231     public boolean canBeStaticallyBound() {
<span class="line-modified">232         return (isFinal() || isPrivate() || isStatic() || holder.isLeaf()) &amp;&amp; isConcrete();</span>
233     }
234 
235     @Override
236     public byte[] getCode() {
237         if (getCodeSize() == 0) {
238             return null;
239         }
240         if (code == null &amp;&amp; holder.isLinked()) {
241             code = compilerToVM().getBytecode(this);
242             assert code.length == getCodeSize() : &quot;expected: &quot; + getCodeSize() + &quot;, actual: &quot; + code.length;
243         }
244         return code;
245     }
246 
247     @Override
248     public int getCodeSize() {
249         return UNSAFE.getChar(getConstMethod() + config().constMethodCodeSizeOffset);
250     }
251 
252     @Override
</pre>
<hr />
<pre>
260         final int exceptionTableLength = compilerToVM().getExceptionTableLength(this);
261         ExceptionHandler[] handlers = new ExceptionHandler[exceptionTableLength];
262         long exceptionTableElement = compilerToVM().getExceptionTableStart(this);
263 
264         for (int i = 0; i &lt; exceptionTableLength; i++) {
265             final int startPc = UNSAFE.getChar(exceptionTableElement + config.exceptionTableElementStartPcOffset);
266             final int endPc = UNSAFE.getChar(exceptionTableElement + config.exceptionTableElementEndPcOffset);
267             final int handlerPc = UNSAFE.getChar(exceptionTableElement + config.exceptionTableElementHandlerPcOffset);
268             int catchTypeIndex = UNSAFE.getChar(exceptionTableElement + config.exceptionTableElementCatchTypeIndexOffset);
269 
270             JavaType catchType;
271             if (catchTypeIndex == 0) {
272                 catchType = null;
273             } else {
274                 final int opcode = -1;  // opcode is not used
275                 catchType = constantPool.lookupType(catchTypeIndex, opcode);
276 
277                 // Check for Throwable which catches everything.
278                 if (catchType instanceof HotSpotResolvedObjectTypeImpl) {
279                     HotSpotResolvedObjectTypeImpl resolvedType = (HotSpotResolvedObjectTypeImpl) catchType;
<span class="line-modified">280                     if (resolvedType.mirror() == Throwable.class) {</span>
281                         catchTypeIndex = 0;
282                         catchType = null;
283                     }
284                 }
285             }
286             handlers[i] = new ExceptionHandler(startPc, endPc, handlerPc, catchTypeIndex, catchType);
287 
288             // Go to the next ExceptionTableElement
289             exceptionTableElement += config.exceptionTableElementSize;
290         }
291 
292         return handlers;
293     }
294 
295     /**
296      * Returns true if this method has a {@code CallerSensitive} annotation.
297      *
298      * @return true if CallerSensitive annotation present, false otherwise
299      */
300     @Override
</pre>
<hr />
<pre>
377     public int getMaxStackSize() {
378         if (isAbstract() || isNative()) {
379             return 0;
380         }
381         HotSpotVMConfig config = config();
382         return config.extraStackEntries + UNSAFE.getChar(getConstMethod() + config.constMethodMaxStackOffset);
383     }
384 
385     @Override
386     public StackTraceElement asStackTraceElement(int bci) {
387         if (bci &lt; 0 || bci &gt;= getCodeSize()) {
388             // HotSpot code can only construct stack trace elements for valid bcis
389             StackTraceElement ste = compilerToVM().getStackTraceElement(this, 0);
390             return new StackTraceElement(ste.getClassName(), ste.getMethodName(), ste.getFileName(), -1);
391         }
392         return compilerToVM().getStackTraceElement(this, bci);
393     }
394 
395     @Override
396     public ResolvedJavaMethod uniqueConcreteMethod(HotSpotResolvedObjectType receiver) {


397         if (receiver.isInterface()) {
398             // Cannot trust interfaces. Because of:
399             // interface I { void foo(); }
400             // class A { public void foo() {} }
401             // class B extends A implements I { }
402             // class C extends B { public void foo() { } }
403             // class D extends B { }
404             // Would lead to identify C.foo() as the unique concrete method for I.foo() without
405             // seeing A.foo().
406             return null;
407         }

408         if (this.isDefault()) {
409             // CHA for default methods doesn&#39;t work and may crash the VM
410             return null;
411         }
412         return compilerToVM().findUniqueConcreteMethod(((HotSpotResolvedObjectTypeImpl) receiver), this);
413     }
414 
415     @Override
416     public HotSpotSignature getSignature() {
417         return signature;
418     }
419 
420     /**
421      * Gets the value of {@code Method::_code}.
422      *
423      * @return the value of {@code Method::_code}
424      */
425     private long getCompiledCode() {
426         HotSpotVMConfig config = config();
<span class="line-modified">427         return UNSAFE.getAddress(metaspaceMethod + config.methodCodeOffset);</span>
428     }
429 
430     /**
431      * Returns whether this method has compiled code.
432      *
433      * @return true if this method has compiled code, false otherwise
434      */
435     @Override
436     public boolean hasCompiledCode() {
437         return getCompiledCode() != 0L;
438     }
439 
440     /**
441      * @param level
442      * @return true if the currently installed code was generated at {@code level}.
443      */
444     @Override
445     public boolean hasCompiledCodeAtLevel(int level) {
446         long compiledCode = getCompiledCode();
447         if (compiledCode != 0) {
448             return UNSAFE.getInt(compiledCode + config().nmethodCompLevelOffset) == level;
449         }
450         return false;
451     }
452 
453     @Override
454     public ProfilingInfo getProfilingInfo(boolean includeNormal, boolean includeOSR) {
455         ProfilingInfo info;
456 
457         if (Option.UseProfilingInformation.getBoolean() &amp;&amp; methodData == null) {
<span class="line-modified">458             long metaspaceMethodData = UNSAFE.getAddress(metaspaceMethod + config().methodDataOffset);</span>
459             if (metaspaceMethodData != 0) {
460                 methodData = new HotSpotMethodData(metaspaceMethodData, this);
461                 String methodDataFilter = Option.TraceMethodDataFilter.getString();
462                 if (methodDataFilter != null &amp;&amp; this.format(&quot;%H.%n&quot;).contains(methodDataFilter)) {
<span class="line-modified">463                     System.out.println(methodData.toString());</span>


464                 }
465             }
466         }
467 
468         if (methodData == null || (!methodData.hasNormalData() &amp;&amp; !methodData.hasExtraData())) {
469             // Be optimistic and return false for exceptionSeen. A methodDataOop is allocated in
470             // case of a deoptimization.
471             info = DefaultProfilingInfo.get(TriState.FALSE);
472         } else {
473             info = new HotSpotProfilingInfo(methodData, this, includeNormal, includeOSR);
474         }
475         return info;
476     }
477 
478     @Override
479     public void reprofile() {
480         compilerToVM().reprofile(this);
481     }
482 
483     @Override
484     public ConstantPool getConstantPool() {
485         return constantPool;
486     }
487 
488     @Override
489     public Parameter[] getParameters() {
490         if (signature.getParameterCount(false) == 0) {
491             return new ResolvedJavaMethod.Parameter[0];
492         }
<span class="line-modified">493         java.lang.reflect.Parameter[] javaParameters = toJava().getParameters();</span>
<span class="line-removed">494         Parameter[] res = new Parameter[javaParameters.length];</span>
<span class="line-removed">495         for (int i = 0; i &lt; res.length; i++) {</span>
<span class="line-removed">496             java.lang.reflect.Parameter src = javaParameters[i];</span>
<span class="line-removed">497             String paramName = src.isNamePresent() ? src.getName() : null;</span>
<span class="line-removed">498             res[i] = new Parameter(paramName, src.getModifiers(), this, i);</span>
<span class="line-removed">499         }</span>
<span class="line-removed">500         return res;</span>
501     }
502 
503     @Override
504     public Annotation[][] getParameterAnnotations() {
<span class="line-modified">505         if ((getConstMethodFlags() &amp; config().constMethodHasParameterAnnotations) == 0) {</span>
506             return new Annotation[signature.getParameterCount(false)][0];
507         }
<span class="line-modified">508         return toJava().getParameterAnnotations();</span>
509     }
510 
511     @Override
512     public Annotation[] getAnnotations() {
<span class="line-modified">513         if ((getConstMethodFlags() &amp; config().constMethodHasMethodAnnotations) == 0) {</span>
514             return new Annotation[0];
515         }
<span class="line-modified">516         return toJava().getAnnotations();</span>
517     }
518 
519     @Override
520     public Annotation[] getDeclaredAnnotations() {
<span class="line-modified">521         if ((getConstMethodFlags() &amp; config().constMethodHasMethodAnnotations) == 0) {</span>
522             return new Annotation[0];
523         }
<span class="line-modified">524         return toJava().getDeclaredAnnotations();</span>
525     }
526 
527     @Override
528     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="line-modified">529         if ((getConstMethodFlags() &amp; config().constMethodHasMethodAnnotations) == 0) {</span>
530             return null;
531         }
<span class="line-modified">532         return toJava().getAnnotation(annotationClass);</span>
533     }
534 
535     @Override
536     public boolean isBridge() {
537         return (BRIDGE &amp; getModifiers()) != 0;
538     }
539 
540     @Override
541     public boolean isSynthetic() {
542         return (SYNTHETIC &amp; getModifiers()) != 0;
543     }
544 
545     @Override
546     public boolean isVarArgs() {
547         return (VARARGS &amp; getModifiers()) != 0;
548     }
549 
550     @Override
551     public boolean isDefault() {
552         // Copied from java.lang.Method.isDefault()
553         int mask = Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC;
554         return ((getModifiers() &amp; mask) == Modifier.PUBLIC) &amp;&amp; getDeclaringClass().isInterface();
555     }
556 
557     @Override
558     public Type[] getGenericParameterTypes() {
559         if (isClassInitializer()) {
560             return new Type[0];
561         }
<span class="line-modified">562         return toJava().getGenericParameterTypes();</span>
<span class="line-removed">563     }</span>
<span class="line-removed">564 </span>
<span class="line-removed">565     private Executable toJava() {</span>
<span class="line-removed">566         if (toJavaCache == null) {</span>
<span class="line-removed">567             assert !isClassInitializer() : this;</span>
<span class="line-removed">568             synchronized (this) {</span>
<span class="line-removed">569                 if (toJavaCache == null) {</span>
<span class="line-removed">570                     toJavaCache = compilerToVM().asReflectionExecutable(this);</span>
<span class="line-removed">571                 }</span>
<span class="line-removed">572             }</span>
<span class="line-removed">573         }</span>
<span class="line-removed">574         return toJavaCache;</span>
575     }
576 
577     @Override
578     public boolean canBeInlined() {
579         if (hasNeverInlineDirective()) {
580             return false;
581         }
582         return compilerToVM().isCompilable(this);
583     }
584 
585     @Override
586     public boolean hasNeverInlineDirective() {
587         return compilerToVM().hasNeverInlineDirective(this);
588     }
589 
590     @Override
591     public boolean shouldBeInlined() {
592         if (isForceInline()) {
593             return true;
594         }
</pre>
<hr />
<pre>
681         if (!holder.isLinked()) {
682             return config().invalidVtableIndex;
683         }
684         if (holder.isInterface()) {
685             if (resolved.isInterface() || !resolved.isLinked()) {
686                 return config().invalidVtableIndex;
687             }
688             return getVtableIndexForInterfaceMethod(resolved);
689         }
690         return getVtableIndex();
691     }
692 
693     /**
694      * Returns this method&#39;s virtual table index.
695      *
696      * @return virtual table index
697      */
698     private int getVtableIndex() {
699         assert !holder.isInterface();
700         HotSpotVMConfig config = config();
<span class="line-modified">701         int result = UNSAFE.getInt(metaspaceMethod + config.methodVtableIndexOffset);</span>
702         assert result &gt;= config.nonvirtualVtableIndex : &quot;must be linked&quot;;
703         return result;
704     }
705 
706     private int getVtableIndexForInterfaceMethod(ResolvedJavaType resolved) {
707         HotSpotResolvedObjectTypeImpl hotspotType = (HotSpotResolvedObjectTypeImpl) resolved;
708         return compilerToVM().getVtableIndexForInterfaceMethod(hotspotType, this);
709     }
710 
<span class="line-removed">711     /**</span>
<span class="line-removed">712      * The {@link SpeculationLog} for methods compiled by JVMCI hang off this per-declaring-type</span>
<span class="line-removed">713      * {@link ClassValue}. The raw Method* value is safe to use as a key in the map as a) it is</span>
<span class="line-removed">714      * never moves and b) we never read from it.</span>
<span class="line-removed">715      * &lt;p&gt;</span>
<span class="line-removed">716      * One implication is that we will preserve {@link SpeculationLog}s for methods that have been</span>
<span class="line-removed">717      * redefined via class redefinition. It&#39;s tempting to periodically flush such logs but we cannot</span>
<span class="line-removed">718      * read the JVM_ACC_IS_OBSOLETE bit (or anything else) via the raw pointer as obsoleted methods</span>
<span class="line-removed">719      * are subject to clean up and deletion (see InstanceKlass::purge_previous_versions_internal).</span>
<span class="line-removed">720      */</span>
<span class="line-removed">721     private static final ClassValue&lt;Map&lt;Long, SpeculationLog&gt;&gt; SpeculationLogs = new ClassValue&lt;&gt;() {</span>
<span class="line-removed">722         @Override</span>
<span class="line-removed">723         protected Map&lt;Long, SpeculationLog&gt; computeValue(java.lang.Class&lt;?&gt; type) {</span>
<span class="line-removed">724             return new HashMap&lt;&gt;(4);</span>
<span class="line-removed">725         }</span>
<span class="line-removed">726     };</span>
<span class="line-removed">727 </span>
728     @Override
729     public SpeculationLog getSpeculationLog() {
<span class="line-modified">730         Map&lt;Long, SpeculationLog&gt; map = SpeculationLogs.get(holder.mirror());</span>
<span class="line-modified">731         synchronized (map) {</span>
<span class="line-removed">732             SpeculationLog log = map.get(this.metaspaceMethod);</span>
<span class="line-removed">733             if (log == null) {</span>
<span class="line-removed">734                 log = new HotSpotSpeculationLog();</span>
<span class="line-removed">735                 map.put(metaspaceMethod, log);</span>
<span class="line-removed">736             }</span>
<span class="line-removed">737             return log;</span>
<span class="line-removed">738         }</span>
739     }
740 
741     @Override
742     public int intrinsicId() {
743         HotSpotVMConfig config = config();
<span class="line-modified">744         return UNSAFE.getChar(metaspaceMethod + config.methodIntrinsicIdOffset);</span>
745     }
746 
747     @Override
748     public boolean isIntrinsicCandidate() {
749         return (getFlags() &amp; config().methodFlagsIntrinsicCandidate) != 0;
750     }
751 
752     /**
753      * Allocates a compile id for this method by asking the VM for one.
754      *
755      * @param entryBCI entry bci
756      * @return compile id
757      */
758     @Override
759     public int allocateCompileId(int entryBCI) {
760         return compilerToVM().allocateCompileId(this, entryBCI);
761     }
762 
763     @Override
764     public boolean hasCodeAtLevel(int entryBCI, int level) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
 26 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 27 import static jdk.vm.ci.hotspot.HotSpotModifiers.BRIDGE;
 28 import static jdk.vm.ci.hotspot.HotSpotModifiers.SYNTHETIC;
 29 import static jdk.vm.ci.hotspot.HotSpotModifiers.VARARGS;
 30 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmMethodModifiers;
 31 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
 32 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 33 
 34 import java.lang.annotation.Annotation;
 35 import java.lang.reflect.Executable;
 36 import java.lang.reflect.Modifier;
 37 import java.lang.reflect.Type;


 38 
 39 import jdk.vm.ci.common.JVMCIError;
 40 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.Option;
 41 import jdk.vm.ci.meta.Constant;
 42 import jdk.vm.ci.meta.ConstantPool;
 43 import jdk.vm.ci.meta.DefaultProfilingInfo;
 44 import jdk.vm.ci.meta.ExceptionHandler;
 45 import jdk.vm.ci.meta.JavaMethod;
 46 import jdk.vm.ci.meta.JavaType;
 47 import jdk.vm.ci.meta.LineNumberTable;
 48 import jdk.vm.ci.meta.Local;
 49 import jdk.vm.ci.meta.LocalVariableTable;
 50 import jdk.vm.ci.meta.ProfilingInfo;
 51 import jdk.vm.ci.meta.ResolvedJavaMethod;
 52 import jdk.vm.ci.meta.ResolvedJavaType;
 53 import jdk.vm.ci.meta.SpeculationLog;
 54 import jdk.vm.ci.meta.TriState;
 55 
 56 /**
 57  * Implementation of {@link JavaMethod} for resolved HotSpot methods.
 58  */
<span class="line-modified"> 59 final class HotSpotResolvedJavaMethodImpl extends HotSpotMethod implements HotSpotResolvedJavaMethod, MetaspaceHandleObject {</span>
 60 
 61     /**
<span class="line-modified"> 62      * Handle to the metaspace {@code Method} object. The handle is in</span>
<span class="line-added"> 63      * {@code JVMCI::_metadata_handles}.</span>
 64      */
<span class="line-modified"> 65     private final long metadataHandle;</span>
 66 
 67     private final HotSpotResolvedObjectTypeImpl holder;
 68     private final HotSpotConstantPool constantPool;
<span class="line-modified"> 69     final HotSpotSignature signature;</span>
 70     private HotSpotMethodData methodData;
 71     private byte[] code;
 72 
 73     /**
<span class="line-modified"> 74      * Cache for {@link HotSpotJDKReflection#getMethod}.</span>
 75      */
<span class="line-modified"> 76     volatile Executable toJavaCache;</span>
 77 
 78     /**
 79      * Only 30% of {@link HotSpotResolvedJavaMethodImpl}s have their name accessed so compute it
 80      * lazily and cache it.
 81      */
 82     private String nameCache;
 83 
 84     /**
 85      * Gets the holder of a HotSpot metaspace method native object.
 86      *
<span class="line-modified"> 87      * @param metaspaceHandle a handle to a metaspace Method object</span>
 88      * @return the {@link ResolvedJavaType} corresponding to the holder of the
 89      *         {@code metaspaceMethod}
 90      */
<span class="line-modified"> 91     private static HotSpotResolvedObjectTypeImpl getHolder(long metaspaceHandle) {</span>
 92         HotSpotVMConfig config = config();
<span class="line-added"> 93         long metaspaceMethod = UNSAFE.getLong(metaspaceHandle);</span>
<span class="line-added"> 94         assert metaspaceMethod != 0 : metaspaceHandle;</span>
 95         final long metaspaceConstMethod = UNSAFE.getAddress(metaspaceMethod + config.methodConstMethodOffset);
 96         final long metaspaceConstantPool = UNSAFE.getAddress(metaspaceConstMethod + config.constMethodConstantsOffset);
<span class="line-modified"> 97         HotSpotResolvedObjectTypeImpl result = compilerToVM().getResolvedJavaType(metaspaceConstantPool + config.constantPoolHolderOffset, false);</span>
<span class="line-added"> 98         assert result != null;</span>
<span class="line-added"> 99         return result;</span>
100     }
101 
102     /**
103      * Gets the JVMCI mirror from a HotSpot method. The VM is responsible for ensuring that the
<span class="line-modified">104      * Method* is kept alive for the duration of this call and the {@link HotSpotJVMCIRuntime} keeps</span>
<span class="line-modified">105      * it alive after that.</span>
<span class="line-modified">106      * &lt;p&gt;</span>
107      * Called from the VM.
108      *
<span class="line-modified">109      * @param metaspaceHandle a handle to metaspace Method object</span>
110      * @return the {@link ResolvedJavaMethod} corresponding to {@code metaspaceMethod}
111      */
112     @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">113     @VMEntryPoint</span>
<span class="line-modified">114     private static HotSpotResolvedJavaMethod fromMetaspace(long metaspaceHandle) {</span>
<span class="line-modified">115         HotSpotResolvedObjectTypeImpl holder = getHolder(metaspaceHandle);</span>
<span class="line-added">116         return holder.createMethod(metaspaceHandle);</span>
117     }
118 
<span class="line-modified">119     HotSpotResolvedJavaMethodImpl(HotSpotResolvedObjectTypeImpl holder, long metaspaceHandle) {</span>
<span class="line-modified">120         this.metadataHandle = metaspaceHandle;</span>
121         this.holder = holder;
122 
123         HotSpotVMConfig config = config();
124         final long constMethod = getConstMethod();
125 
126         /*
127          * Get the constant pool from the metaspace method. Some methods (e.g. intrinsics for
128          * signature-polymorphic method handle methods) have their own constant pool instead of the
129          * one from their holder.
130          */
131         final long metaspaceConstantPool = UNSAFE.getAddress(constMethod + config.constMethodConstantsOffset);
132         if (metaspaceConstantPool == holder.getConstantPool().getMetaspaceConstantPool()) {
133             this.constantPool = holder.getConstantPool();
134         } else {
135             this.constantPool = compilerToVM().getConstantPool(this);
136         }
137 
138         final int signatureIndex = UNSAFE.getChar(constMethod + config.constMethodSignatureIndexOffset);
139         this.signature = (HotSpotSignature) constantPool.lookupSignature(signatureIndex);
<span class="line-added">140         HandleCleaner.create(this, metaspaceHandle);</span>
141     }
142 
143     /**
144      * Returns a pointer to this method&#39;s constant method data structure (
145      * {@code Method::_constMethod}). This pointer isn&#39;t wrapped since it should be safe to use it
146      * within the context of this HotSpotResolvedJavaMethodImpl since the Method* and ConstMethod*
147      * are kept alive as a pair.
148      *
149      * @return pointer to this method&#39;s ConstMethod
150      */
151     private long getConstMethod() {
<span class="line-modified">152         return UNSAFE.getAddress(getMetaspaceMethod() + config().methodConstMethodOffset);</span>

153     }
154 
155     @Override
156     public String getName() {
157         if (nameCache == null) {
158             final int nameIndex = UNSAFE.getChar(getConstMethod() + config().constMethodNameIndexOffset);
159             nameCache = constantPool.lookupUtf8(nameIndex);
160         }
161         return nameCache;
162     }
163 
164     @Override
165     public boolean equals(Object obj) {
166         if (this == obj) {
167             return true;
168         }
169         if (obj instanceof HotSpotResolvedJavaMethodImpl) {
170             HotSpotResolvedJavaMethodImpl that = (HotSpotResolvedJavaMethodImpl) obj;
<span class="line-modified">171             return that.getMetaspaceMethod() == getMetaspaceMethod();</span>
172         }
173         return false;
174     }
175 
176     @Override
177     public int hashCode() {
<span class="line-modified">178         return (int) getMetaspaceMethod();</span>
179     }
180 
181     /**
182      * Returns this method&#39;s flags ({@code Method::_flags}).
183      *
184      * @return flags of this method
185      */
186     private int getFlags() {
<span class="line-modified">187         return UNSAFE.getShort(getMetaspaceMethod() + config().methodFlagsOffset);</span>
188     }
189 
190     /**
191      * Returns this method&#39;s constant method flags ({@code ConstMethod::_flags}).
192      *
193      * @return flags of this method&#39;s ConstMethod
194      */
195     private int getConstMethodFlags() {
196         return UNSAFE.getChar(getConstMethod() + config().constMethodFlagsOffset);
197     }
198 
199     @Override
200     public HotSpotResolvedObjectTypeImpl getDeclaringClass() {
201         return holder;
202     }
203 
204     /**
205      * Gets the address of the C++ Method object for this method.
206      */
207     public Constant getMetaspaceMethodConstant() {
208         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
209     }
210 
<span class="line-added">211     long getMetaspaceMethod() {</span>
<span class="line-added">212         long metaspacePointer = getMetaspacePointer();</span>
<span class="line-added">213         if (metaspacePointer == 0) {</span>
<span class="line-added">214             throw new NullPointerException(&quot;Method* is null&quot;);</span>
<span class="line-added">215         }</span>
<span class="line-added">216         return metaspacePointer;</span>
<span class="line-added">217     }</span>
<span class="line-added">218 </span>
219     @Override
<span class="line-modified">220     public long getMetadataHandle() {</span>
<span class="line-modified">221         return metadataHandle;</span>
222     }
223 
224     @Override
225     public Constant getEncoding() {
226         return getMetaspaceMethodConstant();
227     }
228 
229     /**
230      * Gets the complete set of modifiers for this method which includes the JVM specification
231      * modifiers as well as the HotSpot internal modifiers.
232      */
233     public int getAllModifiers() {
<span class="line-modified">234         return UNSAFE.getInt(getMetaspaceMethod() + config().methodAccessFlagsOffset);</span>
235     }
236 
237     @Override
238     public int getModifiers() {
239         return getAllModifiers() &amp; jvmMethodModifiers();
240     }
241 
242     @Override
243     public boolean canBeStaticallyBound() {
<span class="line-modified">244         return (isFinal() || isPrivate() || isStatic() || holder.isLeaf() || isConstructor()) &amp;&amp; isConcrete();</span>
245     }
246 
247     @Override
248     public byte[] getCode() {
249         if (getCodeSize() == 0) {
250             return null;
251         }
252         if (code == null &amp;&amp; holder.isLinked()) {
253             code = compilerToVM().getBytecode(this);
254             assert code.length == getCodeSize() : &quot;expected: &quot; + getCodeSize() + &quot;, actual: &quot; + code.length;
255         }
256         return code;
257     }
258 
259     @Override
260     public int getCodeSize() {
261         return UNSAFE.getChar(getConstMethod() + config().constMethodCodeSizeOffset);
262     }
263 
264     @Override
</pre>
<hr />
<pre>
272         final int exceptionTableLength = compilerToVM().getExceptionTableLength(this);
273         ExceptionHandler[] handlers = new ExceptionHandler[exceptionTableLength];
274         long exceptionTableElement = compilerToVM().getExceptionTableStart(this);
275 
276         for (int i = 0; i &lt; exceptionTableLength; i++) {
277             final int startPc = UNSAFE.getChar(exceptionTableElement + config.exceptionTableElementStartPcOffset);
278             final int endPc = UNSAFE.getChar(exceptionTableElement + config.exceptionTableElementEndPcOffset);
279             final int handlerPc = UNSAFE.getChar(exceptionTableElement + config.exceptionTableElementHandlerPcOffset);
280             int catchTypeIndex = UNSAFE.getChar(exceptionTableElement + config.exceptionTableElementCatchTypeIndexOffset);
281 
282             JavaType catchType;
283             if (catchTypeIndex == 0) {
284                 catchType = null;
285             } else {
286                 final int opcode = -1;  // opcode is not used
287                 catchType = constantPool.lookupType(catchTypeIndex, opcode);
288 
289                 // Check for Throwable which catches everything.
290                 if (catchType instanceof HotSpotResolvedObjectTypeImpl) {
291                     HotSpotResolvedObjectTypeImpl resolvedType = (HotSpotResolvedObjectTypeImpl) catchType;
<span class="line-modified">292                     if (resolvedType.equals(runtime().getJavaLangThrowable())) {</span>
293                         catchTypeIndex = 0;
294                         catchType = null;
295                     }
296                 }
297             }
298             handlers[i] = new ExceptionHandler(startPc, endPc, handlerPc, catchTypeIndex, catchType);
299 
300             // Go to the next ExceptionTableElement
301             exceptionTableElement += config.exceptionTableElementSize;
302         }
303 
304         return handlers;
305     }
306 
307     /**
308      * Returns true if this method has a {@code CallerSensitive} annotation.
309      *
310      * @return true if CallerSensitive annotation present, false otherwise
311      */
312     @Override
</pre>
<hr />
<pre>
389     public int getMaxStackSize() {
390         if (isAbstract() || isNative()) {
391             return 0;
392         }
393         HotSpotVMConfig config = config();
394         return config.extraStackEntries + UNSAFE.getChar(getConstMethod() + config.constMethodMaxStackOffset);
395     }
396 
397     @Override
398     public StackTraceElement asStackTraceElement(int bci) {
399         if (bci &lt; 0 || bci &gt;= getCodeSize()) {
400             // HotSpot code can only construct stack trace elements for valid bcis
401             StackTraceElement ste = compilerToVM().getStackTraceElement(this, 0);
402             return new StackTraceElement(ste.getClassName(), ste.getMethodName(), ste.getFileName(), -1);
403         }
404         return compilerToVM().getStackTraceElement(this, bci);
405     }
406 
407     @Override
408     public ResolvedJavaMethod uniqueConcreteMethod(HotSpotResolvedObjectType receiver) {
<span class="line-added">409         assert !canBeStaticallyBound() : this;</span>
<span class="line-added">410 </span>
411         if (receiver.isInterface()) {
412             // Cannot trust interfaces. Because of:
413             // interface I { void foo(); }
414             // class A { public void foo() {} }
415             // class B extends A implements I { }
416             // class C extends B { public void foo() { } }
417             // class D extends B { }
418             // Would lead to identify C.foo() as the unique concrete method for I.foo() without
419             // seeing A.foo().
420             return null;
421         }
<span class="line-added">422         assert !receiver.isLinked() || isInVirtualMethodTable(receiver);</span>
423         if (this.isDefault()) {
424             // CHA for default methods doesn&#39;t work and may crash the VM
425             return null;
426         }
427         return compilerToVM().findUniqueConcreteMethod(((HotSpotResolvedObjectTypeImpl) receiver), this);
428     }
429 
430     @Override
431     public HotSpotSignature getSignature() {
432         return signature;
433     }
434 
435     /**
436      * Gets the value of {@code Method::_code}.
437      *
438      * @return the value of {@code Method::_code}
439      */
440     private long getCompiledCode() {
441         HotSpotVMConfig config = config();
<span class="line-modified">442         return UNSAFE.getAddress(getMetaspaceMethod() + config.methodCodeOffset);</span>
443     }
444 
445     /**
446      * Returns whether this method has compiled code.
447      *
448      * @return true if this method has compiled code, false otherwise
449      */
450     @Override
451     public boolean hasCompiledCode() {
452         return getCompiledCode() != 0L;
453     }
454 
455     /**
456      * @param level
457      * @return true if the currently installed code was generated at {@code level}.
458      */
459     @Override
460     public boolean hasCompiledCodeAtLevel(int level) {
461         long compiledCode = getCompiledCode();
462         if (compiledCode != 0) {
463             return UNSAFE.getInt(compiledCode + config().nmethodCompLevelOffset) == level;
464         }
465         return false;
466     }
467 
468     @Override
469     public ProfilingInfo getProfilingInfo(boolean includeNormal, boolean includeOSR) {
470         ProfilingInfo info;
471 
472         if (Option.UseProfilingInformation.getBoolean() &amp;&amp; methodData == null) {
<span class="line-modified">473             long metaspaceMethodData = UNSAFE.getAddress(getMetaspaceMethod() + config().methodDataOffset);</span>
474             if (metaspaceMethodData != 0) {
475                 methodData = new HotSpotMethodData(metaspaceMethodData, this);
476                 String methodDataFilter = Option.TraceMethodDataFilter.getString();
477                 if (methodDataFilter != null &amp;&amp; this.format(&quot;%H.%n&quot;).contains(methodDataFilter)) {
<span class="line-modified">478                     String line = methodData.toString() + System.lineSeparator();</span>
<span class="line-added">479                     byte[] lineBytes = line.getBytes();</span>
<span class="line-added">480                     CompilerToVM.compilerToVM().writeDebugOutput(lineBytes, 0, lineBytes.length, true, true);</span>
481                 }
482             }
483         }
484 
485         if (methodData == null || (!methodData.hasNormalData() &amp;&amp; !methodData.hasExtraData())) {
486             // Be optimistic and return false for exceptionSeen. A methodDataOop is allocated in
487             // case of a deoptimization.
488             info = DefaultProfilingInfo.get(TriState.FALSE);
489         } else {
490             info = new HotSpotProfilingInfo(methodData, this, includeNormal, includeOSR);
491         }
492         return info;
493     }
494 
495     @Override
496     public void reprofile() {
497         compilerToVM().reprofile(this);
498     }
499 
500     @Override
501     public ConstantPool getConstantPool() {
502         return constantPool;
503     }
504 
505     @Override
506     public Parameter[] getParameters() {
507         if (signature.getParameterCount(false) == 0) {
508             return new ResolvedJavaMethod.Parameter[0];
509         }
<span class="line-modified">510         return runtime().reflection.getParameters(this);</span>







511     }
512 
513     @Override
514     public Annotation[][] getParameterAnnotations() {
<span class="line-modified">515         if ((getConstMethodFlags() &amp; config().constMethodHasParameterAnnotations) == 0 || isClassInitializer()) {</span>
516             return new Annotation[signature.getParameterCount(false)][0];
517         }
<span class="line-modified">518         return runtime().reflection.getParameterAnnotations(this);</span>
519     }
520 
521     @Override
522     public Annotation[] getAnnotations() {
<span class="line-modified">523         if ((getConstMethodFlags() &amp; config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {</span>
524             return new Annotation[0];
525         }
<span class="line-modified">526         return runtime().reflection.getMethodAnnotations(this);</span>
527     }
528 
529     @Override
530     public Annotation[] getDeclaredAnnotations() {
<span class="line-modified">531         if ((getConstMethodFlags() &amp; config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {</span>
532             return new Annotation[0];
533         }
<span class="line-modified">534         return runtime().reflection.getMethodDeclaredAnnotations(this);</span>
535     }
536 
537     @Override
538     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="line-modified">539         if ((getConstMethodFlags() &amp; config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {</span>
540             return null;
541         }
<span class="line-modified">542         return runtime().reflection.getMethodAnnotation(this, annotationClass);</span>
543     }
544 
545     @Override
546     public boolean isBridge() {
547         return (BRIDGE &amp; getModifiers()) != 0;
548     }
549 
550     @Override
551     public boolean isSynthetic() {
552         return (SYNTHETIC &amp; getModifiers()) != 0;
553     }
554 
555     @Override
556     public boolean isVarArgs() {
557         return (VARARGS &amp; getModifiers()) != 0;
558     }
559 
560     @Override
561     public boolean isDefault() {
562         // Copied from java.lang.Method.isDefault()
563         int mask = Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC;
564         return ((getModifiers() &amp; mask) == Modifier.PUBLIC) &amp;&amp; getDeclaringClass().isInterface();
565     }
566 
567     @Override
568     public Type[] getGenericParameterTypes() {
569         if (isClassInitializer()) {
570             return new Type[0];
571         }
<span class="line-modified">572         return runtime().reflection.getGenericParameterTypes(this);</span>












573     }
574 
575     @Override
576     public boolean canBeInlined() {
577         if (hasNeverInlineDirective()) {
578             return false;
579         }
580         return compilerToVM().isCompilable(this);
581     }
582 
583     @Override
584     public boolean hasNeverInlineDirective() {
585         return compilerToVM().hasNeverInlineDirective(this);
586     }
587 
588     @Override
589     public boolean shouldBeInlined() {
590         if (isForceInline()) {
591             return true;
592         }
</pre>
<hr />
<pre>
679         if (!holder.isLinked()) {
680             return config().invalidVtableIndex;
681         }
682         if (holder.isInterface()) {
683             if (resolved.isInterface() || !resolved.isLinked()) {
684                 return config().invalidVtableIndex;
685             }
686             return getVtableIndexForInterfaceMethod(resolved);
687         }
688         return getVtableIndex();
689     }
690 
691     /**
692      * Returns this method&#39;s virtual table index.
693      *
694      * @return virtual table index
695      */
696     private int getVtableIndex() {
697         assert !holder.isInterface();
698         HotSpotVMConfig config = config();
<span class="line-modified">699         int result = UNSAFE.getInt(getMetaspaceMethod() + config.methodVtableIndexOffset);</span>
700         assert result &gt;= config.nonvirtualVtableIndex : &quot;must be linked&quot;;
701         return result;
702     }
703 
704     private int getVtableIndexForInterfaceMethod(ResolvedJavaType resolved) {
705         HotSpotResolvedObjectTypeImpl hotspotType = (HotSpotResolvedObjectTypeImpl) resolved;
706         return compilerToVM().getVtableIndexForInterfaceMethod(hotspotType, this);
707     }
708 

















709     @Override
710     public SpeculationLog getSpeculationLog() {
<span class="line-modified">711         long address = compilerToVM().getFailedSpeculationsAddress(this);</span>
<span class="line-modified">712         return new HotSpotSpeculationLog(address);</span>







713     }
714 
715     @Override
716     public int intrinsicId() {
717         HotSpotVMConfig config = config();
<span class="line-modified">718         return UNSAFE.getChar(getMetaspaceMethod() + config.methodIntrinsicIdOffset);</span>
719     }
720 
721     @Override
722     public boolean isIntrinsicCandidate() {
723         return (getFlags() &amp; config().methodFlagsIntrinsicCandidate) != 0;
724     }
725 
726     /**
727      * Allocates a compile id for this method by asking the VM for one.
728      *
729      * @param entryBCI entry bci
730      * @return compile id
731      */
732     @Override
733     public int allocateCompileId(int entryBCI) {
734         return compilerToVM().allocateCompileId(this, entryBCI);
735     }
736 
737     @Override
738     public boolean hasCodeAtLevel(int entryBCI, int level) {
</pre>
</td>
</tr>
</table>
<center><a href="HotSpotResolvedJavaFieldImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotResolvedJavaType.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
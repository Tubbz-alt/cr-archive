<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMemoryAccessProviderImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
<a name="2" id="anc2"></a><span class="line-added"> 25 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;</span>
 26 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 27 
<a name="3" id="anc3"></a>


 28 import jdk.vm.ci.meta.Constant;
 29 import jdk.vm.ci.meta.JavaConstant;
 30 import jdk.vm.ci.meta.JavaKind;
 31 import jdk.vm.ci.meta.MemoryAccessProvider;
<a name="4" id="anc4"></a>
 32 import jdk.vm.ci.meta.PrimitiveConstant;
<a name="5" id="anc5"></a>

 33 
 34 /**
 35  * HotSpot implementation of {@link MemoryAccessProvider}.
 36  */
 37 class HotSpotMemoryAccessProviderImpl implements HotSpotMemoryAccessProvider {
 38 
 39     protected final HotSpotJVMCIRuntime runtime;
 40 
 41     HotSpotMemoryAccessProviderImpl(HotSpotJVMCIRuntime runtime) {
 42         this.runtime = runtime;
 43     }
 44 
 45     /**
 46      * Gets the object boxed by {@code base} that is about to have a value of kind {@code kind} read
 47      * from it at the offset {@code displacement}.
 48      *
 49      * @param base constant value containing the base address for a pending read
 50      * @return {@code null} if {@code base} does not box an object otherwise the object boxed in
 51      *         {@code base}
 52      */
<a name="6" id="anc6"></a><span class="line-modified"> 53     private static HotSpotObjectConstantImpl asObject(Constant base, JavaKind kind, long displacement) {</span>
 54         if (base instanceof HotSpotObjectConstantImpl) {
 55             HotSpotObjectConstantImpl constant = (HotSpotObjectConstantImpl) base;
 56             HotSpotResolvedObjectType type = constant.getType();
<a name="7" id="anc7"></a><span class="line-modified"> 57             runtime().reflection.checkRead(constant, kind, displacement, type);</span>
<span class="line-modified"> 58             return constant;</span>

 59         }
 60         return null;
 61     }
 62 
<a name="8" id="anc8"></a><span class="line-modified"> 63     private boolean isValidObjectFieldDisplacement(Constant base, long displacement) {</span>
<span class="line-modified"> 64         if (base instanceof HotSpotMetaspaceConstant) {</span>
<span class="line-modified"> 65             MetaspaceObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
<span class="line-modified"> 66             if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {</span>
<span class="line-modified"> 67                 if (displacement == runtime.getConfig().javaMirrorOffset) {</span>
<span class="line-modified"> 68                     // Klass::_java_mirror is valid for all Klass* values</span>
<span class="line-modified"> 69                     return true;</span>
































 70                 }
<a name="9" id="anc9"></a>

 71             } else {
<a name="10" id="anc10"></a><span class="line-modified"> 72                 throw new IllegalArgumentException(String.valueOf(metaspaceObject));</span>




















 73             }
 74         }
<a name="11" id="anc11"></a><span class="line-modified"> 75         return false;</span>
 76     }
 77 
 78     private static long asRawPointer(Constant base) {
 79         if (base instanceof HotSpotMetaspaceConstantImpl) {
<a name="12" id="anc12"></a><span class="line-modified"> 80             MetaspaceObject meta = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
 81             return meta.getMetaspacePointer();
 82         } else if (base instanceof PrimitiveConstant) {
 83             PrimitiveConstant prim = (PrimitiveConstant) base;
 84             if (prim.getJavaKind().isNumericInteger()) {
 85                 return prim.asLong();
 86             }
 87         }
 88         throw new IllegalArgumentException(String.valueOf(base));
 89     }
 90 
<a name="13" id="anc13"></a><span class="line-modified"> 91     private static long readRawValue(Constant baseConstant, long displacement, JavaKind kind, int bits) {</span>
<span class="line-modified"> 92         HotSpotObjectConstantImpl base = asObject(baseConstant, kind, displacement);</span>
 93         if (base != null) {
 94             switch (bits) {
 95                 case Byte.SIZE:
<a name="14" id="anc14"></a><span class="line-modified"> 96                     return runtime().reflection.getByte(base, displacement);</span>
 97                 case Short.SIZE:
<a name="15" id="anc15"></a><span class="line-modified"> 98                     return runtime().reflection.getShort(base, displacement);</span>
 99                 case Integer.SIZE:
<a name="16" id="anc16"></a><span class="line-modified">100                     return runtime().reflection.getInt(base, displacement);</span>
101                 case Long.SIZE:
<a name="17" id="anc17"></a><span class="line-modified">102                     return runtime().reflection.getLong(base, displacement);</span>
103                 default:
104                     throw new IllegalArgumentException(String.valueOf(bits));
105             }
106         } else {
107             long pointer = asRawPointer(baseConstant);
108             switch (bits) {
109                 case Byte.SIZE:
110                     return UNSAFE.getByte(pointer + displacement);
111                 case Short.SIZE:
112                     return UNSAFE.getShort(pointer + displacement);
113                 case Integer.SIZE:
114                     return UNSAFE.getInt(pointer + displacement);
115                 case Long.SIZE:
116                     return UNSAFE.getLong(pointer + displacement);
117                 default:
118                     throw new IllegalArgumentException(String.valueOf(bits));
119             }
120         }
121     }
122 
<a name="18" id="anc18"></a><span class="line-modified">123     private boolean verifyReadRawObject(JavaConstant expected, Constant base, long displacement) {</span>
124         if (base instanceof HotSpotMetaspaceConstant) {
<a name="19" id="anc19"></a><span class="line-modified">125             MetaspaceObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
126             if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {
<a name="20" id="anc20"></a><span class="line-modified">127                 if (displacement == runtime.getConfig().javaMirrorOffset) {</span>
<span class="line-modified">128                     HotSpotResolvedObjectTypeImpl type = (HotSpotResolvedObjectTypeImpl) metaspaceObject;</span>
<span class="line-added">129                     assert expected.equals(type.getJavaMirror());</span>
130                 }
131             }
132         }
133         return true;
134     }
135 
<a name="21" id="anc21"></a><span class="line-modified">136     private JavaConstant readRawObject(Constant baseConstant, long initialDisplacement, boolean compressed) {</span>
137         long displacement = initialDisplacement;
<a name="22" id="anc22"></a><span class="line-modified">138         JavaConstant ret;</span>
<span class="line-modified">139         HotSpotObjectConstantImpl base = asObject(baseConstant, JavaKind.Object, displacement);</span>
140         if (base == null) {
141             assert !compressed;
142             displacement += asRawPointer(baseConstant);
<a name="23" id="anc23"></a><span class="line-modified">143             ret = runtime.getCompilerToVM().readUncompressedOop(displacement);</span>
144             assert verifyReadRawObject(ret, baseConstant, initialDisplacement);
145         } else {
146             assert runtime.getConfig().useCompressedOops == compressed;
<a name="24" id="anc24"></a><span class="line-modified">147             ret = runtime.getCompilerToVM().getObject(base, displacement);</span>
































148         }
<a name="25" id="anc25"></a><span class="line-added">149         return ret == null ? JavaConstant.NULL_POINTER : ret;</span>
150     }
151 
152     @Override
153     public JavaConstant readPrimitiveConstant(JavaKind kind, Constant baseConstant, long initialDisplacement, int bits) {
154         try {
155             long rawValue = readRawValue(baseConstant, initialDisplacement, kind, bits);
156             switch (kind) {
157                 case Boolean:
158                     return JavaConstant.forBoolean(rawValue != 0);
159                 case Byte:
160                     return JavaConstant.forByte((byte) rawValue);
161                 case Char:
162                     return JavaConstant.forChar((char) rawValue);
163                 case Short:
164                     return JavaConstant.forShort((short) rawValue);
165                 case Int:
166                     return JavaConstant.forInt((int) rawValue);
167                 case Long:
168                     return JavaConstant.forLong(rawValue);
169                 case Float:
170                     return JavaConstant.forFloat(Float.intBitsToFloat((int) rawValue));
171                 case Double:
172                     return JavaConstant.forDouble(Double.longBitsToDouble(rawValue));
173                 default:
174                     throw new IllegalArgumentException(&quot;Unsupported kind: &quot; + kind);
175             }
176         } catch (NullPointerException e) {
177             return null;
178         }
179     }
180 
181     @Override
182     public JavaConstant readObjectConstant(Constant base, long displacement) {
183         if (base instanceof HotSpotObjectConstantImpl) {
<a name="26" id="anc26"></a><span class="line-modified">184             return readRawObject(base, displacement, runtime.getConfig().useCompressedOops);</span>

185         }
<a name="27" id="anc27"></a><span class="line-modified">186         if (!isValidObjectFieldDisplacement(base, displacement)) {</span>
<span class="line-modified">187             return null;</span>








188         }
<a name="28" id="anc28"></a><span class="line-modified">189         if (base instanceof HotSpotMetaspaceConstant &amp;&amp;</span>
<span class="line-added">190             displacement == runtime.getConfig().javaMirrorOffset) {</span>
<span class="line-added">191             MetaspaceObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
<span class="line-added">192             return ((HotSpotResolvedObjectTypeImpl) metaspaceObject).getJavaMirror();</span>
<span class="line-added">193         }</span>
<span class="line-added">194         return readRawObject(base, displacement, false);</span>
195     }
196 
197     @Override
198     public JavaConstant readNarrowOopConstant(Constant base, long displacement) {
<a name="29" id="anc29"></a><span class="line-modified">199         JavaConstant res = readRawObject(base, displacement, true);</span>
<span class="line-added">200         return JavaConstant.NULL_POINTER.equals(res) ? HotSpotCompressedNullConstant.COMPRESSED_NULL : ((HotSpotObjectConstant) res).compress();</span>
201     }
202 
203     private HotSpotResolvedObjectTypeImpl readKlass(Constant base, long displacement, boolean compressed) {
204         assert (base instanceof HotSpotMetaspaceConstantImpl) || (base instanceof HotSpotObjectConstantImpl) : base.getClass();
<a name="30" id="anc30"></a><span class="line-modified">205         if (base instanceof HotSpotMetaspaceConstantImpl) {</span>
<span class="line-modified">206             return runtime.getCompilerToVM().getResolvedJavaType((HotSpotResolvedObjectTypeImpl) ((HotSpotMetaspaceConstantImpl) base).asResolvedJavaType(), displacement, compressed);</span>
<span class="line-added">207         } else {</span>
<span class="line-added">208             return runtime.getCompilerToVM().getResolvedJavaType(((HotSpotObjectConstantImpl) base), displacement, compressed);</span>
<span class="line-added">209         }</span>
210     }
211 
<a name="31" id="anc31"></a><span class="line-added">212 </span>
213     @Override
214     public Constant readKlassPointerConstant(Constant base, long displacement) {
215         HotSpotResolvedObjectTypeImpl klass = readKlass(base, displacement, false);
216         if (klass == null) {
217             return JavaConstant.NULL_POINTER;
218         }
219         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(klass, false);
220     }
221 
222     @Override
223     public Constant readNarrowKlassPointerConstant(Constant base, long displacement) {
224         HotSpotResolvedObjectTypeImpl klass = readKlass(base, displacement, true);
225         if (klass == null) {
226             return HotSpotCompressedNullConstant.COMPRESSED_NULL;
227         }
228         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(klass, true);
229     }
230 
231     @Override
232     public Constant readMethodPointerConstant(Constant base, long displacement) {
233         assert (base instanceof HotSpotObjectConstantImpl);
<a name="32" id="anc32"></a><span class="line-modified">234         HotSpotResolvedJavaMethodImpl method = runtime.getCompilerToVM().getResolvedJavaMethod((HotSpotObjectConstantImpl) base, displacement);</span>

235         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(method, false);
236     }
237 }
<a name="33" id="anc33"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="33" type="hidden" />
</body>
</html>
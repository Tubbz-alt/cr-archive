<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static jdk.vm.ci.common.InitTimer.timer;
 26 
 27 import java.io.IOException;
 28 import java.io.OutputStream;
 29 import java.io.PrintStream;
 30 import java.lang.module.ModuleDescriptor.Requires;
 31 import java.util.Collections;
 32 import java.util.HashMap;
 33 import java.util.HashSet;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.Objects;
 37 import java.util.ServiceLoader;
 38 import java.util.Set;
 39 import java.util.function.Predicate;
 40 
 41 import jdk.internal.misc.VM;
 42 import jdk.internal.misc.Unsafe;
 43 import jdk.vm.ci.code.Architecture;
 44 import jdk.vm.ci.code.CompilationRequestResult;
 45 import jdk.vm.ci.code.CompiledCode;
 46 import jdk.vm.ci.code.InstalledCode;
 47 import jdk.vm.ci.common.InitTimer;
 48 import jdk.vm.ci.common.JVMCIError;
 49 import jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevel;
 50 import jdk.vm.ci.meta.JavaKind;
 51 import jdk.vm.ci.meta.JavaType;
 52 import jdk.vm.ci.meta.ResolvedJavaType;
 53 import jdk.vm.ci.meta.UnresolvedJavaType;
 54 import jdk.vm.ci.runtime.JVMCI;
 55 import jdk.vm.ci.runtime.JVMCIBackend;
 56 import jdk.vm.ci.runtime.JVMCICompiler;
 57 import jdk.vm.ci.runtime.JVMCICompilerFactory;
 58 import jdk.vm.ci.runtime.JVMCIRuntime;
 59 import jdk.vm.ci.services.JVMCIServiceLocator;
 60 
 61 /**
 62  * HotSpot implementation of a JVMCI runtime.
 63  *
 64  * The initialization of this class is very fragile since it&#39;s initialized both through
 65  * {@link JVMCI#initialize()} or through calling {@link HotSpotJVMCIRuntime#runtime()} and
 66  * {@link HotSpotJVMCIRuntime#runtime()} is also called by {@link JVMCI#initialize()}. So this class
 67  * can&#39;t have a static initializer and any required initialization must be done as part of
 68  * {@link #runtime()}. This allows the initialization to funnel back through
 69  * {@link JVMCI#initialize()} without deadlocking.
 70  */
 71 public final class HotSpotJVMCIRuntime implements JVMCIRuntime {
 72 
 73     @SuppressWarnings(&quot;try&quot;)
 74     static class DelayedInit {
 75         private static final HotSpotJVMCIRuntime instance;
 76 
 77         static {
 78             try (InitTimer t = timer(&quot;HotSpotJVMCIRuntime.&lt;init&gt;&quot;)) {
 79                 instance = new HotSpotJVMCIRuntime();
 80 
 81                 // Can only do eager initialization of the JVMCI compiler
 82                 // once the singleton instance is available.
 83                 if (instance.config.getFlag(&quot;EagerJVMCI&quot;, Boolean.class)) {
 84                     instance.getCompiler();
 85                 }
 86             }
 87         }
 88     }
 89 
 90     /**
 91      * Gets the singleton {@link HotSpotJVMCIRuntime} object.
 92      */
 93     public static HotSpotJVMCIRuntime runtime() {
 94         JVMCI.initialize();
 95         return DelayedInit.instance;
 96     }
 97 
 98     /**
 99      * A list of all supported JVMCI options.
100      */
101     public enum Option {
102         // @formatter:off
103         Compiler(String.class, null, &quot;Selects the system compiler. This must match the getCompilerName() value returned &quot; +
104                                      &quot;by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. &quot; +
105                                      &quot;An empty string or the value \&quot;null\&quot; selects a compiler &quot; +
106                                      &quot;that will raise an exception upon receiving a compilation request.&quot;),
107         // Note: The following one is not used (see InitTimer.ENABLED). It is added here
108         // so that -XX:+JVMCIPrintProperties shows the option.
109         InitTimer(Boolean.class, false, &quot;Specifies if initialization timing is enabled.&quot;),
110         PrintConfig(Boolean.class, false, &quot;Prints VM configuration available via JVMCI.&quot;),
111         TraceMethodDataFilter(String.class, null,
112                         &quot;Enables tracing of profiling info when read by JVMCI.&quot;,
113                         &quot;Empty value: trace all methods&quot;,
114                         &quot;Non-empty value: trace methods whose fully qualified name contains the value.&quot;),
115         UseProfilingInformation(Boolean.class, true, &quot;&quot;);
116         // @formatter:on
117 
118         /**
119          * The prefix for system properties that are JVMCI options.
120          */
121         private static final String JVMCI_OPTION_PROPERTY_PREFIX = &quot;jvmci.&quot;;
122 
123         /**
124          * Marker for uninitialized flags.
125          */
126         private static final String UNINITIALIZED = &quot;UNINITIALIZED&quot;;
127 
128         private final Class&lt;?&gt; type;
129         private Object value;
130         private final Object defaultValue;
131         private boolean isDefault;
132         private final String[] helpLines;
133 
134         Option(Class&lt;?&gt; type, Object defaultValue, String... helpLines) {
135             assert Character.isUpperCase(name().charAt(0)) : &quot;Option name must start with upper-case letter: &quot; + name();
136             this.type = type;
137             this.value = UNINITIALIZED;
138             this.defaultValue = defaultValue;
139             this.helpLines = helpLines;
140         }
141 
142         @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)
143         private Object getValue() {
144             if (value == UNINITIALIZED) {
145                 String propertyValue = VM.getSavedProperty(getPropertyName());
146                 if (propertyValue == null) {
147                     this.value = defaultValue;
148                     this.isDefault = true;
149                 } else {
150                     if (type == Boolean.class) {
151                         this.value = Boolean.parseBoolean(propertyValue);
152                     } else if (type == String.class) {
153                         this.value = propertyValue;
154                     } else {
155                         throw new JVMCIError(&quot;Unexpected option type &quot; + type);
156                     }
157                     this.isDefault = false;
158                 }
159                 // Saved properties should not be interned - let&#39;s be sure
160                 assert value != UNINITIALIZED;
161             }
162             return value;
163         }
164 
165         /**
166          * Gets the name of system property from which this option gets its value.
167          */
168         public String getPropertyName() {
169             return JVMCI_OPTION_PROPERTY_PREFIX + name();
170         }
171 
172         /**
173          * Returns the option&#39;s value as boolean.
174          *
175          * @return option&#39;s value
176          */
177         public boolean getBoolean() {
178             return (boolean) getValue();
179         }
180 
181         /**
182          * Returns the option&#39;s value as String.
183          *
184          * @return option&#39;s value
185          */
186         public String getString() {
187             return (String) getValue();
188         }
189 
190         private static final int PROPERTY_LINE_WIDTH = 80;
191         private static final int PROPERTY_HELP_INDENT = 10;
192 
193         /**
194          * Prints a description of the properties used to configure shared JVMCI code.
195          *
196          * @param out stream to print to
197          */
198         public static void printProperties(PrintStream out) {
199             out.println(&quot;[JVMCI properties]&quot;);
200             Option[] values = values();
201             for (Option option : values) {
202                 Object value = option.getValue();
203                 if (value instanceof String) {
204                     value = &#39;&quot;&#39; + String.valueOf(value) + &#39;&quot;&#39;;
205                 }
206 
207                 String name = option.getPropertyName();
208                 String assign = option.isDefault ? &quot;=&quot; : &quot;:=&quot;;
209                 String typeName = option.type.getSimpleName();
210                 String linePrefix = String.format(&quot;%s %s %s &quot;, name, assign, value);
211                 int typeStartPos = PROPERTY_LINE_WIDTH - typeName.length();
212                 int linePad = typeStartPos - linePrefix.length();
213                 if (linePad &gt; 0) {
214                     out.printf(&quot;%s%-&quot; + linePad + &quot;s[%s]%n&quot;, linePrefix, &quot;&quot;, typeName);
215                 } else {
216                     out.printf(&quot;%s[%s]%n&quot;, linePrefix, typeName);
217                 }
218                 for (String line : option.helpLines) {
219                     out.printf(&quot;%&quot; + PROPERTY_HELP_INDENT + &quot;s%s%n&quot;, &quot;&quot;, line);
220                 }
221             }
222         }
223     }
224 
225     static HotSpotJVMCIBackendFactory findFactory(String architecture) {
226         for (HotSpotJVMCIBackendFactory factory : ServiceLoader.load(HotSpotJVMCIBackendFactory.class, ClassLoader.getSystemClassLoader())) {
227             if (factory.getArchitecture().equalsIgnoreCase(architecture)) {
228                 return factory;
229             }
230         }
231 
232         throw new JVMCIError(&quot;No JVMCI runtime available for the %s architecture&quot;, architecture);
233     }
234 
235     /**
236      * Gets the kind of a word value on the {@linkplain #getHostJVMCIBackend() host} backend.
237      */
238     public static JavaKind getHostWordKind() {
239         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordJavaKind;
240     }
241 
242     final CompilerToVM compilerToVm;
243 
244     protected final HotSpotVMConfigStore configStore;
245     private final HotSpotVMConfig config;
246     private final JVMCIBackend hostBackend;
247 
248     private final JVMCICompilerFactory compilerFactory;
249     private final HotSpotJVMCICompilerFactory hsCompilerFactory;
250     private volatile JVMCICompiler compiler;
251     final HotSpotJVMCIMetaAccessContext metaAccessContext;
252 
253     /**
254      * Stores the result of {@link HotSpotJVMCICompilerFactory#getCompilationLevelAdjustment} so
255      * that it can be read from the VM.
256      */
257     @SuppressWarnings(&quot;unused&quot;) private final int compilationLevelAdjustment;
258 
259     private final Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; backends = new HashMap&lt;&gt;();
260 
261     private volatile List&lt;HotSpotVMEventListener&gt; vmEventListeners;
262 
263     private Iterable&lt;HotSpotVMEventListener&gt; getVmEventListeners() {
264         if (vmEventListeners == null) {
265             synchronized (this) {
266                 if (vmEventListeners == null) {
267                     vmEventListeners = JVMCIServiceLocator.getProviders(HotSpotVMEventListener.class);
268                 }
269             }
270         }
271         return vmEventListeners;
272     }
273 
274     @SuppressWarnings(&quot;try&quot;)
275     private HotSpotJVMCIRuntime() {
276         compilerToVm = new CompilerToVM();
277 
278         try (InitTimer t = timer(&quot;HotSpotVMConfig&lt;init&gt;&quot;)) {
279             configStore = new HotSpotVMConfigStore(compilerToVm);
280             config = new HotSpotVMConfig(configStore);
281         }
282 
283         String hostArchitecture = config.getHostArchitectureName();
284 
285         HotSpotJVMCIBackendFactory factory;
286         try (InitTimer t = timer(&quot;find factory:&quot;, hostArchitecture)) {
287             factory = findFactory(hostArchitecture);
288         }
289 
290         try (InitTimer t = timer(&quot;create JVMCI backend:&quot;, hostArchitecture)) {
291             hostBackend = registerBackend(factory.createJVMCIBackend(this, null));
292         }
293 
294         metaAccessContext = new HotSpotJVMCIMetaAccessContext();
295 
296         compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();
297         if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {
298             hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;
299             switch (hsCompilerFactory.getCompilationLevelAdjustment()) {
300                 case None:
301                     compilationLevelAdjustment = config.compLevelAdjustmentNone;
302                     break;
303                 case ByHolder:
304                     compilationLevelAdjustment = config.compLevelAdjustmentByHolder;
305                     break;
306                 case ByFullSignature:
307                     compilationLevelAdjustment = config.compLevelAdjustmentByFullSignature;
308                     break;
309                 default:
310                     compilationLevelAdjustment = config.compLevelAdjustmentNone;
311                     break;
312             }
313         } else {
314             hsCompilerFactory = null;
315             compilationLevelAdjustment = config.compLevelAdjustmentNone;
316         }
317 
318         if (config.getFlag(&quot;JVMCIPrintProperties&quot;, Boolean.class)) {
319             PrintStream out = new PrintStream(getLogStream());
320             Option.printProperties(out);
321             compilerFactory.printProperties(out);
322             System.exit(0);
323         }
324 
325         if (Option.PrintConfig.getBoolean()) {
326             configStore.printConfig();
327         }
328     }
329 
330     private JVMCIBackend registerBackend(JVMCIBackend backend) {
331         Class&lt;? extends Architecture&gt; arch = backend.getCodeCache().getTarget().arch.getClass();
332         JVMCIBackend oldValue = backends.put(arch, backend);
333         assert oldValue == null : &quot;cannot overwrite existing backend for architecture &quot; + arch.getSimpleName();
334         return backend;
335     }
336 
337     ResolvedJavaType fromClass(Class&lt;?&gt; javaClass) {
338         return metaAccessContext.fromClass(javaClass);
339     }
340 
341     public HotSpotVMConfigStore getConfigStore() {
342         return configStore;
343     }
344 
345     HotSpotVMConfig getConfig() {
346         return config;
347     }
348 
349     CompilerToVM getCompilerToVM() {
350         return compilerToVm;
351     }
352 
353     // Non-volatile since multi-initialization is harmless
354     private Predicate&lt;ResolvedJavaType&gt; intrinsificationTrustPredicate;
355 
356     /**
357      * Gets a predicate that determines if a given type can be considered trusted for the purpose of
358      * intrinsifying methods it declares.
359      *
360      * @param compilerLeafClasses classes in the leaves of the module graph comprising the JVMCI
361      *            compiler.
362      */
363     public Predicate&lt;ResolvedJavaType&gt; getIntrinsificationTrustPredicate(Class&lt;?&gt;... compilerLeafClasses) {
364         if (intrinsificationTrustPredicate == null) {
365             intrinsificationTrustPredicate = new Predicate&lt;&gt;() {
366                 @Override
367                 public boolean test(ResolvedJavaType type) {
368                     if (type instanceof HotSpotResolvedJavaType) {
369                         Class&lt;?&gt; mirror = getMirror(type);
370                         Module module = mirror.getModule();
371                         return getTrustedModules().contains(module);
372                     } else {
373                         return false;
374                     }
375                 }
376 
377                 private volatile Set&lt;Module&gt; trustedModules;
378 
379                 private Set&lt;Module&gt; getTrustedModules() {
380                     Set&lt;Module&gt; modules = trustedModules;
381                     if (modules == null) {
382                         modules = new HashSet&lt;&gt;();
383                         for (Class&lt;?&gt; compilerConfiguration : compilerLeafClasses) {
384                             Module compilerConfigurationModule = compilerConfiguration.getModule();
385                             if (compilerConfigurationModule.getDescriptor().isAutomatic()) {
386                                 throw new IllegalArgumentException(String.format(&quot;The module &#39;%s&#39; defining the Graal compiler configuration class &#39;%s&#39; must not be an automatic module&quot;,
387                                                 compilerConfigurationModule.getName(), compilerConfiguration.getClass().getName()));
388                             }
389                             modules.add(compilerConfigurationModule);
390                             for (Requires require : compilerConfigurationModule.getDescriptor().requires()) {
391                                 for (Module module : compilerConfigurationModule.getLayer().modules()) {
392                                     if (module.getName().equals(require.name())) {
393                                         modules.add(module);
394                                     }
395                                 }
396                             }
397                         }
398                         trustedModules = modules;
399                     }
400                     return modules;
401                 }
402             };
403         }
404         return intrinsificationTrustPredicate;
405     }
406 
407     /**
408      * Get the {@link Class} corresponding to {@code type}.
409      *
410      * @param type the type for which a {@link Class} is requested
411      * @return the original Java class corresponding to {@code type} or {@code null} if this runtime
412      *         does not support mapping {@link ResolvedJavaType} instances to {@link Class}
413      *         instances
414      */
415     @SuppressWarnings(&quot;static-method&quot;)
416     public Class&lt;?&gt; getMirror(ResolvedJavaType type) {
417         return ((HotSpotResolvedJavaType) type).mirror();
418     }
419 
420     @Override
421     public JVMCICompiler getCompiler() {
422         if (compiler == null) {
423             synchronized (this) {
424                 if (compiler == null) {
425                     compiler = compilerFactory.createCompiler(this);
426                 }
427             }
428         }
429         return compiler;
430     }
431 
432     /**
433      * Converts a name to a Java type. This method attempts to resolve {@code name} to a
434      * {@link ResolvedJavaType}.
435      *
436      * @param name a well formed Java type in {@linkplain JavaType#getName() internal} format
437      * @param accessingType the context of resolution which must be non-null
438      * @param resolve specifies whether resolution failure results in an unresolved type being
439      *            return or a {@link LinkageError} being thrown
440      * @return a Java type for {@code name} which is guaranteed to be of type
441      *         {@link ResolvedJavaType} if {@code resolve == true}
442      * @throws LinkageError if {@code resolve == true} and the resolution failed
443      * @throws NullPointerException if {@code accessingClass} is {@code null}
444      */
445     public JavaType lookupType(String name, HotSpotResolvedObjectType accessingType, boolean resolve) {
446         Objects.requireNonNull(accessingType, &quot;cannot resolve type without an accessing class&quot;);
447         // If the name represents a primitive type we can short-circuit the lookup.
448         if (name.length() == 1) {
449             JavaKind kind = JavaKind.fromPrimitiveOrVoidTypeChar(name.charAt(0));
450             return fromClass(kind.toJavaClass());
451         }
452 
453         // Resolve non-primitive types in the VM.
454         HotSpotResolvedObjectTypeImpl hsAccessingType = (HotSpotResolvedObjectTypeImpl) accessingType;
455         try {
456             final HotSpotResolvedObjectTypeImpl klass = compilerToVm.lookupType(name, hsAccessingType.mirror(), resolve);
457 
458             if (klass == null) {
459                 assert resolve == false;
460                 return UnresolvedJavaType.create(name);
461             }
462             return klass;
463         } catch (ClassNotFoundException e) {
464             throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);
465         }
466     }
467 
468     @Override
469     public JVMCIBackend getHostJVMCIBackend() {
470         return hostBackend;
471     }
472 
473     @Override
474     public &lt;T extends Architecture&gt; JVMCIBackend getJVMCIBackend(Class&lt;T&gt; arch) {
475         assert arch != Architecture.class;
476         return backends.get(arch);
477     }
478 
479     public Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; getJVMCIBackends() {
480         return Collections.unmodifiableMap(backends);
481     }
482 
483     /**
484      * Called from the VM.
485      */
486     @SuppressWarnings({&quot;unused&quot;})
487     private int adjustCompilationLevel(Class&lt;?&gt; declaringClass, String name, String signature, boolean isOsr, int level) {
488         CompilationLevel curLevel;
489         if (level == config.compilationLevelNone) {
490             curLevel = CompilationLevel.None;
491         } else if (level == config.compilationLevelSimple) {
492             curLevel = CompilationLevel.Simple;
493         } else if (level == config.compilationLevelLimitedProfile) {
494             curLevel = CompilationLevel.LimitedProfile;
495         } else if (level == config.compilationLevelFullProfile) {
496             curLevel = CompilationLevel.FullProfile;
497         } else if (level == config.compilationLevelFullOptimization) {
498             curLevel = CompilationLevel.FullOptimization;
499         } else {
500             throw JVMCIError.shouldNotReachHere();
501         }
502 
503         switch (hsCompilerFactory.adjustCompilationLevel(declaringClass, name, signature, isOsr, curLevel)) {
504             case None:
505                 return config.compilationLevelNone;
506             case Simple:
507                 return config.compilationLevelSimple;
508             case LimitedProfile:
509                 return config.compilationLevelLimitedProfile;
510             case FullProfile:
511                 return config.compilationLevelFullProfile;
512             case FullOptimization:
513                 return config.compilationLevelFullOptimization;
514             default:
515                 return level;
516         }
517     }
518 
519     /**
520      * Called from the VM.
521      */
522     @SuppressWarnings({&quot;unused&quot;})
523     private HotSpotCompilationRequestResult compileMethod(HotSpotResolvedJavaMethod method, int entryBCI, long jvmciEnv, int id) {
524         CompilationRequestResult result = getCompiler().compileMethod(new HotSpotCompilationRequest(method, entryBCI, jvmciEnv, id));
525         assert result != null : &quot;compileMethod must always return something&quot;;
526         HotSpotCompilationRequestResult hsResult;
527         if (result instanceof HotSpotCompilationRequestResult) {
528             hsResult = (HotSpotCompilationRequestResult) result;
529         } else {
530             Object failure = result.getFailure();
531             if (failure != null) {
532                 boolean retry = false; // Be conservative with unknown compiler
533                 hsResult = HotSpotCompilationRequestResult.failure(failure.toString(), retry);
534             } else {
535                 int inlinedBytecodes = -1;
536                 hsResult = HotSpotCompilationRequestResult.success(inlinedBytecodes);
537             }
538         }
539 
540         return hsResult;
541     }
542 
543     /**
544      * Shuts down the runtime.
545      *
546      * Called from the VM.
547      */
548     @SuppressWarnings({&quot;unused&quot;})
549     private void shutdown() throws Exception {
550         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
551             vmEventListener.notifyShutdown();
552         }
553     }
554 
555     /**
556      * Notify on completion of a bootstrap.
557      *
558      * Called from the VM.
559      */
560     @SuppressWarnings({&quot;unused&quot;})
561     private void bootstrapFinished() throws Exception {
562         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
563             vmEventListener.notifyBootstrapFinished();
564         }
565     }
566 
567     /**
568      * Notify on successful install into the CodeCache.
569      *
570      * @param hotSpotCodeCacheProvider
571      * @param installedCode
572      * @param compiledCode
573      */
574     void notifyInstall(HotSpotCodeCacheProvider hotSpotCodeCacheProvider, InstalledCode installedCode, CompiledCode compiledCode) {
575         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
576             vmEventListener.notifyInstall(hotSpotCodeCacheProvider, installedCode, compiledCode);
577         }
578     }
579 
580     /**
581      * Gets an output stream that writes to HotSpot&#39;s {@code tty} stream.
582      */
583     public OutputStream getLogStream() {
584         return new OutputStream() {
585 
586             @Override
587             public void write(byte[] b, int off, int len) throws IOException {
588                 if (b == null) {
589                     throw new NullPointerException();
590                 } else if (off &lt; 0 || off &gt; b.length || len &lt; 0 || (off + len) &gt; b.length || (off + len) &lt; 0) {
591                     throw new IndexOutOfBoundsException();
592                 } else if (len == 0) {
593                     return;
594                 }
595                 compilerToVm.writeDebugOutput(b, off, len);
596             }
597 
598             @Override
599             public void write(int b) throws IOException {
600                 write(new byte[]{(byte) b}, 0, 1);
601             }
602 
603             @Override
604             public void flush() throws IOException {
605                 compilerToVm.flushDebugOutput();
606             }
607         };
608     }
609 
610     /**
611      * Collects the current values of all JVMCI benchmark counters, summed up over all threads.
612      */
613     public long[] collectCounters() {
614         return compilerToVm.collectCounters();
615     }
616 
617     /**
618      * The offset from the origin of an array to the first element.
619      *
620      * @return the offset in bytes
621      */
622     @SuppressWarnings(&quot;static-method&quot;)
623     public int getArrayBaseOffset(JavaKind kind) {
624         switch (kind) {
625             case Boolean:
626                 return Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;
627             case Byte:
628                 return Unsafe.ARRAY_BYTE_BASE_OFFSET;
629             case Char:
630                 return Unsafe.ARRAY_CHAR_BASE_OFFSET;
631             case Short:
632                 return Unsafe.ARRAY_SHORT_BASE_OFFSET;
633             case Int:
634                 return Unsafe.ARRAY_INT_BASE_OFFSET;
635             case Long:
636                 return Unsafe.ARRAY_LONG_BASE_OFFSET;
637             case Float:
638                 return Unsafe.ARRAY_FLOAT_BASE_OFFSET;
639             case Double:
640                 return Unsafe.ARRAY_DOUBLE_BASE_OFFSET;
641             case Object:
642                 return Unsafe.ARRAY_OBJECT_BASE_OFFSET;
643             default:
644                 throw new JVMCIError(&quot;%s&quot;, kind);
645         }
646 
647     }
648 
649     /**
650      * The scale used for the index when accessing elements of an array of this kind.
651      *
652      * @return the scale in order to convert the index into a byte offset
653      */
654     @SuppressWarnings(&quot;static-method&quot;)
655     public int getArrayIndexScale(JavaKind kind) {
656         switch (kind) {
657             case Boolean:
658                 return Unsafe.ARRAY_BOOLEAN_INDEX_SCALE;
659             case Byte:
660                 return Unsafe.ARRAY_BYTE_INDEX_SCALE;
661             case Char:
662                 return Unsafe.ARRAY_CHAR_INDEX_SCALE;
663             case Short:
664                 return Unsafe.ARRAY_SHORT_INDEX_SCALE;
665             case Int:
666                 return Unsafe.ARRAY_INT_INDEX_SCALE;
667             case Long:
668                 return Unsafe.ARRAY_LONG_INDEX_SCALE;
669             case Float:
670                 return Unsafe.ARRAY_FLOAT_INDEX_SCALE;
671             case Double:
672                 return Unsafe.ARRAY_DOUBLE_INDEX_SCALE;
673             case Object:
674                 return Unsafe.ARRAY_OBJECT_INDEX_SCALE;
675             default:
676                 throw new JVMCIError(&quot;%s&quot;, kind);
677 
678         }
679     }
680 
681     /**
682      * Links each native method in {@code clazz} to an implementation in the JVMCI SVM library.
683      * &lt;p&gt;
684      * A use case for this is a JVMCI compiler implementation that offers an API to Java code
685      * executing in HotSpot to exercise functionality (mostly) in the JVMCI SVM library. For
686      * example:
687      *
688      * &lt;pre&gt;
689      * package com.jcompile;
690      *
691      * import java.lang.reflect.Method;
692      *
693      * public static class JCompile {
694      *     static {
695      *         HotSpotJVMCIRuntime.runtime().registerNativeMethods(JCompile.class);
696      *     }
697      *     public static boolean compile(Method method, String[] options) {
698      *         // Convert to simpler data types for passing/serializing across native interface
699      *         long metaspaceMethodHandle = getHandle(method);
700      *         char[] opts = convertToCharArray(options);
701      *         return compile(metaspaceMethodHandle, opts);
702      *     }
703      *     private static native boolean compile0(long metaspaceMethodHandle, char[] options);
704      *
705      *     private static long getHandle(Method method) { ... }
706      *     private static char[] convertToCharArray(String[] a) { ... }
707      * }
708      * &lt;/pre&gt;
709      *
710      * The implementation of the native {@code JCompile.compile0} method would be in the SVM library
711      * that contains the bulk of the JVMCI compiler. The {@code JCompile.compile0} implementation
712      * will be exported as the following JNI-compliant symbol:
713      *
714      * &lt;pre&gt;
715      * Java_com_jcompile_JCompile_compile0
716      * &lt;/pre&gt;
717      *
718      * How the JVMCI compiler SVM library is built is outside the scope of this document.
719      *
720      * @see &quot;https://docs.oracle.com/javase/10/docs/specs/jni/design.html#resolving-native-method-names&quot;
721      *
722      * @throws NullPointerException if {@code clazz == null}
723      * @throws IllegalArgumentException if the current execution context is SVM or if {@code clazz}
724      *             is {@link Class#isPrimitive()}
725      * @throws UnsatisfiedLinkError if the JVMCI SVM library is not available, a native method in
726      *             {@code clazz} is already linked or the SVM JVMCI library does not contain a
727      *             JNI-compliant symbol for a native method in {@code clazz}
728      */
729     @SuppressWarnings({&quot;static-method&quot;, &quot;unused&quot;})
730     public void registerNativeMethods(Class&lt;?&gt; clazz) {
731         throw new UnsatisfiedLinkError(&quot;SVM library is not available&quot;);
732     }
733 }
    </pre>
  </body>
</html>
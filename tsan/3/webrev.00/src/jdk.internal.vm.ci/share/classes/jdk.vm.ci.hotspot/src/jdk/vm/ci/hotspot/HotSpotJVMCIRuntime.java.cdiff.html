<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotJVMCICompilerConfig.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotMemoryAccessProviderImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,132 ***</span>
   * questions.
   */
  package jdk.vm.ci.hotspot;
  
  import static jdk.vm.ci.common.InitTimer.timer;
  
  import java.io.IOException;
  import java.io.OutputStream;
  import java.io.PrintStream;
<span class="line-modified">! import java.lang.module.ModuleDescriptor.Requires;</span>
  import java.util.Collections;
  import java.util.HashMap;
<span class="line-removed">- import java.util.HashSet;</span>
  import java.util.List;
  import java.util.Map;
  import java.util.Objects;
  import java.util.ServiceLoader;
<span class="line-removed">- import java.util.Set;</span>
  import java.util.function.Predicate;
  
<span class="line-removed">- import jdk.internal.misc.VM;</span>
<span class="line-removed">- import jdk.internal.misc.Unsafe;</span>
  import jdk.vm.ci.code.Architecture;
  import jdk.vm.ci.code.CompilationRequestResult;
  import jdk.vm.ci.code.CompiledCode;
  import jdk.vm.ci.code.InstalledCode;
  import jdk.vm.ci.common.InitTimer;
  import jdk.vm.ci.common.JVMCIError;
<span class="line-modified">! import jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevel;</span>
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.JavaType;
  import jdk.vm.ci.meta.ResolvedJavaType;
  import jdk.vm.ci.meta.UnresolvedJavaType;
  import jdk.vm.ci.runtime.JVMCI;
  import jdk.vm.ci.runtime.JVMCIBackend;
  import jdk.vm.ci.runtime.JVMCICompiler;
  import jdk.vm.ci.runtime.JVMCICompilerFactory;
  import jdk.vm.ci.runtime.JVMCIRuntime;
  import jdk.vm.ci.services.JVMCIServiceLocator;
  
  /**
   * HotSpot implementation of a JVMCI runtime.
<span class="line-removed">-  *</span>
<span class="line-removed">-  * The initialization of this class is very fragile since it&#39;s initialized both through</span>
<span class="line-removed">-  * {@link JVMCI#initialize()} or through calling {@link HotSpotJVMCIRuntime#runtime()} and</span>
<span class="line-removed">-  * {@link HotSpotJVMCIRuntime#runtime()} is also called by {@link JVMCI#initialize()}. So this class</span>
<span class="line-removed">-  * can&#39;t have a static initializer and any required initialization must be done as part of</span>
<span class="line-removed">-  * {@link #runtime()}. This allows the initialization to funnel back through</span>
<span class="line-removed">-  * {@link JVMCI#initialize()} without deadlocking.</span>
   */
  public final class HotSpotJVMCIRuntime implements JVMCIRuntime {
  
<span class="line-modified">!     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-modified">!     static class DelayedInit {</span>
<span class="line-modified">!         private static final HotSpotJVMCIRuntime instance;</span>
  
<span class="line-modified">!         static {</span>
<span class="line-modified">!             try (InitTimer t = timer(&quot;HotSpotJVMCIRuntime.&lt;init&gt;&quot;)) {</span>
<span class="line-modified">!                 instance = new HotSpotJVMCIRuntime();</span>
  
<span class="line-modified">!                 // Can only do eager initialization of the JVMCI compiler</span>
<span class="line-modified">!                 // once the singleton instance is available.</span>
<span class="line-modified">!                 if (instance.config.getFlag(&quot;EagerJVMCI&quot;, Boolean.class)) {</span>
<span class="line-modified">!                     instance.getCompiler();</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
          }
      }
  
      /**
       * Gets the singleton {@link HotSpotJVMCIRuntime} object.
       */
      public static HotSpotJVMCIRuntime runtime() {
<span class="line-modified">!         JVMCI.initialize();</span>
<span class="line-modified">!         return DelayedInit.instance;</span>
      }
  
      /**
       * A list of all supported JVMCI options.
       */
      public enum Option {
          // @formatter:off
          Compiler(String.class, null, &quot;Selects the system compiler. This must match the getCompilerName() value returned &quot; +
<span class="line-modified">!                                      &quot;by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. &quot; +</span>
<span class="line-modified">!                                      &quot;An empty string or the value \&quot;null\&quot; selects a compiler &quot; +</span>
<span class="line-modified">!                                      &quot;that will raise an exception upon receiving a compilation request.&quot;),</span>
          // Note: The following one is not used (see InitTimer.ENABLED). It is added here
          // so that -XX:+JVMCIPrintProperties shows the option.
          InitTimer(Boolean.class, false, &quot;Specifies if initialization timing is enabled.&quot;),
          PrintConfig(Boolean.class, false, &quot;Prints VM configuration available via JVMCI.&quot;),
          TraceMethodDataFilter(String.class, null,
<span class="line-modified">!                         &quot;Enables tracing of profiling info when read by JVMCI.&quot;,</span>
<span class="line-modified">!                         &quot;Empty value: trace all methods&quot;,</span>
<span class="line-modified">!                         &quot;Non-empty value: trace methods whose fully qualified name contains the value.&quot;),</span>
          UseProfilingInformation(Boolean.class, true, &quot;&quot;);
          // @formatter:on
  
          /**
           * The prefix for system properties that are JVMCI options.
           */
          private static final String JVMCI_OPTION_PROPERTY_PREFIX = &quot;jvmci.&quot;;
  
          /**
<span class="line-modified">!          * Marker for uninitialized flags.</span>
           */
<span class="line-modified">!         private static final String UNINITIALIZED = &quot;UNINITIALIZED&quot;;</span>
  
          private final Class&lt;?&gt; type;
<span class="line-modified">!         private Object value;</span>
          private final Object defaultValue;
          private boolean isDefault;
          private final String[] helpLines;
  
          Option(Class&lt;?&gt; type, Object defaultValue, String... helpLines) {
              assert Character.isUpperCase(name().charAt(0)) : &quot;Option name must start with upper-case letter: &quot; + name();
              this.type = type;
<span class="line-removed">-             this.value = UNINITIALIZED;</span>
              this.defaultValue = defaultValue;
              this.helpLines = helpLines;
          }
  
          @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)
          private Object getValue() {
<span class="line-modified">!             if (value == UNINITIALIZED) {</span>
<span class="line-modified">!                 String propertyValue = VM.getSavedProperty(getPropertyName());</span>
                  if (propertyValue == null) {
<span class="line-modified">!                     this.value = defaultValue;</span>
                      this.isDefault = true;
                  } else {
                      if (type == Boolean.class) {
                          this.value = Boolean.parseBoolean(propertyValue);
                      } else if (type == String.class) {
<span class="line-new-header">--- 21,248 ---</span>
   * questions.
   */
  package jdk.vm.ci.hotspot;
  
  import static jdk.vm.ci.common.InitTimer.timer;
<span class="line-added">+ import static jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevelAdjustment.None;</span>
<span class="line-added">+ import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;</span>
<span class="line-added">+ import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;</span>
  
  import java.io.IOException;
  import java.io.OutputStream;
  import java.io.PrintStream;
<span class="line-modified">! import java.io.Serializable;</span>
<span class="line-added">+ import java.lang.invoke.CallSite;</span>
<span class="line-added">+ import java.lang.invoke.ConstantCallSite;</span>
<span class="line-added">+ import java.lang.invoke.MethodHandle;</span>
<span class="line-added">+ import java.lang.ref.WeakReference;</span>
<span class="line-added">+ import java.util.ArrayList;</span>
  import java.util.Collections;
  import java.util.HashMap;
  import java.util.List;
  import java.util.Map;
  import java.util.Objects;
  import java.util.ServiceLoader;
  import java.util.function.Predicate;
  
  import jdk.vm.ci.code.Architecture;
  import jdk.vm.ci.code.CompilationRequestResult;
  import jdk.vm.ci.code.CompiledCode;
  import jdk.vm.ci.code.InstalledCode;
  import jdk.vm.ci.common.InitTimer;
  import jdk.vm.ci.common.JVMCIError;
<span class="line-modified">! import jdk.vm.ci.common.NativeImageReinitialize;</span>
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.JavaType;
  import jdk.vm.ci.meta.ResolvedJavaType;
  import jdk.vm.ci.meta.UnresolvedJavaType;
  import jdk.vm.ci.runtime.JVMCI;
  import jdk.vm.ci.runtime.JVMCIBackend;
  import jdk.vm.ci.runtime.JVMCICompiler;
  import jdk.vm.ci.runtime.JVMCICompilerFactory;
  import jdk.vm.ci.runtime.JVMCIRuntime;
  import jdk.vm.ci.services.JVMCIServiceLocator;
<span class="line-added">+ import jdk.vm.ci.services.Services;</span>
  
  /**
   * HotSpot implementation of a JVMCI runtime.
   */
  public final class HotSpotJVMCIRuntime implements JVMCIRuntime {
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Singleton instance lazily initialized via double-checked locking.</span>
<span class="line-modified">!      */</span>
<span class="line-added">+     @NativeImageReinitialize private static volatile HotSpotJVMCIRuntime instance;</span>
<span class="line-added">+ </span>
<span class="line-added">+     private HotSpotResolvedObjectTypeImpl javaLangObject;</span>
<span class="line-added">+     private HotSpotResolvedObjectTypeImpl javaLangInvokeMethodHandle;</span>
<span class="line-added">+     private HotSpotResolvedObjectTypeImpl constantCallSiteType;</span>
<span class="line-added">+     private HotSpotResolvedObjectTypeImpl callSiteType;</span>
<span class="line-added">+     private HotSpotResolvedObjectTypeImpl javaLangString;</span>
<span class="line-added">+     private HotSpotResolvedObjectTypeImpl javaLangClass;</span>
<span class="line-added">+     private HotSpotResolvedObjectTypeImpl throwableType;</span>
<span class="line-added">+     private HotSpotResolvedObjectTypeImpl serializableType;</span>
<span class="line-added">+     private HotSpotResolvedObjectTypeImpl cloneableType;</span>
<span class="line-added">+     private HotSpotResolvedObjectTypeImpl enumType;</span>
<span class="line-added">+ </span>
<span class="line-added">+     HotSpotResolvedObjectTypeImpl getJavaLangObject() {</span>
<span class="line-added">+         if (javaLangObject == null) {</span>
<span class="line-added">+             javaLangObject = (HotSpotResolvedObjectTypeImpl) fromClass(Object.class);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return javaLangObject;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     HotSpotResolvedObjectTypeImpl getJavaLangString() {</span>
<span class="line-modified">!         if (javaLangString == null) {</span>
<span class="line-modified">!             javaLangString = (HotSpotResolvedObjectTypeImpl) fromClass(String.class);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return javaLangString;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     HotSpotResolvedObjectTypeImpl getJavaLangClass() {</span>
<span class="line-modified">!         if (javaLangClass == null) {</span>
<span class="line-modified">!             javaLangClass = (HotSpotResolvedObjectTypeImpl) fromClass(Class.class);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return javaLangClass;</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     HotSpotResolvedObjectTypeImpl getJavaLangCloneable() {</span>
<span class="line-added">+         if (cloneableType == null) {</span>
<span class="line-added">+             cloneableType = (HotSpotResolvedObjectTypeImpl) fromClass(Cloneable.class);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return cloneableType;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     HotSpotResolvedObjectTypeImpl getJavaLangSerializable() {</span>
<span class="line-added">+         if (serializableType == null) {</span>
<span class="line-added">+             serializableType = (HotSpotResolvedObjectTypeImpl) fromClass(Serializable.class);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return serializableType;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     HotSpotResolvedObjectTypeImpl getJavaLangThrowable() {</span>
<span class="line-added">+         if (throwableType == null) {</span>
<span class="line-added">+             throwableType = (HotSpotResolvedObjectTypeImpl) fromClass(Throwable.class);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return throwableType;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     HotSpotResolvedObjectTypeImpl getJavaLangEnum() {</span>
<span class="line-added">+         if (enumType == null) {</span>
<span class="line-added">+             enumType = (HotSpotResolvedObjectTypeImpl) fromClass(Enum.class);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return enumType;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     HotSpotResolvedObjectTypeImpl getConstantCallSite() {</span>
<span class="line-added">+         if (constantCallSiteType == null) {</span>
<span class="line-added">+             constantCallSiteType = (HotSpotResolvedObjectTypeImpl) fromClass(ConstantCallSite.class);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return constantCallSiteType;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     HotSpotResolvedObjectTypeImpl getCallSite() {</span>
<span class="line-added">+         if (callSiteType == null) {</span>
<span class="line-added">+             callSiteType = (HotSpotResolvedObjectTypeImpl) fromClass(CallSite.class);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return callSiteType;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     HotSpotResolvedObjectType getMethodHandleClass() {</span>
<span class="line-added">+         if (javaLangInvokeMethodHandle == null) {</span>
<span class="line-added">+             javaLangInvokeMethodHandle = (HotSpotResolvedObjectTypeImpl) fromClass(MethodHandle.class);</span>
          }
<span class="line-added">+         return javaLangInvokeMethodHandle;</span>
      }
  
      /**
       * Gets the singleton {@link HotSpotJVMCIRuntime} object.
       */
<span class="line-added">+     @VMEntryPoint</span>
<span class="line-added">+     @SuppressWarnings(&quot;try&quot;)</span>
      public static HotSpotJVMCIRuntime runtime() {
<span class="line-modified">!         HotSpotJVMCIRuntime result = instance;</span>
<span class="line-modified">!         if (result == null) {</span>
<span class="line-added">+             // Synchronize on JVMCI.class to avoid deadlock</span>
<span class="line-added">+             // between the two JVMCI initialization paths:</span>
<span class="line-added">+             // HotSpotJVMCIRuntime.runtime() and JVMCI.getRuntime().</span>
<span class="line-added">+             synchronized (JVMCI.class) {</span>
<span class="line-added">+                 result = instance;</span>
<span class="line-added">+                 if (result == null) {</span>
<span class="line-added">+                     try (InitTimer t = timer(&quot;HotSpotJVMCIRuntime.&lt;init&gt;&quot;)) {</span>
<span class="line-added">+                         instance = result = new HotSpotJVMCIRuntime();</span>
<span class="line-added">+ </span>
<span class="line-added">+                         // Can only do eager initialization of the JVMCI compiler</span>
<span class="line-added">+                         // once the singleton instance is available.</span>
<span class="line-added">+                         if (result.config.getFlag(&quot;EagerJVMCI&quot;, Boolean.class)) {</span>
<span class="line-added">+                             result.getCompiler();</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     // Ensures JVMCIRuntime::_HotSpotJVMCIRuntime_instance is</span>
<span class="line-added">+                     // initialized.</span>
<span class="line-added">+                     JVMCI.getRuntime();</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 // Make sure all the primitive box caches are populated (required to properly</span>
<span class="line-added">+                 // materialize boxed primitives</span>
<span class="line-added">+                 // during deoptimization).</span>
<span class="line-added">+                 Boolean.valueOf(false);</span>
<span class="line-added">+                 Byte.valueOf((byte) 0);</span>
<span class="line-added">+                 Short.valueOf((short) 0);</span>
<span class="line-added">+                 Character.valueOf((char) 0);</span>
<span class="line-added">+                 Integer.valueOf(0);</span>
<span class="line-added">+                 Long.valueOf(0);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @VMEntryPoint</span>
<span class="line-added">+     static Throwable decodeThrowable(String encodedThrowable) throws Throwable {</span>
<span class="line-added">+         return TranslatedException.decodeThrowable(encodedThrowable);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @VMEntryPoint</span>
<span class="line-added">+     static String encodeThrowable(Throwable throwable) throws Throwable {</span>
<span class="line-added">+         return TranslatedException.encodeThrowable(throwable);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @VMEntryPoint</span>
<span class="line-added">+     static String callToString(Object o) {</span>
<span class="line-added">+         return o.toString();</span>
      }
  
      /**
       * A list of all supported JVMCI options.
       */
      public enum Option {
          // @formatter:off
          Compiler(String.class, null, &quot;Selects the system compiler. This must match the getCompilerName() value returned &quot; +
<span class="line-modified">!                 &quot;by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. &quot; +</span>
<span class="line-modified">!                 &quot;An empty string or the value \&quot;null\&quot; selects a compiler &quot; +</span>
<span class="line-modified">!                 &quot;that will raise an exception upon receiving a compilation request.&quot;),</span>
          // Note: The following one is not used (see InitTimer.ENABLED). It is added here
          // so that -XX:+JVMCIPrintProperties shows the option.
          InitTimer(Boolean.class, false, &quot;Specifies if initialization timing is enabled.&quot;),
          PrintConfig(Boolean.class, false, &quot;Prints VM configuration available via JVMCI.&quot;),
<span class="line-added">+         AuditHandles(Boolean.class, false, &quot;Record stack trace along with scoped foreign object reference wrappers &quot; +</span>
<span class="line-added">+                 &quot;to debug issue with a wrapper being used after its scope has closed.&quot;),</span>
          TraceMethodDataFilter(String.class, null,
<span class="line-modified">!                 &quot;Enables tracing of profiling info when read by JVMCI.&quot;,</span>
<span class="line-modified">!                 &quot;Empty value: trace all methods&quot;,</span>
<span class="line-modified">!                 &quot;Non-empty value: trace methods whose fully qualified name contains the value.&quot;),</span>
          UseProfilingInformation(Boolean.class, true, &quot;&quot;);
          // @formatter:on
  
          /**
           * The prefix for system properties that are JVMCI options.
           */
          private static final String JVMCI_OPTION_PROPERTY_PREFIX = &quot;jvmci.&quot;;
  
          /**
<span class="line-modified">!          * Sentinel for value initialized to {@code null} since {@code null} means uninitialized.</span>
           */
<span class="line-modified">!         private static final String NULL_VALUE = &quot;NULL&quot;;</span>
  
          private final Class&lt;?&gt; type;
<span class="line-modified">!         @NativeImageReinitialize private Object value;</span>
          private final Object defaultValue;
          private boolean isDefault;
          private final String[] helpLines;
  
          Option(Class&lt;?&gt; type, Object defaultValue, String... helpLines) {
              assert Character.isUpperCase(name().charAt(0)) : &quot;Option name must start with upper-case letter: &quot; + name();
              this.type = type;
              this.defaultValue = defaultValue;
              this.helpLines = helpLines;
          }
  
          @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)
          private Object getValue() {
<span class="line-modified">!             if (value == null) {</span>
<span class="line-modified">!                 String propertyValue = Services.getSavedProperty(getPropertyName());</span>
                  if (propertyValue == null) {
<span class="line-modified">!                     this.value = defaultValue == null ? NULL_VALUE : defaultValue;</span>
                      this.isDefault = true;
                  } else {
                      if (type == Boolean.class) {
                          this.value = Boolean.parseBoolean(propertyValue);
                      } else if (type == String.class) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 154,14 ***</span>
                      } else {
                          throw new JVMCIError(&quot;Unexpected option type &quot; + type);
                      }
                      this.isDefault = false;
                  }
<span class="line-removed">-                 // Saved properties should not be interned - let&#39;s be sure</span>
<span class="line-removed">-                 assert value != UNINITIALIZED;</span>
              }
<span class="line-modified">!             return value;</span>
          }
  
          /**
           * Gets the name of system property from which this option gets its value.
           */
<span class="line-new-header">--- 270,12 ---</span>
                      } else {
                          throw new JVMCIError(&quot;Unexpected option type &quot; + type);
                      }
                      this.isDefault = false;
                  }
              }
<span class="line-modified">!             return value == NULL_VALUE ? null : value;</span>
          }
  
          /**
           * Gets the name of system property from which this option gets its value.
           */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,43 ***</span>
                  }
              }
          }
      }
  
<span class="line-modified">!     static HotSpotJVMCIBackendFactory findFactory(String architecture) {</span>
<span class="line-modified">!         for (HotSpotJVMCIBackendFactory factory : ServiceLoader.load(HotSpotJVMCIBackendFactory.class, ClassLoader.getSystemClassLoader())) {</span>
              if (factory.getArchitecture().equalsIgnoreCase(architecture)) {
                  return factory;
              }
          }
  
          throw new JVMCIError(&quot;No JVMCI runtime available for the %s architecture&quot;, architecture);
      }
  
      /**
       * Gets the kind of a word value on the {@linkplain #getHostJVMCIBackend() host} backend.
       */
      public static JavaKind getHostWordKind() {
          return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordJavaKind;
      }
  
<span class="line-modified">!     final CompilerToVM compilerToVm;</span>
  
      protected final HotSpotVMConfigStore configStore;
<span class="line-modified">!     private final HotSpotVMConfig config;</span>
      private final JVMCIBackend hostBackend;
  
      private final JVMCICompilerFactory compilerFactory;
      private final HotSpotJVMCICompilerFactory hsCompilerFactory;
      private volatile JVMCICompiler compiler;
<span class="line-modified">!     final HotSpotJVMCIMetaAccessContext metaAccessContext;</span>
  
      /**
<span class="line-modified">!      * Stores the result of {@link HotSpotJVMCICompilerFactory#getCompilationLevelAdjustment} so</span>
<span class="line-modified">!      * that it can be read from the VM.</span>
       */
<span class="line-modified">!     @SuppressWarnings(&quot;unused&quot;) private final int compilationLevelAdjustment;</span>
  
      private final Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; backends = new HashMap&lt;&gt;();
  
      private volatile List&lt;HotSpotVMEventListener&gt; vmEventListeners;
  
<span class="line-new-header">--- 334,93 ---</span>
                  }
              }
          }
      }
  
<span class="line-modified">!     private static HotSpotJVMCIBackendFactory findFactory(String architecture) {</span>
<span class="line-modified">!         Iterable&lt;HotSpotJVMCIBackendFactory&gt; factories = getHotSpotJVMCIBackendFactories();</span>
<span class="line-added">+         assert factories != null : &quot;sanity&quot;;</span>
<span class="line-added">+         for (HotSpotJVMCIBackendFactory factory : factories) {</span>
              if (factory.getArchitecture().equalsIgnoreCase(architecture)) {
                  return factory;
              }
          }
  
          throw new JVMCIError(&quot;No JVMCI runtime available for the %s architecture&quot;, architecture);
      }
  
<span class="line-added">+     private static volatile List&lt;HotSpotJVMCIBackendFactory&gt; cachedHotSpotJVMCIBackendFactories;</span>
<span class="line-added">+ </span>
<span class="line-added">+     @SuppressFBWarnings(value = &quot;LI_LAZY_INIT_UPDATE_STATIC&quot;, justification = &quot;not sure about this&quot;)</span>
<span class="line-added">+     private static Iterable&lt;HotSpotJVMCIBackendFactory&gt; getHotSpotJVMCIBackendFactories() {</span>
<span class="line-added">+         if (IS_IN_NATIVE_IMAGE || cachedHotSpotJVMCIBackendFactories != null) {</span>
<span class="line-added">+             return cachedHotSpotJVMCIBackendFactories;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         Iterable&lt;HotSpotJVMCIBackendFactory&gt; result = ServiceLoader.load(HotSpotJVMCIBackendFactory.class, ClassLoader.getSystemClassLoader());</span>
<span class="line-added">+         if (IS_BUILDING_NATIVE_IMAGE) {</span>
<span class="line-added">+             cachedHotSpotJVMCIBackendFactories = new ArrayList&lt;&gt;();</span>
<span class="line-added">+             for (HotSpotJVMCIBackendFactory factory : result) {</span>
<span class="line-added">+                 cachedHotSpotJVMCIBackendFactories.add(factory);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Gets the kind of a word value on the {@linkplain #getHostJVMCIBackend() host} backend.
       */
      public static JavaKind getHostWordKind() {
          return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordJavaKind;
      }
  
<span class="line-modified">!     protected final CompilerToVM compilerToVm;</span>
  
      protected final HotSpotVMConfigStore configStore;
<span class="line-modified">!     protected final HotSpotVMConfig config;</span>
      private final JVMCIBackend hostBackend;
  
      private final JVMCICompilerFactory compilerFactory;
      private final HotSpotJVMCICompilerFactory hsCompilerFactory;
      private volatile JVMCICompiler compiler;
<span class="line-modified">!     protected final HotSpotJVMCIReflection reflection;</span>
<span class="line-added">+ </span>
<span class="line-added">+     @NativeImageReinitialize private volatile boolean creatingCompiler;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Cache for speeding up {@link #fromClass(Class)}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @NativeImageReinitialize private volatile ClassValue&lt;WeakReferenceHolder&lt;HotSpotResolvedJavaType&gt;&gt; resolvedJavaType;</span>
  
      /**
<span class="line-modified">!      * To avoid calling ClassValue.remove to refresh the weak reference, which under certain</span>
<span class="line-modified">!      * circumstances can lead to an infinite loop, we use a permanent holder with a mutable field</span>
<span class="line-added">+      * that we refresh.</span>
       */
<span class="line-modified">!     private static class WeakReferenceHolder&lt;T&gt; {</span>
<span class="line-added">+         private volatile WeakReference&lt;T&gt; ref;</span>
<span class="line-added">+ </span>
<span class="line-added">+         WeakReferenceHolder(T value) {</span>
<span class="line-added">+             set(value);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         void set(T value) {</span>
<span class="line-added">+             ref = new WeakReference&lt;&gt;(value);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         T get() {</span>
<span class="line-added">+             return ref.get();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @NativeImageReinitialize private HashMap&lt;Long, WeakReference&lt;ResolvedJavaType&gt;&gt; resolvedJavaTypes;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Stores the value set by {@link #excludeFromJVMCICompilation(Module...)} so that it can be</span>
<span class="line-added">+      * read from the VM.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @SuppressWarnings(&quot;unused&quot;)//</span>
<span class="line-added">+     @NativeImageReinitialize private Module[] excludeFromJVMCICompilation;</span>
  
      private final Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; backends = new HashMap&lt;&gt;();
  
      private volatile List&lt;HotSpotVMEventListener&gt; vmEventListeners;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 278,10 ***</span>
<span class="line-new-header">--- 442,20 ---</span>
          try (InitTimer t = timer(&quot;HotSpotVMConfig&lt;init&gt;&quot;)) {
              configStore = new HotSpotVMConfigStore(compilerToVm);
              config = new HotSpotVMConfig(configStore);
          }
  
<span class="line-added">+         reflection = IS_IN_NATIVE_IMAGE ? new SharedLibraryJVMCIReflection() : new HotSpotJDKReflection();</span>
<span class="line-added">+ </span>
<span class="line-added">+         PrintStream vmLogStream = null;</span>
<span class="line-added">+         if (IS_IN_NATIVE_IMAGE) {</span>
<span class="line-added">+             // Redirect System.out and System.err to HotSpot&#39;s TTY stream</span>
<span class="line-added">+             vmLogStream = new PrintStream(getLogStream());</span>
<span class="line-added">+             System.setOut(vmLogStream);</span>
<span class="line-added">+             System.setErr(vmLogStream);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          String hostArchitecture = config.getHostArchitectureName();
  
          HotSpotJVMCIBackendFactory factory;
          try (InitTimer t = timer(&quot;find factory:&quot;, hostArchitecture)) {
              factory = findFactory(hostArchitecture);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 289,142 ***</span>
  
          try (InitTimer t = timer(&quot;create JVMCI backend:&quot;, hostArchitecture)) {
              hostBackend = registerBackend(factory.createJVMCIBackend(this, null));
          }
  
<span class="line-removed">-         metaAccessContext = new HotSpotJVMCIMetaAccessContext();</span>
<span class="line-removed">- </span>
          compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();
          if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {
              hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;
<span class="line-modified">!             switch (hsCompilerFactory.getCompilationLevelAdjustment()) {</span>
<span class="line-modified">!                 case None:</span>
<span class="line-modified">!                     compilationLevelAdjustment = config.compLevelAdjustmentNone;</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 case ByHolder:</span>
<span class="line-removed">-                     compilationLevelAdjustment = config.compLevelAdjustmentByHolder;</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case ByFullSignature:</span>
<span class="line-removed">-                     compilationLevelAdjustment = config.compLevelAdjustmentByFullSignature;</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 default:</span>
<span class="line-removed">-                     compilationLevelAdjustment = config.compLevelAdjustmentNone;</span>
<span class="line-removed">-                     break;</span>
              }
          } else {
              hsCompilerFactory = null;
<span class="line-removed">-             compilationLevelAdjustment = config.compLevelAdjustmentNone;</span>
          }
  
          if (config.getFlag(&quot;JVMCIPrintProperties&quot;, Boolean.class)) {
<span class="line-modified">!             PrintStream out = new PrintStream(getLogStream());</span>
<span class="line-modified">!             Option.printProperties(out);</span>
<span class="line-modified">!             compilerFactory.printProperties(out);</span>
              System.exit(0);
          }
  
          if (Option.PrintConfig.getBoolean()) {
              configStore.printConfig();
          }
      }
  
      private JVMCIBackend registerBackend(JVMCIBackend backend) {
          Class&lt;? extends Architecture&gt; arch = backend.getCodeCache().getTarget().arch.getClass();
          JVMCIBackend oldValue = backends.put(arch, backend);
          assert oldValue == null : &quot;cannot overwrite existing backend for architecture &quot; + arch.getSimpleName();
          return backend;
      }
  
<span class="line-removed">-     ResolvedJavaType fromClass(Class&lt;?&gt; javaClass) {</span>
<span class="line-removed">-         return metaAccessContext.fromClass(javaClass);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      public HotSpotVMConfigStore getConfigStore() {
          return configStore;
      }
  
<span class="line-modified">!     HotSpotVMConfig getConfig() {</span>
          return config;
      }
  
<span class="line-modified">!     CompilerToVM getCompilerToVM() {</span>
          return compilerToVm;
      }
  
<span class="line-modified">!     // Non-volatile since multi-initialization is harmless</span>
<span class="line-modified">!     private Predicate&lt;ResolvedJavaType&gt; intrinsificationTrustPredicate;</span>
  
      /**
       * Gets a predicate that determines if a given type can be considered trusted for the purpose of
       * intrinsifying methods it declares.
       *
       * @param compilerLeafClasses classes in the leaves of the module graph comprising the JVMCI
       *            compiler.
       */
      public Predicate&lt;ResolvedJavaType&gt; getIntrinsificationTrustPredicate(Class&lt;?&gt;... compilerLeafClasses) {
<span class="line-modified">!         if (intrinsificationTrustPredicate == null) {</span>
<span class="line-modified">!             intrinsificationTrustPredicate = new Predicate&lt;&gt;() {</span>
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 public boolean test(ResolvedJavaType type) {</span>
<span class="line-modified">!                     if (type instanceof HotSpotResolvedJavaType) {</span>
<span class="line-modified">!                         Class&lt;?&gt; mirror = getMirror(type);</span>
<span class="line-modified">!                         Module module = mirror.getModule();</span>
<span class="line-modified">!                         return getTrustedModules().contains(module);</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         return false;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 private volatile Set&lt;Module&gt; trustedModules;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 private Set&lt;Module&gt; getTrustedModules() {</span>
<span class="line-removed">-                     Set&lt;Module&gt; modules = trustedModules;</span>
<span class="line-removed">-                     if (modules == null) {</span>
<span class="line-removed">-                         modules = new HashSet&lt;&gt;();</span>
<span class="line-removed">-                         for (Class&lt;?&gt; compilerConfiguration : compilerLeafClasses) {</span>
<span class="line-removed">-                             Module compilerConfigurationModule = compilerConfiguration.getModule();</span>
<span class="line-removed">-                             if (compilerConfigurationModule.getDescriptor().isAutomatic()) {</span>
<span class="line-removed">-                                 throw new IllegalArgumentException(String.format(&quot;The module &#39;%s&#39; defining the Graal compiler configuration class &#39;%s&#39; must not be an automatic module&quot;,</span>
<span class="line-removed">-                                                 compilerConfigurationModule.getName(), compilerConfiguration.getClass().getName()));</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                             modules.add(compilerConfigurationModule);</span>
<span class="line-removed">-                             for (Requires require : compilerConfigurationModule.getDescriptor().requires()) {</span>
<span class="line-removed">-                                 for (Module module : compilerConfigurationModule.getLayer().modules()) {</span>
<span class="line-removed">-                                     if (module.getName().equals(require.name())) {</span>
<span class="line-removed">-                                         modules.add(module);</span>
<span class="line-removed">-                                     }</span>
<span class="line-removed">-                                 }</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         trustedModules = modules;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     return modules;</span>
                  }
<span class="line-modified">!             };</span>
<span class="line-modified">!         }</span>
<span class="line-removed">-         return intrinsificationTrustPredicate;</span>
      }
  
      /**
       * Get the {@link Class} corresponding to {@code type}.
       *
       * @param type the type for which a {@link Class} is requested
       * @return the original Java class corresponding to {@code type} or {@code null} if this runtime
       *         does not support mapping {@link ResolvedJavaType} instances to {@link Class}
       *         instances
       */
<span class="line-removed">-     @SuppressWarnings(&quot;static-method&quot;)</span>
      public Class&lt;?&gt; getMirror(ResolvedJavaType type) {
<span class="line-modified">!         return ((HotSpotResolvedJavaType) type).mirror();</span>
      }
  
      @Override
      public JVMCICompiler getCompiler() {
          if (compiler == null) {
              synchronized (this) {
                  if (compiler == null) {
                      compiler = compilerFactory.createCompiler(this);
                  }
              }
          }
          return compiler;
      }
<span class="line-new-header">--- 463,174 ---</span>
  
          try (InitTimer t = timer(&quot;create JVMCI backend:&quot;, hostArchitecture)) {
              hostBackend = registerBackend(factory.createJVMCIBackend(this, null));
          }
  
          compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();
          if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {
              hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;
<span class="line-modified">!             if (hsCompilerFactory.getCompilationLevelAdjustment() != None) {</span>
<span class="line-modified">!                 String name = HotSpotJVMCICompilerFactory.class.getName();</span>
<span class="line-modified">!                 String msg = String.format(&quot;%s.getCompilationLevelAdjustment() is no longer supported. &quot; +</span>
<span class="line-modified">!                                 &quot;Use %s.excludeFromJVMCICompilation() instead.&quot;, name, name);</span>
<span class="line-modified">!                 throw new UnsupportedOperationException(msg);</span>
              }
          } else {
              hsCompilerFactory = null;
          }
  
          if (config.getFlag(&quot;JVMCIPrintProperties&quot;, Boolean.class)) {
<span class="line-modified">!             if (vmLogStream == null) {</span>
<span class="line-modified">!                 vmLogStream = new PrintStream(getLogStream());</span>
<span class="line-modified">!             }</span>
<span class="line-added">+             Option.printProperties(vmLogStream);</span>
<span class="line-added">+             compilerFactory.printProperties(vmLogStream);</span>
              System.exit(0);
          }
  
          if (Option.PrintConfig.getBoolean()) {
              configStore.printConfig();
          }
      }
  
<span class="line-added">+     HotSpotResolvedJavaType createClass(Class&lt;?&gt; javaClass) {</span>
<span class="line-added">+         if (javaClass.isPrimitive()) {</span>
<span class="line-added">+             return HotSpotResolvedPrimitiveType.forKind(JavaKind.fromJavaClass(javaClass));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (IS_IN_NATIVE_IMAGE) {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 return compilerToVm.lookupType(javaClass.getName().replace(&#39;.&#39;, &#39;/&#39;), null, true);</span>
<span class="line-added">+             } catch (ClassNotFoundException e) {</span>
<span class="line-added">+                 throw new JVMCIError(e);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return compilerToVm.lookupClass(javaClass);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private HotSpotResolvedJavaType fromClass0(Class&lt;?&gt; javaClass) {</span>
<span class="line-added">+         if (resolvedJavaType == null) {</span>
<span class="line-added">+             synchronized (this) {</span>
<span class="line-added">+                 if (resolvedJavaType == null) {</span>
<span class="line-added">+                     resolvedJavaType = new ClassValue&lt;&gt;() {</span>
<span class="line-added">+                         @Override</span>
<span class="line-added">+                         protected WeakReferenceHolder&lt;HotSpotResolvedJavaType&gt; computeValue(Class&lt;?&gt; type) {</span>
<span class="line-added">+                             return new WeakReferenceHolder&lt;&gt;(createClass(type));</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     };</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         WeakReferenceHolder&lt;HotSpotResolvedJavaType&gt; ref = resolvedJavaType.get(javaClass);</span>
<span class="line-added">+         HotSpotResolvedJavaType javaType = ref.get();</span>
<span class="line-added">+         if (javaType == null) {</span>
<span class="line-added">+             /*</span>
<span class="line-added">+              * If the referent has become null, create a new value and update cached weak reference.</span>
<span class="line-added">+              */</span>
<span class="line-added">+             javaType = createClass(javaClass);</span>
<span class="line-added">+             ref.set(javaType);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return javaType;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Gets the JVMCI mirror for a {@link Class} object.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}</span>
<span class="line-added">+      */</span>
<span class="line-added">+     HotSpotResolvedJavaType fromClass(Class&lt;?&gt; javaClass) {</span>
<span class="line-added">+         if (javaClass == null) {</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return fromClass0(javaClass);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     synchronized HotSpotResolvedObjectTypeImpl fromMetaspace(long klassPointer, String signature) {</span>
<span class="line-added">+         if (resolvedJavaTypes == null) {</span>
<span class="line-added">+             resolvedJavaTypes = new HashMap&lt;&gt;();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         assert klassPointer != 0;</span>
<span class="line-added">+         WeakReference&lt;ResolvedJavaType&gt; klassReference = resolvedJavaTypes.get(klassPointer);</span>
<span class="line-added">+         HotSpotResolvedObjectTypeImpl javaType = null;</span>
<span class="line-added">+         if (klassReference != null) {</span>
<span class="line-added">+             javaType = (HotSpotResolvedObjectTypeImpl) klassReference.get();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (javaType == null) {</span>
<span class="line-added">+             javaType = new HotSpotResolvedObjectTypeImpl(klassPointer, signature);</span>
<span class="line-added">+             resolvedJavaTypes.put(klassPointer, new WeakReference&lt;&gt;(javaType));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return javaType;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private JVMCIBackend registerBackend(JVMCIBackend backend) {
          Class&lt;? extends Architecture&gt; arch = backend.getCodeCache().getTarget().arch.getClass();
          JVMCIBackend oldValue = backends.put(arch, backend);
          assert oldValue == null : &quot;cannot overwrite existing backend for architecture &quot; + arch.getSimpleName();
          return backend;
      }
  
      public HotSpotVMConfigStore getConfigStore() {
          return configStore;
      }
  
<span class="line-modified">!     public HotSpotVMConfig getConfig() {</span>
          return config;
      }
  
<span class="line-modified">!     public CompilerToVM getCompilerToVM() {</span>
          return compilerToVm;
      }
  
<span class="line-modified">!     HotSpotJVMCIReflection getReflection() {</span>
<span class="line-modified">!         return reflection;</span>
<span class="line-added">+     }</span>
  
      /**
       * Gets a predicate that determines if a given type can be considered trusted for the purpose of
       * intrinsifying methods it declares.
       *
       * @param compilerLeafClasses classes in the leaves of the module graph comprising the JVMCI
       *            compiler.
       */
      public Predicate&lt;ResolvedJavaType&gt; getIntrinsificationTrustPredicate(Class&lt;?&gt;... compilerLeafClasses) {
<span class="line-modified">!         return new Predicate&lt;&gt;() {</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             public boolean test(ResolvedJavaType type) {</span>
<span class="line-modified">!                 if (type instanceof HotSpotResolvedObjectTypeImpl) {</span>
<span class="line-modified">!                     HotSpotResolvedObjectTypeImpl hsType = (HotSpotResolvedObjectTypeImpl) type;</span>
<span class="line-modified">!                     return compilerToVm.isTrustedForIntrinsics(hsType);</span>
<span class="line-modified">!                 } else {</span>
<span class="line-modified">!                     return false;</span>
                  }
<span class="line-modified">!             }</span>
<span class="line-modified">!         };</span>
      }
  
      /**
       * Get the {@link Class} corresponding to {@code type}.
       *
       * @param type the type for which a {@link Class} is requested
       * @return the original Java class corresponding to {@code type} or {@code null} if this runtime
       *         does not support mapping {@link ResolvedJavaType} instances to {@link Class}
       *         instances
       */
      public Class&lt;?&gt; getMirror(ResolvedJavaType type) {
<span class="line-modified">!         if (type instanceof HotSpotResolvedJavaType &amp;&amp; reflection instanceof HotSpotJDKReflection) {</span>
<span class="line-added">+             return ((HotSpotJDKReflection) reflection).getMirror((HotSpotResolvedJavaType) type);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return null;</span>
      }
  
      @Override
      public JVMCICompiler getCompiler() {
          if (compiler == null) {
              synchronized (this) {
                  if (compiler == null) {
<span class="line-added">+                     assert !creatingCompiler : &quot;recursive compiler creation&quot;;</span>
<span class="line-added">+                     creatingCompiler = true;</span>
                      compiler = compilerFactory.createCompiler(this);
<span class="line-added">+                     creatingCompiler = false;</span>
                  }
              }
          }
          return compiler;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 442,23 ***</span>
       * @throws LinkageError if {@code resolve == true} and the resolution failed
       * @throws NullPointerException if {@code accessingClass} is {@code null}
       */
      public JavaType lookupType(String name, HotSpotResolvedObjectType accessingType, boolean resolve) {
          Objects.requireNonNull(accessingType, &quot;cannot resolve type without an accessing class&quot;);
          // If the name represents a primitive type we can short-circuit the lookup.
          if (name.length() == 1) {
              JavaKind kind = JavaKind.fromPrimitiveOrVoidTypeChar(name.charAt(0));
<span class="line-modified">!             return fromClass(kind.toJavaClass());</span>
          }
  
          // Resolve non-primitive types in the VM.
          HotSpotResolvedObjectTypeImpl hsAccessingType = (HotSpotResolvedObjectTypeImpl) accessingType;
          try {
<span class="line-modified">!             final HotSpotResolvedObjectTypeImpl klass = compilerToVm.lookupType(name, hsAccessingType.mirror(), resolve);</span>
  
              if (klass == null) {
<span class="line-modified">!                 assert resolve == false;</span>
                  return UnresolvedJavaType.create(name);
              }
              return klass;
          } catch (ClassNotFoundException e) {
              throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);
<span class="line-new-header">--- 648,27 ---</span>
       * @throws LinkageError if {@code resolve == true} and the resolution failed
       * @throws NullPointerException if {@code accessingClass} is {@code null}
       */
      public JavaType lookupType(String name, HotSpotResolvedObjectType accessingType, boolean resolve) {
          Objects.requireNonNull(accessingType, &quot;cannot resolve type without an accessing class&quot;);
<span class="line-added">+         return lookupTypeInternal(name, accessingType, resolve);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     JavaType lookupTypeInternal(String name, HotSpotResolvedObjectType accessingType, boolean resolve) {</span>
          // If the name represents a primitive type we can short-circuit the lookup.
          if (name.length() == 1) {
              JavaKind kind = JavaKind.fromPrimitiveOrVoidTypeChar(name.charAt(0));
<span class="line-modified">!             return HotSpotResolvedPrimitiveType.forKind(kind);</span>
          }
  
          // Resolve non-primitive types in the VM.
          HotSpotResolvedObjectTypeImpl hsAccessingType = (HotSpotResolvedObjectTypeImpl) accessingType;
          try {
<span class="line-modified">!             final HotSpotResolvedJavaType klass = compilerToVm.lookupType(name, hsAccessingType, resolve);</span>
  
              if (klass == null) {
<span class="line-modified">!                 assert resolve == false : name;</span>
                  return UnresolvedJavaType.create(name);
              }
              return klass;
          } catch (ClassNotFoundException e) {
              throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 478,52 ***</span>
  
      public Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; getJVMCIBackends() {
          return Collections.unmodifiableMap(backends);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Called from the VM.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     @SuppressWarnings({&quot;unused&quot;})</span>
<span class="line-modified">!     private int adjustCompilationLevel(Class&lt;?&gt; declaringClass, String name, String signature, boolean isOsr, int level) {</span>
<span class="line-removed">-         CompilationLevel curLevel;</span>
<span class="line-removed">-         if (level == config.compilationLevelNone) {</span>
<span class="line-removed">-             curLevel = CompilationLevel.None;</span>
<span class="line-removed">-         } else if (level == config.compilationLevelSimple) {</span>
<span class="line-removed">-             curLevel = CompilationLevel.Simple;</span>
<span class="line-removed">-         } else if (level == config.compilationLevelLimitedProfile) {</span>
<span class="line-removed">-             curLevel = CompilationLevel.LimitedProfile;</span>
<span class="line-removed">-         } else if (level == config.compilationLevelFullProfile) {</span>
<span class="line-removed">-             curLevel = CompilationLevel.FullProfile;</span>
<span class="line-removed">-         } else if (level == config.compilationLevelFullOptimization) {</span>
<span class="line-removed">-             curLevel = CompilationLevel.FullOptimization;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             throw JVMCIError.shouldNotReachHere();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         switch (hsCompilerFactory.adjustCompilationLevel(declaringClass, name, signature, isOsr, curLevel)) {</span>
<span class="line-removed">-             case None:</span>
<span class="line-removed">-                 return config.compilationLevelNone;</span>
<span class="line-removed">-             case Simple:</span>
<span class="line-removed">-                 return config.compilationLevelSimple;</span>
<span class="line-removed">-             case LimitedProfile:</span>
<span class="line-removed">-                 return config.compilationLevelLimitedProfile;</span>
<span class="line-removed">-             case FullProfile:</span>
<span class="line-removed">-                 return config.compilationLevelFullProfile;</span>
<span class="line-removed">-             case FullOptimization:</span>
<span class="line-removed">-                 return config.compilationLevelFullOptimization;</span>
<span class="line-removed">-             default:</span>
<span class="line-removed">-                 return level;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Called from the VM.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     @SuppressWarnings({&quot;unused&quot;})</span>
<span class="line-removed">-     private HotSpotCompilationRequestResult compileMethod(HotSpotResolvedJavaMethod method, int entryBCI, long jvmciEnv, int id) {</span>
<span class="line-removed">-         CompilationRequestResult result = getCompiler().compileMethod(new HotSpotCompilationRequest(method, entryBCI, jvmciEnv, id));</span>
          assert result != null : &quot;compileMethod must always return something&quot;;
          HotSpotCompilationRequestResult hsResult;
          if (result instanceof HotSpotCompilationRequestResult) {
              hsResult = (HotSpotCompilationRequestResult) result;
          } else {
<span class="line-new-header">--- 688,15 ---</span>
  
      public Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; getJVMCIBackends() {
          return Collections.unmodifiableMap(backends);
      }
  
<span class="line-modified">!     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-modified">!     @VMEntryPoint</span>
<span class="line-modified">!     private HotSpotCompilationRequestResult compileMethod(HotSpotResolvedJavaMethod method, int entryBCI, long compileState, int id) {</span>
<span class="line-modified">!         HotSpotCompilationRequest request = new HotSpotCompilationRequest(method, entryBCI, compileState, id);</span>
<span class="line-modified">!         CompilationRequestResult result = getCompiler().compileMethod(request);</span>
          assert result != null : &quot;compileMethod must always return something&quot;;
          HotSpotCompilationRequestResult hsResult;
          if (result instanceof HotSpotCompilationRequestResult) {
              hsResult = (HotSpotCompilationRequestResult) result;
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 534,32 ***</span>
              } else {
                  int inlinedBytecodes = -1;
                  hsResult = HotSpotCompilationRequestResult.success(inlinedBytecodes);
              }
          }
<span class="line-removed">- </span>
          return hsResult;
      }
  
      /**
       * Shuts down the runtime.
<span class="line-removed">-      *</span>
<span class="line-removed">-      * Called from the VM.</span>
       */
<span class="line-modified">!     @SuppressWarnings({&quot;unused&quot;})</span>
      private void shutdown() throws Exception {
          for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
              vmEventListener.notifyShutdown();
          }
      }
  
      /**
       * Notify on completion of a bootstrap.
<span class="line-removed">-      *</span>
<span class="line-removed">-      * Called from the VM.</span>
       */
<span class="line-modified">!     @SuppressWarnings({&quot;unused&quot;})</span>
      private void bootstrapFinished() throws Exception {
          for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
              vmEventListener.notifyBootstrapFinished();
          }
      }
<span class="line-new-header">--- 707,31 ---</span>
              } else {
                  int inlinedBytecodes = -1;
                  hsResult = HotSpotCompilationRequestResult.success(inlinedBytecodes);
              }
          }
          return hsResult;
      }
  
      /**
       * Shuts down the runtime.
       */
<span class="line-modified">!     @VMEntryPoint</span>
      private void shutdown() throws Exception {
<span class="line-added">+         // Cleaners are normally only processed when a new Cleaner is</span>
<span class="line-added">+         // instantiated so process all remaining cleaners now.</span>
<span class="line-added">+         Cleaner.clean();</span>
<span class="line-added">+ </span>
          for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
              vmEventListener.notifyShutdown();
          }
      }
  
      /**
       * Notify on completion of a bootstrap.
       */
<span class="line-modified">!     @VMEntryPoint</span>
      private void bootstrapFinished() throws Exception {
          for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
              vmEventListener.notifyBootstrapFinished();
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 575,10 ***</span>
<span class="line-new-header">--- 747,27 ---</span>
          for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
              vmEventListener.notifyInstall(hotSpotCodeCacheProvider, installedCode, compiledCode);
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Writes {@code length} bytes from {@code bytes} starting at offset {@code offset} to HotSpot&#39;s</span>
<span class="line-added">+      * log stream.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param flush specifies if the log stream should be flushed after writing</span>
<span class="line-added">+      * @param canThrow specifies if an error in the {@code bytes}, {@code offset} or {@code length}</span>
<span class="line-added">+      *            arguments should result in an exception or a negative return value. If</span>
<span class="line-added">+      *            {@code false}, this call will not perform any heap allocation</span>
<span class="line-added">+      * @return 0 on success, -1 if {@code bytes == null &amp;&amp; !canThrow}, -2 if {@code !canThrow} and</span>
<span class="line-added">+      *         copying would cause access of data outside array bounds</span>
<span class="line-added">+      * @throws NullPointerException if {@code bytes == null}</span>
<span class="line-added">+      * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public int writeDebugOutput(byte[] bytes, int offset, int length, boolean flush, boolean canThrow) {</span>
<span class="line-added">+         return compilerToVm.writeDebugOutput(bytes, offset, length, flush, canThrow);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Gets an output stream that writes to HotSpot&#39;s {@code tty} stream.
       */
      public OutputStream getLogStream() {
          return new OutputStream() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 590,11 ***</span>
                  } else if (off &lt; 0 || off &gt; b.length || len &lt; 0 || (off + len) &gt; b.length || (off + len) &lt; 0) {
                      throw new IndexOutOfBoundsException();
                  } else if (len == 0) {
                      return;
                  }
<span class="line-modified">!                 compilerToVm.writeDebugOutput(b, off, len);</span>
              }
  
              @Override
              public void write(int b) throws IOException {
                  write(new byte[]{(byte) b}, 0, 1);
<span class="line-new-header">--- 779,11 ---</span>
                  } else if (off &lt; 0 || off &gt; b.length || len &lt; 0 || (off + len) &gt; b.length || (off + len) &lt; 0) {
                      throw new IndexOutOfBoundsException();
                  } else if (len == 0) {
                      return;
                  }
<span class="line-modified">!                 compilerToVm.writeDebugOutput(b, off, len, false, true);</span>
              }
  
              @Override
              public void write(int b) throws IOException {
                  write(new byte[]{(byte) b}, 0, 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 612,36 ***</span>
       */
      public long[] collectCounters() {
          return compilerToVm.collectCounters();
      }
  
      /**
       * The offset from the origin of an array to the first element.
       *
       * @return the offset in bytes
       */
<span class="line-removed">-     @SuppressWarnings(&quot;static-method&quot;)</span>
      public int getArrayBaseOffset(JavaKind kind) {
          switch (kind) {
              case Boolean:
<span class="line-modified">!                 return Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;</span>
              case Byte:
<span class="line-modified">!                 return Unsafe.ARRAY_BYTE_BASE_OFFSET;</span>
              case Char:
<span class="line-modified">!                 return Unsafe.ARRAY_CHAR_BASE_OFFSET;</span>
              case Short:
<span class="line-modified">!                 return Unsafe.ARRAY_SHORT_BASE_OFFSET;</span>
              case Int:
<span class="line-modified">!                 return Unsafe.ARRAY_INT_BASE_OFFSET;</span>
              case Long:
<span class="line-modified">!                 return Unsafe.ARRAY_LONG_BASE_OFFSET;</span>
              case Float:
<span class="line-modified">!                 return Unsafe.ARRAY_FLOAT_BASE_OFFSET;</span>
              case Double:
<span class="line-modified">!                 return Unsafe.ARRAY_DOUBLE_BASE_OFFSET;</span>
              case Object:
<span class="line-modified">!                 return Unsafe.ARRAY_OBJECT_BASE_OFFSET;</span>
              default:
                  throw new JVMCIError(&quot;%s&quot;, kind);
          }
  
      }
<span class="line-new-header">--- 801,54 ---</span>
       */
      public long[] collectCounters() {
          return compilerToVm.collectCounters();
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * @return the current number of per thread counters. May be set through</span>
<span class="line-added">+      *         {@code -XX:JVMCICompilerSize=} command line option or the</span>
<span class="line-added">+      *         {@link #setCountersSize(int)} call.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public int getCountersSize() {</span>
<span class="line-added">+         return compilerToVm.getCountersSize();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Enlarge the number of per thread counters available. Requires a safepoint so</span>
<span class="line-added">+      * resizing should be rare to avoid performance effects.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param newSize</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public void setCountersSize(int newSize) {</span>
<span class="line-added">+         compilerToVm.setCountersSize(newSize);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * The offset from the origin of an array to the first element.
       *
       * @return the offset in bytes
       */
      public int getArrayBaseOffset(JavaKind kind) {
          switch (kind) {
              case Boolean:
<span class="line-modified">!                 return compilerToVm.ARRAY_BOOLEAN_BASE_OFFSET;</span>
              case Byte:
<span class="line-modified">!                 return compilerToVm.ARRAY_BYTE_BASE_OFFSET;</span>
              case Char:
<span class="line-modified">!                 return compilerToVm.ARRAY_CHAR_BASE_OFFSET;</span>
              case Short:
<span class="line-modified">!                 return compilerToVm.ARRAY_SHORT_BASE_OFFSET;</span>
              case Int:
<span class="line-modified">!                 return compilerToVm.ARRAY_INT_BASE_OFFSET;</span>
              case Long:
<span class="line-modified">!                 return compilerToVm.ARRAY_LONG_BASE_OFFSET;</span>
              case Float:
<span class="line-modified">!                 return compilerToVm.ARRAY_FLOAT_BASE_OFFSET;</span>
              case Double:
<span class="line-modified">!                 return compilerToVm.ARRAY_DOUBLE_BASE_OFFSET;</span>
              case Object:
<span class="line-modified">!                 return compilerToVm.ARRAY_OBJECT_BASE_OFFSET;</span>
              default:
                  throw new JVMCIError(&quot;%s&quot;, kind);
          }
  
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 649,42 ***</span>
      /**
       * The scale used for the index when accessing elements of an array of this kind.
       *
       * @return the scale in order to convert the index into a byte offset
       */
<span class="line-removed">-     @SuppressWarnings(&quot;static-method&quot;)</span>
      public int getArrayIndexScale(JavaKind kind) {
          switch (kind) {
              case Boolean:
<span class="line-modified">!                 return Unsafe.ARRAY_BOOLEAN_INDEX_SCALE;</span>
              case Byte:
<span class="line-modified">!                 return Unsafe.ARRAY_BYTE_INDEX_SCALE;</span>
              case Char:
<span class="line-modified">!                 return Unsafe.ARRAY_CHAR_INDEX_SCALE;</span>
              case Short:
<span class="line-modified">!                 return Unsafe.ARRAY_SHORT_INDEX_SCALE;</span>
              case Int:
<span class="line-modified">!                 return Unsafe.ARRAY_INT_INDEX_SCALE;</span>
              case Long:
<span class="line-modified">!                 return Unsafe.ARRAY_LONG_INDEX_SCALE;</span>
              case Float:
<span class="line-modified">!                 return Unsafe.ARRAY_FLOAT_INDEX_SCALE;</span>
              case Double:
<span class="line-modified">!                 return Unsafe.ARRAY_DOUBLE_INDEX_SCALE;</span>
              case Object:
<span class="line-modified">!                 return Unsafe.ARRAY_OBJECT_INDEX_SCALE;</span>
              default:
                  throw new JVMCIError(&quot;%s&quot;, kind);
  
          }
      }
  
      /**
<span class="line-modified">!      * Links each native method in {@code clazz} to an implementation in the JVMCI SVM library.</span>
       * &lt;p&gt;
       * A use case for this is a JVMCI compiler implementation that offers an API to Java code
<span class="line-modified">!      * executing in HotSpot to exercise functionality (mostly) in the JVMCI SVM library. For</span>
       * example:
       *
       * &lt;pre&gt;
       * package com.jcompile;
       *
<span class="line-new-header">--- 856,41 ---</span>
      /**
       * The scale used for the index when accessing elements of an array of this kind.
       *
       * @return the scale in order to convert the index into a byte offset
       */
      public int getArrayIndexScale(JavaKind kind) {
          switch (kind) {
              case Boolean:
<span class="line-modified">!                 return compilerToVm.ARRAY_BOOLEAN_INDEX_SCALE;</span>
              case Byte:
<span class="line-modified">!                 return compilerToVm.ARRAY_BYTE_INDEX_SCALE;</span>
              case Char:
<span class="line-modified">!                 return compilerToVm.ARRAY_CHAR_INDEX_SCALE;</span>
              case Short:
<span class="line-modified">!                 return compilerToVm.ARRAY_SHORT_INDEX_SCALE;</span>
              case Int:
<span class="line-modified">!                 return compilerToVm.ARRAY_INT_INDEX_SCALE;</span>
              case Long:
<span class="line-modified">!                 return compilerToVm.ARRAY_LONG_INDEX_SCALE;</span>
              case Float:
<span class="line-modified">!                 return compilerToVm.ARRAY_FLOAT_INDEX_SCALE;</span>
              case Double:
<span class="line-modified">!                 return compilerToVm.ARRAY_DOUBLE_INDEX_SCALE;</span>
              case Object:
<span class="line-modified">!                 return compilerToVm.ARRAY_OBJECT_INDEX_SCALE;</span>
              default:
                  throw new JVMCIError(&quot;%s&quot;, kind);
  
          }
      }
  
      /**
<span class="line-modified">!      * Links each native method in {@code clazz} to an implementation in the JVMCI shared library.</span>
       * &lt;p&gt;
       * A use case for this is a JVMCI compiler implementation that offers an API to Java code
<span class="line-modified">!      * executing in HotSpot to exercise functionality (mostly) in the JVMCI shared library. For</span>
       * example:
       *
       * &lt;pre&gt;
       * package com.jcompile;
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 705,29 ***</span>
       *     private static long getHandle(Method method) { ... }
       *     private static char[] convertToCharArray(String[] a) { ... }
       * }
       * &lt;/pre&gt;
       *
<span class="line-modified">!      * The implementation of the native {@code JCompile.compile0} method would be in the SVM library</span>
<span class="line-modified">!      * that contains the bulk of the JVMCI compiler. The {@code JCompile.compile0} implementation</span>
<span class="line-modified">!      * will be exported as the following JNI-compliant symbol:</span>
       *
       * &lt;pre&gt;
       * Java_com_jcompile_JCompile_compile0
       * &lt;/pre&gt;
       *
<span class="line-modified">!      * How the JVMCI compiler SVM library is built is outside the scope of this document.</span>
       *
<span class="line-removed">-      * @see &quot;https://docs.oracle.com/javase/10/docs/specs/jni/design.html#resolving-native-method-names&quot;</span>
       *
       * @throws NullPointerException if {@code clazz == null}
<span class="line-modified">!      * @throws IllegalArgumentException if the current execution context is SVM or if {@code clazz}</span>
<span class="line-modified">!      *             is {@link Class#isPrimitive()}</span>
<span class="line-modified">!      * @throws UnsatisfiedLinkError if the JVMCI SVM library is not available, a native method in</span>
<span class="line-modified">!      *             {@code clazz} is already linked or the SVM JVMCI library does not contain a</span>
<span class="line-modified">!      *             JNI-compliant symbol for a native method in {@code clazz}</span>
       */
<span class="line-modified">!     @SuppressWarnings({&quot;static-method&quot;, &quot;unused&quot;})</span>
<span class="line-modified">!     public void registerNativeMethods(Class&lt;?&gt; clazz) {</span>
<span class="line-modified">!         throw new UnsatisfiedLinkError(&quot;SVM library is not available&quot;);</span>
      }
  }
<span class="line-new-header">--- 911,146 ---</span>
       *     private static long getHandle(Method method) { ... }
       *     private static char[] convertToCharArray(String[] a) { ... }
       * }
       * &lt;/pre&gt;
       *
<span class="line-modified">!      * The implementation of the native {@code JCompile.compile0} method would be in the JVMCI</span>
<span class="line-modified">!      * shared library that contains the bulk of the JVMCI compiler. The {@code JCompile.compile0}</span>
<span class="line-modified">!      * implementation will be exported as the following JNI-compatible symbol:</span>
       *
       * &lt;pre&gt;
       * Java_com_jcompile_JCompile_compile0
       * &lt;/pre&gt;
       *
<span class="line-modified">!      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#resolving_native_method_names&quot;</span>
<span class="line-added">+      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#creating_the_vm&quot;</span>
<span class="line-added">+      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#invocation_api_functions&quot;</span>
       *
       *
<span class="line-added">+      * @return an array of 4 longs where the first value is the {@code JavaVM*} value representing</span>
<span class="line-added">+      *         the Java VM in the JVMCI shared library, and the remaining values are the first 3</span>
<span class="line-added">+      *         pointers in the Invocation API function table (i.e., {@code JNIInvokeInterface})</span>
       * @throws NullPointerException if {@code clazz == null}
<span class="line-modified">!      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.</span>
<span class="line-modified">!      *             {@code -XX:-UseJVMCINativeLibrary})</span>
<span class="line-modified">!      * @throws IllegalStateException if the current execution context is the JVMCI shared library</span>
<span class="line-modified">!      * @throws IllegalArgumentException if {@code clazz} is {@link Class#isPrimitive()}</span>
<span class="line-modified">!      * @throws UnsatisfiedLinkError if there&#39;s a problem linking a native method in {@code clazz}</span>
<span class="line-added">+      *             (no matching JNI symbol or the native method is already linked to a different</span>
<span class="line-added">+      *             address)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public long[] registerNativeMethods(Class&lt;?&gt; clazz) {</span>
<span class="line-added">+         return compilerToVm.registerNativeMethods(clazz);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Creates or retrieves an object in the peer runtime that mirrors {@code obj}. The types whose</span>
<span class="line-added">+      * objects can be translated are:</span>
<span class="line-added">+      * &lt;ul&gt;</span>
<span class="line-added">+      * &lt;li&gt;{@link HotSpotResolvedJavaMethodImpl},&lt;/li&gt;</span>
<span class="line-added">+      * &lt;li&gt;{@link HotSpotResolvedObjectTypeImpl},&lt;/li&gt;</span>
<span class="line-added">+      * &lt;li&gt;{@link HotSpotResolvedPrimitiveType},&lt;/li&gt;</span>
<span class="line-added">+      * &lt;li&gt;{@link IndirectHotSpotObjectConstantImpl},&lt;/li&gt;</span>
<span class="line-added">+      * &lt;li&gt;{@link DirectHotSpotObjectConstantImpl} and&lt;/li&gt;</span>
<span class="line-added">+      * &lt;li&gt;{@link HotSpotNmethod}&lt;/li&gt;</span>
<span class="line-added">+      * &lt;/ul&gt;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * This mechanism can be used to pass and return values between the HotSpot and JVMCI shared</span>
<span class="line-added">+      * library runtimes. In the receiving runtime, the value can be converted back to an object with</span>
<span class="line-added">+      * {@link #unhand(Class, long)}.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param obj an object for which an equivalent instance in the peer runtime is requested</span>
<span class="line-added">+      * @return a JNI global reference to the mirror of {@code obj} in the peer runtime</span>
<span class="line-added">+      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.</span>
<span class="line-added">+      *             {@code -XX:-UseJVMCINativeLibrary})</span>
<span class="line-added">+      * @throws IllegalArgumentException if {@code obj} is not of a translatable type</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#global_and_local_references&quot;</span>
       */
<span class="line-modified">!     public long translate(Object obj) {</span>
<span class="line-modified">!         return compilerToVm.translate(obj);</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Dereferences and returns the object referred to by the JNI global reference {@code handle}.</span>
<span class="line-added">+      * The global reference is deleted prior to returning. Any further use of {@code handle} is</span>
<span class="line-added">+      * invalid.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param handle a JNI global reference to an object in the current runtime</span>
<span class="line-added">+      * @return the object referred to by {@code handle}</span>
<span class="line-added">+      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.</span>
<span class="line-added">+      *             {@code -XX:-UseJVMCINativeLibrary})</span>
<span class="line-added">+      * @throws ClassCastException if the returned object cannot be cast to {@code type}</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#global_and_local_references&quot;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public &lt;T&gt; T unhand(Class&lt;T&gt; type, long handle) {</span>
<span class="line-added">+         return type.cast(compilerToVm.unhand(handle));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Determines if the current thread is attached to the peer runtime.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.</span>
<span class="line-added">+      *             {@code -XX:-UseJVMCINativeLibrary})</span>
<span class="line-added">+      * @throws IllegalStateException if the peer runtime has not been initialized</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public boolean isCurrentThreadAttached() {</span>
<span class="line-added">+         return compilerToVm.isCurrentThreadAttached();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Gets the address of the HotSpot {@code JavaThread} C++ object for the current thread. This</span>
<span class="line-added">+      * will return {@code 0} if called from an unattached JVMCI shared library thread.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public long getCurrentJavaThread() {</span>
<span class="line-added">+         return compilerToVm.getCurrentJavaThread();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Ensures the current thread is attached to the peer runtime.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param asDaemon if the thread is not yet attached, should it be attached as a daemon</span>
<span class="line-added">+      * @return {@code true} if this call attached the current thread, {@code false} if the current</span>
<span class="line-added">+      *         thread was already attached</span>
<span class="line-added">+      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.</span>
<span class="line-added">+      *             {@code -XX:-UseJVMCINativeLibrary})</span>
<span class="line-added">+      * @throws IllegalStateException if the peer runtime has not been initialized or there is an</span>
<span class="line-added">+      *             error while trying to attach the thread</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public boolean attachCurrentThread(boolean asDaemon) {</span>
<span class="line-added">+         return compilerToVm.attachCurrentThread(asDaemon);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Detaches the current thread from the peer runtime.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.</span>
<span class="line-added">+      *             {@code -XX:-UseJVMCINativeLibrary})</span>
<span class="line-added">+      * @throws IllegalStateException if the peer runtime has not been initialized or if the current</span>
<span class="line-added">+      *             thread is not attached or if there is an error while trying to detach the thread</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public void detachCurrentThread() {</span>
<span class="line-added">+         compilerToVm.detachCurrentThread();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Informs HotSpot that no method whose module is in {@code modules} is to be compiled</span>
<span class="line-added">+      * with {@link #compileMethod}.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param modules the set of modules containing JVMCI compiler classes</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public void excludeFromJVMCICompilation(Module...modules) {</span>
<span class="line-added">+         this.excludeFromJVMCICompilation = modules.clone();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Calls {@link System#exit(int)} in HotSpot&#39;s runtime.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public void exitHotSpot(int status) {</span>
<span class="line-added">+         if (!IS_IN_NATIVE_IMAGE) {</span>
<span class="line-added">+             System.exit(status);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         compilerToVm.callSystemExit(status);</span>
      }
  }
</pre>
<center><a href="HotSpotJVMCICompilerConfig.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotMemoryAccessProviderImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
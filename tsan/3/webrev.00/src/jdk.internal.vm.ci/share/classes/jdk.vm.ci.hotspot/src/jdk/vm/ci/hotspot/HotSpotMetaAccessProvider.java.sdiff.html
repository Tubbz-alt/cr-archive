<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMetaAccessProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotMemoryAccessProviderImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotMetaData.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMetaAccessProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
<span class="line-removed"> 25 import static jdk.vm.ci.hotspot.HotSpotResolvedObjectTypeImpl.fromObjectClass;</span>
<span class="line-removed"> 26 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;</span>
<span class="line-removed"> 27 </span>
<span class="line-removed"> 28 import java.lang.reflect.Array;</span>
 29 import java.lang.reflect.Executable;
 30 import java.lang.reflect.Field;
 31 import java.lang.reflect.Modifier;
 32 import java.util.Objects;
 33 
 34 import jdk.vm.ci.code.CodeUtil;
 35 import jdk.vm.ci.common.JVMCIError;
 36 import jdk.vm.ci.meta.DeoptimizationAction;
 37 import jdk.vm.ci.meta.DeoptimizationReason;
 38 import jdk.vm.ci.meta.JavaConstant;
 39 import jdk.vm.ci.meta.JavaKind;
 40 import jdk.vm.ci.meta.MetaAccessProvider;
 41 import jdk.vm.ci.meta.ResolvedJavaField;
 42 import jdk.vm.ci.meta.ResolvedJavaMethod;
 43 import jdk.vm.ci.meta.ResolvedJavaType;
 44 import jdk.vm.ci.meta.Signature;
 45 import jdk.vm.ci.meta.SpeculationLog;


 46 
 47 // JaCoCo Exclude
 48 
 49 /**
 50  * HotSpot implementation of {@link MetaAccessProvider}.
 51  */
 52 public class HotSpotMetaAccessProvider implements MetaAccessProvider {
 53 
 54     protected final HotSpotJVMCIRuntime runtime;
 55 
 56     public HotSpotMetaAccessProvider(HotSpotJVMCIRuntime runtime) {
 57         this.runtime = runtime;
 58     }
 59 
 60     @Override
 61     public ResolvedJavaType lookupJavaType(Class&lt;?&gt; clazz) {
 62         if (clazz == null) {
 63             throw new IllegalArgumentException(&quot;Class parameter was null&quot;);
 64         }
 65         return runtime.fromClass(clazz);
</pre>
<hr />
<pre>
 70         if (constant.isNull() || !(constant instanceof HotSpotObjectConstant)) {
 71             return null;
 72         }
 73         return ((HotSpotObjectConstant) constant).getType();
 74     }
 75 
 76     @Override
 77     public Signature parseMethodDescriptor(String signature) {
 78         return new HotSpotSignature(runtime, signature);
 79     }
 80 
 81     @Override
 82     public ResolvedJavaMethod lookupJavaMethod(Executable reflectionMethod) {
 83         return runtime.getCompilerToVM().asResolvedJavaMethod(Objects.requireNonNull(reflectionMethod));
 84     }
 85 
 86     @Override
 87     public ResolvedJavaField lookupJavaField(Field reflectionField) {
 88         Class&lt;?&gt; fieldHolder = reflectionField.getDeclaringClass();
 89 
<span class="line-modified"> 90         HotSpotResolvedObjectType holder = fromObjectClass(fieldHolder);</span>


 91         if (Modifier.isStatic(reflectionField.getModifiers())) {
<span class="line-modified"> 92             final long offset = UNSAFE.staticFieldOffset(reflectionField);</span>
<span class="line-removed"> 93             for (ResolvedJavaField field : holder.getStaticFields()) {</span>
<span class="line-removed"> 94                 if (offset == ((HotSpotResolvedJavaField) field).getOffset()) {</span>
<span class="line-removed"> 95                     return field;</span>
<span class="line-removed"> 96                 }</span>
<span class="line-removed"> 97             }</span>
 98         } else {
<span class="line-modified"> 99             final long offset = UNSAFE.objectFieldOffset(reflectionField);</span>
<span class="line-modified">100             for (ResolvedJavaField field : holder.getInstanceFields(false)) {</span>
<span class="line-modified">101                 if (offset == ((HotSpotResolvedJavaField) field).getOffset()) {</span>
<span class="line-modified">102                     return field;</span>
<span class="line-modified">103                 }</span>


104             }
105         }
106 
107         throw new JVMCIError(&quot;unresolved field %s&quot;, reflectionField);
108     }
109 
110     private static int intMaskRight(int n) {
111         assert n &lt;= 32;
112         return n == 32 ? -1 : (1 &lt;&lt; n) - 1;
113     }
114 
115     @Override
116     public JavaConstant encodeDeoptActionAndReason(DeoptimizationAction action, DeoptimizationReason reason, int debugId) {
117         HotSpotVMConfig config = runtime.getConfig();
118         int actionValue = convertDeoptAction(action);
119         int reasonValue = convertDeoptReason(reason);
120         int debugValue = debugId &amp; intMaskRight(config.deoptimizationDebugIdBits);
121         JavaConstant c = JavaConstant.forInt(
122                         ~((debugValue &lt;&lt; config.deoptimizationDebugIdShift) | (reasonValue &lt;&lt; config.deoptimizationReasonShift) | (actionValue &lt;&lt; config.deoptimizationActionShift)));
123         assert c.asInt() &lt; 0;
</pre>
<hr />
<pre>
130         int reasonValue = ((~constant.asInt()) &gt;&gt; config.deoptimizationReasonShift) &amp; intMaskRight(config.deoptimizationReasonBits);
131         DeoptimizationReason reason = convertDeoptReason(reasonValue);
132         return reason;
133     }
134 
135     @Override
136     public DeoptimizationAction decodeDeoptAction(JavaConstant constant) {
137         HotSpotVMConfig config = runtime.getConfig();
138         int actionValue = ((~constant.asInt()) &gt;&gt; config.deoptimizationActionShift) &amp; intMaskRight(config.deoptimizationActionBits);
139         DeoptimizationAction action = convertDeoptAction(actionValue);
140         return action;
141     }
142 
143     @Override
144     public int decodeDebugId(JavaConstant constant) {
145         HotSpotVMConfig config = runtime.getConfig();
146         return ((~constant.asInt()) &gt;&gt; config.deoptimizationDebugIdShift) &amp; intMaskRight(config.deoptimizationDebugIdBits);
147     }
148 
149     @Override
<span class="line-modified">150     public JavaConstant encodeSpeculation(SpeculationLog.Speculation speculation) {</span>
<span class="line-modified">151         if (speculation.getReason() instanceof SpeculationLog.NoSpeculationReason) {</span>
152             return JavaConstant.LONG_0;
153         }
154         return ((HotSpotSpeculationLog.HotSpotSpeculation) speculation).getEncoding();
155     }
156 
157     @Override
<span class="line-modified">158     public SpeculationLog.Speculation decodeSpeculation(JavaConstant constant, SpeculationLog speculationLog) {</span>
159         if (constant.equals(JavaConstant.LONG_0)) {
160             return SpeculationLog.NO_SPECULATION;
161         }
<span class="line-modified">162         assert speculationLog != null : &quot;Must have a speculation log&quot;;</span>


163         return speculationLog.lookupSpeculation(constant);
164     }
165 
166     public int convertDeoptAction(DeoptimizationAction action) {
167         HotSpotVMConfig config = runtime.getConfig();
168         switch (action) {
169             case None:
170                 return config.deoptActionNone;
171             case RecompileIfTooManyDeopts:
172                 return config.deoptActionMaybeRecompile;
173             case InvalidateReprofile:
174                 return config.deoptActionReinterpret;
175             case InvalidateRecompile:
176                 return config.deoptActionMakeNotEntrant;
177             case InvalidateStopCompiling:
178                 return config.deoptActionMakeNotCompilable;
179             default:
180                 throw new JVMCIError(&quot;%s&quot;, action);
181         }
182     }
</pre>
<hr />
<pre>
286             return DeoptimizationReason.LoopLimitCheck;
287         }
288         if (reason == config.deoptReasonAliasing) {
289             return DeoptimizationReason.Aliasing;
290         }
291         if (reason == config.deoptReasonTransferToInterpreter) {
292             return DeoptimizationReason.TransferToInterpreter;
293         }
294         throw new JVMCIError(&quot;%x&quot;, reason);
295     }
296 
297     @Override
298     public long getMemorySize(JavaConstant constant) {
299         if (constant.getJavaKind() == JavaKind.Object) {
300             HotSpotResolvedObjectType lookupJavaType = lookupJavaType(constant);
301 
302             if (lookupJavaType == null) {
303                 return 0;
304             } else {
305                 if (lookupJavaType.isArray()) {
<span class="line-modified">306                     int length = Array.getLength(((HotSpotObjectConstantImpl) constant).object());</span>
307                     ResolvedJavaType elementType = lookupJavaType.getComponentType();
308                     JavaKind elementKind = elementType.getJavaKind();
<span class="line-modified">309                     final int headerSize = getArrayBaseOffset(elementKind);</span>
<span class="line-modified">310                     int sizeOfElement = getArrayIndexScale(elementKind);</span>
311                     int log2ElementSize = CodeUtil.log2(sizeOfElement);
312                     return computeArrayAllocationSize(length, headerSize, log2ElementSize);
313                 }
314                 return lookupJavaType.instanceSize();
315             }
316         } else {
317             return constant.getJavaKind().getByteCount();
318         }
319     }
320 
321     /**
322      * Computes the size of the memory chunk allocated for an array. This size accounts for the
323      * array header size, body size and any padding after the last element to satisfy object
324      * alignment requirements.
325      *
326      * @param length the number of elements in the array
327      * @param headerSize the size of the array header
328      * @param log2ElementSize log2 of the size of an element in the array
329      * @return the size of the memory chunk
330      */
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 




 25 import java.lang.reflect.Executable;
 26 import java.lang.reflect.Field;
 27 import java.lang.reflect.Modifier;
 28 import java.util.Objects;
 29 
 30 import jdk.vm.ci.code.CodeUtil;
 31 import jdk.vm.ci.common.JVMCIError;
 32 import jdk.vm.ci.meta.DeoptimizationAction;
 33 import jdk.vm.ci.meta.DeoptimizationReason;
 34 import jdk.vm.ci.meta.JavaConstant;
 35 import jdk.vm.ci.meta.JavaKind;
 36 import jdk.vm.ci.meta.MetaAccessProvider;
 37 import jdk.vm.ci.meta.ResolvedJavaField;
 38 import jdk.vm.ci.meta.ResolvedJavaMethod;
 39 import jdk.vm.ci.meta.ResolvedJavaType;
 40 import jdk.vm.ci.meta.Signature;
 41 import jdk.vm.ci.meta.SpeculationLog;
<span class="line-added"> 42 import jdk.vm.ci.meta.SpeculationLog.NoSpeculationReason;</span>
<span class="line-added"> 43 import jdk.vm.ci.meta.SpeculationLog.Speculation;</span>
 44 
 45 // JaCoCo Exclude
 46 
 47 /**
 48  * HotSpot implementation of {@link MetaAccessProvider}.
 49  */
 50 public class HotSpotMetaAccessProvider implements MetaAccessProvider {
 51 
 52     protected final HotSpotJVMCIRuntime runtime;
 53 
 54     public HotSpotMetaAccessProvider(HotSpotJVMCIRuntime runtime) {
 55         this.runtime = runtime;
 56     }
 57 
 58     @Override
 59     public ResolvedJavaType lookupJavaType(Class&lt;?&gt; clazz) {
 60         if (clazz == null) {
 61             throw new IllegalArgumentException(&quot;Class parameter was null&quot;);
 62         }
 63         return runtime.fromClass(clazz);
</pre>
<hr />
<pre>
 68         if (constant.isNull() || !(constant instanceof HotSpotObjectConstant)) {
 69             return null;
 70         }
 71         return ((HotSpotObjectConstant) constant).getType();
 72     }
 73 
 74     @Override
 75     public Signature parseMethodDescriptor(String signature) {
 76         return new HotSpotSignature(runtime, signature);
 77     }
 78 
 79     @Override
 80     public ResolvedJavaMethod lookupJavaMethod(Executable reflectionMethod) {
 81         return runtime.getCompilerToVM().asResolvedJavaMethod(Objects.requireNonNull(reflectionMethod));
 82     }
 83 
 84     @Override
 85     public ResolvedJavaField lookupJavaField(Field reflectionField) {
 86         Class&lt;?&gt; fieldHolder = reflectionField.getDeclaringClass();
 87 
<span class="line-modified"> 88         HotSpotResolvedJavaType holder = runtime.fromClass(fieldHolder);</span>
<span class="line-added"> 89         assert holder != null : fieldHolder;</span>
<span class="line-added"> 90         ResolvedJavaField[] fields;</span>
 91         if (Modifier.isStatic(reflectionField.getModifiers())) {
<span class="line-modified"> 92             fields = holder.getStaticFields();</span>





 93         } else {
<span class="line-modified"> 94             fields = holder.getInstanceFields(false);</span>
<span class="line-modified"> 95         }</span>
<span class="line-modified"> 96         ResolvedJavaType fieldType = lookupJavaType(reflectionField.getType());</span>
<span class="line-modified"> 97         for (ResolvedJavaField field : fields) {</span>
<span class="line-modified"> 98             if (reflectionField.getName().equals(field.getName()) &amp;&amp; field.getType().equals(fieldType)) {</span>
<span class="line-added"> 99                 assert Modifier.isStatic(reflectionField.getModifiers()) == field.isStatic();</span>
<span class="line-added">100                 return field;</span>
101             }
102         }
103 
104         throw new JVMCIError(&quot;unresolved field %s&quot;, reflectionField);
105     }
106 
107     private static int intMaskRight(int n) {
108         assert n &lt;= 32;
109         return n == 32 ? -1 : (1 &lt;&lt; n) - 1;
110     }
111 
112     @Override
113     public JavaConstant encodeDeoptActionAndReason(DeoptimizationAction action, DeoptimizationReason reason, int debugId) {
114         HotSpotVMConfig config = runtime.getConfig();
115         int actionValue = convertDeoptAction(action);
116         int reasonValue = convertDeoptReason(reason);
117         int debugValue = debugId &amp; intMaskRight(config.deoptimizationDebugIdBits);
118         JavaConstant c = JavaConstant.forInt(
119                         ~((debugValue &lt;&lt; config.deoptimizationDebugIdShift) | (reasonValue &lt;&lt; config.deoptimizationReasonShift) | (actionValue &lt;&lt; config.deoptimizationActionShift)));
120         assert c.asInt() &lt; 0;
</pre>
<hr />
<pre>
127         int reasonValue = ((~constant.asInt()) &gt;&gt; config.deoptimizationReasonShift) &amp; intMaskRight(config.deoptimizationReasonBits);
128         DeoptimizationReason reason = convertDeoptReason(reasonValue);
129         return reason;
130     }
131 
132     @Override
133     public DeoptimizationAction decodeDeoptAction(JavaConstant constant) {
134         HotSpotVMConfig config = runtime.getConfig();
135         int actionValue = ((~constant.asInt()) &gt;&gt; config.deoptimizationActionShift) &amp; intMaskRight(config.deoptimizationActionBits);
136         DeoptimizationAction action = convertDeoptAction(actionValue);
137         return action;
138     }
139 
140     @Override
141     public int decodeDebugId(JavaConstant constant) {
142         HotSpotVMConfig config = runtime.getConfig();
143         return ((~constant.asInt()) &gt;&gt; config.deoptimizationDebugIdShift) &amp; intMaskRight(config.deoptimizationDebugIdBits);
144     }
145 
146     @Override
<span class="line-modified">147     public JavaConstant encodeSpeculation(Speculation speculation) {</span>
<span class="line-modified">148         if (speculation.getReason() instanceof NoSpeculationReason) {</span>
149             return JavaConstant.LONG_0;
150         }
151         return ((HotSpotSpeculationLog.HotSpotSpeculation) speculation).getEncoding();
152     }
153 
154     @Override
<span class="line-modified">155     public Speculation decodeSpeculation(JavaConstant constant, SpeculationLog speculationLog) {</span>
156         if (constant.equals(JavaConstant.LONG_0)) {
157             return SpeculationLog.NO_SPECULATION;
158         }
<span class="line-modified">159         if (speculationLog == null) {</span>
<span class="line-added">160             throw new IllegalArgumentException(&quot;A speculation log is required to decode the speculation denoted by &quot; + constant);</span>
<span class="line-added">161         }</span>
162         return speculationLog.lookupSpeculation(constant);
163     }
164 
165     public int convertDeoptAction(DeoptimizationAction action) {
166         HotSpotVMConfig config = runtime.getConfig();
167         switch (action) {
168             case None:
169                 return config.deoptActionNone;
170             case RecompileIfTooManyDeopts:
171                 return config.deoptActionMaybeRecompile;
172             case InvalidateReprofile:
173                 return config.deoptActionReinterpret;
174             case InvalidateRecompile:
175                 return config.deoptActionMakeNotEntrant;
176             case InvalidateStopCompiling:
177                 return config.deoptActionMakeNotCompilable;
178             default:
179                 throw new JVMCIError(&quot;%s&quot;, action);
180         }
181     }
</pre>
<hr />
<pre>
285             return DeoptimizationReason.LoopLimitCheck;
286         }
287         if (reason == config.deoptReasonAliasing) {
288             return DeoptimizationReason.Aliasing;
289         }
290         if (reason == config.deoptReasonTransferToInterpreter) {
291             return DeoptimizationReason.TransferToInterpreter;
292         }
293         throw new JVMCIError(&quot;%x&quot;, reason);
294     }
295 
296     @Override
297     public long getMemorySize(JavaConstant constant) {
298         if (constant.getJavaKind() == JavaKind.Object) {
299             HotSpotResolvedObjectType lookupJavaType = lookupJavaType(constant);
300 
301             if (lookupJavaType == null) {
302                 return 0;
303             } else {
304                 if (lookupJavaType.isArray()) {
<span class="line-modified">305                     int length = runtime.getHostJVMCIBackend().getConstantReflection().readArrayLength(constant);</span>
306                     ResolvedJavaType elementType = lookupJavaType.getComponentType();
307                     JavaKind elementKind = elementType.getJavaKind();
<span class="line-modified">308                     final int headerSize = runtime.getArrayBaseOffset(elementKind);</span>
<span class="line-modified">309                     int sizeOfElement = runtime.getArrayIndexScale(elementKind);</span>
310                     int log2ElementSize = CodeUtil.log2(sizeOfElement);
311                     return computeArrayAllocationSize(length, headerSize, log2ElementSize);
312                 }
313                 return lookupJavaType.instanceSize();
314             }
315         } else {
316             return constant.getJavaKind().getByteCount();
317         }
318     }
319 
320     /**
321      * Computes the size of the memory chunk allocated for an array. This size accounts for the
322      * array header size, body size and any padding after the last element to satisfy object
323      * alignment requirements.
324      *
325      * @param length the number of elements in the array
326      * @param headerSize the size of the array header
327      * @param log2ElementSize log2 of the size of an element in the array
328      * @return the size of the memory chunk
329      */
</pre>
</td>
</tr>
</table>
<center><a href="HotSpotMemoryAccessProviderImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotMetaData.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
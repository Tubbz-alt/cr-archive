<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodHandleAccessProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotMethodDataAccessor.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotNmethod.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodHandleAccessProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,13 ***</span>
  
  import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  
  import java.lang.invoke.MethodHandle;
<span class="line-removed">- import java.util.Objects;</span>
  
  import jdk.vm.ci.common.JVMCIError;
  import jdk.vm.ci.meta.ConstantReflectionProvider;
  import jdk.vm.ci.meta.JavaConstant;
  import jdk.vm.ci.meta.MethodHandleAccessProvider;
  import jdk.vm.ci.meta.ResolvedJavaField;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
<span class="line-new-header">--- 24,14 ---</span>
  
  import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  
  import java.lang.invoke.MethodHandle;
  
  import jdk.vm.ci.common.JVMCIError;
<span class="line-added">+ import jdk.vm.ci.common.NativeImageReinitialize;</span>
<span class="line-added">+ import jdk.vm.ci.hotspot.HotSpotMethodData.VMState;</span>
  import jdk.vm.ci.meta.ConstantReflectionProvider;
  import jdk.vm.ci.meta.JavaConstant;
  import jdk.vm.ci.meta.MethodHandleAccessProvider;
  import jdk.vm.ci.meta.ResolvedJavaField;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,19 ***</span>
      public HotSpotMethodHandleAccessProvider(ConstantReflectionProvider constantReflection) {
          this.constantReflection = constantReflection;
      }
  
      /**
<span class="line-modified">!      * Lazy initialization to break class initialization cycle. Field and method lookup is only</span>
<span class="line-modified">!      * possible after the {@link HotSpotJVMCIRuntime} is fully initialized.</span>
       */
<span class="line-modified">!     static class LazyInitialization {</span>
<span class="line-modified">!         static final ResolvedJavaType lambdaFormType;</span>
<span class="line-modified">!         static final ResolvedJavaField methodHandleFormField;</span>
<span class="line-modified">!         static final ResolvedJavaField lambdaFormVmentryField;</span>
<span class="line-modified">!         static final ResolvedJavaField methodField;</span>
<span class="line-modified">!         static final HotSpotResolvedJavaField vmtargetField;</span>
  
          /**
           * Search for an instance field with the given name in a class.
           *
           * @param declaringType the type declaring the field
<span class="line-new-header">--- 44,20 ---</span>
      public HotSpotMethodHandleAccessProvider(ConstantReflectionProvider constantReflection) {
          this.constantReflection = constantReflection;
      }
  
      /**
<span class="line-modified">!      * Lazy initialized reflection on {@link MethodHandle} internals. Field and method lookup is</span>
<span class="line-modified">!      * only possible after the {@link HotSpotJVMCIRuntime} is fully initialized.</span>
       */
<span class="line-modified">!     static final class Internals {</span>
<span class="line-modified">!         final ResolvedJavaType lambdaFormType;</span>
<span class="line-modified">!         final ResolvedJavaField methodHandleFormField;</span>
<span class="line-modified">!         final ResolvedJavaField lambdaFormVmentryField;</span>
<span class="line-modified">!         final HotSpotResolvedJavaField callSiteTargetField;</span>
<span class="line-modified">!         final ResolvedJavaField methodField;</span>
<span class="line-added">+         final HotSpotResolvedJavaField vmtargetField;</span>
  
          /**
           * Search for an instance field with the given name in a class.
           *
           * @param declaringType the type declaring the field
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,38 ***</span>
              for (ResolvedJavaField field : fields) {
                  if (field.getName().equals(fieldName) &amp;&amp; field.getType().equals(fieldType)) {
                      return field;
                  }
              }
<span class="line-modified">!             throw new NoSuchFieldError(fieldType.getName() + &quot; &quot; + declaringType + &quot;.&quot; + fieldName);</span>
          }
  
<span class="line-modified">!         private static ResolvedJavaType resolveType(Class&lt;?&gt; c) {</span>
<span class="line-modified">!             return runtime().fromClass(c);</span>
          }
  
<span class="line-modified">!         private static ResolvedJavaType resolveType(String className) throws ClassNotFoundException {</span>
<span class="line-removed">-             return resolveType(Class.forName(className));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static {</span>
              try {
<span class="line-modified">!                 ResolvedJavaType methodHandleType = resolveType(MethodHandle.class);</span>
<span class="line-modified">!                 ResolvedJavaType memberNameType = resolveType(&quot;java.lang.invoke.MemberName&quot;);</span>
<span class="line-modified">!                 lambdaFormType = resolveType(&quot;java.lang.invoke.LambdaForm&quot;);</span>
                  methodHandleFormField = findFieldInClass(methodHandleType, &quot;form&quot;, lambdaFormType);
                  lambdaFormVmentryField = findFieldInClass(lambdaFormType, &quot;vmentry&quot;, memberNameType);
<span class="line-modified">!                 ResolvedJavaType methodType = resolveType(&quot;java.lang.invoke.ResolvedMethodName&quot;);</span>
                  methodField = findFieldInClass(memberNameType, &quot;method&quot;, methodType);
<span class="line-modified">!                 vmtargetField = (HotSpotResolvedJavaField) findFieldInClass(methodType, &quot;vmtarget&quot;, resolveType(HotSpotJVMCIRuntime.getHostWordKind().toJavaClass()));</span>
  
              } catch (Throwable ex) {
                  throw new JVMCIError(ex);
              }
          }
      }
  
      @Override
      public IntrinsicMethod lookupMethodHandleIntrinsic(ResolvedJavaMethod method) {
          int intrinsicId = ((HotSpotResolvedJavaMethodImpl) method).intrinsicId();
          if (intrinsicId != 0) {
              return getMethodHandleIntrinsic(intrinsicId);
<span class="line-new-header">--- 71,57 ---</span>
              for (ResolvedJavaField field : fields) {
                  if (field.getName().equals(fieldName) &amp;&amp; field.getType().equals(fieldType)) {
                      return field;
                  }
              }
<span class="line-modified">!             throw new NoSuchFieldError(declaringType + &quot;.&quot; + fieldName);</span>
          }
  
<span class="line-modified">!         private static ResolvedJavaType resolveType(String className) {</span>
<span class="line-modified">!             return (ResolvedJavaType) runtime().lookupTypeInternal(className, null, true);</span>
          }
  
<span class="line-modified">!         private Internals() {</span>
              try {
<span class="line-modified">!                 ResolvedJavaType methodHandleType = resolveType(&quot;Ljava/lang/invoke/MethodHandle;&quot;);</span>
<span class="line-modified">!                 ResolvedJavaType memberNameType = resolveType(&quot;Ljava/lang/invoke/MemberName;&quot;);</span>
<span class="line-modified">!                 lambdaFormType = resolveType(&quot;Ljava/lang/invoke/LambdaForm;&quot;);</span>
                  methodHandleFormField = findFieldInClass(methodHandleType, &quot;form&quot;, lambdaFormType);
                  lambdaFormVmentryField = findFieldInClass(lambdaFormType, &quot;vmentry&quot;, memberNameType);
<span class="line-modified">! </span>
<span class="line-added">+                 ResolvedJavaType methodType = resolveType(&quot;Ljava/lang/invoke/ResolvedMethodName;&quot;);</span>
                  methodField = findFieldInClass(memberNameType, &quot;method&quot;, methodType);
<span class="line-modified">!                 vmtargetField = (HotSpotResolvedJavaField) findFieldInClass(methodType, &quot;vmtarget&quot;, resolveType(Character.toString(HotSpotJVMCIRuntime.getHostWordKind().getTypeChar())));</span>
  
<span class="line-added">+                 ResolvedJavaType callSiteType = resolveType(&quot;Ljava/lang/invoke/CallSite;&quot;);</span>
<span class="line-added">+                 callSiteTargetField = (HotSpotResolvedJavaField) findFieldInClass(callSiteType, &quot;target&quot;, methodHandleType);</span>
              } catch (Throwable ex) {
                  throw new JVMCIError(ex);
              }
          }
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Singleton instance lazily initialized via double-checked locking.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         @NativeImageReinitialize private static volatile Internals instance;</span>
<span class="line-added">+ </span>
<span class="line-added">+         static Internals instance() {</span>
<span class="line-added">+             Internals result = instance;</span>
<span class="line-added">+             if (result == null) {</span>
<span class="line-added">+                 synchronized (VMState.class) {</span>
<span class="line-added">+                     result = instance;</span>
<span class="line-added">+                     if (result == null) {</span>
<span class="line-added">+                         instance = result = new Internals();</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return result;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
      }
  
<span class="line-added">+ </span>
      @Override
      public IntrinsicMethod lookupMethodHandleIntrinsic(ResolvedJavaMethod method) {
          int intrinsicId = ((HotSpotResolvedJavaMethodImpl) method).intrinsicId();
          if (intrinsicId != 0) {
              return getMethodHandleIntrinsic(intrinsicId);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,32 ***</span>
          if (methodHandle.isNull()) {
              return null;
          }
  
          /* Load non-public field: LambdaForm MethodHandle.form */
<span class="line-modified">!         JavaConstant lambdaForm = constantReflection.readFieldValue(LazyInitialization.methodHandleFormField, methodHandle);</span>
          if (lambdaForm == null || lambdaForm.isNull()) {
              return null;
          }
  
<span class="line-modified">!         JavaConstant memberName = constantReflection.readFieldValue(LazyInitialization.lambdaFormVmentryField, lambdaForm);</span>
          if (memberName.isNull() &amp;&amp; forceBytecodeGeneration) {
<span class="line-modified">!             Object lf = ((HotSpotObjectConstant) lambdaForm).asObject(LazyInitialization.lambdaFormType);</span>
<span class="line-modified">!             compilerToVM().compileToBytecode(Objects.requireNonNull(lf));</span>
<span class="line-removed">-             memberName = constantReflection.readFieldValue(LazyInitialization.lambdaFormVmentryField, lambdaForm);</span>
              assert memberName.isNonNull();
          }
<span class="line-modified">!         JavaConstant method = constantReflection.readFieldValue(LazyInitialization.methodField, memberName);</span>
          return getTargetMethod(method);
      }
  
      @Override
      public ResolvedJavaMethod resolveLinkToTarget(JavaConstant memberName) {
          if (memberName.isNull()) {
              return null;
          }
<span class="line-modified">!         JavaConstant method = constantReflection.readFieldValue(LazyInitialization.methodField, memberName);</span>
          return getTargetMethod(method);
      }
  
      /**
       * Returns the {@link ResolvedJavaMethod} for the method of a java.lang.invoke.MemberName.
<span class="line-new-header">--- 150,32 ---</span>
          if (methodHandle.isNull()) {
              return null;
          }
  
          /* Load non-public field: LambdaForm MethodHandle.form */
<span class="line-modified">!         Internals internals = Internals.instance();</span>
<span class="line-added">+         JavaConstant lambdaForm = constantReflection.readFieldValue(internals.methodHandleFormField, methodHandle);</span>
          if (lambdaForm == null || lambdaForm.isNull()) {
              return null;
          }
  
<span class="line-modified">!         JavaConstant memberName = constantReflection.readFieldValue(internals.lambdaFormVmentryField, lambdaForm);</span>
          if (memberName.isNull() &amp;&amp; forceBytecodeGeneration) {
<span class="line-modified">!             compilerToVM().compileToBytecode((HotSpotObjectConstantImpl) lambdaForm);</span>
<span class="line-modified">!             memberName = constantReflection.readFieldValue(internals.lambdaFormVmentryField, lambdaForm);</span>
              assert memberName.isNonNull();
          }
<span class="line-modified">!         JavaConstant method = constantReflection.readFieldValue(internals.methodField, memberName);</span>
          return getTargetMethod(method);
      }
  
      @Override
      public ResolvedJavaMethod resolveLinkToTarget(JavaConstant memberName) {
          if (memberName.isNull()) {
              return null;
          }
<span class="line-modified">!         JavaConstant method = constantReflection.readFieldValue(Internals.instance().methodField, memberName);</span>
          return getTargetMethod(method);
      }
  
      /**
       * Returns the {@link ResolvedJavaMethod} for the method of a java.lang.invoke.MemberName.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,10 ***</span>
          if (method == null) {
              // If readFieldValue returns NULL the type was wrong
              throw new IllegalArgumentException(&quot;unexpected type for memberName&quot;);
          }
  
<span class="line-removed">-         Object object = ((HotSpotObjectConstantImpl) method).object();</span>
          /* Read the ResolvedJavaMethod from the injected field MemberName.method.vmtarget */
<span class="line-modified">!         return compilerToVM().getResolvedJavaMethod(object, LazyInitialization.vmtargetField.getOffset());</span>
      }
  }
<span class="line-new-header">--- 184,9 ---</span>
          if (method == null) {
              // If readFieldValue returns NULL the type was wrong
              throw new IllegalArgumentException(&quot;unexpected type for memberName&quot;);
          }
  
          /* Read the ResolvedJavaMethod from the injected field MemberName.method.vmtarget */
<span class="line-modified">!         return compilerToVM().getResolvedJavaMethod((HotSpotObjectConstantImpl) method, Internals.instance().vmtargetField.getOffset());</span>
      }
  }
</pre>
<center><a href="HotSpotMethodDataAccessor.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotNmethod.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
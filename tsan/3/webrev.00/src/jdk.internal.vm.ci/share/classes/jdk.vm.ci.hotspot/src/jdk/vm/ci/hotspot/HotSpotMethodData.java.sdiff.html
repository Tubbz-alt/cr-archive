<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodData.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotMethod.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotMethodDataAccessor.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMethodData.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static java.lang.String.format;
 26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
 27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
 29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 30 
 31 import java.util.Arrays;
 32 

 33 import jdk.internal.misc.Unsafe;
 34 import jdk.vm.ci.meta.DeoptimizationReason;
 35 import jdk.vm.ci.meta.JavaMethodProfile;
 36 import jdk.vm.ci.meta.JavaMethodProfile.ProfiledMethod;
 37 import jdk.vm.ci.meta.JavaTypeProfile;
 38 import jdk.vm.ci.meta.JavaTypeProfile.ProfiledType;
 39 import jdk.vm.ci.meta.ResolvedJavaMethod;
 40 import jdk.vm.ci.meta.ResolvedJavaType;
 41 import jdk.vm.ci.meta.TriState;
 42 
 43 /**
 44  * Access to a HotSpot {@code MethodData} structure (defined in methodData.hpp).
 45  */
 46 final class HotSpotMethodData {
 47 
<span class="line-modified"> 48     static final HotSpotVMConfig config = config();</span>
<span class="line-modified"> 49     static final HotSpotMethodDataAccessor NO_DATA_NO_EXCEPTION_ACCESSOR = new NoMethodData(config, config.dataLayoutNoTag, TriState.FALSE);</span>
<span class="line-modified"> 50     static final HotSpotMethodDataAccessor NO_DATA_EXCEPTION_POSSIBLY_NOT_RECORDED_ACCESSOR = new NoMethodData(config, config.dataLayoutNoTag, TriState.UNKNOWN);</span>















































































































 51 
 52     /**
 53      * Reference to the C++ MethodData object.
 54      */
 55     final long metaspaceMethodData;
 56     private final HotSpotResolvedJavaMethodImpl method;

 57 
 58     HotSpotMethodData(long metaspaceMethodData, HotSpotResolvedJavaMethodImpl method) {
 59         this.metaspaceMethodData = metaspaceMethodData;
 60         this.method = method;

 61     }
 62 
 63     /**
 64      * @return value of the MethodData::_data_size field
 65      */
 66     private int normalDataSize() {
<span class="line-modified"> 67         return UNSAFE.getInt(metaspaceMethodData + config.methodDataDataSize);</span>
 68     }
 69 
 70     /**
 71      * Returns the size of the extra data records. This method does the same calculation as
 72      * MethodData::extra_data_size().
 73      *
 74      * @return size of extra data records
 75      */
 76     private int extraDataSize() {
<span class="line-modified"> 77         final int extraDataBase = config.methodDataOopDataOffset + normalDataSize();</span>
<span class="line-modified"> 78         final int extraDataLimit = UNSAFE.getInt(metaspaceMethodData + config.methodDataSize);</span>
 79         return extraDataLimit - extraDataBase;
 80     }
 81 
 82     public boolean hasNormalData() {
 83         return normalDataSize() &gt; 0;
 84     }
 85 
 86     public boolean hasExtraData() {
 87         return extraDataSize() &gt; 0;
 88     }
 89 
 90     public int getExtraDataBeginOffset() {
 91         return normalDataSize();
 92     }
 93 
 94     public boolean isWithin(int position) {
 95         return position &gt;= 0 &amp;&amp; position &lt; normalDataSize() + extraDataSize();
 96     }
 97 
 98     public int getDeoptimizationCount(DeoptimizationReason reason) {
 99         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
100         int reasonIndex = metaAccess.convertDeoptReason(reason);
<span class="line-modified">101         return UNSAFE.getByte(metaspaceMethodData + config.methodDataOopTrapHistoryOffset + reasonIndex) &amp; 0xFF;</span>
102     }
103 
104     public int getOSRDeoptimizationCount(DeoptimizationReason reason) {
105         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
106         int reasonIndex = metaAccess.convertDeoptReason(reason);
<span class="line-modified">107         return UNSAFE.getByte(metaspaceMethodData + config.methodDataOopTrapHistoryOffset + config.deoptReasonOSROffset + reasonIndex) &amp; 0xFF;</span>
108     }
109 
110     public int getDecompileCount() {
<span class="line-modified">111         return UNSAFE.getInt(metaspaceMethodData + config.methodDataDecompiles);</span>
112     }
113 
114     public int getOverflowRecompileCount() {
<span class="line-modified">115         return UNSAFE.getInt(metaspaceMethodData + config.methodDataOverflowRecompiles);</span>
116     }
117 
118     public int getOverflowTrapCount() {
<span class="line-modified">119         return UNSAFE.getInt(metaspaceMethodData + config.methodDataOverflowTraps);</span>
120     }
121 
122     public HotSpotMethodDataAccessor getNormalData(int position) {
123         if (position &gt;= normalDataSize()) {
124             return null;
125         }
126 
127         return getData(position);
128     }
129 
130     public HotSpotMethodDataAccessor getExtraData(int position) {
131         if (position &gt;= normalDataSize() + extraDataSize()) {
132             return null;
133         }
134         HotSpotMethodDataAccessor data = getData(position);
135         if (data != null) {
136             return data;
137         }
138         return data;
139     }
140 
141     public static HotSpotMethodDataAccessor getNoDataAccessor(boolean exceptionPossiblyNotRecorded) {
142         if (exceptionPossiblyNotRecorded) {
<span class="line-modified">143             return NO_DATA_EXCEPTION_POSSIBLY_NOT_RECORDED_ACCESSOR;</span>
144         } else {
<span class="line-modified">145             return NO_DATA_NO_EXCEPTION_ACCESSOR;</span>
146         }
147     }
148 
149     private HotSpotMethodDataAccessor getData(int position) {
150         assert position &gt;= 0 : &quot;out of bounds&quot;;
<span class="line-modified">151         final int tag = HotSpotMethodDataAccessor.readTag(config, this, position);</span>
<span class="line-modified">152         HotSpotMethodDataAccessor accessor = PROFILE_DATA_ACCESSORS[tag];</span>
153         assert accessor == null || accessor.getTag() == tag : &quot;wrong data accessor &quot; + accessor + &quot; for tag &quot; + tag;
154         return accessor;
155     }
156 
157     int readUnsignedByte(int position, int offsetInBytes) {
<span class="line-modified">158         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);</span>
159         return UNSAFE.getByte(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFF;
160     }
161 
162     int readUnsignedShort(int position, int offsetInBytes) {
<span class="line-modified">163         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);</span>
164         return UNSAFE.getShort(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFF;
165     }
166 
167     /**
168      * Since the values are stored in cells (platform words) this method uses
169      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
170      */
171     private long readUnsignedInt(int position, int offsetInBytes) {
<span class="line-modified">172         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);</span>
173         return UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFFFFFFL;
174     }
175 
176     private int readUnsignedIntAsSignedInt(int position, int offsetInBytes) {
177         long value = readUnsignedInt(position, offsetInBytes);
<span class="line-modified">178         return truncateLongToInt(value);</span>
179     }
180 
181     /**
182      * Since the values are stored in cells (platform words) this method uses
183      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
184      */
185     private int readInt(int position, int offsetInBytes) {
<span class="line-modified">186         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);</span>
187         return (int) UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes);
188     }
189 
190     private HotSpotResolvedJavaMethod readMethod(int position, int offsetInBytes) {
<span class="line-modified">191         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);</span>
192         return compilerToVM().getResolvedJavaMethod(null, metaspaceMethodData + fullOffsetInBytes);
193     }
194 
195     private HotSpotResolvedObjectTypeImpl readKlass(int position, int offsetInBytes) {
<span class="line-modified">196         long fullOffsetInBytes = computeFullOffset(position, offsetInBytes);</span>
<span class="line-modified">197         return compilerToVM().getResolvedJavaType(null, metaspaceMethodData + fullOffsetInBytes, false);</span>
<span class="line-removed">198     }</span>
<span class="line-removed">199 </span>
<span class="line-removed">200     private static int truncateLongToInt(long value) {</span>
<span class="line-removed">201         return value &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) value;</span>
<span class="line-removed">202     }</span>
<span class="line-removed">203 </span>
<span class="line-removed">204     private static int computeFullOffset(int position, int offsetInBytes) {</span>
<span class="line-removed">205         return config.methodDataOopDataOffset + position + offsetInBytes;</span>
<span class="line-removed">206     }</span>
<span class="line-removed">207 </span>
<span class="line-removed">208     private static int cellIndexToOffset(int cells) {</span>
<span class="line-removed">209         return config.dataLayoutHeaderSize + cellsToBytes(cells);</span>
<span class="line-removed">210     }</span>
<span class="line-removed">211 </span>
<span class="line-removed">212     private static int cellsToBytes(int cells) {</span>
<span class="line-removed">213         return cells * config.dataLayoutCellSize;</span>
214     }
215 
216     /**
217      * Returns whether profiling ran long enough that the profile information is mature. Other
218      * informational data will still be valid even if the profile isn&#39;t mature.
219      */
220     public boolean isProfileMature() {
221         return runtime().getCompilerToVM().isMature(metaspaceMethodData);
222     }
223 
224     @Override
225     public String toString() {
226         StringBuilder sb = new StringBuilder();
227         String nl = String.format(&quot;%n&quot;);
228         String nlIndent = String.format(&quot;%n%38s&quot;, &quot;&quot;);
229         sb.append(&quot;Raw method data for &quot;);
230         sb.append(method.format(&quot;%H.%n(%p)&quot;));
231         sb.append(&quot;:&quot;);
232         sb.append(nl);
233         sb.append(String.format(&quot;nof_decompiles(%d) nof_overflow_recompiles(%d) nof_overflow_traps(%d)%n&quot;,
</pre>
<hr />
<pre>
246             }
247         }
248 
249         if (hasExtraData()) {
250             int pos = getExtraDataBeginOffset();
251             HotSpotMethodDataAccessor data;
252             while ((data = getExtraData(pos)) != null) {
253                 if (pos == getExtraDataBeginOffset()) {
254                     sb.append(nl).append(&quot;--- Extra data:&quot;);
255                 }
256                 int bci = data.getBCI(this, pos);
257                 sb.append(String.format(&quot;%n%-6d bci: %-6d%-20s&quot;, pos, bci, data.getClass().getSimpleName()));
258                 sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));
259                 pos = pos + data.getSize(this, pos);
260             }
261 
262         }
263         return sb.toString();
264     }
265 
<span class="line-removed">266     static final int NO_DATA_SIZE = cellIndexToOffset(0);</span>
<span class="line-removed">267 </span>
268     static class NoMethodData extends HotSpotMethodDataAccessor {
269 
270         private final TriState exceptionSeen;
271 
<span class="line-modified">272         protected NoMethodData(HotSpotVMConfig config, int tag, TriState exceptionSeen) {</span>
<span class="line-modified">273             super(config, tag, NO_DATA_SIZE);</span>
274             this.exceptionSeen = exceptionSeen;
275         }
276 
277         @Override
278         public int getBCI(HotSpotMethodData data, int position) {
279             return -1;
280         }
281 
282         @Override
283         public TriState getExceptionSeen(HotSpotMethodData data, int position) {
284             return exceptionSeen;
285         }
286 
287         @Override
288         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
289             return sb;
290         }
291     }
292 
<span class="line-removed">293     static final int BIT_DATA_SIZE = cellIndexToOffset(0);</span>
<span class="line-removed">294     static final int BIT_DATA_NULL_SEEN_FLAG = 1 &lt;&lt; config.bitDataNullSeenFlag;</span>
<span class="line-removed">295 </span>
296     static class BitData extends HotSpotMethodDataAccessor {
297 
<span class="line-modified">298         private BitData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">299             super(config, tag, BIT_DATA_SIZE);</span>
300         }
301 
<span class="line-modified">302         protected BitData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="line-modified">303             super(config, tag, staticSize);</span>
304         }
305 
306         @Override
307         public TriState getNullSeen(HotSpotMethodData data, int position) {
<span class="line-modified">308             return TriState.get((getFlags(data, position) &amp; BIT_DATA_NULL_SEEN_FLAG) != 0);</span>
309         }
310 
311         @Override
312         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
313             return sb.append(format(&quot;exception_seen(%s)&quot;, getExceptionSeen(data, pos)));
314         }
315     }
316 
<span class="line-removed">317     static final int COUNTER_DATA_SIZE = cellIndexToOffset(1);</span>
<span class="line-removed">318     static final int COUNTER_DATA_COUNT_OFFSET = cellIndexToOffset(config.methodDataCountOffset);</span>
<span class="line-removed">319 </span>
320     static class CounterData extends BitData {
321 
<span class="line-modified">322         CounterData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">323             super(config, tag, COUNTER_DATA_SIZE);</span>
324         }
325 
<span class="line-modified">326         protected CounterData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="line-modified">327             super(config, tag, staticSize);</span>
328         }
329 
330         @Override
331         public int getExecutionCount(HotSpotMethodData data, int position) {
332             return getCounterValue(data, position);
333         }
334 
335         protected int getCounterValue(HotSpotMethodData data, int position) {
<span class="line-modified">336             return data.readUnsignedIntAsSignedInt(position, COUNTER_DATA_COUNT_OFFSET);</span>
337         }
338 
339         @Override
340         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
341             return sb.append(format(&quot;count(%d) null_seen(%s) exception_seen(%s)&quot;, getCounterValue(data, pos), getNullSeen(data, pos), getExceptionSeen(data, pos)));
342         }
343     }
344 
<span class="line-removed">345     static final int JUMP_DATA_SIZE = cellIndexToOffset(2);</span>
<span class="line-removed">346     static final int TAKEN_COUNT_OFFSET = cellIndexToOffset(config.jumpDataTakenOffset);</span>
<span class="line-removed">347     static final int TAKEN_DISPLACEMENT_OFFSET = cellIndexToOffset(config.jumpDataDisplacementOffset);</span>
<span class="line-removed">348 </span>
349     static class JumpData extends HotSpotMethodDataAccessor {
350 
<span class="line-modified">351         JumpData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">352             super(config, tag, JUMP_DATA_SIZE);</span>
353         }
354 
<span class="line-modified">355         protected JumpData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="line-modified">356             super(config, tag, staticSize);</span>
357         }
358 
359         @Override
360         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
361             return getExecutionCount(data, position) != 0 ? 1 : 0;
362         }
363 
364         @Override
365         public int getExecutionCount(HotSpotMethodData data, int position) {
<span class="line-modified">366             return data.readUnsignedIntAsSignedInt(position, TAKEN_COUNT_OFFSET);</span>
367         }
368 
369         public int getTakenDisplacement(HotSpotMethodData data, int position) {
<span class="line-modified">370             return data.readInt(position, TAKEN_DISPLACEMENT_OFFSET);</span>
371         }
372 
373         @Override
374         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
375             return sb.append(format(&quot;taken(%d) displacement(%d)&quot;, getExecutionCount(data, pos), getTakenDisplacement(data, pos)));
376         }
377     }
378 
379     static class RawItemProfile&lt;T&gt; {
380         final int entries;
381         final T[] items;
382         final long[] counts;
383         final long totalCount;
384 
385         RawItemProfile(int entries, T[] items, long[] counts, long totalCount) {
386             this.entries = entries;
387             this.items = items;
388             this.counts = counts;
389             this.totalCount = totalCount;
390         }
391     }
392 
<span class="line-removed">393     static final int TYPE_DATA_ROW_SIZE = cellsToBytes(config.receiverTypeDataReceiverTypeRowCellCount);</span>
<span class="line-removed">394 </span>
<span class="line-removed">395     static final int NONPROFILED_COUNT_OFFSET = cellIndexToOffset(config.receiverTypeDataNonprofiledCountOffset);</span>
<span class="line-removed">396     static final int TYPE_DATA_FIRST_TYPE_OFFSET = cellIndexToOffset(config.receiverTypeDataReceiver0Offset);</span>
<span class="line-removed">397     static final int TYPE_DATA_FIRST_TYPE_COUNT_OFFSET = cellIndexToOffset(config.receiverTypeDataCount0Offset);</span>
<span class="line-removed">398 </span>
399     abstract static class AbstractTypeData extends CounterData {
400 
<span class="line-modified">401         protected AbstractTypeData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="line-modified">402             super(config, tag, staticSize);</span>
403         }
404 
405         @Override
406         public JavaTypeProfile getTypeProfile(HotSpotMethodData data, int position) {
407             return createTypeProfile(getNullSeen(data, position), getRawTypeProfile(data, position));
408         }
409 
410         private RawItemProfile&lt;ResolvedJavaType&gt; getRawTypeProfile(HotSpotMethodData data, int position) {
411             int typeProfileWidth = config.typeProfileWidth;
412 
413             ResolvedJavaType[] types = new ResolvedJavaType[typeProfileWidth];
414             long[] counts = new long[typeProfileWidth];
415             long totalCount = 0;
416             int entries = 0;
417 
418             outer: for (int i = 0; i &lt; typeProfileWidth; i++) {
419                 HotSpotResolvedObjectTypeImpl receiverKlass = data.readKlass(position, getTypeOffset(i));
420                 if (receiverKlass != null) {
421                     HotSpotResolvedObjectTypeImpl klass = receiverKlass;
422                     long count = data.readUnsignedInt(position, getTypeCountOffset(i));
</pre>
<hr />
<pre>
429                         if (types[j].equals(klass)) {
430                             totalCount += count;
431                             counts[j] += count;
432                             continue outer;
433                         }
434                     }
435                     types[entries] = klass;
436                     totalCount += count;
437                     counts[entries] = count;
438                     entries++;
439                 }
440             }
441 
442             totalCount += getTypesNotRecordedExecutionCount(data, position);
443             return new RawItemProfile&lt;&gt;(entries, types, counts, totalCount);
444         }
445 
446         protected abstract long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position);
447 
448         public int getNonprofiledCount(HotSpotMethodData data, int position) {
<span class="line-modified">449             return data.readUnsignedIntAsSignedInt(position, NONPROFILED_COUNT_OFFSET);</span>
450         }
451 
452         private JavaTypeProfile createTypeProfile(TriState nullSeen, RawItemProfile&lt;ResolvedJavaType&gt; profile) {
453             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
454                 return null;
455             }
456 
457             ProfiledType[] ptypes = new ProfiledType[profile.entries];
458             double totalProbability = 0.0;
459             for (int i = 0; i &lt; profile.entries; i++) {
460                 double p = profile.counts[i];
461                 p = p / profile.totalCount;
462                 totalProbability += p;
463                 ptypes[i] = new ProfiledType(profile.items[i], p);
464             }
465 
466             Arrays.sort(ptypes);
467 
468             double notRecordedTypeProbability = profile.entries &lt; config.typeProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
469             assert notRecordedTypeProbability == 0 || profile.entries == config.typeProfileWidth;
470             return new JavaTypeProfile(nullSeen, notRecordedTypeProbability, ptypes);
471         }
472 
<span class="line-modified">473         private static int getTypeOffset(int row) {</span>
<span class="line-modified">474             return TYPE_DATA_FIRST_TYPE_OFFSET + row * TYPE_DATA_ROW_SIZE;</span>
475         }
476 
<span class="line-modified">477         protected static int getTypeCountOffset(int row) {</span>
<span class="line-modified">478             return TYPE_DATA_FIRST_TYPE_COUNT_OFFSET + row * TYPE_DATA_ROW_SIZE;</span>
479         }
480 
481         @Override
482         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
483             RawItemProfile&lt;ResolvedJavaType&gt; profile = getRawTypeProfile(data, pos);
484             TriState nullSeen = getNullSeen(data, pos);
485             TriState exceptionSeen = getExceptionSeen(data, pos);
486             sb.append(format(&quot;count(%d) null_seen(%s) exception_seen(%s) nonprofiled_count(%d) entries(%d)&quot;, getCounterValue(data, pos), nullSeen, exceptionSeen,
487                             getNonprofiledCount(data, pos), profile.entries));
488             for (int i = 0; i &lt; profile.entries; i++) {
489                 long count = profile.counts[i];
490                 sb.append(format(&quot;%n  %s (%d, %4.2f)&quot;, profile.items[i].toJavaName(), count, (double) count / profile.totalCount));
491             }
492             return sb;
493         }
494     }
495 
<span class="line-removed">496     static final int TYPE_CHECK_DATA_SIZE = cellIndexToOffset(2) + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
<span class="line-removed">497 </span>
498     static class ReceiverTypeData extends AbstractTypeData {
499 
<span class="line-modified">500         ReceiverTypeData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">501             super(config, tag, TYPE_CHECK_DATA_SIZE);</span>
502         }
503 
<span class="line-modified">504         protected ReceiverTypeData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="line-modified">505             super(config, tag, staticSize);</span>
506         }
507 
508         @Override
509         public int getExecutionCount(HotSpotMethodData data, int position) {
510             return -1;
511         }
512 
513         @Override
514         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
515             return getNonprofiledCount(data, position);
516         }
517     }
518 
<span class="line-removed">519     static final int VIRTUAL_CALL_DATA_SIZE = cellIndexToOffset(2) + TYPE_DATA_ROW_SIZE * (config.typeProfileWidth + config.methodProfileWidth);</span>
<span class="line-removed">520     static final int VIRTUAL_CALL_DATA_FIRST_METHOD_OFFSET = TYPE_DATA_FIRST_TYPE_OFFSET + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
<span class="line-removed">521     static final int VIRTUAL_CALL_DATA_FIRST_METHOD_COUNT_OFFSET = TYPE_DATA_FIRST_TYPE_COUNT_OFFSET + TYPE_DATA_ROW_SIZE * config.typeProfileWidth;</span>
<span class="line-removed">522 </span>
523     static class VirtualCallData extends ReceiverTypeData {
524 
<span class="line-modified">525         VirtualCallData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">526             super(config, tag, VIRTUAL_CALL_DATA_SIZE);</span>
527         }
528 
<span class="line-modified">529         protected VirtualCallData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="line-modified">530             super(config, tag, staticSize);</span>
531         }
532 
533         @Override
534         public int getExecutionCount(HotSpotMethodData data, int position) {
535             final int typeProfileWidth = config.typeProfileWidth;
536 
537             long total = 0;
538             for (int i = 0; i &lt; typeProfileWidth; i++) {
539                 total += data.readUnsignedInt(position, getTypeCountOffset(i));
540             }
541 
542             total += getCounterValue(data, position);
<span class="line-modified">543             return truncateLongToInt(total);</span>
544         }
545 
546         @Override
547         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
548             return getCounterValue(data, position);
549         }
550 
<span class="line-modified">551         private static long getMethodsNotRecordedExecutionCount(HotSpotMethodData data, int position) {</span>
<span class="line-modified">552             return data.readUnsignedIntAsSignedInt(position, NONPROFILED_COUNT_OFFSET);</span>
553         }
554 
555         @Override
556         public JavaMethodProfile getMethodProfile(HotSpotMethodData data, int position) {
557             return createMethodProfile(getRawMethodProfile(data, position));
558         }
559 
560         private RawItemProfile&lt;ResolvedJavaMethod&gt; getRawMethodProfile(HotSpotMethodData data, int position) {
561             int profileWidth = config.methodProfileWidth;
562 
563             ResolvedJavaMethod[] methods = new ResolvedJavaMethod[profileWidth];
564             long[] counts = new long[profileWidth];
565             long totalCount = 0;
566             int entries = 0;
567 
568             for (int i = 0; i &lt; profileWidth; i++) {
569                 HotSpotResolvedJavaMethod method = data.readMethod(position, getMethodOffset(i));
570                 if (method != null) {
571                     methods[entries] = method;
572                     long count = data.readUnsignedInt(position, getMethodCountOffset(i));
</pre>
<hr />
<pre>
593             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
594                 return null;
595             }
596 
597             ProfiledMethod[] pmethods = new ProfiledMethod[profile.entries];
598             double totalProbability = 0.0;
599             for (int i = 0; i &lt; profile.entries; i++) {
600                 double p = profile.counts[i];
601                 p = p / profile.totalCount;
602                 totalProbability += p;
603                 pmethods[i] = new ProfiledMethod(profile.items[i], p);
604             }
605 
606             Arrays.sort(pmethods);
607 
608             double notRecordedMethodProbability = profile.entries &lt; config.methodProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
609             assert notRecordedMethodProbability == 0 || profile.entries == config.methodProfileWidth;
610             return new JavaMethodProfile(notRecordedMethodProbability, pmethods);
611         }
612 
<span class="line-modified">613         private static int getMethodOffset(int row) {</span>
<span class="line-modified">614             return VIRTUAL_CALL_DATA_FIRST_METHOD_OFFSET + row * TYPE_DATA_ROW_SIZE;</span>
615         }
616 
<span class="line-modified">617         private static int getMethodCountOffset(int row) {</span>
<span class="line-modified">618             return VIRTUAL_CALL_DATA_FIRST_METHOD_COUNT_OFFSET + row * TYPE_DATA_ROW_SIZE;</span>
619         }
620 
621         @Override
622         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
623             RawItemProfile&lt;ResolvedJavaMethod&gt; profile = getRawMethodProfile(data, pos);
624             super.appendTo(sb.append(format(&quot;exception_seen(%s) &quot;, getExceptionSeen(data, pos))), data, pos).append(format(&quot;%nmethod_entries(%d)&quot;, profile.entries));
625             for (int i = 0; i &lt; profile.entries; i++) {
626                 long count = profile.counts[i];
627                 sb.append(format(&quot;%n  %s (%d, %4.2f)&quot;, profile.items[i].format(&quot;%H.%n(%p)&quot;), count, (double) count / profile.totalCount));
628             }
629             return sb;
630         }
631     }
632 
633     static class VirtualCallTypeData extends VirtualCallData {
634 
<span class="line-modified">635         VirtualCallTypeData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">636             super(config, tag, 0);</span>
637         }
638 
639         @Override
640         protected int getDynamicSize(HotSpotMethodData data, int position) {
641             assert staticSize == 0;
642             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
643         }
644     }
645 
<span class="line-removed">646     static final int RET_DATA_ROW_SIZE = cellsToBytes(3);</span>
<span class="line-removed">647     static final int RET_DATA_SIZE = cellIndexToOffset(1) + RET_DATA_ROW_SIZE * config.bciProfileWidth;</span>
<span class="line-removed">648 </span>
649     static class RetData extends CounterData {
650 
<span class="line-modified">651         RetData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">652             super(config, tag, RET_DATA_SIZE);</span>
653         }
654     }
655 
<span class="line-removed">656     static final int BRANCH_DATA_SIZE = cellIndexToOffset(3);</span>
<span class="line-removed">657     static final int NOT_TAKEN_COUNT_OFFSET = cellIndexToOffset(config.branchDataNotTakenOffset);</span>
<span class="line-removed">658 </span>
659     static class BranchData extends JumpData {
660 
<span class="line-modified">661         BranchData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">662             super(config, tag, BRANCH_DATA_SIZE);</span>
663         }
664 
665         @Override
666         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
<span class="line-modified">667             long takenCount = data.readUnsignedInt(position, TAKEN_COUNT_OFFSET);</span>
<span class="line-modified">668             long notTakenCount = data.readUnsignedInt(position, NOT_TAKEN_COUNT_OFFSET);</span>
669             long total = takenCount + notTakenCount;
670 
671             return total &lt;= 0 ? -1 : takenCount / (double) total;
672         }
673 
674         @Override
675         public int getExecutionCount(HotSpotMethodData data, int position) {
<span class="line-modified">676             long count = data.readUnsignedInt(position, TAKEN_COUNT_OFFSET) + data.readUnsignedInt(position, NOT_TAKEN_COUNT_OFFSET);</span>
<span class="line-modified">677             return truncateLongToInt(count);</span>
678         }
679 
680         @Override
681         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
<span class="line-modified">682             long taken = data.readUnsignedInt(pos, TAKEN_COUNT_OFFSET);</span>
<span class="line-modified">683             long notTaken = data.readUnsignedInt(pos, NOT_TAKEN_COUNT_OFFSET);</span>
684             double takenProbability = getBranchTakenProbability(data, pos);
685             return sb.append(format(&quot;taken(%d, %4.2f) not_taken(%d, %4.2f) displacement(%d)&quot;, taken, takenProbability, notTaken, 1.0D - takenProbability, getTakenDisplacement(data, pos)));
686         }
687     }
688 
<span class="line-removed">689     static final int ARRAY_DATA_LENGTH_OFFSET = cellIndexToOffset(config.arrayDataArrayLenOffset);</span>
<span class="line-removed">690     static final int ARRAY_DATA_START_OFFSET = cellIndexToOffset(config.arrayDataArrayStartOffset);</span>
<span class="line-removed">691 </span>
692     static class ArrayData extends HotSpotMethodDataAccessor {
693 
<span class="line-modified">694         ArrayData(HotSpotVMConfig config, int tag, int staticSize) {</span>
<span class="line-modified">695             super(config, tag, staticSize);</span>
696         }
697 
698         @Override
699         protected int getDynamicSize(HotSpotMethodData data, int position) {
<span class="line-modified">700             return cellsToBytes(getLength(data, position));</span>
701         }
702 
<span class="line-modified">703         protected static int getLength(HotSpotMethodData data, int position) {</span>
<span class="line-modified">704             return data.readInt(position, ARRAY_DATA_LENGTH_OFFSET);</span>
705         }
706 
707         @Override
708         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
709             return sb.append(format(&quot;length(%d)&quot;, getLength(data, pos)));
710         }
711     }
712 
<span class="line-removed">713     static final int MULTI_BRANCH_DATA_SIZE = cellIndexToOffset(1);</span>
<span class="line-removed">714     static final int MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS = config.multiBranchDataPerCaseCellCount;</span>
<span class="line-removed">715     static final int MULTI_BRANCH_DATA_ROW_SIZE = cellsToBytes(MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS);</span>
<span class="line-removed">716     static final int MULTI_BRANCH_DATA_FIRST_COUNT_OFFSET = ARRAY_DATA_START_OFFSET + cellsToBytes(0);</span>
<span class="line-removed">717     static final int MULTI_BRANCH_DATA_FIRST_DISPLACEMENT_OFFSET = ARRAY_DATA_START_OFFSET + cellsToBytes(1);</span>
<span class="line-removed">718 </span>
719     static class MultiBranchData extends ArrayData {
720 
<span class="line-modified">721         MultiBranchData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">722             super(config, tag, MULTI_BRANCH_DATA_SIZE);</span>
723         }
724 
725         @Override
726         public double[] getSwitchProbabilities(HotSpotMethodData data, int position) {
727             int arrayLength = getLength(data, position);
728             assert arrayLength &gt; 0 : &quot;switch must have at least the default case&quot;;
<span class="line-modified">729             assert arrayLength % MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS == 0 : &quot;array must have full rows&quot;;</span>
730 
<span class="line-modified">731             int length = arrayLength / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;</span>
732             long totalCount = 0;
733             double[] result = new double[length];
734 
735             // default case is first in HotSpot but last for the compiler
736             long count = readCount(data, position, 0);
737             totalCount += count;
738             result[length - 1] = count;
739 
740             for (int i = 1; i &lt; length; i++) {
741                 count = readCount(data, position, i);
742                 totalCount += count;
743                 result[i - 1] = count;
744             }
745 
746             if (totalCount &lt;= 0) {
747                 return null;
748             } else {
749                 for (int i = 0; i &lt; length; i++) {
750                     result[i] = result[i] / totalCount;
751                 }
752                 return result;
753             }
754         }
755 
<span class="line-modified">756         private static long readCount(HotSpotMethodData data, int position, int i) {</span>
757             int offset;
758             long count;
759             offset = getCountOffset(i);
760             count = data.readUnsignedInt(position, offset);
761             return count;
762         }
763 
764         @Override
765         public int getExecutionCount(HotSpotMethodData data, int position) {
766             int arrayLength = getLength(data, position);
767             assert arrayLength &gt; 0 : &quot;switch must have at least the default case&quot;;
<span class="line-modified">768             assert arrayLength % MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS == 0 : &quot;array must have full rows&quot;;</span>
769 
<span class="line-modified">770             int length = arrayLength / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;</span>
771             long totalCount = 0;
772             for (int i = 0; i &lt; length; i++) {
773                 int offset = getCountOffset(i);
774                 totalCount += data.readUnsignedInt(position, offset);
775             }
776 
<span class="line-modified">777             return truncateLongToInt(totalCount);</span>
778         }
779 
<span class="line-modified">780         private static int getCountOffset(int index) {</span>
<span class="line-modified">781             return MULTI_BRANCH_DATA_FIRST_COUNT_OFFSET + index * MULTI_BRANCH_DATA_ROW_SIZE;</span>
782         }
783 
<span class="line-modified">784         private static int getDisplacementOffset(int index) {</span>
<span class="line-modified">785             return MULTI_BRANCH_DATA_FIRST_DISPLACEMENT_OFFSET + index * MULTI_BRANCH_DATA_ROW_SIZE;</span>
786         }
787 
788         @Override
789         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
<span class="line-modified">790             int entries = getLength(data, pos) / MULTI_BRANCH_DATA_ROW_SIZE_IN_CELLS;</span>
791             sb.append(format(&quot;entries(%d)&quot;, entries));
792             for (int i = 0; i &lt; entries; i++) {
793                 sb.append(format(&quot;%n  %d: count(%d) displacement(%d)&quot;, i, data.readUnsignedInt(pos, getCountOffset(i)), data.readUnsignedInt(pos, getDisplacementOffset(i))));
794             }
795             return sb;
796         }
797     }
798 
<span class="line-removed">799     static final int ARG_INFO_DATA_SIZE = cellIndexToOffset(1);</span>
<span class="line-removed">800 </span>
801     static class ArgInfoData extends ArrayData {
802 
<span class="line-modified">803         ArgInfoData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">804             super(config, tag, ARG_INFO_DATA_SIZE);</span>
805         }
806     }
807 
808     static class UnknownProfileData extends HotSpotMethodDataAccessor {
<span class="line-modified">809         UnknownProfileData(HotSpotVMConfig config, int tag) {</span>
<span class="line-modified">810             super(config, tag, 0);</span>
811         }
812 
813         @Override
814         protected int getDynamicSize(HotSpotMethodData data, int position) {
815             assert staticSize == 0;
816             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
817         }
818 
819         @Override
820         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
821             sb.append(&quot;unknown profile data with tag: &quot; + tag);
822             return sb;
823         }
824     }
825 
826     public void setCompiledIRSize(int size) {
<span class="line-modified">827         UNSAFE.putInt(metaspaceMethodData + config.methodDataIRSizeOffset, size);</span>
828     }
829 
830     public int getCompiledIRSize() {
<span class="line-modified">831         return UNSAFE.getInt(metaspaceMethodData + config.methodDataIRSizeOffset);</span>
<span class="line-removed">832     }</span>
<span class="line-removed">833 </span>
<span class="line-removed">834     // sorted by tag</span>
<span class="line-removed">835     // @formatter:off</span>
<span class="line-removed">836     static final HotSpotMethodDataAccessor[] PROFILE_DATA_ACCESSORS = {</span>
<span class="line-removed">837         null,</span>
<span class="line-removed">838         new BitData(config, config.dataLayoutBitDataTag),</span>
<span class="line-removed">839         new CounterData(config, config.dataLayoutCounterDataTag),</span>
<span class="line-removed">840         new JumpData(config, config.dataLayoutJumpDataTag),</span>
<span class="line-removed">841         new ReceiverTypeData(config, config.dataLayoutReceiverTypeDataTag),</span>
<span class="line-removed">842         new VirtualCallData(config, config.dataLayoutVirtualCallDataTag),</span>
<span class="line-removed">843         new RetData(config, config.dataLayoutRetDataTag),</span>
<span class="line-removed">844         new BranchData(config, config.dataLayoutBranchDataTag),</span>
<span class="line-removed">845         new MultiBranchData(config, config.dataLayoutMultiBranchDataTag),</span>
<span class="line-removed">846         new ArgInfoData(config, config.dataLayoutArgInfoDataTag),</span>
<span class="line-removed">847         new UnknownProfileData(config, config.dataLayoutCallTypeDataTag),</span>
<span class="line-removed">848         new VirtualCallTypeData(config, config.dataLayoutVirtualCallTypeDataTag),</span>
<span class="line-removed">849         new UnknownProfileData(config, config.dataLayoutParametersTypeDataTag),</span>
<span class="line-removed">850         new UnknownProfileData(config, config.dataLayoutSpeculativeTrapDataTag),</span>
<span class="line-removed">851     };</span>
<span class="line-removed">852 </span>
<span class="line-removed">853     private static boolean checkAccessorTags() {</span>
<span class="line-removed">854         int expectedTag = 0;</span>
<span class="line-removed">855         for (HotSpotMethodDataAccessor accessor : PROFILE_DATA_ACCESSORS) {</span>
<span class="line-removed">856             if (expectedTag == 0) {</span>
<span class="line-removed">857                 assert accessor == null;</span>
<span class="line-removed">858             } else {</span>
<span class="line-removed">859                 assert accessor.tag == expectedTag : expectedTag + &quot; != &quot; + accessor.tag + &quot; &quot; + accessor;</span>
<span class="line-removed">860             }</span>
<span class="line-removed">861             expectedTag++;</span>
<span class="line-removed">862         }</span>
<span class="line-removed">863         return true;</span>
<span class="line-removed">864     }</span>
<span class="line-removed">865 </span>
<span class="line-removed">866     static {</span>
<span class="line-removed">867         assert checkAccessorTags();</span>
868     }
<span class="line-removed">869     // @formatter:on</span>
870 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static java.lang.String.format;
 26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
 27 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
 29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 30 
 31 import java.util.Arrays;
 32 
<span class="line-added"> 33 import jdk.vm.ci.common.NativeImageReinitialize;</span>
 34 import jdk.internal.misc.Unsafe;
 35 import jdk.vm.ci.meta.DeoptimizationReason;
 36 import jdk.vm.ci.meta.JavaMethodProfile;
 37 import jdk.vm.ci.meta.JavaMethodProfile.ProfiledMethod;
 38 import jdk.vm.ci.meta.JavaTypeProfile;
 39 import jdk.vm.ci.meta.JavaTypeProfile.ProfiledType;
 40 import jdk.vm.ci.meta.ResolvedJavaMethod;
 41 import jdk.vm.ci.meta.ResolvedJavaType;
 42 import jdk.vm.ci.meta.TriState;
 43 
 44 /**
 45  * Access to a HotSpot {@code MethodData} structure (defined in methodData.hpp).
 46  */
 47 final class HotSpotMethodData {
 48 
<span class="line-modified"> 49     /**</span>
<span class="line-modified"> 50      * VM state that can be reset when building an AOT image.</span>
<span class="line-modified"> 51      */</span>
<span class="line-added"> 52     static final class VMState {</span>
<span class="line-added"> 53         final HotSpotVMConfig config = config();</span>
<span class="line-added"> 54         final HotSpotMethodDataAccessor noDataNoExceptionAccessor = new NoMethodData(this, config.dataLayoutNoTag, TriState.FALSE);</span>
<span class="line-added"> 55         final HotSpotMethodDataAccessor noDataExceptionPossiblyNotRecordedAccessor = new NoMethodData(this, config.dataLayoutNoTag, TriState.UNKNOWN);</span>
<span class="line-added"> 56         final int noDataSize = cellIndexToOffset(0);</span>
<span class="line-added"> 57         final int bitDataSize = cellIndexToOffset(0);</span>
<span class="line-added"> 58         final int bitDataNullSeenFlag = 1 &lt;&lt; config.bitDataNullSeenFlag;</span>
<span class="line-added"> 59         final int counterDataSize = cellIndexToOffset(1);</span>
<span class="line-added"> 60         final int counterDataCountOffset = cellIndexToOffset(config.methodDataCountOffset);</span>
<span class="line-added"> 61         final int jumpDataSize = cellIndexToOffset(2);</span>
<span class="line-added"> 62         final int takenCountOffset = cellIndexToOffset(config.jumpDataTakenOffset);</span>
<span class="line-added"> 63         final int takenDisplacementOffset = cellIndexToOffset(config.jumpDataDisplacementOffset);</span>
<span class="line-added"> 64         final int typeDataRowSize = cellsToBytes(config.receiverTypeDataReceiverTypeRowCellCount);</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66         final int nonprofiledCountOffset = cellIndexToOffset(config.receiverTypeDataNonprofiledCountOffset);</span>
<span class="line-added"> 67         final int typeDataFirstTypeOffset = cellIndexToOffset(config.receiverTypeDataReceiver0Offset);</span>
<span class="line-added"> 68         final int typeDataFirstTypeCountOffset = cellIndexToOffset(config.receiverTypeDataCount0Offset);</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70         final int typeCheckDataSize = cellIndexToOffset(2) + typeDataRowSize * config.typeProfileWidth;</span>
<span class="line-added"> 71         final int virtualCallDataSize = cellIndexToOffset(2) + typeDataRowSize * (config.typeProfileWidth + config.methodProfileWidth);</span>
<span class="line-added"> 72         final int virtualCallDataFirstMethodOffset = typeDataFirstTypeOffset + typeDataRowSize * config.typeProfileWidth;</span>
<span class="line-added"> 73         final int virtualCallDataFirstMethodCountOffset = typeDataFirstTypeCountOffset + typeDataRowSize * config.typeProfileWidth;</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75         final int retDataRowSize = cellsToBytes(3);</span>
<span class="line-added"> 76         final int retDataSize = cellIndexToOffset(1) + retDataRowSize * config.bciProfileWidth;</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78         final int branchDataSize = cellIndexToOffset(3);</span>
<span class="line-added"> 79         final int notTakenCountOffset = cellIndexToOffset(config.branchDataNotTakenOffset);</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81         final int arrayDataLengthOffset = cellIndexToOffset(config.arrayDataArrayLenOffset);</span>
<span class="line-added"> 82         final int arrayDataStartOffset = cellIndexToOffset(config.arrayDataArrayStartOffset);</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84         final int multiBranchDataSize = cellIndexToOffset(1);</span>
<span class="line-added"> 85         final int multiBranchDataRowSizeInCells = config.multiBranchDataPerCaseCellCount;</span>
<span class="line-added"> 86         final int multiBranchDataRowSize = cellsToBytes(multiBranchDataRowSizeInCells);</span>
<span class="line-added"> 87         final int multiBranchDataFirstCountOffset = arrayDataStartOffset + cellsToBytes(0);</span>
<span class="line-added"> 88         final int multiBranchDataFirstDisplacementOffset = arrayDataStartOffset + cellsToBytes(1);</span>
<span class="line-added"> 89 </span>
<span class="line-added"> 90         final int argInfoDataSize = cellIndexToOffset(1);</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92         // sorted by tag</span>
<span class="line-added"> 93         // @formatter:off</span>
<span class="line-added"> 94         final HotSpotMethodDataAccessor[] profileDataAccessors = {</span>
<span class="line-added"> 95             null,</span>
<span class="line-added"> 96             new BitData(this, config.dataLayoutBitDataTag),</span>
<span class="line-added"> 97             new CounterData(this, config.dataLayoutCounterDataTag),</span>
<span class="line-added"> 98             new JumpData(this, config.dataLayoutJumpDataTag),</span>
<span class="line-added"> 99             new ReceiverTypeData(this, config.dataLayoutReceiverTypeDataTag),</span>
<span class="line-added">100             new VirtualCallData(this, config.dataLayoutVirtualCallDataTag),</span>
<span class="line-added">101             new RetData(this, config.dataLayoutRetDataTag),</span>
<span class="line-added">102             new BranchData(this, config.dataLayoutBranchDataTag),</span>
<span class="line-added">103             new MultiBranchData(this, config.dataLayoutMultiBranchDataTag),</span>
<span class="line-added">104             new ArgInfoData(this, config.dataLayoutArgInfoDataTag),</span>
<span class="line-added">105             new UnknownProfileData(this, config.dataLayoutCallTypeDataTag),</span>
<span class="line-added">106             new VirtualCallTypeData(this, config.dataLayoutVirtualCallTypeDataTag),</span>
<span class="line-added">107             new UnknownProfileData(this, config.dataLayoutParametersTypeDataTag),</span>
<span class="line-added">108             new UnknownProfileData(this, config.dataLayoutSpeculativeTrapDataTag),</span>
<span class="line-added">109         };</span>
<span class="line-added">110         // @formatter:on</span>
<span class="line-added">111 </span>
<span class="line-added">112         private boolean checkAccessorTags() {</span>
<span class="line-added">113             int expectedTag = 0;</span>
<span class="line-added">114             for (HotSpotMethodDataAccessor accessor : profileDataAccessors) {</span>
<span class="line-added">115                 if (expectedTag == 0) {</span>
<span class="line-added">116                     assert accessor == null;</span>
<span class="line-added">117                 } else {</span>
<span class="line-added">118                     assert accessor.tag == expectedTag : expectedTag + &quot; != &quot; + accessor.tag + &quot; &quot; + accessor;</span>
<span class="line-added">119                 }</span>
<span class="line-added">120                 expectedTag++;</span>
<span class="line-added">121             }</span>
<span class="line-added">122             return true;</span>
<span class="line-added">123         }</span>
<span class="line-added">124 </span>
<span class="line-added">125         private VMState() {</span>
<span class="line-added">126             assert checkAccessorTags();</span>
<span class="line-added">127         }</span>
<span class="line-added">128 </span>
<span class="line-added">129         private static int truncateLongToInt(long value) {</span>
<span class="line-added">130             return value &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) value;</span>
<span class="line-added">131         }</span>
<span class="line-added">132 </span>
<span class="line-added">133         private int computeFullOffset(int position, int offsetInBytes) {</span>
<span class="line-added">134             return config.methodDataOopDataOffset + position + offsetInBytes;</span>
<span class="line-added">135         }</span>
<span class="line-added">136 </span>
<span class="line-added">137         private int cellIndexToOffset(int cells) {</span>
<span class="line-added">138             return config.dataLayoutHeaderSize + cellsToBytes(cells);</span>
<span class="line-added">139         }</span>
<span class="line-added">140 </span>
<span class="line-added">141         private int cellsToBytes(int cells) {</span>
<span class="line-added">142             return cells * config.dataLayoutCellSize;</span>
<span class="line-added">143         }</span>
<span class="line-added">144 </span>
<span class="line-added">145         /**</span>
<span class="line-added">146          * Singleton instance lazily initialized via double-checked locking.</span>
<span class="line-added">147          */</span>
<span class="line-added">148         @NativeImageReinitialize private static volatile VMState instance;</span>
<span class="line-added">149 </span>
<span class="line-added">150         static VMState instance() {</span>
<span class="line-added">151             VMState result = instance;</span>
<span class="line-added">152             if (result == null) {</span>
<span class="line-added">153                 synchronized (VMState.class) {</span>
<span class="line-added">154                     result = instance;</span>
<span class="line-added">155                     if (result == null) {</span>
<span class="line-added">156                         instance = result = new VMState();</span>
<span class="line-added">157                     }</span>
<span class="line-added">158                 }</span>
<span class="line-added">159             }</span>
<span class="line-added">160             return result;</span>
<span class="line-added">161         }</span>
<span class="line-added">162     }</span>
163 
164     /**
165      * Reference to the C++ MethodData object.
166      */
167     final long metaspaceMethodData;
168     private final HotSpotResolvedJavaMethodImpl method;
<span class="line-added">169     private final VMState state;</span>
170 
171     HotSpotMethodData(long metaspaceMethodData, HotSpotResolvedJavaMethodImpl method) {
172         this.metaspaceMethodData = metaspaceMethodData;
173         this.method = method;
<span class="line-added">174         this.state = VMState.instance();</span>
175     }
176 
177     /**
178      * @return value of the MethodData::_data_size field
179      */
180     private int normalDataSize() {
<span class="line-modified">181         return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataDataSize);</span>
182     }
183 
184     /**
185      * Returns the size of the extra data records. This method does the same calculation as
186      * MethodData::extra_data_size().
187      *
188      * @return size of extra data records
189      */
190     private int extraDataSize() {
<span class="line-modified">191         final int extraDataBase = state.config.methodDataOopDataOffset + normalDataSize();</span>
<span class="line-modified">192         final int extraDataLimit = UNSAFE.getInt(metaspaceMethodData + state.config.methodDataSize);</span>
193         return extraDataLimit - extraDataBase;
194     }
195 
196     public boolean hasNormalData() {
197         return normalDataSize() &gt; 0;
198     }
199 
200     public boolean hasExtraData() {
201         return extraDataSize() &gt; 0;
202     }
203 
204     public int getExtraDataBeginOffset() {
205         return normalDataSize();
206     }
207 
208     public boolean isWithin(int position) {
209         return position &gt;= 0 &amp;&amp; position &lt; normalDataSize() + extraDataSize();
210     }
211 
212     public int getDeoptimizationCount(DeoptimizationReason reason) {
213         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
214         int reasonIndex = metaAccess.convertDeoptReason(reason);
<span class="line-modified">215         return UNSAFE.getByte(metaspaceMethodData + state.config.methodDataOopTrapHistoryOffset + reasonIndex) &amp; 0xFF;</span>
216     }
217 
218     public int getOSRDeoptimizationCount(DeoptimizationReason reason) {
219         HotSpotMetaAccessProvider metaAccess = (HotSpotMetaAccessProvider) runtime().getHostJVMCIBackend().getMetaAccess();
220         int reasonIndex = metaAccess.convertDeoptReason(reason);
<span class="line-modified">221         return UNSAFE.getByte(metaspaceMethodData + state.config.methodDataOopTrapHistoryOffset + state.config.deoptReasonOSROffset + reasonIndex) &amp; 0xFF;</span>
222     }
223 
224     public int getDecompileCount() {
<span class="line-modified">225         return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataDecompiles);</span>
226     }
227 
228     public int getOverflowRecompileCount() {
<span class="line-modified">229         return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataOverflowRecompiles);</span>
230     }
231 
232     public int getOverflowTrapCount() {
<span class="line-modified">233         return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataOverflowTraps);</span>
234     }
235 
236     public HotSpotMethodDataAccessor getNormalData(int position) {
237         if (position &gt;= normalDataSize()) {
238             return null;
239         }
240 
241         return getData(position);
242     }
243 
244     public HotSpotMethodDataAccessor getExtraData(int position) {
245         if (position &gt;= normalDataSize() + extraDataSize()) {
246             return null;
247         }
248         HotSpotMethodDataAccessor data = getData(position);
249         if (data != null) {
250             return data;
251         }
252         return data;
253     }
254 
255     public static HotSpotMethodDataAccessor getNoDataAccessor(boolean exceptionPossiblyNotRecorded) {
256         if (exceptionPossiblyNotRecorded) {
<span class="line-modified">257             return VMState.instance().noDataExceptionPossiblyNotRecordedAccessor;</span>
258         } else {
<span class="line-modified">259             return VMState.instance().noDataNoExceptionAccessor;</span>
260         }
261     }
262 
263     private HotSpotMethodDataAccessor getData(int position) {
264         assert position &gt;= 0 : &quot;out of bounds&quot;;
<span class="line-modified">265         final int tag = HotSpotMethodDataAccessor.readTag(state.config, this, position);</span>
<span class="line-modified">266         HotSpotMethodDataAccessor accessor = state.profileDataAccessors[tag];</span>
267         assert accessor == null || accessor.getTag() == tag : &quot;wrong data accessor &quot; + accessor + &quot; for tag &quot; + tag;
268         return accessor;
269     }
270 
271     int readUnsignedByte(int position, int offsetInBytes) {
<span class="line-modified">272         long fullOffsetInBytes = state.computeFullOffset(position, offsetInBytes);</span>
273         return UNSAFE.getByte(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFF;
274     }
275 
276     int readUnsignedShort(int position, int offsetInBytes) {
<span class="line-modified">277         long fullOffsetInBytes = state.computeFullOffset(position, offsetInBytes);</span>
278         return UNSAFE.getShort(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFF;
279     }
280 
281     /**
282      * Since the values are stored in cells (platform words) this method uses
283      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
284      */
285     private long readUnsignedInt(int position, int offsetInBytes) {
<span class="line-modified">286         long fullOffsetInBytes = state.computeFullOffset(position, offsetInBytes);</span>
287         return UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes) &amp; 0xFFFFFFFFL;
288     }
289 
290     private int readUnsignedIntAsSignedInt(int position, int offsetInBytes) {
291         long value = readUnsignedInt(position, offsetInBytes);
<span class="line-modified">292         return VMState.truncateLongToInt(value);</span>
293     }
294 
295     /**
296      * Since the values are stored in cells (platform words) this method uses
297      * {@link Unsafe#getAddress} to read the right value on both little and big endian machines.
298      */
299     private int readInt(int position, int offsetInBytes) {
<span class="line-modified">300         long fullOffsetInBytes = state.computeFullOffset(position, offsetInBytes);</span>
301         return (int) UNSAFE.getAddress(metaspaceMethodData + fullOffsetInBytes);
302     }
303 
304     private HotSpotResolvedJavaMethod readMethod(int position, int offsetInBytes) {
<span class="line-modified">305         long fullOffsetInBytes = state.computeFullOffset(position, offsetInBytes);</span>
306         return compilerToVM().getResolvedJavaMethod(null, metaspaceMethodData + fullOffsetInBytes);
307     }
308 
309     private HotSpotResolvedObjectTypeImpl readKlass(int position, int offsetInBytes) {
<span class="line-modified">310         long fullOffsetInBytes = state.computeFullOffset(position, offsetInBytes);</span>
<span class="line-modified">311         return compilerToVM().getResolvedJavaType(metaspaceMethodData + fullOffsetInBytes, false);</span>
















312     }
313 
314     /**
315      * Returns whether profiling ran long enough that the profile information is mature. Other
316      * informational data will still be valid even if the profile isn&#39;t mature.
317      */
318     public boolean isProfileMature() {
319         return runtime().getCompilerToVM().isMature(metaspaceMethodData);
320     }
321 
322     @Override
323     public String toString() {
324         StringBuilder sb = new StringBuilder();
325         String nl = String.format(&quot;%n&quot;);
326         String nlIndent = String.format(&quot;%n%38s&quot;, &quot;&quot;);
327         sb.append(&quot;Raw method data for &quot;);
328         sb.append(method.format(&quot;%H.%n(%p)&quot;));
329         sb.append(&quot;:&quot;);
330         sb.append(nl);
331         sb.append(String.format(&quot;nof_decompiles(%d) nof_overflow_recompiles(%d) nof_overflow_traps(%d)%n&quot;,
</pre>
<hr />
<pre>
344             }
345         }
346 
347         if (hasExtraData()) {
348             int pos = getExtraDataBeginOffset();
349             HotSpotMethodDataAccessor data;
350             while ((data = getExtraData(pos)) != null) {
351                 if (pos == getExtraDataBeginOffset()) {
352                     sb.append(nl).append(&quot;--- Extra data:&quot;);
353                 }
354                 int bci = data.getBCI(this, pos);
355                 sb.append(String.format(&quot;%n%-6d bci: %-6d%-20s&quot;, pos, bci, data.getClass().getSimpleName()));
356                 sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));
357                 pos = pos + data.getSize(this, pos);
358             }
359 
360         }
361         return sb.toString();
362     }
363 


364     static class NoMethodData extends HotSpotMethodDataAccessor {
365 
366         private final TriState exceptionSeen;
367 
<span class="line-modified">368         protected NoMethodData(VMState state, int tag, TriState exceptionSeen) {</span>
<span class="line-modified">369             super(state, tag, state.noDataSize);</span>
370             this.exceptionSeen = exceptionSeen;
371         }
372 
373         @Override
374         public int getBCI(HotSpotMethodData data, int position) {
375             return -1;
376         }
377 
378         @Override
379         public TriState getExceptionSeen(HotSpotMethodData data, int position) {
380             return exceptionSeen;
381         }
382 
383         @Override
384         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
385             return sb;
386         }
387     }
388 



389     static class BitData extends HotSpotMethodDataAccessor {
390 
<span class="line-modified">391         private BitData(VMState state, int tag) {</span>
<span class="line-modified">392             super(state, tag, state.bitDataSize);</span>
393         }
394 
<span class="line-modified">395         protected BitData(VMState state, int tag, int staticSize) {</span>
<span class="line-modified">396             super(state, tag, staticSize);</span>
397         }
398 
399         @Override
400         public TriState getNullSeen(HotSpotMethodData data, int position) {
<span class="line-modified">401             return TriState.get((getFlags(data, position) &amp; state.bitDataNullSeenFlag) != 0);</span>
402         }
403 
404         @Override
405         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
406             return sb.append(format(&quot;exception_seen(%s)&quot;, getExceptionSeen(data, pos)));
407         }
408     }
409 



410     static class CounterData extends BitData {
411 
<span class="line-modified">412         CounterData(VMState state, int tag) {</span>
<span class="line-modified">413             super(state, tag, state.counterDataSize);</span>
414         }
415 
<span class="line-modified">416         protected CounterData(VMState state, int tag, int staticSize) {</span>
<span class="line-modified">417             super(state, tag, staticSize);</span>
418         }
419 
420         @Override
421         public int getExecutionCount(HotSpotMethodData data, int position) {
422             return getCounterValue(data, position);
423         }
424 
425         protected int getCounterValue(HotSpotMethodData data, int position) {
<span class="line-modified">426             return data.readUnsignedIntAsSignedInt(position, state.counterDataCountOffset);</span>
427         }
428 
429         @Override
430         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
431             return sb.append(format(&quot;count(%d) null_seen(%s) exception_seen(%s)&quot;, getCounterValue(data, pos), getNullSeen(data, pos), getExceptionSeen(data, pos)));
432         }
433     }
434 




435     static class JumpData extends HotSpotMethodDataAccessor {
436 
<span class="line-modified">437         JumpData(VMState state, int tag) {</span>
<span class="line-modified">438             super(state, tag, state.jumpDataSize);</span>
439         }
440 
<span class="line-modified">441         protected JumpData(VMState state, int tag, int staticSize) {</span>
<span class="line-modified">442             super(state, tag, staticSize);</span>
443         }
444 
445         @Override
446         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
447             return getExecutionCount(data, position) != 0 ? 1 : 0;
448         }
449 
450         @Override
451         public int getExecutionCount(HotSpotMethodData data, int position) {
<span class="line-modified">452             return data.readUnsignedIntAsSignedInt(position, state.takenCountOffset);</span>
453         }
454 
455         public int getTakenDisplacement(HotSpotMethodData data, int position) {
<span class="line-modified">456             return data.readInt(position, state.takenDisplacementOffset);</span>
457         }
458 
459         @Override
460         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
461             return sb.append(format(&quot;taken(%d) displacement(%d)&quot;, getExecutionCount(data, pos), getTakenDisplacement(data, pos)));
462         }
463     }
464 
465     static class RawItemProfile&lt;T&gt; {
466         final int entries;
467         final T[] items;
468         final long[] counts;
469         final long totalCount;
470 
471         RawItemProfile(int entries, T[] items, long[] counts, long totalCount) {
472             this.entries = entries;
473             this.items = items;
474             this.counts = counts;
475             this.totalCount = totalCount;
476         }
477     }
478 






479     abstract static class AbstractTypeData extends CounterData {
480 
<span class="line-modified">481         protected AbstractTypeData(VMState state, int tag, int staticSize) {</span>
<span class="line-modified">482             super(state, tag, staticSize);</span>
483         }
484 
485         @Override
486         public JavaTypeProfile getTypeProfile(HotSpotMethodData data, int position) {
487             return createTypeProfile(getNullSeen(data, position), getRawTypeProfile(data, position));
488         }
489 
490         private RawItemProfile&lt;ResolvedJavaType&gt; getRawTypeProfile(HotSpotMethodData data, int position) {
491             int typeProfileWidth = config.typeProfileWidth;
492 
493             ResolvedJavaType[] types = new ResolvedJavaType[typeProfileWidth];
494             long[] counts = new long[typeProfileWidth];
495             long totalCount = 0;
496             int entries = 0;
497 
498             outer: for (int i = 0; i &lt; typeProfileWidth; i++) {
499                 HotSpotResolvedObjectTypeImpl receiverKlass = data.readKlass(position, getTypeOffset(i));
500                 if (receiverKlass != null) {
501                     HotSpotResolvedObjectTypeImpl klass = receiverKlass;
502                     long count = data.readUnsignedInt(position, getTypeCountOffset(i));
</pre>
<hr />
<pre>
509                         if (types[j].equals(klass)) {
510                             totalCount += count;
511                             counts[j] += count;
512                             continue outer;
513                         }
514                     }
515                     types[entries] = klass;
516                     totalCount += count;
517                     counts[entries] = count;
518                     entries++;
519                 }
520             }
521 
522             totalCount += getTypesNotRecordedExecutionCount(data, position);
523             return new RawItemProfile&lt;&gt;(entries, types, counts, totalCount);
524         }
525 
526         protected abstract long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position);
527 
528         public int getNonprofiledCount(HotSpotMethodData data, int position) {
<span class="line-modified">529             return data.readUnsignedIntAsSignedInt(position, state.nonprofiledCountOffset);</span>
530         }
531 
532         private JavaTypeProfile createTypeProfile(TriState nullSeen, RawItemProfile&lt;ResolvedJavaType&gt; profile) {
533             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
534                 return null;
535             }
536 
537             ProfiledType[] ptypes = new ProfiledType[profile.entries];
538             double totalProbability = 0.0;
539             for (int i = 0; i &lt; profile.entries; i++) {
540                 double p = profile.counts[i];
541                 p = p / profile.totalCount;
542                 totalProbability += p;
543                 ptypes[i] = new ProfiledType(profile.items[i], p);
544             }
545 
546             Arrays.sort(ptypes);
547 
548             double notRecordedTypeProbability = profile.entries &lt; config.typeProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
549             assert notRecordedTypeProbability == 0 || profile.entries == config.typeProfileWidth;
550             return new JavaTypeProfile(nullSeen, notRecordedTypeProbability, ptypes);
551         }
552 
<span class="line-modified">553         private int getTypeOffset(int row) {</span>
<span class="line-modified">554             return state.typeDataFirstTypeOffset + row * state.typeDataRowSize;</span>
555         }
556 
<span class="line-modified">557         protected int getTypeCountOffset(int row) {</span>
<span class="line-modified">558             return state.typeDataFirstTypeCountOffset + row * state.typeDataRowSize;</span>
559         }
560 
561         @Override
562         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
563             RawItemProfile&lt;ResolvedJavaType&gt; profile = getRawTypeProfile(data, pos);
564             TriState nullSeen = getNullSeen(data, pos);
565             TriState exceptionSeen = getExceptionSeen(data, pos);
566             sb.append(format(&quot;count(%d) null_seen(%s) exception_seen(%s) nonprofiled_count(%d) entries(%d)&quot;, getCounterValue(data, pos), nullSeen, exceptionSeen,
567                             getNonprofiledCount(data, pos), profile.entries));
568             for (int i = 0; i &lt; profile.entries; i++) {
569                 long count = profile.counts[i];
570                 sb.append(format(&quot;%n  %s (%d, %4.2f)&quot;, profile.items[i].toJavaName(), count, (double) count / profile.totalCount));
571             }
572             return sb;
573         }
574     }
575 


576     static class ReceiverTypeData extends AbstractTypeData {
577 
<span class="line-modified">578         ReceiverTypeData(VMState state, int tag) {</span>
<span class="line-modified">579             super(state, tag, state.typeCheckDataSize);</span>
580         }
581 
<span class="line-modified">582         protected ReceiverTypeData(VMState state, int tag, int staticSize) {</span>
<span class="line-modified">583             super(state, tag, staticSize);</span>
584         }
585 
586         @Override
587         public int getExecutionCount(HotSpotMethodData data, int position) {
588             return -1;
589         }
590 
591         @Override
592         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
593             return getNonprofiledCount(data, position);
594         }
595     }
596 




597     static class VirtualCallData extends ReceiverTypeData {
598 
<span class="line-modified">599         VirtualCallData(VMState state, int tag) {</span>
<span class="line-modified">600             super(state, tag, state.virtualCallDataSize);</span>
601         }
602 
<span class="line-modified">603         protected VirtualCallData(VMState state, int tag, int staticSize) {</span>
<span class="line-modified">604             super(state, tag, staticSize);</span>
605         }
606 
607         @Override
608         public int getExecutionCount(HotSpotMethodData data, int position) {
609             final int typeProfileWidth = config.typeProfileWidth;
610 
611             long total = 0;
612             for (int i = 0; i &lt; typeProfileWidth; i++) {
613                 total += data.readUnsignedInt(position, getTypeCountOffset(i));
614             }
615 
616             total += getCounterValue(data, position);
<span class="line-modified">617             return VMState.truncateLongToInt(total);</span>
618         }
619 
620         @Override
621         protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {
622             return getCounterValue(data, position);
623         }
624 
<span class="line-modified">625         private long getMethodsNotRecordedExecutionCount(HotSpotMethodData data, int position) {</span>
<span class="line-modified">626             return data.readUnsignedIntAsSignedInt(position, state.nonprofiledCountOffset);</span>
627         }
628 
629         @Override
630         public JavaMethodProfile getMethodProfile(HotSpotMethodData data, int position) {
631             return createMethodProfile(getRawMethodProfile(data, position));
632         }
633 
634         private RawItemProfile&lt;ResolvedJavaMethod&gt; getRawMethodProfile(HotSpotMethodData data, int position) {
635             int profileWidth = config.methodProfileWidth;
636 
637             ResolvedJavaMethod[] methods = new ResolvedJavaMethod[profileWidth];
638             long[] counts = new long[profileWidth];
639             long totalCount = 0;
640             int entries = 0;
641 
642             for (int i = 0; i &lt; profileWidth; i++) {
643                 HotSpotResolvedJavaMethod method = data.readMethod(position, getMethodOffset(i));
644                 if (method != null) {
645                     methods[entries] = method;
646                     long count = data.readUnsignedInt(position, getMethodCountOffset(i));
</pre>
<hr />
<pre>
667             if (profile.entries &lt;= 0 || profile.totalCount &lt;= 0) {
668                 return null;
669             }
670 
671             ProfiledMethod[] pmethods = new ProfiledMethod[profile.entries];
672             double totalProbability = 0.0;
673             for (int i = 0; i &lt; profile.entries; i++) {
674                 double p = profile.counts[i];
675                 p = p / profile.totalCount;
676                 totalProbability += p;
677                 pmethods[i] = new ProfiledMethod(profile.items[i], p);
678             }
679 
680             Arrays.sort(pmethods);
681 
682             double notRecordedMethodProbability = profile.entries &lt; config.methodProfileWidth ? 0.0 : Math.min(1.0, Math.max(0.0, 1.0 - totalProbability));
683             assert notRecordedMethodProbability == 0 || profile.entries == config.methodProfileWidth;
684             return new JavaMethodProfile(notRecordedMethodProbability, pmethods);
685         }
686 
<span class="line-modified">687         private int getMethodOffset(int row) {</span>
<span class="line-modified">688             return state.virtualCallDataFirstMethodOffset + row * state.typeDataRowSize;</span>
689         }
690 
<span class="line-modified">691         private int getMethodCountOffset(int row) {</span>
<span class="line-modified">692             return state.virtualCallDataFirstMethodCountOffset + row * state.typeDataRowSize;</span>
693         }
694 
695         @Override
696         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
697             RawItemProfile&lt;ResolvedJavaMethod&gt; profile = getRawMethodProfile(data, pos);
698             super.appendTo(sb.append(format(&quot;exception_seen(%s) &quot;, getExceptionSeen(data, pos))), data, pos).append(format(&quot;%nmethod_entries(%d)&quot;, profile.entries));
699             for (int i = 0; i &lt; profile.entries; i++) {
700                 long count = profile.counts[i];
701                 sb.append(format(&quot;%n  %s (%d, %4.2f)&quot;, profile.items[i].format(&quot;%H.%n(%p)&quot;), count, (double) count / profile.totalCount));
702             }
703             return sb;
704         }
705     }
706 
707     static class VirtualCallTypeData extends VirtualCallData {
708 
<span class="line-modified">709         VirtualCallTypeData(VMState state, int tag) {</span>
<span class="line-modified">710             super(state, tag, 0);</span>
711         }
712 
713         @Override
714         protected int getDynamicSize(HotSpotMethodData data, int position) {
715             assert staticSize == 0;
716             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
717         }
718     }
719 



720     static class RetData extends CounterData {
721 
<span class="line-modified">722         RetData(VMState state, int tag) {</span>
<span class="line-modified">723             super(state, tag, state.retDataSize);</span>
724         }
725     }
726 



727     static class BranchData extends JumpData {
728 
<span class="line-modified">729         BranchData(VMState state, int tag) {</span>
<span class="line-modified">730             super(state, tag, state.branchDataSize);</span>
731         }
732 
733         @Override
734         public double getBranchTakenProbability(HotSpotMethodData data, int position) {
<span class="line-modified">735             long takenCount = data.readUnsignedInt(position, state.takenCountOffset);</span>
<span class="line-modified">736             long notTakenCount = data.readUnsignedInt(position, state.notTakenCountOffset);</span>
737             long total = takenCount + notTakenCount;
738 
739             return total &lt;= 0 ? -1 : takenCount / (double) total;
740         }
741 
742         @Override
743         public int getExecutionCount(HotSpotMethodData data, int position) {
<span class="line-modified">744             long count = data.readUnsignedInt(position, state.takenCountOffset) + data.readUnsignedInt(position, state.notTakenCountOffset);</span>
<span class="line-modified">745             return VMState.truncateLongToInt(count);</span>
746         }
747 
748         @Override
749         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
<span class="line-modified">750             long taken = data.readUnsignedInt(pos, state.takenCountOffset);</span>
<span class="line-modified">751             long notTaken = data.readUnsignedInt(pos, state.notTakenCountOffset);</span>
752             double takenProbability = getBranchTakenProbability(data, pos);
753             return sb.append(format(&quot;taken(%d, %4.2f) not_taken(%d, %4.2f) displacement(%d)&quot;, taken, takenProbability, notTaken, 1.0D - takenProbability, getTakenDisplacement(data, pos)));
754         }
755     }
756 



757     static class ArrayData extends HotSpotMethodDataAccessor {
758 
<span class="line-modified">759         ArrayData(VMState state, int tag, int staticSize) {</span>
<span class="line-modified">760             super(state, tag, staticSize);</span>
761         }
762 
763         @Override
764         protected int getDynamicSize(HotSpotMethodData data, int position) {
<span class="line-modified">765             return state.cellsToBytes(getLength(data, position));</span>
766         }
767 
<span class="line-modified">768         protected int getLength(HotSpotMethodData data, int position) {</span>
<span class="line-modified">769             return data.readInt(position, state.arrayDataLengthOffset);</span>
770         }
771 
772         @Override
773         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
774             return sb.append(format(&quot;length(%d)&quot;, getLength(data, pos)));
775         }
776     }
777 






778     static class MultiBranchData extends ArrayData {
779 
<span class="line-modified">780         MultiBranchData(VMState state, int tag) {</span>
<span class="line-modified">781             super(state, tag, state.multiBranchDataSize);</span>
782         }
783 
784         @Override
785         public double[] getSwitchProbabilities(HotSpotMethodData data, int position) {
786             int arrayLength = getLength(data, position);
787             assert arrayLength &gt; 0 : &quot;switch must have at least the default case&quot;;
<span class="line-modified">788             assert arrayLength % state.multiBranchDataRowSizeInCells == 0 : &quot;array must have full rows&quot;;</span>
789 
<span class="line-modified">790             int length = arrayLength / state.multiBranchDataRowSizeInCells;</span>
791             long totalCount = 0;
792             double[] result = new double[length];
793 
794             // default case is first in HotSpot but last for the compiler
795             long count = readCount(data, position, 0);
796             totalCount += count;
797             result[length - 1] = count;
798 
799             for (int i = 1; i &lt; length; i++) {
800                 count = readCount(data, position, i);
801                 totalCount += count;
802                 result[i - 1] = count;
803             }
804 
805             if (totalCount &lt;= 0) {
806                 return null;
807             } else {
808                 for (int i = 0; i &lt; length; i++) {
809                     result[i] = result[i] / totalCount;
810                 }
811                 return result;
812             }
813         }
814 
<span class="line-modified">815         private long readCount(HotSpotMethodData data, int position, int i) {</span>
816             int offset;
817             long count;
818             offset = getCountOffset(i);
819             count = data.readUnsignedInt(position, offset);
820             return count;
821         }
822 
823         @Override
824         public int getExecutionCount(HotSpotMethodData data, int position) {
825             int arrayLength = getLength(data, position);
826             assert arrayLength &gt; 0 : &quot;switch must have at least the default case&quot;;
<span class="line-modified">827             assert arrayLength % state.multiBranchDataRowSizeInCells == 0 : &quot;array must have full rows&quot;;</span>
828 
<span class="line-modified">829             int length = arrayLength / state.multiBranchDataRowSizeInCells;</span>
830             long totalCount = 0;
831             for (int i = 0; i &lt; length; i++) {
832                 int offset = getCountOffset(i);
833                 totalCount += data.readUnsignedInt(position, offset);
834             }
835 
<span class="line-modified">836             return VMState.truncateLongToInt(totalCount);</span>
837         }
838 
<span class="line-modified">839         private int getCountOffset(int index) {</span>
<span class="line-modified">840             return state.multiBranchDataFirstCountOffset + index * state.multiBranchDataRowSize;</span>
841         }
842 
<span class="line-modified">843         private int getDisplacementOffset(int index) {</span>
<span class="line-modified">844             return state.multiBranchDataFirstDisplacementOffset + index * state.multiBranchDataRowSize;</span>
845         }
846 
847         @Override
848         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
<span class="line-modified">849             int entries = getLength(data, pos) / state.multiBranchDataRowSizeInCells;</span>
850             sb.append(format(&quot;entries(%d)&quot;, entries));
851             for (int i = 0; i &lt; entries; i++) {
852                 sb.append(format(&quot;%n  %d: count(%d) displacement(%d)&quot;, i, data.readUnsignedInt(pos, getCountOffset(i)), data.readUnsignedInt(pos, getDisplacementOffset(i))));
853             }
854             return sb;
855         }
856     }
857 


858     static class ArgInfoData extends ArrayData {
859 
<span class="line-modified">860         ArgInfoData(VMState state, int tag) {</span>
<span class="line-modified">861             super(state, tag, state.argInfoDataSize);</span>
862         }
863     }
864 
865     static class UnknownProfileData extends HotSpotMethodDataAccessor {
<span class="line-modified">866         UnknownProfileData(VMState state, int tag) {</span>
<span class="line-modified">867             super(state, tag, 0);</span>
868         }
869 
870         @Override
871         protected int getDynamicSize(HotSpotMethodData data, int position) {
872             assert staticSize == 0;
873             return HotSpotJVMCIRuntime.runtime().compilerToVm.methodDataProfileDataSize(data.metaspaceMethodData, position);
874         }
875 
876         @Override
877         public StringBuilder appendTo(StringBuilder sb, HotSpotMethodData data, int pos) {
878             sb.append(&quot;unknown profile data with tag: &quot; + tag);
879             return sb;
880         }
881     }
882 
883     public void setCompiledIRSize(int size) {
<span class="line-modified">884         UNSAFE.putInt(metaspaceMethodData + state.config.methodDataIRSizeOffset, size);</span>
885     }
886 
887     public int getCompiledIRSize() {
<span class="line-modified">888         return UNSAFE.getInt(metaspaceMethodData + state.config.methodDataIRSizeOffset);</span>




































889     }

890 }
</pre>
</td>
</tr>
</table>
<center><a href="HotSpotMethod.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotMethodDataAccessor.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
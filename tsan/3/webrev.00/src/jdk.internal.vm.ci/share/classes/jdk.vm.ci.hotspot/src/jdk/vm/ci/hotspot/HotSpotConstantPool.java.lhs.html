<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotConstantPool.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
 26 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 27 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
 28 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 29 
<a name="2" id="anc2"></a><span class="line-removed"> 30 import java.lang.invoke.MethodHandle;</span>
<span class="line-removed"> 31 </span>
 32 import jdk.vm.ci.common.JVMCIError;
<a name="3" id="anc3"></a>
 33 import jdk.vm.ci.meta.ConstantPool;
 34 import jdk.vm.ci.meta.JavaConstant;
 35 import jdk.vm.ci.meta.JavaField;
 36 import jdk.vm.ci.meta.JavaMethod;
 37 import jdk.vm.ci.meta.JavaType;
 38 import jdk.vm.ci.meta.ResolvedJavaMethod;
 39 import jdk.vm.ci.meta.ResolvedJavaType;
 40 import jdk.vm.ci.meta.Signature;
 41 import jdk.vm.ci.meta.UnresolvedJavaField;
 42 import jdk.vm.ci.meta.UnresolvedJavaMethod;
 43 import jdk.vm.ci.meta.UnresolvedJavaType;
 44 
 45 /**
 46  * Implementation of {@link ConstantPool} for HotSpot.
 47  */
<a name="4" id="anc4"></a><span class="line-modified"> 48 public final class HotSpotConstantPool implements ConstantPool, MetaspaceWrapperObject {</span>
 49 
 50     /**
 51      * Subset of JVM bytecode opcodes used by {@link HotSpotConstantPool}.
 52      */
 53     public static class Bytecodes {
 54         public static final int LDC = 18; // 0x12
 55         public static final int LDC_W = 19; // 0x13
 56         public static final int LDC2_W = 20; // 0x14
 57         public static final int GETSTATIC = 178; // 0xB2
 58         public static final int PUTSTATIC = 179; // 0xB3
 59         public static final int GETFIELD = 180; // 0xB4
 60         public static final int PUTFIELD = 181; // 0xB5
 61         public static final int INVOKEVIRTUAL = 182; // 0xB6
 62         public static final int INVOKESPECIAL = 183; // 0xB7
 63         public static final int INVOKESTATIC = 184; // 0xB8
 64         public static final int INVOKEINTERFACE = 185; // 0xB9
 65         public static final int INVOKEDYNAMIC = 186; // 0xBA
 66         public static final int NEW = 187; // 0xBB
 67         public static final int NEWARRAY = 188; // 0xBC
 68         public static final int ANEWARRAY = 189; // 0xBD
 69         public static final int CHECKCAST = 192; // 0xC0
 70         public static final int INSTANCEOF = 193; // 0xC1
 71         public static final int MULTIANEWARRAY = 197; // 0xC5
 72 
 73         static boolean isInvoke(int opcode) {
 74             switch (opcode) {
 75                 case INVOKEVIRTUAL:
 76                 case INVOKESPECIAL:
 77                 case INVOKESTATIC:
 78                 case INVOKEINTERFACE:
 79                 case INVOKEDYNAMIC:
 80                     return true;
 81                 default:
 82                     return false;
 83             }
 84         }
 85 
 86         /**
 87          * See: {@code Rewriter::maybe_rewrite_invokehandle}.
 88          */
 89         static boolean isInvokeHandleAlias(int opcode) {
 90             switch (opcode) {
 91                 case INVOKEVIRTUAL:
 92                 case INVOKESPECIAL:
 93                     return true;
 94                 default:
 95                     return false;
 96             }
 97         }
 98     }
 99 
<a name="5" id="anc5"></a><span class="line-modified">100     /**</span>
<span class="line-removed">101      * Enum of all {@code JVM_CONSTANT} constants used in the VM. This includes the public and</span>
<span class="line-removed">102      * internal ones.</span>
<span class="line-removed">103      */</span>
<span class="line-removed">104     private enum JVM_CONSTANT {</span>
<span class="line-removed">105         // @formatter:off</span>
<span class="line-removed">106         Utf8(config().jvmConstantUtf8),</span>
<span class="line-removed">107         Integer(config().jvmConstantInteger),</span>
<span class="line-removed">108         Long(config().jvmConstantLong),</span>
<span class="line-removed">109         Float(config().jvmConstantFloat),</span>
<span class="line-removed">110         Double(config().jvmConstantDouble),</span>
<span class="line-removed">111         Class(config().jvmConstantClass),</span>
<span class="line-removed">112         UnresolvedClass(config().jvmConstantUnresolvedClass),</span>
<span class="line-removed">113         UnresolvedClassInError(config().jvmConstantUnresolvedClassInError),</span>
<span class="line-removed">114         String(config().jvmConstantString),</span>
<span class="line-removed">115         Fieldref(config().jvmConstantFieldref),</span>
<span class="line-removed">116         MethodRef(config().jvmConstantMethodref),</span>
<span class="line-removed">117         InterfaceMethodref(config().jvmConstantInterfaceMethodref),</span>
<span class="line-removed">118         NameAndType(config().jvmConstantNameAndType),</span>
<span class="line-removed">119         MethodHandle(config().jvmConstantMethodHandle),</span>
<span class="line-removed">120         MethodHandleInError(config().jvmConstantMethodHandleInError),</span>
<span class="line-removed">121         MethodType(config().jvmConstantMethodType),</span>
<span class="line-removed">122         MethodTypeInError(config().jvmConstantMethodTypeInError),</span>
<span class="line-removed">123         InvokeDynamic(config().jvmConstantInvokeDynamic);</span>
<span class="line-removed">124         // @formatter:on</span>
<span class="line-removed">125 </span>
126         private final int tag;
<a name="6" id="anc6"></a>
127 
<a name="7" id="anc7"></a><span class="line-modified">128         private static final int ExternalMax = config().jvmConstantExternalMax;</span>
<span class="line-removed">129         private static final int InternalMin = config().jvmConstantInternalMin;</span>
<span class="line-removed">130         private static final int InternalMax = config().jvmConstantInternalMax;</span>
<span class="line-removed">131 </span>
<span class="line-removed">132         JVM_CONSTANT(int tag) {</span>
133             this.tag = tag;
<a name="8" id="anc8"></a>
134         }
135 
<a name="9" id="anc9"></a><span class="line-modified">136         /**</span>
<span class="line-modified">137          * Maps JVM_CONSTANT tags to {@link JVM_CONSTANT} values. Using a separate class for lazy</span>
<span class="line-modified">138          * initialization.</span>
<span class="line-modified">139          */</span>
<span class="line-modified">140         static class TagValueMap {</span>
<span class="line-removed">141             private static final JVM_CONSTANT[] table = new JVM_CONSTANT[ExternalMax + 1 + (InternalMax - InternalMin) + 1];</span>
142 
<a name="10" id="anc10"></a><span class="line-modified">143             static {</span>
<span class="line-modified">144                 assert InternalMin &gt; ExternalMax;</span>
<span class="line-modified">145                 for (JVM_CONSTANT e : values()) {</span>
<span class="line-modified">146                     table[indexOf(e.tag)] = e;</span>
<span class="line-modified">147                 }</span>
<span class="line-modified">148             }</span>




























149 
<a name="11" id="anc11"></a><span class="line-modified">150             private static int indexOf(int tag) {</span>
<span class="line-modified">151                 if (tag &gt;= InternalMin) {</span>
<span class="line-modified">152                     return tag - InternalMin + ExternalMax + 1;</span>
<span class="line-modified">153                 } else {</span>
<span class="line-modified">154                     assert tag &lt;= ExternalMax;</span>
<span class="line-removed">155                 }</span>
<span class="line-removed">156                 return tag;</span>
157             }
<a name="12" id="anc12"></a>

158 
<a name="13" id="anc13"></a><span class="line-modified">159             static JVM_CONSTANT get(int tag) {</span>
<span class="line-modified">160                 JVM_CONSTANT res = table[indexOf(tag)];</span>
<span class="line-modified">161                 if (res != null) {</span>
<span class="line-modified">162                     return res;</span>
<span class="line-removed">163                 }</span>
<span class="line-removed">164                 throw new JVMCIError(&quot;Unknown JVM_CONSTANT tag %s&quot;, tag);</span>
165             }
<a name="14" id="anc14"></a>
166         }
167 
<a name="15" id="anc15"></a><span class="line-modified">168         public static JVM_CONSTANT getEnum(int tag) {</span>
<span class="line-modified">169             return TagValueMap.get(tag);</span>











170         }
171     }
172 
173     private static class LookupTypeCacheElement {
174         int lastCpi = Integer.MIN_VALUE;
175         JavaType javaType;
176 
177         LookupTypeCacheElement(int lastCpi, JavaType javaType) {
178             super();
179             this.lastCpi = lastCpi;
180             this.javaType = javaType;
181         }
182     }
183 
184     /**
<a name="16" id="anc16"></a><span class="line-modified">185      * Reference to the C++ ConstantPool object.</span>

186      */
<a name="17" id="anc17"></a><span class="line-modified">187     private final long metaspaceConstantPool;</span>

188     private volatile LookupTypeCacheElement lastLookupType;
<a name="18" id="anc18"></a>
189 
190     /**
191      * Gets the JVMCI mirror from a HotSpot constant pool.The VM is responsible for ensuring that
192      * the ConstantPool is kept alive for the duration of this call and the
<a name="19" id="anc19"></a><span class="line-modified">193      * {@link HotSpotJVMCIMetaAccessContext} keeps it alive after that.</span>
194      *
195      * Called from the VM.
196      *
197      * @param metaspaceConstantPool a metaspace ConstantPool object
198      * @return the {@link HotSpotConstantPool} corresponding to {@code metaspaceConstantPool}
199      */
200     @SuppressWarnings(&quot;unused&quot;)
<a name="20" id="anc20"></a>
201     private static HotSpotConstantPool fromMetaspace(long metaspaceConstantPool) {
<a name="21" id="anc21"></a><span class="line-modified">202         HotSpotConstantPool cp = new HotSpotConstantPool(metaspaceConstantPool);</span>
<span class="line-removed">203         runtime().metaAccessContext.add(cp);</span>
<span class="line-removed">204         return cp;</span>
205     }
206 
<a name="22" id="anc22"></a><span class="line-modified">207     private HotSpotConstantPool(long metaspaceConstantPool) {</span>
<span class="line-modified">208         this.metaspaceConstantPool = metaspaceConstantPool;</span>


209     }
210 
211     /**
212      * Gets the holder for this constant pool as {@link HotSpotResolvedObjectTypeImpl}.
213      *
214      * @return holder for this constant pool
215      */
216     private HotSpotResolvedObjectType getHolder() {
217         return compilerToVM().getResolvedJavaType(this, config().constantPoolHolderOffset, false);
218     }
219 
220     /**
221      * Converts a raw index from the bytecodes to a constant pool cache index by adding a
222      * {@link HotSpotVMConfig#constantPoolCpCacheIndexTag constant}.
223      *
224      * @param rawIndex index from the bytecode
225      * @param opcode bytecode to convert the index for
226      * @return constant pool cache index
227      */
228     private static int rawIndexToConstantPoolCacheIndex(int rawIndex, int opcode) {
229         int index;
230         if (opcode == Bytecodes.INVOKEDYNAMIC) {
231             index = rawIndex;
232             // See: ConstantPool::is_invokedynamic_index
233             assert index &lt; 0 : &quot;not an invokedynamic constant pool index &quot; + index;
234         } else {
235             assert opcode == Bytecodes.GETFIELD || opcode == Bytecodes.PUTFIELD || opcode == Bytecodes.GETSTATIC || opcode == Bytecodes.PUTSTATIC || opcode == Bytecodes.INVOKEINTERFACE ||
236                             opcode == Bytecodes.INVOKEVIRTUAL || opcode == Bytecodes.INVOKESPECIAL || opcode == Bytecodes.INVOKESTATIC : &quot;unexpected invoke opcode &quot; + opcode;
237             index = rawIndex + config().constantPoolCpCacheIndexTag;
238         }
239         return index;
240     }
241 
242     /**
243      * Decode a constant pool cache index to a constant pool index.
244      *
245      * See {@code ConstantPool::decode_cpcache_index}.
246      *
247      * @param index constant pool cache index
248      * @return decoded index
249      */
250     private static int decodeConstantPoolCacheIndex(int index) {
251         if (isInvokedynamicIndex(index)) {
252             return decodeInvokedynamicIndex(index);
253         } else {
254             return index - config().constantPoolCpCacheIndexTag;
255         }
256     }
257 
258     /**
259      * See {@code ConstantPool::is_invokedynamic_index}.
260      */
261     private static boolean isInvokedynamicIndex(int index) {
262         return index &lt; 0;
263     }
264 
265     /**
266      * See {@code ConstantPool::decode_invokedynamic_index}.
267      */
268     private static int decodeInvokedynamicIndex(int i) {
269         assert isInvokedynamicIndex(i) : i;
270         return ~i;
271     }
272 
273     long getMetaspaceConstantPool() {
<a name="23" id="anc23"></a><span class="line-modified">274         return metaspaceConstantPool;</span>
275     }
276 
277     @Override
<a name="24" id="anc24"></a><span class="line-modified">278     public long getMetaspacePointer() {</span>
<span class="line-modified">279         return getMetaspaceConstantPool();</span>
280     }
281 
282     /**
283      * Gets the constant pool tag at index {@code index}.
284      *
285      * @param index constant pool index
286      * @return constant pool tag
287      */
<a name="25" id="anc25"></a><span class="line-modified">288     private JVM_CONSTANT getTagAt(int index) {</span>
289         assert checkBounds(index);
290         HotSpotVMConfig config = config();
291         final long metaspaceConstantPoolTags = UNSAFE.getAddress(getMetaspaceConstantPool() + config.constantPoolTagsOffset);
292         final int tag = UNSAFE.getByteVolatile(null, metaspaceConstantPoolTags + config.arrayU1DataOffset + index);
293         if (tag == 0) {
294             return null;
295         }
<a name="26" id="anc26"></a><span class="line-modified">296         return JVM_CONSTANT.getEnum(tag);</span>
297     }
298 
299     /**
300      * Gets the constant pool entry at index {@code index}.
301      *
302      * @param index constant pool index
303      * @return constant pool entry
304      */
305     long getEntryAt(int index) {
306         assert checkBounds(index);
307         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
308         return UNSAFE.getAddress(getMetaspaceConstantPool() + config().constantPoolSize + offset);
309     }
310 
311     /**
312      * Gets the integer constant pool entry at index {@code index}.
313      *
314      * @param index constant pool index
315      * @return integer constant pool entry at index
316      */
317     private int getIntAt(int index) {
<a name="27" id="anc27"></a><span class="line-modified">318         assert checkTag(index, JVM_CONSTANT.Integer);</span>
319         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
320         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);
321     }
322 
323     /**
324      * Gets the long constant pool entry at index {@code index}.
325      *
326      * @param index constant pool index
327      * @return long constant pool entry
328      */
329     private long getLongAt(int index) {
<a name="28" id="anc28"></a><span class="line-modified">330         assert checkTag(index, JVM_CONSTANT.Long);</span>
331         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
332         return UNSAFE.getLong(getMetaspaceConstantPool() + config().constantPoolSize + offset);
333     }
334 
335     /**
336      * Gets the float constant pool entry at index {@code index}.
337      *
338      * @param index constant pool index
339      * @return float constant pool entry
340      */
341     private float getFloatAt(int index) {
<a name="29" id="anc29"></a><span class="line-modified">342         assert checkTag(index, JVM_CONSTANT.Float);</span>
343         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
344         return UNSAFE.getFloat(getMetaspaceConstantPool() + config().constantPoolSize + offset);
345     }
346 
347     /**
348      * Gets the double constant pool entry at index {@code index}.
349      *
350      * @param index constant pool index
351      * @return float constant pool entry
352      */
353     private double getDoubleAt(int index) {
<a name="30" id="anc30"></a><span class="line-modified">354         assert checkTag(index, JVM_CONSTANT.Double);</span>
355         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
356         return UNSAFE.getDouble(getMetaspaceConstantPool() + config().constantPoolSize + offset);
357     }
358 
359     /**
360      * Gets the {@code JVM_CONSTANT_NameAndType} constant pool entry at index {@code index}.
361      *
362      * @param index constant pool index
363      * @return {@code JVM_CONSTANT_NameAndType} constant pool entry
364      */
365     private int getNameAndTypeAt(int index) {
<a name="31" id="anc31"></a><span class="line-modified">366         assert checkTag(index, JVM_CONSTANT.NameAndType);</span>
367         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
368         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);
369     }
370 
371     /**
372      * Gets the {@code JVM_CONSTANT_NameAndType} reference index constant pool entry at index
373      * {@code index}.
374      *
375      * @param index constant pool index
376      * @return {@code JVM_CONSTANT_NameAndType} reference constant pool entry
377      */
378     private int getNameAndTypeRefIndexAt(int index) {
379         return compilerToVM().lookupNameAndTypeRefIndexInPool(this, index);
380     }
381 
382     /**
383      * Gets the name of a {@code JVM_CONSTANT_NameAndType} constant pool entry referenced by another
384      * entry denoted by {@code which}.
385      *
386      * @param which constant pool index or constant pool cache index
387      * @return name as {@link String}
388      */
389     private String getNameOf(int which) {
390         return compilerToVM().lookupNameInPool(this, which);
391     }
392 
393     /**
394      * Gets the name reference index of a {@code JVM_CONSTANT_NameAndType} constant pool entry at
395      * index {@code index}.
396      *
397      * @param index constant pool index
398      * @return name reference index
399      */
400     private int getNameRefIndexAt(int index) {
401         final int refIndex = getNameAndTypeAt(index);
402         // name ref index is in the low 16-bits.
403         return refIndex &amp; 0xFFFF;
404     }
405 
406     /**
407      * Gets the signature of a {@code JVM_CONSTANT_NameAndType} constant pool entry referenced by
408      * another entry denoted by {@code which}.
409      *
410      * @param which constant pool index or constant pool cache index
411      * @return signature as {@link String}
412      */
413     private String getSignatureOf(int which) {
414         return compilerToVM().lookupSignatureInPool(this, which);
415     }
416 
417     /**
418      * Gets the signature reference index of a {@code JVM_CONSTANT_NameAndType} constant pool entry
419      * at index {@code index}.
420      *
421      * @param index constant pool index
422      * @return signature reference index
423      */
424     private int getSignatureRefIndexAt(int index) {
425         final int refIndex = getNameAndTypeAt(index);
426         // signature ref index is in the high 16-bits.
427         return refIndex &gt;&gt;&gt; 16;
428     }
429 
430     /**
431      * Gets the klass reference index constant pool entry at index {@code index}.
432      *
433      * @param index constant pool index
434      * @return klass reference index
435      */
436     private int getKlassRefIndexAt(int index) {
437         return compilerToVM().lookupKlassRefIndexInPool(this, index);
438     }
439 
440     /**
441      * Gets the uncached klass reference index constant pool entry at index {@code index}. See:
442      * {@code ConstantPool::uncached_klass_ref_index_at}.
443      *
444      * @param index constant pool index
445      * @return klass reference index
446      */
447     private int getUncachedKlassRefIndexAt(int index) {
448         assert checkTagIsFieldOrMethod(index);
449         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
450         final int refIndex = UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);
451         // klass ref index is in the low 16-bits.
452         return refIndex &amp; 0xFFFF;
453     }
454 
455     /**
456      * Checks that the constant pool index {@code index} is in the bounds of the constant pool.
457      *
458      * @param index constant pool index
459      * @throws AssertionError if the check fails
460      */
461     private boolean checkBounds(int index) {
462         assert 0 &lt;= index &amp;&amp; index &lt; length() : &quot;index &quot; + index + &quot; not between 0 and &quot; + length();
463         return true;
464     }
465 
466     /**
467      * Checks that the constant pool tag at index {@code index} is equal to {@code tag}.
468      *
469      * @param index constant pool index
470      * @param tag expected tag
471      * @throws AssertionError if the check fails
472      */
<a name="32" id="anc32"></a><span class="line-modified">473     private boolean checkTag(int index, JVM_CONSTANT tag) {</span>
<span class="line-modified">474         final JVM_CONSTANT tagAt = getTagAt(index);</span>
475         assert tagAt == tag : &quot;constant pool tag at index &quot; + index + &quot; is &quot; + tagAt + &quot; but expected &quot; + tag;
476         return true;
477     }
478 
479     /**
<a name="33" id="anc33"></a><span class="line-modified">480      * Asserts that the constant pool tag at index {@code index} is a {@link JVM_CONSTANT#Fieldref},</span>
<span class="line-modified">481      * or a {@link JVM_CONSTANT#MethodRef}, or a {@link JVM_CONSTANT#InterfaceMethodref}.</span>

482      *
483      * @param index constant pool index
484      * @throws AssertionError if the check fails
485      */
486     private boolean checkTagIsFieldOrMethod(int index) {
<a name="34" id="anc34"></a><span class="line-modified">487         final JVM_CONSTANT tagAt = getTagAt(index);</span>
<span class="line-modified">488         assert tagAt == JVM_CONSTANT.Fieldref || tagAt == JVM_CONSTANT.MethodRef || tagAt == JVM_CONSTANT.InterfaceMethodref : tagAt;</span>
489         return true;
490     }
491 
492     @Override
493     public int length() {
494         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolLengthOffset);
495     }
496 
497     public boolean hasDynamicConstant() {
498         return (flags() &amp; config().constantPoolHasDynamicConstant) != 0;
499     }
500 
501     private int flags() {
502         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolFlagsOffset);
503     }
504 
505     @Override
506     public Object lookupConstant(int cpi) {
507         assert cpi != 0;
<a name="35" id="anc35"></a><span class="line-modified">508         final JVM_CONSTANT tag = getTagAt(cpi);</span>
<span class="line-modified">509         switch (tag) {</span>
<span class="line-modified">510             case Integer:</span>
511                 return JavaConstant.forInt(getIntAt(cpi));
<a name="36" id="anc36"></a><span class="line-modified">512             case Long:</span>
513                 return JavaConstant.forLong(getLongAt(cpi));
<a name="37" id="anc37"></a><span class="line-modified">514             case Float:</span>
515                 return JavaConstant.forFloat(getFloatAt(cpi));
<a name="38" id="anc38"></a><span class="line-modified">516             case Double:</span>
517                 return JavaConstant.forDouble(getDoubleAt(cpi));
<a name="39" id="anc39"></a><span class="line-modified">518             case Class:</span>
<span class="line-modified">519             case UnresolvedClass:</span>
<span class="line-modified">520             case UnresolvedClassInError:</span>
521                 final int opcode = -1;  // opcode is not used
522                 return lookupType(cpi, opcode);
<a name="40" id="anc40"></a><span class="line-modified">523             case String:</span>
524                 /*
525                  * Normally, we would expect a String here, but unsafe anonymous classes can have
526                  * &quot;pseudo strings&quot; (arbitrary live objects) patched into a String entry. Such
527                  * entries do not have a symbol in the constant pool slot.
528                  */
<a name="41" id="anc41"></a><span class="line-modified">529                 Object string = compilerToVM().resolvePossiblyCachedConstantInPool(this, cpi);</span>
<span class="line-modified">530                 return HotSpotObjectConstantImpl.forObject(string);</span>
<span class="line-modified">531             case MethodHandle:</span>
<span class="line-modified">532             case MethodHandleInError:</span>
<span class="line-modified">533             case MethodType:</span>
<span class="line-modified">534             case MethodTypeInError:</span>
<span class="line-removed">535                 Object obj = compilerToVM().resolveConstantInPool(this, cpi);</span>
<span class="line-removed">536                 return HotSpotObjectConstantImpl.forObject(obj);</span>
537             default:
538                 throw new JVMCIError(&quot;Unknown constant pool tag %s&quot;, tag);
539         }
540     }
541 
542     @Override
543     public String lookupUtf8(int cpi) {
<a name="42" id="anc42"></a><span class="line-modified">544         assert checkTag(cpi, JVM_CONSTANT.Utf8);</span>
545         return compilerToVM().getSymbol(getEntryAt(cpi));
546     }
547 
548     @Override
549     public Signature lookupSignature(int cpi) {
550         return new HotSpotSignature(runtime(), lookupUtf8(cpi));
551     }
552 
553     @Override
554     public JavaConstant lookupAppendix(int cpi, int opcode) {
555         assert Bytecodes.isInvoke(opcode);
556         final int index = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<a name="43" id="anc43"></a><span class="line-modified">557         Object appendix = compilerToVM().lookupAppendixInPool(this, index);</span>
<span class="line-removed">558         if (appendix == null) {</span>
<span class="line-removed">559             return null;</span>
<span class="line-removed">560         } else {</span>
<span class="line-removed">561             return HotSpotObjectConstantImpl.forObject(appendix);</span>
<span class="line-removed">562         }</span>
563     }
564 
565     /**
566      * Gets a {@link JavaType} corresponding a given resolved or unresolved type.
567      *
568      * @param type either a ResolvedJavaType or a String naming a unresolved type.
569      */
570     private static JavaType getJavaType(final Object type) {
571         if (type instanceof String) {
572             String name = (String) type;
573             return UnresolvedJavaType.create(&quot;L&quot; + name + &quot;;&quot;);
574         } else {
575             return (JavaType) type;
576         }
577     }
578 
579     @Override
580     public JavaMethod lookupMethod(int cpi, int opcode) {
581         final int index = rawIndexToConstantPoolCacheIndex(cpi, opcode);
582         final HotSpotResolvedJavaMethod method = compilerToVM().lookupMethodInPool(this, index, (byte) opcode);
583         if (method != null) {
584             return method;
585         } else {
586             // Get the method&#39;s name and signature.
587             String name = getNameOf(index);
588             HotSpotSignature signature = new HotSpotSignature(runtime(), getSignatureOf(index));
589             if (opcode == Bytecodes.INVOKEDYNAMIC) {
<a name="44" id="anc44"></a><span class="line-modified">590                 HotSpotResolvedObjectType holder = HotSpotResolvedObjectTypeImpl.fromObjectClass(MethodHandle.class);</span>
591                 return new UnresolvedJavaMethod(name, signature, holder);
592             } else {
593                 final int klassIndex = getKlassRefIndexAt(index);
594                 final Object type = compilerToVM().lookupKlassInPool(this, klassIndex);
595                 JavaType holder = getJavaType(type);
596                 return new UnresolvedJavaMethod(name, signature, holder);
597             }
598         }
599     }
600 
601     @Override
602     public JavaType lookupType(int cpi, int opcode) {
603         final LookupTypeCacheElement elem = this.lastLookupType;
604         if (elem != null &amp;&amp; elem.lastCpi == cpi) {
605             return elem.javaType;
606         } else {
607             final Object type = compilerToVM().lookupKlassInPool(this, cpi);
608             JavaType result = getJavaType(type);
609             if (result instanceof ResolvedJavaType) {
610                 this.lastLookupType = new LookupTypeCacheElement(cpi, result);
611             }
612             return result;
613         }
614     }
615 
616     @Override
617     public JavaField lookupField(int cpi, ResolvedJavaMethod method, int opcode) {
618         final int index = rawIndexToConstantPoolCacheIndex(cpi, opcode);
619         final int nameAndTypeIndex = getNameAndTypeRefIndexAt(index);
620         final int typeIndex = getSignatureRefIndexAt(nameAndTypeIndex);
621         String typeName = lookupUtf8(typeIndex);
622         JavaType type = runtime().lookupType(typeName, getHolder(), false);
623 
624         final int holderIndex = getKlassRefIndexAt(index);
625         JavaType holder = lookupType(holderIndex, opcode);
626 
627         if (holder instanceof HotSpotResolvedObjectTypeImpl) {
628             int[] info = new int[3];
629             HotSpotResolvedObjectTypeImpl resolvedHolder;
630             try {
631                 resolvedHolder = compilerToVM().resolveFieldInPool(this, index, (HotSpotResolvedJavaMethodImpl) method, (byte) opcode, info);
632             } catch (Throwable t) {
633                 /*
634                  * If there was an exception resolving the field we give up and return an unresolved
635                  * field.
636                  */
637                 return new UnresolvedJavaField(holder, lookupUtf8(getNameRefIndexAt(nameAndTypeIndex)), type);
638             }
639             final int flags = info[0];
640             final int offset = info[1];
641             final int fieldIndex = info[2];
642             HotSpotResolvedJavaField result = resolvedHolder.createField(type, offset, flags, fieldIndex);
643             return result;
644         } else {
645             return new UnresolvedJavaField(holder, lookupUtf8(getNameRefIndexAt(nameAndTypeIndex)), type);
646         }
647     }
648 
649     /**
650      * Converts a raw index from the bytecodes to a constant pool index (not a cache index).
651      *
652      * @param rawIndex index from the bytecode
653      *
654      * @param opcode bytecode to convert the index for
655      *
656      * @return constant pool index
657      */
658     public int rawIndexToConstantPoolIndex(int rawIndex, int opcode) {
659         int index;
660         if (isInvokedynamicIndex(rawIndex)) {
661             assert opcode == Bytecodes.INVOKEDYNAMIC;
662             index = decodeInvokedynamicIndex(rawIndex) + config().constantPoolCpCacheIndexTag;
663         } else {
664             assert opcode != Bytecodes.INVOKEDYNAMIC;
665             index = rawIndexToConstantPoolCacheIndex(rawIndex, opcode);
666         }
667         return compilerToVM().constantPoolRemapInstructionOperandFromCache(this, index);
668     }
669 
670     @Override
671     public void loadReferencedType(int cpi, int opcode) {
672         loadReferencedType(cpi, opcode, true /* initialize */);
673     }
674 
675     @SuppressWarnings(&quot;fallthrough&quot;)
676     public void loadReferencedType(int cpi, int opcode, boolean initialize) {
677         int index;
678         switch (opcode) {
679             case Bytecodes.CHECKCAST:
680             case Bytecodes.INSTANCEOF:
681             case Bytecodes.NEW:
682             case Bytecodes.ANEWARRAY:
683             case Bytecodes.MULTIANEWARRAY:
684             case Bytecodes.LDC:
685             case Bytecodes.LDC_W:
686             case Bytecodes.LDC2_W:
687                 index = cpi;
688                 break;
689             case Bytecodes.INVOKEDYNAMIC: {
690                 // invokedynamic instructions point to a constant pool cache entry.
691                 index = decodeConstantPoolCacheIndex(cpi) + config().constantPoolCpCacheIndexTag;
692                 index = compilerToVM().constantPoolRemapInstructionOperandFromCache(this, index);
693                 break;
694             }
695             case Bytecodes.GETSTATIC:
696             case Bytecodes.PUTSTATIC:
697             case Bytecodes.GETFIELD:
698             case Bytecodes.PUTFIELD:
699             case Bytecodes.INVOKEVIRTUAL:
700             case Bytecodes.INVOKESPECIAL:
701             case Bytecodes.INVOKESTATIC:
702             case Bytecodes.INVOKEINTERFACE: {
703                 // invoke and field instructions point to a constant pool cache entry.
704                 index = rawIndexToConstantPoolCacheIndex(cpi, opcode);
705                 index = compilerToVM().constantPoolRemapInstructionOperandFromCache(this, index);
706                 break;
707             }
708             default:
709                 throw JVMCIError.shouldNotReachHere(&quot;Unexpected opcode &quot; + opcode);
710         }
711 
<a name="45" id="anc45"></a><span class="line-modified">712         final JVM_CONSTANT tag = getTagAt(index);</span>
713         if (tag == null) {
<a name="46" id="anc46"></a><span class="line-modified">714             assert getTagAt(index - 1) == JVM_CONSTANT.Double || getTagAt(index - 1) == JVM_CONSTANT.Long;</span>
715             return;
716         }
<a name="47" id="anc47"></a><span class="line-modified">717         switch (tag) {</span>
<span class="line-modified">718             case MethodRef:</span>
<span class="line-modified">719             case Fieldref:</span>
<span class="line-modified">720             case InterfaceMethodref:</span>
721                 index = getUncachedKlassRefIndexAt(index);
722                 // Read the tag only once because it could change between multiple reads.
<a name="48" id="anc48"></a><span class="line-modified">723                 final JVM_CONSTANT klassTag = getTagAt(index);</span>
<span class="line-modified">724                 assert klassTag == JVM_CONSTANT.Class || klassTag == JVM_CONSTANT.UnresolvedClass || klassTag == JVM_CONSTANT.UnresolvedClassInError : klassTag;</span>
725                 // fall through
<a name="49" id="anc49"></a><span class="line-modified">726             case Class:</span>
<span class="line-modified">727             case UnresolvedClass:</span>
<span class="line-modified">728             case UnresolvedClassInError:</span>
729                 final HotSpotResolvedObjectTypeImpl type = compilerToVM().resolveTypeInPool(this, index);
<a name="50" id="anc50"></a><span class="line-modified">730                 if (initialize) {</span>
<span class="line-modified">731                     Class&lt;?&gt; klass = type.mirror();</span>
<span class="line-removed">732                     if (!klass.isPrimitive() &amp;&amp; !klass.isArray()) {</span>
<span class="line-removed">733                         UNSAFE.ensureClassInitialized(klass);</span>
<span class="line-removed">734                     }</span>
735                 }
<a name="51" id="anc51"></a><span class="line-modified">736                 if (tag == JVM_CONSTANT.MethodRef) {</span>
737                     if (Bytecodes.isInvokeHandleAlias(opcode) &amp;&amp; isSignaturePolymorphicHolder(type)) {
738                         final int methodRefCacheIndex = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<a name="52" id="anc52"></a><span class="line-modified">739                         assert checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), JVM_CONSTANT.MethodRef);</span>
740                         compilerToVM().resolveInvokeHandleInPool(this, methodRefCacheIndex);
741                     }
742                 }
743 
744                 break;
<a name="53" id="anc53"></a><span class="line-modified">745             case InvokeDynamic:</span>
746                 if (isInvokedynamicIndex(cpi)) {
747                     compilerToVM().resolveInvokeDynamicInPool(this, cpi);
748                 }
749                 break;
750             default:
751                 // nothing
752                 break;
753         }
754 
755     }
756 
757     // Lazily initialized.
758     private static String[] signaturePolymorphicHolders;
759 
760     /**
761      * Determines if {@code type} contains signature polymorphic methods.
762      */
763     @SuppressFBWarnings(value = &quot;LI_LAZY_INIT_STATIC&quot;, justification = &quot;signaturePolymorphicHolders is a cache, not a singleton that must be constructed exactly once&quot; +
764                     &quot;and compiler re-ordering is not an issue due to the VM call&quot;)
765     static boolean isSignaturePolymorphicHolder(final ResolvedJavaType type) {
766         String name = type.getName();
767         if (signaturePolymorphicHolders == null) {
768             signaturePolymorphicHolders = compilerToVM().getSignaturePolymorphicHolders();
769         }
770         for (String holder : signaturePolymorphicHolders) {
771             if (name.equals(holder)) {
772                 return true;
773             }
774         }
775         return false;
776     }
777 
778     /**
779      * Check for a resolved dynamic adapter method at the specified index, resulting from either a
780      * resolved invokedynamic or invokevirtual on a signature polymorphic MethodHandle method
781      * (HotSpot invokehandle).
782      *
783      * @param cpi the constant pool index
784      * @param opcode the opcode of the instruction for which the lookup is being performed
785      * @return {@code true} if a signature polymorphic method reference was found, otherwise
786      *         {@code false}
787      */
788     public boolean isResolvedDynamicInvoke(int cpi, int opcode) {
789         if (Bytecodes.isInvokeHandleAlias(opcode)) {
790             final int methodRefCacheIndex = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<a name="54" id="anc54"></a><span class="line-modified">791             assert checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), JVM_CONSTANT.MethodRef);</span>
792             int op = compilerToVM().isResolvedInvokeHandleInPool(this, methodRefCacheIndex);
793             return op == opcode;
794         }
795         return false;
796     }
797 
798     @Override
799     public String toString() {
800         HotSpotResolvedObjectType holder = getHolder();
801         return &quot;HotSpotConstantPool&lt;&quot; + holder.toJavaName() + &quot;&gt;&quot;;
802     }
803 }
<a name="55" id="anc55"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="55" type="hidden" />
</body>
</html>
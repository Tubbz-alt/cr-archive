<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotNmethod.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotMethodHandleAccessProvider.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotObjectConstantImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotNmethod.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,67 ***</span>
   * questions.
   */
  package jdk.vm.ci.hotspot;
  
  import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  import jdk.vm.ci.code.InstalledCode;
  import jdk.vm.ci.code.InvalidInstalledCodeException;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.JavaType;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  
  /**
<span class="line-modified">!  * Implementation of {@link InstalledCode} for code installed as an nmethod.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * When a {@link HotSpotNmethod} dies, it triggers unloading of the nmethod unless</span>
<span class="line-removed">-  * {@link #isDefault() == true}.</span>
   */
  public class HotSpotNmethod extends HotSpotInstalledCode {
  
      /**
<span class="line-modified">!      * This (indirect) Method* reference is safe since class redefinition preserves all methods</span>
<span class="line-modified">!      * associated with nmethods in the code cache.</span>
       */
<span class="line-modified">!     private final HotSpotResolvedJavaMethod method;</span>
  
      private final boolean isDefault;
  
<span class="line-modified">!     public HotSpotNmethod(HotSpotResolvedJavaMethod method, String name, boolean isDefault) {</span>
          super(name);
          this.method = method;
          this.isDefault = isDefault;
      }
  
      /**
       * Determines if the nmethod associated with this object is the compiled entry point for
<span class="line-modified">!      * {@link #getMethod()}. If {@code false}, then the nmethod is unloaded when the VM determines</span>
<span class="line-removed">-      * this object has died.</span>
       */
      public boolean isDefault() {
          return isDefault;
      }
  
      public ResolvedJavaMethod getMethod() {
          return method;
      }
  
      @Override
      public void invalidate() {
<span class="line-modified">!         compilerToVM().invalidateInstalledCode(this);</span>
      }
  
      @Override
<span class="line-modified">!     public String toString() {</span>
<span class="line-modified">!         return String.format(&quot;InstalledNmethod[method=%s, codeBlob=0x%x, isDefault=%b, name=%s]&quot;, method, getAddress(), isDefault, name);</span>
      }
  
<span class="line-modified">!     protected boolean checkThreeObjectArgs() {</span>
<span class="line-modified">!         assert method.getSignature().getParameterCount(!method.isStatic()) == 3;</span>
<span class="line-modified">!         assert method.getSignature().getParameterKind(0) == JavaKind.Object;</span>
<span class="line-modified">!         assert method.getSignature().getParameterKind(1) == JavaKind.Object;</span>
<span class="line-modified">!         assert !method.isStatic() || method.getSignature().getParameterKind(2) == JavaKind.Object;</span>
<span class="line-modified">!         return true;</span>
      }
  
      private boolean checkArgs(Object... args) {
          JavaType[] sig = method.toParameterTypes();
          assert args.length == sig.length : method.format(&quot;%H.%n(%p): expected &quot;) + sig.length + &quot; args, got &quot; + args.length;
<span class="line-new-header">--- 21,117 ---</span>
   * questions.
   */
  package jdk.vm.ci.hotspot;
  
  import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
<span class="line-added">+ import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;</span>
<span class="line-added">+ </span>
  import jdk.vm.ci.code.InstalledCode;
  import jdk.vm.ci.code.InvalidInstalledCodeException;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.JavaType;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  
  /**
<span class="line-modified">!  * Implementation of {@link InstalledCode} for code installed as an {@code nmethod}. The address of</span>
<span class="line-modified">!  * the {@code nmethod} is stored in {@link InstalledCode#address} and the value of</span>
<span class="line-modified">!  * {@code nmethod::verified_entry_point()} is in {@link InstalledCode#entryPoint}.</span>
   */
  public class HotSpotNmethod extends HotSpotInstalledCode {
  
      /**
<span class="line-modified">!      * This (indirect) {@code Method*} reference is safe since class redefinition preserves all</span>
<span class="line-modified">!      * methods associated with nmethods in the code cache.</span>
       */
<span class="line-modified">!     private final HotSpotResolvedJavaMethodImpl method;</span>
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Specifies whether the {@code nmethod} associated with this object is the code executed by</span>
<span class="line-added">+      * default HotSpot linkage when a normal Java call to {@link #method} is made. That is, does</span>
<span class="line-added">+      * {@code this.method.metadataHandle-&gt;_code} == {@code this.address}. If not, then the</span>
<span class="line-added">+      * {@code nmethod} can only be invoked via a reference to this object. An example of this is the</span>
<span class="line-added">+      * trampoline mechanism used by Truffle: https://goo.gl/LX88rZ.</span>
<span class="line-added">+      */</span>
      private final boolean isDefault;
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Determines whether this object is in the oops table of the nmethod.</span>
<span class="line-added">+      * &lt;p&gt;</span>
<span class="line-added">+      * If this object is in the oops table, the VM uses the oops table entry to update this object&#39;s</span>
<span class="line-added">+      * {@link #address} and {@link #entryPoint} fields when the state of the nmethod changes. The</span>
<span class="line-added">+      * nmethod will be unloadable when this object dies.</span>
<span class="line-added">+      * &lt;p&gt;</span>
<span class="line-added">+      * Otherwise, the nmethod&#39;s unloadability is not changed when this object dies.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     boolean inOopsTable() {</span>
<span class="line-added">+         return compileIdSnapshot != 0;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * If this field is 0, this object is in the oops table of the nmethod. Otherwise, the value of</span>
<span class="line-added">+      * the field records the nmethod&#39;s compile identifier. This value is used to confirm an entry in</span>
<span class="line-added">+      * the code cache retrieved by {@link #address} is indeed the nmethod represented by this</span>
<span class="line-added">+      * object.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @see #inOopsTable</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private final long compileIdSnapshot;</span>
<span class="line-added">+ </span>
<span class="line-added">+     HotSpotNmethod(HotSpotResolvedJavaMethodImpl method, String name, boolean isDefault, long compileId) {</span>
          super(name);
          this.method = method;
          this.isDefault = isDefault;
<span class="line-added">+         boolean inOopsTable = !IS_IN_NATIVE_IMAGE &amp;&amp; !isDefault;</span>
<span class="line-added">+         this.compileIdSnapshot = inOopsTable ? 0L : compileId;</span>
<span class="line-added">+         assert inOopsTable || compileId != 0L : this;</span>
      }
  
      /**
       * Determines if the nmethod associated with this object is the compiled entry point for
<span class="line-modified">!      * {@link #getMethod()}.</span>
       */
      public boolean isDefault() {
          return isDefault;
      }
  
<span class="line-added">+     @Override</span>
<span class="line-added">+     public boolean isValid() {</span>
<span class="line-added">+         if (compileIdSnapshot != 0L) {</span>
<span class="line-added">+             compilerToVM().updateHotSpotNmethod(this);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return super.isValid();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public ResolvedJavaMethod getMethod() {
          return method;
      }
  
      @Override
      public void invalidate() {
<span class="line-modified">!         compilerToVM().invalidateHotSpotNmethod(this);</span>
      }
  
      @Override
<span class="line-modified">!     public long getAddress() {</span>
<span class="line-modified">!         if (compileIdSnapshot != 0L) {</span>
<span class="line-added">+             compilerToVM().updateHotSpotNmethod(this);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return super.getAddress();</span>
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public long getEntryPoint() {</span>
<span class="line-modified">!         if (compileIdSnapshot != 0L) {</span>
<span class="line-modified">!             return 0;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return super.getEntryPoint();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public String toString() {</span>
<span class="line-added">+         return String.format(&quot;HotSpotNmethod[method=%s, codeBlob=0x%x, isDefault=%b, name=%s, inOopsTable=%s]&quot;,</span>
<span class="line-added">+                         method, getAddress(), isDefault, name, inOopsTable());</span>
      }
  
      private boolean checkArgs(Object... args) {
          JavaType[] sig = method.toParameterTypes();
          assert args.length == sig.length : method.format(&quot;%H.%n(%p): expected &quot;) + sig.length + &quot; args, got &quot; + args.length;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,12 ***</span>
          return true;
      }
  
      @Override
      public Object executeVarargs(Object... args) throws InvalidInstalledCodeException {
          assert checkArgs(args);
<span class="line-modified">!         return compilerToVM().executeInstalledCode(args, this);</span>
      }
  
      @Override
      public long getStart() {
          return isValid() ? super.getStart() : 0;
<span class="line-new-header">--- 146,15 ---</span>
          return true;
      }
  
      @Override
      public Object executeVarargs(Object... args) throws InvalidInstalledCodeException {
<span class="line-added">+         if (IS_IN_NATIVE_IMAGE) {</span>
<span class="line-added">+             throw new HotSpotJVMCIUnsupportedOperationError(&quot;Cannot execute nmethod via mirror in native image&quot;);</span>
<span class="line-added">+         }</span>
          assert checkArgs(args);
<span class="line-modified">!         return compilerToVM().executeHotSpotNmethod(args, this);</span>
      }
  
      @Override
      public long getStart() {
          return isValid() ? super.getStart() : 0;
</pre>
<center><a href="HotSpotMethodHandleAccessProvider.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotObjectConstantImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotResolvedJavaType.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotResolvedPrimitiveType.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotConstantPool.isSignaturePolymorphicHolder;
  28 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  29 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmClassModifiers;
  30 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  31 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  32 
  33 import java.lang.annotation.Annotation;
<span class="line-removed">  34 import java.lang.reflect.Array;</span>
<span class="line-removed">  35 import java.lang.reflect.Constructor;</span>
  36 import java.lang.reflect.Field;
<span class="line-removed">  37 import java.lang.reflect.Method;</span>
  38 import java.lang.reflect.Modifier;
  39 import java.nio.ByteOrder;


  40 import java.util.HashMap;
  41 
  42 import jdk.vm.ci.common.JVMCIError;
  43 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  44 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  45 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  46 import jdk.vm.ci.meta.Assumptions.LeafType;
  47 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  48 import jdk.vm.ci.meta.Constant;
  49 import jdk.vm.ci.meta.JavaConstant;
  50 import jdk.vm.ci.meta.JavaKind;
  51 import jdk.vm.ci.meta.JavaType;
  52 import jdk.vm.ci.meta.ResolvedJavaField;
  53 import jdk.vm.ci.meta.ResolvedJavaMethod;
  54 import jdk.vm.ci.meta.ResolvedJavaType;
  55 import jdk.vm.ci.meta.UnresolvedJavaField;
  56 import jdk.vm.ci.meta.UnresolvedJavaType;
  57 
  58 /**
<span class="line-modified">  59  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes.</span>


  60  */
<span class="line-modified">  61 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceWrapperObject {</span>
  62 
  63     private static final HotSpotResolvedJavaField[] NO_FIELDS = new HotSpotResolvedJavaField[0];
  64     private static final int METHOD_CACHE_ARRAY_CAPACITY = 8;

  65 
  66     /**
  67      * The Java class this type represents.
  68      */
<span class="line-modified">  69     private final Class&lt;?&gt; javaClass;</span>

  70     private HotSpotResolvedJavaMethodImpl[] methodCacheArray;
  71     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCacheHashMap;
<span class="line-modified">  72     private HotSpotResolvedJavaField[] instanceFields;</span>
<span class="line-modified">  73     private HotSpotResolvedObjectTypeImpl[] interfaces;</span>
  74     private HotSpotConstantPool constantPool;
<span class="line-modified">  75     final HotSpotJVMCIMetaAccessContext context;</span>
<span class="line-modified">  76     private HotSpotResolvedObjectType arrayOfType;</span>
  77 
  78     /**
<span class="line-modified">  79      * Managed exclusively by {@link HotSpotResolvedJavaFieldImpl#toJava}.</span>
  80      */
  81     HashMap&lt;HotSpotResolvedJavaFieldImpl, Field&gt; reflectionFieldCache;
  82 
<span class="line-modified">  83     /**</span>
<span class="line-modified">  84      * Gets the JVMCI mirror for a {@link Class} object.</span>
<span class="line-removed">  85      *</span>
<span class="line-removed">  86      * @return the {@link HotSpotResolvedJavaType} corresponding to {@code javaClass}</span>
<span class="line-removed">  87      */</span>
<span class="line-removed">  88     static HotSpotResolvedObjectTypeImpl fromObjectClass(Class&lt;?&gt; javaClass) {</span>
<span class="line-removed">  89         return (HotSpotResolvedObjectTypeImpl) runtime().fromClass(javaClass);</span>
  90     }
  91 
  92     /**
<span class="line-modified">  93      * Gets the JVMCI mirror from a HotSpot type. Since {@link Class} is already a proxy for the</span>
<span class="line-removed">  94      * underlying Klass*, it is used instead of the raw Klass*.</span>
  95      *
  96      * Called from the VM.
  97      *
<span class="line-modified">  98      * @param javaClass a {@link Class} object</span>
  99      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
 100      */
 101     @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified"> 102     private static HotSpotResolvedObjectTypeImpl fromMetaspace(Class&lt;?&gt; javaClass) {</span>
<span class="line-modified"> 103         return fromObjectClass(javaClass);</span>

 104     }
 105 
 106     /**
 107      * Creates the JVMCI mirror for a {@link Class} object.
 108      *
<span class="line-removed"> 109      * &lt;p&gt;</span>
 110      * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
<span class="line-modified"> 111      * {@link Class} type. Use {@link #fromObjectClass(Class)} or {@link #fromMetaspace(Class)}</span>
<span class="line-removed"> 112      * instead.</span>
 113      * &lt;/p&gt;
 114      *
<span class="line-modified"> 115      * @param javaClass the Class to create the mirror for</span>
<span class="line-removed"> 116      * @param context</span>
 117      */
<span class="line-modified"> 118     HotSpotResolvedObjectTypeImpl(Class&lt;?&gt; javaClass, HotSpotJVMCIMetaAccessContext context) {</span>
<span class="line-modified"> 119         super(getSignatureName(javaClass));</span>
<span class="line-modified"> 120         this.javaClass = javaClass;</span>
<span class="line-modified"> 121         this.context = context;</span>
<span class="line-modified"> 122         assert getName().charAt(0) != &#39;[&#39; || isArray() : getName();</span>
<span class="line-removed"> 123     }</span>
 124 
<span class="line-modified"> 125     /**</span>
<span class="line-modified"> 126      * Returns the name of this type as it would appear in a signature.</span>
<span class="line-modified"> 127      */</span>
<span class="line-modified"> 128     private static String getSignatureName(Class&lt;?&gt; javaClass) {</span>
<span class="line-modified"> 129         if (javaClass.isArray()) {</span>
<span class="line-modified"> 130             return javaClass.getName().replace(&#39;.&#39;, &#39;/&#39;);</span>
 131         }
<span class="line-removed"> 132         return &quot;L&quot; + javaClass.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
 133     }
 134 
 135     /**
 136      * Gets the metaspace Klass for this type.
 137      */
 138     long getMetaspaceKlass() {
<span class="line-modified"> 139         if (HotSpotJVMCIRuntime.getHostWordKind() == JavaKind.Long) {</span>
<span class="line-modified"> 140             return UNSAFE.getLong(javaClass, config().klassOffset);</span>

 141         }
<span class="line-modified"> 142         return UNSAFE.getInt(javaClass, config().klassOffset) &amp; 0xFFFFFFFFL;</span>
 143     }
 144 
 145     @Override
 146     public long getMetaspacePointer() {
<span class="line-modified"> 147         return getMetaspaceKlass();</span>
<span class="line-removed"> 148     }</span>
<span class="line-removed"> 149 </span>
<span class="line-removed"> 150     /**</span>
<span class="line-removed"> 151      * The Klass* for this object is kept alive by the direct reference to {@link #javaClass} so no</span>
<span class="line-removed"> 152      * extra work is required.</span>
<span class="line-removed"> 153      */</span>
<span class="line-removed"> 154     @Override</span>
<span class="line-removed"> 155     public boolean isRegistered() {</span>
<span class="line-removed"> 156         return true;</span>
 157     }
 158 
 159     @Override
 160     public int getModifiers() {
 161         if (isArray()) {
 162             return (getElementalType().getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED)) | Modifier.FINAL | Modifier.ABSTRACT;
 163         } else {
 164             return getAccessFlags() &amp; jvmClassModifiers();
 165         }
 166     }
 167 
 168     public int getAccessFlags() {
 169         HotSpotVMConfig config = config();
 170         return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
 171     }
 172 
<span class="line-removed"> 173     @Override</span>
<span class="line-removed"> 174     public HotSpotResolvedObjectType getArrayClass() {</span>
<span class="line-removed"> 175         if (arrayOfType == null) {</span>
<span class="line-removed"> 176             arrayOfType = fromObjectClass(Array.newInstance(mirror(), 0).getClass());</span>
<span class="line-removed"> 177         }</span>
<span class="line-removed"> 178         return arrayOfType;</span>
<span class="line-removed"> 179     }</span>
<span class="line-removed"> 180 </span>
 181     @Override
 182     public ResolvedJavaType getComponentType() {
<span class="line-modified"> 183         Class&lt;?&gt; javaComponentType = mirror().getComponentType();</span>
<span class="line-removed"> 184         return javaComponentType == null ? null : runtime().fromClass(javaComponentType);</span>
 185     }
 186 
 187     @Override
 188     public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
 189         if (isLeaf()) {
 190             // No assumptions are required.
 191             return new AssumptionResult&lt;&gt;(this);
 192         }
 193         HotSpotVMConfig config = config();
 194         if (isArray()) {
 195             ResolvedJavaType elementalType = getElementalType();
 196             AssumptionResult&lt;ResolvedJavaType&gt; elementType = elementalType.findLeafConcreteSubtype();
 197             if (elementType != null &amp;&amp; elementType.getResult().equals(elementalType)) {
 198                 /*
 199                  * If the elementType is leaf then the array is leaf under the same assumptions but
 200                  * only if the element type is exactly the leaf type. The element type can be
 201                  * abstract even if there is only one implementor of the abstract type.
 202                  */
 203                 AssumptionResult&lt;ResolvedJavaType&gt; result = new AssumptionResult&lt;&gt;(this);
 204                 result.add(elementType);
</pre>
<hr />
<pre>
 262      * {@code Klass::_subklass} field of the underlying class is zero.
 263      *
 264      * @return true if the type is a leaf class
 265      */
 266     private boolean isLeafClass() {
 267         return UNSAFE.getLong(this.getMetaspaceKlass() + config().subklassOffset) == 0;
 268     }
 269 
 270     /**
 271      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 272      * type {@code type}.
 273      *
 274      * @return value of the subklass field as metaspace klass pointer
 275      */
 276     private HotSpotResolvedObjectTypeImpl getSubklass() {
 277         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 278     }
 279 
 280     @Override
 281     public HotSpotResolvedObjectTypeImpl getSuperclass() {
<span class="line-modified"> 282         Class&lt;?&gt; javaSuperclass = mirror().getSuperclass();</span>
<span class="line-modified"> 283         return javaSuperclass == null ? null : fromObjectClass(javaSuperclass);</span>














 284     }
 285 
 286     @Override
 287     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
 288         if (interfaces == null) {
<span class="line-modified"> 289             Class&lt;?&gt;[] javaInterfaces = mirror().getInterfaces();</span>
<span class="line-modified"> 290             HotSpotResolvedObjectTypeImpl[] result = new HotSpotResolvedObjectTypeImpl[javaInterfaces.length];</span>
<span class="line-modified"> 291             for (int i = 0; i &lt; javaInterfaces.length; i++) {</span>
<span class="line-modified"> 292                 result[i] = fromObjectClass(javaInterfaces[i]);</span>



 293             }
<span class="line-removed"> 294             interfaces = result;</span>
 295         }
 296         return interfaces;
 297     }
 298 
 299     @Override
 300     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
 301         if (!isInterface()) {
 302             throw new JVMCIError(&quot;Cannot call getSingleImplementor() on a non-interface type: %s&quot;, this);
 303         }
 304         return compilerToVM().getImplementor(this);
 305     }
 306 
 307     @Override
 308     public HotSpotResolvedObjectTypeImpl getSupertype() {
 309         if (isArray()) {
 310             ResolvedJavaType componentType = getComponentType();
<span class="line-modified"> 311             if (mirror() == Object[].class || componentType.isPrimitive()) {</span>
<span class="line-modified"> 312                 return fromObjectClass(Object.class);</span>
 313             }
<span class="line-modified"> 314             return (HotSpotResolvedObjectTypeImpl) ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype().getArrayClass();</span>

 315         }
 316         if (isInterface()) {
<span class="line-modified"> 317             return fromObjectClass(Object.class);</span>
 318         }
 319         return getSuperclass();
 320     }
 321 
 322     @Override
 323     public HotSpotResolvedObjectType findLeastCommonAncestor(ResolvedJavaType otherType) {
 324         if (otherType.isPrimitive()) {
 325             return null;
 326         } else {
 327             HotSpotResolvedObjectTypeImpl t1 = this;
 328             HotSpotResolvedObjectTypeImpl t2 = (HotSpotResolvedObjectTypeImpl) otherType;
 329             while (true) {
 330                 if (t1.isAssignableFrom(t2)) {
 331                     return t1;
 332                 }
 333                 if (t2.isAssignableFrom(t1)) {
 334                     return t2;
 335                 }
 336                 t1 = t1.getSupertype();
 337                 t2 = t2.getSupertype();
 338             }
 339         }
 340     }
 341 
 342     @Override
 343     public AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass() {
 344         assert !isArray();
 345         if (!compilerToVM().hasFinalizableSubclass(this)) {
 346             return new AssumptionResult&lt;&gt;(false, new NoFinalizableSubclass(this));
 347         }
 348         return new AssumptionResult&lt;&gt;(true);
 349     }
 350 
 351     @Override
 352     public boolean hasFinalizer() {
 353         return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
 354     }
 355 
<span class="line-removed"> 356     @Override</span>
<span class="line-removed"> 357     public boolean isPrimitive() {</span>
<span class="line-removed"> 358         return false;</span>
<span class="line-removed"> 359     }</span>
<span class="line-removed"> 360 </span>
 361     @Override
 362     public boolean isArray() {
<span class="line-modified"> 363         return mirror().isArray();</span>
 364     }
 365 
 366     @Override
 367     public boolean isEnum() {
<span class="line-modified"> 368         return mirror().isEnum();</span>

 369     }
 370 
 371     @Override
 372     public boolean isInitialized() {
 373         return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
 374     }
 375 





 376     @Override
 377     public boolean isLinked() {
 378         return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
 379     }
 380 
 381     /**
 382      * Returns the value of the state field {@code InstanceKlass::_init_state} of the metaspace
 383      * klass.
 384      *
 385      * @return state field value of this type
 386      */
 387     private int getInitState() {
 388         assert !isArray() : &quot;_init_state only exists in InstanceKlass&quot;;
 389         return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) &amp; 0xFF;
 390     }
 391 
 392     @Override
 393     public void initialize() {
 394         if (!isInitialized()) {
<span class="line-modified"> 395             UNSAFE.ensureClassInitialized(mirror());</span>
<span class="line-modified"> 396             assert isInitialized();</span>
 397         }
 398     }
 399 
 400     @Override
 401     public boolean isInstance(JavaConstant obj) {
 402         if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
<span class="line-modified"> 403             return mirror().isInstance(((HotSpotObjectConstantImpl) obj).object());</span>
 404         }
 405         return false;
 406     }
 407 
 408     @Override
 409     public boolean isInstanceClass() {
 410         return !isArray() &amp;&amp; !isInterface();
 411     }
 412 
 413     @Override
 414     public boolean isInterface() {
<span class="line-modified"> 415         return mirror().isInterface();</span>
 416     }
 417 
 418     @Override
 419     public boolean isAssignableFrom(ResolvedJavaType other) {
 420         assert other != null;
 421         if (other instanceof HotSpotResolvedObjectTypeImpl) {
 422             HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
<span class="line-modified"> 423             return mirror().isAssignableFrom(otherType.mirror());</span>
 424         }
 425         return false;
 426     }
 427 
 428     @Override
 429     public ResolvedJavaType getHostClass() {
 430         if (isArray()) {
 431             return null;
 432         }
 433         return compilerToVM().getHostClass(this);
 434     }
 435 
 436     @Override
 437     public boolean isJavaLangObject() {
<span class="line-modified"> 438         return javaClass.equals(Object.class);</span>
 439     }
 440 
 441     @Override
 442     public JavaKind getJavaKind() {
 443         return JavaKind.Object;
 444     }
 445 
 446     @Override
 447     public ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
 448         assert !callerType.isArray();
 449         if (isInterface()) {
 450             // Methods can only be resolved against concrete types
 451             return null;
 452         }
 453         if (method.isConcrete() &amp;&amp; method.getDeclaringClass().equals(this) &amp;&amp; method.isPublic() &amp;&amp; !isSignaturePolymorphicHolder(method.getDeclaringClass())) {
 454             return method;
 455         }
 456         if (!method.getDeclaringClass().isAssignableFrom(this)) {
 457             return null;
 458         }
</pre>
<hr />
<pre>
 484     public int instanceSize() {
 485         assert !isArray();
 486         assert !isInterface();
 487 
 488         HotSpotVMConfig config = config();
 489         final int layoutHelper = layoutHelper();
 490         assert layoutHelper &gt; config.klassLayoutHelperNeutralValue : &quot;must be instance&quot;;
 491 
 492         // See: Klass::layout_helper_size_in_bytes
 493         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 494 
 495         // See: Klass::layout_helper_needs_slow_path
 496         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 497 
 498         return needsSlowPath ? -size : size;
 499     }
 500 
 501     @Override
 502     public int layoutHelper() {
 503         HotSpotVMConfig config = config();

 504         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 505     }
 506 
 507     @Override
 508     public long getFingerprint() {
 509         return compilerToVM().getFingerprint(getMetaspaceKlass());
 510     }
 511 
<span class="line-modified"> 512     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceMethod) {</span>

 513         // Maintain cache as array.
 514         if (methodCacheArray == null) {
 515             methodCacheArray = new HotSpotResolvedJavaMethodImpl[METHOD_CACHE_ARRAY_CAPACITY];
 516         }
 517 
 518         int i = 0;
 519         for (; i &lt; methodCacheArray.length; ++i) {
 520             HotSpotResolvedJavaMethodImpl curMethod = methodCacheArray[i];
 521             if (curMethod == null) {
<span class="line-modified"> 522                 HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);</span>
 523                 methodCacheArray[i] = newMethod;
<span class="line-removed"> 524                 context.add(newMethod);</span>
 525                 return newMethod;
<span class="line-modified"> 526             } else if (curMethod.getMetaspacePointer() == metaspaceMethod) {</span>
 527                 return curMethod;
 528             }
 529         }
 530 
 531         // Fall-back to hash table.
 532         if (methodCacheHashMap == null) {
 533             methodCacheHashMap = new HashMap&lt;&gt;();
 534         }
 535 
 536         HotSpotResolvedJavaMethodImpl lookupResult = methodCacheHashMap.get(metaspaceMethod);
 537         if (lookupResult == null) {
<span class="line-modified"> 538             HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);</span>
 539             methodCacheHashMap.put(metaspaceMethod, newMethod);
<span class="line-removed"> 540             context.add(lookupResult);</span>
 541             return newMethod;
 542         } else {
 543             return lookupResult;
 544         }
 545     }
 546 
 547     @Override
 548     public int getVtableLength() {
 549         HotSpotVMConfig config = config();
 550         if (isInterface() || isArray()) {
 551             /* Everything has the core vtable of java.lang.Object */
 552             return config.baseVtableLength();
 553         }
 554         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 555         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + &quot; &quot; + config.vtableEntrySize;
 556         return result;
 557     }
 558 
 559     HotSpotResolvedJavaField createField(JavaType type, long offset, int rawFlags, int index) {
 560         return new HotSpotResolvedJavaFieldImpl(this, type, offset, rawFlags, index);
 561     }
 562 
 563     @Override
 564     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 565         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 566         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 567         /*
 568          * Sometimes the receiver type in the graph hasn&#39;t stabilized to a subtype of declared
 569          * holder, usually because of phis, so make sure that the type is related to the declared
 570          * type before using it for lookup. Unlinked types should also be ignored because we can&#39;t
 571          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 572          * a deopt instead since they can&#39;t really be used if they aren&#39;t linked yet.
 573          */
 574         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {




 575             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 576             if (result != null) {
 577                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 578             }
 579             return null;
 580         }
 581         /*
 582          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 583          * the correct method for the subtype.
 584          */
 585         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 586         if (resolvedMethod == null) {
 587             // The type isn&#39;t known to implement the method.
 588             return null;
 589         }




 590 
 591         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 592         if (result != null) {
 593             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 594         }
 595         return null;
 596     }
 597 
 598     FieldInfo createFieldInfo(int index) {
 599         return new FieldInfo(index);
 600     }
 601 





















 602     /**
 603      * This class represents the field information for one field contained in the fields array of an
 604      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 605      */
 606     class FieldInfo {
 607         /**
 608          * Native pointer into the array of Java shorts.
 609          */
 610         private final long metaspaceData;
 611 
 612         /**
 613          * Creates a field info for the field in the fields array at index {@code index}.
 614          *
 615          * @param index index to the fields array
 616          */
 617         FieldInfo(int index) {
 618             HotSpotVMConfig config = config();
 619             // Get Klass::_fields
 620             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 621             assert config.fieldInfoFieldSlots == 6 : &quot;revisit the field parsing code&quot;;
</pre>
<hr />
<pre>
 671         }
 672 
 673         public JavaType getType() {
 674             String signature = getSignature();
 675             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 676         }
 677 
 678         private boolean isInternal() {
 679             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 680         }
 681 
 682         public boolean isStatic() {
 683             return Modifier.isStatic(getAccessFlags());
 684         }
 685 
 686         public boolean hasGenericSignature() {
 687             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 688         }
 689     }
 690 






 691     @Override
 692     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 693         if (instanceFields == null) {
 694             if (isArray() || isInterface()) {
 695                 instanceFields = NO_FIELDS;
 696             } else {
 697                 HotSpotResolvedJavaField[] prepend = NO_FIELDS;
 698                 if (getSuperclass() != null) {
 699                     prepend = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);
 700                 }
 701                 instanceFields = getFields(false, prepend);
 702             }
 703         }
 704         if (!includeSuperclasses &amp;&amp; getSuperclass() != null) {
 705             int superClassFieldCount = getSuperclass().getInstanceFields(true).length;
 706             if (superClassFieldCount == instanceFields.length) {
 707                 // This class does not have any instance fields of its own.
 708                 return NO_FIELDS;
 709             } else if (superClassFieldCount != 0) {



 710                 HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[instanceFields.length - superClassFieldCount];
<span class="line-modified"> 711                 System.arraycopy(instanceFields, superClassFieldCount, result, 0, result.length);</span>






 712                 return result;
 713             } else {
 714                 // The super classes of this class do not have any instance fields.
 715             }
 716         }
 717         return instanceFields;
 718     }
 719 
 720     @Override
 721     public ResolvedJavaField[] getStaticFields() {
 722         if (isArray()) {
 723             return new HotSpotResolvedJavaField[0];
 724         } else {
 725             return getFields(true, NO_FIELDS);
 726         }
 727     }
 728 
 729     /**
 730      * Gets the instance or static fields of this class.
 731      *
</pre>
<hr />
<pre>
 744                 metaspaceFieldsLength--;
 745             }
 746 
 747             if (field.isStatic() == retrieveStaticFields) {
 748                 resultCount++;
 749             }
 750         }
 751 
 752         if (resultCount == 0) {
 753             return prepend;
 754         }
 755 
 756         int prependLength = prepend.length;
 757         resultCount += prependLength;
 758 
 759         HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[resultCount];
 760         if (prependLength != 0) {
 761             System.arraycopy(prepend, 0, result, 0, prependLength);
 762         }
 763 



 764         int resultIndex = prependLength;
 765         for (int i = 0; i &lt; index; ++i) {
 766             FieldInfo field = new FieldInfo(i);
 767             if (field.isStatic() == retrieveStaticFields) {
 768                 int offset = field.getOffset();
 769                 HotSpotResolvedJavaField resolvedJavaField = createField(field.getType(), offset, field.getAccessFlags(), i);
<span class="line-modified"> 770 </span>
<span class="line-removed"> 771                 // Make sure the result is sorted by offset.</span>
<span class="line-removed"> 772                 int j;</span>
<span class="line-removed"> 773                 for (j = resultIndex - 1; j &gt;= prependLength &amp;&amp; result[j].getOffset() &gt; offset; j--) {</span>
<span class="line-removed"> 774                     result[j + 1] = result[j];</span>
<span class="line-removed"> 775                 }</span>
<span class="line-removed"> 776                 result[j + 1] = resolvedJavaField;</span>
<span class="line-removed"> 777                 resultIndex++;</span>
 778             }
 779         }
<span class="line-modified"> 780 </span>
 781         return result;
 782     }
 783 
<span class="line-removed"> 784     @Override</span>
<span class="line-removed"> 785     public Class&lt;?&gt; mirror() {</span>
<span class="line-removed"> 786         return javaClass;</span>
<span class="line-removed"> 787     }</span>
<span class="line-removed"> 788 </span>
 789     @Override
 790     public String getSourceFileName() {
 791         HotSpotVMConfig config = config();
 792         final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassSourceFileNameIndexOffset);
 793         if (sourceFileNameIndex == 0) {
 794             return null;
 795         }
 796         return getConstantPool().lookupUtf8(sourceFileNameIndex);
 797     }
 798 
 799     @Override
 800     public Annotation[] getAnnotations() {
<span class="line-modified"> 801         return mirror().getAnnotations();</span>
 802     }
 803 
 804     @Override
 805     public Annotation[] getDeclaredAnnotations() {
<span class="line-modified"> 806         return mirror().getDeclaredAnnotations();</span>
 807     }
 808 
 809     @Override
 810     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="line-modified"> 811         return mirror().getAnnotation(annotationClass);</span>
 812     }
 813 
 814     /**
 815      * Performs a fast-path check that this type is resolved in the context of a given accessing
 816      * class. A negative result does not mean this type is not resolved with respect to
 817      * {@code accessingClass}. That can only be determined by
 818      * {@linkplain HotSpotJVMCIRuntime#lookupType(String, HotSpotResolvedObjectType, boolean)
 819      * re-resolving} the type.
 820      */
 821     @Override
 822     public boolean isDefinitelyResolvedWithRespectTo(ResolvedJavaType accessingClass) {
 823         assert accessingClass != null;
 824         ResolvedJavaType elementType = getElementalType();
 825         if (elementType.isPrimitive()) {
 826             // Primitive type resolution is context free.
 827             return true;
 828         }
<span class="line-modified"> 829         if (elementType.getName().startsWith(&quot;Ljava/&quot;)) {</span>
<span class="line-modified"> 830             // Classes in a java.* package can only be defined by the</span>
<span class="line-removed"> 831             // boot or platform class loader.</span>
 832             return true;
 833         }
<span class="line-modified"> 834         ClassLoader thisCl = mirror().getClassLoader();</span>
<span class="line-modified"> 835         ClassLoader accessingClassCl = ((HotSpotResolvedObjectTypeImpl) accessingClass).mirror().getClassLoader();</span>
<span class="line-modified"> 836         return thisCl == accessingClassCl;</span>




 837     }
 838 
 839     @Override
 840     public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
 841         if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
 842             return this;
 843         }
 844         HotSpotResolvedObjectTypeImpl accessingType = (HotSpotResolvedObjectTypeImpl) accessingClass;
 845         return (ResolvedJavaType) runtime().lookupType(getName(), accessingType, true);
 846     }
 847 
 848     /**
 849      * Gets the metaspace Klass boxed in a {@link JavaConstant}.
 850      */
 851     @Override
 852     public Constant klass() {
 853         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
 854     }
 855 
 856     @Override
</pre>
<hr />
<pre>
 870         if (isArray()) {
 871             return config.arrayPrototypeMarkWord();
 872         } else {
 873             return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);
 874         }
 875     }
 876 
 877     @Override
 878     public ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 879         ResolvedJavaField[] declaredFields = getInstanceFields(true);
 880         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
 881     }
 882 
 883     public ResolvedJavaField findStaticFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 884         ResolvedJavaField[] declaredFields = getStaticFields();
 885         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
 886     }
 887 
 888     private static ResolvedJavaField findFieldWithOffset(long offset, JavaKind expectedEntryKind, ResolvedJavaField[] declaredFields) {
 889         for (ResolvedJavaField field : declaredFields) {
<span class="line-modified"> 890             HotSpotResolvedJavaField resolvedField = (HotSpotResolvedJavaField) field;</span>
<span class="line-removed"> 891             long resolvedFieldOffset = resolvedField.getOffset();</span>
 892             // @formatter:off
<span class="line-modified"> 893             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN  &amp;&amp;</span>
<span class="line-modified"> 894                             expectedEntryKind.isPrimitive() &amp;&amp;</span>
<span class="line-modified"> 895                             !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;</span>
<span class="line-modified"> 896                             resolvedField.getJavaKind().isPrimitive()) {</span>
 897                 resolvedFieldOffset +=
<span class="line-modified"> 898                                 resolvedField.getJavaKind().getByteCount() -</span>
<span class="line-modified"> 899                                 Math.min(resolvedField.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());</span>
 900             }
 901             if (resolvedFieldOffset == offset) {
 902                 return field;
 903             }
 904             // @formatter:on
 905         }
 906         return null;
 907     }
 908 
 909     @Override
 910     public boolean isLocal() {
<span class="line-modified"> 911         return mirror().isLocalClass();</span>
 912     }
 913 
 914     @Override
 915     public boolean isMember() {
<span class="line-modified"> 916         return mirror().isMemberClass();</span>
 917     }
 918 
 919     @Override
<span class="line-modified"> 920     public HotSpotResolvedObjectTypeImpl getEnclosingType() {</span>
<span class="line-modified"> 921         final Class&lt;?&gt; encl = mirror().getEnclosingClass();</span>
<span class="line-removed"> 922         return encl == null ? null : fromObjectClass(encl);</span>
 923     }
 924 
 925     @Override
 926     public ResolvedJavaMethod[] getDeclaredConstructors() {
<span class="line-modified"> 927         Constructor&lt;?&gt;[] constructors = mirror().getDeclaredConstructors();</span>
<span class="line-removed"> 928         ResolvedJavaMethod[] result = new ResolvedJavaMethod[constructors.length];</span>
<span class="line-removed"> 929         for (int i = 0; i &lt; constructors.length; i++) {</span>
<span class="line-removed"> 930             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(constructors[i]);</span>
<span class="line-removed"> 931             assert result[i].isConstructor();</span>
<span class="line-removed"> 932         }</span>
<span class="line-removed"> 933         return result;</span>
 934     }
 935 
 936     @Override
 937     public ResolvedJavaMethod[] getDeclaredMethods() {
<span class="line-modified"> 938         Method[] methods = mirror().getDeclaredMethods();</span>
<span class="line-removed"> 939         ResolvedJavaMethod[] result = new ResolvedJavaMethod[methods.length];</span>
<span class="line-removed"> 940         for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="line-removed"> 941             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(methods[i]);</span>
<span class="line-removed"> 942             assert !result[i].isConstructor();</span>
<span class="line-removed"> 943         }</span>
<span class="line-removed"> 944         return result;</span>
 945     }
 946 
 947     @Override
 948     public ResolvedJavaMethod getClassInitializer() {
 949         if (!isArray()) {
 950             return compilerToVM().getClassInitializer(this);
 951         }
 952         return null;
 953     }
 954 
 955     @Override
 956     public String toString() {
 957         return &quot;HotSpotType&lt;&quot; + getName() + &quot;, resolved&gt;&quot;;
 958     }
 959 
 960     @Override
 961     public ResolvedJavaType lookupType(UnresolvedJavaType unresolvedJavaType, boolean resolve) {
 962         JavaType javaType = HotSpotJVMCIRuntime.runtime().lookupType(unresolvedJavaType.getName(), this, resolve);
 963         if (javaType instanceof ResolvedJavaType) {
 964             return (ResolvedJavaType) javaType;
</pre>
<hr />
<pre>
 969     @Override
 970     public ResolvedJavaField resolveField(UnresolvedJavaField unresolvedJavaField, ResolvedJavaType accessingClass) {
 971         for (ResolvedJavaField field : getInstanceFields(false)) {
 972             if (field.getName().equals(unresolvedJavaField.getName())) {
 973                 return field;
 974             }
 975         }
 976         for (ResolvedJavaField field : getStaticFields()) {
 977             if (field.getName().equals(unresolvedJavaField.getName())) {
 978                 return field;
 979             }
 980         }
 981         throw new InternalError(unresolvedJavaField.toString());
 982     }
 983 
 984     @Override
 985     public boolean isCloneableWithAllocation() {
 986         return (getAccessFlags() &amp; config().jvmAccIsCloneableFast) != 0;
 987     }
 988 




 989     private int getMiscFlags() {
 990         return UNSAFE.getInt(getMetaspaceKlass() + config().instanceKlassMiscFlagsOffset);
 991     }
 992 
 993     @Override
 994     public boolean isUnsafeAnonymous() {
 995         return (getMiscFlags() &amp; config().instanceKlassMiscIsUnsafeAnonymous) != 0;
 996     }
 997 
 998 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotConstantPool.isSignaturePolymorphicHolder;
  28 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  29 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmClassModifiers;
  30 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  31 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  32 
  33 import java.lang.annotation.Annotation;


  34 import java.lang.reflect.Field;

  35 import java.lang.reflect.Modifier;
  36 import java.nio.ByteOrder;
<span class="line-added">  37 import java.util.Arrays;</span>
<span class="line-added">  38 import java.util.Comparator;</span>
  39 import java.util.HashMap;
  40 
  41 import jdk.vm.ci.common.JVMCIError;
  42 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  43 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  44 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  45 import jdk.vm.ci.meta.Assumptions.LeafType;
  46 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  47 import jdk.vm.ci.meta.Constant;
  48 import jdk.vm.ci.meta.JavaConstant;
  49 import jdk.vm.ci.meta.JavaKind;
  50 import jdk.vm.ci.meta.JavaType;
  51 import jdk.vm.ci.meta.ResolvedJavaField;
  52 import jdk.vm.ci.meta.ResolvedJavaMethod;
  53 import jdk.vm.ci.meta.ResolvedJavaType;
  54 import jdk.vm.ci.meta.UnresolvedJavaField;
  55 import jdk.vm.ci.meta.UnresolvedJavaType;
  56 
  57 /**
<span class="line-modified">  58  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes. This class is not</span>
<span class="line-added">  59  * an {@link MetaspaceHandleObject} because it doesn&#39;t have to be scanned for GC. It&#39;s liveness is</span>
<span class="line-added">  60  * maintained by a reference to the {@link Class} instance.</span>
  61  */
<span class="line-modified">  62 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceObject {</span>
  63 
  64     private static final HotSpotResolvedJavaField[] NO_FIELDS = new HotSpotResolvedJavaField[0];
  65     private static final int METHOD_CACHE_ARRAY_CAPACITY = 8;
<span class="line-added">  66     private static final SortByOffset fieldSortingMethod = new SortByOffset();</span>
  67 
  68     /**
  69      * The Java class this type represents.
  70      */
<span class="line-modified">  71     private final long metadataPointer;</span>
<span class="line-added">  72 </span>
  73     private HotSpotResolvedJavaMethodImpl[] methodCacheArray;
  74     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCacheHashMap;
<span class="line-modified">  75     private volatile HotSpotResolvedJavaField[] instanceFields;</span>
<span class="line-modified">  76     private volatile HotSpotResolvedObjectTypeImpl[] interfaces;</span>
  77     private HotSpotConstantPool constantPool;
<span class="line-modified">  78     private final JavaConstant mirror;</span>
<span class="line-modified">  79     private HotSpotResolvedObjectTypeImpl superClass;</span>
  80 
  81     /**
<span class="line-modified">  82      * Managed exclusively by {@link HotSpotJDKReflection#getField}.</span>
  83      */
  84     HashMap&lt;HotSpotResolvedJavaFieldImpl, Field&gt; reflectionFieldCache;
  85 
<span class="line-modified">  86     static HotSpotResolvedObjectTypeImpl getJavaLangObject() {</span>
<span class="line-modified">  87         return runtime().getJavaLangObject();</span>





  88     }
  89 
  90     /**
<span class="line-modified">  91      * Gets the JVMCI mirror from a HotSpot type.</span>

  92      *
  93      * Called from the VM.
  94      *
<span class="line-modified">  95      * @param klassPointer a native pointer to the Klass*</span>
  96      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
  97      */
  98     @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">  99     @VMEntryPoint</span>
<span class="line-modified"> 100     private static HotSpotResolvedObjectTypeImpl fromMetaspace(long klassPointer, String signature) {</span>
<span class="line-added"> 101         return runtime().fromMetaspace(klassPointer, signature);</span>
 102     }
 103 
 104     /**
 105      * Creates the JVMCI mirror for a {@link Class} object.
 106      *

 107      * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
<span class="line-modified"> 108      * {@link Class} type.</span>

 109      * &lt;/p&gt;
 110      *
<span class="line-modified"> 111      * @param metadataPointer the Klass* to create the mirror for</span>

 112      */
<span class="line-modified"> 113     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-modified"> 114     HotSpotResolvedObjectTypeImpl(long metadataPointer, String name) {</span>
<span class="line-modified"> 115         super(name);</span>
<span class="line-modified"> 116         assert metadataPointer != 0;</span>
<span class="line-modified"> 117         this.metadataPointer = metadataPointer;</span>

 118 
<span class="line-modified"> 119         // The mirror object must be in the global scope since</span>
<span class="line-modified"> 120         // this object will be cached in HotSpotJVMCIRuntime.resolvedJavaTypes</span>
<span class="line-modified"> 121         // and live across more than one compilation.</span>
<span class="line-modified"> 122         try (HotSpotObjectConstantScope global = HotSpotObjectConstantScope.enterGlobalScope()) {</span>
<span class="line-modified"> 123             this.mirror = runtime().compilerToVm.getJavaMirror(this);</span>
<span class="line-modified"> 124             assert getName().charAt(0) != &#39;[&#39; || isArray() : getName();</span>
 125         }

 126     }
 127 
 128     /**
 129      * Gets the metaspace Klass for this type.
 130      */
 131     long getMetaspaceKlass() {
<span class="line-modified"> 132         long metaspacePointer = getMetaspacePointer();</span>
<span class="line-modified"> 133         if (metaspacePointer == 0) {</span>
<span class="line-added"> 134             throw new NullPointerException(&quot;Klass* is null&quot;);</span>
 135         }
<span class="line-modified"> 136         return metaspacePointer;</span>
 137     }
 138 
 139     @Override
 140     public long getMetaspacePointer() {
<span class="line-modified"> 141         return metadataPointer;</span>









 142     }
 143 
 144     @Override
 145     public int getModifiers() {
 146         if (isArray()) {
 147             return (getElementalType().getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED)) | Modifier.FINAL | Modifier.ABSTRACT;
 148         } else {
 149             return getAccessFlags() &amp; jvmClassModifiers();
 150         }
 151     }
 152 
 153     public int getAccessFlags() {
 154         HotSpotVMConfig config = config();
 155         return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
 156     }
 157 








 158     @Override
 159     public ResolvedJavaType getComponentType() {
<span class="line-modified"> 160         return runtime().compilerToVm.getComponentType(this);</span>

 161     }
 162 
 163     @Override
 164     public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
 165         if (isLeaf()) {
 166             // No assumptions are required.
 167             return new AssumptionResult&lt;&gt;(this);
 168         }
 169         HotSpotVMConfig config = config();
 170         if (isArray()) {
 171             ResolvedJavaType elementalType = getElementalType();
 172             AssumptionResult&lt;ResolvedJavaType&gt; elementType = elementalType.findLeafConcreteSubtype();
 173             if (elementType != null &amp;&amp; elementType.getResult().equals(elementalType)) {
 174                 /*
 175                  * If the elementType is leaf then the array is leaf under the same assumptions but
 176                  * only if the element type is exactly the leaf type. The element type can be
 177                  * abstract even if there is only one implementor of the abstract type.
 178                  */
 179                 AssumptionResult&lt;ResolvedJavaType&gt; result = new AssumptionResult&lt;&gt;(this);
 180                 result.add(elementType);
</pre>
<hr />
<pre>
 238      * {@code Klass::_subklass} field of the underlying class is zero.
 239      *
 240      * @return true if the type is a leaf class
 241      */
 242     private boolean isLeafClass() {
 243         return UNSAFE.getLong(this.getMetaspaceKlass() + config().subklassOffset) == 0;
 244     }
 245 
 246     /**
 247      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 248      * type {@code type}.
 249      *
 250      * @return value of the subklass field as metaspace klass pointer
 251      */
 252     private HotSpotResolvedObjectTypeImpl getSubklass() {
 253         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 254     }
 255 
 256     @Override
 257     public HotSpotResolvedObjectTypeImpl getSuperclass() {
<span class="line-modified"> 258         if (isInterface()) {</span>
<span class="line-modified"> 259             return null;</span>
<span class="line-added"> 260         }</span>
<span class="line-added"> 261         HotSpotResolvedObjectTypeImpl javaLangObject = runtime().getJavaLangObject();</span>
<span class="line-added"> 262         if (this.equals(javaLangObject)) {</span>
<span class="line-added"> 263             return null;</span>
<span class="line-added"> 264         }</span>
<span class="line-added"> 265         if (isArray()) {</span>
<span class="line-added"> 266             return javaLangObject;</span>
<span class="line-added"> 267         }</span>
<span class="line-added"> 268 </span>
<span class="line-added"> 269         // Cache result of native call</span>
<span class="line-added"> 270         if (superClass == null) {</span>
<span class="line-added"> 271             superClass = compilerToVM().getResolvedJavaType(this, config().superOffset, false);</span>
<span class="line-added"> 272         }</span>
<span class="line-added"> 273         return superClass;</span>
 274     }
 275 
 276     @Override
 277     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
 278         if (interfaces == null) {
<span class="line-modified"> 279             if (isArray()) {</span>
<span class="line-modified"> 280                 HotSpotResolvedObjectTypeImpl[] types = new HotSpotResolvedObjectTypeImpl[2];</span>
<span class="line-modified"> 281                 types[0] = runtime().getJavaLangCloneable();</span>
<span class="line-modified"> 282                 types[1] = runtime().getJavaLangSerializable();</span>
<span class="line-added"> 283                 this.interfaces = types;</span>
<span class="line-added"> 284             } else {</span>
<span class="line-added"> 285                 interfaces = runtime().compilerToVm.getInterfaces(this);</span>
 286             }

 287         }
 288         return interfaces;
 289     }
 290 
 291     @Override
 292     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
 293         if (!isInterface()) {
 294             throw new JVMCIError(&quot;Cannot call getSingleImplementor() on a non-interface type: %s&quot;, this);
 295         }
 296         return compilerToVM().getImplementor(this);
 297     }
 298 
 299     @Override
 300     public HotSpotResolvedObjectTypeImpl getSupertype() {
 301         if (isArray()) {
 302             ResolvedJavaType componentType = getComponentType();
<span class="line-modified"> 303             if (componentType.equals(getJavaLangObject()) || componentType.isPrimitive()) {</span>
<span class="line-modified"> 304                 return getJavaLangObject();</span>
 305             }
<span class="line-modified"> 306             HotSpotResolvedObjectTypeImpl supertype = ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype();</span>
<span class="line-added"> 307             return (HotSpotResolvedObjectTypeImpl) supertype.getArrayClass();</span>
 308         }
 309         if (isInterface()) {
<span class="line-modified"> 310             return getJavaLangObject();</span>
 311         }
 312         return getSuperclass();
 313     }
 314 
 315     @Override
 316     public HotSpotResolvedObjectType findLeastCommonAncestor(ResolvedJavaType otherType) {
 317         if (otherType.isPrimitive()) {
 318             return null;
 319         } else {
 320             HotSpotResolvedObjectTypeImpl t1 = this;
 321             HotSpotResolvedObjectTypeImpl t2 = (HotSpotResolvedObjectTypeImpl) otherType;
 322             while (true) {
 323                 if (t1.isAssignableFrom(t2)) {
 324                     return t1;
 325                 }
 326                 if (t2.isAssignableFrom(t1)) {
 327                     return t2;
 328                 }
 329                 t1 = t1.getSupertype();
 330                 t2 = t2.getSupertype();
 331             }
 332         }
 333     }
 334 
 335     @Override
 336     public AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass() {
 337         assert !isArray();
 338         if (!compilerToVM().hasFinalizableSubclass(this)) {
 339             return new AssumptionResult&lt;&gt;(false, new NoFinalizableSubclass(this));
 340         }
 341         return new AssumptionResult&lt;&gt;(true);
 342     }
 343 
 344     @Override
 345     public boolean hasFinalizer() {
 346         return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
 347     }
 348 





 349     @Override
 350     public boolean isArray() {
<span class="line-modified"> 351         return layoutHelper() &lt; config().klassLayoutHelperNeutralValue;</span>
 352     }
 353 
 354     @Override
 355     public boolean isEnum() {
<span class="line-modified"> 356         HotSpotResolvedObjectTypeImpl superclass = getSuperclass();</span>
<span class="line-added"> 357         return superclass != null &amp;&amp; superclass.equals(runtime().getJavaLangEnum());</span>
 358     }
 359 
 360     @Override
 361     public boolean isInitialized() {
 362         return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
 363     }
 364 
<span class="line-added"> 365     @Override</span>
<span class="line-added"> 366     public boolean isBeingInitialized() {</span>
<span class="line-added"> 367         return isArray() ? false : getInitState() == config().instanceKlassStateBeingInitialized;</span>
<span class="line-added"> 368     }</span>
<span class="line-added"> 369 </span>
 370     @Override
 371     public boolean isLinked() {
 372         return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
 373     }
 374 
 375     /**
 376      * Returns the value of the state field {@code InstanceKlass::_init_state} of the metaspace
 377      * klass.
 378      *
 379      * @return state field value of this type
 380      */
 381     private int getInitState() {
 382         assert !isArray() : &quot;_init_state only exists in InstanceKlass&quot;;
 383         return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) &amp; 0xFF;
 384     }
 385 
 386     @Override
 387     public void initialize() {
 388         if (!isInitialized()) {
<span class="line-modified"> 389             runtime().compilerToVm.ensureInitialized(this);</span>
<span class="line-modified"> 390             assert isInitialized() || isBeingInitialized();</span>
 391         }
 392     }
 393 
 394     @Override
 395     public boolean isInstance(JavaConstant obj) {
 396         if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
<span class="line-modified"> 397             return runtime().reflection.isInstance(this, (HotSpotObjectConstantImpl) obj);</span>
 398         }
 399         return false;
 400     }
 401 
 402     @Override
 403     public boolean isInstanceClass() {
 404         return !isArray() &amp;&amp; !isInterface();
 405     }
 406 
 407     @Override
 408     public boolean isInterface() {
<span class="line-modified"> 409         return (getAccessFlags() &amp; config().jvmAccInterface) != 0;</span>
 410     }
 411 
 412     @Override
 413     public boolean isAssignableFrom(ResolvedJavaType other) {
 414         assert other != null;
 415         if (other instanceof HotSpotResolvedObjectTypeImpl) {
 416             HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
<span class="line-modified"> 417             return runtime().reflection.isAssignableFrom(this, otherType);</span>
 418         }
 419         return false;
 420     }
 421 
 422     @Override
 423     public ResolvedJavaType getHostClass() {
 424         if (isArray()) {
 425             return null;
 426         }
 427         return compilerToVM().getHostClass(this);
 428     }
 429 
 430     @Override
 431     public boolean isJavaLangObject() {
<span class="line-modified"> 432         return getName().equals(&quot;Ljava/lang/Object;&quot;);</span>
 433     }
 434 
 435     @Override
 436     public JavaKind getJavaKind() {
 437         return JavaKind.Object;
 438     }
 439 
 440     @Override
 441     public ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
 442         assert !callerType.isArray();
 443         if (isInterface()) {
 444             // Methods can only be resolved against concrete types
 445             return null;
 446         }
 447         if (method.isConcrete() &amp;&amp; method.getDeclaringClass().equals(this) &amp;&amp; method.isPublic() &amp;&amp; !isSignaturePolymorphicHolder(method.getDeclaringClass())) {
 448             return method;
 449         }
 450         if (!method.getDeclaringClass().isAssignableFrom(this)) {
 451             return null;
 452         }
</pre>
<hr />
<pre>
 478     public int instanceSize() {
 479         assert !isArray();
 480         assert !isInterface();
 481 
 482         HotSpotVMConfig config = config();
 483         final int layoutHelper = layoutHelper();
 484         assert layoutHelper &gt; config.klassLayoutHelperNeutralValue : &quot;must be instance&quot;;
 485 
 486         // See: Klass::layout_helper_size_in_bytes
 487         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 488 
 489         // See: Klass::layout_helper_needs_slow_path
 490         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 491 
 492         return needsSlowPath ? -size : size;
 493     }
 494 
 495     @Override
 496     public int layoutHelper() {
 497         HotSpotVMConfig config = config();
<span class="line-added"> 498         assert getMetaspaceKlass() != 0 : getName();</span>
 499         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 500     }
 501 
 502     @Override
 503     public long getFingerprint() {
 504         return compilerToVM().getFingerprint(getMetaspaceKlass());
 505     }
 506 
<span class="line-modified"> 507     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceHandle) {</span>
<span class="line-added"> 508         long metaspaceMethod = UNSAFE.getLong(metaspaceHandle);</span>
 509         // Maintain cache as array.
 510         if (methodCacheArray == null) {
 511             methodCacheArray = new HotSpotResolvedJavaMethodImpl[METHOD_CACHE_ARRAY_CAPACITY];
 512         }
 513 
 514         int i = 0;
 515         for (; i &lt; methodCacheArray.length; ++i) {
 516             HotSpotResolvedJavaMethodImpl curMethod = methodCacheArray[i];
 517             if (curMethod == null) {
<span class="line-modified"> 518                 HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceHandle);</span>
 519                 methodCacheArray[i] = newMethod;

 520                 return newMethod;
<span class="line-modified"> 521             } else if (curMethod.getMetaspaceMethod() == metaspaceMethod) {</span>
 522                 return curMethod;
 523             }
 524         }
 525 
 526         // Fall-back to hash table.
 527         if (methodCacheHashMap == null) {
 528             methodCacheHashMap = new HashMap&lt;&gt;();
 529         }
 530 
 531         HotSpotResolvedJavaMethodImpl lookupResult = methodCacheHashMap.get(metaspaceMethod);
 532         if (lookupResult == null) {
<span class="line-modified"> 533             HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceHandle);</span>
 534             methodCacheHashMap.put(metaspaceMethod, newMethod);

 535             return newMethod;
 536         } else {
 537             return lookupResult;
 538         }
 539     }
 540 
 541     @Override
 542     public int getVtableLength() {
 543         HotSpotVMConfig config = config();
 544         if (isInterface() || isArray()) {
 545             /* Everything has the core vtable of java.lang.Object */
 546             return config.baseVtableLength();
 547         }
 548         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 549         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + &quot; &quot; + config.vtableEntrySize;
 550         return result;
 551     }
 552 
 553     HotSpotResolvedJavaField createField(JavaType type, long offset, int rawFlags, int index) {
 554         return new HotSpotResolvedJavaFieldImpl(this, type, offset, rawFlags, index);
 555     }
 556 
 557     @Override
 558     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 559         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 560         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 561         /*
 562          * Sometimes the receiver type in the graph hasn&#39;t stabilized to a subtype of declared
 563          * holder, usually because of phis, so make sure that the type is related to the declared
 564          * type before using it for lookup. Unlinked types should also be ignored because we can&#39;t
 565          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 566          * a deopt instead since they can&#39;t really be used if they aren&#39;t linked yet.
 567          */
 568         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
<span class="line-added"> 569             if (hmethod.canBeStaticallyBound()) {</span>
<span class="line-added"> 570                 // No assumptions are required.</span>
<span class="line-added"> 571                 return new AssumptionResult&lt;&gt;(hmethod);</span>
<span class="line-added"> 572             }</span>
 573             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 574             if (result != null) {
 575                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 576             }
 577             return null;
 578         }
 579         /*
 580          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 581          * the correct method for the subtype.
 582          */
 583         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 584         if (resolvedMethod == null) {
 585             // The type isn&#39;t known to implement the method.
 586             return null;
 587         }
<span class="line-added"> 588         if (resolvedMethod.canBeStaticallyBound()) {</span>
<span class="line-added"> 589             // No assumptions are required.</span>
<span class="line-added"> 590             return new AssumptionResult&lt;&gt;(resolvedMethod);</span>
<span class="line-added"> 591         }</span>
 592 
 593         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 594         if (result != null) {
 595             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 596         }
 597         return null;
 598     }
 599 
 600     FieldInfo createFieldInfo(int index) {
 601         return new FieldInfo(index);
 602     }
 603 
<span class="line-added"> 604     public void ensureInitialized() {</span>
<span class="line-added"> 605         runtime().compilerToVm.ensureInitialized(this);</span>
<span class="line-added"> 606     }</span>
<span class="line-added"> 607 </span>
<span class="line-added"> 608     @Override</span>
<span class="line-added"> 609     public boolean equals(Object obj) {</span>
<span class="line-added"> 610         if (obj == this) {</span>
<span class="line-added"> 611             return true;</span>
<span class="line-added"> 612         }</span>
<span class="line-added"> 613         if (!(obj instanceof HotSpotResolvedObjectTypeImpl)) {</span>
<span class="line-added"> 614             return false;</span>
<span class="line-added"> 615         }</span>
<span class="line-added"> 616         HotSpotResolvedObjectTypeImpl that = (HotSpotResolvedObjectTypeImpl) obj;</span>
<span class="line-added"> 617         return getMetaspaceKlass() == that.getMetaspaceKlass();</span>
<span class="line-added"> 618     }</span>
<span class="line-added"> 619 </span>
<span class="line-added"> 620     @Override</span>
<span class="line-added"> 621     JavaConstant getJavaMirror() {</span>
<span class="line-added"> 622         return mirror;</span>
<span class="line-added"> 623     }</span>
<span class="line-added"> 624 </span>
 625     /**
 626      * This class represents the field information for one field contained in the fields array of an
 627      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 628      */
 629     class FieldInfo {
 630         /**
 631          * Native pointer into the array of Java shorts.
 632          */
 633         private final long metaspaceData;
 634 
 635         /**
 636          * Creates a field info for the field in the fields array at index {@code index}.
 637          *
 638          * @param index index to the fields array
 639          */
 640         FieldInfo(int index) {
 641             HotSpotVMConfig config = config();
 642             // Get Klass::_fields
 643             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 644             assert config.fieldInfoFieldSlots == 6 : &quot;revisit the field parsing code&quot;;
</pre>
<hr />
<pre>
 694         }
 695 
 696         public JavaType getType() {
 697             String signature = getSignature();
 698             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 699         }
 700 
 701         private boolean isInternal() {
 702             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 703         }
 704 
 705         public boolean isStatic() {
 706             return Modifier.isStatic(getAccessFlags());
 707         }
 708 
 709         public boolean hasGenericSignature() {
 710             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 711         }
 712     }
 713 
<span class="line-added"> 714     static class SortByOffset implements Comparator&lt;ResolvedJavaField&gt; {</span>
<span class="line-added"> 715         public int compare(ResolvedJavaField a, ResolvedJavaField b) {</span>
<span class="line-added"> 716             return a.getOffset() - b.getOffset();</span>
<span class="line-added"> 717         }</span>
<span class="line-added"> 718     }</span>
<span class="line-added"> 719 </span>
 720     @Override
 721     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 722         if (instanceFields == null) {
 723             if (isArray() || isInterface()) {
 724                 instanceFields = NO_FIELDS;
 725             } else {
 726                 HotSpotResolvedJavaField[] prepend = NO_FIELDS;
 727                 if (getSuperclass() != null) {
 728                     prepend = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);
 729                 }
 730                 instanceFields = getFields(false, prepend);
 731             }
 732         }
 733         if (!includeSuperclasses &amp;&amp; getSuperclass() != null) {
 734             int superClassFieldCount = getSuperclass().getInstanceFields(true).length;
 735             if (superClassFieldCount == instanceFields.length) {
 736                 // This class does not have any instance fields of its own.
 737                 return NO_FIELDS;
 738             } else if (superClassFieldCount != 0) {
<span class="line-added"> 739                 // Fields of the current class can be interleaved with fields of its super-classes</span>
<span class="line-added"> 740                 // but the array of fields to be returned must be sorted by increasing offset</span>
<span class="line-added"> 741                 // This code populates the array, then applies the sorting function</span>
 742                 HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[instanceFields.length - superClassFieldCount];
<span class="line-modified"> 743                 int i = 0;</span>
<span class="line-added"> 744                 for (HotSpotResolvedJavaField f : instanceFields) {</span>
<span class="line-added"> 745                     if (f.getDeclaringClass() == this) {</span>
<span class="line-added"> 746                         result[i++] = f;</span>
<span class="line-added"> 747                     }</span>
<span class="line-added"> 748                 }</span>
<span class="line-added"> 749                 Arrays.sort(result, fieldSortingMethod);</span>
 750                 return result;
 751             } else {
 752                 // The super classes of this class do not have any instance fields.
 753             }
 754         }
 755         return instanceFields;
 756     }
 757 
 758     @Override
 759     public ResolvedJavaField[] getStaticFields() {
 760         if (isArray()) {
 761             return new HotSpotResolvedJavaField[0];
 762         } else {
 763             return getFields(true, NO_FIELDS);
 764         }
 765     }
 766 
 767     /**
 768      * Gets the instance or static fields of this class.
 769      *
</pre>
<hr />
<pre>
 782                 metaspaceFieldsLength--;
 783             }
 784 
 785             if (field.isStatic() == retrieveStaticFields) {
 786                 resultCount++;
 787             }
 788         }
 789 
 790         if (resultCount == 0) {
 791             return prepend;
 792         }
 793 
 794         int prependLength = prepend.length;
 795         resultCount += prependLength;
 796 
 797         HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[resultCount];
 798         if (prependLength != 0) {
 799             System.arraycopy(prepend, 0, result, 0, prependLength);
 800         }
 801 
<span class="line-added"> 802         // Fields of the current class can be interleaved with fields of its super-classes</span>
<span class="line-added"> 803         // but the array of fields to be returned must be sorted by increasing offset</span>
<span class="line-added"> 804         // This code populates the array, then applies the sorting function</span>
 805         int resultIndex = prependLength;
 806         for (int i = 0; i &lt; index; ++i) {
 807             FieldInfo field = new FieldInfo(i);
 808             if (field.isStatic() == retrieveStaticFields) {
 809                 int offset = field.getOffset();
 810                 HotSpotResolvedJavaField resolvedJavaField = createField(field.getType(), offset, field.getAccessFlags(), i);
<span class="line-modified"> 811                 result[resultIndex++] = resolvedJavaField;</span>







 812             }
 813         }
<span class="line-modified"> 814         Arrays.sort(result, fieldSortingMethod);</span>
 815         return result;
 816     }
 817 





 818     @Override
 819     public String getSourceFileName() {
 820         HotSpotVMConfig config = config();
 821         final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassSourceFileNameIndexOffset);
 822         if (sourceFileNameIndex == 0) {
 823             return null;
 824         }
 825         return getConstantPool().lookupUtf8(sourceFileNameIndex);
 826     }
 827 
 828     @Override
 829     public Annotation[] getAnnotations() {
<span class="line-modified"> 830         return runtime().reflection.getAnnotations(this);</span>
 831     }
 832 
 833     @Override
 834     public Annotation[] getDeclaredAnnotations() {
<span class="line-modified"> 835         return runtime().reflection.getDeclaredAnnotations(this);</span>
 836     }
 837 
 838     @Override
 839     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<span class="line-modified"> 840         return runtime().reflection.getAnnotation(this, annotationClass);</span>
 841     }
 842 
 843     /**
 844      * Performs a fast-path check that this type is resolved in the context of a given accessing
 845      * class. A negative result does not mean this type is not resolved with respect to
 846      * {@code accessingClass}. That can only be determined by
 847      * {@linkplain HotSpotJVMCIRuntime#lookupType(String, HotSpotResolvedObjectType, boolean)
 848      * re-resolving} the type.
 849      */
 850     @Override
 851     public boolean isDefinitelyResolvedWithRespectTo(ResolvedJavaType accessingClass) {
 852         assert accessingClass != null;
 853         ResolvedJavaType elementType = getElementalType();
 854         if (elementType.isPrimitive()) {
 855             // Primitive type resolution is context free.
 856             return true;
 857         }
<span class="line-modified"> 858         if (elementType.getName().startsWith(&quot;Ljava/&quot;) &amp;&amp; hasSameClassLoader(runtime().getJavaLangObject())) {</span>
<span class="line-modified"> 859             // Classes in a java.* package defined by the boot class loader are always resolved.</span>

 860             return true;
 861         }
<span class="line-modified"> 862         HotSpotResolvedObjectTypeImpl otherMirror = ((HotSpotResolvedObjectTypeImpl) accessingClass);</span>
<span class="line-modified"> 863         return hasSameClassLoader(otherMirror);</span>
<span class="line-modified"> 864     }</span>
<span class="line-added"> 865 </span>
<span class="line-added"> 866     private boolean hasSameClassLoader(HotSpotResolvedObjectTypeImpl otherMirror) {</span>
<span class="line-added"> 867         return UnsafeAccess.UNSAFE.getAddress(getMetaspaceKlass() + config().classLoaderDataOffset) == UnsafeAccess.UNSAFE.getAddress(</span>
<span class="line-added"> 868                         otherMirror.getMetaspaceKlass() + config().classLoaderDataOffset);</span>
 869     }
 870 
 871     @Override
 872     public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
 873         if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
 874             return this;
 875         }
 876         HotSpotResolvedObjectTypeImpl accessingType = (HotSpotResolvedObjectTypeImpl) accessingClass;
 877         return (ResolvedJavaType) runtime().lookupType(getName(), accessingType, true);
 878     }
 879 
 880     /**
 881      * Gets the metaspace Klass boxed in a {@link JavaConstant}.
 882      */
 883     @Override
 884     public Constant klass() {
 885         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
 886     }
 887 
 888     @Override
</pre>
<hr />
<pre>
 902         if (isArray()) {
 903             return config.arrayPrototypeMarkWord();
 904         } else {
 905             return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);
 906         }
 907     }
 908 
 909     @Override
 910     public ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 911         ResolvedJavaField[] declaredFields = getInstanceFields(true);
 912         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
 913     }
 914 
 915     public ResolvedJavaField findStaticFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 916         ResolvedJavaField[] declaredFields = getStaticFields();
 917         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
 918     }
 919 
 920     private static ResolvedJavaField findFieldWithOffset(long offset, JavaKind expectedEntryKind, ResolvedJavaField[] declaredFields) {
 921         for (ResolvedJavaField field : declaredFields) {
<span class="line-modified"> 922             long resolvedFieldOffset = field.getOffset();</span>

 923             // @formatter:off
<span class="line-modified"> 924             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN &amp;&amp;</span>
<span class="line-modified"> 925                     expectedEntryKind.isPrimitive() &amp;&amp;</span>
<span class="line-modified"> 926                     !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;</span>
<span class="line-modified"> 927                     field.getJavaKind().isPrimitive()) {</span>
 928                 resolvedFieldOffset +=
<span class="line-modified"> 929                         field.getJavaKind().getByteCount() -</span>
<span class="line-modified"> 930                                 Math.min(field.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());</span>
 931             }
 932             if (resolvedFieldOffset == offset) {
 933                 return field;
 934             }
 935             // @formatter:on
 936         }
 937         return null;
 938     }
 939 
 940     @Override
 941     public boolean isLocal() {
<span class="line-modified"> 942         return runtime().reflection.isLocalClass(this);</span>
 943     }
 944 
 945     @Override
 946     public boolean isMember() {
<span class="line-modified"> 947         return runtime().reflection.isMemberClass(this);</span>
 948     }
 949 
 950     @Override
<span class="line-modified"> 951     public HotSpotResolvedObjectType getEnclosingType() {</span>
<span class="line-modified"> 952         return runtime().reflection.getEnclosingClass(this);</span>

 953     }
 954 
 955     @Override
 956     public ResolvedJavaMethod[] getDeclaredConstructors() {
<span class="line-modified"> 957         return runtime().compilerToVm.getDeclaredConstructors(this);</span>






 958     }
 959 
 960     @Override
 961     public ResolvedJavaMethod[] getDeclaredMethods() {
<span class="line-modified"> 962         return runtime().compilerToVm.getDeclaredMethods(this);</span>






 963     }
 964 
 965     @Override
 966     public ResolvedJavaMethod getClassInitializer() {
 967         if (!isArray()) {
 968             return compilerToVM().getClassInitializer(this);
 969         }
 970         return null;
 971     }
 972 
 973     @Override
 974     public String toString() {
 975         return &quot;HotSpotType&lt;&quot; + getName() + &quot;, resolved&gt;&quot;;
 976     }
 977 
 978     @Override
 979     public ResolvedJavaType lookupType(UnresolvedJavaType unresolvedJavaType, boolean resolve) {
 980         JavaType javaType = HotSpotJVMCIRuntime.runtime().lookupType(unresolvedJavaType.getName(), this, resolve);
 981         if (javaType instanceof ResolvedJavaType) {
 982             return (ResolvedJavaType) javaType;
</pre>
<hr />
<pre>
 987     @Override
 988     public ResolvedJavaField resolveField(UnresolvedJavaField unresolvedJavaField, ResolvedJavaType accessingClass) {
 989         for (ResolvedJavaField field : getInstanceFields(false)) {
 990             if (field.getName().equals(unresolvedJavaField.getName())) {
 991                 return field;
 992             }
 993         }
 994         for (ResolvedJavaField field : getStaticFields()) {
 995             if (field.getName().equals(unresolvedJavaField.getName())) {
 996                 return field;
 997             }
 998         }
 999         throw new InternalError(unresolvedJavaField.toString());
1000     }
1001 
1002     @Override
1003     public boolean isCloneableWithAllocation() {
1004         return (getAccessFlags() &amp; config().jvmAccIsCloneableFast) != 0;
1005     }
1006 
<span class="line-added">1007     JavaConstant readFieldValue(HotSpotResolvedJavaField field, boolean isVolatile) {</span>
<span class="line-added">1008         return runtime().reflection.readFieldValue(this, field, isVolatile);</span>
<span class="line-added">1009     }</span>
<span class="line-added">1010 </span>
1011     private int getMiscFlags() {
1012         return UNSAFE.getInt(getMetaspaceKlass() + config().instanceKlassMiscFlagsOffset);
1013     }
1014 
1015     @Override
1016     public boolean isUnsafeAnonymous() {
1017         return (getMiscFlags() &amp; config().instanceKlassMiscIsUnsafeAnonymous) != 0;
1018     }
1019 
1020 }
</pre>
</td>
</tr>
</table>
<center><a href="HotSpotResolvedJavaType.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotResolvedPrimitiveType.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaFieldImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotObjectConstantImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotResolvedJavaMethodImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaFieldImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
<span class="line-modified"> 25 import static jdk.internal.misc.Unsafe.ADDRESS_SIZE;</span>
<span class="line-removed"> 26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;</span>
<span class="line-removed"> 27 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmFieldModifiers;</span>
 28 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
 29 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;

 30 
 31 import java.lang.annotation.Annotation;
<span class="line-modified"> 32 import java.lang.reflect.Field;</span>
<span class="line-modified"> 33 import java.util.HashMap;</span>
 34 
 35 import jdk.vm.ci.meta.JavaConstant;
 36 import jdk.vm.ci.meta.JavaType;
 37 import jdk.vm.ci.meta.ResolvedJavaType;
 38 import jdk.vm.ci.meta.UnresolvedJavaType;
 39 
 40 /**
 41  * Represents a field in a HotSpot type.
 42  */
 43 class HotSpotResolvedJavaFieldImpl implements HotSpotResolvedJavaField {
 44 
 45     private final HotSpotResolvedObjectTypeImpl holder;
 46     private JavaType type;




 47     private final int offset;




 48     private final short index;
 49 
 50     /**
 51      * This value contains all flags as stored in the VM including internal ones.
 52      */
 53     private final int modifiers;
 54 
 55     HotSpotResolvedJavaFieldImpl(HotSpotResolvedObjectTypeImpl holder, JavaType type, long offset, int modifiers, int index) {
 56         this.holder = holder;
 57         this.type = type;
 58         this.index = (short) index;
 59         assert this.index == index;
 60         assert offset != -1;
 61         assert offset == (int) offset : &quot;offset larger than int&quot;;
 62         this.offset = (int) offset;
 63         this.modifiers = modifiers;
 64     }
 65 
 66     @Override
 67     public boolean equals(Object obj) {
 68         if (this == obj) {
 69             return true;
 70         }
<span class="line-modified"> 71         if (obj instanceof HotSpotResolvedJavaField) {</span>
 72             HotSpotResolvedJavaFieldImpl that = (HotSpotResolvedJavaFieldImpl) obj;
 73             if (that.offset != this.offset || that.isStatic() != this.isStatic()) {
 74                 return false;
 75             } else if (this.holder.equals(that.holder)) {
 76                 return true;
 77             }
 78         }
 79         return false;
 80     }
 81 
 82     @Override
 83     public int hashCode() {
 84         return holder.hashCode() ^ offset;
 85     }
 86 
 87     @Override
 88     public int getModifiers() {
<span class="line-modified"> 89         return modifiers &amp; jvmFieldModifiers();</span>
 90     }
 91 
 92     @Override
 93     public boolean isInternal() {
 94         return (modifiers &amp; config().jvmAccFieldInternal) != 0;
 95     }
 96 
 97     /**
 98      * Determines if a given object contains this field.
 99      *
100      * @return true iff this is a non-static field and its declaring class is assignable from
101      *         {@code object}&#39;s class
102      */
103     @Override
<span class="line-modified">104     public boolean isInObject(JavaConstant constant) {</span>
105         if (isStatic()) {
106             return false;
107         }
<span class="line-modified">108         Object object = ((HotSpotObjectConstantImpl) constant).object();</span>
<span class="line-modified">109         return getDeclaringClass().isAssignableFrom(HotSpotResolvedObjectTypeImpl.fromObjectClass(object.getClass()));</span>
110     }
111 
112     @Override
113     public HotSpotResolvedObjectTypeImpl getDeclaringClass() {
114         return holder;
115     }
116 
117     @Override
118     public String getName() {
119         return holder.createFieldInfo(index).getName();
120     }
121 
122     @Override
123     public JavaType getType() {
124         // Pull field into local variable to prevent a race causing
125         // a ClassCastException below
126         JavaType currentType = type;
127         if (currentType instanceof UnresolvedJavaType) {
128             // Don&#39;t allow unresolved types to hang around forever
129             UnresolvedJavaType unresolvedType = (UnresolvedJavaType) currentType;
<span class="line-modified">130             ResolvedJavaType resolved = holder.lookupType(unresolvedType, false);</span>
<span class="line-modified">131             if (resolved != null) {</span>
132                 type = resolved;
133             }
134         }
135         return type;

136     }
137 
138     @Override
139     public int getOffset() {
140         return offset;
141     }
142 








143     @Override
144     public String toString() {
<span class="line-modified">145         return format(&quot;HotSpotField&lt;%H.%n %t:&quot;) + offset + &quot;&gt;&quot;;</span>
146     }
147 
148     @Override
149     public boolean isSynthetic() {
150         return (config().jvmAccSynthetic &amp; modifiers) != 0;
151     }
152 
153     /**
<span class="line-modified">154      * Checks if this field has the {@code Stable} annotation.</span>
155      *
<span class="line-modified">156      * @return true if field has {@code Stable} annotation, false otherwise</span>
157      */
158     @Override
159     public boolean isStable() {
160         return (config().jvmAccFieldStable &amp; modifiers) != 0;
161     }
162 
163     private boolean hasAnnotations() {
164         if (!isInternal()) {
165             HotSpotVMConfig config = config();
166             final long metaspaceAnnotations = UNSAFE.getAddress(holder.getMetaspaceKlass() + config.instanceKlassAnnotationsOffset);
167             if (metaspaceAnnotations != 0) {
168                 long fieldsAnnotations = UNSAFE.getAddress(metaspaceAnnotations + config.annotationsFieldAnnotationsOffset);
169                 if (fieldsAnnotations != 0) {
170                     long fieldAnnotations = UNSAFE.getAddress(fieldsAnnotations + config.fieldsAnnotationsBaseOffset + (ADDRESS_SIZE * index));
171                     return fieldAnnotations != 0;
172                 }
173             }
174         }
175         return false;
176     }
177 
178     @Override
179     public Annotation[] getAnnotations() {
180         if (!hasAnnotations()) {
181             return new Annotation[0];
182         }
<span class="line-modified">183         return toJava().getAnnotations();</span>
184     }
185 
186     @Override
187     public Annotation[] getDeclaredAnnotations() {
188         if (!hasAnnotations()) {
189             return new Annotation[0];
190         }
<span class="line-modified">191         return toJava().getDeclaredAnnotations();</span>
192     }
193 
194     @Override
195     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
196         if (!hasAnnotations()) {
197             return null;
198         }
<span class="line-modified">199         return toJava().getAnnotation(annotationClass);</span>
<span class="line-removed">200     }</span>
<span class="line-removed">201 </span>
<span class="line-removed">202     /**</span>
<span class="line-removed">203      * Gets a {@link Field} object corresponding to this object. This method always returns the same</span>
<span class="line-removed">204      * {@link Field} object for a given {@link HotSpotResolvedJavaFieldImpl}. This ensures</span>
<span class="line-removed">205      * {@link #getDeclaredAnnotations()}, {@link #getAnnotations()} and</span>
<span class="line-removed">206      * {@link #getAnnotation(Class)} are stable with respect to the identity of the</span>
<span class="line-removed">207      * {@link Annotation} objects they return.</span>
<span class="line-removed">208      */</span>
<span class="line-removed">209     private Field toJava() {</span>
<span class="line-removed">210         synchronized (holder) {</span>
<span class="line-removed">211             HashMap&lt;HotSpotResolvedJavaFieldImpl, Field&gt; cache = holder.reflectionFieldCache;</span>
<span class="line-removed">212             if (cache == null) {</span>
<span class="line-removed">213                 cache = new HashMap&lt;&gt;();</span>
<span class="line-removed">214                 holder.reflectionFieldCache = cache;</span>
<span class="line-removed">215             }</span>
<span class="line-removed">216             Field reflect = cache.get(this);</span>
<span class="line-removed">217             if (reflect == null) {</span>
<span class="line-removed">218                 reflect = compilerToVM().asReflectionField(holder, index);</span>
<span class="line-removed">219                 cache.put(this, reflect);</span>
<span class="line-removed">220             }</span>
<span class="line-removed">221             return reflect;</span>
<span class="line-removed">222         }</span>
223     }
224 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
<span class="line-modified"> 25 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;</span>


 26 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
 27 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
<span class="line-added"> 28 import static jdk.internal.misc.Unsafe.ADDRESS_SIZE;</span>
 29 
 30 import java.lang.annotation.Annotation;
<span class="line-modified"> 31 </span>
<span class="line-modified"> 32 import jdk.internal.vm.annotation.Stable;</span>
 33 
 34 import jdk.vm.ci.meta.JavaConstant;
 35 import jdk.vm.ci.meta.JavaType;
 36 import jdk.vm.ci.meta.ResolvedJavaType;
 37 import jdk.vm.ci.meta.UnresolvedJavaType;
 38 
 39 /**
 40  * Represents a field in a HotSpot type.
 41  */
 42 class HotSpotResolvedJavaFieldImpl implements HotSpotResolvedJavaField {
 43 
 44     private final HotSpotResolvedObjectTypeImpl holder;
 45     private JavaType type;
<span class="line-added"> 46 </span>
<span class="line-added"> 47     /**</span>
<span class="line-added"> 48      * Value of {@code fieldDescriptor::access_flags()}.</span>
<span class="line-added"> 49      */</span>
 50     private final int offset;
<span class="line-added"> 51 </span>
<span class="line-added"> 52     /**</span>
<span class="line-added"> 53      * Value of {@code fieldDescriptor::index()}.</span>
<span class="line-added"> 54      */</span>
 55     private final short index;
 56 
 57     /**
 58      * This value contains all flags as stored in the VM including internal ones.
 59      */
 60     private final int modifiers;
 61 
 62     HotSpotResolvedJavaFieldImpl(HotSpotResolvedObjectTypeImpl holder, JavaType type, long offset, int modifiers, int index) {
 63         this.holder = holder;
 64         this.type = type;
 65         this.index = (short) index;
 66         assert this.index == index;
 67         assert offset != -1;
 68         assert offset == (int) offset : &quot;offset larger than int&quot;;
 69         this.offset = (int) offset;
 70         this.modifiers = modifiers;
 71     }
 72 
 73     @Override
 74     public boolean equals(Object obj) {
 75         if (this == obj) {
 76             return true;
 77         }
<span class="line-modified"> 78         if (obj instanceof HotSpotResolvedJavaFieldImpl) {</span>
 79             HotSpotResolvedJavaFieldImpl that = (HotSpotResolvedJavaFieldImpl) obj;
 80             if (that.offset != this.offset || that.isStatic() != this.isStatic()) {
 81                 return false;
 82             } else if (this.holder.equals(that.holder)) {
 83                 return true;
 84             }
 85         }
 86         return false;
 87     }
 88 
 89     @Override
 90     public int hashCode() {
 91         return holder.hashCode() ^ offset;
 92     }
 93 
 94     @Override
 95     public int getModifiers() {
<span class="line-modified"> 96         return modifiers &amp; HotSpotModifiers.jvmFieldModifiers();</span>
 97     }
 98 
 99     @Override
100     public boolean isInternal() {
101         return (modifiers &amp; config().jvmAccFieldInternal) != 0;
102     }
103 
104     /**
105      * Determines if a given object contains this field.
106      *
107      * @return true iff this is a non-static field and its declaring class is assignable from
108      *         {@code object}&#39;s class
109      */
110     @Override
<span class="line-modified">111     public boolean isInObject(JavaConstant object) {</span>
112         if (isStatic()) {
113             return false;
114         }
<span class="line-modified">115         HotSpotObjectConstant constant = (HotSpotObjectConstant) object;</span>
<span class="line-modified">116         return getDeclaringClass().isAssignableFrom(constant.getType());</span>
117     }
118 
119     @Override
120     public HotSpotResolvedObjectTypeImpl getDeclaringClass() {
121         return holder;
122     }
123 
124     @Override
125     public String getName() {
126         return holder.createFieldInfo(index).getName();
127     }
128 
129     @Override
130     public JavaType getType() {
131         // Pull field into local variable to prevent a race causing
132         // a ClassCastException below
133         JavaType currentType = type;
134         if (currentType instanceof UnresolvedJavaType) {
135             // Don&#39;t allow unresolved types to hang around forever
136             UnresolvedJavaType unresolvedType = (UnresolvedJavaType) currentType;
<span class="line-modified">137             JavaType resolved = HotSpotJVMCIRuntime.runtime().lookupType(unresolvedType.getName(), holder, false);</span>
<span class="line-modified">138             if (resolved instanceof ResolvedJavaType) {</span>
139                 type = resolved;
140             }
141         }
142         return type;
<span class="line-added">143 </span>
144     }
145 
146     @Override
147     public int getOffset() {
148         return offset;
149     }
150 
<span class="line-added">151     /**</span>
<span class="line-added">152      * Gets the value of this field&#39;s index (i.e. {@code fieldDescriptor::index()} in the encoded</span>
<span class="line-added">153      * fields of the declaring class.</span>
<span class="line-added">154      */</span>
<span class="line-added">155     int getIndex() {</span>
<span class="line-added">156         return index;</span>
<span class="line-added">157     }</span>
<span class="line-added">158 </span>
159     @Override
160     public String toString() {
<span class="line-modified">161         return format(&quot;HotSpotResolvedJavaFieldImpl&lt;%H.%n %t:&quot;) + offset + &quot;&gt;&quot;;</span>
162     }
163 
164     @Override
165     public boolean isSynthetic() {
166         return (config().jvmAccSynthetic &amp; modifiers) != 0;
167     }
168 
169     /**
<span class="line-modified">170      * Checks if this field has the {@link Stable} annotation.</span>
171      *
<span class="line-modified">172      * @return true if field has {@link Stable} annotation, false otherwise</span>
173      */
174     @Override
175     public boolean isStable() {
176         return (config().jvmAccFieldStable &amp; modifiers) != 0;
177     }
178 
179     private boolean hasAnnotations() {
180         if (!isInternal()) {
181             HotSpotVMConfig config = config();
182             final long metaspaceAnnotations = UNSAFE.getAddress(holder.getMetaspaceKlass() + config.instanceKlassAnnotationsOffset);
183             if (metaspaceAnnotations != 0) {
184                 long fieldsAnnotations = UNSAFE.getAddress(metaspaceAnnotations + config.annotationsFieldAnnotationsOffset);
185                 if (fieldsAnnotations != 0) {
186                     long fieldAnnotations = UNSAFE.getAddress(fieldsAnnotations + config.fieldsAnnotationsBaseOffset + (ADDRESS_SIZE * index));
187                     return fieldAnnotations != 0;
188                 }
189             }
190         }
191         return false;
192     }
193 
194     @Override
195     public Annotation[] getAnnotations() {
196         if (!hasAnnotations()) {
197             return new Annotation[0];
198         }
<span class="line-modified">199         return runtime().reflection.getFieldAnnotations(this);</span>
200     }
201 
202     @Override
203     public Annotation[] getDeclaredAnnotations() {
204         if (!hasAnnotations()) {
205             return new Annotation[0];
206         }
<span class="line-modified">207         return runtime().reflection.getFieldDeclaredAnnotations(this);</span>
208     }
209 
210     @Override
211     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
212         if (!hasAnnotations()) {
213             return null;
214         }
<span class="line-modified">215         return runtime().reflection.getFieldAnnotation(this, annotationClass);</span>























216     }
217 }
</pre>
</td>
</tr>
</table>
<center><a href="HotSpotObjectConstantImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotResolvedJavaMethodImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
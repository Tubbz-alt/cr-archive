<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotSpeculationLog.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2014, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import java.util.HashMap;
 26 import java.util.HashSet;
 27 import java.util.Map;
 28 import java.util.Set;
 29 
 30 import jdk.vm.ci.meta.JavaConstant;
 31 import jdk.vm.ci.meta.SpeculationLog;
 32 
 33 public class HotSpotSpeculationLog implements SpeculationLog {
 34     public static final class HotSpotSpeculation extends Speculation {
 35         private JavaConstant encoding;
 36 
 37         HotSpotSpeculation(SpeculationReason reason, JavaConstant encoding) {
 38             super(reason);
 39             this.encoding = encoding;
 40         }
 41 
 42         public JavaConstant getEncoding() {
 43             return encoding;
 44         }
 45     }
 46 
 47     /** Written by the C++ code that performs deoptimization. */
 48     private volatile long lastFailed;
 49 
 50     /** All speculations that have caused a deoptimization. */
 51     private Set&lt;SpeculationReason&gt; failedSpeculations;
 52 
 53     /** Strong references to all reasons embedded in the current nmethod. */
 54     private HashMap&lt;SpeculationReason, JavaConstant&gt; speculations;
 55 
 56     private long currentSpeculationID;
 57 
 58     @Override
 59     public synchronized void collectFailedSpeculations() {
 60         if (lastFailed != 0) {
 61             if (failedSpeculations == null) {
 62                 failedSpeculations = new HashSet&lt;&gt;(2);
 63             }
 64             if (speculations != null) {
 65                 SpeculationReason lastFailedSpeculation = lookupSpeculation(this.lastFailed);
 66                 if (lastFailedSpeculation != null) {
 67                     failedSpeculations.add(lastFailedSpeculation);
 68                 }
 69                 lastFailed = 0;
 70                 speculations = null;
 71             }
 72         }
 73     }
 74 
 75     private SpeculationReason lookupSpeculation(long value) {
 76         for (Map.Entry&lt;SpeculationReason, JavaConstant&gt; entry : speculations.entrySet()) {
 77             if (value == entry.getValue().asLong()) {
 78                 return entry.getKey();
 79             }
 80         }
 81         return null;
 82     }
 83 
 84     @Override
 85     public synchronized boolean maySpeculate(SpeculationReason reason) {
 86         if (failedSpeculations != null &amp;&amp; failedSpeculations.contains(reason)) {
 87             return false;
 88         }
 89         return true;
 90     }
 91 
 92     @Override
 93     public synchronized Speculation speculate(SpeculationReason reason) {
 94         if (speculations == null) {
 95             speculations = new HashMap&lt;&gt;();
 96         }
 97         JavaConstant id = speculations.get(reason);
 98         if (id == null) {
 99             id = JavaConstant.forLong(++currentSpeculationID);
100             speculations.put(reason, id);
101         }
102         return new HotSpotSpeculation(reason, id);
103     }
104 
105     @Override
106     public synchronized boolean hasSpeculations() {
107         return speculations != null &amp;&amp; !speculations.isEmpty();
108     }
109 
110     @Override
111     public synchronized Speculation lookupSpeculation(JavaConstant constant) {
112         if (constant.isDefaultForKind()) {
113             return NO_SPECULATION;
114         }
115         SpeculationReason reason = lookupSpeculation(constant.asLong());
116         assert reason != null : &quot;Speculation should have been registered&quot;;
117         return new HotSpotSpeculation(reason, constant);
118     }
119 }
    </pre>
  </body>
</html>
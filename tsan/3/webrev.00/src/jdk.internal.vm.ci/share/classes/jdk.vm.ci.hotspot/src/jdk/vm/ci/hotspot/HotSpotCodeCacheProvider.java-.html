<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotCodeCacheProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import java.util.Map;
 26 
 27 import jdk.vm.ci.code.BailoutException;
 28 import jdk.vm.ci.code.BytecodeFrame;
 29 import jdk.vm.ci.code.CodeCacheProvider;
 30 import jdk.vm.ci.code.CompiledCode;
 31 import jdk.vm.ci.code.InstalledCode;
 32 import jdk.vm.ci.code.RegisterConfig;
 33 import jdk.vm.ci.code.TargetDescription;
 34 import jdk.vm.ci.code.site.Call;
 35 import jdk.vm.ci.code.site.Mark;
 36 import jdk.vm.ci.meta.ResolvedJavaMethod;
 37 import jdk.vm.ci.meta.SpeculationLog;
 38 
 39 /**
 40  * HotSpot implementation of {@link CodeCacheProvider}.
 41  */
 42 public class HotSpotCodeCacheProvider implements CodeCacheProvider {
 43 
 44     protected final HotSpotJVMCIRuntime runtime;
 45     private final HotSpotVMConfig config;
 46     protected final TargetDescription target;
 47     protected final RegisterConfig regConfig;
 48 
 49     public HotSpotCodeCacheProvider(HotSpotJVMCIRuntime runtime, TargetDescription target, RegisterConfig regConfig) {
 50         this.runtime = runtime;
 51         this.config = runtime.getConfig();
 52         this.target = target;
 53         this.regConfig = regConfig;
 54     }
 55 
 56     @Override
 57     public String getMarkName(Mark mark) {
 58         int markId = (int) mark.id;
 59         HotSpotVMConfigStore store = runtime.getConfigStore();
 60         for (Map.Entry&lt;String, Long&gt; e : store.getConstants().entrySet()) {
 61             String name = e.getKey();
 62             if (name.startsWith(&quot;MARKID_&quot;) &amp;&amp; e.getValue() == markId) {
 63                 return name;
 64             }
 65         }
 66         return CodeCacheProvider.super.getMarkName(mark);
 67     }
 68 
 69     /**
 70      * Decodes a call target to a mnemonic if possible.
 71      */
 72     @Override
 73     public String getTargetName(Call call) {
 74         if (call.target instanceof HotSpotForeignCallTarget) {
 75             long address = ((HotSpotForeignCallTarget) call.target).address;
 76             HotSpotVMConfigStore store = runtime.getConfigStore();
 77             for (Map.Entry&lt;String, VMField&gt; e : store.getFields().entrySet()) {
 78                 VMField field = e.getValue();
 79                 if (field.isStatic() &amp;&amp; field.value != null &amp;&amp; field.value instanceof Long &amp;&amp; ((Long) field.value) == address) {
 80                     return e.getValue() + &quot;:0x&quot; + Long.toHexString(address);
 81                 }
 82             }
 83         }
 84         return CodeCacheProvider.super.getTargetName(call);
 85     }
 86 
 87     @Override
 88     public RegisterConfig getRegisterConfig() {
 89         return regConfig;
 90     }
 91 
 92     @Override
 93     public int getMinimumOutgoingSize() {
 94         return config.runtimeCallStackSize;
 95     }
 96 
 97     private InstalledCode logOrDump(InstalledCode installedCode, CompiledCode compiledCode) {
 98         runtime.notifyInstall(this, installedCode, compiledCode);
 99         return installedCode;
100     }
101 
102     @Override
103     public InstalledCode installCode(ResolvedJavaMethod method, CompiledCode compiledCode, InstalledCode installedCode, SpeculationLog log, boolean isDefault) {
104         InstalledCode resultInstalledCode;
105         if (installedCode == null) {
106             if (method == null) {
107                 // Must be a stub
108                 resultInstalledCode = new HotSpotRuntimeStub(((HotSpotCompiledCode) compiledCode).getName());
109             } else {
110                 resultInstalledCode = new HotSpotNmethod((HotSpotResolvedJavaMethod) method, ((HotSpotCompiledCode) compiledCode).getName(), isDefault);
111             }
112         } else {
113             resultInstalledCode = installedCode;
114         }
115 
116         HotSpotSpeculationLog speculationLog = (log != null &amp;&amp; log.hasSpeculations()) ? (HotSpotSpeculationLog) log : null;
117 
118         int result = runtime.getCompilerToVM().installCode(target, (HotSpotCompiledCode) compiledCode, resultInstalledCode, speculationLog);
119         if (result != config.codeInstallResultOk) {
120             String resultDesc = config.getCodeInstallResultDescription(result);
121             if (compiledCode instanceof HotSpotCompiledNmethod) {
122                 HotSpotCompiledNmethod compiledNmethod = (HotSpotCompiledNmethod) compiledCode;
123                 String msg = compiledNmethod.getInstallationFailureMessage();
124                 if (msg != null) {
125                     msg = String.format(&quot;Code installation failed: %s%n%s&quot;, resultDesc, msg);
126                 } else {
127                     msg = String.format(&quot;Code installation failed: %s&quot;, resultDesc);
128                 }
129                 if (result == config.codeInstallResultDependenciesInvalid) {
130                     throw new AssertionError(resultDesc + &quot; &quot; + msg);
131                 }
132                 throw new BailoutException(result != config.codeInstallResultDependenciesFailed, msg);
133             } else {
134                 throw new BailoutException(&quot;Error installing %s: %s&quot;, ((HotSpotCompiledCode) compiledCode).getName(), resultDesc);
135             }
136         }
137         return logOrDump(resultInstalledCode, compiledCode);
138     }
139 
140     @Override
141     public void invalidateInstalledCode(InstalledCode installedCode) {
142         runtime.getCompilerToVM().invalidateInstalledCode(installedCode);
143     }
144 
145     @Override
146     public TargetDescription getTarget() {
147         return target;
148     }
149 
150     public String disassemble(InstalledCode code) {
151         if (code.isValid()) {
152             return runtime.getCompilerToVM().disassembleCodeBlob(code);
153         }
154         return null;
155     }
156 
157     @Override
158     public SpeculationLog createSpeculationLog() {
159         return new HotSpotSpeculationLog();
160     }
161 
162     @Override
163     public long getMaxCallTargetOffset(long address) {
164         return runtime.getCompilerToVM().getMaxCallTargetOffset(address);
165     }
166 
167     @Override
168     public boolean shouldDebugNonSafepoints() {
169         return runtime.getCompilerToVM().shouldDebugNonSafepoints();
170     }
171 
172     public int interpreterFrameSize(BytecodeFrame pos) {
173         return runtime.getCompilerToVM().interpreterFrameSize(pos);
174     }
175 
176     /**
177      * Resets all compilation statistics.
178      */
179     public void resetCompilationStatistics() {
180         runtime.getCompilerToVM().resetCompilationStatistics();
181     }
182 }
    </pre>
  </body>
</html>
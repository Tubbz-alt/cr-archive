<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../jdk.vm.ci.hotspot.amd64/src/jdk/vm/ci/hotspot/amd64/AMD64HotSpotVMConfig.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotCodeCacheProvider.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/CompilerToVM.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 34,10 ***</span>
<span class="line-new-header">--- 34,14 ---</span>
  import jdk.vm.ci.code.InvalidInstalledCodeException;
  import jdk.vm.ci.code.TargetDescription;
  import jdk.vm.ci.code.stack.InspectedFrameVisitor;
  import jdk.vm.ci.common.InitTimer;
  import jdk.vm.ci.common.JVMCIError;
<span class="line-added">+ import jdk.vm.ci.meta.Constant;</span>
<span class="line-added">+ import jdk.vm.ci.meta.ConstantReflectionProvider;</span>
<span class="line-added">+ import jdk.vm.ci.meta.JavaConstant;</span>
<span class="line-added">+ import jdk.vm.ci.meta.JavaKind;</span>
  import jdk.vm.ci.meta.JavaType;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import jdk.vm.ci.meta.ResolvedJavaType;
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 49,21 ***</span>
      /**
       * Initializes the native part of the JVMCI runtime.
       */
      private static native void registerNatives();
  
<span class="line-modified">!     static {</span>
<span class="line-modified">!         initialize();</span>
<span class="line-modified">!     }</span>
  
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     private static void initialize() {</span>
          try (InitTimer t = timer(&quot;CompilerToVM.registerNatives&quot;)) {
              registerNatives();
          }
      }
  
      /**
       * Gets the {@link CompilerToVM} instance associated with the singleton
       * {@link HotSpotJVMCIRuntime} instance.
       */
      public static CompilerToVM compilerToVM() {
<span class="line-new-header">--- 53,64 ---</span>
      /**
       * Initializes the native part of the JVMCI runtime.
       */
      private static native void registerNatives();
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * These values mirror the equivalent values from {@code Unsafe} but are appropriate for the JVM</span>
<span class="line-modified">!      * being compiled against.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     // Checkstyle: stop</span>
<span class="line-added">+     final int ARRAY_BOOLEAN_BASE_OFFSET;</span>
<span class="line-added">+     final int ARRAY_BYTE_BASE_OFFSET;</span>
<span class="line-added">+     final int ARRAY_SHORT_BASE_OFFSET;</span>
<span class="line-added">+     final int ARRAY_CHAR_BASE_OFFSET;</span>
<span class="line-added">+     final int ARRAY_INT_BASE_OFFSET;</span>
<span class="line-added">+     final int ARRAY_LONG_BASE_OFFSET;</span>
<span class="line-added">+     final int ARRAY_FLOAT_BASE_OFFSET;</span>
<span class="line-added">+     final int ARRAY_DOUBLE_BASE_OFFSET;</span>
<span class="line-added">+     final int ARRAY_OBJECT_BASE_OFFSET;</span>
<span class="line-added">+     final int ARRAY_BOOLEAN_INDEX_SCALE;</span>
<span class="line-added">+     final int ARRAY_BYTE_INDEX_SCALE;</span>
<span class="line-added">+     final int ARRAY_SHORT_INDEX_SCALE;</span>
<span class="line-added">+     final int ARRAY_CHAR_INDEX_SCALE;</span>
<span class="line-added">+     final int ARRAY_INT_INDEX_SCALE;</span>
<span class="line-added">+     final int ARRAY_LONG_INDEX_SCALE;</span>
<span class="line-added">+     final int ARRAY_FLOAT_INDEX_SCALE;</span>
<span class="line-added">+     final int ARRAY_DOUBLE_INDEX_SCALE;</span>
<span class="line-added">+     final int ARRAY_OBJECT_INDEX_SCALE;</span>
<span class="line-added">+     // Checkstyle: resume</span>
  
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     CompilerToVM() {</span>
          try (InitTimer t = timer(&quot;CompilerToVM.registerNatives&quot;)) {
              registerNatives();
<span class="line-added">+             ARRAY_BOOLEAN_BASE_OFFSET = arrayBaseOffset(JavaKind.Boolean);</span>
<span class="line-added">+             ARRAY_BYTE_BASE_OFFSET = arrayBaseOffset(JavaKind.Byte);</span>
<span class="line-added">+             ARRAY_SHORT_BASE_OFFSET = arrayBaseOffset(JavaKind.Short);</span>
<span class="line-added">+             ARRAY_CHAR_BASE_OFFSET = arrayBaseOffset(JavaKind.Char);</span>
<span class="line-added">+             ARRAY_INT_BASE_OFFSET = arrayBaseOffset(JavaKind.Int);</span>
<span class="line-added">+             ARRAY_LONG_BASE_OFFSET = arrayBaseOffset(JavaKind.Long);</span>
<span class="line-added">+             ARRAY_FLOAT_BASE_OFFSET = arrayBaseOffset(JavaKind.Float);</span>
<span class="line-added">+             ARRAY_DOUBLE_BASE_OFFSET = arrayBaseOffset(JavaKind.Double);</span>
<span class="line-added">+             ARRAY_OBJECT_BASE_OFFSET = arrayBaseOffset(JavaKind.Object);</span>
<span class="line-added">+             ARRAY_BOOLEAN_INDEX_SCALE = arrayIndexScale(JavaKind.Boolean);</span>
<span class="line-added">+             ARRAY_BYTE_INDEX_SCALE = arrayIndexScale(JavaKind.Byte);</span>
<span class="line-added">+             ARRAY_SHORT_INDEX_SCALE = arrayIndexScale(JavaKind.Short);</span>
<span class="line-added">+             ARRAY_CHAR_INDEX_SCALE = arrayIndexScale(JavaKind.Char);</span>
<span class="line-added">+             ARRAY_INT_INDEX_SCALE = arrayIndexScale(JavaKind.Int);</span>
<span class="line-added">+             ARRAY_LONG_INDEX_SCALE = arrayIndexScale(JavaKind.Long);</span>
<span class="line-added">+             ARRAY_FLOAT_INDEX_SCALE = arrayIndexScale(JavaKind.Float);</span>
<span class="line-added">+             ARRAY_DOUBLE_INDEX_SCALE = arrayIndexScale(JavaKind.Double);</span>
<span class="line-added">+             ARRAY_OBJECT_INDEX_SCALE = arrayIndexScale(JavaKind.Object);</span>
          }
      }
  
<span class="line-added">+     native int arrayBaseOffset(JavaKind kind);</span>
<span class="line-added">+ </span>
<span class="line-added">+     native int arrayIndexScale(JavaKind kind);</span>
<span class="line-added">+ </span>
      /**
       * Gets the {@link CompilerToVM} instance associated with the singleton
       * {@link HotSpotJVMCIRuntime} instance.
       */
      public static CompilerToVM compilerToVM() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 150,35 ***</span>
  
      /**
       * Converts a name to a type.
       *
       * @param name a well formed Java type in {@linkplain JavaType#getName() internal} format
<span class="line-modified">!      * @param accessingClass the context of resolution (must not be null)</span>
       * @param resolve force resolution to a {@link ResolvedJavaType}. If true, this method will
       *            either return a {@link ResolvedJavaType} or throw an exception
       * @return the type for {@code name} or 0 if resolution failed and {@code resolve == false}
       * @throws ClassNotFoundException if {@code resolve == true} and the resolution failed
       */
<span class="line-modified">!     native HotSpotResolvedObjectTypeImpl lookupType(String name, Class&lt;?&gt; accessingClass, boolean resolve) throws ClassNotFoundException;</span>
  
<span class="line-modified">!     /**</span>
<span class="line-removed">-      * Resolves the entry at index {@code cpi} in {@code constantPool} to an object.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * The behavior of this method is undefined if {@code cpi} does not denote one of the following</span>
<span class="line-removed">-      * entry types: {@code JVM_CONSTANT_MethodHandle}, {@code JVM_CONSTANT_MethodHandleInError},</span>
<span class="line-removed">-      * {@code JVM_CONSTANT_MethodType} and {@code JVM_CONSTANT_MethodTypeInError}.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     native Object resolveConstantInPool(HotSpotConstantPool constantPool, int cpi);</span>
  
      /**
       * Resolves the entry at index {@code cpi} in {@code constantPool} to an object, looking in the
       * constant pool cache first.
       *
<span class="line-modified">!      * The behavior of this method is undefined if {@code cpi} does not denote a</span>
<span class="line-modified">!      * {@code JVM_CONSTANT_String} entry.</span>
       */
<span class="line-modified">!     native Object resolvePossiblyCachedConstantInPool(HotSpotConstantPool constantPool, int cpi);</span>
  
      /**
       * Gets the {@code JVM_CONSTANT_NameAndType} index from the entry at index {@code cpi} in
       * {@code constantPool}.
       *
<span class="line-new-header">--- 197,31 ---</span>
  
      /**
       * Converts a name to a type.
       *
       * @param name a well formed Java type in {@linkplain JavaType#getName() internal} format
<span class="line-modified">!      * @param accessingClass the context of resolution. A value of {@code null} implies that the</span>
<span class="line-added">+      *            class should be resolved with the class loader.</span>
       * @param resolve force resolution to a {@link ResolvedJavaType}. If true, this method will
       *            either return a {@link ResolvedJavaType} or throw an exception
       * @return the type for {@code name} or 0 if resolution failed and {@code resolve == false}
       * @throws ClassNotFoundException if {@code resolve == true} and the resolution failed
       */
<span class="line-modified">!     native HotSpotResolvedJavaType lookupType(String name, HotSpotResolvedObjectTypeImpl accessingClass, boolean resolve) throws ClassNotFoundException;</span>
  
<span class="line-modified">!     native HotSpotResolvedJavaType lookupClass(Class&lt;?&gt; javaClass);</span>
  
      /**
       * Resolves the entry at index {@code cpi} in {@code constantPool} to an object, looking in the
       * constant pool cache first.
       *
<span class="line-modified">!      * The behavior of this method is undefined if {@code cpi} does not denote one of the following</span>
<span class="line-modified">!      * entry types: {@code JVM_CONSTANT_String}, {@code JVM_CONSTANT_MethodHandle},</span>
<span class="line-added">+      * {@code JVM_CONSTANT_MethodHandleInError}, {@code JVM_CONSTANT_MethodType} and</span>
<span class="line-added">+      * {@code JVM_CONSTANT_MethodTypeInError}.</span>
       */
<span class="line-modified">!     native HotSpotObjectConstantImpl resolvePossiblyCachedConstantInPool(HotSpotConstantPool constantPool, int cpi);</span>
  
      /**
       * Gets the {@code JVM_CONSTANT_NameAndType} index from the entry at index {@code cpi} in
       * {@code constantPool}.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 316,28 ***</span>
  
      /**
       * Gets the appendix object (if any) associated with the entry at index {@code cpi} in
       * {@code constantPool}.
       */
<span class="line-modified">!     native Object lookupAppendixInPool(HotSpotConstantPool constantPool, int cpi);</span>
  
      /**
       * Installs the result of a compilation into the code cache.
       *
       * @param target the target where this code should be installed
       * @param compiledCode the result of a compilation
       * @param code the details of the installed CodeBlob are written to this object
       * @return the outcome of the installation which will be one of
       *         {@link HotSpotVMConfig#codeInstallResultOk},
       *         {@link HotSpotVMConfig#codeInstallResultCacheFull},
<span class="line-modified">!      *         {@link HotSpotVMConfig#codeInstallResultCodeTooLarge},</span>
<span class="line-modified">!      *         {@link HotSpotVMConfig#codeInstallResultDependenciesFailed} or</span>
<span class="line-removed">-      *         {@link HotSpotVMConfig#codeInstallResultDependenciesInvalid}.</span>
       * @throws JVMCIError if there is something wrong with the compiled code or the associated
       *             metadata.
       */
<span class="line-modified">!     native int installCode(TargetDescription target, HotSpotCompiledCode compiledCode, InstalledCode code, HotSpotSpeculationLog speculationLog);</span>
  
      /**
       * Generates the VM metadata for some compiled code and copies them into {@code metaData}. This
       * method does not install anything into the code cache.
       *
<span class="line-new-header">--- 359,27 ---</span>
  
      /**
       * Gets the appendix object (if any) associated with the entry at index {@code cpi} in
       * {@code constantPool}.
       */
<span class="line-modified">!     native HotSpotObjectConstantImpl lookupAppendixInPool(HotSpotConstantPool constantPool, int cpi);</span>
  
      /**
       * Installs the result of a compilation into the code cache.
       *
       * @param target the target where this code should be installed
       * @param compiledCode the result of a compilation
       * @param code the details of the installed CodeBlob are written to this object
       * @return the outcome of the installation which will be one of
       *         {@link HotSpotVMConfig#codeInstallResultOk},
       *         {@link HotSpotVMConfig#codeInstallResultCacheFull},
<span class="line-modified">!      *         {@link HotSpotVMConfig#codeInstallResultCodeTooLarge} or</span>
<span class="line-modified">!      *         {@link HotSpotVMConfig#codeInstallResultDependenciesFailed}.</span>
       * @throws JVMCIError if there is something wrong with the compiled code or the associated
       *             metadata.
       */
<span class="line-modified">!     native int installCode(TargetDescription target, HotSpotCompiledCode compiledCode, InstalledCode code, long failedSpeculationsAddress, byte[] speculations);</span>
  
      /**
       * Generates the VM metadata for some compiled code and copies them into {@code metaData}. This
       * method does not install anything into the code cache.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 345,13 ***</span>
       * @param compiledCode the result of a compilation
       * @param metaData the metadata is written to this object
       * @return the outcome of the installation which will be one of
       *         {@link HotSpotVMConfig#codeInstallResultOk},
       *         {@link HotSpotVMConfig#codeInstallResultCacheFull},
<span class="line-modified">!      *         {@link HotSpotVMConfig#codeInstallResultCodeTooLarge},</span>
<span class="line-modified">!      *         {@link HotSpotVMConfig#codeInstallResultDependenciesFailed} or</span>
<span class="line-removed">-      *         {@link HotSpotVMConfig#codeInstallResultDependenciesInvalid}.</span>
       * @throws JVMCIError if there is something wrong with the compiled code or the metadata
       */
      native int getMetadata(TargetDescription target, HotSpotCompiledCode compiledCode, HotSpotMetaData metaData);
  
      /**
<span class="line-new-header">--- 387,12 ---</span>
       * @param compiledCode the result of a compilation
       * @param metaData the metadata is written to this object
       * @return the outcome of the installation which will be one of
       *         {@link HotSpotVMConfig#codeInstallResultOk},
       *         {@link HotSpotVMConfig#codeInstallResultCacheFull},
<span class="line-modified">!      *         {@link HotSpotVMConfig#codeInstallResultCodeTooLarge} or</span>
<span class="line-modified">!      *         {@link HotSpotVMConfig#codeInstallResultDependenciesFailed}.</span>
       * @throws JVMCIError if there is something wrong with the compiled code or the metadata
       */
      native int getMetadata(TargetDescription target, HotSpotCompiledCode compiledCode, HotSpotMetaData metaData);
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 431,14 ***</span>
      native StackTraceElement getStackTraceElement(HotSpotResolvedJavaMethodImpl method, int bci);
  
      /**
       * Executes some {@code installedCode} with arguments {@code args}.
       *
<span class="line-modified">!      * @return the result of executing {@code installedCode}</span>
<span class="line-modified">!      * @throws InvalidInstalledCodeException if {@code installedCode} has been invalidated</span>
       */
<span class="line-modified">!     native Object executeInstalledCode(Object[] args, InstalledCode installedCode) throws InvalidInstalledCodeException;</span>
  
      /**
       * Gets the line number table for {@code method}. The line number table is encoded as (bci,
       * source line number) pairs.
       *
<span class="line-new-header">--- 472,14 ---</span>
      native StackTraceElement getStackTraceElement(HotSpotResolvedJavaMethodImpl method, int bci);
  
      /**
       * Executes some {@code installedCode} with arguments {@code args}.
       *
<span class="line-modified">!      * @return the result of executing {@code nmethodMirror}</span>
<span class="line-modified">!      * @throws InvalidInstalledCodeException if {@code nmethodMirror} has been invalidated</span>
       */
<span class="line-modified">!     native Object executeHotSpotNmethod(Object[] args, HotSpotNmethod nmethodMirror) throws InvalidInstalledCodeException;</span>
  
      /**
       * Gets the line number table for {@code method}. The line number table is encoded as (bci,
       * source line number) pairs.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 469,10 ***</span>
<span class="line-new-header">--- 510,23 ---</span>
       *
       * @return 0 if {@code method} does not have a local variable table
       */
      native long getLocalVariableTableStart(HotSpotResolvedJavaMethodImpl method);
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Reads an object pointer within a VM data structure. That is, any {@link VMField} whose</span>
<span class="line-added">+      * {@link VMField#type type} is {@code &quot;oop&quot;} (e.g., {@code Klass::_java_mirror},</span>
<span class="line-added">+      * {@code JavaThread::_threadObj}).</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Note that {@code Unsafe.getObject(Object, long)} cannot be used for this since it does a</span>
<span class="line-added">+      * {@code narrowOop} read if the VM is using compressed oops whereas oops within VM data</span>
<span class="line-added">+      * structures are (currently) always uncompressed.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param address address of an oop field within a VM data structure</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native HotSpotObjectConstantImpl readUncompressedOop(long address);</span>
<span class="line-added">+ </span>
      /**
       * Sets flags on {@code method} indicating that it should never be inlined or compiled by the
       * VM.
       */
      native void setNotInlinableOrCompilable(HotSpotResolvedJavaMethodImpl method);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 482,20 ***</span>
       * profiling restarts upon its next invocation.
       */
      native void reprofile(HotSpotResolvedJavaMethodImpl method);
  
      /**
<span class="line-modified">!      * Invalidates {@code installedCode} such that {@link InvalidInstalledCodeException} will be</span>
<span class="line-modified">!      * raised the next time {@code installedCode} is executed.</span>
       */
<span class="line-modified">!     native void invalidateInstalledCode(InstalledCode installedCode);</span>
  
      /**
       * Collects the current values of all JVMCI benchmark counters, summed up over all threads.
       */
      native long[] collectCounters();
  
      /**
       * Determines if {@code metaspaceMethodData} is mature.
       */
      native boolean isMature(long metaspaceMethodData);
  
<span class="line-new-header">--- 536,34 ---</span>
       * profiling restarts upon its next invocation.
       */
      native void reprofile(HotSpotResolvedJavaMethodImpl method);
  
      /**
<span class="line-modified">!      * Invalidates {@code nmethodMirror} such that {@link InvalidInstalledCodeException} will be</span>
<span class="line-modified">!      * raised the next time {@code nmethodMirror} is {@linkplain #executeHotSpotNmethod executed}.</span>
<span class="line-added">+      * The {@code nmethod} associated with {@code nmethodMirror} is also made non-entrant and any</span>
<span class="line-added">+      * current activations of the {@code nmethod} are deoptimized.</span>
       */
<span class="line-modified">!     native void invalidateHotSpotNmethod(HotSpotNmethod nmethodMirror);</span>
  
      /**
       * Collects the current values of all JVMCI benchmark counters, summed up over all threads.
       */
      native long[] collectCounters();
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Get the current number of counters allocated for use by JVMCI. Should be the same value as</span>
<span class="line-added">+      * the flag {@code JVMCICounterSize}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native int getCountersSize();</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Change the size of the counters allocated for JVMCI. This requires a safepoint to</span>
<span class="line-added">+      * safely reallocate the storage but it&#39;s advisable to increase the size in reasonable chunks.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native void setCountersSize(int newSize);</span>
<span class="line-added">+ </span>
      /**
       * Determines if {@code metaspaceMethodData} is mature.
       */
      native boolean isMature(long metaspaceMethodData);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 545,14 ***</span>
  
      /**
       * Writes {@code length} bytes from {@code bytes} starting at offset {@code offset} to HotSpot&#39;s
       * log stream.
       *
       * @throws NullPointerException if {@code bytes == null}
       * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
       */
<span class="line-modified">!     native void writeDebugOutput(byte[] bytes, int offset, int length);</span>
  
      /**
       * Flush HotSpot&#39;s log stream.
       */
      native void flushDebugOutput();
<span class="line-new-header">--- 613,19 ---</span>
  
      /**
       * Writes {@code length} bytes from {@code bytes} starting at offset {@code offset} to HotSpot&#39;s
       * log stream.
       *
<span class="line-added">+      * @param flush specifies if the log stream should be flushed after writing</span>
<span class="line-added">+      * @param canThrow specifies if an error in the {@code bytes}, {@code offset} or {@code length}</span>
<span class="line-added">+      *            arguments should result in an exception or a negative return value</span>
<span class="line-added">+      * @return 0 on success, -1 if {@code bytes == null &amp;&amp; !canThrow}, -2 if {@code !canThrow} and</span>
<span class="line-added">+      *         copying would cause access of data outside array bounds</span>
       * @throws NullPointerException if {@code bytes == null}
       * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
       */
<span class="line-modified">!     native int writeDebugOutput(byte[] bytes, int offset, int length, boolean flush, boolean canThrow);</span>
  
      /**
       * Flush HotSpot&#39;s log stream.
       */
      native void flushDebugOutput();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 570,11 ***</span>
       *
       * @param base an object to read from or null
       * @param displacement
       * @return null or the resolved method for this location
       */
<span class="line-modified">!     native HotSpotResolvedJavaMethodImpl getResolvedJavaMethod(Object base, long displacement);</span>
  
      /**
       * Gets the {@code ConstantPool*} associated with {@code object} and returns a
       * {@link HotSpotConstantPool} wrapping it.
       *
<span class="line-new-header">--- 643,11 ---</span>
       *
       * @param base an object to read from or null
       * @param displacement
       * @return null or the resolved method for this location
       */
<span class="line-modified">!     native HotSpotResolvedJavaMethodImpl getResolvedJavaMethod(HotSpotObjectConstantImpl base, long displacement);</span>
  
      /**
       * Gets the {@code ConstantPool*} associated with {@code object} and returns a
       * {@link HotSpotConstantPool} wrapping it.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 584,11 ***</span>
       *         {@code object}
       * @throws NullPointerException if {@code object == null}
       * @throws IllegalArgumentException if {@code object} is neither a
       *             {@link HotSpotResolvedJavaMethodImpl} nor a {@link HotSpotResolvedObjectTypeImpl}
       */
<span class="line-modified">!     native HotSpotConstantPool getConstantPool(Object object);</span>
  
      /**
       * Read a HotSpot Klass* value from the memory location described by {@code base} plus
       * {@code displacement} and return the {@link HotSpotResolvedObjectTypeImpl} wrapping it. This
       * method does no checking that the memory location actually contains a valid pointer and may
<span class="line-new-header">--- 657,11 ---</span>
       *         {@code object}
       * @throws NullPointerException if {@code object == null}
       * @throws IllegalArgumentException if {@code object} is neither a
       *             {@link HotSpotResolvedJavaMethodImpl} nor a {@link HotSpotResolvedObjectTypeImpl}
       */
<span class="line-modified">!     native HotSpotConstantPool getConstantPool(MetaspaceObject object);</span>
  
      /**
       * Read a HotSpot Klass* value from the memory location described by {@code base} plus
       * {@code displacement} and return the {@link HotSpotResolvedObjectTypeImpl} wrapping it. This
       * method does no checking that the memory location actually contains a valid pointer and may
</pre>
<hr />
<pre>
<span class="line-old-header">*** 602,11 ***</span>
       * @param base an object to read from or null
       * @param displacement
       * @param compressed true if the location contains a compressed Klass*
       * @return null or the resolved method for this location
       */
<span class="line-modified">!     native HotSpotResolvedObjectTypeImpl getResolvedJavaType(Object base, long displacement, boolean compressed);</span>
  
      /**
       * Return the size of the HotSpot ProfileData* pointed at by {@code position}. If
       * {@code position} is outside the space of the MethodData then an
       * {@link IllegalArgumentException} is thrown. A {@code position} inside the MethodData but that
<span class="line-new-header">--- 675,23 ---</span>
       * @param base an object to read from or null
       * @param displacement
       * @param compressed true if the location contains a compressed Klass*
       * @return null or the resolved method for this location
       */
<span class="line-modified">!     private native HotSpotResolvedObjectTypeImpl getResolvedJavaType0(Object base, long displacement, boolean compressed);</span>
<span class="line-added">+ </span>
<span class="line-added">+     HotSpotResolvedObjectTypeImpl getResolvedJavaType(MetaspaceObject base, long displacement, boolean compressed) {</span>
<span class="line-added">+         return getResolvedJavaType0(base, displacement, compressed);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     HotSpotResolvedObjectTypeImpl getResolvedJavaType(HotSpotObjectConstantImpl base, long displacement, boolean compressed) {</span>
<span class="line-added">+         return getResolvedJavaType0(base, displacement, compressed);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     HotSpotResolvedObjectTypeImpl getResolvedJavaType(long displacement, boolean compressed) {</span>
<span class="line-added">+         return getResolvedJavaType0(null, displacement, compressed);</span>
<span class="line-added">+     }</span>
  
      /**
       * Return the size of the HotSpot ProfileData* pointed at by {@code position}. If
       * {@code position} is outside the space of the MethodData then an
       * {@link IllegalArgumentException} is thrown. A {@code position} inside the MethodData but that
</pre>
<hr />
<pre>
<span class="line-old-header">*** 639,11 ***</span>
  
      /**
       * Invokes non-public method {@code java.lang.invoke.LambdaForm.compileToBytecode()} on
       * {@code lambdaForm} (which must be a {@code java.lang.invoke.LambdaForm} instance).
       */
<span class="line-modified">!     native void compileToBytecode(Object lambdaForm);</span>
  
      /**
       * Gets the value of the VM flag named {@code name}.
       *
       * @param name name of a VM option
<span class="line-new-header">--- 724,11 ---</span>
  
      /**
       * Invokes non-public method {@code java.lang.invoke.LambdaForm.compileToBytecode()} on
       * {@code lambdaForm} (which must be a {@code java.lang.invoke.LambdaForm} instance).
       */
<span class="line-modified">!     native void compileToBytecode(HotSpotObjectConstantImpl lambdaForm);</span>
  
      /**
       * Gets the value of the VM flag named {@code name}.
       *
       * @param name name of a VM option
</pre>
<hr />
<pre>
<span class="line-old-header">*** 657,10 ***</span>
<span class="line-new-header">--- 742,174 ---</span>
      /**
       * Gets the host class for {@code type}.
       */
      native HotSpotResolvedObjectTypeImpl getHostClass(HotSpotResolvedObjectTypeImpl type);
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Gets the object at the address {@code oopAddress}.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param oopAddress a valid {@code oopDesc**} value</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native Object getObjectAtAddress(long oopAddress);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see ResolvedJavaType#getInterfaces()</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native HotSpotResolvedObjectTypeImpl[] getInterfaces(HotSpotResolvedObjectTypeImpl type);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see ResolvedJavaType#getComponentType()</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native HotSpotResolvedJavaType getComponentType(HotSpotResolvedObjectTypeImpl type);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Get the array class for {@code type}. This can&#39;t be done symbolically since anonymous types</span>
<span class="line-added">+      * can&#39;t be looked up by name.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native HotSpotResolvedObjectTypeImpl getArrayType(HotSpotResolvedJavaType type);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Forces initialization of {@code type}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native void ensureInitialized(HotSpotResolvedObjectTypeImpl type);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Checks if {@code object} is a String and is an interned string value.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native boolean isInternedString(HotSpotObjectConstantImpl object);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Gets the {@linkplain System#identityHashCode(Object) identity} has code for the object</span>
<span class="line-added">+      * represented by this constant.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native int getIdentityHashCode(HotSpotObjectConstantImpl object);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Converts a constant object representing a boxed primitive into a boxed primitive.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native Object unboxPrimitive(HotSpotObjectConstantImpl object);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Converts a boxed primitive into a JavaConstant representing the same value.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native HotSpotObjectConstantImpl boxPrimitive(Object source);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Gets the {@link ResolvedJavaMethod}s for all the constructors of the type {@code holder}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native ResolvedJavaMethod[] getDeclaredConstructors(HotSpotResolvedObjectTypeImpl holder);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Gets the {@link ResolvedJavaMethod}s for all the non-constructor methods of the type</span>
<span class="line-added">+      * {@code holder}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native ResolvedJavaMethod[] getDeclaredMethods(HotSpotResolvedObjectTypeImpl holder);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Reads the current value of a static field.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native JavaConstant readFieldValue(HotSpotResolvedObjectTypeImpl resolvedObjectType, HotSpotResolvedJavaField field, boolean isVolatile);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Reads the current value of an instance field.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native JavaConstant readFieldValue(HotSpotObjectConstantImpl object, HotSpotResolvedJavaField field, boolean isVolatile);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see ResolvedJavaType#isInstance(JavaConstant)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native boolean isInstance(HotSpotResolvedObjectTypeImpl holder, HotSpotObjectConstantImpl object);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see ResolvedJavaType#isAssignableFrom(ResolvedJavaType)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native boolean isAssignableFrom(HotSpotResolvedObjectTypeImpl holder, HotSpotResolvedObjectTypeImpl otherType);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see ConstantReflectionProvider#asJavaType(Constant)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native HotSpotResolvedJavaType asJavaType(HotSpotObjectConstantImpl object);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Converts a String constant into a String.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native String asString(HotSpotObjectConstantImpl object);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Compares the contents of {@code xHandle} and {@code yHandle} for pointer equality.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native boolean equals(HotSpotObjectConstantImpl x, long xHandle, HotSpotObjectConstantImpl y, long yHandle);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Gets a {@link JavaConstant} wrapping the {@link java.lang.Class} mirror for {@code type}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native HotSpotObjectConstantImpl getJavaMirror(HotSpotResolvedJavaType type);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the length of the array if {@code object} represents an array or -1 otherwise.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native int getArrayLength(HotSpotObjectConstantImpl object);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Reads the element at {@code index} if {@code object} is an array. Elements of an object array</span>
<span class="line-added">+      * are returned as {@link JavaConstant}s and primitives are returned as boxed values. The value</span>
<span class="line-added">+      * {@code null} is returned if the {@code index} is out of range or object is not an array.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native Object readArrayElement(HotSpotObjectConstantImpl object, int index);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Reads a byte sized value from {@code displacement} in {@code object}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native byte getByte(HotSpotObjectConstantImpl object, long displacement);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Reads a short sized value from {@code displacement} in {@code object}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native short getShort(HotSpotObjectConstantImpl object, long displacement);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Reads an int sized value from {@code displacement} in {@code object}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native int getInt(HotSpotObjectConstantImpl object, long displacement);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Reads a long sized value from {@code displacement} in {@code object}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native long getLong(HotSpotObjectConstantImpl object, long displacement);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Reads a Java object from {@code displacement} in {@code object}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native HotSpotObjectConstantImpl getObject(HotSpotObjectConstantImpl object, long displacement);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see HotSpotJVMCIRuntime#registerNativeMethods</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native long[] registerNativeMethods(Class&lt;?&gt; clazz);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see HotSpotJVMCIRuntime#translate(Object)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native long translate(Object obj);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see HotSpotJVMCIRuntime#unhand(Class, long)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native Object unhand(long handle);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Updates {@code address} and {@code entryPoint} fields of {@code nmethodMirror} based on the</span>
<span class="line-added">+      * current state of the {@code nmethod} identified by {@code address} and</span>
<span class="line-added">+      * {@code nmethodMirror.compileId} in the code cache.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native void updateHotSpotNmethod(HotSpotNmethod nmethodMirror);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see InstalledCode#getCode()</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native byte[] getCode(HotSpotInstalledCode code);</span>
<span class="line-added">+ </span>
      /**
       * Gets a {@link Executable} corresponding to {@code method}.
       */
      native Executable asReflectionExecutable(HotSpotResolvedJavaMethodImpl method);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 669,6 ***</span>
<span class="line-new-header">--- 918,71 ---</span>
       *
       * @param holder the class in which the requested field is declared
       * @param fieldIndex the {@code fieldDescriptor::index()} denoting the field
       */
      native Field asReflectionField(HotSpotResolvedObjectTypeImpl holder, int fieldIndex);
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see HotSpotJVMCIRuntime#getIntrinsificationTrustPredicate(Class...)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native boolean isTrustedForIntrinsics(HotSpotResolvedObjectTypeImpl type);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Releases the resources backing the global JNI {@code handle}. This is equivalent to the</span>
<span class="line-added">+      * {@code DeleteGlobalRef} JNI function.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native void deleteGlobalHandle(long handle);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Gets the failed speculations pointed to by {@code *failedSpeculationsAddress}.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param currentFailures the known failures at {@code failedSpeculationsAddress}</span>
<span class="line-added">+      * @return the list of failed speculations with each entry being a single speculation in the</span>
<span class="line-added">+      *         format emitted by {@link HotSpotSpeculationEncoding#toByteArray()}</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native byte[][] getFailedSpeculations(long failedSpeculationsAddress, byte[][] currentFailures);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Gets the address of the {@code MethodData::_failed_speculations} field in the</span>
<span class="line-added">+      * {@code MethodData} associated with {@code method}. This will create and install the</span>
<span class="line-added">+      * {@code MethodData} if it didn&#39;t already exist.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native long getFailedSpeculationsAddress(HotSpotResolvedJavaMethodImpl method);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Frees the failed speculations pointed to by {@code *failedSpeculationsAddress}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native void releaseFailedSpeculations(long failedSpeculationsAddress);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Adds a speculation to the failed speculations pointed to by</span>
<span class="line-added">+      * {@code *failedSpeculationsAddress}.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return {@code false} if the speculation could not be appended to the list</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native boolean addFailedSpeculation(long failedSpeculationsAddress, byte[] speculation);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see HotSpotJVMCIRuntime#isCurrentThreadAttached()</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native boolean isCurrentThreadAttached();</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see HotSpotJVMCIRuntime#getCurrentJavaThread()</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native long getCurrentJavaThread();</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see HotSpotJVMCIRuntime#attachCurrentThread</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native boolean attachCurrentThread(boolean asDaemon);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see HotSpotJVMCIRuntime#detachCurrentThread()</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native void detachCurrentThread();</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see HotSpotJVMCIRuntime#exitHotSpot(int)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     native void callSystemExit(int status);</span>
  }
</pre>
<center><a href="../../../../../../jdk.vm.ci.hotspot.amd64/src/jdk/vm/ci/hotspot/amd64/AMD64HotSpotVMConfig.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotCodeCacheProvider.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
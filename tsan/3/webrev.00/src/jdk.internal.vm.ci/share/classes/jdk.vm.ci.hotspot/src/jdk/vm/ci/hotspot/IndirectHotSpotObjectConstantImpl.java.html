<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/IndirectHotSpotObjectConstantImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 26 
 27 import java.io.ByteArrayOutputStream;
 28 import java.io.PrintStream;
 29 
 30 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.Option;
 31 import jdk.vm.ci.meta.JavaConstant;
 32 
 33 /**
 34  * Encapsulates a JNI reference to an object in the HotSpot heap.
 35  *
 36  * {@link IndirectHotSpotObjectConstantImpl} objects are only allocated in the shared library heap.
 37  *
 38  * @see HotSpotObjectConstantScope
 39  */
 40 final class IndirectHotSpotObjectConstantImpl extends HotSpotObjectConstantImpl {
 41     /**
 42      * An object handle in {@code JVMCI::_object_handles}.
 43      */
 44     private long objectHandle;
 45 
 46     /**
 47      * Lazily computed hash code.
 48      */
 49     private int hashCode;
 50 
 51     final IndirectHotSpotObjectConstantImpl base;
 52 
 53     private static class Audit {
 54         final Object scope;
 55         final long handle;
 56         final Throwable origin;
 57 
 58         Audit(Object scope, long handle, Throwable origin) {
 59             this.scope = scope;
 60             this.handle = handle;
 61             this.origin = origin;
 62         }
 63     }
 64 
 65     /**
 66      * Details useful to audit a scoped handle used after its creating scope closes. Set to an
 67      * {@link Audit} object if {@link HotSpotJVMCIRuntime.Option#AuditHandles} is true otherwise to
 68      * {@link HotSpotObjectConstantScope#localScopeDescription}.
 69      */
 70     private Object rawAudit;
 71 
 72     @SuppressWarnings(&quot;serial&quot;)
 73     @VMEntryPoint
 74     private IndirectHotSpotObjectConstantImpl(long objectHandle, boolean compressed, boolean skipRegister) {
 75         super(compressed);
 76         assert objectHandle != 0 &amp;&amp; UnsafeAccess.UNSAFE.getLong(objectHandle) != 0;
 77         this.objectHandle = objectHandle;
 78         this.base = null;
 79         if (!skipRegister) {
 80             HotSpotObjectConstantScope scope = HotSpotObjectConstantScope.CURRENT.get();
 81             if (scope != null &amp;&amp; !scope.isGlobal()) {
 82                 scope.add(this);
 83                 if (HotSpotJVMCIRuntime.Option.AuditHandles.getBoolean()) {
 84                     rawAudit = new Audit(scope.localScopeDescription, objectHandle, new Throwable() {
 85                         @Override
 86                         public String toString() {
 87                             return &quot;Created &quot; + objectHandle;
 88                         }
 89                     });
 90                 }
 91             } else {
 92                 HandleCleaner.create(this, objectHandle);
 93             }
 94         }
 95     }
 96 
 97     private IndirectHotSpotObjectConstantImpl(IndirectHotSpotObjectConstantImpl base, boolean compressed) {
 98         super(compressed);
 99         // This is a variant of an original object that only varies in compress vs uncompressed.
100         // Instead of creating a new handle, reference that object and objectHandle.
101         this.objectHandle = base.getHandle();
102         // There should only be one level of indirection to the base object.
103         assert base.base == null || base.base.base == null;
104         this.base = base.base != null ? base.base : base;
105     }
106 
107     long getHandle() {
108         checkHandle();
109         return objectHandle;
110     }
111 
112     private void checkHandle() {
113         if (objectHandle == 0L) {
114             String message;
115             if (rawAudit instanceof Audit) {
116                 Audit audit = (Audit) rawAudit;
117                 ByteArrayOutputStream baos = new ByteArrayOutputStream();
118                 PrintStream ps = new PrintStream(baos);
119                 ps.println(&quot;Foreign object reference &quot; + audit.handle + &quot; created in scope &#39;&quot; + audit.scope + &quot;&#39; is no longer valid. Origin: {&quot;);
120                 audit.origin.printStackTrace(ps);
121                 ps.print(&#39;}&#39;);
122                 ps.flush();
123                 message = baos.toString();
124             } else {
125                 message = &quot;Foreign object reference created in scope &#39;&quot; + rawAudit + &quot;&#39; is no longer valid. &quot; +
126                                 &quot;Set property &quot; + Option.AuditHandles.getPropertyName() + &quot;=true to show origin of invalid foreign references.&quot;;
127             }
128             throw new NullPointerException(message);
129         }
130     }
131 
132     boolean isValid() {
133         return objectHandle != 0L;
134     }
135 
136     @Override
137     public HotSpotResolvedObjectType getType() {
138         checkHandle();
139         return super.getType();
140     }
141 
142     /**
143      * Clears the foreign object reference.
144      */
145     void clear(Object scopeDescription) {
146         checkHandle();
147         CompilerToVM.compilerToVM().deleteGlobalHandle(objectHandle);
148         if (rawAudit == null) {
149             rawAudit = scopeDescription;
150         }
151         objectHandle = 0L;
152     }
153 
154     @Override
155     public JavaConstant compress() {
156         assert !compressed;
157         return new IndirectHotSpotObjectConstantImpl(this, true);
158     }
159 
160     @Override
161     public JavaConstant uncompress() {
162         assert compressed;
163         return new IndirectHotSpotObjectConstantImpl(this, false);
164     }
165 
166     @Override
167     public int getIdentityHashCode() {
168         checkHandle();
169         int hash = hashCode;
170         if (hash == 0) {
171             hash = runtime().compilerToVm.getIdentityHashCode(this);
172             if (hash == 0) {
173                 hash = 31;
174             }
175             hashCode = hash;
176         }
177         return hash;
178     }
179 }
    </pre>
  </body>
</html>
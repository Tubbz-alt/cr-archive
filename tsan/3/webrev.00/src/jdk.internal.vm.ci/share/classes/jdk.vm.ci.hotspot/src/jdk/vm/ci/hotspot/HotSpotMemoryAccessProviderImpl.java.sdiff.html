<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMemoryAccessProviderImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotJVMCIRuntime.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotMetaAccessProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMemoryAccessProviderImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 

 25 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 26 
<span class="line-removed"> 27 import java.lang.reflect.Array;</span>
<span class="line-removed"> 28 </span>
<span class="line-removed"> 29 import jdk.vm.ci.common.JVMCIError;</span>
 30 import jdk.vm.ci.meta.Constant;
 31 import jdk.vm.ci.meta.JavaConstant;
 32 import jdk.vm.ci.meta.JavaKind;
 33 import jdk.vm.ci.meta.MemoryAccessProvider;
<span class="line-removed"> 34 import jdk.vm.ci.meta.MetaAccessProvider;</span>
 35 import jdk.vm.ci.meta.PrimitiveConstant;
<span class="line-removed"> 36 import jdk.vm.ci.meta.ResolvedJavaField;</span>
<span class="line-removed"> 37 import jdk.vm.ci.meta.ResolvedJavaType;</span>
 38 
 39 /**
 40  * HotSpot implementation of {@link MemoryAccessProvider}.
 41  */
 42 class HotSpotMemoryAccessProviderImpl implements HotSpotMemoryAccessProvider {
 43 
 44     protected final HotSpotJVMCIRuntime runtime;
 45 
 46     HotSpotMemoryAccessProviderImpl(HotSpotJVMCIRuntime runtime) {
 47         this.runtime = runtime;
 48     }
 49 
 50     /**
 51      * Gets the object boxed by {@code base} that is about to have a value of kind {@code kind} read
 52      * from it at the offset {@code displacement}.
 53      *
 54      * @param base constant value containing the base address for a pending read
 55      * @return {@code null} if {@code base} does not box an object otherwise the object boxed in
 56      *         {@code base}
 57      */
<span class="line-modified"> 58     private Object asObject(Constant base, JavaKind kind, long displacement) {</span>
 59         if (base instanceof HotSpotObjectConstantImpl) {
 60             HotSpotObjectConstantImpl constant = (HotSpotObjectConstantImpl) base;
 61             HotSpotResolvedObjectType type = constant.getType();
<span class="line-modified"> 62             Object object = constant.object();</span>
<span class="line-modified"> 63             checkRead(kind, displacement, type, object, runtime.getHostJVMCIBackend().getMetaAccess());</span>
<span class="line-removed"> 64             return object;</span>
 65         }
 66         return null;
 67     }
 68 
<span class="line-modified"> 69     /**</span>
<span class="line-modified"> 70      * Offset of injected {@code java.lang.Class::oop_size} field. No need to make {@code volatile}</span>
<span class="line-modified"> 71      * as initialization is idempotent.</span>
<span class="line-modified"> 72      */</span>
<span class="line-modified"> 73     private long oopSizeOffset;</span>
<span class="line-modified"> 74 </span>
<span class="line-modified"> 75     private static int computeOopSizeOffset(HotSpotJVMCIRuntime runtime) {</span>
<span class="line-removed"> 76         MetaAccessProvider metaAccess = runtime.getHostJVMCIBackend().getMetaAccess();</span>
<span class="line-removed"> 77         ResolvedJavaType staticType = metaAccess.lookupJavaType(Class.class);</span>
<span class="line-removed"> 78         for (ResolvedJavaField f : staticType.getInstanceFields(false)) {</span>
<span class="line-removed"> 79             if (f.getName().equals(&quot;oop_size&quot;)) {</span>
<span class="line-removed"> 80                 int offset = ((HotSpotResolvedJavaField) f).getOffset();</span>
<span class="line-removed"> 81                 assert offset != 0 : &quot;not expecting offset of java.lang.Class::oop_size to be 0&quot;;</span>
<span class="line-removed"> 82                 return offset;</span>
<span class="line-removed"> 83             }</span>
<span class="line-removed"> 84         }</span>
<span class="line-removed"> 85         throw new JVMCIError(&quot;Could not find injected java.lang.Class::oop_size field&quot;);</span>
<span class="line-removed"> 86     }</span>
<span class="line-removed"> 87 </span>
<span class="line-removed"> 88     private boolean checkRead(JavaKind kind, long displacement, HotSpotResolvedObjectType type, Object object, MetaAccessProvider metaAccess) {</span>
<span class="line-removed"> 89         if (type.isArray()) {</span>
<span class="line-removed"> 90             ResolvedJavaType componentType = type.getComponentType();</span>
<span class="line-removed"> 91             JavaKind componentKind = componentType.getJavaKind();</span>
<span class="line-removed"> 92             final int headerSize = metaAccess.getArrayBaseOffset(componentKind);</span>
<span class="line-removed"> 93             int sizeOfElement = metaAccess.getArrayIndexScale(componentKind);</span>
<span class="line-removed"> 94             int length = Array.getLength(object);</span>
<span class="line-removed"> 95             long arrayEnd = headerSize + (sizeOfElement * length);</span>
<span class="line-removed"> 96             boolean aligned = ((displacement - headerSize) % sizeOfElement) == 0;</span>
<span class="line-removed"> 97             if (displacement &lt; 0 || displacement &gt; (arrayEnd - sizeOfElement) || (kind == JavaKind.Object &amp;&amp; !aligned)) {</span>
<span class="line-removed"> 98                 int index = (int) ((displacement - headerSize) / sizeOfElement);</span>
<span class="line-removed"> 99                 throw new IllegalArgumentException(&quot;Unsafe array access: reading element of kind &quot; + kind +</span>
<span class="line-removed">100                                 &quot; at offset &quot; + displacement + &quot; (index ~ &quot; + index + &quot;) in &quot; +</span>
<span class="line-removed">101                                 type.toJavaName() + &quot; object of length &quot; + length);</span>
<span class="line-removed">102             }</span>
<span class="line-removed">103         } else if (kind != JavaKind.Object) {</span>
<span class="line-removed">104             long size;</span>
<span class="line-removed">105             if (object instanceof Class) {</span>
<span class="line-removed">106                 if (oopSizeOffset == 0) {</span>
<span class="line-removed">107                     oopSizeOffset = computeOopSizeOffset(runtime);</span>
108                 }
<span class="line-removed">109                 int wordSize = runtime.getHostJVMCIBackend().getCodeCache().getTarget().wordSize;</span>
<span class="line-removed">110                 size = UNSAFE.getInt(object, oopSizeOffset) * wordSize;</span>
111             } else {
<span class="line-modified">112                 size = Math.abs(type.instanceSize());</span>
<span class="line-removed">113             }</span>
<span class="line-removed">114             int bytesToRead = kind.getByteCount();</span>
<span class="line-removed">115             if (displacement + bytesToRead &gt; size || displacement &lt; 0) {</span>
<span class="line-removed">116                 throw new IllegalArgumentException(&quot;Unsafe access: reading &quot; + bytesToRead + &quot; bytes at offset &quot; + displacement + &quot; in &quot; +</span>
<span class="line-removed">117                                 type.toJavaName() + &quot; object of size &quot; + size);</span>
<span class="line-removed">118             }</span>
<span class="line-removed">119         } else {</span>
<span class="line-removed">120             ResolvedJavaField field = type.findInstanceFieldWithOffset(displacement, JavaKind.Object);</span>
<span class="line-removed">121             if (field == null &amp;&amp; object instanceof Class) {</span>
<span class="line-removed">122                 // Read of a static field</span>
<span class="line-removed">123                 HotSpotResolvedObjectTypeImpl staticFieldsHolder = (HotSpotResolvedObjectTypeImpl) metaAccess.lookupJavaType((Class&lt;?&gt;) object);</span>
<span class="line-removed">124                 field = staticFieldsHolder.findStaticFieldWithOffset(displacement, JavaKind.Object);</span>
<span class="line-removed">125             }</span>
<span class="line-removed">126             if (field == null) {</span>
<span class="line-removed">127                 throw new IllegalArgumentException(&quot;Unsafe object access: field not found for read of kind Object&quot; +</span>
<span class="line-removed">128                                 &quot; at offset &quot; + displacement + &quot; in &quot; + type.toJavaName() + &quot; object&quot;);</span>
<span class="line-removed">129             }</span>
<span class="line-removed">130             if (field.getJavaKind() != JavaKind.Object) {</span>
<span class="line-removed">131                 throw new IllegalArgumentException(&quot;Unsafe object access: field &quot; + field.format(&quot;%H.%n:%T&quot;) + &quot; not of expected kind Object&quot; +</span>
<span class="line-removed">132                                 &quot; at offset &quot; + displacement + &quot; in &quot; + type.toJavaName() + &quot; object&quot;);</span>
133             }
134         }
<span class="line-modified">135         return true;</span>
136     }
137 
138     private static long asRawPointer(Constant base) {
139         if (base instanceof HotSpotMetaspaceConstantImpl) {
<span class="line-modified">140             MetaspaceWrapperObject meta = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
141             return meta.getMetaspacePointer();
142         } else if (base instanceof PrimitiveConstant) {
143             PrimitiveConstant prim = (PrimitiveConstant) base;
144             if (prim.getJavaKind().isNumericInteger()) {
145                 return prim.asLong();
146             }
147         }
148         throw new IllegalArgumentException(String.valueOf(base));
149     }
150 
<span class="line-modified">151     private long readRawValue(Constant baseConstant, long displacement, JavaKind kind, int bits) {</span>
<span class="line-modified">152         Object base = asObject(baseConstant, kind, displacement);</span>
153         if (base != null) {
154             switch (bits) {
155                 case Byte.SIZE:
<span class="line-modified">156                     return UNSAFE.getByte(base, displacement);</span>
157                 case Short.SIZE:
<span class="line-modified">158                     return UNSAFE.getShort(base, displacement);</span>
159                 case Integer.SIZE:
<span class="line-modified">160                     return UNSAFE.getInt(base, displacement);</span>
161                 case Long.SIZE:
<span class="line-modified">162                     return UNSAFE.getLong(base, displacement);</span>
163                 default:
164                     throw new IllegalArgumentException(String.valueOf(bits));
165             }
166         } else {
167             long pointer = asRawPointer(baseConstant);
168             switch (bits) {
169                 case Byte.SIZE:
170                     return UNSAFE.getByte(pointer + displacement);
171                 case Short.SIZE:
172                     return UNSAFE.getShort(pointer + displacement);
173                 case Integer.SIZE:
174                     return UNSAFE.getInt(pointer + displacement);
175                 case Long.SIZE:
176                     return UNSAFE.getLong(pointer + displacement);
177                 default:
178                     throw new IllegalArgumentException(String.valueOf(bits));
179             }
180         }
181     }
182 
<span class="line-modified">183     private boolean verifyReadRawObject(Object expected, Constant base, long displacement) {</span>
184         if (base instanceof HotSpotMetaspaceConstant) {
<span class="line-modified">185             MetaspaceWrapperObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
186             if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {
<span class="line-modified">187                 if (displacement == runtime.getConfig().classMirrorHandleOffset) {</span>
<span class="line-modified">188                     assert expected == ((HotSpotResolvedObjectTypeImpl) metaspaceObject).mirror();</span>

189                 }
190             }
191         }
192         return true;
193     }
194 
<span class="line-modified">195     private Object readRawObject(Constant baseConstant, long initialDisplacement, boolean compressed) {</span>
196         long displacement = initialDisplacement;
<span class="line-modified">197         Object ret;</span>
<span class="line-modified">198         Object base = asObject(baseConstant, JavaKind.Object, displacement);</span>
199         if (base == null) {
200             assert !compressed;
201             displacement += asRawPointer(baseConstant);
<span class="line-modified">202             ret = UNSAFE.getUncompressedObject(displacement);</span>
203             assert verifyReadRawObject(ret, baseConstant, initialDisplacement);
204         } else {
205             assert runtime.getConfig().useCompressedOops == compressed;
<span class="line-modified">206             ret = UNSAFE.getReference(base, displacement);</span>
<span class="line-removed">207         }</span>
<span class="line-removed">208         return ret;</span>
<span class="line-removed">209     }</span>
<span class="line-removed">210 </span>
<span class="line-removed">211     JavaConstant readFieldValue(HotSpotResolvedJavaField field, Object obj, boolean isVolatile) {</span>
<span class="line-removed">212         assert obj != null;</span>
<span class="line-removed">213         assert !field.isStatic() || obj instanceof Class;</span>
<span class="line-removed">214         long displacement = field.getOffset();</span>
<span class="line-removed">215         assert checkRead(field.getJavaKind(), displacement, (HotSpotResolvedObjectType) runtime.getHostJVMCIBackend().getMetaAccess().lookupJavaType(obj.getClass()), obj,</span>
<span class="line-removed">216                         runtime.getHostJVMCIBackend().getMetaAccess());</span>
<span class="line-removed">217         JavaKind kind = field.getJavaKind();</span>
<span class="line-removed">218         switch (kind) {</span>
<span class="line-removed">219             case Boolean:</span>
<span class="line-removed">220                 return JavaConstant.forBoolean(isVolatile ? UNSAFE.getBooleanVolatile(obj, displacement) : UNSAFE.getBoolean(obj, displacement));</span>
<span class="line-removed">221             case Byte:</span>
<span class="line-removed">222                 return JavaConstant.forByte(isVolatile ? UNSAFE.getByteVolatile(obj, displacement) : UNSAFE.getByte(obj, displacement));</span>
<span class="line-removed">223             case Char:</span>
<span class="line-removed">224                 return JavaConstant.forChar(isVolatile ? UNSAFE.getCharVolatile(obj, displacement) : UNSAFE.getChar(obj, displacement));</span>
<span class="line-removed">225             case Short:</span>
<span class="line-removed">226                 return JavaConstant.forShort(isVolatile ? UNSAFE.getShortVolatile(obj, displacement) : UNSAFE.getShort(obj, displacement));</span>
<span class="line-removed">227             case Int:</span>
<span class="line-removed">228                 return JavaConstant.forInt(isVolatile ? UNSAFE.getIntVolatile(obj, displacement) : UNSAFE.getInt(obj, displacement));</span>
<span class="line-removed">229             case Long:</span>
<span class="line-removed">230                 return JavaConstant.forLong(isVolatile ? UNSAFE.getLongVolatile(obj, displacement) : UNSAFE.getLong(obj, displacement));</span>
<span class="line-removed">231             case Float:</span>
<span class="line-removed">232                 return JavaConstant.forFloat(isVolatile ? UNSAFE.getFloatVolatile(obj, displacement) : UNSAFE.getFloat(obj, displacement));</span>
<span class="line-removed">233             case Double:</span>
<span class="line-removed">234                 return JavaConstant.forDouble(isVolatile ? UNSAFE.getDoubleVolatile(obj, displacement) : UNSAFE.getDouble(obj, displacement));</span>
<span class="line-removed">235             case Object:</span>
<span class="line-removed">236                 return HotSpotObjectConstantImpl.forObject(isVolatile ? UNSAFE.getReferenceVolatile(obj, displacement) : UNSAFE.getReference(obj, displacement));</span>
<span class="line-removed">237             default:</span>
<span class="line-removed">238                 throw new IllegalArgumentException(&quot;Unsupported kind: &quot; + kind);</span>
239         }

240     }
241 
242     @Override
243     public JavaConstant readPrimitiveConstant(JavaKind kind, Constant baseConstant, long initialDisplacement, int bits) {
244         try {
245             long rawValue = readRawValue(baseConstant, initialDisplacement, kind, bits);
246             switch (kind) {
247                 case Boolean:
248                     return JavaConstant.forBoolean(rawValue != 0);
249                 case Byte:
250                     return JavaConstant.forByte((byte) rawValue);
251                 case Char:
252                     return JavaConstant.forChar((char) rawValue);
253                 case Short:
254                     return JavaConstant.forShort((short) rawValue);
255                 case Int:
256                     return JavaConstant.forInt((int) rawValue);
257                 case Long:
258                     return JavaConstant.forLong(rawValue);
259                 case Float:
260                     return JavaConstant.forFloat(Float.intBitsToFloat((int) rawValue));
261                 case Double:
262                     return JavaConstant.forDouble(Double.longBitsToDouble(rawValue));
263                 default:
264                     throw new IllegalArgumentException(&quot;Unsupported kind: &quot; + kind);
265             }
266         } catch (NullPointerException e) {
267             return null;
268         }
269     }
270 
271     @Override
272     public JavaConstant readObjectConstant(Constant base, long displacement) {
273         if (base instanceof HotSpotObjectConstantImpl) {
<span class="line-modified">274             Object o = readRawObject(base, displacement, runtime.getConfig().useCompressedOops);</span>
<span class="line-removed">275             return HotSpotObjectConstantImpl.forObject(o);</span>
276         }
<span class="line-modified">277         if (base instanceof HotSpotMetaspaceConstant) {</span>
<span class="line-modified">278             MetaspaceWrapperObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
<span class="line-removed">279             if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {</span>
<span class="line-removed">280                  if (displacement == runtime.getConfig().classMirrorHandleOffset) {</span>
<span class="line-removed">281                     // Klass::_java_mirror is valid for all Klass* values</span>
<span class="line-removed">282                     return HotSpotObjectConstantImpl.forObject(((HotSpotResolvedObjectTypeImpl) metaspaceObject).mirror());</span>
<span class="line-removed">283                  }</span>
<span class="line-removed">284              } else {</span>
<span class="line-removed">285                  throw new IllegalArgumentException(String.valueOf(metaspaceObject));</span>
<span class="line-removed">286              }</span>
287         }
<span class="line-modified">288         return null;</span>





289     }
290 
291     @Override
292     public JavaConstant readNarrowOopConstant(Constant base, long displacement) {
<span class="line-modified">293         return HotSpotObjectConstantImpl.forObject(readRawObject(base, displacement, true), true);</span>

294     }
295 
296     private HotSpotResolvedObjectTypeImpl readKlass(Constant base, long displacement, boolean compressed) {
297         assert (base instanceof HotSpotMetaspaceConstantImpl) || (base instanceof HotSpotObjectConstantImpl) : base.getClass();
<span class="line-modified">298         Object baseObject = (base instanceof HotSpotMetaspaceConstantImpl) ? ((HotSpotMetaspaceConstantImpl) base).asResolvedJavaType() : ((HotSpotObjectConstantImpl) base).object();</span>
<span class="line-modified">299         return runtime.getCompilerToVM().getResolvedJavaType(baseObject, displacement, compressed);</span>



300     }
301 

302     @Override
303     public Constant readKlassPointerConstant(Constant base, long displacement) {
304         HotSpotResolvedObjectTypeImpl klass = readKlass(base, displacement, false);
305         if (klass == null) {
306             return JavaConstant.NULL_POINTER;
307         }
308         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(klass, false);
309     }
310 
311     @Override
312     public Constant readNarrowKlassPointerConstant(Constant base, long displacement) {
313         HotSpotResolvedObjectTypeImpl klass = readKlass(base, displacement, true);
314         if (klass == null) {
315             return HotSpotCompressedNullConstant.COMPRESSED_NULL;
316         }
317         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(klass, true);
318     }
319 
320     @Override
321     public Constant readMethodPointerConstant(Constant base, long displacement) {
322         assert (base instanceof HotSpotObjectConstantImpl);
<span class="line-modified">323         Object baseObject = ((HotSpotObjectConstantImpl) base).object();</span>
<span class="line-removed">324         HotSpotResolvedJavaMethodImpl method = runtime.getCompilerToVM().getResolvedJavaMethod(baseObject, displacement);</span>
325         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(method, false);
326     }
327 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
<span class="line-added"> 25 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;</span>
 26 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 27 



 28 import jdk.vm.ci.meta.Constant;
 29 import jdk.vm.ci.meta.JavaConstant;
 30 import jdk.vm.ci.meta.JavaKind;
 31 import jdk.vm.ci.meta.MemoryAccessProvider;

 32 import jdk.vm.ci.meta.PrimitiveConstant;


 33 
 34 /**
 35  * HotSpot implementation of {@link MemoryAccessProvider}.
 36  */
 37 class HotSpotMemoryAccessProviderImpl implements HotSpotMemoryAccessProvider {
 38 
 39     protected final HotSpotJVMCIRuntime runtime;
 40 
 41     HotSpotMemoryAccessProviderImpl(HotSpotJVMCIRuntime runtime) {
 42         this.runtime = runtime;
 43     }
 44 
 45     /**
 46      * Gets the object boxed by {@code base} that is about to have a value of kind {@code kind} read
 47      * from it at the offset {@code displacement}.
 48      *
 49      * @param base constant value containing the base address for a pending read
 50      * @return {@code null} if {@code base} does not box an object otherwise the object boxed in
 51      *         {@code base}
 52      */
<span class="line-modified"> 53     private static HotSpotObjectConstantImpl asObject(Constant base, JavaKind kind, long displacement) {</span>
 54         if (base instanceof HotSpotObjectConstantImpl) {
 55             HotSpotObjectConstantImpl constant = (HotSpotObjectConstantImpl) base;
 56             HotSpotResolvedObjectType type = constant.getType();
<span class="line-modified"> 57             runtime().reflection.checkRead(constant, kind, displacement, type);</span>
<span class="line-modified"> 58             return constant;</span>

 59         }
 60         return null;
 61     }
 62 
<span class="line-modified"> 63     private boolean isValidObjectFieldDisplacement(Constant base, long displacement) {</span>
<span class="line-modified"> 64         if (base instanceof HotSpotMetaspaceConstant) {</span>
<span class="line-modified"> 65             MetaspaceObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
<span class="line-modified"> 66             if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {</span>
<span class="line-modified"> 67                 if (displacement == runtime.getConfig().javaMirrorOffset) {</span>
<span class="line-modified"> 68                     // Klass::_java_mirror is valid for all Klass* values</span>
<span class="line-modified"> 69                     return true;</span>
































 70                 }


 71             } else {
<span class="line-modified"> 72                 throw new IllegalArgumentException(String.valueOf(metaspaceObject));</span>




















 73             }
 74         }
<span class="line-modified"> 75         return false;</span>
 76     }
 77 
 78     private static long asRawPointer(Constant base) {
 79         if (base instanceof HotSpotMetaspaceConstantImpl) {
<span class="line-modified"> 80             MetaspaceObject meta = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
 81             return meta.getMetaspacePointer();
 82         } else if (base instanceof PrimitiveConstant) {
 83             PrimitiveConstant prim = (PrimitiveConstant) base;
 84             if (prim.getJavaKind().isNumericInteger()) {
 85                 return prim.asLong();
 86             }
 87         }
 88         throw new IllegalArgumentException(String.valueOf(base));
 89     }
 90 
<span class="line-modified"> 91     private static long readRawValue(Constant baseConstant, long displacement, JavaKind kind, int bits) {</span>
<span class="line-modified"> 92         HotSpotObjectConstantImpl base = asObject(baseConstant, kind, displacement);</span>
 93         if (base != null) {
 94             switch (bits) {
 95                 case Byte.SIZE:
<span class="line-modified"> 96                     return runtime().reflection.getByte(base, displacement);</span>
 97                 case Short.SIZE:
<span class="line-modified"> 98                     return runtime().reflection.getShort(base, displacement);</span>
 99                 case Integer.SIZE:
<span class="line-modified">100                     return runtime().reflection.getInt(base, displacement);</span>
101                 case Long.SIZE:
<span class="line-modified">102                     return runtime().reflection.getLong(base, displacement);</span>
103                 default:
104                     throw new IllegalArgumentException(String.valueOf(bits));
105             }
106         } else {
107             long pointer = asRawPointer(baseConstant);
108             switch (bits) {
109                 case Byte.SIZE:
110                     return UNSAFE.getByte(pointer + displacement);
111                 case Short.SIZE:
112                     return UNSAFE.getShort(pointer + displacement);
113                 case Integer.SIZE:
114                     return UNSAFE.getInt(pointer + displacement);
115                 case Long.SIZE:
116                     return UNSAFE.getLong(pointer + displacement);
117                 default:
118                     throw new IllegalArgumentException(String.valueOf(bits));
119             }
120         }
121     }
122 
<span class="line-modified">123     private boolean verifyReadRawObject(JavaConstant expected, Constant base, long displacement) {</span>
124         if (base instanceof HotSpotMetaspaceConstant) {
<span class="line-modified">125             MetaspaceObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
126             if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {
<span class="line-modified">127                 if (displacement == runtime.getConfig().javaMirrorOffset) {</span>
<span class="line-modified">128                     HotSpotResolvedObjectTypeImpl type = (HotSpotResolvedObjectTypeImpl) metaspaceObject;</span>
<span class="line-added">129                     assert expected.equals(type.getJavaMirror());</span>
130                 }
131             }
132         }
133         return true;
134     }
135 
<span class="line-modified">136     private JavaConstant readRawObject(Constant baseConstant, long initialDisplacement, boolean compressed) {</span>
137         long displacement = initialDisplacement;
<span class="line-modified">138         JavaConstant ret;</span>
<span class="line-modified">139         HotSpotObjectConstantImpl base = asObject(baseConstant, JavaKind.Object, displacement);</span>
140         if (base == null) {
141             assert !compressed;
142             displacement += asRawPointer(baseConstant);
<span class="line-modified">143             ret = runtime.getCompilerToVM().readUncompressedOop(displacement);</span>
144             assert verifyReadRawObject(ret, baseConstant, initialDisplacement);
145         } else {
146             assert runtime.getConfig().useCompressedOops == compressed;
<span class="line-modified">147             ret = runtime.getCompilerToVM().getObject(base, displacement);</span>
































148         }
<span class="line-added">149         return ret == null ? JavaConstant.NULL_POINTER : ret;</span>
150     }
151 
152     @Override
153     public JavaConstant readPrimitiveConstant(JavaKind kind, Constant baseConstant, long initialDisplacement, int bits) {
154         try {
155             long rawValue = readRawValue(baseConstant, initialDisplacement, kind, bits);
156             switch (kind) {
157                 case Boolean:
158                     return JavaConstant.forBoolean(rawValue != 0);
159                 case Byte:
160                     return JavaConstant.forByte((byte) rawValue);
161                 case Char:
162                     return JavaConstant.forChar((char) rawValue);
163                 case Short:
164                     return JavaConstant.forShort((short) rawValue);
165                 case Int:
166                     return JavaConstant.forInt((int) rawValue);
167                 case Long:
168                     return JavaConstant.forLong(rawValue);
169                 case Float:
170                     return JavaConstant.forFloat(Float.intBitsToFloat((int) rawValue));
171                 case Double:
172                     return JavaConstant.forDouble(Double.longBitsToDouble(rawValue));
173                 default:
174                     throw new IllegalArgumentException(&quot;Unsupported kind: &quot; + kind);
175             }
176         } catch (NullPointerException e) {
177             return null;
178         }
179     }
180 
181     @Override
182     public JavaConstant readObjectConstant(Constant base, long displacement) {
183         if (base instanceof HotSpotObjectConstantImpl) {
<span class="line-modified">184             return readRawObject(base, displacement, runtime.getConfig().useCompressedOops);</span>

185         }
<span class="line-modified">186         if (!isValidObjectFieldDisplacement(base, displacement)) {</span>
<span class="line-modified">187             return null;</span>








188         }
<span class="line-modified">189         if (base instanceof HotSpotMetaspaceConstant &amp;&amp;</span>
<span class="line-added">190             displacement == runtime.getConfig().javaMirrorOffset) {</span>
<span class="line-added">191             MetaspaceObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
<span class="line-added">192             return ((HotSpotResolvedObjectTypeImpl) metaspaceObject).getJavaMirror();</span>
<span class="line-added">193         }</span>
<span class="line-added">194         return readRawObject(base, displacement, false);</span>
195     }
196 
197     @Override
198     public JavaConstant readNarrowOopConstant(Constant base, long displacement) {
<span class="line-modified">199         JavaConstant res = readRawObject(base, displacement, true);</span>
<span class="line-added">200         return JavaConstant.NULL_POINTER.equals(res) ? HotSpotCompressedNullConstant.COMPRESSED_NULL : ((HotSpotObjectConstant) res).compress();</span>
201     }
202 
203     private HotSpotResolvedObjectTypeImpl readKlass(Constant base, long displacement, boolean compressed) {
204         assert (base instanceof HotSpotMetaspaceConstantImpl) || (base instanceof HotSpotObjectConstantImpl) : base.getClass();
<span class="line-modified">205         if (base instanceof HotSpotMetaspaceConstantImpl) {</span>
<span class="line-modified">206             return runtime.getCompilerToVM().getResolvedJavaType((HotSpotResolvedObjectTypeImpl) ((HotSpotMetaspaceConstantImpl) base).asResolvedJavaType(), displacement, compressed);</span>
<span class="line-added">207         } else {</span>
<span class="line-added">208             return runtime.getCompilerToVM().getResolvedJavaType(((HotSpotObjectConstantImpl) base), displacement, compressed);</span>
<span class="line-added">209         }</span>
210     }
211 
<span class="line-added">212 </span>
213     @Override
214     public Constant readKlassPointerConstant(Constant base, long displacement) {
215         HotSpotResolvedObjectTypeImpl klass = readKlass(base, displacement, false);
216         if (klass == null) {
217             return JavaConstant.NULL_POINTER;
218         }
219         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(klass, false);
220     }
221 
222     @Override
223     public Constant readNarrowKlassPointerConstant(Constant base, long displacement) {
224         HotSpotResolvedObjectTypeImpl klass = readKlass(base, displacement, true);
225         if (klass == null) {
226             return HotSpotCompressedNullConstant.COMPRESSED_NULL;
227         }
228         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(klass, true);
229     }
230 
231     @Override
232     public Constant readMethodPointerConstant(Constant base, long displacement) {
233         assert (base instanceof HotSpotObjectConstantImpl);
<span class="line-modified">234         HotSpotResolvedJavaMethodImpl method = runtime.getCompilerToVM().getResolvedJavaMethod((HotSpotObjectConstantImpl) base, displacement);</span>

235         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(method, false);
236     }
237 }
</pre>
</td>
</tr>
</table>
<center><a href="HotSpotJVMCIRuntime.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotMetaAccessProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMetaAccessProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
<a name="2" id="anc2"></a>



 25 import java.lang.reflect.Executable;
 26 import java.lang.reflect.Field;
 27 import java.lang.reflect.Modifier;
 28 import java.util.Objects;
 29 
 30 import jdk.vm.ci.code.CodeUtil;
 31 import jdk.vm.ci.common.JVMCIError;
 32 import jdk.vm.ci.meta.DeoptimizationAction;
 33 import jdk.vm.ci.meta.DeoptimizationReason;
 34 import jdk.vm.ci.meta.JavaConstant;
 35 import jdk.vm.ci.meta.JavaKind;
 36 import jdk.vm.ci.meta.MetaAccessProvider;
 37 import jdk.vm.ci.meta.ResolvedJavaField;
 38 import jdk.vm.ci.meta.ResolvedJavaMethod;
 39 import jdk.vm.ci.meta.ResolvedJavaType;
 40 import jdk.vm.ci.meta.Signature;
 41 import jdk.vm.ci.meta.SpeculationLog;
<a name="3" id="anc3"></a><span class="line-added"> 42 import jdk.vm.ci.meta.SpeculationLog.NoSpeculationReason;</span>
<span class="line-added"> 43 import jdk.vm.ci.meta.SpeculationLog.Speculation;</span>
 44 
 45 // JaCoCo Exclude
 46 
 47 /**
 48  * HotSpot implementation of {@link MetaAccessProvider}.
 49  */
 50 public class HotSpotMetaAccessProvider implements MetaAccessProvider {
 51 
 52     protected final HotSpotJVMCIRuntime runtime;
 53 
 54     public HotSpotMetaAccessProvider(HotSpotJVMCIRuntime runtime) {
 55         this.runtime = runtime;
 56     }
 57 
 58     @Override
 59     public ResolvedJavaType lookupJavaType(Class&lt;?&gt; clazz) {
 60         if (clazz == null) {
 61             throw new IllegalArgumentException(&quot;Class parameter was null&quot;);
 62         }
 63         return runtime.fromClass(clazz);
 64     }
 65 
 66     @Override
 67     public HotSpotResolvedObjectType lookupJavaType(JavaConstant constant) {
 68         if (constant.isNull() || !(constant instanceof HotSpotObjectConstant)) {
 69             return null;
 70         }
 71         return ((HotSpotObjectConstant) constant).getType();
 72     }
 73 
 74     @Override
 75     public Signature parseMethodDescriptor(String signature) {
 76         return new HotSpotSignature(runtime, signature);
 77     }
 78 
 79     @Override
 80     public ResolvedJavaMethod lookupJavaMethod(Executable reflectionMethod) {
 81         return runtime.getCompilerToVM().asResolvedJavaMethod(Objects.requireNonNull(reflectionMethod));
 82     }
 83 
 84     @Override
 85     public ResolvedJavaField lookupJavaField(Field reflectionField) {
 86         Class&lt;?&gt; fieldHolder = reflectionField.getDeclaringClass();
 87 
<a name="4" id="anc4"></a><span class="line-modified"> 88         HotSpotResolvedJavaType holder = runtime.fromClass(fieldHolder);</span>
<span class="line-added"> 89         assert holder != null : fieldHolder;</span>
<span class="line-added"> 90         ResolvedJavaField[] fields;</span>
 91         if (Modifier.isStatic(reflectionField.getModifiers())) {
<a name="5" id="anc5"></a><span class="line-modified"> 92             fields = holder.getStaticFields();</span>





 93         } else {
<a name="6" id="anc6"></a><span class="line-modified"> 94             fields = holder.getInstanceFields(false);</span>
<span class="line-modified"> 95         }</span>
<span class="line-modified"> 96         ResolvedJavaType fieldType = lookupJavaType(reflectionField.getType());</span>
<span class="line-modified"> 97         for (ResolvedJavaField field : fields) {</span>
<span class="line-modified"> 98             if (reflectionField.getName().equals(field.getName()) &amp;&amp; field.getType().equals(fieldType)) {</span>
<span class="line-added"> 99                 assert Modifier.isStatic(reflectionField.getModifiers()) == field.isStatic();</span>
<span class="line-added">100                 return field;</span>
101             }
102         }
103 
104         throw new JVMCIError(&quot;unresolved field %s&quot;, reflectionField);
105     }
106 
107     private static int intMaskRight(int n) {
108         assert n &lt;= 32;
109         return n == 32 ? -1 : (1 &lt;&lt; n) - 1;
110     }
111 
112     @Override
113     public JavaConstant encodeDeoptActionAndReason(DeoptimizationAction action, DeoptimizationReason reason, int debugId) {
114         HotSpotVMConfig config = runtime.getConfig();
115         int actionValue = convertDeoptAction(action);
116         int reasonValue = convertDeoptReason(reason);
117         int debugValue = debugId &amp; intMaskRight(config.deoptimizationDebugIdBits);
118         JavaConstant c = JavaConstant.forInt(
119                         ~((debugValue &lt;&lt; config.deoptimizationDebugIdShift) | (reasonValue &lt;&lt; config.deoptimizationReasonShift) | (actionValue &lt;&lt; config.deoptimizationActionShift)));
120         assert c.asInt() &lt; 0;
121         return c;
122     }
123 
124     @Override
125     public DeoptimizationReason decodeDeoptReason(JavaConstant constant) {
126         HotSpotVMConfig config = runtime.getConfig();
127         int reasonValue = ((~constant.asInt()) &gt;&gt; config.deoptimizationReasonShift) &amp; intMaskRight(config.deoptimizationReasonBits);
128         DeoptimizationReason reason = convertDeoptReason(reasonValue);
129         return reason;
130     }
131 
132     @Override
133     public DeoptimizationAction decodeDeoptAction(JavaConstant constant) {
134         HotSpotVMConfig config = runtime.getConfig();
135         int actionValue = ((~constant.asInt()) &gt;&gt; config.deoptimizationActionShift) &amp; intMaskRight(config.deoptimizationActionBits);
136         DeoptimizationAction action = convertDeoptAction(actionValue);
137         return action;
138     }
139 
140     @Override
141     public int decodeDebugId(JavaConstant constant) {
142         HotSpotVMConfig config = runtime.getConfig();
143         return ((~constant.asInt()) &gt;&gt; config.deoptimizationDebugIdShift) &amp; intMaskRight(config.deoptimizationDebugIdBits);
144     }
145 
146     @Override
<a name="7" id="anc7"></a><span class="line-modified">147     public JavaConstant encodeSpeculation(Speculation speculation) {</span>
<span class="line-modified">148         if (speculation.getReason() instanceof NoSpeculationReason) {</span>
149             return JavaConstant.LONG_0;
150         }
151         return ((HotSpotSpeculationLog.HotSpotSpeculation) speculation).getEncoding();
152     }
153 
154     @Override
<a name="8" id="anc8"></a><span class="line-modified">155     public Speculation decodeSpeculation(JavaConstant constant, SpeculationLog speculationLog) {</span>
156         if (constant.equals(JavaConstant.LONG_0)) {
157             return SpeculationLog.NO_SPECULATION;
158         }
<a name="9" id="anc9"></a><span class="line-modified">159         if (speculationLog == null) {</span>
<span class="line-added">160             throw new IllegalArgumentException(&quot;A speculation log is required to decode the speculation denoted by &quot; + constant);</span>
<span class="line-added">161         }</span>
162         return speculationLog.lookupSpeculation(constant);
163     }
164 
165     public int convertDeoptAction(DeoptimizationAction action) {
166         HotSpotVMConfig config = runtime.getConfig();
167         switch (action) {
168             case None:
169                 return config.deoptActionNone;
170             case RecompileIfTooManyDeopts:
171                 return config.deoptActionMaybeRecompile;
172             case InvalidateReprofile:
173                 return config.deoptActionReinterpret;
174             case InvalidateRecompile:
175                 return config.deoptActionMakeNotEntrant;
176             case InvalidateStopCompiling:
177                 return config.deoptActionMakeNotCompilable;
178             default:
179                 throw new JVMCIError(&quot;%s&quot;, action);
180         }
181     }
182 
183     public DeoptimizationAction convertDeoptAction(int action) {
184         HotSpotVMConfig config = runtime.getConfig();
185         if (action == config.deoptActionNone) {
186             return DeoptimizationAction.None;
187         }
188         if (action == config.deoptActionMaybeRecompile) {
189             return DeoptimizationAction.RecompileIfTooManyDeopts;
190         }
191         if (action == config.deoptActionReinterpret) {
192             return DeoptimizationAction.InvalidateReprofile;
193         }
194         if (action == config.deoptActionMakeNotEntrant) {
195             return DeoptimizationAction.InvalidateRecompile;
196         }
197         if (action == config.deoptActionMakeNotCompilable) {
198             return DeoptimizationAction.InvalidateStopCompiling;
199         }
200         throw new JVMCIError(&quot;%d&quot;, action);
201     }
202 
203     public int convertDeoptReason(DeoptimizationReason reason) {
204         HotSpotVMConfig config = runtime.getConfig();
205         switch (reason) {
206             case None:
207                 return config.deoptReasonNone;
208             case NullCheckException:
209                 return config.deoptReasonNullCheck;
210             case BoundsCheckException:
211                 return config.deoptReasonRangeCheck;
212             case ClassCastException:
213                 return config.deoptReasonClassCheck;
214             case ArrayStoreException:
215                 return config.deoptReasonArrayCheck;
216             case UnreachedCode:
217                 return config.deoptReasonUnreached0;
218             case TypeCheckedInliningViolated:
219                 return config.deoptReasonTypeCheckInlining;
220             case OptimizedTypeCheckViolated:
221                 return config.deoptReasonOptimizedTypeCheck;
222             case NotCompiledExceptionHandler:
223                 return config.deoptReasonNotCompiledExceptionHandler;
224             case Unresolved:
225                 return config.deoptReasonUnresolved;
226             case JavaSubroutineMismatch:
227                 return config.deoptReasonJsrMismatch;
228             case ArithmeticException:
229                 return config.deoptReasonDiv0Check;
230             case RuntimeConstraint:
231                 return config.deoptReasonConstraint;
232             case LoopLimitCheck:
233                 return config.deoptReasonLoopLimitCheck;
234             case Aliasing:
235                 return config.deoptReasonAliasing;
236             case TransferToInterpreter:
237                 return config.deoptReasonTransferToInterpreter;
238             default:
239                 throw new JVMCIError(&quot;%s&quot;, reason);
240         }
241     }
242 
243     public DeoptimizationReason convertDeoptReason(int reason) {
244         HotSpotVMConfig config = runtime.getConfig();
245         if (reason == config.deoptReasonNone) {
246             return DeoptimizationReason.None;
247         }
248         if (reason == config.deoptReasonNullCheck) {
249             return DeoptimizationReason.NullCheckException;
250         }
251         if (reason == config.deoptReasonRangeCheck) {
252             return DeoptimizationReason.BoundsCheckException;
253         }
254         if (reason == config.deoptReasonClassCheck) {
255             return DeoptimizationReason.ClassCastException;
256         }
257         if (reason == config.deoptReasonArrayCheck) {
258             return DeoptimizationReason.ArrayStoreException;
259         }
260         if (reason == config.deoptReasonUnreached0) {
261             return DeoptimizationReason.UnreachedCode;
262         }
263         if (reason == config.deoptReasonTypeCheckInlining) {
264             return DeoptimizationReason.TypeCheckedInliningViolated;
265         }
266         if (reason == config.deoptReasonOptimizedTypeCheck) {
267             return DeoptimizationReason.OptimizedTypeCheckViolated;
268         }
269         if (reason == config.deoptReasonNotCompiledExceptionHandler) {
270             return DeoptimizationReason.NotCompiledExceptionHandler;
271         }
272         if (reason == config.deoptReasonUnresolved) {
273             return DeoptimizationReason.Unresolved;
274         }
275         if (reason == config.deoptReasonJsrMismatch) {
276             return DeoptimizationReason.JavaSubroutineMismatch;
277         }
278         if (reason == config.deoptReasonDiv0Check) {
279             return DeoptimizationReason.ArithmeticException;
280         }
281         if (reason == config.deoptReasonConstraint) {
282             return DeoptimizationReason.RuntimeConstraint;
283         }
284         if (reason == config.deoptReasonLoopLimitCheck) {
285             return DeoptimizationReason.LoopLimitCheck;
286         }
287         if (reason == config.deoptReasonAliasing) {
288             return DeoptimizationReason.Aliasing;
289         }
290         if (reason == config.deoptReasonTransferToInterpreter) {
291             return DeoptimizationReason.TransferToInterpreter;
292         }
293         throw new JVMCIError(&quot;%x&quot;, reason);
294     }
295 
296     @Override
297     public long getMemorySize(JavaConstant constant) {
298         if (constant.getJavaKind() == JavaKind.Object) {
299             HotSpotResolvedObjectType lookupJavaType = lookupJavaType(constant);
300 
301             if (lookupJavaType == null) {
302                 return 0;
303             } else {
304                 if (lookupJavaType.isArray()) {
<a name="10" id="anc10"></a><span class="line-modified">305                     int length = runtime.getHostJVMCIBackend().getConstantReflection().readArrayLength(constant);</span>
306                     ResolvedJavaType elementType = lookupJavaType.getComponentType();
307                     JavaKind elementKind = elementType.getJavaKind();
<a name="11" id="anc11"></a><span class="line-modified">308                     final int headerSize = runtime.getArrayBaseOffset(elementKind);</span>
<span class="line-modified">309                     int sizeOfElement = runtime.getArrayIndexScale(elementKind);</span>
310                     int log2ElementSize = CodeUtil.log2(sizeOfElement);
311                     return computeArrayAllocationSize(length, headerSize, log2ElementSize);
312                 }
313                 return lookupJavaType.instanceSize();
314             }
315         } else {
316             return constant.getJavaKind().getByteCount();
317         }
318     }
319 
320     /**
321      * Computes the size of the memory chunk allocated for an array. This size accounts for the
322      * array header size, body size and any padding after the last element to satisfy object
323      * alignment requirements.
324      *
325      * @param length the number of elements in the array
326      * @param headerSize the size of the array header
327      * @param log2ElementSize log2 of the size of an element in the array
328      * @return the size of the memory chunk
329      */
330     public int computeArrayAllocationSize(int length, int headerSize, int log2ElementSize) {
331         HotSpotVMConfig config = runtime.getConfig();
332         int alignment = config.objectAlignment;
333         int size = (length &lt;&lt; log2ElementSize) + headerSize + (alignment - 1);
334         int mask = ~(alignment - 1);
335         return size &amp; mask;
336     }
337 
338     @Override
339     public int getArrayBaseOffset(JavaKind kind) {
340         return runtime.getArrayBaseOffset(kind);
341     }
342 
343     @Override
344     public int getArrayIndexScale(JavaKind kind) {
345         return runtime.getArrayIndexScale(kind);
346     }
347 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
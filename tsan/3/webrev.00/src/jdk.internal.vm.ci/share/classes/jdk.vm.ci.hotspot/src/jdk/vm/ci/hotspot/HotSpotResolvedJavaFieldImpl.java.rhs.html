<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedJavaFieldImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
<a name="2" id="anc2"></a><span class="line-modified"> 25 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;</span>


 26 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
 27 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
<a name="3" id="anc3"></a><span class="line-added"> 28 import static jdk.internal.misc.Unsafe.ADDRESS_SIZE;</span>
 29 
 30 import java.lang.annotation.Annotation;
<a name="4" id="anc4"></a><span class="line-modified"> 31 </span>
<span class="line-modified"> 32 import jdk.internal.vm.annotation.Stable;</span>
 33 
 34 import jdk.vm.ci.meta.JavaConstant;
 35 import jdk.vm.ci.meta.JavaType;
 36 import jdk.vm.ci.meta.ResolvedJavaType;
 37 import jdk.vm.ci.meta.UnresolvedJavaType;
 38 
 39 /**
 40  * Represents a field in a HotSpot type.
 41  */
 42 class HotSpotResolvedJavaFieldImpl implements HotSpotResolvedJavaField {
 43 
 44     private final HotSpotResolvedObjectTypeImpl holder;
 45     private JavaType type;
<a name="5" id="anc5"></a><span class="line-added"> 46 </span>
<span class="line-added"> 47     /**</span>
<span class="line-added"> 48      * Value of {@code fieldDescriptor::access_flags()}.</span>
<span class="line-added"> 49      */</span>
 50     private final int offset;
<a name="6" id="anc6"></a><span class="line-added"> 51 </span>
<span class="line-added"> 52     /**</span>
<span class="line-added"> 53      * Value of {@code fieldDescriptor::index()}.</span>
<span class="line-added"> 54      */</span>
 55     private final short index;
 56 
 57     /**
 58      * This value contains all flags as stored in the VM including internal ones.
 59      */
 60     private final int modifiers;
 61 
 62     HotSpotResolvedJavaFieldImpl(HotSpotResolvedObjectTypeImpl holder, JavaType type, long offset, int modifiers, int index) {
 63         this.holder = holder;
 64         this.type = type;
 65         this.index = (short) index;
 66         assert this.index == index;
 67         assert offset != -1;
 68         assert offset == (int) offset : &quot;offset larger than int&quot;;
 69         this.offset = (int) offset;
 70         this.modifiers = modifiers;
 71     }
 72 
 73     @Override
 74     public boolean equals(Object obj) {
 75         if (this == obj) {
 76             return true;
 77         }
<a name="7" id="anc7"></a><span class="line-modified"> 78         if (obj instanceof HotSpotResolvedJavaFieldImpl) {</span>
 79             HotSpotResolvedJavaFieldImpl that = (HotSpotResolvedJavaFieldImpl) obj;
 80             if (that.offset != this.offset || that.isStatic() != this.isStatic()) {
 81                 return false;
 82             } else if (this.holder.equals(that.holder)) {
 83                 return true;
 84             }
 85         }
 86         return false;
 87     }
 88 
 89     @Override
 90     public int hashCode() {
 91         return holder.hashCode() ^ offset;
 92     }
 93 
 94     @Override
 95     public int getModifiers() {
<a name="8" id="anc8"></a><span class="line-modified"> 96         return modifiers &amp; HotSpotModifiers.jvmFieldModifiers();</span>
 97     }
 98 
 99     @Override
100     public boolean isInternal() {
101         return (modifiers &amp; config().jvmAccFieldInternal) != 0;
102     }
103 
104     /**
105      * Determines if a given object contains this field.
106      *
107      * @return true iff this is a non-static field and its declaring class is assignable from
108      *         {@code object}&#39;s class
109      */
110     @Override
<a name="9" id="anc9"></a><span class="line-modified">111     public boolean isInObject(JavaConstant object) {</span>
112         if (isStatic()) {
113             return false;
114         }
<a name="10" id="anc10"></a><span class="line-modified">115         HotSpotObjectConstant constant = (HotSpotObjectConstant) object;</span>
<span class="line-modified">116         return getDeclaringClass().isAssignableFrom(constant.getType());</span>
117     }
118 
119     @Override
120     public HotSpotResolvedObjectTypeImpl getDeclaringClass() {
121         return holder;
122     }
123 
124     @Override
125     public String getName() {
126         return holder.createFieldInfo(index).getName();
127     }
128 
129     @Override
130     public JavaType getType() {
131         // Pull field into local variable to prevent a race causing
132         // a ClassCastException below
133         JavaType currentType = type;
134         if (currentType instanceof UnresolvedJavaType) {
135             // Don&#39;t allow unresolved types to hang around forever
136             UnresolvedJavaType unresolvedType = (UnresolvedJavaType) currentType;
<a name="11" id="anc11"></a><span class="line-modified">137             JavaType resolved = HotSpotJVMCIRuntime.runtime().lookupType(unresolvedType.getName(), holder, false);</span>
<span class="line-modified">138             if (resolved instanceof ResolvedJavaType) {</span>
139                 type = resolved;
140             }
141         }
142         return type;
<a name="12" id="anc12"></a><span class="line-added">143 </span>
144     }
145 
146     @Override
147     public int getOffset() {
148         return offset;
149     }
150 
<a name="13" id="anc13"></a><span class="line-added">151     /**</span>
<span class="line-added">152      * Gets the value of this field&#39;s index (i.e. {@code fieldDescriptor::index()} in the encoded</span>
<span class="line-added">153      * fields of the declaring class.</span>
<span class="line-added">154      */</span>
<span class="line-added">155     int getIndex() {</span>
<span class="line-added">156         return index;</span>
<span class="line-added">157     }</span>
<span class="line-added">158 </span>
159     @Override
160     public String toString() {
<a name="14" id="anc14"></a><span class="line-modified">161         return format(&quot;HotSpotResolvedJavaFieldImpl&lt;%H.%n %t:&quot;) + offset + &quot;&gt;&quot;;</span>
162     }
163 
164     @Override
165     public boolean isSynthetic() {
166         return (config().jvmAccSynthetic &amp; modifiers) != 0;
167     }
168 
169     /**
<a name="15" id="anc15"></a><span class="line-modified">170      * Checks if this field has the {@link Stable} annotation.</span>
171      *
<a name="16" id="anc16"></a><span class="line-modified">172      * @return true if field has {@link Stable} annotation, false otherwise</span>
173      */
174     @Override
175     public boolean isStable() {
176         return (config().jvmAccFieldStable &amp; modifiers) != 0;
177     }
178 
179     private boolean hasAnnotations() {
180         if (!isInternal()) {
181             HotSpotVMConfig config = config();
182             final long metaspaceAnnotations = UNSAFE.getAddress(holder.getMetaspaceKlass() + config.instanceKlassAnnotationsOffset);
183             if (metaspaceAnnotations != 0) {
184                 long fieldsAnnotations = UNSAFE.getAddress(metaspaceAnnotations + config.annotationsFieldAnnotationsOffset);
185                 if (fieldsAnnotations != 0) {
186                     long fieldAnnotations = UNSAFE.getAddress(fieldsAnnotations + config.fieldsAnnotationsBaseOffset + (ADDRESS_SIZE * index));
187                     return fieldAnnotations != 0;
188                 }
189             }
190         }
191         return false;
192     }
193 
194     @Override
195     public Annotation[] getAnnotations() {
196         if (!hasAnnotations()) {
197             return new Annotation[0];
198         }
<a name="17" id="anc17"></a><span class="line-modified">199         return runtime().reflection.getFieldAnnotations(this);</span>
200     }
201 
202     @Override
203     public Annotation[] getDeclaredAnnotations() {
204         if (!hasAnnotations()) {
205             return new Annotation[0];
206         }
<a name="18" id="anc18"></a><span class="line-modified">207         return runtime().reflection.getFieldDeclaredAnnotations(this);</span>
208     }
209 
210     @Override
211     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
212         if (!hasAnnotations()) {
213             return null;
214         }
<a name="19" id="anc19"></a><span class="line-modified">215         return runtime().reflection.getFieldAnnotation(this, annotationClass);</span>























216     }
217 }
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
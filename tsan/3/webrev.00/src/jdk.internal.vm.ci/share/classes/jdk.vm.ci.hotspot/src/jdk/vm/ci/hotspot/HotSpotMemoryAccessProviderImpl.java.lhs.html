<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotMemoryAccessProviderImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
<a name="2" id="anc2"></a>
 25 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 26 
<a name="3" id="anc3"></a><span class="line-removed"> 27 import java.lang.reflect.Array;</span>
<span class="line-removed"> 28 </span>
<span class="line-removed"> 29 import jdk.vm.ci.common.JVMCIError;</span>
 30 import jdk.vm.ci.meta.Constant;
 31 import jdk.vm.ci.meta.JavaConstant;
 32 import jdk.vm.ci.meta.JavaKind;
 33 import jdk.vm.ci.meta.MemoryAccessProvider;
<a name="4" id="anc4"></a><span class="line-removed"> 34 import jdk.vm.ci.meta.MetaAccessProvider;</span>
 35 import jdk.vm.ci.meta.PrimitiveConstant;
<a name="5" id="anc5"></a><span class="line-removed"> 36 import jdk.vm.ci.meta.ResolvedJavaField;</span>
<span class="line-removed"> 37 import jdk.vm.ci.meta.ResolvedJavaType;</span>
 38 
 39 /**
 40  * HotSpot implementation of {@link MemoryAccessProvider}.
 41  */
 42 class HotSpotMemoryAccessProviderImpl implements HotSpotMemoryAccessProvider {
 43 
 44     protected final HotSpotJVMCIRuntime runtime;
 45 
 46     HotSpotMemoryAccessProviderImpl(HotSpotJVMCIRuntime runtime) {
 47         this.runtime = runtime;
 48     }
 49 
 50     /**
 51      * Gets the object boxed by {@code base} that is about to have a value of kind {@code kind} read
 52      * from it at the offset {@code displacement}.
 53      *
 54      * @param base constant value containing the base address for a pending read
 55      * @return {@code null} if {@code base} does not box an object otherwise the object boxed in
 56      *         {@code base}
 57      */
<a name="6" id="anc6"></a><span class="line-modified"> 58     private Object asObject(Constant base, JavaKind kind, long displacement) {</span>
 59         if (base instanceof HotSpotObjectConstantImpl) {
 60             HotSpotObjectConstantImpl constant = (HotSpotObjectConstantImpl) base;
 61             HotSpotResolvedObjectType type = constant.getType();
<a name="7" id="anc7"></a><span class="line-modified"> 62             Object object = constant.object();</span>
<span class="line-modified"> 63             checkRead(kind, displacement, type, object, runtime.getHostJVMCIBackend().getMetaAccess());</span>
<span class="line-removed"> 64             return object;</span>
 65         }
 66         return null;
 67     }
 68 
<a name="8" id="anc8"></a><span class="line-modified"> 69     /**</span>
<span class="line-modified"> 70      * Offset of injected {@code java.lang.Class::oop_size} field. No need to make {@code volatile}</span>
<span class="line-modified"> 71      * as initialization is idempotent.</span>
<span class="line-modified"> 72      */</span>
<span class="line-modified"> 73     private long oopSizeOffset;</span>
<span class="line-modified"> 74 </span>
<span class="line-modified"> 75     private static int computeOopSizeOffset(HotSpotJVMCIRuntime runtime) {</span>
<span class="line-removed"> 76         MetaAccessProvider metaAccess = runtime.getHostJVMCIBackend().getMetaAccess();</span>
<span class="line-removed"> 77         ResolvedJavaType staticType = metaAccess.lookupJavaType(Class.class);</span>
<span class="line-removed"> 78         for (ResolvedJavaField f : staticType.getInstanceFields(false)) {</span>
<span class="line-removed"> 79             if (f.getName().equals(&quot;oop_size&quot;)) {</span>
<span class="line-removed"> 80                 int offset = ((HotSpotResolvedJavaField) f).getOffset();</span>
<span class="line-removed"> 81                 assert offset != 0 : &quot;not expecting offset of java.lang.Class::oop_size to be 0&quot;;</span>
<span class="line-removed"> 82                 return offset;</span>
<span class="line-removed"> 83             }</span>
<span class="line-removed"> 84         }</span>
<span class="line-removed"> 85         throw new JVMCIError(&quot;Could not find injected java.lang.Class::oop_size field&quot;);</span>
<span class="line-removed"> 86     }</span>
<span class="line-removed"> 87 </span>
<span class="line-removed"> 88     private boolean checkRead(JavaKind kind, long displacement, HotSpotResolvedObjectType type, Object object, MetaAccessProvider metaAccess) {</span>
<span class="line-removed"> 89         if (type.isArray()) {</span>
<span class="line-removed"> 90             ResolvedJavaType componentType = type.getComponentType();</span>
<span class="line-removed"> 91             JavaKind componentKind = componentType.getJavaKind();</span>
<span class="line-removed"> 92             final int headerSize = metaAccess.getArrayBaseOffset(componentKind);</span>
<span class="line-removed"> 93             int sizeOfElement = metaAccess.getArrayIndexScale(componentKind);</span>
<span class="line-removed"> 94             int length = Array.getLength(object);</span>
<span class="line-removed"> 95             long arrayEnd = headerSize + (sizeOfElement * length);</span>
<span class="line-removed"> 96             boolean aligned = ((displacement - headerSize) % sizeOfElement) == 0;</span>
<span class="line-removed"> 97             if (displacement &lt; 0 || displacement &gt; (arrayEnd - sizeOfElement) || (kind == JavaKind.Object &amp;&amp; !aligned)) {</span>
<span class="line-removed"> 98                 int index = (int) ((displacement - headerSize) / sizeOfElement);</span>
<span class="line-removed"> 99                 throw new IllegalArgumentException(&quot;Unsafe array access: reading element of kind &quot; + kind +</span>
<span class="line-removed">100                                 &quot; at offset &quot; + displacement + &quot; (index ~ &quot; + index + &quot;) in &quot; +</span>
<span class="line-removed">101                                 type.toJavaName() + &quot; object of length &quot; + length);</span>
<span class="line-removed">102             }</span>
<span class="line-removed">103         } else if (kind != JavaKind.Object) {</span>
<span class="line-removed">104             long size;</span>
<span class="line-removed">105             if (object instanceof Class) {</span>
<span class="line-removed">106                 if (oopSizeOffset == 0) {</span>
<span class="line-removed">107                     oopSizeOffset = computeOopSizeOffset(runtime);</span>
108                 }
<a name="9" id="anc9"></a><span class="line-removed">109                 int wordSize = runtime.getHostJVMCIBackend().getCodeCache().getTarget().wordSize;</span>
<span class="line-removed">110                 size = UNSAFE.getInt(object, oopSizeOffset) * wordSize;</span>
111             } else {
<a name="10" id="anc10"></a><span class="line-modified">112                 size = Math.abs(type.instanceSize());</span>
<span class="line-removed">113             }</span>
<span class="line-removed">114             int bytesToRead = kind.getByteCount();</span>
<span class="line-removed">115             if (displacement + bytesToRead &gt; size || displacement &lt; 0) {</span>
<span class="line-removed">116                 throw new IllegalArgumentException(&quot;Unsafe access: reading &quot; + bytesToRead + &quot; bytes at offset &quot; + displacement + &quot; in &quot; +</span>
<span class="line-removed">117                                 type.toJavaName() + &quot; object of size &quot; + size);</span>
<span class="line-removed">118             }</span>
<span class="line-removed">119         } else {</span>
<span class="line-removed">120             ResolvedJavaField field = type.findInstanceFieldWithOffset(displacement, JavaKind.Object);</span>
<span class="line-removed">121             if (field == null &amp;&amp; object instanceof Class) {</span>
<span class="line-removed">122                 // Read of a static field</span>
<span class="line-removed">123                 HotSpotResolvedObjectTypeImpl staticFieldsHolder = (HotSpotResolvedObjectTypeImpl) metaAccess.lookupJavaType((Class&lt;?&gt;) object);</span>
<span class="line-removed">124                 field = staticFieldsHolder.findStaticFieldWithOffset(displacement, JavaKind.Object);</span>
<span class="line-removed">125             }</span>
<span class="line-removed">126             if (field == null) {</span>
<span class="line-removed">127                 throw new IllegalArgumentException(&quot;Unsafe object access: field not found for read of kind Object&quot; +</span>
<span class="line-removed">128                                 &quot; at offset &quot; + displacement + &quot; in &quot; + type.toJavaName() + &quot; object&quot;);</span>
<span class="line-removed">129             }</span>
<span class="line-removed">130             if (field.getJavaKind() != JavaKind.Object) {</span>
<span class="line-removed">131                 throw new IllegalArgumentException(&quot;Unsafe object access: field &quot; + field.format(&quot;%H.%n:%T&quot;) + &quot; not of expected kind Object&quot; +</span>
<span class="line-removed">132                                 &quot; at offset &quot; + displacement + &quot; in &quot; + type.toJavaName() + &quot; object&quot;);</span>
133             }
134         }
<a name="11" id="anc11"></a><span class="line-modified">135         return true;</span>
136     }
137 
138     private static long asRawPointer(Constant base) {
139         if (base instanceof HotSpotMetaspaceConstantImpl) {
<a name="12" id="anc12"></a><span class="line-modified">140             MetaspaceWrapperObject meta = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
141             return meta.getMetaspacePointer();
142         } else if (base instanceof PrimitiveConstant) {
143             PrimitiveConstant prim = (PrimitiveConstant) base;
144             if (prim.getJavaKind().isNumericInteger()) {
145                 return prim.asLong();
146             }
147         }
148         throw new IllegalArgumentException(String.valueOf(base));
149     }
150 
<a name="13" id="anc13"></a><span class="line-modified">151     private long readRawValue(Constant baseConstant, long displacement, JavaKind kind, int bits) {</span>
<span class="line-modified">152         Object base = asObject(baseConstant, kind, displacement);</span>
153         if (base != null) {
154             switch (bits) {
155                 case Byte.SIZE:
<a name="14" id="anc14"></a><span class="line-modified">156                     return UNSAFE.getByte(base, displacement);</span>
157                 case Short.SIZE:
<a name="15" id="anc15"></a><span class="line-modified">158                     return UNSAFE.getShort(base, displacement);</span>
159                 case Integer.SIZE:
<a name="16" id="anc16"></a><span class="line-modified">160                     return UNSAFE.getInt(base, displacement);</span>
161                 case Long.SIZE:
<a name="17" id="anc17"></a><span class="line-modified">162                     return UNSAFE.getLong(base, displacement);</span>
163                 default:
164                     throw new IllegalArgumentException(String.valueOf(bits));
165             }
166         } else {
167             long pointer = asRawPointer(baseConstant);
168             switch (bits) {
169                 case Byte.SIZE:
170                     return UNSAFE.getByte(pointer + displacement);
171                 case Short.SIZE:
172                     return UNSAFE.getShort(pointer + displacement);
173                 case Integer.SIZE:
174                     return UNSAFE.getInt(pointer + displacement);
175                 case Long.SIZE:
176                     return UNSAFE.getLong(pointer + displacement);
177                 default:
178                     throw new IllegalArgumentException(String.valueOf(bits));
179             }
180         }
181     }
182 
<a name="18" id="anc18"></a><span class="line-modified">183     private boolean verifyReadRawObject(Object expected, Constant base, long displacement) {</span>
184         if (base instanceof HotSpotMetaspaceConstant) {
<a name="19" id="anc19"></a><span class="line-modified">185             MetaspaceWrapperObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
186             if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {
<a name="20" id="anc20"></a><span class="line-modified">187                 if (displacement == runtime.getConfig().classMirrorHandleOffset) {</span>
<span class="line-modified">188                     assert expected == ((HotSpotResolvedObjectTypeImpl) metaspaceObject).mirror();</span>

189                 }
190             }
191         }
192         return true;
193     }
194 
<a name="21" id="anc21"></a><span class="line-modified">195     private Object readRawObject(Constant baseConstant, long initialDisplacement, boolean compressed) {</span>
196         long displacement = initialDisplacement;
<a name="22" id="anc22"></a><span class="line-modified">197         Object ret;</span>
<span class="line-modified">198         Object base = asObject(baseConstant, JavaKind.Object, displacement);</span>
199         if (base == null) {
200             assert !compressed;
201             displacement += asRawPointer(baseConstant);
<a name="23" id="anc23"></a><span class="line-modified">202             ret = UNSAFE.getUncompressedObject(displacement);</span>
203             assert verifyReadRawObject(ret, baseConstant, initialDisplacement);
204         } else {
205             assert runtime.getConfig().useCompressedOops == compressed;
<a name="24" id="anc24"></a><span class="line-modified">206             ret = UNSAFE.getReference(base, displacement);</span>
<span class="line-removed">207         }</span>
<span class="line-removed">208         return ret;</span>
<span class="line-removed">209     }</span>
<span class="line-removed">210 </span>
<span class="line-removed">211     JavaConstant readFieldValue(HotSpotResolvedJavaField field, Object obj, boolean isVolatile) {</span>
<span class="line-removed">212         assert obj != null;</span>
<span class="line-removed">213         assert !field.isStatic() || obj instanceof Class;</span>
<span class="line-removed">214         long displacement = field.getOffset();</span>
<span class="line-removed">215         assert checkRead(field.getJavaKind(), displacement, (HotSpotResolvedObjectType) runtime.getHostJVMCIBackend().getMetaAccess().lookupJavaType(obj.getClass()), obj,</span>
<span class="line-removed">216                         runtime.getHostJVMCIBackend().getMetaAccess());</span>
<span class="line-removed">217         JavaKind kind = field.getJavaKind();</span>
<span class="line-removed">218         switch (kind) {</span>
<span class="line-removed">219             case Boolean:</span>
<span class="line-removed">220                 return JavaConstant.forBoolean(isVolatile ? UNSAFE.getBooleanVolatile(obj, displacement) : UNSAFE.getBoolean(obj, displacement));</span>
<span class="line-removed">221             case Byte:</span>
<span class="line-removed">222                 return JavaConstant.forByte(isVolatile ? UNSAFE.getByteVolatile(obj, displacement) : UNSAFE.getByte(obj, displacement));</span>
<span class="line-removed">223             case Char:</span>
<span class="line-removed">224                 return JavaConstant.forChar(isVolatile ? UNSAFE.getCharVolatile(obj, displacement) : UNSAFE.getChar(obj, displacement));</span>
<span class="line-removed">225             case Short:</span>
<span class="line-removed">226                 return JavaConstant.forShort(isVolatile ? UNSAFE.getShortVolatile(obj, displacement) : UNSAFE.getShort(obj, displacement));</span>
<span class="line-removed">227             case Int:</span>
<span class="line-removed">228                 return JavaConstant.forInt(isVolatile ? UNSAFE.getIntVolatile(obj, displacement) : UNSAFE.getInt(obj, displacement));</span>
<span class="line-removed">229             case Long:</span>
<span class="line-removed">230                 return JavaConstant.forLong(isVolatile ? UNSAFE.getLongVolatile(obj, displacement) : UNSAFE.getLong(obj, displacement));</span>
<span class="line-removed">231             case Float:</span>
<span class="line-removed">232                 return JavaConstant.forFloat(isVolatile ? UNSAFE.getFloatVolatile(obj, displacement) : UNSAFE.getFloat(obj, displacement));</span>
<span class="line-removed">233             case Double:</span>
<span class="line-removed">234                 return JavaConstant.forDouble(isVolatile ? UNSAFE.getDoubleVolatile(obj, displacement) : UNSAFE.getDouble(obj, displacement));</span>
<span class="line-removed">235             case Object:</span>
<span class="line-removed">236                 return HotSpotObjectConstantImpl.forObject(isVolatile ? UNSAFE.getReferenceVolatile(obj, displacement) : UNSAFE.getReference(obj, displacement));</span>
<span class="line-removed">237             default:</span>
<span class="line-removed">238                 throw new IllegalArgumentException(&quot;Unsupported kind: &quot; + kind);</span>
239         }
<a name="25" id="anc25"></a>
240     }
241 
242     @Override
243     public JavaConstant readPrimitiveConstant(JavaKind kind, Constant baseConstant, long initialDisplacement, int bits) {
244         try {
245             long rawValue = readRawValue(baseConstant, initialDisplacement, kind, bits);
246             switch (kind) {
247                 case Boolean:
248                     return JavaConstant.forBoolean(rawValue != 0);
249                 case Byte:
250                     return JavaConstant.forByte((byte) rawValue);
251                 case Char:
252                     return JavaConstant.forChar((char) rawValue);
253                 case Short:
254                     return JavaConstant.forShort((short) rawValue);
255                 case Int:
256                     return JavaConstant.forInt((int) rawValue);
257                 case Long:
258                     return JavaConstant.forLong(rawValue);
259                 case Float:
260                     return JavaConstant.forFloat(Float.intBitsToFloat((int) rawValue));
261                 case Double:
262                     return JavaConstant.forDouble(Double.longBitsToDouble(rawValue));
263                 default:
264                     throw new IllegalArgumentException(&quot;Unsupported kind: &quot; + kind);
265             }
266         } catch (NullPointerException e) {
267             return null;
268         }
269     }
270 
271     @Override
272     public JavaConstant readObjectConstant(Constant base, long displacement) {
273         if (base instanceof HotSpotObjectConstantImpl) {
<a name="26" id="anc26"></a><span class="line-modified">274             Object o = readRawObject(base, displacement, runtime.getConfig().useCompressedOops);</span>
<span class="line-removed">275             return HotSpotObjectConstantImpl.forObject(o);</span>
276         }
<a name="27" id="anc27"></a><span class="line-modified">277         if (base instanceof HotSpotMetaspaceConstant) {</span>
<span class="line-modified">278             MetaspaceWrapperObject metaspaceObject = HotSpotMetaspaceConstantImpl.getMetaspaceObject(base);</span>
<span class="line-removed">279             if (metaspaceObject instanceof HotSpotResolvedObjectTypeImpl) {</span>
<span class="line-removed">280                  if (displacement == runtime.getConfig().classMirrorHandleOffset) {</span>
<span class="line-removed">281                     // Klass::_java_mirror is valid for all Klass* values</span>
<span class="line-removed">282                     return HotSpotObjectConstantImpl.forObject(((HotSpotResolvedObjectTypeImpl) metaspaceObject).mirror());</span>
<span class="line-removed">283                  }</span>
<span class="line-removed">284              } else {</span>
<span class="line-removed">285                  throw new IllegalArgumentException(String.valueOf(metaspaceObject));</span>
<span class="line-removed">286              }</span>
287         }
<a name="28" id="anc28"></a><span class="line-modified">288         return null;</span>





289     }
290 
291     @Override
292     public JavaConstant readNarrowOopConstant(Constant base, long displacement) {
<a name="29" id="anc29"></a><span class="line-modified">293         return HotSpotObjectConstantImpl.forObject(readRawObject(base, displacement, true), true);</span>

294     }
295 
296     private HotSpotResolvedObjectTypeImpl readKlass(Constant base, long displacement, boolean compressed) {
297         assert (base instanceof HotSpotMetaspaceConstantImpl) || (base instanceof HotSpotObjectConstantImpl) : base.getClass();
<a name="30" id="anc30"></a><span class="line-modified">298         Object baseObject = (base instanceof HotSpotMetaspaceConstantImpl) ? ((HotSpotMetaspaceConstantImpl) base).asResolvedJavaType() : ((HotSpotObjectConstantImpl) base).object();</span>
<span class="line-modified">299         return runtime.getCompilerToVM().getResolvedJavaType(baseObject, displacement, compressed);</span>



300     }
301 
<a name="31" id="anc31"></a>
302     @Override
303     public Constant readKlassPointerConstant(Constant base, long displacement) {
304         HotSpotResolvedObjectTypeImpl klass = readKlass(base, displacement, false);
305         if (klass == null) {
306             return JavaConstant.NULL_POINTER;
307         }
308         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(klass, false);
309     }
310 
311     @Override
312     public Constant readNarrowKlassPointerConstant(Constant base, long displacement) {
313         HotSpotResolvedObjectTypeImpl klass = readKlass(base, displacement, true);
314         if (klass == null) {
315             return HotSpotCompressedNullConstant.COMPRESSED_NULL;
316         }
317         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(klass, true);
318     }
319 
320     @Override
321     public Constant readMethodPointerConstant(Constant base, long displacement) {
322         assert (base instanceof HotSpotObjectConstantImpl);
<a name="32" id="anc32"></a><span class="line-modified">323         Object baseObject = ((HotSpotObjectConstantImpl) base).object();</span>
<span class="line-removed">324         HotSpotResolvedJavaMethodImpl method = runtime.getCompilerToVM().getResolvedJavaMethod(baseObject, displacement);</span>
325         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(method, false);
326     }
327 }
<a name="33" id="anc33"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="33" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfigAccess.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotVMConfig.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotVMConfigStore.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotVMConfigAccess.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 20,10 ***</span>
<span class="line-new-header">--- 20,13 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  package jdk.vm.ci.hotspot;
  
<span class="line-added">+ import java.util.Set;</span>
<span class="line-added">+ import java.util.stream.Collectors;</span>
<span class="line-added">+ </span>
  import jdk.vm.ci.common.JVMCIError;
  
  /**
   * Access to VM configuration data.
   */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,12 ***</span>
          Long entry = store.vmAddresses.get(name);
          if (entry == null) {
              if (notPresent != null) {
                  return notPresent;
              }
<span class="line-modified">!             store.printConfig();</span>
<span class="line-modified">!             throw new JVMCIError(&quot;expected VM symbol not found in &quot; + store + &quot;: &quot; + name);</span>
          }
          return entry;
      }
  
      /**
<span class="line-new-header">--- 51,12 ---</span>
          Long entry = store.vmAddresses.get(name);
          if (entry == null) {
              if (notPresent != null) {
                  return notPresent;
              }
<span class="line-modified">!             throw missingEntry(&quot;address&quot;, name, store.vmFlags.keySet());</span>
<span class="line-modified">! </span>
          }
          return entry;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,12 ***</span>
          Long c = store.vmConstants.get(name);
          if (c == null) {
              if (notPresent != null) {
                  return notPresent;
              }
<span class="line-modified">!             store.printConfig();</span>
<span class="line-removed">-             throw new JVMCIError(&quot;expected VM constant not found in &quot; + store + &quot;: &quot; + name);</span>
          }
          return type.cast(convertValue(name, type, c, null));
      }
  
      /**
<span class="line-new-header">--- 83,11 ---</span>
          Long c = store.vmConstants.get(name);
          if (c == null) {
              if (notPresent != null) {
                  return notPresent;
              }
<span class="line-modified">!             throw missingEntry(&quot;constant&quot;, name, store.vmConstants.keySet());</span>
          }
          return type.cast(convertValue(name, type, c, null));
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,19 ***</span>
       * @param notPresent if non-null and the field is not present then this value is returned
       * @return the offset in bytes of the requested field
       * @throws JVMCIError if the field is static or not present and {@code notPresent} is null
       */
      public &lt;T&gt; T getFieldOffset(String name, Class&lt;T&gt; type, String cppType, T notPresent) {
<span class="line-modified">!         assert type == Integer.class || type == Long.class;</span>
<span class="line-modified">!         VMField entry = getField(name, cppType, notPresent == null);</span>
<span class="line-modified">!         if (entry == null) {</span>
<span class="line-modified">!             return notPresent;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (entry.address != 0) {</span>
<span class="line-modified">!             throw new JVMCIError(&quot;cannot get offset of static field &quot; + name);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return type.cast(convertValue(name, type, entry.offset, cppType));</span>
      }
  
      /**
       * Gets the offset of a non-static C++ field.
       *
<span class="line-new-header">--- 112,27 ---</span>
       * @param notPresent if non-null and the field is not present then this value is returned
       * @return the offset in bytes of the requested field
       * @throws JVMCIError if the field is static or not present and {@code notPresent} is null
       */
      public &lt;T&gt; T getFieldOffset(String name, Class&lt;T&gt; type, String cppType, T notPresent) {
<span class="line-modified">!         return getFieldOffset0(name, type, notPresent, cppType, null);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Gets the offset of a non-static C++ field.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param name fully qualified name of the field</span>
<span class="line-modified">!      * @param type the boxed type to which the offset value will be converted (must be</span>
<span class="line-modified">!      *            {@link Integer} or {@link Long})</span>
<span class="line-added">+      * @param notPresent if non-null and the field is not present then this value is returned</span>
<span class="line-added">+      * @param outCppType if non-null, the C++ type of the field (e.g., {@code &quot;HeapWord*&quot;}) is</span>
<span class="line-added">+      *            returned in element 0 of this array</span>
<span class="line-added">+      * @return the offset in bytes of the requested field</span>
<span class="line-added">+      * @throws JVMCIError if the field is static or not present and {@code notPresent} is null</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public &lt;T&gt; T getFieldOffset(String name, Class&lt;T&gt; type, T notPresent, String[] outCppType) {</span>
<span class="line-added">+         return getFieldOffset0(name, type, notPresent, null, outCppType);</span>
      }
  
      /**
       * Gets the offset of a non-static C++ field.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 132,11 ***</span>
       * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
       * @return the offset in bytes of the requested field
       * @throws JVMCIError if the field is static or not present
       */
      public &lt;T&gt; T getFieldOffset(String name, Class&lt;T&gt; type, String cppType) {
<span class="line-modified">!         return getFieldOffset(name, type, cppType, null);</span>
      }
  
      /**
       * Gets the offset of a non-static C++ field.
       *
<span class="line-new-header">--- 142,11 ---</span>
       * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
       * @return the offset in bytes of the requested field
       * @throws JVMCIError if the field is static or not present
       */
      public &lt;T&gt; T getFieldOffset(String name, Class&lt;T&gt; type, String cppType) {
<span class="line-modified">!         return getFieldOffset0(name, type, null, cppType, null);</span>
      }
  
      /**
       * Gets the offset of a non-static C++ field.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 145,11 ***</span>
       *            {@link Integer} or {@link Long})
       * @return the offset in bytes of the requested field
       * @throws JVMCIError if the field is static or not present
       */
      public &lt;T&gt; T getFieldOffset(String name, Class&lt;T&gt; type) {
<span class="line-modified">!         return getFieldOffset(name, type, null, null);</span>
      }
  
      /**
       * Gets the address of a static C++ field.
       *
<span class="line-new-header">--- 155,26 ---</span>
       *            {@link Integer} or {@link Long})
       * @return the offset in bytes of the requested field
       * @throws JVMCIError if the field is static or not present
       */
      public &lt;T&gt; T getFieldOffset(String name, Class&lt;T&gt; type) {
<span class="line-modified">!         return getFieldOffset0(name, type, null, null, null);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private &lt;T&gt; T getFieldOffset0(String name, Class&lt;T&gt; type, T notPresent, String inCppType, String[] outCppType) {</span>
<span class="line-added">+         assert type == Integer.class || type == Long.class;</span>
<span class="line-added">+         VMField entry = getField(name, inCppType, notPresent == null);</span>
<span class="line-added">+         if (entry == null) {</span>
<span class="line-added">+             return notPresent;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (entry.address != 0) {</span>
<span class="line-added">+             throw new JVMCIError(&quot;cannot get offset of static field &quot; + name);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (outCppType != null) {</span>
<span class="line-added">+             outCppType[0] = entry.type;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return type.cast(convertValue(name, type, entry.offset, inCppType));</span>
      }
  
      /**
       * Gets the address of a static C++ field.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,18 ***</span>
       * @param notPresent if non-null and the field is not present then this value is returned
       * @return the address of the requested field
       * @throws JVMCIError if the field is not static or not present and {@code notPresent} is null
       */
      public long getFieldAddress(String name, String cppType, Long notPresent) {
<span class="line-modified">!         VMField entry = getField(name, cppType, notPresent == null);</span>
<span class="line-modified">!         if (entry == null) {</span>
<span class="line-modified">!             return notPresent;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (entry.address == 0) {</span>
<span class="line-modified">!             throw new JVMCIError(name + &quot; is not a static field&quot;);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return entry.address;</span>
      }
  
      /**
       * Gets the address of a static C++ field.
       *
<span class="line-new-header">--- 183,25 ---</span>
       * @param notPresent if non-null and the field is not present then this value is returned
       * @return the address of the requested field
       * @throws JVMCIError if the field is not static or not present and {@code notPresent} is null
       */
      public long getFieldAddress(String name, String cppType, Long notPresent) {
<span class="line-modified">!         return getFieldAddress0(name, notPresent, cppType, null);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Gets the address of a static C++ field.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param name fully qualified name of the field</span>
<span class="line-modified">!      * @param notPresent if non-null and the field is not present then this value is returned</span>
<span class="line-added">+      * @param outCppType if non-null, the C++ type of the field (e.g., {@code &quot;HeapWord*&quot;}) is</span>
<span class="line-added">+      *            returned in element 0 of this array</span>
<span class="line-added">+      * @return the address of the requested field</span>
<span class="line-added">+      * @throws JVMCIError if the field is not static or not present and {@code notPresent} is null</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public long getFieldAddress(String name, Long notPresent, String[] outCppType) {</span>
<span class="line-added">+         return getFieldAddress0(name, notPresent, null, outCppType);</span>
      }
  
      /**
       * Gets the address of a static C++ field.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 177,11 ***</span>
       * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
       * @return the address of the requested field
       * @throws JVMCIError if the field is not static or not present
       */
      public long getFieldAddress(String name, String cppType) {
<span class="line-modified">!         return getFieldAddress(name, cppType, null);</span>
      }
  
      /**
       * Gets the value of a static C++ field.
       *
<span class="line-new-header">--- 209,25 ---</span>
       * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
       * @return the address of the requested field
       * @throws JVMCIError if the field is not static or not present
       */
      public long getFieldAddress(String name, String cppType) {
<span class="line-modified">!         return getFieldAddress0(name, null, cppType, null);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private long getFieldAddress0(String name, Long notPresent, String inCppType, String[] outCppType) {</span>
<span class="line-added">+         VMField entry = getField(name, inCppType, notPresent == null);</span>
<span class="line-added">+         if (entry == null) {</span>
<span class="line-added">+             return notPresent;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (entry.address == 0) {</span>
<span class="line-added">+             throw new JVMCIError(name + &quot; is not a static field&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (outCppType != null) {</span>
<span class="line-added">+             outCppType[0] = entry.type;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return entry.address;</span>
      }
  
      /**
       * Gets the value of a static C++ field.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,18 ***</span>
       * @param notPresent if non-null and the field is not present then this value is returned
       * @return the value of the requested field
       * @throws JVMCIError if the field is not static or not present and {@code notPresent} is null
       */
      public &lt;T&gt; T getFieldValue(String name, Class&lt;T&gt; type, String cppType, T notPresent) {
<span class="line-modified">!         VMField entry = getField(name, cppType, notPresent == null);</span>
<span class="line-removed">-         if (entry == null) {</span>
<span class="line-removed">-             return notPresent;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (entry.value == null) {</span>
<span class="line-removed">-             throw new JVMCIError(name + &quot; is not a static field&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return type.cast(convertValue(name, type, entry.value, cppType));</span>
      }
  
      /**
       * Gets the value of a static C++ field.
       *
<span class="line-new-header">--- 237,11 ---</span>
       * @param notPresent if non-null and the field is not present then this value is returned
       * @return the value of the requested field
       * @throws JVMCIError if the field is not static or not present and {@code notPresent} is null
       */
      public &lt;T&gt; T getFieldValue(String name, Class&lt;T&gt; type, String cppType, T notPresent) {
<span class="line-modified">!         return getFieldValue0(name, type, notPresent, cppType, null);</span>
      }
  
      /**
       * Gets the value of a static C++ field.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 211,11 ***</span>
       * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
       * @return the value of the requested field
       * @throws JVMCIError if the field is not static or not present
       */
      public &lt;T&gt; T getFieldValue(String name, Class&lt;T&gt; type, String cppType) {
<span class="line-modified">!         return getFieldValue(name, type, cppType, null);</span>
      }
  
      /**
       * Gets the value of a static C++ field.
       *
<span class="line-new-header">--- 250,26 ---</span>
       * @param cppType if non-null, the expected C++ type of the field (e.g., {@code &quot;HeapWord*&quot;})
       * @return the value of the requested field
       * @throws JVMCIError if the field is not static or not present
       */
      public &lt;T&gt; T getFieldValue(String name, Class&lt;T&gt; type, String cppType) {
<span class="line-modified">!         return getFieldValue0(name, type, null, cppType, null);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Gets the value of a static C++ field.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param name fully qualified name of the field</span>
<span class="line-added">+      * @param type the boxed type to which the constant value will be converted</span>
<span class="line-added">+      * @param notPresent if non-null and the field is not present then this value is returned</span>
<span class="line-added">+      * @param outCppType if non-null, the C++ type of the field (e.g., {@code &quot;HeapWord*&quot;}) is</span>
<span class="line-added">+      *            returned in element 0 of this array</span>
<span class="line-added">+      * @return the value of the requested field</span>
<span class="line-added">+      * @throws JVMCIError if the field is not static or not present and {@code notPresent} is null</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public &lt;T&gt; T getFieldValue(String name, Class&lt;T&gt; type, T notPresent, String[] outCppType) {</span>
<span class="line-added">+         return getFieldValue0(name, type, notPresent, null, outCppType);</span>
      }
  
      /**
       * Gets the value of a static C++ field.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 223,11 ***</span>
       * @param type the boxed type to which the constant value will be converted
       * @return the value of the requested field
       * @throws JVMCIError if the field is not static or not present
       */
      public &lt;T&gt; T getFieldValue(String name, Class&lt;T&gt; type) {
<span class="line-modified">!         return getFieldValue(name, type, null, null);</span>
      }
  
      /**
       * Gets a C++ field.
       *
<span class="line-new-header">--- 277,25 ---</span>
       * @param type the boxed type to which the constant value will be converted
       * @return the value of the requested field
       * @throws JVMCIError if the field is not static or not present
       */
      public &lt;T&gt; T getFieldValue(String name, Class&lt;T&gt; type) {
<span class="line-modified">!         return getFieldValue0(name, type, null, null, null);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private &lt;T&gt; T getFieldValue0(String name, Class&lt;T&gt; type, T notPresent, String inCppType, String[] outCppType) {</span>
<span class="line-added">+         VMField entry = getField(name, inCppType, notPresent == null);</span>
<span class="line-added">+         if (entry == null) {</span>
<span class="line-added">+             return notPresent;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (entry.value == null) {</span>
<span class="line-added">+             throw new JVMCIError(name + &quot; is not a static field &quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (outCppType != null) {</span>
<span class="line-added">+             outCppType[0] = entry.type;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return type.cast(convertValue(name, type, entry.value, inCppType));</span>
      }
  
      /**
       * Gets a C++ field.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,12 ***</span>
          VMField entry = store.vmFields.get(name);
          if (entry == null) {
              if (!required) {
                  return null;
              }
<span class="line-modified">!             store.printConfig();</span>
<span class="line-removed">-             throw new JVMCIError(&quot;expected VM field not found in &quot; + store + &quot;: &quot; + name);</span>
          }
  
          // Make sure the native type is still the type we expect.
          if (cppType != null &amp;&amp; !cppType.equals(entry.type)) {
              throw new JVMCIError(&quot;expected type &quot; + cppType + &quot; but VM field &quot; + name + &quot; is of type &quot; + entry.type);
<span class="line-new-header">--- 309,11 ---</span>
          VMField entry = store.vmFields.get(name);
          if (entry == null) {
              if (!required) {
                  return null;
              }
<span class="line-modified">!             throw missingEntry(&quot;field&quot;, name, store.vmFields.keySet());</span>
          }
  
          // Make sure the native type is still the type we expect.
          if (cppType != null &amp;&amp; !cppType.equals(entry.type)) {
              throw new JVMCIError(&quot;expected type &quot; + cppType + &quot; but VM field &quot; + name + &quot; is of type &quot; + entry.type);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,22 ***</span>
              value = store.compilerToVm.getFlagValue(name);
              if (value == store.compilerToVm) {
                  if (notPresent != null) {
                      return notPresent;
                  }
<span class="line-modified">!                 store.printConfig();</span>
<span class="line-removed">-                 throw new JVMCIError(&quot;expected VM flag not found in &quot; + store + &quot;: &quot; + name);</span>
              } else {
                  cppType = null;
              }
          } else {
              value = entry.value;
              cppType = entry.type;
          }
          return type.cast(convertValue(name, type, value, cppType));
      }
  
      private static &lt;T&gt; Object convertValue(String name, Class&lt;T&gt; toType, Object value, String cppType) throws JVMCIError {
          if (toType == Boolean.class) {
              if (value instanceof String) {
                  return Boolean.valueOf((String) value);
              } else if (value instanceof Boolean) {
<span class="line-new-header">--- 353,26 ---</span>
              value = store.compilerToVm.getFlagValue(name);
              if (value == store.compilerToVm) {
                  if (notPresent != null) {
                      return notPresent;
                  }
<span class="line-modified">!                 throw missingEntry(&quot;flag&quot;, name, store.vmFlags.keySet());</span>
              } else {
                  cppType = null;
              }
          } else {
              value = entry.value;
              cppType = entry.type;
          }
          return type.cast(convertValue(name, type, value, cppType));
      }
  
<span class="line-added">+     private JVMCIError missingEntry(String category, String name, Set&lt;String&gt; keys) {</span>
<span class="line-added">+         throw new JVMCIError(&quot;expected VM %s not found in %s: %s%nAvailable values:%n    %s&quot;, category, store, name,</span>
<span class="line-added">+                         keys.stream().sorted().collect(Collectors.joining(System.lineSeparator() + &quot;    &quot;)));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private static &lt;T&gt; Object convertValue(String name, Class&lt;T&gt; toType, Object value, String cppType) throws JVMCIError {
          if (toType == Boolean.class) {
              if (value instanceof String) {
                  return Boolean.valueOf((String) value);
              } else if (value instanceof Boolean) {
</pre>
<center><a href="HotSpotVMConfig.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotVMConfigStore.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
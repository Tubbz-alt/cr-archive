<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotConstantPool.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotCompiledNmethod.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotConstantPoolObject.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotConstantPool.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
 26 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 27 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
 28 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 29 
<span class="line-removed"> 30 import java.lang.invoke.MethodHandle;</span>
<span class="line-removed"> 31 </span>
 32 import jdk.vm.ci.common.JVMCIError;

 33 import jdk.vm.ci.meta.ConstantPool;
 34 import jdk.vm.ci.meta.JavaConstant;
 35 import jdk.vm.ci.meta.JavaField;
 36 import jdk.vm.ci.meta.JavaMethod;
 37 import jdk.vm.ci.meta.JavaType;
 38 import jdk.vm.ci.meta.ResolvedJavaMethod;
 39 import jdk.vm.ci.meta.ResolvedJavaType;
 40 import jdk.vm.ci.meta.Signature;
 41 import jdk.vm.ci.meta.UnresolvedJavaField;
 42 import jdk.vm.ci.meta.UnresolvedJavaMethod;
 43 import jdk.vm.ci.meta.UnresolvedJavaType;
 44 
 45 /**
 46  * Implementation of {@link ConstantPool} for HotSpot.
 47  */
<span class="line-modified"> 48 public final class HotSpotConstantPool implements ConstantPool, MetaspaceWrapperObject {</span>
 49 
 50     /**
 51      * Subset of JVM bytecode opcodes used by {@link HotSpotConstantPool}.
 52      */
 53     public static class Bytecodes {
 54         public static final int LDC = 18; // 0x12
 55         public static final int LDC_W = 19; // 0x13
 56         public static final int LDC2_W = 20; // 0x14
 57         public static final int GETSTATIC = 178; // 0xB2
 58         public static final int PUTSTATIC = 179; // 0xB3
 59         public static final int GETFIELD = 180; // 0xB4
 60         public static final int PUTFIELD = 181; // 0xB5
 61         public static final int INVOKEVIRTUAL = 182; // 0xB6
 62         public static final int INVOKESPECIAL = 183; // 0xB7
 63         public static final int INVOKESTATIC = 184; // 0xB8
 64         public static final int INVOKEINTERFACE = 185; // 0xB9
 65         public static final int INVOKEDYNAMIC = 186; // 0xBA
 66         public static final int NEW = 187; // 0xBB
 67         public static final int NEWARRAY = 188; // 0xBC
 68         public static final int ANEWARRAY = 189; // 0xBD
</pre>
<hr />
<pre>
 80                     return true;
 81                 default:
 82                     return false;
 83             }
 84         }
 85 
 86         /**
 87          * See: {@code Rewriter::maybe_rewrite_invokehandle}.
 88          */
 89         static boolean isInvokeHandleAlias(int opcode) {
 90             switch (opcode) {
 91                 case INVOKEVIRTUAL:
 92                 case INVOKESPECIAL:
 93                     return true;
 94                 default:
 95                     return false;
 96             }
 97         }
 98     }
 99 
<span class="line-modified">100     /**</span>
<span class="line-removed">101      * Enum of all {@code JVM_CONSTANT} constants used in the VM. This includes the public and</span>
<span class="line-removed">102      * internal ones.</span>
<span class="line-removed">103      */</span>
<span class="line-removed">104     private enum JVM_CONSTANT {</span>
<span class="line-removed">105         // @formatter:off</span>
<span class="line-removed">106         Utf8(config().jvmConstantUtf8),</span>
<span class="line-removed">107         Integer(config().jvmConstantInteger),</span>
<span class="line-removed">108         Long(config().jvmConstantLong),</span>
<span class="line-removed">109         Float(config().jvmConstantFloat),</span>
<span class="line-removed">110         Double(config().jvmConstantDouble),</span>
<span class="line-removed">111         Class(config().jvmConstantClass),</span>
<span class="line-removed">112         UnresolvedClass(config().jvmConstantUnresolvedClass),</span>
<span class="line-removed">113         UnresolvedClassInError(config().jvmConstantUnresolvedClassInError),</span>
<span class="line-removed">114         String(config().jvmConstantString),</span>
<span class="line-removed">115         Fieldref(config().jvmConstantFieldref),</span>
<span class="line-removed">116         MethodRef(config().jvmConstantMethodref),</span>
<span class="line-removed">117         InterfaceMethodref(config().jvmConstantInterfaceMethodref),</span>
<span class="line-removed">118         NameAndType(config().jvmConstantNameAndType),</span>
<span class="line-removed">119         MethodHandle(config().jvmConstantMethodHandle),</span>
<span class="line-removed">120         MethodHandleInError(config().jvmConstantMethodHandleInError),</span>
<span class="line-removed">121         MethodType(config().jvmConstantMethodType),</span>
<span class="line-removed">122         MethodTypeInError(config().jvmConstantMethodTypeInError),</span>
<span class="line-removed">123         InvokeDynamic(config().jvmConstantInvokeDynamic);</span>
<span class="line-removed">124         // @formatter:on</span>
<span class="line-removed">125 </span>
126         private final int tag;

127 
<span class="line-modified">128         private static final int ExternalMax = config().jvmConstantExternalMax;</span>
<span class="line-removed">129         private static final int InternalMin = config().jvmConstantInternalMin;</span>
<span class="line-removed">130         private static final int InternalMax = config().jvmConstantInternalMax;</span>
<span class="line-removed">131 </span>
<span class="line-removed">132         JVM_CONSTANT(int tag) {</span>
133             this.tag = tag;

134         }
135 
<span class="line-modified">136         /**</span>
<span class="line-modified">137          * Maps JVM_CONSTANT tags to {@link JVM_CONSTANT} values. Using a separate class for lazy</span>
<span class="line-modified">138          * initialization.</span>
<span class="line-modified">139          */</span>
<span class="line-modified">140         static class TagValueMap {</span>
<span class="line-removed">141             private static final JVM_CONSTANT[] table = new JVM_CONSTANT[ExternalMax + 1 + (InternalMax - InternalMin) + 1];</span>
142 
<span class="line-modified">143             static {</span>
<span class="line-modified">144                 assert InternalMin &gt; ExternalMax;</span>
<span class="line-modified">145                 for (JVM_CONSTANT e : values()) {</span>
<span class="line-modified">146                     table[indexOf(e.tag)] = e;</span>
<span class="line-modified">147                 }</span>
<span class="line-modified">148             }</span>




























149 
<span class="line-modified">150             private static int indexOf(int tag) {</span>
<span class="line-modified">151                 if (tag &gt;= InternalMin) {</span>
<span class="line-modified">152                     return tag - InternalMin + ExternalMax + 1;</span>
<span class="line-modified">153                 } else {</span>
<span class="line-modified">154                     assert tag &lt;= ExternalMax;</span>
<span class="line-removed">155                 }</span>
<span class="line-removed">156                 return tag;</span>
157             }


158 
<span class="line-modified">159             static JVM_CONSTANT get(int tag) {</span>
<span class="line-modified">160                 JVM_CONSTANT res = table[indexOf(tag)];</span>
<span class="line-modified">161                 if (res != null) {</span>
<span class="line-modified">162                     return res;</span>
<span class="line-removed">163                 }</span>
<span class="line-removed">164                 throw new JVMCIError(&quot;Unknown JVM_CONSTANT tag %s&quot;, tag);</span>
165             }

166         }
167 
<span class="line-modified">168         public static JVM_CONSTANT getEnum(int tag) {</span>
<span class="line-modified">169             return TagValueMap.get(tag);</span>











170         }
171     }
172 
173     private static class LookupTypeCacheElement {
174         int lastCpi = Integer.MIN_VALUE;
175         JavaType javaType;
176 
177         LookupTypeCacheElement(int lastCpi, JavaType javaType) {
178             super();
179             this.lastCpi = lastCpi;
180             this.javaType = javaType;
181         }
182     }
183 
184     /**
<span class="line-modified">185      * Reference to the C++ ConstantPool object.</span>

186      */
<span class="line-modified">187     private final long metaspaceConstantPool;</span>

188     private volatile LookupTypeCacheElement lastLookupType;

189 
190     /**
191      * Gets the JVMCI mirror from a HotSpot constant pool.The VM is responsible for ensuring that
192      * the ConstantPool is kept alive for the duration of this call and the
<span class="line-modified">193      * {@link HotSpotJVMCIMetaAccessContext} keeps it alive after that.</span>
194      *
195      * Called from the VM.
196      *
197      * @param metaspaceConstantPool a metaspace ConstantPool object
198      * @return the {@link HotSpotConstantPool} corresponding to {@code metaspaceConstantPool}
199      */
200     @SuppressWarnings(&quot;unused&quot;)

201     private static HotSpotConstantPool fromMetaspace(long metaspaceConstantPool) {
<span class="line-modified">202         HotSpotConstantPool cp = new HotSpotConstantPool(metaspaceConstantPool);</span>
<span class="line-removed">203         runtime().metaAccessContext.add(cp);</span>
<span class="line-removed">204         return cp;</span>
205     }
206 
<span class="line-modified">207     private HotSpotConstantPool(long metaspaceConstantPool) {</span>
<span class="line-modified">208         this.metaspaceConstantPool = metaspaceConstantPool;</span>


209     }
210 
211     /**
212      * Gets the holder for this constant pool as {@link HotSpotResolvedObjectTypeImpl}.
213      *
214      * @return holder for this constant pool
215      */
216     private HotSpotResolvedObjectType getHolder() {
217         return compilerToVM().getResolvedJavaType(this, config().constantPoolHolderOffset, false);
218     }
219 
220     /**
221      * Converts a raw index from the bytecodes to a constant pool cache index by adding a
222      * {@link HotSpotVMConfig#constantPoolCpCacheIndexTag constant}.
223      *
224      * @param rawIndex index from the bytecode
225      * @param opcode bytecode to convert the index for
226      * @return constant pool cache index
227      */
228     private static int rawIndexToConstantPoolCacheIndex(int rawIndex, int opcode) {
</pre>
<hr />
<pre>
254             return index - config().constantPoolCpCacheIndexTag;
255         }
256     }
257 
258     /**
259      * See {@code ConstantPool::is_invokedynamic_index}.
260      */
261     private static boolean isInvokedynamicIndex(int index) {
262         return index &lt; 0;
263     }
264 
265     /**
266      * See {@code ConstantPool::decode_invokedynamic_index}.
267      */
268     private static int decodeInvokedynamicIndex(int i) {
269         assert isInvokedynamicIndex(i) : i;
270         return ~i;
271     }
272 
273     long getMetaspaceConstantPool() {
<span class="line-modified">274         return metaspaceConstantPool;</span>
275     }
276 
277     @Override
<span class="line-modified">278     public long getMetaspacePointer() {</span>
<span class="line-modified">279         return getMetaspaceConstantPool();</span>
280     }
281 
282     /**
283      * Gets the constant pool tag at index {@code index}.
284      *
285      * @param index constant pool index
286      * @return constant pool tag
287      */
<span class="line-modified">288     private JVM_CONSTANT getTagAt(int index) {</span>
289         assert checkBounds(index);
290         HotSpotVMConfig config = config();
291         final long metaspaceConstantPoolTags = UNSAFE.getAddress(getMetaspaceConstantPool() + config.constantPoolTagsOffset);
292         final int tag = UNSAFE.getByteVolatile(null, metaspaceConstantPoolTags + config.arrayU1DataOffset + index);
293         if (tag == 0) {
294             return null;
295         }
<span class="line-modified">296         return JVM_CONSTANT.getEnum(tag);</span>
297     }
298 
299     /**
300      * Gets the constant pool entry at index {@code index}.
301      *
302      * @param index constant pool index
303      * @return constant pool entry
304      */
305     long getEntryAt(int index) {
306         assert checkBounds(index);
307         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
308         return UNSAFE.getAddress(getMetaspaceConstantPool() + config().constantPoolSize + offset);
309     }
310 
311     /**
312      * Gets the integer constant pool entry at index {@code index}.
313      *
314      * @param index constant pool index
315      * @return integer constant pool entry at index
316      */
317     private int getIntAt(int index) {
<span class="line-modified">318         assert checkTag(index, JVM_CONSTANT.Integer);</span>
319         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
320         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);
321     }
322 
323     /**
324      * Gets the long constant pool entry at index {@code index}.
325      *
326      * @param index constant pool index
327      * @return long constant pool entry
328      */
329     private long getLongAt(int index) {
<span class="line-modified">330         assert checkTag(index, JVM_CONSTANT.Long);</span>
331         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
332         return UNSAFE.getLong(getMetaspaceConstantPool() + config().constantPoolSize + offset);
333     }
334 
335     /**
336      * Gets the float constant pool entry at index {@code index}.
337      *
338      * @param index constant pool index
339      * @return float constant pool entry
340      */
341     private float getFloatAt(int index) {
<span class="line-modified">342         assert checkTag(index, JVM_CONSTANT.Float);</span>
343         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
344         return UNSAFE.getFloat(getMetaspaceConstantPool() + config().constantPoolSize + offset);
345     }
346 
347     /**
348      * Gets the double constant pool entry at index {@code index}.
349      *
350      * @param index constant pool index
351      * @return float constant pool entry
352      */
353     private double getDoubleAt(int index) {
<span class="line-modified">354         assert checkTag(index, JVM_CONSTANT.Double);</span>
355         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
356         return UNSAFE.getDouble(getMetaspaceConstantPool() + config().constantPoolSize + offset);
357     }
358 
359     /**
360      * Gets the {@code JVM_CONSTANT_NameAndType} constant pool entry at index {@code index}.
361      *
362      * @param index constant pool index
363      * @return {@code JVM_CONSTANT_NameAndType} constant pool entry
364      */
365     private int getNameAndTypeAt(int index) {
<span class="line-modified">366         assert checkTag(index, JVM_CONSTANT.NameAndType);</span>
367         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
368         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);
369     }
370 
371     /**
372      * Gets the {@code JVM_CONSTANT_NameAndType} reference index constant pool entry at index
373      * {@code index}.
374      *
375      * @param index constant pool index
376      * @return {@code JVM_CONSTANT_NameAndType} reference constant pool entry
377      */
378     private int getNameAndTypeRefIndexAt(int index) {
379         return compilerToVM().lookupNameAndTypeRefIndexInPool(this, index);
380     }
381 
382     /**
383      * Gets the name of a {@code JVM_CONSTANT_NameAndType} constant pool entry referenced by another
384      * entry denoted by {@code which}.
385      *
386      * @param which constant pool index or constant pool cache index
</pre>
<hr />
<pre>
453     }
454 
455     /**
456      * Checks that the constant pool index {@code index} is in the bounds of the constant pool.
457      *
458      * @param index constant pool index
459      * @throws AssertionError if the check fails
460      */
461     private boolean checkBounds(int index) {
462         assert 0 &lt;= index &amp;&amp; index &lt; length() : &quot;index &quot; + index + &quot; not between 0 and &quot; + length();
463         return true;
464     }
465 
466     /**
467      * Checks that the constant pool tag at index {@code index} is equal to {@code tag}.
468      *
469      * @param index constant pool index
470      * @param tag expected tag
471      * @throws AssertionError if the check fails
472      */
<span class="line-modified">473     private boolean checkTag(int index, JVM_CONSTANT tag) {</span>
<span class="line-modified">474         final JVM_CONSTANT tagAt = getTagAt(index);</span>
475         assert tagAt == tag : &quot;constant pool tag at index &quot; + index + &quot; is &quot; + tagAt + &quot; but expected &quot; + tag;
476         return true;
477     }
478 
479     /**
<span class="line-modified">480      * Asserts that the constant pool tag at index {@code index} is a {@link JVM_CONSTANT#Fieldref},</span>
<span class="line-modified">481      * or a {@link JVM_CONSTANT#MethodRef}, or a {@link JVM_CONSTANT#InterfaceMethodref}.</span>

482      *
483      * @param index constant pool index
484      * @throws AssertionError if the check fails
485      */
486     private boolean checkTagIsFieldOrMethod(int index) {
<span class="line-modified">487         final JVM_CONSTANT tagAt = getTagAt(index);</span>
<span class="line-modified">488         assert tagAt == JVM_CONSTANT.Fieldref || tagAt == JVM_CONSTANT.MethodRef || tagAt == JVM_CONSTANT.InterfaceMethodref : tagAt;</span>
489         return true;
490     }
491 
492     @Override
493     public int length() {
494         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolLengthOffset);
495     }
496 
497     public boolean hasDynamicConstant() {
498         return (flags() &amp; config().constantPoolHasDynamicConstant) != 0;
499     }
500 
501     private int flags() {
502         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolFlagsOffset);
503     }
504 
505     @Override
506     public Object lookupConstant(int cpi) {
507         assert cpi != 0;
<span class="line-modified">508         final JVM_CONSTANT tag = getTagAt(cpi);</span>
<span class="line-modified">509         switch (tag) {</span>
<span class="line-modified">510             case Integer:</span>
511                 return JavaConstant.forInt(getIntAt(cpi));
<span class="line-modified">512             case Long:</span>
513                 return JavaConstant.forLong(getLongAt(cpi));
<span class="line-modified">514             case Float:</span>
515                 return JavaConstant.forFloat(getFloatAt(cpi));
<span class="line-modified">516             case Double:</span>
517                 return JavaConstant.forDouble(getDoubleAt(cpi));
<span class="line-modified">518             case Class:</span>
<span class="line-modified">519             case UnresolvedClass:</span>
<span class="line-modified">520             case UnresolvedClassInError:</span>
521                 final int opcode = -1;  // opcode is not used
522                 return lookupType(cpi, opcode);
<span class="line-modified">523             case String:</span>
524                 /*
525                  * Normally, we would expect a String here, but unsafe anonymous classes can have
526                  * &quot;pseudo strings&quot; (arbitrary live objects) patched into a String entry. Such
527                  * entries do not have a symbol in the constant pool slot.
528                  */
<span class="line-modified">529                 Object string = compilerToVM().resolvePossiblyCachedConstantInPool(this, cpi);</span>
<span class="line-modified">530                 return HotSpotObjectConstantImpl.forObject(string);</span>
<span class="line-modified">531             case MethodHandle:</span>
<span class="line-modified">532             case MethodHandleInError:</span>
<span class="line-modified">533             case MethodType:</span>
<span class="line-modified">534             case MethodTypeInError:</span>
<span class="line-removed">535                 Object obj = compilerToVM().resolveConstantInPool(this, cpi);</span>
<span class="line-removed">536                 return HotSpotObjectConstantImpl.forObject(obj);</span>
537             default:
538                 throw new JVMCIError(&quot;Unknown constant pool tag %s&quot;, tag);
539         }
540     }
541 
542     @Override
543     public String lookupUtf8(int cpi) {
<span class="line-modified">544         assert checkTag(cpi, JVM_CONSTANT.Utf8);</span>
545         return compilerToVM().getSymbol(getEntryAt(cpi));
546     }
547 
548     @Override
549     public Signature lookupSignature(int cpi) {
550         return new HotSpotSignature(runtime(), lookupUtf8(cpi));
551     }
552 
553     @Override
554     public JavaConstant lookupAppendix(int cpi, int opcode) {
555         assert Bytecodes.isInvoke(opcode);
556         final int index = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<span class="line-modified">557         Object appendix = compilerToVM().lookupAppendixInPool(this, index);</span>
<span class="line-removed">558         if (appendix == null) {</span>
<span class="line-removed">559             return null;</span>
<span class="line-removed">560         } else {</span>
<span class="line-removed">561             return HotSpotObjectConstantImpl.forObject(appendix);</span>
<span class="line-removed">562         }</span>
563     }
564 
565     /**
566      * Gets a {@link JavaType} corresponding a given resolved or unresolved type.
567      *
568      * @param type either a ResolvedJavaType or a String naming a unresolved type.
569      */
570     private static JavaType getJavaType(final Object type) {
571         if (type instanceof String) {
572             String name = (String) type;
573             return UnresolvedJavaType.create(&quot;L&quot; + name + &quot;;&quot;);
574         } else {
575             return (JavaType) type;
576         }
577     }
578 
579     @Override
580     public JavaMethod lookupMethod(int cpi, int opcode) {
581         final int index = rawIndexToConstantPoolCacheIndex(cpi, opcode);
582         final HotSpotResolvedJavaMethod method = compilerToVM().lookupMethodInPool(this, index, (byte) opcode);
583         if (method != null) {
584             return method;
585         } else {
586             // Get the method&#39;s name and signature.
587             String name = getNameOf(index);
588             HotSpotSignature signature = new HotSpotSignature(runtime(), getSignatureOf(index));
589             if (opcode == Bytecodes.INVOKEDYNAMIC) {
<span class="line-modified">590                 HotSpotResolvedObjectType holder = HotSpotResolvedObjectTypeImpl.fromObjectClass(MethodHandle.class);</span>
591                 return new UnresolvedJavaMethod(name, signature, holder);
592             } else {
593                 final int klassIndex = getKlassRefIndexAt(index);
594                 final Object type = compilerToVM().lookupKlassInPool(this, klassIndex);
595                 JavaType holder = getJavaType(type);
596                 return new UnresolvedJavaMethod(name, signature, holder);
597             }
598         }
599     }
600 
601     @Override
602     public JavaType lookupType(int cpi, int opcode) {
603         final LookupTypeCacheElement elem = this.lastLookupType;
604         if (elem != null &amp;&amp; elem.lastCpi == cpi) {
605             return elem.javaType;
606         } else {
607             final Object type = compilerToVM().lookupKlassInPool(this, cpi);
608             JavaType result = getJavaType(type);
609             if (result instanceof ResolvedJavaType) {
610                 this.lastLookupType = new LookupTypeCacheElement(cpi, result);
</pre>
<hr />
<pre>
692                 index = compilerToVM().constantPoolRemapInstructionOperandFromCache(this, index);
693                 break;
694             }
695             case Bytecodes.GETSTATIC:
696             case Bytecodes.PUTSTATIC:
697             case Bytecodes.GETFIELD:
698             case Bytecodes.PUTFIELD:
699             case Bytecodes.INVOKEVIRTUAL:
700             case Bytecodes.INVOKESPECIAL:
701             case Bytecodes.INVOKESTATIC:
702             case Bytecodes.INVOKEINTERFACE: {
703                 // invoke and field instructions point to a constant pool cache entry.
704                 index = rawIndexToConstantPoolCacheIndex(cpi, opcode);
705                 index = compilerToVM().constantPoolRemapInstructionOperandFromCache(this, index);
706                 break;
707             }
708             default:
709                 throw JVMCIError.shouldNotReachHere(&quot;Unexpected opcode &quot; + opcode);
710         }
711 
<span class="line-modified">712         final JVM_CONSTANT tag = getTagAt(index);</span>
713         if (tag == null) {
<span class="line-modified">714             assert getTagAt(index - 1) == JVM_CONSTANT.Double || getTagAt(index - 1) == JVM_CONSTANT.Long;</span>
715             return;
716         }
<span class="line-modified">717         switch (tag) {</span>
<span class="line-modified">718             case MethodRef:</span>
<span class="line-modified">719             case Fieldref:</span>
<span class="line-modified">720             case InterfaceMethodref:</span>
721                 index = getUncachedKlassRefIndexAt(index);
722                 // Read the tag only once because it could change between multiple reads.
<span class="line-modified">723                 final JVM_CONSTANT klassTag = getTagAt(index);</span>
<span class="line-modified">724                 assert klassTag == JVM_CONSTANT.Class || klassTag == JVM_CONSTANT.UnresolvedClass || klassTag == JVM_CONSTANT.UnresolvedClassInError : klassTag;</span>
725                 // fall through
<span class="line-modified">726             case Class:</span>
<span class="line-modified">727             case UnresolvedClass:</span>
<span class="line-modified">728             case UnresolvedClassInError:</span>
729                 final HotSpotResolvedObjectTypeImpl type = compilerToVM().resolveTypeInPool(this, index);
<span class="line-modified">730                 if (initialize) {</span>
<span class="line-modified">731                     Class&lt;?&gt; klass = type.mirror();</span>
<span class="line-removed">732                     if (!klass.isPrimitive() &amp;&amp; !klass.isArray()) {</span>
<span class="line-removed">733                         UNSAFE.ensureClassInitialized(klass);</span>
<span class="line-removed">734                     }</span>
735                 }
<span class="line-modified">736                 if (tag == JVM_CONSTANT.MethodRef) {</span>
737                     if (Bytecodes.isInvokeHandleAlias(opcode) &amp;&amp; isSignaturePolymorphicHolder(type)) {
738                         final int methodRefCacheIndex = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<span class="line-modified">739                         assert checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), JVM_CONSTANT.MethodRef);</span>
740                         compilerToVM().resolveInvokeHandleInPool(this, methodRefCacheIndex);
741                     }
742                 }
743 
744                 break;
<span class="line-modified">745             case InvokeDynamic:</span>
746                 if (isInvokedynamicIndex(cpi)) {
747                     compilerToVM().resolveInvokeDynamicInPool(this, cpi);
748                 }
749                 break;
750             default:
751                 // nothing
752                 break;
753         }
754 
755     }
756 
757     // Lazily initialized.
758     private static String[] signaturePolymorphicHolders;
759 
760     /**
761      * Determines if {@code type} contains signature polymorphic methods.
762      */
763     @SuppressFBWarnings(value = &quot;LI_LAZY_INIT_STATIC&quot;, justification = &quot;signaturePolymorphicHolders is a cache, not a singleton that must be constructed exactly once&quot; +
764                     &quot;and compiler re-ordering is not an issue due to the VM call&quot;)
765     static boolean isSignaturePolymorphicHolder(final ResolvedJavaType type) {
</pre>
<hr />
<pre>
771             if (name.equals(holder)) {
772                 return true;
773             }
774         }
775         return false;
776     }
777 
778     /**
779      * Check for a resolved dynamic adapter method at the specified index, resulting from either a
780      * resolved invokedynamic or invokevirtual on a signature polymorphic MethodHandle method
781      * (HotSpot invokehandle).
782      *
783      * @param cpi the constant pool index
784      * @param opcode the opcode of the instruction for which the lookup is being performed
785      * @return {@code true} if a signature polymorphic method reference was found, otherwise
786      *         {@code false}
787      */
788     public boolean isResolvedDynamicInvoke(int cpi, int opcode) {
789         if (Bytecodes.isInvokeHandleAlias(opcode)) {
790             final int methodRefCacheIndex = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<span class="line-modified">791             assert checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), JVM_CONSTANT.MethodRef);</span>
792             int op = compilerToVM().isResolvedInvokeHandleInPool(this, methodRefCacheIndex);
793             return op == opcode;
794         }
795         return false;
796     }
797 
798     @Override
799     public String toString() {
800         HotSpotResolvedObjectType holder = getHolder();
801         return &quot;HotSpotConstantPool&lt;&quot; + holder.toJavaName() + &quot;&gt;&quot;;
802     }
803 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
 26 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 27 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
 28 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 29 


 30 import jdk.vm.ci.common.JVMCIError;
<span class="line-added"> 31 import jdk.vm.ci.common.NativeImageReinitialize;</span>
 32 import jdk.vm.ci.meta.ConstantPool;
 33 import jdk.vm.ci.meta.JavaConstant;
 34 import jdk.vm.ci.meta.JavaField;
 35 import jdk.vm.ci.meta.JavaMethod;
 36 import jdk.vm.ci.meta.JavaType;
 37 import jdk.vm.ci.meta.ResolvedJavaMethod;
 38 import jdk.vm.ci.meta.ResolvedJavaType;
 39 import jdk.vm.ci.meta.Signature;
 40 import jdk.vm.ci.meta.UnresolvedJavaField;
 41 import jdk.vm.ci.meta.UnresolvedJavaMethod;
 42 import jdk.vm.ci.meta.UnresolvedJavaType;
 43 
 44 /**
 45  * Implementation of {@link ConstantPool} for HotSpot.
 46  */
<span class="line-modified"> 47 public final class HotSpotConstantPool implements ConstantPool, MetaspaceHandleObject {</span>
 48 
 49     /**
 50      * Subset of JVM bytecode opcodes used by {@link HotSpotConstantPool}.
 51      */
 52     public static class Bytecodes {
 53         public static final int LDC = 18; // 0x12
 54         public static final int LDC_W = 19; // 0x13
 55         public static final int LDC2_W = 20; // 0x14
 56         public static final int GETSTATIC = 178; // 0xB2
 57         public static final int PUTSTATIC = 179; // 0xB3
 58         public static final int GETFIELD = 180; // 0xB4
 59         public static final int PUTFIELD = 181; // 0xB5
 60         public static final int INVOKEVIRTUAL = 182; // 0xB6
 61         public static final int INVOKESPECIAL = 183; // 0xB7
 62         public static final int INVOKESTATIC = 184; // 0xB8
 63         public static final int INVOKEINTERFACE = 185; // 0xB9
 64         public static final int INVOKEDYNAMIC = 186; // 0xBA
 65         public static final int NEW = 187; // 0xBB
 66         public static final int NEWARRAY = 188; // 0xBC
 67         public static final int ANEWARRAY = 189; // 0xBD
</pre>
<hr />
<pre>
 79                     return true;
 80                 default:
 81                     return false;
 82             }
 83         }
 84 
 85         /**
 86          * See: {@code Rewriter::maybe_rewrite_invokehandle}.
 87          */
 88         static boolean isInvokeHandleAlias(int opcode) {
 89             switch (opcode) {
 90                 case INVOKEVIRTUAL:
 91                 case INVOKESPECIAL:
 92                     return true;
 93                 default:
 94                     return false;
 95             }
 96         }
 97     }
 98 
<span class="line-modified"> 99     static final class JvmConstant {</span>

























100         private final int tag;
<span class="line-added">101         private final String name;</span>
102 
<span class="line-modified">103         JvmConstant(int tag, String name) {</span>




104             this.tag = tag;
<span class="line-added">105             this.name = name;</span>
106         }
107 
<span class="line-modified">108         @Override</span>
<span class="line-modified">109         public String toString() {</span>
<span class="line-modified">110             return name;</span>
<span class="line-modified">111         }</span>
<span class="line-modified">112     }</span>

113 
<span class="line-modified">114     /**</span>
<span class="line-modified">115      * {@code JVM_CONSTANT} constants used in the VM including both public and internal ones.</span>
<span class="line-modified">116      */</span>
<span class="line-modified">117     static final class JvmConstants {</span>
<span class="line-modified">118 </span>
<span class="line-modified">119         private final HotSpotVMConfig c = config();</span>
<span class="line-added">120         private final int externalMax = c.jvmConstantExternalMax;</span>
<span class="line-added">121         private final int internalMax = c.jvmConstantInternalMax;</span>
<span class="line-added">122         private final int internalMin = c.jvmConstantInternalMin;</span>
<span class="line-added">123         private final JvmConstant[] table = new JvmConstant[externalMax + 1 + (internalMax - internalMin) + 1];</span>
<span class="line-added">124 </span>
<span class="line-added">125         final JvmConstant jvmUtf8 = add(new JvmConstant(c.jvmConstantUtf8, &quot;Utf8&quot;));</span>
<span class="line-added">126         final JvmConstant jvmInteger = add(new JvmConstant(c.jvmConstantInteger, &quot;Integer&quot;));</span>
<span class="line-added">127         final JvmConstant jvmLong = add(new JvmConstant(c.jvmConstantLong, &quot;Long&quot;));</span>
<span class="line-added">128         final JvmConstant jvmFloat = add(new JvmConstant(c.jvmConstantFloat, &quot;Float&quot;));</span>
<span class="line-added">129         final JvmConstant jvmDouble = add(new JvmConstant(c.jvmConstantDouble, &quot;Double&quot;));</span>
<span class="line-added">130         final JvmConstant jvmClass = add(new JvmConstant(c.jvmConstantClass, &quot;Class&quot;));</span>
<span class="line-added">131         final JvmConstant jvmUnresolvedClass = add(new JvmConstant(c.jvmConstantUnresolvedClass, &quot;UnresolvedClass&quot;));</span>
<span class="line-added">132         final JvmConstant jvmUnresolvedClassInError = add(new JvmConstant(c.jvmConstantUnresolvedClassInError, &quot;UnresolvedClassInError&quot;));</span>
<span class="line-added">133         final JvmConstant jvmString = add(new JvmConstant(c.jvmConstantString, &quot;String&quot;));</span>
<span class="line-added">134         final JvmConstant jvmFieldref = add(new JvmConstant(c.jvmConstantFieldref, &quot;Fieldref&quot;));</span>
<span class="line-added">135         final JvmConstant jvmMethodref = add(new JvmConstant(c.jvmConstantMethodref, &quot;Methodref&quot;));</span>
<span class="line-added">136         final JvmConstant jvmInterfaceMethodref = add(new JvmConstant(c.jvmConstantInterfaceMethodref, &quot;InterfaceMethodref&quot;));</span>
<span class="line-added">137         final JvmConstant jvmNameAndType = add(new JvmConstant(c.jvmConstantNameAndType, &quot;NameAndType&quot;));</span>
<span class="line-added">138         final JvmConstant jvmMethodHandle = add(new JvmConstant(c.jvmConstantMethodHandle, &quot;MethodHandle&quot;));</span>
<span class="line-added">139         final JvmConstant jvmMethodHandleInError = add(new JvmConstant(c.jvmConstantMethodHandleInError, &quot;MethodHandleInError&quot;));</span>
<span class="line-added">140         final JvmConstant jvmMethodType = add(new JvmConstant(c.jvmConstantMethodType, &quot;MethodType&quot;));</span>
<span class="line-added">141         final JvmConstant jvmMethodTypeInError = add(new JvmConstant(c.jvmConstantMethodTypeInError, &quot;MethodTypeInError&quot;));</span>
<span class="line-added">142         final JvmConstant jvmInvokeDynamic = add(new JvmConstant(c.jvmConstantInvokeDynamic, &quot;InvokeDynamic&quot;));</span>
<span class="line-added">143 </span>
<span class="line-added">144         private JvmConstant add(JvmConstant constant) {</span>
<span class="line-added">145             table[indexOf(constant.tag)] = constant;</span>
<span class="line-added">146             return constant;</span>
<span class="line-added">147         }</span>
148 
<span class="line-modified">149         private int indexOf(int tag) {</span>
<span class="line-modified">150             if (tag &gt;= internalMin) {</span>
<span class="line-modified">151                 return tag - internalMin + externalMax + 1;</span>
<span class="line-modified">152             } else {</span>
<span class="line-modified">153                 assert tag &lt;= externalMax;</span>


154             }
<span class="line-added">155             return tag;</span>
<span class="line-added">156         }</span>
157 
<span class="line-modified">158         JvmConstant get(int tag) {</span>
<span class="line-modified">159             JvmConstant res = table[indexOf(tag)];</span>
<span class="line-modified">160             if (res != null) {</span>
<span class="line-modified">161                 return res;</span>


162             }
<span class="line-added">163             throw new JVMCIError(&quot;Unknown JvmConstant tag %s&quot;, tag);</span>
164         }
165 
<span class="line-modified">166         @NativeImageReinitialize private static volatile JvmConstants instance;</span>
<span class="line-modified">167 </span>
<span class="line-added">168         static JvmConstants instance() {</span>
<span class="line-added">169             JvmConstants result = instance;</span>
<span class="line-added">170             if (result == null) {</span>
<span class="line-added">171                 synchronized (JvmConstants.class) {</span>
<span class="line-added">172                     result = instance;</span>
<span class="line-added">173                     if (result == null) {</span>
<span class="line-added">174                         instance = result = new JvmConstants();</span>
<span class="line-added">175                     }</span>
<span class="line-added">176                 }</span>
<span class="line-added">177             }</span>
<span class="line-added">178             return result;</span>
179         }
180     }
181 
182     private static class LookupTypeCacheElement {
183         int lastCpi = Integer.MIN_VALUE;
184         JavaType javaType;
185 
186         LookupTypeCacheElement(int lastCpi, JavaType javaType) {
187             super();
188             this.lastCpi = lastCpi;
189             this.javaType = javaType;
190         }
191     }
192 
193     /**
<span class="line-modified">194      * Handle to the {@code ConstantPool} VM object. The handle is in</span>
<span class="line-added">195      * {@code JVMCI::_metadata_handles}.</span>
196      */
<span class="line-modified">197     private final long metadataHandle;</span>
<span class="line-added">198 </span>
199     private volatile LookupTypeCacheElement lastLookupType;
<span class="line-added">200     private final JvmConstants constants;</span>
201 
202     /**
203      * Gets the JVMCI mirror from a HotSpot constant pool.The VM is responsible for ensuring that
204      * the ConstantPool is kept alive for the duration of this call and the
<span class="line-modified">205      * {@link HotSpotJVMCIRuntime} keeps it alive after that.</span>
206      *
207      * Called from the VM.
208      *
209      * @param metaspaceConstantPool a metaspace ConstantPool object
210      * @return the {@link HotSpotConstantPool} corresponding to {@code metaspaceConstantPool}
211      */
212     @SuppressWarnings(&quot;unused&quot;)
<span class="line-added">213     @VMEntryPoint</span>
214     private static HotSpotConstantPool fromMetaspace(long metaspaceConstantPool) {
<span class="line-modified">215         return new HotSpotConstantPool(metaspaceConstantPool);</span>


216     }
217 
<span class="line-modified">218     private HotSpotConstantPool(long metadataHandle) {</span>
<span class="line-modified">219         this.metadataHandle = metadataHandle;</span>
<span class="line-added">220         this.constants = JvmConstants.instance();</span>
<span class="line-added">221         HandleCleaner.create(this, metadataHandle);</span>
222     }
223 
224     /**
225      * Gets the holder for this constant pool as {@link HotSpotResolvedObjectTypeImpl}.
226      *
227      * @return holder for this constant pool
228      */
229     private HotSpotResolvedObjectType getHolder() {
230         return compilerToVM().getResolvedJavaType(this, config().constantPoolHolderOffset, false);
231     }
232 
233     /**
234      * Converts a raw index from the bytecodes to a constant pool cache index by adding a
235      * {@link HotSpotVMConfig#constantPoolCpCacheIndexTag constant}.
236      *
237      * @param rawIndex index from the bytecode
238      * @param opcode bytecode to convert the index for
239      * @return constant pool cache index
240      */
241     private static int rawIndexToConstantPoolCacheIndex(int rawIndex, int opcode) {
</pre>
<hr />
<pre>
267             return index - config().constantPoolCpCacheIndexTag;
268         }
269     }
270 
271     /**
272      * See {@code ConstantPool::is_invokedynamic_index}.
273      */
274     private static boolean isInvokedynamicIndex(int index) {
275         return index &lt; 0;
276     }
277 
278     /**
279      * See {@code ConstantPool::decode_invokedynamic_index}.
280      */
281     private static int decodeInvokedynamicIndex(int i) {
282         assert isInvokedynamicIndex(i) : i;
283         return ~i;
284     }
285 
286     long getMetaspaceConstantPool() {
<span class="line-modified">287         return getMetaspacePointer();</span>
288     }
289 
290     @Override
<span class="line-modified">291     public long getMetadataHandle() {</span>
<span class="line-modified">292         return metadataHandle;</span>
293     }
294 
295     /**
296      * Gets the constant pool tag at index {@code index}.
297      *
298      * @param index constant pool index
299      * @return constant pool tag
300      */
<span class="line-modified">301     private JvmConstant getTagAt(int index) {</span>
302         assert checkBounds(index);
303         HotSpotVMConfig config = config();
304         final long metaspaceConstantPoolTags = UNSAFE.getAddress(getMetaspaceConstantPool() + config.constantPoolTagsOffset);
305         final int tag = UNSAFE.getByteVolatile(null, metaspaceConstantPoolTags + config.arrayU1DataOffset + index);
306         if (tag == 0) {
307             return null;
308         }
<span class="line-modified">309         return constants.get(tag);</span>
310     }
311 
312     /**
313      * Gets the constant pool entry at index {@code index}.
314      *
315      * @param index constant pool index
316      * @return constant pool entry
317      */
318     long getEntryAt(int index) {
319         assert checkBounds(index);
320         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
321         return UNSAFE.getAddress(getMetaspaceConstantPool() + config().constantPoolSize + offset);
322     }
323 
324     /**
325      * Gets the integer constant pool entry at index {@code index}.
326      *
327      * @param index constant pool index
328      * @return integer constant pool entry at index
329      */
330     private int getIntAt(int index) {
<span class="line-modified">331         assert checkTag(index, constants.jvmInteger);</span>
332         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
333         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);
334     }
335 
336     /**
337      * Gets the long constant pool entry at index {@code index}.
338      *
339      * @param index constant pool index
340      * @return long constant pool entry
341      */
342     private long getLongAt(int index) {
<span class="line-modified">343         assert checkTag(index, constants.jvmLong);</span>
344         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
345         return UNSAFE.getLong(getMetaspaceConstantPool() + config().constantPoolSize + offset);
346     }
347 
348     /**
349      * Gets the float constant pool entry at index {@code index}.
350      *
351      * @param index constant pool index
352      * @return float constant pool entry
353      */
354     private float getFloatAt(int index) {
<span class="line-modified">355         assert checkTag(index, constants.jvmFloat);</span>
356         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
357         return UNSAFE.getFloat(getMetaspaceConstantPool() + config().constantPoolSize + offset);
358     }
359 
360     /**
361      * Gets the double constant pool entry at index {@code index}.
362      *
363      * @param index constant pool index
364      * @return float constant pool entry
365      */
366     private double getDoubleAt(int index) {
<span class="line-modified">367         assert checkTag(index, constants.jvmDouble);</span>
368         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
369         return UNSAFE.getDouble(getMetaspaceConstantPool() + config().constantPoolSize + offset);
370     }
371 
372     /**
373      * Gets the {@code JVM_CONSTANT_NameAndType} constant pool entry at index {@code index}.
374      *
375      * @param index constant pool index
376      * @return {@code JVM_CONSTANT_NameAndType} constant pool entry
377      */
378     private int getNameAndTypeAt(int index) {
<span class="line-modified">379         assert checkTag(index, constants.jvmNameAndType);</span>
380         int offset = index * runtime().getHostJVMCIBackend().getTarget().wordSize;
381         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolSize + offset);
382     }
383 
384     /**
385      * Gets the {@code JVM_CONSTANT_NameAndType} reference index constant pool entry at index
386      * {@code index}.
387      *
388      * @param index constant pool index
389      * @return {@code JVM_CONSTANT_NameAndType} reference constant pool entry
390      */
391     private int getNameAndTypeRefIndexAt(int index) {
392         return compilerToVM().lookupNameAndTypeRefIndexInPool(this, index);
393     }
394 
395     /**
396      * Gets the name of a {@code JVM_CONSTANT_NameAndType} constant pool entry referenced by another
397      * entry denoted by {@code which}.
398      *
399      * @param which constant pool index or constant pool cache index
</pre>
<hr />
<pre>
466     }
467 
468     /**
469      * Checks that the constant pool index {@code index} is in the bounds of the constant pool.
470      *
471      * @param index constant pool index
472      * @throws AssertionError if the check fails
473      */
474     private boolean checkBounds(int index) {
475         assert 0 &lt;= index &amp;&amp; index &lt; length() : &quot;index &quot; + index + &quot; not between 0 and &quot; + length();
476         return true;
477     }
478 
479     /**
480      * Checks that the constant pool tag at index {@code index} is equal to {@code tag}.
481      *
482      * @param index constant pool index
483      * @param tag expected tag
484      * @throws AssertionError if the check fails
485      */
<span class="line-modified">486     private boolean checkTag(int index, JvmConstant tag) {</span>
<span class="line-modified">487         final JvmConstant tagAt = getTagAt(index);</span>
488         assert tagAt == tag : &quot;constant pool tag at index &quot; + index + &quot; is &quot; + tagAt + &quot; but expected &quot; + tag;
489         return true;
490     }
491 
492     /**
<span class="line-modified">493      * Asserts that the constant pool tag at index {@code index} is a</span>
<span class="line-modified">494      * {@link JvmConstants#jvmFieldref}, or a {@link JvmConstants#jvmMethodref}, or a</span>
<span class="line-added">495      * {@link JvmConstants#jvmInterfaceMethodref}.</span>
496      *
497      * @param index constant pool index
498      * @throws AssertionError if the check fails
499      */
500     private boolean checkTagIsFieldOrMethod(int index) {
<span class="line-modified">501         final JvmConstant tagAt = getTagAt(index);</span>
<span class="line-modified">502         assert tagAt == constants.jvmFieldref || tagAt == constants.jvmMethodref || tagAt == constants.jvmInterfaceMethodref : tagAt;</span>
503         return true;
504     }
505 
506     @Override
507     public int length() {
508         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolLengthOffset);
509     }
510 
511     public boolean hasDynamicConstant() {
512         return (flags() &amp; config().constantPoolHasDynamicConstant) != 0;
513     }
514 
515     private int flags() {
516         return UNSAFE.getInt(getMetaspaceConstantPool() + config().constantPoolFlagsOffset);
517     }
518 
519     @Override
520     public Object lookupConstant(int cpi) {
521         assert cpi != 0;
<span class="line-modified">522         final JvmConstant tag = getTagAt(cpi);</span>
<span class="line-modified">523         switch (tag.name) {</span>
<span class="line-modified">524             case &quot;Integer&quot;:</span>
525                 return JavaConstant.forInt(getIntAt(cpi));
<span class="line-modified">526             case &quot;Long&quot;:</span>
527                 return JavaConstant.forLong(getLongAt(cpi));
<span class="line-modified">528             case &quot;Float&quot;:</span>
529                 return JavaConstant.forFloat(getFloatAt(cpi));
<span class="line-modified">530             case &quot;Double&quot;:</span>
531                 return JavaConstant.forDouble(getDoubleAt(cpi));
<span class="line-modified">532             case &quot;Class&quot;:</span>
<span class="line-modified">533             case &quot;UnresolvedClass&quot;:</span>
<span class="line-modified">534             case &quot;UnresolvedClassInError&quot;:</span>
535                 final int opcode = -1;  // opcode is not used
536                 return lookupType(cpi, opcode);
<span class="line-modified">537             case &quot;String&quot;:</span>
538                 /*
539                  * Normally, we would expect a String here, but unsafe anonymous classes can have
540                  * &quot;pseudo strings&quot; (arbitrary live objects) patched into a String entry. Such
541                  * entries do not have a symbol in the constant pool slot.
542                  */
<span class="line-modified">543                 return compilerToVM().resolvePossiblyCachedConstantInPool(this, cpi);</span>
<span class="line-modified">544             case &quot;MethodHandle&quot;:</span>
<span class="line-modified">545             case &quot;MethodHandleInError&quot;:</span>
<span class="line-modified">546             case &quot;MethodType&quot;:</span>
<span class="line-modified">547             case &quot;MethodTypeInError&quot;:</span>
<span class="line-modified">548                 return compilerToVM().resolvePossiblyCachedConstantInPool(this, cpi);</span>


549             default:
550                 throw new JVMCIError(&quot;Unknown constant pool tag %s&quot;, tag);
551         }
552     }
553 
554     @Override
555     public String lookupUtf8(int cpi) {
<span class="line-modified">556         assert checkTag(cpi, constants.jvmUtf8);</span>
557         return compilerToVM().getSymbol(getEntryAt(cpi));
558     }
559 
560     @Override
561     public Signature lookupSignature(int cpi) {
562         return new HotSpotSignature(runtime(), lookupUtf8(cpi));
563     }
564 
565     @Override
566     public JavaConstant lookupAppendix(int cpi, int opcode) {
567         assert Bytecodes.isInvoke(opcode);
568         final int index = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<span class="line-modified">569         return compilerToVM().lookupAppendixInPool(this, index);</span>





570     }
571 
572     /**
573      * Gets a {@link JavaType} corresponding a given resolved or unresolved type.
574      *
575      * @param type either a ResolvedJavaType or a String naming a unresolved type.
576      */
577     private static JavaType getJavaType(final Object type) {
578         if (type instanceof String) {
579             String name = (String) type;
580             return UnresolvedJavaType.create(&quot;L&quot; + name + &quot;;&quot;);
581         } else {
582             return (JavaType) type;
583         }
584     }
585 
586     @Override
587     public JavaMethod lookupMethod(int cpi, int opcode) {
588         final int index = rawIndexToConstantPoolCacheIndex(cpi, opcode);
589         final HotSpotResolvedJavaMethod method = compilerToVM().lookupMethodInPool(this, index, (byte) opcode);
590         if (method != null) {
591             return method;
592         } else {
593             // Get the method&#39;s name and signature.
594             String name = getNameOf(index);
595             HotSpotSignature signature = new HotSpotSignature(runtime(), getSignatureOf(index));
596             if (opcode == Bytecodes.INVOKEDYNAMIC) {
<span class="line-modified">597                 HotSpotResolvedObjectType holder = runtime().getMethodHandleClass();</span>
598                 return new UnresolvedJavaMethod(name, signature, holder);
599             } else {
600                 final int klassIndex = getKlassRefIndexAt(index);
601                 final Object type = compilerToVM().lookupKlassInPool(this, klassIndex);
602                 JavaType holder = getJavaType(type);
603                 return new UnresolvedJavaMethod(name, signature, holder);
604             }
605         }
606     }
607 
608     @Override
609     public JavaType lookupType(int cpi, int opcode) {
610         final LookupTypeCacheElement elem = this.lastLookupType;
611         if (elem != null &amp;&amp; elem.lastCpi == cpi) {
612             return elem.javaType;
613         } else {
614             final Object type = compilerToVM().lookupKlassInPool(this, cpi);
615             JavaType result = getJavaType(type);
616             if (result instanceof ResolvedJavaType) {
617                 this.lastLookupType = new LookupTypeCacheElement(cpi, result);
</pre>
<hr />
<pre>
699                 index = compilerToVM().constantPoolRemapInstructionOperandFromCache(this, index);
700                 break;
701             }
702             case Bytecodes.GETSTATIC:
703             case Bytecodes.PUTSTATIC:
704             case Bytecodes.GETFIELD:
705             case Bytecodes.PUTFIELD:
706             case Bytecodes.INVOKEVIRTUAL:
707             case Bytecodes.INVOKESPECIAL:
708             case Bytecodes.INVOKESTATIC:
709             case Bytecodes.INVOKEINTERFACE: {
710                 // invoke and field instructions point to a constant pool cache entry.
711                 index = rawIndexToConstantPoolCacheIndex(cpi, opcode);
712                 index = compilerToVM().constantPoolRemapInstructionOperandFromCache(this, index);
713                 break;
714             }
715             default:
716                 throw JVMCIError.shouldNotReachHere(&quot;Unexpected opcode &quot; + opcode);
717         }
718 
<span class="line-modified">719         final JvmConstant tag = getTagAt(index);</span>
720         if (tag == null) {
<span class="line-modified">721             assert getTagAt(index - 1) == constants.jvmDouble || getTagAt(index - 1) == constants.jvmLong;</span>
722             return;
723         }
<span class="line-modified">724         switch (tag.name) {</span>
<span class="line-modified">725             case &quot;Methodref&quot;:</span>
<span class="line-modified">726             case &quot;Fieldref&quot;:</span>
<span class="line-modified">727             case &quot;InterfaceMethodref&quot;:</span>
728                 index = getUncachedKlassRefIndexAt(index);
729                 // Read the tag only once because it could change between multiple reads.
<span class="line-modified">730                 final JvmConstant klassTag = getTagAt(index);</span>
<span class="line-modified">731                 assert klassTag == constants.jvmClass || klassTag == constants.jvmUnresolvedClass || klassTag == constants.jvmUnresolvedClassInError : klassTag;</span>
732                 // fall through
<span class="line-modified">733             case &quot;Class&quot;:</span>
<span class="line-modified">734             case &quot;UnresolvedClass&quot;:</span>
<span class="line-modified">735             case &quot;UnresolvedClassInError&quot;:</span>
736                 final HotSpotResolvedObjectTypeImpl type = compilerToVM().resolveTypeInPool(this, index);
<span class="line-modified">737                 if (initialize &amp;&amp; !type.isPrimitive() &amp;&amp; !type.isArray()) {</span>
<span class="line-modified">738                     type.ensureInitialized();</span>



739                 }
<span class="line-modified">740                 if (tag == constants.jvmMethodref) {</span>
741                     if (Bytecodes.isInvokeHandleAlias(opcode) &amp;&amp; isSignaturePolymorphicHolder(type)) {
742                         final int methodRefCacheIndex = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<span class="line-modified">743                         assert checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), constants.jvmMethodref);</span>
744                         compilerToVM().resolveInvokeHandleInPool(this, methodRefCacheIndex);
745                     }
746                 }
747 
748                 break;
<span class="line-modified">749             case &quot;InvokeDynamic&quot;:</span>
750                 if (isInvokedynamicIndex(cpi)) {
751                     compilerToVM().resolveInvokeDynamicInPool(this, cpi);
752                 }
753                 break;
754             default:
755                 // nothing
756                 break;
757         }
758 
759     }
760 
761     // Lazily initialized.
762     private static String[] signaturePolymorphicHolders;
763 
764     /**
765      * Determines if {@code type} contains signature polymorphic methods.
766      */
767     @SuppressFBWarnings(value = &quot;LI_LAZY_INIT_STATIC&quot;, justification = &quot;signaturePolymorphicHolders is a cache, not a singleton that must be constructed exactly once&quot; +
768                     &quot;and compiler re-ordering is not an issue due to the VM call&quot;)
769     static boolean isSignaturePolymorphicHolder(final ResolvedJavaType type) {
</pre>
<hr />
<pre>
775             if (name.equals(holder)) {
776                 return true;
777             }
778         }
779         return false;
780     }
781 
782     /**
783      * Check for a resolved dynamic adapter method at the specified index, resulting from either a
784      * resolved invokedynamic or invokevirtual on a signature polymorphic MethodHandle method
785      * (HotSpot invokehandle).
786      *
787      * @param cpi the constant pool index
788      * @param opcode the opcode of the instruction for which the lookup is being performed
789      * @return {@code true} if a signature polymorphic method reference was found, otherwise
790      *         {@code false}
791      */
792     public boolean isResolvedDynamicInvoke(int cpi, int opcode) {
793         if (Bytecodes.isInvokeHandleAlias(opcode)) {
794             final int methodRefCacheIndex = rawIndexToConstantPoolCacheIndex(cpi, opcode);
<span class="line-modified">795             assert checkTag(compilerToVM().constantPoolRemapInstructionOperandFromCache(this, methodRefCacheIndex), constants.jvmMethodref);</span>
796             int op = compilerToVM().isResolvedInvokeHandleInPool(this, methodRefCacheIndex);
797             return op == opcode;
798         }
799         return false;
800     }
801 
802     @Override
803     public String toString() {
804         HotSpotResolvedObjectType holder = getHolder();
805         return &quot;HotSpotConstantPool&lt;&quot; + holder.toJavaName() + &quot;&gt;&quot;;
806     }
807 }
</pre>
</td>
</tr>
</table>
<center><a href="HotSpotCompiledNmethod.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotConstantPoolObject.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCICompilerConfig.java b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCICompilerConfig.java
--- a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCICompilerConfig.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCICompilerConfig.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -20,33 +20,44 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.vm.ci.hotspot;
 
+import java.util.List;
 import java.util.Set;
 
 import jdk.vm.ci.code.CompilationRequest;
 import jdk.vm.ci.common.JVMCIError;
+import jdk.vm.ci.common.NativeImageReinitialize;
 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.Option;
 import jdk.vm.ci.runtime.JVMCICompiler;
 import jdk.vm.ci.runtime.JVMCICompilerFactory;
 import jdk.vm.ci.runtime.JVMCIRuntime;
 import jdk.vm.ci.services.JVMCIPermission;
 import jdk.vm.ci.services.JVMCIServiceLocator;
+import jdk.vm.ci.services.Services;
+
+import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
 
 final class HotSpotJVMCICompilerConfig {
 
     /**
      * This factory allows JVMCI initialization to succeed but raises an error if the VM asks JVMCI
      * to perform a compilation. This allows the reflective parts of the JVMCI API to be used
      * without requiring a compiler implementation to be available.
      */
     private static class DummyCompilerFactory implements JVMCICompilerFactory, JVMCICompiler {
 
+        private final String reason;
+
+        DummyCompilerFactory(String reason) {
+            this.reason = reason;
+        }
+
         @Override
         public HotSpotCompilationRequestResult compileMethod(CompilationRequest request) {
-            throw new JVMCIError("no JVMCI compiler selected");
+            throw new JVMCIError("no JVMCI compiler selected: " + reason);
         }
 
         @Override
         public String getCompilerName() {
             return "null";
@@ -59,11 +70,11 @@
     }
 
     /**
      * Factory of the selected system compiler.
      */
-    private static JVMCICompilerFactory compilerFactory;
+    @NativeImageReinitialize private static JVMCICompilerFactory compilerFactory;
 
     /**
      * Gets the selected system compiler factory.
      *
      * @return the selected system compiler factory
@@ -73,36 +84,45 @@
     static JVMCICompilerFactory getCompilerFactory() {
         if (compilerFactory == null) {
             JVMCICompilerFactory factory = null;
             String compilerName = Option.Compiler.getString();
             if (compilerName != null) {
-                if (compilerName.isEmpty() || compilerName.equals("null")) {
-                    factory = new DummyCompilerFactory();
+                if (compilerName.isEmpty()) {
+                    factory = new DummyCompilerFactory(" empty \"\" is specified");
+                } else if (compilerName.equals("null")) {
+                    factory = new DummyCompilerFactory("\"null\" is specified");
                 } else {
-                    for (JVMCICompilerFactory f : JVMCIServiceLocator.getProviders(JVMCICompilerFactory.class)) {
+                    for (JVMCICompilerFactory f : getJVMCICompilerFactories()) {
                         if (f.getCompilerName().equals(compilerName)) {
                             factory = f;
                         }
                     }
                     if (factory == null) {
+                        if (Services.IS_IN_NATIVE_IMAGE) {
+                            throw new JVMCIError("JVMCI compiler '%s' not found in JVMCI native library.%n" +
+                                            "Use -XX:-UseJVMCINativeLibrary when specifying a JVMCI compiler available on a class path with %s.",
+                                            compilerName, Option.Compiler.getPropertyName());
+                        }
                         throw new JVMCIError("JVMCI compiler '%s' not found", compilerName);
                     }
                 }
             } else {
                 // Auto select a single available compiler
-                for (JVMCICompilerFactory f : JVMCIServiceLocator.getProviders(JVMCICompilerFactory.class)) {
+                String reason = "default compiler is not found";
+                for (JVMCICompilerFactory f : getJVMCICompilerFactories()) {
                     if (factory == null) {
                         openJVMCITo(f.getClass().getModule());
                         factory = f;
                     } else {
                         // Multiple factories seen - cancel auto selection
+                        reason = "multiple factories seen: \"" + factory.getCompilerName() + "\" and \"" + f.getCompilerName() + "\"";
                         factory = null;
                         break;
                     }
                 }
                 if (factory == null) {
-                    factory = new DummyCompilerFactory();
+                    factory = new DummyCompilerFactory(reason);
                 }
             }
             factory.onSelection();
             compilerFactory = factory;
         }
@@ -111,17 +131,23 @@
 
     /**
      * Opens all JVMCI packages to {@code otherModule}.
      */
     private static void openJVMCITo(Module otherModule) {
-        Module jvmci = HotSpotJVMCICompilerConfig.class.getModule();
-        if (jvmci != otherModule) {
-            Set<String> packages = jvmci.getPackages();
-            for (String pkg : packages) {
-                boolean opened = jvmci.isOpen(pkg, otherModule);
-                if (!opened) {
-                    jvmci.addOpens(pkg, otherModule);
+        if (!IS_IN_NATIVE_IMAGE) {
+            Module jvmci = HotSpotJVMCICompilerConfig.class.getModule();
+            if (jvmci != otherModule) {
+                Set<String> packages = jvmci.getPackages();
+                for (String pkg : packages) {
+                    boolean opened = jvmci.isOpen(pkg, otherModule);
+                    if (!opened) {
+                        jvmci.addOpens(pkg, otherModule);
+                    }
                 }
             }
         }
     }
+
+    private static List<JVMCICompilerFactory> getJVMCICompilerFactories() {
+        return JVMCIServiceLocator.getProviders(JVMCICompilerFactory.class);
+    }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotJVMCICompilerConfig.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotMemoryAccessProviderImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.common.InitTimer.timer;



  26 
  27 import java.io.IOException;
  28 import java.io.OutputStream;
  29 import java.io.PrintStream;
<span class="line-modified">  30 import java.lang.module.ModuleDescriptor.Requires;</span>





  31 import java.util.Collections;
  32 import java.util.HashMap;
<span class="line-removed">  33 import java.util.HashSet;</span>
  34 import java.util.List;
  35 import java.util.Map;
  36 import java.util.Objects;
  37 import java.util.ServiceLoader;
<span class="line-removed">  38 import java.util.Set;</span>
  39 import java.util.function.Predicate;
  40 
<span class="line-removed">  41 import jdk.internal.misc.VM;</span>
<span class="line-removed">  42 import jdk.internal.misc.Unsafe;</span>
  43 import jdk.vm.ci.code.Architecture;
  44 import jdk.vm.ci.code.CompilationRequestResult;
  45 import jdk.vm.ci.code.CompiledCode;
  46 import jdk.vm.ci.code.InstalledCode;
  47 import jdk.vm.ci.common.InitTimer;
  48 import jdk.vm.ci.common.JVMCIError;
<span class="line-modified">  49 import jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevel;</span>
  50 import jdk.vm.ci.meta.JavaKind;
  51 import jdk.vm.ci.meta.JavaType;
  52 import jdk.vm.ci.meta.ResolvedJavaType;
  53 import jdk.vm.ci.meta.UnresolvedJavaType;
  54 import jdk.vm.ci.runtime.JVMCI;
  55 import jdk.vm.ci.runtime.JVMCIBackend;
  56 import jdk.vm.ci.runtime.JVMCICompiler;
  57 import jdk.vm.ci.runtime.JVMCICompilerFactory;
  58 import jdk.vm.ci.runtime.JVMCIRuntime;
  59 import jdk.vm.ci.services.JVMCIServiceLocator;

  60 
  61 /**
  62  * HotSpot implementation of a JVMCI runtime.
<span class="line-removed">  63  *</span>
<span class="line-removed">  64  * The initialization of this class is very fragile since it&#39;s initialized both through</span>
<span class="line-removed">  65  * {@link JVMCI#initialize()} or through calling {@link HotSpotJVMCIRuntime#runtime()} and</span>
<span class="line-removed">  66  * {@link HotSpotJVMCIRuntime#runtime()} is also called by {@link JVMCI#initialize()}. So this class</span>
<span class="line-removed">  67  * can&#39;t have a static initializer and any required initialization must be done as part of</span>
<span class="line-removed">  68  * {@link #runtime()}. This allows the initialization to funnel back through</span>
<span class="line-removed">  69  * {@link JVMCI#initialize()} without deadlocking.</span>
  70  */
  71 public final class HotSpotJVMCIRuntime implements JVMCIRuntime {
  72 
<span class="line-modified">  73     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-modified">  74     static class DelayedInit {</span>
<span class="line-modified">  75         private static final HotSpotJVMCIRuntime instance;</span>



















  76 
<span class="line-modified">  77         static {</span>
<span class="line-modified">  78             try (InitTimer t = timer(&quot;HotSpotJVMCIRuntime.&lt;init&gt;&quot;)) {</span>
<span class="line-modified">  79                 instance = new HotSpotJVMCIRuntime();</span>



  80 
<span class="line-modified">  81                 // Can only do eager initialization of the JVMCI compiler</span>
<span class="line-modified">  82                 // once the singleton instance is available.</span>
<span class="line-modified">  83                 if (instance.config.getFlag(&quot;EagerJVMCI&quot;, Boolean.class)) {</span>
<span class="line-modified">  84                     instance.getCompiler();</span>
<span class="line-modified">  85                 }</span>
<span class="line-modified">  86             }</span>














































  87         }

  88     }
  89 
  90     /**
  91      * Gets the singleton {@link HotSpotJVMCIRuntime} object.
  92      */


  93     public static HotSpotJVMCIRuntime runtime() {
<span class="line-modified">  94         JVMCI.initialize();</span>
<span class="line-modified">  95         return DelayedInit.instance;</span>














































  96     }
  97 
  98     /**
  99      * A list of all supported JVMCI options.
 100      */
 101     public enum Option {
 102         // @formatter:off
 103         Compiler(String.class, null, &quot;Selects the system compiler. This must match the getCompilerName() value returned &quot; +
<span class="line-modified"> 104                                      &quot;by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. &quot; +</span>
<span class="line-modified"> 105                                      &quot;An empty string or the value \&quot;null\&quot; selects a compiler &quot; +</span>
<span class="line-modified"> 106                                      &quot;that will raise an exception upon receiving a compilation request.&quot;),</span>
 107         // Note: The following one is not used (see InitTimer.ENABLED). It is added here
 108         // so that -XX:+JVMCIPrintProperties shows the option.
 109         InitTimer(Boolean.class, false, &quot;Specifies if initialization timing is enabled.&quot;),
 110         PrintConfig(Boolean.class, false, &quot;Prints VM configuration available via JVMCI.&quot;),


 111         TraceMethodDataFilter(String.class, null,
<span class="line-modified"> 112                         &quot;Enables tracing of profiling info when read by JVMCI.&quot;,</span>
<span class="line-modified"> 113                         &quot;Empty value: trace all methods&quot;,</span>
<span class="line-modified"> 114                         &quot;Non-empty value: trace methods whose fully qualified name contains the value.&quot;),</span>
 115         UseProfilingInformation(Boolean.class, true, &quot;&quot;);
 116         // @formatter:on
 117 
 118         /**
 119          * The prefix for system properties that are JVMCI options.
 120          */
 121         private static final String JVMCI_OPTION_PROPERTY_PREFIX = &quot;jvmci.&quot;;
 122 
 123         /**
<span class="line-modified"> 124          * Marker for uninitialized flags.</span>
 125          */
<span class="line-modified"> 126         private static final String UNINITIALIZED = &quot;UNINITIALIZED&quot;;</span>
 127 
 128         private final Class&lt;?&gt; type;
<span class="line-modified"> 129         private Object value;</span>
 130         private final Object defaultValue;
 131         private boolean isDefault;
 132         private final String[] helpLines;
 133 
 134         Option(Class&lt;?&gt; type, Object defaultValue, String... helpLines) {
 135             assert Character.isUpperCase(name().charAt(0)) : &quot;Option name must start with upper-case letter: &quot; + name();
 136             this.type = type;
<span class="line-removed"> 137             this.value = UNINITIALIZED;</span>
 138             this.defaultValue = defaultValue;
 139             this.helpLines = helpLines;
 140         }
 141 
 142         @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)
 143         private Object getValue() {
<span class="line-modified"> 144             if (value == UNINITIALIZED) {</span>
<span class="line-modified"> 145                 String propertyValue = VM.getSavedProperty(getPropertyName());</span>
 146                 if (propertyValue == null) {
<span class="line-modified"> 147                     this.value = defaultValue;</span>
 148                     this.isDefault = true;
 149                 } else {
 150                     if (type == Boolean.class) {
 151                         this.value = Boolean.parseBoolean(propertyValue);
 152                     } else if (type == String.class) {
 153                         this.value = propertyValue;
 154                     } else {
 155                         throw new JVMCIError(&quot;Unexpected option type &quot; + type);
 156                     }
 157                     this.isDefault = false;
 158                 }
<span class="line-removed"> 159                 // Saved properties should not be interned - let&#39;s be sure</span>
<span class="line-removed"> 160                 assert value != UNINITIALIZED;</span>
 161             }
<span class="line-modified"> 162             return value;</span>
 163         }
 164 
 165         /**
 166          * Gets the name of system property from which this option gets its value.
 167          */
 168         public String getPropertyName() {
 169             return JVMCI_OPTION_PROPERTY_PREFIX + name();
 170         }
 171 
 172         /**
 173          * Returns the option&#39;s value as boolean.
 174          *
 175          * @return option&#39;s value
 176          */
 177         public boolean getBoolean() {
 178             return (boolean) getValue();
 179         }
 180 
 181         /**
 182          * Returns the option&#39;s value as String.
</pre>
<hr />
<pre>
 205                 }
 206 
 207                 String name = option.getPropertyName();
 208                 String assign = option.isDefault ? &quot;=&quot; : &quot;:=&quot;;
 209                 String typeName = option.type.getSimpleName();
 210                 String linePrefix = String.format(&quot;%s %s %s &quot;, name, assign, value);
 211                 int typeStartPos = PROPERTY_LINE_WIDTH - typeName.length();
 212                 int linePad = typeStartPos - linePrefix.length();
 213                 if (linePad &gt; 0) {
 214                     out.printf(&quot;%s%-&quot; + linePad + &quot;s[%s]%n&quot;, linePrefix, &quot;&quot;, typeName);
 215                 } else {
 216                     out.printf(&quot;%s[%s]%n&quot;, linePrefix, typeName);
 217                 }
 218                 for (String line : option.helpLines) {
 219                     out.printf(&quot;%&quot; + PROPERTY_HELP_INDENT + &quot;s%s%n&quot;, &quot;&quot;, line);
 220                 }
 221             }
 222         }
 223     }
 224 
<span class="line-modified"> 225     static HotSpotJVMCIBackendFactory findFactory(String architecture) {</span>
<span class="line-modified"> 226         for (HotSpotJVMCIBackendFactory factory : ServiceLoader.load(HotSpotJVMCIBackendFactory.class, ClassLoader.getSystemClassLoader())) {</span>


 227             if (factory.getArchitecture().equalsIgnoreCase(architecture)) {
 228                 return factory;
 229             }
 230         }
 231 
 232         throw new JVMCIError(&quot;No JVMCI runtime available for the %s architecture&quot;, architecture);
 233     }
 234 

















 235     /**
 236      * Gets the kind of a word value on the {@linkplain #getHostJVMCIBackend() host} backend.
 237      */
 238     public static JavaKind getHostWordKind() {
 239         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordJavaKind;
 240     }
 241 
<span class="line-modified"> 242     final CompilerToVM compilerToVm;</span>
 243 
 244     protected final HotSpotVMConfigStore configStore;
<span class="line-modified"> 245     private final HotSpotVMConfig config;</span>
 246     private final JVMCIBackend hostBackend;
 247 
 248     private final JVMCICompilerFactory compilerFactory;
 249     private final HotSpotJVMCICompilerFactory hsCompilerFactory;
 250     private volatile JVMCICompiler compiler;
<span class="line-modified"> 251     final HotSpotJVMCIMetaAccessContext metaAccessContext;</span>







 252 
 253     /**
<span class="line-modified"> 254      * Stores the result of {@link HotSpotJVMCICompilerFactory#getCompilationLevelAdjustment} so</span>
<span class="line-modified"> 255      * that it can be read from the VM.</span>

 256      */
<span class="line-modified"> 257     @SuppressWarnings(&quot;unused&quot;) private final int compilationLevelAdjustment;</span>























 258 
 259     private final Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; backends = new HashMap&lt;&gt;();
 260 
 261     private volatile List&lt;HotSpotVMEventListener&gt; vmEventListeners;
 262 
 263     private Iterable&lt;HotSpotVMEventListener&gt; getVmEventListeners() {
 264         if (vmEventListeners == null) {
 265             synchronized (this) {
 266                 if (vmEventListeners == null) {
 267                     vmEventListeners = JVMCIServiceLocator.getProviders(HotSpotVMEventListener.class);
 268                 }
 269             }
 270         }
 271         return vmEventListeners;
 272     }
 273 
 274     @SuppressWarnings(&quot;try&quot;)
 275     private HotSpotJVMCIRuntime() {
 276         compilerToVm = new CompilerToVM();
 277 
 278         try (InitTimer t = timer(&quot;HotSpotVMConfig&lt;init&gt;&quot;)) {
 279             configStore = new HotSpotVMConfigStore(compilerToVm);
 280             config = new HotSpotVMConfig(configStore);
 281         }
 282 










 283         String hostArchitecture = config.getHostArchitectureName();
 284 
 285         HotSpotJVMCIBackendFactory factory;
 286         try (InitTimer t = timer(&quot;find factory:&quot;, hostArchitecture)) {
 287             factory = findFactory(hostArchitecture);
 288         }
 289 
 290         try (InitTimer t = timer(&quot;create JVMCI backend:&quot;, hostArchitecture)) {
 291             hostBackend = registerBackend(factory.createJVMCIBackend(this, null));
 292         }
 293 
<span class="line-removed"> 294         metaAccessContext = new HotSpotJVMCIMetaAccessContext();</span>
<span class="line-removed"> 295 </span>
 296         compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();
 297         if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {
 298             hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;
<span class="line-modified"> 299             switch (hsCompilerFactory.getCompilationLevelAdjustment()) {</span>
<span class="line-modified"> 300                 case None:</span>
<span class="line-modified"> 301                     compilationLevelAdjustment = config.compLevelAdjustmentNone;</span>
<span class="line-modified"> 302                     break;</span>
<span class="line-modified"> 303                 case ByHolder:</span>
<span class="line-removed"> 304                     compilationLevelAdjustment = config.compLevelAdjustmentByHolder;</span>
<span class="line-removed"> 305                     break;</span>
<span class="line-removed"> 306                 case ByFullSignature:</span>
<span class="line-removed"> 307                     compilationLevelAdjustment = config.compLevelAdjustmentByFullSignature;</span>
<span class="line-removed"> 308                     break;</span>
<span class="line-removed"> 309                 default:</span>
<span class="line-removed"> 310                     compilationLevelAdjustment = config.compLevelAdjustmentNone;</span>
<span class="line-removed"> 311                     break;</span>
 312             }
 313         } else {
 314             hsCompilerFactory = null;
<span class="line-removed"> 315             compilationLevelAdjustment = config.compLevelAdjustmentNone;</span>
 316         }
 317 
 318         if (config.getFlag(&quot;JVMCIPrintProperties&quot;, Boolean.class)) {
<span class="line-modified"> 319             PrintStream out = new PrintStream(getLogStream());</span>
<span class="line-modified"> 320             Option.printProperties(out);</span>
<span class="line-modified"> 321             compilerFactory.printProperties(out);</span>


 322             System.exit(0);
 323         }
 324 
 325         if (Option.PrintConfig.getBoolean()) {
 326             configStore.printConfig();
 327         }
 328     }
 329 





































































 330     private JVMCIBackend registerBackend(JVMCIBackend backend) {
 331         Class&lt;? extends Architecture&gt; arch = backend.getCodeCache().getTarget().arch.getClass();
 332         JVMCIBackend oldValue = backends.put(arch, backend);
 333         assert oldValue == null : &quot;cannot overwrite existing backend for architecture &quot; + arch.getSimpleName();
 334         return backend;
 335     }
 336 
<span class="line-removed"> 337     ResolvedJavaType fromClass(Class&lt;?&gt; javaClass) {</span>
<span class="line-removed"> 338         return metaAccessContext.fromClass(javaClass);</span>
<span class="line-removed"> 339     }</span>
<span class="line-removed"> 340 </span>
 341     public HotSpotVMConfigStore getConfigStore() {
 342         return configStore;
 343     }
 344 
<span class="line-modified"> 345     HotSpotVMConfig getConfig() {</span>
 346         return config;
 347     }
 348 
<span class="line-modified"> 349     CompilerToVM getCompilerToVM() {</span>
 350         return compilerToVm;
 351     }
 352 
<span class="line-modified"> 353     // Non-volatile since multi-initialization is harmless</span>
<span class="line-modified"> 354     private Predicate&lt;ResolvedJavaType&gt; intrinsificationTrustPredicate;</span>

 355 
 356     /**
 357      * Gets a predicate that determines if a given type can be considered trusted for the purpose of
 358      * intrinsifying methods it declares.
 359      *
 360      * @param compilerLeafClasses classes in the leaves of the module graph comprising the JVMCI
 361      *            compiler.
 362      */
 363     public Predicate&lt;ResolvedJavaType&gt; getIntrinsificationTrustPredicate(Class&lt;?&gt;... compilerLeafClasses) {
<span class="line-modified"> 364         if (intrinsificationTrustPredicate == null) {</span>
<span class="line-modified"> 365             intrinsificationTrustPredicate = new Predicate&lt;&gt;() {</span>
<span class="line-modified"> 366                 @Override</span>
<span class="line-modified"> 367                 public boolean test(ResolvedJavaType type) {</span>
<span class="line-modified"> 368                     if (type instanceof HotSpotResolvedJavaType) {</span>
<span class="line-modified"> 369                         Class&lt;?&gt; mirror = getMirror(type);</span>
<span class="line-modified"> 370                         Module module = mirror.getModule();</span>
<span class="line-modified"> 371                         return getTrustedModules().contains(module);</span>
<span class="line-removed"> 372                     } else {</span>
<span class="line-removed"> 373                         return false;</span>
<span class="line-removed"> 374                     }</span>
<span class="line-removed"> 375                 }</span>
<span class="line-removed"> 376 </span>
<span class="line-removed"> 377                 private volatile Set&lt;Module&gt; trustedModules;</span>
<span class="line-removed"> 378 </span>
<span class="line-removed"> 379                 private Set&lt;Module&gt; getTrustedModules() {</span>
<span class="line-removed"> 380                     Set&lt;Module&gt; modules = trustedModules;</span>
<span class="line-removed"> 381                     if (modules == null) {</span>
<span class="line-removed"> 382                         modules = new HashSet&lt;&gt;();</span>
<span class="line-removed"> 383                         for (Class&lt;?&gt; compilerConfiguration : compilerLeafClasses) {</span>
<span class="line-removed"> 384                             Module compilerConfigurationModule = compilerConfiguration.getModule();</span>
<span class="line-removed"> 385                             if (compilerConfigurationModule.getDescriptor().isAutomatic()) {</span>
<span class="line-removed"> 386                                 throw new IllegalArgumentException(String.format(&quot;The module &#39;%s&#39; defining the Graal compiler configuration class &#39;%s&#39; must not be an automatic module&quot;,</span>
<span class="line-removed"> 387                                                 compilerConfigurationModule.getName(), compilerConfiguration.getClass().getName()));</span>
<span class="line-removed"> 388                             }</span>
<span class="line-removed"> 389                             modules.add(compilerConfigurationModule);</span>
<span class="line-removed"> 390                             for (Requires require : compilerConfigurationModule.getDescriptor().requires()) {</span>
<span class="line-removed"> 391                                 for (Module module : compilerConfigurationModule.getLayer().modules()) {</span>
<span class="line-removed"> 392                                     if (module.getName().equals(require.name())) {</span>
<span class="line-removed"> 393                                         modules.add(module);</span>
<span class="line-removed"> 394                                     }</span>
<span class="line-removed"> 395                                 }</span>
<span class="line-removed"> 396                             }</span>
<span class="line-removed"> 397                         }</span>
<span class="line-removed"> 398                         trustedModules = modules;</span>
<span class="line-removed"> 399                     }</span>
<span class="line-removed"> 400                     return modules;</span>
 401                 }
<span class="line-modified"> 402             };</span>
<span class="line-modified"> 403         }</span>
<span class="line-removed"> 404         return intrinsificationTrustPredicate;</span>
 405     }
 406 
 407     /**
 408      * Get the {@link Class} corresponding to {@code type}.
 409      *
 410      * @param type the type for which a {@link Class} is requested
 411      * @return the original Java class corresponding to {@code type} or {@code null} if this runtime
 412      *         does not support mapping {@link ResolvedJavaType} instances to {@link Class}
 413      *         instances
 414      */
<span class="line-removed"> 415     @SuppressWarnings(&quot;static-method&quot;)</span>
 416     public Class&lt;?&gt; getMirror(ResolvedJavaType type) {
<span class="line-modified"> 417         return ((HotSpotResolvedJavaType) type).mirror();</span>



 418     }
 419 
 420     @Override
 421     public JVMCICompiler getCompiler() {
 422         if (compiler == null) {
 423             synchronized (this) {
 424                 if (compiler == null) {


 425                     compiler = compilerFactory.createCompiler(this);

 426                 }
 427             }
 428         }
 429         return compiler;
 430     }
 431 
 432     /**
 433      * Converts a name to a Java type. This method attempts to resolve {@code name} to a
 434      * {@link ResolvedJavaType}.
 435      *
 436      * @param name a well formed Java type in {@linkplain JavaType#getName() internal} format
 437      * @param accessingType the context of resolution which must be non-null
 438      * @param resolve specifies whether resolution failure results in an unresolved type being
 439      *            return or a {@link LinkageError} being thrown
 440      * @return a Java type for {@code name} which is guaranteed to be of type
 441      *         {@link ResolvedJavaType} if {@code resolve == true}
 442      * @throws LinkageError if {@code resolve == true} and the resolution failed
 443      * @throws NullPointerException if {@code accessingClass} is {@code null}
 444      */
 445     public JavaType lookupType(String name, HotSpotResolvedObjectType accessingType, boolean resolve) {
 446         Objects.requireNonNull(accessingType, &quot;cannot resolve type without an accessing class&quot;);




 447         // If the name represents a primitive type we can short-circuit the lookup.
 448         if (name.length() == 1) {
 449             JavaKind kind = JavaKind.fromPrimitiveOrVoidTypeChar(name.charAt(0));
<span class="line-modified"> 450             return fromClass(kind.toJavaClass());</span>
 451         }
 452 
 453         // Resolve non-primitive types in the VM.
 454         HotSpotResolvedObjectTypeImpl hsAccessingType = (HotSpotResolvedObjectTypeImpl) accessingType;
 455         try {
<span class="line-modified"> 456             final HotSpotResolvedObjectTypeImpl klass = compilerToVm.lookupType(name, hsAccessingType.mirror(), resolve);</span>
 457 
 458             if (klass == null) {
<span class="line-modified"> 459                 assert resolve == false;</span>
 460                 return UnresolvedJavaType.create(name);
 461             }
 462             return klass;
 463         } catch (ClassNotFoundException e) {
 464             throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);
 465         }
 466     }
 467 
 468     @Override
 469     public JVMCIBackend getHostJVMCIBackend() {
 470         return hostBackend;
 471     }
 472 
 473     @Override
 474     public &lt;T extends Architecture&gt; JVMCIBackend getJVMCIBackend(Class&lt;T&gt; arch) {
 475         assert arch != Architecture.class;
 476         return backends.get(arch);
 477     }
 478 
 479     public Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; getJVMCIBackends() {
 480         return Collections.unmodifiableMap(backends);
 481     }
 482 
<span class="line-modified"> 483     /**</span>
<span class="line-modified"> 484      * Called from the VM.</span>
<span class="line-modified"> 485      */</span>
<span class="line-modified"> 486     @SuppressWarnings({&quot;unused&quot;})</span>
<span class="line-modified"> 487     private int adjustCompilationLevel(Class&lt;?&gt; declaringClass, String name, String signature, boolean isOsr, int level) {</span>
<span class="line-removed"> 488         CompilationLevel curLevel;</span>
<span class="line-removed"> 489         if (level == config.compilationLevelNone) {</span>
<span class="line-removed"> 490             curLevel = CompilationLevel.None;</span>
<span class="line-removed"> 491         } else if (level == config.compilationLevelSimple) {</span>
<span class="line-removed"> 492             curLevel = CompilationLevel.Simple;</span>
<span class="line-removed"> 493         } else if (level == config.compilationLevelLimitedProfile) {</span>
<span class="line-removed"> 494             curLevel = CompilationLevel.LimitedProfile;</span>
<span class="line-removed"> 495         } else if (level == config.compilationLevelFullProfile) {</span>
<span class="line-removed"> 496             curLevel = CompilationLevel.FullProfile;</span>
<span class="line-removed"> 497         } else if (level == config.compilationLevelFullOptimization) {</span>
<span class="line-removed"> 498             curLevel = CompilationLevel.FullOptimization;</span>
<span class="line-removed"> 499         } else {</span>
<span class="line-removed"> 500             throw JVMCIError.shouldNotReachHere();</span>
<span class="line-removed"> 501         }</span>
<span class="line-removed"> 502 </span>
<span class="line-removed"> 503         switch (hsCompilerFactory.adjustCompilationLevel(declaringClass, name, signature, isOsr, curLevel)) {</span>
<span class="line-removed"> 504             case None:</span>
<span class="line-removed"> 505                 return config.compilationLevelNone;</span>
<span class="line-removed"> 506             case Simple:</span>
<span class="line-removed"> 507                 return config.compilationLevelSimple;</span>
<span class="line-removed"> 508             case LimitedProfile:</span>
<span class="line-removed"> 509                 return config.compilationLevelLimitedProfile;</span>
<span class="line-removed"> 510             case FullProfile:</span>
<span class="line-removed"> 511                 return config.compilationLevelFullProfile;</span>
<span class="line-removed"> 512             case FullOptimization:</span>
<span class="line-removed"> 513                 return config.compilationLevelFullOptimization;</span>
<span class="line-removed"> 514             default:</span>
<span class="line-removed"> 515                 return level;</span>
<span class="line-removed"> 516         }</span>
<span class="line-removed"> 517     }</span>
<span class="line-removed"> 518 </span>
<span class="line-removed"> 519     /**</span>
<span class="line-removed"> 520      * Called from the VM.</span>
<span class="line-removed"> 521      */</span>
<span class="line-removed"> 522     @SuppressWarnings({&quot;unused&quot;})</span>
<span class="line-removed"> 523     private HotSpotCompilationRequestResult compileMethod(HotSpotResolvedJavaMethod method, int entryBCI, long jvmciEnv, int id) {</span>
<span class="line-removed"> 524         CompilationRequestResult result = getCompiler().compileMethod(new HotSpotCompilationRequest(method, entryBCI, jvmciEnv, id));</span>
 525         assert result != null : &quot;compileMethod must always return something&quot;;
 526         HotSpotCompilationRequestResult hsResult;
 527         if (result instanceof HotSpotCompilationRequestResult) {
 528             hsResult = (HotSpotCompilationRequestResult) result;
 529         } else {
 530             Object failure = result.getFailure();
 531             if (failure != null) {
 532                 boolean retry = false; // Be conservative with unknown compiler
 533                 hsResult = HotSpotCompilationRequestResult.failure(failure.toString(), retry);
 534             } else {
 535                 int inlinedBytecodes = -1;
 536                 hsResult = HotSpotCompilationRequestResult.success(inlinedBytecodes);
 537             }
 538         }
<span class="line-removed"> 539 </span>
 540         return hsResult;
 541     }
 542 
 543     /**
 544      * Shuts down the runtime.
<span class="line-removed"> 545      *</span>
<span class="line-removed"> 546      * Called from the VM.</span>
 547      */
<span class="line-modified"> 548     @SuppressWarnings({&quot;unused&quot;})</span>
 549     private void shutdown() throws Exception {




 550         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 551             vmEventListener.notifyShutdown();
 552         }
 553     }
 554 
 555     /**
 556      * Notify on completion of a bootstrap.
<span class="line-removed"> 557      *</span>
<span class="line-removed"> 558      * Called from the VM.</span>
 559      */
<span class="line-modified"> 560     @SuppressWarnings({&quot;unused&quot;})</span>
 561     private void bootstrapFinished() throws Exception {
 562         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 563             vmEventListener.notifyBootstrapFinished();
 564         }
 565     }
 566 
 567     /**
 568      * Notify on successful install into the CodeCache.
 569      *
 570      * @param hotSpotCodeCacheProvider
 571      * @param installedCode
 572      * @param compiledCode
 573      */
 574     void notifyInstall(HotSpotCodeCacheProvider hotSpotCodeCacheProvider, InstalledCode installedCode, CompiledCode compiledCode) {
 575         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 576             vmEventListener.notifyInstall(hotSpotCodeCacheProvider, installedCode, compiledCode);
 577         }
 578     }
 579 

















 580     /**
 581      * Gets an output stream that writes to HotSpot&#39;s {@code tty} stream.
 582      */
 583     public OutputStream getLogStream() {
 584         return new OutputStream() {
 585 
 586             @Override
 587             public void write(byte[] b, int off, int len) throws IOException {
 588                 if (b == null) {
 589                     throw new NullPointerException();
 590                 } else if (off &lt; 0 || off &gt; b.length || len &lt; 0 || (off + len) &gt; b.length || (off + len) &lt; 0) {
 591                     throw new IndexOutOfBoundsException();
 592                 } else if (len == 0) {
 593                     return;
 594                 }
<span class="line-modified"> 595                 compilerToVm.writeDebugOutput(b, off, len);</span>
 596             }
 597 
 598             @Override
 599             public void write(int b) throws IOException {
 600                 write(new byte[]{(byte) b}, 0, 1);
 601             }
 602 
 603             @Override
 604             public void flush() throws IOException {
 605                 compilerToVm.flushDebugOutput();
 606             }
 607         };
 608     }
 609 
 610     /**
 611      * Collects the current values of all JVMCI benchmark counters, summed up over all threads.
 612      */
 613     public long[] collectCounters() {
 614         return compilerToVm.collectCounters();
 615     }
 616 



















 617     /**
 618      * The offset from the origin of an array to the first element.
 619      *
 620      * @return the offset in bytes
 621      */
<span class="line-removed"> 622     @SuppressWarnings(&quot;static-method&quot;)</span>
 623     public int getArrayBaseOffset(JavaKind kind) {
 624         switch (kind) {
 625             case Boolean:
<span class="line-modified"> 626                 return Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;</span>
 627             case Byte:
<span class="line-modified"> 628                 return Unsafe.ARRAY_BYTE_BASE_OFFSET;</span>
 629             case Char:
<span class="line-modified"> 630                 return Unsafe.ARRAY_CHAR_BASE_OFFSET;</span>
 631             case Short:
<span class="line-modified"> 632                 return Unsafe.ARRAY_SHORT_BASE_OFFSET;</span>
 633             case Int:
<span class="line-modified"> 634                 return Unsafe.ARRAY_INT_BASE_OFFSET;</span>
 635             case Long:
<span class="line-modified"> 636                 return Unsafe.ARRAY_LONG_BASE_OFFSET;</span>
 637             case Float:
<span class="line-modified"> 638                 return Unsafe.ARRAY_FLOAT_BASE_OFFSET;</span>
 639             case Double:
<span class="line-modified"> 640                 return Unsafe.ARRAY_DOUBLE_BASE_OFFSET;</span>
 641             case Object:
<span class="line-modified"> 642                 return Unsafe.ARRAY_OBJECT_BASE_OFFSET;</span>
 643             default:
 644                 throw new JVMCIError(&quot;%s&quot;, kind);
 645         }
 646 
 647     }
 648 
 649     /**
 650      * The scale used for the index when accessing elements of an array of this kind.
 651      *
 652      * @return the scale in order to convert the index into a byte offset
 653      */
<span class="line-removed"> 654     @SuppressWarnings(&quot;static-method&quot;)</span>
 655     public int getArrayIndexScale(JavaKind kind) {
 656         switch (kind) {
 657             case Boolean:
<span class="line-modified"> 658                 return Unsafe.ARRAY_BOOLEAN_INDEX_SCALE;</span>
 659             case Byte:
<span class="line-modified"> 660                 return Unsafe.ARRAY_BYTE_INDEX_SCALE;</span>
 661             case Char:
<span class="line-modified"> 662                 return Unsafe.ARRAY_CHAR_INDEX_SCALE;</span>
 663             case Short:
<span class="line-modified"> 664                 return Unsafe.ARRAY_SHORT_INDEX_SCALE;</span>
 665             case Int:
<span class="line-modified"> 666                 return Unsafe.ARRAY_INT_INDEX_SCALE;</span>
 667             case Long:
<span class="line-modified"> 668                 return Unsafe.ARRAY_LONG_INDEX_SCALE;</span>
 669             case Float:
<span class="line-modified"> 670                 return Unsafe.ARRAY_FLOAT_INDEX_SCALE;</span>
 671             case Double:
<span class="line-modified"> 672                 return Unsafe.ARRAY_DOUBLE_INDEX_SCALE;</span>
 673             case Object:
<span class="line-modified"> 674                 return Unsafe.ARRAY_OBJECT_INDEX_SCALE;</span>
 675             default:
 676                 throw new JVMCIError(&quot;%s&quot;, kind);
 677 
 678         }
 679     }
 680 
 681     /**
<span class="line-modified"> 682      * Links each native method in {@code clazz} to an implementation in the JVMCI SVM library.</span>
 683      * &lt;p&gt;
 684      * A use case for this is a JVMCI compiler implementation that offers an API to Java code
<span class="line-modified"> 685      * executing in HotSpot to exercise functionality (mostly) in the JVMCI SVM library. For</span>
 686      * example:
 687      *
 688      * &lt;pre&gt;
 689      * package com.jcompile;
 690      *
 691      * import java.lang.reflect.Method;
 692      *
 693      * public static class JCompile {
 694      *     static {
 695      *         HotSpotJVMCIRuntime.runtime().registerNativeMethods(JCompile.class);
 696      *     }
 697      *     public static boolean compile(Method method, String[] options) {
 698      *         // Convert to simpler data types for passing/serializing across native interface
 699      *         long metaspaceMethodHandle = getHandle(method);
 700      *         char[] opts = convertToCharArray(options);
 701      *         return compile(metaspaceMethodHandle, opts);
 702      *     }
 703      *     private static native boolean compile0(long metaspaceMethodHandle, char[] options);
 704      *
 705      *     private static long getHandle(Method method) { ... }
 706      *     private static char[] convertToCharArray(String[] a) { ... }
 707      * }
 708      * &lt;/pre&gt;
 709      *
<span class="line-modified"> 710      * The implementation of the native {@code JCompile.compile0} method would be in the SVM library</span>
<span class="line-modified"> 711      * that contains the bulk of the JVMCI compiler. The {@code JCompile.compile0} implementation</span>
<span class="line-modified"> 712      * will be exported as the following JNI-compliant symbol:</span>
 713      *
 714      * &lt;pre&gt;
 715      * Java_com_jcompile_JCompile_compile0
 716      * &lt;/pre&gt;
 717      *
<span class="line-modified"> 718      * How the JVMCI compiler SVM library is built is outside the scope of this document.</span>


 719      *
<span class="line-removed"> 720      * @see &quot;https://docs.oracle.com/javase/10/docs/specs/jni/design.html#resolving-native-method-names&quot;</span>
 721      *



 722      * @throws NullPointerException if {@code clazz == null}
<span class="line-modified"> 723      * @throws IllegalArgumentException if the current execution context is SVM or if {@code clazz}</span>
<span class="line-modified"> 724      *             is {@link Class#isPrimitive()}</span>
<span class="line-modified"> 725      * @throws UnsatisfiedLinkError if the JVMCI SVM library is not available, a native method in</span>
<span class="line-modified"> 726      *             {@code clazz} is already linked or the SVM JVMCI library does not contain a</span>
<span class="line-modified"> 727      *             JNI-compliant symbol for a native method in {@code clazz}</span>






























 728      */
<span class="line-modified"> 729     @SuppressWarnings({&quot;static-method&quot;, &quot;unused&quot;})</span>
<span class="line-modified"> 730     public void registerNativeMethods(Class&lt;?&gt; clazz) {</span>
<span class="line-modified"> 731         throw new UnsatisfiedLinkError(&quot;SVM library is not available&quot;);</span>



















































































 732     }
 733 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.common.InitTimer.timer;
<span class="line-added">  26 import static jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevelAdjustment.None;</span>
<span class="line-added">  27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;</span>
<span class="line-added">  28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;</span>
  29 
  30 import java.io.IOException;
  31 import java.io.OutputStream;
  32 import java.io.PrintStream;
<span class="line-modified">  33 import java.io.Serializable;</span>
<span class="line-added">  34 import java.lang.invoke.CallSite;</span>
<span class="line-added">  35 import java.lang.invoke.ConstantCallSite;</span>
<span class="line-added">  36 import java.lang.invoke.MethodHandle;</span>
<span class="line-added">  37 import java.lang.ref.WeakReference;</span>
<span class="line-added">  38 import java.util.ArrayList;</span>
  39 import java.util.Collections;
  40 import java.util.HashMap;

  41 import java.util.List;
  42 import java.util.Map;
  43 import java.util.Objects;
  44 import java.util.ServiceLoader;

  45 import java.util.function.Predicate;
  46 


  47 import jdk.vm.ci.code.Architecture;
  48 import jdk.vm.ci.code.CompilationRequestResult;
  49 import jdk.vm.ci.code.CompiledCode;
  50 import jdk.vm.ci.code.InstalledCode;
  51 import jdk.vm.ci.common.InitTimer;
  52 import jdk.vm.ci.common.JVMCIError;
<span class="line-modified">  53 import jdk.vm.ci.common.NativeImageReinitialize;</span>
  54 import jdk.vm.ci.meta.JavaKind;
  55 import jdk.vm.ci.meta.JavaType;
  56 import jdk.vm.ci.meta.ResolvedJavaType;
  57 import jdk.vm.ci.meta.UnresolvedJavaType;
  58 import jdk.vm.ci.runtime.JVMCI;
  59 import jdk.vm.ci.runtime.JVMCIBackend;
  60 import jdk.vm.ci.runtime.JVMCICompiler;
  61 import jdk.vm.ci.runtime.JVMCICompilerFactory;
  62 import jdk.vm.ci.runtime.JVMCIRuntime;
  63 import jdk.vm.ci.services.JVMCIServiceLocator;
<span class="line-added">  64 import jdk.vm.ci.services.Services;</span>
  65 
  66 /**
  67  * HotSpot implementation of a JVMCI runtime.







  68  */
  69 public final class HotSpotJVMCIRuntime implements JVMCIRuntime {
  70 
<span class="line-modified">  71     /**</span>
<span class="line-modified">  72      * Singleton instance lazily initialized via double-checked locking.</span>
<span class="line-modified">  73      */</span>
<span class="line-added">  74     @NativeImageReinitialize private static volatile HotSpotJVMCIRuntime instance;</span>
<span class="line-added">  75 </span>
<span class="line-added">  76     private HotSpotResolvedObjectTypeImpl javaLangObject;</span>
<span class="line-added">  77     private HotSpotResolvedObjectTypeImpl javaLangInvokeMethodHandle;</span>
<span class="line-added">  78     private HotSpotResolvedObjectTypeImpl constantCallSiteType;</span>
<span class="line-added">  79     private HotSpotResolvedObjectTypeImpl callSiteType;</span>
<span class="line-added">  80     private HotSpotResolvedObjectTypeImpl javaLangString;</span>
<span class="line-added">  81     private HotSpotResolvedObjectTypeImpl javaLangClass;</span>
<span class="line-added">  82     private HotSpotResolvedObjectTypeImpl throwableType;</span>
<span class="line-added">  83     private HotSpotResolvedObjectTypeImpl serializableType;</span>
<span class="line-added">  84     private HotSpotResolvedObjectTypeImpl cloneableType;</span>
<span class="line-added">  85     private HotSpotResolvedObjectTypeImpl enumType;</span>
<span class="line-added">  86 </span>
<span class="line-added">  87     HotSpotResolvedObjectTypeImpl getJavaLangObject() {</span>
<span class="line-added">  88         if (javaLangObject == null) {</span>
<span class="line-added">  89             javaLangObject = (HotSpotResolvedObjectTypeImpl) fromClass(Object.class);</span>
<span class="line-added">  90         }</span>
<span class="line-added">  91         return javaLangObject;</span>
<span class="line-added">  92     }</span>
  93 
<span class="line-modified">  94     HotSpotResolvedObjectTypeImpl getJavaLangString() {</span>
<span class="line-modified">  95         if (javaLangString == null) {</span>
<span class="line-modified">  96             javaLangString = (HotSpotResolvedObjectTypeImpl) fromClass(String.class);</span>
<span class="line-added">  97         }</span>
<span class="line-added">  98         return javaLangString;</span>
<span class="line-added">  99     }</span>
 100 
<span class="line-modified"> 101     HotSpotResolvedObjectTypeImpl getJavaLangClass() {</span>
<span class="line-modified"> 102         if (javaLangClass == null) {</span>
<span class="line-modified"> 103             javaLangClass = (HotSpotResolvedObjectTypeImpl) fromClass(Class.class);</span>
<span class="line-modified"> 104         }</span>
<span class="line-modified"> 105         return javaLangClass;</span>
<span class="line-modified"> 106     }</span>
<span class="line-added"> 107 </span>
<span class="line-added"> 108     HotSpotResolvedObjectTypeImpl getJavaLangCloneable() {</span>
<span class="line-added"> 109         if (cloneableType == null) {</span>
<span class="line-added"> 110             cloneableType = (HotSpotResolvedObjectTypeImpl) fromClass(Cloneable.class);</span>
<span class="line-added"> 111         }</span>
<span class="line-added"> 112         return cloneableType;</span>
<span class="line-added"> 113     }</span>
<span class="line-added"> 114 </span>
<span class="line-added"> 115     HotSpotResolvedObjectTypeImpl getJavaLangSerializable() {</span>
<span class="line-added"> 116         if (serializableType == null) {</span>
<span class="line-added"> 117             serializableType = (HotSpotResolvedObjectTypeImpl) fromClass(Serializable.class);</span>
<span class="line-added"> 118         }</span>
<span class="line-added"> 119         return serializableType;</span>
<span class="line-added"> 120     }</span>
<span class="line-added"> 121 </span>
<span class="line-added"> 122     HotSpotResolvedObjectTypeImpl getJavaLangThrowable() {</span>
<span class="line-added"> 123         if (throwableType == null) {</span>
<span class="line-added"> 124             throwableType = (HotSpotResolvedObjectTypeImpl) fromClass(Throwable.class);</span>
<span class="line-added"> 125         }</span>
<span class="line-added"> 126         return throwableType;</span>
<span class="line-added"> 127     }</span>
<span class="line-added"> 128 </span>
<span class="line-added"> 129     HotSpotResolvedObjectTypeImpl getJavaLangEnum() {</span>
<span class="line-added"> 130         if (enumType == null) {</span>
<span class="line-added"> 131             enumType = (HotSpotResolvedObjectTypeImpl) fromClass(Enum.class);</span>
<span class="line-added"> 132         }</span>
<span class="line-added"> 133         return enumType;</span>
<span class="line-added"> 134     }</span>
<span class="line-added"> 135 </span>
<span class="line-added"> 136     HotSpotResolvedObjectTypeImpl getConstantCallSite() {</span>
<span class="line-added"> 137         if (constantCallSiteType == null) {</span>
<span class="line-added"> 138             constantCallSiteType = (HotSpotResolvedObjectTypeImpl) fromClass(ConstantCallSite.class);</span>
<span class="line-added"> 139         }</span>
<span class="line-added"> 140         return constantCallSiteType;</span>
<span class="line-added"> 141     }</span>
<span class="line-added"> 142 </span>
<span class="line-added"> 143     HotSpotResolvedObjectTypeImpl getCallSite() {</span>
<span class="line-added"> 144         if (callSiteType == null) {</span>
<span class="line-added"> 145             callSiteType = (HotSpotResolvedObjectTypeImpl) fromClass(CallSite.class);</span>
<span class="line-added"> 146         }</span>
<span class="line-added"> 147         return callSiteType;</span>
<span class="line-added"> 148     }</span>
<span class="line-added"> 149 </span>
<span class="line-added"> 150     HotSpotResolvedObjectType getMethodHandleClass() {</span>
<span class="line-added"> 151         if (javaLangInvokeMethodHandle == null) {</span>
<span class="line-added"> 152             javaLangInvokeMethodHandle = (HotSpotResolvedObjectTypeImpl) fromClass(MethodHandle.class);</span>
 153         }
<span class="line-added"> 154         return javaLangInvokeMethodHandle;</span>
 155     }
 156 
 157     /**
 158      * Gets the singleton {@link HotSpotJVMCIRuntime} object.
 159      */
<span class="line-added"> 160     @VMEntryPoint</span>
<span class="line-added"> 161     @SuppressWarnings(&quot;try&quot;)</span>
 162     public static HotSpotJVMCIRuntime runtime() {
<span class="line-modified"> 163         HotSpotJVMCIRuntime result = instance;</span>
<span class="line-modified"> 164         if (result == null) {</span>
<span class="line-added"> 165             // Synchronize on JVMCI.class to avoid deadlock</span>
<span class="line-added"> 166             // between the two JVMCI initialization paths:</span>
<span class="line-added"> 167             // HotSpotJVMCIRuntime.runtime() and JVMCI.getRuntime().</span>
<span class="line-added"> 168             synchronized (JVMCI.class) {</span>
<span class="line-added"> 169                 result = instance;</span>
<span class="line-added"> 170                 if (result == null) {</span>
<span class="line-added"> 171                     try (InitTimer t = timer(&quot;HotSpotJVMCIRuntime.&lt;init&gt;&quot;)) {</span>
<span class="line-added"> 172                         instance = result = new HotSpotJVMCIRuntime();</span>
<span class="line-added"> 173 </span>
<span class="line-added"> 174                         // Can only do eager initialization of the JVMCI compiler</span>
<span class="line-added"> 175                         // once the singleton instance is available.</span>
<span class="line-added"> 176                         if (result.config.getFlag(&quot;EagerJVMCI&quot;, Boolean.class)) {</span>
<span class="line-added"> 177                             result.getCompiler();</span>
<span class="line-added"> 178                         }</span>
<span class="line-added"> 179                     }</span>
<span class="line-added"> 180                     // Ensures JVMCIRuntime::_HotSpotJVMCIRuntime_instance is</span>
<span class="line-added"> 181                     // initialized.</span>
<span class="line-added"> 182                     JVMCI.getRuntime();</span>
<span class="line-added"> 183                 }</span>
<span class="line-added"> 184                 // Make sure all the primitive box caches are populated (required to properly</span>
<span class="line-added"> 185                 // materialize boxed primitives</span>
<span class="line-added"> 186                 // during deoptimization).</span>
<span class="line-added"> 187                 Boolean.valueOf(false);</span>
<span class="line-added"> 188                 Byte.valueOf((byte) 0);</span>
<span class="line-added"> 189                 Short.valueOf((short) 0);</span>
<span class="line-added"> 190                 Character.valueOf((char) 0);</span>
<span class="line-added"> 191                 Integer.valueOf(0);</span>
<span class="line-added"> 192                 Long.valueOf(0);</span>
<span class="line-added"> 193             }</span>
<span class="line-added"> 194         }</span>
<span class="line-added"> 195         return result;</span>
<span class="line-added"> 196     }</span>
<span class="line-added"> 197 </span>
<span class="line-added"> 198     @VMEntryPoint</span>
<span class="line-added"> 199     static Throwable decodeThrowable(String encodedThrowable) throws Throwable {</span>
<span class="line-added"> 200         return TranslatedException.decodeThrowable(encodedThrowable);</span>
<span class="line-added"> 201     }</span>
<span class="line-added"> 202 </span>
<span class="line-added"> 203     @VMEntryPoint</span>
<span class="line-added"> 204     static String encodeThrowable(Throwable throwable) throws Throwable {</span>
<span class="line-added"> 205         return TranslatedException.encodeThrowable(throwable);</span>
<span class="line-added"> 206     }</span>
<span class="line-added"> 207 </span>
<span class="line-added"> 208     @VMEntryPoint</span>
<span class="line-added"> 209     static String callToString(Object o) {</span>
<span class="line-added"> 210         return o.toString();</span>
 211     }
 212 
 213     /**
 214      * A list of all supported JVMCI options.
 215      */
 216     public enum Option {
 217         // @formatter:off
 218         Compiler(String.class, null, &quot;Selects the system compiler. This must match the getCompilerName() value returned &quot; +
<span class="line-modified"> 219                 &quot;by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. &quot; +</span>
<span class="line-modified"> 220                 &quot;An empty string or the value \&quot;null\&quot; selects a compiler &quot; +</span>
<span class="line-modified"> 221                 &quot;that will raise an exception upon receiving a compilation request.&quot;),</span>
 222         // Note: The following one is not used (see InitTimer.ENABLED). It is added here
 223         // so that -XX:+JVMCIPrintProperties shows the option.
 224         InitTimer(Boolean.class, false, &quot;Specifies if initialization timing is enabled.&quot;),
 225         PrintConfig(Boolean.class, false, &quot;Prints VM configuration available via JVMCI.&quot;),
<span class="line-added"> 226         AuditHandles(Boolean.class, false, &quot;Record stack trace along with scoped foreign object reference wrappers &quot; +</span>
<span class="line-added"> 227                 &quot;to debug issue with a wrapper being used after its scope has closed.&quot;),</span>
 228         TraceMethodDataFilter(String.class, null,
<span class="line-modified"> 229                 &quot;Enables tracing of profiling info when read by JVMCI.&quot;,</span>
<span class="line-modified"> 230                 &quot;Empty value: trace all methods&quot;,</span>
<span class="line-modified"> 231                 &quot;Non-empty value: trace methods whose fully qualified name contains the value.&quot;),</span>
 232         UseProfilingInformation(Boolean.class, true, &quot;&quot;);
 233         // @formatter:on
 234 
 235         /**
 236          * The prefix for system properties that are JVMCI options.
 237          */
 238         private static final String JVMCI_OPTION_PROPERTY_PREFIX = &quot;jvmci.&quot;;
 239 
 240         /**
<span class="line-modified"> 241          * Sentinel for value initialized to {@code null} since {@code null} means uninitialized.</span>
 242          */
<span class="line-modified"> 243         private static final String NULL_VALUE = &quot;NULL&quot;;</span>
 244 
 245         private final Class&lt;?&gt; type;
<span class="line-modified"> 246         @NativeImageReinitialize private Object value;</span>
 247         private final Object defaultValue;
 248         private boolean isDefault;
 249         private final String[] helpLines;
 250 
 251         Option(Class&lt;?&gt; type, Object defaultValue, String... helpLines) {
 252             assert Character.isUpperCase(name().charAt(0)) : &quot;Option name must start with upper-case letter: &quot; + name();
 253             this.type = type;

 254             this.defaultValue = defaultValue;
 255             this.helpLines = helpLines;
 256         }
 257 
 258         @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)
 259         private Object getValue() {
<span class="line-modified"> 260             if (value == null) {</span>
<span class="line-modified"> 261                 String propertyValue = Services.getSavedProperty(getPropertyName());</span>
 262                 if (propertyValue == null) {
<span class="line-modified"> 263                     this.value = defaultValue == null ? NULL_VALUE : defaultValue;</span>
 264                     this.isDefault = true;
 265                 } else {
 266                     if (type == Boolean.class) {
 267                         this.value = Boolean.parseBoolean(propertyValue);
 268                     } else if (type == String.class) {
 269                         this.value = propertyValue;
 270                     } else {
 271                         throw new JVMCIError(&quot;Unexpected option type &quot; + type);
 272                     }
 273                     this.isDefault = false;
 274                 }


 275             }
<span class="line-modified"> 276             return value == NULL_VALUE ? null : value;</span>
 277         }
 278 
 279         /**
 280          * Gets the name of system property from which this option gets its value.
 281          */
 282         public String getPropertyName() {
 283             return JVMCI_OPTION_PROPERTY_PREFIX + name();
 284         }
 285 
 286         /**
 287          * Returns the option&#39;s value as boolean.
 288          *
 289          * @return option&#39;s value
 290          */
 291         public boolean getBoolean() {
 292             return (boolean) getValue();
 293         }
 294 
 295         /**
 296          * Returns the option&#39;s value as String.
</pre>
<hr />
<pre>
 319                 }
 320 
 321                 String name = option.getPropertyName();
 322                 String assign = option.isDefault ? &quot;=&quot; : &quot;:=&quot;;
 323                 String typeName = option.type.getSimpleName();
 324                 String linePrefix = String.format(&quot;%s %s %s &quot;, name, assign, value);
 325                 int typeStartPos = PROPERTY_LINE_WIDTH - typeName.length();
 326                 int linePad = typeStartPos - linePrefix.length();
 327                 if (linePad &gt; 0) {
 328                     out.printf(&quot;%s%-&quot; + linePad + &quot;s[%s]%n&quot;, linePrefix, &quot;&quot;, typeName);
 329                 } else {
 330                     out.printf(&quot;%s[%s]%n&quot;, linePrefix, typeName);
 331                 }
 332                 for (String line : option.helpLines) {
 333                     out.printf(&quot;%&quot; + PROPERTY_HELP_INDENT + &quot;s%s%n&quot;, &quot;&quot;, line);
 334                 }
 335             }
 336         }
 337     }
 338 
<span class="line-modified"> 339     private static HotSpotJVMCIBackendFactory findFactory(String architecture) {</span>
<span class="line-modified"> 340         Iterable&lt;HotSpotJVMCIBackendFactory&gt; factories = getHotSpotJVMCIBackendFactories();</span>
<span class="line-added"> 341         assert factories != null : &quot;sanity&quot;;</span>
<span class="line-added"> 342         for (HotSpotJVMCIBackendFactory factory : factories) {</span>
 343             if (factory.getArchitecture().equalsIgnoreCase(architecture)) {
 344                 return factory;
 345             }
 346         }
 347 
 348         throw new JVMCIError(&quot;No JVMCI runtime available for the %s architecture&quot;, architecture);
 349     }
 350 
<span class="line-added"> 351     private static volatile List&lt;HotSpotJVMCIBackendFactory&gt; cachedHotSpotJVMCIBackendFactories;</span>
<span class="line-added"> 352 </span>
<span class="line-added"> 353     @SuppressFBWarnings(value = &quot;LI_LAZY_INIT_UPDATE_STATIC&quot;, justification = &quot;not sure about this&quot;)</span>
<span class="line-added"> 354     private static Iterable&lt;HotSpotJVMCIBackendFactory&gt; getHotSpotJVMCIBackendFactories() {</span>
<span class="line-added"> 355         if (IS_IN_NATIVE_IMAGE || cachedHotSpotJVMCIBackendFactories != null) {</span>
<span class="line-added"> 356             return cachedHotSpotJVMCIBackendFactories;</span>
<span class="line-added"> 357         }</span>
<span class="line-added"> 358         Iterable&lt;HotSpotJVMCIBackendFactory&gt; result = ServiceLoader.load(HotSpotJVMCIBackendFactory.class, ClassLoader.getSystemClassLoader());</span>
<span class="line-added"> 359         if (IS_BUILDING_NATIVE_IMAGE) {</span>
<span class="line-added"> 360             cachedHotSpotJVMCIBackendFactories = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 361             for (HotSpotJVMCIBackendFactory factory : result) {</span>
<span class="line-added"> 362                 cachedHotSpotJVMCIBackendFactories.add(factory);</span>
<span class="line-added"> 363             }</span>
<span class="line-added"> 364         }</span>
<span class="line-added"> 365         return result;</span>
<span class="line-added"> 366     }</span>
<span class="line-added"> 367 </span>
 368     /**
 369      * Gets the kind of a word value on the {@linkplain #getHostJVMCIBackend() host} backend.
 370      */
 371     public static JavaKind getHostWordKind() {
 372         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordJavaKind;
 373     }
 374 
<span class="line-modified"> 375     protected final CompilerToVM compilerToVm;</span>
 376 
 377     protected final HotSpotVMConfigStore configStore;
<span class="line-modified"> 378     protected final HotSpotVMConfig config;</span>
 379     private final JVMCIBackend hostBackend;
 380 
 381     private final JVMCICompilerFactory compilerFactory;
 382     private final HotSpotJVMCICompilerFactory hsCompilerFactory;
 383     private volatile JVMCICompiler compiler;
<span class="line-modified"> 384     protected final HotSpotJVMCIReflection reflection;</span>
<span class="line-added"> 385 </span>
<span class="line-added"> 386     @NativeImageReinitialize private volatile boolean creatingCompiler;</span>
<span class="line-added"> 387 </span>
<span class="line-added"> 388     /**</span>
<span class="line-added"> 389      * Cache for speeding up {@link #fromClass(Class)}.</span>
<span class="line-added"> 390      */</span>
<span class="line-added"> 391     @NativeImageReinitialize private volatile ClassValue&lt;WeakReferenceHolder&lt;HotSpotResolvedJavaType&gt;&gt; resolvedJavaType;</span>
 392 
 393     /**
<span class="line-modified"> 394      * To avoid calling ClassValue.remove to refresh the weak reference, which under certain</span>
<span class="line-modified"> 395      * circumstances can lead to an infinite loop, we use a permanent holder with a mutable field</span>
<span class="line-added"> 396      * that we refresh.</span>
 397      */
<span class="line-modified"> 398     private static class WeakReferenceHolder&lt;T&gt; {</span>
<span class="line-added"> 399         private volatile WeakReference&lt;T&gt; ref;</span>
<span class="line-added"> 400 </span>
<span class="line-added"> 401         WeakReferenceHolder(T value) {</span>
<span class="line-added"> 402             set(value);</span>
<span class="line-added"> 403         }</span>
<span class="line-added"> 404 </span>
<span class="line-added"> 405         void set(T value) {</span>
<span class="line-added"> 406             ref = new WeakReference&lt;&gt;(value);</span>
<span class="line-added"> 407         }</span>
<span class="line-added"> 408 </span>
<span class="line-added"> 409         T get() {</span>
<span class="line-added"> 410             return ref.get();</span>
<span class="line-added"> 411         }</span>
<span class="line-added"> 412     }</span>
<span class="line-added"> 413 </span>
<span class="line-added"> 414     @NativeImageReinitialize private HashMap&lt;Long, WeakReference&lt;ResolvedJavaType&gt;&gt; resolvedJavaTypes;</span>
<span class="line-added"> 415 </span>
<span class="line-added"> 416     /**</span>
<span class="line-added"> 417      * Stores the value set by {@link #excludeFromJVMCICompilation(Module...)} so that it can be</span>
<span class="line-added"> 418      * read from the VM.</span>
<span class="line-added"> 419      */</span>
<span class="line-added"> 420     @SuppressWarnings(&quot;unused&quot;)//</span>
<span class="line-added"> 421     @NativeImageReinitialize private Module[] excludeFromJVMCICompilation;</span>
 422 
 423     private final Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; backends = new HashMap&lt;&gt;();
 424 
 425     private volatile List&lt;HotSpotVMEventListener&gt; vmEventListeners;
 426 
 427     private Iterable&lt;HotSpotVMEventListener&gt; getVmEventListeners() {
 428         if (vmEventListeners == null) {
 429             synchronized (this) {
 430                 if (vmEventListeners == null) {
 431                     vmEventListeners = JVMCIServiceLocator.getProviders(HotSpotVMEventListener.class);
 432                 }
 433             }
 434         }
 435         return vmEventListeners;
 436     }
 437 
 438     @SuppressWarnings(&quot;try&quot;)
 439     private HotSpotJVMCIRuntime() {
 440         compilerToVm = new CompilerToVM();
 441 
 442         try (InitTimer t = timer(&quot;HotSpotVMConfig&lt;init&gt;&quot;)) {
 443             configStore = new HotSpotVMConfigStore(compilerToVm);
 444             config = new HotSpotVMConfig(configStore);
 445         }
 446 
<span class="line-added"> 447         reflection = IS_IN_NATIVE_IMAGE ? new SharedLibraryJVMCIReflection() : new HotSpotJDKReflection();</span>
<span class="line-added"> 448 </span>
<span class="line-added"> 449         PrintStream vmLogStream = null;</span>
<span class="line-added"> 450         if (IS_IN_NATIVE_IMAGE) {</span>
<span class="line-added"> 451             // Redirect System.out and System.err to HotSpot&#39;s TTY stream</span>
<span class="line-added"> 452             vmLogStream = new PrintStream(getLogStream());</span>
<span class="line-added"> 453             System.setOut(vmLogStream);</span>
<span class="line-added"> 454             System.setErr(vmLogStream);</span>
<span class="line-added"> 455         }</span>
<span class="line-added"> 456 </span>
 457         String hostArchitecture = config.getHostArchitectureName();
 458 
 459         HotSpotJVMCIBackendFactory factory;
 460         try (InitTimer t = timer(&quot;find factory:&quot;, hostArchitecture)) {
 461             factory = findFactory(hostArchitecture);
 462         }
 463 
 464         try (InitTimer t = timer(&quot;create JVMCI backend:&quot;, hostArchitecture)) {
 465             hostBackend = registerBackend(factory.createJVMCIBackend(this, null));
 466         }
 467 


 468         compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();
 469         if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {
 470             hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;
<span class="line-modified"> 471             if (hsCompilerFactory.getCompilationLevelAdjustment() != None) {</span>
<span class="line-modified"> 472                 String name = HotSpotJVMCICompilerFactory.class.getName();</span>
<span class="line-modified"> 473                 String msg = String.format(&quot;%s.getCompilationLevelAdjustment() is no longer supported. &quot; +</span>
<span class="line-modified"> 474                                 &quot;Use %s.excludeFromJVMCICompilation() instead.&quot;, name, name);</span>
<span class="line-modified"> 475                 throw new UnsupportedOperationException(msg);</span>








 476             }
 477         } else {
 478             hsCompilerFactory = null;

 479         }
 480 
 481         if (config.getFlag(&quot;JVMCIPrintProperties&quot;, Boolean.class)) {
<span class="line-modified"> 482             if (vmLogStream == null) {</span>
<span class="line-modified"> 483                 vmLogStream = new PrintStream(getLogStream());</span>
<span class="line-modified"> 484             }</span>
<span class="line-added"> 485             Option.printProperties(vmLogStream);</span>
<span class="line-added"> 486             compilerFactory.printProperties(vmLogStream);</span>
 487             System.exit(0);
 488         }
 489 
 490         if (Option.PrintConfig.getBoolean()) {
 491             configStore.printConfig();
 492         }
 493     }
 494 
<span class="line-added"> 495     HotSpotResolvedJavaType createClass(Class&lt;?&gt; javaClass) {</span>
<span class="line-added"> 496         if (javaClass.isPrimitive()) {</span>
<span class="line-added"> 497             return HotSpotResolvedPrimitiveType.forKind(JavaKind.fromJavaClass(javaClass));</span>
<span class="line-added"> 498         }</span>
<span class="line-added"> 499         if (IS_IN_NATIVE_IMAGE) {</span>
<span class="line-added"> 500             try {</span>
<span class="line-added"> 501                 return compilerToVm.lookupType(javaClass.getName().replace(&#39;.&#39;, &#39;/&#39;), null, true);</span>
<span class="line-added"> 502             } catch (ClassNotFoundException e) {</span>
<span class="line-added"> 503                 throw new JVMCIError(e);</span>
<span class="line-added"> 504             }</span>
<span class="line-added"> 505         }</span>
<span class="line-added"> 506         return compilerToVm.lookupClass(javaClass);</span>
<span class="line-added"> 507     }</span>
<span class="line-added"> 508 </span>
<span class="line-added"> 509     private HotSpotResolvedJavaType fromClass0(Class&lt;?&gt; javaClass) {</span>
<span class="line-added"> 510         if (resolvedJavaType == null) {</span>
<span class="line-added"> 511             synchronized (this) {</span>
<span class="line-added"> 512                 if (resolvedJavaType == null) {</span>
<span class="line-added"> 513                     resolvedJavaType = new ClassValue&lt;&gt;() {</span>
<span class="line-added"> 514                         @Override</span>
<span class="line-added"> 515                         protected WeakReferenceHolder&lt;HotSpotResolvedJavaType&gt; computeValue(Class&lt;?&gt; type) {</span>
<span class="line-added"> 516                             return new WeakReferenceHolder&lt;&gt;(createClass(type));</span>
<span class="line-added"> 517                         }</span>
<span class="line-added"> 518                     };</span>
<span class="line-added"> 519                 }</span>
<span class="line-added"> 520             }</span>
<span class="line-added"> 521         }</span>
<span class="line-added"> 522 </span>
<span class="line-added"> 523         WeakReferenceHolder&lt;HotSpotResolvedJavaType&gt; ref = resolvedJavaType.get(javaClass);</span>
<span class="line-added"> 524         HotSpotResolvedJavaType javaType = ref.get();</span>
<span class="line-added"> 525         if (javaType == null) {</span>
<span class="line-added"> 526             /*</span>
<span class="line-added"> 527              * If the referent has become null, create a new value and update cached weak reference.</span>
<span class="line-added"> 528              */</span>
<span class="line-added"> 529             javaType = createClass(javaClass);</span>
<span class="line-added"> 530             ref.set(javaType);</span>
<span class="line-added"> 531         }</span>
<span class="line-added"> 532         return javaType;</span>
<span class="line-added"> 533     }</span>
<span class="line-added"> 534 </span>
<span class="line-added"> 535     /**</span>
<span class="line-added"> 536      * Gets the JVMCI mirror for a {@link Class} object.</span>
<span class="line-added"> 537      *</span>
<span class="line-added"> 538      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}</span>
<span class="line-added"> 539      */</span>
<span class="line-added"> 540     HotSpotResolvedJavaType fromClass(Class&lt;?&gt; javaClass) {</span>
<span class="line-added"> 541         if (javaClass == null) {</span>
<span class="line-added"> 542             return null;</span>
<span class="line-added"> 543         }</span>
<span class="line-added"> 544         return fromClass0(javaClass);</span>
<span class="line-added"> 545     }</span>
<span class="line-added"> 546 </span>
<span class="line-added"> 547     synchronized HotSpotResolvedObjectTypeImpl fromMetaspace(long klassPointer, String signature) {</span>
<span class="line-added"> 548         if (resolvedJavaTypes == null) {</span>
<span class="line-added"> 549             resolvedJavaTypes = new HashMap&lt;&gt;();</span>
<span class="line-added"> 550         }</span>
<span class="line-added"> 551         assert klassPointer != 0;</span>
<span class="line-added"> 552         WeakReference&lt;ResolvedJavaType&gt; klassReference = resolvedJavaTypes.get(klassPointer);</span>
<span class="line-added"> 553         HotSpotResolvedObjectTypeImpl javaType = null;</span>
<span class="line-added"> 554         if (klassReference != null) {</span>
<span class="line-added"> 555             javaType = (HotSpotResolvedObjectTypeImpl) klassReference.get();</span>
<span class="line-added"> 556         }</span>
<span class="line-added"> 557         if (javaType == null) {</span>
<span class="line-added"> 558             javaType = new HotSpotResolvedObjectTypeImpl(klassPointer, signature);</span>
<span class="line-added"> 559             resolvedJavaTypes.put(klassPointer, new WeakReference&lt;&gt;(javaType));</span>
<span class="line-added"> 560         }</span>
<span class="line-added"> 561         return javaType;</span>
<span class="line-added"> 562     }</span>
<span class="line-added"> 563 </span>
 564     private JVMCIBackend registerBackend(JVMCIBackend backend) {
 565         Class&lt;? extends Architecture&gt; arch = backend.getCodeCache().getTarget().arch.getClass();
 566         JVMCIBackend oldValue = backends.put(arch, backend);
 567         assert oldValue == null : &quot;cannot overwrite existing backend for architecture &quot; + arch.getSimpleName();
 568         return backend;
 569     }
 570 




 571     public HotSpotVMConfigStore getConfigStore() {
 572         return configStore;
 573     }
 574 
<span class="line-modified"> 575     public HotSpotVMConfig getConfig() {</span>
 576         return config;
 577     }
 578 
<span class="line-modified"> 579     public CompilerToVM getCompilerToVM() {</span>
 580         return compilerToVm;
 581     }
 582 
<span class="line-modified"> 583     HotSpotJVMCIReflection getReflection() {</span>
<span class="line-modified"> 584         return reflection;</span>
<span class="line-added"> 585     }</span>
 586 
 587     /**
 588      * Gets a predicate that determines if a given type can be considered trusted for the purpose of
 589      * intrinsifying methods it declares.
 590      *
 591      * @param compilerLeafClasses classes in the leaves of the module graph comprising the JVMCI
 592      *            compiler.
 593      */
 594     public Predicate&lt;ResolvedJavaType&gt; getIntrinsificationTrustPredicate(Class&lt;?&gt;... compilerLeafClasses) {
<span class="line-modified"> 595         return new Predicate&lt;&gt;() {</span>
<span class="line-modified"> 596             @Override</span>
<span class="line-modified"> 597             public boolean test(ResolvedJavaType type) {</span>
<span class="line-modified"> 598                 if (type instanceof HotSpotResolvedObjectTypeImpl) {</span>
<span class="line-modified"> 599                     HotSpotResolvedObjectTypeImpl hsType = (HotSpotResolvedObjectTypeImpl) type;</span>
<span class="line-modified"> 600                     return compilerToVm.isTrustedForIntrinsics(hsType);</span>
<span class="line-modified"> 601                 } else {</span>
<span class="line-modified"> 602                     return false;</span>





























 603                 }
<span class="line-modified"> 604             }</span>
<span class="line-modified"> 605         };</span>

 606     }
 607 
 608     /**
 609      * Get the {@link Class} corresponding to {@code type}.
 610      *
 611      * @param type the type for which a {@link Class} is requested
 612      * @return the original Java class corresponding to {@code type} or {@code null} if this runtime
 613      *         does not support mapping {@link ResolvedJavaType} instances to {@link Class}
 614      *         instances
 615      */

 616     public Class&lt;?&gt; getMirror(ResolvedJavaType type) {
<span class="line-modified"> 617         if (type instanceof HotSpotResolvedJavaType &amp;&amp; reflection instanceof HotSpotJDKReflection) {</span>
<span class="line-added"> 618             return ((HotSpotJDKReflection) reflection).getMirror((HotSpotResolvedJavaType) type);</span>
<span class="line-added"> 619         }</span>
<span class="line-added"> 620         return null;</span>
 621     }
 622 
 623     @Override
 624     public JVMCICompiler getCompiler() {
 625         if (compiler == null) {
 626             synchronized (this) {
 627                 if (compiler == null) {
<span class="line-added"> 628                     assert !creatingCompiler : &quot;recursive compiler creation&quot;;</span>
<span class="line-added"> 629                     creatingCompiler = true;</span>
 630                     compiler = compilerFactory.createCompiler(this);
<span class="line-added"> 631                     creatingCompiler = false;</span>
 632                 }
 633             }
 634         }
 635         return compiler;
 636     }
 637 
 638     /**
 639      * Converts a name to a Java type. This method attempts to resolve {@code name} to a
 640      * {@link ResolvedJavaType}.
 641      *
 642      * @param name a well formed Java type in {@linkplain JavaType#getName() internal} format
 643      * @param accessingType the context of resolution which must be non-null
 644      * @param resolve specifies whether resolution failure results in an unresolved type being
 645      *            return or a {@link LinkageError} being thrown
 646      * @return a Java type for {@code name} which is guaranteed to be of type
 647      *         {@link ResolvedJavaType} if {@code resolve == true}
 648      * @throws LinkageError if {@code resolve == true} and the resolution failed
 649      * @throws NullPointerException if {@code accessingClass} is {@code null}
 650      */
 651     public JavaType lookupType(String name, HotSpotResolvedObjectType accessingType, boolean resolve) {
 652         Objects.requireNonNull(accessingType, &quot;cannot resolve type without an accessing class&quot;);
<span class="line-added"> 653         return lookupTypeInternal(name, accessingType, resolve);</span>
<span class="line-added"> 654     }</span>
<span class="line-added"> 655 </span>
<span class="line-added"> 656     JavaType lookupTypeInternal(String name, HotSpotResolvedObjectType accessingType, boolean resolve) {</span>
 657         // If the name represents a primitive type we can short-circuit the lookup.
 658         if (name.length() == 1) {
 659             JavaKind kind = JavaKind.fromPrimitiveOrVoidTypeChar(name.charAt(0));
<span class="line-modified"> 660             return HotSpotResolvedPrimitiveType.forKind(kind);</span>
 661         }
 662 
 663         // Resolve non-primitive types in the VM.
 664         HotSpotResolvedObjectTypeImpl hsAccessingType = (HotSpotResolvedObjectTypeImpl) accessingType;
 665         try {
<span class="line-modified"> 666             final HotSpotResolvedJavaType klass = compilerToVm.lookupType(name, hsAccessingType, resolve);</span>
 667 
 668             if (klass == null) {
<span class="line-modified"> 669                 assert resolve == false : name;</span>
 670                 return UnresolvedJavaType.create(name);
 671             }
 672             return klass;
 673         } catch (ClassNotFoundException e) {
 674             throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);
 675         }
 676     }
 677 
 678     @Override
 679     public JVMCIBackend getHostJVMCIBackend() {
 680         return hostBackend;
 681     }
 682 
 683     @Override
 684     public &lt;T extends Architecture&gt; JVMCIBackend getJVMCIBackend(Class&lt;T&gt; arch) {
 685         assert arch != Architecture.class;
 686         return backends.get(arch);
 687     }
 688 
 689     public Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; getJVMCIBackends() {
 690         return Collections.unmodifiableMap(backends);
 691     }
 692 
<span class="line-modified"> 693     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-modified"> 694     @VMEntryPoint</span>
<span class="line-modified"> 695     private HotSpotCompilationRequestResult compileMethod(HotSpotResolvedJavaMethod method, int entryBCI, long compileState, int id) {</span>
<span class="line-modified"> 696         HotSpotCompilationRequest request = new HotSpotCompilationRequest(method, entryBCI, compileState, id);</span>
<span class="line-modified"> 697         CompilationRequestResult result = getCompiler().compileMethod(request);</span>





































 698         assert result != null : &quot;compileMethod must always return something&quot;;
 699         HotSpotCompilationRequestResult hsResult;
 700         if (result instanceof HotSpotCompilationRequestResult) {
 701             hsResult = (HotSpotCompilationRequestResult) result;
 702         } else {
 703             Object failure = result.getFailure();
 704             if (failure != null) {
 705                 boolean retry = false; // Be conservative with unknown compiler
 706                 hsResult = HotSpotCompilationRequestResult.failure(failure.toString(), retry);
 707             } else {
 708                 int inlinedBytecodes = -1;
 709                 hsResult = HotSpotCompilationRequestResult.success(inlinedBytecodes);
 710             }
 711         }

 712         return hsResult;
 713     }
 714 
 715     /**
 716      * Shuts down the runtime.


 717      */
<span class="line-modified"> 718     @VMEntryPoint</span>
 719     private void shutdown() throws Exception {
<span class="line-added"> 720         // Cleaners are normally only processed when a new Cleaner is</span>
<span class="line-added"> 721         // instantiated so process all remaining cleaners now.</span>
<span class="line-added"> 722         Cleaner.clean();</span>
<span class="line-added"> 723 </span>
 724         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 725             vmEventListener.notifyShutdown();
 726         }
 727     }
 728 
 729     /**
 730      * Notify on completion of a bootstrap.


 731      */
<span class="line-modified"> 732     @VMEntryPoint</span>
 733     private void bootstrapFinished() throws Exception {
 734         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 735             vmEventListener.notifyBootstrapFinished();
 736         }
 737     }
 738 
 739     /**
 740      * Notify on successful install into the CodeCache.
 741      *
 742      * @param hotSpotCodeCacheProvider
 743      * @param installedCode
 744      * @param compiledCode
 745      */
 746     void notifyInstall(HotSpotCodeCacheProvider hotSpotCodeCacheProvider, InstalledCode installedCode, CompiledCode compiledCode) {
 747         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 748             vmEventListener.notifyInstall(hotSpotCodeCacheProvider, installedCode, compiledCode);
 749         }
 750     }
 751 
<span class="line-added"> 752     /**</span>
<span class="line-added"> 753      * Writes {@code length} bytes from {@code bytes} starting at offset {@code offset} to HotSpot&#39;s</span>
<span class="line-added"> 754      * log stream.</span>
<span class="line-added"> 755      *</span>
<span class="line-added"> 756      * @param flush specifies if the log stream should be flushed after writing</span>
<span class="line-added"> 757      * @param canThrow specifies if an error in the {@code bytes}, {@code offset} or {@code length}</span>
<span class="line-added"> 758      *            arguments should result in an exception or a negative return value. If</span>
<span class="line-added"> 759      *            {@code false}, this call will not perform any heap allocation</span>
<span class="line-added"> 760      * @return 0 on success, -1 if {@code bytes == null &amp;&amp; !canThrow}, -2 if {@code !canThrow} and</span>
<span class="line-added"> 761      *         copying would cause access of data outside array bounds</span>
<span class="line-added"> 762      * @throws NullPointerException if {@code bytes == null}</span>
<span class="line-added"> 763      * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds</span>
<span class="line-added"> 764      */</span>
<span class="line-added"> 765     public int writeDebugOutput(byte[] bytes, int offset, int length, boolean flush, boolean canThrow) {</span>
<span class="line-added"> 766         return compilerToVm.writeDebugOutput(bytes, offset, length, flush, canThrow);</span>
<span class="line-added"> 767     }</span>
<span class="line-added"> 768 </span>
 769     /**
 770      * Gets an output stream that writes to HotSpot&#39;s {@code tty} stream.
 771      */
 772     public OutputStream getLogStream() {
 773         return new OutputStream() {
 774 
 775             @Override
 776             public void write(byte[] b, int off, int len) throws IOException {
 777                 if (b == null) {
 778                     throw new NullPointerException();
 779                 } else if (off &lt; 0 || off &gt; b.length || len &lt; 0 || (off + len) &gt; b.length || (off + len) &lt; 0) {
 780                     throw new IndexOutOfBoundsException();
 781                 } else if (len == 0) {
 782                     return;
 783                 }
<span class="line-modified"> 784                 compilerToVm.writeDebugOutput(b, off, len, false, true);</span>
 785             }
 786 
 787             @Override
 788             public void write(int b) throws IOException {
 789                 write(new byte[]{(byte) b}, 0, 1);
 790             }
 791 
 792             @Override
 793             public void flush() throws IOException {
 794                 compilerToVm.flushDebugOutput();
 795             }
 796         };
 797     }
 798 
 799     /**
 800      * Collects the current values of all JVMCI benchmark counters, summed up over all threads.
 801      */
 802     public long[] collectCounters() {
 803         return compilerToVm.collectCounters();
 804     }
 805 
<span class="line-added"> 806     /**</span>
<span class="line-added"> 807      * @return the current number of per thread counters. May be set through</span>
<span class="line-added"> 808      *         {@code -XX:JVMCICompilerSize=} command line option or the</span>
<span class="line-added"> 809      *         {@link #setCountersSize(int)} call.</span>
<span class="line-added"> 810      */</span>
<span class="line-added"> 811     public int getCountersSize() {</span>
<span class="line-added"> 812         return compilerToVm.getCountersSize();</span>
<span class="line-added"> 813     }</span>
<span class="line-added"> 814 </span>
<span class="line-added"> 815     /**</span>
<span class="line-added"> 816      * Enlarge the number of per thread counters available. Requires a safepoint so</span>
<span class="line-added"> 817      * resizing should be rare to avoid performance effects.</span>
<span class="line-added"> 818      *</span>
<span class="line-added"> 819      * @param newSize</span>
<span class="line-added"> 820      */</span>
<span class="line-added"> 821     public void setCountersSize(int newSize) {</span>
<span class="line-added"> 822         compilerToVm.setCountersSize(newSize);</span>
<span class="line-added"> 823     }</span>
<span class="line-added"> 824 </span>
 825     /**
 826      * The offset from the origin of an array to the first element.
 827      *
 828      * @return the offset in bytes
 829      */

 830     public int getArrayBaseOffset(JavaKind kind) {
 831         switch (kind) {
 832             case Boolean:
<span class="line-modified"> 833                 return compilerToVm.ARRAY_BOOLEAN_BASE_OFFSET;</span>
 834             case Byte:
<span class="line-modified"> 835                 return compilerToVm.ARRAY_BYTE_BASE_OFFSET;</span>
 836             case Char:
<span class="line-modified"> 837                 return compilerToVm.ARRAY_CHAR_BASE_OFFSET;</span>
 838             case Short:
<span class="line-modified"> 839                 return compilerToVm.ARRAY_SHORT_BASE_OFFSET;</span>
 840             case Int:
<span class="line-modified"> 841                 return compilerToVm.ARRAY_INT_BASE_OFFSET;</span>
 842             case Long:
<span class="line-modified"> 843                 return compilerToVm.ARRAY_LONG_BASE_OFFSET;</span>
 844             case Float:
<span class="line-modified"> 845                 return compilerToVm.ARRAY_FLOAT_BASE_OFFSET;</span>
 846             case Double:
<span class="line-modified"> 847                 return compilerToVm.ARRAY_DOUBLE_BASE_OFFSET;</span>
 848             case Object:
<span class="line-modified"> 849                 return compilerToVm.ARRAY_OBJECT_BASE_OFFSET;</span>
 850             default:
 851                 throw new JVMCIError(&quot;%s&quot;, kind);
 852         }
 853 
 854     }
 855 
 856     /**
 857      * The scale used for the index when accessing elements of an array of this kind.
 858      *
 859      * @return the scale in order to convert the index into a byte offset
 860      */

 861     public int getArrayIndexScale(JavaKind kind) {
 862         switch (kind) {
 863             case Boolean:
<span class="line-modified"> 864                 return compilerToVm.ARRAY_BOOLEAN_INDEX_SCALE;</span>
 865             case Byte:
<span class="line-modified"> 866                 return compilerToVm.ARRAY_BYTE_INDEX_SCALE;</span>
 867             case Char:
<span class="line-modified"> 868                 return compilerToVm.ARRAY_CHAR_INDEX_SCALE;</span>
 869             case Short:
<span class="line-modified"> 870                 return compilerToVm.ARRAY_SHORT_INDEX_SCALE;</span>
 871             case Int:
<span class="line-modified"> 872                 return compilerToVm.ARRAY_INT_INDEX_SCALE;</span>
 873             case Long:
<span class="line-modified"> 874                 return compilerToVm.ARRAY_LONG_INDEX_SCALE;</span>
 875             case Float:
<span class="line-modified"> 876                 return compilerToVm.ARRAY_FLOAT_INDEX_SCALE;</span>
 877             case Double:
<span class="line-modified"> 878                 return compilerToVm.ARRAY_DOUBLE_INDEX_SCALE;</span>
 879             case Object:
<span class="line-modified"> 880                 return compilerToVm.ARRAY_OBJECT_INDEX_SCALE;</span>
 881             default:
 882                 throw new JVMCIError(&quot;%s&quot;, kind);
 883 
 884         }
 885     }
 886 
 887     /**
<span class="line-modified"> 888      * Links each native method in {@code clazz} to an implementation in the JVMCI shared library.</span>
 889      * &lt;p&gt;
 890      * A use case for this is a JVMCI compiler implementation that offers an API to Java code
<span class="line-modified"> 891      * executing in HotSpot to exercise functionality (mostly) in the JVMCI shared library. For</span>
 892      * example:
 893      *
 894      * &lt;pre&gt;
 895      * package com.jcompile;
 896      *
 897      * import java.lang.reflect.Method;
 898      *
 899      * public static class JCompile {
 900      *     static {
 901      *         HotSpotJVMCIRuntime.runtime().registerNativeMethods(JCompile.class);
 902      *     }
 903      *     public static boolean compile(Method method, String[] options) {
 904      *         // Convert to simpler data types for passing/serializing across native interface
 905      *         long metaspaceMethodHandle = getHandle(method);
 906      *         char[] opts = convertToCharArray(options);
 907      *         return compile(metaspaceMethodHandle, opts);
 908      *     }
 909      *     private static native boolean compile0(long metaspaceMethodHandle, char[] options);
 910      *
 911      *     private static long getHandle(Method method) { ... }
 912      *     private static char[] convertToCharArray(String[] a) { ... }
 913      * }
 914      * &lt;/pre&gt;
 915      *
<span class="line-modified"> 916      * The implementation of the native {@code JCompile.compile0} method would be in the JVMCI</span>
<span class="line-modified"> 917      * shared library that contains the bulk of the JVMCI compiler. The {@code JCompile.compile0}</span>
<span class="line-modified"> 918      * implementation will be exported as the following JNI-compatible symbol:</span>
 919      *
 920      * &lt;pre&gt;
 921      * Java_com_jcompile_JCompile_compile0
 922      * &lt;/pre&gt;
 923      *
<span class="line-modified"> 924      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#resolving_native_method_names&quot;</span>
<span class="line-added"> 925      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#creating_the_vm&quot;</span>
<span class="line-added"> 926      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#invocation_api_functions&quot;</span>
 927      *

 928      *
<span class="line-added"> 929      * @return an array of 4 longs where the first value is the {@code JavaVM*} value representing</span>
<span class="line-added"> 930      *         the Java VM in the JVMCI shared library, and the remaining values are the first 3</span>
<span class="line-added"> 931      *         pointers in the Invocation API function table (i.e., {@code JNIInvokeInterface})</span>
 932      * @throws NullPointerException if {@code clazz == null}
<span class="line-modified"> 933      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.</span>
<span class="line-modified"> 934      *             {@code -XX:-UseJVMCINativeLibrary})</span>
<span class="line-modified"> 935      * @throws IllegalStateException if the current execution context is the JVMCI shared library</span>
<span class="line-modified"> 936      * @throws IllegalArgumentException if {@code clazz} is {@link Class#isPrimitive()}</span>
<span class="line-modified"> 937      * @throws UnsatisfiedLinkError if there&#39;s a problem linking a native method in {@code clazz}</span>
<span class="line-added"> 938      *             (no matching JNI symbol or the native method is already linked to a different</span>
<span class="line-added"> 939      *             address)</span>
<span class="line-added"> 940      */</span>
<span class="line-added"> 941     public long[] registerNativeMethods(Class&lt;?&gt; clazz) {</span>
<span class="line-added"> 942         return compilerToVm.registerNativeMethods(clazz);</span>
<span class="line-added"> 943     }</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945     /**</span>
<span class="line-added"> 946      * Creates or retrieves an object in the peer runtime that mirrors {@code obj}. The types whose</span>
<span class="line-added"> 947      * objects can be translated are:</span>
<span class="line-added"> 948      * &lt;ul&gt;</span>
<span class="line-added"> 949      * &lt;li&gt;{@link HotSpotResolvedJavaMethodImpl},&lt;/li&gt;</span>
<span class="line-added"> 950      * &lt;li&gt;{@link HotSpotResolvedObjectTypeImpl},&lt;/li&gt;</span>
<span class="line-added"> 951      * &lt;li&gt;{@link HotSpotResolvedPrimitiveType},&lt;/li&gt;</span>
<span class="line-added"> 952      * &lt;li&gt;{@link IndirectHotSpotObjectConstantImpl},&lt;/li&gt;</span>
<span class="line-added"> 953      * &lt;li&gt;{@link DirectHotSpotObjectConstantImpl} and&lt;/li&gt;</span>
<span class="line-added"> 954      * &lt;li&gt;{@link HotSpotNmethod}&lt;/li&gt;</span>
<span class="line-added"> 955      * &lt;/ul&gt;</span>
<span class="line-added"> 956      *</span>
<span class="line-added"> 957      * This mechanism can be used to pass and return values between the HotSpot and JVMCI shared</span>
<span class="line-added"> 958      * library runtimes. In the receiving runtime, the value can be converted back to an object with</span>
<span class="line-added"> 959      * {@link #unhand(Class, long)}.</span>
<span class="line-added"> 960      *</span>
<span class="line-added"> 961      * @param obj an object for which an equivalent instance in the peer runtime is requested</span>
<span class="line-added"> 962      * @return a JNI global reference to the mirror of {@code obj} in the peer runtime</span>
<span class="line-added"> 963      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.</span>
<span class="line-added"> 964      *             {@code -XX:-UseJVMCINativeLibrary})</span>
<span class="line-added"> 965      * @throws IllegalArgumentException if {@code obj} is not of a translatable type</span>
<span class="line-added"> 966      *</span>
<span class="line-added"> 967      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#global_and_local_references&quot;</span>
 968      */
<span class="line-modified"> 969     public long translate(Object obj) {</span>
<span class="line-modified"> 970         return compilerToVm.translate(obj);</span>
<span class="line-modified"> 971     }</span>
<span class="line-added"> 972 </span>
<span class="line-added"> 973     /**</span>
<span class="line-added"> 974      * Dereferences and returns the object referred to by the JNI global reference {@code handle}.</span>
<span class="line-added"> 975      * The global reference is deleted prior to returning. Any further use of {@code handle} is</span>
<span class="line-added"> 976      * invalid.</span>
<span class="line-added"> 977      *</span>
<span class="line-added"> 978      * @param handle a JNI global reference to an object in the current runtime</span>
<span class="line-added"> 979      * @return the object referred to by {@code handle}</span>
<span class="line-added"> 980      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.</span>
<span class="line-added"> 981      *             {@code -XX:-UseJVMCINativeLibrary})</span>
<span class="line-added"> 982      * @throws ClassCastException if the returned object cannot be cast to {@code type}</span>
<span class="line-added"> 983      *</span>
<span class="line-added"> 984      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#global_and_local_references&quot;</span>
<span class="line-added"> 985      *</span>
<span class="line-added"> 986      */</span>
<span class="line-added"> 987     public &lt;T&gt; T unhand(Class&lt;T&gt; type, long handle) {</span>
<span class="line-added"> 988         return type.cast(compilerToVm.unhand(handle));</span>
<span class="line-added"> 989     }</span>
<span class="line-added"> 990 </span>
<span class="line-added"> 991     /**</span>
<span class="line-added"> 992      * Determines if the current thread is attached to the peer runtime.</span>
<span class="line-added"> 993      *</span>
<span class="line-added"> 994      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.</span>
<span class="line-added"> 995      *             {@code -XX:-UseJVMCINativeLibrary})</span>
<span class="line-added"> 996      * @throws IllegalStateException if the peer runtime has not been initialized</span>
<span class="line-added"> 997      */</span>
<span class="line-added"> 998     public boolean isCurrentThreadAttached() {</span>
<span class="line-added"> 999         return compilerToVm.isCurrentThreadAttached();</span>
<span class="line-added">1000     }</span>
<span class="line-added">1001 </span>
<span class="line-added">1002     /**</span>
<span class="line-added">1003      * Gets the address of the HotSpot {@code JavaThread} C++ object for the current thread. This</span>
<span class="line-added">1004      * will return {@code 0} if called from an unattached JVMCI shared library thread.</span>
<span class="line-added">1005      */</span>
<span class="line-added">1006     public long getCurrentJavaThread() {</span>
<span class="line-added">1007         return compilerToVm.getCurrentJavaThread();</span>
<span class="line-added">1008     }</span>
<span class="line-added">1009 </span>
<span class="line-added">1010     /**</span>
<span class="line-added">1011      * Ensures the current thread is attached to the peer runtime.</span>
<span class="line-added">1012      *</span>
<span class="line-added">1013      * @param asDaemon if the thread is not yet attached, should it be attached as a daemon</span>
<span class="line-added">1014      * @return {@code true} if this call attached the current thread, {@code false} if the current</span>
<span class="line-added">1015      *         thread was already attached</span>
<span class="line-added">1016      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.</span>
<span class="line-added">1017      *             {@code -XX:-UseJVMCINativeLibrary})</span>
<span class="line-added">1018      * @throws IllegalStateException if the peer runtime has not been initialized or there is an</span>
<span class="line-added">1019      *             error while trying to attach the thread</span>
<span class="line-added">1020      */</span>
<span class="line-added">1021     public boolean attachCurrentThread(boolean asDaemon) {</span>
<span class="line-added">1022         return compilerToVm.attachCurrentThread(asDaemon);</span>
<span class="line-added">1023     }</span>
<span class="line-added">1024 </span>
<span class="line-added">1025     /**</span>
<span class="line-added">1026      * Detaches the current thread from the peer runtime.</span>
<span class="line-added">1027      *</span>
<span class="line-added">1028      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.</span>
<span class="line-added">1029      *             {@code -XX:-UseJVMCINativeLibrary})</span>
<span class="line-added">1030      * @throws IllegalStateException if the peer runtime has not been initialized or if the current</span>
<span class="line-added">1031      *             thread is not attached or if there is an error while trying to detach the thread</span>
<span class="line-added">1032      */</span>
<span class="line-added">1033     public void detachCurrentThread() {</span>
<span class="line-added">1034         compilerToVm.detachCurrentThread();</span>
<span class="line-added">1035     }</span>
<span class="line-added">1036 </span>
<span class="line-added">1037     /**</span>
<span class="line-added">1038      * Informs HotSpot that no method whose module is in {@code modules} is to be compiled</span>
<span class="line-added">1039      * with {@link #compileMethod}.</span>
<span class="line-added">1040      *</span>
<span class="line-added">1041      * @param modules the set of modules containing JVMCI compiler classes</span>
<span class="line-added">1042      */</span>
<span class="line-added">1043     public void excludeFromJVMCICompilation(Module...modules) {</span>
<span class="line-added">1044         this.excludeFromJVMCICompilation = modules.clone();</span>
<span class="line-added">1045     }</span>
<span class="line-added">1046 </span>
<span class="line-added">1047     /**</span>
<span class="line-added">1048      * Calls {@link System#exit(int)} in HotSpot&#39;s runtime.</span>
<span class="line-added">1049      */</span>
<span class="line-added">1050     public void exitHotSpot(int status) {</span>
<span class="line-added">1051         if (!IS_IN_NATIVE_IMAGE) {</span>
<span class="line-added">1052             System.exit(status);</span>
<span class="line-added">1053         }</span>
<span class="line-added">1054         compilerToVm.callSystemExit(status);</span>
1055     }
1056 }
</pre>
</td>
</tr>
</table>
<center><a href="HotSpotJVMCICompilerConfig.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotMemoryAccessProviderImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
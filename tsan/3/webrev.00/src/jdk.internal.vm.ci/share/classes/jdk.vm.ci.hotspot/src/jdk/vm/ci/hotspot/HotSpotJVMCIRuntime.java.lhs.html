<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static jdk.vm.ci.common.InitTimer.timer;
<a name="2" id="anc2"></a>


 26 
 27 import java.io.IOException;
 28 import java.io.OutputStream;
 29 import java.io.PrintStream;
<a name="3" id="anc3"></a><span class="line-modified"> 30 import java.lang.module.ModuleDescriptor.Requires;</span>





 31 import java.util.Collections;
 32 import java.util.HashMap;
<a name="4" id="anc4"></a><span class="line-removed"> 33 import java.util.HashSet;</span>
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.Objects;
 37 import java.util.ServiceLoader;
<a name="5" id="anc5"></a><span class="line-removed"> 38 import java.util.Set;</span>
 39 import java.util.function.Predicate;
 40 
<a name="6" id="anc6"></a><span class="line-removed"> 41 import jdk.internal.misc.VM;</span>
<span class="line-removed"> 42 import jdk.internal.misc.Unsafe;</span>
 43 import jdk.vm.ci.code.Architecture;
 44 import jdk.vm.ci.code.CompilationRequestResult;
 45 import jdk.vm.ci.code.CompiledCode;
 46 import jdk.vm.ci.code.InstalledCode;
 47 import jdk.vm.ci.common.InitTimer;
 48 import jdk.vm.ci.common.JVMCIError;
<a name="7" id="anc7"></a><span class="line-modified"> 49 import jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevel;</span>
 50 import jdk.vm.ci.meta.JavaKind;
 51 import jdk.vm.ci.meta.JavaType;
 52 import jdk.vm.ci.meta.ResolvedJavaType;
 53 import jdk.vm.ci.meta.UnresolvedJavaType;
 54 import jdk.vm.ci.runtime.JVMCI;
 55 import jdk.vm.ci.runtime.JVMCIBackend;
 56 import jdk.vm.ci.runtime.JVMCICompiler;
 57 import jdk.vm.ci.runtime.JVMCICompilerFactory;
 58 import jdk.vm.ci.runtime.JVMCIRuntime;
 59 import jdk.vm.ci.services.JVMCIServiceLocator;
<a name="8" id="anc8"></a>
 60 
 61 /**
 62  * HotSpot implementation of a JVMCI runtime.
<a name="9" id="anc9"></a><span class="line-removed"> 63  *</span>
<span class="line-removed"> 64  * The initialization of this class is very fragile since it&#39;s initialized both through</span>
<span class="line-removed"> 65  * {@link JVMCI#initialize()} or through calling {@link HotSpotJVMCIRuntime#runtime()} and</span>
<span class="line-removed"> 66  * {@link HotSpotJVMCIRuntime#runtime()} is also called by {@link JVMCI#initialize()}. So this class</span>
<span class="line-removed"> 67  * can&#39;t have a static initializer and any required initialization must be done as part of</span>
<span class="line-removed"> 68  * {@link #runtime()}. This allows the initialization to funnel back through</span>
<span class="line-removed"> 69  * {@link JVMCI#initialize()} without deadlocking.</span>
 70  */
 71 public final class HotSpotJVMCIRuntime implements JVMCIRuntime {
 72 
<a name="10" id="anc10"></a><span class="line-modified"> 73     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-modified"> 74     static class DelayedInit {</span>
<span class="line-modified"> 75         private static final HotSpotJVMCIRuntime instance;</span>



















 76 
<a name="11" id="anc11"></a><span class="line-modified"> 77         static {</span>
<span class="line-modified"> 78             try (InitTimer t = timer(&quot;HotSpotJVMCIRuntime.&lt;init&gt;&quot;)) {</span>
<span class="line-modified"> 79                 instance = new HotSpotJVMCIRuntime();</span>



 80 
<a name="12" id="anc12"></a><span class="line-modified"> 81                 // Can only do eager initialization of the JVMCI compiler</span>
<span class="line-modified"> 82                 // once the singleton instance is available.</span>
<span class="line-modified"> 83                 if (instance.config.getFlag(&quot;EagerJVMCI&quot;, Boolean.class)) {</span>
<span class="line-modified"> 84                     instance.getCompiler();</span>
<span class="line-modified"> 85                 }</span>
<span class="line-modified"> 86             }</span>














































 87         }
<a name="13" id="anc13"></a>
 88     }
 89 
 90     /**
 91      * Gets the singleton {@link HotSpotJVMCIRuntime} object.
 92      */
<a name="14" id="anc14"></a>

 93     public static HotSpotJVMCIRuntime runtime() {
<a name="15" id="anc15"></a><span class="line-modified"> 94         JVMCI.initialize();</span>
<span class="line-modified"> 95         return DelayedInit.instance;</span>














































 96     }
 97 
 98     /**
 99      * A list of all supported JVMCI options.
100      */
101     public enum Option {
102         // @formatter:off
103         Compiler(String.class, null, &quot;Selects the system compiler. This must match the getCompilerName() value returned &quot; +
<a name="16" id="anc16"></a><span class="line-modified">104                                      &quot;by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. &quot; +</span>
<span class="line-modified">105                                      &quot;An empty string or the value \&quot;null\&quot; selects a compiler &quot; +</span>
<span class="line-modified">106                                      &quot;that will raise an exception upon receiving a compilation request.&quot;),</span>
107         // Note: The following one is not used (see InitTimer.ENABLED). It is added here
108         // so that -XX:+JVMCIPrintProperties shows the option.
109         InitTimer(Boolean.class, false, &quot;Specifies if initialization timing is enabled.&quot;),
110         PrintConfig(Boolean.class, false, &quot;Prints VM configuration available via JVMCI.&quot;),
<a name="17" id="anc17"></a>

111         TraceMethodDataFilter(String.class, null,
<a name="18" id="anc18"></a><span class="line-modified">112                         &quot;Enables tracing of profiling info when read by JVMCI.&quot;,</span>
<span class="line-modified">113                         &quot;Empty value: trace all methods&quot;,</span>
<span class="line-modified">114                         &quot;Non-empty value: trace methods whose fully qualified name contains the value.&quot;),</span>
115         UseProfilingInformation(Boolean.class, true, &quot;&quot;);
116         // @formatter:on
117 
118         /**
119          * The prefix for system properties that are JVMCI options.
120          */
121         private static final String JVMCI_OPTION_PROPERTY_PREFIX = &quot;jvmci.&quot;;
122 
123         /**
<a name="19" id="anc19"></a><span class="line-modified">124          * Marker for uninitialized flags.</span>
125          */
<a name="20" id="anc20"></a><span class="line-modified">126         private static final String UNINITIALIZED = &quot;UNINITIALIZED&quot;;</span>
127 
128         private final Class&lt;?&gt; type;
<a name="21" id="anc21"></a><span class="line-modified">129         private Object value;</span>
130         private final Object defaultValue;
131         private boolean isDefault;
132         private final String[] helpLines;
133 
134         Option(Class&lt;?&gt; type, Object defaultValue, String... helpLines) {
135             assert Character.isUpperCase(name().charAt(0)) : &quot;Option name must start with upper-case letter: &quot; + name();
136             this.type = type;
<a name="22" id="anc22"></a><span class="line-removed">137             this.value = UNINITIALIZED;</span>
138             this.defaultValue = defaultValue;
139             this.helpLines = helpLines;
140         }
141 
142         @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)
143         private Object getValue() {
<a name="23" id="anc23"></a><span class="line-modified">144             if (value == UNINITIALIZED) {</span>
<span class="line-modified">145                 String propertyValue = VM.getSavedProperty(getPropertyName());</span>
146                 if (propertyValue == null) {
<a name="24" id="anc24"></a><span class="line-modified">147                     this.value = defaultValue;</span>
148                     this.isDefault = true;
149                 } else {
150                     if (type == Boolean.class) {
151                         this.value = Boolean.parseBoolean(propertyValue);
152                     } else if (type == String.class) {
153                         this.value = propertyValue;
154                     } else {
155                         throw new JVMCIError(&quot;Unexpected option type &quot; + type);
156                     }
157                     this.isDefault = false;
158                 }
<a name="25" id="anc25"></a><span class="line-removed">159                 // Saved properties should not be interned - let&#39;s be sure</span>
<span class="line-removed">160                 assert value != UNINITIALIZED;</span>
161             }
<a name="26" id="anc26"></a><span class="line-modified">162             return value;</span>
163         }
164 
165         /**
166          * Gets the name of system property from which this option gets its value.
167          */
168         public String getPropertyName() {
169             return JVMCI_OPTION_PROPERTY_PREFIX + name();
170         }
171 
172         /**
173          * Returns the option&#39;s value as boolean.
174          *
175          * @return option&#39;s value
176          */
177         public boolean getBoolean() {
178             return (boolean) getValue();
179         }
180 
181         /**
182          * Returns the option&#39;s value as String.
183          *
184          * @return option&#39;s value
185          */
186         public String getString() {
187             return (String) getValue();
188         }
189 
190         private static final int PROPERTY_LINE_WIDTH = 80;
191         private static final int PROPERTY_HELP_INDENT = 10;
192 
193         /**
194          * Prints a description of the properties used to configure shared JVMCI code.
195          *
196          * @param out stream to print to
197          */
198         public static void printProperties(PrintStream out) {
199             out.println(&quot;[JVMCI properties]&quot;);
200             Option[] values = values();
201             for (Option option : values) {
202                 Object value = option.getValue();
203                 if (value instanceof String) {
204                     value = &#39;&quot;&#39; + String.valueOf(value) + &#39;&quot;&#39;;
205                 }
206 
207                 String name = option.getPropertyName();
208                 String assign = option.isDefault ? &quot;=&quot; : &quot;:=&quot;;
209                 String typeName = option.type.getSimpleName();
210                 String linePrefix = String.format(&quot;%s %s %s &quot;, name, assign, value);
211                 int typeStartPos = PROPERTY_LINE_WIDTH - typeName.length();
212                 int linePad = typeStartPos - linePrefix.length();
213                 if (linePad &gt; 0) {
214                     out.printf(&quot;%s%-&quot; + linePad + &quot;s[%s]%n&quot;, linePrefix, &quot;&quot;, typeName);
215                 } else {
216                     out.printf(&quot;%s[%s]%n&quot;, linePrefix, typeName);
217                 }
218                 for (String line : option.helpLines) {
219                     out.printf(&quot;%&quot; + PROPERTY_HELP_INDENT + &quot;s%s%n&quot;, &quot;&quot;, line);
220                 }
221             }
222         }
223     }
224 
<a name="27" id="anc27"></a><span class="line-modified">225     static HotSpotJVMCIBackendFactory findFactory(String architecture) {</span>
<span class="line-modified">226         for (HotSpotJVMCIBackendFactory factory : ServiceLoader.load(HotSpotJVMCIBackendFactory.class, ClassLoader.getSystemClassLoader())) {</span>


227             if (factory.getArchitecture().equalsIgnoreCase(architecture)) {
228                 return factory;
229             }
230         }
231 
232         throw new JVMCIError(&quot;No JVMCI runtime available for the %s architecture&quot;, architecture);
233     }
234 
<a name="28" id="anc28"></a>
















235     /**
236      * Gets the kind of a word value on the {@linkplain #getHostJVMCIBackend() host} backend.
237      */
238     public static JavaKind getHostWordKind() {
239         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordJavaKind;
240     }
241 
<a name="29" id="anc29"></a><span class="line-modified">242     final CompilerToVM compilerToVm;</span>
243 
244     protected final HotSpotVMConfigStore configStore;
<a name="30" id="anc30"></a><span class="line-modified">245     private final HotSpotVMConfig config;</span>
246     private final JVMCIBackend hostBackend;
247 
248     private final JVMCICompilerFactory compilerFactory;
249     private final HotSpotJVMCICompilerFactory hsCompilerFactory;
250     private volatile JVMCICompiler compiler;
<a name="31" id="anc31"></a><span class="line-modified">251     final HotSpotJVMCIMetaAccessContext metaAccessContext;</span>







252 
253     /**
<a name="32" id="anc32"></a><span class="line-modified">254      * Stores the result of {@link HotSpotJVMCICompilerFactory#getCompilationLevelAdjustment} so</span>
<span class="line-modified">255      * that it can be read from the VM.</span>

256      */
<a name="33" id="anc33"></a><span class="line-modified">257     @SuppressWarnings(&quot;unused&quot;) private final int compilationLevelAdjustment;</span>























258 
259     private final Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; backends = new HashMap&lt;&gt;();
260 
261     private volatile List&lt;HotSpotVMEventListener&gt; vmEventListeners;
262 
263     private Iterable&lt;HotSpotVMEventListener&gt; getVmEventListeners() {
264         if (vmEventListeners == null) {
265             synchronized (this) {
266                 if (vmEventListeners == null) {
267                     vmEventListeners = JVMCIServiceLocator.getProviders(HotSpotVMEventListener.class);
268                 }
269             }
270         }
271         return vmEventListeners;
272     }
273 
274     @SuppressWarnings(&quot;try&quot;)
275     private HotSpotJVMCIRuntime() {
276         compilerToVm = new CompilerToVM();
277 
278         try (InitTimer t = timer(&quot;HotSpotVMConfig&lt;init&gt;&quot;)) {
279             configStore = new HotSpotVMConfigStore(compilerToVm);
280             config = new HotSpotVMConfig(configStore);
281         }
282 
<a name="34" id="anc34"></a>









283         String hostArchitecture = config.getHostArchitectureName();
284 
285         HotSpotJVMCIBackendFactory factory;
286         try (InitTimer t = timer(&quot;find factory:&quot;, hostArchitecture)) {
287             factory = findFactory(hostArchitecture);
288         }
289 
290         try (InitTimer t = timer(&quot;create JVMCI backend:&quot;, hostArchitecture)) {
291             hostBackend = registerBackend(factory.createJVMCIBackend(this, null));
292         }
293 
<a name="35" id="anc35"></a><span class="line-removed">294         metaAccessContext = new HotSpotJVMCIMetaAccessContext();</span>
<span class="line-removed">295 </span>
296         compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();
297         if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {
298             hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;
<a name="36" id="anc36"></a><span class="line-modified">299             switch (hsCompilerFactory.getCompilationLevelAdjustment()) {</span>
<span class="line-modified">300                 case None:</span>
<span class="line-modified">301                     compilationLevelAdjustment = config.compLevelAdjustmentNone;</span>
<span class="line-modified">302                     break;</span>
<span class="line-modified">303                 case ByHolder:</span>
<span class="line-removed">304                     compilationLevelAdjustment = config.compLevelAdjustmentByHolder;</span>
<span class="line-removed">305                     break;</span>
<span class="line-removed">306                 case ByFullSignature:</span>
<span class="line-removed">307                     compilationLevelAdjustment = config.compLevelAdjustmentByFullSignature;</span>
<span class="line-removed">308                     break;</span>
<span class="line-removed">309                 default:</span>
<span class="line-removed">310                     compilationLevelAdjustment = config.compLevelAdjustmentNone;</span>
<span class="line-removed">311                     break;</span>
312             }
313         } else {
314             hsCompilerFactory = null;
<a name="37" id="anc37"></a><span class="line-removed">315             compilationLevelAdjustment = config.compLevelAdjustmentNone;</span>
316         }
317 
318         if (config.getFlag(&quot;JVMCIPrintProperties&quot;, Boolean.class)) {
<a name="38" id="anc38"></a><span class="line-modified">319             PrintStream out = new PrintStream(getLogStream());</span>
<span class="line-modified">320             Option.printProperties(out);</span>
<span class="line-modified">321             compilerFactory.printProperties(out);</span>


322             System.exit(0);
323         }
324 
325         if (Option.PrintConfig.getBoolean()) {
326             configStore.printConfig();
327         }
328     }
329 
<a name="39" id="anc39"></a>




































































330     private JVMCIBackend registerBackend(JVMCIBackend backend) {
331         Class&lt;? extends Architecture&gt; arch = backend.getCodeCache().getTarget().arch.getClass();
332         JVMCIBackend oldValue = backends.put(arch, backend);
333         assert oldValue == null : &quot;cannot overwrite existing backend for architecture &quot; + arch.getSimpleName();
334         return backend;
335     }
336 
<a name="40" id="anc40"></a><span class="line-removed">337     ResolvedJavaType fromClass(Class&lt;?&gt; javaClass) {</span>
<span class="line-removed">338         return metaAccessContext.fromClass(javaClass);</span>
<span class="line-removed">339     }</span>
<span class="line-removed">340 </span>
341     public HotSpotVMConfigStore getConfigStore() {
342         return configStore;
343     }
344 
<a name="41" id="anc41"></a><span class="line-modified">345     HotSpotVMConfig getConfig() {</span>
346         return config;
347     }
348 
<a name="42" id="anc42"></a><span class="line-modified">349     CompilerToVM getCompilerToVM() {</span>
350         return compilerToVm;
351     }
352 
<a name="43" id="anc43"></a><span class="line-modified">353     // Non-volatile since multi-initialization is harmless</span>
<span class="line-modified">354     private Predicate&lt;ResolvedJavaType&gt; intrinsificationTrustPredicate;</span>

355 
356     /**
357      * Gets a predicate that determines if a given type can be considered trusted for the purpose of
358      * intrinsifying methods it declares.
359      *
360      * @param compilerLeafClasses classes in the leaves of the module graph comprising the JVMCI
361      *            compiler.
362      */
363     public Predicate&lt;ResolvedJavaType&gt; getIntrinsificationTrustPredicate(Class&lt;?&gt;... compilerLeafClasses) {
<a name="44" id="anc44"></a><span class="line-modified">364         if (intrinsificationTrustPredicate == null) {</span>
<span class="line-modified">365             intrinsificationTrustPredicate = new Predicate&lt;&gt;() {</span>
<span class="line-modified">366                 @Override</span>
<span class="line-modified">367                 public boolean test(ResolvedJavaType type) {</span>
<span class="line-modified">368                     if (type instanceof HotSpotResolvedJavaType) {</span>
<span class="line-modified">369                         Class&lt;?&gt; mirror = getMirror(type);</span>
<span class="line-modified">370                         Module module = mirror.getModule();</span>
<span class="line-modified">371                         return getTrustedModules().contains(module);</span>
<span class="line-removed">372                     } else {</span>
<span class="line-removed">373                         return false;</span>
<span class="line-removed">374                     }</span>
<span class="line-removed">375                 }</span>
<span class="line-removed">376 </span>
<span class="line-removed">377                 private volatile Set&lt;Module&gt; trustedModules;</span>
<span class="line-removed">378 </span>
<span class="line-removed">379                 private Set&lt;Module&gt; getTrustedModules() {</span>
<span class="line-removed">380                     Set&lt;Module&gt; modules = trustedModules;</span>
<span class="line-removed">381                     if (modules == null) {</span>
<span class="line-removed">382                         modules = new HashSet&lt;&gt;();</span>
<span class="line-removed">383                         for (Class&lt;?&gt; compilerConfiguration : compilerLeafClasses) {</span>
<span class="line-removed">384                             Module compilerConfigurationModule = compilerConfiguration.getModule();</span>
<span class="line-removed">385                             if (compilerConfigurationModule.getDescriptor().isAutomatic()) {</span>
<span class="line-removed">386                                 throw new IllegalArgumentException(String.format(&quot;The module &#39;%s&#39; defining the Graal compiler configuration class &#39;%s&#39; must not be an automatic module&quot;,</span>
<span class="line-removed">387                                                 compilerConfigurationModule.getName(), compilerConfiguration.getClass().getName()));</span>
<span class="line-removed">388                             }</span>
<span class="line-removed">389                             modules.add(compilerConfigurationModule);</span>
<span class="line-removed">390                             for (Requires require : compilerConfigurationModule.getDescriptor().requires()) {</span>
<span class="line-removed">391                                 for (Module module : compilerConfigurationModule.getLayer().modules()) {</span>
<span class="line-removed">392                                     if (module.getName().equals(require.name())) {</span>
<span class="line-removed">393                                         modules.add(module);</span>
<span class="line-removed">394                                     }</span>
<span class="line-removed">395                                 }</span>
<span class="line-removed">396                             }</span>
<span class="line-removed">397                         }</span>
<span class="line-removed">398                         trustedModules = modules;</span>
<span class="line-removed">399                     }</span>
<span class="line-removed">400                     return modules;</span>
401                 }
<a name="45" id="anc45"></a><span class="line-modified">402             };</span>
<span class="line-modified">403         }</span>
<span class="line-removed">404         return intrinsificationTrustPredicate;</span>
405     }
406 
407     /**
408      * Get the {@link Class} corresponding to {@code type}.
409      *
410      * @param type the type for which a {@link Class} is requested
411      * @return the original Java class corresponding to {@code type} or {@code null} if this runtime
412      *         does not support mapping {@link ResolvedJavaType} instances to {@link Class}
413      *         instances
414      */
<a name="46" id="anc46"></a><span class="line-removed">415     @SuppressWarnings(&quot;static-method&quot;)</span>
416     public Class&lt;?&gt; getMirror(ResolvedJavaType type) {
<a name="47" id="anc47"></a><span class="line-modified">417         return ((HotSpotResolvedJavaType) type).mirror();</span>



418     }
419 
420     @Override
421     public JVMCICompiler getCompiler() {
422         if (compiler == null) {
423             synchronized (this) {
424                 if (compiler == null) {
<a name="48" id="anc48"></a>

425                     compiler = compilerFactory.createCompiler(this);
<a name="49" id="anc49"></a>
426                 }
427             }
428         }
429         return compiler;
430     }
431 
432     /**
433      * Converts a name to a Java type. This method attempts to resolve {@code name} to a
434      * {@link ResolvedJavaType}.
435      *
436      * @param name a well formed Java type in {@linkplain JavaType#getName() internal} format
437      * @param accessingType the context of resolution which must be non-null
438      * @param resolve specifies whether resolution failure results in an unresolved type being
439      *            return or a {@link LinkageError} being thrown
440      * @return a Java type for {@code name} which is guaranteed to be of type
441      *         {@link ResolvedJavaType} if {@code resolve == true}
442      * @throws LinkageError if {@code resolve == true} and the resolution failed
443      * @throws NullPointerException if {@code accessingClass} is {@code null}
444      */
445     public JavaType lookupType(String name, HotSpotResolvedObjectType accessingType, boolean resolve) {
446         Objects.requireNonNull(accessingType, &quot;cannot resolve type without an accessing class&quot;);
<a name="50" id="anc50"></a>



447         // If the name represents a primitive type we can short-circuit the lookup.
448         if (name.length() == 1) {
449             JavaKind kind = JavaKind.fromPrimitiveOrVoidTypeChar(name.charAt(0));
<a name="51" id="anc51"></a><span class="line-modified">450             return fromClass(kind.toJavaClass());</span>
451         }
452 
453         // Resolve non-primitive types in the VM.
454         HotSpotResolvedObjectTypeImpl hsAccessingType = (HotSpotResolvedObjectTypeImpl) accessingType;
455         try {
<a name="52" id="anc52"></a><span class="line-modified">456             final HotSpotResolvedObjectTypeImpl klass = compilerToVm.lookupType(name, hsAccessingType.mirror(), resolve);</span>
457 
458             if (klass == null) {
<a name="53" id="anc53"></a><span class="line-modified">459                 assert resolve == false;</span>
460                 return UnresolvedJavaType.create(name);
461             }
462             return klass;
463         } catch (ClassNotFoundException e) {
464             throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);
465         }
466     }
467 
468     @Override
469     public JVMCIBackend getHostJVMCIBackend() {
470         return hostBackend;
471     }
472 
473     @Override
474     public &lt;T extends Architecture&gt; JVMCIBackend getJVMCIBackend(Class&lt;T&gt; arch) {
475         assert arch != Architecture.class;
476         return backends.get(arch);
477     }
478 
479     public Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; getJVMCIBackends() {
480         return Collections.unmodifiableMap(backends);
481     }
482 
<a name="54" id="anc54"></a><span class="line-modified">483     /**</span>
<span class="line-modified">484      * Called from the VM.</span>
<span class="line-modified">485      */</span>
<span class="line-modified">486     @SuppressWarnings({&quot;unused&quot;})</span>
<span class="line-modified">487     private int adjustCompilationLevel(Class&lt;?&gt; declaringClass, String name, String signature, boolean isOsr, int level) {</span>
<span class="line-removed">488         CompilationLevel curLevel;</span>
<span class="line-removed">489         if (level == config.compilationLevelNone) {</span>
<span class="line-removed">490             curLevel = CompilationLevel.None;</span>
<span class="line-removed">491         } else if (level == config.compilationLevelSimple) {</span>
<span class="line-removed">492             curLevel = CompilationLevel.Simple;</span>
<span class="line-removed">493         } else if (level == config.compilationLevelLimitedProfile) {</span>
<span class="line-removed">494             curLevel = CompilationLevel.LimitedProfile;</span>
<span class="line-removed">495         } else if (level == config.compilationLevelFullProfile) {</span>
<span class="line-removed">496             curLevel = CompilationLevel.FullProfile;</span>
<span class="line-removed">497         } else if (level == config.compilationLevelFullOptimization) {</span>
<span class="line-removed">498             curLevel = CompilationLevel.FullOptimization;</span>
<span class="line-removed">499         } else {</span>
<span class="line-removed">500             throw JVMCIError.shouldNotReachHere();</span>
<span class="line-removed">501         }</span>
<span class="line-removed">502 </span>
<span class="line-removed">503         switch (hsCompilerFactory.adjustCompilationLevel(declaringClass, name, signature, isOsr, curLevel)) {</span>
<span class="line-removed">504             case None:</span>
<span class="line-removed">505                 return config.compilationLevelNone;</span>
<span class="line-removed">506             case Simple:</span>
<span class="line-removed">507                 return config.compilationLevelSimple;</span>
<span class="line-removed">508             case LimitedProfile:</span>
<span class="line-removed">509                 return config.compilationLevelLimitedProfile;</span>
<span class="line-removed">510             case FullProfile:</span>
<span class="line-removed">511                 return config.compilationLevelFullProfile;</span>
<span class="line-removed">512             case FullOptimization:</span>
<span class="line-removed">513                 return config.compilationLevelFullOptimization;</span>
<span class="line-removed">514             default:</span>
<span class="line-removed">515                 return level;</span>
<span class="line-removed">516         }</span>
<span class="line-removed">517     }</span>
<span class="line-removed">518 </span>
<span class="line-removed">519     /**</span>
<span class="line-removed">520      * Called from the VM.</span>
<span class="line-removed">521      */</span>
<span class="line-removed">522     @SuppressWarnings({&quot;unused&quot;})</span>
<span class="line-removed">523     private HotSpotCompilationRequestResult compileMethod(HotSpotResolvedJavaMethod method, int entryBCI, long jvmciEnv, int id) {</span>
<span class="line-removed">524         CompilationRequestResult result = getCompiler().compileMethod(new HotSpotCompilationRequest(method, entryBCI, jvmciEnv, id));</span>
525         assert result != null : &quot;compileMethod must always return something&quot;;
526         HotSpotCompilationRequestResult hsResult;
527         if (result instanceof HotSpotCompilationRequestResult) {
528             hsResult = (HotSpotCompilationRequestResult) result;
529         } else {
530             Object failure = result.getFailure();
531             if (failure != null) {
532                 boolean retry = false; // Be conservative with unknown compiler
533                 hsResult = HotSpotCompilationRequestResult.failure(failure.toString(), retry);
534             } else {
535                 int inlinedBytecodes = -1;
536                 hsResult = HotSpotCompilationRequestResult.success(inlinedBytecodes);
537             }
538         }
<a name="55" id="anc55"></a><span class="line-removed">539 </span>
540         return hsResult;
541     }
542 
543     /**
544      * Shuts down the runtime.
<a name="56" id="anc56"></a><span class="line-removed">545      *</span>
<span class="line-removed">546      * Called from the VM.</span>
547      */
<a name="57" id="anc57"></a><span class="line-modified">548     @SuppressWarnings({&quot;unused&quot;})</span>
549     private void shutdown() throws Exception {
<a name="58" id="anc58"></a>



550         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
551             vmEventListener.notifyShutdown();
552         }
553     }
554 
555     /**
556      * Notify on completion of a bootstrap.
<a name="59" id="anc59"></a><span class="line-removed">557      *</span>
<span class="line-removed">558      * Called from the VM.</span>
559      */
<a name="60" id="anc60"></a><span class="line-modified">560     @SuppressWarnings({&quot;unused&quot;})</span>
561     private void bootstrapFinished() throws Exception {
562         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
563             vmEventListener.notifyBootstrapFinished();
564         }
565     }
566 
567     /**
568      * Notify on successful install into the CodeCache.
569      *
570      * @param hotSpotCodeCacheProvider
571      * @param installedCode
572      * @param compiledCode
573      */
574     void notifyInstall(HotSpotCodeCacheProvider hotSpotCodeCacheProvider, InstalledCode installedCode, CompiledCode compiledCode) {
575         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
576             vmEventListener.notifyInstall(hotSpotCodeCacheProvider, installedCode, compiledCode);
577         }
578     }
579 
<a name="61" id="anc61"></a>
















580     /**
581      * Gets an output stream that writes to HotSpot&#39;s {@code tty} stream.
582      */
583     public OutputStream getLogStream() {
584         return new OutputStream() {
585 
586             @Override
587             public void write(byte[] b, int off, int len) throws IOException {
588                 if (b == null) {
589                     throw new NullPointerException();
590                 } else if (off &lt; 0 || off &gt; b.length || len &lt; 0 || (off + len) &gt; b.length || (off + len) &lt; 0) {
591                     throw new IndexOutOfBoundsException();
592                 } else if (len == 0) {
593                     return;
594                 }
<a name="62" id="anc62"></a><span class="line-modified">595                 compilerToVm.writeDebugOutput(b, off, len);</span>
596             }
597 
598             @Override
599             public void write(int b) throws IOException {
600                 write(new byte[]{(byte) b}, 0, 1);
601             }
602 
603             @Override
604             public void flush() throws IOException {
605                 compilerToVm.flushDebugOutput();
606             }
607         };
608     }
609 
610     /**
611      * Collects the current values of all JVMCI benchmark counters, summed up over all threads.
612      */
613     public long[] collectCounters() {
614         return compilerToVm.collectCounters();
615     }
616 
<a name="63" id="anc63"></a>


















617     /**
618      * The offset from the origin of an array to the first element.
619      *
620      * @return the offset in bytes
621      */
<a name="64" id="anc64"></a><span class="line-removed">622     @SuppressWarnings(&quot;static-method&quot;)</span>
623     public int getArrayBaseOffset(JavaKind kind) {
624         switch (kind) {
625             case Boolean:
<a name="65" id="anc65"></a><span class="line-modified">626                 return Unsafe.ARRAY_BOOLEAN_BASE_OFFSET;</span>
627             case Byte:
<a name="66" id="anc66"></a><span class="line-modified">628                 return Unsafe.ARRAY_BYTE_BASE_OFFSET;</span>
629             case Char:
<a name="67" id="anc67"></a><span class="line-modified">630                 return Unsafe.ARRAY_CHAR_BASE_OFFSET;</span>
631             case Short:
<a name="68" id="anc68"></a><span class="line-modified">632                 return Unsafe.ARRAY_SHORT_BASE_OFFSET;</span>
633             case Int:
<a name="69" id="anc69"></a><span class="line-modified">634                 return Unsafe.ARRAY_INT_BASE_OFFSET;</span>
635             case Long:
<a name="70" id="anc70"></a><span class="line-modified">636                 return Unsafe.ARRAY_LONG_BASE_OFFSET;</span>
637             case Float:
<a name="71" id="anc71"></a><span class="line-modified">638                 return Unsafe.ARRAY_FLOAT_BASE_OFFSET;</span>
639             case Double:
<a name="72" id="anc72"></a><span class="line-modified">640                 return Unsafe.ARRAY_DOUBLE_BASE_OFFSET;</span>
641             case Object:
<a name="73" id="anc73"></a><span class="line-modified">642                 return Unsafe.ARRAY_OBJECT_BASE_OFFSET;</span>
643             default:
644                 throw new JVMCIError(&quot;%s&quot;, kind);
645         }
646 
647     }
648 
649     /**
650      * The scale used for the index when accessing elements of an array of this kind.
651      *
652      * @return the scale in order to convert the index into a byte offset
653      */
<a name="74" id="anc74"></a><span class="line-removed">654     @SuppressWarnings(&quot;static-method&quot;)</span>
655     public int getArrayIndexScale(JavaKind kind) {
656         switch (kind) {
657             case Boolean:
<a name="75" id="anc75"></a><span class="line-modified">658                 return Unsafe.ARRAY_BOOLEAN_INDEX_SCALE;</span>
659             case Byte:
<a name="76" id="anc76"></a><span class="line-modified">660                 return Unsafe.ARRAY_BYTE_INDEX_SCALE;</span>
661             case Char:
<a name="77" id="anc77"></a><span class="line-modified">662                 return Unsafe.ARRAY_CHAR_INDEX_SCALE;</span>
663             case Short:
<a name="78" id="anc78"></a><span class="line-modified">664                 return Unsafe.ARRAY_SHORT_INDEX_SCALE;</span>
665             case Int:
<a name="79" id="anc79"></a><span class="line-modified">666                 return Unsafe.ARRAY_INT_INDEX_SCALE;</span>
667             case Long:
<a name="80" id="anc80"></a><span class="line-modified">668                 return Unsafe.ARRAY_LONG_INDEX_SCALE;</span>
669             case Float:
<a name="81" id="anc81"></a><span class="line-modified">670                 return Unsafe.ARRAY_FLOAT_INDEX_SCALE;</span>
671             case Double:
<a name="82" id="anc82"></a><span class="line-modified">672                 return Unsafe.ARRAY_DOUBLE_INDEX_SCALE;</span>
673             case Object:
<a name="83" id="anc83"></a><span class="line-modified">674                 return Unsafe.ARRAY_OBJECT_INDEX_SCALE;</span>
675             default:
676                 throw new JVMCIError(&quot;%s&quot;, kind);
677 
678         }
679     }
680 
681     /**
<a name="84" id="anc84"></a><span class="line-modified">682      * Links each native method in {@code clazz} to an implementation in the JVMCI SVM library.</span>
683      * &lt;p&gt;
684      * A use case for this is a JVMCI compiler implementation that offers an API to Java code
<a name="85" id="anc85"></a><span class="line-modified">685      * executing in HotSpot to exercise functionality (mostly) in the JVMCI SVM library. For</span>
686      * example:
687      *
688      * &lt;pre&gt;
689      * package com.jcompile;
690      *
691      * import java.lang.reflect.Method;
692      *
693      * public static class JCompile {
694      *     static {
695      *         HotSpotJVMCIRuntime.runtime().registerNativeMethods(JCompile.class);
696      *     }
697      *     public static boolean compile(Method method, String[] options) {
698      *         // Convert to simpler data types for passing/serializing across native interface
699      *         long metaspaceMethodHandle = getHandle(method);
700      *         char[] opts = convertToCharArray(options);
701      *         return compile(metaspaceMethodHandle, opts);
702      *     }
703      *     private static native boolean compile0(long metaspaceMethodHandle, char[] options);
704      *
705      *     private static long getHandle(Method method) { ... }
706      *     private static char[] convertToCharArray(String[] a) { ... }
707      * }
708      * &lt;/pre&gt;
709      *
<a name="86" id="anc86"></a><span class="line-modified">710      * The implementation of the native {@code JCompile.compile0} method would be in the SVM library</span>
<span class="line-modified">711      * that contains the bulk of the JVMCI compiler. The {@code JCompile.compile0} implementation</span>
<span class="line-modified">712      * will be exported as the following JNI-compliant symbol:</span>
713      *
714      * &lt;pre&gt;
715      * Java_com_jcompile_JCompile_compile0
716      * &lt;/pre&gt;
717      *
<a name="87" id="anc87"></a><span class="line-modified">718      * How the JVMCI compiler SVM library is built is outside the scope of this document.</span>


719      *
<a name="88" id="anc88"></a><span class="line-removed">720      * @see &quot;https://docs.oracle.com/javase/10/docs/specs/jni/design.html#resolving-native-method-names&quot;</span>
721      *
<a name="89" id="anc89"></a>


722      * @throws NullPointerException if {@code clazz == null}
<a name="90" id="anc90"></a><span class="line-modified">723      * @throws IllegalArgumentException if the current execution context is SVM or if {@code clazz}</span>
<span class="line-modified">724      *             is {@link Class#isPrimitive()}</span>
<span class="line-modified">725      * @throws UnsatisfiedLinkError if the JVMCI SVM library is not available, a native method in</span>
<span class="line-modified">726      *             {@code clazz} is already linked or the SVM JVMCI library does not contain a</span>
<span class="line-modified">727      *             JNI-compliant symbol for a native method in {@code clazz}</span>






























728      */
<a name="91" id="anc91"></a><span class="line-modified">729     @SuppressWarnings({&quot;static-method&quot;, &quot;unused&quot;})</span>
<span class="line-modified">730     public void registerNativeMethods(Class&lt;?&gt; clazz) {</span>
<span class="line-modified">731         throw new UnsatisfiedLinkError(&quot;SVM library is not available&quot;);</span>



















































































732     }
733 }
<a name="92" id="anc92"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="92" type="hidden" />
</body>
</html>
diff a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.code/src/jdk/vm/ci/code/VirtualObject.java b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.code/src/jdk/vm/ci/code/VirtualObject.java
--- a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.code/src/jdk/vm/ci/code/VirtualObject.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.code/src/jdk/vm/ci/code/VirtualObject.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -20,15 +20,15 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.vm.ci.code;
 
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.IdentityHashMap;
 import java.util.Set;
 
+import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.meta.JavaKind;
 import jdk.vm.ci.meta.JavaValue;
 import jdk.vm.ci.meta.ResolvedJavaField;
 import jdk.vm.ci.meta.ResolvedJavaType;
 
@@ -41,10 +41,11 @@
 
     private final ResolvedJavaType type;
     private JavaValue[] values;
     private JavaKind[] slotKinds;
     private final int id;
+    private boolean isAutoBox;
 
     /**
      * Creates a new {@link VirtualObject} for the given type, with the given fields. If
      * {@code type} is an instance class then {@code values} provides the values for the fields
      * returned by {@link ResolvedJavaType#getInstanceFields(boolean) getInstanceFields(true)}. If
@@ -56,16 +57,37 @@
      * @param id a unique id that identifies the object within the debug information for one
      *            position in the compiled code.
      * @return a new {@link VirtualObject} instance.
      */
     public static VirtualObject get(ResolvedJavaType type, int id) {
-        return new VirtualObject(type, id);
+        return new VirtualObject(type, id, false);
     }
 
-    private VirtualObject(ResolvedJavaType type, int id) {
+    /**
+     * Creates a new {@link VirtualObject} for the given type, with the given fields. If
+     * {@code type} is an instance class then {@code values} provides the values for the fields
+     * returned by {@link ResolvedJavaType#getInstanceFields(boolean) getInstanceFields(true)}. If
+     * {@code type} is an array then the length of the values array determines the reallocated array
+     * length.
+     *
+     * @param type the type of the object whose allocation was removed during compilation. This can
+     *            be either an instance of an array type.
+     * @param id a unique id that identifies the object within the debug information for one
+     *            position in the compiled code.
+     * @param isAutoBox a flag that tells the runtime that the object may be a boxed primitive and
+     *            that it possibly needs to be obtained for the box cache instead of creating a new
+     *            instance.
+     * @return a new {@link VirtualObject} instance.
+     */
+    public static VirtualObject get(ResolvedJavaType type, int id, boolean isAutoBox) {
+        return new VirtualObject(type, id, isAutoBox);
+    }
+
+    private VirtualObject(ResolvedJavaType type, int id, boolean isAutoBox) {
         this.type = type;
         this.id = id;
+        this.isAutoBox = isAutoBox;
     }
 
     private static StringBuilder appendValue(StringBuilder buf, JavaValue value, Set<VirtualObject> visited) {
         if (value instanceof VirtualObject) {
             VirtualObject vo = (VirtualObject) value;
@@ -84,28 +106,95 @@
                             buf.append(i).append('=');
                             appendValue(buf, vo.values[i], visited);
                         }
                     } else {
                         ResolvedJavaField[] fields = vo.type.getInstanceFields(true);
-                        assert fields.length == vo.values.length : vo.type + ", fields=" + Arrays.toString(fields) + ", values=" + Arrays.toString(vo.values);
-                        for (int i = 0; i < vo.values.length; i++) {
+                        int fieldIndex = 0;
+                        for (int i = 0; i < vo.values.length; i++, fieldIndex++) {
                             if (i != 0) {
                                 buf.append(',');
                             }
-                            buf.append(fields[i].getName()).append('=');
+                            if (fieldIndex >= fields.length) {
+                                buf.append("<missing field>");
+                            } else {
+                                ResolvedJavaField field = fields[fieldIndex];
+                                buf.append(field.getName());
+                                if (vo.slotKinds[i].getSlotCount() == 2 && field.getType().getJavaKind().getSlotCount() == 1) {
+                                    if (fieldIndex + 1 >= fields.length) {
+                                        buf.append("/<missing field>");
+                                    } else {
+                                        ResolvedJavaField field2 = fields[++fieldIndex];
+                                        buf.append('/').append(field2.getName());
+                                    }
+                                }
+                            }
+                            buf.append('=');
                             appendValue(buf, vo.values[i], visited);
                         }
+                        // Extra fields
+                        for (; fieldIndex < fields.length; fieldIndex++) {
+                            buf.append(fields[fieldIndex].getName()).append("=<missing value>");
+                        }
                     }
                 }
                 buf.append('}');
             }
         } else {
             buf.append(value);
         }
         return buf;
     }
 
+    public interface LayoutVerifier {
+        int getOffset(ResolvedJavaField field);
+
+        default JavaKind getStorageKind(ResolvedJavaField field) {
+            return field.getType().getJavaKind();
+        }
+    }
+
+    public void verifyLayout(LayoutVerifier verifier) {
+        if (!type.isArray()) {
+            ResolvedJavaField[] fields = type.getInstanceFields(true);
+            int fieldIndex = 0;
+            for (int i = 0; i < values.length; i++, fieldIndex++) {
+                JavaKind slotKind = slotKinds[i];
+                if (fieldIndex >= fields.length) {
+                    throw new JVMCIError("Not enough fields for the values provided for %s", toString());
+                } else {
+                    ResolvedJavaField field = fields[fieldIndex];
+                    JavaKind fieldKind = verifier.getStorageKind(field);
+                    if (slotKind.getSlotCount() == 2 && fieldKind == JavaKind.Int) {
+                        int offset = verifier.getOffset(field);
+                        if (offset % 8 != 0) {
+                            throw new JVMCIError("Double word value stored across two ints must be aligned %s", toString());
+                        }
+
+                        if (fieldIndex + 1 >= fields.length) {
+                            throw new JVMCIError("Missing second field for double word value stored in two ints %s", toString());
+                        }
+                        ResolvedJavaField field2 = fields[fieldIndex + 1];
+                        if (field2.getType().getJavaKind() != JavaKind.Int) {
+                            throw new JVMCIError("Second field for double word value stored in two ints must be int but got %s in %s", field2.getType().getJavaKind(), toString());
+                        }
+                        int offset2 = verifier.getOffset(field2);
+                        if (offset + 4 != offset2) {
+                            throw new JVMCIError("Double word value stored across two ints must be sequential %s", toString());
+                        }
+                        fieldIndex++;
+                    } else if (fieldKind.getStackKind() != slotKind.getStackKind()) {
+                        throw new JVMCIError("Expected value of kind %s but got %s for field %s in %s", fieldKind, slotKind, field, toString());
+                    }
+                }
+            }
+            // Extra fields
+            if (fieldIndex < fields.length) {
+                throw new JVMCIError("Not enough values provided for fields in %s", this);
+            }
+        }
+    }
+
     @Override
     public String toString() {
         Set<VirtualObject> visited = Collections.newSetFromMap(new IdentityHashMap<VirtualObject, Boolean>());
         return appendValue(new StringBuilder(), this, visited).toString();
     }
@@ -141,10 +230,29 @@
      */
     public int getId() {
         return id;
     }
 
+    /**
+     * Returns true if the object is a box. For boxes the deoptimization would check if the value of
+     * the box is in the cache range and try to return a cached object.
+     */
+    public boolean isAutoBox() {
+        return isAutoBox;
+    }
+
+    /**
+     * Sets the value of the box flag.
+     *
+     * @param isAutoBox a flag that tells the runtime that the object may be a boxed primitive and
+     *            that it possibly needs to be obtained for the box cache instead of creating a new
+     *            instance.
+     */
+    public void setIsAutoBox(boolean isAutoBox) {
+        this.isAutoBox = isAutoBox;
+    }
+
     /**
      * Overwrites the current set of values with a new one.
      *
      * @param values an array containing all the values to be stored into the object when it is
      *            recreated.

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.services/src/jdk/vm/ci/services/Services.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JVMCIServiceLocator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../jdk.vm.ci.sparc/src/jdk/vm/ci/sparc/SPARC.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.services/src/jdk/vm/ci/services/Services.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 20,53 ***</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  package jdk.vm.ci.services;
  
  import java.util.Map;
  import java.util.Set;
  
  import jdk.internal.misc.VM;
  
  /**
   * Provides utilities needed by JVMCI clients.
   */
  public final class Services {
  
<span class="line-removed">-     // This class must be compilable and executable on JDK 8 since it&#39;s used in annotation</span>
<span class="line-removed">-     // processors while building JDK 9 so use of API added in JDK 9 is made via reflection.</span>
<span class="line-removed">- </span>
      /**
<span class="line-modified">!      * Guards code that should be run when building a native image but should be excluded from</span>
<span class="line-modified">!      * (being compiled into) the image. Such code must be directly guarded by an {@code if}</span>
       * statement on this field - the guard cannot be behind a method call.
       */
<span class="line-modified">!     public static final boolean IS_BUILDING_NATIVE_IMAGE;</span>
  
      /**
<span class="line-modified">!      * Guards code that should only be run in native image. Such code must be directly guarded by an</span>
<span class="line-modified">!      * {@code if} statement on this field - the guard cannot be behind a method call.</span>
       *
<span class="line-modified">!      * The value of this field seen during analysis and compilation of an SVM image must be</span>
<span class="line-removed">-      * {@code true}.</span>
       */
      public static final boolean IS_IN_NATIVE_IMAGE;
<span class="line-removed">- </span>
      static {
          /*
<span class="line-modified">!          * Prevents javac from constant folding use of this field. It is set to true in the SVM</span>
<span class="line-modified">!          * image via substitution during image building.</span>
           */
          IS_IN_NATIVE_IMAGE = false;
<span class="line-removed">-         IS_BUILDING_NATIVE_IMAGE = false;</span>
      }
  
      private Services() {
      }
  
<span class="line-modified">!     static final Map&lt;String, String&gt; SAVED_PROPERTIES = VM.getSavedProperties();</span>
<span class="line-modified">!     static final boolean JVMCI_ENABLED = Boolean.parseBoolean(SAVED_PROPERTIES.get(&quot;jdk.internal.vm.ci.enabled&quot;));</span>
  
      /**
       * Checks that JVMCI is enabled in the VM and throws an error if it isn&#39;t.
       */
      static void checkJVMCIEnabled() {
<span class="line-new-header">--- 20,62 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  package jdk.vm.ci.services;
  
<span class="line-added">+ import java.io.ByteArrayInputStream;</span>
<span class="line-added">+ import java.io.ByteArrayOutputStream;</span>
<span class="line-added">+ import java.io.DataInputStream;</span>
<span class="line-added">+ import java.io.DataOutputStream;</span>
<span class="line-added">+ import java.io.IOException;</span>
<span class="line-added">+ import java.util.ArrayList;</span>
<span class="line-added">+ import java.util.Collections;</span>
<span class="line-added">+ import java.util.Formatter;</span>
<span class="line-added">+ import java.util.HashMap;</span>
<span class="line-added">+ import java.util.List;</span>
  import java.util.Map;
<span class="line-added">+ import java.util.ServiceLoader;</span>
  import java.util.Set;
  
  import jdk.internal.misc.VM;
  
  /**
   * Provides utilities needed by JVMCI clients.
   */
  public final class Services {
  
      /**
<span class="line-modified">!      * Guards code that should be run when building an JVMCI shared library but should be excluded</span>
<span class="line-modified">!      * from (being compiled into) the library. Such code must be directly guarded by an {@code if}</span>
       * statement on this field - the guard cannot be behind a method call.
       */
<span class="line-modified">!     public static final boolean IS_BUILDING_NATIVE_IMAGE = Boolean.parseBoolean(VM.getSavedProperty(&quot;jdk.vm.ci.services.aot&quot;));</span>
  
      /**
<span class="line-modified">!      * Guards code that should only be run in a JVMCI shared library. Such code must be directly</span>
<span class="line-modified">!      * guarded by an {@code if} statement on this field - the guard cannot be behind a method call.</span>
       *
<span class="line-modified">!      * The value of this field in a JVMCI shared library runtime must be {@code true}.</span>
       */
      public static final boolean IS_IN_NATIVE_IMAGE;
      static {
          /*
<span class="line-modified">!          * Prevents javac from constant folding use of this field. It is set to true by the process</span>
<span class="line-modified">!          * that builds the shared library.</span>
           */
          IS_IN_NATIVE_IMAGE = false;
      }
  
      private Services() {
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * In a native image, this field is initialized by {@link #initializeSavedProperties(byte[])}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static volatile Map&lt;String, String&gt; savedProperties;</span>
<span class="line-added">+ </span>
<span class="line-added">+     static final boolean JVMCI_ENABLED = Boolean.parseBoolean(VM.getSavedProperties().get(&quot;jdk.internal.vm.ci.enabled&quot;));</span>
  
      /**
       * Checks that JVMCI is enabled in the VM and throws an error if it isn&#39;t.
       */
      static void checkJVMCIEnabled() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,15 ***</span>
      /**
       * Gets an unmodifiable copy of the system properties saved when {@link System} is initialized.
       */
      public static Map&lt;String, String&gt; getSavedProperties() {
          checkJVMCIEnabled();
<span class="line-modified">!         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-modified">!         if (sm != null) {</span>
<span class="line-modified">!             sm.checkPermission(new JVMCIPermission());</span>
          }
<span class="line-modified">!         return SAVED_PROPERTIES;</span>
      }
  
      /**
       * Causes the JVMCI subsystem to be initialized if it isn&#39;t already initialized.
       */
<span class="line-new-header">--- 87,42 ---</span>
      /**
       * Gets an unmodifiable copy of the system properties saved when {@link System} is initialized.
       */
      public static Map&lt;String, String&gt; getSavedProperties() {
          checkJVMCIEnabled();
<span class="line-modified">!         if (IS_IN_NATIVE_IMAGE) {</span>
<span class="line-modified">!             if (savedProperties == null) {</span>
<span class="line-modified">!                 throw new InternalError(&quot;Saved properties not initialized&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             if (savedProperties == null) {</span>
<span class="line-added">+                 synchronized (Services.class) {</span>
<span class="line-added">+                     if (savedProperties == null) {</span>
<span class="line-added">+                         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">+                         if (sm != null) {</span>
<span class="line-added">+                             sm.checkPermission(new JVMCIPermission());</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         savedProperties = VM.getSavedProperties();</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
          }
<span class="line-modified">!         return savedProperties;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Helper method equivalent to {@link #getSavedProperties()}{@code .getOrDefault(name, def)}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static String getSavedProperty(String name, String def) {</span>
<span class="line-added">+         return Services.getSavedProperties().getOrDefault(name, def);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Helper method equivalent to {@link #getSavedProperties()}{@code .get(name)}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static String getSavedProperty(String name) {</span>
<span class="line-added">+         return Services.getSavedProperties().get(name);</span>
      }
  
      /**
       * Causes the JVMCI subsystem to be initialized if it isn&#39;t already initialized.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 97,10 ***</span>
<span class="line-new-header">--- 133,38 ---</span>
          } catch (ClassNotFoundException e) {
              throw new InternalError(e);
          }
      }
  
<span class="line-added">+     private static final Map&lt;Class&lt;?&gt;, List&lt;?&gt;&gt; servicesCache = IS_BUILDING_NATIVE_IMAGE ? new HashMap&lt;&gt;() : null;</span>
<span class="line-added">+ </span>
<span class="line-added">+     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">+     private static &lt;S&gt; Iterable&lt;S&gt; load0(Class&lt;S&gt; service) {</span>
<span class="line-added">+         if (IS_IN_NATIVE_IMAGE || IS_BUILDING_NATIVE_IMAGE) {</span>
<span class="line-added">+             List&lt;?&gt; list = servicesCache.get(service);</span>
<span class="line-added">+             if (list != null) {</span>
<span class="line-added">+                 return (Iterable&lt;S&gt;) list;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (IS_IN_NATIVE_IMAGE) {</span>
<span class="line-added">+                 throw new InternalError(String.format(&quot;No %s providers found when building native image&quot;, service.getName()));</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         Iterable&lt;S&gt; providers = ServiceLoader.load(service, ClassLoader.getSystemClassLoader());</span>
<span class="line-added">+         if (IS_BUILDING_NATIVE_IMAGE) {</span>
<span class="line-added">+             synchronized (servicesCache) {</span>
<span class="line-added">+                 ArrayList&lt;S&gt; providersList = new ArrayList&lt;&gt;();</span>
<span class="line-added">+                 for (S provider : providers) {</span>
<span class="line-added">+                     providersList.add(provider);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 servicesCache.put(service, providersList);</span>
<span class="line-added">+                 providers = providersList;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return providers;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Opens all JVMCI packages to {@code otherModule}.
       */
      static void openJVMCITo(Module otherModule) {
          Module jvmci = Services.class.getModule();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,6 ***</span>
<span class="line-new-header">--- 176,162 ---</span>
                      jvmci.addOpens(pkg, otherModule);
                  }
              }
          }
      }
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Gets an {@link Iterable} of the JVMCI providers available for a given service.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws SecurityException if a security manager is present and it denies &lt;tt&gt;</span>
<span class="line-added">+      *             {@link RuntimePermission}(&quot;jvmci&quot;)&lt;/tt&gt;</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static &lt;S&gt; Iterable&lt;S&gt; load(Class&lt;S&gt; service) {</span>
<span class="line-added">+         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">+         if (sm != null) {</span>
<span class="line-added">+             sm.checkPermission(new JVMCIPermission());</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return load0(service);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Gets the JVMCI provider for a given service for which at most one provider must be available.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param service the service whose provider is being requested</span>
<span class="line-added">+      * @param required specifies if an {@link InternalError} should be thrown if no provider of</span>
<span class="line-added">+      *            {@code service} is available</span>
<span class="line-added">+      * @throws SecurityException if a security manager is present and it denies &lt;tt&gt;</span>
<span class="line-added">+      *             {@link RuntimePermission}(&quot;jvmci&quot;)&lt;/tt&gt;</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static &lt;S&gt; S loadSingle(Class&lt;S&gt; service, boolean required) {</span>
<span class="line-added">+         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">+         if (sm != null) {</span>
<span class="line-added">+             sm.checkPermission(new JVMCIPermission());</span>
<span class="line-added">+         }</span>
<span class="line-added">+         Iterable&lt;S&gt; providers = load0(service);</span>
<span class="line-added">+ </span>
<span class="line-added">+         S singleProvider = null;</span>
<span class="line-added">+         for (S provider : providers) {</span>
<span class="line-added">+             if (singleProvider != null) {</span>
<span class="line-added">+                 throw new InternalError(String.format(&quot;Multiple %s providers found: %s, %s&quot;, service.getName(), singleProvider.getClass().getName(), provider.getClass().getName()));</span>
<span class="line-added">+             }</span>
<span class="line-added">+             singleProvider = provider;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (singleProvider == null &amp;&amp; required) {</span>
<span class="line-added">+             String javaHome = Services.getSavedProperty(&quot;java.home&quot;);</span>
<span class="line-added">+             String vmName = Services.getSavedProperty(&quot;java.vm.name&quot;);</span>
<span class="line-added">+             Formatter errorMessage = new Formatter();</span>
<span class="line-added">+             errorMessage.format(&quot;The VM does not expose required service %s.%n&quot;, service.getName());</span>
<span class="line-added">+             errorMessage.format(&quot;Currently used Java home directory is %s.%n&quot;, javaHome);</span>
<span class="line-added">+             errorMessage.format(&quot;Currently used VM configuration is: %s&quot;, vmName);</span>
<span class="line-added">+             throw new UnsupportedOperationException(errorMessage.toString());</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return singleProvider;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * A Java {@code char} has a maximal UTF8 length of 3.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static final int MAX_UNICODE_IN_UTF8_LENGTH = 3;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * {@link DataOutputStream#writeUTF(String)} only supports values whose UTF8 encoding length is</span>
<span class="line-added">+      * less than 65535.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static final int MAX_UTF8_PROPERTY_STRING_LENGTH = 65535 / MAX_UNICODE_IN_UTF8_LENGTH;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Serializes the {@linkplain #getSavedProperties() saved system properties} to a byte array for</span>
<span class="line-added">+      * the purpose of {@linkplain #initializeSavedProperties(byte[]) initializing} the initial</span>
<span class="line-added">+      * properties in the JVMCI shared library.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @VMEntryPoint</span>
<span class="line-added">+     private static byte[] serializeSavedProperties() throws IOException {</span>
<span class="line-added">+         if (IS_IN_NATIVE_IMAGE) {</span>
<span class="line-added">+             throw new InternalError(&quot;Can only serialize saved properties in HotSpot runtime&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return serializeProperties(Services.getSavedProperties());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static byte[] serializeProperties(Map&lt;String, String&gt; props) throws IOException {</span>
<span class="line-added">+         // Compute size of output on the assumption that</span>
<span class="line-added">+         // all system properties have ASCII names and values</span>
<span class="line-added">+         int estimate = 4 + 4;</span>
<span class="line-added">+         int nonUtf8Props = 0;</span>
<span class="line-added">+         for (Map.Entry&lt;String, String&gt; e : props.entrySet()) {</span>
<span class="line-added">+             String name = e.getKey();</span>
<span class="line-added">+             String value = e.getValue();</span>
<span class="line-added">+             estimate += (2 + (name.length())) + (2 + (value.length()));</span>
<span class="line-added">+             if (name.length() &gt; MAX_UTF8_PROPERTY_STRING_LENGTH || value.length() &gt; MAX_UTF8_PROPERTY_STRING_LENGTH) {</span>
<span class="line-added">+                 nonUtf8Props++;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         ByteArrayOutputStream baos = new ByteArrayOutputStream(estimate);</span>
<span class="line-added">+         DataOutputStream out = new DataOutputStream(baos);</span>
<span class="line-added">+         out.writeInt(props.size() - nonUtf8Props);</span>
<span class="line-added">+         out.writeInt(nonUtf8Props);</span>
<span class="line-added">+         for (Map.Entry&lt;String, String&gt; e : props.entrySet()) {</span>
<span class="line-added">+             String name = e.getKey();</span>
<span class="line-added">+             String value = e.getValue();</span>
<span class="line-added">+             if (name.length() &lt;= MAX_UTF8_PROPERTY_STRING_LENGTH &amp;&amp; value.length() &lt;= MAX_UTF8_PROPERTY_STRING_LENGTH) {</span>
<span class="line-added">+                 out.writeUTF(name);</span>
<span class="line-added">+                 out.writeUTF(value);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (nonUtf8Props != 0) {</span>
<span class="line-added">+             for (Map.Entry&lt;String, String&gt; e : props.entrySet()) {</span>
<span class="line-added">+                 String name = e.getKey();</span>
<span class="line-added">+                 String value = e.getValue();</span>
<span class="line-added">+                 if (name.length() &gt; MAX_UTF8_PROPERTY_STRING_LENGTH || value.length() &gt; MAX_UTF8_PROPERTY_STRING_LENGTH) {</span>
<span class="line-added">+                     byte[] utf8Name = name.getBytes(&quot;UTF-8&quot;);</span>
<span class="line-added">+                     byte[] utf8Value = value.getBytes(&quot;UTF-8&quot;);</span>
<span class="line-added">+                     out.writeInt(utf8Name.length);</span>
<span class="line-added">+                     out.write(utf8Name);</span>
<span class="line-added">+                     out.writeInt(utf8Value.length);</span>
<span class="line-added">+                     out.write(utf8Value);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return baos.toByteArray();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Initialized the {@linkplain #getSavedProperties() saved system properties} in the JVMCI</span>
<span class="line-added">+      * shared library from the {@linkplain #serializeSavedProperties() serialized saved properties}</span>
<span class="line-added">+      * in the HotSpot runtime.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @VMEntryPoint</span>
<span class="line-added">+     private static void initializeSavedProperties(byte[] serializedProperties) throws IOException {</span>
<span class="line-added">+         if (!IS_IN_NATIVE_IMAGE) {</span>
<span class="line-added">+             throw new InternalError(&quot;Can only initialize saved properties in JVMCI shared library runtime&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         savedProperties = Collections.unmodifiableMap(deserializeProperties(serializedProperties));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static Map&lt;String, String&gt; deserializeProperties(byte[] serializedProperties) throws IOException {</span>
<span class="line-added">+         DataInputStream in = new DataInputStream(new ByteArrayInputStream(serializedProperties));</span>
<span class="line-added">+         int utf8Props = in.readInt();</span>
<span class="line-added">+         int nonUtf8Props = in.readInt();</span>
<span class="line-added">+         Map&lt;String, String&gt; props = new HashMap&lt;&gt;(utf8Props + nonUtf8Props);</span>
<span class="line-added">+         int index = 0;</span>
<span class="line-added">+         while (in.available() != 0) {</span>
<span class="line-added">+             if (index &lt; utf8Props) {</span>
<span class="line-added">+                 String name = in.readUTF();</span>
<span class="line-added">+                 String value = in.readUTF();</span>
<span class="line-added">+                 props.put(name, value);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 int nameLen = in.readInt();</span>
<span class="line-added">+                 byte[] nameBytes = new byte[nameLen];</span>
<span class="line-added">+                 in.read(nameBytes);</span>
<span class="line-added">+                 int valueLen = in.readInt();</span>
<span class="line-added">+                 byte[] valueBytes = new byte[valueLen];</span>
<span class="line-added">+                 in.read(valueBytes);</span>
<span class="line-added">+                 String name = new String(nameBytes, &quot;UTF-8&quot;);</span>
<span class="line-added">+                 String value = new String(valueBytes, &quot;UTF-8&quot;);</span>
<span class="line-added">+                 props.put(name, value);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             index++;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return props;</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="JVMCIServiceLocator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../jdk.vm.ci.sparc/src/jdk/vm/ci/sparc/SPARC.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>